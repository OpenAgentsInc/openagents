---
id: d-007
title: Native Rust FROSTR Implementation (Threshold Signatures)
status: active
priority: high
created: 2025-12-21
updated: 2025-12-21
---

## Goal

Create `crates/frostr/` - a native Rust implementation of the FROSTR protocol for threshold Schnorr signatures. This enables k-of-n signing where the private key is never reconstructed, providing the cryptographic foundation for NIP-SA Sovereign Agents.

## Background

FROSTR (FROST for Nostr) is a threshold signature protocol that enables:
- **k-of-n signing**: Any k shares can sign, but no single party has the full key
- **Invisible multi-sig**: Signatures look identical to single-key signatures
- **Key rotation**: Compromised shares can be replaced without changing identity
- **Distributed coordination**: Peers communicate via encrypted Nostr events

Reference implementation: `~/code/igloo-server` (TypeScript)
Protocol: https://github.com/FROSTR-ORG

### Why Native Rust?
- OpenAgents codebase is Rust
- No runtime dependency on TypeScript/Node.js
- Better integration with existing crates
- Performance benefits for cryptographic operations
- Can be compiled to WASM for web wallet

## Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         crates/frostr/                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐         │
│  │    Keygen       │    │    Signing      │    │     ECDH        │         │
│  │  (Shamir SSS)   │    │    (FROST)      │    │  (threshold)    │         │
│  └────────┬────────┘    └────────┬────────┘    └────────┬────────┘         │
│           │                      │                      │                   │
│           └──────────────────────┼──────────────────────┘                   │
│                                  │                                          │
│                    ┌─────────────▼─────────────┐                           │
│                    │      Bifrost Node         │                           │
│                    │                           │                           │
│                    │  • Peer coordination      │                           │
│                    │  • Nostr transport        │                           │
│                    │  • Request routing        │                           │
│                    │  • Share aggregation      │                           │
│                    └─────────────┬─────────────┘                           │
│                                  │                                          │
│                    ┌─────────────▼─────────────┐                           │
│                    │      Nostr Relays         │                           │
│                    └───────────────────────────┘                           │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Credential Format

```
GROUP_CRED: "bfgroup1..." - Threshold group public key + config
  └─ threshold: k (e.g., 2)
  └─ total: n (e.g., 3)
  └─ group_pk: 32-byte public key

SHARE_CRED: "bfshare1..." - Individual secret share
  └─ index: share number (1..n)
  └─ secret_share: 32-byte scalar
  └─ group_pk: must match GROUP_CRED
```

## Success Criteria

### Phase 1: Core Cryptography
- [x] Create `crates/frostr/` workspace crate
- [x] Implement Shamir Secret Sharing for key splitting
- [x] Implement FROST key generation (dealer mode)
- [x] Implement FROST signing round protocol
- [ ] Implement threshold ECDH for decryption (blocked by #500)
- [x] Credential encoding/decoding (bech32: bfgroup1, bfshare1)

### Phase 2: Bifrost Protocol
- [x] Define Bifrost message types (`/sign/req`, `/sign/res`, `/sign/ret`, `/sign/err`)
- [x] Define ECDH message types (`/ecdh/req`, `/ecdh/res`, `/ecdh/ret`)
- [x] Implement peer discovery and connection
- [x] Implement message routing via Nostr relays
- [x] Implement request timeout and retry logic
- [ ] Implement share aggregation for threshold operations (blocked by #501)

### Phase 3: Node Implementation
- [x] Create `BifrostNode` struct with lifecycle management
- [ ] Implement `node.sign(event_hash)` → threshold signature (blocked by #501)
- [ ] Implement `node.ecdh(peer_pubkey)` → shared secret (blocked by #500)
- [x] Implement `node.ping(peer)` → connectivity check
- [x] Add health monitoring and peer status tracking
- [x] Implement graceful shutdown and reconnection

### Phase 4: Wallet Integration
- [ ] Create `ThresholdIdentity` extending `UnifiedIdentity`
- [ ] Add `cargo wallet frostr keygen` command (generate group + shares)
- [ ] Add `cargo wallet frostr sign` command (sign event)
- [ ] Add share import/export functionality
- [ ] Integrate with secure keychain storage
- [ ] Add `--threshold` flag to wallet commands

### Phase 5: NIP-SA Integration
- [ ] Expose signing interface for NIP-SA agent events
- [ ] Expose ECDH interface for NIP-44 state decryption
- [ ] Support marketplace signer as threshold peer
- [ ] Support guardian signer for recovery
- [ ] Add policy enforcement hooks (pre-sign checks)

## Key Files to Create

| File | Purpose |
|------|---------|
| `crates/frostr/Cargo.toml` | **NEW** - Workspace crate manifest |
| `crates/frostr/src/lib.rs` | **NEW** - Public API exports |
| `crates/frostr/src/keygen.rs` | **NEW** - Shamir SSS + FROST keygen |
| `crates/frostr/src/signing.rs` | **NEW** - FROST signing protocol |
| `crates/frostr/src/ecdh.rs` | **NEW** - Threshold ECDH |
| `crates/frostr/src/credential.rs` | **NEW** - bech32 encoding (bfgroup1, bfshare1) |
| `crates/frostr/src/bifrost/mod.rs` | **NEW** - Bifrost protocol types |
| `crates/frostr/src/bifrost/node.rs` | **NEW** - BifrostNode implementation |
| `crates/frostr/src/bifrost/transport.rs` | **NEW** - Nostr relay transport |
| `crates/frostr/src/bifrost/messages.rs` | **NEW** - Protocol message types |
| `crates/wallet/src/cli/frostr.rs` | **NEW** - CLI commands for threshold ops |
| `Cargo.toml` | Add frostr to workspace members |

## Dependencies

### External Crates
```toml
[dependencies]
# Cryptography
frost-secp256k1 = "2.0"      # FROST implementation
secp256k1 = "0.29"           # Schnorr signatures
sha2 = "0.10"                # Hashing
rand = "0.8"                 # Randomness

# Encoding
bech32 = "0.11"              # Credential encoding

# Nostr (internal)
nostr-core = { path = "../nostr/core" }
nostr-client = { path = "../nostr/client" }

# Async
tokio = { version = "1", features = ["full"] }

# Serialization
serde = { version = "1", features = ["derive"] }
serde_json = "1"
```

### Reference Implementation
- `~/code/igloo-server` - TypeScript implementation to study
- `@frostr/bifrost` - Protocol messages and flow
- `@frostr/igloo-core` - Key management patterns

## Protocol Reference

### Signing Round Flow

```
1. Initiator broadcasts /sign/req to threshold peers
   {
     event_hash: [32 bytes],
     nonce_commitment: [33 bytes]
   }

2. Peers respond with /sign/res
   {
     partial_sig: [32 bytes],
     nonce_share: [33 bytes]
   }

3. Initiator aggregates and broadcasts /sign/ret
   {
     final_sig: [64 bytes]  // Schnorr signature
   }

4. On failure: /sign/err with reason
```

### ECDH Round Flow

```
1. Initiator broadcasts /ecdh/req
   {
     target_pubkey: [32 bytes x-only]
   }

2. Peers respond with /ecdh/res
   {
     partial_ecdh: [32 bytes]
   }

3. Initiator aggregates to shared secret
   {
     shared_secret: [32 bytes]  // For NIP-44 encryption
   }
```

## Testing Strategy

1. **Unit tests** - Keygen, signing math, aggregation
2. **Protocol tests** - Message serialization, routing
3. **Integration tests** - Multi-peer signing with mock relays
4. **Compatibility tests** - Verify signatures match TypeScript implementation
5. **Interop tests** - Rust peer can sign with igloo-server peers

## Configuration

```toml
# ~/.openagents/frostr.toml

[node]
# Threshold configuration
threshold = 2
total_shares = 3

# Relay pool for peer coordination
relays = [
    "wss://relay.damus.io",
    "wss://nos.lol"
]

# Timeout for signing rounds
sign_timeout_ms = 30000
ecdh_timeout_ms = 10000

[peers]
# Known peer pubkeys for threshold operations
marketplace = "npub1marketplace..."
guardian = "npub1guardian..."

[storage]
# Where to store share credentials
share_path = "~/.openagents/frostr/share.enc"
```

## Security Considerations

### Key Protection
- Secret shares MUST be stored encrypted (AES-256)
- Shares SHOULD be in secure enclave where available
- Private key NEVER reconstructed in memory
- Threshold ensures no single point of compromise

### Peer Verification
- All Bifrost messages signed by sender
- Peer pubkeys verified against known list
- Rate limiting on signing requests
- Anomaly detection for unusual patterns

### Protocol Safety
- Nonce commitments prevent signature malleability
- Timeout prevents indefinite blocking
- Error handling for partial responses
- Audit logging of all signing operations

## Notes

This directive provides the cryptographic foundation for d-006 (NIP-SA Sovereign Agents). The threshold signing capability enables:

1. **Agent identity protection** - Operator cannot extract agent private key
2. **Marketplace enforcement** - Signer can check licenses before participating
3. **Recovery** - Guardian share enables key recovery without full reconstruction

The implementation follows the FROSTR specification while being native Rust for optimal integration with OpenAgents.

## Related Directives

- **d-006** (NIP-SA) - Uses FROSTR for agent identity protection
- **d-003** (Wallet) - Extended with threshold identity support

## Related Documents

- `~/code/igloo-server` - TypeScript reference implementation
- https://github.com/FROSTR-ORG - Protocol organization
- FROST paper: https://eprint.iacr.org/2020/852
