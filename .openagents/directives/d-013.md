---
id: d-013
title: Comprehensive Testing Framework
status: active
priority: high
created: 2025-12-21
updated: 2025-12-25T14:20:56Z
---

## Directive

**All code must be thoroughly tested. This directive establishes the testing framework, conventions, and requirements for OpenAgents.**

Testing is not optional. Every feature, component, and integration point must have corresponding tests. We use a multi-layered testing strategy covering unit, component, integration, protocol, and end-to-end flows.

## Testing Architecture

### Test Categories

| Category | Description | Location | Runner |
|----------|-------------|----------|--------|
| Unit | Module/function level | `crates/<crate>/src/tests/` | `cargo test --lib` |
| Component | WGPUI components + scene assertions | `crates/wgpui/src/**` | `cargo test -p wgpui` |
| Integration | Backend channels, API routes, DB | `crates/<crate>/tests/` | `cargo test --test '*'` |
| Protocol | Nostr NIP-90, relay comms | `crates/nostr/tests/integration/` | `cargo test -p nostr-core` |
| E2E Flows | Full user journeys | `tests/e2e/` | `cargo test --test e2e` |

### Directory Structure

```
openagents/
  crates/
    <crate>/
      src/
        tests/           # Unit tests co-located
          mod.rs
      tests/             # Integration tests
        integration.rs
        <feature>.rs
    testing/             # Shared test utilities
      src/
        lib.rs
        fixtures.rs      # TestApp, DB helpers
        mocks.rs         # Mock services
        factories.rs     # Fake data generators
  tests/
    e2e/                 # Workspace E2E tests
      mod.rs
      flows/             # User flow tests
      smoke.rs           # Critical path smoke tests
```

## Required Dependencies

Add to workspace `Cargo.toml`:

```toml
[workspace.dependencies]
# Testing
quickcheck = "1.0"           # Property-based testing
fake = { version = "2.9", features = ["derive"] }  # Fake data
wiremock = "0.6"             # HTTP mocking
test-case = "3.3"            # Parameterized tests
insta = "1.34"               # Snapshot testing (WGPUI scenes)
tokio-tungstenite = "0.21"   # WebSocket testing (relay + GitAfter)
scraper = "0.18"             # HTML parsing (GitAfter only)
```

## Testing Patterns

### 1. Unit Tests

Every public function must have unit tests. Use property-based testing for validators.

```rust
// Property-based testing for validators
use quickcheck::quickcheck;

quickcheck! {
    fn prop_npub_roundtrip(bytes: [u8; 32]) -> bool {
        let npub = encode_npub(&bytes);
        decode_npub(&npub).map(|b| b == bytes).unwrap_or(false)
    }
}

// Standard unit test
#[test]
fn test_issue_state_transition() {
    let issue = Issue::new("Test task");
    assert_eq!(issue.status, IssueStatus::Pending);

    let claimed = issue.claim("agent-1").unwrap();
    assert_eq!(claimed.status, IssueStatus::Claimed);
}
```

### 2. Component Tests (WGPUI)

All WGPUI components must test:
- State/variant correctness
- Layout/measurement behavior
- Accessibility metadata where applicable
- All variants and states

```rust
use wgpui::components::{Button, ButtonVariant};

#[test]
fn test_button_variants() {
    let primary = Button::new("Primary").variant(ButtonVariant::Primary);
    let ghost = Button::new("Ghost").variant(ButtonVariant::Ghost);

    assert_eq!(primary.variant, ButtonVariant::Primary);
    assert_eq!(ghost.variant, ButtonVariant::Ghost);
}
```

### 3. Snapshot Testing

Use `insta` for HTML snapshot testing to catch visual regressions:

```rust
use insta::assert_snapshot;

#[test]
fn test_dashboard_snapshot() {
    let dashboard = Dashboard::new()
        .with_identity(&test_identity())
        .with_balance(50000)
        .render();

    assert_snapshot!(dashboard.into_string());
}
```

Run `cargo insta review` to approve changes. Snapshots go in `snapshots/` directories.

### 4. Integration Tests with TestApp

Use the TestApp pattern for isolated integration tests:

```rust
use openagents_testing::TestApp;

#[tokio::test]
async fn test_dashboard_shows_identity() {
    let app = TestApp::new().await;

    let response = app.get("/").await;
    assert_eq!(response.status(), 200);

    let body = response.text().await.unwrap();
    assert!(body.contains("npub"));
}

#[tokio::test]
async fn test_issue_create_flow() {
    let app = TestApp::new().await;

    // Create issue via API
    let response = app.post("/api/issues")
        .json(&json!({"title": "Test issue"}))
        .send()
        .await;

    assert_eq!(response.status(), 201);

    // Verify in database
    let issues = app.db().get_all_issues().unwrap();
    assert_eq!(issues.len(), 1);
}
```

### 5. WebSocket Testing

Test WebSocket handlers with `tokio-tungstenite`:

```rust
use tokio_tungstenite::connect_async;

#[tokio::test]
async fn test_ws_connection() {
    let app = TestApp::new().await;
    let ws_url = format!("ws://127.0.0.1:{}/ws", app.port);

    let (ws, _) = connect_async(&ws_url).await.expect("connect failed");
    let (mut write, mut read) = ws.split();

    // Send message
    write.send(Message::Text("ping".into())).await.unwrap();

    // Verify response
    let msg = timeout(Duration::from_secs(2), read.next())
        .await.unwrap().unwrap().unwrap();

    assert!(matches!(msg, Message::Text(_)));
}
```

### 6. Nostr Protocol Testing

Test NIP-90 job flows with mock relays:

```rust
#[tokio::test]
async fn test_nip90_job_workflow() {
    let relay = MockRelay::start().await;

    // Create and publish job request
    let request = JobRequest::new(KIND_JOB_TEXT_GENERATION)
        .add_input(JobInput::text("Test prompt"))
        .sign(&test_keypair());

    relay.publish(&request).await.unwrap();

    // Verify event received
    let events = relay.get_events_by_kind(KIND_JOB_TEXT_GENERATION).await;
    assert_eq!(events.len(), 1);

    // Simulate provider response
    let result = JobResult::new(&request.id, "Response text")
        .sign(&provider_keypair());

    relay.publish(&result).await.unwrap();

    // Verify result linked to request
    let results = relay.get_results_for_job(&request.id).await;
    assert_eq!(results.len(), 1);
}
```

### 7. Mock Services

Use trait-based mocking for external dependencies:

```rust
#[async_trait]
pub trait WalletService: Send + Sync {
    async fn get_balance(&self) -> Result<u64>;
    async fn send_payment(&self, address: &str, amount: u64) -> Result<TxId>;
}

pub struct MockWalletService {
    pub balance: u64,
    pub send_result: Result<TxId>,
}

#[async_trait]
impl WalletService for MockWalletService {
    async fn get_balance(&self) -> Result<u64> {
        Ok(self.balance)
    }

    async fn send_payment(&self, _: &str, _: u64) -> Result<TxId> {
        self.send_result.clone()
    }
}
```

## User Story Coverage

### P0 - Must Test (Critical Path)

| Story | Test File | Assertions |
|-------|-----------|------------|
| Autopilot runs task | `crates/autopilot/tests/autonomous_loop.rs` | Task starts, trajectory captured, completes |
| Marketplace browsing | `crates/marketplace/tests/discovery.rs` | Skills listed, filters work, details shown |
| Issue lifecycle | `crates/issues/tests/integration.rs` | Create -> Claim -> Complete transitions |
| Nostr event broadcast | `crates/nostr/tests/integration/publish.rs` | Event signed, sent to relay, confirmed |

### P1 - Should Test (Important)

| Story | Test File | Assertions |
|-------|-----------|------------|
| Wallet init | `crates/wallet/tests/init.rs` | Mnemonic generates keys, identity saved |
| Identity display | `crates/wallet/tests/wallet_gui_integration.rs` | npub shown on dashboard |
| Relay subscription | `crates/nostr/tests/integration/subscribe.rs` | Filter applied, events received |
| Trajectory export | `crates/autopilot/tests/trajectory.rs` | NIP-SA format, all steps included |

### P2 - Could Test (Nice to Have)

| Story | Test File | Assertions |
|-------|-----------|------------|
| Payment flows | `tests/e2e/flows/payment.rs` | Send/receive complete |
| Storybook | `crates/ui/tests/storybook.rs` | All components render |
| Multi-relay | `crates/nostr/tests/integration/stress.rs` | Broadcast succeeds |

## Testability Requirements

### 1. Extract Handlers from Routes

Rendering logic must be in pure functions, not embedded in route handlers:

```rust
// BAD: Logic in route
async fn index(state: Data<AppState>) -> HttpResponse {
    let balance = state.wallet.sync().await?;
    let html = html! {
        div { (balance) }
    };
    HttpResponse::Ok().body(html.into_string())
}

// GOOD: Extracted handler
pub fn render_dashboard(balance: u64) -> Markup {
    html! {
        div { (balance) }
    }
}

async fn index(state: Data<AppState>) -> HttpResponse {
    let balance = state.wallet.sync().await?;
    let html = render_dashboard(balance);
    HttpResponse::Ok().body(html.into_string())
}
```

### 2. Trait-Based Dependencies

All external services must be behind traits:

```rust
// Service trait
#[async_trait]
pub trait RelayPool: Send + Sync {
    async fn publish(&self, event: &Event) -> Result<Vec<Confirmation>>;
    async fn subscribe(&self, filters: &[Filter]) -> Result<Subscription>;
}

// AppState uses trait object
pub struct AppState {
    pub relay_pool: Arc<dyn RelayPool>,
    pub wallet: Arc<dyn WalletService>,
}
```

### 3. In-Memory Database Support

All database modules must support in-memory mode:

```rust
pub fn init_db(path: Option<&Path>) -> Result<Connection> {
    let conn = match path {
        Some(p) => Connection::open(p)?,
        None => Connection::open_in_memory()?,
    };
    init_schema(&conn)?;
    Ok(conn)
}
```

## CI/CD Integration

### GitHub Actions Workflow

```yaml
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [main]
  pull_request:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-action@stable

      - name: Run Unit Tests
        run: cargo test --workspace --lib

      - name: Run Integration Tests
        run: cargo test --workspace --test '*' -- --test-threads=1

      - name: Generate Coverage
        run: |
          cargo install cargo-llvm-cov
          cargo llvm-cov --workspace --lcov --output-path lcov.info

      - name: Check Coverage Threshold
        run: |
          COV=$(cargo llvm-cov --workspace --json | jq '.data[0].totals.lines.percent')
          if (( $(echo "$COV < 70" | bc -l) )); then
            echo "Coverage $COV% below 70% threshold"
            exit 1
          fi

  snapshots:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Check Snapshots
        run: cargo insta test --review=fail
```

### Pre-commit Hooks

Add to `.githooks/pre-commit`:

```bash
#!/bin/bash

# Run fast unit tests
cargo test --workspace --lib -- --test-threads=4 || exit 1

# Check for snapshot changes
if cargo insta test --review=fail 2>&1 | grep -q "pending"; then
    echo "ERROR: Uncommitted snapshot changes. Run 'cargo insta review'"
    exit 1
fi
```

## Coverage Requirements

| Category | Minimum | Enforcement |
|----------|---------|-------------|
| Unit tests (--lib) | 70% | CI gate |
| Public API | 100% | PR review |
| P0 user stories | 100% | Release gate |
| P1 user stories | 80% | Release gate |

### Coverage Exclusions

```toml
# .cargo/llvm-cov.toml
[llvm-cov]
exclude = [
    "crates/storybook/*",     # Visual explorer
    "*/examples/*",           # Example code
    "*/benches/*",            # Benchmarks
    "src/main.rs",            # CLI entrypoint
]
```

## Running Tests

```bash
# All tests
cargo test --workspace

# Unit tests only (fast)
cargo test --workspace --lib

# Integration tests (slower, sequential)
cargo test --workspace --test '*' -- --test-threads=1

# Specific crate
cargo test -p autopilot

# With coverage
cargo llvm-cov --workspace

# Update snapshots
cargo insta test
cargo insta review

# Property tests with more iterations
QUICKCHECK_TESTS=10000 cargo test --lib
```

## Enforcement

### PR Checklist

- [ ] All new code has corresponding tests
- [ ] Tests pass locally: `cargo test --workspace`
- [ ] No snapshot changes without review: `cargo insta test`
- [ ] Coverage not decreased
- [ ] P0 flows remain covered
- [ ] Accessibility tests pass for new UI components

### Test Naming Convention

```rust
// Unit tests: test_<function>_<scenario>
#[test]
fn test_validate_npub_rejects_invalid_prefix() { }

// Integration: test_<feature>_<flow>
#[tokio::test]
async fn test_issue_claim_succeeds_for_pending() { }

// Property: prop_<invariant>
quickcheck! {
    fn prop_encode_decode_roundtrip(input: String) -> bool { }
}
```

## Related

- d-012 (No Stubs) - Tests must verify real implementations
- crates/testing/ - Shared test utilities (to be created)
- .github/workflows/test.yml - CI configuration (to be created)
