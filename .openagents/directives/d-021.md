---
id: d-021
title: "OpenCode SDK Integration"
status: active
priority: high
created: 2025-12-24
updated: 2025-12-25T14:24:33Z
---

# d-021: OpenCode SDK Integration

## Goal

Create a native Rust SDK for communicating with OpenCode servers, enabling provider-agnostic AI agent execution through OpenCode's REST API + SSE architecture. This positions OpenCode as our unified backend for multi-model agent execution.

## Background

OpenCode is an open-source AI coding agent with a clean client/server architecture. Unlike our existing `codex-agent-sdk` (which spawns Codex CLI) and `codex-agent-sdk` (which spawns Codex CLI), OpenCode provides:

- **Provider-agnostic**: Works with Codex, OpenAI, Google, or local models
- **REST + SSE architecture**: Clean HTTP API with real-time event streaming
- **Session management**: Built-in conversation persistence and compaction
- **Plugin ecosystem**: Extensible via TypeScript plugins (like oh-my-opencode)
- **OpenAPI specification**: Machine-readable API definition for client generation

### Why OpenCode?

| Concern | Current State | With OpenCode |
|---------|---------------|---------------|
| Multi-model | Separate SDKs per provider | Single SDK, provider config |
| Protocol | Different per agent (JSONL, JSON events) | Unified REST + SSE |
| Session state | We manage in Rust | OpenCode manages, we consume |
| Tool execution | We implement | OpenCode executes, we observe |
| Compaction | Not available | Built-in context management |

### Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                         OpenAgents App                               │
│                                                                      │
│  ┌────────────────────────────────────────────────────────────────┐ │
│  │                     crates/opencode-sdk/                        │ │
│  │  ┌──────────────────┐  ┌──────────────────┐                    │ │
│  │  │ OpencodeClient   │  │ OpencodeServer   │                    │ │
│  │  │ • session.*      │  │ • spawn()        │                    │ │
│  │  │ • provider.*     │  │ • health()       │                    │ │
│  │  │ • file.*         │  │ • close()        │                    │ │
│  │  │ • config.*       │  │                  │                    │ │
│  │  └────────┬─────────┘  └────────┬─────────┘                    │ │
│  │           │ HTTP/REST           │ Subprocess                   │ │
│  │           │                     │                              │ │
│  │  ┌────────┴─────────────────────┴──────────┐                   │ │
│  │  │           EventStream (SSE)              │                   │ │
│  │  │  impl Stream<Item = Event>               │                   │ │
│  │  └─────────────────────────────────────────┘                   │ │
│  └────────────────────────────────────────────────────────────────┘ │
│                                │                                     │
└────────────────────────────────┼─────────────────────────────────────┘
                                 │
                     ┌───────────┴───────────┐
                     │   opencode serve     │
                     │   (port 4096)        │
                     │                       │
                     │  ┌─────────────────┐  │
                     │  │ OpenCode Core   │  │
                     │  │ • Sessions      │  │
                     │  │ • Tools         │  │
                     │  │ • Permissions   │  │
                     │  └────────┬────────┘  │
                     │           │           │
                     │  ┌────────┴────────┐  │
                     │  │ Providers       │  │
                     │  │ • OpenAI     │  │
                     │  │ • OpenAI        │  │
                     │  │ • Google        │  │
                     │  │ • Local         │  │
                     │  └─────────────────┘  │
                     └───────────────────────┘
```

### Key Decisions

1. **Generate from OpenAPI** — Use `~/code/opencode/packages/sdk/openapi.json` to generate type-safe Rust client. Prefer `progenitor` or similar OpenAPI-to-Rust generator.

2. **Server spawning** — Follow `createOpencodeServer` pattern: spawn `opencode serve`, wait for health check, return connection.

3. **Event streaming** — Implement SSE client that yields `Stream<Item = Event>`. Map OpenCode event types to our existing patterns.

4. **ACP integration** — Add OpenCode backend to `acp-adapter`, enabling unified protocol layer across all agent types.

5. **Plugin passthrough** — OpenCode can run with oh-my-opencode plugin installed; our SDK just communicates with whatever OpenCode exposes.

## Success Criteria

### Phase 1: Core Client (v0.1)
- [x] Create `crates/opencode-sdk/` crate structure
- [x] Generate client types from `openapi.json`
- [x] Implement `OpencodeClient` with session operations
- [x] Implement `EventStream` for SSE consumption
- [x] Add health check and connection management

### Phase 2: Server Management (v0.2)
- [x] Implement `OpencodeServer` for spawning/managing server process
- [x] Add `create_opencode()` combined client+server helper
- [x] Port timeout, startup wait, and cleanup logic from TS
- [x] Handle graceful shutdown and process cleanup

### Phase 3: Full API Coverage (v0.3)
- [x] Implement all session operations (create, prompt, abort, fork, share)
- [x] Implement provider operations (list, auth, OAuth flow)
- [x] Implement file operations (list, read, status)
- [x] Implement search operations (text, files, symbols)
- [x] Implement config, MCP, and command endpoints

### Phase 4: ACP Integration (v0.4)
- [x] Add `agents/opencode.rs` to `acp-adapter`
- [x] Implement `AcpAgentConnection` for OpenCode
- [x] Add converters: OpenCode events → ACP notifications
- [ ] Enable in WGPUI agent selector (autopilot-gui)

### Phase 5: Testing & Documentation (v0.5)
- [x] Unit tests with mock HTTP responses
- [ ] Integration tests with real OpenCode server
- [x] API documentation with examples
- [x] Usage guide for switching between providers

## Key Files to Create/Modify

| File | Purpose |
|------|---------|
| `crates/opencode-sdk/Cargo.toml` | **NEW** - Crate manifest |
| `crates/opencode-sdk/src/lib.rs` | **NEW** - Public exports |
| `crates/opencode-sdk/src/client.rs` | **NEW** - OpencodeClient implementation |
| `crates/opencode-sdk/src/server.rs` | **NEW** - OpencodeServer spawning |
| `crates/opencode-sdk/src/events.rs` | **NEW** - SSE event stream |
| `crates/opencode-sdk/src/types.rs` | **NEW** - Generated types (or inline) |
| `crates/opencode-sdk/src/error.rs` | **NEW** - Error types |
| `crates/acp-adapter/src/agents/opencode.rs` | **NEW** - OpenCode agent wrapper |
| `crates/acp-adapter/src/agents/mod.rs` | Add opencode module |
| `crates/acp-adapter/src/converters/opencode.rs` | **NEW** - Event converters |
| `Cargo.toml` | Add opencode-sdk to workspace |

## Dependencies

**External (new)**:
- `reqwest` — HTTP client (already in workspace)
- `reqwest-eventsource` or `eventsource-client` — SSE client
- `progenitor` or `openapiv3` — OpenAPI code generation (build-time)

**Internal**:
- `acp-adapter` — Protocol unification
- `recorder` — Trajectory logging

## API Design

### OpencodeClient

```rust
// crates/opencode-sdk/src/client.rs

pub struct OpencodeClient {
    base_url: String,
    http_client: reqwest::Client,
    directory: Option<PathBuf>,
}

impl OpencodeClient {
    pub fn new(config: OpencodeClientConfig) -> Self;

    // Session operations
    pub async fn session_create(&self, req: SessionCreateRequest) -> Result<Session>;
    pub async fn session_list(&self) -> Result<Vec<Session>>;
    pub async fn session_get(&self, id: &SessionId) -> Result<Session>;
    pub async fn session_delete(&self, id: &SessionId) -> Result<()>;
    pub async fn session_prompt(&self, id: &SessionId, req: PromptRequest) -> Result<()>;
    pub async fn session_prompt_async(&self, id: &SessionId, req: PromptRequest) -> Result<()>;
    pub async fn session_abort(&self, id: &SessionId) -> Result<()>;
    pub async fn session_fork(&self, id: &SessionId) -> Result<Session>;
    pub async fn session_messages(&self, id: &SessionId) -> Result<Vec<Message>>;
    pub async fn session_diff(&self, id: &SessionId) -> Result<Diff>;
    pub async fn session_summarize(&self, id: &SessionId, model: ModelRef) -> Result<()>;

    // Provider operations
    pub async fn provider_list(&self) -> Result<Vec<Provider>>;
    pub async fn provider_auth(&self) -> Result<Vec<AuthMethod>>;

    // Event stream
    pub async fn events(&self) -> Result<EventStream>;

    // File operations
    pub async fn file_list(&self, path: &Path) -> Result<Vec<FileInfo>>;
    pub async fn file_read(&self, path: &Path) -> Result<String>;
    pub async fn file_status(&self) -> Result<GitStatus>;

    // Search operations
    pub async fn find_text(&self, pattern: &str) -> Result<Vec<TextMatch>>;
    pub async fn find_files(&self, query: &str) -> Result<Vec<PathBuf>>;
    pub async fn find_symbols(&self, query: &str) -> Result<Vec<Symbol>>;

    // Config
    pub async fn config_get(&self) -> Result<Config>;
    pub async fn config_update(&self, config: Config) -> Result<()>;

    // Health
    pub async fn health(&self) -> Result<HealthStatus>;
}
```

### OpencodeServer

```rust
// crates/opencode-sdk/src/server.rs

pub struct OpencodeServer {
    process: Child,
    url: String,
    port: u16,
}

pub struct ServerOptions {
    pub hostname: String,
    pub port: u16,
    pub timeout_ms: u64,
    pub config: Option<OpencodeConfig>,
}

impl OpencodeServer {
    pub async fn spawn(options: ServerOptions) -> Result<Self>;
    pub fn url(&self) -> &str;
    pub fn port(&self) -> u16;
    pub fn close(self) -> Result<()>;
}

/// Convenience: spawn server + create connected client
pub async fn create_opencode(options: ServerOptions) -> Result<(OpencodeClient, OpencodeServer)>;
```

### EventStream

```rust
// crates/opencode-sdk/src/events.rs

pub struct EventStream {
    inner: Pin<Box<dyn Stream<Item = Result<Event>> + Send>>,
}

impl Stream for EventStream {
    type Item = Result<Event>;
    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>>;
}

#[derive(Debug, Clone)]
pub enum Event {
    // Session lifecycle
    SessionCreated { info: Session },
    SessionUpdated { info: Session },
    SessionDeleted { info: Session },
    SessionStatus { session_id: SessionId, status: SessionStatus },
    SessionIdle { session_id: SessionId },
    SessionError { session_id: Option<SessionId>, error: Option<String> },

    // Message updates
    MessageUpdated { info: Message },
    MessageRemoved { session_id: SessionId, message_id: MessageId },
    MessagePartUpdated { part: Part, delta: Option<String> },
    MessagePartRemoved { session_id: SessionId, message_id: MessageId, part_id: PartId },

    // Permissions
    PermissionUpdated { permission: Permission },
    PermissionReplied { session_id: SessionId, permission_id: PermissionId, response: String },

    // File changes
    FileEdited { file: FileInfo },

    // Todos
    TodoUpdated { session_id: SessionId, todos: Vec<Todo> },

    // Server
    ServerConnected,
    ServerDisposed { directory: PathBuf },
}
```

### Usage Example

```rust
use opencode_sdk::{create_opencode, ServerOptions, PromptRequest, Part};
use futures::StreamExt;

#[tokio::main]
async fn main() -> Result<()> {
    // Spawn server and create client
    let (client, server) = create_opencode(ServerOptions {
        port: 4096,
        config: Some(OpencodeConfig {
            model: "openai/codex-sonnet-4".to_string(),
            ..Default::default()
        }),
        ..Default::default()
    }).await?;

    // Create session
    let session = client.session_create(Default::default()).await?;

    // Start event listener
    let events = client.events().await?;
    tokio::spawn(async move {
        while let Some(event) = events.next().await {
            match event? {
                Event::MessagePartUpdated { delta: Some(text), .. } => {
                    print!("{}", text);
                }
                Event::SessionIdle { session_id } => {
                    println!("\nSession {} complete", session_id);
                    break;
                }
                _ => {}
            }
        }
    });

    // Send prompt
    client.session_prompt(&session.id, PromptRequest {
        parts: vec![Part::Text { text: "Fix the bug in main.rs".to_string() }],
        ..Default::default()
    }).await?;

    // Cleanup
    server.close()?;
    Ok(())
}
```

## Testing Strategy

1. **Unit Tests** — Mock HTTP responses for all endpoints
2. **Integration Tests** — Spin up real OpenCode server, run session flows
3. **Event Tests** — Validate SSE parsing with recorded event streams
4. **ACP Tests** — Verify converter output matches expected ACP notifications

## Notes

### OpenCode Installation

```bash
# Install OpenCode globally
npm i -g opencode-ai@latest

# Or run directly
npx opencode-ai serve --port 4096
```

### Environment Variables

```bash
# OpenCode server (when spawned by SDK)
OPENCODE_PORT=4096
OPENCODE_HOSTNAME=127.0.0.1

# Provider keys (used by OpenCode)
OPENAI_API_KEY=sk-ant-...
OPENAI_API_KEY=sk-...
GOOGLE_AI_API_KEY=...
```

### Plugin Configuration

To use OpenCode with oh-my-opencode plugin (until d-022 completes):

```bash
# Install plugin globally
npm i -g oh-my-opencode

# OpenCode auto-discovers installed plugins
opencode serve --port 4096
```

## Related Directives

- **d-017**: ACP Integration (protocol unification)
- **d-019**: GPT-OSS Local Inference (alternative backend)
- **d-022**: Agent Orchestration Framework (uses this SDK)
- **d-012**: No Stubs (all implementations must be complete)

## References

- [OpenCode Repository](https://github.com/sst/opencode)
- [OpenCode SDK Documentation](https://opencode.ai/docs)
- [OpenAPI Specification](~/code/opencode/packages/sdk/openapi.json)
- [SDK Architecture](~/code/opencode/SDK_ARCHITECTURE.md)
