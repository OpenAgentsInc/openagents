---
id: d-026
title: E2E Test Live Viewer for WGPUI
status: active
priority: high
created: 2025-12-25
updated: 2025-12-25
---

## Goal

Build a live e2e test viewer that lets users watch automated tests execute in real-time, with an overlay showing mouse/keyboard input visualization. Tests are specified via a fluent Rust DSL, and execution happens in the same window as the component under test.

## Background

Testing UI components in isolation is valuable, but watching a full test sequence execute provides unique benefits:

- **Debugging** - See exactly what the test does and where it fails
- **Validation** - Verify the test matches intended user flow
- **Documentation** - Tests serve as animated usage examples
- **Confidence** - Visual confirmation that assertions match reality

The system is inspired by StarCraft replay viewers and Playwright trace viewers, adapted for WGPUI's GPU-accelerated rendering.

### Key Features

| Feature | Description |
|---------|-------------|
| Automated Script | Pre-defined click sequences drive the test |
| Rust DSL | Fluent API for test specification (`test.click("#button").expect("#result")`) |
| Same Window | Overlay renders on top of component under test |
| Live Visualization | User watches test execute in real-time |
| Input Overlay | Cursor crosshair, click ripples, key press display |
| Playback Control | Play/pause/step with speed adjustment (0.5x-10x) |

## Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    TestHarness<C>                        │
│  ┌─────────────────────────────────────────────────────┐│
│  │              Control Bar (play/pause/step)          ││
│  ├─────────────────────────────────────────────────────┤│
│  │                                                      ││
│  │              Component Under Test                    ││
│  │                                                      ││
│  ├─────────────────────────────────────────────────────┤│
│  │              InputOverlay                            ││
│  │  • Mouse cursor crosshair                           ││
│  │  • Click ripple animations                          ││
│  │  • Key press display                                ││
│  └─────────────────────────────────────────────────────┘│
│                                                          │
│  TestRunner ──► EventInjection ──► Component.event()    │
└─────────────────────────────────────────────────────────┘
```

### Data Flow

1. User writes test using fluent DSL
2. DSL builds TestRunner with list of TestSteps
3. TestHarness wraps component and runner
4. On each frame, runner advances (respecting playback speed)
5. Runner generates synthetic InputEvents
6. Events injected into component.event() before real events
7. InputOverlay observes events for visualization
8. Assertions verified after each step

## Core Types

### TestStep

The fundamental building block of a test:

```rust
pub enum TestStep {
    Click { target: ClickTarget, button: MouseButton },
    DoubleClick { target: ClickTarget, button: MouseButton },
    Type { text: String, delay_per_char: Option<Duration> },
    KeyPress { key: Key, modifiers: Modifiers },
    Scroll { target: ClickTarget, dx: f32, dy: f32 },
    MoveTo { target: ClickTarget },
    Wait { duration: Duration },
    WaitFor { selector: ElementSelector, timeout: Duration },
    Expect { selector: ElementSelector },
    ExpectText { selector: ElementSelector, text: String },
    ExpectVisible { selector: ElementSelector },
}
```

### ElementSelector

How to find elements for interaction:

```rust
pub enum ElementSelector {
    Id(u64),                    // ComponentId(123)
    Text(String),               // Find by text content
    Bounds(Bounds),             // Specific screen area
    Query(String),              // "#123" or "text:Hello"
}
```

### ClickTarget

Where to click:

```rust
pub enum ClickTarget {
    Element(ElementSelector),                      // Center of element
    Position(Point),                               // Absolute coordinates
    ElementOffset { selector: ElementSelector, offset: Point },  // Relative to element
}
```

### RunnerState

State machine for test execution:

```rust
pub enum RunnerState {
    Idle,      // Not started
    Running,   // Executing steps
    Paused,    // User paused
    Stepping,  // Single-step mode
    Passed,    // All steps succeeded
    Failed,    // Assertion or action failed
    Aborted,   // User cancelled
}
```

### PlaybackSpeed

How fast tests execute:

```rust
pub struct PlaybackSpeed(pub f32);

impl PlaybackSpeed {
    pub const SLOW: Self = Self(0.5);
    pub const NORMAL: Self = Self(1.0);
    pub const FAST: Self = Self(2.0);
    pub const INSTANT: Self = Self(10.0);
}
```

## Fluent DSL

Tests are written using a builder pattern:

```rust
let login_test = test("Login Flow")
    .click("#email-input")
    .type_text("user@example.com")
    .press_key(Key::Named(NamedKey::Tab))
    .type_text("password123")
    .click("#login-button")
    .wait(500)
    .expect("#dashboard")
    .expect_text("#welcome", "Welcome")
    .build();
```

### DSL Methods

| Method | Description |
|--------|-------------|
| `click(selector)` | Left-click element |
| `click_at(x, y)` | Click at coordinates |
| `right_click(selector)` | Right-click element |
| `double_click(selector)` | Double-click element |
| `type_text(text)` | Type with 50ms delay per char |
| `type_instant(text)` | Type instantly |
| `press_key(key)` | Press a key |
| `press_key_with(key, mods)` | Press key with modifiers |
| `scroll(selector, dx, dy)` | Scroll element |
| `hover(selector)` | Move mouse to element |
| `wait(ms)` | Wait duration |
| `wait_for(selector)` | Wait for element (5s timeout) |
| `wait_for_timeout(sel, ms)` | Wait with custom timeout |
| `expect(selector)` | Assert element exists |
| `expect_text(sel, text)` | Assert element has text |
| `expect_visible(selector)` | Assert element visible |

## InputOverlay Component

Visual feedback during test execution:

### Cursor Display
- Crosshair at current mouse position
- Size: 16px default
- Color: Theme accent color

### Click Ripples
- Expanding circle on click
- Animation: 400ms with EaseOutQuad
- Max radius: 30px
- Queue: max 5 concurrent ripples

### Key Press Display
- Stack of recent keys (bottom-left)
- Fade out after 800ms
- Max 5 visible
- Shows modifier combinations (Ctrl+S)

```rust
pub struct InputOverlay {
    mouse_position: Point,
    ripples: VecDeque<ClickRipple>,
    key_presses: VecDeque<KeyPress>,
    cursor_size: f32,
    ripple_max_radius: f32,
}
```

## TestHarness Component

Wraps any Component for testing:

```rust
let harness = TestHarness::new(my_component)
    .with_runner(test_runner)
    .show_overlay(true)
    .show_controls(true);

// Use as normal component
window.render_root(&mut harness);
```

### Control Bar
- State indicator (IDLE/RUNNING/PAUSED/PASSED/FAILED)
- Step counter (Step 3/10)
- Keyboard shortcuts: [P]lay [S]tep [Space]Pause [1-4]Speed

### Event Flow
1. TestRunner.tick() generates synthetic events
2. Events queued in harness
3. Injected into component.event() before real events
4. Overlay observes all events for visualization

## Success Criteria

### Phase 1: Core Types
- [ ] Create `crates/wgpui/src/testing/mod.rs` with module exports
- [ ] Create `testing/step.rs` with TestStep, ElementSelector, ClickTarget
- [ ] Create `testing/assertion.rs` with TestAssertion, AssertionResult
- [ ] Create `testing/context.rs` with ComponentRegistry, TestContext
- [ ] Add unit tests for all core types

### Phase 2: Test Runner
- [ ] Create `testing/runner.rs` with TestRunner struct
- [ ] Implement RunnerState state machine
- [ ] Add PlaybackSpeed with configurable multiplier
- [ ] Implement step execution with timing
- [ ] Add assertion result tracking
- [ ] Unit tests for runner state transitions

### Phase 3: DSL Builder
- [ ] Create `testing/dsl.rs` with Test builder struct
- [ ] Implement all click methods (click, right_click, double_click)
- [ ] Implement type methods (type_text, type_instant)
- [ ] Implement key methods (press_key, press_key_with)
- [ ] Implement wait methods (wait, wait_for, wait_for_timeout)
- [ ] Implement expect methods (expect, expect_text, expect_visible)
- [ ] Implement hover and scroll methods
- [ ] Add build() to construct TestRunner
- [ ] Unit tests for DSL builder

### Phase 4: Event Injection
- [ ] Create `testing/injection.rs` with EventSequence
- [ ] Implement EventPlayer iterator for timed playback
- [ ] Generate InputEvent::MouseMove for cursor movement
- [ ] Generate InputEvent::MouseDown/MouseUp for clicks
- [ ] Generate InputEvent::KeyDown/KeyUp for key presses
- [ ] Generate InputEvent::Scroll for scroll events
- [ ] Unit tests for event generation

### Phase 5: Input Overlay
- [ ] Create `testing/overlay.rs` with InputOverlay component
- [ ] Implement cursor crosshair rendering
- [ ] Implement click ripple animation (EaseOutQuad, 400ms)
- [ ] Implement key press stack display (bottom-left)
- [ ] Implement Component trait for InputOverlay
- [ ] Add configurable position for key display
- [ ] Unit tests for overlay state management

### Phase 6: Test Harness
- [ ] Create `testing/harness.rs` with TestHarness wrapper
- [ ] Integrate TestRunner with Component lifecycle
- [ ] Implement control bar UI (state, step count, shortcuts)
- [ ] Add keyboard shortcut handling (P, S, Space, 1-4)
- [ ] Connect event injection to component.event()
- [ ] Connect InputOverlay to observe events
- [ ] Implement Component trait for TestHarness
- [ ] Integration tests with mock components

### Phase 7: Integration
- [ ] Add `pub mod testing` to `crates/wgpui/src/lib.rs`
- [ ] Export public API from testing/mod.rs
- [ ] Add comprehensive documentation
- [ ] Create example test using the framework
- [ ] Run storybook components with test harness
- [ ] Verify 60fps performance with overlay

## Key Files to Create

| File | Purpose |
|------|---------|
| `crates/wgpui/src/testing/mod.rs` | Module exports |
| `crates/wgpui/src/testing/step.rs` | TestStep, ElementSelector, ClickTarget |
| `crates/wgpui/src/testing/assertion.rs` | TestAssertion, AssertionResult |
| `crates/wgpui/src/testing/context.rs` | ComponentRegistry, TestContext |
| `crates/wgpui/src/testing/runner.rs` | TestRunner, RunnerState, PlaybackSpeed |
| `crates/wgpui/src/testing/dsl.rs` | Fluent Test builder |
| `crates/wgpui/src/testing/injection.rs` | EventSequence, EventPlayer |
| `crates/wgpui/src/testing/overlay.rs` | InputOverlay component |
| `crates/wgpui/src/testing/harness.rs` | TestHarness wrapper |

## Key Files to Modify

| File | Change |
|------|--------|
| `crates/wgpui/src/lib.rs` | Add `pub mod testing` |

## Dependencies

No new external dependencies required. Uses existing WGPUI infrastructure:

- `crates/wgpui/src/input.rs` - InputEvent types
- `crates/wgpui/src/components/component.rs` - Component trait
- `crates/wgpui/src/animation.rs` - Animation and easing
- `crates/wgpui/src/theme.rs` - Theme colors
- `crates/wgpui/src/geometry.rs` - Bounds, Point, Size

## Testing Strategy

1. **Unit tests** - Each module has isolated tests
2. **Integration tests** - TestHarness with mock components
3. **Visual tests** - Overlay rendering verification
4. **Performance tests** - 60fps with active overlay
5. **DSL tests** - Builder produces correct TestSteps

### Test Files

| Test File | Coverage |
|-----------|----------|
| `testing/step.rs` | TestStep serialization, ElementSelector parsing |
| `testing/runner.rs` | State transitions, timing accuracy |
| `testing/dsl.rs` | Builder method chaining, step generation |
| `testing/injection.rs` | Event generation correctness |
| `testing/overlay.rs` | Ripple animation, key stack management |
| `testing/harness.rs` | Event routing, control bar interaction |

## Notes

### Design Decisions

1. **No border radius** - Per AGENTS.md, sharp corners only
2. **Vera Mono font** - Use TextSystem for all overlay text
3. **Single-threaded** - Runs within WGPUI event loop
4. **Query syntax** - `#123` for ComponentId, `text:Hello` for text search
5. **Overlay-first** - InputOverlay paints over everything

### Inspiration

- **StarCraft 2 replay viewer** - Watching actions unfold with APM counter
- **Playwright trace viewer** - Step-by-step test visualization
- **Cypress UI** - Real-time test execution feedback
- **Storybook interactions** - Component testing with visual feedback

### Future Enhancements

- Record mode: Watch user actions, generate DSL code
- Snapshot comparison: Assert screen state matches expected
- Network mocking: Simulate API responses
- Multi-window support: Test across multiple windows
- Video export: Save test runs as video files

## Related Directives

- d-011 (Storybook) - Tests can run against storybook components
- d-013 (Testing Framework) - E2E testing architecture
- d-020 (WGPUI Integration) - Component testing infrastructure
- d-023 (WGPUI Framework) - Core rendering and input types
- d-024 (Arwes Parity) - Animation/easing functions for overlay
