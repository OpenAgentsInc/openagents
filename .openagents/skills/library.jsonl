{"id":"skill-read-file-v1","name":"Read File","version":"v1","description":"Read the contents of a file. Use when you need to examine file contents before making changes.","category":"file_operations","status":"active","code":"// Read file contents\nconst content = await Bun.file(path).text();\n// Returns: file content as string","parameters":[{"name":"path","type":"path","description":"Path to the file to read","required":true}],"verification":{"type":"none"},"examples":[],"tags":["file","read","input"],"successRate":0.36000000000000004,"usageCount":2,"lastUsed":"2025-12-08T06:03:51.054Z","createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:03:51.054Z","source":"bootstrap"}
{"id":"skill-write-file-v1","name":"Write File","version":"v1","description":"Write content to a file, creating it if it doesn't exist. Use for creating new files or completely replacing file contents.","category":"file_operations","status":"active","code":"// Write content to file\nawait Bun.write(path, content);\n// Creates file if doesn't exist, overwrites if exists","parameters":[{"name":"path","type":"path","description":"Path to the file to write","required":true},{"name":"content","type":"string","description":"Content to write to the file","required":true}],"verification":{"type":"command","command":"test -f {path}"},"examples":[],"tags":["file","write","output","create"],"successRate":0.36000000000000004,"usageCount":2,"lastUsed":"2025-12-08T06:03:51.055Z","createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:03:51.055Z","source":"bootstrap"}
{"id":"skill-edit-file-v1","name":"Edit File","version":"v1","description":"Replace specific text in a file. Use for targeted modifications without rewriting the entire file.","category":"file_operations","status":"active","code":"// Edit file by replacing text\nconst content = await Bun.file(path).text();\nconst updated = content.replace(oldText, newText);\nawait Bun.write(path, updated);","parameters":[{"name":"path","type":"path","description":"Path to the file to edit","required":true},{"name":"oldText","type":"string","description":"Text to find and replace","required":true},{"name":"newText","type":"string","description":"Text to replace with","required":true}],"verification":{"type":"pattern","pattern":"{newText}"},"examples":[],"tags":["file","edit","modify","replace"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-glob-files-v1","name":"Glob Files","version":"v1","description":"Find files matching a glob pattern. Use to discover files before reading or modifying them.","category":"file_operations","status":"active","code":"// Find files matching pattern\nconst glob = new Bun.Glob(pattern);\nconst files = await Array.fromAsync(glob.scan({ cwd: directory }));\n// Returns: array of matching file paths","parameters":[{"name":"pattern","type":"pattern","description":"Glob pattern (e.g., '**/*.ts')","required":true},{"name":"directory","type":"path","description":"Directory to search in","required":false,"default":"."}],"verification":{"type":"none"},"examples":[],"tags":["file","search","glob","find"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-create-directory-v1","name":"Create Directory","version":"v1","description":"Create a new directory. Use before writing files to non-existent directories.","category":"file_operations","status":"active","code":"// Create directory recursively\nimport { mkdir } from \"fs/promises\";\nawait mkdir(path, { recursive: true });","parameters":[{"name":"path","type":"path","description":"Directory path to create","required":true}],"verification":{"type":"command","command":"test -d {path}"},"examples":[],"tags":["file","directory","create"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:03:51.056Z","source":"bootstrap","successRate":0.2,"usageCount":1,"lastUsed":"2025-12-08T06:03:51.056Z"}
{"id":"skill-delete-file-v1","name":"Delete File","version":"v1","description":"Delete a file. Use to clean up temporary or unwanted files.","category":"file_operations","status":"active","code":"// Delete file\nimport { unlink } from \"fs/promises\";\nawait unlink(path);","parameters":[{"name":"path","type":"path","description":"Path to file to delete","required":true}],"verification":{"type":"command","command":"test ! -f {path}"},"examples":[],"tags":["file","delete","remove"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-copy-file-v1","name":"Copy File","version":"v1","description":"Copy a file to a new location. Use to duplicate files or create backups.","category":"file_operations","status":"active","code":"// Copy file\nimport { copyFile } from \"fs/promises\";\nawait copyFile(source, destination);","parameters":[{"name":"source","type":"path","description":"Source file path","required":true},{"name":"destination","type":"path","description":"Destination path","required":true}],"verification":{"type":"command","command":"test -f {destination}"},"examples":[],"tags":["file","copy","duplicate"],"successRate":0.2,"usageCount":1,"lastUsed":"2025-12-08T06:03:04.454Z","createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:03:04.454Z","source":"bootstrap"}
{"id":"skill-list-directory-v1","name":"List Directory","version":"v1","description":"List contents of a directory. Use to explore directory structure.","category":"file_operations","status":"active","code":"// List directory contents\nimport { readdir } from \"fs/promises\";\nconst entries = await readdir(path, { withFileTypes: true });\n// Returns: array of { name, isDirectory(), isFile() }","parameters":[{"name":"path","type":"path","description":"Directory to list","required":true}],"verification":{"type":"none"},"examples":[],"tags":["file","list","directory","explore"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-grep-code-v1","name":"Grep Code","version":"v1","description":"Search for text patterns in files. Use to find specific code patterns or text.","category":"search","status":"active","code":"// Search for pattern in files\nconst proc = Bun.spawn([\"grep\", \"-rn\", pattern, path]);\nconst output = await new Response(proc.stdout).text();\n// Returns: matching lines with file:line:content format","parameters":[{"name":"pattern","type":"pattern","description":"Regex pattern to search for","required":true},{"name":"path","type":"path","description":"File or directory to search","required":false,"default":"."}],"verification":{"type":"none"},"examples":[],"tags":["search","grep","find","pattern"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:03:51.055Z","source":"bootstrap","successRate":0.2,"usageCount":1,"lastUsed":"2025-12-08T06:03:51.055Z"}
{"id":"skill-find-file-v1","name":"Find File","version":"v1","description":"Find a file by name or pattern. Use to locate files before reading or modifying.","category":"search","status":"active","code":"// Find file by name\nconst glob = new Bun.Glob(\"**/\" + filename);\nconst files = await Array.fromAsync(glob.scan({ cwd: searchDir }));\n// Returns: array of matching paths","parameters":[{"name":"filename","type":"string","description":"File name to find","required":true},{"name":"searchDir","type":"path","description":"Directory to search","required":false,"default":"."}],"verification":{"type":"none"},"examples":[],"tags":["search","find","file"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-find-definition-v1","name":"Find Definition","version":"v1","description":"Find where a function, class, or variable is defined. Use to understand code structure.","category":"search","status":"active","code":"// Search for definition patterns\n// Function: \"function name(\" or \"const name = (\"\n// Class: \"class Name\"\n// Variable: \"const/let/var name =\"\n// Type: \"type Name =\" or \"interface Name\"\nconst patterns = [\n  `function ${name}\\\\(`,\n  `class ${name}`,\n  `(const|let|var) ${name}\\\\s*=`,\n  `(type|interface) ${name}`,\n];","parameters":[{"name":"name","type":"string","description":"Name of function/class/variable to find","required":true},{"name":"searchDir","type":"path","description":"Directory to search","required":false,"default":"."}],"verification":{"type":"none"},"examples":[],"tags":["search","definition","code","navigate"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-search-code-v1","name":"Search Code","version":"v1","description":"Search for code patterns across the codebase. Use to find usage examples or similar patterns.","category":"search","status":"active","code":"// Search code with context\nconst proc = Bun.spawn([\"grep\", \"-rn\", \"-A\", \"3\", \"-B\", \"1\", pattern, path]);\nconst output = await new Response(proc.stdout).text();\n// Returns: matching lines with surrounding context","parameters":[{"name":"pattern","type":"pattern","description":"Code pattern to search","required":true},{"name":"path","type":"path","description":"Directory to search","required":false,"default":"src"},{"name":"fileType","type":"string","description":"File extension (e.g., 'ts', 'js')","required":false}],"verification":{"type":"none"},"examples":[],"tags":["search","code","pattern"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:03:51.056Z","source":"bootstrap","successRate":0.2,"usageCount":1,"lastUsed":"2025-12-08T06:03:51.056Z"}
{"id":"skill-run-tests-v1","name":"Run Tests","version":"v1","description":"Execute test suite using bun test. Use to verify code changes don't break existing functionality.","category":"testing","status":"active","code":"// Run tests\nconst proc = Bun.spawn([\"bun\", \"test\", testPattern], { cwd: projectRoot });\nconst exitCode = await proc.exited;\n// exitCode 0 = success, non-zero = failure","parameters":[{"name":"testPattern","type":"string","description":"Test file pattern (e.g., 'src/**/*.test.ts')","required":false},{"name":"projectRoot","type":"path","description":"Project root directory","required":false,"default":"."}],"verification":{"type":"command","command":"bun test {testPattern}"},"examples":[],"tags":["test","verify","quality"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-run-typecheck-v1","name":"Run Typecheck","version":"v1","description":"Run TypeScript type checking. Use to verify type correctness after code changes.","category":"testing","status":"active","code":"// Run TypeScript type check\nconst proc = Bun.spawn([\"bun\", \"run\", \"build:check\"], { cwd: projectRoot });\nconst exitCode = await proc.exited;\n// exitCode 0 = no type errors","parameters":[{"name":"projectRoot","type":"path","description":"Project root directory","required":false,"default":"."}],"verification":{"type":"command","command":"bun run build:check"},"examples":[],"tags":["typecheck","typescript","types","verify"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-run-lint-v1","name":"Run Lint","version":"v1","description":"Run linter to check code style. Use to ensure code follows project conventions.","category":"testing","status":"active","code":"// Run ESLint\nconst proc = Bun.spawn([\"bun\", \"run\", \"lint\"], { cwd: projectRoot });\nconst exitCode = await proc.exited;\n// exitCode 0 = no lint errors","parameters":[{"name":"projectRoot","type":"path","description":"Project root directory","required":false,"default":"."}],"verification":{"type":"command","command":"bun run lint"},"examples":[],"tags":["lint","style","quality"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-git-status-v1","name":"Git Status","version":"v1","description":"Check git repository status. Use to see changed, staged, and untracked files.","category":"git","status":"active","code":"// Check git status\nconst proc = Bun.spawn([\"git\", \"status\", \"--porcelain\"]);\nconst output = await new Response(proc.stdout).text();\n// Returns: modified files in short format","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["git","status","changes"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-git-diff-v1","name":"Git Diff","version":"v1","description":"Show changes in files. Use to review changes before committing.","category":"git","status":"active","code":"// Show git diff\nconst proc = Bun.spawn([\"git\", \"diff\", path || \".\"]);\nconst output = await new Response(proc.stdout).text();\n// Returns: unified diff output","parameters":[{"name":"path","type":"path","description":"Specific file or directory to diff","required":false},{"name":"staged","type":"boolean","description":"Show staged changes only","required":false,"default":"false"}],"verification":{"type":"none"},"examples":[],"tags":["git","diff","changes"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-git-add-v1","name":"Git Add","version":"v1","description":"Stage files for commit. Use to prepare changes for committing.","category":"git","status":"active","code":"// Stage files\nconst proc = Bun.spawn([\"git\", \"add\", ...files]);\nawait proc.exited;","parameters":[{"name":"files","type":"array","description":"Files to stage (use '.' for all)","required":true}],"verification":{"type":"command","command":"git status --porcelain"},"examples":[],"tags":["git","add","stage"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-git-commit-v1","name":"Git Commit","version":"v1","description":"Create a commit with staged changes. Use after staging changes with git add.","category":"git","status":"active","code":"// Create commit\nconst proc = Bun.spawn([\"git\", \"commit\", \"-m\", message]);\nawait proc.exited;","parameters":[{"name":"message","type":"string","description":"Commit message","required":true}],"verification":{"type":"command","command":"git log -1 --oneline"},"examples":[],"tags":["git","commit","save"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-git-log-v1","name":"Git Log","version":"v1","description":"Show recent commit history. Use to understand recent changes.","category":"git","status":"active","code":"// Show recent commits\nconst proc = Bun.spawn([\"git\", \"log\", \"--oneline\", \"-n\", String(count)]);\nconst output = await new Response(proc.stdout).text();","parameters":[{"name":"count","type":"number","description":"Number of commits to show","required":false,"default":"10"}],"verification":{"type":"none"},"examples":[],"tags":["git","log","history"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-git-branch-v1","name":"Git Branch","version":"v1","description":"List or create git branches. Use for branch management.","category":"git","status":"active","code":"// List branches\nconst proc = Bun.spawn([\"git\", \"branch\", \"-a\"]);\nconst output = await new Response(proc.stdout).text();","parameters":[{"name":"create","type":"string","description":"Branch name to create (optional)","required":false}],"verification":{"type":"none"},"examples":[],"tags":["git","branch","version-control"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-analyze-error-v1","name":"Analyze Error","version":"v1","description":"Parse and analyze an error message to identify the cause and location. Use when encountering test failures or runtime errors.","category":"debugging","status":"active","code":"// Parse error message\n// Look for: file path, line number, error type, error message\n// Common patterns:\n//   TypeScript: \"src/file.ts(10,5): error TS2345: ...\"\n//   Runtime: \"Error: message\\n    at function (file.ts:10:5)\"\n//   Test: \"expected X but got Y\"","parameters":[{"name":"error","type":"string","description":"Error message or stack trace","required":true}],"verification":{"type":"none"},"examples":[],"tags":["debug","error","analyze","diagnose"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-fix-import-error-v1","name":"Fix Import Error","version":"v1","description":"Fix a missing or incorrect import statement. Use when encountering 'Cannot find module' or similar errors.","category":"debugging","status":"active","code":"// Fix import by adding correct import statement\n// 1. Identify the missing import from error message\n// 2. Find the correct module path\n// 3. Add import at top of file\n\n// Example fix:\n// import { MissingThing } from './correct/path.js';","parameters":[{"name":"file","type":"path","description":"File with import error","required":true},{"name":"missingImport","type":"string","description":"Name of missing import","required":true},{"name":"sourcePath","type":"string","description":"Path to import from","required":true}],"verification":{"type":"typecheck"},"examples":[],"tags":["debug","import","fix","typescript"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-fix-syntax-error-v1","name":"Fix Syntax Error","version":"v1","description":"Fix JavaScript/TypeScript syntax errors by analyzing parser output and correcting code structure","category":"debugging","status":"active","code":"// Common syntax error patterns:\n\n// 1. Missing/extra brackets: Look for unbalanced {}, [], ()\n// 2. Missing semicolons (though TypeScript usually handles this)\n// 3. Incorrect template literals: Use backticks for ${...}\n// 4. Arrow function issues: Check => placement\n// 5. Object literal issues: Check for trailing commas in JSON\n\n// Strategy:\n// 1. Read the error message carefully for the expected token\n// 2. Look at surrounding context (2-3 lines before/after)\n// 3. Check for matching pairs of brackets\n// 4. Verify string/template literal termination\n\nconst content = await Bun.file(errorFile).text();\nconst lines = content.split(\"\\n\");\nconst errorContext = lines.slice(errorLine - 3, errorLine + 2);\n// Analyze and fix the syntax issue","parameters":[{"name":"errorFile","type":"path","description":"File with syntax error","required":true},{"name":"errorLine","type":"number","description":"Line where error occurs","required":true}],"verification":{"type":"none"},"examples":[],"tags":["syntax","error-fix"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-execute-command-v1","name":"Execute Command","version":"v1","description":"Run a shell command. Use for system operations not covered by other skills.","category":"shell","status":"active","code":"// Execute shell command\nconst proc = Bun.spawn(command.split(\" \"), { cwd: workingDir });\nconst stdout = await new Response(proc.stdout).text();\nconst stderr = await new Response(proc.stderr).text();\nconst exitCode = await proc.exited;","parameters":[{"name":"command","type":"string","description":"Command to execute","required":true},{"name":"workingDir","type":"path","description":"Working directory","required":false,"default":"."}],"verification":{"type":"none"},"examples":[],"tags":["shell","command","execute"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-check-command-output-v1","name":"Check Command Output","version":"v1","description":"Run a command and verify its output matches expected pattern. Use for verification steps.","category":"shell","status":"active","code":"// Run command and check output\nconst proc = Bun.spawn(command.split(\" \"));\nconst output = await new Response(proc.stdout).text();\nconst matches = new RegExp(pattern).test(output);","parameters":[{"name":"command","type":"string","description":"Command to execute","required":true},{"name":"pattern","type":"pattern","description":"Regex pattern to match in output","required":true}],"verification":{"type":"pattern"},"examples":[],"tags":["shell","verify","output"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-install-dependency-v1","name":"Install Dependency","version":"v1","description":"Install an npm package. Use when code requires a missing dependency.","category":"shell","status":"active","code":"// Install package\nconst proc = Bun.spawn([\"bun\", \"add\", packageName]);\nawait proc.exited;","parameters":[{"name":"packageName","type":"string","description":"Package name to install","required":true},{"name":"dev","type":"boolean","description":"Install as dev dependency","required":false,"default":"false"}],"verification":{"type":"command","command":"bun pm ls | grep {packageName}"},"examples":[],"tags":["npm","install","dependency","package"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-fix-typescript-import-error-v1","name":"Fix TypeScript Import Error","version":"v1","description":"Fix missing or incorrect TypeScript imports by analyzing error messages and adding correct import statements","category":"debugging","status":"active","code":"// 1. Analyze the error to identify the missing symbol\n// 2. Search for where the symbol is exported:\nconst searchResult = await $`grep -r \"export.*{symbolName}\" --include=\"*.ts\" .`.text();\n// Or check common patterns:\n// - Named export: export { Symbol } from './path'\n// - Default export: export default Symbol\n// - Type export: export type { Symbol }\n\n// 3. Add the import at the top of the file:\nconst importStatement = `import { ${symbolName} } from \"${sourcePath}\";`;\n// Insert after existing imports or at file start\n\n// 4. Run typecheck to verify fix:\nawait $`bun tsc --noEmit ${errorFile}`;","parameters":[{"name":"errorFile","type":"path","description":"File with the import error","required":true},{"name":"missingSymbol","type":"string","description":"The symbol that's missing","required":true}],"verification":{"type":"none"},"examples":[{"description":"Fix missing Effect import","input":{"error":"TS2304: Cannot find name 'Effect'"},"output":"import { Effect } from 'effect';"}],"tags":["typescript","import","error-fix"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-fix-typescript-type-error-v1","name":"Fix TypeScript Type Error","version":"v1","description":"Resolve TypeScript type mismatches by analyzing expected vs actual types and applying correct fixes","category":"debugging","status":"active","code":"// Common type error patterns and fixes:\n\n// Pattern 1: Type 'X' is not assignable to type 'Y'\n// - Check if types are compatible (structural typing)\n// - Use type assertion: value as Type\n// - Use type guard: if (isType(value)) { ... }\n\n// Pattern 2: Property 'X' does not exist on type 'Y'\n// - Add optional chaining: obj?.property\n// - Add type declaration: (obj as ExtendedType).property\n// - Extend the interface/type\n\n// Pattern 3: Argument of type 'X' is not assignable\n// - Check function signature\n// - Create proper type conversion\n// - Use satisfies operator for better inference\n\n// Pattern 4: exactOptionalPropertyTypes issues\n// - Add undefined to optional property types: prop?: string | undefined\n// - Or explicitly set the property rather than spreading\n\n// After fix, verify with:\nawait $`bun tsc --noEmit`;","parameters":[{"name":"errorFile","type":"path","description":"File with the type error","required":true},{"name":"errorLine","type":"number","description":"Line number of the error","required":true}],"verification":{"type":"none"},"examples":[],"tags":["typescript","types","error-fix"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-add-test-for-function-v1","name":"Add Test for Function","version":"v1","description":"Create a test file or add tests to existing test file for a function","category":"testing","status":"active","code":"// 1. Read the function to understand its signature and behavior\nconst sourceContent = await Bun.file(functionFile).text();\n// Extract function signature, parameters, return type\n\n// 2. Create or locate test file\nconst testFile = functionFile.replace(/\\.ts$/, '.test.ts');\nconst existingTests = await Bun.file(testFile).text().catch(() => '');\n\n// 3. Generate test structure\nconst testTemplate = `\nimport { describe, test, expect } from \"bun:test\";\nimport { ${functionName} } from \"./${basename(functionFile, '.ts')}\";\n\ndescribe(\"${functionName}\", () => {\n  test(\"handles basic case\", () => {\n    // TODO: Add expected input/output\n    const result = ${functionName}(/* args */);\n    expect(result).toBe(/* expected */);\n  });\n\n  test(\"handles edge cases\", () => {\n    // TODO: Add edge case tests\n  });\n\n  test(\"throws on invalid input\", () => {\n    expect(() => ${functionName}(/* invalid */)).toThrow();\n  });\n});\n`;\n\n// 4. Write and run tests\nawait Bun.write(testFile, existingTests + testTemplate);\nawait $`bun test ${testFile}`;","parameters":[{"name":"functionFile","type":"path","description":"File containing the function","required":true},{"name":"functionName","type":"string","description":"Name of the function to test","required":true}],"verification":{"type":"none"},"examples":[],"tags":["test","bun","vitest"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-run-tests-with-coverage-v1","name":"Run Tests with Coverage","version":"v1","description":"Run test suite and analyze code coverage, identifying untested paths","category":"testing","status":"active","code":"// Run tests with coverage enabled\nconst result = await $`bun test --coverage`.text();\n\n// Parse coverage output\n// Look for:\n// - File coverage percentages\n// - Uncovered lines\n// - Branch coverage\n\n// Generate coverage report\nconsole.log(\"Coverage Results:\");\nconsole.log(result);\n\n// Identify files below threshold (e.g., 80%)\n// Suggest adding tests for uncovered code","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["test","coverage"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-fix-failing-test-v1","name":"Fix Failing Test","version":"v1","description":"Analyze and fix a failing test by understanding the mismatch between expected and actual values","category":"testing","status":"active","code":"// 1. Run the specific test to see failure output\nconst output = await $`bun test ${testFile}`.text();\n\n// 2. Parse error to find:\n// - Expected value\n// - Actual value\n// - Test location\n\n// 3. Determine if the issue is:\n// a) Test is wrong (update expected value)\n// b) Code is wrong (fix implementation)\n// c) Test setup is incomplete (add mocks/fixtures)\n\n// 4. Common fixes:\n// - Snapshot updates: bun test --update-snapshots\n// - Async timing: Add await or adjust timeout\n// - Mock data: Ensure test data matches expected structure\n\n// 5. Re-run to verify fix\nawait $`bun test ${testFile}`;","parameters":[{"name":"testFile","type":"path","description":"The failing test file","required":true}],"verification":{"type":"none"},"examples":[],"tags":["test","debugging"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-mock-dependency-v1","name":"Mock Dependency","version":"v1","description":"Create mocks and stubs for external dependencies in tests","category":"testing","status":"active","code":"import { mock, spyOn } from \"bun:test\";\n\n// 1. Mock entire module\nmock.module(\"./database\", () => ({\n  query: () => Promise.resolve([{ id: 1 }]),\n  connect: () => Promise.resolve(),\n}));\n\n// 2. Spy on method\nconst spy = spyOn(object, \"method\");\n// Later: expect(spy).toHaveBeenCalledWith(\"arg\");\n\n// 3. Mock with implementation\nconst mockFn = mock(() => \"mocked value\");\n\n// 4. Restore after test\nafterEach(() => {\n  mock.restore();\n});","parameters":[{"name":"modulePath","type":"string","description":"Path to module to mock","required":true}],"verification":{"type":"none"},"examples":[],"tags":["test","mock","stub"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-write-integration-test-v1","name":"Write Integration Test","version":"v1","description":"Create integration tests that test multiple components working together","category":"testing","status":"active","code":"import { describe, test, expect, beforeAll, afterAll } from \"bun:test\";\n\ndescribe(\"Integration: Feature X\", () => {\n  let server: ReturnType<typeof Bun.serve>;\n  let db: Database;\n\n  beforeAll(async () => {\n    // Setup test fixtures\n    db = new Database(\":memory:\");\n    server = Bun.serve({\n      port: 0, // Random port\n      fetch: handler,\n    });\n  });\n\n  afterAll(async () => {\n    // Cleanup\n    server.stop();\n    db.close();\n  });\n\n  test(\"complete user flow\", async () => {\n    // 1. Create user\n    const createRes = await fetch(`http://localhost:${server.port}/users`, {\n      method: \"POST\",\n      body: JSON.stringify({ name: \"Test\" }),\n    });\n    expect(createRes.status).toBe(201);\n\n    // 2. Get user\n    const getRes = await fetch(`http://localhost:${server.port}/users/1`);\n    const user = await getRes.json();\n    expect(user.name).toBe(\"Test\");\n  });\n});","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["test","integration"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-write-snapshot-test-v1","name":"Write Snapshot Test","version":"v1","description":"Create snapshot tests for complex output validation","category":"testing","status":"active","code":"import { test, expect } from \"bun:test\";\n\ntest(\"component renders correctly\", () => {\n  const output = renderComponent({ prop: \"value\" });\n  expect(output).toMatchSnapshot();\n});\n\n// Update snapshots when output changes intentionally:\n// bun test --update-snapshots\n\n// Tips:\n// - Use for complex objects/structures\n// - Review snapshot diffs carefully\n// - Keep snapshots small and focused","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["test","snapshot"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-create-feature-branch-v1","name":"Create Feature Branch","version":"v1","description":"Create a new feature branch following project conventions and push to remote","category":"git","status":"active","code":"// 1. Ensure clean working directory\nconst status = await $`git status --porcelain`.text();\nif (status.trim()) {\n  console.log(\"Working directory not clean. Stash or commit changes first.\");\n  return;\n}\n\n// 2. Update main branch\nawait $`git checkout main && git pull origin main`;\n\n// 3. Create feature branch with conventional name\nconst branchName = `feat/${featureName.toLowerCase().replace(/\\s+/g, '-')}`;\nawait $`git checkout -b ${branchName}`;\n\n// 4. Push and set upstream\nawait $`git push -u origin ${branchName}`;\n\nconsole.log(`Created and pushed branch: ${branchName}`);","parameters":[{"name":"featureName","type":"string","description":"Short name for the feature","required":true}],"verification":{"type":"none"},"examples":[],"tags":["git","branch","workflow"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-create-pull-request-v1","name":"Create Pull Request","version":"v1","description":"Create a GitHub PR with proper title, description, and reviewers using gh CLI","category":"git","status":"active","code":"// 1. Ensure all changes are committed\nconst status = await $`git status --porcelain`.text();\nif (status.trim()) {\n  await $`git add -A && git commit -m \"WIP: pending changes\"`;\n}\n\n// 2. Push current branch\nconst branch = (await $`git branch --show-current`.text()).trim();\nawait $`git push -u origin ${branch}`;\n\n// 3. Create PR using gh CLI\nconst prBody = body || `\n## Summary\n- Add summary of changes here\n\n## Test Plan\n- [ ] Unit tests pass\n- [ ] Manual testing completed\n\n`;\n\nawait $`gh pr create --title \"${title}\" --body \"${prBody}\"`;","parameters":[{"name":"title","type":"string","description":"PR title","required":true},{"name":"body","type":"string","description":"PR description","required":false}],"verification":{"type":"none"},"examples":[],"tags":["git","github","pr"],"successRate":0.2,"usageCount":1,"lastUsed":"2025-12-08T06:03:04.454Z","createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:03:04.454Z","source":"bootstrap"}
{"id":"skill-resolve-git-conflict-v1","name":"Resolve Git Conflict","version":"v1","description":"Identify and resolve git merge conflicts by analyzing conflict markers and choosing appropriate resolution","category":"git","status":"active","code":"// 1. Read file and identify conflict markers\nconst content = await Bun.file(conflictFile).text();\nconst hasConflicts = content.includes('<<<<<<<');\n\n// 2. Parse conflict sections\n// <<<<<<< HEAD (current branch)\n// =======\n// >>>>>>> branch-name (incoming)\n\n// 3. Resolution strategies:\n// a) Keep ours: git checkout --ours <file>\n// b) Keep theirs: git checkout --theirs <file>\n// c) Manual merge: Edit file to combine changes\n\n// 4. After resolving, mark as resolved\nawait $`git add ${conflictFile}`;\n\n// 5. Continue merge/rebase if applicable\n// git merge --continue or git rebase --continue","parameters":[{"name":"conflictFile","type":"path","description":"File with merge conflict","required":true}],"verification":{"type":"none"},"examples":[],"tags":["git","merge","conflict"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-cherry-pick-commit-v1","name":"Cherry Pick Commit","version":"v1","description":"Apply specific commits from one branch to another","category":"git","status":"active","code":"// 1. Switch to target branch\nawait $`git checkout target-branch`;\n\n// 2. Cherry-pick the commit\nawait $`git cherry-pick ${commitSha}`;\n\n// 3. If conflicts occur:\n// - Resolve conflicts in affected files\n// - git add <resolved-files>\n// - git cherry-pick --continue\n\n// 4. To abort if needed:\n// git cherry-pick --abort","parameters":[{"name":"commitSha","type":"string","description":"SHA of commit to cherry-pick","required":true}],"verification":{"type":"none"},"examples":[],"tags":["git","cherry-pick"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-git-bisect-bug-v1","name":"Git Bisect Bug","version":"v1","description":"Use git bisect to find the commit that introduced a bug","category":"git","status":"active","code":"// 1. Start bisect\nawait $`git bisect start`;\n\n// 2. Mark current (bad) commit\nawait $`git bisect bad`;\n\n// 3. Mark known good commit\nawait $`git bisect good <commit-sha>`;\n\n// 4. Test each suggested commit:\n// - Run your test\n// - git bisect good OR git bisect bad\n\n// 5. Automate with script:\nawait $`git bisect run bun test path/to/failing-test.ts`;\n\n// 6. When done:\nawait $`git bisect reset`;","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["git","debugging","bisect"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-revert-commit-v1","name":"Revert Commit","version":"v1","description":"Safely revert a commit while preserving history","category":"git","status":"active","code":"// 1. Revert creates a new commit that undoes changes\nawait $`git revert ${commitSha}`;\n\n// 2. If reverting a merge commit:\nawait $`git revert -m 1 ${commitSha}`;\n// -m 1 means keep the first parent (usually main branch)\n\n// 3. To revert without committing (for review):\nawait $`git revert --no-commit ${commitSha}`;\n\n// 4. After review, commit:\nawait $`git commit -m \"Revert: reason for reverting\"`;","parameters":[{"name":"commitSha","type":"string","description":"SHA of commit to revert","required":true}],"verification":{"type":"none"},"examples":[],"tags":["git","revert"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-extract-function-v1","name":"Extract Function","version":"v1","description":"Extract a block of code into a reusable function with proper parameters and return type","category":"refactoring","status":"active","code":"// 1. Read the source file\nconst content = await Bun.file(sourceFile).text();\nconst lines = content.split(\"\\n\");\n\n// 2. Extract the code block\nconst codeBlock = lines.slice(startLine - 1, endLine).join(\"\\n\");\n\n// 3. Analyze dependencies\n// - Variables used but not declared (become parameters)\n// - Variables declared and used later (become return values)\n// - External imports needed\n\n// 4. Generate function signature\nconst func = `\nexport function ${functionName}(/* params */): /* returnType */ {\n  ${codeBlock}\n}\n`;\n\n// 5. Replace original code with function call\n// 6. Add function to appropriate location (same file or new module)\n// 7. Update imports if extracted to new file","parameters":[{"name":"sourceFile","type":"path","description":"File containing code to extract","required":true},{"name":"startLine","type":"number","description":"Start line of code block","required":true},{"name":"endLine","type":"number","description":"End line of code block","required":true},{"name":"functionName","type":"string","description":"Name for the new function","required":true}],"verification":{"type":"none"},"examples":[],"tags":["refactor","function","code-quality"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-rename-symbol-v1","name":"Rename Symbol","version":"v1","description":"Safely rename a function, variable, or type across the entire codebase","category":"refactoring","status":"active","code":"// 1. Find all occurrences\nconst occurrences = await $`grep -rn \"\\b${oldName}\\b\" --include=\"*.ts\" --include=\"*.tsx\" .`.text();\n\n// 2. Categorize by type:\n// - Declarations (function/class/type/interface)\n// - Imports/exports\n// - References\n\n// 3. Perform replacements in correct order:\n// a) Update exports first\n// b) Update imports\n// c) Update local references\n\n// 4. Use word boundary matching to avoid partial matches\nawait $`find . -name \"*.ts\" -o -name \"*.tsx\" | xargs sed -i '' 's/\\b${oldName}\\b/${newName}/g'`;\n\n// 5. Verify with typecheck\nawait $`bun tsc --noEmit`;","parameters":[{"name":"oldName","type":"string","description":"Current symbol name","required":true},{"name":"newName","type":"string","description":"New symbol name","required":true}],"verification":{"type":"none"},"examples":[],"tags":["refactor","rename"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-convert-to-effect-v1","name":"Convert to Effect","version":"v1","description":"Convert Promise-based async code to Effect-TS patterns with proper error handling","category":"refactoring","status":"active","code":"// Effect-TS conversion patterns:\n\n// 1. Promise to Effect\n// Before: async function foo(): Promise<T>\n// After:  const foo = (): Effect.Effect<T, Error> =>\n\n// 2. try/catch to Effect.gen\n// Before:\n// try { const x = await something(); } catch (e) { ... }\n// After:\n// Effect.gen(function* () {\n//   const x = yield* Effect.tryPromise(() => something());\n// })\n\n// 3. Error types\n// Before: throw new Error(\"...\")\n// After: yield* Effect.fail(new CustomError(\"...\"))\n\n// 4. Services/Context\n// Before: const db = new Database();\n// After: const db = yield* Database;\n\n// 5. Layer composition\n// Build layers for dependency injection\n\n// Common imports needed:\n// import { Effect, Context, Layer, pipe } from \"effect\";","parameters":[{"name":"sourceFile","type":"path","description":"File to convert","required":true}],"verification":{"type":"none"},"examples":[],"tags":["effect","refactor","async"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-split-large-file-v1","name":"Split Large File","version":"v1","description":"Split a large file into smaller, focused modules while maintaining imports","category":"refactoring","status":"active","code":"// File splitting strategy:\n\n// 1. Identify logical groups\n// - Types/interfaces\n// - Constants\n// - Helper functions\n// - Main exports\n\n// 2. Create new files for each group\n// original/types.ts - Type definitions\n// original/utils.ts - Helper functions\n// original/index.ts - Main exports + re-exports\n\n// 3. Update imports in original file to use new modules\n// import { Type } from './types';\n// import { helper } from './utils';\n\n// 4. Create barrel export (index.ts)\nexport * from './types';\nexport * from './utils';\nexport { mainFunction } from './main';\n\n// 5. Update all external imports to use the barrel","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["refactor","modules","organization"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-inline-abstraction-v1","name":"Inline Abstraction","version":"v1","description":"Remove premature abstractions by inlining rarely-used helpers","category":"refactoring","status":"active","code":"// When to inline:\n// - Helper is used only once\n// - Abstraction adds more complexity than it removes\n// - Name doesn't add clarity\n\n// Steps:\n// 1. Find all usages of the abstraction\nconst usages = await $`grep -rn \"helperName\" --include=\"*.ts\" .`.text();\n\n// 2. If used only once, inline the implementation\n// 3. If used 2-3 times but simple, consider inlining\n\n// 4. Remove the helper function after inlining all usages\n// 5. Run typecheck to verify\nawait $`bun tsc --noEmit`;","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["refactor","simplify"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-generate-type-from-json-v1","name":"Generate Type from JSON","version":"v1","description":"Generate TypeScript type definitions from JSON data samples","category":"file_operations","status":"active","code":"// 1. Parse JSON\nconst data = JSON.parse(jsonSample);\n\n// 2. Infer types from values\nfunction inferType(value: unknown): string {\n  if (value === null) return 'null';\n  if (Array.isArray(value)) {\n    if (value.length === 0) return 'unknown[]';\n    return `${inferType(value[0])}[]`;\n  }\n  if (typeof value === 'object') {\n    const props = Object.entries(value)\n      .map(([k, v]) => `  ${k}: ${inferType(v)};`)\n      .join('\\n');\n    return `{\\n${props}\\n}`;\n  }\n  return typeof value;\n}\n\n// 3. Generate type definition\nconst typeDef = `export interface ${typeName} ${inferType(data)}`;\n\nconsole.log(typeDef);","parameters":[{"name":"jsonSample","type":"string","description":"JSON string or path to JSON file","required":true},{"name":"typeName","type":"string","description":"Name for the generated type","required":true}],"verification":{"type":"none"},"examples":[],"tags":["typescript","types","json"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-scaffold-react-component-v1","name":"Scaffold React Component","version":"v1","description":"Create a new React component with proper TypeScript types, tests, and story files","category":"file_operations","status":"active","code":"// Create component directory structure\nconst dir = `${componentDir}/${componentName}`;\nawait $`mkdir -p ${dir}`;\n\n// Component file\nconst componentCode = `\nimport React from 'react';\n\nexport interface ${componentName}Props {\n  // Add props here\n}\n\nexport function ${componentName}({ }: ${componentName}Props) {\n  return (\n    <div>\n      {${componentName}}\n    </div>\n  );\n}\n`;\nawait Bun.write(`${dir}/${componentName}.tsx`, componentCode);\n\n// Test file\nconst testCode = `\nimport { describe, test, expect } from \"bun:test\";\nimport { render } from \"@testing-library/react\";\nimport { ${componentName} } from \"./${componentName}\";\n\ndescribe(\"${componentName}\", () => {\n  test(\"renders without crashing\", () => {\n    const { container } = render(<${componentName} />);\n    expect(container).toBeTruthy();\n  });\n});\n`;\nawait Bun.write(`${dir}/${componentName}.test.tsx`, testCode);\n\n// Index file for easy imports\nawait Bun.write(`${dir}/index.ts`, `export * from './${componentName}';`);","parameters":[{"name":"componentName","type":"string","description":"Name of the component (PascalCase)","required":true},{"name":"componentDir","type":"path","description":"Directory for the component","required":true}],"verification":{"type":"none"},"examples":[],"tags":["react","component","scaffold"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-generate-api-client-v1","name":"Generate API Client","version":"v1","description":"Generate a type-safe API client from OpenAPI spec or endpoint definitions","category":"file_operations","status":"active","code":"// Generate typed API client\n\nconst clientCode = `\nconst BASE_URL = \"${baseUrl}\";\n\nasync function request<T>(path: string, options?: RequestInit): Promise<T> {\n  const res = await fetch(`${BASE_URL}${path}`, {\n    ...options,\n    headers: {\n      'Content-Type': 'application/json',\n      ...options?.headers,\n    },\n  });\n  if (!res.ok) throw new Error(`API error: ${res.status}`);\n  return res.json();\n}\n\nexport const api = {\n  // Generated from endpoints\n  get: <T>(path: string) => request<T>(path, { method: 'GET' }),\n  post: <T>(path: string, body: unknown) => request<T>(path, {\n    method: 'POST',\n    body: JSON.stringify(body),\n  }),\n  put: <T>(path: string, body: unknown) => request<T>(path, {\n    method: 'PUT',\n    body: JSON.stringify(body),\n  }),\n  delete: (path: string) => request<void>(path, { method: 'DELETE' }),\n};\n`;\n\nawait Bun.write(\"api-client.ts\", clientCode);","parameters":[{"name":"baseUrl","type":"string","description":"Base URL for the API","required":true},{"name":"endpoints","type":"string","description":"JSON array of endpoint definitions","required":true}],"verification":{"type":"none"},"examples":[],"tags":["api","typescript","client"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-profile-code-performance-v1","name":"Profile Code Performance","version":"v1","description":"Profile code execution to identify performance bottlenecks","category":"debugging","status":"active","code":"// Bun built-in profiling\n\n// 1. Run with profiling enabled\nawait $`bun --smol ${targetFile}`;\n\n// 2. Use console.time for specific sections\n// console.time('operation');\n// ... code ...\n// console.timeEnd('operation');\n\n// 3. Memory profiling\n// const mem1 = process.memoryUsage();\n// ... code ...\n// const mem2 = process.memoryUsage();\n// console.log('Memory delta:', mem2.heapUsed - mem1.heapUsed);\n\n// 4. Identify hot paths\n// - Look for loops with many iterations\n// - Check for unnecessary allocations\n// - Review async operation batching","parameters":[{"name":"targetFile","type":"path","description":"File to profile","required":true}],"verification":{"type":"none"},"examples":[],"tags":["performance","profiling"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-optimize-imports-v1","name":"Optimize Imports","version":"v1","description":"Remove unused imports and organize remaining imports by type","category":"refactoring","status":"active","code":"// 1. Identify unused imports using TypeScript compiler\n// bun tsc --noEmit will report unused imports with noUnusedLocals\n\n// 2. Parse imports\nconst content = await Bun.file(targetFile).text();\nconst importLines = content.match(/^import .* from .*;?$/gm) || [];\n\n// 3. Categorize imports:\n// - Node built-ins (node:*)\n// - External packages\n// - Internal aliases (@/*)\n// - Relative imports (./)\n\n// 4. Sort and group\n// - Remove duplicates\n// - Combine named imports from same source\n// - Order: built-ins, external, internal, relative\n\n// 5. Rewrite import section","parameters":[{"name":"targetFile","type":"path","description":"File to optimize","required":true}],"verification":{"type":"none"},"examples":[],"tags":["imports","cleanup","performance"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-implement-cache-v1","name":"Implement Cache","version":"v1","description":"Add caching layer with TTL and LRU eviction","category":"performance","status":"active","code":"// Simple cache with TTL\n\nclass Cache<T> {\n  private store = new Map<string, { value: T; expiresAt: number }>();\n  private maxSize: number;\n\n  constructor(maxSize: number = 1000) {\n    this.maxSize = maxSize;\n  }\n\n  get(key: string): T | undefined {\n    const entry = this.store.get(key);\n    if (!entry) return undefined;\n\n    if (Date.now() > entry.expiresAt) {\n      this.store.delete(key);\n      return undefined;\n    }\n\n    return entry.value;\n  }\n\n  set(key: string, value: T, ttlMs: number = 60000): void {\n    // Evict oldest if at capacity\n    if (this.store.size >= this.maxSize) {\n      const oldest = this.store.keys().next().value;\n      this.store.delete(oldest);\n    }\n\n    this.store.set(key, {\n      value,\n      expiresAt: Date.now() + ttlMs,\n    });\n  }\n\n  delete(key: string): boolean {\n    return this.store.delete(key);\n  }\n}\n\nconst cache = new Cache<string>();","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["cache","performance"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-generate-jsdoc-v1","name":"Generate JSDoc","version":"v1","description":"Generate JSDoc comments for functions and classes based on their implementation","category":"documentation","status":"active","code":"// 1. Parse file for function/class declarations\nconst content = await Bun.file(targetFile).text();\n\n// 2. For each declaration, generate JSDoc:\n// /**\n//  * Description based on function name and body\n//  * @param {Type} name - Description\n//  * @returns {Type} Description\n//  * @throws {Error} When condition\n//  * @example\n//  * const result = functionName(arg);\n//  */\n\n// 3. Consider:\n// - Parameter types and names\n// - Return type\n// - Thrown errors\n// - Side effects\n// - Usage examples","parameters":[{"name":"targetFile","type":"path","description":"File to document","required":true}],"verification":{"type":"none"},"examples":[],"tags":["jsdoc","documentation"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-audit-dependencies-v1","name":"Audit Dependencies","version":"v1","description":"Check dependencies for known vulnerabilities and outdated packages","category":"security","status":"active","code":"// 1. Check for vulnerabilities\nawait $`bun pm audit`;\n\n// 2. List outdated packages\nawait $`bun outdated`;\n\n// 3. Review package.json for:\n// - Pinned versions vs ranges\n// - Unused dependencies\n// - Dev vs prod dependencies\n\n// 4. Check for malicious packages\n// - Verify package publishers\n// - Check download counts\n// - Review changelogs for major updates","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["security","dependencies","audit"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-sanitize-user-input-v1","name":"Sanitize User Input","version":"v1","description":"Add proper input validation and sanitization for user-provided data","category":"security","status":"active","code":"// Input sanitization patterns:\n\n// 1. String sanitization\nconst sanitizeString = (input: string): string => {\n  return input\n    .trim()\n    .replace(/[<>]/g, '') // Remove HTML tags\n    .slice(0, 1000); // Limit length\n};\n\n// 2. Email validation\nconst isValidEmail = (email: string): boolean => {\n  const pattern = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return pattern.test(email);\n};\n\n// 3. URL validation\nconst isValidUrl = (url: string): boolean => {\n  try {\n    new URL(url);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n// 4. SQL injection prevention\n// Use parameterized queries, never string concatenation\n\n// 5. Path traversal prevention\nconst safePath = (path: string): string => {\n  return path.replace(/\\.\\.\\//g, '').replace(/^\\//, '');\n};","parameters":[{"name":"inputType","type":"string","description":"Type of input (string, email, url, etc.)","required":true}],"verification":{"type":"none"},"examples":[],"tags":["security","validation","input"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-setup-bun-project-v1","name":"Setup Bun Project","version":"v1","description":"Initialize a new Bun project with TypeScript, testing, and common configurations","category":"file_operations","status":"active","code":"// 1. Initialize project\nawait $`mkdir -p ${projectName} && cd ${projectName}`;\nawait $`bun init -y`;\n\n// 2. Add TypeScript config\nconst tsconfig = {\n  compilerOptions: {\n    target: \"ES2022\",\n    module: \"ESNext\",\n    moduleResolution: \"bundler\",\n    strict: true,\n    skipLibCheck: true,\n    types: [\"bun-types\"],\n  },\n};\nawait Bun.write(\"tsconfig.json\", JSON.stringify(tsconfig, null, 2));\n\n// 3. Add common dependencies\nawait $`bun add -d typescript bun-types`;\n\n// 4. Create source structure\nawait $`mkdir -p src tests`;\nawait Bun.write(\"src/index.ts\", 'console.log(\"Hello from Bun!\");');\n\n// 5. Add scripts to package.json","parameters":[{"name":"projectName","type":"string","description":"Name of the project","required":true}],"verification":{"type":"none"},"examples":[],"tags":["bun","setup","project"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-create-dockerfile-v1","name":"Create Dockerfile","version":"v1","description":"Generate an optimized Dockerfile for Bun applications","category":"file_operations","status":"active","code":"const dockerfile = `\nFROM oven/bun:1 as builder\n\nWORKDIR /app\nCOPY package.json bun.lockb ./\nRUN bun install --frozen-lockfile\n\nCOPY . .\nRUN bun run build\n\nFROM oven/bun:1-slim\nWORKDIR /app\nCOPY --from=builder /app/dist ./dist\nCOPY --from=builder /app/package.json ./\n\nUSER bun\nEXPOSE 3000\nCMD [\"bun\", \"run\", \"dist/index.js\"]\n`;\n\nawait Bun.write(\"Dockerfile\", dockerfile);\n\n// Also create .dockerignore\nconst dockerignore = `\nnode_modules\n.git\n*.log\n.env*\ndist\n`;\nawait Bun.write(\".dockerignore\", dockerignore);","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["docker","deployment"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-create-effect-service-v1","name":"Create Effect Service","version":"v1","description":"Create an Effect-TS service with proper Context.Tag, interface, implementation, and Layer","category":"file_operations","status":"active","code":"// Effect Service Template\n\nconst serviceTemplate = `\nimport { Effect, Context, Layer } from \"effect\";\n\n// --- Interface ---\n\nexport interface I${serviceName} {\n  readonly doSomething: (input: string) => Effect.Effect<string, ${serviceName}Error>;\n}\n\n// --- Error Type ---\n\nexport class ${serviceName}Error extends Error {\n  readonly _tag = \"${serviceName}Error\";\n  constructor(\n    readonly reason: string,\n    message: string,\n    readonly cause?: Error,\n  ) {\n    super(message);\n    this.name = \"${serviceName}Error\";\n  }\n}\n\n// --- Service Tag ---\n\nexport class ${serviceName} extends Context.Tag(\"${serviceName}\")<\n  ${serviceName},\n  I${serviceName}\n>() {}\n\n// --- Implementation ---\n\nconst make${serviceName} = (): I${serviceName} => ({\n  doSomething: (input) =>\n    Effect.gen(function* () {\n      // Implementation here\n      return \\`Processed: \\${input}\\`;\n    }),\n});\n\n// --- Layer ---\n\nexport const ${serviceName}Live: Layer.Layer<${serviceName}> =\n  Layer.succeed(${serviceName}, make${serviceName}());\n`;\n\nawait Bun.write(`src/${serviceName.toLowerCase()}.ts`, serviceTemplate);","parameters":[{"name":"serviceName","type":"string","description":"Name of the service (PascalCase)","required":true}],"verification":{"type":"none"},"examples":[],"tags":["effect","service","dependency-injection"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-handle-effect-error-v1","name":"Handle Effect Error","version":"v1","description":"Add proper error handling and recovery to Effect-TS code","category":"file_operations","status":"active","code":"// Effect error handling patterns:\n\n// 1. Map error types\nEffect.mapError((e) => new MyError(\"wrapped\", e.message));\n\n// 2. Catch specific errors\nEffect.catchTag(\"NetworkError\", (e) =>\n  Effect.succeed(fallbackValue)\n);\n\n// 3. Catch all errors\nEffect.catchAll((e) =>\n  Effect.logError(\"Failed\", e).pipe(\n    Effect.flatMap(() => Effect.fail(e))\n  )\n);\n\n// 4. Retry with backoff\nEffect.retry(\n  Schedule.exponential(\"100 millis\").pipe(\n    Schedule.compose(Schedule.recurs(3))\n  )\n);\n\n// 5. Provide fallback\nEffect.orElse(() => Effect.succeed(defaultValue));\n\n// 6. Ensure cleanup\nEffect.ensuring(cleanup());","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["effect","error-handling"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-create-database-migration-v1","name":"Create Database Migration","version":"v1","description":"Create a database migration file with up and down functions","category":"file_operations","status":"active","code":"// Create timestamped migration file\nconst timestamp = Date.now();\nconst fileName = `${timestamp}_${migrationName.toLowerCase().replace(/\\s+/g, '_')}.ts`;\n\nconst migrationTemplate = `\nimport { Database } from \"bun:sqlite\";\n\nexport const up = (db: Database) => {\n  db.run(\\`\n    CREATE TABLE IF NOT EXISTS table_name (\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\n      created_at TEXT DEFAULT CURRENT_TIMESTAMP,\n      updated_at TEXT DEFAULT CURRENT_TIMESTAMP\n    )\n  \\`);\n};\n\nexport const down = (db: Database) => {\n  db.run(\\`DROP TABLE IF EXISTS table_name\\`);\n};\n`;\n\nawait Bun.write(`migrations/${fileName}`, migrationTemplate);\nconsole.log(`Created migration: migrations/${fileName}`);","parameters":[{"name":"migrationName","type":"string","description":"Name describing the migration","required":true}],"verification":{"type":"none"},"examples":[],"tags":["database","migration","sqlite"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-debug-async-issue-v1","name":"Debug Async Issue","version":"v1","description":"Debug async/await issues by tracing promise chains and identifying race conditions","category":"debugging","status":"active","code":"// Common async issues and fixes:\n\n// 1. Missing await\n// Before: const data = fetchData();\n// After: const data = await fetchData();\n\n// 2. Race conditions\n// Use Promise.all for parallel, sequential for dependencies\nconst [a, b] = await Promise.all([fetchA(), fetchB()]);\nconst c = await fetchC(a); // depends on a\n\n// 3. Unhandled rejections\nprocess.on('unhandledRejection', (reason) => {\n  console.error('Unhandled:', reason);\n});\n\n// 4. Timeout handling\nconst withTimeout = <T>(promise: Promise<T>, ms: number): Promise<T> =>\n  Promise.race([\n    promise,\n    new Promise((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), ms)\n    )\n  ]);","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["async","debugging","promises"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-trace-memory-leak-v1","name":"Trace Memory Leak","version":"v1","description":"Identify and fix memory leaks by analyzing object retention and garbage collection","category":"debugging","status":"active","code":"// Memory leak detection patterns:\n\n// 1. Track heap snapshots\nconst before = process.memoryUsage().heapUsed;\n// ... operation ...\nconst after = process.memoryUsage().heapUsed;\nconsole.log('Memory delta:', (after - before) / 1024 / 1024, 'MB');\n\n// 2. Common leak sources:\n// - Event listeners not removed\n// - Closures capturing large objects\n// - Growing arrays/maps without cleanup\n// - Circular references\n\n// 3. Fix patterns:\n// - Use WeakMap/WeakSet for caches\n// - Implement dispose/cleanup methods\n// - Remove event listeners in cleanup\n// - Use AbortController for cancellation","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["memory","debugging","performance"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-handle-api-errors-v1","name":"Handle API Errors","version":"v1","description":"Implement proper error handling for API endpoints with status codes","category":"file_operations","status":"active","code":"// API Error handling pattern\n\nclass ApiError extends Error {\n  constructor(\n    public statusCode: number,\n    message: string,\n    public details?: unknown,\n  ) {\n    super(message);\n    this.name = 'ApiError';\n  }\n}\n\n// Error response helper\nconst errorResponse = (error: ApiError) =>\n  new Response(\n    JSON.stringify({\n      error: error.message,\n      details: error.details,\n    }),\n    {\n      status: error.statusCode,\n      headers: { 'Content-Type': 'application/json' },\n    }\n  );\n\n// Usage in handler\ntry {\n  // ... handle request\n} catch (e) {\n  if (e instanceof ApiError) {\n    return errorResponse(e);\n  }\n  return errorResponse(new ApiError(500, 'Internal Server Error'));\n}","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["api","error-handling","http"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-validate-api-input-v1","name":"Validate API Input","version":"v1","description":"Validate request body, query params, and headers for API endpoints","category":"file_operations","status":"active","code":"// API Input validation pattern\n\ninterface ValidationResult<T> {\n  success: boolean;\n  data?: T;\n  errors?: string[];\n}\n\nfunction validateBody<T>(\n  body: unknown,\n  schema: {\n    [K in keyof T]: (value: unknown) => value is T[K];\n  }\n): ValidationResult<T> {\n  if (!body || typeof body !== 'object') {\n    return { success: false, errors: ['Body must be an object'] };\n  }\n\n  const errors: string[] = [];\n  const result = {} as T;\n\n  for (const [key, validator] of Object.entries(schema)) {\n    const value = (body as Record<string, unknown>)[key];\n    if (!validator(value)) {\n      errors.push(`Invalid ${key}`);\n    } else {\n      (result as Record<string, unknown>)[key] = value;\n    }\n  }\n\n  return errors.length ? { success: false, errors } : { success: true, data: result };\n}","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["api","validation","security"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-implement-rate-limiting-v1","name":"Implement Rate Limiting","version":"v1","description":"Add rate limiting to API endpoints to prevent abuse","category":"file_operations","status":"active","code":"// Simple in-memory rate limiter\n\nconst rateLimits = new Map<string, { count: number; resetAt: number }>();\n\nfunction rateLimit(\n  key: string,\n  limit: number = 100,\n  windowMs: number = 60000\n): { allowed: boolean; remaining: number; resetAt: number } {\n  const now = Date.now();\n  let entry = rateLimits.get(key);\n\n  if (!entry || now > entry.resetAt) {\n    entry = { count: 0, resetAt: now + windowMs };\n    rateLimits.set(key, entry);\n  }\n\n  entry.count++;\n\n  return {\n    allowed: entry.count <= limit,\n    remaining: Math.max(0, limit - entry.count),\n    resetAt: entry.resetAt,\n  };\n}\n\n// Usage in handler\nconst clientIp = request.headers.get('x-forwarded-for') || 'unknown';\nconst { allowed, remaining, resetAt } = rateLimit(clientIp);\n\nif (!allowed) {\n  return new Response('Too Many Requests', {\n    status: 429,\n    headers: {\n      'X-RateLimit-Remaining': String(remaining),\n      'X-RateLimit-Reset': String(resetAt),\n    },\n  });\n}","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["api","security","rate-limit"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-parse-cli-arguments-v1","name":"Parse CLI Arguments","version":"v1","description":"Parse command line arguments with flags, options, and positional args","category":"shell","status":"active","code":"// Simple CLI argument parser\n\ninterface CliOptions {\n  flags: Record<string, boolean>;\n  options: Record<string, string>;\n  positional: string[];\n}\n\nfunction parseArgs(args: string[]): CliOptions {\n  const result: CliOptions = { flags: {}, options: {}, positional: [] };\n\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n\n    if (arg.startsWith('--')) {\n      const key = arg.slice(2);\n      if (args[i + 1] && !args[i + 1].startsWith('-')) {\n        result.options[key] = args[++i];\n      } else {\n        result.flags[key] = true;\n      }\n    } else if (arg.startsWith('-')) {\n      result.flags[arg.slice(1)] = true;\n    } else {\n      result.positional.push(arg);\n    }\n  }\n\n  return result;\n}\n\n// Usage:\nconst { flags, options, positional } = parseArgs(Bun.argv.slice(2));","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["cli","args","parsing"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-create-cli-command-v1","name":"Create CLI Command","version":"v1","description":"Create a new CLI command with help text and argument validation","category":"shell","status":"active","code":"// CLI command template\n\nconst HELP = `\nUsage: bun ${commandName} [options] <arg>\n\nOptions:\n  --help, -h     Show this help\n  --verbose, -v  Verbose output\n  --output, -o   Output file path\n\nExamples:\n  bun ${commandName} input.txt\n  bun ${commandName} --output result.txt input.txt\n`;\n\nconst args = Bun.argv.slice(2);\n\nif (args.includes('--help') || args.includes('-h')) {\n  console.log(HELP);\n  process.exit(0);\n}\n\n// Parse and validate arguments\nconst verbose = args.includes('--verbose') || args.includes('-v');\nconst outputIndex = args.findIndex(a => a === '--output' || a === '-o');\nconst output = outputIndex >= 0 ? args[outputIndex + 1] : undefined;\nconst input = args.filter(a => !a.startsWith('-'))[0];\n\nif (!input) {\n  console.error('Error: Input file required');\n  process.exit(1);\n}","parameters":[{"name":"commandName","type":"string","description":"Name of the command","required":true}],"verification":{"type":"none"},"examples":[],"tags":["cli","command"],"successRate":0.2,"usageCount":1,"lastUsed":"2025-12-08T06:03:04.453Z","createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:03:04.453Z","source":"bootstrap"}
{"id":"skill-handle-websocket-connection-v1","name":"Handle WebSocket Connection","version":"v1","description":"Implement WebSocket connection handling with message routing","category":"file_operations","status":"active","code":"// WebSocket handling with Bun.serve\n\nBun.serve({\n  websocket: {\n    open(ws) {\n      console.log('Client connected');\n      ws.subscribe('global'); // Subscribe to broadcast channel\n    },\n\n    message(ws, message) {\n      const data = JSON.parse(message as string);\n\n      switch (data.type) {\n        case 'ping':\n          ws.send(JSON.stringify({ type: 'pong' }));\n          break;\n\n        case 'broadcast':\n          ws.publish('global', JSON.stringify(data));\n          break;\n\n        case 'subscribe':\n          ws.subscribe(data.channel);\n          break;\n\n        default:\n          ws.send(JSON.stringify({ error: 'Unknown message type' }));\n      }\n    },\n\n    close(ws) {\n      console.log('Client disconnected');\n    },\n  },\n});","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["websocket","realtime"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-load-configuration-v1","name":"Load Configuration","version":"v1","description":"Load configuration from environment, files, and defaults with validation","category":"file_operations","status":"active","code":"// Configuration loading pattern\n\ninterface Config {\n  port: number;\n  database: {\n    host: string;\n    port: number;\n    name: string;\n  };\n  debug: boolean;\n}\n\nconst loadConfig = (): Config => {\n  // 1. Start with defaults\n  const config: Config = {\n    port: 3000,\n    database: {\n      host: 'localhost',\n      port: 5432,\n      name: 'app',\n    },\n    debug: false,\n  };\n\n  // 2. Load from config file if exists\n  try {\n    const fileConfig = JSON.parse(\n      await Bun.file('config.json').text()\n    );\n    Object.assign(config, fileConfig);\n  } catch { /* no config file */ }\n\n  // 3. Override with environment variables\n  if (process.env.PORT) config.port = parseInt(process.env.PORT);\n  if (process.env.DB_HOST) config.database.host = process.env.DB_HOST;\n  if (process.env.DEBUG === 'true') config.debug = true;\n\n  // 4. Validate required values\n  if (!config.database.host) {\n    throw new Error('Database host is required');\n  }\n\n  return config;\n};","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["config","environment"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
{"id":"skill-structured-logging-v1","name":"Structured Logging","version":"v1","description":"Implement structured JSON logging for production applications","category":"file_operations","status":"active","code":"// Structured logging helper\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\ninterface LogEntry {\n  timestamp: string;\n  level: LogLevel;\n  message: string;\n  [key: string]: unknown;\n}\n\nconst log = (level: LogLevel, message: string, meta?: Record<string, unknown>) => {\n  const entry: LogEntry = {\n    timestamp: new Date().toISOString(),\n    level,\n    message,\n    ...meta,\n  };\n\n  const output = JSON.stringify(entry);\n\n  if (level === 'error') {\n    console.error(output);\n  } else {\n    console.log(output);\n  }\n};\n\n// Usage:\nlog('info', 'Request handled', { path: '/api/users', duration: 45 });\nlog('error', 'Database connection failed', { error: err.message, retryIn: 5000 });","parameters":[],"verification":{"type":"none"},"examples":[],"tags":["logging","observability"],"createdAt":"2025-12-08T06:02:19.711Z","updatedAt":"2025-12-08T06:02:19.711Z","source":"bootstrap"}
