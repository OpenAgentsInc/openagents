{
  "taskId": "oa-254afa",
  "taskTitle": "Add orchestrator phase checkpoints for crash recovery",
  "subtasks": [
    {
      "id": "oa-254afa-sub-001",
      "description": "Implement: Add orchestrator phase checkpoints for crash recovery\n\n## Background\n\nThe Golden Loop orchestrator executes multiple phases:\n```\nOrient → Select Task → Decompose → Execute Subtasks → Verify → Commit → Update → Log\n```\n\nCurrently, if the orchestrator crashes mid-execution, it must restart from the beginning. There's no mechanism to resume from the last successful phase.\n\nIn durable execution systems (Temporal, Restate, DBOS), workflows persist state at key points (\"checkpoints\") so they can resume from the last checkpoint after a crash.\n\n## Current State\n\nSome state IS persisted:\n- `progress.md` - Human-readable session summary\n- `.openagents/subtasks/{taskId}.json` - Subtask status\n- Claude Code `sessionId` - For LLM conversation resumption\n\nBut there's no formal checkpoint that captures:\n- Current orchestrator phase\n- Task being worked on\n- Git state at checkpoint time\n- Verification results\n\n## Proposed Solution\n\n### Checkpoint Schema\n\n```typescript\n// src/agent/orchestrator/checkpoint.ts\ninterface OrchestratorCheckpoint {\n  version: 1;\n  sessionId: string;\n  timestamp: string;\n  \n  // Current position in workflow\n  phase: OrchestratorPhase;\n  phaseStartedAt: string;\n  \n  // Task context\n  taskId: string;\n  taskTitle: string;\n  \n  // Subtask progress\n  completedSubtaskIds: string[];\n  currentSubtaskId: string | null;\n  \n  // Git state\n  git: {\n    branch: string;\n    headCommit: string;\n    isDirty: boolean;\n    stagedFiles: string[];\n  };\n  \n  // Verification results (if past verify phase)\n  verification?: {\n    typecheckPassed: boolean;\n    testsPassed: boolean;\n    verifiedAt: string;\n  };\n  \n  // Healer invocations in this session\n  healerInvocations: Array<{\n    scenario: string;\n    outcome: string;\n    timestamp: string;\n  }>;\n}\n\ntype OrchestratorPhase = \n  | \"init\"\n  | \"orient\"\n  | \"select_task\"\n  | \"decompose\"\n  | \"execute_subtasks\"\n  | \"verify\"\n  | \"commit\"\n  | \"update_task\"\n  | \"log\"\n  | \"complete\";\n```\n\n### Checkpoint Persistence\n\n```typescript\n// Write checkpoint at each phase transition\nconst writeCheckpoint = (checkpoint: OrchestratorCheckpoint) =>\n  Effect.gen(function* () {\n    const path = `${config.cwd}/.openagents/checkpoint.json`;\n    const tempPath = `${path}.tmp`;\n    \n    // Atomic write: write to temp, then rename\n    yield* fs.writeFileString(tempPath, JSON.stringify(checkpoint, null, 2));\n    yield* fs.rename(tempPath, path);\n  });\n\n// Clear checkpoint on successful completion\nconst clearCheckpoint = () =>\n  Effect.gen(function* () {\n    const path = `${config.cwd}/.openagents/checkpoint.json`;\n    yield* fs.remove(path).pipe(Effect.ignore);\n  });\n```\n\n### Recovery on Startup\n\n```typescript\n// In orchestrator initialization\nconst maybeResume = Effect.gen(function* () {\n  const checkpointPath = `${config.cwd}/.openagents/checkpoint.json`;\n  \n  const checkpointExists = yield* fs.exists(checkpointPath);\n  if (!checkpointExists) return Option.none();\n  \n  const checkpoint = yield* fs.readFileString(checkpointPath)\n    .pipe(Effect.map(JSON.parse));\n  \n  // Validate checkpoint is recent (within last 24 hours)\n  const age = Date.now() - new Date(checkpoint.timestamp).getTime();\n  if (age > 24 * 60 * 60 * 1000) {\n    yield* clearCheckpoint();\n    return Option.none();\n  }\n  \n  // Offer to resume\n  return Option.some(checkpoint);\n});\n```\n\n### Phase-Specific Resume Logic\n\n```typescript\nconst resumeFromCheckpoint = (checkpoint: OrchestratorCheckpoint) =>\n  Effect.gen(function* () {\n    switch (checkpoint.phase) {\n      case \"execute_subtasks\":\n        // Skip completed subtasks, resume from current\n        return yield* executeSubtasksFromCheckpoint(checkpoint);\n        \n      case \"verify\":\n        // Re-run verification (it's idempotent)\n        return yield* runVerificationPhase(checkpoint.taskId);\n        \n      case \"commit\":\n        // Check if commit exists, skip if so\n        return yield* resumeCommitPhase(checkpoint);\n        \n      // ... other phases\n    }\n  });\n```\n\n## Implementation Plan\n\n1. **Define checkpoint schema** in new `src/agent/orchestrator/checkpoint.ts`\n\n2. **Add checkpoint writes** at each phase transition in `orchestrator.ts`:\n   - After `orient` completes\n   - After `select_task` returns task\n   - After `decompose` creates subtasks\n   - After each subtask completes\n   - After `verify` completes\n   - After `commit` (covered by separate task)\n   - After `update_task`\n\n3. **Add recovery logic** in orchestrator startup:\n   - Check for existing checkpoint\n   - Validate checkpoint (age, git state match)\n   - Resume from appropriate phase\n\n4. **Add checkpoint cleanup** on successful completion\n\n5. **Add tests** for checkpoint persistence and recovery\n\n## Files to Create/Modify\n\n- `src/agent/orchestrator/checkpoint.ts` (new) - Checkpoint types and helpers\n- `src/agent/orchestrator/orchestrator.ts` - Add checkpoint writes and recovery\n- `src/agent/orchestrator/types.ts` - OrchestratorPhase type\n- `src/agent/orchestrator/__tests__/checkpoint.test.ts` (new) - Tests\n\n## Acceptance Criteria\n\n- [ ] Checkpoint written at each phase transition\n- [ ] Checkpoint uses atomic write (temp file + rename)\n- [ ] Recovery detects and validates existing checkpoints\n- [ ] Orchestrator can resume from checkpoint after crash\n- [ ] Completed subtasks are not re-executed\n- [ ] Checkpoint cleared on successful completion\n- [ ] Stale checkpoints (>24h) are discarded\n- [ ] Tests verify recovery from each phase",
      "status": "done",
      "startedAt": "2025-12-04T21:15:59.754Z",
      "claudeCode": {
        "sessionId": "5d974e9d-6a25-4f6b-b4b4-4214d273b130"
      },
      "completedAt": "2025-12-04T21:30:48.852Z"
    },
    {
      "id": "oa-254afa-sub-002",
      "description": "Add tests for: Add orchestrator phase checkpoints for crash recovery\n\nVerify the implementation works correctly with unit tests.",
      "status": "done",
      "startedAt": "2025-12-04T21:30:48.856Z",
      "claudeCode": {
        "sessionId": "de533b02-a611-4c0f-a83f-14abac9ddd3c"
      },
      "completedAt": "2025-12-04T21:33:44.719Z"
    }
  ],
  "createdAt": "2025-12-04T21:15:59.751Z",
  "updatedAt": "2025-12-04T21:15:59.751Z"
}