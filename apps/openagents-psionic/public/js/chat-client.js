import {
  C,
  F,
  L,
  P,
  R,
  T,
  U,
  Vr,
  ce,
  h,
  or,
  u,
  ur,
  x
} from "./chat-client-8crq2eqy.js";
import {
  __export,
  __require,
  __toESM
} from "./chat-client-13a4mv5g.js";
// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/entity.js
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(`Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
  }
  let cls = Object.getPrototypeOf(value).constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/column.js
class Column {
  constructor(table, config) {
    this.table = table;
    this.config = config;
    this.name = config.name;
    this.keyAsName = config.keyAsName;
    this.notNull = config.notNull;
    this.default = config.default;
    this.defaultFn = config.defaultFn;
    this.onUpdateFn = config.onUpdateFn;
    this.hasDefault = config.hasDefault;
    this.primary = config.primaryKey;
    this.isUnique = config.isUnique;
    this.uniqueName = config.uniqueName;
    this.uniqueType = config.uniqueType;
    this.dataType = config.dataType;
    this.columnType = config.columnType;
    this.generated = config.generated;
    this.generatedIdentity = config.generatedIdentity;
  }
  static [entityKind] = "Column";
  name;
  keyAsName;
  primary;
  notNull;
  default;
  defaultFn;
  onUpdateFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = undefined;
  generated = undefined;
  generatedIdentity = undefined;
  config;
  mapFromDriverValue(value) {
    return value;
  }
  mapToDriverValue(value) {
    return value;
  }
  shouldDisableInsert() {
    return this.config.generated !== undefined && this.config.generated.type !== "byDefault";
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/column-builder.js
class ColumnBuilder {
  static [entityKind] = "ColumnBuilder";
  config;
  constructor(name2, dataType, columnType) {
    this.config = {
      name: name2,
      keyAsName: name2 === "",
      notNull: false,
      default: undefined,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: undefined,
      uniqueType: undefined,
      dataType,
      columnType,
      generated: undefined
    };
  }
  $type() {
    return this;
  }
  notNull() {
    this.config.notNull = true;
    return this;
  }
  default(value) {
    this.config.default = value;
    this.config.hasDefault = true;
    return this;
  }
  $defaultFn(fn) {
    this.config.defaultFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $default = this.$defaultFn;
  $onUpdateFn(fn) {
    this.config.onUpdateFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $onUpdate = this.$onUpdateFn;
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
  setName(name2) {
    if (this.config.name !== "")
      return;
    this.config.name = name2;
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/table.utils.js
var TableName = Symbol.for("drizzle:Name");

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/foreign-keys.js
class ForeignKeyBuilder {
  static [entityKind] = "PgForeignKeyBuilder";
  reference;
  _onUpdate = "no action";
  _onDelete = "no action";
  constructor(config, actions) {
    this.reference = () => {
      const { name: name2, columns, foreignColumns } = config();
      return { name: name2, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action === undefined ? "no action" : action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action === undefined ? "no action" : action;
    return this;
  }
  build(table) {
    return new ForeignKey(table, this);
  }
}

class ForeignKey {
  constructor(table, builder) {
    this.table = table;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  static [entityKind] = "PgForeignKey";
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name: name2, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[TableName],
      ...columnNames,
      foreignColumns[0].table[TableName],
      ...foreignColumnNames
    ];
    return name2 ?? `${chunks.join("_")}_fk`;
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/tracing-utils.js
function iife(fn, ...args2) {
  return fn(...args2);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/unique-constraint.js
function uniqueKeyName(table, columns) {
  return `${table[TableName]}_${columns.join("_")}_unique`;
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/utils/array.js
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i2 = startFrom;i2 < arrayString.length; i2++) {
    const char = arrayString[i2];
    if (char === "\\") {
      i2++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i2).replace(/\\/g, ""), i2 + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i2).replace(/\\/g, ""), i2];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i2 = startFrom;
  let lastCharIsComma = false;
  while (i2 < arrayString.length) {
    const char = arrayString[i2];
    if (char === ",") {
      if (lastCharIsComma || i2 === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i2++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i2 += 2;
      continue;
    }
    if (char === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i2 + 1, true);
      result.push(value2);
      i2 = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i2 + 1];
    }
    if (char === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i2 + 1);
      result.push(value2);
      i2 = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i2, false);
    result.push(value);
    i2 = newStartFrom;
  }
  return [result, i2];
}
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
function makePgArray(array) {
  return `{${array.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, "\\\"")}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/common.js
class PgColumnBuilder extends ColumnBuilder {
  foreignKeyConfigs = [];
  static [entityKind] = "PgColumnBuilder";
  array(size) {
    return new PgArrayBuilder(this.config.name, this, size);
  }
  references(ref, actions = {}) {
    this.foreignKeyConfigs.push({ ref, actions });
    return this;
  }
  unique(name2, config) {
    this.config.isUnique = true;
    this.config.uniqueName = name2;
    this.config.uniqueType = config?.nulls;
    return this;
  }
  generatedAlwaysAs(as) {
    this.config.generated = {
      as,
      type: "always",
      mode: "stored"
    };
    return this;
  }
  buildForeignKeys(column, table) {
    return this.foreignKeyConfigs.map(({ ref, actions }) => {
      return iife((ref2, actions2) => {
        const builder = new ForeignKeyBuilder(() => {
          const foreignColumn = ref2();
          return { columns: [column], foreignColumns: [foreignColumn] };
        });
        if (actions2.onUpdate) {
          builder.onUpdate(actions2.onUpdate);
        }
        if (actions2.onDelete) {
          builder.onDelete(actions2.onDelete);
        }
        return builder.build(table);
      }, ref, actions);
    });
  }
  buildExtraConfigColumn(table) {
    return new ExtraConfigColumn(table, this.config);
  }
}

class PgColumn extends Column {
  constructor(table, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName(table, [config.name]);
    }
    super(table, config);
    this.table = table;
  }
  static [entityKind] = "PgColumn";
}

class ExtraConfigColumn extends PgColumn {
  static [entityKind] = "ExtraConfigColumn";
  getSQLType() {
    return this.getSQLType();
  }
  indexConfig = {
    order: this.config.order ?? "asc",
    nulls: this.config.nulls ?? "last",
    opClass: this.config.opClass
  };
  defaultConfig = {
    order: "asc",
    nulls: "last",
    opClass: undefined
  };
  asc() {
    this.indexConfig.order = "asc";
    return this;
  }
  desc() {
    this.indexConfig.order = "desc";
    return this;
  }
  nullsFirst() {
    this.indexConfig.nulls = "first";
    return this;
  }
  nullsLast() {
    this.indexConfig.nulls = "last";
    return this;
  }
  op(opClass) {
    this.indexConfig.opClass = opClass;
    return this;
  }
}

class IndexedColumn {
  static [entityKind] = "IndexedColumn";
  constructor(name2, keyAsName, type, indexConfig) {
    this.name = name2;
    this.keyAsName = keyAsName;
    this.type = type;
    this.indexConfig = indexConfig;
  }
  name;
  keyAsName;
  type;
  indexConfig;
}

class PgArrayBuilder extends PgColumnBuilder {
  static [entityKind] = "PgArrayBuilder";
  constructor(name2, baseBuilder, size) {
    super(name2, "array", "PgArray");
    this.config.baseBuilder = baseBuilder;
    this.config.size = size;
  }
  build(table) {
    const baseColumn = this.config.baseBuilder.build(table);
    return new PgArray(table, this.config, baseColumn);
  }
}

class PgArray extends PgColumn {
  constructor(table, config, baseColumn, range) {
    super(table, config);
    this.baseColumn = baseColumn;
    this.range = range;
    this.size = config.size;
  }
  size;
  static [entityKind] = "PgArray";
  getSQLType() {
    return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      value = parsePgArray(value);
    }
    return value.map((v) => this.baseColumn.mapFromDriverValue(v));
  }
  mapToDriverValue(value, isNestedArray = false) {
    const a = value.map((v) => v === null ? null : is(this.baseColumn, PgArray) ? this.baseColumn.mapToDriverValue(v, true) : this.baseColumn.mapToDriverValue(v));
    if (isNestedArray)
      return a;
    return makePgArray(a);
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/enum.js
class PgEnumObjectColumn extends PgColumn {
  static [entityKind] = "PgEnumObjectColumn";
  enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config) {
    super(table, config);
    this.enum = config.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}
var isPgEnumSym = Symbol.for("drizzle:isPgEnum");
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}
class PgEnumColumn extends PgColumn {
  static [entityKind] = "PgEnumColumn";
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config) {
    super(table, config);
    this.enum = config.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/subquery.js
class Subquery {
  static [entityKind] = "Subquery";
  constructor(sql, fields, alias, isWith = false, usedTables = []) {
    this._ = {
      brand: "Subquery",
      sql,
      selectedFields: fields,
      alias,
      isWith,
      usedTables
    };
  }
}

class WithSubquery extends Subquery {
  static [entityKind] = "WithSubquery";
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/version.js
var version = "0.44.2";

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/tracing.js
var otel;
var rawTracer;
var tracer = {
  startActiveSpan(name2, fn) {
    if (!otel) {
      return fn();
    }
    if (!rawTracer) {
      rawTracer = otel.trace.getTracer("drizzle-orm", version);
    }
    return iife((otel2, rawTracer2) => rawTracer2.startActiveSpan(name2, (span) => {
      try {
        return fn(span);
      } catch (e) {
        span.setStatus({
          code: otel2.SpanStatusCode.ERROR,
          message: e instanceof Error ? e.message : "Unknown error"
        });
        throw e;
      } finally {
        span.end();
      }
    }), otel, rawTracer);
  }
};

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/view-common.js
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/table.js
var Schema = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var ExtraConfigColumns = Symbol.for("drizzle:ExtraConfigColumns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");

class Table {
  static [entityKind] = "Table";
  static Symbol = {
    Name: TableName,
    Schema,
    OriginalName,
    Columns,
    ExtraConfigColumns,
    BaseName,
    IsAlias,
    ExtraConfigBuilder
  };
  [TableName];
  [OriginalName];
  [Schema];
  [Columns];
  [ExtraConfigColumns];
  [BaseName];
  [IsAlias] = false;
  [IsDrizzleTable] = true;
  [ExtraConfigBuilder] = undefined;
  constructor(name2, schema, baseName) {
    this[TableName] = this[OriginalName] = name2;
    this[Schema] = schema;
    this[BaseName] = baseName;
  }
}
function getTableName(table) {
  return table[TableName];
}
function getTableUniqueName(table) {
  return `${table[Schema] ?? "public"}.${table[TableName]}`;
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/sql/sql.js
function isSQLWrapper(value) {
  return value !== null && value !== undefined && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}

class StringChunk {
  static [entityKind] = "StringChunk";
  value;
  constructor(value) {
    this.value = Array.isArray(value) ? value : [value];
  }
  getSQL() {
    return new SQL([this]);
  }
}

class SQL {
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
    for (const chunk of queryChunks) {
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        this.usedTables.push(schemaName === undefined ? chunk[Table.Symbol.Name] : schemaName + "." + chunk[Table.Symbol.Name]);
      }
    }
  }
  static [entityKind] = "SQL";
  decoder = noopDecoder;
  shouldInlineParams = false;
  usedTables = [];
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config) {
    const config = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const {
      casing,
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config;
    return mergeQueries(chunks.map((chunk) => {
      if (is(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is(chunk, Name)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === undefined) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result = [new StringChunk("(")];
        for (const [i2, p] of chunk.entries()) {
          result.push(p);
          if (i2 < chunk.length - 1) {
            result.push(new StringChunk(", "));
          }
        }
        result.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result, config);
      }
      if (is(chunk, SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === undefined || chunk[IsAlias] ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is(chunk, Column)) {
        const columnName = casing.getColumnCasing(chunk);
        if (_config.invokeSource === "indexes") {
          return { sql: escapeName(columnName), params: [] };
        }
        const schemaName = chunk.table[Table.Symbol.Schema];
        return {
          sql: chunk.table[IsAlias] || schemaName === undefined ? escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName) : escapeName(schemaName) + "." + escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName),
          params: []
        };
      }
      if (is(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === undefined || chunk[ViewBaseConfig].isAlias ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is(chunk, Param)) {
        if (is(chunk.value, Placeholder)) {
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
        }
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is(mappedValue, SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config), params: [] };
        }
        let typings = ["none"];
        if (prepareTyping) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
      }
      if (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is(chunk, Subquery)) {
        if (chunk._.isWith) {
          return { sql: escapeName(chunk._.alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk._.sql,
          new StringChunk(") "),
          new Name(chunk._.alias)
        ], config);
      }
      if (isPgEnum(chunk)) {
        if (chunk.schema) {
          return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
        }
        return { sql: escapeName(chunk.enumName), params: [] };
      }
      if (isSQLWrapper(chunk)) {
        if (chunk.shouldOmitSQLParens?.()) {
          return this.buildQueryFromSourceParams([chunk.getSQL()], config);
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === undefined) {
      return this;
    }
    return new SQL.Aliased(this, alias);
  }
  mapWith(decoder) {
    this.decoder = typeof decoder === "function" ? { mapFromDriverValue: decoder } : decoder;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
  if(condition) {
    return condition ? this : undefined;
  }
}

class Name {
  constructor(value) {
    this.value = value;
  }
  static [entityKind] = "Name";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
var noopDecoder = {
  mapFromDriverValue: (value) => value
};
var noopEncoder = {
  mapToDriverValue: (value) => value
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};

class Param {
  constructor(value, encoder = noopEncoder) {
    this.value = value;
    this.encoder = encoder;
  }
  static [entityKind] = "Param";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
((sql2) => {
  function empty() {
    return new SQL([]);
  }
  sql2.empty = empty;
  function fromList(list) {
    return new SQL(list);
  }
  sql2.fromList = fromList;
  function raw(str) {
    return new SQL([new StringChunk(str)]);
  }
  sql2.raw = raw;
  function join(chunks, separator) {
    const result = [];
    for (const [i2, chunk] of chunks.entries()) {
      if (i2 > 0 && separator !== undefined) {
        result.push(separator);
      }
      result.push(chunk);
    }
    return new SQL(result);
  }
  sql2.join = join;
  function identifier(value) {
    return new Name(value);
  }
  sql2.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  sql2.placeholder = placeholder2;
  function param2(value, encoder) {
    return new Param(value, encoder);
  }
  sql2.param = param2;
})(sql || (sql = {}));
((SQL2) => {

  class Aliased {
    constructor(sql2, fieldAlias) {
      this.sql = sql2;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind] = "SQL.Aliased";
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));

class Placeholder {
  constructor(name2) {
    this.name = name2;
  }
  static [entityKind] = "Placeholder";
  getSQL() {
    return new SQL([this]);
  }
}
function fillPlaceholders(params, values) {
  return params.map((p) => {
    if (is(p, Placeholder)) {
      if (!(p.name in values)) {
        throw new Error(`No value for placeholder "${p.name}" was provided`);
      }
      return values[p.name];
    }
    if (is(p, Param) && is(p.value, Placeholder)) {
      if (!(p.value.name in values)) {
        throw new Error(`No value for placeholder "${p.value.name}" was provided`);
      }
      return p.encoder.mapToDriverValue(values[p.value.name]);
    }
    return p;
  });
}
var IsDrizzleView = Symbol.for("drizzle:IsDrizzleView");

class View {
  static [entityKind] = "View";
  [ViewBaseConfig];
  [IsDrizzleView] = true;
  constructor({ name: name2, schema, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
}
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
Table.prototype.getSQL = function() {
  return new SQL([this]);
};
Subquery.prototype.getSQL = function() {
  return new SQL([this]);
};

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/alias.js
class ColumnAliasProxyHandler {
  constructor(table) {
    this.table = table;
  }
  static [entityKind] = "ColumnAliasProxyHandler";
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
}

class TableAliasProxyHandler {
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  static [entityKind] = "TableAliasProxyHandler";
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(columns[key], new ColumnAliasProxyHandler(new Proxy(target, this)));
      });
      return proxiedColumns;
    }
    const value = target[prop];
    if (is(value, Column)) {
      return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value;
  }
}
function aliasedTable(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(column, new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))));
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c) => {
    if (is(c, Column)) {
      return aliasedTableColumn(c, alias);
    }
    if (is(c, SQL)) {
      return mapColumnsInSQLToAlias(c, alias);
    }
    if (is(c, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c, alias);
    }
    return c;
  }));
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/utils.js
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce((result2, { path, field }, columnIndex) => {
    let decoder;
    if (is(field, Column)) {
      decoder = field;
    } else if (is(field, SQL)) {
      decoder = field.decoder;
    } else {
      decoder = field.sql.decoder;
    }
    let node = result2;
    for (const [pathChunkIndex, pathChunk] of path.entries()) {
      if (pathChunkIndex < path.length - 1) {
        if (!(pathChunk in node)) {
          node[pathChunk] = {};
        }
        node = node[pathChunk];
      } else {
        const rawValue = row[columnIndex];
        const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
        if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
          const objectName = path[0];
          if (!(objectName in nullifyMap)) {
            nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
          } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
            nullifyMap[objectName] = false;
          }
        }
      }
    }
    return result2;
  }, {});
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name2, field]) => {
    if (typeof name2 !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name2] : [name2];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index, key] of leftKeys.entries()) {
    if (key !== rightKeys[index]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== undefined).map(([key, value]) => {
    if (is(value, SQL) || is(value, Column)) {
      return [key, value];
    } else {
      return [key, new Param(value, table[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name2 of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name2 === "constructor")
        continue;
      Object.defineProperty(baseClass.prototype, name2, Object.getOwnPropertyDescriptor(extendedClass.prototype, name2) || /* @__PURE__ */ Object.create(null));
    }
  }
}
function getTableColumns(table) {
  return table[Table.Symbol.Columns];
}
function getTableLikeName(table) {
  return is(table, Subquery) ? table._.alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
}
function getColumnNameAndConfig(a, b) {
  return {
    name: typeof a === "string" && a.length > 0 ? a : "",
    config: typeof a === "object" ? a : b
  };
}
function isConfig(data) {
  if (typeof data !== "object" || data === null)
    return false;
  if (data.constructor.name !== "Object")
    return false;
  if ("logger" in data) {
    const type = typeof data["logger"];
    if (type !== "boolean" && (type !== "object" || typeof data["logger"]["logQuery"] !== "function") && type !== "undefined")
      return false;
    return true;
  }
  if ("schema" in data) {
    const type = typeof data["schema"];
    if (type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("casing" in data) {
    const type = typeof data["casing"];
    if (type !== "string" && type !== "undefined")
      return false;
    return true;
  }
  if ("mode" in data) {
    if (data["mode"] !== "default" || data["mode"] !== "planetscale" || data["mode"] !== undefined)
      return false;
    return true;
  }
  if ("connection" in data) {
    const type = typeof data["connection"];
    if (type !== "string" && type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("client" in data) {
    const type = typeof data["client"];
    if (type !== "object" && type !== "function" && type !== "undefined")
      return false;
    return true;
  }
  if (Object.keys(data).length === 0)
    return true;
  return false;
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/int.common.js
class PgIntColumnBaseBuilder extends PgColumnBuilder {
  static [entityKind] = "PgIntColumnBaseBuilder";
  generatedAlwaysAsIdentity(sequence) {
    if (sequence) {
      const { name: name2, ...options } = sequence;
      this.config.generatedIdentity = {
        type: "always",
        sequenceName: name2,
        sequenceOptions: options
      };
    } else {
      this.config.generatedIdentity = {
        type: "always"
      };
    }
    this.config.hasDefault = true;
    this.config.notNull = true;
    return this;
  }
  generatedByDefaultAsIdentity(sequence) {
    if (sequence) {
      const { name: name2, ...options } = sequence;
      this.config.generatedIdentity = {
        type: "byDefault",
        sequenceName: name2,
        sequenceOptions: options
      };
    } else {
      this.config.generatedIdentity = {
        type: "byDefault"
      };
    }
    this.config.hasDefault = true;
    this.config.notNull = true;
    return this;
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/bigint.js
class PgBigInt53Builder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgBigInt53Builder";
  constructor(name2) {
    super(name2, "number", "PgBigInt53");
  }
  build(table) {
    return new PgBigInt53(table, this.config);
  }
}

class PgBigInt53 extends PgColumn {
  static [entityKind] = "PgBigInt53";
  getSQLType() {
    return "bigint";
  }
  mapFromDriverValue(value) {
    if (typeof value === "number") {
      return value;
    }
    return Number(value);
  }
}

class PgBigInt64Builder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgBigInt64Builder";
  constructor(name2) {
    super(name2, "bigint", "PgBigInt64");
  }
  build(table) {
    return new PgBigInt64(table, this.config);
  }
}

class PgBigInt64 extends PgColumn {
  static [entityKind] = "PgBigInt64";
  getSQLType() {
    return "bigint";
  }
  mapFromDriverValue(value) {
    return BigInt(value);
  }
}
function bigint(a, b) {
  const { name: name2, config } = getColumnNameAndConfig(a, b);
  if (config.mode === "number") {
    return new PgBigInt53Builder(name2);
  }
  return new PgBigInt64Builder(name2);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/bigserial.js
class PgBigSerial53Builder extends PgColumnBuilder {
  static [entityKind] = "PgBigSerial53Builder";
  constructor(name2) {
    super(name2, "number", "PgBigSerial53");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgBigSerial53(table, this.config);
  }
}

class PgBigSerial53 extends PgColumn {
  static [entityKind] = "PgBigSerial53";
  getSQLType() {
    return "bigserial";
  }
  mapFromDriverValue(value) {
    if (typeof value === "number") {
      return value;
    }
    return Number(value);
  }
}

class PgBigSerial64Builder extends PgColumnBuilder {
  static [entityKind] = "PgBigSerial64Builder";
  constructor(name2) {
    super(name2, "bigint", "PgBigSerial64");
    this.config.hasDefault = true;
  }
  build(table) {
    return new PgBigSerial64(table, this.config);
  }
}

class PgBigSerial64 extends PgColumn {
  static [entityKind] = "PgBigSerial64";
  getSQLType() {
    return "bigserial";
  }
  mapFromDriverValue(value) {
    return BigInt(value);
  }
}
function bigserial(a, b) {
  const { name: name2, config } = getColumnNameAndConfig(a, b);
  if (config.mode === "number") {
    return new PgBigSerial53Builder(name2);
  }
  return new PgBigSerial64Builder(name2);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/boolean.js
class PgBooleanBuilder extends PgColumnBuilder {
  static [entityKind] = "PgBooleanBuilder";
  constructor(name2) {
    super(name2, "boolean", "PgBoolean");
  }
  build(table) {
    return new PgBoolean(table, this.config);
  }
}

class PgBoolean extends PgColumn {
  static [entityKind] = "PgBoolean";
  getSQLType() {
    return "boolean";
  }
}
function boolean(name2) {
  return new PgBooleanBuilder(name2 ?? "");
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/char.js
class PgCharBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCharBuilder";
  constructor(name2, config) {
    super(name2, "string", "PgChar");
    this.config.length = config.length;
    this.config.enumValues = config.enum;
  }
  build(table) {
    return new PgChar(table, this.config);
  }
}

class PgChar extends PgColumn {
  static [entityKind] = "PgChar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `char` : `char(${this.length})`;
  }
}
function char(a, b = {}) {
  const { name: name2, config } = getColumnNameAndConfig(a, b);
  return new PgCharBuilder(name2, config);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/cidr.js
class PgCidrBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCidrBuilder";
  constructor(name2) {
    super(name2, "string", "PgCidr");
  }
  build(table) {
    return new PgCidr(table, this.config);
  }
}

class PgCidr extends PgColumn {
  static [entityKind] = "PgCidr";
  getSQLType() {
    return "cidr";
  }
}
function cidr(name2) {
  return new PgCidrBuilder(name2 ?? "");
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/custom.js
class PgCustomColumnBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCustomColumnBuilder";
  constructor(name2, fieldConfig, customTypeParams) {
    super(name2, "custom", "PgCustomColumn");
    this.config.fieldConfig = fieldConfig;
    this.config.customTypeParams = customTypeParams;
  }
  build(table) {
    return new PgCustomColumn(table, this.config);
  }
}

class PgCustomColumn extends PgColumn {
  static [entityKind] = "PgCustomColumn";
  sqlName;
  mapTo;
  mapFrom;
  constructor(table, config) {
    super(table, config);
    this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
    this.mapTo = config.customTypeParams.toDriver;
    this.mapFrom = config.customTypeParams.fromDriver;
  }
  getSQLType() {
    return this.sqlName;
  }
  mapFromDriverValue(value) {
    return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
  }
  mapToDriverValue(value) {
    return typeof this.mapTo === "function" ? this.mapTo(value) : value;
  }
}
function customType(customTypeParams) {
  return (a, b) => {
    const { name: name2, config } = getColumnNameAndConfig(a, b);
    return new PgCustomColumnBuilder(name2, config, customTypeParams);
  };
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/date.common.js
class PgDateColumnBaseBuilder extends PgColumnBuilder {
  static [entityKind] = "PgDateColumnBaseBuilder";
  defaultNow() {
    return this.default(sql`now()`);
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/date.js
class PgDateBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgDateBuilder";
  constructor(name2) {
    super(name2, "date", "PgDate");
  }
  build(table) {
    return new PgDate(table, this.config);
  }
}

class PgDate extends PgColumn {
  static [entityKind] = "PgDate";
  getSQLType() {
    return "date";
  }
  mapFromDriverValue(value) {
    return new Date(value);
  }
  mapToDriverValue(value) {
    return value.toISOString();
  }
}

class PgDateStringBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgDateStringBuilder";
  constructor(name2) {
    super(name2, "string", "PgDateString");
  }
  build(table) {
    return new PgDateString(table, this.config);
  }
}

class PgDateString extends PgColumn {
  static [entityKind] = "PgDateString";
  getSQLType() {
    return "date";
  }
}
function date(a, b) {
  const { name: name2, config } = getColumnNameAndConfig(a, b);
  if (config?.mode === "date") {
    return new PgDateBuilder(name2);
  }
  return new PgDateStringBuilder(name2);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/double-precision.js
class PgDoublePrecisionBuilder extends PgColumnBuilder {
  static [entityKind] = "PgDoublePrecisionBuilder";
  constructor(name2) {
    super(name2, "number", "PgDoublePrecision");
  }
  build(table) {
    return new PgDoublePrecision(table, this.config);
  }
}

class PgDoublePrecision extends PgColumn {
  static [entityKind] = "PgDoublePrecision";
  getSQLType() {
    return "double precision";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseFloat(value);
    }
    return value;
  }
}
function doublePrecision(name2) {
  return new PgDoublePrecisionBuilder(name2 ?? "");
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/inet.js
class PgInetBuilder extends PgColumnBuilder {
  static [entityKind] = "PgInetBuilder";
  constructor(name2) {
    super(name2, "string", "PgInet");
  }
  build(table) {
    return new PgInet(table, this.config);
  }
}

class PgInet extends PgColumn {
  static [entityKind] = "PgInet";
  getSQLType() {
    return "inet";
  }
}
function inet(name2) {
  return new PgInetBuilder(name2 ?? "");
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/integer.js
class PgIntegerBuilder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgIntegerBuilder";
  constructor(name2) {
    super(name2, "number", "PgInteger");
  }
  build(table) {
    return new PgInteger(table, this.config);
  }
}

class PgInteger extends PgColumn {
  static [entityKind] = "PgInteger";
  getSQLType() {
    return "integer";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseInt(value);
    }
    return value;
  }
}
function integer(name2) {
  return new PgIntegerBuilder(name2 ?? "");
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/interval.js
class PgIntervalBuilder extends PgColumnBuilder {
  static [entityKind] = "PgIntervalBuilder";
  constructor(name2, intervalConfig) {
    super(name2, "string", "PgInterval");
    this.config.intervalConfig = intervalConfig;
  }
  build(table) {
    return new PgInterval(table, this.config);
  }
}

class PgInterval extends PgColumn {
  static [entityKind] = "PgInterval";
  fields = this.config.intervalConfig.fields;
  precision = this.config.intervalConfig.precision;
  getSQLType() {
    const fields = this.fields ? ` ${this.fields}` : "";
    const precision = this.precision ? `(${this.precision})` : "";
    return `interval${fields}${precision}`;
  }
}
function interval(a, b = {}) {
  const { name: name2, config } = getColumnNameAndConfig(a, b);
  return new PgIntervalBuilder(name2, config);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/json.js
class PgJsonBuilder extends PgColumnBuilder {
  static [entityKind] = "PgJsonBuilder";
  constructor(name2) {
    super(name2, "json", "PgJson");
  }
  build(table) {
    return new PgJson(table, this.config);
  }
}

class PgJson extends PgColumn {
  static [entityKind] = "PgJson";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "json";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
}
function json(name2) {
  return new PgJsonBuilder(name2 ?? "");
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/jsonb.js
class PgJsonbBuilder extends PgColumnBuilder {
  static [entityKind] = "PgJsonbBuilder";
  constructor(name2) {
    super(name2, "json", "PgJsonb");
  }
  build(table) {
    return new PgJsonb(table, this.config);
  }
}

class PgJsonb extends PgColumn {
  static [entityKind] = "PgJsonb";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "jsonb";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
}
function jsonb(name2) {
  return new PgJsonbBuilder(name2 ?? "");
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/line.js
class PgLineBuilder extends PgColumnBuilder {
  static [entityKind] = "PgLineBuilder";
  constructor(name2) {
    super(name2, "array", "PgLine");
  }
  build(table) {
    return new PgLineTuple(table, this.config);
  }
}

class PgLineTuple extends PgColumn {
  static [entityKind] = "PgLine";
  getSQLType() {
    return "line";
  }
  mapFromDriverValue(value) {
    const [a, b, c] = value.slice(1, -1).split(",");
    return [Number.parseFloat(a), Number.parseFloat(b), Number.parseFloat(c)];
  }
  mapToDriverValue(value) {
    return `{${value[0]},${value[1]},${value[2]}}`;
  }
}

class PgLineABCBuilder extends PgColumnBuilder {
  static [entityKind] = "PgLineABCBuilder";
  constructor(name2) {
    super(name2, "json", "PgLineABC");
  }
  build(table) {
    return new PgLineABC(table, this.config);
  }
}

class PgLineABC extends PgColumn {
  static [entityKind] = "PgLineABC";
  getSQLType() {
    return "line";
  }
  mapFromDriverValue(value) {
    const [a, b, c] = value.slice(1, -1).split(",");
    return { a: Number.parseFloat(a), b: Number.parseFloat(b), c: Number.parseFloat(c) };
  }
  mapToDriverValue(value) {
    return `{${value.a},${value.b},${value.c}}`;
  }
}
function line(a, b) {
  const { name: name2, config } = getColumnNameAndConfig(a, b);
  if (!config?.mode || config.mode === "tuple") {
    return new PgLineBuilder(name2);
  }
  return new PgLineABCBuilder(name2);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/macaddr.js
class PgMacaddrBuilder extends PgColumnBuilder {
  static [entityKind] = "PgMacaddrBuilder";
  constructor(name2) {
    super(name2, "string", "PgMacaddr");
  }
  build(table) {
    return new PgMacaddr(table, this.config);
  }
}

class PgMacaddr extends PgColumn {
  static [entityKind] = "PgMacaddr";
  getSQLType() {
    return "macaddr";
  }
}
function macaddr(name2) {
  return new PgMacaddrBuilder(name2 ?? "");
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/macaddr8.js
class PgMacaddr8Builder extends PgColumnBuilder {
  static [entityKind] = "PgMacaddr8Builder";
  constructor(name2) {
    super(name2, "string", "PgMacaddr8");
  }
  build(table) {
    return new PgMacaddr8(table, this.config);
  }
}

class PgMacaddr8 extends PgColumn {
  static [entityKind] = "PgMacaddr8";
  getSQLType() {
    return "macaddr8";
  }
}
function macaddr8(name2) {
  return new PgMacaddr8Builder(name2 ?? "");
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/numeric.js
class PgNumericBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericBuilder";
  constructor(name2, precision, scale) {
    super(name2, "string", "PgNumeric");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumeric(table, this.config);
  }
}

class PgNumeric extends PgColumn {
  static [entityKind] = "PgNumeric";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string")
      return value;
    return String(value);
  }
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}

class PgNumericNumberBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericNumberBuilder";
  constructor(name2, precision, scale) {
    super(name2, "number", "PgNumericNumber");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumericNumber(table, this.config);
  }
}

class PgNumericNumber extends PgColumn {
  static [entityKind] = "PgNumericNumber";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  mapFromDriverValue(value) {
    if (typeof value === "number")
      return value;
    return Number(value);
  }
  mapToDriverValue = String;
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}

class PgNumericBigIntBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericBigIntBuilder";
  constructor(name2, precision, scale) {
    super(name2, "bigint", "PgNumericBigInt");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumericBigInt(table, this.config);
  }
}

class PgNumericBigInt extends PgColumn {
  static [entityKind] = "PgNumericBigInt";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  mapFromDriverValue = BigInt;
  mapToDriverValue = String;
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}
function numeric(a, b) {
  const { name: name2, config } = getColumnNameAndConfig(a, b);
  const mode = config?.mode;
  return mode === "number" ? new PgNumericNumberBuilder(name2, config?.precision, config?.scale) : mode === "bigint" ? new PgNumericBigIntBuilder(name2, config?.precision, config?.scale) : new PgNumericBuilder(name2, config?.precision, config?.scale);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/point.js
class PgPointTupleBuilder extends PgColumnBuilder {
  static [entityKind] = "PgPointTupleBuilder";
  constructor(name2) {
    super(name2, "array", "PgPointTuple");
  }
  build(table) {
    return new PgPointTuple(table, this.config);
  }
}

class PgPointTuple extends PgColumn {
  static [entityKind] = "PgPointTuple";
  getSQLType() {
    return "point";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      const [x2, y] = value.slice(1, -1).split(",");
      return [Number.parseFloat(x2), Number.parseFloat(y)];
    }
    return [value.x, value.y];
  }
  mapToDriverValue(value) {
    return `(${value[0]},${value[1]})`;
  }
}

class PgPointObjectBuilder extends PgColumnBuilder {
  static [entityKind] = "PgPointObjectBuilder";
  constructor(name2) {
    super(name2, "json", "PgPointObject");
  }
  build(table) {
    return new PgPointObject(table, this.config);
  }
}

class PgPointObject extends PgColumn {
  static [entityKind] = "PgPointObject";
  getSQLType() {
    return "point";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      const [x2, y] = value.slice(1, -1).split(",");
      return { x: Number.parseFloat(x2), y: Number.parseFloat(y) };
    }
    return value;
  }
  mapToDriverValue(value) {
    return `(${value.x},${value.y})`;
  }
}
function point(a, b) {
  const { name: name2, config } = getColumnNameAndConfig(a, b);
  if (!config?.mode || config.mode === "tuple") {
    return new PgPointTupleBuilder(name2);
  }
  return new PgPointObjectBuilder(name2);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/postgis_extension/utils.js
function hexToBytes(hex) {
  const bytes = [];
  for (let c = 0;c < hex.length; c += 2) {
    bytes.push(Number.parseInt(hex.slice(c, c + 2), 16));
  }
  return new Uint8Array(bytes);
}
function bytesToFloat64(bytes, offset) {
  const buffer = new ArrayBuffer(8);
  const view = new DataView(buffer);
  for (let i2 = 0;i2 < 8; i2++) {
    view.setUint8(i2, bytes[offset + i2]);
  }
  return view.getFloat64(0, true);
}
function parseEWKB(hex) {
  const bytes = hexToBytes(hex);
  let offset = 0;
  const byteOrder = bytes[offset];
  offset += 1;
  const view = new DataView(bytes.buffer);
  const geomType = view.getUint32(offset, byteOrder === 1);
  offset += 4;
  let _srid;
  if (geomType & 536870912) {
    _srid = view.getUint32(offset, byteOrder === 1);
    offset += 4;
  }
  if ((geomType & 65535) === 1) {
    const x2 = bytesToFloat64(bytes, offset);
    offset += 8;
    const y = bytesToFloat64(bytes, offset);
    offset += 8;
    return [x2, y];
  }
  throw new Error("Unsupported geometry type");
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/postgis_extension/geometry.js
class PgGeometryBuilder extends PgColumnBuilder {
  static [entityKind] = "PgGeometryBuilder";
  constructor(name2) {
    super(name2, "array", "PgGeometry");
  }
  build(table) {
    return new PgGeometry(table, this.config);
  }
}

class PgGeometry extends PgColumn {
  static [entityKind] = "PgGeometry";
  getSQLType() {
    return "geometry(point)";
  }
  mapFromDriverValue(value) {
    return parseEWKB(value);
  }
  mapToDriverValue(value) {
    return `point(${value[0]} ${value[1]})`;
  }
}

class PgGeometryObjectBuilder extends PgColumnBuilder {
  static [entityKind] = "PgGeometryObjectBuilder";
  constructor(name2) {
    super(name2, "json", "PgGeometryObject");
  }
  build(table) {
    return new PgGeometryObject(table, this.config);
  }
}

class PgGeometryObject extends PgColumn {
  static [entityKind] = "PgGeometryObject";
  getSQLType() {
    return "geometry(point)";
  }
  mapFromDriverValue(value) {
    const parsed = parseEWKB(value);
    return { x: parsed[0], y: parsed[1] };
  }
  mapToDriverValue(value) {
    return `point(${value.x} ${value.y})`;
  }
}
function geometry(a, b) {
  const { name: name2, config } = getColumnNameAndConfig(a, b);
  if (!config?.mode || config.mode === "tuple") {
    return new PgGeometryBuilder(name2);
  }
  return new PgGeometryObjectBuilder(name2);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/real.js
class PgRealBuilder extends PgColumnBuilder {
  static [entityKind] = "PgRealBuilder";
  constructor(name2, length) {
    super(name2, "number", "PgReal");
    this.config.length = length;
  }
  build(table) {
    return new PgReal(table, this.config);
  }
}

class PgReal extends PgColumn {
  static [entityKind] = "PgReal";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "real";
  }
  mapFromDriverValue = (value) => {
    if (typeof value === "string") {
      return Number.parseFloat(value);
    }
    return value;
  };
}
function real(name2) {
  return new PgRealBuilder(name2 ?? "");
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/serial.js
class PgSerialBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSerialBuilder";
  constructor(name2) {
    super(name2, "number", "PgSerial");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgSerial(table, this.config);
  }
}

class PgSerial extends PgColumn {
  static [entityKind] = "PgSerial";
  getSQLType() {
    return "serial";
  }
}
function serial(name2) {
  return new PgSerialBuilder(name2 ?? "");
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/smallint.js
class PgSmallIntBuilder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgSmallIntBuilder";
  constructor(name2) {
    super(name2, "number", "PgSmallInt");
  }
  build(table) {
    return new PgSmallInt(table, this.config);
  }
}

class PgSmallInt extends PgColumn {
  static [entityKind] = "PgSmallInt";
  getSQLType() {
    return "smallint";
  }
  mapFromDriverValue = (value) => {
    if (typeof value === "string") {
      return Number(value);
    }
    return value;
  };
}
function smallint(name2) {
  return new PgSmallIntBuilder(name2 ?? "");
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/smallserial.js
class PgSmallSerialBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSmallSerialBuilder";
  constructor(name2) {
    super(name2, "number", "PgSmallSerial");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgSmallSerial(table, this.config);
  }
}

class PgSmallSerial extends PgColumn {
  static [entityKind] = "PgSmallSerial";
  getSQLType() {
    return "smallserial";
  }
}
function smallserial(name2) {
  return new PgSmallSerialBuilder(name2 ?? "");
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/text.js
class PgTextBuilder extends PgColumnBuilder {
  static [entityKind] = "PgTextBuilder";
  constructor(name2, config) {
    super(name2, "string", "PgText");
    this.config.enumValues = config.enum;
  }
  build(table) {
    return new PgText(table, this.config);
  }
}

class PgText extends PgColumn {
  static [entityKind] = "PgText";
  enumValues = this.config.enumValues;
  getSQLType() {
    return "text";
  }
}
function text(a, b = {}) {
  const { name: name2, config } = getColumnNameAndConfig(a, b);
  return new PgTextBuilder(name2, config);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/time.js
class PgTimeBuilder extends PgDateColumnBaseBuilder {
  constructor(name2, withTimezone, precision) {
    super(name2, "string", "PgTime");
    this.withTimezone = withTimezone;
    this.precision = precision;
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  static [entityKind] = "PgTimeBuilder";
  build(table) {
    return new PgTime(table, this.config);
  }
}

class PgTime extends PgColumn {
  static [entityKind] = "PgTime";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}
function time(a, b = {}) {
  const { name: name2, config } = getColumnNameAndConfig(a, b);
  return new PgTimeBuilder(name2, config.withTimezone ?? false, config.precision);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/timestamp.js
class PgTimestampBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampBuilder";
  constructor(name2, withTimezone, precision) {
    super(name2, "date", "PgTimestamp");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table) {
    return new PgTimestamp(table, this.config);
  }
}

class PgTimestamp extends PgColumn {
  static [entityKind] = "PgTimestamp";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : ` (${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
  mapFromDriverValue = (value) => {
    return new Date(this.withTimezone ? value : value + "+0000");
  };
  mapToDriverValue = (value) => {
    return value.toISOString();
  };
}

class PgTimestampStringBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampStringBuilder";
  constructor(name2, withTimezone, precision) {
    super(name2, "string", "PgTimestampString");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table) {
    return new PgTimestampString(table, this.config);
  }
}

class PgTimestampString extends PgColumn {
  static [entityKind] = "PgTimestampString";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}
function timestamp(a, b = {}) {
  const { name: name2, config } = getColumnNameAndConfig(a, b);
  if (config?.mode === "string") {
    return new PgTimestampStringBuilder(name2, config.withTimezone ?? false, config.precision);
  }
  return new PgTimestampBuilder(name2, config?.withTimezone ?? false, config?.precision);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/uuid.js
class PgUUIDBuilder extends PgColumnBuilder {
  static [entityKind] = "PgUUIDBuilder";
  constructor(name2) {
    super(name2, "string", "PgUUID");
  }
  defaultRandom() {
    return this.default(sql`gen_random_uuid()`);
  }
  build(table) {
    return new PgUUID(table, this.config);
  }
}

class PgUUID extends PgColumn {
  static [entityKind] = "PgUUID";
  getSQLType() {
    return "uuid";
  }
}
function uuid(name2) {
  return new PgUUIDBuilder(name2 ?? "");
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/varchar.js
class PgVarcharBuilder extends PgColumnBuilder {
  static [entityKind] = "PgVarcharBuilder";
  constructor(name2, config) {
    super(name2, "string", "PgVarchar");
    this.config.length = config.length;
    this.config.enumValues = config.enum;
  }
  build(table) {
    return new PgVarchar(table, this.config);
  }
}

class PgVarchar extends PgColumn {
  static [entityKind] = "PgVarchar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `varchar` : `varchar(${this.length})`;
  }
}
function varchar(a, b = {}) {
  const { name: name2, config } = getColumnNameAndConfig(a, b);
  return new PgVarcharBuilder(name2, config);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/vector_extension/bit.js
class PgBinaryVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgBinaryVectorBuilder";
  constructor(name2, config) {
    super(name2, "string", "PgBinaryVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgBinaryVector(table, this.config);
  }
}

class PgBinaryVector extends PgColumn {
  static [entityKind] = "PgBinaryVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `bit(${this.dimensions})`;
  }
}
function bit(a, b) {
  const { name: name2, config } = getColumnNameAndConfig(a, b);
  return new PgBinaryVectorBuilder(name2, config);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/vector_extension/halfvec.js
class PgHalfVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgHalfVectorBuilder";
  constructor(name2, config) {
    super(name2, "array", "PgHalfVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgHalfVector(table, this.config);
  }
}

class PgHalfVector extends PgColumn {
  static [entityKind] = "PgHalfVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `halfvec(${this.dimensions})`;
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    return value.slice(1, -1).split(",").map((v) => Number.parseFloat(v));
  }
}
function halfvec(a, b) {
  const { name: name2, config } = getColumnNameAndConfig(a, b);
  return new PgHalfVectorBuilder(name2, config);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/vector_extension/sparsevec.js
class PgSparseVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSparseVectorBuilder";
  constructor(name2, config) {
    super(name2, "string", "PgSparseVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgSparseVector(table, this.config);
  }
}

class PgSparseVector extends PgColumn {
  static [entityKind] = "PgSparseVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `sparsevec(${this.dimensions})`;
  }
}
function sparsevec(a, b) {
  const { name: name2, config } = getColumnNameAndConfig(a, b);
  return new PgSparseVectorBuilder(name2, config);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/vector_extension/vector.js
class PgVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgVectorBuilder";
  constructor(name2, config) {
    super(name2, "array", "PgVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgVector(table, this.config);
  }
}

class PgVector extends PgColumn {
  static [entityKind] = "PgVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `vector(${this.dimensions})`;
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    return value.slice(1, -1).split(",").map((v) => Number.parseFloat(v));
  }
}
function vector(a, b) {
  const { name: name2, config } = getColumnNameAndConfig(a, b);
  return new PgVectorBuilder(name2, config);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/query-promise.js
class QueryPromise {
  static [entityKind] = "QueryPromise";
  [Symbol.toStringTag] = "QueryPromise";
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/selection-proxy.js
class SelectionProxyHandler {
  static [entityKind] = "SelectionProxyHandler";
  config;
  constructor(config) {
    this.config = { ...config };
  }
  get(subquery, prop) {
    if (prop === "_") {
      return {
        ...subquery["_"],
        selectedFields: new Proxy(subquery._.selectedFields, this)
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery[ViewBaseConfig],
        selectedFields: new Proxy(subquery[ViewBaseConfig].selectedFields, this)
      };
    }
    if (typeof prop === "symbol") {
      return subquery[prop];
    }
    const columns = is(subquery, Subquery) ? subquery._.selectedFields : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
    const value = columns[prop];
    if (is(value, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
        return value.sql;
      }
      const newValue = value.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is(value, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value;
      }
      throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
    }
    if (is(value, Column)) {
      if (this.config.alias) {
        return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(value.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
      }
      return value;
    }
    if (typeof value !== "object" || value === null) {
      return value;
    }
    return new Proxy(value, new SelectionProxyHandler(this.config));
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/columns/all.js
function getPgColumnBuilders() {
  return {
    bigint,
    bigserial,
    boolean,
    char,
    cidr,
    customType,
    date,
    doublePrecision,
    inet,
    integer,
    interval,
    json,
    jsonb,
    line,
    macaddr,
    macaddr8,
    numeric,
    point,
    geometry,
    real,
    serial,
    smallint,
    smallserial,
    text,
    time,
    timestamp,
    uuid,
    varchar,
    bit,
    halfvec,
    sparsevec,
    vector
  };
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/table.js
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
var EnableRLS = Symbol.for("drizzle:EnableRLS");

class PgTable extends Table {
  static [entityKind] = "PgTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys,
    EnableRLS
  });
  [InlineForeignKeys] = [];
  [EnableRLS] = false;
  [Table.Symbol.ExtraConfigBuilder] = undefined;
  [Table.Symbol.ExtraConfigColumns] = {};
}
function pgTableWithSchema(name2, columns, extraConfig, schema, baseName = name2) {
  const rawTable = new PgTable(name2, schema, baseName);
  const parsedColumns = typeof columns === "function" ? columns(getPgColumnBuilders()) : columns;
  const builtColumns = Object.fromEntries(Object.entries(parsedColumns).map(([name22, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    colBuilder.setName(name22);
    const column = colBuilder.build(rawTable);
    rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
    return [name22, column];
  }));
  const builtColumnsForExtraConfig = Object.fromEntries(Object.entries(parsedColumns).map(([name22, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    colBuilder.setName(name22);
    const column = colBuilder.buildExtraConfigColumn(rawTable);
    return [name22, column];
  }));
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  table[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;
  if (extraConfig) {
    table[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return Object.assign(table, {
    enableRLS: () => {
      table[PgTable.Symbol.EnableRLS] = true;
      return table;
    }
  });
}
var pgTable = (name2, columns, extraConfig) => {
  return pgTableWithSchema(name2, columns, extraConfig, undefined);
};

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/indexes.js
class IndexBuilderOn {
  constructor(unique, name2) {
    this.unique = unique;
    this.name = name2;
  }
  static [entityKind] = "PgIndexBuilderOn";
  on(...columns) {
    return new IndexBuilder(columns.map((it) => {
      if (is(it, SQL)) {
        return it;
      }
      it = it;
      const clonedIndexedColumn = new IndexedColumn(it.name, !!it.keyAsName, it.columnType, it.indexConfig);
      it.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));
      return clonedIndexedColumn;
    }), this.unique, false, this.name);
  }
  onOnly(...columns) {
    return new IndexBuilder(columns.map((it) => {
      if (is(it, SQL)) {
        return it;
      }
      it = it;
      const clonedIndexedColumn = new IndexedColumn(it.name, !!it.keyAsName, it.columnType, it.indexConfig);
      it.indexConfig = it.defaultConfig;
      return clonedIndexedColumn;
    }), this.unique, true, this.name);
  }
  using(method, ...columns) {
    return new IndexBuilder(columns.map((it) => {
      if (is(it, SQL)) {
        return it;
      }
      it = it;
      const clonedIndexedColumn = new IndexedColumn(it.name, !!it.keyAsName, it.columnType, it.indexConfig);
      it.indexConfig = JSON.parse(JSON.stringify(it.defaultConfig));
      return clonedIndexedColumn;
    }), this.unique, true, this.name, method);
  }
}

class IndexBuilder {
  static [entityKind] = "PgIndexBuilder";
  config;
  constructor(columns, unique, only, name2, method = "btree") {
    this.config = {
      name: name2,
      columns,
      unique,
      only,
      method
    };
  }
  concurrently() {
    this.config.concurrently = true;
    return this;
  }
  with(obj) {
    this.config.with = obj;
    return this;
  }
  where(condition) {
    this.config.where = condition;
    return this;
  }
  build(table) {
    return new Index(this.config, table);
  }
}

class Index {
  static [entityKind] = "PgIndex";
  config;
  constructor(config, table) {
    this.config = { ...config, table };
  }
}
function index(name2) {
  return new IndexBuilderOn(false, name2);
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/primary-keys.js
class PrimaryKeyBuilder {
  static [entityKind] = "PgPrimaryKeyBuilder";
  columns;
  name;
  constructor(columns, name2) {
    this.columns = columns;
    this.name = name2;
  }
  build(table) {
    return new PrimaryKey(table, this.columns, this.name);
  }
}

class PrimaryKey {
  constructor(table, columns, name2) {
    this.table = table;
    this.columns = columns;
    this.name = name2;
  }
  static [entityKind] = "PgPrimaryKey";
  columns;
  name;
  getName() {
    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/casing.js
function toSnakeCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.map((word) => word.toLowerCase()).join("_");
}
function toCamelCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.reduce((acc, word, i2) => {
    const formattedWord = i2 === 0 ? word.toLowerCase() : `${word[0].toUpperCase()}${word.slice(1)}`;
    return acc + formattedWord;
  }, "");
}
function noopCase(input) {
  return input;
}

class CasingCache {
  static [entityKind] = "CasingCache";
  cache = {};
  cachedTables = {};
  convert;
  constructor(casing) {
    this.convert = casing === "snake_case" ? toSnakeCase : casing === "camelCase" ? toCamelCase : noopCase;
  }
  getColumnCasing(column) {
    if (!column.keyAsName)
      return column.name;
    const schema = column.table[Table.Symbol.Schema] ?? "public";
    const tableName = column.table[Table.Symbol.OriginalName];
    const key = `${schema}.${tableName}.${column.name}`;
    if (!this.cache[key]) {
      this.cacheTable(column.table);
    }
    return this.cache[key];
  }
  cacheTable(table) {
    const schema = table[Table.Symbol.Schema] ?? "public";
    const tableName = table[Table.Symbol.OriginalName];
    const tableKey = `${schema}.${tableName}`;
    if (!this.cachedTables[tableKey]) {
      for (const column of Object.values(table[Table.Symbol.Columns])) {
        const columnKey = `${tableKey}.${column.name}`;
        this.cache[columnKey] = this.convert(column.name);
      }
      this.cachedTables[tableKey] = true;
    }
  }
  clearCache() {
    this.cache = {};
    this.cachedTables = {};
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/errors.js
class DrizzleError extends Error {
  static [entityKind] = "DrizzleError";
  constructor({ message, cause }) {
    super(message);
    this.name = "DrizzleError";
    this.cause = cause;
  }
}

class TransactionRollbackError extends DrizzleError {
  static [entityKind] = "TransactionRollbackError";
  constructor() {
    super({ message: "Rollback" });
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/sql/expressions/conditions.js
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
var eq = (left, right) => {
  return sql`${left} = ${bindIfParam(right, left)}`;
};
var ne = (left, right) => {
  return sql`${left} <> ${bindIfParam(right, left)}`;
};
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or2(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
var gt = (left, right) => {
  return sql`${left} > ${bindIfParam(right, left)}`;
};
var gte = (left, right) => {
  return sql`${left} >= ${bindIfParam(right, left)}`;
};
var lt = (left, right) => {
  return sql`${left} < ${bindIfParam(right, left)}`;
};
var lte = (left, right) => {
  return sql`${left} <= ${bindIfParam(right, left)}`;
};
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`false`;
    }
    return sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`true`;
    }
    return sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
function isNull(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min, max) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function notBetween(column, min, max) {
  return sql`${column} not between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/sql/expressions/select.js
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/relations.js
class Relation {
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
  static [entityKind] = "Relation";
  referencedTableName;
  fieldName;
}

class Relations {
  constructor(table, config) {
    this.table = table;
    this.config = config;
  }
  static [entityKind] = "Relations";
}

class One extends Relation {
  constructor(sourceTable, referencedTable, config, isNullable) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
    this.isNullable = isNullable;
  }
  static [entityKind] = "One";
  withFieldName(fieldName) {
    const relation = new One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
    relation.fieldName = fieldName;
    return relation;
  }
}

class Many extends Relation {
  constructor(sourceTable, referencedTable, config) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
  }
  static [entityKind] = "Many";
  withFieldName(fieldName) {
    const relation = new Many(this.sourceTable, this.referencedTable, this.config);
    relation.fieldName = fieldName;
    return relation;
  }
}
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or: or2,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema)) {
    if (is(value, Table)) {
      const dbName = getTableUniqueName(value);
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(value[Table.Symbol.Columns])) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value[Table.Symbol.ExtraConfigColumns]);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = getTableUniqueName(value.table);
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(configHelpers(value.table));
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function createOne(sourceTable) {
  return function one(table, config) {
    return new One(sourceTable, table, config, config?.fields.reduce((res, f) => res && f.notNull, true) ?? false);
  };
}
function createMany(sourceTable) {
  return function many(referencedTable, config) {
    return new Many(sourceTable, referencedTable, config);
  };
}
function normalizeRelation(schema, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];
  if (!referencedTableTsName) {
    throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];
  if (!sourceTableTsName) {
    throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(referencedTableConfig.relations)) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`) : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRows, selectionItem.selection, mapColumnValue) : subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRow, selectionItem.selection, mapColumnValue));
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
    }
  }
  return result;
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/view-base.js
class PgViewBase extends View {
  static [entityKind] = "PgViewBase";
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/dialect.js
class PgDialect {
  static [entityKind] = "PgDialect";
  casing;
  constructor(config) {
    this.casing = new CasingCache(config?.casing);
  }
  async migrate(migrations, session, config) {
    const migrationsTable = typeof config === "string" ? "__drizzle_migrations" : config.migrationsTable ?? "__drizzle_migrations";
    const migrationsSchema = typeof config === "string" ? "drizzle" : config.migrationsSchema ?? "drizzle";
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
    await session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);
    await session.execute(migrationTableCreate);
    const dbMigrations = await session.all(sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`);
    const lastDbMigration = dbMigrations[0];
    await session.transaction(async (tx) => {
      for await (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.execute(sql.raw(stmt));
          }
          await tx.execute(sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
        }
      }
    });
  }
  escapeName(name2) {
    return `"${name2}"`;
  }
  escapeParam(num) {
    return `$${num + 1}`;
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildWithCTE(queries) {
    if (!queries?.length)
      return;
    const withSqlChunks = [sql`with `];
    for (const [i2, w] of queries.entries()) {
      withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);
      if (i2 < queries.length - 1) {
        withSqlChunks.push(sql`, `);
      }
    }
    withSqlChunks.push(sql` `);
    return sql.join(withSqlChunks);
  }
  buildDeleteQuery({ table, where, returning, withList }) {
    const withSql = this.buildWithCTE(withList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    return sql`${withSql}delete from ${table}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table, set) {
    const tableColumns = table[Table.Symbol.Columns];
    const columnNames = Object.keys(tableColumns).filter((colName) => set[colName] !== undefined || tableColumns[colName]?.onUpdateFn !== undefined);
    const setSize = columnNames.length;
    return sql.join(columnNames.flatMap((colName, i2) => {
      const col = tableColumns[colName];
      const value = set[colName] ?? sql.param(col.onUpdateFn(), col);
      const res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value}`;
      if (i2 < setSize - 1) {
        return [res, sql.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table, set, where, returning, withList, from, joins }) {
    const withSql = this.buildWithCTE(withList);
    const tableName = table[PgTable.Symbol.Name];
    const tableSchema = table[PgTable.Symbol.Schema];
    const origTableName = table[PgTable.Symbol.OriginalName];
    const alias = tableName === origTableName ? undefined : tableName;
    const tableSql = sql`${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}`;
    const setSql = this.buildUpdateSet(table, set);
    const fromSql = from && sql.join([sql.raw(" from "), this.buildFromTable(from)]);
    const joinsSql = this.buildJoins(joins);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: !from })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    return sql`${withSql}update ${tableSql} set ${setSql}${fromSql}${joinsSql}${whereSql}${returningSql}`;
  }
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i2) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(new SQL(query.queryChunks.map((c) => {
            if (is(c, PgColumn)) {
              return sql.identifier(this.casing.getColumnCasing(c));
            }
            return c;
          })));
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        if (isSingleTable) {
          chunk.push(sql.identifier(this.casing.getColumnCasing(field)));
        } else {
          chunk.push(field);
        }
      }
      if (i2 < columnsLen - 1) {
        chunk.push(sql`, `);
      }
      return chunk;
    });
    return sql.join(chunks);
  }
  buildJoins(joins) {
    if (!joins || joins.length === 0) {
      return;
    }
    const joinsArray = [];
    for (const [index2, joinMeta] of joins.entries()) {
      if (index2 === 0) {
        joinsArray.push(sql` `);
      }
      const table = joinMeta.table;
      const lateralSql = joinMeta.lateral ? sql` lateral` : undefined;
      const onSql = joinMeta.on ? sql` on ${joinMeta.on}` : undefined;
      if (is(table, PgTable)) {
        const tableName = table[PgTable.Symbol.Name];
        const tableSchema = table[PgTable.Symbol.Schema];
        const origTableName = table[PgTable.Symbol.OriginalName];
        const alias = tableName === origTableName ? undefined : joinMeta.alias;
        joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`);
      } else if (is(table, View)) {
        const viewName = table[ViewBaseConfig].name;
        const viewSchema = table[ViewBaseConfig].schema;
        const origViewName = table[ViewBaseConfig].originalName;
        const alias = viewName === origViewName ? undefined : joinMeta.alias;
        joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : undefined}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`);
      } else {
        joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table}${onSql}`);
      }
      if (index2 < joins.length - 1) {
        joinsArray.push(sql` `);
      }
    }
    return sql.join(joinsArray);
  }
  buildFromTable(table) {
    if (is(table, Table) && table[Table.Symbol.IsAlias]) {
      let fullName = sql`${sql.identifier(table[Table.Symbol.OriginalName])}`;
      if (table[Table.Symbol.Schema]) {
        fullName = sql`${sql.identifier(table[Table.Symbol.Schema])}.${fullName}`;
      }
      return sql`${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;
    }
    return table;
  }
  buildSelectQuery({
    withList,
    fields,
    fieldsFlat,
    where,
    having,
    table,
    joins,
    orderBy,
    groupBy,
    limit,
    offset,
    lockingClause,
    distinct,
    setOperators
  }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f of fieldsList) {
      if (is(f.field, Column) && getTableName(f.field.table) !== (is(table, Subquery) ? table._.alias : is(table, PgViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : getTableName(table)) && !((table2) => joins?.some(({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])))(f.field.table)) {
        const tableName = getTableName(f.field.table);
        throw new Error(`Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    const withSql = this.buildWithCTE(withList);
    let distinctSql;
    if (distinct) {
      distinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, sql`, `)})`;
    }
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = this.buildFromTable(table);
    const joinsSql = this.buildJoins(joins);
    const whereSql = where ? sql` where ${where}` : undefined;
    const havingSql = having ? sql` having ${having}` : undefined;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
    }
    let groupBySql;
    if (groupBy && groupBy.length > 0) {
      groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    const lockingClauseSql = sql.empty();
    if (lockingClause) {
      const clauseSql = sql` for ${sql.raw(lockingClause.strength)}`;
      if (lockingClause.config.of) {
        clauseSql.append(sql` of ${sql.join(Array.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of], sql`, `)}`);
      }
      if (lockingClause.config.noWait) {
        clauseSql.append(sql` nowait`);
      } else if (lockingClause.config.skipLocked) {
        clauseSql.append(sql` skip locked`);
      }
      lockingClauseSql.append(clauseSql);
    }
    const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;
    if (setOperators.length > 0) {
      return this.buildSetOperations(finalQuery, setOperators);
    }
    return finalQuery;
  }
  buildSetOperations(leftSelect, setOperators) {
    const [setOperator, ...rest] = setOperators;
    if (!setOperator) {
      throw new Error("Cannot pass undefined values to any set operator");
    }
    if (rest.length === 0) {
      return this.buildSetOperationQuery({ leftSelect, setOperator });
    }
    return this.buildSetOperations(this.buildSetOperationQuery({ leftSelect, setOperator }), rest);
  }
  buildSetOperationQuery({
    leftSelect,
    setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
  }) {
    const leftChunk = sql`(${leftSelect.getSQL()}) `;
    const rightChunk = sql`(${rightSelect.getSQL()})`;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      const orderByValues = [];
      for (const singleOrderBy of orderBy) {
        if (is(singleOrderBy, PgColumn)) {
          orderByValues.push(sql.identifier(singleOrderBy.name));
        } else if (is(singleOrderBy, SQL)) {
          for (let i2 = 0;i2 < singleOrderBy.queryChunks.length; i2++) {
            const chunk = singleOrderBy.queryChunks[i2];
            if (is(chunk, PgColumn)) {
              singleOrderBy.queryChunks[i2] = sql.identifier(chunk.name);
            }
          }
          orderByValues.push(sql`${singleOrderBy}`);
        } else {
          orderByValues.push(sql`${singleOrderBy}`);
        }
      }
      orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
    const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table, values: valuesOrSelect, onConflict, returning, withList, select, overridingSystemValue_ }) {
    const valuesSqlList = [];
    const columns = table[Table.Symbol.Columns];
    const colEntries = Object.entries(columns).filter(([_, col]) => !col.shouldDisableInsert());
    const insertOrder = colEntries.map(([, column]) => sql.identifier(this.casing.getColumnCasing(column)));
    if (select) {
      const select2 = valuesOrSelect;
      if (is(select2, SQL)) {
        valuesSqlList.push(select2);
      } else {
        valuesSqlList.push(select2.getSQL());
      }
    } else {
      const values = valuesOrSelect;
      valuesSqlList.push(sql.raw("values "));
      for (const [valueIndex, value] of values.entries()) {
        const valueList = [];
        for (const [fieldName, col] of colEntries) {
          const colValue = value[fieldName];
          if (colValue === undefined || is(colValue, Param) && colValue.value === undefined) {
            if (col.defaultFn !== undefined) {
              const defaultFnResult = col.defaultFn();
              const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
              valueList.push(defaultValue);
            } else if (!col.default && col.onUpdateFn !== undefined) {
              const onUpdateFnResult = col.onUpdateFn();
              const newValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
              valueList.push(newValue);
            } else {
              valueList.push(sql`default`);
            }
          } else {
            valueList.push(colValue);
          }
        }
        valuesSqlList.push(valueList);
        if (valueIndex < values.length - 1) {
          valuesSqlList.push(sql`, `);
        }
      }
    }
    const withSql = this.buildWithCTE(withList);
    const valuesSql = sql.join(valuesSqlList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : undefined;
    const overridingSql = overridingSystemValue_ === true ? sql`overriding system value ` : undefined;
    return sql`${withSql}insert into ${table} ${insertOrder} ${overridingSql}${valuesSql}${onConflictSql}${returningSql}`;
  }
  buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
    const concurrentlySql = concurrently ? sql` concurrently` : undefined;
    const withNoDataSql = withNoData ? sql` with no data` : undefined;
    return sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
  }
  prepareTyping(encoder) {
    if (is(encoder, PgJsonb) || is(encoder, PgJson)) {
      return "json";
    } else if (is(encoder, PgNumeric)) {
      return "decimal";
    } else if (is(encoder, PgTime)) {
      return "time";
    } else if (is(encoder, PgTimestamp) || is(encoder, PgTimestampString)) {
      return "timestamp";
    } else if (is(encoder, PgDate) || is(encoder, PgDateString)) {
      return "date";
    } else if (is(encoder, PgUUID)) {
      return "uuid";
    } else {
      return "none";
    }
  }
  sqlToQuery(sql2, invokeSource) {
    return sql2.toQuery({
      casing: this.casing,
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      prepareTyping: this.prepareTyping,
      invokeSource
    });
  }
  buildRelationalQueryWithoutPK({
    fullSchema,
    schema,
    tableNamesMap,
    table,
    tableConfig,
    queryConfig: config,
    tableAlias,
    nestedQueryRelation,
    joinOn
  }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value]) => ({
        dbKey: value.name,
        tsKey: key,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: undefined,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
      if (config.where) {
        const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config.columns)) {
          if (value === undefined) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config.with) {
        selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config.extras) {
        extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: undefined,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config.limit;
      offset = config.offset;
      for (const {
        tsKey: selectedRelationTsKey,
        queryConfig: selectedRelationConfigValue,
        relation
      } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
        const relationTableName = getTableUniqueName(relation.referencedTable);
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(...normalizedRelation.fields.map((field2, i2) => eq(aliasedTableColumn(normalizedRelation.references[i2], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
        const builtRelation = this.buildRelationalQueryWithoutPK({
          fullSchema,
          schema,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
        joins.push({
          on: sql`true`,
          table: new Subquery(builtRelation.sql, {}, relationTableAlias),
          alias: relationTableAlias,
          joinType: "left",
          lateral: true
        });
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError({ message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")` });
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_build_array(${sql.join(selection.map(({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2), sql`, `)})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_agg(${field}${orderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : undefined}), '[]'::json)`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table, tableAlias),
          fields: {},
          fieldsFlat: [{
            path: [],
            field: sql.raw("*")
          }],
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
        where = undefined;
        limit = undefined;
        offset = undefined;
        orderBy = [];
      } else {
        result = aliasedTable(table, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/query-builders/query-builder.js
class TypedQueryBuilder {
  static [entityKind] = "TypedQueryBuilder";
  getSelectedFields() {
    return this._.selectedFields;
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/query-builders/select.js
class PgSelectBuilder {
  static [entityKind] = "PgSelectBuilder";
  fields;
  session;
  dialect;
  withList = [];
  distinct;
  constructor(config) {
    this.fields = config.fields;
    this.session = config.session;
    this.dialect = config.dialect;
    if (config.withList) {
      this.withList = config.withList;
    }
    this.distinct = config.distinct;
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  from(source) {
    const isPartialSelect = !!this.fields;
    const src = source;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(src, Subquery)) {
      fields = Object.fromEntries(Object.keys(src._.selectedFields).map((key) => [key, src[key]]));
    } else if (is(src, PgViewBase)) {
      fields = src[ViewBaseConfig].selectedFields;
    } else if (is(src, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(src);
    }
    return new PgSelectBase({
      table: src,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    }).setToken(this.authToken);
  }
}

class PgSelectQueryBuilderBase extends TypedQueryBuilder {
  static [entityKind] = "PgSelectQueryBuilder";
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  cacheConfig = undefined;
  usedTables = /* @__PURE__ */ new Set;
  constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table,
      fields: { ...fields },
      distinct,
      setOperators: []
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields,
      config: this.config
    };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
    for (const item of extractUsedTable(table))
      this.usedTables.add(item);
  }
  getUsedTables() {
    return [...this.usedTables];
  }
  createJoin(joinType, lateral) {
    return (table, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table);
      for (const item of extractUsedTable(table))
        this.usedTables.add(item);
      if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table, SQL)) {
          const selection = is(table, Subquery) ? table._.selectedFields : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table, joinType, alias: tableName, lateral });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "cross":
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left", false);
  leftJoinLateral = this.createJoin("left", true);
  rightJoin = this.createJoin("right", false);
  innerJoin = this.createJoin("inner", false);
  innerJoinLateral = this.createJoin("inner", true);
  fullJoin = this.createJoin("full", false);
  crossJoin = this.createJoin("cross", false);
  crossJoinLateral = this.createJoin("cross", true);
  createSetOperator(type, isAll) {
    return (rightSelection) => {
      const rightSelect = typeof rightSelection === "function" ? rightSelection(getPgSetOperators()) : rightSelection;
      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
      this.config.setOperators.push({ type, isAll, rightSelect });
      return this;
    };
  }
  union = this.createSetOperator("union", false);
  unionAll = this.createSetOperator("union", true);
  intersect = this.createSetOperator("intersect", false);
  intersectAll = this.createSetOperator("intersect", true);
  except = this.createSetOperator("except", false);
  exceptAll = this.createSetOperator("except", true);
  addSetOperators(setOperators) {
    this.config.setOperators.push(...setOperators);
    return this;
  }
  where(where) {
    if (typeof where === "function") {
      where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.where = where;
    return this;
  }
  having(having) {
    if (typeof having === "function") {
      having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    } else {
      const orderByArray = columns;
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    }
    return this;
  }
  limit(limit) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).limit = limit;
    } else {
      this.config.limit = limit;
    }
    return this;
  }
  offset(offset) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).offset = offset;
    } else {
      this.config.offset = offset;
    }
    return this;
  }
  for(strength, config = {}) {
    this.config.lockingClause = { strength, config };
    return this;
  }
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    const usedTables = [];
    usedTables.push(...extractUsedTable(this.config.table));
    if (this.config.joins) {
      for (const it of this.config.joins)
        usedTables.push(...extractUsedTable(it.table));
    }
    return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias, false, [...new Set(usedTables)]), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  getSelectedFields() {
    return new Proxy(this.config.fields, new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  $dynamic() {
    return this;
  }
  $withCache(config) {
    this.cacheConfig = config === undefined ? { config: {}, enable: true, autoInvalidate: true } : config === false ? { enable: false } : { enable: true, autoInvalidate: true, ...config };
    return this;
  }
}

class PgSelectBase extends PgSelectQueryBuilderBase {
  static [entityKind] = "PgSelect";
  _prepare(name2) {
    const { session, config, dialect, joinsNotNullableMap, authToken, cacheConfig, usedTables } = this;
    if (!session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    const { fields } = config;
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const fieldsList = orderSelectedFields(fields);
      const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name2, true, undefined, {
        type: "select",
        tables: [...usedTables]
      }, cacheConfig);
      query.joinsNotNullableMap = joinsNotNullableMap;
      return query.setToken(authToken);
    });
  }
  prepare(name2) {
    return this._prepare(name2);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
}
applyMixins(PgSelectBase, [QueryPromise]);
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var getPgSetOperators = () => ({
  union,
  unionAll,
  intersect,
  intersectAll,
  except,
  exceptAll
});
var union = createSetOperator("union", false);
var unionAll = createSetOperator("union", true);
var intersect = createSetOperator("intersect", false);
var intersectAll = createSetOperator("intersect", true);
var except = createSetOperator("except", false);
var exceptAll = createSetOperator("except", true);

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
class QueryBuilder {
  static [entityKind] = "PgQueryBuilder";
  dialect;
  dialectConfig;
  constructor(dialect) {
    this.dialect = is(dialect, PgDialect) ? dialect : undefined;
    this.dialectConfig = is(dialect, PgDialect) ? undefined : dialect;
  }
  $with = (alias, selection) => {
    const queryBuilder = this;
    const as = (qb) => {
      if (typeof qb === "function") {
        qb = qb(queryBuilder);
      }
      return new Proxy(new WithSubquery(qb.getSQL(), selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
    };
    return { as };
  };
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        distinct: { on }
      });
    }
    return { select, selectDistinct, selectDistinctOn };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect()
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: { on }
    });
  }
  getDialect() {
    if (!this.dialect) {
      this.dialect = new PgDialect(this.dialectConfig);
    }
    return this.dialect;
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/utils.js
function extractUsedTable(table) {
  if (is(table, PgTable)) {
    return [table[Schema] ? `${table[Schema]}.${table[Table.Symbol.BaseName]}` : table[Table.Symbol.BaseName]];
  }
  if (is(table, Subquery)) {
    return table._.usedTables ?? [];
  }
  if (is(table, SQL)) {
    return table.usedTables ?? [];
  }
  return [];
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/query-builders/delete.js
class PgDeleteBase extends QueryPromise {
  constructor(table, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, withList };
  }
  static [entityKind] = "PgDelete";
  config;
  cacheConfig;
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name2) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name2, true, undefined, {
        type: "delete",
        tables: extractUsedTable(this.config.table)
      }, this.cacheConfig);
    });
  }
  prepare(name2) {
    return this._prepare(name2);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
      alias: getTableName(this.config.table),
      sqlAliasedBehavior: "alias",
      sqlBehavior: "error"
    })) : undefined;
  }
  $dynamic() {
    return this;
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/query-builders/insert.js
class PgInsertBuilder {
  constructor(table, session, dialect, withList, overridingSystemValue_) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
    this.overridingSystemValue_ = overridingSystemValue_;
  }
  static [entityKind] = "PgInsertBuilder";
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  overridingSystemValue() {
    this.overridingSystemValue_ = true;
    return this;
  }
  values(values) {
    values = Array.isArray(values) ? values : [values];
    if (values.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new PgInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList, false, this.overridingSystemValue_).setToken(this.authToken);
  }
  select(selectQuery) {
    const select = typeof selectQuery === "function" ? selectQuery(new QueryBuilder) : selectQuery;
    if (!is(select, SQL) && !haveSameKeys(this.table[Columns], select._.selectedFields)) {
      throw new Error("Insert select error: selected fields are not the same or are in a different order compared to the table definition");
    }
    return new PgInsertBase(this.table, select, this.session, this.dialect, this.withList, true);
  }
}

class PgInsertBase extends QueryPromise {
  constructor(table, values, session, dialect, withList, select, overridingSystemValue_) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, values, withList, select, overridingSystemValue_ };
  }
  static [entityKind] = "PgInsert";
  config;
  cacheConfig;
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  onConflictDoNothing(config = {}) {
    if (config.target === undefined) {
      this.config.onConflict = sql`do nothing`;
    } else {
      let targetColumn = "";
      targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config.target));
      const whereSql = config.where ? sql` where ${config.where}` : undefined;
      this.config.onConflict = sql`(${sql.raw(targetColumn)})${whereSql} do nothing`;
    }
    return this;
  }
  onConflictDoUpdate(config) {
    if (config.where && (config.targetWhere || config.setWhere)) {
      throw new Error('You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.');
    }
    const whereSql = config.where ? sql` where ${config.where}` : undefined;
    const targetWhereSql = config.targetWhere ? sql` where ${config.targetWhere}` : undefined;
    const setWhereSql = config.setWhere ? sql` where ${config.setWhere}` : undefined;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
    let targetColumn = "";
    targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config.target));
    this.config.onConflict = sql`(${sql.raw(targetColumn)})${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;
    return this;
  }
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name2) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name2, true, undefined, {
        type: "insert",
        tables: extractUsedTable(this.config.table)
      }, this.cacheConfig);
    });
  }
  prepare(name2) {
    return this._prepare(name2);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
      alias: getTableName(this.config.table),
      sqlAliasedBehavior: "alias",
      sqlBehavior: "error"
    })) : undefined;
  }
  $dynamic() {
    return this;
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js
class PgRefreshMaterializedView extends QueryPromise {
  constructor(view, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { view };
  }
  static [entityKind] = "PgRefreshMaterializedView";
  config;
  concurrently() {
    if (this.config.withNoData !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.concurrently = true;
    return this;
  }
  withNoData() {
    if (this.config.concurrently !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.withNoData = true;
    return this;
  }
  getSQL() {
    return this.dialect.buildRefreshMaterializedViewQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name2) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), undefined, name2, true);
    });
  }
  prepare(name2) {
    return this._prepare(name2);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/query-builders/update.js
class PgUpdateBuilder {
  constructor(table, session, dialect, withList) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  static [entityKind] = "PgUpdateBuilder";
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  set(values) {
    return new PgUpdateBase(this.table, mapUpdateSet(this.table, values), this.session, this.dialect, this.withList).setToken(this.authToken);
  }
}

class PgUpdateBase extends QueryPromise {
  constructor(table, set, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { set, table, withList, joins: [] };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  static [entityKind] = "PgUpdate";
  config;
  tableName;
  joinsNotNullableMap;
  cacheConfig;
  from(source) {
    const src = source;
    const tableName = getTableLikeName(src);
    if (typeof tableName === "string") {
      this.joinsNotNullableMap[tableName] = true;
    }
    this.config.from = src;
    return this;
  }
  getTableLikeFields(table) {
    if (is(table, PgTable)) {
      return table[Table.Symbol.Columns];
    } else if (is(table, Subquery)) {
      return table._.selectedFields;
    }
    return table[ViewBaseConfig].selectedFields;
  }
  createJoin(joinType) {
    return (table, on) => {
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (typeof on === "function") {
        const from = this.config.from && !is(this.config.from, SQL) ? this.getTableLikeFields(this.config.from) : undefined;
        on = on(new Proxy(this.config.table[Table.Symbol.Columns], new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })), from && new Proxy(from, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      this.config.joins.push({ on, table, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields) {
    if (!fields) {
      fields = Object.assign({}, this.config.table[Table.Symbol.Columns]);
      if (this.config.from) {
        const tableName = getTableLikeName(this.config.from);
        if (typeof tableName === "string" && this.config.from && !is(this.config.from, SQL)) {
          const fromFields = this.getTableLikeFields(this.config.from);
          fields[tableName] = fromFields;
        }
        for (const join of this.config.joins) {
          const tableName2 = getTableLikeName(join.table);
          if (typeof tableName2 === "string" && !is(join.table, SQL)) {
            const fromFields = this.getTableLikeFields(join.table);
            fields[tableName2] = fromFields;
          }
        }
      }
    }
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name2) {
    const query = this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name2, true, undefined, {
      type: "insert",
      tables: extractUsedTable(this.config.table)
    }, this.cacheConfig);
    query.joinsNotNullableMap = this.joinsNotNullableMap;
    return query;
  }
  prepare(name2) {
    return this._prepare(name2);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return this._prepare().execute(placeholderValues, this.authToken);
  };
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
      alias: getTableName(this.config.table),
      sqlAliasedBehavior: "alias",
      sqlBehavior: "error"
    })) : undefined;
  }
  $dynamic() {
    return this;
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/query-builders/count.js
class PgCountBuilder extends SQL {
  constructor(params) {
    super(PgCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);
    this.params = params;
    this.mapWith(Number);
    this.session = params.session;
    this.sql = PgCountBuilder.buildCount(params.source, params.filters);
  }
  sql;
  token;
  static [entityKind] = "PgCountBuilder";
  [Symbol.toStringTag] = "PgCountBuilder";
  session;
  static buildEmbeddedCount(source, filters) {
    return sql`(select count(*) from ${source}${sql.raw(" where ").if(filters)}${filters})`;
  }
  static buildCount(source, filters) {
    return sql`select count(*) as count from ${source}${sql.raw(" where ").if(filters)}${filters};`;
  }
  setToken(token) {
    this.token = token;
    return this;
  }
  then(onfulfilled, onrejected) {
    return Promise.resolve(this.session.count(this.sql, this.token)).then(onfulfilled, onrejected);
  }
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/query-builders/query.js
class RelationalQueryBuilder {
  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
  }
  static [entityKind] = "PgRelationalQueryBuilder";
  findMany(config) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, "many");
  }
  findFirst(config) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, "first");
  }
}

class PgRelationalQuery extends QueryPromise {
  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
    this.config = config;
    this.mode = mode;
  }
  static [entityKind] = "PgRelationalQuery";
  _prepare(name2) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const { query, builtQuery } = this._toSQL();
      return this.session.prepareQuery(builtQuery, undefined, name2, true, (rawRows, mapColumnValue) => {
        const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
        if (this.mode === "first") {
          return rows[0];
        }
        return rows;
      });
    });
  }
  prepare(name2) {
    return this._prepare(name2);
  }
  _getQuery() {
    return this.dialect.buildRelationalQueryWithoutPK({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
  }
  getSQL() {
    return this._getQuery().sql;
  }
  _toSQL() {
    const query = this._getQuery();
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute() {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(undefined, this.authToken);
    });
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/query-builders/raw.js
class PgRaw extends QueryPromise {
  constructor(execute, sql2, query, mapBatchResult) {
    super();
    this.execute = execute;
    this.sql = sql2;
    this.query = query;
    this.mapBatchResult = mapBatchResult;
  }
  static [entityKind] = "PgRaw";
  getSQL() {
    return this.sql;
  }
  getQuery() {
    return this.query;
  }
  mapResult(result, isFromBatch) {
    return isFromBatch ? this.mapBatchResult(result) : result;
  }
  _prepare() {
    return this;
  }
  isResponseInArrayMode() {
    return false;
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/db.js
class PgDatabase {
  constructor(dialect, session, schema) {
    this.dialect = dialect;
    this.session = session;
    this._ = schema ? {
      schema: schema.schema,
      fullSchema: schema.fullSchema,
      tableNamesMap: schema.tableNamesMap,
      session
    } : {
      schema: undefined,
      fullSchema: {},
      tableNamesMap: {},
      session
    };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder(schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns, dialect, session);
      }
    }
    this.$cache = { invalidate: async (_params) => {
    } };
  }
  static [entityKind] = "PgDatabase";
  query;
  $with = (alias, selection) => {
    const self2 = this;
    const as = (qb) => {
      if (typeof qb === "function") {
        qb = qb(new QueryBuilder(self2.dialect));
      }
      return new Proxy(new WithSubquery(qb.getSQL(), selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
    };
    return { as };
  };
  $count(source, filters) {
    return new PgCountBuilder({ source, filters, session: this.session });
  }
  $cache;
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: { on }
      });
    }
    function update(table) {
      return new PgUpdateBuilder(table, self2.session, self2.dialect, queries);
    }
    function insert(table) {
      return new PgInsertBuilder(table, self2.session, self2.dialect, queries);
    }
    function delete_(table) {
      return new PgDeleteBase(table, self2.session, self2.dialect, queries);
    }
    return { select, selectDistinct, selectDistinctOn, update, insert, delete: delete_ };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: { on }
    });
  }
  update(table) {
    return new PgUpdateBuilder(table, this.session, this.dialect);
  }
  insert(table) {
    return new PgInsertBuilder(table, this.session, this.dialect);
  }
  delete(table) {
    return new PgDeleteBase(table, this.session, this.dialect);
  }
  refreshMaterializedView(view) {
    return new PgRefreshMaterializedView(view, this.session, this.dialect);
  }
  authToken;
  execute(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    const builtQuery = this.dialect.sqlToQuery(sequel);
    const prepared = this.session.prepareQuery(builtQuery, undefined, undefined, false);
    return new PgRaw(() => prepared.execute(undefined, this.authToken), sequel, builtQuery, (result) => prepared.mapResult(result, true));
  }
  transaction(transaction, config) {
    return this.session.transaction(transaction, config);
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/cache/core/cache.js
class Cache {
  static [entityKind] = "Cache";
}

class NoopCache extends Cache {
  strategy() {
    return "all";
  }
  static [entityKind] = "NoopCache";
  async get(_key) {
    return;
  }
  async put(_hashedQuery, _response, _tables, _config) {
  }
  async onMutate(_params) {
  }
}
async function hashQuery(sql2, params) {
  const dataToHash = `${sql2}-${JSON.stringify(params)}`;
  const encoder = new TextEncoder;
  const data = encoder.encode(dataToHash);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = [...new Uint8Array(hashBuffer)];
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/errors/index.js
class DrizzleQueryError extends Error {
  constructor(query, params, cause) {
    super(`Failed query: ${query}
params: ${params}`);
    this.query = query;
    this.params = params;
    this.cause = cause;
    Error.captureStackTrace(this, DrizzleQueryError);
    if (cause)
      this.cause = cause;
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pg-core/session.js
class PgPreparedQuery {
  constructor(query, cache, queryMetadata, cacheConfig) {
    this.query = query;
    this.cache = cache;
    this.queryMetadata = queryMetadata;
    this.cacheConfig = cacheConfig;
    if (cache && cache.strategy() === "all" && cacheConfig === undefined) {
      this.cacheConfig = { enable: true, autoInvalidate: true };
    }
    if (!this.cacheConfig?.enable) {
      this.cacheConfig = undefined;
    }
  }
  authToken;
  getQuery() {
    return this.query;
  }
  mapResult(response, _isFromBatch) {
    return response;
  }
  setToken(token) {
    this.authToken = token;
    return this;
  }
  static [entityKind] = "PgPreparedQuery";
  joinsNotNullableMap;
  async queryWithCache(queryString, params, query) {
    if (this.cache === undefined || is(this.cache, NoopCache) || this.queryMetadata === undefined) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (this.cacheConfig && !this.cacheConfig.enable) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if ((this.queryMetadata.type === "insert" || this.queryMetadata.type === "update" || this.queryMetadata.type === "delete") && this.queryMetadata.tables.length > 0) {
      try {
        const [res] = await Promise.all([
          query(),
          this.cache.onMutate({ tables: this.queryMetadata.tables })
        ]);
        return res;
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (!this.cacheConfig) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (this.queryMetadata.type === "select") {
      const fromCache = await this.cache.get(this.cacheConfig.tag ?? await hashQuery(queryString, params), this.queryMetadata.tables, this.cacheConfig.tag !== undefined, this.cacheConfig.autoInvalidate);
      if (fromCache === undefined) {
        let result;
        try {
          result = await query();
        } catch (e) {
          throw new DrizzleQueryError(queryString, params, e);
        }
        await this.cache.put(this.cacheConfig.tag ?? await hashQuery(queryString, params), result, this.cacheConfig.autoInvalidate ? this.queryMetadata.tables : [], this.cacheConfig.tag !== undefined, this.cacheConfig.config);
        return result;
      }
      return fromCache;
    }
    try {
      return await query();
    } catch (e) {
      throw new DrizzleQueryError(queryString, params, e);
    }
  }
}

class PgSession {
  constructor(dialect) {
    this.dialect = dialect;
  }
  static [entityKind] = "PgSession";
  execute(query, token) {
    return tracer.startActiveSpan("drizzle.operation", () => {
      const prepared = tracer.startActiveSpan("drizzle.prepareQuery", () => {
        return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined, false);
      });
      return prepared.setToken(token).execute(undefined, token);
    });
  }
  all(query) {
    return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined, false).all();
  }
  async count(sql2, token) {
    const res = await this.execute(sql2, token);
    return Number(res[0]["count"]);
  }
}

class PgTransaction extends PgDatabase {
  constructor(dialect, session, schema, nestedIndex = 0) {
    super(dialect, session, schema);
    this.schema = schema;
    this.nestedIndex = nestedIndex;
  }
  static [entityKind] = "PgTransaction";
  rollback() {
    throw new TransactionRollbackError;
  }
  getTransactionConfigSQL(config) {
    const chunks = [];
    if (config.isolationLevel) {
      chunks.push(`isolation level ${config.isolationLevel}`);
    }
    if (config.accessMode) {
      chunks.push(config.accessMode);
    }
    if (typeof config.deferrable === "boolean") {
      chunks.push(config.deferrable ? "deferrable" : "not deferrable");
    }
    return sql.raw(chunks.join(" "));
  }
  setTransaction(config) {
    return this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config)}`);
  }
}

// ../../packages/psionic/src/persistence/schema.ts
var conversations = pgTable("conversations", {
  id: uuid("id").defaultRandom().primaryKey(),
  userId: text("user_id").notNull().default("local"),
  title: text("title"),
  model: text("model"),
  lastMessageAt: timestamp("last_message_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  archived: boolean("archived").default(false),
  metadata: jsonb("metadata").$type().default({})
}, (table) => ({
  userIdIdx: index("idx_user_created").on(table.userId, table.createdAt),
  archivedIdx: index("idx_archived").on(table.archived)
}));
var messages = pgTable("messages", {
  id: uuid("id").defaultRandom().primaryKey(),
  conversationId: uuid("conversation_id").notNull().references(() => conversations.id, { onDelete: "cascade" }),
  role: text("role").notNull().$type(),
  content: text("content").notNull(),
  model: text("model"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  metadata: jsonb("metadata").$type().default({})
}, (table) => ({
  conversationIdx: index("idx_conversation_created").on(table.conversationId, table.createdAt),
  roleIdx: index("idx_role").on(table.role)
}));
// ../../node_modules/.pnpm/@electric-sql+pglite@0.3.3/node_modules/@electric-sql/pglite/dist/chunk-7PRRATDV.js
var hn = {};
F(hn, { ABSTIME: () => Et, ACLITEM: () => Vt, BIT: () => Wt, BOOL: () => be, BPCHAR: () => _e, BYTEA: () => ge, CHAR: () => gt2, CID: () => St, CIDR: () => Tt, CIRCLE: () => Ut, DATE: () => He, FLOAT4: () => je, FLOAT8: () => Qe, GTSVECTOR: () => rn, INET: () => kt, INT2: () => ve, INT4: () => Ge, INT8: () => we, INTERVAL: () => vt, JSON: () => Ae, JSONB: () => Ye, MACADDR: () => Ot, MACADDR8: () => Nt, MONEY: () => Lt, NUMERIC: () => Qt, OID: () => We, PATH: () => Mt, PG_DEPENDENCIES: () => en, PG_LSN: () => Xt, PG_NDISTINCT: () => Zt, PG_NODE_TREE: () => Bt, POLYGON: () => Rt, REFCURSOR: () => _t, REGCLASS: () => Yt, REGCONFIG: () => sn, REGDICTIONARY: () => an, REGNAMESPACE: () => on, REGOPER: () => Ht, REGOPERATOR: () => qt, REGPROC: () => wt, REGPROCEDURE: () => zt, REGROLE: () => un, REGTYPE: () => $t, RELTIME: () => Ct, SMGR: () => It, TEXT: () => F2, TID: () => At, TIME: () => Ft, TIMESTAMP: () => qe, TIMESTAMPTZ: () => xe, TIMETZ: () => Gt, TINTERVAL: () => Pt, TSQUERY: () => nn, TSVECTOR: () => tn, TXID_SNAPSHOT: () => Jt, UUID: () => Kt, VARBIT: () => jt, VARCHAR: () => ze, XID: () => xt, XML: () => Dt, arrayParser: () => yn, arraySerializer: () => Ke, parseType: () => ue, parsers: () => ln, serializers: () => cn, types: () => $e });
u();
var ht = globalThis.JSON.parse;
var bt = globalThis.JSON.stringify;
var be = 16;
var ge = 17;
var gt2 = 18;
var we = 20;
var ve = 21;
var Ge = 23;
var wt = 24;
var F2 = 25;
var We = 26;
var At = 27;
var xt = 28;
var St = 29;
var Ae = 114;
var Dt = 142;
var Bt = 194;
var It = 210;
var Mt = 602;
var Rt = 604;
var Tt = 650;
var je = 700;
var Qe = 701;
var Et = 702;
var Ct = 703;
var Pt = 704;
var Ut = 718;
var Nt = 774;
var Lt = 790;
var Ot = 829;
var kt = 869;
var Vt = 1033;
var _e = 1042;
var ze = 1043;
var He = 1082;
var Ft = 1083;
var qe = 1114;
var xe = 1184;
var vt = 1186;
var Gt = 1266;
var Wt = 1560;
var jt = 1562;
var Qt = 1700;
var _t = 1790;
var zt = 2202;
var Ht = 2203;
var qt = 2204;
var Yt = 2205;
var $t = 2206;
var Kt = 2950;
var Jt = 2970;
var Xt = 3220;
var Zt = 3361;
var en = 3402;
var tn = 3614;
var nn = 3615;
var rn = 3642;
var sn = 3734;
var an = 3769;
var Ye = 3802;
var on = 4089;
var un = 4096;
var $e = { string: { to: F2, from: [F2, ze, _e], serialize: (e) => {
  if (typeof e == "string")
    return e;
  if (typeof e == "number")
    return e.toString();
  throw new Error("Invalid input for string type");
}, parse: (e) => e }, number: { to: 0, from: [ve, Ge, We, je, Qe], serialize: (e) => e.toString(), parse: (e) => +e }, bigint: { to: we, from: [we], serialize: (e) => e.toString(), parse: (e) => {
  let t = BigInt(e);
  return t < Number.MIN_SAFE_INTEGER || t > Number.MAX_SAFE_INTEGER ? t : Number(t);
} }, json: { to: Ae, from: [Ae, Ye], serialize: (e) => typeof e == "string" ? e : bt(e), parse: (e) => ht(e) }, boolean: { to: be, from: [be], serialize: (e) => {
  if (typeof e != "boolean")
    throw new Error("Invalid input for boolean type");
  return e ? "t" : "f";
}, parse: (e) => e === "t" }, date: { to: xe, from: [He, qe, xe], serialize: (e) => {
  if (typeof e == "string")
    return e;
  if (typeof e == "number")
    return new Date(e).toISOString();
  if (e instanceof Date)
    return e.toISOString();
  throw new Error("Invalid input for date type");
}, parse: (e) => new Date(e) }, bytea: { to: ge, from: [ge], serialize: (e) => {
  if (!(e instanceof Uint8Array))
    throw new Error("Invalid input for bytea type");
  return "\\x" + Array.from(e).map((t) => t.toString(16).padStart(2, "0")).join("");
}, parse: (e) => {
  let t = e.slice(2);
  return Uint8Array.from({ length: t.length / 2 }, (n, r) => parseInt(t.substring(r * 2, (r + 1) * 2), 16));
} } };
var Se = pn($e);
var ln = Se.parsers;
var cn = Se.serializers;
function ue(e, t, n) {
  if (e === null)
    return null;
  let r = n?.[t] ?? Se.parsers[t];
  return r ? r(e, t) : e;
}
function pn(e) {
  return Object.keys(e).reduce(({ parsers: t, serializers: n }, r) => {
    let { to: i2, from: a, serialize: u2, parse: d } = e[r];
    return n[i2] = u2, n[r] = u2, t[r] = d, Array.isArray(a) ? a.forEach((c) => {
      t[c] = d, n[c] = u2;
    }) : (t[a] = d, n[a] = u2), { parsers: t, serializers: n };
  }, { parsers: {}, serializers: {} });
}
var dn = /\\/g;
var fn = /"/g;
function mn(e) {
  return e.replace(dn, "\\\\").replace(fn, "\\\"");
}
function Ke(e, t, n) {
  if (Array.isArray(e) === false)
    return e;
  if (!e.length)
    return "{}";
  let r = e[0], i2 = n === 1020 ? ";" : ",";
  return Array.isArray(r) ? `{${e.map((a) => Ke(a, t, n)).join(i2)}}` : `{${e.map((a) => (a === undefined && (a = null), a === null ? "null" : '"' + mn(t ? t(a) : a.toString()) + '"')).join(i2)}}`;
}
var he = { i: 0, char: null, str: "", quoted: false, last: 0, p: null };
function yn(e, t, n) {
  return he.i = he.last = 0, Je(he, e, t, n)[0];
}
function Je(e, t, n, r) {
  let i2 = [], a = r === 1020 ? ";" : ",";
  for (;e.i < t.length; e.i++) {
    if (e.char = t[e.i], e.quoted)
      e.char === "\\" ? e.str += t[++e.i] : e.char === '"' ? (i2.push(n ? n(e.str) : e.str), e.str = "", e.quoted = t[e.i + 1] === '"', e.last = e.i + 2) : e.str += e.char;
    else if (e.char === '"')
      e.quoted = true;
    else if (e.char === "{")
      e.last = ++e.i, i2.push(Je(e, t, n, r));
    else if (e.char === "}") {
      e.quoted = false, e.last < e.i && i2.push(n ? n(t.slice(e.last, e.i)) : t.slice(e.last, e.i)), e.last = e.i + 1;
      break;
    } else
      e.char === a && e.p !== "}" && e.p !== '"' && (i2.push(n ? n(t.slice(e.last, e.i)) : t.slice(e.last, e.i)), e.last = e.i + 1);
    e.p = e.char;
  }
  return e.last < e.i && i2.push(n ? n(t.slice(e.last, e.i + 1)) : t.slice(e.last, e.i + 1)), i2;
}
var wn = {};
F(wn, { parseDescribeStatementResults: () => De, parseResults: () => bn });
u();
function bn(e, t, n, r) {
  let i2 = [], a = { rows: [], fields: [] }, u2 = 0, d = { ...t, ...n?.parsers };
  return e.forEach((c) => {
    switch (c.name) {
      case "rowDescription": {
        let V = c;
        a.fields = V.fields.map((T2) => ({ name: T2.name, dataTypeID: T2.dataTypeID }));
        break;
      }
      case "dataRow": {
        if (!a)
          break;
        let V = c;
        n?.rowMode === "array" ? a.rows.push(V.fields.map((T2, ie) => ue(T2, a.fields[ie].dataTypeID, d))) : a.rows.push(Object.fromEntries(V.fields.map((T2, ie) => [a.fields[ie].name, ue(T2, a.fields[ie].dataTypeID, d)])));
        break;
      }
      case "commandComplete": {
        u2 += gn(c), i2.push({ ...a, affectedRows: u2, ...r ? { blob: r } : {} }), a = { rows: [], fields: [] };
        break;
      }
    }
  }), i2.length === 0 && i2.push({ affectedRows: 0, rows: [], fields: [] }), i2;
}
function gn(e) {
  let t = e.text.split(" ");
  switch (t[0]) {
    case "INSERT":
      return parseInt(t[2], 10);
    case "UPDATE":
    case "DELETE":
    case "COPY":
      return parseInt(t[1], 10);
    default:
      return 0;
  }
}
function De(e) {
  let t = e.find((n) => n.name === "parameterDescription");
  return t ? t.dataTypeIDs : [];
}
var Ue = {};
F(Ue, { AuthenticationCleartextPassword: () => G, AuthenticationMD5Password: () => W, AuthenticationOk: () => v, AuthenticationSASL: () => j, AuthenticationSASLContinue: () => Q, AuthenticationSASLFinal: () => _, BackendKeyDataMessage: () => J, CommandCompleteMessage: () => ee, CopyDataMessage: () => z, CopyResponse: () => H, DataRowMessage: () => te, DatabaseError: () => E, Field: () => q, NoticeMessage: () => ne2, NotificationResponseMessage: () => X, ParameterDescriptionMessage: () => $, ParameterStatusMessage: () => K, ReadyForQueryMessage: () => Z, RowDescriptionMessage: () => Y, bindComplete: () => Ie, closeComplete: () => Me, copyDone: () => Pe, emptyQuery: () => Ce, noData: () => Re, parseComplete: () => Be, portalSuspended: () => Te, replicationStart: () => Ee });
u();
var Be = { name: "parseComplete", length: 5 };
var Ie = { name: "bindComplete", length: 5 };
var Me = { name: "closeComplete", length: 5 };
var Re = { name: "noData", length: 5 };
var Te = { name: "portalSuspended", length: 5 };
var Ee = { name: "replicationStart", length: 4 };
var Ce = { name: "emptyQuery", length: 4 };
var Pe = { name: "copyDone", length: 4 };
var v = class {
  constructor(t) {
    this.length = t;
    this.name = "authenticationOk";
  }
};
var G = class {
  constructor(t) {
    this.length = t;
    this.name = "authenticationCleartextPassword";
  }
};
var W = class {
  constructor(t, n) {
    this.length = t;
    this.salt = n;
    this.name = "authenticationMD5Password";
  }
};
var j = class {
  constructor(t, n) {
    this.length = t;
    this.mechanisms = n;
    this.name = "authenticationSASL";
  }
};
var Q = class {
  constructor(t, n) {
    this.length = t;
    this.data = n;
    this.name = "authenticationSASLContinue";
  }
};
var _ = class {
  constructor(t, n) {
    this.length = t;
    this.data = n;
    this.name = "authenticationSASLFinal";
  }
};
var E = class extends Error {
  constructor(n, r, i2) {
    super(n);
    this.length = r;
    this.name = i2;
  }
};
var z = class {
  constructor(t, n) {
    this.length = t;
    this.chunk = n;
    this.name = "copyData";
  }
};
var H = class {
  constructor(t, n, r, i2) {
    this.length = t;
    this.name = n;
    this.binary = r;
    this.columnTypes = new Array(i2);
  }
};
var q = class {
  constructor(t, n, r, i2, a, u2, d) {
    this.name = t;
    this.tableID = n;
    this.columnID = r;
    this.dataTypeID = i2;
    this.dataTypeSize = a;
    this.dataTypeModifier = u2;
    this.format = d;
  }
};
var Y = class {
  constructor(t, n) {
    this.length = t;
    this.fieldCount = n;
    this.name = "rowDescription";
    this.fields = new Array(this.fieldCount);
  }
};
var $ = class {
  constructor(t, n) {
    this.length = t;
    this.parameterCount = n;
    this.name = "parameterDescription";
    this.dataTypeIDs = new Array(this.parameterCount);
  }
};
var K = class {
  constructor(t, n, r) {
    this.length = t;
    this.parameterName = n;
    this.parameterValue = r;
    this.name = "parameterStatus";
  }
};
var J = class {
  constructor(t, n, r) {
    this.length = t;
    this.processID = n;
    this.secretKey = r;
    this.name = "backendKeyData";
  }
};
var X = class {
  constructor(t, n, r, i2) {
    this.length = t;
    this.processId = n;
    this.channel = r;
    this.payload = i2;
    this.name = "notification";
  }
};
var Z = class {
  constructor(t, n) {
    this.length = t;
    this.status = n;
    this.name = "readyForQuery";
  }
};
var ee = class {
  constructor(t, n) {
    this.length = t;
    this.text = n;
    this.name = "commandComplete";
  }
};
var te = class {
  constructor(t, n) {
    this.length = t;
    this.fields = n;
    this.name = "dataRow";
    this.fieldCount = n.length;
  }
};
var ne2 = class {
  constructor(t, n) {
    this.length = t;
    this.message = n;
    this.name = "notice";
  }
};
var zn = {};
F(zn, { Parser: () => ye, messages: () => Ue, serialize: () => O });
u();
u();
u();
u();
function C2(e) {
  let t = e.length;
  for (let n = e.length - 1;n >= 0; n--) {
    let r = e.charCodeAt(n);
    r > 127 && r <= 2047 ? t++ : r > 2047 && r <= 65535 && (t += 2), r >= 56320 && r <= 57343 && n--;
  }
  return t;
}
var b;
var g;
var U2;
var ce2;
var N;
var x2;
var le;
var P2;
var Xe;
var R2 = class {
  constructor(t = 256) {
    this.size = t;
    R(this, x2);
    R(this, b);
    R(this, g, 5);
    R(this, U2, false);
    R(this, ce2, new TextEncoder);
    R(this, N, 0);
    x(this, b, T(this, x2, le).call(this, t));
  }
  addInt32(t) {
    return T(this, x2, P2).call(this, 4), h(this, b).setInt32(h(this, g), t, h(this, U2)), x(this, g, h(this, g) + 4), this;
  }
  addInt16(t) {
    return T(this, x2, P2).call(this, 2), h(this, b).setInt16(h(this, g), t, h(this, U2)), x(this, g, h(this, g) + 2), this;
  }
  addCString(t) {
    return t && this.addString(t), T(this, x2, P2).call(this, 1), h(this, b).setUint8(h(this, g), 0), U(this, g)._++, this;
  }
  addString(t = "") {
    let n = C2(t);
    return T(this, x2, P2).call(this, n), h(this, ce2).encodeInto(t, new Uint8Array(h(this, b).buffer, h(this, g))), x(this, g, h(this, g) + n), this;
  }
  add(t) {
    return T(this, x2, P2).call(this, t.byteLength), new Uint8Array(h(this, b).buffer).set(new Uint8Array(t), h(this, g)), x(this, g, h(this, g) + t.byteLength), this;
  }
  flush(t) {
    let n = T(this, x2, Xe).call(this, t);
    return x(this, g, 5), x(this, b, T(this, x2, le).call(this, this.size)), new Uint8Array(n);
  }
};
b = new WeakMap, g = new WeakMap, U2 = new WeakMap, ce2 = new WeakMap, N = new WeakMap, x2 = new WeakSet, le = function(t) {
  return new DataView(new ArrayBuffer(t));
}, P2 = function(t) {
  if (h(this, b).byteLength - h(this, g) < t) {
    let r = h(this, b).buffer, i2 = r.byteLength + (r.byteLength >> 1) + t;
    x(this, b, T(this, x2, le).call(this, i2)), new Uint8Array(h(this, b).buffer).set(new Uint8Array(r));
  }
}, Xe = function(t) {
  if (t) {
    h(this, b).setUint8(h(this, N), t);
    let n = h(this, g) - (h(this, N) + 1);
    h(this, b).setInt32(h(this, N) + 1, n, h(this, U2));
  }
  return h(this, b).buffer.slice(t ? 0 : 5, h(this, g));
};
var m = new R2;
var An = (e) => {
  m.addInt16(3).addInt16(0);
  for (let r of Object.keys(e))
    m.addCString(r).addCString(e[r]);
  m.addCString("client_encoding").addCString("UTF8");
  let t = m.addCString("").flush(), n = t.byteLength + 4;
  return new R2().addInt32(n).add(t).flush();
};
var xn = () => {
  let e = new DataView(new ArrayBuffer(8));
  return e.setInt32(0, 8, false), e.setInt32(4, 80877103, false), new Uint8Array(e.buffer);
};
var Sn = (e) => m.addCString(e).flush(112);
var Dn = (e, t) => (m.addCString(e).addInt32(C2(t)).addString(t), m.flush(112));
var Bn = (e) => m.addString(e).flush(112);
var In = (e) => m.addCString(e).flush(81);
var Mn = [];
var Rn = (e) => {
  let t = e.name ?? "";
  t.length > 63 && (console.error("Warning! Postgres only supports 63 characters for query names."), console.error("You supplied %s (%s)", t, t.length), console.error("This can cause conflicts and silent errors executing queries"));
  let n = m.addCString(t).addCString(e.text).addInt16(e.types?.length ?? 0);
  return e.types?.forEach((r) => n.addInt32(r)), m.flush(80);
};
var L2 = new R2;
var Tn = (e, t) => {
  for (let n = 0;n < e.length; n++) {
    let r = t ? t(e[n], n) : e[n];
    if (r === null)
      m.addInt16(0), L2.addInt32(-1);
    else if (r instanceof ArrayBuffer || ArrayBuffer.isView(r)) {
      let i2 = ArrayBuffer.isView(r) ? r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength) : r;
      m.addInt16(1), L2.addInt32(i2.byteLength), L2.add(i2);
    } else
      m.addInt16(0), L2.addInt32(C2(r)), L2.addString(r);
  }
};
var En = (e = {}) => {
  let t = e.portal ?? "", n = e.statement ?? "", r = e.binary ?? false, i2 = e.values ?? Mn, a = i2.length;
  return m.addCString(t).addCString(n), m.addInt16(a), Tn(i2, e.valueMapper), m.addInt16(a), m.add(L2.flush()), m.addInt16(r ? 1 : 0), m.flush(66);
};
var Cn = new Uint8Array([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]);
var Pn = (e) => {
  if (!e || !e.portal && !e.rows)
    return Cn;
  let t = e.portal ?? "", n = e.rows ?? 0, r = C2(t), i2 = 4 + r + 1 + 4, a = new DataView(new ArrayBuffer(1 + i2));
  return a.setUint8(0, 69), a.setInt32(1, i2, false), new TextEncoder().encodeInto(t, new Uint8Array(a.buffer, 5)), a.setUint8(r + 5, 0), a.setUint32(a.byteLength - 4, n, false), new Uint8Array(a.buffer);
};
var Un = (e, t) => {
  let n = new DataView(new ArrayBuffer(16));
  return n.setInt32(0, 16, false), n.setInt16(4, 1234, false), n.setInt16(6, 5678, false), n.setInt32(8, e, false), n.setInt32(12, t, false), new Uint8Array(n.buffer);
};
var Ne = (e, t) => {
  let n = new R2;
  return n.addCString(t), n.flush(e);
};
var Nn = m.addCString("P").flush(68);
var Ln = m.addCString("S").flush(68);
var On = (e) => e.name ? Ne(68, `${e.type}${e.name ?? ""}`) : e.type === "P" ? Nn : Ln;
var kn = (e) => {
  let t = `${e.type}${e.name ?? ""}`;
  return Ne(67, t);
};
var Vn = (e) => m.add(e).flush(100);
var Fn = (e) => Ne(102, e);
var pe = (e) => new Uint8Array([e, 0, 0, 0, 4]);
var vn = pe(72);
var Gn = pe(83);
var Wn = pe(88);
var jn = pe(99);
var O = { startup: An, password: Sn, requestSsl: xn, sendSASLInitialResponseMessage: Dn, sendSCRAMClientFinalMessage: Bn, query: In, parse: Rn, bind: En, execute: Pn, describe: On, close: kn, flush: () => vn, sync: () => Gn, end: () => Wn, copyData: Vn, copyDone: () => jn, copyFail: Fn, cancel: Un };
u();
u();
var Le = { text: 0, binary: 1 };
u();
var Qn = new ArrayBuffer(0);
var M;
var w;
var fe;
var me;
var re;
var de = class {
  constructor(t = 0) {
    R(this, M, new DataView(Qn));
    R(this, w);
    R(this, fe, "utf-8");
    R(this, me, new TextDecoder(h(this, fe)));
    R(this, re, false);
    x(this, w, t);
  }
  setBuffer(t, n) {
    x(this, w, t), x(this, M, new DataView(n));
  }
  int16() {
    let t = h(this, M).getInt16(h(this, w), h(this, re));
    return x(this, w, h(this, w) + 2), t;
  }
  byte() {
    let t = h(this, M).getUint8(h(this, w));
    return U(this, w)._++, t;
  }
  int32() {
    let t = h(this, M).getInt32(h(this, w), h(this, re));
    return x(this, w, h(this, w) + 4), t;
  }
  string(t) {
    return h(this, me).decode(this.bytes(t));
  }
  cstring() {
    let t = h(this, w), n = t;
    for (;h(this, M).getUint8(n++) !== 0; )
      ;
    let r = this.string(n - t - 1);
    return x(this, w, n), r;
  }
  bytes(t) {
    let n = h(this, M).buffer.slice(h(this, w), h(this, w) + t);
    return x(this, w, h(this, w) + t), new Uint8Array(n);
  }
};
M = new WeakMap, w = new WeakMap, fe = new WeakMap, me = new WeakMap, re = new WeakMap;
var Oe = 1;
var _n = 4;
var Ze = Oe + _n;
var et = new ArrayBuffer(0);
var A;
var S;
var D;
var o;
var l;
var tt;
var nt;
var rt;
var st;
var it;
var at;
var ot;
var ke;
var ut;
var lt2;
var ct;
var pt;
var dt;
var ft;
var mt;
var yt;
var Ve;
var ye = class {
  constructor() {
    R(this, l);
    R(this, A, new DataView(et));
    R(this, S, 0);
    R(this, D, 0);
    R(this, o, new de);
  }
  parse(t, n) {
    T(this, l, tt).call(this, ArrayBuffer.isView(t) ? t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength) : t);
    let r = h(this, D) + h(this, S), i2 = h(this, D);
    for (;i2 + Ze <= r; ) {
      let a = h(this, A).getUint8(i2), u2 = h(this, A).getUint32(i2 + Oe, false), d = Oe + u2;
      if (d + i2 <= r) {
        let c = T(this, l, nt).call(this, i2 + Ze, a, u2, h(this, A).buffer);
        n(c), i2 += d;
      } else
        break;
    }
    i2 === r ? (x(this, A, new DataView(et)), x(this, S, 0), x(this, D, 0)) : (x(this, S, r - i2), x(this, D, i2));
  }
};
A = new WeakMap, S = new WeakMap, D = new WeakMap, o = new WeakMap, l = new WeakSet, tt = function(t) {
  if (h(this, S) > 0) {
    let n = h(this, S) + t.byteLength;
    if (n + h(this, D) > h(this, A).byteLength) {
      let i2;
      if (n <= h(this, A).byteLength && h(this, D) >= h(this, S))
        i2 = h(this, A).buffer;
      else {
        let a = h(this, A).byteLength * 2;
        for (;n >= a; )
          a *= 2;
        i2 = new ArrayBuffer(a);
      }
      new Uint8Array(i2).set(new Uint8Array(h(this, A).buffer, h(this, D), h(this, S))), x(this, A, new DataView(i2)), x(this, D, 0);
    }
    new Uint8Array(h(this, A).buffer).set(new Uint8Array(t), h(this, D) + h(this, S)), x(this, S, n);
  } else
    x(this, A, new DataView(t)), x(this, D, 0), x(this, S, t.byteLength);
}, nt = function(t, n, r, i2) {
  switch (n) {
    case 50:
      return Ie;
    case 49:
      return Be;
    case 51:
      return Me;
    case 110:
      return Re;
    case 115:
      return Te;
    case 99:
      return Pe;
    case 87:
      return Ee;
    case 73:
      return Ce;
    case 68:
      return T(this, l, dt).call(this, t, r, i2);
    case 67:
      return T(this, l, st).call(this, t, r, i2);
    case 90:
      return T(this, l, rt).call(this, t, r, i2);
    case 65:
      return T(this, l, ut).call(this, t, r, i2);
    case 82:
      return T(this, l, yt).call(this, t, r, i2);
    case 83:
      return T(this, l, ft).call(this, t, r, i2);
    case 75:
      return T(this, l, mt).call(this, t, r, i2);
    case 69:
      return T(this, l, Ve).call(this, t, r, i2, "error");
    case 78:
      return T(this, l, Ve).call(this, t, r, i2, "notice");
    case 84:
      return T(this, l, lt2).call(this, t, r, i2);
    case 116:
      return T(this, l, pt).call(this, t, r, i2);
    case 71:
      return T(this, l, at).call(this, t, r, i2);
    case 72:
      return T(this, l, ot).call(this, t, r, i2);
    case 100:
      return T(this, l, it).call(this, t, r, i2);
    default:
      return new E("received invalid response: " + n.toString(16), r, "error");
  }
}, rt = function(t, n, r) {
  h(this, o).setBuffer(t, r);
  let i2 = h(this, o).string(1);
  return new Z(n, i2);
}, st = function(t, n, r) {
  h(this, o).setBuffer(t, r);
  let i2 = h(this, o).cstring();
  return new ee(n, i2);
}, it = function(t, n, r) {
  let i2 = r.slice(t, t + (n - 4));
  return new z(n, new Uint8Array(i2));
}, at = function(t, n, r) {
  return T(this, l, ke).call(this, t, n, r, "copyInResponse");
}, ot = function(t, n, r) {
  return T(this, l, ke).call(this, t, n, r, "copyOutResponse");
}, ke = function(t, n, r, i2) {
  h(this, o).setBuffer(t, r);
  let a = h(this, o).byte() !== 0, u2 = h(this, o).int16(), d = new H(n, i2, a, u2);
  for (let c = 0;c < u2; c++)
    d.columnTypes[c] = h(this, o).int16();
  return d;
}, ut = function(t, n, r) {
  h(this, o).setBuffer(t, r);
  let i2 = h(this, o).int32(), a = h(this, o).cstring(), u2 = h(this, o).cstring();
  return new X(n, i2, a, u2);
}, lt2 = function(t, n, r) {
  h(this, o).setBuffer(t, r);
  let i2 = h(this, o).int16(), a = new Y(n, i2);
  for (let u2 = 0;u2 < i2; u2++)
    a.fields[u2] = T(this, l, ct).call(this);
  return a;
}, ct = function() {
  let t = h(this, o).cstring(), n = h(this, o).int32(), r = h(this, o).int16(), i2 = h(this, o).int32(), a = h(this, o).int16(), u2 = h(this, o).int32(), d = h(this, o).int16() === 0 ? Le.text : Le.binary;
  return new q(t, n, r, i2, a, u2, d);
}, pt = function(t, n, r) {
  h(this, o).setBuffer(t, r);
  let i2 = h(this, o).int16(), a = new $(n, i2);
  for (let u2 = 0;u2 < i2; u2++)
    a.dataTypeIDs[u2] = h(this, o).int32();
  return a;
}, dt = function(t, n, r) {
  h(this, o).setBuffer(t, r);
  let i2 = h(this, o).int16(), a = new Array(i2);
  for (let u2 = 0;u2 < i2; u2++) {
    let d = h(this, o).int32();
    a[u2] = d === -1 ? null : h(this, o).string(d);
  }
  return new te(n, a);
}, ft = function(t, n, r) {
  h(this, o).setBuffer(t, r);
  let i2 = h(this, o).cstring(), a = h(this, o).cstring();
  return new K(n, i2, a);
}, mt = function(t, n, r) {
  h(this, o).setBuffer(t, r);
  let i2 = h(this, o).int32(), a = h(this, o).int32();
  return new J(n, i2, a);
}, yt = function(t, n, r) {
  h(this, o).setBuffer(t, r);
  let i2 = h(this, o).int32();
  switch (i2) {
    case 0:
      return new v(n);
    case 3:
      return new G(n);
    case 5:
      return new W(n, h(this, o).bytes(4));
    case 10: {
      let a = [];
      for (;; ) {
        let u2 = h(this, o).cstring();
        if (u2.length === 0)
          return new j(n, a);
        a.push(u2);
      }
    }
    case 11:
      return new Q(n, h(this, o).string(n - 8));
    case 12:
      return new _(n, h(this, o).string(n - 8));
    default:
      throw new Error("Unknown authenticationOk message type " + i2);
  }
}, Ve = function(t, n, r, i2) {
  h(this, o).setBuffer(t, r);
  let a = {}, u2 = h(this, o).string(1);
  for (;u2 !== "\x00"; )
    a[u2] = h(this, o).cstring(), u2 = h(this, o).string(1);
  let d = a.M, c = i2 === "notice" ? new ne2(n, d) : new E(d, n, i2);
  return c.severity = a.S, c.code = a.C, c.detail = a.D, c.hint = a.H, c.position = a.P, c.internalPosition = a.p, c.internalQuery = a.q, c.where = a.W, c.schema = a.s, c.table = a.t, c.column = a.c, c.dataType = a.d, c.constraint = a.n, c.file = a.F, c.line = a.L, c.routine = a.R, c;
};
u();
var Fe = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
var se;
async function Rr() {
  if (Fe || se)
    return;
  let e = new URL("./pglite.wasm", import.meta.url);
  se = fetch(e);
}
var k;
async function Tr(e, t) {
  if (t || k)
    return WebAssembly.instantiate(t || k, e), { instance: await WebAssembly.instantiate(t || k, e), module: t || k };
  let n = new URL("./pglite.wasm", import.meta.url);
  if (Fe) {
    let i2 = await (await import("fs/promises")).readFile(n), { module: a, instance: u2 } = await WebAssembly.instantiate(i2, e);
    return k = a, { instance: u2, module: a };
  } else {
    se || (se = fetch(n));
    let r = await se, { module: i2, instance: a } = await WebAssembly.instantiateStreaming(r, e);
    return k = i2, { instance: a, module: i2 };
  }
}
async function Er() {
  let e = new URL("./pglite.data", import.meta.url);
  return Fe ? (await (await import("fs/promises")).readFile(e)).buffer : (await fetch(e)).arrayBuffer();
}
var Cr = () => {
  if (globalThis.crypto?.randomUUID)
    return globalThis.crypto.randomUUID();
  let e = new Uint8Array(16);
  if (globalThis.crypto?.getRandomValues)
    globalThis.crypto.getRandomValues(e);
  else
    for (let n = 0;n < e.length; n++)
      e[n] = Math.floor(Math.random() * 256);
  e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128;
  let t = [];
  return e.forEach((n) => {
    t.push(n.toString(16).padStart(2, "0"));
  }), t.slice(0, 4).join("") + "-" + t.slice(4, 6).join("") + "-" + t.slice(6, 8).join("") + "-" + t.slice(8, 10).join("") + "-" + t.slice(10).join("");
};
async function Pr(e, t, n, r) {
  if (!n || n.length === 0)
    return t;
  r = r ?? e;
  let i2;
  try {
    await e.execProtocol(O.parse({ text: t }), { syncToFs: false }), i2 = De((await e.execProtocol(O.describe({ type: "S" }), { syncToFs: false })).messages);
  } finally {
    await e.execProtocol(O.sync(), { syncToFs: false });
  }
  let a = t.replace(/\$([0-9]+)/g, (d, c) => "%" + c + "L");
  return (await r.query(`SELECT format($1, ${n.map((d, c) => `$${c + 2}`).join(", ")}) as query`, [a, ...n], { paramTypes: [F2, ...i2] })).rows[0].query;
}
function Ur(e) {
  let t, n = false, r = async () => {
    if (!t) {
      n = false;
      return;
    }
    n = true;
    let { args: i2, resolve: a, reject: u2 } = t;
    t = undefined;
    try {
      let d = await e(...i2);
      a(d);
    } catch (d) {
      u2(d);
    } finally {
      r();
    }
  };
  return async (...i2) => {
    t && t.resolve(undefined);
    let a = new Promise((u2, d) => {
      t = { args: i2, resolve: u2, reject: d };
    });
    return n || r(), a;
  };
}
function Nr(e) {
  let t;
  return e.startsWith('"') && e.endsWith('"') ? t = e.substring(1, e.length - 1) : t = e.toLowerCase(), t;
}

// ../../node_modules/.pnpm/@electric-sql+pglite@0.3.3/node_modules/@electric-sql/pglite/dist/chunk-STOZMFXW.js
u();
var o2 = { part: "part", container: "container" };
function s(t, r, ...e) {
  let a = t.length - 1, p = e.length - 1;
  if (p !== -1) {
    if (p === 0) {
      t[a] = t[a] + e[0] + r;
      return;
    }
    t[a] = t[a] + e[0], t.push(...e.slice(1, p)), t.push(e[p] + r);
  }
}
function y(t, ...r) {
  let e = [t[0]];
  e.raw = [t.raw[0]];
  let a = [];
  for (let p = 0;p < r.length; p++) {
    let n = r[p], i2 = p + 1;
    if (n?._templateType === o2.part) {
      s(e, t[i2], n.str), s(e.raw, t.raw[i2], n.str);
      continue;
    }
    if (n?._templateType === o2.container) {
      s(e, t[i2], ...n.strings), s(e.raw, t.raw[i2], ...n.strings.raw), a.push(...n.values);
      continue;
    }
    e.push(t[i2]), e.raw.push(t.raw[i2]), a.push(n);
  }
  return { _templateType: "container", strings: e, values: a };
}
function g2(t, ...r) {
  let { strings: e, values: a } = y(t, ...r);
  return { query: [e[0], ...a.flatMap((p, n) => [`$${n + 1}`, e[n + 1]])].join(""), params: a };
}

// ../../node_modules/.pnpm/@electric-sql+pglite@0.3.3/node_modules/@electric-sql/pglite/dist/chunk-TGYMLQND.js
u();
var b2;
var u2;
var r;
var l2;
var d;
var h2;
var R3;
var z2 = class {
  constructor() {
    R(this, r);
    this.serializers = { ...cn };
    this.parsers = { ...ln };
    R(this, b2, false);
    R(this, u2, false);
  }
  async _initArrayTypes({ force: t = false } = {}) {
    if (h(this, b2) && !t)
      return;
    x(this, b2, true);
    let e = await this.query(`
      SELECT b.oid, b.typarray
      FROM pg_catalog.pg_type a
      LEFT JOIN pg_catalog.pg_type b ON b.oid = a.typelem
      WHERE a.typcategory = 'A'
      GROUP BY b.oid, b.typarray
      ORDER BY b.oid
    `);
    for (let s2 of e.rows)
      this.serializers[s2.typarray] = (i2) => Ke(i2, this.serializers[s2.oid], s2.typarray), this.parsers[s2.typarray] = (i2) => yn(i2, this.parsers[s2.oid], s2.typarray);
  }
  async refreshArrayTypes() {
    await this._initArrayTypes({ force: true });
  }
  async query(t, e, s2) {
    return await this._checkReady(), await this._runExclusiveTransaction(async () => await T(this, r, d).call(this, t, e, s2));
  }
  async sql(t, ...e) {
    let { query: s2, params: i2 } = g2(t, ...e);
    return await this.query(s2, i2);
  }
  async exec(t, e) {
    return await this._checkReady(), await this._runExclusiveTransaction(async () => await T(this, r, h2).call(this, t, e));
  }
  async describeQuery(t, e) {
    try {
      await T(this, r, l2).call(this, O.parse({ text: t, types: e?.paramTypes }), e);
      let s2 = await T(this, r, l2).call(this, O.describe({ type: "S" }), e), i2 = s2.messages.find((n) => n.name === "parameterDescription"), c = s2.messages.find((n) => n.name === "rowDescription"), y2 = i2?.dataTypeIDs.map((n) => ({ dataTypeID: n, serializer: this.serializers[n] })) ?? [], m2 = c?.fields.map((n) => ({ name: n.name, dataTypeID: n.dataTypeID, parser: this.parsers[n.dataTypeID] })) ?? [];
      return { queryParams: y2, resultFields: m2 };
    } finally {
      await T(this, r, l2).call(this, O.sync(), e);
    }
  }
  async transaction(t) {
    return await this._checkReady(), await this._runExclusiveTransaction(async () => {
      await T(this, r, h2).call(this, "BEGIN"), x(this, u2, true);
      let e = false, s2 = () => {
        if (e)
          throw new Error("Transaction is closed");
      }, i2 = { query: async (c, y2, m2) => (s2(), await T(this, r, d).call(this, c, y2, m2)), sql: async (c, ...y2) => {
        let { query: m2, params: n } = g2(c, ...y2);
        return await T(this, r, d).call(this, m2, n);
      }, exec: async (c, y2) => (s2(), await T(this, r, h2).call(this, c, y2)), rollback: async () => {
        s2(), await T(this, r, h2).call(this, "ROLLBACK"), e = true;
      }, get closed() {
        return e;
      } };
      try {
        let c = await t(i2);
        return e || (e = true, await T(this, r, h2).call(this, "COMMIT")), x(this, u2, false), c;
      } catch (c) {
        throw e || await T(this, r, h2).call(this, "ROLLBACK"), x(this, u2, false), c;
      }
    });
  }
  async runExclusive(t) {
    return await this._runExclusiveQuery(t);
  }
};
b2 = new WeakMap, u2 = new WeakMap, r = new WeakSet, l2 = async function(t, e = {}) {
  return await this.execProtocol(t, { ...e, syncToFs: false });
}, d = async function(t, e = [], s2) {
  return await this._runExclusiveQuery(async () => {
    T(this, r, R3).call(this, "runQuery", t, e, s2), await this._handleBlob(s2?.blob);
    let i2;
    try {
      let { messages: y2 } = await T(this, r, l2).call(this, O.parse({ text: t, types: s2?.paramTypes }), s2), m2 = De((await T(this, r, l2).call(this, O.describe({ type: "S" }), s2)).messages), n = e.map((T2, B) => {
        let x3 = m2[B];
        if (T2 == null)
          return null;
        let _2 = s2?.serializers?.[x3] ?? this.serializers[x3];
        return _2 ? _2(T2) : T2.toString();
      });
      i2 = [...y2, ...(await T(this, r, l2).call(this, O.bind({ values: n }), s2)).messages, ...(await T(this, r, l2).call(this, O.describe({ type: "P" }), s2)).messages, ...(await T(this, r, l2).call(this, O.execute({}), s2)).messages];
    } finally {
      await T(this, r, l2).call(this, O.sync(), s2);
    }
    await this._cleanupBlob(), h(this, u2) || await this.syncToFs();
    let c = await this._getWrittenBlob();
    return bn(i2, this.parsers, s2, c)[0];
  });
}, h2 = async function(t, e) {
  return await this._runExclusiveQuery(async () => {
    T(this, r, R3).call(this, "runExec", t, e), await this._handleBlob(e?.blob);
    let s2;
    try {
      s2 = (await T(this, r, l2).call(this, O.query(t), e)).messages;
    } finally {
      await T(this, r, l2).call(this, O.sync(), e);
    }
    this._cleanupBlob(), h(this, u2) || await this.syncToFs();
    let i2 = await this._getWrittenBlob();
    return bn(s2, this.parsers, e, i2);
  });
}, R3 = function(...t) {
  this.debug > 0 && console.log(...t);
};

// ../../node_modules/.pnpm/@electric-sql+pglite@0.3.3/node_modules/@electric-sql/pglite/dist/index.js
u();
u();
u();
var et2 = new Error("timeout while waiting for mutex to become available");
var tt2 = new Error("mutex already locked");
var Ke2 = new Error("request for lock canceled");
var Ye2 = function(e, t, r2, a) {
  function o3(s2) {
    return s2 instanceof r2 ? s2 : new r2(function(l3) {
      l3(s2);
    });
  }
  return new (r2 || (r2 = Promise))(function(s2, l3) {
    function _2(p) {
      try {
        m2(a.next(p));
      } catch (d2) {
        l3(d2);
      }
    }
    function n(p) {
      try {
        m2(a.throw(p));
      } catch (d2) {
        l3(d2);
      }
    }
    function m2(p) {
      p.done ? s2(p.value) : o3(p.value).then(_2, n);
    }
    m2((a = a.apply(e, t || [])).next());
  });
};
var fe2 = class {
  constructor(t, r2 = Ke2) {
    this._value = t, this._cancelError = r2, this._weightedQueues = [], this._weightedWaiters = [];
  }
  acquire(t = 1) {
    if (t <= 0)
      throw new Error(`invalid weight ${t}: must be positive`);
    return new Promise((r2, a) => {
      this._weightedQueues[t - 1] || (this._weightedQueues[t - 1] = []), this._weightedQueues[t - 1].push({ resolve: r2, reject: a }), this._dispatch();
    });
  }
  runExclusive(t, r2 = 1) {
    return Ye2(this, undefined, undefined, function* () {
      let [a, o3] = yield this.acquire(r2);
      try {
        return yield t(a);
      } finally {
        o3();
      }
    });
  }
  waitForUnlock(t = 1) {
    if (t <= 0)
      throw new Error(`invalid weight ${t}: must be positive`);
    return new Promise((r2) => {
      this._weightedWaiters[t - 1] || (this._weightedWaiters[t - 1] = []), this._weightedWaiters[t - 1].push(r2), this._dispatch();
    });
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(t) {
    this._value = t, this._dispatch();
  }
  release(t = 1) {
    if (t <= 0)
      throw new Error(`invalid weight ${t}: must be positive`);
    this._value += t, this._dispatch();
  }
  cancel() {
    this._weightedQueues.forEach((t) => t.forEach((r2) => r2.reject(this._cancelError))), this._weightedQueues = [];
  }
  _dispatch() {
    var t;
    for (let r2 = this._value;r2 > 0; r2--) {
      let a = (t = this._weightedQueues[r2 - 1]) === null || t === undefined ? undefined : t.shift();
      if (!a)
        continue;
      let o3 = this._value, s2 = r2;
      this._value -= r2, r2 = this._value + 1, a.resolve([o3, this._newReleaser(s2)]);
    }
    this._drainUnlockWaiters();
  }
  _newReleaser(t) {
    let r2 = false;
    return () => {
      r2 || (r2 = true, this.release(t));
    };
  }
  _drainUnlockWaiters() {
    for (let t = this._value;t > 0; t--)
      this._weightedWaiters[t - 1] && (this._weightedWaiters[t - 1].forEach((r2) => r2()), this._weightedWaiters[t - 1] = []);
  }
};
var Je2 = function(e, t, r2, a) {
  function o3(s2) {
    return s2 instanceof r2 ? s2 : new r2(function(l3) {
      l3(s2);
    });
  }
  return new (r2 || (r2 = Promise))(function(s2, l3) {
    function _2(p) {
      try {
        m2(a.next(p));
      } catch (d2) {
        l3(d2);
      }
    }
    function n(p) {
      try {
        m2(a.throw(p));
      } catch (d2) {
        l3(d2);
      }
    }
    function m2(p) {
      p.done ? s2(p.value) : o3(p.value).then(_2, n);
    }
    m2((a = a.apply(e, t || [])).next());
  });
};
var X2 = class {
  constructor(t) {
    this._semaphore = new fe2(1, t);
  }
  acquire() {
    return Je2(this, undefined, undefined, function* () {
      let [, t] = yield this._semaphore.acquire();
      return t;
    });
  }
  runExclusive(t) {
    return this._semaphore.runExclusive(() => t());
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock() {
    return this._semaphore.waitForUnlock();
  }
  release() {
    this._semaphore.isLocked() && this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};
u();
var Pe2 = L(or(), 1);
async function xe2(e) {
  if (Fe) {
    let t = await import("fs"), r2 = await import("./index-z7xxh162.js"), { Writable: a } = await import("./index-1dgnsgf4.js"), { pipeline: o3 } = await import("stream/promises");
    if (!t.existsSync(e))
      throw new Error(`Extension bundle not found: ${e}`);
    let s2 = r2.createGunzip(), l3 = [];
    return await o3(t.createReadStream(e), s2, new a({ write(_2, n, m2) {
      l3.push(_2), m2();
    } })), new Blob(l3);
  } else {
    let t = await fetch(e.toString());
    if (!t.ok || !t.body)
      return null;
    if (t.headers.get("Content-Encoding") === "gzip")
      return t.blob();
    {
      let r2 = new DecompressionStream("gzip");
      return new Response(t.body.pipeThrough(r2)).blob();
    }
  }
}
async function ke2(e, t) {
  for (let r2 in e.pg_extensions) {
    let a;
    try {
      a = await e.pg_extensions[r2];
    } catch (o3) {
      console.error("Failed to fetch extension:", r2, o3);
      continue;
    }
    if (a) {
      let o3 = new Uint8Array(await a.arrayBuffer());
      Qe2(e, r2, o3, t);
    } else
      console.error("Could not get binary data for extension:", r2);
  }
}
function Qe2(e, t, r2, a) {
  Pe2.default.untar(r2).forEach((s2) => {
    if (!s2.name.startsWith(".")) {
      let l3 = e.WASM_PREFIX + "/" + s2.name;
      if (s2.name.endsWith(".so")) {
        let _2 = (...m2) => {
          a("pgfs:ext OK", l3, m2);
        }, n = (...m2) => {
          a("pgfs:ext FAIL", l3, m2);
        };
        e.FS.createPreloadedFile($e2(l3), s2.name.split("/").pop().slice(0, -3), s2.data, true, true, _2, n, false);
      } else
        e.FS.writeFile(l3, s2.data);
    }
  });
}
function $e2(e) {
  let t = e.lastIndexOf("/");
  return t > 0 ? e.slice(0, t) : e;
}
u();
u();
var ee2 = class extends ur {
  async init(t, r2) {
    return this.pg = t, { emscriptenOpts: { ...r2, preRun: [...r2.preRun || [], (o3) => {
      let s2 = o3.FS.filesystems.IDBFS;
      o3.FS.mkdir("/pglite"), o3.FS.mkdir(`/pglite/${this.dataDir}`), o3.FS.mount(s2, {}, `/pglite/${this.dataDir}`), o3.FS.symlink(`/pglite/${this.dataDir}`, C);
    }] } };
  }
  initialSyncFs() {
    return new Promise((t, r2) => {
      this.pg.Module.FS.syncfs(true, (a) => {
        a ? r2(a) : t();
      });
    });
  }
  syncToFs(t) {
    return new Promise((r2, a) => {
      this.pg.Module.FS.syncfs(false, (o3) => {
        o3 ? a(o3) : r2();
      });
    });
  }
  async closeFs() {
    let t = this.pg.Module.FS.filesystems.IDBFS.dbs[this.dataDir];
    t && t.close(), this.pg.Module.FS.quit();
  }
};
u();
var te2 = class extends ur {
  async closeFs() {
    this.pg.Module.FS.quit();
  }
};
function Ae2(e) {
  let t;
  if (e?.startsWith("file://")) {
    if (e = e.slice(7), !e)
      throw new Error("Invalid dataDir, must be a valid path");
    t = "nodefs";
  } else
    e?.startsWith("idb://") ? (e = e.slice(6), t = "idbfs") : e?.startsWith("opfs-ahp://") ? (e = e.slice(11), t = "opfs-ahp") : !e || e?.startsWith("memory://") ? t = "memoryfs" : t = "nodefs";
  return { dataDir: e, fsType: t };
}
async function Te2(e, t) {
  let r2;
  if (e && t === "nodefs") {
    let { NodeFS: a } = await import("./nodefs-3dkq9kfd.js");
    r2 = new a(e);
  } else if (e && t === "idbfs")
    r2 = new ee2(e);
  else if (e && t === "opfs-ahp") {
    let { OpfsAhpFS: a } = await import("./opfs-ahp-pp0k6qhc.js");
    r2 = new a(e);
  } else
    r2 = new te2;
  return r2;
}
u();
u();
var Ze2 = (() => {
  var _scriptName = import.meta.url;
  return async function(moduleArg = {}) {
    var moduleRtn, Module = moduleArg, readyPromiseResolve, readyPromiseReject, readyPromise = new Promise((e, t) => {
      readyPromiseResolve = e, readyPromiseReject = t;
    }), ENVIRONMENT_IS_WEB = typeof window == "object", ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope < "u", ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && process.type != "renderer";
    if (ENVIRONMENT_IS_NODE) {
      let { createRequire: e } = await import("module"), t = import.meta.url;
      t.startsWith("data:") && (t = "/");
      var require = e(t);
    }
    Module.expectedDataFileDownloads ?? (Module.expectedDataFileDownloads = 0), Module.expectedDataFileDownloads++, (() => {
      var e = typeof ENVIRONMENT_IS_PTHREAD < "u" && ENVIRONMENT_IS_PTHREAD, t = typeof ENVIRONMENT_IS_WASM_WORKER < "u" && ENVIRONMENT_IS_WASM_WORKER;
      if (e || t)
        return;
      var r2 = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
      function a(o3) {
        var s2 = "";
        typeof window == "object" ? s2 = window.encodeURIComponent(window.location.pathname.substring(0, window.location.pathname.lastIndexOf("/")) + "/") : typeof process > "u" && typeof location < "u" && (s2 = encodeURIComponent(location.pathname.substring(0, location.pathname.lastIndexOf("/")) + "/"));
        var l3 = "/tmp/sdk/dist/pglite-web/pglite.data", _2 = "pglite.data", n = Module.locateFile ? Module.locateFile(_2, "") : _2, m2 = o3.remote_package_size;
        function p(c, w2, h3, v2) {
          if (r2) {
            require("fs").readFile(c, (x3, y2) => {
              x3 ? v2(x3) : h3(y2.buffer);
            });
            return;
          }
          Module.dataFileDownloads ?? (Module.dataFileDownloads = {}), fetch(c).catch((x3) => Promise.reject(new Error(`Network Error: ${c}`, { cause: x3 }))).then((x3) => {
            if (!x3.ok)
              return Promise.reject(new Error(`${x3.status}: ${x3.url}`));
            if (!x3.body && x3.arrayBuffer)
              return x3.arrayBuffer().then(h3);
            let y2 = x3.body.getReader(), M2 = () => y2.read().then(W2).catch((D2) => Promise.reject(new Error(`Unexpected error while handling : ${x3.url} ${D2}`, { cause: D2 }))), E2 = [], b3 = x3.headers, U3 = Number(b3.get("Content-Length") ?? w2), z3 = 0, W2 = ({ done: D2, value: N2 }) => {
              if (D2) {
                let P3 = new Uint8Array(E2.map((k2) => k2.length).reduce((k2, Le2) => k2 + Le2, 0)), R4 = 0;
                for (let k2 of E2)
                  P3.set(k2, R4), R4 += k2.length;
                h3(P3.buffer);
              } else {
                E2.push(N2), z3 += N2.length, Module.dataFileDownloads[c] = { loaded: z3, total: U3 };
                let P3 = 0, R4 = 0;
                for (let k2 of Object.values(Module.dataFileDownloads))
                  P3 += k2.loaded, R4 += k2.total;
                return Module.setStatus?.(`Downloading data... (${P3}/${R4})`), M2();
              }
            };
            return Module.setStatus?.("Downloading data..."), M2();
          });
        }
        function d2(c) {
          console.error("package error:", c);
        }
        var g3 = null, u3 = Module.getPreloadedPackage ? Module.getPreloadedPackage(n, m2) : null;
        u3 || p(n, m2, (c) => {
          g3 ? (g3(c), g3 = null) : u3 = c;
        }, d2);
        function f(c) {
          function w2(M2, E2) {
            if (!M2)
              throw E2 + new Error().stack;
          }
          c.FS_createPath("/", "home", true, true), c.FS_createPath("/home", "web_user", true, true), c.FS_createPath("/", "tmp", true, true), c.FS_createPath("/tmp", "pglite", true, true), c.FS_createPath("/tmp/pglite", "bin", true, true), c.FS_createPath("/tmp/pglite", "lib", true, true), c.FS_createPath("/tmp/pglite/lib", "postgresql", true, true), c.FS_createPath("/tmp/pglite/lib/postgresql", "pgxs", true, true), c.FS_createPath("/tmp/pglite/lib/postgresql/pgxs", "config", true, true), c.FS_createPath("/tmp/pglite/lib/postgresql/pgxs", "src", true, true), c.FS_createPath("/tmp/pglite/lib/postgresql/pgxs/src", "makefiles", true, true), c.FS_createPath("/tmp/pglite", "share", true, true), c.FS_createPath("/tmp/pglite/share", "postgresql", true, true), c.FS_createPath("/tmp/pglite/share/postgresql", "extension", true, true), c.FS_createPath("/tmp/pglite/share/postgresql", "timezone", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Africa", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone", "America", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone/America", "Argentina", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone/America", "Indiana", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone/America", "Kentucky", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone/America", "North_Dakota", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Antarctica", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Arctic", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Asia", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Atlantic", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Australia", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Brazil", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Canada", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Chile", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Etc", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Europe", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Indian", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Mexico", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone", "Pacific", true, true), c.FS_createPath("/tmp/pglite/share/postgresql/timezone", "US", true, true), c.FS_createPath("/tmp/pglite/share/postgresql", "timezonesets", true, true), c.FS_createPath("/tmp/pglite/share/postgresql", "tsearch_data", true, true);
          function h3(M2, E2, b3) {
            this.start = M2, this.end = E2, this.audio = b3;
          }
          h3.prototype = { requests: {}, open: function(M2, E2) {
            this.name = E2, this.requests[E2] = this, c.addRunDependency(`fp ${this.name}`);
          }, send: function() {
          }, onload: function() {
            var M2 = this.byteArray.subarray(this.start, this.end);
            this.finish(M2);
          }, finish: function(M2) {
            var E2 = this;
            c.FS_createDataFile(this.name, null, M2, true, true, true), c.removeRunDependency(`fp ${E2.name}`), this.requests[this.name] = null;
          } };
          for (var v2 = o3.files, x3 = 0;x3 < v2.length; ++x3)
            new h3(v2[x3].start, v2[x3].end, v2[x3].audio || 0).open("GET", v2[x3].filename);
          function y2(M2) {
            w2(M2, "Loading data file failed."), w2(M2.constructor.name === ArrayBuffer.name, "bad input to processPackageData");
            var E2 = new Uint8Array(M2);
            h3.prototype.byteArray = E2;
            for (var b3 = o3.files, U3 = 0;U3 < b3.length; ++U3)
              h3.prototype.requests[b3[U3].filename].onload();
            c.removeRunDependency("datafile_/tmp/sdk/dist/pglite-web/pglite.data");
          }
          c.addRunDependency("datafile_/tmp/sdk/dist/pglite-web/pglite.data"), c.preloadResults ?? (c.preloadResults = {}), c.preloadResults[l3] = { fromCache: false }, u3 ? (y2(u3), u3 = null) : g3 = y2;
        }
        Module.calledRun ? f(Module) : (Module.preRun ?? (Module.preRun = [])).push(f);
      }
      a({ files: [{ filename: "/home/web_user/.pgpass", start: 0, end: 204 }, { filename: "/tmp/pglite/bin/initdb", start: 204, end: 204 }, { filename: "/tmp/pglite/bin/postgres", start: 204, end: 204 }, { filename: "/tmp/pglite/lib/postgresql/cyrillic_and_mic.so", start: 204, end: 4699 }, { filename: "/tmp/pglite/lib/postgresql/dict_snowball.so", start: 4699, end: 576732 }, { filename: "/tmp/pglite/lib/postgresql/euc2004_sjis2004.so", start: 576732, end: 578729 }, { filename: "/tmp/pglite/lib/postgresql/euc_cn_and_mic.so", start: 578729, end: 579667 }, { filename: "/tmp/pglite/lib/postgresql/euc_jp_and_sjis.so", start: 579667, end: 586924 }, { filename: "/tmp/pglite/lib/postgresql/euc_kr_and_mic.so", start: 586924, end: 587876 }, { filename: "/tmp/pglite/lib/postgresql/euc_tw_and_big5.so", start: 587876, end: 592450 }, { filename: "/tmp/pglite/lib/postgresql/latin2_and_win1250.so", start: 592450, end: 593857 }, { filename: "/tmp/pglite/lib/postgresql/latin_and_mic.so", start: 593857, end: 594879 }, { filename: "/tmp/pglite/lib/postgresql/libpqwalreceiver.so", start: 594879, end: 715269 }, { filename: "/tmp/pglite/lib/postgresql/pgoutput.so", start: 715269, end: 728610 }, { filename: "/tmp/pglite/lib/postgresql/pgxs/config/install-sh", start: 728610, end: 742607 }, { filename: "/tmp/pglite/lib/postgresql/pgxs/config/missing", start: 742607, end: 743955 }, { filename: "/tmp/pglite/lib/postgresql/pgxs/src/Makefile.global", start: 743955, end: 780212 }, { filename: "/tmp/pglite/lib/postgresql/pgxs/src/Makefile.port", start: 780212, end: 780764 }, { filename: "/tmp/pglite/lib/postgresql/pgxs/src/Makefile.shlib", start: 780764, end: 796066 }, { filename: "/tmp/pglite/lib/postgresql/pgxs/src/makefiles/pgxs.mk", start: 796066, end: 810977 }, { filename: "/tmp/pglite/lib/postgresql/pgxs/src/nls-global.mk", start: 810977, end: 817845 }, { filename: "/tmp/pglite/lib/postgresql/plpgsql.so", start: 817845, end: 967676 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_big5.so", start: 967676, end: 1082425 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_cyrillic.so", start: 1082425, end: 1088400 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_euc2004.so", start: 1088400, end: 1293333 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_euc_cn.so", start: 1293333, end: 1368514 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_euc_jp.so", start: 1368514, end: 1519743 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_euc_kr.so", start: 1519743, end: 1622600 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_euc_tw.so", start: 1622600, end: 1822157 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_gb18030.so", start: 1822157, end: 2084535 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_gbk.so", start: 2084535, end: 2231068 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_iso8859.so", start: 2231068, end: 2254653 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_iso8859_1.so", start: 2254653, end: 2255623 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_johab.so", start: 2255623, end: 2417328 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_sjis.so", start: 2417328, end: 2498989 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_sjis2004.so", start: 2498989, end: 2625622 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_uhc.so", start: 2625622, end: 2792895 }, { filename: "/tmp/pglite/lib/postgresql/utf8_and_win.so", start: 2792895, end: 2819439 }, { filename: "/tmp/pglite/password", start: 2819439, end: 2819448 }, { filename: "/tmp/pglite/share/postgresql/errcodes.txt", start: 2819448, end: 2852840 }, { filename: "/tmp/pglite/share/postgresql/extension/plpgsql--1.0.sql", start: 2852840, end: 2853498 }, { filename: "/tmp/pglite/share/postgresql/extension/plpgsql.control", start: 2853498, end: 2853691 }, { filename: "/tmp/pglite/share/postgresql/information_schema.sql", start: 2853691, end: 2969214 }, { filename: "/tmp/pglite/share/postgresql/pg_hba.conf.sample", start: 2969214, end: 2974839 }, { filename: "/tmp/pglite/share/postgresql/pg_ident.conf.sample", start: 2974839, end: 2977479 }, { filename: "/tmp/pglite/share/postgresql/pg_service.conf.sample", start: 2977479, end: 2978083 }, { filename: "/tmp/pglite/share/postgresql/postgres.bki", start: 2978083, end: 3931351 }, { filename: "/tmp/pglite/share/postgresql/postgresql.conf.sample", start: 3931351, end: 3962013 }, { filename: "/tmp/pglite/share/postgresql/psqlrc.sample", start: 3962013, end: 3962291 }, { filename: "/tmp/pglite/share/postgresql/snowball_create.sql", start: 3962291, end: 4006467 }, { filename: "/tmp/pglite/share/postgresql/sql_features.txt", start: 4006467, end: 4042200 }, { filename: "/tmp/pglite/share/postgresql/system_constraints.sql", start: 4042200, end: 4051095 }, { filename: "/tmp/pglite/share/postgresql/system_functions.sql", start: 4051095, end: 4075398 }, { filename: "/tmp/pglite/share/postgresql/system_views.sql", start: 4075398, end: 4127092 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Abidjan", start: 4127092, end: 4127240 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Accra", start: 4127240, end: 4127388 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Addis_Ababa", start: 4127388, end: 4127653 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Algiers", start: 4127653, end: 4128388 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Asmara", start: 4128388, end: 4128653 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Asmera", start: 4128653, end: 4128918 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Bamako", start: 4128918, end: 4129066 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Bangui", start: 4129066, end: 4129301 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Banjul", start: 4129301, end: 4129449 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Bissau", start: 4129449, end: 4129643 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Blantyre", start: 4129643, end: 4129792 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Brazzaville", start: 4129792, end: 4130027 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Bujumbura", start: 4130027, end: 4130176 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Cairo", start: 4130176, end: 4132575 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Casablanca", start: 4132575, end: 4135004 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Ceuta", start: 4135004, end: 4137056 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Conakry", start: 4137056, end: 4137204 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Dakar", start: 4137204, end: 4137352 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Dar_es_Salaam", start: 4137352, end: 4137617 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Djibouti", start: 4137617, end: 4137882 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Douala", start: 4137882, end: 4138117 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/El_Aaiun", start: 4138117, end: 4140412 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Freetown", start: 4140412, end: 4140560 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Gaborone", start: 4140560, end: 4140709 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Harare", start: 4140709, end: 4140858 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Johannesburg", start: 4140858, end: 4141104 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Juba", start: 4141104, end: 4141783 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Kampala", start: 4141783, end: 4142048 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Khartoum", start: 4142048, end: 4142727 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Kigali", start: 4142727, end: 4142876 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Kinshasa", start: 4142876, end: 4143111 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Lagos", start: 4143111, end: 4143346 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Libreville", start: 4143346, end: 4143581 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Lome", start: 4143581, end: 4143729 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Luanda", start: 4143729, end: 4143964 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Lubumbashi", start: 4143964, end: 4144113 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Lusaka", start: 4144113, end: 4144262 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Malabo", start: 4144262, end: 4144497 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Maputo", start: 4144497, end: 4144646 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Maseru", start: 4144646, end: 4144892 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Mbabane", start: 4144892, end: 4145138 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Mogadishu", start: 4145138, end: 4145403 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Monrovia", start: 4145403, end: 4145611 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Nairobi", start: 4145611, end: 4145876 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Ndjamena", start: 4145876, end: 4146075 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Niamey", start: 4146075, end: 4146310 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Nouakchott", start: 4146310, end: 4146458 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Ouagadougou", start: 4146458, end: 4146606 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Porto-Novo", start: 4146606, end: 4146841 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Sao_Tome", start: 4146841, end: 4147095 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Timbuktu", start: 4147095, end: 4147243 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Tripoli", start: 4147243, end: 4147868 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Tunis", start: 4147868, end: 4148557 }, { filename: "/tmp/pglite/share/postgresql/timezone/Africa/Windhoek", start: 4148557, end: 4149512 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Adak", start: 4149512, end: 4151868 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Anchorage", start: 4151868, end: 4154239 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Anguilla", start: 4154239, end: 4154485 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Antigua", start: 4154485, end: 4154731 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Araguaina", start: 4154731, end: 4155615 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/Buenos_Aires", start: 4155615, end: 4156691 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/Catamarca", start: 4156691, end: 4157767 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/ComodRivadavia", start: 4157767, end: 4158843 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/Cordoba", start: 4158843, end: 4159919 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/Jujuy", start: 4159919, end: 4160967 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/La_Rioja", start: 4160967, end: 4162057 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/Mendoza", start: 4162057, end: 4163133 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/Rio_Gallegos", start: 4163133, end: 4164209 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/Salta", start: 4164209, end: 4165257 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/San_Juan", start: 4165257, end: 4166347 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/San_Luis", start: 4166347, end: 4167449 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/Tucuman", start: 4167449, end: 4168553 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Argentina/Ushuaia", start: 4168553, end: 4169629 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Aruba", start: 4169629, end: 4169875 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Asuncion", start: 4169875, end: 4171533 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Atikokan", start: 4171533, end: 4171715 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Atka", start: 4171715, end: 4174071 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Bahia", start: 4174071, end: 4175095 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Bahia_Banderas", start: 4175095, end: 4176195 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Barbados", start: 4176195, end: 4176631 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Belem", start: 4176631, end: 4177207 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Belize", start: 4177207, end: 4178821 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Blanc-Sablon", start: 4178821, end: 4179067 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Boa_Vista", start: 4179067, end: 4179699 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Bogota", start: 4179699, end: 4179945 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Boise", start: 4179945, end: 4182355 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Buenos_Aires", start: 4182355, end: 4183431 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Cambridge_Bay", start: 4183431, end: 4185685 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Campo_Grande", start: 4185685, end: 4187129 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Cancun", start: 4187129, end: 4187993 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Caracas", start: 4187993, end: 4188257 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Catamarca", start: 4188257, end: 4189333 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Cayenne", start: 4189333, end: 4189531 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Cayman", start: 4189531, end: 4189713 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Chicago", start: 4189713, end: 4193305 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Chihuahua", start: 4193305, end: 4194407 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Ciudad_Juarez", start: 4194407, end: 4195945 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Coral_Harbour", start: 4195945, end: 4196127 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Cordoba", start: 4196127, end: 4197203 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Costa_Rica", start: 4197203, end: 4197519 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Creston", start: 4197519, end: 4197879 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Cuiaba", start: 4197879, end: 4199295 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Curacao", start: 4199295, end: 4199541 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Danmarkshavn", start: 4199541, end: 4200239 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Dawson", start: 4200239, end: 4201853 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Dawson_Creek", start: 4201853, end: 4202903 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Denver", start: 4202903, end: 4205363 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Detroit", start: 4205363, end: 4207593 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Dominica", start: 4207593, end: 4207839 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Edmonton", start: 4207839, end: 4210171 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Eirunepe", start: 4210171, end: 4210827 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/El_Salvador", start: 4210827, end: 4211051 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Ensenada", start: 4211051, end: 4213509 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Fort_Nelson", start: 4213509, end: 4215749 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Fort_Wayne", start: 4215749, end: 4217431 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Fortaleza", start: 4217431, end: 4218147 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Glace_Bay", start: 4218147, end: 4220339 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Godthab", start: 4220339, end: 4222242 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Goose_Bay", start: 4222242, end: 4225452 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Grand_Turk", start: 4225452, end: 4227286 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Grenada", start: 4227286, end: 4227532 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Guadeloupe", start: 4227532, end: 4227778 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Guatemala", start: 4227778, end: 4228058 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Guayaquil", start: 4228058, end: 4228304 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Guyana", start: 4228304, end: 4228566 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Halifax", start: 4228566, end: 4231990 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Havana", start: 4231990, end: 4234406 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Hermosillo", start: 4234406, end: 4234794 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Indiana/Indianapolis", start: 4234794, end: 4236476 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Indiana/Knox", start: 4236476, end: 4238920 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Indiana/Marengo", start: 4238920, end: 4240658 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Indiana/Petersburg", start: 4240658, end: 4242578 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Indiana/Tell_City", start: 4242578, end: 4244278 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Indiana/Vevay", start: 4244278, end: 4245708 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Indiana/Vincennes", start: 4245708, end: 4247418 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Indiana/Winamac", start: 4247418, end: 4249212 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Indianapolis", start: 4249212, end: 4250894 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Inuvik", start: 4250894, end: 4252968 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Iqaluit", start: 4252968, end: 4255170 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Jamaica", start: 4255170, end: 4255652 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Jujuy", start: 4255652, end: 4256700 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Juneau", start: 4256700, end: 4259053 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Kentucky/Louisville", start: 4259053, end: 4261841 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Kentucky/Monticello", start: 4261841, end: 4264209 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Knox_IN", start: 4264209, end: 4266653 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Kralendijk", start: 4266653, end: 4266899 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/La_Paz", start: 4266899, end: 4267131 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Lima", start: 4267131, end: 4267537 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Los_Angeles", start: 4267537, end: 4270389 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Louisville", start: 4270389, end: 4273177 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Lower_Princes", start: 4273177, end: 4273423 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Maceio", start: 4273423, end: 4274167 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Managua", start: 4274167, end: 4274597 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Manaus", start: 4274597, end: 4275201 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Marigot", start: 4275201, end: 4275447 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Martinique", start: 4275447, end: 4275679 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Matamoros", start: 4275679, end: 4277097 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Mazatlan", start: 4277097, end: 4278157 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Mendoza", start: 4278157, end: 4279233 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Menominee", start: 4279233, end: 4281507 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Merida", start: 4281507, end: 4282511 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Metlakatla", start: 4282511, end: 4283934 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Mexico_City", start: 4283934, end: 4285156 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Miquelon", start: 4285156, end: 4286822 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Moncton", start: 4286822, end: 4289976 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Monterrey", start: 4289976, end: 4291090 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Montevideo", start: 4291090, end: 4292600 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Montreal", start: 4292600, end: 4296094 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Montserrat", start: 4296094, end: 4296340 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Nassau", start: 4296340, end: 4299834 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/New_York", start: 4299834, end: 4303386 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Nipigon", start: 4303386, end: 4306880 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Nome", start: 4306880, end: 4309247 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Noronha", start: 4309247, end: 4309963 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/North_Dakota/Beulah", start: 4309963, end: 4312359 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/North_Dakota/Center", start: 4312359, end: 4314755 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/North_Dakota/New_Salem", start: 4314755, end: 4317151 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Nuuk", start: 4317151, end: 4319054 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Ojinaga", start: 4319054, end: 4320578 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Panama", start: 4320578, end: 4320760 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Pangnirtung", start: 4320760, end: 4322962 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Paramaribo", start: 4322962, end: 4323224 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Phoenix", start: 4323224, end: 4323584 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Port-au-Prince", start: 4323584, end: 4325018 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Port_of_Spain", start: 4325018, end: 4325264 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Porto_Acre", start: 4325264, end: 4325892 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Porto_Velho", start: 4325892, end: 4326468 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Puerto_Rico", start: 4326468, end: 4326714 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Punta_Arenas", start: 4326714, end: 4328630 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Rainy_River", start: 4328630, end: 4331498 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Rankin_Inlet", start: 4331498, end: 4333564 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Recife", start: 4333564, end: 4334280 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Regina", start: 4334280, end: 4335260 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Resolute", start: 4335260, end: 4337326 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Rio_Branco", start: 4337326, end: 4337954 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Rosario", start: 4337954, end: 4339030 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Santa_Isabel", start: 4339030, end: 4341488 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Santarem", start: 4341488, end: 4342090 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Santiago", start: 4342090, end: 4344619 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Santo_Domingo", start: 4344619, end: 4345077 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Sao_Paulo", start: 4345077, end: 4346521 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Scoresbysund", start: 4346521, end: 4348470 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Shiprock", start: 4348470, end: 4350930 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Sitka", start: 4350930, end: 4353259 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/St_Barthelemy", start: 4353259, end: 4353505 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/St_Johns", start: 4353505, end: 4357160 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/St_Kitts", start: 4357160, end: 4357406 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/St_Lucia", start: 4357406, end: 4357652 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/St_Thomas", start: 4357652, end: 4357898 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/St_Vincent", start: 4357898, end: 4358144 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Swift_Current", start: 4358144, end: 4358704 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Tegucigalpa", start: 4358704, end: 4358956 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Thule", start: 4358956, end: 4360458 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Thunder_Bay", start: 4360458, end: 4363952 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Tijuana", start: 4363952, end: 4366410 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Toronto", start: 4366410, end: 4369904 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Tortola", start: 4369904, end: 4370150 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Vancouver", start: 4370150, end: 4373042 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Virgin", start: 4373042, end: 4373288 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Whitehorse", start: 4373288, end: 4374902 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Winnipeg", start: 4374902, end: 4377770 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Yakutat", start: 4377770, end: 4380075 }, { filename: "/tmp/pglite/share/postgresql/timezone/America/Yellowknife", start: 4380075, end: 4382407 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/Casey", start: 4382407, end: 4382844 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/Davis", start: 4382844, end: 4383141 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/DumontDUrville", start: 4383141, end: 4383327 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/Macquarie", start: 4383327, end: 4385587 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/Mawson", start: 4385587, end: 4385786 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/McMurdo", start: 4385786, end: 4388223 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/Palmer", start: 4388223, end: 4389641 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/Rothera", start: 4389641, end: 4389805 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/South_Pole", start: 4389805, end: 4392242 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/Syowa", start: 4392242, end: 4392407 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/Troll", start: 4392407, end: 4393569 }, { filename: "/tmp/pglite/share/postgresql/timezone/Antarctica/Vostok", start: 4393569, end: 4393796 }, { filename: "/tmp/pglite/share/postgresql/timezone/Arctic/Longyearbyen", start: 4393796, end: 4396094 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Aden", start: 4396094, end: 4396259 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Almaty", start: 4396259, end: 4397256 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Amman", start: 4397256, end: 4398703 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Anadyr", start: 4398703, end: 4399891 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Aqtau", start: 4399891, end: 4400874 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Aqtobe", start: 4400874, end: 4401885 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Ashgabat", start: 4401885, end: 4402504 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Ashkhabad", start: 4402504, end: 4403123 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Atyrau", start: 4403123, end: 4404114 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Baghdad", start: 4404114, end: 4405097 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Bahrain", start: 4405097, end: 4405296 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Baku", start: 4405296, end: 4406523 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Bangkok", start: 4406523, end: 4406722 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Barnaul", start: 4406722, end: 4407943 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Beirut", start: 4407943, end: 4410097 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Bishkek", start: 4410097, end: 4411080 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Brunei", start: 4411080, end: 4411563 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Calcutta", start: 4411563, end: 4411848 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Chita", start: 4411848, end: 4413069 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Choibalsan", start: 4413069, end: 4413960 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Chongqing", start: 4413960, end: 4414521 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Chungking", start: 4414521, end: 4415082 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Colombo", start: 4415082, end: 4415454 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Dacca", start: 4415454, end: 4415791 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Damascus", start: 4415791, end: 4417678 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Dhaka", start: 4417678, end: 4418015 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Dili", start: 4418015, end: 4418286 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Dubai", start: 4418286, end: 4418451 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Dushanbe", start: 4418451, end: 4419042 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Famagusta", start: 4419042, end: 4421070 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Gaza", start: 4421070, end: 4424914 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Harbin", start: 4424914, end: 4425475 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Hebron", start: 4425475, end: 4429347 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Ho_Chi_Minh", start: 4429347, end: 4429698 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Hong_Kong", start: 4429698, end: 4430931 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Hovd", start: 4430931, end: 4431822 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Irkutsk", start: 4431822, end: 4433065 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Istanbul", start: 4433065, end: 4435012 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Jakarta", start: 4435012, end: 4435395 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Jayapura", start: 4435395, end: 4435616 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Jerusalem", start: 4435616, end: 4438004 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Kabul", start: 4438004, end: 4438212 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Kamchatka", start: 4438212, end: 4439378 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Karachi", start: 4439378, end: 4439757 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Kashgar", start: 4439757, end: 4439922 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Kathmandu", start: 4439922, end: 4440134 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Katmandu", start: 4440134, end: 4440346 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Khandyga", start: 4440346, end: 4441617 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Kolkata", start: 4441617, end: 4441902 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Krasnoyarsk", start: 4441902, end: 4443109 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Kuala_Lumpur", start: 4443109, end: 4443524 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Kuching", start: 4443524, end: 4444007 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Kuwait", start: 4444007, end: 4444172 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Macao", start: 4444172, end: 4445399 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Macau", start: 4445399, end: 4446626 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Magadan", start: 4446626, end: 4447848 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Makassar", start: 4447848, end: 4448102 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Manila", start: 4448102, end: 4448524 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Muscat", start: 4448524, end: 4448689 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Nicosia", start: 4448689, end: 4450691 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Novokuznetsk", start: 4450691, end: 4451856 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Novosibirsk", start: 4451856, end: 4453077 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Omsk", start: 4453077, end: 4454284 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Oral", start: 4454284, end: 4455289 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Phnom_Penh", start: 4455289, end: 4455488 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Pontianak", start: 4455488, end: 4455841 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Pyongyang", start: 4455841, end: 4456078 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Qatar", start: 4456078, end: 4456277 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Qostanay", start: 4456277, end: 4457316 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Qyzylorda", start: 4457316, end: 4458341 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Rangoon", start: 4458341, end: 4458609 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Riyadh", start: 4458609, end: 4458774 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Saigon", start: 4458774, end: 4459125 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Sakhalin", start: 4459125, end: 4460327 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Samarkand", start: 4460327, end: 4460904 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Seoul", start: 4460904, end: 4461521 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Shanghai", start: 4461521, end: 4462082 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Singapore", start: 4462082, end: 4462497 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Srednekolymsk", start: 4462497, end: 4463705 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Taipei", start: 4463705, end: 4464466 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Tashkent", start: 4464466, end: 4465057 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Tbilisi", start: 4465057, end: 4466092 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Tehran", start: 4466092, end: 4467354 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Tel_Aviv", start: 4467354, end: 4469742 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Thimbu", start: 4469742, end: 4469945 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Thimphu", start: 4469945, end: 4470148 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Tokyo", start: 4470148, end: 4470457 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Tomsk", start: 4470457, end: 4471678 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Ujung_Pandang", start: 4471678, end: 4471932 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Ulaanbaatar", start: 4471932, end: 4472823 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Ulan_Bator", start: 4472823, end: 4473714 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Urumqi", start: 4473714, end: 4473879 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Ust-Nera", start: 4473879, end: 4475131 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Vientiane", start: 4475131, end: 4475330 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Vladivostok", start: 4475330, end: 4476538 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Yakutsk", start: 4476538, end: 4477745 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Yangon", start: 4477745, end: 4478013 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Yekaterinburg", start: 4478013, end: 4479256 }, { filename: "/tmp/pglite/share/postgresql/timezone/Asia/Yerevan", start: 4479256, end: 4480407 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Azores", start: 4480407, end: 4483863 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Bermuda", start: 4483863, end: 4486259 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Canary", start: 4486259, end: 4488156 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Cape_Verde", start: 4488156, end: 4488426 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Faeroe", start: 4488426, end: 4490241 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Faroe", start: 4490241, end: 4492056 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Jan_Mayen", start: 4492056, end: 4494354 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Madeira", start: 4494354, end: 4497731 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Reykjavik", start: 4497731, end: 4497879 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/South_Georgia", start: 4497879, end: 4498043 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/St_Helena", start: 4498043, end: 4498191 }, { filename: "/tmp/pglite/share/postgresql/timezone/Atlantic/Stanley", start: 4498191, end: 4499405 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/ACT", start: 4499405, end: 4501595 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Adelaide", start: 4501595, end: 4503803 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Brisbane", start: 4503803, end: 4504222 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Broken_Hill", start: 4504222, end: 4506451 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Canberra", start: 4506451, end: 4508641 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Currie", start: 4508641, end: 4510999 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Darwin", start: 4510999, end: 4511324 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Eucla", start: 4511324, end: 4511794 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Hobart", start: 4511794, end: 4514152 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/LHI", start: 4514152, end: 4516012 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Lindeman", start: 4516012, end: 4516487 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Lord_Howe", start: 4516487, end: 4518347 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Melbourne", start: 4518347, end: 4520537 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/NSW", start: 4520537, end: 4522727 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/North", start: 4522727, end: 4523052 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Perth", start: 4523052, end: 4523498 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Queensland", start: 4523498, end: 4523917 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/South", start: 4523917, end: 4526125 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Sydney", start: 4526125, end: 4528315 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Tasmania", start: 4528315, end: 4530673 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Victoria", start: 4530673, end: 4532863 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/West", start: 4532863, end: 4533309 }, { filename: "/tmp/pglite/share/postgresql/timezone/Australia/Yancowinna", start: 4533309, end: 4535538 }, { filename: "/tmp/pglite/share/postgresql/timezone/Brazil/Acre", start: 4535538, end: 4536166 }, { filename: "/tmp/pglite/share/postgresql/timezone/Brazil/DeNoronha", start: 4536166, end: 4536882 }, { filename: "/tmp/pglite/share/postgresql/timezone/Brazil/East", start: 4536882, end: 4538326 }, { filename: "/tmp/pglite/share/postgresql/timezone/Brazil/West", start: 4538326, end: 4538930 }, { filename: "/tmp/pglite/share/postgresql/timezone/CET", start: 4538930, end: 4541863 }, { filename: "/tmp/pglite/share/postgresql/timezone/CST6CDT", start: 4541863, end: 4545455 }, { filename: "/tmp/pglite/share/postgresql/timezone/Canada/Atlantic", start: 4545455, end: 4548879 }, { filename: "/tmp/pglite/share/postgresql/timezone/Canada/Central", start: 4548879, end: 4551747 }, { filename: "/tmp/pglite/share/postgresql/timezone/Canada/Eastern", start: 4551747, end: 4555241 }, { filename: "/tmp/pglite/share/postgresql/timezone/Canada/Mountain", start: 4555241, end: 4557573 }, { filename: "/tmp/pglite/share/postgresql/timezone/Canada/Newfoundland", start: 4557573, end: 4561228 }, { filename: "/tmp/pglite/share/postgresql/timezone/Canada/Pacific", start: 4561228, end: 4564120 }, { filename: "/tmp/pglite/share/postgresql/timezone/Canada/Saskatchewan", start: 4564120, end: 4565100 }, { filename: "/tmp/pglite/share/postgresql/timezone/Canada/Yukon", start: 4565100, end: 4566714 }, { filename: "/tmp/pglite/share/postgresql/timezone/Chile/Continental", start: 4566714, end: 4569243 }, { filename: "/tmp/pglite/share/postgresql/timezone/Chile/EasterIsland", start: 4569243, end: 4571476 }, { filename: "/tmp/pglite/share/postgresql/timezone/Cuba", start: 4571476, end: 4573892 }, { filename: "/tmp/pglite/share/postgresql/timezone/EET", start: 4573892, end: 4576154 }, { filename: "/tmp/pglite/share/postgresql/timezone/EST", start: 4576154, end: 4576336 }, { filename: "/tmp/pglite/share/postgresql/timezone/EST5EDT", start: 4576336, end: 4579888 }, { filename: "/tmp/pglite/share/postgresql/timezone/Egypt", start: 4579888, end: 4582287 }, { filename: "/tmp/pglite/share/postgresql/timezone/Eire", start: 4582287, end: 4585779 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT", start: 4585779, end: 4585893 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+0", start: 4585893, end: 4586007 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+1", start: 4586007, end: 4586123 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+10", start: 4586123, end: 4586240 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+11", start: 4586240, end: 4586357 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+12", start: 4586357, end: 4586474 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+2", start: 4586474, end: 4586590 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+3", start: 4586590, end: 4586706 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+4", start: 4586706, end: 4586822 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+5", start: 4586822, end: 4586938 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+6", start: 4586938, end: 4587054 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+7", start: 4587054, end: 4587170 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+8", start: 4587170, end: 4587286 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT+9", start: 4587286, end: 4587402 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-0", start: 4587402, end: 4587516 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-1", start: 4587516, end: 4587633 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-10", start: 4587633, end: 4587751 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-11", start: 4587751, end: 4587869 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-12", start: 4587869, end: 4587987 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-13", start: 4587987, end: 4588105 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-14", start: 4588105, end: 4588223 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-2", start: 4588223, end: 4588340 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-3", start: 4588340, end: 4588457 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-4", start: 4588457, end: 4588574 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-5", start: 4588574, end: 4588691 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-6", start: 4588691, end: 4588808 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-7", start: 4588808, end: 4588925 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-8", start: 4588925, end: 4589042 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT-9", start: 4589042, end: 4589159 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/GMT0", start: 4589159, end: 4589273 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/Greenwich", start: 4589273, end: 4589387 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/UCT", start: 4589387, end: 4589501 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/UTC", start: 4589501, end: 4589615 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/Universal", start: 4589615, end: 4589729 }, { filename: "/tmp/pglite/share/postgresql/timezone/Etc/Zulu", start: 4589729, end: 4589843 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Amsterdam", start: 4589843, end: 4592776 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Andorra", start: 4592776, end: 4594518 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Astrakhan", start: 4594518, end: 4595683 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Athens", start: 4595683, end: 4597945 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Belfast", start: 4597945, end: 4601609 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Belgrade", start: 4601609, end: 4603529 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Berlin", start: 4603529, end: 4605827 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Bratislava", start: 4605827, end: 4608128 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Brussels", start: 4608128, end: 4611061 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Bucharest", start: 4611061, end: 4613245 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Budapest", start: 4613245, end: 4615613 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Busingen", start: 4615613, end: 4617522 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Chisinau", start: 4617522, end: 4619912 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Copenhagen", start: 4619912, end: 4622210 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Dublin", start: 4622210, end: 4625702 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Gibraltar", start: 4625702, end: 4628770 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Guernsey", start: 4628770, end: 4632434 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Helsinki", start: 4632434, end: 4634334 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Isle_of_Man", start: 4634334, end: 4637998 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Istanbul", start: 4637998, end: 4639945 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Jersey", start: 4639945, end: 4643609 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Kaliningrad", start: 4643609, end: 4645102 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Kiev", start: 4645102, end: 4647222 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Kirov", start: 4647222, end: 4648407 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Kyiv", start: 4648407, end: 4650527 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Lisbon", start: 4650527, end: 4654054 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Ljubljana", start: 4654054, end: 4655974 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/London", start: 4655974, end: 4659638 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Luxembourg", start: 4659638, end: 4662571 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Madrid", start: 4662571, end: 4665185 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Malta", start: 4665185, end: 4667805 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Mariehamn", start: 4667805, end: 4669705 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Minsk", start: 4669705, end: 4671026 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Monaco", start: 4671026, end: 4673988 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Moscow", start: 4673988, end: 4675523 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Nicosia", start: 4675523, end: 4677525 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Oslo", start: 4677525, end: 4679823 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Paris", start: 4679823, end: 4682785 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Podgorica", start: 4682785, end: 4684705 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Prague", start: 4684705, end: 4687006 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Riga", start: 4687006, end: 4689204 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Rome", start: 4689204, end: 4691845 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Samara", start: 4691845, end: 4693060 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/San_Marino", start: 4693060, end: 4695701 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Sarajevo", start: 4695701, end: 4697621 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Saratov", start: 4697621, end: 4698804 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Simferopol", start: 4698804, end: 4700273 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Skopje", start: 4700273, end: 4702193 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Sofia", start: 4702193, end: 4704270 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Stockholm", start: 4704270, end: 4706568 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Tallinn", start: 4706568, end: 4708716 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Tirane", start: 4708716, end: 4710800 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Tiraspol", start: 4710800, end: 4713190 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Ulyanovsk", start: 4713190, end: 4714457 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Uzhgorod", start: 4714457, end: 4716577 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Vaduz", start: 4716577, end: 4718486 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Vatican", start: 4718486, end: 4721127 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Vienna", start: 4721127, end: 4723327 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Vilnius", start: 4723327, end: 4725489 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Volgograd", start: 4725489, end: 4726682 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Warsaw", start: 4726682, end: 4729336 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Zagreb", start: 4729336, end: 4731256 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Zaporozhye", start: 4731256, end: 4733376 }, { filename: "/tmp/pglite/share/postgresql/timezone/Europe/Zurich", start: 4733376, end: 4735285 }, { filename: "/tmp/pglite/share/postgresql/timezone/Factory", start: 4735285, end: 4735401 }, { filename: "/tmp/pglite/share/postgresql/timezone/GB", start: 4735401, end: 4739065 }, { filename: "/tmp/pglite/share/postgresql/timezone/GB-Eire", start: 4739065, end: 4742729 }, { filename: "/tmp/pglite/share/postgresql/timezone/GMT", start: 4742729, end: 4742843 }, { filename: "/tmp/pglite/share/postgresql/timezone/GMT+0", start: 4742843, end: 4742957 }, { filename: "/tmp/pglite/share/postgresql/timezone/GMT-0", start: 4742957, end: 4743071 }, { filename: "/tmp/pglite/share/postgresql/timezone/GMT0", start: 4743071, end: 4743185 }, { filename: "/tmp/pglite/share/postgresql/timezone/Greenwich", start: 4743185, end: 4743299 }, { filename: "/tmp/pglite/share/postgresql/timezone/HST", start: 4743299, end: 4743628 }, { filename: "/tmp/pglite/share/postgresql/timezone/Hongkong", start: 4743628, end: 4744861 }, { filename: "/tmp/pglite/share/postgresql/timezone/Iceland", start: 4744861, end: 4745009 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Antananarivo", start: 4745009, end: 4745274 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Chagos", start: 4745274, end: 4745473 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Christmas", start: 4745473, end: 4745672 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Cocos", start: 4745672, end: 4745940 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Comoro", start: 4745940, end: 4746205 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Kerguelen", start: 4746205, end: 4746404 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Mahe", start: 4746404, end: 4746569 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Maldives", start: 4746569, end: 4746768 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Mauritius", start: 4746768, end: 4747009 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Mayotte", start: 4747009, end: 4747274 }, { filename: "/tmp/pglite/share/postgresql/timezone/Indian/Reunion", start: 4747274, end: 4747439 }, { filename: "/tmp/pglite/share/postgresql/timezone/Iran", start: 4747439, end: 4748701 }, { filename: "/tmp/pglite/share/postgresql/timezone/Israel", start: 4748701, end: 4751089 }, { filename: "/tmp/pglite/share/postgresql/timezone/Jamaica", start: 4751089, end: 4751571 }, { filename: "/tmp/pglite/share/postgresql/timezone/Japan", start: 4751571, end: 4751880 }, { filename: "/tmp/pglite/share/postgresql/timezone/Kwajalein", start: 4751880, end: 4752196 }, { filename: "/tmp/pglite/share/postgresql/timezone/Libya", start: 4752196, end: 4752821 }, { filename: "/tmp/pglite/share/postgresql/timezone/MET", start: 4752821, end: 4755754 }, { filename: "/tmp/pglite/share/postgresql/timezone/MST", start: 4755754, end: 4756114 }, { filename: "/tmp/pglite/share/postgresql/timezone/MST7MDT", start: 4756114, end: 4758574 }, { filename: "/tmp/pglite/share/postgresql/timezone/Mexico/BajaNorte", start: 4758574, end: 4761032 }, { filename: "/tmp/pglite/share/postgresql/timezone/Mexico/BajaSur", start: 4761032, end: 4762092 }, { filename: "/tmp/pglite/share/postgresql/timezone/Mexico/General", start: 4762092, end: 4763314 }, { filename: "/tmp/pglite/share/postgresql/timezone/NZ", start: 4763314, end: 4765751 }, { filename: "/tmp/pglite/share/postgresql/timezone/NZ-CHAT", start: 4765751, end: 4767819 }, { filename: "/tmp/pglite/share/postgresql/timezone/Navajo", start: 4767819, end: 4770279 }, { filename: "/tmp/pglite/share/postgresql/timezone/PRC", start: 4770279, end: 4770840 }, { filename: "/tmp/pglite/share/postgresql/timezone/PST8PDT", start: 4770840, end: 4773692 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Apia", start: 4773692, end: 4774304 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Auckland", start: 4774304, end: 4776741 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Bougainville", start: 4776741, end: 4777009 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Chatham", start: 4777009, end: 4779077 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Chuuk", start: 4779077, end: 4779263 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Easter", start: 4779263, end: 4781496 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Efate", start: 4781496, end: 4782034 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Enderbury", start: 4782034, end: 4782268 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Fakaofo", start: 4782268, end: 4782468 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Fiji", start: 4782468, end: 4783046 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Funafuti", start: 4783046, end: 4783212 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Galapagos", start: 4783212, end: 4783450 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Gambier", start: 4783450, end: 4783614 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Guadalcanal", start: 4783614, end: 4783780 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Guam", start: 4783780, end: 4784274 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Honolulu", start: 4784274, end: 4784603 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Johnston", start: 4784603, end: 4784932 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Kanton", start: 4784932, end: 4785166 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Kiritimati", start: 4785166, end: 4785404 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Kosrae", start: 4785404, end: 4785755 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Kwajalein", start: 4785755, end: 4786071 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Majuro", start: 4786071, end: 4786237 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Marquesas", start: 4786237, end: 4786410 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Midway", start: 4786410, end: 4786585 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Nauru", start: 4786585, end: 4786837 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Niue", start: 4786837, end: 4787040 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Norfolk", start: 4787040, end: 4787920 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Noumea", start: 4787920, end: 4788224 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Pago_Pago", start: 4788224, end: 4788399 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Palau", start: 4788399, end: 4788579 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Pitcairn", start: 4788579, end: 4788781 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Pohnpei", start: 4788781, end: 4788947 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Ponape", start: 4788947, end: 4789113 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Port_Moresby", start: 4789113, end: 4789299 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Rarotonga", start: 4789299, end: 4789902 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Saipan", start: 4789902, end: 4790396 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Samoa", start: 4790396, end: 4790571 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Tahiti", start: 4790571, end: 4790736 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Tarawa", start: 4790736, end: 4790902 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Tongatapu", start: 4790902, end: 4791274 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Truk", start: 4791274, end: 4791460 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Wake", start: 4791460, end: 4791626 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Wallis", start: 4791626, end: 4791792 }, { filename: "/tmp/pglite/share/postgresql/timezone/Pacific/Yap", start: 4791792, end: 4791978 }, { filename: "/tmp/pglite/share/postgresql/timezone/Poland", start: 4791978, end: 4794632 }, { filename: "/tmp/pglite/share/postgresql/timezone/Portugal", start: 4794632, end: 4798159 }, { filename: "/tmp/pglite/share/postgresql/timezone/ROC", start: 4798159, end: 4798920 }, { filename: "/tmp/pglite/share/postgresql/timezone/ROK", start: 4798920, end: 4799537 }, { filename: "/tmp/pglite/share/postgresql/timezone/Singapore", start: 4799537, end: 4799952 }, { filename: "/tmp/pglite/share/postgresql/timezone/Turkey", start: 4799952, end: 4801899 }, { filename: "/tmp/pglite/share/postgresql/timezone/UCT", start: 4801899, end: 4802013 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Alaska", start: 4802013, end: 4804384 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Aleutian", start: 4804384, end: 4806740 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Arizona", start: 4806740, end: 4807100 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Central", start: 4807100, end: 4810692 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/East-Indiana", start: 4810692, end: 4812374 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Eastern", start: 4812374, end: 4815926 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Hawaii", start: 4815926, end: 4816255 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Indiana-Starke", start: 4816255, end: 4818699 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Michigan", start: 4818699, end: 4820929 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Mountain", start: 4820929, end: 4823389 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Pacific", start: 4823389, end: 4826241 }, { filename: "/tmp/pglite/share/postgresql/timezone/US/Samoa", start: 4826241, end: 4826416 }, { filename: "/tmp/pglite/share/postgresql/timezone/UTC", start: 4826416, end: 4826530 }, { filename: "/tmp/pglite/share/postgresql/timezone/Universal", start: 4826530, end: 4826644 }, { filename: "/tmp/pglite/share/postgresql/timezone/W-SU", start: 4826644, end: 4828179 }, { filename: "/tmp/pglite/share/postgresql/timezone/WET", start: 4828179, end: 4831706 }, { filename: "/tmp/pglite/share/postgresql/timezone/Zulu", start: 4831706, end: 4831820 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Africa.txt", start: 4831820, end: 4838793 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/America.txt", start: 4838793, end: 4849800 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Antarctica.txt", start: 4849800, end: 4850934 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Asia.txt", start: 4850934, end: 4859245 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Atlantic.txt", start: 4859245, end: 4862778 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Australia", start: 4862778, end: 4863913 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Australia.txt", start: 4863913, end: 4867297 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Default", start: 4867297, end: 4894511 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Etc.txt", start: 4894511, end: 4895761 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Europe.txt", start: 4895761, end: 4904507 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/India", start: 4904507, end: 4905100 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Indian.txt", start: 4905100, end: 4906361 }, { filename: "/tmp/pglite/share/postgresql/timezonesets/Pacific.txt", start: 4906361, end: 4910129 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/danish.stop", start: 4910129, end: 4910553 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/dutch.stop", start: 4910553, end: 4911006 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/english.stop", start: 4911006, end: 4911628 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/finnish.stop", start: 4911628, end: 4913207 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/french.stop", start: 4913207, end: 4914012 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/german.stop", start: 4914012, end: 4915361 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/hungarian.stop", start: 4915361, end: 4916588 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample.affix", start: 4916588, end: 4916831 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample_long.affix", start: 4916831, end: 4917464 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample_long.dict", start: 4917464, end: 4917562 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample_num.affix", start: 4917562, end: 4918024 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/hunspell_sample_num.dict", start: 4918024, end: 4918153 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/ispell_sample.affix", start: 4918153, end: 4918618 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/ispell_sample.dict", start: 4918618, end: 4918699 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/italian.stop", start: 4918699, end: 4920353 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/nepali.stop", start: 4920353, end: 4924614 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/norwegian.stop", start: 4924614, end: 4925465 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/portuguese.stop", start: 4925465, end: 4926732 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/russian.stop", start: 4926732, end: 4927967 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/spanish.stop", start: 4927967, end: 4930145 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/swedish.stop", start: 4930145, end: 4930704 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/synonym_sample.syn", start: 4930704, end: 4930777 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/thesaurus_sample.ths", start: 4930777, end: 4931250 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/turkish.stop", start: 4931250, end: 4931510 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/unaccent.rules", start: 4931510, end: 4941513 }, { filename: "/tmp/pglite/share/postgresql/tsearch_data/xsyn_sample.rules", start: 4941513, end: 4941652 }], remote_package_size: 4941652 });
    })();
    var moduleOverrides = Object.assign({}, Module), arguments_ = [], thisProgram = "./this.program", quit_ = (e, t) => {
      throw t;
    }, scriptDirectory = "";
    function locateFile(e) {
      return Module.locateFile ? Module.locateFile(e, scriptDirectory) : scriptDirectory + e;
    }
    var readAsync, readBinary;
    if (ENVIRONMENT_IS_NODE) {
      var fs = require("fs"), nodePath = require("path");
      import.meta.url.startsWith("data:") || (scriptDirectory = nodePath.dirname(require("url").fileURLToPath(import.meta.url)) + "/"), readBinary = (e) => {
        e = isFileURI(e) ? new URL(e) : e;
        var t = fs.readFileSync(e);
        return t;
      }, readAsync = async (e, t = true) => {
        e = isFileURI(e) ? new URL(e) : e;
        var r2 = fs.readFileSync(e, t ? undefined : "utf8");
        return r2;
      }, !Module.thisProgram && process.argv.length > 1 && (thisProgram = process.argv[1].replace(/\\/g, "/")), arguments_ = process.argv.slice(2), quit_ = (e, t) => {
        throw process.exitCode = e, t;
      };
    } else
      (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && (ENVIRONMENT_IS_WORKER ? scriptDirectory = self.location.href : typeof document < "u" && document.currentScript && (scriptDirectory = document.currentScript.src), _scriptName && (scriptDirectory = _scriptName), scriptDirectory.startsWith("blob:") ? scriptDirectory = "" : scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1), readAsync = async (e) => {
        var t = await fetch(e, { credentials: "same-origin" });
        if (t.ok)
          return t.arrayBuffer();
        throw new Error(t.status + " : " + t.url);
      });
    var out = Module.print || console.log.bind(console), err = Module.printErr || console.error.bind(console);
    Object.assign(Module, moduleOverrides), moduleOverrides = null, Module.arguments && (arguments_ = Module.arguments), Module.thisProgram && (thisProgram = Module.thisProgram);
    var dynamicLibraries = Module.dynamicLibraries || [], wasmBinary = Module.wasmBinary, wasmMemory, ABORT = false, EXITSTATUS;
    function assert(e, t) {
      e || abort(t);
    }
    var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
    function updateMemoryViews() {
      var e = wasmMemory.buffer;
      Module.HEAP8 = HEAP8 = new Int8Array(e), Module.HEAP16 = HEAP16 = new Int16Array(e), Module.HEAPU8 = HEAPU8 = new Uint8Array(e), Module.HEAPU16 = HEAPU16 = new Uint16Array(e), Module.HEAP32 = HEAP32 = new Int32Array(e), Module.HEAPU32 = HEAPU32 = new Uint32Array(e), Module.HEAPF32 = HEAPF32 = new Float32Array(e), Module.HEAPF64 = HEAPF64 = new Float64Array(e), Module.HEAP64 = HEAP64 = new BigInt64Array(e), Module.HEAPU64 = HEAPU64 = new BigUint64Array(e);
    }
    if (Module.wasmMemory)
      wasmMemory = Module.wasmMemory;
    else {
      var INITIAL_MEMORY = Module.INITIAL_MEMORY || 16777216;
      wasmMemory = new WebAssembly.Memory({ initial: INITIAL_MEMORY / 65536, maximum: 32768 });
    }
    updateMemoryViews();
    var __ATPRERUN__ = [], __ATINIT__ = [], __ATMAIN__ = [], __ATPOSTRUN__ = [], __RELOC_FUNCS__ = [], runtimeInitialized = false;
    function preRun() {
      if (Module.preRun)
        for (typeof Module.preRun == "function" && (Module.preRun = [Module.preRun]);Module.preRun.length; )
          addOnPreRun(Module.preRun.shift());
      callRuntimeCallbacks(__ATPRERUN__);
    }
    function initRuntime() {
      runtimeInitialized = true, callRuntimeCallbacks(__RELOC_FUNCS__), !Module.noFSInit && !FS.initialized && FS.init(), FS.ignorePermissions = false, TTY.init(), SOCKFS.root = FS.mount(SOCKFS, {}, null), PIPEFS.root = FS.mount(PIPEFS, {}, null), callRuntimeCallbacks(__ATINIT__);
    }
    function preMain() {
      callRuntimeCallbacks(__ATMAIN__);
    }
    function postRun() {
      if (Module.postRun)
        for (typeof Module.postRun == "function" && (Module.postRun = [Module.postRun]);Module.postRun.length; )
          addOnPostRun(Module.postRun.shift());
      callRuntimeCallbacks(__ATPOSTRUN__);
    }
    function addOnPreRun(e) {
      __ATPRERUN__.unshift(e);
    }
    function addOnInit(e) {
      __ATINIT__.unshift(e);
    }
    function addOnPostRun(e) {
      __ATPOSTRUN__.unshift(e);
    }
    var runDependencies = 0, dependenciesFulfilled = null;
    function getUniqueRunDependency(e) {
      return e;
    }
    function addRunDependency(e) {
      runDependencies++, Module.monitorRunDependencies?.(runDependencies);
    }
    function removeRunDependency(e) {
      if (runDependencies--, Module.monitorRunDependencies?.(runDependencies), runDependencies == 0 && dependenciesFulfilled) {
        var t = dependenciesFulfilled;
        dependenciesFulfilled = null, t();
      }
    }
    function abort(e) {
      Module.onAbort?.(e), e = "Aborted(" + e + ")", err(e), ABORT = true, e += ". Build with -sASSERTIONS for more info.";
      var t = new WebAssembly.RuntimeError(e);
      throw readyPromiseReject(t), t;
    }
    var dataURIPrefix = "data:application/octet-stream;base64,", isDataURI = (e) => e.startsWith(dataURIPrefix), isFileURI = (e) => e.startsWith("file://");
    function findWasmBinary() {
      if (Module.locateFile) {
        var e = "pglite.wasm";
        return isDataURI(e) ? e : locateFile(e);
      }
      return new URL("pglite.wasm", import.meta.url).href;
    }
    var wasmBinaryFile;
    function getBinarySync(e) {
      if (e == wasmBinaryFile && wasmBinary)
        return new Uint8Array(wasmBinary);
      if (readBinary)
        return readBinary(e);
      throw "both async and sync fetching of the wasm failed";
    }
    async function getWasmBinary(e) {
      if (!wasmBinary)
        try {
          var t = await readAsync(e);
          return new Uint8Array(t);
        } catch {
        }
      return getBinarySync(e);
    }
    async function instantiateArrayBuffer(e, t) {
      try {
        var r2 = await getWasmBinary(e), a = await WebAssembly.instantiate(r2, t);
        return a;
      } catch (o3) {
        err(`failed to asynchronously prepare wasm: ${o3}`), abort(o3);
      }
    }
    async function instantiateAsync(e, t, r2) {
      if (!e && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(t) && !ENVIRONMENT_IS_NODE && typeof fetch == "function")
        try {
          var a = fetch(t, { credentials: "same-origin" }), o3 = await WebAssembly.instantiateStreaming(a, r2);
          return o3;
        } catch (s2) {
          err(`wasm streaming compile failed: ${s2}`), err("falling back to ArrayBuffer instantiation");
        }
      return instantiateArrayBuffer(t, r2);
    }
    function getWasmImports() {
      return { env: wasmImports, wasi_snapshot_preview1: wasmImports, "GOT.mem": new Proxy(wasmImports, GOTHandler), "GOT.func": new Proxy(wasmImports, GOTHandler) };
    }
    async function createWasm() {
      function e(o3, s2) {
        wasmExports = o3.exports, wasmExports = relocateExports(wasmExports, 12582912);
        var l3 = getDylinkMetadata(s2);
        return l3.neededDynlibs && (dynamicLibraries = l3.neededDynlibs.concat(dynamicLibraries)), mergeLibSymbols(wasmExports, "main"), LDSO.init(), loadDylibs(), addOnInit(wasmExports.__wasm_call_ctors), __RELOC_FUNCS__.push(wasmExports.__wasm_apply_data_relocs), removeRunDependency("wasm-instantiate"), wasmExports;
      }
      addRunDependency("wasm-instantiate");
      function t(o3) {
        e(o3.instance, o3.module);
      }
      var r2 = getWasmImports();
      if (Module.instantiateWasm)
        try {
          return Module.instantiateWasm(r2, e);
        } catch (o3) {
          err(`Module.instantiateWasm callback failed with error: ${o3}`), readyPromiseReject(o3);
        }
      wasmBinaryFile ?? (wasmBinaryFile = findWasmBinary());
      try {
        var a = await instantiateAsync(wasmBinary, wasmBinaryFile, r2);
        return t(a), a;
      } catch (o3) {
        readyPromiseReject(o3);
        return;
      }
    }
    var ASM_CONSTS = { 15161036: (e) => {
      Module.is_worker = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope, Module.FD_BUFFER_MAX = e, Module.emscripten_copy_to = console.warn;
    }, 15161208: () => {
      Module.postMessage = function(t) {
        console.log("# pg_main_emsdk.c:544: onCustomMessage:", t);
      };
    }, 15161337: () => {
      if (Module.is_worker) {
        let t = function(r2) {
          console.log("onCustomMessage:", r2);
        };
        var e = t;
        Module.onCustomMessage = t;
      } else
        Module.postMessage = function(r2) {
          switch (r2.type) {
            case "raw":
              break;
            case "stdin": {
              stringToUTF8(r2.data, 1, Module.FD_BUFFER_MAX);
              break;
            }
            case "rcon":
              break;
            default:
              console.warn("custom_postMessage?", r2);
          }
        };
    } };

    class ExitStatus {
      constructor(t) {
        P(this, "name", "ExitStatus");
        this.message = `Program terminated with exit(${t})`, this.status = t;
      }
    }
    var GOT = {}, currentModuleWeakSymbols = new Set([]), GOTHandler = { get(e, t) {
      var r2 = GOT[t];
      return r2 || (r2 = GOT[t] = new WebAssembly.Global({ value: "i32", mutable: true })), currentModuleWeakSymbols.has(t) || (r2.required = true), r2;
    } }, callRuntimeCallbacks = (e) => {
      for (;e.length > 0; )
        e.shift()(Module);
    }, UTF8Decoder = typeof TextDecoder < "u" ? new TextDecoder : undefined, UTF8ArrayToString = (e, t = 0, r2 = NaN) => {
      for (var a = t + r2, o3 = t;e[o3] && !(o3 >= a); )
        ++o3;
      if (o3 - t > 16 && e.buffer && UTF8Decoder)
        return UTF8Decoder.decode(e.subarray(t, o3));
      for (var s2 = "";t < o3; ) {
        var l3 = e[t++];
        if (!(l3 & 128)) {
          s2 += String.fromCharCode(l3);
          continue;
        }
        var _2 = e[t++] & 63;
        if ((l3 & 224) == 192) {
          s2 += String.fromCharCode((l3 & 31) << 6 | _2);
          continue;
        }
        var n = e[t++] & 63;
        if ((l3 & 240) == 224 ? l3 = (l3 & 15) << 12 | _2 << 6 | n : l3 = (l3 & 7) << 18 | _2 << 12 | n << 6 | e[t++] & 63, l3 < 65536)
          s2 += String.fromCharCode(l3);
        else {
          var m2 = l3 - 65536;
          s2 += String.fromCharCode(55296 | m2 >> 10, 56320 | m2 & 1023);
        }
      }
      return s2;
    }, getDylinkMetadata = (e) => {
      var t = 0, r2 = 0;
      function a() {
        return e[t++];
      }
      function o3() {
        for (var P3 = 0, R4 = 1;; ) {
          var k2 = e[t++];
          if (P3 += (k2 & 127) * R4, R4 *= 128, !(k2 & 128))
            break;
        }
        return P3;
      }
      function s2() {
        var P3 = o3();
        return t += P3, UTF8ArrayToString(e, t - P3, P3);
      }
      function l3(P3, R4) {
        if (P3)
          throw new Error(R4);
      }
      var _2 = "dylink.0";
      if (e instanceof WebAssembly.Module) {
        var n = WebAssembly.Module.customSections(e, _2);
        n.length === 0 && (_2 = "dylink", n = WebAssembly.Module.customSections(e, _2)), l3(n.length === 0, "need dylink section"), e = new Uint8Array(n[0]), r2 = e.length;
      } else {
        var m2 = new Uint32Array(new Uint8Array(e.subarray(0, 24)).buffer), p = m2[0] == 1836278016;
        l3(!p, "need to see wasm magic number"), l3(e[8] !== 0, "need the dylink section to be first"), t = 9;
        var d2 = o3();
        r2 = t + d2, _2 = s2();
      }
      var g3 = { neededDynlibs: [], tlsExports: new Set, weakImports: new Set };
      if (_2 == "dylink") {
        g3.memorySize = o3(), g3.memoryAlign = o3(), g3.tableSize = o3(), g3.tableAlign = o3();
        for (var u3 = o3(), f = 0;f < u3; ++f) {
          var c = s2();
          g3.neededDynlibs.push(c);
        }
      } else {
        l3(_2 !== "dylink.0");
        for (var w2 = 1, h3 = 2, v2 = 3, x3 = 4, y2 = 256, M2 = 3, E2 = 1;t < r2; ) {
          var b3 = a(), U3 = o3();
          if (b3 === w2)
            g3.memorySize = o3(), g3.memoryAlign = o3(), g3.tableSize = o3(), g3.tableAlign = o3();
          else if (b3 === h3)
            for (var u3 = o3(), f = 0;f < u3; ++f)
              c = s2(), g3.neededDynlibs.push(c);
          else if (b3 === v2)
            for (var z3 = o3();z3--; ) {
              var W2 = s2(), D2 = o3();
              D2 & y2 && g3.tlsExports.add(W2);
            }
          else if (b3 === x3)
            for (var z3 = o3();z3--; ) {
              var N2 = s2(), W2 = s2(), D2 = o3();
              (D2 & M2) == E2 && g3.weakImports.add(W2);
            }
          else
            t += U3;
        }
      }
      return g3;
    };
    function getValue(e, t = "i8") {
      switch (t.endsWith("*") && (t = "*"), t) {
        case "i1":
          return HEAP8[e];
        case "i8":
          return HEAP8[e];
        case "i16":
          return HEAP16[e >> 1];
        case "i32":
          return HEAP32[e >> 2];
        case "i64":
          return HEAP64[e >> 3];
        case "float":
          return HEAPF32[e >> 2];
        case "double":
          return HEAPF64[e >> 3];
        case "*":
          return HEAPU32[e >> 2];
        default:
          abort(`invalid type for getValue: ${t}`);
      }
    }
    var newDSO = (e, t, r2) => {
      var a = { refcount: Infinity, name: e, exports: r2, global: true };
      return LDSO.loadedLibsByName[e] = a, t != null && (LDSO.loadedLibsByHandle[t] = a), a;
    }, LDSO = { loadedLibsByName: {}, loadedLibsByHandle: {}, init() {
      newDSO("__main__", 0, wasmImports);
    } }, ___heap_base = 15394512, alignMemory = (e, t) => Math.ceil(e / t) * t, getMemory = (e) => {
      if (runtimeInitialized)
        return _calloc(e, 1);
      var t = ___heap_base, r2 = t + alignMemory(e, 16);
      return ___heap_base = r2, GOT.__heap_base.value = r2, t;
    }, isInternalSym = (e) => ["__cpp_exception", "__c_longjmp", "__wasm_apply_data_relocs", "__dso_handle", "__tls_size", "__tls_align", "__set_stack_limits", "_emscripten_tls_init", "__wasm_init_tls", "__wasm_call_ctors", "__start_em_asm", "__stop_em_asm", "__start_em_js", "__stop_em_js"].includes(e) || e.startsWith("__em_js__"), uleb128Encode = (e, t) => {
      e < 128 ? t.push(e) : t.push(e % 128 | 128, e >> 7);
    }, sigToWasmTypes = (e) => {
      for (var t = { i: "i32", j: "i64", f: "f32", d: "f64", e: "externref", p: "i32" }, r2 = { parameters: [], results: e[0] == "v" ? [] : [t[e[0]]] }, a = 1;a < e.length; ++a)
        r2.parameters.push(t[e[a]]);
      return r2;
    }, generateFuncType = (e, t) => {
      var r2 = e.slice(0, 1), a = e.slice(1), o3 = { i: 127, p: 127, j: 126, f: 125, d: 124, e: 111 };
      t.push(96), uleb128Encode(a.length, t);
      for (var s2 = 0;s2 < a.length; ++s2)
        t.push(o3[a[s2]]);
      r2 == "v" ? t.push(0) : t.push(1, o3[r2]);
    }, convertJsFunctionToWasm = (e, t) => {
      if (typeof WebAssembly.Function == "function")
        return new WebAssembly.Function(sigToWasmTypes(t), e);
      var r2 = [1];
      generateFuncType(t, r2);
      var a = [0, 97, 115, 109, 1, 0, 0, 0, 1];
      uleb128Encode(r2.length, a), a.push(...r2), a.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
      var o3 = new WebAssembly.Module(new Uint8Array(a)), s2 = new WebAssembly.Instance(o3, { e: { f: e } }), l3 = s2.exports.f;
      return l3;
    }, wasmTable = new WebAssembly.Table({ initial: 5919, element: "anyfunc" }), getWasmTableEntry = (e) => wasmTable.get(e), updateTableMap = (e, t) => {
      if (functionsInTableMap)
        for (var r2 = e;r2 < e + t; r2++) {
          var a = getWasmTableEntry(r2);
          a && functionsInTableMap.set(a, r2);
        }
    }, functionsInTableMap, getFunctionAddress = (e) => (functionsInTableMap || (functionsInTableMap = new WeakMap, updateTableMap(0, wasmTable.length)), functionsInTableMap.get(e) || 0), freeTableIndexes = [], getEmptyTableSlot = () => {
      if (freeTableIndexes.length)
        return freeTableIndexes.pop();
      try {
        wasmTable.grow(1);
      } catch (e) {
        throw e instanceof RangeError ? "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH." : e;
      }
      return wasmTable.length - 1;
    }, setWasmTableEntry = (e, t) => wasmTable.set(e, t), addFunction = (e, t) => {
      var r2 = getFunctionAddress(e);
      if (r2)
        return r2;
      var a = getEmptyTableSlot();
      try {
        setWasmTableEntry(a, e);
      } catch (s2) {
        if (!(s2 instanceof TypeError))
          throw s2;
        var o3 = convertJsFunctionToWasm(e, t);
        setWasmTableEntry(a, o3);
      }
      return functionsInTableMap.set(e, a), a;
    }, updateGOT = (e, t) => {
      for (var r2 in e)
        if (!isInternalSym(r2)) {
          var a = e[r2];
          GOT[r2] || (GOT[r2] = new WebAssembly.Global({ value: "i32", mutable: true })), (t || GOT[r2].value == 0) && (typeof a == "function" ? GOT[r2].value = addFunction(a) : typeof a == "number" ? GOT[r2].value = a : err(`unhandled export type for '${r2}': ${typeof a}`));
        }
    }, relocateExports = (e, t, r2) => {
      var a = {};
      for (var o3 in e) {
        var s2 = e[o3];
        typeof s2 == "object" && (s2 = s2.value), typeof s2 == "number" && (s2 += t), a[o3] = s2;
      }
      return updateGOT(a, r2), a;
    }, isSymbolDefined = (e) => {
      var t = wasmImports[e];
      return !(!t || t.stub);
    }, dynCall = (e, t, r2 = []) => {
      var a = getWasmTableEntry(t)(...r2);
      return a;
    }, stackSave = () => _emscripten_stack_get_current(), stackRestore = (e) => __emscripten_stack_restore(e), createInvokeFunction = (e) => (t, ...r2) => {
      var a = stackSave();
      try {
        return dynCall(e, t, r2);
      } catch (o3) {
        if (stackRestore(a), o3 !== o3 + 0)
          throw o3;
        if (_setThrew(1, 0), e[0] == "j")
          return 0n;
      }
    }, resolveGlobalSymbol = (e, t = false) => {
      var r2;
      return isSymbolDefined(e) ? r2 = wasmImports[e] : e.startsWith("invoke_") && (r2 = wasmImports[e] = createInvokeFunction(e.split("_")[1])), { sym: r2, name: e };
    }, UTF8ToString = (e, t) => e ? UTF8ArrayToString(HEAPU8, e, t) : "", loadWebAssemblyModule = (binary, flags, libName, localScope, handle) => {
      var metadata = getDylinkMetadata(binary);
      currentModuleWeakSymbols = metadata.weakImports;
      function loadModule() {
        var firstLoad = !handle || !HEAP8[handle + 8];
        if (firstLoad) {
          var memAlign = Math.pow(2, metadata.memoryAlign), memoryBase = metadata.memorySize ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign) : 0, tableBase = metadata.tableSize ? wasmTable.length : 0;
          handle && (HEAP8[handle + 8] = 1, HEAPU32[handle + 12 >> 2] = memoryBase, HEAP32[handle + 16 >> 2] = metadata.memorySize, HEAPU32[handle + 20 >> 2] = tableBase, HEAP32[handle + 24 >> 2] = metadata.tableSize);
        } else
          memoryBase = HEAPU32[handle + 12 >> 2], tableBase = HEAPU32[handle + 20 >> 2];
        var tableGrowthNeeded = tableBase + metadata.tableSize - wasmTable.length;
        tableGrowthNeeded > 0 && wasmTable.grow(tableGrowthNeeded);
        var moduleExports;
        function resolveSymbol(e) {
          var t = resolveGlobalSymbol(e).sym;
          return !t && localScope && (t = localScope[e]), t || (t = moduleExports[e]), t;
        }
        var proxyHandler = { get(e, t) {
          switch (t) {
            case "__memory_base":
              return memoryBase;
            case "__table_base":
              return tableBase;
          }
          if (t in wasmImports && !wasmImports[t].stub)
            return wasmImports[t];
          if (!(t in e)) {
            var r2;
            e[t] = (...a) => {
              if (r2 || (r2 = resolveSymbol(t)), !r2) {
                if (t === "getTempRet0")
                  return __emscripten_tempret_get(...a);
                throw new Error(`Dynamic linking error: cannot resolve symbol ${t}`);
              }
              return r2(...a);
            };
          }
          return e[t];
        } }, proxy = new Proxy({}, proxyHandler), info = { "GOT.mem": new Proxy({}, GOTHandler), "GOT.func": new Proxy({}, GOTHandler), env: proxy, wasi_snapshot_preview1: proxy };
        function postInstantiation(module, instance) {
          updateTableMap(tableBase, metadata.tableSize), moduleExports = relocateExports(instance.exports, memoryBase), flags.allowUndefined || reportUndefinedSymbols();
          function addEmAsm(addr, body) {
            for (var args = [], arity = 0;arity < 16 && body.indexOf("$" + arity) != -1; arity++)
              args.push("$" + arity);
            args = args.join(",");
            var func = `(${args}) => { ${body} };`;
            ASM_CONSTS[start] = eval(func);
          }
          if ("__start_em_asm" in moduleExports)
            for (var { __start_em_asm: start, __stop_em_asm: stop } = moduleExports;start < stop; ) {
              var jsString = UTF8ToString(start);
              addEmAsm(start, jsString), start = HEAPU8.indexOf(0, start) + 1;
            }
          function addEmJs(name, cSig, body) {
            var jsArgs = [];
            if (cSig = cSig.slice(1, -1), cSig != "void") {
              cSig = cSig.split(",");
              for (var i in cSig) {
                var jsArg = cSig[i].split(" ").pop();
                jsArgs.push(jsArg.replaceAll("*", ""));
              }
            }
            var func = `(${jsArgs}) => ${body};`;
            moduleExports[name] = eval(func);
          }
          for (var name in moduleExports)
            if (name.startsWith("__em_js__")) {
              var start = moduleExports[name], jsString = UTF8ToString(start), parts = jsString.split("<::>");
              addEmJs(name.replace("__em_js__", ""), parts[0], parts[1]), delete moduleExports[name];
            }
          var applyRelocs = moduleExports.__wasm_apply_data_relocs;
          applyRelocs && (runtimeInitialized ? applyRelocs() : __RELOC_FUNCS__.push(applyRelocs));
          var init = moduleExports.__wasm_call_ctors;
          return init && (runtimeInitialized ? init() : __ATINIT__.push(init)), moduleExports;
        }
        if (flags.loadAsync) {
          if (binary instanceof WebAssembly.Module) {
            var instance = new WebAssembly.Instance(binary, info);
            return Promise.resolve(postInstantiation(binary, instance));
          }
          return WebAssembly.instantiate(binary, info).then((e) => postInstantiation(e.module, e.instance));
        }
        var module = binary instanceof WebAssembly.Module ? binary : new WebAssembly.Module(binary), instance = new WebAssembly.Instance(module, info);
        return postInstantiation(module, instance);
      }
      return flags.loadAsync ? metadata.neededDynlibs.reduce((e, t) => e.then(() => loadDynamicLibrary(t, flags, localScope)), Promise.resolve()).then(loadModule) : (metadata.neededDynlibs.forEach((e) => loadDynamicLibrary(e, flags, localScope)), loadModule());
    }, mergeLibSymbols = (e, t) => {
      for (var [r2, a] of Object.entries(e)) {
        let o3 = (l3) => {
          isSymbolDefined(l3) || (wasmImports[l3] = a);
        };
        o3(r2);
        let s2 = "__main_argc_argv";
        r2 == "main" && o3(s2), r2 == s2 && o3("main");
      }
    }, asyncLoad = async (e) => {
      var t = await readAsync(e);
      return new Uint8Array(t);
    }, preloadPlugins = Module.preloadPlugins || [], registerWasmPlugin = () => {
      var e = { promiseChainEnd: Promise.resolve(), canHandle: (t) => !Module.noWasmDecoding && t.endsWith(".so"), handle: (t, r2, a, o3) => {
        e.promiseChainEnd = e.promiseChainEnd.then(() => loadWebAssemblyModule(t, { loadAsync: true, nodelete: true }, r2, {})).then((s2) => {
          preloadedWasm[r2] = s2, a(t);
        }, (s2) => {
          err(`failed to instantiate wasm: ${r2}: ${s2}`), o3();
        });
      } };
      preloadPlugins.push(e);
    }, preloadedWasm = {};
    function loadDynamicLibrary(e, t = { global: true, nodelete: true }, r2, a) {
      var o3 = LDSO.loadedLibsByName[e];
      if (o3)
        return t.global ? o3.global || (o3.global = true, mergeLibSymbols(o3.exports, e)) : r2 && Object.assign(r2, o3.exports), t.nodelete && o3.refcount !== Infinity && (o3.refcount = Infinity), o3.refcount++, a && (LDSO.loadedLibsByHandle[a] = o3), t.loadAsync ? Promise.resolve(true) : true;
      o3 = newDSO(e, a, "loading"), o3.refcount = t.nodelete ? Infinity : 1, o3.global = t.global;
      function s2() {
        if (a) {
          var n = HEAPU32[a + 28 >> 2], m2 = HEAPU32[a + 32 >> 2];
          if (n && m2) {
            var p = HEAP8.slice(n, n + m2);
            return t.loadAsync ? Promise.resolve(p) : p;
          }
        }
        var d2 = locateFile(e);
        if (t.loadAsync)
          return asyncLoad(d2);
        if (!readBinary)
          throw new Error(`${d2}: file not found, and synchronous loading of external files is not available`);
        return readBinary(d2);
      }
      function l3() {
        var n = preloadedWasm[e];
        return n ? t.loadAsync ? Promise.resolve(n) : n : t.loadAsync ? s2().then((m2) => loadWebAssemblyModule(m2, t, e, r2, a)) : loadWebAssemblyModule(s2(), t, e, r2, a);
      }
      function _2(n) {
        o3.global ? mergeLibSymbols(n, e) : r2 && Object.assign(r2, n), o3.exports = n;
      }
      return t.loadAsync ? l3().then((n) => (_2(n), true)) : (_2(l3()), true);
    }
    var reportUndefinedSymbols = () => {
      for (var [e, t] of Object.entries(GOT))
        if (t.value == 0) {
          var r2 = resolveGlobalSymbol(e, true).sym;
          if (!r2 && !t.required)
            continue;
          if (typeof r2 == "function")
            t.value = addFunction(r2, r2.sig);
          else if (typeof r2 == "number")
            t.value = r2;
          else
            throw new Error(`bad export type for '${e}': ${typeof r2}`);
        }
    }, loadDylibs = () => {
      if (!dynamicLibraries.length) {
        reportUndefinedSymbols();
        return;
      }
      addRunDependency("loadDylibs"), dynamicLibraries.reduce((e, t) => e.then(() => loadDynamicLibrary(t, { loadAsync: true, global: true, nodelete: true, allowUndefined: true })), Promise.resolve()).then(() => {
        reportUndefinedSymbols(), removeRunDependency("loadDylibs");
      });
    }, noExitRuntime = Module.noExitRuntime || true;
    function setValue(e, t, r2 = "i8") {
      switch (r2.endsWith("*") && (r2 = "*"), r2) {
        case "i1":
          HEAP8[e] = t;
          break;
        case "i8":
          HEAP8[e] = t;
          break;
        case "i16":
          HEAP16[e >> 1] = t;
          break;
        case "i32":
          HEAP32[e >> 2] = t;
          break;
        case "i64":
          HEAP64[e >> 3] = BigInt(t);
          break;
        case "float":
          HEAPF32[e >> 2] = t;
          break;
        case "double":
          HEAPF64[e >> 3] = t;
          break;
        case "*":
          HEAPU32[e >> 2] = t;
          break;
        default:
          abort(`invalid type for setValue: ${r2}`);
      }
    }
    var ___assert_fail = (e, t, r2, a) => abort(`Assertion failed: ${UTF8ToString(e)}, at: ` + [t ? UTF8ToString(t) : "unknown filename", r2, a ? UTF8ToString(a) : "unknown function"]);
    ___assert_fail.sig = "vppip";
    var ___call_sighandler = (e, t) => getWasmTableEntry(e)(t);
    ___call_sighandler.sig = "vpi";
    var ___memory_base = new WebAssembly.Global({ value: "i32", mutable: false }, 12582912), ___stack_pointer = new WebAssembly.Global({ value: "i32", mutable: true }, 15394512), PATH = { isAbs: (e) => e.charAt(0) === "/", splitPath: (e) => {
      var t = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return t.exec(e).slice(1);
    }, normalizeArray: (e, t) => {
      for (var r2 = 0, a = e.length - 1;a >= 0; a--) {
        var o3 = e[a];
        o3 === "." ? e.splice(a, 1) : o3 === ".." ? (e.splice(a, 1), r2++) : r2 && (e.splice(a, 1), r2--);
      }
      if (t)
        for (;r2; r2--)
          e.unshift("..");
      return e;
    }, normalize: (e) => {
      var t = PATH.isAbs(e), r2 = e.substr(-1) === "/";
      return e = PATH.normalizeArray(e.split("/").filter((a) => !!a), !t).join("/"), !e && !t && (e = "."), e && r2 && (e += "/"), (t ? "/" : "") + e;
    }, dirname: (e) => {
      var t = PATH.splitPath(e), r2 = t[0], a = t[1];
      return !r2 && !a ? "." : (a && (a = a.substr(0, a.length - 1)), r2 + a);
    }, basename: (e) => {
      if (e === "/")
        return "/";
      e = PATH.normalize(e), e = e.replace(/\/$/, "");
      var t = e.lastIndexOf("/");
      return t === -1 ? e : e.substr(t + 1);
    }, join: (...e) => PATH.normalize(e.join("/")), join2: (e, t) => PATH.normalize(e + "/" + t) }, initRandomFill = () => {
      if (typeof crypto == "object" && typeof crypto.getRandomValues == "function")
        return (a) => crypto.getRandomValues(a);
      if (ENVIRONMENT_IS_NODE)
        try {
          var e = require("crypto"), t = e.randomFillSync;
          if (t)
            return (a) => e.randomFillSync(a);
          var r2 = e.randomBytes;
          return (a) => (a.set(r2(a.byteLength)), a);
        } catch {
        }
      abort("initRandomDevice");
    }, randomFill = (e) => (randomFill = initRandomFill())(e), PATH_FS = { resolve: (...e) => {
      for (var t = "", r2 = false, a = e.length - 1;a >= -1 && !r2; a--) {
        var o3 = a >= 0 ? e[a] : FS.cwd();
        if (typeof o3 != "string")
          throw new TypeError("Arguments to path.resolve must be strings");
        if (!o3)
          return "";
        t = o3 + "/" + t, r2 = PATH.isAbs(o3);
      }
      return t = PATH.normalizeArray(t.split("/").filter((s2) => !!s2), !r2).join("/"), (r2 ? "/" : "") + t || ".";
    }, relative: (e, t) => {
      e = PATH_FS.resolve(e).substr(1), t = PATH_FS.resolve(t).substr(1);
      function r2(m2) {
        for (var p = 0;p < m2.length && m2[p] === ""; p++)
          ;
        for (var d2 = m2.length - 1;d2 >= 0 && m2[d2] === ""; d2--)
          ;
        return p > d2 ? [] : m2.slice(p, d2 - p + 1);
      }
      for (var a = r2(e.split("/")), o3 = r2(t.split("/")), s2 = Math.min(a.length, o3.length), l3 = s2, _2 = 0;_2 < s2; _2++)
        if (a[_2] !== o3[_2]) {
          l3 = _2;
          break;
        }
      for (var n = [], _2 = l3;_2 < a.length; _2++)
        n.push("..");
      return n = n.concat(o3.slice(l3)), n.join("/");
    } }, FS_stdin_getChar_buffer = [], lengthBytesUTF8 = (e) => {
      for (var t = 0, r2 = 0;r2 < e.length; ++r2) {
        var a = e.charCodeAt(r2);
        a <= 127 ? t++ : a <= 2047 ? t += 2 : a >= 55296 && a <= 57343 ? (t += 4, ++r2) : t += 3;
      }
      return t;
    }, stringToUTF8Array = (e, t, r2, a) => {
      if (!(a > 0))
        return 0;
      for (var o3 = r2, s2 = r2 + a - 1, l3 = 0;l3 < e.length; ++l3) {
        var _2 = e.charCodeAt(l3);
        if (_2 >= 55296 && _2 <= 57343) {
          var n = e.charCodeAt(++l3);
          _2 = 65536 + ((_2 & 1023) << 10) | n & 1023;
        }
        if (_2 <= 127) {
          if (r2 >= s2)
            break;
          t[r2++] = _2;
        } else if (_2 <= 2047) {
          if (r2 + 1 >= s2)
            break;
          t[r2++] = 192 | _2 >> 6, t[r2++] = 128 | _2 & 63;
        } else if (_2 <= 65535) {
          if (r2 + 2 >= s2)
            break;
          t[r2++] = 224 | _2 >> 12, t[r2++] = 128 | _2 >> 6 & 63, t[r2++] = 128 | _2 & 63;
        } else {
          if (r2 + 3 >= s2)
            break;
          t[r2++] = 240 | _2 >> 18, t[r2++] = 128 | _2 >> 12 & 63, t[r2++] = 128 | _2 >> 6 & 63, t[r2++] = 128 | _2 & 63;
        }
      }
      return t[r2] = 0, r2 - o3;
    };
    function intArrayFromString(e, t, r2) {
      var a = r2 > 0 ? r2 : lengthBytesUTF8(e) + 1, o3 = new Array(a), s2 = stringToUTF8Array(e, o3, 0, o3.length);
      return t && (o3.length = s2), o3;
    }
    var FS_stdin_getChar = () => {
      if (!FS_stdin_getChar_buffer.length) {
        var e = null;
        if (ENVIRONMENT_IS_NODE) {
          var t = 256, r2 = Buffer.alloc(t), a = 0, o3 = process.stdin.fd;
          try {
            a = fs.readSync(o3, r2, 0, t);
          } catch (s2) {
            if (s2.toString().includes("EOF"))
              a = 0;
            else
              throw s2;
          }
          a > 0 && (e = r2.slice(0, a).toString("utf-8"));
        } else
          typeof window < "u" && typeof window.prompt == "function" && (e = window.prompt("Input: "), e !== null && (e += `
`));
        if (!e)
          return null;
        FS_stdin_getChar_buffer = intArrayFromString(e, true);
      }
      return FS_stdin_getChar_buffer.shift();
    }, TTY = { ttys: [], init() {
    }, shutdown() {
    }, register(e, t) {
      TTY.ttys[e] = { input: [], output: [], ops: t }, FS.registerDevice(e, TTY.stream_ops);
    }, stream_ops: { open(e) {
      var t = TTY.ttys[e.node.rdev];
      if (!t)
        throw new FS.ErrnoError(43);
      e.tty = t, e.seekable = false;
    }, close(e) {
      e.tty.ops.fsync(e.tty);
    }, fsync(e) {
      e.tty.ops.fsync(e.tty);
    }, read(e, t, r2, a, o3) {
      if (!e.tty || !e.tty.ops.get_char)
        throw new FS.ErrnoError(60);
      for (var s2 = 0, l3 = 0;l3 < a; l3++) {
        var _2;
        try {
          _2 = e.tty.ops.get_char(e.tty);
        } catch {
          throw new FS.ErrnoError(29);
        }
        if (_2 === undefined && s2 === 0)
          throw new FS.ErrnoError(6);
        if (_2 == null)
          break;
        s2++, t[r2 + l3] = _2;
      }
      return s2 && (e.node.atime = Date.now()), s2;
    }, write(e, t, r2, a, o3) {
      if (!e.tty || !e.tty.ops.put_char)
        throw new FS.ErrnoError(60);
      try {
        for (var s2 = 0;s2 < a; s2++)
          e.tty.ops.put_char(e.tty, t[r2 + s2]);
      } catch {
        throw new FS.ErrnoError(29);
      }
      return a && (e.node.mtime = e.node.ctime = Date.now()), s2;
    } }, default_tty_ops: { get_char(e) {
      return FS_stdin_getChar();
    }, put_char(e, t) {
      t === null || t === 10 ? (out(UTF8ArrayToString(e.output)), e.output = []) : t != 0 && e.output.push(t);
    }, fsync(e) {
      e.output && e.output.length > 0 && (out(UTF8ArrayToString(e.output)), e.output = []);
    }, ioctl_tcgets(e) {
      return { c_iflag: 25856, c_oflag: 5, c_cflag: 191, c_lflag: 35387, c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
    }, ioctl_tcsets(e, t, r2) {
      return 0;
    }, ioctl_tiocgwinsz(e) {
      return [24, 80];
    } }, default_tty1_ops: { put_char(e, t) {
      t === null || t === 10 ? (err(UTF8ArrayToString(e.output)), e.output = []) : t != 0 && e.output.push(t);
    }, fsync(e) {
      e.output && e.output.length > 0 && (err(UTF8ArrayToString(e.output)), e.output = []);
    } } }, zeroMemory = (e, t) => {
      HEAPU8.fill(0, e, e + t);
    }, mmapAlloc = (e) => {
      e = alignMemory(e, 65536);
      var t = _emscripten_builtin_memalign(65536, e);
      return t && zeroMemory(t, e), t;
    }, MEMFS = { ops_table: null, mount(e) {
      return MEMFS.createNode(null, "/", 16895, 0);
    }, createNode(e, t, r2, a) {
      if (FS.isBlkdev(r2) || FS.isFIFO(r2))
        throw new FS.ErrnoError(63);
      MEMFS.ops_table || (MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } });
      var o3 = FS.createNode(e, t, r2, a);
      return FS.isDir(o3.mode) ? (o3.node_ops = MEMFS.ops_table.dir.node, o3.stream_ops = MEMFS.ops_table.dir.stream, o3.contents = {}) : FS.isFile(o3.mode) ? (o3.node_ops = MEMFS.ops_table.file.node, o3.stream_ops = MEMFS.ops_table.file.stream, o3.usedBytes = 0, o3.contents = null) : FS.isLink(o3.mode) ? (o3.node_ops = MEMFS.ops_table.link.node, o3.stream_ops = MEMFS.ops_table.link.stream) : FS.isChrdev(o3.mode) && (o3.node_ops = MEMFS.ops_table.chrdev.node, o3.stream_ops = MEMFS.ops_table.chrdev.stream), o3.atime = o3.mtime = o3.ctime = Date.now(), e && (e.contents[t] = o3, e.atime = e.mtime = e.ctime = o3.atime), o3;
    }, getFileDataAsTypedArray(e) {
      return e.contents ? e.contents.subarray ? e.contents.subarray(0, e.usedBytes) : new Uint8Array(e.contents) : new Uint8Array(0);
    }, expandFileStorage(e, t) {
      var r2 = e.contents ? e.contents.length : 0;
      if (!(r2 >= t)) {
        var a = 1048576;
        t = Math.max(t, r2 * (r2 < a ? 2 : 1.125) >>> 0), r2 != 0 && (t = Math.max(t, 256));
        var o3 = e.contents;
        e.contents = new Uint8Array(t), e.usedBytes > 0 && e.contents.set(o3.subarray(0, e.usedBytes), 0);
      }
    }, resizeFileStorage(e, t) {
      if (e.usedBytes != t)
        if (t == 0)
          e.contents = null, e.usedBytes = 0;
        else {
          var r2 = e.contents;
          e.contents = new Uint8Array(t), r2 && e.contents.set(r2.subarray(0, Math.min(t, e.usedBytes))), e.usedBytes = t;
        }
    }, node_ops: { getattr(e) {
      var t = {};
      return t.dev = FS.isChrdev(e.mode) ? e.id : 1, t.ino = e.id, t.mode = e.mode, t.nlink = 1, t.uid = 0, t.gid = 0, t.rdev = e.rdev, FS.isDir(e.mode) ? t.size = 4096 : FS.isFile(e.mode) ? t.size = e.usedBytes : FS.isLink(e.mode) ? t.size = e.link.length : t.size = 0, t.atime = new Date(e.atime), t.mtime = new Date(e.mtime), t.ctime = new Date(e.ctime), t.blksize = 4096, t.blocks = Math.ceil(t.size / t.blksize), t;
    }, setattr(e, t) {
      for (let r2 of ["mode", "atime", "mtime", "ctime"])
        t[r2] && (e[r2] = t[r2]);
      t.size !== undefined && MEMFS.resizeFileStorage(e, t.size);
    }, lookup(e, t) {
      throw MEMFS.doesNotExistError;
    }, mknod(e, t, r2, a) {
      return MEMFS.createNode(e, t, r2, a);
    }, rename(e, t, r2) {
      var a;
      try {
        a = FS.lookupNode(t, r2);
      } catch {
      }
      if (a) {
        if (FS.isDir(e.mode))
          for (var o3 in a.contents)
            throw new FS.ErrnoError(55);
        FS.hashRemoveNode(a);
      }
      delete e.parent.contents[e.name], t.contents[r2] = e, e.name = r2, t.ctime = t.mtime = e.parent.ctime = e.parent.mtime = Date.now();
    }, unlink(e, t) {
      delete e.contents[t], e.ctime = e.mtime = Date.now();
    }, rmdir(e, t) {
      var r2 = FS.lookupNode(e, t);
      for (var a in r2.contents)
        throw new FS.ErrnoError(55);
      delete e.contents[t], e.ctime = e.mtime = Date.now();
    }, readdir(e) {
      return [".", "..", ...Object.keys(e.contents)];
    }, symlink(e, t, r2) {
      var a = MEMFS.createNode(e, t, 41471, 0);
      return a.link = r2, a;
    }, readlink(e) {
      if (!FS.isLink(e.mode))
        throw new FS.ErrnoError(28);
      return e.link;
    } }, stream_ops: { read(e, t, r2, a, o3) {
      var s2 = e.node.contents;
      if (o3 >= e.node.usedBytes)
        return 0;
      var l3 = Math.min(e.node.usedBytes - o3, a);
      if (l3 > 8 && s2.subarray)
        t.set(s2.subarray(o3, o3 + l3), r2);
      else
        for (var _2 = 0;_2 < l3; _2++)
          t[r2 + _2] = s2[o3 + _2];
      return l3;
    }, write(e, t, r2, a, o3, s2) {
      if (t.buffer === HEAP8.buffer && (s2 = false), !a)
        return 0;
      var l3 = e.node;
      if (l3.mtime = l3.ctime = Date.now(), t.subarray && (!l3.contents || l3.contents.subarray)) {
        if (s2)
          return l3.contents = t.subarray(r2, r2 + a), l3.usedBytes = a, a;
        if (l3.usedBytes === 0 && o3 === 0)
          return l3.contents = t.slice(r2, r2 + a), l3.usedBytes = a, a;
        if (o3 + a <= l3.usedBytes)
          return l3.contents.set(t.subarray(r2, r2 + a), o3), a;
      }
      if (MEMFS.expandFileStorage(l3, o3 + a), l3.contents.subarray && t.subarray)
        l3.contents.set(t.subarray(r2, r2 + a), o3);
      else
        for (var _2 = 0;_2 < a; _2++)
          l3.contents[o3 + _2] = t[r2 + _2];
      return l3.usedBytes = Math.max(l3.usedBytes, o3 + a), a;
    }, llseek(e, t, r2) {
      var a = t;
      if (r2 === 1 ? a += e.position : r2 === 2 && FS.isFile(e.node.mode) && (a += e.node.usedBytes), a < 0)
        throw new FS.ErrnoError(28);
      return a;
    }, allocate(e, t, r2) {
      MEMFS.expandFileStorage(e.node, t + r2), e.node.usedBytes = Math.max(e.node.usedBytes, t + r2);
    }, mmap(e, t, r2, a, o3) {
      if (!FS.isFile(e.node.mode))
        throw new FS.ErrnoError(43);
      var s2, l3, _2 = e.node.contents;
      if (!(o3 & 2) && _2 && _2.buffer === HEAP8.buffer)
        l3 = false, s2 = _2.byteOffset;
      else {
        if (l3 = true, s2 = mmapAlloc(t), !s2)
          throw new FS.ErrnoError(48);
        _2 && ((r2 > 0 || r2 + t < _2.length) && (_2.subarray ? _2 = _2.subarray(r2, r2 + t) : _2 = Array.prototype.slice.call(_2, r2, r2 + t)), HEAP8.set(_2, s2));
      }
      return { ptr: s2, allocated: l3 };
    }, msync(e, t, r2, a, o3) {
      return MEMFS.stream_ops.write(e, t, 0, a, r2, false), 0;
    } } }, FS_createDataFile = (e, t, r2, a, o3, s2) => {
      FS.createDataFile(e, t, r2, a, o3, s2);
    }, FS_handledByPreloadPlugin = (e, t, r2, a) => {
      typeof Browser < "u" && Browser.init();
      var o3 = false;
      return preloadPlugins.forEach((s2) => {
        o3 || s2.canHandle(t) && (s2.handle(e, t, r2, a), o3 = true);
      }), o3;
    }, FS_createPreloadedFile = (e, t, r2, a, o3, s2, l3, _2, n, m2) => {
      var p = t ? PATH_FS.resolve(PATH.join2(e, t)) : e, d2 = `cp ${p}`;
      function g3(u3) {
        function f(c) {
          m2?.(), _2 || FS_createDataFile(e, t, c, a, o3, n), s2?.(), removeRunDependency(d2);
        }
        FS_handledByPreloadPlugin(u3, p, f, () => {
          l3?.(), removeRunDependency(d2);
        }) || f(u3);
      }
      addRunDependency(d2), typeof r2 == "string" ? asyncLoad(r2).then(g3, l3) : g3(r2);
    }, FS_modeStringToFlags = (e) => {
      var t = { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 }, r2 = t[e];
      if (typeof r2 > "u")
        throw new Error(`Unknown file open mode: ${e}`);
      return r2;
    }, FS_getMode = (e, t) => {
      var r2 = 0;
      return e && (r2 |= 365), t && (r2 |= 146), r2;
    }, IDBFS = { dbs: {}, indexedDB: () => {
      if (typeof indexedDB < "u")
        return indexedDB;
      var e = null;
      return typeof window == "object" && (e = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB), e;
    }, DB_VERSION: 21, DB_STORE_NAME: "FILE_DATA", queuePersist: (e) => {
      function t() {
        e.idbPersistState === "again" ? r2() : e.idbPersistState = 0;
      }
      function r2() {
        e.idbPersistState = "idb", IDBFS.syncfs(e, false, t);
      }
      e.idbPersistState ? e.idbPersistState === "idb" && (e.idbPersistState = "again") : e.idbPersistState = setTimeout(r2, 0);
    }, mount: (e) => {
      var t = MEMFS.mount(e);
      if (e?.opts?.autoPersist) {
        t.idbPersistState = 0;
        var r2 = t.node_ops;
        t.node_ops = Object.assign({}, t.node_ops), t.node_ops.mknod = (a, o3, s2, l3) => {
          var _2 = r2.mknod(a, o3, s2, l3);
          return _2.node_ops = t.node_ops, _2.idbfs_mount = t.mount, _2.memfs_stream_ops = _2.stream_ops, _2.stream_ops = Object.assign({}, _2.stream_ops), _2.stream_ops.write = (n, m2, p, d2, g3, u3) => (n.node.isModified = true, _2.memfs_stream_ops.write(n, m2, p, d2, g3, u3)), _2.stream_ops.close = (n) => {
            var m2 = n.node;
            if (m2.isModified && (IDBFS.queuePersist(m2.idbfs_mount), m2.isModified = false), m2.memfs_stream_ops.close)
              return m2.memfs_stream_ops.close(n);
          }, _2;
        }, t.node_ops.mkdir = (...a) => (IDBFS.queuePersist(t.mount), r2.mkdir(...a)), t.node_ops.rmdir = (...a) => (IDBFS.queuePersist(t.mount), r2.rmdir(...a)), t.node_ops.symlink = (...a) => (IDBFS.queuePersist(t.mount), r2.symlink(...a)), t.node_ops.unlink = (...a) => (IDBFS.queuePersist(t.mount), r2.unlink(...a)), t.node_ops.rename = (...a) => (IDBFS.queuePersist(t.mount), r2.rename(...a));
      }
      return t;
    }, syncfs: (e, t, r2) => {
      IDBFS.getLocalSet(e, (a, o3) => {
        if (a)
          return r2(a);
        IDBFS.getRemoteSet(e, (s2, l3) => {
          if (s2)
            return r2(s2);
          var _2 = t ? l3 : o3, n = t ? o3 : l3;
          IDBFS.reconcile(_2, n, r2);
        });
      });
    }, quit: () => {
      Object.values(IDBFS.dbs).forEach((e) => e.close()), IDBFS.dbs = {};
    }, getDB: (e, t) => {
      var r2 = IDBFS.dbs[e];
      if (r2)
        return t(null, r2);
      var a;
      try {
        a = IDBFS.indexedDB().open(e, IDBFS.DB_VERSION);
      } catch (o3) {
        return t(o3);
      }
      if (!a)
        return t("Unable to connect to IndexedDB");
      a.onupgradeneeded = (o3) => {
        var s2 = o3.target.result, l3 = o3.target.transaction, _2;
        s2.objectStoreNames.contains(IDBFS.DB_STORE_NAME) ? _2 = l3.objectStore(IDBFS.DB_STORE_NAME) : _2 = s2.createObjectStore(IDBFS.DB_STORE_NAME), _2.indexNames.contains("timestamp") || _2.createIndex("timestamp", "timestamp", { unique: false });
      }, a.onsuccess = () => {
        r2 = a.result, IDBFS.dbs[e] = r2, t(null, r2);
      }, a.onerror = (o3) => {
        t(o3.target.error), o3.preventDefault();
      };
    }, getLocalSet: (e, t) => {
      var r2 = {};
      function a(n) {
        return n !== "." && n !== "..";
      }
      function o3(n) {
        return (m2) => PATH.join2(n, m2);
      }
      for (var s2 = FS.readdir(e.mountpoint).filter(a).map(o3(e.mountpoint));s2.length; ) {
        var l3 = s2.pop(), _2;
        try {
          _2 = FS.stat(l3);
        } catch (n) {
          return t(n);
        }
        FS.isDir(_2.mode) && s2.push(...FS.readdir(l3).filter(a).map(o3(l3))), r2[l3] = { timestamp: _2.mtime };
      }
      return t(null, { type: "local", entries: r2 });
    }, getRemoteSet: (e, t) => {
      var r2 = {};
      IDBFS.getDB(e.mountpoint, (a, o3) => {
        if (a)
          return t(a);
        try {
          var s2 = o3.transaction([IDBFS.DB_STORE_NAME], "readonly");
          s2.onerror = (n) => {
            t(n.target.error), n.preventDefault();
          };
          var l3 = s2.objectStore(IDBFS.DB_STORE_NAME), _2 = l3.index("timestamp");
          _2.openKeyCursor().onsuccess = (n) => {
            var m2 = n.target.result;
            if (!m2)
              return t(null, { type: "remote", db: o3, entries: r2 });
            r2[m2.primaryKey] = { timestamp: m2.key }, m2.continue();
          };
        } catch (n) {
          return t(n);
        }
      });
    }, loadLocalEntry: (e, t) => {
      var r2, a;
      try {
        var o3 = FS.lookupPath(e);
        a = o3.node, r2 = FS.stat(e);
      } catch (s2) {
        return t(s2);
      }
      return FS.isDir(r2.mode) ? t(null, { timestamp: r2.mtime, mode: r2.mode }) : FS.isFile(r2.mode) ? (a.contents = MEMFS.getFileDataAsTypedArray(a), t(null, { timestamp: r2.mtime, mode: r2.mode, contents: a.contents })) : t(new Error("node type not supported"));
    }, storeLocalEntry: (e, t, r2) => {
      try {
        if (FS.isDir(t.mode))
          FS.mkdirTree(e, t.mode);
        else if (FS.isFile(t.mode))
          FS.writeFile(e, t.contents, { canOwn: true });
        else
          return r2(new Error("node type not supported"));
        FS.chmod(e, t.mode), FS.utime(e, t.timestamp, t.timestamp);
      } catch (a) {
        return r2(a);
      }
      r2(null);
    }, removeLocalEntry: (e, t) => {
      try {
        var r2 = FS.stat(e);
        FS.isDir(r2.mode) ? FS.rmdir(e) : FS.isFile(r2.mode) && FS.unlink(e);
      } catch (a) {
        return t(a);
      }
      t(null);
    }, loadRemoteEntry: (e, t, r2) => {
      var a = e.get(t);
      a.onsuccess = (o3) => r2(null, o3.target.result), a.onerror = (o3) => {
        r2(o3.target.error), o3.preventDefault();
      };
    }, storeRemoteEntry: (e, t, r2, a) => {
      try {
        var o3 = e.put(r2, t);
      } catch (s2) {
        a(s2);
        return;
      }
      o3.onsuccess = (s2) => a(), o3.onerror = (s2) => {
        a(s2.target.error), s2.preventDefault();
      };
    }, removeRemoteEntry: (e, t, r2) => {
      var a = e.delete(t);
      a.onsuccess = (o3) => r2(), a.onerror = (o3) => {
        r2(o3.target.error), o3.preventDefault();
      };
    }, reconcile: (e, t, r2) => {
      var a = 0, o3 = [];
      Object.keys(e.entries).forEach((d2) => {
        var g3 = e.entries[d2], u3 = t.entries[d2];
        (!u3 || g3.timestamp.getTime() != u3.timestamp.getTime()) && (o3.push(d2), a++);
      });
      var s2 = [];
      if (Object.keys(t.entries).forEach((d2) => {
        e.entries[d2] || (s2.push(d2), a++);
      }), !a)
        return r2(null);
      var l3 = false, _2 = e.type === "remote" ? e.db : t.db, n = _2.transaction([IDBFS.DB_STORE_NAME], "readwrite"), m2 = n.objectStore(IDBFS.DB_STORE_NAME);
      function p(d2) {
        if (d2 && !l3)
          return l3 = true, r2(d2);
      }
      n.onerror = n.onabort = (d2) => {
        p(d2.target.error), d2.preventDefault();
      }, n.oncomplete = (d2) => {
        l3 || r2(null);
      }, o3.sort().forEach((d2) => {
        t.type === "local" ? IDBFS.loadRemoteEntry(m2, d2, (g3, u3) => {
          if (g3)
            return p(g3);
          IDBFS.storeLocalEntry(d2, u3, p);
        }) : IDBFS.loadLocalEntry(d2, (g3, u3) => {
          if (g3)
            return p(g3);
          IDBFS.storeRemoteEntry(m2, d2, u3, p);
        });
      }), s2.sort().reverse().forEach((d2) => {
        t.type === "local" ? IDBFS.removeLocalEntry(d2, p) : IDBFS.removeRemoteEntry(m2, d2, p);
      });
    } }, ERRNO_CODES = { EPERM: 63, ENOENT: 44, ESRCH: 71, EINTR: 27, EIO: 29, ENXIO: 60, E2BIG: 1, ENOEXEC: 45, EBADF: 8, ECHILD: 12, EAGAIN: 6, EWOULDBLOCK: 6, ENOMEM: 48, EACCES: 2, EFAULT: 21, ENOTBLK: 105, EBUSY: 10, EEXIST: 20, EXDEV: 75, ENODEV: 43, ENOTDIR: 54, EISDIR: 31, EINVAL: 28, ENFILE: 41, EMFILE: 33, ENOTTY: 59, ETXTBSY: 74, EFBIG: 22, ENOSPC: 51, ESPIPE: 70, EROFS: 69, EMLINK: 34, EPIPE: 64, EDOM: 18, ERANGE: 68, ENOMSG: 49, EIDRM: 24, ECHRNG: 106, EL2NSYNC: 156, EL3HLT: 107, EL3RST: 108, ELNRNG: 109, EUNATCH: 110, ENOCSI: 111, EL2HLT: 112, EDEADLK: 16, ENOLCK: 46, EBADE: 113, EBADR: 114, EXFULL: 115, ENOANO: 104, EBADRQC: 103, EBADSLT: 102, EDEADLOCK: 16, EBFONT: 101, ENOSTR: 100, ENODATA: 116, ETIME: 117, ENOSR: 118, ENONET: 119, ENOPKG: 120, EREMOTE: 121, ENOLINK: 47, EADV: 122, ESRMNT: 123, ECOMM: 124, EPROTO: 65, EMULTIHOP: 36, EDOTDOT: 125, EBADMSG: 9, ENOTUNIQ: 126, EBADFD: 127, EREMCHG: 128, ELIBACC: 129, ELIBBAD: 130, ELIBSCN: 131, ELIBMAX: 132, ELIBEXEC: 133, ENOSYS: 52, ENOTEMPTY: 55, ENAMETOOLONG: 37, ELOOP: 32, EOPNOTSUPP: 138, EPFNOSUPPORT: 139, ECONNRESET: 15, ENOBUFS: 42, EAFNOSUPPORT: 5, EPROTOTYPE: 67, ENOTSOCK: 57, ENOPROTOOPT: 50, ESHUTDOWN: 140, ECONNREFUSED: 14, EADDRINUSE: 3, ECONNABORTED: 13, ENETUNREACH: 40, ENETDOWN: 38, ETIMEDOUT: 73, EHOSTDOWN: 142, EHOSTUNREACH: 23, EINPROGRESS: 26, EALREADY: 7, EDESTADDRREQ: 17, EMSGSIZE: 35, EPROTONOSUPPORT: 66, ESOCKTNOSUPPORT: 137, EADDRNOTAVAIL: 4, ENETRESET: 39, EISCONN: 30, ENOTCONN: 53, ETOOMANYREFS: 141, EUSERS: 136, EDQUOT: 19, ESTALE: 72, ENOTSUP: 138, ENOMEDIUM: 148, EILSEQ: 25, EOVERFLOW: 61, ECANCELED: 11, ENOTRECOVERABLE: 56, EOWNERDEAD: 62, ESTRPIPE: 135 }, NODEFS = { isWindows: false, staticInit() {
      NODEFS.isWindows = !!process.platform.match(/^win/);
      var e = process.binding("constants");
      e.fs && (e = e.fs), NODEFS.flagsForNodeMap = { 1024: e.O_APPEND, 64: e.O_CREAT, 128: e.O_EXCL, 256: e.O_NOCTTY, 0: e.O_RDONLY, 2: e.O_RDWR, 4096: e.O_SYNC, 512: e.O_TRUNC, 1: e.O_WRONLY, 131072: e.O_NOFOLLOW };
    }, convertNodeCode(e) {
      var t = e.code;
      return ERRNO_CODES[t];
    }, tryFSOperation(e) {
      try {
        return e();
      } catch (t) {
        throw t.code ? t.code === "UNKNOWN" ? new FS.ErrnoError(28) : new FS.ErrnoError(NODEFS.convertNodeCode(t)) : t;
      }
    }, mount(e) {
      return NODEFS.createNode(null, "/", NODEFS.getMode(e.opts.root), 0);
    }, createNode(e, t, r2, a) {
      if (!FS.isDir(r2) && !FS.isFile(r2) && !FS.isLink(r2))
        throw new FS.ErrnoError(28);
      var o3 = FS.createNode(e, t, r2);
      return o3.node_ops = NODEFS.node_ops, o3.stream_ops = NODEFS.stream_ops, o3;
    }, getMode(e) {
      return NODEFS.tryFSOperation(() => {
        var t = fs.lstatSync(e).mode;
        return NODEFS.isWindows && (t |= (t & 292) >> 2), t;
      });
    }, realPath(e) {
      for (var t = [];e.parent !== e; )
        t.push(e.name), e = e.parent;
      return t.push(e.mount.opts.root), t.reverse(), PATH.join(...t);
    }, flagsForNode(e) {
      e &= -2097153, e &= -2049, e &= -32769, e &= -524289, e &= -65537;
      var t = 0;
      for (var r2 in NODEFS.flagsForNodeMap)
        e & r2 && (t |= NODEFS.flagsForNodeMap[r2], e ^= r2);
      if (e)
        throw new FS.ErrnoError(28);
      return t;
    }, node_ops: { getattr(e) {
      var t = NODEFS.realPath(e), r2;
      return NODEFS.tryFSOperation(() => r2 = fs.lstatSync(t)), NODEFS.isWindows && (r2.blksize || (r2.blksize = 4096), r2.blocks || (r2.blocks = (r2.size + r2.blksize - 1) / r2.blksize | 0), r2.mode |= (r2.mode & 292) >> 2), { dev: r2.dev, ino: r2.ino, mode: r2.mode, nlink: r2.nlink, uid: r2.uid, gid: r2.gid, rdev: r2.rdev, size: r2.size, atime: r2.atime, mtime: r2.mtime, ctime: r2.ctime, blksize: r2.blksize, blocks: r2.blocks };
    }, setattr(e, t) {
      var r2 = NODEFS.realPath(e);
      NODEFS.tryFSOperation(() => {
        if (t.mode !== undefined) {
          var a = t.mode;
          NODEFS.isWindows && (a &= 384), fs.chmodSync(r2, a), e.mode = t.mode;
        }
        if (t.atime || t.mtime) {
          var o3 = t.atime && new Date(t.atime), s2 = t.mtime && new Date(t.mtime);
          fs.utimesSync(r2, o3, s2);
        }
        t.size !== undefined && fs.truncateSync(r2, t.size);
      });
    }, lookup(e, t) {
      var r2 = PATH.join2(NODEFS.realPath(e), t), a = NODEFS.getMode(r2);
      return NODEFS.createNode(e, t, a);
    }, mknod(e, t, r2, a) {
      var o3 = NODEFS.createNode(e, t, r2, a), s2 = NODEFS.realPath(o3);
      return NODEFS.tryFSOperation(() => {
        FS.isDir(o3.mode) ? fs.mkdirSync(s2, o3.mode) : fs.writeFileSync(s2, "", { mode: o3.mode });
      }), o3;
    }, rename(e, t, r2) {
      var a = NODEFS.realPath(e), o3 = PATH.join2(NODEFS.realPath(t), r2);
      try {
        FS.unlink(o3);
      } catch {
      }
      NODEFS.tryFSOperation(() => fs.renameSync(a, o3)), e.name = r2;
    }, unlink(e, t) {
      var r2 = PATH.join2(NODEFS.realPath(e), t);
      NODEFS.tryFSOperation(() => fs.unlinkSync(r2));
    }, rmdir(e, t) {
      var r2 = PATH.join2(NODEFS.realPath(e), t);
      NODEFS.tryFSOperation(() => fs.rmdirSync(r2));
    }, readdir(e) {
      var t = NODEFS.realPath(e);
      return NODEFS.tryFSOperation(() => fs.readdirSync(t));
    }, symlink(e, t, r2) {
      var a = PATH.join2(NODEFS.realPath(e), t);
      NODEFS.tryFSOperation(() => fs.symlinkSync(r2, a));
    }, readlink(e) {
      var t = NODEFS.realPath(e);
      return NODEFS.tryFSOperation(() => fs.readlinkSync(t));
    }, statfs(e) {
      var t = NODEFS.tryFSOperation(() => fs.statfsSync(e));
      return t.frsize = t.bsize, t;
    } }, stream_ops: { open(e) {
      var t = NODEFS.realPath(e.node);
      NODEFS.tryFSOperation(() => {
        FS.isFile(e.node.mode) && (e.shared.refcount = 1, e.nfd = fs.openSync(t, NODEFS.flagsForNode(e.flags)));
      });
    }, close(e) {
      NODEFS.tryFSOperation(() => {
        FS.isFile(e.node.mode) && e.nfd && --e.shared.refcount === 0 && fs.closeSync(e.nfd);
      });
    }, dup(e) {
      e.shared.refcount++;
    }, read(e, t, r2, a, o3) {
      return a === 0 ? 0 : NODEFS.tryFSOperation(() => fs.readSync(e.nfd, new Int8Array(t.buffer, r2, a), 0, a, o3));
    }, write(e, t, r2, a, o3) {
      return NODEFS.tryFSOperation(() => fs.writeSync(e.nfd, new Int8Array(t.buffer, r2, a), 0, a, o3));
    }, llseek(e, t, r2) {
      var a = t;
      if (r2 === 1 ? a += e.position : r2 === 2 && FS.isFile(e.node.mode) && NODEFS.tryFSOperation(() => {
        var o3 = fs.fstatSync(e.nfd);
        a += o3.size;
      }), a < 0)
        throw new FS.ErrnoError(28);
      return a;
    }, mmap(e, t, r2, a, o3) {
      if (!FS.isFile(e.node.mode))
        throw new FS.ErrnoError(43);
      var s2 = mmapAlloc(t);
      return NODEFS.stream_ops.read(e, HEAP8, s2, t, r2), { ptr: s2, allocated: true };
    }, msync(e, t, r2, a, o3) {
      return NODEFS.stream_ops.write(e, t, 0, a, r2, false), 0;
    } } }, FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, ErrnoError: class {
      constructor(e) {
        P(this, "name", "ErrnoError");
        this.errno = e;
      }
    }, filesystems: null, syncFSRequests: 0, readFiles: {}, FSStream: class {
      constructor() {
        P(this, "shared", {});
      }
      get object() {
        return this.node;
      }
      set object(e) {
        this.node = e;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(e) {
        this.shared.flags = e;
      }
      get position() {
        return this.shared.position;
      }
      set position(e) {
        this.shared.position = e;
      }
    }, FSNode: class {
      constructor(e, t, r2, a) {
        P(this, "node_ops", {});
        P(this, "stream_ops", {});
        P(this, "readMode", 365);
        P(this, "writeMode", 146);
        P(this, "mounted", null);
        e || (e = this), this.parent = e, this.mount = e.mount, this.id = FS.nextInode++, this.name = t, this.mode = r2, this.rdev = a, this.atime = this.mtime = this.ctime = Date.now();
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(e) {
        e ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(e) {
        e ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    }, lookupPath(e, t = {}) {
      if (!e)
        return { path: "", node: null };
      t.follow_mount ?? (t.follow_mount = true), PATH.isAbs(e) || (e = FS.cwd() + "/" + e);
      e:
        for (var r2 = 0;r2 < 40; r2++) {
          for (var a = e.split("/").filter((m2) => !!m2 && m2 !== "."), o3 = FS.root, s2 = "/", l3 = 0;l3 < a.length; l3++) {
            var _2 = l3 === a.length - 1;
            if (_2 && t.parent)
              break;
            if (a[l3] === "..") {
              s2 = PATH.dirname(s2), o3 = o3.parent;
              continue;
            }
            s2 = PATH.join2(s2, a[l3]);
            try {
              o3 = FS.lookupNode(o3, a[l3]);
            } catch (m2) {
              if (m2?.errno === 44 && _2 && t.noent_okay)
                return { path: s2 };
              throw m2;
            }
            if (FS.isMountpoint(o3) && (!_2 || t.follow_mount) && (o3 = o3.mounted.root), FS.isLink(o3.mode) && (!_2 || t.follow)) {
              if (!o3.node_ops.readlink)
                throw new FS.ErrnoError(52);
              var n = o3.node_ops.readlink(o3);
              PATH.isAbs(n) || (n = PATH.dirname(s2) + "/" + n), e = n + "/" + a.slice(l3 + 1).join("/");
              continue e;
            }
          }
          return { path: s2, node: o3 };
        }
      throw new FS.ErrnoError(32);
    }, getPath(e) {
      for (var t;; ) {
        if (FS.isRoot(e)) {
          var r2 = e.mount.mountpoint;
          return t ? r2[r2.length - 1] !== "/" ? `${r2}/${t}` : r2 + t : r2;
        }
        t = t ? `${e.name}/${t}` : e.name, e = e.parent;
      }
    }, hashName(e, t) {
      for (var r2 = 0, a = 0;a < t.length; a++)
        r2 = (r2 << 5) - r2 + t.charCodeAt(a) | 0;
      return (e + r2 >>> 0) % FS.nameTable.length;
    }, hashAddNode(e) {
      var t = FS.hashName(e.parent.id, e.name);
      e.name_next = FS.nameTable[t], FS.nameTable[t] = e;
    }, hashRemoveNode(e) {
      var t = FS.hashName(e.parent.id, e.name);
      if (FS.nameTable[t] === e)
        FS.nameTable[t] = e.name_next;
      else
        for (var r2 = FS.nameTable[t];r2; ) {
          if (r2.name_next === e) {
            r2.name_next = e.name_next;
            break;
          }
          r2 = r2.name_next;
        }
    }, lookupNode(e, t) {
      var r2 = FS.mayLookup(e);
      if (r2)
        throw new FS.ErrnoError(r2);
      for (var a = FS.hashName(e.id, t), o3 = FS.nameTable[a];o3; o3 = o3.name_next) {
        var s2 = o3.name;
        if (o3.parent.id === e.id && s2 === t)
          return o3;
      }
      return FS.lookup(e, t);
    }, createNode(e, t, r2, a) {
      var o3 = new FS.FSNode(e, t, r2, a);
      return FS.hashAddNode(o3), o3;
    }, destroyNode(e) {
      FS.hashRemoveNode(e);
    }, isRoot(e) {
      return e === e.parent;
    }, isMountpoint(e) {
      return !!e.mounted;
    }, isFile(e) {
      return (e & 61440) === 32768;
    }, isDir(e) {
      return (e & 61440) === 16384;
    }, isLink(e) {
      return (e & 61440) === 40960;
    }, isChrdev(e) {
      return (e & 61440) === 8192;
    }, isBlkdev(e) {
      return (e & 61440) === 24576;
    }, isFIFO(e) {
      return (e & 61440) === 4096;
    }, isSocket(e) {
      return (e & 49152) === 49152;
    }, flagsToPermissionString(e) {
      var t = ["r", "w", "rw"][e & 3];
      return e & 512 && (t += "w"), t;
    }, nodePermissions(e, t) {
      return FS.ignorePermissions ? 0 : t.includes("r") && !(e.mode & 292) || t.includes("w") && !(e.mode & 146) || t.includes("x") && !(e.mode & 73) ? 2 : 0;
    }, mayLookup(e) {
      if (!FS.isDir(e.mode))
        return 54;
      var t = FS.nodePermissions(e, "x");
      return t || (e.node_ops.lookup ? 0 : 2);
    }, mayCreate(e, t) {
      if (!FS.isDir(e.mode))
        return 54;
      try {
        var r2 = FS.lookupNode(e, t);
        return 20;
      } catch {
      }
      return FS.nodePermissions(e, "wx");
    }, mayDelete(e, t, r2) {
      var a;
      try {
        a = FS.lookupNode(e, t);
      } catch (s2) {
        return s2.errno;
      }
      var o3 = FS.nodePermissions(e, "wx");
      if (o3)
        return o3;
      if (r2) {
        if (!FS.isDir(a.mode))
          return 54;
        if (FS.isRoot(a) || FS.getPath(a) === FS.cwd())
          return 10;
      } else if (FS.isDir(a.mode))
        return 31;
      return 0;
    }, mayOpen(e, t) {
      return e ? FS.isLink(e.mode) ? 32 : FS.isDir(e.mode) && (FS.flagsToPermissionString(t) !== "r" || t & 512) ? 31 : FS.nodePermissions(e, FS.flagsToPermissionString(t)) : 44;
    }, MAX_OPEN_FDS: 4096, nextfd() {
      for (var e = 0;e <= FS.MAX_OPEN_FDS; e++)
        if (!FS.streams[e])
          return e;
      throw new FS.ErrnoError(33);
    }, getStreamChecked(e) {
      var t = FS.getStream(e);
      if (!t)
        throw new FS.ErrnoError(8);
      return t;
    }, getStream: (e) => FS.streams[e], createStream(e, t = -1) {
      return e = Object.assign(new FS.FSStream, e), t == -1 && (t = FS.nextfd()), e.fd = t, FS.streams[t] = e, e;
    }, closeStream(e) {
      FS.streams[e] = null;
    }, dupStream(e, t = -1) {
      var r2 = FS.createStream(e, t);
      return r2.stream_ops?.dup?.(r2), r2;
    }, chrdev_stream_ops: { open(e) {
      var t = FS.getDevice(e.node.rdev);
      e.stream_ops = t.stream_ops, e.stream_ops.open?.(e);
    }, llseek() {
      throw new FS.ErrnoError(70);
    } }, major: (e) => e >> 8, minor: (e) => e & 255, makedev: (e, t) => e << 8 | t, registerDevice(e, t) {
      FS.devices[e] = { stream_ops: t };
    }, getDevice: (e) => FS.devices[e], getMounts(e) {
      for (var t = [], r2 = [e];r2.length; ) {
        var a = r2.pop();
        t.push(a), r2.push(...a.mounts);
      }
      return t;
    }, syncfs(e, t) {
      typeof e == "function" && (t = e, e = false), FS.syncFSRequests++, FS.syncFSRequests > 1 && err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      var r2 = FS.getMounts(FS.root.mount), a = 0;
      function o3(l3) {
        return FS.syncFSRequests--, t(l3);
      }
      function s2(l3) {
        if (l3)
          return s2.errored ? undefined : (s2.errored = true, o3(l3));
        ++a >= r2.length && o3(null);
      }
      r2.forEach((l3) => {
        if (!l3.type.syncfs)
          return s2(null);
        l3.type.syncfs(l3, e, s2);
      });
    }, mount(e, t, r2) {
      var a = r2 === "/", o3 = !r2, s2;
      if (a && FS.root)
        throw new FS.ErrnoError(10);
      if (!a && !o3) {
        var l3 = FS.lookupPath(r2, { follow_mount: false });
        if (r2 = l3.path, s2 = l3.node, FS.isMountpoint(s2))
          throw new FS.ErrnoError(10);
        if (!FS.isDir(s2.mode))
          throw new FS.ErrnoError(54);
      }
      var _2 = { type: e, opts: t, mountpoint: r2, mounts: [] }, n = e.mount(_2);
      return n.mount = _2, _2.root = n, a ? FS.root = n : s2 && (s2.mounted = _2, s2.mount && s2.mount.mounts.push(_2)), n;
    }, unmount(e) {
      var t = FS.lookupPath(e, { follow_mount: false });
      if (!FS.isMountpoint(t.node))
        throw new FS.ErrnoError(28);
      var r2 = t.node, a = r2.mounted, o3 = FS.getMounts(a);
      Object.keys(FS.nameTable).forEach((l3) => {
        for (var _2 = FS.nameTable[l3];_2; ) {
          var n = _2.name_next;
          o3.includes(_2.mount) && FS.destroyNode(_2), _2 = n;
        }
      }), r2.mounted = null;
      var s2 = r2.mount.mounts.indexOf(a);
      r2.mount.mounts.splice(s2, 1);
    }, lookup(e, t) {
      return e.node_ops.lookup(e, t);
    }, mknod(e, t, r2) {
      var a = FS.lookupPath(e, { parent: true }), o3 = a.node, s2 = PATH.basename(e);
      if (!s2 || s2 === "." || s2 === "..")
        throw new FS.ErrnoError(28);
      var l3 = FS.mayCreate(o3, s2);
      if (l3)
        throw new FS.ErrnoError(l3);
      if (!o3.node_ops.mknod)
        throw new FS.ErrnoError(63);
      return o3.node_ops.mknod(o3, s2, t, r2);
    }, statfs(e) {
      var t = { bsize: 4096, frsize: 4096, blocks: 1e6, bfree: 500000, bavail: 500000, files: FS.nextInode, ffree: FS.nextInode - 1, fsid: 42, flags: 2, namelen: 255 }, r2 = FS.lookupPath(e, { follow: true }).node;
      return r2?.node_ops.statfs && Object.assign(t, r2.node_ops.statfs(r2.mount.opts.root)), t;
    }, create(e, t = 438) {
      return t &= 4095, t |= 32768, FS.mknod(e, t, 0);
    }, mkdir(e, t = 511) {
      return t &= 1023, t |= 16384, FS.mknod(e, t, 0);
    }, mkdirTree(e, t) {
      for (var r2 = e.split("/"), a = "", o3 = 0;o3 < r2.length; ++o3)
        if (r2[o3]) {
          a += "/" + r2[o3];
          try {
            FS.mkdir(a, t);
          } catch (s2) {
            if (s2.errno != 20)
              throw s2;
          }
        }
    }, mkdev(e, t, r2) {
      return typeof r2 > "u" && (r2 = t, t = 438), t |= 8192, FS.mknod(e, t, r2);
    }, symlink(e, t) {
      if (!PATH_FS.resolve(e))
        throw new FS.ErrnoError(44);
      var r2 = FS.lookupPath(t, { parent: true }), a = r2.node;
      if (!a)
        throw new FS.ErrnoError(44);
      var o3 = PATH.basename(t), s2 = FS.mayCreate(a, o3);
      if (s2)
        throw new FS.ErrnoError(s2);
      if (!a.node_ops.symlink)
        throw new FS.ErrnoError(63);
      return a.node_ops.symlink(a, o3, e);
    }, rename(e, t) {
      var r2 = PATH.dirname(e), a = PATH.dirname(t), o3 = PATH.basename(e), s2 = PATH.basename(t), l3, _2, n;
      if (l3 = FS.lookupPath(e, { parent: true }), _2 = l3.node, l3 = FS.lookupPath(t, { parent: true }), n = l3.node, !_2 || !n)
        throw new FS.ErrnoError(44);
      if (_2.mount !== n.mount)
        throw new FS.ErrnoError(75);
      var m2 = FS.lookupNode(_2, o3), p = PATH_FS.relative(e, a);
      if (p.charAt(0) !== ".")
        throw new FS.ErrnoError(28);
      if (p = PATH_FS.relative(t, r2), p.charAt(0) !== ".")
        throw new FS.ErrnoError(55);
      var d2;
      try {
        d2 = FS.lookupNode(n, s2);
      } catch {
      }
      if (m2 !== d2) {
        var g3 = FS.isDir(m2.mode), u3 = FS.mayDelete(_2, o3, g3);
        if (u3)
          throw new FS.ErrnoError(u3);
        if (u3 = d2 ? FS.mayDelete(n, s2, g3) : FS.mayCreate(n, s2), u3)
          throw new FS.ErrnoError(u3);
        if (!_2.node_ops.rename)
          throw new FS.ErrnoError(63);
        if (FS.isMountpoint(m2) || d2 && FS.isMountpoint(d2))
          throw new FS.ErrnoError(10);
        if (n !== _2 && (u3 = FS.nodePermissions(_2, "w"), u3))
          throw new FS.ErrnoError(u3);
        FS.hashRemoveNode(m2);
        try {
          _2.node_ops.rename(m2, n, s2), m2.parent = n;
        } catch (f) {
          throw f;
        } finally {
          FS.hashAddNode(m2);
        }
      }
    }, rmdir(e) {
      var t = FS.lookupPath(e, { parent: true }), r2 = t.node, a = PATH.basename(e), o3 = FS.lookupNode(r2, a), s2 = FS.mayDelete(r2, a, true);
      if (s2)
        throw new FS.ErrnoError(s2);
      if (!r2.node_ops.rmdir)
        throw new FS.ErrnoError(63);
      if (FS.isMountpoint(o3))
        throw new FS.ErrnoError(10);
      r2.node_ops.rmdir(r2, a), FS.destroyNode(o3);
    }, readdir(e) {
      var t = FS.lookupPath(e, { follow: true }), r2 = t.node;
      if (!r2.node_ops.readdir)
        throw new FS.ErrnoError(54);
      return r2.node_ops.readdir(r2);
    }, unlink(e) {
      var t = FS.lookupPath(e, { parent: true }), r2 = t.node;
      if (!r2)
        throw new FS.ErrnoError(44);
      var a = PATH.basename(e), o3 = FS.lookupNode(r2, a), s2 = FS.mayDelete(r2, a, false);
      if (s2)
        throw new FS.ErrnoError(s2);
      if (!r2.node_ops.unlink)
        throw new FS.ErrnoError(63);
      if (FS.isMountpoint(o3))
        throw new FS.ErrnoError(10);
      r2.node_ops.unlink(r2, a), FS.destroyNode(o3);
    }, readlink(e) {
      var t = FS.lookupPath(e), r2 = t.node;
      if (!r2)
        throw new FS.ErrnoError(44);
      if (!r2.node_ops.readlink)
        throw new FS.ErrnoError(28);
      return r2.node_ops.readlink(r2);
    }, stat(e, t) {
      var r2 = FS.lookupPath(e, { follow: !t }), a = r2.node;
      if (!a)
        throw new FS.ErrnoError(44);
      if (!a.node_ops.getattr)
        throw new FS.ErrnoError(63);
      return a.node_ops.getattr(a);
    }, lstat(e) {
      return FS.stat(e, true);
    }, chmod(e, t, r2) {
      var a;
      if (typeof e == "string") {
        var o3 = FS.lookupPath(e, { follow: !r2 });
        a = o3.node;
      } else
        a = e;
      if (!a.node_ops.setattr)
        throw new FS.ErrnoError(63);
      a.node_ops.setattr(a, { mode: t & 4095 | a.mode & -4096, ctime: Date.now() });
    }, lchmod(e, t) {
      FS.chmod(e, t, true);
    }, fchmod(e, t) {
      var r2 = FS.getStreamChecked(e);
      FS.chmod(r2.node, t);
    }, chown(e, t, r2, a) {
      var o3;
      if (typeof e == "string") {
        var s2 = FS.lookupPath(e, { follow: !a });
        o3 = s2.node;
      } else
        o3 = e;
      if (!o3.node_ops.setattr)
        throw new FS.ErrnoError(63);
      o3.node_ops.setattr(o3, { timestamp: Date.now() });
    }, lchown(e, t, r2) {
      FS.chown(e, t, r2, true);
    }, fchown(e, t, r2) {
      var a = FS.getStreamChecked(e);
      FS.chown(a.node, t, r2);
    }, truncate(e, t) {
      if (t < 0)
        throw new FS.ErrnoError(28);
      var r2;
      if (typeof e == "string") {
        var a = FS.lookupPath(e, { follow: true });
        r2 = a.node;
      } else
        r2 = e;
      if (!r2.node_ops.setattr)
        throw new FS.ErrnoError(63);
      if (FS.isDir(r2.mode))
        throw new FS.ErrnoError(31);
      if (!FS.isFile(r2.mode))
        throw new FS.ErrnoError(28);
      var o3 = FS.nodePermissions(r2, "w");
      if (o3)
        throw new FS.ErrnoError(o3);
      r2.node_ops.setattr(r2, { size: t, timestamp: Date.now() });
    }, ftruncate(e, t) {
      var r2 = FS.getStreamChecked(e);
      if (!(r2.flags & 2097155))
        throw new FS.ErrnoError(28);
      FS.truncate(r2.node, t);
    }, utime(e, t, r2) {
      var a = FS.lookupPath(e, { follow: true }), o3 = a.node;
      o3.node_ops.setattr(o3, { atime: t, mtime: r2 });
    }, open(e, t, r2 = 438) {
      if (e === "")
        throw new FS.ErrnoError(44);
      t = typeof t == "string" ? FS_modeStringToFlags(t) : t, t & 64 ? r2 = r2 & 4095 | 32768 : r2 = 0;
      var a;
      if (typeof e == "object")
        a = e;
      else {
        var o3 = FS.lookupPath(e, { follow: !(t & 131072), noent_okay: true });
        a = o3.node, e = o3.path;
      }
      var s2 = false;
      if (t & 64)
        if (a) {
          if (t & 128)
            throw new FS.ErrnoError(20);
        } else
          a = FS.mknod(e, r2, 0), s2 = true;
      if (!a)
        throw new FS.ErrnoError(44);
      if (FS.isChrdev(a.mode) && (t &= -513), t & 65536 && !FS.isDir(a.mode))
        throw new FS.ErrnoError(54);
      if (!s2) {
        var l3 = FS.mayOpen(a, t);
        if (l3)
          throw new FS.ErrnoError(l3);
      }
      t & 512 && !s2 && FS.truncate(a, 0), t &= -131713;
      var _2 = FS.createStream({ node: a, path: FS.getPath(a), flags: t, seekable: true, position: 0, stream_ops: a.stream_ops, ungotten: [], error: false });
      return _2.stream_ops.open && _2.stream_ops.open(_2), Module.logReadFiles && !(t & 1) && ((e in FS.readFiles) || (FS.readFiles[e] = 1)), _2;
    }, close(e) {
      if (FS.isClosed(e))
        throw new FS.ErrnoError(8);
      e.getdents && (e.getdents = null);
      try {
        e.stream_ops.close && e.stream_ops.close(e);
      } catch (t) {
        throw t;
      } finally {
        FS.closeStream(e.fd);
      }
      e.fd = null;
    }, isClosed(e) {
      return e.fd === null;
    }, llseek(e, t, r2) {
      if (FS.isClosed(e))
        throw new FS.ErrnoError(8);
      if (!e.seekable || !e.stream_ops.llseek)
        throw new FS.ErrnoError(70);
      if (r2 != 0 && r2 != 1 && r2 != 2)
        throw new FS.ErrnoError(28);
      return e.position = e.stream_ops.llseek(e, t, r2), e.ungotten = [], e.position;
    }, read(e, t, r2, a, o3) {
      if (a < 0 || o3 < 0)
        throw new FS.ErrnoError(28);
      if (FS.isClosed(e))
        throw new FS.ErrnoError(8);
      if ((e.flags & 2097155) === 1)
        throw new FS.ErrnoError(8);
      if (FS.isDir(e.node.mode))
        throw new FS.ErrnoError(31);
      if (!e.stream_ops.read)
        throw new FS.ErrnoError(28);
      var s2 = typeof o3 < "u";
      if (!s2)
        o3 = e.position;
      else if (!e.seekable)
        throw new FS.ErrnoError(70);
      var l3 = e.stream_ops.read(e, t, r2, a, o3);
      return s2 || (e.position += l3), l3;
    }, write(e, t, r2, a, o3, s2) {
      if (a < 0 || o3 < 0)
        throw new FS.ErrnoError(28);
      if (FS.isClosed(e))
        throw new FS.ErrnoError(8);
      if (!(e.flags & 2097155))
        throw new FS.ErrnoError(8);
      if (FS.isDir(e.node.mode))
        throw new FS.ErrnoError(31);
      if (!e.stream_ops.write)
        throw new FS.ErrnoError(28);
      e.seekable && e.flags & 1024 && FS.llseek(e, 0, 2);
      var l3 = typeof o3 < "u";
      if (!l3)
        o3 = e.position;
      else if (!e.seekable)
        throw new FS.ErrnoError(70);
      var _2 = e.stream_ops.write(e, t, r2, a, o3, s2);
      return l3 || (e.position += _2), _2;
    }, allocate(e, t, r2) {
      if (FS.isClosed(e))
        throw new FS.ErrnoError(8);
      if (t < 0 || r2 <= 0)
        throw new FS.ErrnoError(28);
      if (!(e.flags & 2097155))
        throw new FS.ErrnoError(8);
      if (!FS.isFile(e.node.mode) && !FS.isDir(e.node.mode))
        throw new FS.ErrnoError(43);
      if (!e.stream_ops.allocate)
        throw new FS.ErrnoError(138);
      e.stream_ops.allocate(e, t, r2);
    }, mmap(e, t, r2, a, o3) {
      if (a & 2 && !(o3 & 2) && (e.flags & 2097155) !== 2)
        throw new FS.ErrnoError(2);
      if ((e.flags & 2097155) === 1)
        throw new FS.ErrnoError(2);
      if (!e.stream_ops.mmap)
        throw new FS.ErrnoError(43);
      if (!t)
        throw new FS.ErrnoError(28);
      return e.stream_ops.mmap(e, t, r2, a, o3);
    }, msync(e, t, r2, a, o3) {
      return e.stream_ops.msync ? e.stream_ops.msync(e, t, r2, a, o3) : 0;
    }, ioctl(e, t, r2) {
      if (!e.stream_ops.ioctl)
        throw new FS.ErrnoError(59);
      return e.stream_ops.ioctl(e, t, r2);
    }, readFile(e, t = {}) {
      if (t.flags = t.flags || 0, t.encoding = t.encoding || "binary", t.encoding !== "utf8" && t.encoding !== "binary")
        throw new Error(`Invalid encoding type "${t.encoding}"`);
      var r2, a = FS.open(e, t.flags), o3 = FS.stat(e), s2 = o3.size, l3 = new Uint8Array(s2);
      return FS.read(a, l3, 0, s2, 0), t.encoding === "utf8" ? r2 = UTF8ArrayToString(l3) : t.encoding === "binary" && (r2 = l3), FS.close(a), r2;
    }, writeFile(e, t, r2 = {}) {
      r2.flags = r2.flags || 577;
      var a = FS.open(e, r2.flags, r2.mode);
      if (typeof t == "string") {
        var o3 = new Uint8Array(lengthBytesUTF8(t) + 1), s2 = stringToUTF8Array(t, o3, 0, o3.length);
        FS.write(a, o3, 0, s2, undefined, r2.canOwn);
      } else if (ArrayBuffer.isView(t))
        FS.write(a, t, 0, t.byteLength, undefined, r2.canOwn);
      else
        throw new Error("Unsupported data type");
      FS.close(a);
    }, cwd: () => FS.currentPath, chdir(e) {
      var t = FS.lookupPath(e, { follow: true });
      if (t.node === null)
        throw new FS.ErrnoError(44);
      if (!FS.isDir(t.node.mode))
        throw new FS.ErrnoError(54);
      var r2 = FS.nodePermissions(t.node, "x");
      if (r2)
        throw new FS.ErrnoError(r2);
      FS.currentPath = t.path;
    }, createDefaultDirectories() {
      FS.mkdir("/tmp"), FS.mkdir("/home"), FS.mkdir("/home/web_user");
    }, createDefaultDevices() {
      FS.mkdir("/dev"), FS.registerDevice(FS.makedev(1, 3), { read: () => 0, write: (a, o3, s2, l3, _2) => l3, llseek: () => 0 }), FS.mkdev("/dev/null", FS.makedev(1, 3)), TTY.register(FS.makedev(5, 0), TTY.default_tty_ops), TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops), FS.mkdev("/dev/tty", FS.makedev(5, 0)), FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var e = new Uint8Array(1024), t = 0, r2 = () => (t === 0 && (t = randomFill(e).byteLength), e[--t]);
      FS.createDevice("/dev", "random", r2), FS.createDevice("/dev", "urandom", r2), FS.mkdir("/dev/shm"), FS.mkdir("/dev/shm/tmp");
    }, createSpecialDirectories() {
      FS.mkdir("/proc");
      var e = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd"), FS.mount({ mount() {
        var t = FS.createNode(e, "fd", 16895, 73);
        return t.stream_ops = { llseek: MEMFS.stream_ops.llseek }, t.node_ops = { lookup(r2, a) {
          var o3 = +a, s2 = FS.getStreamChecked(o3), l3 = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: () => s2.path }, id: o3 + 1 };
          return l3.parent = l3, l3;
        }, readdir() {
          return Array.from(FS.streams.entries()).filter(([r2, a]) => a).map(([r2, a]) => r2.toString());
        } }, t;
      } }, {}, "/proc/self/fd");
    }, createStandardStreams(e, t, r2) {
      e ? FS.createDevice("/dev", "stdin", e) : FS.symlink("/dev/tty", "/dev/stdin"), t ? FS.createDevice("/dev", "stdout", null, t) : FS.symlink("/dev/tty", "/dev/stdout"), r2 ? FS.createDevice("/dev", "stderr", null, r2) : FS.symlink("/dev/tty1", "/dev/stderr");
      var a = FS.open("/dev/stdin", 0), o3 = FS.open("/dev/stdout", 1), s2 = FS.open("/dev/stderr", 1);
    }, staticInit() {
      FS.nameTable = new Array(4096), FS.mount(MEMFS, {}, "/"), FS.createDefaultDirectories(), FS.createDefaultDevices(), FS.createSpecialDirectories(), FS.filesystems = { MEMFS, IDBFS, NODEFS };
    }, init(e, t, r2) {
      FS.initialized = true, e ?? (e = Module.stdin), t ?? (t = Module.stdout), r2 ?? (r2 = Module.stderr), FS.createStandardStreams(e, t, r2);
    }, quit() {
      FS.initialized = false, _fflush(0);
      for (var e = 0;e < FS.streams.length; e++) {
        var t = FS.streams[e];
        t && FS.close(t);
      }
    }, findObject(e, t) {
      var r2 = FS.analyzePath(e, t);
      return r2.exists ? r2.object : null;
    }, analyzePath(e, t) {
      try {
        var r2 = FS.lookupPath(e, { follow: !t });
        e = r2.path;
      } catch {
      }
      var a = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
      try {
        var r2 = FS.lookupPath(e, { parent: true });
        a.parentExists = true, a.parentPath = r2.path, a.parentObject = r2.node, a.name = PATH.basename(e), r2 = FS.lookupPath(e, { follow: !t }), a.exists = true, a.path = r2.path, a.object = r2.node, a.name = r2.node.name, a.isRoot = r2.path === "/";
      } catch (o3) {
        a.error = o3.errno;
      }
      return a;
    }, createPath(e, t, r2, a) {
      e = typeof e == "string" ? e : FS.getPath(e);
      for (var o3 = t.split("/").reverse();o3.length; ) {
        var s2 = o3.pop();
        if (s2) {
          var l3 = PATH.join2(e, s2);
          try {
            FS.mkdir(l3);
          } catch {
          }
          e = l3;
        }
      }
      return l3;
    }, createFile(e, t, r2, a, o3) {
      var s2 = PATH.join2(typeof e == "string" ? e : FS.getPath(e), t), l3 = FS_getMode(a, o3);
      return FS.create(s2, l3);
    }, createDataFile(e, t, r2, a, o3, s2) {
      var l3 = t;
      e && (e = typeof e == "string" ? e : FS.getPath(e), l3 = t ? PATH.join2(e, t) : e);
      var _2 = FS_getMode(a, o3), n = FS.create(l3, _2);
      if (r2) {
        if (typeof r2 == "string") {
          for (var m2 = new Array(r2.length), p = 0, d2 = r2.length;p < d2; ++p)
            m2[p] = r2.charCodeAt(p);
          r2 = m2;
        }
        FS.chmod(n, _2 | 146);
        var g3 = FS.open(n, 577);
        FS.write(g3, r2, 0, r2.length, 0, s2), FS.close(g3), FS.chmod(n, _2);
      }
    }, createDevice(e, t, r2, a) {
      var _2;
      var o3 = PATH.join2(typeof e == "string" ? e : FS.getPath(e), t), s2 = FS_getMode(!!r2, !!a);
      (_2 = FS.createDevice).major ?? (_2.major = 64);
      var l3 = FS.makedev(FS.createDevice.major++, 0);
      return FS.registerDevice(l3, { open(n) {
        n.seekable = false;
      }, close(n) {
        a?.buffer?.length && a(10);
      }, read(n, m2, p, d2, g3) {
        for (var u3 = 0, f = 0;f < d2; f++) {
          var c;
          try {
            c = r2();
          } catch {
            throw new FS.ErrnoError(29);
          }
          if (c === undefined && u3 === 0)
            throw new FS.ErrnoError(6);
          if (c == null)
            break;
          u3++, m2[p + f] = c;
        }
        return u3 && (n.node.atime = Date.now()), u3;
      }, write(n, m2, p, d2, g3) {
        for (var u3 = 0;u3 < d2; u3++)
          try {
            a(m2[p + u3]);
          } catch {
            throw new FS.ErrnoError(29);
          }
        return d2 && (n.node.mtime = n.node.ctime = Date.now()), u3;
      } }), FS.mkdev(o3, s2, l3);
    }, forceLoadFile(e) {
      if (e.isDevice || e.isFolder || e.link || e.contents)
        return true;
      if (typeof XMLHttpRequest < "u")
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      try {
        e.contents = readBinary(e.url), e.usedBytes = e.contents.length;
      } catch {
        throw new FS.ErrnoError(29);
      }
    }, createLazyFile(e, t, r2, a, o3) {

      class s2 {
        constructor() {
          P(this, "lengthKnown", false);
          P(this, "chunks", []);
        }
        get(u3) {
          if (!(u3 > this.length - 1 || u3 < 0)) {
            var f = u3 % this.chunkSize, c = u3 / this.chunkSize | 0;
            return this.getter(c)[f];
          }
        }
        setDataGetter(u3) {
          this.getter = u3;
        }
        cacheLength() {
          var u3 = new XMLHttpRequest;
          if (u3.open("HEAD", r2, false), u3.send(null), !(u3.status >= 200 && u3.status < 300 || u3.status === 304))
            throw new Error("Couldn't load " + r2 + ". Status: " + u3.status);
          var f = Number(u3.getResponseHeader("Content-length")), c, w2 = (c = u3.getResponseHeader("Accept-Ranges")) && c === "bytes", h3 = (c = u3.getResponseHeader("Content-Encoding")) && c === "gzip", v2 = 1048576;
          w2 || (v2 = f);
          var x3 = (M2, E2) => {
            if (M2 > E2)
              throw new Error("invalid range (" + M2 + ", " + E2 + ") or no bytes requested!");
            if (E2 > f - 1)
              throw new Error("only " + f + " bytes available! programmer error!");
            var b3 = new XMLHttpRequest;
            if (b3.open("GET", r2, false), f !== v2 && b3.setRequestHeader("Range", "bytes=" + M2 + "-" + E2), b3.responseType = "arraybuffer", b3.overrideMimeType && b3.overrideMimeType("text/plain; charset=x-user-defined"), b3.send(null), !(b3.status >= 200 && b3.status < 300 || b3.status === 304))
              throw new Error("Couldn't load " + r2 + ". Status: " + b3.status);
            return b3.response !== undefined ? new Uint8Array(b3.response || []) : intArrayFromString(b3.responseText || "", true);
          }, y2 = this;
          y2.setDataGetter((M2) => {
            var E2 = M2 * v2, b3 = (M2 + 1) * v2 - 1;
            if (b3 = Math.min(b3, f - 1), typeof y2.chunks[M2] > "u" && (y2.chunks[M2] = x3(E2, b3)), typeof y2.chunks[M2] > "u")
              throw new Error("doXHR failed!");
            return y2.chunks[M2];
          }), (h3 || !f) && (v2 = f = 1, f = this.getter(0).length, v2 = f, out("LazyFiles on gzip forces download of the whole file when length is accessed")), this._length = f, this._chunkSize = v2, this.lengthKnown = true;
        }
        get length() {
          return this.lengthKnown || this.cacheLength(), this._length;
        }
        get chunkSize() {
          return this.lengthKnown || this.cacheLength(), this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest < "u") {
        if (!ENVIRONMENT_IS_WORKER)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var l3 = new s2, _2 = { isDevice: false, contents: l3 };
      } else
        var _2 = { isDevice: false, url: r2 };
      var n = FS.createFile(e, t, _2, a, o3);
      _2.contents ? n.contents = _2.contents : _2.url && (n.contents = null, n.url = _2.url), Object.defineProperties(n, { usedBytes: { get: function() {
        return this.contents.length;
      } } });
      var m2 = {}, p = Object.keys(n.stream_ops);
      p.forEach((g3) => {
        var u3 = n.stream_ops[g3];
        m2[g3] = (...f) => (FS.forceLoadFile(n), u3(...f));
      });
      function d2(g3, u3, f, c, w2) {
        var h3 = g3.node.contents;
        if (w2 >= h3.length)
          return 0;
        var v2 = Math.min(h3.length - w2, c);
        if (h3.slice)
          for (var x3 = 0;x3 < v2; x3++)
            u3[f + x3] = h3[w2 + x3];
        else
          for (var x3 = 0;x3 < v2; x3++)
            u3[f + x3] = h3.get(w2 + x3);
        return v2;
      }
      return m2.read = (g3, u3, f, c, w2) => (FS.forceLoadFile(n), d2(g3, u3, f, c, w2)), m2.mmap = (g3, u3, f, c, w2) => {
        FS.forceLoadFile(n);
        var h3 = mmapAlloc(u3);
        if (!h3)
          throw new FS.ErrnoError(48);
        return d2(g3, HEAP8, h3, u3, f), { ptr: h3, allocated: true };
      }, n.stream_ops = m2, n;
    } }, SYSCALLS = { DEFAULT_POLLMASK: 5, calculateAt(e, t, r2) {
      if (PATH.isAbs(t))
        return t;
      var a;
      if (e === -100)
        a = FS.cwd();
      else {
        var o3 = SYSCALLS.getStreamFromFD(e);
        a = o3.path;
      }
      if (t.length == 0) {
        if (!r2)
          throw new FS.ErrnoError(44);
        return a;
      }
      return a + "/" + t;
    }, doStat(e, t, r2) {
      var a = e(t);
      HEAP32[r2 >> 2] = a.dev, HEAP32[r2 + 4 >> 2] = a.mode, HEAPU32[r2 + 8 >> 2] = a.nlink, HEAP32[r2 + 12 >> 2] = a.uid, HEAP32[r2 + 16 >> 2] = a.gid, HEAP32[r2 + 20 >> 2] = a.rdev, HEAP64[r2 + 24 >> 3] = BigInt(a.size), HEAP32[r2 + 32 >> 2] = 4096, HEAP32[r2 + 36 >> 2] = a.blocks;
      var o3 = a.atime.getTime(), s2 = a.mtime.getTime(), l3 = a.ctime.getTime();
      return HEAP64[r2 + 40 >> 3] = BigInt(Math.floor(o3 / 1000)), HEAPU32[r2 + 48 >> 2] = o3 % 1000 * 1000 * 1000, HEAP64[r2 + 56 >> 3] = BigInt(Math.floor(s2 / 1000)), HEAPU32[r2 + 64 >> 2] = s2 % 1000 * 1000 * 1000, HEAP64[r2 + 72 >> 3] = BigInt(Math.floor(l3 / 1000)), HEAPU32[r2 + 80 >> 2] = l3 % 1000 * 1000 * 1000, HEAP64[r2 + 88 >> 3] = BigInt(a.ino), 0;
    }, doMsync(e, t, r2, a, o3) {
      if (!FS.isFile(t.node.mode))
        throw new FS.ErrnoError(43);
      if (a & 2)
        return 0;
      var s2 = HEAPU8.slice(e, e + r2);
      FS.msync(t, s2, o3, r2, a);
    }, getStreamFromFD(e) {
      var t = FS.getStreamChecked(e);
      return t;
    }, varargs: undefined, getStr(e) {
      var t = UTF8ToString(e);
      return t;
    } }, ___syscall__newselect = function(e, t, r2, a, o3) {
      try {
        for (var s2 = 0, l3 = t ? HEAP32[t >> 2] : 0, _2 = t ? HEAP32[t + 4 >> 2] : 0, n = r2 ? HEAP32[r2 >> 2] : 0, m2 = r2 ? HEAP32[r2 + 4 >> 2] : 0, p = a ? HEAP32[a >> 2] : 0, d2 = a ? HEAP32[a + 4 >> 2] : 0, g3 = 0, u3 = 0, f = 0, c = 0, w2 = 0, h3 = 0, v2 = (t ? HEAP32[t >> 2] : 0) | (r2 ? HEAP32[r2 >> 2] : 0) | (a ? HEAP32[a >> 2] : 0), x3 = (t ? HEAP32[t + 4 >> 2] : 0) | (r2 ? HEAP32[r2 + 4 >> 2] : 0) | (a ? HEAP32[a + 4 >> 2] : 0), y2 = (N2, P3, R4, k2) => N2 < 32 ? P3 & k2 : R4 & k2, M2 = 0;M2 < e; M2++) {
          var E2 = 1 << M2 % 32;
          if (y2(M2, v2, x3, E2)) {
            var b3 = SYSCALLS.getStreamFromFD(M2), U3 = SYSCALLS.DEFAULT_POLLMASK;
            if (b3.stream_ops.poll) {
              var z3 = -1;
              if (o3) {
                var W2 = t ? HEAP32[o3 >> 2] : 0, D2 = t ? HEAP32[o3 + 4 >> 2] : 0;
                z3 = (W2 + D2 / 1e6) * 1000;
              }
              U3 = b3.stream_ops.poll(b3, z3);
            }
            U3 & 1 && y2(M2, l3, _2, E2) && (M2 < 32 ? g3 = g3 | E2 : u3 = u3 | E2, s2++), U3 & 4 && y2(M2, n, m2, E2) && (M2 < 32 ? f = f | E2 : c = c | E2, s2++), U3 & 2 && y2(M2, p, d2, E2) && (M2 < 32 ? w2 = w2 | E2 : h3 = h3 | E2, s2++);
          }
        }
        return t && (HEAP32[t >> 2] = g3, HEAP32[t + 4 >> 2] = u3), r2 && (HEAP32[r2 >> 2] = f, HEAP32[r2 + 4 >> 2] = c), a && (HEAP32[a >> 2] = w2, HEAP32[a + 4 >> 2] = h3), s2;
      } catch (N2) {
        if (typeof FS > "u" || N2.name !== "ErrnoError")
          throw N2;
        return -N2.errno;
      }
    };
    ___syscall__newselect.sig = "iipppp";
    var SOCKFS = { websocketArgs: {}, callbacks: {}, on(e, t) {
      SOCKFS.callbacks[e] = t;
    }, emit(e, t) {
      SOCKFS.callbacks[e]?.(t);
    }, mount(e) {
      return SOCKFS.websocketArgs = Module.websocket || {}, (Module.websocket ?? (Module.websocket = {})).on = SOCKFS.on, FS.createNode(null, "/", 16895, 0);
    }, createSocket(e, t, r2) {
      t &= -526337;
      var a = t == 1;
      if (a && r2 && r2 != 6)
        throw new FS.ErrnoError(66);
      var o3 = { family: e, type: t, protocol: r2, server: null, error: null, peers: {}, pending: [], recv_queue: [], sock_ops: SOCKFS.websocket_sock_ops }, s2 = SOCKFS.nextname(), l3 = FS.createNode(SOCKFS.root, s2, 49152, 0);
      l3.sock = o3;
      var _2 = FS.createStream({ path: s2, node: l3, flags: 2, seekable: false, stream_ops: SOCKFS.stream_ops });
      return o3.stream = _2, o3;
    }, getSocket(e) {
      var t = FS.getStream(e);
      return !t || !FS.isSocket(t.node.mode) ? null : t.node.sock;
    }, stream_ops: { poll(e) {
      var t = e.node.sock;
      return t.sock_ops.poll(t);
    }, ioctl(e, t, r2) {
      var a = e.node.sock;
      return a.sock_ops.ioctl(a, t, r2);
    }, read(e, t, r2, a, o3) {
      var s2 = e.node.sock, l3 = s2.sock_ops.recvmsg(s2, a);
      return l3 ? (t.set(l3.buffer, r2), l3.buffer.length) : 0;
    }, write(e, t, r2, a, o3) {
      var s2 = e.node.sock;
      return s2.sock_ops.sendmsg(s2, t, r2, a);
    }, close(e) {
      var t = e.node.sock;
      t.sock_ops.close(t);
    } }, nextname() {
      return SOCKFS.nextname.current || (SOCKFS.nextname.current = 0), `socket[${SOCKFS.nextname.current++}]`;
    }, websocket_sock_ops: { createPeer(e, t, r2) {
      var a;
      if (typeof t == "object" && (a = t, t = null, r2 = null), a)
        if (a._socket)
          t = a._socket.remoteAddress, r2 = a._socket.remotePort;
        else {
          var o3 = /ws[s]?:\/\/([^:]+):(\d+)/.exec(a.url);
          if (!o3)
            throw new Error("WebSocket URL must be in the format ws(s)://address:port");
          t = o3[1], r2 = parseInt(o3[2], 10);
        }
      else
        try {
          var s2 = "ws:#".replace("#", "//"), l3 = "binary", _2 = undefined;
          if (SOCKFS.websocketArgs.url && (s2 = SOCKFS.websocketArgs.url), SOCKFS.websocketArgs.subprotocol ? l3 = SOCKFS.websocketArgs.subprotocol : SOCKFS.websocketArgs.subprotocol === null && (l3 = "null"), s2 === "ws://" || s2 === "wss://") {
            var n = t.split("/");
            s2 = s2 + n[0] + ":" + r2 + "/" + n.slice(1).join("/");
          }
          l3 !== "null" && (l3 = l3.replace(/^ +| +$/g, "").split(/ *, */), _2 = l3);
          var m2;
          ENVIRONMENT_IS_NODE ? m2 = require("ws") : m2 = WebSocket, a = new m2(s2, _2), a.binaryType = "arraybuffer";
        } catch {
          throw new FS.ErrnoError(23);
        }
      var p = { addr: t, port: r2, socket: a, msg_send_queue: [] };
      return SOCKFS.websocket_sock_ops.addPeer(e, p), SOCKFS.websocket_sock_ops.handlePeerEvents(e, p), e.type === 2 && typeof e.sport < "u" && p.msg_send_queue.push(new Uint8Array([255, 255, 255, 255, 112, 111, 114, 116, (e.sport & 65280) >> 8, e.sport & 255])), p;
    }, getPeer(e, t, r2) {
      return e.peers[t + ":" + r2];
    }, addPeer(e, t) {
      e.peers[t.addr + ":" + t.port] = t;
    }, removePeer(e, t) {
      delete e.peers[t.addr + ":" + t.port];
    }, handlePeerEvents(e, t) {
      var r2 = true, a = function() {
        e.connecting = false, SOCKFS.emit("open", e.stream.fd);
        try {
          for (var s2 = t.msg_send_queue.shift();s2; )
            t.socket.send(s2), s2 = t.msg_send_queue.shift();
        } catch {
          t.socket.close();
        }
      };
      function o3(s2) {
        if (typeof s2 == "string") {
          var l3 = new TextEncoder;
          s2 = l3.encode(s2);
        } else {
          if (assert(s2.byteLength !== undefined), s2.byteLength == 0)
            return;
          s2 = new Uint8Array(s2);
        }
        var _2 = r2;
        if (r2 = false, _2 && s2.length === 10 && s2[0] === 255 && s2[1] === 255 && s2[2] === 255 && s2[3] === 255 && s2[4] === 112 && s2[5] === 111 && s2[6] === 114 && s2[7] === 116) {
          var n = s2[8] << 8 | s2[9];
          SOCKFS.websocket_sock_ops.removePeer(e, t), t.port = n, SOCKFS.websocket_sock_ops.addPeer(e, t);
          return;
        }
        e.recv_queue.push({ addr: t.addr, port: t.port, data: s2 }), SOCKFS.emit("message", e.stream.fd);
      }
      ENVIRONMENT_IS_NODE ? (t.socket.on("open", a), t.socket.on("message", function(s2, l3) {
        l3 && o3(new Uint8Array(s2).buffer);
      }), t.socket.on("close", function() {
        SOCKFS.emit("close", e.stream.fd);
      }), t.socket.on("error", function(s2) {
        e.error = 14, SOCKFS.emit("error", [e.stream.fd, e.error, "ECONNREFUSED: Connection refused"]);
      })) : (t.socket.onopen = a, t.socket.onclose = function() {
        SOCKFS.emit("close", e.stream.fd);
      }, t.socket.onmessage = function(l3) {
        o3(l3.data);
      }, t.socket.onerror = function(s2) {
        e.error = 14, SOCKFS.emit("error", [e.stream.fd, e.error, "ECONNREFUSED: Connection refused"]);
      });
    }, poll(e) {
      if (e.type === 1 && e.server)
        return e.pending.length ? 65 : 0;
      var t = 0, r2 = e.type === 1 ? SOCKFS.websocket_sock_ops.getPeer(e, e.daddr, e.dport) : null;
      return (e.recv_queue.length || !r2 || r2 && r2.socket.readyState === r2.socket.CLOSING || r2 && r2.socket.readyState === r2.socket.CLOSED) && (t |= 65), (!r2 || r2 && r2.socket.readyState === r2.socket.OPEN) && (t |= 4), (r2 && r2.socket.readyState === r2.socket.CLOSING || r2 && r2.socket.readyState === r2.socket.CLOSED) && (e.connecting ? t |= 4 : t |= 16), t;
    }, ioctl(e, t, r2) {
      switch (t) {
        case 21531:
          var a = 0;
          return e.recv_queue.length && (a = e.recv_queue[0].data.length), HEAP32[r2 >> 2] = a, 0;
        default:
          return 28;
      }
    }, close(e) {
      if (e.server) {
        try {
          e.server.close();
        } catch {
        }
        e.server = null;
      }
      for (var t = Object.keys(e.peers), r2 = 0;r2 < t.length; r2++) {
        var a = e.peers[t[r2]];
        try {
          a.socket.close();
        } catch {
        }
        SOCKFS.websocket_sock_ops.removePeer(e, a);
      }
      return 0;
    }, bind(e, t, r2) {
      if (typeof e.saddr < "u" || typeof e.sport < "u")
        throw new FS.ErrnoError(28);
      if (e.saddr = t, e.sport = r2, e.type === 2) {
        e.server && (e.server.close(), e.server = null);
        try {
          e.sock_ops.listen(e, 0);
        } catch (a) {
          if (a.name !== "ErrnoError" || a.errno !== 138)
            throw a;
        }
      }
    }, connect(e, t, r2) {
      if (e.server)
        throw new FS.ErrnoError(138);
      if (typeof e.daddr < "u" && typeof e.dport < "u") {
        var a = SOCKFS.websocket_sock_ops.getPeer(e, e.daddr, e.dport);
        if (a)
          throw a.socket.readyState === a.socket.CONNECTING ? new FS.ErrnoError(7) : new FS.ErrnoError(30);
      }
      var o3 = SOCKFS.websocket_sock_ops.createPeer(e, t, r2);
      e.daddr = o3.addr, e.dport = o3.port, e.connecting = true;
    }, listen(e, t) {
      if (!ENVIRONMENT_IS_NODE)
        throw new FS.ErrnoError(138);
      if (e.server)
        throw new FS.ErrnoError(28);
      var r2 = require("ws").Server, a = e.saddr;
      e.server = new r2({ host: a, port: e.sport }), SOCKFS.emit("listen", e.stream.fd), e.server.on("connection", function(o3) {
        if (e.type === 1) {
          var s2 = SOCKFS.createSocket(e.family, e.type, e.protocol), l3 = SOCKFS.websocket_sock_ops.createPeer(s2, o3);
          s2.daddr = l3.addr, s2.dport = l3.port, e.pending.push(s2), SOCKFS.emit("connection", s2.stream.fd);
        } else
          SOCKFS.websocket_sock_ops.createPeer(e, o3), SOCKFS.emit("connection", e.stream.fd);
      }), e.server.on("close", function() {
        SOCKFS.emit("close", e.stream.fd), e.server = null;
      }), e.server.on("error", function(o3) {
        e.error = 23, SOCKFS.emit("error", [e.stream.fd, e.error, "EHOSTUNREACH: Host is unreachable"]);
      });
    }, accept(e) {
      if (!e.server || !e.pending.length)
        throw new FS.ErrnoError(28);
      var t = e.pending.shift();
      return t.stream.flags = e.stream.flags, t;
    }, getname(e, t) {
      var r2, a;
      if (t) {
        if (e.daddr === undefined || e.dport === undefined)
          throw new FS.ErrnoError(53);
        r2 = e.daddr, a = e.dport;
      } else
        r2 = e.saddr || 0, a = e.sport || 0;
      return { addr: r2, port: a };
    }, sendmsg(e, t, r2, a, o3, s2) {
      if (e.type === 2) {
        if ((o3 === undefined || s2 === undefined) && (o3 = e.daddr, s2 = e.dport), o3 === undefined || s2 === undefined)
          throw new FS.ErrnoError(17);
      } else
        o3 = e.daddr, s2 = e.dport;
      var l3 = SOCKFS.websocket_sock_ops.getPeer(e, o3, s2);
      if (e.type === 1 && (!l3 || l3.socket.readyState === l3.socket.CLOSING || l3.socket.readyState === l3.socket.CLOSED))
        throw new FS.ErrnoError(53);
      ArrayBuffer.isView(t) && (r2 += t.byteOffset, t = t.buffer);
      var _2 = t.slice(r2, r2 + a);
      if (!l3 || l3.socket.readyState !== l3.socket.OPEN)
        return e.type === 2 && (!l3 || l3.socket.readyState === l3.socket.CLOSING || l3.socket.readyState === l3.socket.CLOSED) && (l3 = SOCKFS.websocket_sock_ops.createPeer(e, o3, s2)), l3.msg_send_queue.push(_2), a;
      try {
        return l3.socket.send(_2), a;
      } catch {
        throw new FS.ErrnoError(28);
      }
    }, recvmsg(e, t) {
      if (e.type === 1 && e.server)
        throw new FS.ErrnoError(53);
      var r2 = e.recv_queue.shift();
      if (!r2) {
        if (e.type === 1) {
          var a = SOCKFS.websocket_sock_ops.getPeer(e, e.daddr, e.dport);
          if (!a)
            throw new FS.ErrnoError(53);
          if (a.socket.readyState === a.socket.CLOSING || a.socket.readyState === a.socket.CLOSED)
            return null;
          throw new FS.ErrnoError(6);
        }
        throw new FS.ErrnoError(6);
      }
      var o3 = r2.data.byteLength || r2.data.length, s2 = r2.data.byteOffset || 0, l3 = r2.data.buffer || r2.data, _2 = Math.min(t, o3), n = { buffer: new Uint8Array(l3, s2, _2), addr: r2.addr, port: r2.port };
      if (e.type === 1 && _2 < o3) {
        var m2 = o3 - _2;
        r2.data = new Uint8Array(l3, s2 + _2, m2), e.recv_queue.unshift(r2);
      }
      return n;
    } } }, getSocketFromFD = (e) => {
      var t = SOCKFS.getSocket(e);
      if (!t)
        throw new FS.ErrnoError(8);
      return t;
    }, inetNtop4 = (e) => (e & 255) + "." + (e >> 8 & 255) + "." + (e >> 16 & 255) + "." + (e >> 24 & 255), inetNtop6 = (e) => {
      var t = "", r2 = 0, a = 0, o3 = 0, s2 = 0, l3 = 0, _2 = 0, n = [e[0] & 65535, e[0] >> 16, e[1] & 65535, e[1] >> 16, e[2] & 65535, e[2] >> 16, e[3] & 65535, e[3] >> 16], m2 = true, p = "";
      for (_2 = 0;_2 < 5; _2++)
        if (n[_2] !== 0) {
          m2 = false;
          break;
        }
      if (m2) {
        if (p = inetNtop4(n[6] | n[7] << 16), n[5] === -1)
          return t = "::ffff:", t += p, t;
        if (n[5] === 0)
          return t = "::", p === "0.0.0.0" && (p = ""), p === "0.0.0.1" && (p = "1"), t += p, t;
      }
      for (r2 = 0;r2 < 8; r2++)
        n[r2] === 0 && (r2 - o3 > 1 && (l3 = 0), o3 = r2, l3++), l3 > a && (a = l3, s2 = r2 - a + 1);
      for (r2 = 0;r2 < 8; r2++) {
        if (a > 1 && n[r2] === 0 && r2 >= s2 && r2 < s2 + a) {
          r2 === s2 && (t += ":", s2 === 0 && (t += ":"));
          continue;
        }
        t += Number(_ntohs(n[r2] & 65535)).toString(16), t += r2 < 7 ? ":" : "";
      }
      return t;
    }, readSockaddr = (e, t) => {
      var r2 = HEAP16[e >> 1], a = _ntohs(HEAPU16[e + 2 >> 1]), o3;
      switch (r2) {
        case 2:
          if (t !== 16)
            return { errno: 28 };
          o3 = HEAP32[e + 4 >> 2], o3 = inetNtop4(o3);
          break;
        case 10:
          if (t !== 28)
            return { errno: 28 };
          o3 = [HEAP32[e + 8 >> 2], HEAP32[e + 12 >> 2], HEAP32[e + 16 >> 2], HEAP32[e + 20 >> 2]], o3 = inetNtop6(o3);
          break;
        default:
          return { errno: 5 };
      }
      return { family: r2, addr: o3, port: a };
    }, inetPton4 = (e) => {
      for (var t = e.split("."), r2 = 0;r2 < 4; r2++) {
        var a = Number(t[r2]);
        if (isNaN(a))
          return null;
        t[r2] = a;
      }
      return (t[0] | t[1] << 8 | t[2] << 16 | t[3] << 24) >>> 0;
    }, jstoi_q = (e) => parseInt(e), inetPton6 = (e) => {
      var t, r2, a, o3, s2 = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i, l3 = [];
      if (!s2.test(e))
        return null;
      if (e === "::")
        return [0, 0, 0, 0, 0, 0, 0, 0];
      for (e.startsWith("::") ? e = e.replace("::", "Z:") : e = e.replace("::", ":Z:"), e.indexOf(".") > 0 ? (e = e.replace(new RegExp("[.]", "g"), ":"), t = e.split(":"), t[t.length - 4] = jstoi_q(t[t.length - 4]) + jstoi_q(t[t.length - 3]) * 256, t[t.length - 3] = jstoi_q(t[t.length - 2]) + jstoi_q(t[t.length - 1]) * 256, t = t.slice(0, t.length - 2)) : t = e.split(":"), a = 0, o3 = 0, r2 = 0;r2 < t.length; r2++)
        if (typeof t[r2] == "string")
          if (t[r2] === "Z") {
            for (o3 = 0;o3 < 8 - t.length + 1; o3++)
              l3[r2 + o3] = 0;
            a = o3 - 1;
          } else
            l3[r2 + a] = _htons(parseInt(t[r2], 16));
        else
          l3[r2 + a] = t[r2];
      return [l3[1] << 16 | l3[0], l3[3] << 16 | l3[2], l3[5] << 16 | l3[4], l3[7] << 16 | l3[6]];
    }, DNS = { address_map: { id: 1, addrs: {}, names: {} }, lookup_name(e) {
      var t = inetPton4(e);
      if (t !== null || (t = inetPton6(e), t !== null))
        return e;
      var r2;
      if (DNS.address_map.addrs[e])
        r2 = DNS.address_map.addrs[e];
      else {
        var a = DNS.address_map.id++;
        assert(a < 65535, "exceeded max address mappings of 65535"), r2 = "172.29." + (a & 255) + "." + (a & 65280), DNS.address_map.names[r2] = e, DNS.address_map.addrs[e] = r2;
      }
      return r2;
    }, lookup_addr(e) {
      return DNS.address_map.names[e] ? DNS.address_map.names[e] : null;
    } }, getSocketAddress = (e, t) => {
      var r2 = readSockaddr(e, t);
      if (r2.errno)
        throw new FS.ErrnoError(r2.errno);
      return r2.addr = DNS.lookup_addr(r2.addr) || r2.addr, r2;
    };
    function ___syscall_bind(e, t, r2, a, o3, s2) {
      try {
        var l3 = getSocketFromFD(e), _2 = getSocketAddress(t, r2);
        return l3.sock_ops.bind(l3, _2.addr, _2.port), 0;
      } catch (n) {
        if (typeof FS > "u" || n.name !== "ErrnoError")
          throw n;
        return -n.errno;
      }
    }
    ___syscall_bind.sig = "iippiii";
    function ___syscall_chdir(e) {
      try {
        return e = SYSCALLS.getStr(e), FS.chdir(e), 0;
      } catch (t) {
        if (typeof FS > "u" || t.name !== "ErrnoError")
          throw t;
        return -t.errno;
      }
    }
    ___syscall_chdir.sig = "ip";
    function ___syscall_chmod(e, t) {
      try {
        return e = SYSCALLS.getStr(e), FS.chmod(e, t), 0;
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return -r2.errno;
      }
    }
    ___syscall_chmod.sig = "ipi";
    function ___syscall_connect(e, t, r2, a, o3, s2) {
      try {
        var l3 = getSocketFromFD(e), _2 = getSocketAddress(t, r2);
        return l3.sock_ops.connect(l3, _2.addr, _2.port), 0;
      } catch (n) {
        if (typeof FS > "u" || n.name !== "ErrnoError")
          throw n;
        return -n.errno;
      }
    }
    ___syscall_connect.sig = "iippiii";
    function ___syscall_dup(e) {
      try {
        var t = SYSCALLS.getStreamFromFD(e);
        return FS.dupStream(t).fd;
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return -r2.errno;
      }
    }
    ___syscall_dup.sig = "ii";
    function ___syscall_dup3(e, t, r2) {
      try {
        var a = SYSCALLS.getStreamFromFD(e);
        if (a.fd === t)
          return -28;
        if (t < 0 || t >= FS.MAX_OPEN_FDS)
          return -8;
        var o3 = FS.getStream(t);
        return o3 && FS.close(o3), FS.dupStream(a, t).fd;
      } catch (s2) {
        if (typeof FS > "u" || s2.name !== "ErrnoError")
          throw s2;
        return -s2.errno;
      }
    }
    ___syscall_dup3.sig = "iiii";
    function ___syscall_faccessat(e, t, r2, a) {
      try {
        if (t = SYSCALLS.getStr(t), t = SYSCALLS.calculateAt(e, t), r2 & -8)
          return -28;
        var o3 = FS.lookupPath(t, { follow: true }), s2 = o3.node;
        if (!s2)
          return -44;
        var l3 = "";
        return r2 & 4 && (l3 += "r"), r2 & 2 && (l3 += "w"), r2 & 1 && (l3 += "x"), l3 && FS.nodePermissions(s2, l3) ? -2 : 0;
      } catch (_2) {
        if (typeof FS > "u" || _2.name !== "ErrnoError")
          throw _2;
        return -_2.errno;
      }
    }
    ___syscall_faccessat.sig = "iipii";
    var ___syscall_fadvise64 = (e, t, r2, a) => 0;
    ___syscall_fadvise64.sig = "iijji";
    var INT53_MAX = 9007199254740992, INT53_MIN = -9007199254740992, bigintToI53Checked = (e) => e < INT53_MIN || e > INT53_MAX ? NaN : Number(e);
    function ___syscall_fallocate(e, t, r2, a) {
      r2 = bigintToI53Checked(r2), a = bigintToI53Checked(a);
      try {
        if (isNaN(r2))
          return 61;
        var o3 = SYSCALLS.getStreamFromFD(e);
        return FS.allocate(o3, r2, a), 0;
      } catch (s2) {
        if (typeof FS > "u" || s2.name !== "ErrnoError")
          throw s2;
        return -s2.errno;
      }
    }
    ___syscall_fallocate.sig = "iiijj";
    var syscallGetVarargI = () => {
      var e = HEAP32[+SYSCALLS.varargs >> 2];
      return SYSCALLS.varargs += 4, e;
    }, syscallGetVarargP = syscallGetVarargI;
    function ___syscall_fcntl64(e, t, r2) {
      SYSCALLS.varargs = r2;
      try {
        var a = SYSCALLS.getStreamFromFD(e);
        switch (t) {
          case 0: {
            var o3 = syscallGetVarargI();
            if (o3 < 0)
              return -28;
            for (;FS.streams[o3]; )
              o3++;
            var s2;
            return s2 = FS.dupStream(a, o3), s2.fd;
          }
          case 1:
          case 2:
            return 0;
          case 3:
            return a.flags;
          case 4: {
            var o3 = syscallGetVarargI();
            return a.flags |= o3, 0;
          }
          case 12: {
            var o3 = syscallGetVarargP(), l3 = 0;
            return HEAP16[o3 + l3 >> 1] = 2, 0;
          }
          case 13:
          case 14:
            return 0;
        }
        return -28;
      } catch (_2) {
        if (typeof FS > "u" || _2.name !== "ErrnoError")
          throw _2;
        return -_2.errno;
      }
    }
    ___syscall_fcntl64.sig = "iiip";
    function ___syscall_fdatasync(e) {
      try {
        var t = SYSCALLS.getStreamFromFD(e);
        return 0;
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return -r2.errno;
      }
    }
    ___syscall_fdatasync.sig = "ii";
    function ___syscall_fstat64(e, t) {
      try {
        var r2 = SYSCALLS.getStreamFromFD(e);
        return SYSCALLS.doStat(FS.stat, r2.path, t);
      } catch (a) {
        if (typeof FS > "u" || a.name !== "ErrnoError")
          throw a;
        return -a.errno;
      }
    }
    ___syscall_fstat64.sig = "iip";
    function ___syscall_ftruncate64(e, t) {
      t = bigintToI53Checked(t);
      try {
        return isNaN(t) ? 61 : (FS.ftruncate(e, t), 0);
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return -r2.errno;
      }
    }
    ___syscall_ftruncate64.sig = "iij";
    var stringToUTF8 = (e, t, r2) => stringToUTF8Array(e, HEAPU8, t, r2);
    function ___syscall_getcwd(e, t) {
      try {
        if (t === 0)
          return -28;
        var r2 = FS.cwd(), a = lengthBytesUTF8(r2) + 1;
        return t < a ? -68 : (stringToUTF8(r2, e, t), a);
      } catch (o3) {
        if (typeof FS > "u" || o3.name !== "ErrnoError")
          throw o3;
        return -o3.errno;
      }
    }
    ___syscall_getcwd.sig = "ipp";
    function ___syscall_getdents64(e, t, r2) {
      try {
        var a = SYSCALLS.getStreamFromFD(e);
        a.getdents || (a.getdents = FS.readdir(a.path));
        for (var o3 = 280, s2 = 0, l3 = FS.llseek(a, 0, 1), _2 = Math.floor(l3 / o3), n = Math.min(a.getdents.length, _2 + Math.floor(r2 / o3)), m2 = _2;m2 < n; m2++) {
          var p, d2, g3 = a.getdents[m2];
          if (g3 === ".")
            p = a.node.id, d2 = 4;
          else if (g3 === "..") {
            var u3 = FS.lookupPath(a.path, { parent: true });
            p = u3.node.id, d2 = 4;
          } else {
            var f;
            try {
              f = FS.lookupNode(a.node, g3);
            } catch (c) {
              if (c?.errno === 28)
                continue;
              throw c;
            }
            p = f.id, d2 = FS.isChrdev(f.mode) ? 2 : FS.isDir(f.mode) ? 4 : FS.isLink(f.mode) ? 10 : 8;
          }
          HEAP64[t + s2 >> 3] = BigInt(p), HEAP64[t + s2 + 8 >> 3] = BigInt((m2 + 1) * o3), HEAP16[t + s2 + 16 >> 1] = 280, HEAP8[t + s2 + 18] = d2, stringToUTF8(g3, t + s2 + 19, 256), s2 += o3;
        }
        return FS.llseek(a, m2 * o3, 0), s2;
      } catch (c) {
        if (typeof FS > "u" || c.name !== "ErrnoError")
          throw c;
        return -c.errno;
      }
    }
    ___syscall_getdents64.sig = "iipp";
    var writeSockaddr = (e, t, r2, a, o3) => {
      switch (t) {
        case 2:
          r2 = inetPton4(r2), zeroMemory(e, 16), o3 && (HEAP32[o3 >> 2] = 16), HEAP16[e >> 1] = t, HEAP32[e + 4 >> 2] = r2, HEAP16[e + 2 >> 1] = _htons(a);
          break;
        case 10:
          r2 = inetPton6(r2), zeroMemory(e, 28), o3 && (HEAP32[o3 >> 2] = 28), HEAP32[e >> 2] = t, HEAP32[e + 8 >> 2] = r2[0], HEAP32[e + 12 >> 2] = r2[1], HEAP32[e + 16 >> 2] = r2[2], HEAP32[e + 20 >> 2] = r2[3], HEAP16[e + 2 >> 1] = _htons(a);
          break;
        default:
          return 5;
      }
      return 0;
    };
    function ___syscall_getsockname(e, t, r2, a, o3, s2) {
      try {
        var l3 = getSocketFromFD(e), _2 = writeSockaddr(t, l3.family, DNS.lookup_name(l3.saddr || "0.0.0.0"), l3.sport, r2);
        return 0;
      } catch (n) {
        if (typeof FS > "u" || n.name !== "ErrnoError")
          throw n;
        return -n.errno;
      }
    }
    ___syscall_getsockname.sig = "iippiii";
    function ___syscall_getsockopt(e, t, r2, a, o3, s2) {
      try {
        var l3 = getSocketFromFD(e);
        return t === 1 && r2 === 4 ? (HEAP32[a >> 2] = l3.error, HEAP32[o3 >> 2] = 4, l3.error = null, 0) : -50;
      } catch (_2) {
        if (typeof FS > "u" || _2.name !== "ErrnoError")
          throw _2;
        return -_2.errno;
      }
    }
    ___syscall_getsockopt.sig = "iiiippi";
    function ___syscall_ioctl(e, t, r2) {
      SYSCALLS.varargs = r2;
      try {
        var a = SYSCALLS.getStreamFromFD(e);
        switch (t) {
          case 21509:
            return a.tty ? 0 : -59;
          case 21505: {
            if (!a.tty)
              return -59;
            if (a.tty.ops.ioctl_tcgets) {
              var o3 = a.tty.ops.ioctl_tcgets(a), s2 = syscallGetVarargP();
              HEAP32[s2 >> 2] = o3.c_iflag || 0, HEAP32[s2 + 4 >> 2] = o3.c_oflag || 0, HEAP32[s2 + 8 >> 2] = o3.c_cflag || 0, HEAP32[s2 + 12 >> 2] = o3.c_lflag || 0;
              for (var l3 = 0;l3 < 32; l3++)
                HEAP8[s2 + l3 + 17] = o3.c_cc[l3] || 0;
              return 0;
            }
            return 0;
          }
          case 21510:
          case 21511:
          case 21512:
            return a.tty ? 0 : -59;
          case 21506:
          case 21507:
          case 21508: {
            if (!a.tty)
              return -59;
            if (a.tty.ops.ioctl_tcsets) {
              for (var s2 = syscallGetVarargP(), _2 = HEAP32[s2 >> 2], n = HEAP32[s2 + 4 >> 2], m2 = HEAP32[s2 + 8 >> 2], p = HEAP32[s2 + 12 >> 2], d2 = [], l3 = 0;l3 < 32; l3++)
                d2.push(HEAP8[s2 + l3 + 17]);
              return a.tty.ops.ioctl_tcsets(a.tty, t, { c_iflag: _2, c_oflag: n, c_cflag: m2, c_lflag: p, c_cc: d2 });
            }
            return 0;
          }
          case 21519: {
            if (!a.tty)
              return -59;
            var s2 = syscallGetVarargP();
            return HEAP32[s2 >> 2] = 0, 0;
          }
          case 21520:
            return a.tty ? -28 : -59;
          case 21531: {
            var s2 = syscallGetVarargP();
            return FS.ioctl(a, t, s2);
          }
          case 21523: {
            if (!a.tty)
              return -59;
            if (a.tty.ops && a.tty.ops.ioctl_tiocgwinsz) {
              var g3 = a.tty.ops.ioctl_tiocgwinsz(a.tty), s2 = syscallGetVarargP();
              HEAP16[s2 >> 1] = g3[0], HEAP16[s2 + 2 >> 1] = g3[1];
            }
            return 0;
          }
          case 21524:
            return a.tty ? 0 : -59;
          case 21515:
            return a.tty ? 0 : -59;
          default:
            return -28;
        }
      } catch (u3) {
        if (typeof FS > "u" || u3.name !== "ErrnoError")
          throw u3;
        return -u3.errno;
      }
    }
    ___syscall_ioctl.sig = "iiip";
    function ___syscall_lstat64(e, t) {
      try {
        return e = SYSCALLS.getStr(e), SYSCALLS.doStat(FS.lstat, e, t);
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return -r2.errno;
      }
    }
    ___syscall_lstat64.sig = "ipp";
    function ___syscall_mkdirat(e, t, r2) {
      try {
        return t = SYSCALLS.getStr(t), t = SYSCALLS.calculateAt(e, t), FS.mkdir(t, r2, 0), 0;
      } catch (a) {
        if (typeof FS > "u" || a.name !== "ErrnoError")
          throw a;
        return -a.errno;
      }
    }
    ___syscall_mkdirat.sig = "iipi";
    function ___syscall_newfstatat(e, t, r2, a) {
      try {
        t = SYSCALLS.getStr(t);
        var o3 = a & 256, s2 = a & 4096;
        return a = a & -6401, t = SYSCALLS.calculateAt(e, t, s2), SYSCALLS.doStat(o3 ? FS.lstat : FS.stat, t, r2);
      } catch (l3) {
        if (typeof FS > "u" || l3.name !== "ErrnoError")
          throw l3;
        return -l3.errno;
      }
    }
    ___syscall_newfstatat.sig = "iippi";
    function ___syscall_openat(e, t, r2, a) {
      SYSCALLS.varargs = a;
      try {
        t = SYSCALLS.getStr(t), t = SYSCALLS.calculateAt(e, t);
        var o3 = a ? syscallGetVarargI() : 0;
        return FS.open(t, r2, o3).fd;
      } catch (s2) {
        if (typeof FS > "u" || s2.name !== "ErrnoError")
          throw s2;
        return -s2.errno;
      }
    }
    ___syscall_openat.sig = "iipip";
    var PIPEFS = { BUCKET_BUFFER_SIZE: 8192, mount(e) {
      return FS.createNode(null, "/", 16895, 0);
    }, createPipe() {
      var e = { buckets: [], refcnt: 2 };
      e.buckets.push({ buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE), offset: 0, roffset: 0 });
      var t = PIPEFS.nextname(), r2 = PIPEFS.nextname(), a = FS.createNode(PIPEFS.root, t, 4096, 0), o3 = FS.createNode(PIPEFS.root, r2, 4096, 0);
      a.pipe = e, o3.pipe = e;
      var s2 = FS.createStream({ path: t, node: a, flags: 0, seekable: false, stream_ops: PIPEFS.stream_ops });
      a.stream = s2;
      var l3 = FS.createStream({ path: r2, node: o3, flags: 1, seekable: false, stream_ops: PIPEFS.stream_ops });
      return o3.stream = l3, { readable_fd: s2.fd, writable_fd: l3.fd };
    }, stream_ops: { poll(e) {
      var t = e.node.pipe;
      if ((e.flags & 2097155) === 1)
        return 260;
      if (t.buckets.length > 0)
        for (var r2 = 0;r2 < t.buckets.length; r2++) {
          var a = t.buckets[r2];
          if (a.offset - a.roffset > 0)
            return 65;
        }
      return 0;
    }, ioctl(e, t, r2) {
      return 28;
    }, fsync(e) {
      return 28;
    }, read(e, t, r2, a, o3) {
      for (var s2 = e.node.pipe, l3 = 0, _2 = 0;_2 < s2.buckets.length; _2++) {
        var n = s2.buckets[_2];
        l3 += n.offset - n.roffset;
      }
      var m2 = t.subarray(r2, r2 + a);
      if (a <= 0)
        return 0;
      if (l3 == 0)
        throw new FS.ErrnoError(6);
      for (var p = Math.min(l3, a), d2 = p, g3 = 0, _2 = 0;_2 < s2.buckets.length; _2++) {
        var u3 = s2.buckets[_2], f = u3.offset - u3.roffset;
        if (p <= f) {
          var c = u3.buffer.subarray(u3.roffset, u3.offset);
          p < f ? (c = c.subarray(0, p), u3.roffset += p) : g3++, m2.set(c);
          break;
        } else {
          var c = u3.buffer.subarray(u3.roffset, u3.offset);
          m2.set(c), m2 = m2.subarray(c.byteLength), p -= c.byteLength, g3++;
        }
      }
      return g3 && g3 == s2.buckets.length && (g3--, s2.buckets[g3].offset = 0, s2.buckets[g3].roffset = 0), s2.buckets.splice(0, g3), d2;
    }, write(e, t, r2, a, o3) {
      var s2 = e.node.pipe, l3 = t.subarray(r2, r2 + a), _2 = l3.byteLength;
      if (_2 <= 0)
        return 0;
      var n = null;
      s2.buckets.length == 0 ? (n = { buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE), offset: 0, roffset: 0 }, s2.buckets.push(n)) : n = s2.buckets[s2.buckets.length - 1], assert(n.offset <= PIPEFS.BUCKET_BUFFER_SIZE);
      var m2 = PIPEFS.BUCKET_BUFFER_SIZE - n.offset;
      if (m2 >= _2)
        return n.buffer.set(l3, n.offset), n.offset += _2, _2;
      m2 > 0 && (n.buffer.set(l3.subarray(0, m2), n.offset), n.offset += m2, l3 = l3.subarray(m2, l3.byteLength));
      for (var p = l3.byteLength / PIPEFS.BUCKET_BUFFER_SIZE | 0, d2 = l3.byteLength % PIPEFS.BUCKET_BUFFER_SIZE, g3 = 0;g3 < p; g3++) {
        var u3 = { buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE), offset: PIPEFS.BUCKET_BUFFER_SIZE, roffset: 0 };
        s2.buckets.push(u3), u3.buffer.set(l3.subarray(0, PIPEFS.BUCKET_BUFFER_SIZE)), l3 = l3.subarray(PIPEFS.BUCKET_BUFFER_SIZE, l3.byteLength);
      }
      if (d2 > 0) {
        var u3 = { buffer: new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE), offset: l3.byteLength, roffset: 0 };
        s2.buckets.push(u3), u3.buffer.set(l3);
      }
      return _2;
    }, close(e) {
      var t = e.node.pipe;
      t.refcnt--, t.refcnt === 0 && (t.buckets = null);
    } }, nextname() {
      return PIPEFS.nextname.current || (PIPEFS.nextname.current = 0), "pipe[" + PIPEFS.nextname.current++ + "]";
    } };
    function ___syscall_pipe(e) {
      try {
        if (e == 0)
          throw new FS.ErrnoError(21);
        var t = PIPEFS.createPipe();
        return HEAP32[e >> 2] = t.readable_fd, HEAP32[e + 4 >> 2] = t.writable_fd, 0;
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return -r2.errno;
      }
    }
    ___syscall_pipe.sig = "ip";
    function ___syscall_poll(e, t, r2) {
      try {
        for (var a = 0, o3 = 0;o3 < t; o3++) {
          var s2 = e + 8 * o3, l3 = HEAP32[s2 >> 2], _2 = HEAP16[s2 + 4 >> 1], n = 32, m2 = FS.getStream(l3);
          m2 && (n = SYSCALLS.DEFAULT_POLLMASK, m2.stream_ops.poll && (n = m2.stream_ops.poll(m2, -1))), n &= _2 | 8 | 16, n && a++, HEAP16[s2 + 6 >> 1] = n;
        }
        return a;
      } catch (p) {
        if (typeof FS > "u" || p.name !== "ErrnoError")
          throw p;
        return -p.errno;
      }
    }
    ___syscall_poll.sig = "ipii";
    function ___syscall_readlinkat(e, t, r2, a) {
      try {
        if (t = SYSCALLS.getStr(t), t = SYSCALLS.calculateAt(e, t), a <= 0)
          return -28;
        var o3 = FS.readlink(t), s2 = Math.min(a, lengthBytesUTF8(o3)), l3 = HEAP8[r2 + s2];
        return stringToUTF8(o3, r2, a + 1), HEAP8[r2 + s2] = l3, s2;
      } catch (_2) {
        if (typeof FS > "u" || _2.name !== "ErrnoError")
          throw _2;
        return -_2.errno;
      }
    }
    ___syscall_readlinkat.sig = "iippp";
    function ___syscall_recvfrom(e, t, r2, a, o3, s2) {
      try {
        var l3 = getSocketFromFD(e), _2 = l3.sock_ops.recvmsg(l3, r2);
        if (!_2)
          return 0;
        if (o3)
          var n = writeSockaddr(o3, l3.family, DNS.lookup_name(_2.addr), _2.port, s2);
        return HEAPU8.set(_2.buffer, t), _2.buffer.byteLength;
      } catch (m2) {
        if (typeof FS > "u" || m2.name !== "ErrnoError")
          throw m2;
        return -m2.errno;
      }
    }
    ___syscall_recvfrom.sig = "iippipp";
    function ___syscall_renameat(e, t, r2, a) {
      try {
        return t = SYSCALLS.getStr(t), a = SYSCALLS.getStr(a), t = SYSCALLS.calculateAt(e, t), a = SYSCALLS.calculateAt(r2, a), FS.rename(t, a), 0;
      } catch (o3) {
        if (typeof FS > "u" || o3.name !== "ErrnoError")
          throw o3;
        return -o3.errno;
      }
    }
    ___syscall_renameat.sig = "iipip";
    function ___syscall_rmdir(e) {
      try {
        return e = SYSCALLS.getStr(e), FS.rmdir(e), 0;
      } catch (t) {
        if (typeof FS > "u" || t.name !== "ErrnoError")
          throw t;
        return -t.errno;
      }
    }
    ___syscall_rmdir.sig = "ip";
    function ___syscall_sendto(e, t, r2, a, o3, s2) {
      try {
        var l3 = getSocketFromFD(e);
        if (!o3)
          return FS.write(l3.stream, HEAP8, t, r2);
        var _2 = getSocketAddress(o3, s2);
        return l3.sock_ops.sendmsg(l3, HEAP8, t, r2, _2.addr, _2.port);
      } catch (n) {
        if (typeof FS > "u" || n.name !== "ErrnoError")
          throw n;
        return -n.errno;
      }
    }
    ___syscall_sendto.sig = "iippipp";
    function ___syscall_socket(e, t, r2) {
      try {
        var a = SOCKFS.createSocket(e, t, r2);
        return a.stream.fd;
      } catch (o3) {
        if (typeof FS > "u" || o3.name !== "ErrnoError")
          throw o3;
        return -o3.errno;
      }
    }
    ___syscall_socket.sig = "iiiiiii";
    function ___syscall_stat64(e, t) {
      try {
        return e = SYSCALLS.getStr(e), SYSCALLS.doStat(FS.stat, e, t);
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return -r2.errno;
      }
    }
    ___syscall_stat64.sig = "ipp";
    function ___syscall_symlinkat(e, t, r2) {
      try {
        return e = SYSCALLS.getStr(e), r2 = SYSCALLS.getStr(r2), r2 = SYSCALLS.calculateAt(t, r2), FS.symlink(e, r2), 0;
      } catch (a) {
        if (typeof FS > "u" || a.name !== "ErrnoError")
          throw a;
        return -a.errno;
      }
    }
    ___syscall_symlinkat.sig = "ipip";
    function ___syscall_truncate64(e, t) {
      t = bigintToI53Checked(t);
      try {
        return isNaN(t) ? 61 : (e = SYSCALLS.getStr(e), FS.truncate(e, t), 0);
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return -r2.errno;
      }
    }
    ___syscall_truncate64.sig = "ipj";
    function ___syscall_unlinkat(e, t, r2) {
      try {
        return t = SYSCALLS.getStr(t), t = SYSCALLS.calculateAt(e, t), r2 === 0 ? FS.unlink(t) : r2 === 512 ? FS.rmdir(t) : abort("Invalid flags passed to unlinkat"), 0;
      } catch (a) {
        if (typeof FS > "u" || a.name !== "ErrnoError")
          throw a;
        return -a.errno;
      }
    }
    ___syscall_unlinkat.sig = "iipi";
    var ___table_base = new WebAssembly.Global({ value: "i32", mutable: false }, 1), __abort_js = () => abort("");
    __abort_js.sig = "v";
    var ENV = {}, stackAlloc = (e) => __emscripten_stack_alloc(e), stringToUTF8OnStack = (e) => {
      var t = lengthBytesUTF8(e) + 1, r2 = stackAlloc(t);
      return stringToUTF8(e, r2, t), r2;
    }, dlSetError = (e) => {
      var t = stackSave(), r2 = stringToUTF8OnStack(e);
      ___dl_seterr(r2, 0), stackRestore(t);
    }, dlopenInternal = (e, t) => {
      var r2 = UTF8ToString(e + 36), a = HEAP32[e + 4 >> 2];
      r2 = PATH.normalize(r2);
      var o3 = !!(a & 256), s2 = o3 ? null : {}, l3 = { global: o3, nodelete: !!(a & 4096), loadAsync: t.loadAsync };
      if (t.loadAsync)
        return loadDynamicLibrary(r2, l3, s2, e);
      try {
        return loadDynamicLibrary(r2, l3, s2, e);
      } catch (_2) {
        return dlSetError(`Could not load dynamic lib: ${r2}
${_2}`), 0;
      }
    }, __dlopen_js = (e) => dlopenInternal(e, { loadAsync: false });
    __dlopen_js.sig = "pp";
    var __dlsym_js = (e, t, r2) => {
      t = UTF8ToString(t);
      var a, o3, s2 = LDSO.loadedLibsByHandle[e];
      if (!s2.exports.hasOwnProperty(t) || s2.exports[t].stub)
        return dlSetError(`Tried to lookup unknown symbol "${t}" in dynamic lib: ${s2.name}`), 0;
      if (o3 = Object.keys(s2.exports).indexOf(t), a = s2.exports[t], typeof a == "function") {
        var l3 = getFunctionAddress(a);
        l3 ? a = l3 : (a = addFunction(a, a.sig), HEAPU32[r2 >> 2] = o3);
      }
      return a;
    };
    __dlsym_js.sig = "pppp";
    var getExecutableName = () => thisProgram || "./this.program", __emscripten_get_progname = (e, t) => stringToUTF8(getExecutableName(), e, t);
    __emscripten_get_progname.sig = "vpi";
    var __emscripten_memcpy_js = (e, t, r2) => HEAPU8.copyWithin(e, t, t + r2);
    __emscripten_memcpy_js.sig = "vppp";
    var runtimeKeepaliveCounter = 0, __emscripten_runtime_keepalive_clear = () => {
      noExitRuntime = false, runtimeKeepaliveCounter = 0;
    };
    __emscripten_runtime_keepalive_clear.sig = "v";
    var __emscripten_system = (e) => {
      if (ENVIRONMENT_IS_NODE) {
        if (!e)
          return 1;
        var t = UTF8ToString(e);
        if (!t.length)
          return 0;
        var r2 = require("child_process"), a = r2.spawnSync(t, [], { shell: true, stdio: "inherit" }), o3 = (l3, _2) => l3 << 8 | _2;
        if (a.status === null) {
          var s2 = (l3) => {
            switch (l3) {
              case "SIGHUP":
                return 1;
              case "SIGQUIT":
                return 3;
              case "SIGFPE":
                return 8;
              case "SIGKILL":
                return 9;
              case "SIGALRM":
                return 14;
              case "SIGTERM":
                return 15;
              default:
                return 2;
            }
          };
          return o3(0, s2(a.signal));
        }
        return o3(a.status, 0);
      }
      return e ? -52 : 0;
    };
    __emscripten_system.sig = "ip";
    var __emscripten_throw_longjmp = () => {
      throw Infinity;
    };
    __emscripten_throw_longjmp.sig = "v";
    function __gmtime_js(e, t) {
      e = bigintToI53Checked(e);
      var r2 = new Date(e * 1000);
      HEAP32[t >> 2] = r2.getUTCSeconds(), HEAP32[t + 4 >> 2] = r2.getUTCMinutes(), HEAP32[t + 8 >> 2] = r2.getUTCHours(), HEAP32[t + 12 >> 2] = r2.getUTCDate(), HEAP32[t + 16 >> 2] = r2.getUTCMonth(), HEAP32[t + 20 >> 2] = r2.getUTCFullYear() - 1900, HEAP32[t + 24 >> 2] = r2.getUTCDay();
      var a = Date.UTC(r2.getUTCFullYear(), 0, 1, 0, 0, 0, 0), o3 = (r2.getTime() - a) / 86400000 | 0;
      HEAP32[t + 28 >> 2] = o3;
    }
    __gmtime_js.sig = "vjp";
    var isLeapYear = (e) => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0), MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], ydayFromDate = (e) => {
      var t = isLeapYear(e.getFullYear()), r2 = t ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE, a = r2[e.getMonth()] + e.getDate() - 1;
      return a;
    };
    function __localtime_js(e, t) {
      e = bigintToI53Checked(e);
      var r2 = new Date(e * 1000);
      HEAP32[t >> 2] = r2.getSeconds(), HEAP32[t + 4 >> 2] = r2.getMinutes(), HEAP32[t + 8 >> 2] = r2.getHours(), HEAP32[t + 12 >> 2] = r2.getDate(), HEAP32[t + 16 >> 2] = r2.getMonth(), HEAP32[t + 20 >> 2] = r2.getFullYear() - 1900, HEAP32[t + 24 >> 2] = r2.getDay();
      var a = ydayFromDate(r2) | 0;
      HEAP32[t + 28 >> 2] = a, HEAP32[t + 36 >> 2] = -(r2.getTimezoneOffset() * 60);
      var o3 = new Date(r2.getFullYear(), 0, 1), s2 = new Date(r2.getFullYear(), 6, 1).getTimezoneOffset(), l3 = o3.getTimezoneOffset(), _2 = (s2 != l3 && r2.getTimezoneOffset() == Math.min(l3, s2)) | 0;
      HEAP32[t + 32 >> 2] = _2;
    }
    __localtime_js.sig = "vjp";
    function __mmap_js(e, t, r2, a, o3, s2, l3) {
      o3 = bigintToI53Checked(o3);
      try {
        if (isNaN(o3))
          return 61;
        var _2 = SYSCALLS.getStreamFromFD(a), n = FS.mmap(_2, e, o3, t, r2), m2 = n.ptr;
        return HEAP32[s2 >> 2] = n.allocated, HEAPU32[l3 >> 2] = m2, 0;
      } catch (p) {
        if (typeof FS > "u" || p.name !== "ErrnoError")
          throw p;
        return -p.errno;
      }
    }
    __mmap_js.sig = "ipiiijpp";
    function __munmap_js(e, t, r2, a, o3, s2) {
      s2 = bigintToI53Checked(s2);
      try {
        var l3 = SYSCALLS.getStreamFromFD(o3);
        r2 & 2 && SYSCALLS.doMsync(e, l3, t, a, s2);
      } catch (_2) {
        if (typeof FS > "u" || _2.name !== "ErrnoError")
          throw _2;
        return -_2.errno;
      }
    }
    __munmap_js.sig = "ippiiij";
    var timers = {}, handleException = (e) => {
      if (e instanceof ExitStatus || e == "unwind")
        return EXITSTATUS;
      quit_(1, e);
    }, keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0, _proc_exit = (e) => {
      EXITSTATUS = e, keepRuntimeAlive() || (Module.onExit?.(e), ABORT = true), quit_(e, new ExitStatus(e));
    };
    _proc_exit.sig = "vi";
    var exitJS = (e, t) => {
      EXITSTATUS = e, _proc_exit(e);
    }, _exit = exitJS;
    _exit.sig = "vi";
    var maybeExit = () => {
      if (!keepRuntimeAlive())
        try {
          _exit(EXITSTATUS);
        } catch (e) {
          handleException(e);
        }
    }, callUserCallback = (e) => {
      if (!ABORT)
        try {
          e(), maybeExit();
        } catch (t) {
          handleException(t);
        }
    }, _emscripten_get_now = () => performance.now();
    _emscripten_get_now.sig = "d";
    var __setitimer_js = (e, t) => {
      if (timers[e] && (clearTimeout(timers[e].id), delete timers[e]), !t)
        return 0;
      var r2 = setTimeout(() => {
        delete timers[e], callUserCallback(() => __emscripten_timeout(e, _emscripten_get_now()));
      }, t);
      return timers[e] = { id: r2, timeout_ms: t }, 0;
    };
    __setitimer_js.sig = "iid";
    var __tzset_js = (e, t, r2, a) => {
      var o3 = new Date().getFullYear(), s2 = new Date(o3, 0, 1), l3 = new Date(o3, 6, 1), _2 = s2.getTimezoneOffset(), n = l3.getTimezoneOffset(), m2 = Math.max(_2, n);
      HEAPU32[e >> 2] = m2 * 60, HEAP32[t >> 2] = +(_2 != n);
      var p = (u3) => {
        var f = u3 >= 0 ? "-" : "+", c = Math.abs(u3), w2 = String(Math.floor(c / 60)).padStart(2, "0"), h3 = String(c % 60).padStart(2, "0");
        return `UTC${f}${w2}${h3}`;
      }, d2 = p(_2), g3 = p(n);
      n < _2 ? (stringToUTF8(d2, r2, 17), stringToUTF8(g3, a, 17)) : (stringToUTF8(d2, a, 17), stringToUTF8(g3, r2, 17));
    };
    __tzset_js.sig = "vpppp";
    var _emscripten_date_now = () => Date.now();
    _emscripten_date_now.sig = "d";
    var nowIsMonotonic = 1, checkWasiClock = (e) => e >= 0 && e <= 3;
    function _clock_time_get(e, t, r2) {
      if (t = bigintToI53Checked(t), !checkWasiClock(e))
        return 28;
      var a;
      if (e === 0)
        a = _emscripten_date_now();
      else if (nowIsMonotonic)
        a = _emscripten_get_now();
      else
        return 52;
      var o3 = Math.round(a * 1000 * 1000);
      return HEAP64[r2 >> 3] = BigInt(o3), 0;
    }
    _clock_time_get.sig = "iijp";
    var readEmAsmArgsArray = [], readEmAsmArgs = (e, t) => {
      readEmAsmArgsArray.length = 0;
      for (var r2;r2 = HEAPU8[e++]; ) {
        var a = r2 != 105;
        a &= r2 != 112, t += a && t % 8 ? 4 : 0, readEmAsmArgsArray.push(r2 == 112 ? HEAPU32[t >> 2] : r2 == 106 ? HEAP64[t >> 3] : r2 == 105 ? HEAP32[t >> 2] : HEAPF64[t >> 3]), t += a ? 8 : 4;
      }
      return readEmAsmArgsArray;
    }, runEmAsmFunction = (e, t, r2) => {
      var a = readEmAsmArgs(t, r2);
      return ASM_CONSTS[e](...a);
    }, _emscripten_asm_const_int = (e, t, r2) => runEmAsmFunction(e, t, r2);
    _emscripten_asm_const_int.sig = "ippp";
    var _emscripten_force_exit = (e) => {
      __emscripten_runtime_keepalive_clear(), _exit(e);
    };
    _emscripten_force_exit.sig = "vi";
    var getHeapMax = () => 2147483648, growMemory = (e) => {
      var t = wasmMemory.buffer, r2 = (e - t.byteLength + 65535) / 65536 | 0;
      try {
        return wasmMemory.grow(r2), updateMemoryViews(), 1;
      } catch {
      }
    }, _emscripten_resize_heap = (e) => {
      var t = HEAPU8.length;
      e >>>= 0;
      var r2 = getHeapMax();
      if (e > r2)
        return false;
      for (var a = 1;a <= 4; a *= 2) {
        var o3 = t * (1 + 0.2 / a);
        o3 = Math.min(o3, e + 100663296);
        var s2 = Math.min(r2, alignMemory(Math.max(e, o3), 65536)), l3 = growMemory(s2);
        if (l3)
          return true;
      }
      return false;
    };
    _emscripten_resize_heap.sig = "ip";
    var getEnvStrings = () => {
      if (!getEnvStrings.strings) {
        var e = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", t = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: e, _: getExecutableName() };
        for (var r2 in ENV)
          ENV[r2] === undefined ? delete t[r2] : t[r2] = ENV[r2];
        var a = [];
        for (var r2 in t)
          a.push(`${r2}=${t[r2]}`);
        getEnvStrings.strings = a;
      }
      return getEnvStrings.strings;
    }, stringToAscii = (e, t) => {
      for (var r2 = 0;r2 < e.length; ++r2)
        HEAP8[t++] = e.charCodeAt(r2);
      HEAP8[t] = 0;
    }, _environ_get = (e, t) => {
      var r2 = 0;
      return getEnvStrings().forEach((a, o3) => {
        var s2 = t + r2;
        HEAPU32[e + o3 * 4 >> 2] = s2, stringToAscii(a, s2), r2 += a.length + 1;
      }), 0;
    };
    _environ_get.sig = "ipp";
    var _environ_sizes_get = (e, t) => {
      var r2 = getEnvStrings();
      HEAPU32[e >> 2] = r2.length;
      var a = 0;
      return r2.forEach((o3) => a += o3.length + 1), HEAPU32[t >> 2] = a, 0;
    };
    _environ_sizes_get.sig = "ipp";
    function _fd_close(e) {
      try {
        var t = SYSCALLS.getStreamFromFD(e);
        return FS.close(t), 0;
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return r2.errno;
      }
    }
    _fd_close.sig = "ii";
    function _fd_fdstat_get(e, t) {
      try {
        var r2 = 0, a = 0, o3 = 0, s2 = SYSCALLS.getStreamFromFD(e), l3 = s2.tty ? 2 : FS.isDir(s2.mode) ? 3 : FS.isLink(s2.mode) ? 7 : 4;
        return HEAP8[t] = l3, HEAP16[t + 2 >> 1] = o3, HEAP64[t + 8 >> 3] = BigInt(r2), HEAP64[t + 16 >> 3] = BigInt(a), 0;
      } catch (_2) {
        if (typeof FS > "u" || _2.name !== "ErrnoError")
          throw _2;
        return _2.errno;
      }
    }
    _fd_fdstat_get.sig = "iip";
    var doReadv = (e, t, r2, a) => {
      for (var o3 = 0, s2 = 0;s2 < r2; s2++) {
        var l3 = HEAPU32[t >> 2], _2 = HEAPU32[t + 4 >> 2];
        t += 8;
        var n = FS.read(e, HEAP8, l3, _2, a);
        if (n < 0)
          return -1;
        if (o3 += n, n < _2)
          break;
        typeof a < "u" && (a += n);
      }
      return o3;
    };
    function _fd_pread(e, t, r2, a, o3) {
      a = bigintToI53Checked(a);
      try {
        if (isNaN(a))
          return 61;
        var s2 = SYSCALLS.getStreamFromFD(e), l3 = doReadv(s2, t, r2, a);
        return HEAPU32[o3 >> 2] = l3, 0;
      } catch (_2) {
        if (typeof FS > "u" || _2.name !== "ErrnoError")
          throw _2;
        return _2.errno;
      }
    }
    _fd_pread.sig = "iippjp";
    var doWritev = (e, t, r2, a) => {
      for (var o3 = 0, s2 = 0;s2 < r2; s2++) {
        var l3 = HEAPU32[t >> 2], _2 = HEAPU32[t + 4 >> 2];
        t += 8;
        var n = FS.write(e, HEAP8, l3, _2, a);
        if (n < 0)
          return -1;
        if (o3 += n, n < _2)
          break;
        typeof a < "u" && (a += n);
      }
      return o3;
    };
    function _fd_pwrite(e, t, r2, a, o3) {
      a = bigintToI53Checked(a);
      try {
        if (isNaN(a))
          return 61;
        var s2 = SYSCALLS.getStreamFromFD(e), l3 = doWritev(s2, t, r2, a);
        return HEAPU32[o3 >> 2] = l3, 0;
      } catch (_2) {
        if (typeof FS > "u" || _2.name !== "ErrnoError")
          throw _2;
        return _2.errno;
      }
    }
    _fd_pwrite.sig = "iippjp";
    function _fd_read(e, t, r2, a) {
      try {
        var o3 = SYSCALLS.getStreamFromFD(e), s2 = doReadv(o3, t, r2);
        return HEAPU32[a >> 2] = s2, 0;
      } catch (l3) {
        if (typeof FS > "u" || l3.name !== "ErrnoError")
          throw l3;
        return l3.errno;
      }
    }
    _fd_read.sig = "iippp";
    function _fd_seek(e, t, r2, a) {
      t = bigintToI53Checked(t);
      try {
        if (isNaN(t))
          return 61;
        var o3 = SYSCALLS.getStreamFromFD(e);
        return FS.llseek(o3, t, r2), HEAP64[a >> 3] = BigInt(o3.position), o3.getdents && t === 0 && r2 === 0 && (o3.getdents = null), 0;
      } catch (s2) {
        if (typeof FS > "u" || s2.name !== "ErrnoError")
          throw s2;
        return s2.errno;
      }
    }
    _fd_seek.sig = "iijip";
    function _fd_sync(e) {
      try {
        var t = SYSCALLS.getStreamFromFD(e);
        return t.stream_ops?.fsync ? t.stream_ops.fsync(t) : 0;
      } catch (r2) {
        if (typeof FS > "u" || r2.name !== "ErrnoError")
          throw r2;
        return r2.errno;
      }
    }
    _fd_sync.sig = "ii";
    function _fd_write(e, t, r2, a) {
      try {
        var o3 = SYSCALLS.getStreamFromFD(e), s2 = doWritev(o3, t, r2);
        return HEAPU32[a >> 2] = s2, 0;
      } catch (l3) {
        if (typeof FS > "u" || l3.name !== "ErrnoError")
          throw l3;
        return l3.errno;
      }
    }
    _fd_write.sig = "iippp";
    var _getaddrinfo = (e, t, r2, a) => {
      var o3 = 0, s2 = 0, l3 = 0, _2 = 0, n = 0, m2 = 0, p;
      function d2(g3, u3, f, c, w2, h3) {
        var v2, x3, y2, M2;
        return x3 = g3 === 10 ? 28 : 16, w2 = g3 === 10 ? inetNtop6(w2) : inetNtop4(w2), v2 = _malloc(x3), M2 = writeSockaddr(v2, g3, w2, h3), assert(!M2), y2 = _malloc(32), HEAP32[y2 + 4 >> 2] = g3, HEAP32[y2 + 8 >> 2] = u3, HEAP32[y2 + 12 >> 2] = f, HEAPU32[y2 + 24 >> 2] = c, HEAPU32[y2 + 20 >> 2] = v2, g3 === 10 ? HEAP32[y2 + 16 >> 2] = 28 : HEAP32[y2 + 16 >> 2] = 16, HEAP32[y2 + 28 >> 2] = 0, y2;
      }
      if (r2 && (l3 = HEAP32[r2 >> 2], _2 = HEAP32[r2 + 4 >> 2], n = HEAP32[r2 + 8 >> 2], m2 = HEAP32[r2 + 12 >> 2]), n && !m2 && (m2 = n === 2 ? 17 : 6), !n && m2 && (n = m2 === 17 ? 2 : 1), m2 === 0 && (m2 = 6), n === 0 && (n = 1), !e && !t)
        return -2;
      if (l3 & -1088 || r2 !== 0 && HEAP32[r2 >> 2] & 2 && !e)
        return -1;
      if (l3 & 32)
        return -2;
      if (n !== 0 && n !== 1 && n !== 2)
        return -7;
      if (_2 !== 0 && _2 !== 2 && _2 !== 10)
        return -6;
      if (t && (t = UTF8ToString(t), s2 = parseInt(t, 10), isNaN(s2)))
        return l3 & 1024 ? -2 : -8;
      if (!e)
        return _2 === 0 && (_2 = 2), l3 & 1 || (_2 === 2 ? o3 = _htonl(2130706433) : o3 = [0, 0, 0, _htonl(1)]), p = d2(_2, n, m2, null, o3, s2), HEAPU32[a >> 2] = p, 0;
      if (e = UTF8ToString(e), o3 = inetPton4(e), o3 !== null)
        if (_2 === 0 || _2 === 2)
          _2 = 2;
        else if (_2 === 10 && l3 & 8)
          o3 = [0, 0, _htonl(65535), o3], _2 = 10;
        else
          return -2;
      else if (o3 = inetPton6(e), o3 !== null)
        if (_2 === 0 || _2 === 10)
          _2 = 10;
        else
          return -2;
      return o3 != null ? (p = d2(_2, n, m2, e, o3, s2), HEAPU32[a >> 2] = p, 0) : l3 & 4 ? -2 : (e = DNS.lookup_name(e), o3 = inetPton4(e), _2 === 0 ? _2 = 2 : _2 === 10 && (o3 = [0, 0, _htonl(65535), o3]), p = d2(_2, n, m2, null, o3, s2), HEAPU32[a >> 2] = p, 0);
    };
    _getaddrinfo.sig = "ipppp";
    var _getnameinfo = (e, t, r2, a, o3, s2, l3) => {
      var _2 = readSockaddr(e, t);
      if (_2.errno)
        return -6;
      var { port: n, addr: m2 } = _2, p = false;
      if (r2 && a) {
        var d2;
        if (l3 & 1 || !(d2 = DNS.lookup_addr(m2))) {
          if (l3 & 8)
            return -2;
        } else
          m2 = d2;
        var g3 = stringToUTF8(m2, r2, a);
        g3 + 1 >= a && (p = true);
      }
      if (o3 && s2) {
        n = "" + n;
        var g3 = stringToUTF8(n, o3, s2);
        g3 + 1 >= s2 && (p = true);
      }
      return p ? -12 : 0;
    };
    _getnameinfo.sig = "ipipipii";
    var stringToNewUTF8 = (e) => {
      var t = lengthBytesUTF8(e) + 1, r2 = _malloc(t);
      return r2 && stringToUTF8(e, r2, t), r2;
    }, FS_createPath = FS.createPath, FS_unlink = (e) => FS.unlink(e), FS_createLazyFile = FS.createLazyFile, FS_createDevice = FS.createDevice, getTempRet0 = (e) => __emscripten_tempret_get();
    Module.getTempRet0 = getTempRet0;
    var setTempRet0 = (e) => __emscripten_tempret_set(e), _setTempRet0 = setTempRet0;
    Module._setTempRet0 = _setTempRet0;
    var _getTempRet0 = getTempRet0;
    Module._getTempRet0 = _getTempRet0;

    class ExceptionInfo {
      constructor(t) {
        this.excPtr = t, this.ptr = t - 24;
      }
      set_type(t) {
        HEAPU32[this.ptr + 4 >> 2] = t;
      }
      get_type() {
        return HEAPU32[this.ptr + 4 >> 2];
      }
      set_destructor(t) {
        HEAPU32[this.ptr + 8 >> 2] = t;
      }
      get_destructor() {
        return HEAPU32[this.ptr + 8 >> 2];
      }
      set_caught(t) {
        t = t ? 1 : 0, HEAP8[this.ptr + 12] = t;
      }
      get_caught() {
        return HEAP8[this.ptr + 12] != 0;
      }
      set_rethrown(t) {
        t = t ? 1 : 0, HEAP8[this.ptr + 13] = t;
      }
      get_rethrown() {
        return HEAP8[this.ptr + 13] != 0;
      }
      init(t, r2) {
        this.set_adjusted_ptr(0), this.set_type(t), this.set_destructor(r2);
      }
      set_adjusted_ptr(t) {
        HEAPU32[this.ptr + 16 >> 2] = t;
      }
      get_adjusted_ptr() {
        return HEAPU32[this.ptr + 16 >> 2];
      }
    }
    var exceptionLast = 0, uncaughtExceptionCount = 0, ___cxa_throw = (e, t, r2) => {
      var a = new ExceptionInfo(e);
      throw a.init(t, r2), exceptionLast = e, uncaughtExceptionCount++, exceptionLast;
    };
    Module.___cxa_throw = ___cxa_throw, ___cxa_throw.sig = "vppp", registerWasmPlugin(), FS.createPreloadedFile = FS_createPreloadedFile, FS.staticInit(), Module.FS_createPath = FS.createPath, Module.FS_createDataFile = FS.createDataFile, Module.FS_createPreloadedFile = FS.createPreloadedFile, Module.FS_unlink = FS.unlink, Module.FS_createLazyFile = FS.createLazyFile, Module.FS_createDevice = FS.createDevice, MEMFS.doesNotExistError = new FS.ErrnoError(44), MEMFS.doesNotExistError.stack = "<generic error, no stack>", ENVIRONMENT_IS_NODE && NODEFS.staticInit();
    var wasmImports = { __assert_fail: ___assert_fail, __call_sighandler: ___call_sighandler, __heap_base: ___heap_base, __indirect_function_table: wasmTable, __memory_base: ___memory_base, __stack_pointer: ___stack_pointer, __syscall__newselect: ___syscall__newselect, __syscall_bind: ___syscall_bind, __syscall_chdir: ___syscall_chdir, __syscall_chmod: ___syscall_chmod, __syscall_connect: ___syscall_connect, __syscall_dup: ___syscall_dup, __syscall_dup3: ___syscall_dup3, __syscall_faccessat: ___syscall_faccessat, __syscall_fadvise64: ___syscall_fadvise64, __syscall_fallocate: ___syscall_fallocate, __syscall_fcntl64: ___syscall_fcntl64, __syscall_fdatasync: ___syscall_fdatasync, __syscall_fstat64: ___syscall_fstat64, __syscall_ftruncate64: ___syscall_ftruncate64, __syscall_getcwd: ___syscall_getcwd, __syscall_getdents64: ___syscall_getdents64, __syscall_getsockname: ___syscall_getsockname, __syscall_getsockopt: ___syscall_getsockopt, __syscall_ioctl: ___syscall_ioctl, __syscall_lstat64: ___syscall_lstat64, __syscall_mkdirat: ___syscall_mkdirat, __syscall_newfstatat: ___syscall_newfstatat, __syscall_openat: ___syscall_openat, __syscall_pipe: ___syscall_pipe, __syscall_poll: ___syscall_poll, __syscall_readlinkat: ___syscall_readlinkat, __syscall_recvfrom: ___syscall_recvfrom, __syscall_renameat: ___syscall_renameat, __syscall_rmdir: ___syscall_rmdir, __syscall_sendto: ___syscall_sendto, __syscall_socket: ___syscall_socket, __syscall_stat64: ___syscall_stat64, __syscall_symlinkat: ___syscall_symlinkat, __syscall_truncate64: ___syscall_truncate64, __syscall_unlinkat: ___syscall_unlinkat, __table_base: ___table_base, _abort_js: __abort_js, _dlopen_js: __dlopen_js, _dlsym_js: __dlsym_js, _emscripten_get_progname: __emscripten_get_progname, _emscripten_memcpy_js: __emscripten_memcpy_js, _emscripten_runtime_keepalive_clear: __emscripten_runtime_keepalive_clear, _emscripten_system: __emscripten_system, _emscripten_throw_longjmp: __emscripten_throw_longjmp, _gmtime_js: __gmtime_js, _localtime_js: __localtime_js, _mmap_js: __mmap_js, _munmap_js: __munmap_js, _setitimer_js: __setitimer_js, _tzset_js: __tzset_js, clock_time_get: _clock_time_get, emscripten_asm_const_int: _emscripten_asm_const_int, emscripten_date_now: _emscripten_date_now, emscripten_force_exit: _emscripten_force_exit, emscripten_get_now: _emscripten_get_now, emscripten_resize_heap: _emscripten_resize_heap, environ_get: _environ_get, environ_sizes_get: _environ_sizes_get, exit: _exit, fd_close: _fd_close, fd_fdstat_get: _fd_fdstat_get, fd_pread: _fd_pread, fd_pwrite: _fd_pwrite, fd_read: _fd_read, fd_seek: _fd_seek, fd_sync: _fd_sync, fd_write: _fd_write, getaddrinfo: _getaddrinfo, getnameinfo: _getnameinfo, invoke_di, invoke_i, invoke_id, invoke_ii, invoke_iii, invoke_iiii, invoke_iiiii, invoke_iiiiii, invoke_iiiiiii, invoke_iiiiiiii, invoke_iiiiiiiii, invoke_iiiiiiiiii, invoke_iiiiiiiiiii, invoke_iiiiiiiiiiiiii, invoke_iiiiiiiiiiiiiiiiii, invoke_iiiiiji, invoke_iiiij, invoke_iiiijii, invoke_iiij, invoke_iiji, invoke_ij, invoke_ijiiiii, invoke_ijiiiiii, invoke_j, invoke_ji, invoke_jii, invoke_jiiii, invoke_jiiiiii, invoke_jiiiiiiiii, invoke_v, invoke_vi, invoke_vid, invoke_vii, invoke_viii, invoke_viiii, invoke_viiiii, invoke_viiiiii, invoke_viiiiiii, invoke_viiiiiiii, invoke_viiiiiiiii, invoke_viiiiiiiiiiii, invoke_viiiji, invoke_viij, invoke_viiji, invoke_viijii, invoke_viijiiii, invoke_vij, invoke_viji, invoke_vijiji, invoke_vj, invoke_vji, memory: wasmMemory, proc_exit: _proc_exit }, wasmExports;
    createWasm();
    var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports.__wasm_call_ctors)(), _fiprintf = Module._fiprintf = (e, t, r2) => (_fiprintf = Module._fiprintf = wasmExports.fiprintf)(e, t, r2), _fopen = Module._fopen = (e, t) => (_fopen = Module._fopen = wasmExports.fopen)(e, t), _fflush = Module._fflush = (e) => (_fflush = Module._fflush = wasmExports.fflush)(e), _fclose = Module._fclose = (e) => (_fclose = Module._fclose = wasmExports.fclose)(e), _free = Module._free = (e) => (_free = Module._free = wasmExports.free)(e), ___errno_location = Module.___errno_location = () => (___errno_location = Module.___errno_location = wasmExports.__errno_location)(), _ProcessInterrupts = Module._ProcessInterrupts = () => (_ProcessInterrupts = Module._ProcessInterrupts = wasmExports.ProcessInterrupts)(), _errstart_cold = Module._errstart_cold = (e, t) => (_errstart_cold = Module._errstart_cold = wasmExports.errstart_cold)(e, t), _errcode = Module._errcode = (e) => (_errcode = Module._errcode = wasmExports.errcode)(e), _errmsg = Module._errmsg = (e, t) => (_errmsg = Module._errmsg = wasmExports.errmsg)(e, t), _errfinish = Module._errfinish = (e, t, r2) => (_errfinish = Module._errfinish = wasmExports.errfinish)(e, t, r2), _puts = Module._puts = (e) => (_puts = Module._puts = wasmExports.puts)(e), _errstart = Module._errstart = (e, t) => (_errstart = Module._errstart = wasmExports.errstart)(e, t), _errmsg_internal = Module._errmsg_internal = (e, t) => (_errmsg_internal = Module._errmsg_internal = wasmExports.errmsg_internal)(e, t), _errdetail = Module._errdetail = (e, t) => (_errdetail = Module._errdetail = wasmExports.errdetail)(e, t), _errhint = Module._errhint = (e, t) => (_errhint = Module._errhint = wasmExports.errhint)(e, t), _pg_parse_query = Module._pg_parse_query = (e) => (_pg_parse_query = Module._pg_parse_query = wasmExports.pg_parse_query)(e), _gettimeofday = Module._gettimeofday = (e, t) => (_gettimeofday = Module._gettimeofday = wasmExports.gettimeofday)(e, t), _raw_parser = Module._raw_parser = (e, t) => (_raw_parser = Module._raw_parser = wasmExports.raw_parser)(e, t), _initStringInfo = Module._initStringInfo = (e) => (_initStringInfo = Module._initStringInfo = wasmExports.initStringInfo)(e), _appendStringInfoString = Module._appendStringInfoString = (e, t) => (_appendStringInfoString = Module._appendStringInfoString = wasmExports.appendStringInfoString)(e, t), _appendStringInfo = Module._appendStringInfo = (e, t, r2) => (_appendStringInfo = Module._appendStringInfo = wasmExports.appendStringInfo)(e, t, r2), _errdetail_internal = Module._errdetail_internal = (e, t) => (_errdetail_internal = Module._errdetail_internal = wasmExports.errdetail_internal)(e, t), _pfree = Module._pfree = (e) => (_pfree = Module._pfree = wasmExports.pfree)(e), _list_make1_impl = Module._list_make1_impl = (e, t) => (_list_make1_impl = Module._list_make1_impl = wasmExports.list_make1_impl)(e, t), _QueryRewrite = Module._QueryRewrite = (e) => (_QueryRewrite = Module._QueryRewrite = wasmExports.QueryRewrite)(e), _pg_plan_query = Module._pg_plan_query = (e, t, r2, a) => (_pg_plan_query = Module._pg_plan_query = wasmExports.pg_plan_query)(e, t, r2, a), _palloc0 = Module._palloc0 = (e) => (_palloc0 = Module._palloc0 = wasmExports.palloc0)(e), _lappend = Module._lappend = (e, t) => (_lappend = Module._lappend = wasmExports.lappend)(e, t), _GetCurrentTimestamp = Module._GetCurrentTimestamp = () => (_GetCurrentTimestamp = Module._GetCurrentTimestamp = wasmExports.GetCurrentTimestamp)(), _pg_prng_double = Module._pg_prng_double = (e) => (_pg_prng_double = Module._pg_prng_double = wasmExports.pg_prng_double)(e), _pg_snprintf = Module._pg_snprintf = (e, t, r2, a) => (_pg_snprintf = Module._pg_snprintf = wasmExports.pg_snprintf)(e, t, r2, a), _sigaddset = Module._sigaddset = (e, t) => (_sigaddset = Module._sigaddset = wasmExports.sigaddset)(e, t), _die = Module._die = (e) => (_die = Module._die = wasmExports.die)(e), _check_stack_depth = Module._check_stack_depth = () => (_check_stack_depth = Module._check_stack_depth = wasmExports.check_stack_depth)(), _pre_format_elog_string = Module._pre_format_elog_string = (e, t) => (_pre_format_elog_string = Module._pre_format_elog_string = wasmExports.pre_format_elog_string)(e, t), _format_elog_string = Module._format_elog_string = (e, t) => (_format_elog_string = Module._format_elog_string = wasmExports.format_elog_string)(e, t), _pstrdup = Module._pstrdup = (e) => (_pstrdup = Module._pstrdup = wasmExports.pstrdup)(e), _SplitIdentifierString = Module._SplitIdentifierString = (e, t, r2) => (_SplitIdentifierString = Module._SplitIdentifierString = wasmExports.SplitIdentifierString)(e, t, r2), _list_free = Module._list_free = (e) => (_list_free = Module._list_free = wasmExports.list_free)(e), _pg_strcasecmp = Module._pg_strcasecmp = (e, t) => (_pg_strcasecmp = Module._pg_strcasecmp = wasmExports.pg_strcasecmp)(e, t), _guc_malloc = Module._guc_malloc = (e, t) => (_guc_malloc = Module._guc_malloc = wasmExports.guc_malloc)(e, t), _SetConfigOption = Module._SetConfigOption = (e, t, r2, a) => (_SetConfigOption = Module._SetConfigOption = wasmExports.SetConfigOption)(e, t, r2, a), _pg_sprintf = Module._pg_sprintf = (e, t, r2) => (_pg_sprintf = Module._pg_sprintf = wasmExports.pg_sprintf)(e, t, r2), _strcmp = Module._strcmp = (e, t) => (_strcmp = Module._strcmp = wasmExports.strcmp)(e, t), _strdup = Module._strdup = (e) => (_strdup = Module._strdup = wasmExports.strdup)(e), _atoi = Module._atoi = (e) => (_atoi = Module._atoi = wasmExports.atoi)(e), _strlcpy = Module._strlcpy = (e, t, r2) => (_strlcpy = Module._strlcpy = wasmExports.strlcpy)(e, t, r2), _pgl_shutdown = Module._pgl_shutdown = () => (_pgl_shutdown = Module._pgl_shutdown = wasmExports.pgl_shutdown)(), _pgl_closed = Module._pgl_closed = () => (_pgl_closed = Module._pgl_closed = wasmExports.pgl_closed)(), _resetStringInfo = Module._resetStringInfo = (e) => (_resetStringInfo = Module._resetStringInfo = wasmExports.resetStringInfo)(e), _getc = Module._getc = (e) => (_getc = Module._getc = wasmExports.getc)(e), _appendStringInfoChar = Module._appendStringInfoChar = (e, t) => (_appendStringInfoChar = Module._appendStringInfoChar = wasmExports.appendStringInfoChar)(e, t), _strlen = Module._strlen = (e) => (_strlen = Module._strlen = wasmExports.strlen)(e), _strncmp = Module._strncmp = (e, t, r2) => (_strncmp = Module._strncmp = wasmExports.strncmp)(e, t, r2), _pg_fprintf = Module._pg_fprintf = (e, t, r2) => (_pg_fprintf = Module._pg_fprintf = wasmExports.pg_fprintf)(e, t, r2), _pgstat_report_activity = Module._pgstat_report_activity = (e, t) => (_pgstat_report_activity = Module._pgstat_report_activity = wasmExports.pgstat_report_activity)(e, t), _errhidestmt = Module._errhidestmt = (e) => (_errhidestmt = Module._errhidestmt = wasmExports.errhidestmt)(e), _GetTransactionSnapshot = Module._GetTransactionSnapshot = () => (_GetTransactionSnapshot = Module._GetTransactionSnapshot = wasmExports.GetTransactionSnapshot)(), _PushActiveSnapshot = Module._PushActiveSnapshot = (e) => (_PushActiveSnapshot = Module._PushActiveSnapshot = wasmExports.PushActiveSnapshot)(e), _AllocSetContextCreateInternal = Module._AllocSetContextCreateInternal = (e, t, r2, a, o3) => (_AllocSetContextCreateInternal = Module._AllocSetContextCreateInternal = wasmExports.AllocSetContextCreateInternal)(e, t, r2, a, o3), _PopActiveSnapshot = Module._PopActiveSnapshot = () => (_PopActiveSnapshot = Module._PopActiveSnapshot = wasmExports.PopActiveSnapshot)(), _CreateDestReceiver = Module._CreateDestReceiver = (e) => (_CreateDestReceiver = Module._CreateDestReceiver = wasmExports.CreateDestReceiver)(e), _CommitTransactionCommand = Module._CommitTransactionCommand = () => (_CommitTransactionCommand = Module._CommitTransactionCommand = wasmExports.CommitTransactionCommand)(), _CommandCounterIncrement = Module._CommandCounterIncrement = () => (_CommandCounterIncrement = Module._CommandCounterIncrement = wasmExports.CommandCounterIncrement)(), _MemoryContextDelete = Module._MemoryContextDelete = (e) => (_MemoryContextDelete = Module._MemoryContextDelete = wasmExports.MemoryContextDelete)(e), _StartTransactionCommand = Module._StartTransactionCommand = () => (_StartTransactionCommand = Module._StartTransactionCommand = wasmExports.StartTransactionCommand)(), ___wasm_setjmp_test = Module.___wasm_setjmp_test = (e, t) => (___wasm_setjmp_test = Module.___wasm_setjmp_test = wasmExports.__wasm_setjmp_test)(e, t), _pg_printf = Module._pg_printf = (e, t) => (_pg_printf = Module._pg_printf = wasmExports.pg_printf)(e, t), ___wasm_setjmp = Module.___wasm_setjmp = (e, t, r2) => (___wasm_setjmp = Module.___wasm_setjmp = wasmExports.__wasm_setjmp)(e, t, r2), _FlushErrorState = Module._FlushErrorState = () => (_FlushErrorState = Module._FlushErrorState = wasmExports.FlushErrorState)(), _emscripten_longjmp = Module._emscripten_longjmp = (e, t) => (_emscripten_longjmp = Module._emscripten_longjmp = wasmExports.emscripten_longjmp)(e, t), _enlargeStringInfo = Module._enlargeStringInfo = (e, t) => (_enlargeStringInfo = Module._enlargeStringInfo = wasmExports.enlargeStringInfo)(e, t), _malloc = Module._malloc = (e) => (_malloc = Module._malloc = wasmExports.malloc)(e), _realloc = Module._realloc = (e, t) => (_realloc = Module._realloc = wasmExports.realloc)(e, t), _getenv = Module._getenv = (e) => (_getenv = Module._getenv = wasmExports.getenv)(e), _strspn = Module._strspn = (e, t) => (_strspn = Module._strspn = wasmExports.strspn)(e, t), _strnlen = Module._strnlen = (e, t) => (_strnlen = Module._strnlen = wasmExports.strnlen)(e, t), _setenv = Module._setenv = (e, t, r2) => (_setenv = Module._setenv = wasmExports.setenv)(e, t, r2), _fileno = Module._fileno = (e) => (_fileno = Module._fileno = wasmExports.fileno)(e), _isatty = Module._isatty = (e) => (_isatty = Module._isatty = wasmExports.isatty)(e), _strchr = Module._strchr = (e, t) => (_strchr = Module._strchr = wasmExports.strchr)(e, t), _pg_vsnprintf = Module._pg_vsnprintf = (e, t, r2, a) => (_pg_vsnprintf = Module._pg_vsnprintf = wasmExports.pg_vsnprintf)(e, t, r2, a), _strcpy = Module._strcpy = (e, t) => (_strcpy = Module._strcpy = wasmExports.strcpy)(e, t), _pg_get_encoding_from_locale = Module._pg_get_encoding_from_locale = (e, t) => (_pg_get_encoding_from_locale = Module._pg_get_encoding_from_locale = wasmExports.pg_get_encoding_from_locale)(e, t), _pg_encoding_to_char_private = Module._pg_encoding_to_char_private = (e) => (_pg_encoding_to_char_private = Module._pg_encoding_to_char_private = wasmExports.pg_encoding_to_char_private)(e), _psprintf = Module._psprintf = (e, t) => (_psprintf = Module._psprintf = wasmExports.psprintf)(e, t), _stat = Module._stat = (e, t) => (_stat = Module._stat = wasmExports.stat)(e, t), _pqsignal = Module._pqsignal = (e, t) => (_pqsignal = Module._pqsignal = wasmExports.pqsignal)(e, t), _fwrite = Module._fwrite = (e, t, r2, a) => (_fwrite = Module._fwrite = wasmExports.fwrite)(e, t, r2, a), _strftime = Module._strftime = (e, t, r2, a) => (_strftime = Module._strftime = wasmExports.strftime)(e, t, r2, a), _strstr = Module._strstr = (e, t) => (_strstr = Module._strstr = wasmExports.strstr)(e, t), _fputs = Module._fputs = (e, t) => (_fputs = Module._fputs = wasmExports.fputs)(e, t), _strtol = Module._strtol = (e, t, r2) => (_strtol = Module._strtol = wasmExports.strtol)(e, t, r2), _ferror = Module._ferror = (e) => (_ferror = Module._ferror = wasmExports.ferror)(e), _pg_strip_crlf = Module._pg_strip_crlf = (e) => (_pg_strip_crlf = Module._pg_strip_crlf = wasmExports.pg_strip_crlf)(e), _get_buffer_size = Module._get_buffer_size = (e) => (_get_buffer_size = Module._get_buffer_size = wasmExports.get_buffer_size)(e), _get_buffer_addr = Module._get_buffer_addr = (e) => (_get_buffer_addr = Module._get_buffer_addr = wasmExports.get_buffer_addr)(e), _get_channel = Module._get_channel = () => (_get_channel = Module._get_channel = wasmExports.get_channel)(), _interactive_read = Module._interactive_read = () => (_interactive_read = Module._interactive_read = wasmExports.interactive_read)(), _interactive_write = Module._interactive_write = (e) => (_interactive_write = Module._interactive_write = wasmExports.interactive_write)(e), _use_wire = Module._use_wire = (e) => (_use_wire = Module._use_wire = wasmExports.use_wire)(e), _clear_error = Module._clear_error = () => (_clear_error = Module._clear_error = wasmExports.clear_error)(), _interactive_one = Module._interactive_one = () => (_interactive_one = Module._interactive_one = wasmExports.interactive_one)(), _abort = Module._abort = () => (_abort = Module._abort = wasmExports.abort)(), _pq_recvbuf_fill = Module._pq_recvbuf_fill = (e, t) => (_pq_recvbuf_fill = Module._pq_recvbuf_fill = wasmExports.pq_recvbuf_fill)(e, t), _pq_getmsgint = Module._pq_getmsgint = (e, t) => (_pq_getmsgint = Module._pq_getmsgint = wasmExports.pq_getmsgint)(e, t), _palloc = Module._palloc = (e) => (_palloc = Module._palloc = wasmExports.palloc)(e), _makeParamList = Module._makeParamList = (e) => (_makeParamList = Module._makeParamList = wasmExports.makeParamList)(e), _getTypeInputInfo = Module._getTypeInputInfo = (e, t, r2) => (_getTypeInputInfo = Module._getTypeInputInfo = wasmExports.getTypeInputInfo)(e, t, r2), _pnstrdup = Module._pnstrdup = (e, t) => (_pnstrdup = Module._pnstrdup = wasmExports.pnstrdup)(e, t), _MemoryContextSetParent = Module._MemoryContextSetParent = (e, t) => (_MemoryContextSetParent = Module._MemoryContextSetParent = wasmExports.MemoryContextSetParent)(e, t), _unlink = Module._unlink = (e) => (_unlink = Module._unlink = wasmExports.unlink)(e), _pgl_backend = Module._pgl_backend = () => (_pgl_backend = Module._pgl_backend = wasmExports.pgl_backend)(), _pgl_initdb = Module._pgl_initdb = () => (_pgl_initdb = Module._pgl_initdb = wasmExports.pgl_initdb)(), _dup = Module._dup = (e) => (_dup = Module._dup = wasmExports.dup)(e), _main = Module._main = (e, t) => (_main = Module._main = wasmExports.__main_argc_argv)(e, t), _appendStringInfoStringQuoted = Module._appendStringInfoStringQuoted = (e, t, r2) => (_appendStringInfoStringQuoted = Module._appendStringInfoStringQuoted = wasmExports.appendStringInfoStringQuoted)(e, t, r2), _set_errcontext_domain = Module._set_errcontext_domain = (e) => (_set_errcontext_domain = Module._set_errcontext_domain = wasmExports.set_errcontext_domain)(e), _errcontext_msg = Module._errcontext_msg = (e, t) => (_errcontext_msg = Module._errcontext_msg = wasmExports.errcontext_msg)(e, t), _pg_is_ascii = Module._pg_is_ascii = (e) => (_pg_is_ascii = Module._pg_is_ascii = wasmExports.pg_is_ascii)(e), _memchr = Module._memchr = (e, t, r2) => (_memchr = Module._memchr = wasmExports.memchr)(e, t, r2), _strrchr = Module._strrchr = (e, t) => (_strrchr = Module._strrchr = wasmExports.strrchr)(e, t), _replace_percent_placeholders = Module._replace_percent_placeholders = (e, t, r2, a) => (_replace_percent_placeholders = Module._replace_percent_placeholders = wasmExports.replace_percent_placeholders)(e, t, r2, a), _pg_b64_encode = Module._pg_b64_encode = (e, t, r2, a) => (_pg_b64_encode = Module._pg_b64_encode = wasmExports.pg_b64_encode)(e, t, r2, a), _pg_b64_decode = Module._pg_b64_decode = (e, t, r2, a) => (_pg_b64_decode = Module._pg_b64_decode = wasmExports.pg_b64_decode)(e, t, r2, a), _pg_b64_enc_len = Module._pg_b64_enc_len = (e) => (_pg_b64_enc_len = Module._pg_b64_enc_len = wasmExports.pg_b64_enc_len)(e), _pg_b64_dec_len = Module._pg_b64_dec_len = (e) => (_pg_b64_dec_len = Module._pg_b64_dec_len = wasmExports.pg_b64_dec_len)(e), _MemoryContextAllocZero = Module._MemoryContextAllocZero = (e, t) => (_MemoryContextAllocZero = Module._MemoryContextAllocZero = wasmExports.MemoryContextAllocZero)(e, t), _MemoryContextAllocExtended = Module._MemoryContextAllocExtended = (e, t, r2) => (_MemoryContextAllocExtended = Module._MemoryContextAllocExtended = wasmExports.MemoryContextAllocExtended)(e, t, r2), _hash_bytes = Module._hash_bytes = (e, t) => (_hash_bytes = Module._hash_bytes = wasmExports.hash_bytes)(e, t), _memcmp = Module._memcmp = (e, t, r2) => (_memcmp = Module._memcmp = wasmExports.memcmp)(e, t, r2), _repalloc = Module._repalloc = (e, t) => (_repalloc = Module._repalloc = wasmExports.repalloc)(e, t), _pg_qsort = Module._pg_qsort = (e, t, r2, a) => (_pg_qsort = Module._pg_qsort = wasmExports.pg_qsort)(e, t, r2, a), _strlcat = Module._strlcat = (e, t, r2) => (_strlcat = Module._strlcat = wasmExports.strlcat)(e, t, r2), _OpenTransientFile = Module._OpenTransientFile = (e, t) => (_OpenTransientFile = Module._OpenTransientFile = wasmExports.OpenTransientFile)(e, t), _errcode_for_file_access = Module._errcode_for_file_access = () => (_errcode_for_file_access = Module._errcode_for_file_access = wasmExports.errcode_for_file_access)(), _read = Module._read = (e, t, r2) => (_read = Module._read = wasmExports.read)(e, t, r2), _CloseTransientFile = Module._CloseTransientFile = (e) => (_CloseTransientFile = Module._CloseTransientFile = wasmExports.CloseTransientFile)(e), _time = Module._time = (e) => (_time = Module._time = wasmExports.time)(e), _write = Module._write = (e, t, r2) => (_write = Module._write = wasmExports.write)(e, t, r2), _close = Module._close = (e) => (_close = Module._close = wasmExports.close)(e), ___multi3 = Module.___multi3 = (e, t, r2, a, o3) => (___multi3 = Module.___multi3 = wasmExports.__multi3)(e, t, r2, a, o3), _pg_char_to_encoding_private = Module._pg_char_to_encoding_private = (e) => (_pg_char_to_encoding_private = Module._pg_char_to_encoding_private = wasmExports.pg_char_to_encoding_private)(e), _isalnum = Module._isalnum = (e) => (_isalnum = Module._isalnum = wasmExports.isalnum)(e), _popen = Module._popen = (e, t) => (_popen = Module._popen = wasmExports.popen)(e, t), _pclose = Module._pclose = (e) => (_pclose = Module._pclose = wasmExports.pclose)(e), _wait_result_to_str = Module._wait_result_to_str = (e) => (_wait_result_to_str = Module._wait_result_to_str = wasmExports.wait_result_to_str)(e), _float_to_shortest_decimal_bufn = Module._float_to_shortest_decimal_bufn = (e, t) => (_float_to_shortest_decimal_bufn = Module._float_to_shortest_decimal_bufn = wasmExports.float_to_shortest_decimal_bufn)(e, t), _float_to_shortest_decimal_buf = Module._float_to_shortest_decimal_buf = (e, t) => (_float_to_shortest_decimal_buf = Module._float_to_shortest_decimal_buf = wasmExports.float_to_shortest_decimal_buf)(e, t), _pwrite = Module._pwrite = (e, t, r2, a) => (_pwrite = Module._pwrite = wasmExports.pwrite)(e, t, r2, a), _hash_bytes_extended = Module._hash_bytes_extended = (e, t, r2) => (_hash_bytes_extended = Module._hash_bytes_extended = wasmExports.hash_bytes_extended)(e, t, r2), _pg_getaddrinfo_all = Module._pg_getaddrinfo_all = (e, t, r2, a) => (_pg_getaddrinfo_all = Module._pg_getaddrinfo_all = wasmExports.pg_getaddrinfo_all)(e, t, r2, a), _calloc = Module._calloc = (e, t) => (_calloc = Module._calloc = wasmExports.calloc)(e, t), _pg_freeaddrinfo_all = Module._pg_freeaddrinfo_all = (e, t) => (_pg_freeaddrinfo_all = Module._pg_freeaddrinfo_all = wasmExports.pg_freeaddrinfo_all)(e, t), _pg_getnameinfo_all = Module._pg_getnameinfo_all = (e, t, r2, a, o3, s2, l3) => (_pg_getnameinfo_all = Module._pg_getnameinfo_all = wasmExports.pg_getnameinfo_all)(e, t, r2, a, o3, s2, l3), _IsValidJsonNumber = Module._IsValidJsonNumber = (e, t) => (_IsValidJsonNumber = Module._IsValidJsonNumber = wasmExports.IsValidJsonNumber)(e, t), _appendBinaryStringInfo = Module._appendBinaryStringInfo = (e, t, r2) => (_appendBinaryStringInfo = Module._appendBinaryStringInfo = wasmExports.appendBinaryStringInfo)(e, t, r2), _makeStringInfo = Module._makeStringInfo = () => (_makeStringInfo = Module._makeStringInfo = wasmExports.makeStringInfo)(), _pg_encoding_mblen = Module._pg_encoding_mblen = (e, t) => (_pg_encoding_mblen = Module._pg_encoding_mblen = wasmExports.pg_encoding_mblen)(e, t), _GetDatabaseEncodingName = Module._GetDatabaseEncodingName = () => (_GetDatabaseEncodingName = Module._GetDatabaseEncodingName = wasmExports.GetDatabaseEncodingName)(), _ScanKeywordLookup = Module._ScanKeywordLookup = (e, t) => (_ScanKeywordLookup = Module._ScanKeywordLookup = wasmExports.ScanKeywordLookup)(e, t), _pg_md5_encrypt = Module._pg_md5_encrypt = (e, t, r2, a, o3) => (_pg_md5_encrypt = Module._pg_md5_encrypt = wasmExports.pg_md5_encrypt)(e, t, r2, a, o3), _strtoul = Module._strtoul = (e, t, r2) => (_strtoul = Module._strtoul = wasmExports.strtoul)(e, t, r2), _sscanf = Module._sscanf = (e, t, r2) => (_sscanf = Module._sscanf = wasmExports.sscanf)(e, t, r2), _fgets = Module._fgets = (e, t, r2) => (_fgets = Module._fgets = wasmExports.fgets)(e, t, r2), _pg_prng_seed = Module._pg_prng_seed = (e, t) => (_pg_prng_seed = Module._pg_prng_seed = wasmExports.pg_prng_seed)(e, t), _pg_prng_seed_check = Module._pg_prng_seed_check = (e) => (_pg_prng_seed_check = Module._pg_prng_seed_check = wasmExports.pg_prng_seed_check)(e), _pg_prng_uint64 = Module._pg_prng_uint64 = (e) => (_pg_prng_uint64 = Module._pg_prng_uint64 = wasmExports.pg_prng_uint64)(e), _pg_prng_uint64_range = Module._pg_prng_uint64_range = (e, t, r2) => (_pg_prng_uint64_range = Module._pg_prng_uint64_range = wasmExports.pg_prng_uint64_range)(e, t, r2), _pg_prng_uint32 = Module._pg_prng_uint32 = (e) => (_pg_prng_uint32 = Module._pg_prng_uint32 = wasmExports.pg_prng_uint32)(e), _log = Module._log = (e) => (_log = Module._log = wasmExports.log)(e), _sin = Module._sin = (e) => (_sin = Module._sin = wasmExports.sin)(e), _forkname_to_number = Module._forkname_to_number = (e) => (_forkname_to_number = Module._forkname_to_number = wasmExports.forkname_to_number)(e), _pg_saslprep = Module._pg_saslprep = (e, t) => (_pg_saslprep = Module._pg_saslprep = wasmExports.pg_saslprep)(e, t), _pg_utf_mblen_private = Module._pg_utf_mblen_private = (e) => (_pg_utf_mblen_private = Module._pg_utf_mblen_private = wasmExports.pg_utf_mblen_private)(e), _pg_utf8_islegal = Module._pg_utf8_islegal = (e, t) => (_pg_utf8_islegal = Module._pg_utf8_islegal = wasmExports.pg_utf8_islegal)(e, t), _bsearch = Module._bsearch = (e, t, r2, a, o3) => (_bsearch = Module._bsearch = wasmExports.bsearch)(e, t, r2, a, o3), _scram_SaltedPassword = Module._scram_SaltedPassword = (e, t, r2, a, o3, s2, l3, _2) => (_scram_SaltedPassword = Module._scram_SaltedPassword = wasmExports.scram_SaltedPassword)(e, t, r2, a, o3, s2, l3, _2), _pg_hmac_create = Module._pg_hmac_create = (e) => (_pg_hmac_create = Module._pg_hmac_create = wasmExports.pg_hmac_create)(e), _pg_hmac_error = Module._pg_hmac_error = (e) => (_pg_hmac_error = Module._pg_hmac_error = wasmExports.pg_hmac_error)(e), _pg_hmac_init = Module._pg_hmac_init = (e, t, r2) => (_pg_hmac_init = Module._pg_hmac_init = wasmExports.pg_hmac_init)(e, t, r2), _pg_hmac_update = Module._pg_hmac_update = (e, t, r2) => (_pg_hmac_update = Module._pg_hmac_update = wasmExports.pg_hmac_update)(e, t, r2), _pg_hmac_final = Module._pg_hmac_final = (e, t, r2) => (_pg_hmac_final = Module._pg_hmac_final = wasmExports.pg_hmac_final)(e, t, r2), _pg_hmac_free = Module._pg_hmac_free = (e) => (_pg_hmac_free = Module._pg_hmac_free = wasmExports.pg_hmac_free)(e), _scram_H = Module._scram_H = (e, t, r2, a, o3) => (_scram_H = Module._scram_H = wasmExports.scram_H)(e, t, r2, a, o3), _scram_ClientKey = Module._scram_ClientKey = (e, t, r2, a, o3) => (_scram_ClientKey = Module._scram_ClientKey = wasmExports.scram_ClientKey)(e, t, r2, a, o3), _scram_ServerKey = Module._scram_ServerKey = (e, t, r2, a, o3) => (_scram_ServerKey = Module._scram_ServerKey = wasmExports.scram_ServerKey)(e, t, r2, a, o3), _scram_build_secret = Module._scram_build_secret = (e, t, r2, a, o3, s2, l3) => (_scram_build_secret = Module._scram_build_secret = wasmExports.scram_build_secret)(e, t, r2, a, o3, s2, l3), _palloc_extended = Module._palloc_extended = (e, t) => (_palloc_extended = Module._palloc_extended = wasmExports.palloc_extended)(e, t), _appendStringInfoSpaces = Module._appendStringInfoSpaces = (e, t) => (_appendStringInfoSpaces = Module._appendStringInfoSpaces = wasmExports.appendStringInfoSpaces)(e, t), _geteuid = Module._geteuid = () => (_geteuid = Module._geteuid = wasmExports.geteuid)(), _pg_encoding_set_invalid = Module._pg_encoding_set_invalid = (e, t) => (_pg_encoding_set_invalid = Module._pg_encoding_set_invalid = wasmExports.pg_encoding_set_invalid)(e, t), _pg_encoding_dsplen = Module._pg_encoding_dsplen = (e, t) => (_pg_encoding_dsplen = Module._pg_encoding_dsplen = wasmExports.pg_encoding_dsplen)(e, t), _pg_encoding_verifymbchar = Module._pg_encoding_verifymbchar = (e, t, r2) => (_pg_encoding_verifymbchar = Module._pg_encoding_verifymbchar = wasmExports.pg_encoding_verifymbchar)(e, t, r2), _pg_encoding_verifymbstr = Module._pg_encoding_verifymbstr = (e, t, r2) => (_pg_encoding_verifymbstr = Module._pg_encoding_verifymbstr = wasmExports.pg_encoding_verifymbstr)(e, t, r2), _pg_encoding_max_length = Module._pg_encoding_max_length = (e) => (_pg_encoding_max_length = Module._pg_encoding_max_length = wasmExports.pg_encoding_max_length)(e), _explicit_bzero = Module._explicit_bzero = (e, t) => (_explicit_bzero = Module._explicit_bzero = wasmExports.explicit_bzero)(e, t), _getpeereid = Module._getpeereid = (e, t, r2) => (_getpeereid = Module._getpeereid = wasmExports.getpeereid)(e, t, r2), _getsockopt = Module._getsockopt = (e, t, r2, a, o3) => (_getsockopt = Module._getsockopt = wasmExports.getsockopt)(e, t, r2, a, o3), _pg_inet_net_ntop = Module._pg_inet_net_ntop = (e, t, r2, a, o3) => (_pg_inet_net_ntop = Module._pg_inet_net_ntop = wasmExports.pg_inet_net_ntop)(e, t, r2, a, o3), _fcntl = Module._fcntl = (e, t, r2) => (_fcntl = Module._fcntl = wasmExports.fcntl)(e, t, r2), _getcwd = Module._getcwd = (e, t) => (_getcwd = Module._getcwd = wasmExports.getcwd)(e, t), _pg_get_user_home_dir = Module._pg_get_user_home_dir = (e, t, r2) => (_pg_get_user_home_dir = Module._pg_get_user_home_dir = wasmExports.pg_get_user_home_dir)(e, t, r2), _pg_popcount_optimized = Module._pg_popcount_optimized = (e, t) => (_pg_popcount_optimized = Module._pg_popcount_optimized = wasmExports.pg_popcount_optimized)(e, t), _pg_strong_random = Module._pg_strong_random = (e, t) => (_pg_strong_random = Module._pg_strong_random = wasmExports.pg_strong_random)(e, t), _open = Module._open = (e, t, r2) => (_open = Module._open = wasmExports.open)(e, t, r2), _pg_usleep = Module._pg_usleep = (e) => (_pg_usleep = Module._pg_usleep = wasmExports.pg_usleep)(e), _nanosleep = Module._nanosleep = (e, t) => (_nanosleep = Module._nanosleep = wasmExports.nanosleep)(e, t), _pg_tolower = Module._pg_tolower = (e) => (_pg_tolower = Module._pg_tolower = wasmExports.pg_tolower)(e), _sigemptyset = Module._sigemptyset = (e) => (_sigemptyset = Module._sigemptyset = wasmExports.sigemptyset)(e), _getpid = Module._getpid = () => (_getpid = Module._getpid = wasmExports.getpid)(), _qsort_arg = Module._qsort_arg = (e, t, r2, a, o3) => (_qsort_arg = Module._qsort_arg = wasmExports.qsort_arg)(e, t, r2, a, o3), _snprintf = Module._snprintf = (e, t, r2, a) => (_snprintf = Module._snprintf = wasmExports.snprintf)(e, t, r2, a), _pg_strerror_r = Module._pg_strerror_r = (e, t, r2) => (_pg_strerror_r = Module._pg_strerror_r = wasmExports.pg_strerror_r)(e, t, r2), _RelationGetNumberOfBlocksInFork = Module._RelationGetNumberOfBlocksInFork = (e, t) => (_RelationGetNumberOfBlocksInFork = Module._RelationGetNumberOfBlocksInFork = wasmExports.RelationGetNumberOfBlocksInFork)(e, t), _ExtendBufferedRel = Module._ExtendBufferedRel = (e, t, r2, a) => (_ExtendBufferedRel = Module._ExtendBufferedRel = wasmExports.ExtendBufferedRel)(e, t, r2, a), _MarkBufferDirty = Module._MarkBufferDirty = (e) => (_MarkBufferDirty = Module._MarkBufferDirty = wasmExports.MarkBufferDirty)(e), _XLogBeginInsert = Module._XLogBeginInsert = () => (_XLogBeginInsert = Module._XLogBeginInsert = wasmExports.XLogBeginInsert)(), _XLogRegisterData = Module._XLogRegisterData = (e, t) => (_XLogRegisterData = Module._XLogRegisterData = wasmExports.XLogRegisterData)(e, t), _XLogInsert = Module._XLogInsert = (e, t) => (_XLogInsert = Module._XLogInsert = wasmExports.XLogInsert)(e, t), _UnlockReleaseBuffer = Module._UnlockReleaseBuffer = (e) => (_UnlockReleaseBuffer = Module._UnlockReleaseBuffer = wasmExports.UnlockReleaseBuffer)(e), _brin_build_desc = Module._brin_build_desc = (e) => (_brin_build_desc = Module._brin_build_desc = wasmExports.brin_build_desc)(e), _EnterParallelMode = Module._EnterParallelMode = () => (_EnterParallelMode = Module._EnterParallelMode = wasmExports.EnterParallelMode)(), _CreateParallelContext = Module._CreateParallelContext = (e, t, r2) => (_CreateParallelContext = Module._CreateParallelContext = wasmExports.CreateParallelContext)(e, t, r2), _RegisterSnapshot = Module._RegisterSnapshot = (e) => (_RegisterSnapshot = Module._RegisterSnapshot = wasmExports.RegisterSnapshot)(e), _table_parallelscan_estimate = Module._table_parallelscan_estimate = (e, t) => (_table_parallelscan_estimate = Module._table_parallelscan_estimate = wasmExports.table_parallelscan_estimate)(e, t), _add_size = Module._add_size = (e, t) => (_add_size = Module._add_size = wasmExports.add_size)(e, t), _tuplesort_estimate_shared = Module._tuplesort_estimate_shared = (e) => (_tuplesort_estimate_shared = Module._tuplesort_estimate_shared = wasmExports.tuplesort_estimate_shared)(e), _InitializeParallelDSM = Module._InitializeParallelDSM = (e) => (_InitializeParallelDSM = Module._InitializeParallelDSM = wasmExports.InitializeParallelDSM)(e), _UnregisterSnapshot = Module._UnregisterSnapshot = (e) => (_UnregisterSnapshot = Module._UnregisterSnapshot = wasmExports.UnregisterSnapshot)(e), _DestroyParallelContext = Module._DestroyParallelContext = (e) => (_DestroyParallelContext = Module._DestroyParallelContext = wasmExports.DestroyParallelContext)(e), _ExitParallelMode = Module._ExitParallelMode = () => (_ExitParallelMode = Module._ExitParallelMode = wasmExports.ExitParallelMode)(), _shm_toc_allocate = Module._shm_toc_allocate = (e, t) => (_shm_toc_allocate = Module._shm_toc_allocate = wasmExports.shm_toc_allocate)(e, t), _ConditionVariableInit = Module._ConditionVariableInit = (e) => (_ConditionVariableInit = Module._ConditionVariableInit = wasmExports.ConditionVariableInit)(e), _s_init_lock_sema = Module._s_init_lock_sema = (e, t) => (_s_init_lock_sema = Module._s_init_lock_sema = wasmExports.s_init_lock_sema)(e, t), _table_parallelscan_initialize = Module._table_parallelscan_initialize = (e, t, r2) => (_table_parallelscan_initialize = Module._table_parallelscan_initialize = wasmExports.table_parallelscan_initialize)(e, t, r2), _tuplesort_initialize_shared = Module._tuplesort_initialize_shared = (e, t, r2) => (_tuplesort_initialize_shared = Module._tuplesort_initialize_shared = wasmExports.tuplesort_initialize_shared)(e, t, r2), _shm_toc_insert = Module._shm_toc_insert = (e, t, r2) => (_shm_toc_insert = Module._shm_toc_insert = wasmExports.shm_toc_insert)(e, t, r2), _LaunchParallelWorkers = Module._LaunchParallelWorkers = (e) => (_LaunchParallelWorkers = Module._LaunchParallelWorkers = wasmExports.LaunchParallelWorkers)(e), _WaitForParallelWorkersToAttach = Module._WaitForParallelWorkersToAttach = (e) => (_WaitForParallelWorkersToAttach = Module._WaitForParallelWorkersToAttach = wasmExports.WaitForParallelWorkersToAttach)(e), _tas_sema = Module._tas_sema = (e) => (_tas_sema = Module._tas_sema = wasmExports.tas_sema)(e), _s_lock = Module._s_lock = (e, t, r2, a) => (_s_lock = Module._s_lock = wasmExports.s_lock)(e, t, r2, a), _s_unlock_sema = Module._s_unlock_sema = (e) => (_s_unlock_sema = Module._s_unlock_sema = wasmExports.s_unlock_sema)(e), _ConditionVariableSleep = Module._ConditionVariableSleep = (e, t) => (_ConditionVariableSleep = Module._ConditionVariableSleep = wasmExports.ConditionVariableSleep)(e, t), _ConditionVariableCancelSleep = Module._ConditionVariableCancelSleep = () => (_ConditionVariableCancelSleep = Module._ConditionVariableCancelSleep = wasmExports.ConditionVariableCancelSleep)(), _tuplesort_performsort = Module._tuplesort_performsort = (e) => (_tuplesort_performsort = Module._tuplesort_performsort = wasmExports.tuplesort_performsort)(e), _tuplesort_end = Module._tuplesort_end = (e) => (_tuplesort_end = Module._tuplesort_end = wasmExports.tuplesort_end)(e), _MemoryContextReset = Module._MemoryContextReset = (e) => (_MemoryContextReset = Module._MemoryContextReset = wasmExports.MemoryContextReset)(e), _brin_deform_tuple = Module._brin_deform_tuple = (e, t, r2) => (_brin_deform_tuple = Module._brin_deform_tuple = wasmExports.brin_deform_tuple)(e, t, r2), _log_newpage_buffer = Module._log_newpage_buffer = (e, t) => (_log_newpage_buffer = Module._log_newpage_buffer = wasmExports.log_newpage_buffer)(e, t), _LockBuffer = Module._LockBuffer = (e, t) => (_LockBuffer = Module._LockBuffer = wasmExports.LockBuffer)(e, t), _ReleaseBuffer = Module._ReleaseBuffer = (e) => (_ReleaseBuffer = Module._ReleaseBuffer = wasmExports.ReleaseBuffer)(e), _IndexGetRelation = Module._IndexGetRelation = (e, t) => (_IndexGetRelation = Module._IndexGetRelation = wasmExports.IndexGetRelation)(e, t), _table_open = Module._table_open = (e, t) => (_table_open = Module._table_open = wasmExports.table_open)(e, t), _ReadBufferExtended = Module._ReadBufferExtended = (e, t, r2, a, o3) => (_ReadBufferExtended = Module._ReadBufferExtended = wasmExports.ReadBufferExtended)(e, t, r2, a, o3), _table_close = Module._table_close = (e, t) => (_table_close = Module._table_close = wasmExports.table_close)(e, t), _build_reloptions = Module._build_reloptions = (e, t, r2, a, o3, s2) => (_build_reloptions = Module._build_reloptions = wasmExports.build_reloptions)(e, t, r2, a, o3, s2), _RelationGetIndexScan = Module._RelationGetIndexScan = (e, t, r2) => (_RelationGetIndexScan = Module._RelationGetIndexScan = wasmExports.RelationGetIndexScan)(e, t, r2), _pgstat_assoc_relation = Module._pgstat_assoc_relation = (e) => (_pgstat_assoc_relation = Module._pgstat_assoc_relation = wasmExports.pgstat_assoc_relation)(e), _index_getprocinfo = Module._index_getprocinfo = (e, t, r2) => (_index_getprocinfo = Module._index_getprocinfo = wasmExports.index_getprocinfo)(e, t, r2), _fmgr_info_copy = Module._fmgr_info_copy = (e, t, r2) => (_fmgr_info_copy = Module._fmgr_info_copy = wasmExports.fmgr_info_copy)(e, t, r2), _FunctionCall4Coll = Module._FunctionCall4Coll = (e, t, r2, a, o3, s2) => (_FunctionCall4Coll = Module._FunctionCall4Coll = wasmExports.FunctionCall4Coll)(e, t, r2, a, o3, s2), _FunctionCall1Coll = Module._FunctionCall1Coll = (e, t, r2) => (_FunctionCall1Coll = Module._FunctionCall1Coll = wasmExports.FunctionCall1Coll)(e, t, r2), _brin_free_desc = Module._brin_free_desc = (e) => (_brin_free_desc = Module._brin_free_desc = wasmExports.brin_free_desc)(e), _WaitForParallelWorkersToFinish = Module._WaitForParallelWorkersToFinish = (e) => (_WaitForParallelWorkersToFinish = Module._WaitForParallelWorkersToFinish = wasmExports.WaitForParallelWorkersToFinish)(e), _PageGetFreeSpace = Module._PageGetFreeSpace = (e) => (_PageGetFreeSpace = Module._PageGetFreeSpace = wasmExports.PageGetFreeSpace)(e), _BufferGetBlockNumber = Module._BufferGetBlockNumber = (e) => (_BufferGetBlockNumber = Module._BufferGetBlockNumber = wasmExports.BufferGetBlockNumber)(e), _BuildIndexInfo = Module._BuildIndexInfo = (e) => (_BuildIndexInfo = Module._BuildIndexInfo = wasmExports.BuildIndexInfo)(e), _Int64GetDatum = Module._Int64GetDatum = (e) => (_Int64GetDatum = Module._Int64GetDatum = wasmExports.Int64GetDatum)(e), _DirectFunctionCall2Coll = Module._DirectFunctionCall2Coll = (e, t, r2, a) => (_DirectFunctionCall2Coll = Module._DirectFunctionCall2Coll = wasmExports.DirectFunctionCall2Coll)(e, t, r2, a), _RecoveryInProgress = Module._RecoveryInProgress = () => (_RecoveryInProgress = Module._RecoveryInProgress = wasmExports.RecoveryInProgress)(), _GetUserIdAndSecContext = Module._GetUserIdAndSecContext = (e, t) => (_GetUserIdAndSecContext = Module._GetUserIdAndSecContext = wasmExports.GetUserIdAndSecContext)(e, t), _SetUserIdAndSecContext = Module._SetUserIdAndSecContext = (e, t) => (_SetUserIdAndSecContext = Module._SetUserIdAndSecContext = wasmExports.SetUserIdAndSecContext)(e, t), _NewGUCNestLevel = Module._NewGUCNestLevel = () => (_NewGUCNestLevel = Module._NewGUCNestLevel = wasmExports.NewGUCNestLevel)(), _RestrictSearchPath = Module._RestrictSearchPath = () => (_RestrictSearchPath = Module._RestrictSearchPath = wasmExports.RestrictSearchPath)(), _index_open = Module._index_open = (e, t) => (_index_open = Module._index_open = wasmExports.index_open)(e, t), _object_ownercheck = Module._object_ownercheck = (e, t, r2) => (_object_ownercheck = Module._object_ownercheck = wasmExports.object_ownercheck)(e, t, r2), _aclcheck_error = Module._aclcheck_error = (e, t, r2) => (_aclcheck_error = Module._aclcheck_error = wasmExports.aclcheck_error)(e, t, r2), _AtEOXact_GUC = Module._AtEOXact_GUC = (e, t) => (_AtEOXact_GUC = Module._AtEOXact_GUC = wasmExports.AtEOXact_GUC)(e, t), _relation_close = Module._relation_close = (e, t) => (_relation_close = Module._relation_close = wasmExports.relation_close)(e, t), _GetUserId = Module._GetUserId = () => (_GetUserId = Module._GetUserId = wasmExports.GetUserId)(), _ReadBuffer = Module._ReadBuffer = (e, t) => (_ReadBuffer = Module._ReadBuffer = wasmExports.ReadBuffer)(e, t), _shm_toc_lookup = Module._shm_toc_lookup = (e, t, r2) => (_shm_toc_lookup = Module._shm_toc_lookup = wasmExports.shm_toc_lookup)(e, t, r2), _tuplesort_attach_shared = Module._tuplesort_attach_shared = (e, t) => (_tuplesort_attach_shared = Module._tuplesort_attach_shared = wasmExports.tuplesort_attach_shared)(e, t), _index_close = Module._index_close = (e, t) => (_index_close = Module._index_close = wasmExports.index_close)(e, t), _table_beginscan_parallel = Module._table_beginscan_parallel = (e, t) => (_table_beginscan_parallel = Module._table_beginscan_parallel = wasmExports.table_beginscan_parallel)(e, t), _ConditionVariableSignal = Module._ConditionVariableSignal = (e) => (_ConditionVariableSignal = Module._ConditionVariableSignal = wasmExports.ConditionVariableSignal)(e), _datumCopy = Module._datumCopy = (e, t, r2) => (_datumCopy = Module._datumCopy = wasmExports.datumCopy)(e, t, r2), _lookup_type_cache = Module._lookup_type_cache = (e, t) => (_lookup_type_cache = Module._lookup_type_cache = wasmExports.lookup_type_cache)(e, t), _get_fn_opclass_options = Module._get_fn_opclass_options = (e) => (_get_fn_opclass_options = Module._get_fn_opclass_options = wasmExports.get_fn_opclass_options)(e), _pg_detoast_datum = Module._pg_detoast_datum = (e) => (_pg_detoast_datum = Module._pg_detoast_datum = wasmExports.pg_detoast_datum)(e), _index_getprocid = Module._index_getprocid = (e, t, r2) => (_index_getprocid = Module._index_getprocid = wasmExports.index_getprocid)(e, t, r2), _init_local_reloptions = Module._init_local_reloptions = (e, t) => (_init_local_reloptions = Module._init_local_reloptions = wasmExports.init_local_reloptions)(e, t), _FunctionCall2Coll = Module._FunctionCall2Coll = (e, t, r2, a) => (_FunctionCall2Coll = Module._FunctionCall2Coll = wasmExports.FunctionCall2Coll)(e, t, r2, a), _SysCacheGetAttrNotNull = Module._SysCacheGetAttrNotNull = (e, t, r2) => (_SysCacheGetAttrNotNull = Module._SysCacheGetAttrNotNull = wasmExports.SysCacheGetAttrNotNull)(e, t, r2), _ReleaseSysCache = Module._ReleaseSysCache = (e) => (_ReleaseSysCache = Module._ReleaseSysCache = wasmExports.ReleaseSysCache)(e), _fmgr_info_cxt = Module._fmgr_info_cxt = (e, t, r2) => (_fmgr_info_cxt = Module._fmgr_info_cxt = wasmExports.fmgr_info_cxt)(e, t, r2), _Float8GetDatum = Module._Float8GetDatum = (e) => (_Float8GetDatum = Module._Float8GetDatum = wasmExports.Float8GetDatum)(e), _numeric_sub = Module._numeric_sub = (e) => (_numeric_sub = Module._numeric_sub = wasmExports.numeric_sub)(e), _DirectFunctionCall1Coll = Module._DirectFunctionCall1Coll = (e, t, r2) => (_DirectFunctionCall1Coll = Module._DirectFunctionCall1Coll = wasmExports.DirectFunctionCall1Coll)(e, t, r2), _pg_detoast_datum_packed = Module._pg_detoast_datum_packed = (e) => (_pg_detoast_datum_packed = Module._pg_detoast_datum_packed = wasmExports.pg_detoast_datum_packed)(e), _add_local_int_reloption = Module._add_local_int_reloption = (e, t, r2, a, o3, s2, l3) => (_add_local_int_reloption = Module._add_local_int_reloption = wasmExports.add_local_int_reloption)(e, t, r2, a, o3, s2, l3), _getTypeOutputInfo = Module._getTypeOutputInfo = (e, t, r2) => (_getTypeOutputInfo = Module._getTypeOutputInfo = wasmExports.getTypeOutputInfo)(e, t, r2), _fmgr_info = Module._fmgr_info = (e, t) => (_fmgr_info = Module._fmgr_info = wasmExports.fmgr_info)(e, t), _OutputFunctionCall = Module._OutputFunctionCall = (e, t) => (_OutputFunctionCall = Module._OutputFunctionCall = wasmExports.OutputFunctionCall)(e, t), _cstring_to_text_with_len = Module._cstring_to_text_with_len = (e, t) => (_cstring_to_text_with_len = Module._cstring_to_text_with_len = wasmExports.cstring_to_text_with_len)(e, t), _accumArrayResult = Module._accumArrayResult = (e, t, r2, a, o3) => (_accumArrayResult = Module._accumArrayResult = wasmExports.accumArrayResult)(e, t, r2, a, o3), _makeArrayResult = Module._makeArrayResult = (e, t) => (_makeArrayResult = Module._makeArrayResult = wasmExports.makeArrayResult)(e, t), _OidOutputFunctionCall = Module._OidOutputFunctionCall = (e, t) => (_OidOutputFunctionCall = Module._OidOutputFunctionCall = wasmExports.OidOutputFunctionCall)(e, t), _cstring_to_text = Module._cstring_to_text = (e) => (_cstring_to_text = Module._cstring_to_text = wasmExports.cstring_to_text)(e), _PageGetExactFreeSpace = Module._PageGetExactFreeSpace = (e) => (_PageGetExactFreeSpace = Module._PageGetExactFreeSpace = wasmExports.PageGetExactFreeSpace)(e), _PageIndexTupleOverwrite = Module._PageIndexTupleOverwrite = (e, t, r2, a) => (_PageIndexTupleOverwrite = Module._PageIndexTupleOverwrite = wasmExports.PageIndexTupleOverwrite)(e, t, r2, a), _PageInit = Module._PageInit = (e, t, r2) => (_PageInit = Module._PageInit = wasmExports.PageInit)(e, t, r2), _PageAddItemExtended = Module._PageAddItemExtended = (e, t, r2, a, o3) => (_PageAddItemExtended = Module._PageAddItemExtended = wasmExports.PageAddItemExtended)(e, t, r2, a, o3), _LockRelationForExtension = Module._LockRelationForExtension = (e, t) => (_LockRelationForExtension = Module._LockRelationForExtension = wasmExports.LockRelationForExtension)(e, t), _UnlockRelationForExtension = Module._UnlockRelationForExtension = (e, t) => (_UnlockRelationForExtension = Module._UnlockRelationForExtension = wasmExports.UnlockRelationForExtension)(e, t), _smgropen = Module._smgropen = (e, t) => (_smgropen = Module._smgropen = wasmExports.smgropen)(e, t), _smgrpin = Module._smgrpin = (e) => (_smgrpin = Module._smgrpin = wasmExports.smgrpin)(e), _ItemPointerEquals = Module._ItemPointerEquals = (e, t) => (_ItemPointerEquals = Module._ItemPointerEquals = wasmExports.ItemPointerEquals)(e, t), _detoast_external_attr = Module._detoast_external_attr = (e) => (_detoast_external_attr = Module._detoast_external_attr = wasmExports.detoast_external_attr)(e), _CreateTemplateTupleDesc = Module._CreateTemplateTupleDesc = (e) => (_CreateTemplateTupleDesc = Module._CreateTemplateTupleDesc = wasmExports.CreateTemplateTupleDesc)(e), _TupleDescInitEntry = Module._TupleDescInitEntry = (e, t, r2, a, o3, s2) => (_TupleDescInitEntry = Module._TupleDescInitEntry = wasmExports.TupleDescInitEntry)(e, t, r2, a, o3, s2), _SearchSysCache1 = Module._SearchSysCache1 = (e, t) => (_SearchSysCache1 = Module._SearchSysCache1 = wasmExports.SearchSysCache1)(e, t), _SearchSysCacheList = Module._SearchSysCacheList = (e, t, r2, a, o3) => (_SearchSysCacheList = Module._SearchSysCacheList = wasmExports.SearchSysCacheList)(e, t, r2, a, o3), _check_amproc_signature = Module._check_amproc_signature = (e, t, r2, a, o3, s2) => (_check_amproc_signature = Module._check_amproc_signature = wasmExports.check_amproc_signature)(e, t, r2, a, o3, s2), _check_amoptsproc_signature = Module._check_amoptsproc_signature = (e) => (_check_amoptsproc_signature = Module._check_amoptsproc_signature = wasmExports.check_amoptsproc_signature)(e), _format_procedure = Module._format_procedure = (e) => (_format_procedure = Module._format_procedure = wasmExports.format_procedure)(e), _format_operator = Module._format_operator = (e) => (_format_operator = Module._format_operator = wasmExports.format_operator)(e), _check_amop_signature = Module._check_amop_signature = (e, t, r2, a) => (_check_amop_signature = Module._check_amop_signature = wasmExports.check_amop_signature)(e, t, r2, a), _identify_opfamily_groups = Module._identify_opfamily_groups = (e, t) => (_identify_opfamily_groups = Module._identify_opfamily_groups = wasmExports.identify_opfamily_groups)(e, t), _format_type_be = Module._format_type_be = (e) => (_format_type_be = Module._format_type_be = wasmExports.format_type_be)(e), _ReleaseCatCacheList = Module._ReleaseCatCacheList = (e) => (_ReleaseCatCacheList = Module._ReleaseCatCacheList = wasmExports.ReleaseCatCacheList)(e), _free_attrmap = Module._free_attrmap = (e) => (_free_attrmap = Module._free_attrmap = wasmExports.free_attrmap)(e), _format_type_with_typemod = Module._format_type_with_typemod = (e, t) => (_format_type_with_typemod = Module._format_type_with_typemod = wasmExports.format_type_with_typemod)(e, t), _build_attrmap_by_name_if_req = Module._build_attrmap_by_name_if_req = (e, t, r2) => (_build_attrmap_by_name_if_req = Module._build_attrmap_by_name_if_req = wasmExports.build_attrmap_by_name_if_req)(e, t, r2), _DatumGetEOHP = Module._DatumGetEOHP = (e) => (_DatumGetEOHP = Module._DatumGetEOHP = wasmExports.DatumGetEOHP)(e), _EOH_get_flat_size = Module._EOH_get_flat_size = (e) => (_EOH_get_flat_size = Module._EOH_get_flat_size = wasmExports.EOH_get_flat_size)(e), _EOH_flatten_into = Module._EOH_flatten_into = (e, t, r2) => (_EOH_flatten_into = Module._EOH_flatten_into = wasmExports.EOH_flatten_into)(e, t, r2), _getmissingattr = Module._getmissingattr = (e, t, r2) => (_getmissingattr = Module._getmissingattr = wasmExports.getmissingattr)(e, t, r2), _hash_create = Module._hash_create = (e, t, r2, a) => (_hash_create = Module._hash_create = wasmExports.hash_create)(e, t, r2, a), _hash_search = Module._hash_search = (e, t, r2, a) => (_hash_search = Module._hash_search = wasmExports.hash_search)(e, t, r2, a), _nocachegetattr = Module._nocachegetattr = (e, t, r2) => (_nocachegetattr = Module._nocachegetattr = wasmExports.nocachegetattr)(e, t, r2), _heap_form_tuple = Module._heap_form_tuple = (e, t, r2) => (_heap_form_tuple = Module._heap_form_tuple = wasmExports.heap_form_tuple)(e, t, r2), _heap_modify_tuple = Module._heap_modify_tuple = (e, t, r2, a, o3) => (_heap_modify_tuple = Module._heap_modify_tuple = wasmExports.heap_modify_tuple)(e, t, r2, a, o3), _heap_deform_tuple = Module._heap_deform_tuple = (e, t, r2, a) => (_heap_deform_tuple = Module._heap_deform_tuple = wasmExports.heap_deform_tuple)(e, t, r2, a), _heap_modify_tuple_by_cols = Module._heap_modify_tuple_by_cols = (e, t, r2, a, o3, s2) => (_heap_modify_tuple_by_cols = Module._heap_modify_tuple_by_cols = wasmExports.heap_modify_tuple_by_cols)(e, t, r2, a, o3, s2), _heap_freetuple = Module._heap_freetuple = (e) => (_heap_freetuple = Module._heap_freetuple = wasmExports.heap_freetuple)(e), _index_form_tuple = Module._index_form_tuple = (e, t, r2) => (_index_form_tuple = Module._index_form_tuple = wasmExports.index_form_tuple)(e, t, r2), _nocache_index_getattr = Module._nocache_index_getattr = (e, t, r2) => (_nocache_index_getattr = Module._nocache_index_getattr = wasmExports.nocache_index_getattr)(e, t, r2), _index_deform_tuple = Module._index_deform_tuple = (e, t, r2, a) => (_index_deform_tuple = Module._index_deform_tuple = wasmExports.index_deform_tuple)(e, t, r2, a), _slot_getsomeattrs_int = Module._slot_getsomeattrs_int = (e, t) => (_slot_getsomeattrs_int = Module._slot_getsomeattrs_int = wasmExports.slot_getsomeattrs_int)(e, t), _pg_ltoa = Module._pg_ltoa = (e, t) => (_pg_ltoa = Module._pg_ltoa = wasmExports.pg_ltoa)(e, t), _relation_open = Module._relation_open = (e, t) => (_relation_open = Module._relation_open = wasmExports.relation_open)(e, t), _LockRelationOid = Module._LockRelationOid = (e, t) => (_LockRelationOid = Module._LockRelationOid = wasmExports.LockRelationOid)(e, t), _RelationIdGetRelation = Module._RelationIdGetRelation = (e) => (_RelationIdGetRelation = Module._RelationIdGetRelation = wasmExports.RelationIdGetRelation)(e), _try_relation_open = Module._try_relation_open = (e, t) => (_try_relation_open = Module._try_relation_open = wasmExports.try_relation_open)(e, t), _SearchSysCacheExists = Module._SearchSysCacheExists = (e, t, r2, a, o3) => (_SearchSysCacheExists = Module._SearchSysCacheExists = wasmExports.SearchSysCacheExists)(e, t, r2, a, o3), _relation_openrv = Module._relation_openrv = (e, t) => (_relation_openrv = Module._relation_openrv = wasmExports.relation_openrv)(e, t), _RangeVarGetRelidExtended = Module._RangeVarGetRelidExtended = (e, t, r2, a, o3) => (_RangeVarGetRelidExtended = Module._RangeVarGetRelidExtended = wasmExports.RangeVarGetRelidExtended)(e, t, r2, a, o3), _RelationClose = Module._RelationClose = (e) => (_RelationClose = Module._RelationClose = wasmExports.RelationClose)(e), _add_reloption_kind = Module._add_reloption_kind = () => (_add_reloption_kind = Module._add_reloption_kind = wasmExports.add_reloption_kind)(), _register_reloptions_validator = Module._register_reloptions_validator = (e, t) => (_register_reloptions_validator = Module._register_reloptions_validator = wasmExports.register_reloptions_validator)(e, t), _add_int_reloption = Module._add_int_reloption = (e, t, r2, a, o3, s2, l3) => (_add_int_reloption = Module._add_int_reloption = wasmExports.add_int_reloption)(e, t, r2, a, o3, s2, l3), _MemoryContextStrdup = Module._MemoryContextStrdup = (e, t) => (_MemoryContextStrdup = Module._MemoryContextStrdup = wasmExports.MemoryContextStrdup)(e, t), _transformRelOptions = Module._transformRelOptions = (e, t, r2, a, o3, s2) => (_transformRelOptions = Module._transformRelOptions = wasmExports.transformRelOptions)(e, t, r2, a, o3, s2), _deconstruct_array_builtin = Module._deconstruct_array_builtin = (e, t, r2, a, o3) => (_deconstruct_array_builtin = Module._deconstruct_array_builtin = wasmExports.deconstruct_array_builtin)(e, t, r2, a, o3), _defGetString = Module._defGetString = (e) => (_defGetString = Module._defGetString = wasmExports.defGetString)(e), _defGetBoolean = Module._defGetBoolean = (e) => (_defGetBoolean = Module._defGetBoolean = wasmExports.defGetBoolean)(e), _untransformRelOptions = Module._untransformRelOptions = (e) => (_untransformRelOptions = Module._untransformRelOptions = wasmExports.untransformRelOptions)(e), _text_to_cstring = Module._text_to_cstring = (e) => (_text_to_cstring = Module._text_to_cstring = wasmExports.text_to_cstring)(e), _makeString = Module._makeString = (e) => (_makeString = Module._makeString = wasmExports.makeString)(e), _makeDefElem = Module._makeDefElem = (e, t, r2) => (_makeDefElem = Module._makeDefElem = wasmExports.makeDefElem)(e, t, r2), _heap_reloptions = Module._heap_reloptions = (e, t, r2) => (_heap_reloptions = Module._heap_reloptions = wasmExports.heap_reloptions)(e, t, r2), _MemoryContextAlloc = Module._MemoryContextAlloc = (e, t) => (_MemoryContextAlloc = Module._MemoryContextAlloc = wasmExports.MemoryContextAlloc)(e, t), _parse_bool = Module._parse_bool = (e, t) => (_parse_bool = Module._parse_bool = wasmExports.parse_bool)(e, t), _parse_int = Module._parse_int = (e, t, r2, a) => (_parse_int = Module._parse_int = wasmExports.parse_int)(e, t, r2, a), _parse_real = Module._parse_real = (e, t, r2, a) => (_parse_real = Module._parse_real = wasmExports.parse_real)(e, t, r2, a), _ScanKeyInit = Module._ScanKeyInit = (e, t, r2, a, o3) => (_ScanKeyInit = Module._ScanKeyInit = wasmExports.ScanKeyInit)(e, t, r2, a, o3), _dsm_segment_handle = Module._dsm_segment_handle = (e) => (_dsm_segment_handle = Module._dsm_segment_handle = wasmExports.dsm_segment_handle)(e), _dsm_create = Module._dsm_create = (e, t) => (_dsm_create = Module._dsm_create = wasmExports.dsm_create)(e, t), _dsm_segment_address = Module._dsm_segment_address = (e) => (_dsm_segment_address = Module._dsm_segment_address = wasmExports.dsm_segment_address)(e), _dsm_attach = Module._dsm_attach = (e) => (_dsm_attach = Module._dsm_attach = wasmExports.dsm_attach)(e), _dsm_detach = Module._dsm_detach = (e) => (_dsm_detach = Module._dsm_detach = wasmExports.dsm_detach)(e), _ShmemInitStruct = Module._ShmemInitStruct = (e, t, r2) => (_ShmemInitStruct = Module._ShmemInitStruct = wasmExports.ShmemInitStruct)(e, t, r2), _LWLockAcquire = Module._LWLockAcquire = (e, t) => (_LWLockAcquire = Module._LWLockAcquire = wasmExports.LWLockAcquire)(e, t), _LWLockRelease = Module._LWLockRelease = (e) => (_LWLockRelease = Module._LWLockRelease = wasmExports.LWLockRelease)(e), _LWLockInitialize = Module._LWLockInitialize = (e, t) => (_LWLockInitialize = Module._LWLockInitialize = wasmExports.LWLockInitialize)(e, t), _MemoryContextMemAllocated = Module._MemoryContextMemAllocated = (e, t) => (_MemoryContextMemAllocated = Module._MemoryContextMemAllocated = wasmExports.MemoryContextMemAllocated)(e, t), _GetCurrentCommandId = Module._GetCurrentCommandId = (e) => (_GetCurrentCommandId = Module._GetCurrentCommandId = wasmExports.GetCurrentCommandId)(e), _toast_open_indexes = Module._toast_open_indexes = (e, t, r2, a) => (_toast_open_indexes = Module._toast_open_indexes = wasmExports.toast_open_indexes)(e, t, r2, a), _RelationGetIndexList = Module._RelationGetIndexList = (e) => (_RelationGetIndexList = Module._RelationGetIndexList = wasmExports.RelationGetIndexList)(e), _systable_beginscan = Module._systable_beginscan = (e, t, r2, a, o3, s2) => (_systable_beginscan = Module._systable_beginscan = wasmExports.systable_beginscan)(e, t, r2, a, o3, s2), _systable_getnext = Module._systable_getnext = (e) => (_systable_getnext = Module._systable_getnext = wasmExports.systable_getnext)(e), _systable_endscan = Module._systable_endscan = (e) => (_systable_endscan = Module._systable_endscan = wasmExports.systable_endscan)(e), _toast_close_indexes = Module._toast_close_indexes = (e, t, r2) => (_toast_close_indexes = Module._toast_close_indexes = wasmExports.toast_close_indexes)(e, t, r2), _systable_beginscan_ordered = Module._systable_beginscan_ordered = (e, t, r2, a, o3) => (_systable_beginscan_ordered = Module._systable_beginscan_ordered = wasmExports.systable_beginscan_ordered)(e, t, r2, a, o3), _systable_getnext_ordered = Module._systable_getnext_ordered = (e, t) => (_systable_getnext_ordered = Module._systable_getnext_ordered = wasmExports.systable_getnext_ordered)(e, t), _systable_endscan_ordered = Module._systable_endscan_ordered = (e) => (_systable_endscan_ordered = Module._systable_endscan_ordered = wasmExports.systable_endscan_ordered)(e), _init_toast_snapshot = Module._init_toast_snapshot = (e) => (_init_toast_snapshot = Module._init_toast_snapshot = wasmExports.init_toast_snapshot)(e), _convert_tuples_by_position = Module._convert_tuples_by_position = (e, t, r2) => (_convert_tuples_by_position = Module._convert_tuples_by_position = wasmExports.convert_tuples_by_position)(e, t, r2), _execute_attr_map_tuple = Module._execute_attr_map_tuple = (e, t) => (_execute_attr_map_tuple = Module._execute_attr_map_tuple = wasmExports.execute_attr_map_tuple)(e, t), _execute_attr_map_slot = Module._execute_attr_map_slot = (e, t, r2) => (_execute_attr_map_slot = Module._execute_attr_map_slot = wasmExports.execute_attr_map_slot)(e, t, r2), _ExecStoreVirtualTuple = Module._ExecStoreVirtualTuple = (e) => (_ExecStoreVirtualTuple = Module._ExecStoreVirtualTuple = wasmExports.ExecStoreVirtualTuple)(e), _bms_is_member = Module._bms_is_member = (e, t) => (_bms_is_member = Module._bms_is_member = wasmExports.bms_is_member)(e, t), _bms_add_member = Module._bms_add_member = (e, t) => (_bms_add_member = Module._bms_add_member = wasmExports.bms_add_member)(e, t), _CreateTupleDescCopy = Module._CreateTupleDescCopy = (e) => (_CreateTupleDescCopy = Module._CreateTupleDescCopy = wasmExports.CreateTupleDescCopy)(e), _CreateTupleDescCopyConstr = Module._CreateTupleDescCopyConstr = (e) => (_CreateTupleDescCopyConstr = Module._CreateTupleDescCopyConstr = wasmExports.CreateTupleDescCopyConstr)(e), _FreeTupleDesc = Module._FreeTupleDesc = (e) => (_FreeTupleDesc = Module._FreeTupleDesc = wasmExports.FreeTupleDesc)(e), _ResourceOwnerEnlarge = Module._ResourceOwnerEnlarge = (e) => (_ResourceOwnerEnlarge = Module._ResourceOwnerEnlarge = wasmExports.ResourceOwnerEnlarge)(e), _ResourceOwnerRemember = Module._ResourceOwnerRemember = (e, t, r2) => (_ResourceOwnerRemember = Module._ResourceOwnerRemember = wasmExports.ResourceOwnerRemember)(e, t, r2), _DecrTupleDescRefCount = Module._DecrTupleDescRefCount = (e) => (_DecrTupleDescRefCount = Module._DecrTupleDescRefCount = wasmExports.DecrTupleDescRefCount)(e), _ResourceOwnerForget = Module._ResourceOwnerForget = (e, t, r2) => (_ResourceOwnerForget = Module._ResourceOwnerForget = wasmExports.ResourceOwnerForget)(e, t, r2), _datumIsEqual = Module._datumIsEqual = (e, t, r2, a) => (_datumIsEqual = Module._datumIsEqual = wasmExports.datumIsEqual)(e, t, r2, a), _TupleDescInitEntryCollation = Module._TupleDescInitEntryCollation = (e, t, r2) => (_TupleDescInitEntryCollation = Module._TupleDescInitEntryCollation = wasmExports.TupleDescInitEntryCollation)(e, t, r2), _stringToNode = Module._stringToNode = (e) => (_stringToNode = Module._stringToNode = wasmExports.stringToNode)(e), _pg_detoast_datum_copy = Module._pg_detoast_datum_copy = (e) => (_pg_detoast_datum_copy = Module._pg_detoast_datum_copy = wasmExports.pg_detoast_datum_copy)(e), _get_typlenbyvalalign = Module._get_typlenbyvalalign = (e, t, r2, a) => (_get_typlenbyvalalign = Module._get_typlenbyvalalign = wasmExports.get_typlenbyvalalign)(e, t, r2, a), _deconstruct_array = Module._deconstruct_array = (e, t, r2, a, o3, s2, l3, _2) => (_deconstruct_array = Module._deconstruct_array = wasmExports.deconstruct_array)(e, t, r2, a, o3, s2, l3, _2), _tbm_add_tuples = Module._tbm_add_tuples = (e, t, r2, a) => (_tbm_add_tuples = Module._tbm_add_tuples = wasmExports.tbm_add_tuples)(e, t, r2, a), _ginPostingListDecode = Module._ginPostingListDecode = (e, t) => (_ginPostingListDecode = Module._ginPostingListDecode = wasmExports.ginPostingListDecode)(e, t), _ItemPointerCompare = Module._ItemPointerCompare = (e, t) => (_ItemPointerCompare = Module._ItemPointerCompare = wasmExports.ItemPointerCompare)(e, t), _LockPage = Module._LockPage = (e, t, r2) => (_LockPage = Module._LockPage = wasmExports.LockPage)(e, t, r2), _UnlockPage = Module._UnlockPage = (e, t, r2) => (_UnlockPage = Module._UnlockPage = wasmExports.UnlockPage)(e, t, r2), _vacuum_delay_point = Module._vacuum_delay_point = () => (_vacuum_delay_point = Module._vacuum_delay_point = wasmExports.vacuum_delay_point)(), _RecordFreeIndexPage = Module._RecordFreeIndexPage = (e, t) => (_RecordFreeIndexPage = Module._RecordFreeIndexPage = wasmExports.RecordFreeIndexPage)(e, t), _IndexFreeSpaceMapVacuum = Module._IndexFreeSpaceMapVacuum = (e) => (_IndexFreeSpaceMapVacuum = Module._IndexFreeSpaceMapVacuum = wasmExports.IndexFreeSpaceMapVacuum)(e), _log_newpage_range = Module._log_newpage_range = (e, t, r2, a, o3) => (_log_newpage_range = Module._log_newpage_range = wasmExports.log_newpage_range)(e, t, r2, a, o3), _GetFreeIndexPage = Module._GetFreeIndexPage = (e) => (_GetFreeIndexPage = Module._GetFreeIndexPage = wasmExports.GetFreeIndexPage)(e), _ConditionalLockBuffer = Module._ConditionalLockBuffer = (e) => (_ConditionalLockBuffer = Module._ConditionalLockBuffer = wasmExports.ConditionalLockBuffer)(e), _LockBufferForCleanup = Module._LockBufferForCleanup = (e) => (_LockBufferForCleanup = Module._LockBufferForCleanup = wasmExports.LockBufferForCleanup)(e), _gistcheckpage = Module._gistcheckpage = (e, t) => (_gistcheckpage = Module._gistcheckpage = wasmExports.gistcheckpage)(e, t), _PageIndexMultiDelete = Module._PageIndexMultiDelete = (e, t, r2) => (_PageIndexMultiDelete = Module._PageIndexMultiDelete = wasmExports.PageIndexMultiDelete)(e, t, r2), _pow = Module._pow = (e, t) => (_pow = Module._pow = wasmExports.pow)(e, t), _smgrnblocks = Module._smgrnblocks = (e, t) => (_smgrnblocks = Module._smgrnblocks = wasmExports.smgrnblocks)(e, t), _list_free_deep = Module._list_free_deep = (e) => (_list_free_deep = Module._list_free_deep = wasmExports.list_free_deep)(e), _pairingheap_remove_first = Module._pairingheap_remove_first = (e) => (_pairingheap_remove_first = Module._pairingheap_remove_first = wasmExports.pairingheap_remove_first)(e), _pairingheap_add = Module._pairingheap_add = (e, t) => (_pairingheap_add = Module._pairingheap_add = wasmExports.pairingheap_add)(e, t), _float_overflow_error = Module._float_overflow_error = () => (_float_overflow_error = Module._float_overflow_error = wasmExports.float_overflow_error)(), _float_underflow_error = Module._float_underflow_error = () => (_float_underflow_error = Module._float_underflow_error = wasmExports.float_underflow_error)(), _DirectFunctionCall5Coll = Module._DirectFunctionCall5Coll = (e, t, r2, a, o3, s2, l3) => (_DirectFunctionCall5Coll = Module._DirectFunctionCall5Coll = wasmExports.DirectFunctionCall5Coll)(e, t, r2, a, o3, s2, l3), _pairingheap_allocate = Module._pairingheap_allocate = (e, t) => (_pairingheap_allocate = Module._pairingheap_allocate = wasmExports.pairingheap_allocate)(e, t), _GenerationContextCreate = Module._GenerationContextCreate = (e, t, r2, a, o3) => (_GenerationContextCreate = Module._GenerationContextCreate = wasmExports.GenerationContextCreate)(e, t, r2, a, o3), _pgstat_progress_update_param = Module._pgstat_progress_update_param = (e, t) => (_pgstat_progress_update_param = Module._pgstat_progress_update_param = wasmExports.pgstat_progress_update_param)(e, t), __hash_getbuf = Module.__hash_getbuf = (e, t, r2, a) => (__hash_getbuf = Module.__hash_getbuf = wasmExports._hash_getbuf)(e, t, r2, a), __hash_relbuf = Module.__hash_relbuf = (e, t) => (__hash_relbuf = Module.__hash_relbuf = wasmExports._hash_relbuf)(e, t), __hash_get_indextuple_hashkey = Module.__hash_get_indextuple_hashkey = (e) => (__hash_get_indextuple_hashkey = Module.__hash_get_indextuple_hashkey = wasmExports._hash_get_indextuple_hashkey)(e), __hash_getbuf_with_strategy = Module.__hash_getbuf_with_strategy = (e, t, r2, a, o3) => (__hash_getbuf_with_strategy = Module.__hash_getbuf_with_strategy = wasmExports._hash_getbuf_with_strategy)(e, t, r2, a, o3), __hash_ovflblkno_to_bitno = Module.__hash_ovflblkno_to_bitno = (e, t) => (__hash_ovflblkno_to_bitno = Module.__hash_ovflblkno_to_bitno = wasmExports._hash_ovflblkno_to_bitno)(e, t), _hash_destroy = Module._hash_destroy = (e) => (_hash_destroy = Module._hash_destroy = wasmExports.hash_destroy)(e), _list_member_oid = Module._list_member_oid = (e, t) => (_list_member_oid = Module._list_member_oid = wasmExports.list_member_oid)(e, t), _HeapTupleSatisfiesVisibility = Module._HeapTupleSatisfiesVisibility = (e, t, r2) => (_HeapTupleSatisfiesVisibility = Module._HeapTupleSatisfiesVisibility = wasmExports.HeapTupleSatisfiesVisibility)(e, t, r2), _read_stream_begin_relation = Module._read_stream_begin_relation = (e, t, r2, a, o3, s2, l3) => (_read_stream_begin_relation = Module._read_stream_begin_relation = wasmExports.read_stream_begin_relation)(e, t, r2, a, o3, s2, l3), _GetAccessStrategy = Module._GetAccessStrategy = (e) => (_GetAccessStrategy = Module._GetAccessStrategy = wasmExports.GetAccessStrategy)(e), _FreeAccessStrategy = Module._FreeAccessStrategy = (e) => (_FreeAccessStrategy = Module._FreeAccessStrategy = wasmExports.FreeAccessStrategy)(e), _read_stream_end = Module._read_stream_end = (e) => (_read_stream_end = Module._read_stream_end = wasmExports.read_stream_end)(e), _heap_getnext = Module._heap_getnext = (e, t) => (_heap_getnext = Module._heap_getnext = wasmExports.heap_getnext)(e, t), _HeapTupleSatisfiesVacuum = Module._HeapTupleSatisfiesVacuum = (e, t, r2) => (_HeapTupleSatisfiesVacuum = Module._HeapTupleSatisfiesVacuum = wasmExports.HeapTupleSatisfiesVacuum)(e, t, r2), _GetMultiXactIdMembers = Module._GetMultiXactIdMembers = (e, t, r2, a) => (_GetMultiXactIdMembers = Module._GetMultiXactIdMembers = wasmExports.GetMultiXactIdMembers)(e, t, r2, a), _TransactionIdPrecedes = Module._TransactionIdPrecedes = (e, t) => (_TransactionIdPrecedes = Module._TransactionIdPrecedes = wasmExports.TransactionIdPrecedes)(e, t), _HeapTupleGetUpdateXid = Module._HeapTupleGetUpdateXid = (e) => (_HeapTupleGetUpdateXid = Module._HeapTupleGetUpdateXid = wasmExports.HeapTupleGetUpdateXid)(e), _visibilitymap_clear = Module._visibilitymap_clear = (e, t, r2, a) => (_visibilitymap_clear = Module._visibilitymap_clear = wasmExports.visibilitymap_clear)(e, t, r2, a), _pgstat_count_heap_insert = Module._pgstat_count_heap_insert = (e, t) => (_pgstat_count_heap_insert = Module._pgstat_count_heap_insert = wasmExports.pgstat_count_heap_insert)(e, t), _ExecFetchSlotHeapTuple = Module._ExecFetchSlotHeapTuple = (e, t, r2) => (_ExecFetchSlotHeapTuple = Module._ExecFetchSlotHeapTuple = wasmExports.ExecFetchSlotHeapTuple)(e, t, r2), _PageGetHeapFreeSpace = Module._PageGetHeapFreeSpace = (e) => (_PageGetHeapFreeSpace = Module._PageGetHeapFreeSpace = wasmExports.PageGetHeapFreeSpace)(e), _visibilitymap_pin = Module._visibilitymap_pin = (e, t, r2) => (_visibilitymap_pin = Module._visibilitymap_pin = wasmExports.visibilitymap_pin)(e, t, r2), _HeapTupleSatisfiesUpdate = Module._HeapTupleSatisfiesUpdate = (e, t, r2) => (_HeapTupleSatisfiesUpdate = Module._HeapTupleSatisfiesUpdate = wasmExports.HeapTupleSatisfiesUpdate)(e, t, r2), _TransactionIdIsCurrentTransactionId = Module._TransactionIdIsCurrentTransactionId = (e) => (_TransactionIdIsCurrentTransactionId = Module._TransactionIdIsCurrentTransactionId = wasmExports.TransactionIdIsCurrentTransactionId)(e), _TransactionIdDidCommit = Module._TransactionIdDidCommit = (e) => (_TransactionIdDidCommit = Module._TransactionIdDidCommit = wasmExports.TransactionIdDidCommit)(e), _TransactionIdIsInProgress = Module._TransactionIdIsInProgress = (e) => (_TransactionIdIsInProgress = Module._TransactionIdIsInProgress = wasmExports.TransactionIdIsInProgress)(e), _bms_free = Module._bms_free = (e) => (_bms_free = Module._bms_free = wasmExports.bms_free)(e), _bms_add_members = Module._bms_add_members = (e, t) => (_bms_add_members = Module._bms_add_members = wasmExports.bms_add_members)(e, t), _bms_next_member = Module._bms_next_member = (e, t) => (_bms_next_member = Module._bms_next_member = wasmExports.bms_next_member)(e, t), _bms_overlap = Module._bms_overlap = (e, t) => (_bms_overlap = Module._bms_overlap = wasmExports.bms_overlap)(e, t), _MultiXactIdPrecedes = Module._MultiXactIdPrecedes = (e, t) => (_MultiXactIdPrecedes = Module._MultiXactIdPrecedes = wasmExports.MultiXactIdPrecedes)(e, t), _heap_tuple_needs_eventual_freeze = Module._heap_tuple_needs_eventual_freeze = (e) => (_heap_tuple_needs_eventual_freeze = Module._heap_tuple_needs_eventual_freeze = wasmExports.heap_tuple_needs_eventual_freeze)(e), _PrefetchBuffer = Module._PrefetchBuffer = (e, t, r2, a) => (_PrefetchBuffer = Module._PrefetchBuffer = wasmExports.PrefetchBuffer)(e, t, r2, a), _XLogRecGetBlockTagExtended = Module._XLogRecGetBlockTagExtended = (e, t, r2, a, o3, s2) => (_XLogRecGetBlockTagExtended = Module._XLogRecGetBlockTagExtended = wasmExports.XLogRecGetBlockTagExtended)(e, t, r2, a, o3, s2), _read_stream_next_buffer = Module._read_stream_next_buffer = (e, t) => (_read_stream_next_buffer = Module._read_stream_next_buffer = wasmExports.read_stream_next_buffer)(e, t), _smgrexists = Module._smgrexists = (e, t) => (_smgrexists = Module._smgrexists = wasmExports.smgrexists)(e, t), _table_slot_create = Module._table_slot_create = (e, t) => (_table_slot_create = Module._table_slot_create = wasmExports.table_slot_create)(e, t), _ExecDropSingleTupleTableSlot = Module._ExecDropSingleTupleTableSlot = (e) => (_ExecDropSingleTupleTableSlot = Module._ExecDropSingleTupleTableSlot = wasmExports.ExecDropSingleTupleTableSlot)(e), _CreateExecutorState = Module._CreateExecutorState = () => (_CreateExecutorState = Module._CreateExecutorState = wasmExports.CreateExecutorState)(), _MakePerTupleExprContext = Module._MakePerTupleExprContext = (e) => (_MakePerTupleExprContext = Module._MakePerTupleExprContext = wasmExports.MakePerTupleExprContext)(e), _GetOldestNonRemovableTransactionId = Module._GetOldestNonRemovableTransactionId = (e) => (_GetOldestNonRemovableTransactionId = Module._GetOldestNonRemovableTransactionId = wasmExports.GetOldestNonRemovableTransactionId)(e), _FreeExecutorState = Module._FreeExecutorState = (e) => (_FreeExecutorState = Module._FreeExecutorState = wasmExports.FreeExecutorState)(e), _MakeSingleTupleTableSlot = Module._MakeSingleTupleTableSlot = (e, t) => (_MakeSingleTupleTableSlot = Module._MakeSingleTupleTableSlot = wasmExports.MakeSingleTupleTableSlot)(e, t), _ExecStoreHeapTuple = Module._ExecStoreHeapTuple = (e, t, r2) => (_ExecStoreHeapTuple = Module._ExecStoreHeapTuple = wasmExports.ExecStoreHeapTuple)(e, t, r2), _visibilitymap_get_status = Module._visibilitymap_get_status = (e, t, r2) => (_visibilitymap_get_status = Module._visibilitymap_get_status = wasmExports.visibilitymap_get_status)(e, t, r2), _ExecStoreAllNullTuple = Module._ExecStoreAllNullTuple = (e) => (_ExecStoreAllNullTuple = Module._ExecStoreAllNullTuple = wasmExports.ExecStoreAllNullTuple)(e), _XidInMVCCSnapshot = Module._XidInMVCCSnapshot = (e, t) => (_XidInMVCCSnapshot = Module._XidInMVCCSnapshot = wasmExports.XidInMVCCSnapshot)(e, t), _hash_seq_init = Module._hash_seq_init = (e, t) => (_hash_seq_init = Module._hash_seq_init = wasmExports.hash_seq_init)(e, t), _hash_seq_search = Module._hash_seq_search = (e) => (_hash_seq_search = Module._hash_seq_search = wasmExports.hash_seq_search)(e), _ftruncate = Module._ftruncate = (e, t) => (_ftruncate = Module._ftruncate = wasmExports.ftruncate)(e, t), _fd_fsync_fname = Module._fd_fsync_fname = (e, t) => (_fd_fsync_fname = Module._fd_fsync_fname = wasmExports.fd_fsync_fname)(e, t), _get_namespace_name = Module._get_namespace_name = (e) => (_get_namespace_name = Module._get_namespace_name = wasmExports.get_namespace_name)(e), _GetRecordedFreeSpace = Module._GetRecordedFreeSpace = (e, t) => (_GetRecordedFreeSpace = Module._GetRecordedFreeSpace = wasmExports.GetRecordedFreeSpace)(e, t), _vac_estimate_reltuples = Module._vac_estimate_reltuples = (e, t, r2, a) => (_vac_estimate_reltuples = Module._vac_estimate_reltuples = wasmExports.vac_estimate_reltuples)(e, t, r2, a), _WaitLatch = Module._WaitLatch = (e, t, r2, a) => (_WaitLatch = Module._WaitLatch = wasmExports.WaitLatch)(e, t, r2, a), _ResetLatch = Module._ResetLatch = (e) => (_ResetLatch = Module._ResetLatch = wasmExports.ResetLatch)(e), _clock_gettime = Module._clock_gettime = (e, t) => (_clock_gettime = Module._clock_gettime = wasmExports.clock_gettime)(e, t), _WalUsageAccumDiff = Module._WalUsageAccumDiff = (e, t, r2) => (_WalUsageAccumDiff = Module._WalUsageAccumDiff = wasmExports.WalUsageAccumDiff)(e, t, r2), _BufferUsageAccumDiff = Module._BufferUsageAccumDiff = (e, t, r2) => (_BufferUsageAccumDiff = Module._BufferUsageAccumDiff = wasmExports.BufferUsageAccumDiff)(e, t, r2), _visibilitymap_prepare_truncate = Module._visibilitymap_prepare_truncate = (e, t) => (_visibilitymap_prepare_truncate = Module._visibilitymap_prepare_truncate = wasmExports.visibilitymap_prepare_truncate)(e, t), _pg_class_aclcheck = Module._pg_class_aclcheck = (e, t, r2) => (_pg_class_aclcheck = Module._pg_class_aclcheck = wasmExports.pg_class_aclcheck)(e, t, r2), _btboolcmp = Module._btboolcmp = (e) => (_btboolcmp = Module._btboolcmp = wasmExports.btboolcmp)(e), _btint2cmp = Module._btint2cmp = (e) => (_btint2cmp = Module._btint2cmp = wasmExports.btint2cmp)(e), _btint4cmp = Module._btint4cmp = (e) => (_btint4cmp = Module._btint4cmp = wasmExports.btint4cmp)(e), _btint8cmp = Module._btint8cmp = (e) => (_btint8cmp = Module._btint8cmp = wasmExports.btint8cmp)(e), _btoidcmp = Module._btoidcmp = (e) => (_btoidcmp = Module._btoidcmp = wasmExports.btoidcmp)(e), _btcharcmp = Module._btcharcmp = (e) => (_btcharcmp = Module._btcharcmp = wasmExports.btcharcmp)(e), __bt_form_posting = Module.__bt_form_posting = (e, t, r2) => (__bt_form_posting = Module.__bt_form_posting = wasmExports._bt_form_posting)(e, t, r2), __bt_mkscankey = Module.__bt_mkscankey = (e, t) => (__bt_mkscankey = Module.__bt_mkscankey = wasmExports._bt_mkscankey)(e, t), __bt_checkpage = Module.__bt_checkpage = (e, t) => (__bt_checkpage = Module.__bt_checkpage = wasmExports._bt_checkpage)(e, t), __bt_compare = Module.__bt_compare = (e, t, r2, a) => (__bt_compare = Module.__bt_compare = wasmExports._bt_compare)(e, t, r2, a), __bt_relbuf = Module.__bt_relbuf = (e, t) => (__bt_relbuf = Module.__bt_relbuf = wasmExports._bt_relbuf)(e, t), __bt_search = Module.__bt_search = (e, t, r2, a, o3) => (__bt_search = Module.__bt_search = wasmExports._bt_search)(e, t, r2, a, o3), __bt_binsrch_insert = Module.__bt_binsrch_insert = (e, t) => (__bt_binsrch_insert = Module.__bt_binsrch_insert = wasmExports._bt_binsrch_insert)(e, t), __bt_freestack = Module.__bt_freestack = (e) => (__bt_freestack = Module.__bt_freestack = wasmExports._bt_freestack)(e), __bt_metaversion = Module.__bt_metaversion = (e, t, r2) => (__bt_metaversion = Module.__bt_metaversion = wasmExports._bt_metaversion)(e, t, r2), __bt_allequalimage = Module.__bt_allequalimage = (e, t) => (__bt_allequalimage = Module.__bt_allequalimage = wasmExports._bt_allequalimage)(e, t), _before_shmem_exit = Module._before_shmem_exit = (e, t) => (_before_shmem_exit = Module._before_shmem_exit = wasmExports.before_shmem_exit)(e, t), _cancel_before_shmem_exit = Module._cancel_before_shmem_exit = (e, t) => (_cancel_before_shmem_exit = Module._cancel_before_shmem_exit = wasmExports.cancel_before_shmem_exit)(e, t), _pg_re_throw = Module._pg_re_throw = () => (_pg_re_throw = Module._pg_re_throw = wasmExports.pg_re_throw)(), _get_opfamily_member = Module._get_opfamily_member = (e, t, r2, a) => (_get_opfamily_member = Module._get_opfamily_member = wasmExports.get_opfamily_member)(e, t, r2, a), __bt_check_natts = Module.__bt_check_natts = (e, t, r2, a) => (__bt_check_natts = Module.__bt_check_natts = wasmExports._bt_check_natts)(e, t, r2, a), _strncpy = Module._strncpy = (e, t, r2) => (_strncpy = Module._strncpy = wasmExports.strncpy)(e, t, r2), _timestamptz_to_str = Module._timestamptz_to_str = (e) => (_timestamptz_to_str = Module._timestamptz_to_str = wasmExports.timestamptz_to_str)(e), _XLogRecGetBlockRefInfo = Module._XLogRecGetBlockRefInfo = (e, t, r2, a, o3) => (_XLogRecGetBlockRefInfo = Module._XLogRecGetBlockRefInfo = wasmExports.XLogRecGetBlockRefInfo)(e, t, r2, a, o3), _varstr_cmp = Module._varstr_cmp = (e, t, r2, a, o3) => (_varstr_cmp = Module._varstr_cmp = wasmExports.varstr_cmp)(e, t, r2, a, o3), _exprType = Module._exprType = (e) => (_exprType = Module._exprType = wasmExports.exprType)(e), _GetActiveSnapshot = Module._GetActiveSnapshot = () => (_GetActiveSnapshot = Module._GetActiveSnapshot = wasmExports.GetActiveSnapshot)(), _errdetail_relkind_not_supported = Module._errdetail_relkind_not_supported = (e) => (_errdetail_relkind_not_supported = Module._errdetail_relkind_not_supported = wasmExports.errdetail_relkind_not_supported)(e), _table_openrv = Module._table_openrv = (e, t) => (_table_openrv = Module._table_openrv = wasmExports.table_openrv)(e, t), _table_slot_callbacks = Module._table_slot_callbacks = (e) => (_table_slot_callbacks = Module._table_slot_callbacks = wasmExports.table_slot_callbacks)(e), _estimate_expression_value = Module._estimate_expression_value = (e, t) => (_estimate_expression_value = Module._estimate_expression_value = wasmExports.estimate_expression_value)(e, t), _clamp_row_est = Module._clamp_row_est = (e) => (_clamp_row_est = Module._clamp_row_est = wasmExports.clamp_row_est)(e), _XLogFlush = Module._XLogFlush = (e) => (_XLogFlush = Module._XLogFlush = wasmExports.XLogFlush)(e), _get_call_result_type = Module._get_call_result_type = (e, t, r2) => (_get_call_result_type = Module._get_call_result_type = wasmExports.get_call_result_type)(e, t, r2), _HeapTupleHeaderGetDatum = Module._HeapTupleHeaderGetDatum = (e) => (_HeapTupleHeaderGetDatum = Module._HeapTupleHeaderGetDatum = wasmExports.HeapTupleHeaderGetDatum)(e), _GenericXLogStart = Module._GenericXLogStart = (e) => (_GenericXLogStart = Module._GenericXLogStart = wasmExports.GenericXLogStart)(e), _GenericXLogRegisterBuffer = Module._GenericXLogRegisterBuffer = (e, t, r2) => (_GenericXLogRegisterBuffer = Module._GenericXLogRegisterBuffer = wasmExports.GenericXLogRegisterBuffer)(e, t, r2), _GenericXLogFinish = Module._GenericXLogFinish = (e) => (_GenericXLogFinish = Module._GenericXLogFinish = wasmExports.GenericXLogFinish)(e), _GenericXLogAbort = Module._GenericXLogAbort = (e) => (_GenericXLogAbort = Module._GenericXLogAbort = wasmExports.GenericXLogAbort)(e), _errmsg_plural = Module._errmsg_plural = (e, t, r2, a) => (_errmsg_plural = Module._errmsg_plural = wasmExports.errmsg_plural)(e, t, r2, a), _ReadNextMultiXactId = Module._ReadNextMultiXactId = () => (_ReadNextMultiXactId = Module._ReadNextMultiXactId = wasmExports.ReadNextMultiXactId)(), _ReadMultiXactIdRange = Module._ReadMultiXactIdRange = (e, t) => (_ReadMultiXactIdRange = Module._ReadMultiXactIdRange = wasmExports.ReadMultiXactIdRange)(e, t), _MultiXactIdPrecedesOrEquals = Module._MultiXactIdPrecedesOrEquals = (e, t) => (_MultiXactIdPrecedesOrEquals = Module._MultiXactIdPrecedesOrEquals = wasmExports.MultiXactIdPrecedesOrEquals)(e, t), _init_MultiFuncCall = Module._init_MultiFuncCall = (e) => (_init_MultiFuncCall = Module._init_MultiFuncCall = wasmExports.init_MultiFuncCall)(e), _TupleDescGetAttInMetadata = Module._TupleDescGetAttInMetadata = (e) => (_TupleDescGetAttInMetadata = Module._TupleDescGetAttInMetadata = wasmExports.TupleDescGetAttInMetadata)(e), _per_MultiFuncCall = Module._per_MultiFuncCall = (e) => (_per_MultiFuncCall = Module._per_MultiFuncCall = wasmExports.per_MultiFuncCall)(e), _BuildTupleFromCStrings = Module._BuildTupleFromCStrings = (e, t) => (_BuildTupleFromCStrings = Module._BuildTupleFromCStrings = wasmExports.BuildTupleFromCStrings)(e, t), _end_MultiFuncCall = Module._end_MultiFuncCall = (e, t) => (_end_MultiFuncCall = Module._end_MultiFuncCall = wasmExports.end_MultiFuncCall)(e, t), _GetCurrentSubTransactionId = Module._GetCurrentSubTransactionId = () => (_GetCurrentSubTransactionId = Module._GetCurrentSubTransactionId = wasmExports.GetCurrentSubTransactionId)(), _WaitForBackgroundWorkerShutdown = Module._WaitForBackgroundWorkerShutdown = (e) => (_WaitForBackgroundWorkerShutdown = Module._WaitForBackgroundWorkerShutdown = wasmExports.WaitForBackgroundWorkerShutdown)(e), _RegisterDynamicBackgroundWorker = Module._RegisterDynamicBackgroundWorker = (e, t) => (_RegisterDynamicBackgroundWorker = Module._RegisterDynamicBackgroundWorker = wasmExports.RegisterDynamicBackgroundWorker)(e, t), _BackgroundWorkerUnblockSignals = Module._BackgroundWorkerUnblockSignals = () => (_BackgroundWorkerUnblockSignals = Module._BackgroundWorkerUnblockSignals = wasmExports.BackgroundWorkerUnblockSignals)(), _BackgroundWorkerInitializeConnectionByOid = Module._BackgroundWorkerInitializeConnectionByOid = (e, t, r2) => (_BackgroundWorkerInitializeConnectionByOid = Module._BackgroundWorkerInitializeConnectionByOid = wasmExports.BackgroundWorkerInitializeConnectionByOid)(e, t, r2), _GetDatabaseEncoding = Module._GetDatabaseEncoding = () => (_GetDatabaseEncoding = Module._GetDatabaseEncoding = wasmExports.GetDatabaseEncoding)(), _RmgrNotFound = Module._RmgrNotFound = (e) => (_RmgrNotFound = Module._RmgrNotFound = wasmExports.RmgrNotFound)(e), _InitMaterializedSRF = Module._InitMaterializedSRF = (e, t) => (_InitMaterializedSRF = Module._InitMaterializedSRF = wasmExports.InitMaterializedSRF)(e, t), _tuplestore_putvalues = Module._tuplestore_putvalues = (e, t, r2, a) => (_tuplestore_putvalues = Module._tuplestore_putvalues = wasmExports.tuplestore_putvalues)(e, t, r2, a), _lseek = Module._lseek = (e, t, r2) => (_lseek = Module._lseek = wasmExports.lseek)(e, t, r2), _AllocateFile = Module._AllocateFile = (e, t) => (_AllocateFile = Module._AllocateFile = wasmExports.AllocateFile)(e, t), _FreeFile = Module._FreeFile = (e) => (_FreeFile = Module._FreeFile = wasmExports.FreeFile)(e), _fd_durable_rename = Module._fd_durable_rename = (e, t, r2) => (_fd_durable_rename = Module._fd_durable_rename = wasmExports.fd_durable_rename)(e, t, r2), _BlessTupleDesc = Module._BlessTupleDesc = (e) => (_BlessTupleDesc = Module._BlessTupleDesc = wasmExports.BlessTupleDesc)(e), _fstat = Module._fstat = (e, t) => (_fstat = Module._fstat = wasmExports.fstat)(e, t), _superuser_arg = Module._superuser_arg = (e) => (_superuser_arg = Module._superuser_arg = wasmExports.superuser_arg)(e), _wal_segment_close = Module._wal_segment_close = (e) => (_wal_segment_close = Module._wal_segment_close = wasmExports.wal_segment_close)(e), _wal_segment_open = Module._wal_segment_open = (e, t, r2) => (_wal_segment_open = Module._wal_segment_open = wasmExports.wal_segment_open)(e, t, r2), _XLogReaderAllocate = Module._XLogReaderAllocate = (e, t, r2, a) => (_XLogReaderAllocate = Module._XLogReaderAllocate = wasmExports.XLogReaderAllocate)(e, t, r2, a), _XLogReadRecord = Module._XLogReadRecord = (e, t) => (_XLogReadRecord = Module._XLogReadRecord = wasmExports.XLogReadRecord)(e, t), _XLogReaderFree = Module._XLogReaderFree = (e) => (_XLogReaderFree = Module._XLogReaderFree = wasmExports.XLogReaderFree)(e), _GetTopFullTransactionId = Module._GetTopFullTransactionId = () => (_GetTopFullTransactionId = Module._GetTopFullTransactionId = wasmExports.GetTopFullTransactionId)(), _GetCurrentTransactionNestLevel = Module._GetCurrentTransactionNestLevel = () => (_GetCurrentTransactionNestLevel = Module._GetCurrentTransactionNestLevel = wasmExports.GetCurrentTransactionNestLevel)(), _ResourceOwnerCreate = Module._ResourceOwnerCreate = (e, t) => (_ResourceOwnerCreate = Module._ResourceOwnerCreate = wasmExports.ResourceOwnerCreate)(e, t), _RegisterXactCallback = Module._RegisterXactCallback = (e, t) => (_RegisterXactCallback = Module._RegisterXactCallback = wasmExports.RegisterXactCallback)(e, t), _RegisterSubXactCallback = Module._RegisterSubXactCallback = (e, t) => (_RegisterSubXactCallback = Module._RegisterSubXactCallback = wasmExports.RegisterSubXactCallback)(e, t), _BeginInternalSubTransaction = Module._BeginInternalSubTransaction = (e) => (_BeginInternalSubTransaction = Module._BeginInternalSubTransaction = wasmExports.BeginInternalSubTransaction)(e), _ReleaseCurrentSubTransaction = Module._ReleaseCurrentSubTransaction = () => (_ReleaseCurrentSubTransaction = Module._ReleaseCurrentSubTransaction = wasmExports.ReleaseCurrentSubTransaction)(), _ResourceOwnerDelete = Module._ResourceOwnerDelete = (e) => (_ResourceOwnerDelete = Module._ResourceOwnerDelete = wasmExports.ResourceOwnerDelete)(e), _RollbackAndReleaseCurrentSubTransaction = Module._RollbackAndReleaseCurrentSubTransaction = () => (_RollbackAndReleaseCurrentSubTransaction = Module._RollbackAndReleaseCurrentSubTransaction = wasmExports.RollbackAndReleaseCurrentSubTransaction)(), _ReleaseExternalFD = Module._ReleaseExternalFD = () => (_ReleaseExternalFD = Module._ReleaseExternalFD = wasmExports.ReleaseExternalFD)(), _GetFlushRecPtr = Module._GetFlushRecPtr = (e) => (_GetFlushRecPtr = Module._GetFlushRecPtr = wasmExports.GetFlushRecPtr)(e), _GetXLogReplayRecPtr = Module._GetXLogReplayRecPtr = (e) => (_GetXLogReplayRecPtr = Module._GetXLogReplayRecPtr = wasmExports.GetXLogReplayRecPtr)(e), _TimestampDifferenceMilliseconds = Module._TimestampDifferenceMilliseconds = (e, t) => (_TimestampDifferenceMilliseconds = Module._TimestampDifferenceMilliseconds = wasmExports.TimestampDifferenceMilliseconds)(e, t), _numeric_in = Module._numeric_in = (e) => (_numeric_in = Module._numeric_in = wasmExports.numeric_in)(e), _DirectFunctionCall3Coll = Module._DirectFunctionCall3Coll = (e, t, r2, a, o3) => (_DirectFunctionCall3Coll = Module._DirectFunctionCall3Coll = wasmExports.DirectFunctionCall3Coll)(e, t, r2, a, o3), _XLogFindNextRecord = Module._XLogFindNextRecord = (e, t) => (_XLogFindNextRecord = Module._XLogFindNextRecord = wasmExports.XLogFindNextRecord)(e, t), _RestoreBlockImage = Module._RestoreBlockImage = (e, t, r2) => (_RestoreBlockImage = Module._RestoreBlockImage = wasmExports.RestoreBlockImage)(e, t, r2), _timestamptz_in = Module._timestamptz_in = (e) => (_timestamptz_in = Module._timestamptz_in = wasmExports.timestamptz_in)(e), _fscanf = Module._fscanf = (e, t, r2) => (_fscanf = Module._fscanf = wasmExports.fscanf)(e, t, r2), _XLogRecStoreStats = Module._XLogRecStoreStats = (e, t) => (_XLogRecStoreStats = Module._XLogRecStoreStats = wasmExports.XLogRecStoreStats)(e, t), _hash_get_num_entries = Module._hash_get_num_entries = (e) => (_hash_get_num_entries = Module._hash_get_num_entries = wasmExports.hash_get_num_entries)(e), _read_local_xlog_page_no_wait = Module._read_local_xlog_page_no_wait = (e, t, r2, a, o3) => (_read_local_xlog_page_no_wait = Module._read_local_xlog_page_no_wait = wasmExports.read_local_xlog_page_no_wait)(e, t, r2, a, o3), _escape_json = Module._escape_json = (e, t) => (_escape_json = Module._escape_json = wasmExports.escape_json)(e, t), _list_sort = Module._list_sort = (e, t) => (_list_sort = Module._list_sort = wasmExports.list_sort)(e, t), _pg_checksum_page = Module._pg_checksum_page = (e, t) => (_pg_checksum_page = Module._pg_checksum_page = wasmExports.pg_checksum_page)(e, t), _bbsink_forward_end_archive = Module._bbsink_forward_end_archive = (e) => (_bbsink_forward_end_archive = Module._bbsink_forward_end_archive = wasmExports.bbsink_forward_end_archive)(e), _bbsink_forward_begin_manifest = Module._bbsink_forward_begin_manifest = (e) => (_bbsink_forward_begin_manifest = Module._bbsink_forward_begin_manifest = wasmExports.bbsink_forward_begin_manifest)(e), _bbsink_forward_end_manifest = Module._bbsink_forward_end_manifest = (e) => (_bbsink_forward_end_manifest = Module._bbsink_forward_end_manifest = wasmExports.bbsink_forward_end_manifest)(e), _bbsink_forward_end_backup = Module._bbsink_forward_end_backup = (e, t, r2) => (_bbsink_forward_end_backup = Module._bbsink_forward_end_backup = wasmExports.bbsink_forward_end_backup)(e, t, r2), _bbsink_forward_cleanup = Module._bbsink_forward_cleanup = (e) => (_bbsink_forward_cleanup = Module._bbsink_forward_cleanup = wasmExports.bbsink_forward_cleanup)(e), _list_concat = Module._list_concat = (e, t) => (_list_concat = Module._list_concat = wasmExports.list_concat)(e, t), _bbsink_forward_begin_backup = Module._bbsink_forward_begin_backup = (e) => (_bbsink_forward_begin_backup = Module._bbsink_forward_begin_backup = wasmExports.bbsink_forward_begin_backup)(e), _bbsink_forward_archive_contents = Module._bbsink_forward_archive_contents = (e, t) => (_bbsink_forward_archive_contents = Module._bbsink_forward_archive_contents = wasmExports.bbsink_forward_archive_contents)(e, t), _bbsink_forward_begin_archive = Module._bbsink_forward_begin_archive = (e, t) => (_bbsink_forward_begin_archive = Module._bbsink_forward_begin_archive = wasmExports.bbsink_forward_begin_archive)(e, t), _bbsink_forward_manifest_contents = Module._bbsink_forward_manifest_contents = (e, t) => (_bbsink_forward_manifest_contents = Module._bbsink_forward_manifest_contents = wasmExports.bbsink_forward_manifest_contents)(e, t), _has_privs_of_role = Module._has_privs_of_role = (e, t) => (_has_privs_of_role = Module._has_privs_of_role = wasmExports.has_privs_of_role)(e, t), _BaseBackupAddTarget = Module._BaseBackupAddTarget = (e, t, r2) => (_BaseBackupAddTarget = Module._BaseBackupAddTarget = wasmExports.BaseBackupAddTarget)(e, t, r2), _list_copy = Module._list_copy = (e) => (_list_copy = Module._list_copy = wasmExports.list_copy)(e), _tuplestore_puttuple = Module._tuplestore_puttuple = (e, t) => (_tuplestore_puttuple = Module._tuplestore_puttuple = wasmExports.tuplestore_puttuple)(e, t), _makeRangeVar = Module._makeRangeVar = (e, t, r2) => (_makeRangeVar = Module._makeRangeVar = wasmExports.makeRangeVar)(e, t, r2), _DefineIndex = Module._DefineIndex = (e, t, r2, a, o3, s2, l3, _2, n, m2, p, d2) => (_DefineIndex = Module._DefineIndex = wasmExports.DefineIndex)(e, t, r2, a, o3, s2, l3, _2, n, m2, p, d2), _fread = Module._fread = (e, t, r2, a) => (_fread = Module._fread = wasmExports.fread)(e, t, r2, a), _clearerr = Module._clearerr = (e) => (_clearerr = Module._clearerr = wasmExports.clearerr)(e), _copyObjectImpl = Module._copyObjectImpl = (e) => (_copyObjectImpl = Module._copyObjectImpl = wasmExports.copyObjectImpl)(e), _lappend_oid = Module._lappend_oid = (e, t) => (_lappend_oid = Module._lappend_oid = wasmExports.lappend_oid)(e, t), _makeTypeNameFromNameList = Module._makeTypeNameFromNameList = (e) => (_makeTypeNameFromNameList = Module._makeTypeNameFromNameList = wasmExports.makeTypeNameFromNameList)(e), _SearchSysCache2 = Module._SearchSysCache2 = (e, t, r2) => (_SearchSysCache2 = Module._SearchSysCache2 = wasmExports.SearchSysCache2)(e, t, r2), _SysCacheGetAttr = Module._SysCacheGetAttr = (e, t, r2, a) => (_SysCacheGetAttr = Module._SysCacheGetAttr = wasmExports.SysCacheGetAttr)(e, t, r2, a), _CatalogTupleUpdate = Module._CatalogTupleUpdate = (e, t, r2) => (_CatalogTupleUpdate = Module._CatalogTupleUpdate = wasmExports.CatalogTupleUpdate)(e, t, r2), _get_rel_name = Module._get_rel_name = (e) => (_get_rel_name = Module._get_rel_name = wasmExports.get_rel_name)(e), _CatalogTupleDelete = Module._CatalogTupleDelete = (e, t) => (_CatalogTupleDelete = Module._CatalogTupleDelete = wasmExports.CatalogTupleDelete)(e, t), _CatalogTupleInsert = Module._CatalogTupleInsert = (e, t) => (_CatalogTupleInsert = Module._CatalogTupleInsert = wasmExports.CatalogTupleInsert)(e, t), _recordDependencyOn = Module._recordDependencyOn = (e, t, r2) => (_recordDependencyOn = Module._recordDependencyOn = wasmExports.recordDependencyOn)(e, t, r2), _get_element_type = Module._get_element_type = (e) => (_get_element_type = Module._get_element_type = wasmExports.get_element_type)(e), _object_aclcheck = Module._object_aclcheck = (e, t, r2, a) => (_object_aclcheck = Module._object_aclcheck = wasmExports.object_aclcheck)(e, t, r2, a), _superuser = Module._superuser = () => (_superuser = Module._superuser = wasmExports.superuser)(), _SearchSysCacheAttName = Module._SearchSysCacheAttName = (e, t) => (_SearchSysCacheAttName = Module._SearchSysCacheAttName = wasmExports.SearchSysCacheAttName)(e, t), _new_object_addresses = Module._new_object_addresses = () => (_new_object_addresses = Module._new_object_addresses = wasmExports.new_object_addresses)(), _free_object_addresses = Module._free_object_addresses = (e) => (_free_object_addresses = Module._free_object_addresses = wasmExports.free_object_addresses)(e), _performMultipleDeletions = Module._performMultipleDeletions = (e, t, r2) => (_performMultipleDeletions = Module._performMultipleDeletions = wasmExports.performMultipleDeletions)(e, t, r2), _recordDependencyOnExpr = Module._recordDependencyOnExpr = (e, t, r2, a) => (_recordDependencyOnExpr = Module._recordDependencyOnExpr = wasmExports.recordDependencyOnExpr)(e, t, r2, a), _query_tree_walker_impl = Module._query_tree_walker_impl = (e, t, r2, a) => (_query_tree_walker_impl = Module._query_tree_walker_impl = wasmExports.query_tree_walker_impl)(e, t, r2, a), _expression_tree_walker_impl = Module._expression_tree_walker_impl = (e, t, r2) => (_expression_tree_walker_impl = Module._expression_tree_walker_impl = wasmExports.expression_tree_walker_impl)(e, t, r2), _add_exact_object_address = Module._add_exact_object_address = (e, t) => (_add_exact_object_address = Module._add_exact_object_address = wasmExports.add_exact_object_address)(e, t), _get_rel_relkind = Module._get_rel_relkind = (e) => (_get_rel_relkind = Module._get_rel_relkind = wasmExports.get_rel_relkind)(e), _get_typtype = Module._get_typtype = (e) => (_get_typtype = Module._get_typtype = wasmExports.get_typtype)(e), _list_delete_last = Module._list_delete_last = (e) => (_list_delete_last = Module._list_delete_last = wasmExports.list_delete_last)(e), _type_is_collatable = Module._type_is_collatable = (e) => (_type_is_collatable = Module._type_is_collatable = wasmExports.type_is_collatable)(e), _GetSysCacheOid = Module._GetSysCacheOid = (e, t, r2, a, o3, s2) => (_GetSysCacheOid = Module._GetSysCacheOid = wasmExports.GetSysCacheOid)(e, t, r2, a, o3, s2), _CheckTableNotInUse = Module._CheckTableNotInUse = (e, t) => (_CheckTableNotInUse = Module._CheckTableNotInUse = wasmExports.CheckTableNotInUse)(e, t), _make_parsestate = Module._make_parsestate = (e) => (_make_parsestate = Module._make_parsestate = wasmExports.make_parsestate)(e), _transformExpr = Module._transformExpr = (e, t, r2) => (_transformExpr = Module._transformExpr = wasmExports.transformExpr)(e, t, r2), _equal = Module._equal = (e, t) => (_equal = Module._equal = wasmExports.equal)(e, t), _pull_var_clause = Module._pull_var_clause = (e, t) => (_pull_var_clause = Module._pull_var_clause = wasmExports.pull_var_clause)(e, t), _get_attname = Module._get_attname = (e, t, r2) => (_get_attname = Module._get_attname = wasmExports.get_attname)(e, t, r2), _coerce_to_target_type = Module._coerce_to_target_type = (e, t, r2, a, o3, s2, l3, _2) => (_coerce_to_target_type = Module._coerce_to_target_type = wasmExports.coerce_to_target_type)(e, t, r2, a, o3, s2, l3, _2), _nodeToString = Module._nodeToString = (e) => (_nodeToString = Module._nodeToString = wasmExports.nodeToString)(e), _parser_errposition = Module._parser_errposition = (e, t) => (_parser_errposition = Module._parser_errposition = wasmExports.parser_errposition)(e, t), _exprTypmod = Module._exprTypmod = (e) => (_exprTypmod = Module._exprTypmod = wasmExports.exprTypmod)(e), _get_base_element_type = Module._get_base_element_type = (e) => (_get_base_element_type = Module._get_base_element_type = wasmExports.get_base_element_type)(e), _SystemFuncName = Module._SystemFuncName = (e) => (_SystemFuncName = Module._SystemFuncName = wasmExports.SystemFuncName)(e), _CreateTrigger = Module._CreateTrigger = (e, t, r2, a, o3, s2, l3, _2, n, m2, p, d2) => (_CreateTrigger = Module._CreateTrigger = wasmExports.CreateTrigger)(e, t, r2, a, o3, s2, l3, _2, n, m2, p, d2), _plan_create_index_workers = Module._plan_create_index_workers = (e, t) => (_plan_create_index_workers = Module._plan_create_index_workers = wasmExports.plan_create_index_workers)(e, t), _get_rel_relispartition = Module._get_rel_relispartition = (e) => (_get_rel_relispartition = Module._get_rel_relispartition = wasmExports.get_rel_relispartition)(e), _get_partition_ancestors = Module._get_partition_ancestors = (e) => (_get_partition_ancestors = Module._get_partition_ancestors = wasmExports.get_partition_ancestors)(e), _get_rel_namespace = Module._get_rel_namespace = (e) => (_get_rel_namespace = Module._get_rel_namespace = wasmExports.get_rel_namespace)(e), _ConditionalLockRelationOid = Module._ConditionalLockRelationOid = (e, t) => (_ConditionalLockRelationOid = Module._ConditionalLockRelationOid = wasmExports.ConditionalLockRelationOid)(e, t), _RelnameGetRelid = Module._RelnameGetRelid = (e) => (_RelnameGetRelid = Module._RelnameGetRelid = wasmExports.RelnameGetRelid)(e), _get_relkind_objtype = Module._get_relkind_objtype = (e) => (_get_relkind_objtype = Module._get_relkind_objtype = wasmExports.get_relkind_objtype)(e), _RelationIsVisible = Module._RelationIsVisible = (e) => (_RelationIsVisible = Module._RelationIsVisible = wasmExports.RelationIsVisible)(e), _get_func_arg_info = Module._get_func_arg_info = (e, t, r2, a) => (_get_func_arg_info = Module._get_func_arg_info = wasmExports.get_func_arg_info)(e, t, r2, a), _NameListToString = Module._NameListToString = (e) => (_NameListToString = Module._NameListToString = wasmExports.NameListToString)(e), _OpernameGetOprid = Module._OpernameGetOprid = (e, t, r2) => (_OpernameGetOprid = Module._OpernameGetOprid = wasmExports.OpernameGetOprid)(e, t, r2), _makeRangeVarFromNameList = Module._makeRangeVarFromNameList = (e) => (_makeRangeVarFromNameList = Module._makeRangeVarFromNameList = wasmExports.makeRangeVarFromNameList)(e), _quote_identifier = Module._quote_identifier = (e) => (_quote_identifier = Module._quote_identifier = wasmExports.quote_identifier)(e), _GetSearchPathMatcher = Module._GetSearchPathMatcher = (e) => (_GetSearchPathMatcher = Module._GetSearchPathMatcher = wasmExports.GetSearchPathMatcher)(e), _SearchPathMatchesCurrentEnvironment = Module._SearchPathMatchesCurrentEnvironment = (e) => (_SearchPathMatchesCurrentEnvironment = Module._SearchPathMatchesCurrentEnvironment = wasmExports.SearchPathMatchesCurrentEnvironment)(e), _get_collation_oid = Module._get_collation_oid = (e, t) => (_get_collation_oid = Module._get_collation_oid = wasmExports.get_collation_oid)(e, t), _CacheRegisterSyscacheCallback = Module._CacheRegisterSyscacheCallback = (e, t, r2) => (_CacheRegisterSyscacheCallback = Module._CacheRegisterSyscacheCallback = wasmExports.CacheRegisterSyscacheCallback)(e, t, r2), _get_extension_oid = Module._get_extension_oid = (e, t) => (_get_extension_oid = Module._get_extension_oid = wasmExports.get_extension_oid)(e, t), _get_role_oid = Module._get_role_oid = (e, t) => (_get_role_oid = Module._get_role_oid = wasmExports.get_role_oid)(e, t), _GetForeignServerByName = Module._GetForeignServerByName = (e, t) => (_GetForeignServerByName = Module._GetForeignServerByName = wasmExports.GetForeignServerByName)(e, t), _GetPublicationByName = Module._GetPublicationByName = (e, t) => (_GetPublicationByName = Module._GetPublicationByName = wasmExports.GetPublicationByName)(e, t), _typeStringToTypeName = Module._typeStringToTypeName = (e, t) => (_typeStringToTypeName = Module._typeStringToTypeName = wasmExports.typeStringToTypeName)(e, t), _list_make2_impl = Module._list_make2_impl = (e, t, r2) => (_list_make2_impl = Module._list_make2_impl = wasmExports.list_make2_impl)(e, t, r2), _GetUserNameFromId = Module._GetUserNameFromId = (e, t) => (_GetUserNameFromId = Module._GetUserNameFromId = wasmExports.GetUserNameFromId)(e, t), _format_type_extended = Module._format_type_extended = (e, t, r2) => (_format_type_extended = Module._format_type_extended = wasmExports.format_type_extended)(e, t, r2), _quote_qualified_identifier = Module._quote_qualified_identifier = (e, t) => (_quote_qualified_identifier = Module._quote_qualified_identifier = wasmExports.quote_qualified_identifier)(e, t), _get_tablespace_name = Module._get_tablespace_name = (e) => (_get_tablespace_name = Module._get_tablespace_name = wasmExports.get_tablespace_name)(e), _GetForeignServerExtended = Module._GetForeignServerExtended = (e, t) => (_GetForeignServerExtended = Module._GetForeignServerExtended = wasmExports.GetForeignServerExtended)(e, t), _GetForeignServer = Module._GetForeignServer = (e) => (_GetForeignServer = Module._GetForeignServer = wasmExports.GetForeignServer)(e), _construct_empty_array = Module._construct_empty_array = (e) => (_construct_empty_array = Module._construct_empty_array = wasmExports.construct_empty_array)(e), _format_type_be_qualified = Module._format_type_be_qualified = (e) => (_format_type_be_qualified = Module._format_type_be_qualified = wasmExports.format_type_be_qualified)(e), _get_namespace_name_or_temp = Module._get_namespace_name_or_temp = (e) => (_get_namespace_name_or_temp = Module._get_namespace_name_or_temp = wasmExports.get_namespace_name_or_temp)(e), _list_make3_impl = Module._list_make3_impl = (e, t, r2, a) => (_list_make3_impl = Module._list_make3_impl = wasmExports.list_make3_impl)(e, t, r2, a), _construct_md_array = Module._construct_md_array = (e, t, r2, a, o3, s2, l3, _2, n) => (_construct_md_array = Module._construct_md_array = wasmExports.construct_md_array)(e, t, r2, a, o3, s2, l3, _2, n), _pull_varattnos = Module._pull_varattnos = (e, t, r2) => (_pull_varattnos = Module._pull_varattnos = wasmExports.pull_varattnos)(e, t, r2), _get_func_name = Module._get_func_name = (e) => (_get_func_name = Module._get_func_name = wasmExports.get_func_name)(e), _ExecPrepareExpr = Module._ExecPrepareExpr = (e, t) => (_ExecPrepareExpr = Module._ExecPrepareExpr = wasmExports.ExecPrepareExpr)(e, t), _construct_array = Module._construct_array = (e, t, r2, a, o3, s2) => (_construct_array = Module._construct_array = wasmExports.construct_array)(e, t, r2, a, o3, s2), _construct_array_builtin = Module._construct_array_builtin = (e, t, r2) => (_construct_array_builtin = Module._construct_array_builtin = wasmExports.construct_array_builtin)(e, t, r2), _makeObjectName = Module._makeObjectName = (e, t, r2) => (_makeObjectName = Module._makeObjectName = wasmExports.makeObjectName)(e, t, r2), _get_primary_key_attnos = Module._get_primary_key_attnos = (e, t, r2) => (_get_primary_key_attnos = Module._get_primary_key_attnos = wasmExports.get_primary_key_attnos)(e, t, r2), _bms_is_subset = Module._bms_is_subset = (e, t) => (_bms_is_subset = Module._bms_is_subset = wasmExports.bms_is_subset)(e, t), _getExtensionOfObject = Module._getExtensionOfObject = (e, t) => (_getExtensionOfObject = Module._getExtensionOfObject = wasmExports.getExtensionOfObject)(e, t), _find_inheritance_children = Module._find_inheritance_children = (e, t) => (_find_inheritance_children = Module._find_inheritance_children = wasmExports.find_inheritance_children)(e, t), _lappend_int = Module._lappend_int = (e, t) => (_lappend_int = Module._lappend_int = wasmExports.lappend_int)(e, t), _has_superclass = Module._has_superclass = (e) => (_has_superclass = Module._has_superclass = wasmExports.has_superclass)(e), _CheckFunctionValidatorAccess = Module._CheckFunctionValidatorAccess = (e, t) => (_CheckFunctionValidatorAccess = Module._CheckFunctionValidatorAccess = wasmExports.CheckFunctionValidatorAccess)(e, t), _AcquireRewriteLocks = Module._AcquireRewriteLocks = (e, t, r2) => (_AcquireRewriteLocks = Module._AcquireRewriteLocks = wasmExports.AcquireRewriteLocks)(e, t, r2), _function_parse_error_transpose = Module._function_parse_error_transpose = (e) => (_function_parse_error_transpose = Module._function_parse_error_transpose = wasmExports.function_parse_error_transpose)(e), _geterrposition = Module._geterrposition = () => (_geterrposition = Module._geterrposition = wasmExports.geterrposition)(), _getinternalerrposition = Module._getinternalerrposition = () => (_getinternalerrposition = Module._getinternalerrposition = wasmExports.getinternalerrposition)(), _pg_mblen = Module._pg_mblen = (e) => (_pg_mblen = Module._pg_mblen = wasmExports.pg_mblen)(e), _pg_mbstrlen_with_len = Module._pg_mbstrlen_with_len = (e, t) => (_pg_mbstrlen_with_len = Module._pg_mbstrlen_with_len = wasmExports.pg_mbstrlen_with_len)(e, t), _errposition = Module._errposition = (e) => (_errposition = Module._errposition = wasmExports.errposition)(e), _internalerrposition = Module._internalerrposition = (e) => (_internalerrposition = Module._internalerrposition = wasmExports.internalerrposition)(e), _internalerrquery = Module._internalerrquery = (e) => (_internalerrquery = Module._internalerrquery = wasmExports.internalerrquery)(e), _is_publishable_relation = Module._is_publishable_relation = (e) => (_is_publishable_relation = Module._is_publishable_relation = wasmExports.is_publishable_relation)(e), _GetTopMostAncestorInPublication = Module._GetTopMostAncestorInPublication = (e, t, r2) => (_GetTopMostAncestorInPublication = Module._GetTopMostAncestorInPublication = wasmExports.GetTopMostAncestorInPublication)(e, t, r2), _GetRelationPublications = Module._GetRelationPublications = (e) => (_GetRelationPublications = Module._GetRelationPublications = wasmExports.GetRelationPublications)(e), _GetSchemaPublications = Module._GetSchemaPublications = (e) => (_GetSchemaPublications = Module._GetSchemaPublications = wasmExports.GetSchemaPublications)(e), _pub_collist_to_bitmapset = Module._pub_collist_to_bitmapset = (e, t, r2) => (_pub_collist_to_bitmapset = Module._pub_collist_to_bitmapset = wasmExports.pub_collist_to_bitmapset)(e, t, r2), _list_delete_nth_cell = Module._list_delete_nth_cell = (e, t) => (_list_delete_nth_cell = Module._list_delete_nth_cell = wasmExports.list_delete_nth_cell)(e, t), _get_array_type = Module._get_array_type = (e) => (_get_array_type = Module._get_array_type = wasmExports.get_array_type)(e), _smgrtruncate2 = Module._smgrtruncate2 = (e, t, r2, a, o3) => (_smgrtruncate2 = Module._smgrtruncate2 = wasmExports.smgrtruncate2)(e, t, r2, a, o3), _smgrreadv = Module._smgrreadv = (e, t, r2, a, o3) => (_smgrreadv = Module._smgrreadv = wasmExports.smgrreadv)(e, t, r2, a, o3), _NewRelationCreateToastTable = Module._NewRelationCreateToastTable = (e, t) => (_NewRelationCreateToastTable = Module._NewRelationCreateToastTable = wasmExports.NewRelationCreateToastTable)(e, t), _transformStmt = Module._transformStmt = (e, t) => (_transformStmt = Module._transformStmt = wasmExports.transformStmt)(e, t), _exprLocation = Module._exprLocation = (e) => (_exprLocation = Module._exprLocation = wasmExports.exprLocation)(e), _ParseFuncOrColumn = Module._ParseFuncOrColumn = (e, t, r2, a, o3, s2, l3) => (_ParseFuncOrColumn = Module._ParseFuncOrColumn = wasmExports.ParseFuncOrColumn)(e, t, r2, a, o3, s2, l3), _exprCollation = Module._exprCollation = (e) => (_exprCollation = Module._exprCollation = wasmExports.exprCollation)(e), _transformDistinctClause = Module._transformDistinctClause = (e, t, r2, a) => (_transformDistinctClause = Module._transformDistinctClause = wasmExports.transformDistinctClause)(e, t, r2, a), _makeTargetEntry = Module._makeTargetEntry = (e, t, r2, a) => (_makeTargetEntry = Module._makeTargetEntry = wasmExports.makeTargetEntry)(e, t, r2, a), _makeAlias = Module._makeAlias = (e, t) => (_makeAlias = Module._makeAlias = wasmExports.makeAlias)(e, t), _addRangeTableEntryForSubquery = Module._addRangeTableEntryForSubquery = (e, t, r2, a, o3) => (_addRangeTableEntryForSubquery = Module._addRangeTableEntryForSubquery = wasmExports.addRangeTableEntryForSubquery)(e, t, r2, a, o3), _makeVar = Module._makeVar = (e, t, r2, a, o3, s2) => (_makeVar = Module._makeVar = wasmExports.makeVar)(e, t, r2, a, o3, s2), _makeBoolean = Module._makeBoolean = (e) => (_makeBoolean = Module._makeBoolean = wasmExports.makeBoolean)(e), _makeInteger = Module._makeInteger = (e) => (_makeInteger = Module._makeInteger = wasmExports.makeInteger)(e), _makeTypeName = Module._makeTypeName = (e) => (_makeTypeName = Module._makeTypeName = wasmExports.makeTypeName)(e), _makeFuncCall = Module._makeFuncCall = (e, t, r2, a) => (_makeFuncCall = Module._makeFuncCall = wasmExports.makeFuncCall)(e, t, r2, a), _list_make4_impl = Module._list_make4_impl = (e, t, r2, a, o3) => (_list_make4_impl = Module._list_make4_impl = wasmExports.list_make4_impl)(e, t, r2, a, o3), _get_sortgroupclause_tle = Module._get_sortgroupclause_tle = (e, t) => (_get_sortgroupclause_tle = Module._get_sortgroupclause_tle = wasmExports.get_sortgroupclause_tle)(e, t), _flatten_join_alias_vars = Module._flatten_join_alias_vars = (e, t, r2) => (_flatten_join_alias_vars = Module._flatten_join_alias_vars = wasmExports.flatten_join_alias_vars)(e, t, r2), _list_member_int = Module._list_member_int = (e, t) => (_list_member_int = Module._list_member_int = wasmExports.list_member_int)(e, t), _addRangeTableEntryForENR = Module._addRangeTableEntryForENR = (e, t, r2) => (_addRangeTableEntryForENR = Module._addRangeTableEntryForENR = wasmExports.addRangeTableEntryForENR)(e, t, r2), _typenameTypeIdAndMod = Module._typenameTypeIdAndMod = (e, t, r2, a) => (_typenameTypeIdAndMod = Module._typenameTypeIdAndMod = wasmExports.typenameTypeIdAndMod)(e, t, r2, a), _get_typcollation = Module._get_typcollation = (e) => (_get_typcollation = Module._get_typcollation = wasmExports.get_typcollation)(e), _strip_implicit_coercions = Module._strip_implicit_coercions = (e) => (_strip_implicit_coercions = Module._strip_implicit_coercions = wasmExports.strip_implicit_coercions)(e), _get_sortgroupref_tle = Module._get_sortgroupref_tle = (e, t) => (_get_sortgroupref_tle = Module._get_sortgroupref_tle = wasmExports.get_sortgroupref_tle)(e, t), _contain_aggs_of_level = Module._contain_aggs_of_level = (e, t) => (_contain_aggs_of_level = Module._contain_aggs_of_level = wasmExports.contain_aggs_of_level)(e, t), _typeidType = Module._typeidType = (e) => (_typeidType = Module._typeidType = wasmExports.typeidType)(e), _typeTypeCollation = Module._typeTypeCollation = (e) => (_typeTypeCollation = Module._typeTypeCollation = wasmExports.typeTypeCollation)(e), _typeLen = Module._typeLen = (e) => (_typeLen = Module._typeLen = wasmExports.typeLen)(e), _typeByVal = Module._typeByVal = (e) => (_typeByVal = Module._typeByVal = wasmExports.typeByVal)(e), _makeConst = Module._makeConst = (e, t, r2, a, o3, s2, l3) => (_makeConst = Module._makeConst = wasmExports.makeConst)(e, t, r2, a, o3, s2, l3), _lookup_rowtype_tupdesc = Module._lookup_rowtype_tupdesc = (e, t) => (_lookup_rowtype_tupdesc = Module._lookup_rowtype_tupdesc = wasmExports.lookup_rowtype_tupdesc)(e, t), _bms_del_member = Module._bms_del_member = (e, t) => (_bms_del_member = Module._bms_del_member = wasmExports.bms_del_member)(e, t), _list_member = Module._list_member = (e, t) => (_list_member = Module._list_member = wasmExports.list_member)(e, t), _type_is_rowtype = Module._type_is_rowtype = (e) => (_type_is_rowtype = Module._type_is_rowtype = wasmExports.type_is_rowtype)(e), _bit_in = Module._bit_in = (e) => (_bit_in = Module._bit_in = wasmExports.bit_in)(e), _bms_union = Module._bms_union = (e, t) => (_bms_union = Module._bms_union = wasmExports.bms_union)(e, t), _varstr_levenshtein_less_equal = Module._varstr_levenshtein_less_equal = (e, t, r2, a, o3, s2, l3, _2, n) => (_varstr_levenshtein_less_equal = Module._varstr_levenshtein_less_equal = wasmExports.varstr_levenshtein_less_equal)(e, t, r2, a, o3, s2, l3, _2, n), _addRTEPermissionInfo = Module._addRTEPermissionInfo = (e, t) => (_addRTEPermissionInfo = Module._addRTEPermissionInfo = wasmExports.addRTEPermissionInfo)(e, t), _errsave_start = Module._errsave_start = (e, t) => (_errsave_start = Module._errsave_start = wasmExports.errsave_start)(e, t), _errsave_finish = Module._errsave_finish = (e, t, r2, a) => (_errsave_finish = Module._errsave_finish = wasmExports.errsave_finish)(e, t, r2, a), _makeColumnDef = Module._makeColumnDef = (e, t, r2, a) => (_makeColumnDef = Module._makeColumnDef = wasmExports.makeColumnDef)(e, t, r2, a), _GetDefaultOpClass = Module._GetDefaultOpClass = (e, t) => (_GetDefaultOpClass = Module._GetDefaultOpClass = wasmExports.GetDefaultOpClass)(e, t), _scanner_init = Module._scanner_init = (e, t, r2, a) => (_scanner_init = Module._scanner_init = wasmExports.scanner_init)(e, t, r2, a), _scanner_finish = Module._scanner_finish = (e) => (_scanner_finish = Module._scanner_finish = wasmExports.scanner_finish)(e), _core_yylex = Module._core_yylex = (e, t, r2) => (_core_yylex = Module._core_yylex = wasmExports.core_yylex)(e, t, r2), _isxdigit = Module._isxdigit = (e) => (_isxdigit = Module._isxdigit = wasmExports.isxdigit)(e), _scanner_isspace = Module._scanner_isspace = (e) => (_scanner_isspace = Module._scanner_isspace = wasmExports.scanner_isspace)(e), _truncate_identifier = Module._truncate_identifier = (e, t, r2) => (_truncate_identifier = Module._truncate_identifier = wasmExports.truncate_identifier)(e, t, r2), _downcase_truncate_identifier = Module._downcase_truncate_identifier = (e, t, r2) => (_downcase_truncate_identifier = Module._downcase_truncate_identifier = wasmExports.downcase_truncate_identifier)(e, t, r2), _pg_database_encoding_max_length = Module._pg_database_encoding_max_length = () => (_pg_database_encoding_max_length = Module._pg_database_encoding_max_length = wasmExports.pg_database_encoding_max_length)(), _namein = Module._namein = (e) => (_namein = Module._namein = wasmExports.namein)(e), _BlockSampler_Init = Module._BlockSampler_Init = (e, t, r2, a) => (_BlockSampler_Init = Module._BlockSampler_Init = wasmExports.BlockSampler_Init)(e, t, r2, a), _reservoir_init_selection_state = Module._reservoir_init_selection_state = (e, t) => (_reservoir_init_selection_state = Module._reservoir_init_selection_state = wasmExports.reservoir_init_selection_state)(e, t), _reservoir_get_next_S = Module._reservoir_get_next_S = (e, t, r2) => (_reservoir_get_next_S = Module._reservoir_get_next_S = wasmExports.reservoir_get_next_S)(e, t, r2), _sampler_random_fract = Module._sampler_random_fract = (e) => (_sampler_random_fract = Module._sampler_random_fract = wasmExports.sampler_random_fract)(e), _BlockSampler_HasMore = Module._BlockSampler_HasMore = (e) => (_BlockSampler_HasMore = Module._BlockSampler_HasMore = wasmExports.BlockSampler_HasMore)(e), _BlockSampler_Next = Module._BlockSampler_Next = (e) => (_BlockSampler_Next = Module._BlockSampler_Next = wasmExports.BlockSampler_Next)(e), _Async_Notify = Module._Async_Notify = (e, t) => (_Async_Notify = Module._Async_Notify = wasmExports.Async_Notify)(e, t), _RangeVarCallbackMaintainsTable = Module._RangeVarCallbackMaintainsTable = (e, t, r2, a) => (_RangeVarCallbackMaintainsTable = Module._RangeVarCallbackMaintainsTable = wasmExports.RangeVarCallbackMaintainsTable)(e, t, r2, a), _make_new_heap = Module._make_new_heap = (e, t, r2, a, o3) => (_make_new_heap = Module._make_new_heap = wasmExports.make_new_heap)(e, t, r2, a, o3), _finish_heap_swap = Module._finish_heap_swap = (e, t, r2, a, o3, s2, l3, _2, n) => (_finish_heap_swap = Module._finish_heap_swap = wasmExports.finish_heap_swap)(e, t, r2, a, o3, s2, l3, _2, n), _wasm_OpenPipeStream = Module._wasm_OpenPipeStream = (e, t) => (_wasm_OpenPipeStream = Module._wasm_OpenPipeStream = wasmExports.wasm_OpenPipeStream)(e, t), _ClosePipeStream = Module._ClosePipeStream = (e) => (_ClosePipeStream = Module._ClosePipeStream = wasmExports.ClosePipeStream)(e), _BeginCopyFrom = Module._BeginCopyFrom = (e, t, r2, a, o3, s2, l3, _2) => (_BeginCopyFrom = Module._BeginCopyFrom = wasmExports.BeginCopyFrom)(e, t, r2, a, o3, s2, l3, _2), _EndCopyFrom = Module._EndCopyFrom = (e) => (_EndCopyFrom = Module._EndCopyFrom = wasmExports.EndCopyFrom)(e), _ProcessCopyOptions = Module._ProcessCopyOptions = (e, t, r2, a) => (_ProcessCopyOptions = Module._ProcessCopyOptions = wasmExports.ProcessCopyOptions)(e, t, r2, a), _CopyFromErrorCallback = Module._CopyFromErrorCallback = (e) => (_CopyFromErrorCallback = Module._CopyFromErrorCallback = wasmExports.CopyFromErrorCallback)(e), _ExecInitRangeTable = Module._ExecInitRangeTable = (e, t, r2) => (_ExecInitRangeTable = Module._ExecInitRangeTable = wasmExports.ExecInitRangeTable)(e, t, r2), _NextCopyFrom = Module._NextCopyFrom = (e, t, r2, a) => (_NextCopyFrom = Module._NextCopyFrom = wasmExports.NextCopyFrom)(e, t, r2, a), _ExecInitExpr = Module._ExecInitExpr = (e, t) => (_ExecInitExpr = Module._ExecInitExpr = wasmExports.ExecInitExpr)(e, t), _report_invalid_encoding = Module._report_invalid_encoding = (e, t, r2) => (_report_invalid_encoding = Module._report_invalid_encoding = wasmExports.report_invalid_encoding)(e, t, r2), _tolower = Module._tolower = (e) => (_tolower = Module._tolower = wasmExports.tolower)(e), _PushCopiedSnapshot = Module._PushCopiedSnapshot = (e) => (_PushCopiedSnapshot = Module._PushCopiedSnapshot = wasmExports.PushCopiedSnapshot)(e), _UpdateActiveSnapshotCommandId = Module._UpdateActiveSnapshotCommandId = () => (_UpdateActiveSnapshotCommandId = Module._UpdateActiveSnapshotCommandId = wasmExports.UpdateActiveSnapshotCommandId)(), _CreateQueryDesc = Module._CreateQueryDesc = (e, t, r2, a, o3, s2, l3, _2) => (_CreateQueryDesc = Module._CreateQueryDesc = wasmExports.CreateQueryDesc)(e, t, r2, a, o3, s2, l3, _2), _ExecutorStart = Module._ExecutorStart = (e, t) => (_ExecutorStart = Module._ExecutorStart = wasmExports.ExecutorStart)(e, t), _ExecutorFinish = Module._ExecutorFinish = (e) => (_ExecutorFinish = Module._ExecutorFinish = wasmExports.ExecutorFinish)(e), _ExecutorEnd = Module._ExecutorEnd = (e) => (_ExecutorEnd = Module._ExecutorEnd = wasmExports.ExecutorEnd)(e), _FreeQueryDesc = Module._FreeQueryDesc = (e) => (_FreeQueryDesc = Module._FreeQueryDesc = wasmExports.FreeQueryDesc)(e), _pg_server_to_any = Module._pg_server_to_any = (e, t, r2) => (_pg_server_to_any = Module._pg_server_to_any = wasmExports.pg_server_to_any)(e, t, r2), _ExecutorRun = Module._ExecutorRun = (e, t, r2, a) => (_ExecutorRun = Module._ExecutorRun = wasmExports.ExecutorRun)(e, t, r2, a), _CreateTableAsRelExists = Module._CreateTableAsRelExists = (e) => (_CreateTableAsRelExists = Module._CreateTableAsRelExists = wasmExports.CreateTableAsRelExists)(e), _DefineRelation = Module._DefineRelation = (e, t, r2, a, o3, s2) => (_DefineRelation = Module._DefineRelation = wasmExports.DefineRelation)(e, t, r2, a, o3, s2), _oidin = Module._oidin = (e) => (_oidin = Module._oidin = wasmExports.oidin)(e), _GetCommandTagName = Module._GetCommandTagName = (e) => (_GetCommandTagName = Module._GetCommandTagName = wasmExports.GetCommandTagName)(e), _ExplainBeginOutput = Module._ExplainBeginOutput = (e) => (_ExplainBeginOutput = Module._ExplainBeginOutput = wasmExports.ExplainBeginOutput)(e), _NewExplainState = Module._NewExplainState = () => (_NewExplainState = Module._NewExplainState = wasmExports.NewExplainState)(), _ExplainEndOutput = Module._ExplainEndOutput = (e) => (_ExplainEndOutput = Module._ExplainEndOutput = wasmExports.ExplainEndOutput)(e), _ExplainPrintPlan = Module._ExplainPrintPlan = (e, t) => (_ExplainPrintPlan = Module._ExplainPrintPlan = wasmExports.ExplainPrintPlan)(e, t), _ExplainPrintTriggers = Module._ExplainPrintTriggers = (e, t) => (_ExplainPrintTriggers = Module._ExplainPrintTriggers = wasmExports.ExplainPrintTriggers)(e, t), _ExplainPrintJITSummary = Module._ExplainPrintJITSummary = (e, t) => (_ExplainPrintJITSummary = Module._ExplainPrintJITSummary = wasmExports.ExplainPrintJITSummary)(e, t), _InstrEndLoop = Module._InstrEndLoop = (e) => (_InstrEndLoop = Module._InstrEndLoop = wasmExports.InstrEndLoop)(e), _ExplainPropertyInteger = Module._ExplainPropertyInteger = (e, t, r2, a) => (_ExplainPropertyInteger = Module._ExplainPropertyInteger = wasmExports.ExplainPropertyInteger)(e, t, r2, a), _make_orclause = Module._make_orclause = (e) => (_make_orclause = Module._make_orclause = wasmExports.make_orclause)(e), _ExplainQueryText = Module._ExplainQueryText = (e, t) => (_ExplainQueryText = Module._ExplainQueryText = wasmExports.ExplainQueryText)(e, t), _ExplainPropertyText = Module._ExplainPropertyText = (e, t, r2) => (_ExplainPropertyText = Module._ExplainPropertyText = wasmExports.ExplainPropertyText)(e, t, r2), _ExplainQueryParameters = Module._ExplainQueryParameters = (e, t, r2) => (_ExplainQueryParameters = Module._ExplainQueryParameters = wasmExports.ExplainQueryParameters)(e, t, r2), _get_func_namespace = Module._get_func_namespace = (e) => (_get_func_namespace = Module._get_func_namespace = wasmExports.get_func_namespace)(e), _get_rel_type_id = Module._get_rel_type_id = (e) => (_get_rel_type_id = Module._get_rel_type_id = wasmExports.get_rel_type_id)(e), _set_config_option = Module._set_config_option = (e, t, r2, a, o3, s2, l3, _2) => (_set_config_option = Module._set_config_option = wasmExports.set_config_option)(e, t, r2, a, o3, s2, l3, _2), _pg_any_to_server = Module._pg_any_to_server = (e, t, r2) => (_pg_any_to_server = Module._pg_any_to_server = wasmExports.pg_any_to_server)(e, t, r2), _DirectFunctionCall4Coll = Module._DirectFunctionCall4Coll = (e, t, r2, a, o3, s2) => (_DirectFunctionCall4Coll = Module._DirectFunctionCall4Coll = wasmExports.DirectFunctionCall4Coll)(e, t, r2, a, o3, s2), _list_delete_cell = Module._list_delete_cell = (e, t) => (_list_delete_cell = Module._list_delete_cell = wasmExports.list_delete_cell)(e, t), _GetForeignDataWrapper = Module._GetForeignDataWrapper = (e) => (_GetForeignDataWrapper = Module._GetForeignDataWrapper = wasmExports.GetForeignDataWrapper)(e), _CreateExprContext = Module._CreateExprContext = (e) => (_CreateExprContext = Module._CreateExprContext = wasmExports.CreateExprContext)(e), _EnsurePortalSnapshotExists = Module._EnsurePortalSnapshotExists = () => (_EnsurePortalSnapshotExists = Module._EnsurePortalSnapshotExists = wasmExports.EnsurePortalSnapshotExists)(), _CheckIndexCompatible = Module._CheckIndexCompatible = (e, t, r2, a) => (_CheckIndexCompatible = Module._CheckIndexCompatible = wasmExports.CheckIndexCompatible)(e, t, r2, a), _pgstat_count_truncate = Module._pgstat_count_truncate = (e) => (_pgstat_count_truncate = Module._pgstat_count_truncate = wasmExports.pgstat_count_truncate)(e), _SPI_connect = Module._SPI_connect = () => (_SPI_connect = Module._SPI_connect = wasmExports.SPI_connect)(), _SPI_exec = Module._SPI_exec = (e, t) => (_SPI_exec = Module._SPI_exec = wasmExports.SPI_exec)(e, t), _SPI_execute = Module._SPI_execute = (e, t, r2) => (_SPI_execute = Module._SPI_execute = wasmExports.SPI_execute)(e, t, r2), _SPI_getvalue = Module._SPI_getvalue = (e, t, r2) => (_SPI_getvalue = Module._SPI_getvalue = wasmExports.SPI_getvalue)(e, t, r2), _generate_operator_clause = Module._generate_operator_clause = (e, t, r2, a, o3, s2) => (_generate_operator_clause = Module._generate_operator_clause = wasmExports.generate_operator_clause)(e, t, r2, a, o3, s2), _SPI_finish = Module._SPI_finish = () => (_SPI_finish = Module._SPI_finish = wasmExports.SPI_finish)(), _CreateTransientRelDestReceiver = Module._CreateTransientRelDestReceiver = (e) => (_CreateTransientRelDestReceiver = Module._CreateTransientRelDestReceiver = wasmExports.CreateTransientRelDestReceiver)(e), _MemoryContextSetIdentifier = Module._MemoryContextSetIdentifier = (e, t) => (_MemoryContextSetIdentifier = Module._MemoryContextSetIdentifier = wasmExports.MemoryContextSetIdentifier)(e, t), _checkExprHasSubLink = Module._checkExprHasSubLink = (e) => (_checkExprHasSubLink = Module._checkExprHasSubLink = wasmExports.checkExprHasSubLink)(e), _SetTuplestoreDestReceiverParams = Module._SetTuplestoreDestReceiverParams = (e, t, r2, a, o3, s2) => (_SetTuplestoreDestReceiverParams = Module._SetTuplestoreDestReceiverParams = wasmExports.SetTuplestoreDestReceiverParams)(e, t, r2, a, o3, s2), _tuplestore_rescan = Module._tuplestore_rescan = (e) => (_tuplestore_rescan = Module._tuplestore_rescan = wasmExports.tuplestore_rescan)(e), _MemoryContextDeleteChildren = Module._MemoryContextDeleteChildren = (e) => (_MemoryContextDeleteChildren = Module._MemoryContextDeleteChildren = wasmExports.MemoryContextDeleteChildren)(e), _ReleaseCachedPlan = Module._ReleaseCachedPlan = (e, t) => (_ReleaseCachedPlan = Module._ReleaseCachedPlan = wasmExports.ReleaseCachedPlan)(e, t), _bms_equal = Module._bms_equal = (e, t) => (_bms_equal = Module._bms_equal = wasmExports.bms_equal)(e, t), _nextval = Module._nextval = (e) => (_nextval = Module._nextval = wasmExports.nextval)(e), _textToQualifiedNameList = Module._textToQualifiedNameList = (e) => (_textToQualifiedNameList = Module._textToQualifiedNameList = wasmExports.textToQualifiedNameList)(e), _defGetStreamingMode = Module._defGetStreamingMode = (e) => (_defGetStreamingMode = Module._defGetStreamingMode = wasmExports.defGetStreamingMode)(e), _pg_lsn_in = Module._pg_lsn_in = (e) => (_pg_lsn_in = Module._pg_lsn_in = wasmExports.pg_lsn_in)(e), _tuplestore_gettupleslot = Module._tuplestore_gettupleslot = (e, t, r2, a) => (_tuplestore_gettupleslot = Module._tuplestore_gettupleslot = wasmExports.tuplestore_gettupleslot)(e, t, r2, a), _list_delete = Module._list_delete = (e, t) => (_list_delete = Module._list_delete = wasmExports.list_delete)(e, t), _tuplestore_end = Module._tuplestore_end = (e) => (_tuplestore_end = Module._tuplestore_end = wasmExports.tuplestore_end)(e), _quote_literal_cstr = Module._quote_literal_cstr = (e) => (_quote_literal_cstr = Module._quote_literal_cstr = wasmExports.quote_literal_cstr)(e), _contain_mutable_functions = Module._contain_mutable_functions = (e) => (_contain_mutable_functions = Module._contain_mutable_functions = wasmExports.contain_mutable_functions)(e), _ExecuteTruncateGuts = Module._ExecuteTruncateGuts = (e, t, r2, a, o3, s2) => (_ExecuteTruncateGuts = Module._ExecuteTruncateGuts = wasmExports.ExecuteTruncateGuts)(e, t, r2, a, o3, s2), _bms_make_singleton = Module._bms_make_singleton = (e) => (_bms_make_singleton = Module._bms_make_singleton = wasmExports.bms_make_singleton)(e), _tuplestore_puttupleslot = Module._tuplestore_puttupleslot = (e, t) => (_tuplestore_puttupleslot = Module._tuplestore_puttupleslot = wasmExports.tuplestore_puttupleslot)(e, t), _tuplestore_begin_heap = Module._tuplestore_begin_heap = (e, t, r2) => (_tuplestore_begin_heap = Module._tuplestore_begin_heap = wasmExports.tuplestore_begin_heap)(e, t, r2), _ExecForceStoreHeapTuple = Module._ExecForceStoreHeapTuple = (e, t, r2) => (_ExecForceStoreHeapTuple = Module._ExecForceStoreHeapTuple = wasmExports.ExecForceStoreHeapTuple)(e, t, r2), _strtod = Module._strtod = (e, t) => (_strtod = Module._strtod = wasmExports.strtod)(e, t), _plain_crypt_verify = Module._plain_crypt_verify = (e, t, r2, a) => (_plain_crypt_verify = Module._plain_crypt_verify = wasmExports.plain_crypt_verify)(e, t, r2, a), _ProcessConfigFile = Module._ProcessConfigFile = (e) => (_ProcessConfigFile = Module._ProcessConfigFile = wasmExports.ProcessConfigFile)(e), _ExecReScan = Module._ExecReScan = (e) => (_ExecReScan = Module._ExecReScan = wasmExports.ExecReScan)(e), _ExecAsyncResponse = Module._ExecAsyncResponse = (e) => (_ExecAsyncResponse = Module._ExecAsyncResponse = wasmExports.ExecAsyncResponse)(e), _ExecAsyncRequestDone = Module._ExecAsyncRequestDone = (e, t) => (_ExecAsyncRequestDone = Module._ExecAsyncRequestDone = wasmExports.ExecAsyncRequestDone)(e, t), _ExecAsyncRequestPending = Module._ExecAsyncRequestPending = (e) => (_ExecAsyncRequestPending = Module._ExecAsyncRequestPending = wasmExports.ExecAsyncRequestPending)(e), _ExprEvalPushStep = Module._ExprEvalPushStep = (e, t) => (_ExprEvalPushStep = Module._ExprEvalPushStep = wasmExports.ExprEvalPushStep)(e, t), _ExecInitExprWithParams = Module._ExecInitExprWithParams = (e, t) => (_ExecInitExprWithParams = Module._ExecInitExprWithParams = wasmExports.ExecInitExprWithParams)(e, t), _ExecInitExprList = Module._ExecInitExprList = (e, t) => (_ExecInitExprList = Module._ExecInitExprList = wasmExports.ExecInitExprList)(e, t), _MakeExpandedObjectReadOnlyInternal = Module._MakeExpandedObjectReadOnlyInternal = (e) => (_MakeExpandedObjectReadOnlyInternal = Module._MakeExpandedObjectReadOnlyInternal = wasmExports.MakeExpandedObjectReadOnlyInternal)(e), _tuplesort_puttupleslot = Module._tuplesort_puttupleslot = (e, t) => (_tuplesort_puttupleslot = Module._tuplesort_puttupleslot = wasmExports.tuplesort_puttupleslot)(e, t), _ArrayGetNItems = Module._ArrayGetNItems = (e, t) => (_ArrayGetNItems = Module._ArrayGetNItems = wasmExports.ArrayGetNItems)(e, t), _expanded_record_fetch_tupdesc = Module._expanded_record_fetch_tupdesc = (e) => (_expanded_record_fetch_tupdesc = Module._expanded_record_fetch_tupdesc = wasmExports.expanded_record_fetch_tupdesc)(e), _expanded_record_fetch_field = Module._expanded_record_fetch_field = (e, t, r2) => (_expanded_record_fetch_field = Module._expanded_record_fetch_field = wasmExports.expanded_record_fetch_field)(e, t, r2), _JsonbValueToJsonb = Module._JsonbValueToJsonb = (e) => (_JsonbValueToJsonb = Module._JsonbValueToJsonb = wasmExports.JsonbValueToJsonb)(e), _boolout = Module._boolout = (e) => (_boolout = Module._boolout = wasmExports.boolout)(e), _lookup_rowtype_tupdesc_domain = Module._lookup_rowtype_tupdesc_domain = (e, t, r2) => (_lookup_rowtype_tupdesc_domain = Module._lookup_rowtype_tupdesc_domain = wasmExports.lookup_rowtype_tupdesc_domain)(e, t, r2), _MemoryContextGetParent = Module._MemoryContextGetParent = (e) => (_MemoryContextGetParent = Module._MemoryContextGetParent = wasmExports.MemoryContextGetParent)(e), _DeleteExpandedObject = Module._DeleteExpandedObject = (e) => (_DeleteExpandedObject = Module._DeleteExpandedObject = wasmExports.DeleteExpandedObject)(e), _ExecFindJunkAttributeInTlist = Module._ExecFindJunkAttributeInTlist = (e, t) => (_ExecFindJunkAttributeInTlist = Module._ExecFindJunkAttributeInTlist = wasmExports.ExecFindJunkAttributeInTlist)(e, t), _standard_ExecutorStart = Module._standard_ExecutorStart = (e, t) => (_standard_ExecutorStart = Module._standard_ExecutorStart = wasmExports.standard_ExecutorStart)(e, t), _standard_ExecutorRun = Module._standard_ExecutorRun = (e, t, r2, a) => (_standard_ExecutorRun = Module._standard_ExecutorRun = wasmExports.standard_ExecutorRun)(e, t, r2, a), _standard_ExecutorFinish = Module._standard_ExecutorFinish = (e) => (_standard_ExecutorFinish = Module._standard_ExecutorFinish = wasmExports.standard_ExecutorFinish)(e), _standard_ExecutorEnd = Module._standard_ExecutorEnd = (e) => (_standard_ExecutorEnd = Module._standard_ExecutorEnd = wasmExports.standard_ExecutorEnd)(e), _InstrAlloc = Module._InstrAlloc = (e, t, r2) => (_InstrAlloc = Module._InstrAlloc = wasmExports.InstrAlloc)(e, t, r2), _MakeTupleTableSlot = Module._MakeTupleTableSlot = (e, t) => (_MakeTupleTableSlot = Module._MakeTupleTableSlot = wasmExports.MakeTupleTableSlot)(e, t), _get_typlenbyval = Module._get_typlenbyval = (e, t, r2) => (_get_typlenbyval = Module._get_typlenbyval = wasmExports.get_typlenbyval)(e, t, r2), _bms_num_members = Module._bms_num_members = (e) => (_bms_num_members = Module._bms_num_members = wasmExports.bms_num_members)(e), _InputFunctionCall = Module._InputFunctionCall = (e, t, r2, a) => (_InputFunctionCall = Module._InputFunctionCall = wasmExports.InputFunctionCall)(e, t, r2, a), _FreeExprContext = Module._FreeExprContext = (e, t) => (_FreeExprContext = Module._FreeExprContext = wasmExports.FreeExprContext)(e, t), _ExecOpenScanRelation = Module._ExecOpenScanRelation = (e, t, r2) => (_ExecOpenScanRelation = Module._ExecOpenScanRelation = wasmExports.ExecOpenScanRelation)(e, t, r2), _bms_intersect = Module._bms_intersect = (e, t) => (_bms_intersect = Module._bms_intersect = wasmExports.bms_intersect)(e, t), _ExecGetReturningSlot = Module._ExecGetReturningSlot = (e, t) => (_ExecGetReturningSlot = Module._ExecGetReturningSlot = wasmExports.ExecGetReturningSlot)(e, t), _ExecGetResultRelCheckAsUser = Module._ExecGetResultRelCheckAsUser = (e, t) => (_ExecGetResultRelCheckAsUser = Module._ExecGetResultRelCheckAsUser = wasmExports.ExecGetResultRelCheckAsUser)(e, t), _get_call_expr_argtype = Module._get_call_expr_argtype = (e, t) => (_get_call_expr_argtype = Module._get_call_expr_argtype = wasmExports.get_call_expr_argtype)(e, t), _tuplestore_clear = Module._tuplestore_clear = (e) => (_tuplestore_clear = Module._tuplestore_clear = wasmExports.tuplestore_clear)(e), _InstrUpdateTupleCount = Module._InstrUpdateTupleCount = (e, t) => (_InstrUpdateTupleCount = Module._InstrUpdateTupleCount = wasmExports.InstrUpdateTupleCount)(e, t), _tuplesort_begin_heap = Module._tuplesort_begin_heap = (e, t, r2, a, o3, s2, l3, _2, n) => (_tuplesort_begin_heap = Module._tuplesort_begin_heap = wasmExports.tuplesort_begin_heap)(e, t, r2, a, o3, s2, l3, _2, n), _tuplesort_gettupleslot = Module._tuplesort_gettupleslot = (e, t, r2, a, o3) => (_tuplesort_gettupleslot = Module._tuplesort_gettupleslot = wasmExports.tuplesort_gettupleslot)(e, t, r2, a, o3), _AddWaitEventToSet = Module._AddWaitEventToSet = (e, t, r2, a, o3) => (_AddWaitEventToSet = Module._AddWaitEventToSet = wasmExports.AddWaitEventToSet)(e, t, r2, a, o3), _GetNumRegisteredWaitEvents = Module._GetNumRegisteredWaitEvents = (e) => (_GetNumRegisteredWaitEvents = Module._GetNumRegisteredWaitEvents = wasmExports.GetNumRegisteredWaitEvents)(e), _get_attstatsslot = Module._get_attstatsslot = (e, t, r2, a, o3) => (_get_attstatsslot = Module._get_attstatsslot = wasmExports.get_attstatsslot)(e, t, r2, a, o3), _free_attstatsslot = Module._free_attstatsslot = (e) => (_free_attstatsslot = Module._free_attstatsslot = wasmExports.free_attstatsslot)(e), _tuplesort_reset = Module._tuplesort_reset = (e) => (_tuplesort_reset = Module._tuplesort_reset = wasmExports.tuplesort_reset)(e), _pairingheap_first = Module._pairingheap_first = (e) => (_pairingheap_first = Module._pairingheap_first = wasmExports.pairingheap_first)(e), _bms_nonempty_difference = Module._bms_nonempty_difference = (e, t) => (_bms_nonempty_difference = Module._bms_nonempty_difference = wasmExports.bms_nonempty_difference)(e, t), _SPI_connect_ext = Module._SPI_connect_ext = (e) => (_SPI_connect_ext = Module._SPI_connect_ext = wasmExports.SPI_connect_ext)(e), _SPI_commit = Module._SPI_commit = () => (_SPI_commit = Module._SPI_commit = wasmExports.SPI_commit)(), _CopyErrorData = Module._CopyErrorData = () => (_CopyErrorData = Module._CopyErrorData = wasmExports.CopyErrorData)(), _ReThrowError = Module._ReThrowError = (e) => (_ReThrowError = Module._ReThrowError = wasmExports.ReThrowError)(e), _SPI_commit_and_chain = Module._SPI_commit_and_chain = () => (_SPI_commit_and_chain = Module._SPI_commit_and_chain = wasmExports.SPI_commit_and_chain)(), _SPI_rollback = Module._SPI_rollback = () => (_SPI_rollback = Module._SPI_rollback = wasmExports.SPI_rollback)(), _SPI_rollback_and_chain = Module._SPI_rollback_and_chain = () => (_SPI_rollback_and_chain = Module._SPI_rollback_and_chain = wasmExports.SPI_rollback_and_chain)(), _SPI_freetuptable = Module._SPI_freetuptable = (e) => (_SPI_freetuptable = Module._SPI_freetuptable = wasmExports.SPI_freetuptable)(e), _SPI_execute_extended = Module._SPI_execute_extended = (e, t) => (_SPI_execute_extended = Module._SPI_execute_extended = wasmExports.SPI_execute_extended)(e, t), _SPI_execute_plan = Module._SPI_execute_plan = (e, t, r2, a, o3) => (_SPI_execute_plan = Module._SPI_execute_plan = wasmExports.SPI_execute_plan)(e, t, r2, a, o3), _SPI_execp = Module._SPI_execp = (e, t, r2, a) => (_SPI_execp = Module._SPI_execp = wasmExports.SPI_execp)(e, t, r2, a), _SPI_execute_plan_extended = Module._SPI_execute_plan_extended = (e, t) => (_SPI_execute_plan_extended = Module._SPI_execute_plan_extended = wasmExports.SPI_execute_plan_extended)(e, t), _SPI_execute_plan_with_paramlist = Module._SPI_execute_plan_with_paramlist = (e, t, r2, a) => (_SPI_execute_plan_with_paramlist = Module._SPI_execute_plan_with_paramlist = wasmExports.SPI_execute_plan_with_paramlist)(e, t, r2, a), _SPI_prepare = Module._SPI_prepare = (e, t, r2) => (_SPI_prepare = Module._SPI_prepare = wasmExports.SPI_prepare)(e, t, r2), _SPI_prepare_extended = Module._SPI_prepare_extended = (e, t) => (_SPI_prepare_extended = Module._SPI_prepare_extended = wasmExports.SPI_prepare_extended)(e, t), _SPI_keepplan = Module._SPI_keepplan = (e) => (_SPI_keepplan = Module._SPI_keepplan = wasmExports.SPI_keepplan)(e), _SPI_freeplan = Module._SPI_freeplan = (e) => (_SPI_freeplan = Module._SPI_freeplan = wasmExports.SPI_freeplan)(e), _SPI_copytuple = Module._SPI_copytuple = (e) => (_SPI_copytuple = Module._SPI_copytuple = wasmExports.SPI_copytuple)(e), _SPI_returntuple = Module._SPI_returntuple = (e, t) => (_SPI_returntuple = Module._SPI_returntuple = wasmExports.SPI_returntuple)(e, t), _SPI_fnumber = Module._SPI_fnumber = (e, t) => (_SPI_fnumber = Module._SPI_fnumber = wasmExports.SPI_fnumber)(e, t), _SPI_fname = Module._SPI_fname = (e, t) => (_SPI_fname = Module._SPI_fname = wasmExports.SPI_fname)(e, t), _SPI_getbinval = Module._SPI_getbinval = (e, t, r2, a) => (_SPI_getbinval = Module._SPI_getbinval = wasmExports.SPI_getbinval)(e, t, r2, a), _SPI_gettype = Module._SPI_gettype = (e, t) => (_SPI_gettype = Module._SPI_gettype = wasmExports.SPI_gettype)(e, t), _SPI_gettypeid = Module._SPI_gettypeid = (e, t) => (_SPI_gettypeid = Module._SPI_gettypeid = wasmExports.SPI_gettypeid)(e, t), _SPI_getrelname = Module._SPI_getrelname = (e) => (_SPI_getrelname = Module._SPI_getrelname = wasmExports.SPI_getrelname)(e), _SPI_palloc = Module._SPI_palloc = (e) => (_SPI_palloc = Module._SPI_palloc = wasmExports.SPI_palloc)(e), _SPI_datumTransfer = Module._SPI_datumTransfer = (e, t, r2) => (_SPI_datumTransfer = Module._SPI_datumTransfer = wasmExports.SPI_datumTransfer)(e, t, r2), _datumTransfer = Module._datumTransfer = (e, t, r2) => (_datumTransfer = Module._datumTransfer = wasmExports.datumTransfer)(e, t, r2), _SPI_cursor_open_with_paramlist = Module._SPI_cursor_open_with_paramlist = (e, t, r2, a) => (_SPI_cursor_open_with_paramlist = Module._SPI_cursor_open_with_paramlist = wasmExports.SPI_cursor_open_with_paramlist)(e, t, r2, a), _SPI_cursor_parse_open = Module._SPI_cursor_parse_open = (e, t, r2) => (_SPI_cursor_parse_open = Module._SPI_cursor_parse_open = wasmExports.SPI_cursor_parse_open)(e, t, r2), _SPI_cursor_find = Module._SPI_cursor_find = (e) => (_SPI_cursor_find = Module._SPI_cursor_find = wasmExports.SPI_cursor_find)(e), _SPI_cursor_fetch = Module._SPI_cursor_fetch = (e, t, r2) => (_SPI_cursor_fetch = Module._SPI_cursor_fetch = wasmExports.SPI_cursor_fetch)(e, t, r2), _SPI_scroll_cursor_fetch = Module._SPI_scroll_cursor_fetch = (e, t, r2) => (_SPI_scroll_cursor_fetch = Module._SPI_scroll_cursor_fetch = wasmExports.SPI_scroll_cursor_fetch)(e, t, r2), _SPI_scroll_cursor_move = Module._SPI_scroll_cursor_move = (e, t, r2) => (_SPI_scroll_cursor_move = Module._SPI_scroll_cursor_move = wasmExports.SPI_scroll_cursor_move)(e, t, r2), _SPI_cursor_close = Module._SPI_cursor_close = (e) => (_SPI_cursor_close = Module._SPI_cursor_close = wasmExports.SPI_cursor_close)(e), _SPI_plan_is_valid = Module._SPI_plan_is_valid = (e) => (_SPI_plan_is_valid = Module._SPI_plan_is_valid = wasmExports.SPI_plan_is_valid)(e), _SPI_result_code_string = Module._SPI_result_code_string = (e) => (_SPI_result_code_string = Module._SPI_result_code_string = wasmExports.SPI_result_code_string)(e), _SPI_plan_get_plan_sources = Module._SPI_plan_get_plan_sources = (e) => (_SPI_plan_get_plan_sources = Module._SPI_plan_get_plan_sources = wasmExports.SPI_plan_get_plan_sources)(e), _SPI_plan_get_cached_plan = Module._SPI_plan_get_cached_plan = (e) => (_SPI_plan_get_cached_plan = Module._SPI_plan_get_cached_plan = wasmExports.SPI_plan_get_cached_plan)(e), _SPI_register_relation = Module._SPI_register_relation = (e) => (_SPI_register_relation = Module._SPI_register_relation = wasmExports.SPI_register_relation)(e), _create_queryEnv = Module._create_queryEnv = () => (_create_queryEnv = Module._create_queryEnv = wasmExports.create_queryEnv)(), _register_ENR = Module._register_ENR = (e, t) => (_register_ENR = Module._register_ENR = wasmExports.register_ENR)(e, t), _SPI_register_trigger_data = Module._SPI_register_trigger_data = (e) => (_SPI_register_trigger_data = Module._SPI_register_trigger_data = wasmExports.SPI_register_trigger_data)(e), _tuplestore_tuple_count = Module._tuplestore_tuple_count = (e) => (_tuplestore_tuple_count = Module._tuplestore_tuple_count = wasmExports.tuplestore_tuple_count)(e), _GetUserMapping = Module._GetUserMapping = (e, t) => (_GetUserMapping = Module._GetUserMapping = wasmExports.GetUserMapping)(e, t), _GetForeignTable = Module._GetForeignTable = (e) => (_GetForeignTable = Module._GetForeignTable = wasmExports.GetForeignTable)(e), _GetForeignColumnOptions = Module._GetForeignColumnOptions = (e, t) => (_GetForeignColumnOptions = Module._GetForeignColumnOptions = wasmExports.GetForeignColumnOptions)(e, t), _initClosestMatch = Module._initClosestMatch = (e, t, r2) => (_initClosestMatch = Module._initClosestMatch = wasmExports.initClosestMatch)(e, t, r2), _updateClosestMatch = Module._updateClosestMatch = (e, t) => (_updateClosestMatch = Module._updateClosestMatch = wasmExports.updateClosestMatch)(e, t), _getClosestMatch = Module._getClosestMatch = (e) => (_getClosestMatch = Module._getClosestMatch = wasmExports.getClosestMatch)(e), _GetExistingLocalJoinPath = Module._GetExistingLocalJoinPath = (e) => (_GetExistingLocalJoinPath = Module._GetExistingLocalJoinPath = wasmExports.GetExistingLocalJoinPath)(e), _bloom_create = Module._bloom_create = (e, t, r2) => (_bloom_create = Module._bloom_create = wasmExports.bloom_create)(e, t, r2), _bloom_free = Module._bloom_free = (e) => (_bloom_free = Module._bloom_free = wasmExports.bloom_free)(e), _bloom_add_element = Module._bloom_add_element = (e, t, r2) => (_bloom_add_element = Module._bloom_add_element = wasmExports.bloom_add_element)(e, t, r2), _bloom_lacks_element = Module._bloom_lacks_element = (e, t, r2) => (_bloom_lacks_element = Module._bloom_lacks_element = wasmExports.bloom_lacks_element)(e, t, r2), _bloom_prop_bits_set = Module._bloom_prop_bits_set = (e) => (_bloom_prop_bits_set = Module._bloom_prop_bits_set = wasmExports.bloom_prop_bits_set)(e), _gai_strerror = Module._gai_strerror = (e) => (_gai_strerror = Module._gai_strerror = wasmExports.gai_strerror)(e), _socket = Module._socket = (e, t, r2) => (_socket = Module._socket = wasmExports.socket)(e, t, r2), _connect = Module._connect = (e, t, r2) => (_connect = Module._connect = wasmExports.connect)(e, t, r2), _send = Module._send = (e, t, r2, a) => (_send = Module._send = wasmExports.send)(e, t, r2, a), _recv = Module._recv = (e, t, r2, a) => (_recv = Module._recv = wasmExports.recv)(e, t, r2, a), _be_lo_unlink = Module._be_lo_unlink = (e) => (_be_lo_unlink = Module._be_lo_unlink = wasmExports.be_lo_unlink)(e), _text_to_cstring_buffer = Module._text_to_cstring_buffer = (e, t, r2) => (_text_to_cstring_buffer = Module._text_to_cstring_buffer = wasmExports.text_to_cstring_buffer)(e, t, r2), _feof = Module._feof = (e) => (_feof = Module._feof = wasmExports.feof)(e), _pg_mb2wchar_with_len = Module._pg_mb2wchar_with_len = (e, t, r2) => (_pg_mb2wchar_with_len = Module._pg_mb2wchar_with_len = wasmExports.pg_mb2wchar_with_len)(e, t, r2), _pg_regcomp = Module._pg_regcomp = (e, t, r2, a, o3) => (_pg_regcomp = Module._pg_regcomp = wasmExports.pg_regcomp)(e, t, r2, a, o3), _pg_regerror = Module._pg_regerror = (e, t, r2, a) => (_pg_regerror = Module._pg_regerror = wasmExports.pg_regerror)(e, t, r2, a), _strcat = Module._strcat = (e, t) => (_strcat = Module._strcat = wasmExports.strcat)(e, t), _setsockopt = Module._setsockopt = (e, t, r2, a, o3) => (_setsockopt = Module._setsockopt = wasmExports.setsockopt)(e, t, r2, a, o3), _pq_sendtext = Module._pq_sendtext = (e, t, r2) => (_pq_sendtext = Module._pq_sendtext = wasmExports.pq_sendtext)(e, t, r2), _pq_sendfloat4 = Module._pq_sendfloat4 = (e, t) => (_pq_sendfloat4 = Module._pq_sendfloat4 = wasmExports.pq_sendfloat4)(e, t), _pq_sendfloat8 = Module._pq_sendfloat8 = (e, t) => (_pq_sendfloat8 = Module._pq_sendfloat8 = wasmExports.pq_sendfloat8)(e, t), _pq_begintypsend = Module._pq_begintypsend = (e) => (_pq_begintypsend = Module._pq_begintypsend = wasmExports.pq_begintypsend)(e), _pq_endtypsend = Module._pq_endtypsend = (e) => (_pq_endtypsend = Module._pq_endtypsend = wasmExports.pq_endtypsend)(e), _pq_getmsgfloat4 = Module._pq_getmsgfloat4 = (e) => (_pq_getmsgfloat4 = Module._pq_getmsgfloat4 = wasmExports.pq_getmsgfloat4)(e), _pq_getmsgfloat8 = Module._pq_getmsgfloat8 = (e) => (_pq_getmsgfloat8 = Module._pq_getmsgfloat8 = wasmExports.pq_getmsgfloat8)(e), _pq_getmsgtext = Module._pq_getmsgtext = (e, t, r2) => (_pq_getmsgtext = Module._pq_getmsgtext = wasmExports.pq_getmsgtext)(e, t, r2), _pg_strtoint32 = Module._pg_strtoint32 = (e) => (_pg_strtoint32 = Module._pg_strtoint32 = wasmExports.pg_strtoint32)(e), _bms_membership = Module._bms_membership = (e) => (_bms_membership = Module._bms_membership = wasmExports.bms_membership)(e), _list_make5_impl = Module._list_make5_impl = (e, t, r2, a, o3, s2) => (_list_make5_impl = Module._list_make5_impl = wasmExports.list_make5_impl)(e, t, r2, a, o3, s2), _lappend_xid = Module._lappend_xid = (e, t) => (_lappend_xid = Module._lappend_xid = wasmExports.lappend_xid)(e, t), _list_insert_nth = Module._list_insert_nth = (e, t, r2) => (_list_insert_nth = Module._list_insert_nth = wasmExports.list_insert_nth)(e, t, r2), _list_member_ptr = Module._list_member_ptr = (e, t) => (_list_member_ptr = Module._list_member_ptr = wasmExports.list_member_ptr)(e, t), _list_member_xid = Module._list_member_xid = (e, t) => (_list_member_xid = Module._list_member_xid = wasmExports.list_member_xid)(e, t), _list_append_unique_ptr = Module._list_append_unique_ptr = (e, t) => (_list_append_unique_ptr = Module._list_append_unique_ptr = wasmExports.list_append_unique_ptr)(e, t), _make_opclause = Module._make_opclause = (e, t, r2, a, o3, s2, l3) => (_make_opclause = Module._make_opclause = wasmExports.make_opclause)(e, t, r2, a, o3, s2, l3), _exprIsLengthCoercion = Module._exprIsLengthCoercion = (e, t) => (_exprIsLengthCoercion = Module._exprIsLengthCoercion = wasmExports.exprIsLengthCoercion)(e, t), _fix_opfuncids = Module._fix_opfuncids = (e) => (_fix_opfuncids = Module._fix_opfuncids = wasmExports.fix_opfuncids)(e), _CleanQuerytext = Module._CleanQuerytext = (e, t, r2) => (_CleanQuerytext = Module._CleanQuerytext = wasmExports.CleanQuerytext)(e, t, r2), _EnableQueryId = Module._EnableQueryId = () => (_EnableQueryId = Module._EnableQueryId = wasmExports.EnableQueryId)(), _find_base_rel = Module._find_base_rel = (e, t) => (_find_base_rel = Module._find_base_rel = wasmExports.find_base_rel)(e, t), _add_path = Module._add_path = (e, t) => (_add_path = Module._add_path = wasmExports.add_path)(e, t), _pathkeys_contained_in = Module._pathkeys_contained_in = (e, t) => (_pathkeys_contained_in = Module._pathkeys_contained_in = wasmExports.pathkeys_contained_in)(e, t), _create_sort_path = Module._create_sort_path = (e, t, r2, a, o3) => (_create_sort_path = Module._create_sort_path = wasmExports.create_sort_path)(e, t, r2, a, o3), _set_baserel_size_estimates = Module._set_baserel_size_estimates = (e, t) => (_set_baserel_size_estimates = Module._set_baserel_size_estimates = wasmExports.set_baserel_size_estimates)(e, t), _clauselist_selectivity = Module._clauselist_selectivity = (e, t, r2, a, o3) => (_clauselist_selectivity = Module._clauselist_selectivity = wasmExports.clauselist_selectivity)(e, t, r2, a, o3), _get_tablespace_page_costs = Module._get_tablespace_page_costs = (e, t, r2) => (_get_tablespace_page_costs = Module._get_tablespace_page_costs = wasmExports.get_tablespace_page_costs)(e, t, r2), _cost_qual_eval = Module._cost_qual_eval = (e, t, r2) => (_cost_qual_eval = Module._cost_qual_eval = wasmExports.cost_qual_eval)(e, t, r2), _estimate_num_groups = Module._estimate_num_groups = (e, t, r2, a, o3) => (_estimate_num_groups = Module._estimate_num_groups = wasmExports.estimate_num_groups)(e, t, r2, a, o3), _cost_sort = Module._cost_sort = (e, t, r2, a, o3, s2, l3, _2, n) => (_cost_sort = Module._cost_sort = wasmExports.cost_sort)(e, t, r2, a, o3, s2, l3, _2, n), _get_sortgrouplist_exprs = Module._get_sortgrouplist_exprs = (e, t) => (_get_sortgrouplist_exprs = Module._get_sortgrouplist_exprs = wasmExports.get_sortgrouplist_exprs)(e, t), _make_restrictinfo = Module._make_restrictinfo = (e, t, r2, a, o3, s2, l3, _2, n, m2) => (_make_restrictinfo = Module._make_restrictinfo = wasmExports.make_restrictinfo)(e, t, r2, a, o3, s2, l3, _2, n, m2), _generate_implied_equalities_for_column = Module._generate_implied_equalities_for_column = (e, t, r2, a, o3) => (_generate_implied_equalities_for_column = Module._generate_implied_equalities_for_column = wasmExports.generate_implied_equalities_for_column)(e, t, r2, a, o3), _eclass_useful_for_merging = Module._eclass_useful_for_merging = (e, t, r2) => (_eclass_useful_for_merging = Module._eclass_useful_for_merging = wasmExports.eclass_useful_for_merging)(e, t, r2), _join_clause_is_movable_to = Module._join_clause_is_movable_to = (e, t) => (_join_clause_is_movable_to = Module._join_clause_is_movable_to = wasmExports.join_clause_is_movable_to)(e, t), _get_plan_rowmark = Module._get_plan_rowmark = (e, t) => (_get_plan_rowmark = Module._get_plan_rowmark = wasmExports.get_plan_rowmark)(e, t), _update_mergeclause_eclasses = Module._update_mergeclause_eclasses = (e, t) => (_update_mergeclause_eclasses = Module._update_mergeclause_eclasses = wasmExports.update_mergeclause_eclasses)(e, t), _find_join_rel = Module._find_join_rel = (e, t) => (_find_join_rel = Module._find_join_rel = wasmExports.find_join_rel)(e, t), _make_canonical_pathkey = Module._make_canonical_pathkey = (e, t, r2, a, o3) => (_make_canonical_pathkey = Module._make_canonical_pathkey = wasmExports.make_canonical_pathkey)(e, t, r2, a, o3), _get_sortgroupref_clause_noerr = Module._get_sortgroupref_clause_noerr = (e, t) => (_get_sortgroupref_clause_noerr = Module._get_sortgroupref_clause_noerr = wasmExports.get_sortgroupref_clause_noerr)(e, t), _extract_actual_clauses = Module._extract_actual_clauses = (e, t) => (_extract_actual_clauses = Module._extract_actual_clauses = wasmExports.extract_actual_clauses)(e, t), _change_plan_targetlist = Module._change_plan_targetlist = (e, t, r2) => (_change_plan_targetlist = Module._change_plan_targetlist = wasmExports.change_plan_targetlist)(e, t, r2), _make_foreignscan = Module._make_foreignscan = (e, t, r2, a, o3, s2, l3, _2) => (_make_foreignscan = Module._make_foreignscan = wasmExports.make_foreignscan)(e, t, r2, a, o3, s2, l3, _2), _tlist_member = Module._tlist_member = (e, t) => (_tlist_member = Module._tlist_member = wasmExports.tlist_member)(e, t), _pull_vars_of_level = Module._pull_vars_of_level = (e, t) => (_pull_vars_of_level = Module._pull_vars_of_level = wasmExports.pull_vars_of_level)(e, t), _IncrementVarSublevelsUp = Module._IncrementVarSublevelsUp = (e, t, r2) => (_IncrementVarSublevelsUp = Module._IncrementVarSublevelsUp = wasmExports.IncrementVarSublevelsUp)(e, t, r2), _standard_planner = Module._standard_planner = (e, t, r2, a) => (_standard_planner = Module._standard_planner = wasmExports.standard_planner)(e, t, r2, a), _get_relids_in_jointree = Module._get_relids_in_jointree = (e, t, r2) => (_get_relids_in_jointree = Module._get_relids_in_jointree = wasmExports.get_relids_in_jointree)(e, t, r2), _add_new_columns_to_pathtarget = Module._add_new_columns_to_pathtarget = (e, t) => (_add_new_columns_to_pathtarget = Module._add_new_columns_to_pathtarget = wasmExports.add_new_columns_to_pathtarget)(e, t), _get_agg_clause_costs = Module._get_agg_clause_costs = (e, t, r2) => (_get_agg_clause_costs = Module._get_agg_clause_costs = wasmExports.get_agg_clause_costs)(e, t, r2), _grouping_is_sortable = Module._grouping_is_sortable = (e) => (_grouping_is_sortable = Module._grouping_is_sortable = wasmExports.grouping_is_sortable)(e), _copy_pathtarget = Module._copy_pathtarget = (e) => (_copy_pathtarget = Module._copy_pathtarget = wasmExports.copy_pathtarget)(e), _create_projection_path = Module._create_projection_path = (e, t, r2, a) => (_create_projection_path = Module._create_projection_path = wasmExports.create_projection_path)(e, t, r2, a), _GetSysCacheHashValue = Module._GetSysCacheHashValue = (e, t, r2, a, o3) => (_GetSysCacheHashValue = Module._GetSysCacheHashValue = wasmExports.GetSysCacheHashValue)(e, t, r2, a, o3), _get_translated_update_targetlist = Module._get_translated_update_targetlist = (e, t, r2, a) => (_get_translated_update_targetlist = Module._get_translated_update_targetlist = wasmExports.get_translated_update_targetlist)(e, t, r2, a), _add_row_identity_var = Module._add_row_identity_var = (e, t, r2, a) => (_add_row_identity_var = Module._add_row_identity_var = wasmExports.add_row_identity_var)(e, t, r2, a), _get_rel_all_updated_cols = Module._get_rel_all_updated_cols = (e, t) => (_get_rel_all_updated_cols = Module._get_rel_all_updated_cols = wasmExports.get_rel_all_updated_cols)(e, t), _get_baserel_parampathinfo = Module._get_baserel_parampathinfo = (e, t, r2) => (_get_baserel_parampathinfo = Module._get_baserel_parampathinfo = wasmExports.get_baserel_parampathinfo)(e, t, r2), _create_foreignscan_path = Module._create_foreignscan_path = (e, t, r2, a, o3, s2, l3, _2, n, m2, p) => (_create_foreignscan_path = Module._create_foreignscan_path = wasmExports.create_foreignscan_path)(e, t, r2, a, o3, s2, l3, _2, n, m2, p), _create_foreign_join_path = Module._create_foreign_join_path = (e, t, r2, a, o3, s2, l3, _2, n, m2, p) => (_create_foreign_join_path = Module._create_foreign_join_path = wasmExports.create_foreign_join_path)(e, t, r2, a, o3, s2, l3, _2, n, m2, p), _create_foreign_upper_path = Module._create_foreign_upper_path = (e, t, r2, a, o3, s2, l3, _2, n, m2) => (_create_foreign_upper_path = Module._create_foreign_upper_path = wasmExports.create_foreign_upper_path)(e, t, r2, a, o3, s2, l3, _2, n, m2), _adjust_limit_rows_costs = Module._adjust_limit_rows_costs = (e, t, r2, a, o3) => (_adjust_limit_rows_costs = Module._adjust_limit_rows_costs = wasmExports.adjust_limit_rows_costs)(e, t, r2, a, o3), _add_to_flat_tlist = Module._add_to_flat_tlist = (e, t) => (_add_to_flat_tlist = Module._add_to_flat_tlist = wasmExports.add_to_flat_tlist)(e, t), _get_fn_expr_argtype = Module._get_fn_expr_argtype = (e, t) => (_get_fn_expr_argtype = Module._get_fn_expr_argtype = wasmExports.get_fn_expr_argtype)(e, t), _on_shmem_exit = Module._on_shmem_exit = (e, t) => (_on_shmem_exit = Module._on_shmem_exit = wasmExports.on_shmem_exit)(e, t), _SignalHandlerForConfigReload = Module._SignalHandlerForConfigReload = (e) => (_SignalHandlerForConfigReload = Module._SignalHandlerForConfigReload = wasmExports.SignalHandlerForConfigReload)(e), _SignalHandlerForShutdownRequest = Module._SignalHandlerForShutdownRequest = (e) => (_SignalHandlerForShutdownRequest = Module._SignalHandlerForShutdownRequest = wasmExports.SignalHandlerForShutdownRequest)(e), _procsignal_sigusr1_handler = Module._procsignal_sigusr1_handler = (e) => (_procsignal_sigusr1_handler = Module._procsignal_sigusr1_handler = wasmExports.procsignal_sigusr1_handler)(e), _RegisterBackgroundWorker = Module._RegisterBackgroundWorker = (e) => (_RegisterBackgroundWorker = Module._RegisterBackgroundWorker = wasmExports.RegisterBackgroundWorker)(e), _WaitForBackgroundWorkerStartup = Module._WaitForBackgroundWorkerStartup = (e, t) => (_WaitForBackgroundWorkerStartup = Module._WaitForBackgroundWorkerStartup = wasmExports.WaitForBackgroundWorkerStartup)(e, t), _GetConfigOption = Module._GetConfigOption = (e, t, r2) => (_GetConfigOption = Module._GetConfigOption = wasmExports.GetConfigOption)(e, t, r2), _fputc = Module._fputc = (e, t) => (_fputc = Module._fputc = wasmExports.fputc)(e, t), _toupper = Module._toupper = (e) => (_toupper = Module._toupper = wasmExports.toupper)(e), _pg_reg_getinitialstate = Module._pg_reg_getinitialstate = (e) => (_pg_reg_getinitialstate = Module._pg_reg_getinitialstate = wasmExports.pg_reg_getinitialstate)(e), _pg_reg_getfinalstate = Module._pg_reg_getfinalstate = (e) => (_pg_reg_getfinalstate = Module._pg_reg_getfinalstate = wasmExports.pg_reg_getfinalstate)(e), _pg_reg_getnumoutarcs = Module._pg_reg_getnumoutarcs = (e, t) => (_pg_reg_getnumoutarcs = Module._pg_reg_getnumoutarcs = wasmExports.pg_reg_getnumoutarcs)(e, t), _pg_reg_getoutarcs = Module._pg_reg_getoutarcs = (e, t, r2, a) => (_pg_reg_getoutarcs = Module._pg_reg_getoutarcs = wasmExports.pg_reg_getoutarcs)(e, t, r2, a), _pg_reg_getnumcolors = Module._pg_reg_getnumcolors = (e) => (_pg_reg_getnumcolors = Module._pg_reg_getnumcolors = wasmExports.pg_reg_getnumcolors)(e), _pg_reg_colorisbegin = Module._pg_reg_colorisbegin = (e, t) => (_pg_reg_colorisbegin = Module._pg_reg_colorisbegin = wasmExports.pg_reg_colorisbegin)(e, t), _pg_reg_colorisend = Module._pg_reg_colorisend = (e, t) => (_pg_reg_colorisend = Module._pg_reg_colorisend = wasmExports.pg_reg_colorisend)(e, t), _pg_reg_getnumcharacters = Module._pg_reg_getnumcharacters = (e, t) => (_pg_reg_getnumcharacters = Module._pg_reg_getnumcharacters = wasmExports.pg_reg_getnumcharacters)(e, t), _pg_reg_getcharacters = Module._pg_reg_getcharacters = (e, t, r2, a) => (_pg_reg_getcharacters = Module._pg_reg_getcharacters = wasmExports.pg_reg_getcharacters)(e, t, r2, a), _OutputPluginPrepareWrite = Module._OutputPluginPrepareWrite = (e, t) => (_OutputPluginPrepareWrite = Module._OutputPluginPrepareWrite = wasmExports.OutputPluginPrepareWrite)(e, t), _OutputPluginWrite = Module._OutputPluginWrite = (e, t) => (_OutputPluginWrite = Module._OutputPluginWrite = wasmExports.OutputPluginWrite)(e, t), _OutputPluginUpdateProgress = Module._OutputPluginUpdateProgress = (e, t) => (_OutputPluginUpdateProgress = Module._OutputPluginUpdateProgress = wasmExports.OutputPluginUpdateProgress)(e, t), _array_contains_nulls = Module._array_contains_nulls = (e) => (_array_contains_nulls = Module._array_contains_nulls = wasmExports.array_contains_nulls)(e), _replorigin_by_oid = Module._replorigin_by_oid = (e, t, r2) => (_replorigin_by_oid = Module._replorigin_by_oid = wasmExports.replorigin_by_oid)(e, t, r2), _logicalrep_write_begin = Module._logicalrep_write_begin = (e, t) => (_logicalrep_write_begin = Module._logicalrep_write_begin = wasmExports.logicalrep_write_begin)(e, t), _logicalrep_write_commit = Module._logicalrep_write_commit = (e, t, r2) => (_logicalrep_write_commit = Module._logicalrep_write_commit = wasmExports.logicalrep_write_commit)(e, t, r2), _logicalrep_write_begin_prepare = Module._logicalrep_write_begin_prepare = (e, t) => (_logicalrep_write_begin_prepare = Module._logicalrep_write_begin_prepare = wasmExports.logicalrep_write_begin_prepare)(e, t), _logicalrep_write_prepare = Module._logicalrep_write_prepare = (e, t, r2) => (_logicalrep_write_prepare = Module._logicalrep_write_prepare = wasmExports.logicalrep_write_prepare)(e, t, r2), _logicalrep_write_commit_prepared = Module._logicalrep_write_commit_prepared = (e, t, r2) => (_logicalrep_write_commit_prepared = Module._logicalrep_write_commit_prepared = wasmExports.logicalrep_write_commit_prepared)(e, t, r2), _logicalrep_write_rollback_prepared = Module._logicalrep_write_rollback_prepared = (e, t, r2, a) => (_logicalrep_write_rollback_prepared = Module._logicalrep_write_rollback_prepared = wasmExports.logicalrep_write_rollback_prepared)(e, t, r2, a), _logicalrep_write_stream_prepare = Module._logicalrep_write_stream_prepare = (e, t, r2) => (_logicalrep_write_stream_prepare = Module._logicalrep_write_stream_prepare = wasmExports.logicalrep_write_stream_prepare)(e, t, r2), _logicalrep_write_origin = Module._logicalrep_write_origin = (e, t, r2) => (_logicalrep_write_origin = Module._logicalrep_write_origin = wasmExports.logicalrep_write_origin)(e, t, r2), _logicalrep_write_insert = Module._logicalrep_write_insert = (e, t, r2, a, o3, s2) => (_logicalrep_write_insert = Module._logicalrep_write_insert = wasmExports.logicalrep_write_insert)(e, t, r2, a, o3, s2), _logicalrep_write_update = Module._logicalrep_write_update = (e, t, r2, a, o3, s2, l3) => (_logicalrep_write_update = Module._logicalrep_write_update = wasmExports.logicalrep_write_update)(e, t, r2, a, o3, s2, l3), _logicalrep_write_delete = Module._logicalrep_write_delete = (e, t, r2, a, o3, s2) => (_logicalrep_write_delete = Module._logicalrep_write_delete = wasmExports.logicalrep_write_delete)(e, t, r2, a, o3, s2), _logicalrep_write_truncate = Module._logicalrep_write_truncate = (e, t, r2, a, o3, s2) => (_logicalrep_write_truncate = Module._logicalrep_write_truncate = wasmExports.logicalrep_write_truncate)(e, t, r2, a, o3, s2), _logicalrep_write_message = Module._logicalrep_write_message = (e, t, r2, a, o3, s2, l3) => (_logicalrep_write_message = Module._logicalrep_write_message = wasmExports.logicalrep_write_message)(e, t, r2, a, o3, s2, l3), _logicalrep_write_rel = Module._logicalrep_write_rel = (e, t, r2, a) => (_logicalrep_write_rel = Module._logicalrep_write_rel = wasmExports.logicalrep_write_rel)(e, t, r2, a), _logicalrep_write_typ = Module._logicalrep_write_typ = (e, t, r2) => (_logicalrep_write_typ = Module._logicalrep_write_typ = wasmExports.logicalrep_write_typ)(e, t, r2), _logicalrep_write_stream_start = Module._logicalrep_write_stream_start = (e, t, r2) => (_logicalrep_write_stream_start = Module._logicalrep_write_stream_start = wasmExports.logicalrep_write_stream_start)(e, t, r2), _logicalrep_write_stream_stop = Module._logicalrep_write_stream_stop = (e) => (_logicalrep_write_stream_stop = Module._logicalrep_write_stream_stop = wasmExports.logicalrep_write_stream_stop)(e), _logicalrep_write_stream_commit = Module._logicalrep_write_stream_commit = (e, t, r2) => (_logicalrep_write_stream_commit = Module._logicalrep_write_stream_commit = wasmExports.logicalrep_write_stream_commit)(e, t, r2), _logicalrep_write_stream_abort = Module._logicalrep_write_stream_abort = (e, t, r2, a, o3, s2) => (_logicalrep_write_stream_abort = Module._logicalrep_write_stream_abort = wasmExports.logicalrep_write_stream_abort)(e, t, r2, a, o3, s2), _CacheRegisterRelcacheCallback = Module._CacheRegisterRelcacheCallback = (e, t) => (_CacheRegisterRelcacheCallback = Module._CacheRegisterRelcacheCallback = wasmExports.CacheRegisterRelcacheCallback)(e, t), _hash_seq_term = Module._hash_seq_term = (e) => (_hash_seq_term = Module._hash_seq_term = wasmExports.hash_seq_term)(e), _FreeErrorData = Module._FreeErrorData = (e) => (_FreeErrorData = Module._FreeErrorData = wasmExports.FreeErrorData)(e), _RelidByRelfilenumber = Module._RelidByRelfilenumber = (e, t) => (_RelidByRelfilenumber = Module._RelidByRelfilenumber = wasmExports.RelidByRelfilenumber)(e, t), _WaitLatchOrSocket = Module._WaitLatchOrSocket = (e, t, r2, a, o3) => (_WaitLatchOrSocket = Module._WaitLatchOrSocket = wasmExports.WaitLatchOrSocket)(e, t, r2, a, o3), _ProcessWalRcvInterrupts = Module._ProcessWalRcvInterrupts = () => (_ProcessWalRcvInterrupts = Module._ProcessWalRcvInterrupts = wasmExports.ProcessWalRcvInterrupts)(), _get_row_security_policies = Module._get_row_security_policies = (e, t, r2, a, o3, s2, l3) => (_get_row_security_policies = Module._get_row_security_policies = wasmExports.get_row_security_policies)(e, t, r2, a, o3, s2, l3), _hash_estimate_size = Module._hash_estimate_size = (e, t) => (_hash_estimate_size = Module._hash_estimate_size = wasmExports.hash_estimate_size)(e, t), _ShmemInitHash = Module._ShmemInitHash = (e, t, r2, a, o3) => (_ShmemInitHash = Module._ShmemInitHash = wasmExports.ShmemInitHash)(e, t, r2, a, o3), _LockBufHdr = Module._LockBufHdr = (e) => (_LockBufHdr = Module._LockBufHdr = wasmExports.LockBufHdr)(e), _EvictUnpinnedBuffer = Module._EvictUnpinnedBuffer = (e) => (_EvictUnpinnedBuffer = Module._EvictUnpinnedBuffer = wasmExports.EvictUnpinnedBuffer)(e), _have_free_buffer = Module._have_free_buffer = () => (_have_free_buffer = Module._have_free_buffer = wasmExports.have_free_buffer)(), _copy_file = Module._copy_file = (e, t) => (_copy_file = Module._copy_file = wasmExports.copy_file)(e, t), _AcquireExternalFD = Module._AcquireExternalFD = () => (_AcquireExternalFD = Module._AcquireExternalFD = wasmExports.AcquireExternalFD)(), _GetNamedDSMSegment = Module._GetNamedDSMSegment = (e, t, r2, a) => (_GetNamedDSMSegment = Module._GetNamedDSMSegment = wasmExports.GetNamedDSMSegment)(e, t, r2, a), _RequestAddinShmemSpace = Module._RequestAddinShmemSpace = (e) => (_RequestAddinShmemSpace = Module._RequestAddinShmemSpace = wasmExports.RequestAddinShmemSpace)(e), _poll = Module._poll = (e, t, r2) => (_poll = Module._poll = wasmExports.poll)(e, t, r2), _GetRunningTransactionData = Module._GetRunningTransactionData = () => (_GetRunningTransactionData = Module._GetRunningTransactionData = wasmExports.GetRunningTransactionData)(), _BackendXidGetPid = Module._BackendXidGetPid = (e) => (_BackendXidGetPid = Module._BackendXidGetPid = wasmExports.BackendXidGetPid)(e), _LWLockRegisterTranche = Module._LWLockRegisterTranche = (e, t) => (_LWLockRegisterTranche = Module._LWLockRegisterTranche = wasmExports.LWLockRegisterTranche)(e, t), _GetNamedLWLockTranche = Module._GetNamedLWLockTranche = (e) => (_GetNamedLWLockTranche = Module._GetNamedLWLockTranche = wasmExports.GetNamedLWLockTranche)(e), _LWLockNewTrancheId = Module._LWLockNewTrancheId = () => (_LWLockNewTrancheId = Module._LWLockNewTrancheId = wasmExports.LWLockNewTrancheId)(), _RequestNamedLWLockTranche = Module._RequestNamedLWLockTranche = (e, t) => (_RequestNamedLWLockTranche = Module._RequestNamedLWLockTranche = wasmExports.RequestNamedLWLockTranche)(e, t), _standard_ProcessUtility = Module._standard_ProcessUtility = (e, t, r2, a, o3, s2, l3, _2) => (_standard_ProcessUtility = Module._standard_ProcessUtility = wasmExports.standard_ProcessUtility)(e, t, r2, a, o3, s2, l3, _2), _lookup_ts_dictionary_cache = Module._lookup_ts_dictionary_cache = (e) => (_lookup_ts_dictionary_cache = Module._lookup_ts_dictionary_cache = wasmExports.lookup_ts_dictionary_cache)(e), _get_tsearch_config_filename = Module._get_tsearch_config_filename = (e, t) => (_get_tsearch_config_filename = Module._get_tsearch_config_filename = wasmExports.get_tsearch_config_filename)(e, t), _lowerstr = Module._lowerstr = (e) => (_lowerstr = Module._lowerstr = wasmExports.lowerstr)(e), _readstoplist = Module._readstoplist = (e, t, r2) => (_readstoplist = Module._readstoplist = wasmExports.readstoplist)(e, t, r2), _lowerstr_with_len = Module._lowerstr_with_len = (e, t) => (_lowerstr_with_len = Module._lowerstr_with_len = wasmExports.lowerstr_with_len)(e, t), _searchstoplist = Module._searchstoplist = (e, t) => (_searchstoplist = Module._searchstoplist = wasmExports.searchstoplist)(e, t), _tsearch_readline_begin = Module._tsearch_readline_begin = (e, t) => (_tsearch_readline_begin = Module._tsearch_readline_begin = wasmExports.tsearch_readline_begin)(e, t), _tsearch_readline = Module._tsearch_readline = (e) => (_tsearch_readline = Module._tsearch_readline = wasmExports.tsearch_readline)(e), _t_isspace = Module._t_isspace = (e) => (_t_isspace = Module._t_isspace = wasmExports.t_isspace)(e), _tsearch_readline_end = Module._tsearch_readline_end = (e) => (_tsearch_readline_end = Module._tsearch_readline_end = wasmExports.tsearch_readline_end)(e), _stringToQualifiedNameList = Module._stringToQualifiedNameList = (e, t) => (_stringToQualifiedNameList = Module._stringToQualifiedNameList = wasmExports.stringToQualifiedNameList)(e, t), _t_isdigit = Module._t_isdigit = (e) => (_t_isdigit = Module._t_isdigit = wasmExports.t_isdigit)(e), _t_isalnum = Module._t_isalnum = (e) => (_t_isalnum = Module._t_isalnum = wasmExports.t_isalnum)(e), _get_restriction_variable = Module._get_restriction_variable = (e, t, r2, a, o3, s2) => (_get_restriction_variable = Module._get_restriction_variable = wasmExports.get_restriction_variable)(e, t, r2, a, o3, s2), _MemoryContextAllocHuge = Module._MemoryContextAllocHuge = (e, t) => (_MemoryContextAllocHuge = Module._MemoryContextAllocHuge = wasmExports.MemoryContextAllocHuge)(e, t), _WaitEventExtensionNew = Module._WaitEventExtensionNew = (e) => (_WaitEventExtensionNew = Module._WaitEventExtensionNew = wasmExports.WaitEventExtensionNew)(e), _expand_array = Module._expand_array = (e, t, r2) => (_expand_array = Module._expand_array = wasmExports.expand_array)(e, t, r2), _arraycontsel = Module._arraycontsel = (e) => (_arraycontsel = Module._arraycontsel = wasmExports.arraycontsel)(e), _arraycontjoinsel = Module._arraycontjoinsel = (e) => (_arraycontjoinsel = Module._arraycontjoinsel = wasmExports.arraycontjoinsel)(e), _initArrayResult = Module._initArrayResult = (e, t, r2) => (_initArrayResult = Module._initArrayResult = wasmExports.initArrayResult)(e, t, r2), _array_create_iterator = Module._array_create_iterator = (e, t, r2) => (_array_create_iterator = Module._array_create_iterator = wasmExports.array_create_iterator)(e, t, r2), _array_iterate = Module._array_iterate = (e, t, r2) => (_array_iterate = Module._array_iterate = wasmExports.array_iterate)(e, t, r2), _ArrayGetIntegerTypmods = Module._ArrayGetIntegerTypmods = (e, t) => (_ArrayGetIntegerTypmods = Module._ArrayGetIntegerTypmods = wasmExports.ArrayGetIntegerTypmods)(e, t), _boolin = Module._boolin = (e) => (_boolin = Module._boolin = wasmExports.boolin)(e), _cash_cmp = Module._cash_cmp = (e) => (_cash_cmp = Module._cash_cmp = wasmExports.cash_cmp)(e), _int64_to_numeric = Module._int64_to_numeric = (e) => (_int64_to_numeric = Module._int64_to_numeric = wasmExports.int64_to_numeric)(e), _numeric_div = Module._numeric_div = (e) => (_numeric_div = Module._numeric_div = wasmExports.numeric_div)(e), _date_eq = Module._date_eq = (e) => (_date_eq = Module._date_eq = wasmExports.date_eq)(e), _date_lt = Module._date_lt = (e) => (_date_lt = Module._date_lt = wasmExports.date_lt)(e), _date_le = Module._date_le = (e) => (_date_le = Module._date_le = wasmExports.date_le)(e), _date_gt = Module._date_gt = (e) => (_date_gt = Module._date_gt = wasmExports.date_gt)(e), _date_ge = Module._date_ge = (e) => (_date_ge = Module._date_ge = wasmExports.date_ge)(e), _date_cmp = Module._date_cmp = (e) => (_date_cmp = Module._date_cmp = wasmExports.date_cmp)(e), _date_mi = Module._date_mi = (e) => (_date_mi = Module._date_mi = wasmExports.date_mi)(e), _time_eq = Module._time_eq = (e) => (_time_eq = Module._time_eq = wasmExports.time_eq)(e), _time_lt = Module._time_lt = (e) => (_time_lt = Module._time_lt = wasmExports.time_lt)(e), _time_le = Module._time_le = (e) => (_time_le = Module._time_le = wasmExports.time_le)(e), _time_gt = Module._time_gt = (e) => (_time_gt = Module._time_gt = wasmExports.time_gt)(e), _time_ge = Module._time_ge = (e) => (_time_ge = Module._time_ge = wasmExports.time_ge)(e), _time_cmp = Module._time_cmp = (e) => (_time_cmp = Module._time_cmp = wasmExports.time_cmp)(e), _time_mi_time = Module._time_mi_time = (e) => (_time_mi_time = Module._time_mi_time = wasmExports.time_mi_time)(e), _timetz_cmp = Module._timetz_cmp = (e) => (_timetz_cmp = Module._timetz_cmp = wasmExports.timetz_cmp)(e), _TransferExpandedObject = Module._TransferExpandedObject = (e, t) => (_TransferExpandedObject = Module._TransferExpandedObject = wasmExports.TransferExpandedObject)(e, t), _numeric_lt = Module._numeric_lt = (e) => (_numeric_lt = Module._numeric_lt = wasmExports.numeric_lt)(e), _numeric_ge = Module._numeric_ge = (e) => (_numeric_ge = Module._numeric_ge = wasmExports.numeric_ge)(e), _err_generic_string = Module._err_generic_string = (e, t) => (_err_generic_string = Module._err_generic_string = wasmExports.err_generic_string)(e, t), _domain_check = Module._domain_check = (e, t, r2, a, o3) => (_domain_check = Module._domain_check = wasmExports.domain_check)(e, t, r2, a, o3), _enum_lt = Module._enum_lt = (e) => (_enum_lt = Module._enum_lt = wasmExports.enum_lt)(e), _enum_le = Module._enum_le = (e) => (_enum_le = Module._enum_le = wasmExports.enum_le)(e), _enum_ge = Module._enum_ge = (e) => (_enum_ge = Module._enum_ge = wasmExports.enum_ge)(e), _enum_gt = Module._enum_gt = (e) => (_enum_gt = Module._enum_gt = wasmExports.enum_gt)(e), _enum_cmp = Module._enum_cmp = (e) => (_enum_cmp = Module._enum_cmp = wasmExports.enum_cmp)(e), _make_expanded_record_from_typeid = Module._make_expanded_record_from_typeid = (e, t, r2) => (_make_expanded_record_from_typeid = Module._make_expanded_record_from_typeid = wasmExports.make_expanded_record_from_typeid)(e, t, r2), _MemoryContextRegisterResetCallback = Module._MemoryContextRegisterResetCallback = (e, t) => (_MemoryContextRegisterResetCallback = Module._MemoryContextRegisterResetCallback = wasmExports.MemoryContextRegisterResetCallback)(e, t), _make_expanded_record_from_tupdesc = Module._make_expanded_record_from_tupdesc = (e, t) => (_make_expanded_record_from_tupdesc = Module._make_expanded_record_from_tupdesc = wasmExports.make_expanded_record_from_tupdesc)(e, t), _make_expanded_record_from_exprecord = Module._make_expanded_record_from_exprecord = (e, t) => (_make_expanded_record_from_exprecord = Module._make_expanded_record_from_exprecord = wasmExports.make_expanded_record_from_exprecord)(e, t), _expanded_record_set_tuple = Module._expanded_record_set_tuple = (e, t, r2, a) => (_expanded_record_set_tuple = Module._expanded_record_set_tuple = wasmExports.expanded_record_set_tuple)(e, t, r2, a), _expanded_record_get_tuple = Module._expanded_record_get_tuple = (e) => (_expanded_record_get_tuple = Module._expanded_record_get_tuple = wasmExports.expanded_record_get_tuple)(e), _deconstruct_expanded_record = Module._deconstruct_expanded_record = (e) => (_deconstruct_expanded_record = Module._deconstruct_expanded_record = wasmExports.deconstruct_expanded_record)(e), _expanded_record_lookup_field = Module._expanded_record_lookup_field = (e, t, r2) => (_expanded_record_lookup_field = Module._expanded_record_lookup_field = wasmExports.expanded_record_lookup_field)(e, t, r2), _expanded_record_set_field_internal = Module._expanded_record_set_field_internal = (e, t, r2, a, o3, s2) => (_expanded_record_set_field_internal = Module._expanded_record_set_field_internal = wasmExports.expanded_record_set_field_internal)(e, t, r2, a, o3, s2), _expanded_record_set_fields = Module._expanded_record_set_fields = (e, t, r2, a) => (_expanded_record_set_fields = Module._expanded_record_set_fields = wasmExports.expanded_record_set_fields)(e, t, r2, a), _float4in_internal = Module._float4in_internal = (e, t, r2, a, o3) => (_float4in_internal = Module._float4in_internal = wasmExports.float4in_internal)(e, t, r2, a, o3), _strtof = Module._strtof = (e, t) => (_strtof = Module._strtof = wasmExports.strtof)(e, t), _float8in_internal = Module._float8in_internal = (e, t, r2, a, o3) => (_float8in_internal = Module._float8in_internal = wasmExports.float8in_internal)(e, t, r2, a, o3), _float8out_internal = Module._float8out_internal = (e) => (_float8out_internal = Module._float8out_internal = wasmExports.float8out_internal)(e), _btfloat4cmp = Module._btfloat4cmp = (e) => (_btfloat4cmp = Module._btfloat4cmp = wasmExports.btfloat4cmp)(e), _btfloat8cmp = Module._btfloat8cmp = (e) => (_btfloat8cmp = Module._btfloat8cmp = wasmExports.btfloat8cmp)(e), _log10 = Module._log10 = (e) => (_log10 = Module._log10 = wasmExports.log10)(e), _acos = Module._acos = (e) => (_acos = Module._acos = wasmExports.acos)(e), _asin = Module._asin = (e) => (_asin = Module._asin = wasmExports.asin)(e), _cos = Module._cos = (e) => (_cos = Module._cos = wasmExports.cos)(e), _fmod = Module._fmod = (e, t) => (_fmod = Module._fmod = wasmExports.fmod)(e, t), _str_tolower = Module._str_tolower = (e, t, r2) => (_str_tolower = Module._str_tolower = wasmExports.str_tolower)(e, t, r2), _pushJsonbValue = Module._pushJsonbValue = (e, t, r2) => (_pushJsonbValue = Module._pushJsonbValue = wasmExports.pushJsonbValue)(e, t, r2), _numeric_float4 = Module._numeric_float4 = (e) => (_numeric_float4 = Module._numeric_float4 = wasmExports.numeric_float4)(e), _numeric_cmp = Module._numeric_cmp = (e) => (_numeric_cmp = Module._numeric_cmp = wasmExports.numeric_cmp)(e), _numeric_eq = Module._numeric_eq = (e) => (_numeric_eq = Module._numeric_eq = wasmExports.numeric_eq)(e), _numeric_is_nan = Module._numeric_is_nan = (e) => (_numeric_is_nan = Module._numeric_is_nan = wasmExports.numeric_is_nan)(e), _timestamp_cmp = Module._timestamp_cmp = (e) => (_timestamp_cmp = Module._timestamp_cmp = wasmExports.timestamp_cmp)(e), _macaddr_cmp = Module._macaddr_cmp = (e) => (_macaddr_cmp = Module._macaddr_cmp = wasmExports.macaddr_cmp)(e), _macaddr_lt = Module._macaddr_lt = (e) => (_macaddr_lt = Module._macaddr_lt = wasmExports.macaddr_lt)(e), _macaddr_le = Module._macaddr_le = (e) => (_macaddr_le = Module._macaddr_le = wasmExports.macaddr_le)(e), _macaddr_eq = Module._macaddr_eq = (e) => (_macaddr_eq = Module._macaddr_eq = wasmExports.macaddr_eq)(e), _macaddr_ge = Module._macaddr_ge = (e) => (_macaddr_ge = Module._macaddr_ge = wasmExports.macaddr_ge)(e), _macaddr_gt = Module._macaddr_gt = (e) => (_macaddr_gt = Module._macaddr_gt = wasmExports.macaddr_gt)(e), _macaddr8_cmp = Module._macaddr8_cmp = (e) => (_macaddr8_cmp = Module._macaddr8_cmp = wasmExports.macaddr8_cmp)(e), _macaddr8_lt = Module._macaddr8_lt = (e) => (_macaddr8_lt = Module._macaddr8_lt = wasmExports.macaddr8_lt)(e), _macaddr8_le = Module._macaddr8_le = (e) => (_macaddr8_le = Module._macaddr8_le = wasmExports.macaddr8_le)(e), _macaddr8_eq = Module._macaddr8_eq = (e) => (_macaddr8_eq = Module._macaddr8_eq = wasmExports.macaddr8_eq)(e), _macaddr8_ge = Module._macaddr8_ge = (e) => (_macaddr8_ge = Module._macaddr8_ge = wasmExports.macaddr8_ge)(e), _macaddr8_gt = Module._macaddr8_gt = (e) => (_macaddr8_gt = Module._macaddr8_gt = wasmExports.macaddr8_gt)(e), _current_query = Module._current_query = (e) => (_current_query = Module._current_query = wasmExports.current_query)(e), _unpack_sql_state = Module._unpack_sql_state = (e) => (_unpack_sql_state = Module._unpack_sql_state = wasmExports.unpack_sql_state)(e), _get_fn_expr_rettype = Module._get_fn_expr_rettype = (e) => (_get_fn_expr_rettype = Module._get_fn_expr_rettype = wasmExports.get_fn_expr_rettype)(e), _btnamecmp = Module._btnamecmp = (e) => (_btnamecmp = Module._btnamecmp = wasmExports.btnamecmp)(e), _inet_in = Module._inet_in = (e) => (_inet_in = Module._inet_in = wasmExports.inet_in)(e), _network_cmp = Module._network_cmp = (e) => (_network_cmp = Module._network_cmp = wasmExports.network_cmp)(e), _convert_network_to_scalar = Module._convert_network_to_scalar = (e, t, r2) => (_convert_network_to_scalar = Module._convert_network_to_scalar = wasmExports.convert_network_to_scalar)(e, t, r2), _numeric_gt = Module._numeric_gt = (e) => (_numeric_gt = Module._numeric_gt = wasmExports.numeric_gt)(e), _numeric_le = Module._numeric_le = (e) => (_numeric_le = Module._numeric_le = wasmExports.numeric_le)(e), _numeric_float8_no_overflow = Module._numeric_float8_no_overflow = (e) => (_numeric_float8_no_overflow = Module._numeric_float8_no_overflow = wasmExports.numeric_float8_no_overflow)(e), _oidout = Module._oidout = (e) => (_oidout = Module._oidout = wasmExports.oidout)(e), _interval_mi = Module._interval_mi = (e) => (_interval_mi = Module._interval_mi = wasmExports.interval_mi)(e), _localtime = Module._localtime = (e) => (_localtime = Module._localtime = wasmExports.localtime)(e), _quote_ident = Module._quote_ident = (e) => (_quote_ident = Module._quote_ident = wasmExports.quote_ident)(e), _pg_wchar2mb_with_len = Module._pg_wchar2mb_with_len = (e, t, r2) => (_pg_wchar2mb_with_len = Module._pg_wchar2mb_with_len = wasmExports.pg_wchar2mb_with_len)(e, t, r2), _pg_get_indexdef_columns_extended = Module._pg_get_indexdef_columns_extended = (e, t) => (_pg_get_indexdef_columns_extended = Module._pg_get_indexdef_columns_extended = wasmExports.pg_get_indexdef_columns_extended)(e, t), _pg_get_querydef = Module._pg_get_querydef = (e, t) => (_pg_get_querydef = Module._pg_get_querydef = wasmExports.pg_get_querydef)(e, t), _strcspn = Module._strcspn = (e, t) => (_strcspn = Module._strcspn = wasmExports.strcspn)(e, t), _generic_restriction_selectivity = Module._generic_restriction_selectivity = (e, t, r2, a, o3, s2) => (_generic_restriction_selectivity = Module._generic_restriction_selectivity = wasmExports.generic_restriction_selectivity)(e, t, r2, a, o3, s2), _genericcostestimate = Module._genericcostestimate = (e, t, r2, a) => (_genericcostestimate = Module._genericcostestimate = wasmExports.genericcostestimate)(e, t, r2, a), _tidin = Module._tidin = (e) => (_tidin = Module._tidin = wasmExports.tidin)(e), _tidout = Module._tidout = (e) => (_tidout = Module._tidout = wasmExports.tidout)(e), _timestamp_in = Module._timestamp_in = (e) => (_timestamp_in = Module._timestamp_in = wasmExports.timestamp_in)(e), _timestamp_eq = Module._timestamp_eq = (e) => (_timestamp_eq = Module._timestamp_eq = wasmExports.timestamp_eq)(e), _timestamp_lt = Module._timestamp_lt = (e) => (_timestamp_lt = Module._timestamp_lt = wasmExports.timestamp_lt)(e), _timestamp_gt = Module._timestamp_gt = (e) => (_timestamp_gt = Module._timestamp_gt = wasmExports.timestamp_gt)(e), _timestamp_le = Module._timestamp_le = (e) => (_timestamp_le = Module._timestamp_le = wasmExports.timestamp_le)(e), _timestamp_ge = Module._timestamp_ge = (e) => (_timestamp_ge = Module._timestamp_ge = wasmExports.timestamp_ge)(e), _interval_eq = Module._interval_eq = (e) => (_interval_eq = Module._interval_eq = wasmExports.interval_eq)(e), _interval_lt = Module._interval_lt = (e) => (_interval_lt = Module._interval_lt = wasmExports.interval_lt)(e), _interval_gt = Module._interval_gt = (e) => (_interval_gt = Module._interval_gt = wasmExports.interval_gt)(e), _interval_le = Module._interval_le = (e) => (_interval_le = Module._interval_le = wasmExports.interval_le)(e), _interval_ge = Module._interval_ge = (e) => (_interval_ge = Module._interval_ge = wasmExports.interval_ge)(e), _interval_cmp = Module._interval_cmp = (e) => (_interval_cmp = Module._interval_cmp = wasmExports.interval_cmp)(e), _timestamp_mi = Module._timestamp_mi = (e) => (_timestamp_mi = Module._timestamp_mi = wasmExports.timestamp_mi)(e), _interval_um = Module._interval_um = (e) => (_interval_um = Module._interval_um = wasmExports.interval_um)(e), _has_fn_opclass_options = Module._has_fn_opclass_options = (e) => (_has_fn_opclass_options = Module._has_fn_opclass_options = wasmExports.has_fn_opclass_options)(e), _uuid_in = Module._uuid_in = (e) => (_uuid_in = Module._uuid_in = wasmExports.uuid_in)(e), _uuid_out = Module._uuid_out = (e) => (_uuid_out = Module._uuid_out = wasmExports.uuid_out)(e), _uuid_cmp = Module._uuid_cmp = (e) => (_uuid_cmp = Module._uuid_cmp = wasmExports.uuid_cmp)(e), _gen_random_uuid = Module._gen_random_uuid = (e) => (_gen_random_uuid = Module._gen_random_uuid = wasmExports.gen_random_uuid)(e), _varbit_in = Module._varbit_in = (e) => (_varbit_in = Module._varbit_in = wasmExports.varbit_in)(e), _biteq = Module._biteq = (e) => (_biteq = Module._biteq = wasmExports.biteq)(e), _bitlt = Module._bitlt = (e) => (_bitlt = Module._bitlt = wasmExports.bitlt)(e), _bitle = Module._bitle = (e) => (_bitle = Module._bitle = wasmExports.bitle)(e), _bitgt = Module._bitgt = (e) => (_bitgt = Module._bitgt = wasmExports.bitgt)(e), _bitge = Module._bitge = (e) => (_bitge = Module._bitge = wasmExports.bitge)(e), _bitcmp = Module._bitcmp = (e) => (_bitcmp = Module._bitcmp = wasmExports.bitcmp)(e), _bpchareq = Module._bpchareq = (e) => (_bpchareq = Module._bpchareq = wasmExports.bpchareq)(e), _bpcharlt = Module._bpcharlt = (e) => (_bpcharlt = Module._bpcharlt = wasmExports.bpcharlt)(e), _bpcharle = Module._bpcharle = (e) => (_bpcharle = Module._bpcharle = wasmExports.bpcharle)(e), _bpchargt = Module._bpchargt = (e) => (_bpchargt = Module._bpchargt = wasmExports.bpchargt)(e), _bpcharge = Module._bpcharge = (e) => (_bpcharge = Module._bpcharge = wasmExports.bpcharge)(e), _bpcharcmp = Module._bpcharcmp = (e) => (_bpcharcmp = Module._bpcharcmp = wasmExports.bpcharcmp)(e), _texteq = Module._texteq = (e) => (_texteq = Module._texteq = wasmExports.texteq)(e), _text_lt = Module._text_lt = (e) => (_text_lt = Module._text_lt = wasmExports.text_lt)(e), _text_le = Module._text_le = (e) => (_text_le = Module._text_le = wasmExports.text_le)(e), _text_gt = Module._text_gt = (e) => (_text_gt = Module._text_gt = wasmExports.text_gt)(e), _text_ge = Module._text_ge = (e) => (_text_ge = Module._text_ge = wasmExports.text_ge)(e), _bttextcmp = Module._bttextcmp = (e) => (_bttextcmp = Module._bttextcmp = wasmExports.bttextcmp)(e), _byteaeq = Module._byteaeq = (e) => (_byteaeq = Module._byteaeq = wasmExports.byteaeq)(e), _bytealt = Module._bytealt = (e) => (_bytealt = Module._bytealt = wasmExports.bytealt)(e), _byteale = Module._byteale = (e) => (_byteale = Module._byteale = wasmExports.byteale)(e), _byteagt = Module._byteagt = (e) => (_byteagt = Module._byteagt = wasmExports.byteagt)(e), _byteage = Module._byteage = (e) => (_byteage = Module._byteage = wasmExports.byteage)(e), _byteacmp = Module._byteacmp = (e) => (_byteacmp = Module._byteacmp = wasmExports.byteacmp)(e), _to_hex32 = Module._to_hex32 = (e) => (_to_hex32 = Module._to_hex32 = wasmExports.to_hex32)(e), _varstr_levenshtein = Module._varstr_levenshtein = (e, t, r2, a, o3, s2, l3, _2) => (_varstr_levenshtein = Module._varstr_levenshtein = wasmExports.varstr_levenshtein)(e, t, r2, a, o3, s2, l3, _2), _pg_xml_init = Module._pg_xml_init = (e) => (_pg_xml_init = Module._pg_xml_init = wasmExports.pg_xml_init)(e), _xmlInitParser = Module._xmlInitParser = () => (_xmlInitParser = Module._xmlInitParser = wasmExports.xmlInitParser)(), _xml_ereport = Module._xml_ereport = (e, t, r2, a) => (_xml_ereport = Module._xml_ereport = wasmExports.xml_ereport)(e, t, r2, a), _pg_xml_done = Module._pg_xml_done = (e, t) => (_pg_xml_done = Module._pg_xml_done = wasmExports.pg_xml_done)(e, t), _xmlXPathNewContext = Module._xmlXPathNewContext = (e) => (_xmlXPathNewContext = Module._xmlXPathNewContext = wasmExports.xmlXPathNewContext)(e), _xmlXPathFreeContext = Module._xmlXPathFreeContext = (e) => (_xmlXPathFreeContext = Module._xmlXPathFreeContext = wasmExports.xmlXPathFreeContext)(e), _xmlFreeDoc = Module._xmlFreeDoc = (e) => (_xmlFreeDoc = Module._xmlFreeDoc = wasmExports.xmlFreeDoc)(e), _xmlXPathCtxtCompile = Module._xmlXPathCtxtCompile = (e, t) => (_xmlXPathCtxtCompile = Module._xmlXPathCtxtCompile = wasmExports.xmlXPathCtxtCompile)(e, t), _xmlXPathCompiledEval = Module._xmlXPathCompiledEval = (e, t) => (_xmlXPathCompiledEval = Module._xmlXPathCompiledEval = wasmExports.xmlXPathCompiledEval)(e, t), _xmlXPathFreeCompExpr = Module._xmlXPathFreeCompExpr = (e) => (_xmlXPathFreeCompExpr = Module._xmlXPathFreeCompExpr = wasmExports.xmlXPathFreeCompExpr)(e), _pg_do_encoding_conversion = Module._pg_do_encoding_conversion = (e, t, r2, a) => (_pg_do_encoding_conversion = Module._pg_do_encoding_conversion = wasmExports.pg_do_encoding_conversion)(e, t, r2, a), _xmlStrdup = Module._xmlStrdup = (e) => (_xmlStrdup = Module._xmlStrdup = wasmExports.xmlStrdup)(e), _xmlXPathCastNodeToString = Module._xmlXPathCastNodeToString = (e) => (_xmlXPathCastNodeToString = Module._xmlXPathCastNodeToString = wasmExports.xmlXPathCastNodeToString)(e), _get_typsubscript = Module._get_typsubscript = (e, t) => (_get_typsubscript = Module._get_typsubscript = wasmExports.get_typsubscript)(e, t), _CachedPlanAllowsSimpleValidityCheck = Module._CachedPlanAllowsSimpleValidityCheck = (e, t, r2) => (_CachedPlanAllowsSimpleValidityCheck = Module._CachedPlanAllowsSimpleValidityCheck = wasmExports.CachedPlanAllowsSimpleValidityCheck)(e, t, r2), _CachedPlanIsSimplyValid = Module._CachedPlanIsSimplyValid = (e, t, r2) => (_CachedPlanIsSimplyValid = Module._CachedPlanIsSimplyValid = wasmExports.CachedPlanIsSimplyValid)(e, t, r2), _GetCachedExpression = Module._GetCachedExpression = (e) => (_GetCachedExpression = Module._GetCachedExpression = wasmExports.GetCachedExpression)(e), _FreeCachedExpression = Module._FreeCachedExpression = (e) => (_FreeCachedExpression = Module._FreeCachedExpression = wasmExports.FreeCachedExpression)(e), _ReleaseAllPlanCacheRefsInOwner = Module._ReleaseAllPlanCacheRefsInOwner = (e) => (_ReleaseAllPlanCacheRefsInOwner = Module._ReleaseAllPlanCacheRefsInOwner = wasmExports.ReleaseAllPlanCacheRefsInOwner)(e), _in_error_recursion_trouble = Module._in_error_recursion_trouble = () => (_in_error_recursion_trouble = Module._in_error_recursion_trouble = wasmExports.in_error_recursion_trouble)(), _GetErrorContextStack = Module._GetErrorContextStack = () => (_GetErrorContextStack = Module._GetErrorContextStack = wasmExports.GetErrorContextStack)(), _dlsym = Module._dlsym = (e, t) => (_dlsym = Module._dlsym = wasmExports.dlsym)(e, t), _dlopen = Module._dlopen = (e, t) => (_dlopen = Module._dlopen = wasmExports.dlopen)(e, t), _dlerror = Module._dlerror = () => (_dlerror = Module._dlerror = wasmExports.dlerror)(), _dlclose = Module._dlclose = (e) => (_dlclose = Module._dlclose = wasmExports.dlclose)(e), _find_rendezvous_variable = Module._find_rendezvous_variable = (e) => (_find_rendezvous_variable = Module._find_rendezvous_variable = wasmExports.find_rendezvous_variable)(e), _CallerFInfoFunctionCall2 = Module._CallerFInfoFunctionCall2 = (e, t, r2, a, o3) => (_CallerFInfoFunctionCall2 = Module._CallerFInfoFunctionCall2 = wasmExports.CallerFInfoFunctionCall2)(e, t, r2, a, o3), _FunctionCall0Coll = Module._FunctionCall0Coll = (e, t) => (_FunctionCall0Coll = Module._FunctionCall0Coll = wasmExports.FunctionCall0Coll)(e, t), _resolve_polymorphic_argtypes = Module._resolve_polymorphic_argtypes = (e, t, r2, a) => (_resolve_polymorphic_argtypes = Module._resolve_polymorphic_argtypes = wasmExports.resolve_polymorphic_argtypes)(e, t, r2, a), _memcpy = Module._memcpy = (e, t, r2) => (_memcpy = Module._memcpy = wasmExports.memcpy)(e, t, r2), _pg_bindtextdomain = Module._pg_bindtextdomain = (e) => (_pg_bindtextdomain = Module._pg_bindtextdomain = wasmExports.pg_bindtextdomain)(e), _local2local = Module._local2local = (e, t, r2, a, o3, s2, l3) => (_local2local = Module._local2local = wasmExports.local2local)(e, t, r2, a, o3, s2, l3), _report_untranslatable_char = Module._report_untranslatable_char = (e, t, r2, a) => (_report_untranslatable_char = Module._report_untranslatable_char = wasmExports.report_untranslatable_char)(e, t, r2, a), _latin2mic = Module._latin2mic = (e, t, r2, a, o3, s2) => (_latin2mic = Module._latin2mic = wasmExports.latin2mic)(e, t, r2, a, o3, s2), _mic2latin = Module._mic2latin = (e, t, r2, a, o3, s2) => (_mic2latin = Module._mic2latin = wasmExports.mic2latin)(e, t, r2, a, o3, s2), _latin2mic_with_table = Module._latin2mic_with_table = (e, t, r2, a, o3, s2, l3) => (_latin2mic_with_table = Module._latin2mic_with_table = wasmExports.latin2mic_with_table)(e, t, r2, a, o3, s2, l3), _mic2latin_with_table = Module._mic2latin_with_table = (e, t, r2, a, o3, s2, l3) => (_mic2latin_with_table = Module._mic2latin_with_table = wasmExports.mic2latin_with_table)(e, t, r2, a, o3, s2, l3), _UtfToLocal = Module._UtfToLocal = (e, t, r2, a, o3, s2, l3, _2, n) => (_UtfToLocal = Module._UtfToLocal = wasmExports.UtfToLocal)(e, t, r2, a, o3, s2, l3, _2, n), _LocalToUtf = Module._LocalToUtf = (e, t, r2, a, o3, s2, l3, _2, n) => (_LocalToUtf = Module._LocalToUtf = wasmExports.LocalToUtf)(e, t, r2, a, o3, s2, l3, _2, n), _check_encoding_conversion_args = Module._check_encoding_conversion_args = (e, t, r2, a, o3) => (_check_encoding_conversion_args = Module._check_encoding_conversion_args = wasmExports.check_encoding_conversion_args)(e, t, r2, a, o3), _DefineCustomBoolVariable = Module._DefineCustomBoolVariable = (e, t, r2, a, o3, s2, l3, _2, n, m2) => (_DefineCustomBoolVariable = Module._DefineCustomBoolVariable = wasmExports.DefineCustomBoolVariable)(e, t, r2, a, o3, s2, l3, _2, n, m2), _DefineCustomIntVariable = Module._DefineCustomIntVariable = (e, t, r2, a, o3, s2, l3, _2, n, m2, p, d2) => (_DefineCustomIntVariable = Module._DefineCustomIntVariable = wasmExports.DefineCustomIntVariable)(e, t, r2, a, o3, s2, l3, _2, n, m2, p, d2), _DefineCustomRealVariable = Module._DefineCustomRealVariable = (e, t, r2, a, o3, s2, l3, _2, n, m2, p, d2) => (_DefineCustomRealVariable = Module._DefineCustomRealVariable = wasmExports.DefineCustomRealVariable)(e, t, r2, a, o3, s2, l3, _2, n, m2, p, d2), _DefineCustomStringVariable = Module._DefineCustomStringVariable = (e, t, r2, a, o3, s2, l3, _2, n, m2) => (_DefineCustomStringVariable = Module._DefineCustomStringVariable = wasmExports.DefineCustomStringVariable)(e, t, r2, a, o3, s2, l3, _2, n, m2), _DefineCustomEnumVariable = Module._DefineCustomEnumVariable = (e, t, r2, a, o3, s2, l3, _2, n, m2, p) => (_DefineCustomEnumVariable = Module._DefineCustomEnumVariable = wasmExports.DefineCustomEnumVariable)(e, t, r2, a, o3, s2, l3, _2, n, m2, p), _MarkGUCPrefixReserved = Module._MarkGUCPrefixReserved = (e) => (_MarkGUCPrefixReserved = Module._MarkGUCPrefixReserved = wasmExports.MarkGUCPrefixReserved)(e), _sampler_random_init_state = Module._sampler_random_init_state = (e, t) => (_sampler_random_init_state = Module._sampler_random_init_state = wasmExports.sampler_random_init_state)(e, t), _pchomp = Module._pchomp = (e) => (_pchomp = Module._pchomp = wasmExports.pchomp)(e), _PinPortal = Module._PinPortal = (e) => (_PinPortal = Module._PinPortal = wasmExports.PinPortal)(e), _UnpinPortal = Module._UnpinPortal = (e) => (_UnpinPortal = Module._UnpinPortal = wasmExports.UnpinPortal)(e), _isolat1ToUTF8 = Module._isolat1ToUTF8 = (e, t, r2, a) => (_isolat1ToUTF8 = Module._isolat1ToUTF8 = wasmExports.isolat1ToUTF8)(e, t, r2, a), _UTF8Toisolat1 = Module._UTF8Toisolat1 = (e, t, r2, a) => (_UTF8Toisolat1 = Module._UTF8Toisolat1 = wasmExports.UTF8Toisolat1)(e, t, r2, a), _vfprintf = Module._vfprintf = (e, t, r2) => (_vfprintf = Module._vfprintf = wasmExports.vfprintf)(e, t, r2), _vsnprintf = Module._vsnprintf = (e, t, r2, a) => (_vsnprintf = Module._vsnprintf = wasmExports.vsnprintf)(e, t, r2, a), _xmlParserValidityWarning = Module._xmlParserValidityWarning = (e, t, r2) => (_xmlParserValidityWarning = Module._xmlParserValidityWarning = wasmExports.xmlParserValidityWarning)(e, t, r2), _xmlParserValidityError = Module._xmlParserValidityError = (e, t, r2) => (_xmlParserValidityError = Module._xmlParserValidityError = wasmExports.xmlParserValidityError)(e, t, r2), _xmlParserError = Module._xmlParserError = (e, t, r2) => (_xmlParserError = Module._xmlParserError = wasmExports.xmlParserError)(e, t, r2), _xmlParserWarning = Module._xmlParserWarning = (e, t, r2) => (_xmlParserWarning = Module._xmlParserWarning = wasmExports.xmlParserWarning)(e, t, r2), _fprintf = Module._fprintf = (e, t, r2) => (_fprintf = Module._fprintf = wasmExports.fprintf)(e, t, r2), ___xmlParserInputBufferCreateFilename = Module.___xmlParserInputBufferCreateFilename = (e, t) => (___xmlParserInputBufferCreateFilename = Module.___xmlParserInputBufferCreateFilename = wasmExports.__xmlParserInputBufferCreateFilename)(e, t), ___xmlOutputBufferCreateFilename = Module.___xmlOutputBufferCreateFilename = (e, t, r2) => (___xmlOutputBufferCreateFilename = Module.___xmlOutputBufferCreateFilename = wasmExports.__xmlOutputBufferCreateFilename)(e, t, r2), _xmlSAX2InternalSubset = Module._xmlSAX2InternalSubset = (e, t, r2, a) => (_xmlSAX2InternalSubset = Module._xmlSAX2InternalSubset = wasmExports.xmlSAX2InternalSubset)(e, t, r2, a), _xmlSAX2IsStandalone = Module._xmlSAX2IsStandalone = (e) => (_xmlSAX2IsStandalone = Module._xmlSAX2IsStandalone = wasmExports.xmlSAX2IsStandalone)(e), _xmlSAX2HasInternalSubset = Module._xmlSAX2HasInternalSubset = (e) => (_xmlSAX2HasInternalSubset = Module._xmlSAX2HasInternalSubset = wasmExports.xmlSAX2HasInternalSubset)(e), _xmlSAX2HasExternalSubset = Module._xmlSAX2HasExternalSubset = (e) => (_xmlSAX2HasExternalSubset = Module._xmlSAX2HasExternalSubset = wasmExports.xmlSAX2HasExternalSubset)(e), _xmlSAX2ResolveEntity = Module._xmlSAX2ResolveEntity = (e, t, r2) => (_xmlSAX2ResolveEntity = Module._xmlSAX2ResolveEntity = wasmExports.xmlSAX2ResolveEntity)(e, t, r2), _xmlSAX2GetEntity = Module._xmlSAX2GetEntity = (e, t) => (_xmlSAX2GetEntity = Module._xmlSAX2GetEntity = wasmExports.xmlSAX2GetEntity)(e, t), _xmlSAX2EntityDecl = Module._xmlSAX2EntityDecl = (e, t, r2, a, o3, s2) => (_xmlSAX2EntityDecl = Module._xmlSAX2EntityDecl = wasmExports.xmlSAX2EntityDecl)(e, t, r2, a, o3, s2), _xmlSAX2NotationDecl = Module._xmlSAX2NotationDecl = (e, t, r2, a) => (_xmlSAX2NotationDecl = Module._xmlSAX2NotationDecl = wasmExports.xmlSAX2NotationDecl)(e, t, r2, a), _xmlSAX2AttributeDecl = Module._xmlSAX2AttributeDecl = (e, t, r2, a, o3, s2, l3) => (_xmlSAX2AttributeDecl = Module._xmlSAX2AttributeDecl = wasmExports.xmlSAX2AttributeDecl)(e, t, r2, a, o3, s2, l3), _xmlSAX2ElementDecl = Module._xmlSAX2ElementDecl = (e, t, r2, a) => (_xmlSAX2ElementDecl = Module._xmlSAX2ElementDecl = wasmExports.xmlSAX2ElementDecl)(e, t, r2, a), _xmlSAX2UnparsedEntityDecl = Module._xmlSAX2UnparsedEntityDecl = (e, t, r2, a, o3) => (_xmlSAX2UnparsedEntityDecl = Module._xmlSAX2UnparsedEntityDecl = wasmExports.xmlSAX2UnparsedEntityDecl)(e, t, r2, a, o3), _xmlSAX2SetDocumentLocator = Module._xmlSAX2SetDocumentLocator = (e, t) => (_xmlSAX2SetDocumentLocator = Module._xmlSAX2SetDocumentLocator = wasmExports.xmlSAX2SetDocumentLocator)(e, t), _xmlSAX2StartDocument = Module._xmlSAX2StartDocument = (e) => (_xmlSAX2StartDocument = Module._xmlSAX2StartDocument = wasmExports.xmlSAX2StartDocument)(e), _xmlSAX2EndDocument = Module._xmlSAX2EndDocument = (e) => (_xmlSAX2EndDocument = Module._xmlSAX2EndDocument = wasmExports.xmlSAX2EndDocument)(e), _xmlSAX2StartElement = Module._xmlSAX2StartElement = (e, t, r2) => (_xmlSAX2StartElement = Module._xmlSAX2StartElement = wasmExports.xmlSAX2StartElement)(e, t, r2), _xmlSAX2EndElement = Module._xmlSAX2EndElement = (e, t) => (_xmlSAX2EndElement = Module._xmlSAX2EndElement = wasmExports.xmlSAX2EndElement)(e, t), _xmlSAX2Reference = Module._xmlSAX2Reference = (e, t) => (_xmlSAX2Reference = Module._xmlSAX2Reference = wasmExports.xmlSAX2Reference)(e, t), _xmlSAX2Characters = Module._xmlSAX2Characters = (e, t, r2) => (_xmlSAX2Characters = Module._xmlSAX2Characters = wasmExports.xmlSAX2Characters)(e, t, r2), _xmlSAX2ProcessingInstruction = Module._xmlSAX2ProcessingInstruction = (e, t, r2) => (_xmlSAX2ProcessingInstruction = Module._xmlSAX2ProcessingInstruction = wasmExports.xmlSAX2ProcessingInstruction)(e, t, r2), _xmlSAX2Comment = Module._xmlSAX2Comment = (e, t) => (_xmlSAX2Comment = Module._xmlSAX2Comment = wasmExports.xmlSAX2Comment)(e, t), _xmlSAX2GetParameterEntity = Module._xmlSAX2GetParameterEntity = (e, t) => (_xmlSAX2GetParameterEntity = Module._xmlSAX2GetParameterEntity = wasmExports.xmlSAX2GetParameterEntity)(e, t), _xmlSAX2CDataBlock = Module._xmlSAX2CDataBlock = (e, t, r2) => (_xmlSAX2CDataBlock = Module._xmlSAX2CDataBlock = wasmExports.xmlSAX2CDataBlock)(e, t, r2), _xmlSAX2ExternalSubset = Module._xmlSAX2ExternalSubset = (e, t, r2, a) => (_xmlSAX2ExternalSubset = Module._xmlSAX2ExternalSubset = wasmExports.xmlSAX2ExternalSubset)(e, t, r2, a), _xmlSAX2GetPublicId = Module._xmlSAX2GetPublicId = (e) => (_xmlSAX2GetPublicId = Module._xmlSAX2GetPublicId = wasmExports.xmlSAX2GetPublicId)(e), _xmlSAX2GetSystemId = Module._xmlSAX2GetSystemId = (e) => (_xmlSAX2GetSystemId = Module._xmlSAX2GetSystemId = wasmExports.xmlSAX2GetSystemId)(e), _xmlSAX2GetLineNumber = Module._xmlSAX2GetLineNumber = (e) => (_xmlSAX2GetLineNumber = Module._xmlSAX2GetLineNumber = wasmExports.xmlSAX2GetLineNumber)(e), _xmlSAX2GetColumnNumber = Module._xmlSAX2GetColumnNumber = (e) => (_xmlSAX2GetColumnNumber = Module._xmlSAX2GetColumnNumber = wasmExports.xmlSAX2GetColumnNumber)(e), _xmlSAX2IgnorableWhitespace = Module._xmlSAX2IgnorableWhitespace = (e, t, r2) => (_xmlSAX2IgnorableWhitespace = Module._xmlSAX2IgnorableWhitespace = wasmExports.xmlSAX2IgnorableWhitespace)(e, t, r2), _xmlHashDefaultDeallocator = Module._xmlHashDefaultDeallocator = (e, t) => (_xmlHashDefaultDeallocator = Module._xmlHashDefaultDeallocator = wasmExports.xmlHashDefaultDeallocator)(e, t), _iconv_open = Module._iconv_open = (e, t) => (_iconv_open = Module._iconv_open = wasmExports.iconv_open)(e, t), _iconv_close = Module._iconv_close = (e) => (_iconv_close = Module._iconv_close = wasmExports.iconv_close)(e), _iconv = Module._iconv = (e, t, r2, a, o3) => (_iconv = Module._iconv = wasmExports.iconv)(e, t, r2, a, o3), _UTF8ToHtml = Module._UTF8ToHtml = (e, t, r2, a) => (_UTF8ToHtml = Module._UTF8ToHtml = wasmExports.UTF8ToHtml)(e, t, r2, a), _xmlReadMemory = Module._xmlReadMemory = (e, t, r2, a, o3) => (_xmlReadMemory = Module._xmlReadMemory = wasmExports.xmlReadMemory)(e, t, r2, a, o3), _xmlSAX2StartElementNs = Module._xmlSAX2StartElementNs = (e, t, r2, a, o3, s2, l3, _2, n) => (_xmlSAX2StartElementNs = Module._xmlSAX2StartElementNs = wasmExports.xmlSAX2StartElementNs)(e, t, r2, a, o3, s2, l3, _2, n), _xmlSAX2EndElementNs = Module._xmlSAX2EndElementNs = (e, t, r2, a) => (_xmlSAX2EndElementNs = Module._xmlSAX2EndElementNs = wasmExports.xmlSAX2EndElementNs)(e, t, r2, a), ___cxa_atexit = Module.___cxa_atexit = (e, t, r2) => (___cxa_atexit = Module.___cxa_atexit = wasmExports.__cxa_atexit)(e, t, r2), _xmlDocGetRootElement = Module._xmlDocGetRootElement = (e) => (_xmlDocGetRootElement = Module._xmlDocGetRootElement = wasmExports.xmlDocGetRootElement)(e), _xmlFileMatch = Module._xmlFileMatch = (e) => (_xmlFileMatch = Module._xmlFileMatch = wasmExports.xmlFileMatch)(e), _xmlFileOpen = Module._xmlFileOpen = (e) => (_xmlFileOpen = Module._xmlFileOpen = wasmExports.xmlFileOpen)(e), _xmlFileRead = Module._xmlFileRead = (e, t, r2) => (_xmlFileRead = Module._xmlFileRead = wasmExports.xmlFileRead)(e, t, r2), _xmlFileClose = Module._xmlFileClose = (e) => (_xmlFileClose = Module._xmlFileClose = wasmExports.xmlFileClose)(e), _gzread = Module._gzread = (e, t, r2) => (_gzread = Module._gzread = wasmExports.gzread)(e, t, r2), _gzclose = Module._gzclose = (e) => (_gzclose = Module._gzclose = wasmExports.gzclose)(e), _gzdirect = Module._gzdirect = (e) => (_gzdirect = Module._gzdirect = wasmExports.gzdirect)(e), _gzdopen = Module._gzdopen = (e, t) => (_gzdopen = Module._gzdopen = wasmExports.gzdopen)(e, t), _gzopen = Module._gzopen = (e, t) => (_gzopen = Module._gzopen = wasmExports.gzopen)(e, t), _gzwrite = Module._gzwrite = (e, t, r2) => (_gzwrite = Module._gzwrite = wasmExports.gzwrite)(e, t, r2), _xmlUCSIsCatNd = Module._xmlUCSIsCatNd = (e) => (_xmlUCSIsCatNd = Module._xmlUCSIsCatNd = wasmExports.xmlUCSIsCatNd)(e), _xmlUCSIsCatP = Module._xmlUCSIsCatP = (e) => (_xmlUCSIsCatP = Module._xmlUCSIsCatP = wasmExports.xmlUCSIsCatP)(e), _xmlUCSIsCatZ = Module._xmlUCSIsCatZ = (e) => (_xmlUCSIsCatZ = Module._xmlUCSIsCatZ = wasmExports.xmlUCSIsCatZ)(e), _xmlUCSIsCatC = Module._xmlUCSIsCatC = (e) => (_xmlUCSIsCatC = Module._xmlUCSIsCatC = wasmExports.xmlUCSIsCatC)(e), _xmlUCSIsCatL = Module._xmlUCSIsCatL = (e) => (_xmlUCSIsCatL = Module._xmlUCSIsCatL = wasmExports.xmlUCSIsCatL)(e), _xmlUCSIsCatLu = Module._xmlUCSIsCatLu = (e) => (_xmlUCSIsCatLu = Module._xmlUCSIsCatLu = wasmExports.xmlUCSIsCatLu)(e), _xmlUCSIsCatLl = Module._xmlUCSIsCatLl = (e) => (_xmlUCSIsCatLl = Module._xmlUCSIsCatLl = wasmExports.xmlUCSIsCatLl)(e), _xmlUCSIsCatLt = Module._xmlUCSIsCatLt = (e) => (_xmlUCSIsCatLt = Module._xmlUCSIsCatLt = wasmExports.xmlUCSIsCatLt)(e), _xmlUCSIsCatLm = Module._xmlUCSIsCatLm = (e) => (_xmlUCSIsCatLm = Module._xmlUCSIsCatLm = wasmExports.xmlUCSIsCatLm)(e), _xmlUCSIsCatLo = Module._xmlUCSIsCatLo = (e) => (_xmlUCSIsCatLo = Module._xmlUCSIsCatLo = wasmExports.xmlUCSIsCatLo)(e), _xmlUCSIsCatM = Module._xmlUCSIsCatM = (e) => (_xmlUCSIsCatM = Module._xmlUCSIsCatM = wasmExports.xmlUCSIsCatM)(e), _xmlUCSIsCatMn = Module._xmlUCSIsCatMn = (e) => (_xmlUCSIsCatMn = Module._xmlUCSIsCatMn = wasmExports.xmlUCSIsCatMn)(e), _xmlUCSIsCatMc = Module._xmlUCSIsCatMc = (e) => (_xmlUCSIsCatMc = Module._xmlUCSIsCatMc = wasmExports.xmlUCSIsCatMc)(e), _xmlUCSIsCatMe = Module._xmlUCSIsCatMe = (e) => (_xmlUCSIsCatMe = Module._xmlUCSIsCatMe = wasmExports.xmlUCSIsCatMe)(e), _xmlUCSIsCatN = Module._xmlUCSIsCatN = (e) => (_xmlUCSIsCatN = Module._xmlUCSIsCatN = wasmExports.xmlUCSIsCatN)(e), _xmlUCSIsCatNl = Module._xmlUCSIsCatNl = (e) => (_xmlUCSIsCatNl = Module._xmlUCSIsCatNl = wasmExports.xmlUCSIsCatNl)(e), _xmlUCSIsCatNo = Module._xmlUCSIsCatNo = (e) => (_xmlUCSIsCatNo = Module._xmlUCSIsCatNo = wasmExports.xmlUCSIsCatNo)(e), _xmlUCSIsCatPc = Module._xmlUCSIsCatPc = (e) => (_xmlUCSIsCatPc = Module._xmlUCSIsCatPc = wasmExports.xmlUCSIsCatPc)(e), _xmlUCSIsCatPd = Module._xmlUCSIsCatPd = (e) => (_xmlUCSIsCatPd = Module._xmlUCSIsCatPd = wasmExports.xmlUCSIsCatPd)(e), _xmlUCSIsCatPs = Module._xmlUCSIsCatPs = (e) => (_xmlUCSIsCatPs = Module._xmlUCSIsCatPs = wasmExports.xmlUCSIsCatPs)(e), _xmlUCSIsCatPe = Module._xmlUCSIsCatPe = (e) => (_xmlUCSIsCatPe = Module._xmlUCSIsCatPe = wasmExports.xmlUCSIsCatPe)(e), _xmlUCSIsCatPi = Module._xmlUCSIsCatPi = (e) => (_xmlUCSIsCatPi = Module._xmlUCSIsCatPi = wasmExports.xmlUCSIsCatPi)(e), _xmlUCSIsCatPf = Module._xmlUCSIsCatPf = (e) => (_xmlUCSIsCatPf = Module._xmlUCSIsCatPf = wasmExports.xmlUCSIsCatPf)(e), _xmlUCSIsCatPo = Module._xmlUCSIsCatPo = (e) => (_xmlUCSIsCatPo = Module._xmlUCSIsCatPo = wasmExports.xmlUCSIsCatPo)(e), _xmlUCSIsCatZs = Module._xmlUCSIsCatZs = (e) => (_xmlUCSIsCatZs = Module._xmlUCSIsCatZs = wasmExports.xmlUCSIsCatZs)(e), _xmlUCSIsCatZl = Module._xmlUCSIsCatZl = (e) => (_xmlUCSIsCatZl = Module._xmlUCSIsCatZl = wasmExports.xmlUCSIsCatZl)(e), _xmlUCSIsCatZp = Module._xmlUCSIsCatZp = (e) => (_xmlUCSIsCatZp = Module._xmlUCSIsCatZp = wasmExports.xmlUCSIsCatZp)(e), _xmlUCSIsCatS = Module._xmlUCSIsCatS = (e) => (_xmlUCSIsCatS = Module._xmlUCSIsCatS = wasmExports.xmlUCSIsCatS)(e), _xmlUCSIsCatSm = Module._xmlUCSIsCatSm = (e) => (_xmlUCSIsCatSm = Module._xmlUCSIsCatSm = wasmExports.xmlUCSIsCatSm)(e), _xmlUCSIsCatSc = Module._xmlUCSIsCatSc = (e) => (_xmlUCSIsCatSc = Module._xmlUCSIsCatSc = wasmExports.xmlUCSIsCatSc)(e), _xmlUCSIsCatSk = Module._xmlUCSIsCatSk = (e) => (_xmlUCSIsCatSk = Module._xmlUCSIsCatSk = wasmExports.xmlUCSIsCatSk)(e), _xmlUCSIsCatSo = Module._xmlUCSIsCatSo = (e) => (_xmlUCSIsCatSo = Module._xmlUCSIsCatSo = wasmExports.xmlUCSIsCatSo)(e), _xmlUCSIsCatCc = Module._xmlUCSIsCatCc = (e) => (_xmlUCSIsCatCc = Module._xmlUCSIsCatCc = wasmExports.xmlUCSIsCatCc)(e), _xmlUCSIsCatCf = Module._xmlUCSIsCatCf = (e) => (_xmlUCSIsCatCf = Module._xmlUCSIsCatCf = wasmExports.xmlUCSIsCatCf)(e), _xmlUCSIsCatCo = Module._xmlUCSIsCatCo = (e) => (_xmlUCSIsCatCo = Module._xmlUCSIsCatCo = wasmExports.xmlUCSIsCatCo)(e), _xmlUCSIsAegeanNumbers = Module._xmlUCSIsAegeanNumbers = (e) => (_xmlUCSIsAegeanNumbers = Module._xmlUCSIsAegeanNumbers = wasmExports.xmlUCSIsAegeanNumbers)(e), _xmlUCSIsAlphabeticPresentationForms = Module._xmlUCSIsAlphabeticPresentationForms = (e) => (_xmlUCSIsAlphabeticPresentationForms = Module._xmlUCSIsAlphabeticPresentationForms = wasmExports.xmlUCSIsAlphabeticPresentationForms)(e), _xmlUCSIsArabic = Module._xmlUCSIsArabic = (e) => (_xmlUCSIsArabic = Module._xmlUCSIsArabic = wasmExports.xmlUCSIsArabic)(e), _xmlUCSIsArabicPresentationFormsA = Module._xmlUCSIsArabicPresentationFormsA = (e) => (_xmlUCSIsArabicPresentationFormsA = Module._xmlUCSIsArabicPresentationFormsA = wasmExports.xmlUCSIsArabicPresentationFormsA)(e), _xmlUCSIsArabicPresentationFormsB = Module._xmlUCSIsArabicPresentationFormsB = (e) => (_xmlUCSIsArabicPresentationFormsB = Module._xmlUCSIsArabicPresentationFormsB = wasmExports.xmlUCSIsArabicPresentationFormsB)(e), _xmlUCSIsArmenian = Module._xmlUCSIsArmenian = (e) => (_xmlUCSIsArmenian = Module._xmlUCSIsArmenian = wasmExports.xmlUCSIsArmenian)(e), _xmlUCSIsArrows = Module._xmlUCSIsArrows = (e) => (_xmlUCSIsArrows = Module._xmlUCSIsArrows = wasmExports.xmlUCSIsArrows)(e), _xmlUCSIsBasicLatin = Module._xmlUCSIsBasicLatin = (e) => (_xmlUCSIsBasicLatin = Module._xmlUCSIsBasicLatin = wasmExports.xmlUCSIsBasicLatin)(e), _xmlUCSIsBengali = Module._xmlUCSIsBengali = (e) => (_xmlUCSIsBengali = Module._xmlUCSIsBengali = wasmExports.xmlUCSIsBengali)(e), _xmlUCSIsBlockElements = Module._xmlUCSIsBlockElements = (e) => (_xmlUCSIsBlockElements = Module._xmlUCSIsBlockElements = wasmExports.xmlUCSIsBlockElements)(e), _xmlUCSIsBopomofo = Module._xmlUCSIsBopomofo = (e) => (_xmlUCSIsBopomofo = Module._xmlUCSIsBopomofo = wasmExports.xmlUCSIsBopomofo)(e), _xmlUCSIsBopomofoExtended = Module._xmlUCSIsBopomofoExtended = (e) => (_xmlUCSIsBopomofoExtended = Module._xmlUCSIsBopomofoExtended = wasmExports.xmlUCSIsBopomofoExtended)(e), _xmlUCSIsBoxDrawing = Module._xmlUCSIsBoxDrawing = (e) => (_xmlUCSIsBoxDrawing = Module._xmlUCSIsBoxDrawing = wasmExports.xmlUCSIsBoxDrawing)(e), _xmlUCSIsBraillePatterns = Module._xmlUCSIsBraillePatterns = (e) => (_xmlUCSIsBraillePatterns = Module._xmlUCSIsBraillePatterns = wasmExports.xmlUCSIsBraillePatterns)(e), _xmlUCSIsBuhid = Module._xmlUCSIsBuhid = (e) => (_xmlUCSIsBuhid = Module._xmlUCSIsBuhid = wasmExports.xmlUCSIsBuhid)(e), _xmlUCSIsByzantineMusicalSymbols = Module._xmlUCSIsByzantineMusicalSymbols = (e) => (_xmlUCSIsByzantineMusicalSymbols = Module._xmlUCSIsByzantineMusicalSymbols = wasmExports.xmlUCSIsByzantineMusicalSymbols)(e), _xmlUCSIsCJKCompatibility = Module._xmlUCSIsCJKCompatibility = (e) => (_xmlUCSIsCJKCompatibility = Module._xmlUCSIsCJKCompatibility = wasmExports.xmlUCSIsCJKCompatibility)(e), _xmlUCSIsCJKCompatibilityForms = Module._xmlUCSIsCJKCompatibilityForms = (e) => (_xmlUCSIsCJKCompatibilityForms = Module._xmlUCSIsCJKCompatibilityForms = wasmExports.xmlUCSIsCJKCompatibilityForms)(e), _xmlUCSIsCJKCompatibilityIdeographs = Module._xmlUCSIsCJKCompatibilityIdeographs = (e) => (_xmlUCSIsCJKCompatibilityIdeographs = Module._xmlUCSIsCJKCompatibilityIdeographs = wasmExports.xmlUCSIsCJKCompatibilityIdeographs)(e), _xmlUCSIsCJKCompatibilityIdeographsSupplement = Module._xmlUCSIsCJKCompatibilityIdeographsSupplement = (e) => (_xmlUCSIsCJKCompatibilityIdeographsSupplement = Module._xmlUCSIsCJKCompatibilityIdeographsSupplement = wasmExports.xmlUCSIsCJKCompatibilityIdeographsSupplement)(e), _xmlUCSIsCJKRadicalsSupplement = Module._xmlUCSIsCJKRadicalsSupplement = (e) => (_xmlUCSIsCJKRadicalsSupplement = Module._xmlUCSIsCJKRadicalsSupplement = wasmExports.xmlUCSIsCJKRadicalsSupplement)(e), _xmlUCSIsCJKSymbolsandPunctuation = Module._xmlUCSIsCJKSymbolsandPunctuation = (e) => (_xmlUCSIsCJKSymbolsandPunctuation = Module._xmlUCSIsCJKSymbolsandPunctuation = wasmExports.xmlUCSIsCJKSymbolsandPunctuation)(e), _xmlUCSIsCJKUnifiedIdeographs = Module._xmlUCSIsCJKUnifiedIdeographs = (e) => (_xmlUCSIsCJKUnifiedIdeographs = Module._xmlUCSIsCJKUnifiedIdeographs = wasmExports.xmlUCSIsCJKUnifiedIdeographs)(e), _xmlUCSIsCJKUnifiedIdeographsExtensionA = Module._xmlUCSIsCJKUnifiedIdeographsExtensionA = (e) => (_xmlUCSIsCJKUnifiedIdeographsExtensionA = Module._xmlUCSIsCJKUnifiedIdeographsExtensionA = wasmExports.xmlUCSIsCJKUnifiedIdeographsExtensionA)(e), _xmlUCSIsCJKUnifiedIdeographsExtensionB = Module._xmlUCSIsCJKUnifiedIdeographsExtensionB = (e) => (_xmlUCSIsCJKUnifiedIdeographsExtensionB = Module._xmlUCSIsCJKUnifiedIdeographsExtensionB = wasmExports.xmlUCSIsCJKUnifiedIdeographsExtensionB)(e), _xmlUCSIsCherokee = Module._xmlUCSIsCherokee = (e) => (_xmlUCSIsCherokee = Module._xmlUCSIsCherokee = wasmExports.xmlUCSIsCherokee)(e), _xmlUCSIsCombiningDiacriticalMarks = Module._xmlUCSIsCombiningDiacriticalMarks = (e) => (_xmlUCSIsCombiningDiacriticalMarks = Module._xmlUCSIsCombiningDiacriticalMarks = wasmExports.xmlUCSIsCombiningDiacriticalMarks)(e), _xmlUCSIsCombiningDiacriticalMarksforSymbols = Module._xmlUCSIsCombiningDiacriticalMarksforSymbols = (e) => (_xmlUCSIsCombiningDiacriticalMarksforSymbols = Module._xmlUCSIsCombiningDiacriticalMarksforSymbols = wasmExports.xmlUCSIsCombiningDiacriticalMarksforSymbols)(e), _xmlUCSIsCombiningHalfMarks = Module._xmlUCSIsCombiningHalfMarks = (e) => (_xmlUCSIsCombiningHalfMarks = Module._xmlUCSIsCombiningHalfMarks = wasmExports.xmlUCSIsCombiningHalfMarks)(e), _xmlUCSIsCombiningMarksforSymbols = Module._xmlUCSIsCombiningMarksforSymbols = (e) => (_xmlUCSIsCombiningMarksforSymbols = Module._xmlUCSIsCombiningMarksforSymbols = wasmExports.xmlUCSIsCombiningMarksforSymbols)(e), _xmlUCSIsControlPictures = Module._xmlUCSIsControlPictures = (e) => (_xmlUCSIsControlPictures = Module._xmlUCSIsControlPictures = wasmExports.xmlUCSIsControlPictures)(e), _xmlUCSIsCurrencySymbols = Module._xmlUCSIsCurrencySymbols = (e) => (_xmlUCSIsCurrencySymbols = Module._xmlUCSIsCurrencySymbols = wasmExports.xmlUCSIsCurrencySymbols)(e), _xmlUCSIsCypriotSyllabary = Module._xmlUCSIsCypriotSyllabary = (e) => (_xmlUCSIsCypriotSyllabary = Module._xmlUCSIsCypriotSyllabary = wasmExports.xmlUCSIsCypriotSyllabary)(e), _xmlUCSIsCyrillic = Module._xmlUCSIsCyrillic = (e) => (_xmlUCSIsCyrillic = Module._xmlUCSIsCyrillic = wasmExports.xmlUCSIsCyrillic)(e), _xmlUCSIsCyrillicSupplement = Module._xmlUCSIsCyrillicSupplement = (e) => (_xmlUCSIsCyrillicSupplement = Module._xmlUCSIsCyrillicSupplement = wasmExports.xmlUCSIsCyrillicSupplement)(e), _xmlUCSIsDeseret = Module._xmlUCSIsDeseret = (e) => (_xmlUCSIsDeseret = Module._xmlUCSIsDeseret = wasmExports.xmlUCSIsDeseret)(e), _xmlUCSIsDevanagari = Module._xmlUCSIsDevanagari = (e) => (_xmlUCSIsDevanagari = Module._xmlUCSIsDevanagari = wasmExports.xmlUCSIsDevanagari)(e), _xmlUCSIsDingbats = Module._xmlUCSIsDingbats = (e) => (_xmlUCSIsDingbats = Module._xmlUCSIsDingbats = wasmExports.xmlUCSIsDingbats)(e), _xmlUCSIsEnclosedAlphanumerics = Module._xmlUCSIsEnclosedAlphanumerics = (e) => (_xmlUCSIsEnclosedAlphanumerics = Module._xmlUCSIsEnclosedAlphanumerics = wasmExports.xmlUCSIsEnclosedAlphanumerics)(e), _xmlUCSIsEnclosedCJKLettersandMonths = Module._xmlUCSIsEnclosedCJKLettersandMonths = (e) => (_xmlUCSIsEnclosedCJKLettersandMonths = Module._xmlUCSIsEnclosedCJKLettersandMonths = wasmExports.xmlUCSIsEnclosedCJKLettersandMonths)(e), _xmlUCSIsEthiopic = Module._xmlUCSIsEthiopic = (e) => (_xmlUCSIsEthiopic = Module._xmlUCSIsEthiopic = wasmExports.xmlUCSIsEthiopic)(e), _xmlUCSIsGeneralPunctuation = Module._xmlUCSIsGeneralPunctuation = (e) => (_xmlUCSIsGeneralPunctuation = Module._xmlUCSIsGeneralPunctuation = wasmExports.xmlUCSIsGeneralPunctuation)(e), _xmlUCSIsGeometricShapes = Module._xmlUCSIsGeometricShapes = (e) => (_xmlUCSIsGeometricShapes = Module._xmlUCSIsGeometricShapes = wasmExports.xmlUCSIsGeometricShapes)(e), _xmlUCSIsGeorgian = Module._xmlUCSIsGeorgian = (e) => (_xmlUCSIsGeorgian = Module._xmlUCSIsGeorgian = wasmExports.xmlUCSIsGeorgian)(e), _xmlUCSIsGothic = Module._xmlUCSIsGothic = (e) => (_xmlUCSIsGothic = Module._xmlUCSIsGothic = wasmExports.xmlUCSIsGothic)(e), _xmlUCSIsGreek = Module._xmlUCSIsGreek = (e) => (_xmlUCSIsGreek = Module._xmlUCSIsGreek = wasmExports.xmlUCSIsGreek)(e), _xmlUCSIsGreekExtended = Module._xmlUCSIsGreekExtended = (e) => (_xmlUCSIsGreekExtended = Module._xmlUCSIsGreekExtended = wasmExports.xmlUCSIsGreekExtended)(e), _xmlUCSIsGreekandCoptic = Module._xmlUCSIsGreekandCoptic = (e) => (_xmlUCSIsGreekandCoptic = Module._xmlUCSIsGreekandCoptic = wasmExports.xmlUCSIsGreekandCoptic)(e), _xmlUCSIsGujarati = Module._xmlUCSIsGujarati = (e) => (_xmlUCSIsGujarati = Module._xmlUCSIsGujarati = wasmExports.xmlUCSIsGujarati)(e), _xmlUCSIsGurmukhi = Module._xmlUCSIsGurmukhi = (e) => (_xmlUCSIsGurmukhi = Module._xmlUCSIsGurmukhi = wasmExports.xmlUCSIsGurmukhi)(e), _xmlUCSIsHalfwidthandFullwidthForms = Module._xmlUCSIsHalfwidthandFullwidthForms = (e) => (_xmlUCSIsHalfwidthandFullwidthForms = Module._xmlUCSIsHalfwidthandFullwidthForms = wasmExports.xmlUCSIsHalfwidthandFullwidthForms)(e), _xmlUCSIsHangulCompatibilityJamo = Module._xmlUCSIsHangulCompatibilityJamo = (e) => (_xmlUCSIsHangulCompatibilityJamo = Module._xmlUCSIsHangulCompatibilityJamo = wasmExports.xmlUCSIsHangulCompatibilityJamo)(e), _xmlUCSIsHangulJamo = Module._xmlUCSIsHangulJamo = (e) => (_xmlUCSIsHangulJamo = Module._xmlUCSIsHangulJamo = wasmExports.xmlUCSIsHangulJamo)(e), _xmlUCSIsHangulSyllables = Module._xmlUCSIsHangulSyllables = (e) => (_xmlUCSIsHangulSyllables = Module._xmlUCSIsHangulSyllables = wasmExports.xmlUCSIsHangulSyllables)(e), _xmlUCSIsHanunoo = Module._xmlUCSIsHanunoo = (e) => (_xmlUCSIsHanunoo = Module._xmlUCSIsHanunoo = wasmExports.xmlUCSIsHanunoo)(e), _xmlUCSIsHebrew = Module._xmlUCSIsHebrew = (e) => (_xmlUCSIsHebrew = Module._xmlUCSIsHebrew = wasmExports.xmlUCSIsHebrew)(e), _xmlUCSIsHighPrivateUseSurrogates = Module._xmlUCSIsHighPrivateUseSurrogates = (e) => (_xmlUCSIsHighPrivateUseSurrogates = Module._xmlUCSIsHighPrivateUseSurrogates = wasmExports.xmlUCSIsHighPrivateUseSurrogates)(e), _xmlUCSIsHighSurrogates = Module._xmlUCSIsHighSurrogates = (e) => (_xmlUCSIsHighSurrogates = Module._xmlUCSIsHighSurrogates = wasmExports.xmlUCSIsHighSurrogates)(e), _xmlUCSIsHiragana = Module._xmlUCSIsHiragana = (e) => (_xmlUCSIsHiragana = Module._xmlUCSIsHiragana = wasmExports.xmlUCSIsHiragana)(e), _xmlUCSIsIPAExtensions = Module._xmlUCSIsIPAExtensions = (e) => (_xmlUCSIsIPAExtensions = Module._xmlUCSIsIPAExtensions = wasmExports.xmlUCSIsIPAExtensions)(e), _xmlUCSIsIdeographicDescriptionCharacters = Module._xmlUCSIsIdeographicDescriptionCharacters = (e) => (_xmlUCSIsIdeographicDescriptionCharacters = Module._xmlUCSIsIdeographicDescriptionCharacters = wasmExports.xmlUCSIsIdeographicDescriptionCharacters)(e), _xmlUCSIsKanbun = Module._xmlUCSIsKanbun = (e) => (_xmlUCSIsKanbun = Module._xmlUCSIsKanbun = wasmExports.xmlUCSIsKanbun)(e), _xmlUCSIsKangxiRadicals = Module._xmlUCSIsKangxiRadicals = (e) => (_xmlUCSIsKangxiRadicals = Module._xmlUCSIsKangxiRadicals = wasmExports.xmlUCSIsKangxiRadicals)(e), _xmlUCSIsKannada = Module._xmlUCSIsKannada = (e) => (_xmlUCSIsKannada = Module._xmlUCSIsKannada = wasmExports.xmlUCSIsKannada)(e), _xmlUCSIsKatakana = Module._xmlUCSIsKatakana = (e) => (_xmlUCSIsKatakana = Module._xmlUCSIsKatakana = wasmExports.xmlUCSIsKatakana)(e), _xmlUCSIsKatakanaPhoneticExtensions = Module._xmlUCSIsKatakanaPhoneticExtensions = (e) => (_xmlUCSIsKatakanaPhoneticExtensions = Module._xmlUCSIsKatakanaPhoneticExtensions = wasmExports.xmlUCSIsKatakanaPhoneticExtensions)(e), _xmlUCSIsKhmer = Module._xmlUCSIsKhmer = (e) => (_xmlUCSIsKhmer = Module._xmlUCSIsKhmer = wasmExports.xmlUCSIsKhmer)(e), _xmlUCSIsKhmerSymbols = Module._xmlUCSIsKhmerSymbols = (e) => (_xmlUCSIsKhmerSymbols = Module._xmlUCSIsKhmerSymbols = wasmExports.xmlUCSIsKhmerSymbols)(e), _xmlUCSIsLao = Module._xmlUCSIsLao = (e) => (_xmlUCSIsLao = Module._xmlUCSIsLao = wasmExports.xmlUCSIsLao)(e), _xmlUCSIsLatin1Supplement = Module._xmlUCSIsLatin1Supplement = (e) => (_xmlUCSIsLatin1Supplement = Module._xmlUCSIsLatin1Supplement = wasmExports.xmlUCSIsLatin1Supplement)(e), _xmlUCSIsLatinExtendedA = Module._xmlUCSIsLatinExtendedA = (e) => (_xmlUCSIsLatinExtendedA = Module._xmlUCSIsLatinExtendedA = wasmExports.xmlUCSIsLatinExtendedA)(e), _xmlUCSIsLatinExtendedB = Module._xmlUCSIsLatinExtendedB = (e) => (_xmlUCSIsLatinExtendedB = Module._xmlUCSIsLatinExtendedB = wasmExports.xmlUCSIsLatinExtendedB)(e), _xmlUCSIsLatinExtendedAdditional = Module._xmlUCSIsLatinExtendedAdditional = (e) => (_xmlUCSIsLatinExtendedAdditional = Module._xmlUCSIsLatinExtendedAdditional = wasmExports.xmlUCSIsLatinExtendedAdditional)(e), _xmlUCSIsLetterlikeSymbols = Module._xmlUCSIsLetterlikeSymbols = (e) => (_xmlUCSIsLetterlikeSymbols = Module._xmlUCSIsLetterlikeSymbols = wasmExports.xmlUCSIsLetterlikeSymbols)(e), _xmlUCSIsLimbu = Module._xmlUCSIsLimbu = (e) => (_xmlUCSIsLimbu = Module._xmlUCSIsLimbu = wasmExports.xmlUCSIsLimbu)(e), _xmlUCSIsLinearBIdeograms = Module._xmlUCSIsLinearBIdeograms = (e) => (_xmlUCSIsLinearBIdeograms = Module._xmlUCSIsLinearBIdeograms = wasmExports.xmlUCSIsLinearBIdeograms)(e), _xmlUCSIsLinearBSyllabary = Module._xmlUCSIsLinearBSyllabary = (e) => (_xmlUCSIsLinearBSyllabary = Module._xmlUCSIsLinearBSyllabary = wasmExports.xmlUCSIsLinearBSyllabary)(e), _xmlUCSIsLowSurrogates = Module._xmlUCSIsLowSurrogates = (e) => (_xmlUCSIsLowSurrogates = Module._xmlUCSIsLowSurrogates = wasmExports.xmlUCSIsLowSurrogates)(e), _xmlUCSIsMalayalam = Module._xmlUCSIsMalayalam = (e) => (_xmlUCSIsMalayalam = Module._xmlUCSIsMalayalam = wasmExports.xmlUCSIsMalayalam)(e), _xmlUCSIsMathematicalAlphanumericSymbols = Module._xmlUCSIsMathematicalAlphanumericSymbols = (e) => (_xmlUCSIsMathematicalAlphanumericSymbols = Module._xmlUCSIsMathematicalAlphanumericSymbols = wasmExports.xmlUCSIsMathematicalAlphanumericSymbols)(e), _xmlUCSIsMathematicalOperators = Module._xmlUCSIsMathematicalOperators = (e) => (_xmlUCSIsMathematicalOperators = Module._xmlUCSIsMathematicalOperators = wasmExports.xmlUCSIsMathematicalOperators)(e), _xmlUCSIsMiscellaneousMathematicalSymbolsA = Module._xmlUCSIsMiscellaneousMathematicalSymbolsA = (e) => (_xmlUCSIsMiscellaneousMathematicalSymbolsA = Module._xmlUCSIsMiscellaneousMathematicalSymbolsA = wasmExports.xmlUCSIsMiscellaneousMathematicalSymbolsA)(e), _xmlUCSIsMiscellaneousMathematicalSymbolsB = Module._xmlUCSIsMiscellaneousMathematicalSymbolsB = (e) => (_xmlUCSIsMiscellaneousMathematicalSymbolsB = Module._xmlUCSIsMiscellaneousMathematicalSymbolsB = wasmExports.xmlUCSIsMiscellaneousMathematicalSymbolsB)(e), _xmlUCSIsMiscellaneousSymbols = Module._xmlUCSIsMiscellaneousSymbols = (e) => (_xmlUCSIsMiscellaneousSymbols = Module._xmlUCSIsMiscellaneousSymbols = wasmExports.xmlUCSIsMiscellaneousSymbols)(e), _xmlUCSIsMiscellaneousSymbolsandArrows = Module._xmlUCSIsMiscellaneousSymbolsandArrows = (e) => (_xmlUCSIsMiscellaneousSymbolsandArrows = Module._xmlUCSIsMiscellaneousSymbolsandArrows = wasmExports.xmlUCSIsMiscellaneousSymbolsandArrows)(e), _xmlUCSIsMiscellaneousTechnical = Module._xmlUCSIsMiscellaneousTechnical = (e) => (_xmlUCSIsMiscellaneousTechnical = Module._xmlUCSIsMiscellaneousTechnical = wasmExports.xmlUCSIsMiscellaneousTechnical)(e), _xmlUCSIsMongolian = Module._xmlUCSIsMongolian = (e) => (_xmlUCSIsMongolian = Module._xmlUCSIsMongolian = wasmExports.xmlUCSIsMongolian)(e), _xmlUCSIsMusicalSymbols = Module._xmlUCSIsMusicalSymbols = (e) => (_xmlUCSIsMusicalSymbols = Module._xmlUCSIsMusicalSymbols = wasmExports.xmlUCSIsMusicalSymbols)(e), _xmlUCSIsMyanmar = Module._xmlUCSIsMyanmar = (e) => (_xmlUCSIsMyanmar = Module._xmlUCSIsMyanmar = wasmExports.xmlUCSIsMyanmar)(e), _xmlUCSIsNumberForms = Module._xmlUCSIsNumberForms = (e) => (_xmlUCSIsNumberForms = Module._xmlUCSIsNumberForms = wasmExports.xmlUCSIsNumberForms)(e), _xmlUCSIsOgham = Module._xmlUCSIsOgham = (e) => (_xmlUCSIsOgham = Module._xmlUCSIsOgham = wasmExports.xmlUCSIsOgham)(e), _xmlUCSIsOldItalic = Module._xmlUCSIsOldItalic = (e) => (_xmlUCSIsOldItalic = Module._xmlUCSIsOldItalic = wasmExports.xmlUCSIsOldItalic)(e), _xmlUCSIsOpticalCharacterRecognition = Module._xmlUCSIsOpticalCharacterRecognition = (e) => (_xmlUCSIsOpticalCharacterRecognition = Module._xmlUCSIsOpticalCharacterRecognition = wasmExports.xmlUCSIsOpticalCharacterRecognition)(e), _xmlUCSIsOriya = Module._xmlUCSIsOriya = (e) => (_xmlUCSIsOriya = Module._xmlUCSIsOriya = wasmExports.xmlUCSIsOriya)(e), _xmlUCSIsOsmanya = Module._xmlUCSIsOsmanya = (e) => (_xmlUCSIsOsmanya = Module._xmlUCSIsOsmanya = wasmExports.xmlUCSIsOsmanya)(e), _xmlUCSIsPhoneticExtensions = Module._xmlUCSIsPhoneticExtensions = (e) => (_xmlUCSIsPhoneticExtensions = Module._xmlUCSIsPhoneticExtensions = wasmExports.xmlUCSIsPhoneticExtensions)(e), _xmlUCSIsPrivateUse = Module._xmlUCSIsPrivateUse = (e) => (_xmlUCSIsPrivateUse = Module._xmlUCSIsPrivateUse = wasmExports.xmlUCSIsPrivateUse)(e), _xmlUCSIsPrivateUseArea = Module._xmlUCSIsPrivateUseArea = (e) => (_xmlUCSIsPrivateUseArea = Module._xmlUCSIsPrivateUseArea = wasmExports.xmlUCSIsPrivateUseArea)(e), _xmlUCSIsRunic = Module._xmlUCSIsRunic = (e) => (_xmlUCSIsRunic = Module._xmlUCSIsRunic = wasmExports.xmlUCSIsRunic)(e), _xmlUCSIsShavian = Module._xmlUCSIsShavian = (e) => (_xmlUCSIsShavian = Module._xmlUCSIsShavian = wasmExports.xmlUCSIsShavian)(e), _xmlUCSIsSinhala = Module._xmlUCSIsSinhala = (e) => (_xmlUCSIsSinhala = Module._xmlUCSIsSinhala = wasmExports.xmlUCSIsSinhala)(e), _xmlUCSIsSmallFormVariants = Module._xmlUCSIsSmallFormVariants = (e) => (_xmlUCSIsSmallFormVariants = Module._xmlUCSIsSmallFormVariants = wasmExports.xmlUCSIsSmallFormVariants)(e), _xmlUCSIsSpacingModifierLetters = Module._xmlUCSIsSpacingModifierLetters = (e) => (_xmlUCSIsSpacingModifierLetters = Module._xmlUCSIsSpacingModifierLetters = wasmExports.xmlUCSIsSpacingModifierLetters)(e), _xmlUCSIsSpecials = Module._xmlUCSIsSpecials = (e) => (_xmlUCSIsSpecials = Module._xmlUCSIsSpecials = wasmExports.xmlUCSIsSpecials)(e), _xmlUCSIsSuperscriptsandSubscripts = Module._xmlUCSIsSuperscriptsandSubscripts = (e) => (_xmlUCSIsSuperscriptsandSubscripts = Module._xmlUCSIsSuperscriptsandSubscripts = wasmExports.xmlUCSIsSuperscriptsandSubscripts)(e), _xmlUCSIsSupplementalArrowsA = Module._xmlUCSIsSupplementalArrowsA = (e) => (_xmlUCSIsSupplementalArrowsA = Module._xmlUCSIsSupplementalArrowsA = wasmExports.xmlUCSIsSupplementalArrowsA)(e), _xmlUCSIsSupplementalArrowsB = Module._xmlUCSIsSupplementalArrowsB = (e) => (_xmlUCSIsSupplementalArrowsB = Module._xmlUCSIsSupplementalArrowsB = wasmExports.xmlUCSIsSupplementalArrowsB)(e), _xmlUCSIsSupplementalMathematicalOperators = Module._xmlUCSIsSupplementalMathematicalOperators = (e) => (_xmlUCSIsSupplementalMathematicalOperators = Module._xmlUCSIsSupplementalMathematicalOperators = wasmExports.xmlUCSIsSupplementalMathematicalOperators)(e), _xmlUCSIsSupplementaryPrivateUseAreaA = Module._xmlUCSIsSupplementaryPrivateUseAreaA = (e) => (_xmlUCSIsSupplementaryPrivateUseAreaA = Module._xmlUCSIsSupplementaryPrivateUseAreaA = wasmExports.xmlUCSIsSupplementaryPrivateUseAreaA)(e), _xmlUCSIsSupplementaryPrivateUseAreaB = Module._xmlUCSIsSupplementaryPrivateUseAreaB = (e) => (_xmlUCSIsSupplementaryPrivateUseAreaB = Module._xmlUCSIsSupplementaryPrivateUseAreaB = wasmExports.xmlUCSIsSupplementaryPrivateUseAreaB)(e), _xmlUCSIsSyriac = Module._xmlUCSIsSyriac = (e) => (_xmlUCSIsSyriac = Module._xmlUCSIsSyriac = wasmExports.xmlUCSIsSyriac)(e), _xmlUCSIsTagalog = Module._xmlUCSIsTagalog = (e) => (_xmlUCSIsTagalog = Module._xmlUCSIsTagalog = wasmExports.xmlUCSIsTagalog)(e), _xmlUCSIsTagbanwa = Module._xmlUCSIsTagbanwa = (e) => (_xmlUCSIsTagbanwa = Module._xmlUCSIsTagbanwa = wasmExports.xmlUCSIsTagbanwa)(e), _xmlUCSIsTags = Module._xmlUCSIsTags = (e) => (_xmlUCSIsTags = Module._xmlUCSIsTags = wasmExports.xmlUCSIsTags)(e), _xmlUCSIsTaiLe = Module._xmlUCSIsTaiLe = (e) => (_xmlUCSIsTaiLe = Module._xmlUCSIsTaiLe = wasmExports.xmlUCSIsTaiLe)(e), _xmlUCSIsTaiXuanJingSymbols = Module._xmlUCSIsTaiXuanJingSymbols = (e) => (_xmlUCSIsTaiXuanJingSymbols = Module._xmlUCSIsTaiXuanJingSymbols = wasmExports.xmlUCSIsTaiXuanJingSymbols)(e), _xmlUCSIsTamil = Module._xmlUCSIsTamil = (e) => (_xmlUCSIsTamil = Module._xmlUCSIsTamil = wasmExports.xmlUCSIsTamil)(e), _xmlUCSIsTelugu = Module._xmlUCSIsTelugu = (e) => (_xmlUCSIsTelugu = Module._xmlUCSIsTelugu = wasmExports.xmlUCSIsTelugu)(e), _xmlUCSIsThaana = Module._xmlUCSIsThaana = (e) => (_xmlUCSIsThaana = Module._xmlUCSIsThaana = wasmExports.xmlUCSIsThaana)(e), _xmlUCSIsThai = Module._xmlUCSIsThai = (e) => (_xmlUCSIsThai = Module._xmlUCSIsThai = wasmExports.xmlUCSIsThai)(e), _xmlUCSIsTibetan = Module._xmlUCSIsTibetan = (e) => (_xmlUCSIsTibetan = Module._xmlUCSIsTibetan = wasmExports.xmlUCSIsTibetan)(e), _xmlUCSIsUgaritic = Module._xmlUCSIsUgaritic = (e) => (_xmlUCSIsUgaritic = Module._xmlUCSIsUgaritic = wasmExports.xmlUCSIsUgaritic)(e), _xmlUCSIsUnifiedCanadianAboriginalSyllabics = Module._xmlUCSIsUnifiedCanadianAboriginalSyllabics = (e) => (_xmlUCSIsUnifiedCanadianAboriginalSyllabics = Module._xmlUCSIsUnifiedCanadianAboriginalSyllabics = wasmExports.xmlUCSIsUnifiedCanadianAboriginalSyllabics)(e), _xmlUCSIsVariationSelectors = Module._xmlUCSIsVariationSelectors = (e) => (_xmlUCSIsVariationSelectors = Module._xmlUCSIsVariationSelectors = wasmExports.xmlUCSIsVariationSelectors)(e), _xmlUCSIsVariationSelectorsSupplement = Module._xmlUCSIsVariationSelectorsSupplement = (e) => (_xmlUCSIsVariationSelectorsSupplement = Module._xmlUCSIsVariationSelectorsSupplement = wasmExports.xmlUCSIsVariationSelectorsSupplement)(e), _xmlUCSIsYiRadicals = Module._xmlUCSIsYiRadicals = (e) => (_xmlUCSIsYiRadicals = Module._xmlUCSIsYiRadicals = wasmExports.xmlUCSIsYiRadicals)(e), _xmlUCSIsYiSyllables = Module._xmlUCSIsYiSyllables = (e) => (_xmlUCSIsYiSyllables = Module._xmlUCSIsYiSyllables = wasmExports.xmlUCSIsYiSyllables)(e), _xmlUCSIsYijingHexagramSymbols = Module._xmlUCSIsYijingHexagramSymbols = (e) => (_xmlUCSIsYijingHexagramSymbols = Module._xmlUCSIsYijingHexagramSymbols = wasmExports.xmlUCSIsYijingHexagramSymbols)(e), _xmlUCSIsCatCs = Module._xmlUCSIsCatCs = (e) => (_xmlUCSIsCatCs = Module._xmlUCSIsCatCs = wasmExports.xmlUCSIsCatCs)(e), ___small_fprintf = Module.___small_fprintf = (e, t, r2) => (___small_fprintf = Module.___small_fprintf = wasmExports.__small_fprintf)(e, t, r2), _xmlXPathBooleanFunction = Module._xmlXPathBooleanFunction = (e, t) => (_xmlXPathBooleanFunction = Module._xmlXPathBooleanFunction = wasmExports.xmlXPathBooleanFunction)(e, t), _xmlXPathCeilingFunction = Module._xmlXPathCeilingFunction = (e, t) => (_xmlXPathCeilingFunction = Module._xmlXPathCeilingFunction = wasmExports.xmlXPathCeilingFunction)(e, t), _xmlXPathCountFunction = Module._xmlXPathCountFunction = (e, t) => (_xmlXPathCountFunction = Module._xmlXPathCountFunction = wasmExports.xmlXPathCountFunction)(e, t), _xmlXPathConcatFunction = Module._xmlXPathConcatFunction = (e, t) => (_xmlXPathConcatFunction = Module._xmlXPathConcatFunction = wasmExports.xmlXPathConcatFunction)(e, t), _xmlXPathContainsFunction = Module._xmlXPathContainsFunction = (e, t) => (_xmlXPathContainsFunction = Module._xmlXPathContainsFunction = wasmExports.xmlXPathContainsFunction)(e, t), _xmlXPathIdFunction = Module._xmlXPathIdFunction = (e, t) => (_xmlXPathIdFunction = Module._xmlXPathIdFunction = wasmExports.xmlXPathIdFunction)(e, t), _xmlXPathFalseFunction = Module._xmlXPathFalseFunction = (e, t) => (_xmlXPathFalseFunction = Module._xmlXPathFalseFunction = wasmExports.xmlXPathFalseFunction)(e, t), _xmlXPathFloorFunction = Module._xmlXPathFloorFunction = (e, t) => (_xmlXPathFloorFunction = Module._xmlXPathFloorFunction = wasmExports.xmlXPathFloorFunction)(e, t), _xmlXPathLastFunction = Module._xmlXPathLastFunction = (e, t) => (_xmlXPathLastFunction = Module._xmlXPathLastFunction = wasmExports.xmlXPathLastFunction)(e, t), _xmlXPathLangFunction = Module._xmlXPathLangFunction = (e, t) => (_xmlXPathLangFunction = Module._xmlXPathLangFunction = wasmExports.xmlXPathLangFunction)(e, t), _xmlXPathLocalNameFunction = Module._xmlXPathLocalNameFunction = (e, t) => (_xmlXPathLocalNameFunction = Module._xmlXPathLocalNameFunction = wasmExports.xmlXPathLocalNameFunction)(e, t), _xmlXPathNotFunction = Module._xmlXPathNotFunction = (e, t) => (_xmlXPathNotFunction = Module._xmlXPathNotFunction = wasmExports.xmlXPathNotFunction)(e, t), _xmlXPathNamespaceURIFunction = Module._xmlXPathNamespaceURIFunction = (e, t) => (_xmlXPathNamespaceURIFunction = Module._xmlXPathNamespaceURIFunction = wasmExports.xmlXPathNamespaceURIFunction)(e, t), _xmlXPathNormalizeFunction = Module._xmlXPathNormalizeFunction = (e, t) => (_xmlXPathNormalizeFunction = Module._xmlXPathNormalizeFunction = wasmExports.xmlXPathNormalizeFunction)(e, t), _xmlXPathNumberFunction = Module._xmlXPathNumberFunction = (e, t) => (_xmlXPathNumberFunction = Module._xmlXPathNumberFunction = wasmExports.xmlXPathNumberFunction)(e, t), _xmlXPathPositionFunction = Module._xmlXPathPositionFunction = (e, t) => (_xmlXPathPositionFunction = Module._xmlXPathPositionFunction = wasmExports.xmlXPathPositionFunction)(e, t), _xmlXPathRoundFunction = Module._xmlXPathRoundFunction = (e, t) => (_xmlXPathRoundFunction = Module._xmlXPathRoundFunction = wasmExports.xmlXPathRoundFunction)(e, t), _xmlXPathStringFunction = Module._xmlXPathStringFunction = (e, t) => (_xmlXPathStringFunction = Module._xmlXPathStringFunction = wasmExports.xmlXPathStringFunction)(e, t), _xmlXPathStringLengthFunction = Module._xmlXPathStringLengthFunction = (e, t) => (_xmlXPathStringLengthFunction = Module._xmlXPathStringLengthFunction = wasmExports.xmlXPathStringLengthFunction)(e, t), _xmlXPathStartsWithFunction = Module._xmlXPathStartsWithFunction = (e, t) => (_xmlXPathStartsWithFunction = Module._xmlXPathStartsWithFunction = wasmExports.xmlXPathStartsWithFunction)(e, t), _xmlXPathSubstringFunction = Module._xmlXPathSubstringFunction = (e, t) => (_xmlXPathSubstringFunction = Module._xmlXPathSubstringFunction = wasmExports.xmlXPathSubstringFunction)(e, t), _xmlXPathSubstringBeforeFunction = Module._xmlXPathSubstringBeforeFunction = (e, t) => (_xmlXPathSubstringBeforeFunction = Module._xmlXPathSubstringBeforeFunction = wasmExports.xmlXPathSubstringBeforeFunction)(e, t), _xmlXPathSubstringAfterFunction = Module._xmlXPathSubstringAfterFunction = (e, t) => (_xmlXPathSubstringAfterFunction = Module._xmlXPathSubstringAfterFunction = wasmExports.xmlXPathSubstringAfterFunction)(e, t), _xmlXPathSumFunction = Module._xmlXPathSumFunction = (e, t) => (_xmlXPathSumFunction = Module._xmlXPathSumFunction = wasmExports.xmlXPathSumFunction)(e, t), _xmlXPathTrueFunction = Module._xmlXPathTrueFunction = (e, t) => (_xmlXPathTrueFunction = Module._xmlXPathTrueFunction = wasmExports.xmlXPathTrueFunction)(e, t), _xmlXPathTranslateFunction = Module._xmlXPathTranslateFunction = (e, t) => (_xmlXPathTranslateFunction = Module._xmlXPathTranslateFunction = wasmExports.xmlXPathTranslateFunction)(e, t), _xmlXPathNextSelf = Module._xmlXPathNextSelf = (e, t) => (_xmlXPathNextSelf = Module._xmlXPathNextSelf = wasmExports.xmlXPathNextSelf)(e, t), _xmlXPathNextChild = Module._xmlXPathNextChild = (e, t) => (_xmlXPathNextChild = Module._xmlXPathNextChild = wasmExports.xmlXPathNextChild)(e, t), _xmlXPathNextDescendant = Module._xmlXPathNextDescendant = (e, t) => (_xmlXPathNextDescendant = Module._xmlXPathNextDescendant = wasmExports.xmlXPathNextDescendant)(e, t), _xmlXPathNextDescendantOrSelf = Module._xmlXPathNextDescendantOrSelf = (e, t) => (_xmlXPathNextDescendantOrSelf = Module._xmlXPathNextDescendantOrSelf = wasmExports.xmlXPathNextDescendantOrSelf)(e, t), _xmlXPathNextParent = Module._xmlXPathNextParent = (e, t) => (_xmlXPathNextParent = Module._xmlXPathNextParent = wasmExports.xmlXPathNextParent)(e, t), _xmlXPathNextAncestor = Module._xmlXPathNextAncestor = (e, t) => (_xmlXPathNextAncestor = Module._xmlXPathNextAncestor = wasmExports.xmlXPathNextAncestor)(e, t), _xmlXPathNextAncestorOrSelf = Module._xmlXPathNextAncestorOrSelf = (e, t) => (_xmlXPathNextAncestorOrSelf = Module._xmlXPathNextAncestorOrSelf = wasmExports.xmlXPathNextAncestorOrSelf)(e, t), _xmlXPathNextFollowingSibling = Module._xmlXPathNextFollowingSibling = (e, t) => (_xmlXPathNextFollowingSibling = Module._xmlXPathNextFollowingSibling = wasmExports.xmlXPathNextFollowingSibling)(e, t), _xmlXPathNextPrecedingSibling = Module._xmlXPathNextPrecedingSibling = (e, t) => (_xmlXPathNextPrecedingSibling = Module._xmlXPathNextPrecedingSibling = wasmExports.xmlXPathNextPrecedingSibling)(e, t), _xmlXPathNextFollowing = Module._xmlXPathNextFollowing = (e, t) => (_xmlXPathNextFollowing = Module._xmlXPathNextFollowing = wasmExports.xmlXPathNextFollowing)(e, t), _xmlXPathNextNamespace = Module._xmlXPathNextNamespace = (e, t) => (_xmlXPathNextNamespace = Module._xmlXPathNextNamespace = wasmExports.xmlXPathNextNamespace)(e, t), _xmlXPathNextAttribute = Module._xmlXPathNextAttribute = (e, t) => (_xmlXPathNextAttribute = Module._xmlXPathNextAttribute = wasmExports.xmlXPathNextAttribute)(e, t), _zcalloc = Module._zcalloc = (e, t, r2) => (_zcalloc = Module._zcalloc = wasmExports.zcalloc)(e, t, r2), _zcfree = Module._zcfree = (e, t) => (_zcfree = Module._zcfree = wasmExports.zcfree)(e, t), _memset = Module._memset = (e, t, r2) => (_memset = Module._memset = wasmExports.memset)(e, t, r2), _strerror = Module._strerror = (e) => (_strerror = Module._strerror = wasmExports.strerror)(e), _memmove = Module._memmove = (e, t, r2) => (_memmove = Module._memmove = wasmExports.memmove)(e, t, r2), ___multf3 = Module.___multf3 = (e, t, r2, a, o3) => (___multf3 = Module.___multf3 = wasmExports.__multf3)(e, t, r2, a, o3), ___subtf3 = Module.___subtf3 = (e, t, r2, a, o3) => (___subtf3 = Module.___subtf3 = wasmExports.__subtf3)(e, t, r2, a, o3), ___lttf2 = Module.___lttf2 = (e, t, r2, a) => (___lttf2 = Module.___lttf2 = wasmExports.__lttf2)(e, t, r2, a), ___fixtfsi = Module.___fixtfsi = (e, t) => (___fixtfsi = Module.___fixtfsi = wasmExports.__fixtfsi)(e, t), ___floatsitf = Module.___floatsitf = (e, t) => (___floatsitf = Module.___floatsitf = wasmExports.__floatsitf)(e, t), ___extenddftf2 = Module.___extenddftf2 = (e, t) => (___extenddftf2 = Module.___extenddftf2 = wasmExports.__extenddftf2)(e, t), ___getf2 = Module.___getf2 = (e, t, r2, a) => (___getf2 = Module.___getf2 = wasmExports.__getf2)(e, t, r2, a), _pthread_mutex_lock = Module._pthread_mutex_lock = (e) => (_pthread_mutex_lock = Module._pthread_mutex_lock = wasmExports.pthread_mutex_lock)(e), _pthread_mutex_unlock = Module._pthread_mutex_unlock = (e) => (_pthread_mutex_unlock = Module._pthread_mutex_unlock = wasmExports.pthread_mutex_unlock)(e), ___dl_seterr = (e, t) => (___dl_seterr = wasmExports.__dl_seterr)(e, t), _emscripten_builtin_memalign = (e, t) => (_emscripten_builtin_memalign = wasmExports.emscripten_builtin_memalign)(e, t), _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports.emscripten_stack_get_current)(), _putc = Module._putc = (e, t) => (_putc = Module._putc = wasmExports.putc)(e, t), ___letf2 = Module.___letf2 = (e, t, r2, a) => (___letf2 = Module.___letf2 = wasmExports.__letf2)(e, t, r2, a), _pthread_sigmask = Module._pthread_sigmask = (e, t, r2) => (_pthread_sigmask = Module._pthread_sigmask = wasmExports.pthread_sigmask)(e, t, r2), _htons = (e) => (_htons = wasmExports.htons)(e), _ntohs = (e) => (_ntohs = wasmExports.ntohs)(e), _gmtime = Module._gmtime = (e) => (_gmtime = Module._gmtime = wasmExports.gmtime)(e), _htonl = (e) => (_htonl = wasmExports.htonl)(e), _ioctl = Module._ioctl = (e, t, r2) => (_ioctl = Module._ioctl = wasmExports.ioctl)(e, t, r2), _sigismember = Module._sigismember = (e, t) => (_sigismember = Module._sigismember = wasmExports.sigismember)(e, t), _sigpending = Module._sigpending = (e) => (_sigpending = Module._sigpending = wasmExports.sigpending)(e), _srand = Module._srand = (e) => (_srand = Module._srand = wasmExports.srand)(e), _rand = Module._rand = () => (_rand = Module._rand = wasmExports.rand)(), __emscripten_timeout = (e, t) => (__emscripten_timeout = wasmExports._emscripten_timeout)(e, t), _sigwait = Module._sigwait = (e, t) => (_sigwait = Module._sigwait = wasmExports.sigwait)(e, t), _strncat = Module._strncat = (e, t, r2) => (_strncat = Module._strncat = wasmExports.strncat)(e, t, r2), _setThrew = (e, t) => (_setThrew = wasmExports.setThrew)(e, t), __emscripten_tempret_set = (e) => (__emscripten_tempret_set = wasmExports._emscripten_tempret_set)(e), __emscripten_tempret_get = () => (__emscripten_tempret_get = wasmExports._emscripten_tempret_get)(), __emscripten_stack_restore = (e) => (__emscripten_stack_restore = wasmExports._emscripten_stack_restore)(e), __emscripten_stack_alloc = (e) => (__emscripten_stack_alloc = wasmExports._emscripten_stack_alloc)(e), _getsockname = Module._getsockname = (e, t, r2) => (_getsockname = Module._getsockname = wasmExports.getsockname)(e, t, r2), ___wasm_apply_data_relocs = () => (___wasm_apply_data_relocs = wasmExports.__wasm_apply_data_relocs)(), _stderr = Module._stderr = 15157024, _InterruptPending = Module._InterruptPending = 15301456, _MyLatch = Module._MyLatch = 15301644, _CritSectionCount = Module._CritSectionCount = 15301508, _MyProc = Module._MyProc = 15271260, _pg_global_prng_state = Module._pg_global_prng_state = 15247840, _error_context_stack = Module._error_context_stack = 15299752, _GUC_check_errdetail_string = Module._GUC_check_errdetail_string = 15305404, _IsUnderPostmaster = Module._IsUnderPostmaster = 15301537, _CurrentMemoryContext = Module._CurrentMemoryContext = 15306832, _stdout = Module._stdout = 15157328, _debug_query_string = Module._debug_query_string = 15162268, _MyProcPort = Module._MyProcPort = 15301632, ___THREW__ = Module.___THREW__ = 15325956, ___threwValue = Module.___threwValue = 15325960, _MyDatabaseId = Module._MyDatabaseId = 15301516, _TopMemoryContext = Module._TopMemoryContext = 15306836, _PG_exception_stack = Module._PG_exception_stack = 15299756, _MyProcPid = Module._MyProcPid = 15301608, _stdin = Module._stdin = 15157176, _ScanKeywords = Module._ScanKeywords = 14989880, _pg_number_of_ones = Module._pg_number_of_ones = 13556160, _LocalBufferBlockPointers = Module._LocalBufferBlockPointers = 15267836, _BufferBlocks = Module._BufferBlocks = 15262572, _wal_level = Module._wal_level = 15003760, _SnapshotAnyData = Module._SnapshotAnyData = 15089936, _maintenance_work_mem = Module._maintenance_work_mem = 15037416, _ParallelWorkerNumber = Module._ParallelWorkerNumber = 14995320, _MainLWLockArray = Module._MainLWLockArray = 15269444, _CurrentResourceOwner = Module._CurrentResourceOwner = 15306880, _work_mem = Module._work_mem = 15037400, _NBuffers = Module._NBuffers = 15037424, _bsysscan = Module._bsysscan = 15249076, _CheckXidAlive = Module._CheckXidAlive = 15249072, _RecentXmin = Module._RecentXmin = 15090028, _TTSOpsHeapTuple = Module._TTSOpsHeapTuple = 15007500, _XactIsoLevel = Module._XactIsoLevel = 15003624, _pgWalUsage = Module._pgWalUsage = 15252544, _pgBufferUsage = Module._pgBufferUsage = 15252416, _TTSOpsVirtual = Module._TTSOpsVirtual = 15007448, _TransamVariables = Module._TransamVariables = 15249064, _TopTransactionContext = Module._TopTransactionContext = 15306856, _RmgrTable = Module._RmgrTable = 14995344, _process_shared_preload_libraries_in_progress = Module._process_shared_preload_libraries_in_progress = 15304800, _wal_segment_size = Module._wal_segment_size = 15003780, _TopTransactionResourceOwner = Module._TopTransactionResourceOwner = 15306888, _arch_module_check_errdetail_string = Module._arch_module_check_errdetail_string = 15261956, _object_access_hook = Module._object_access_hook = 15251184, _InvalidObjectAddress = Module._InvalidObjectAddress = 14151628, _check_function_bodies = Module._check_function_bodies = 15037590, _post_parse_analyze_hook = Module._post_parse_analyze_hook = 15251224, _ScanKeywordTokens = Module._ScanKeywordTokens = 14182928, _SPI_processed = Module._SPI_processed = 15252568, _SPI_tuptable = Module._SPI_tuptable = 15252576, _CacheMemoryContext = Module._CacheMemoryContext = 15306848, _WalReceiverFunctions = Module._WalReceiverFunctions = 15262348, _TTSOpsMinimalTuple = Module._TTSOpsMinimalTuple = 15007552, _check_password_hook = Module._check_password_hook = 15251492, _ConfigReloadPending = Module._ConfigReloadPending = 15261944, _max_parallel_maintenance_workers = Module._max_parallel_maintenance_workers = 15037420, _DateStyle = Module._DateStyle = 15037388, _ExecutorStart_hook = Module._ExecutorStart_hook = 15252392, _ExecutorRun_hook = Module._ExecutorRun_hook = 15252396, _ExecutorFinish_hook = Module._ExecutorFinish_hook = 15252400, _ExecutorEnd_hook = Module._ExecutorEnd_hook = 15252404, _SPI_result = Module._SPI_result = 15252580, _ClientAuthentication_hook = Module._ClientAuthentication_hook = 15252752, _cpu_tuple_cost = Module._cpu_tuple_cost = 15008008, _cpu_operator_cost = Module._cpu_operator_cost = 15008024, _seq_page_cost = Module._seq_page_cost = 15007992, _planner_hook = Module._planner_hook = 15261640, _ShutdownRequestPending = Module._ShutdownRequestPending = 15261948, _MyStartTime = Module._MyStartTime = 15301616, _cluster_name = Module._cluster_name = 15037640, _application_name = Module._application_name = 15305628, _BufferDescriptors = Module._BufferDescriptors = 15262568, _shmem_startup_hook = Module._shmem_startup_hook = 15268516, _ProcessUtility_hook = Module._ProcessUtility_hook = 15271348, _IntervalStyle = Module._IntervalStyle = 15301540, _extra_float_digits = Module._extra_float_digits = 15027816, _pg_crc32_table = Module._pg_crc32_table = 14743360, _xmlFree = Module._xmlFree = 15139240, _xmlStructuredError = Module._xmlStructuredError = 15308404, _xmlStructuredErrorContext = Module._xmlStructuredErrorContext = 15308412, _xmlGenericErrorContext = Module._xmlGenericErrorContext = 15308408, _xmlGenericError = Module._xmlGenericError = 15139276, _xmlIsBaseCharGroup = Module._xmlIsBaseCharGroup = 15138640, _xmlIsDigitGroup = Module._xmlIsDigitGroup = 15138672, _xmlIsCombiningGroup = Module._xmlIsCombiningGroup = 15138656, _xmlIsExtenderGroup = Module._xmlIsExtenderGroup = 15138688, _ErrorContext = Module._ErrorContext = 15306840, _shmem_request_hook = Module._shmem_request_hook = 15304804, _xmlIsPubidChar_tab = Module._xmlIsPubidChar_tab = 14784656, _xmlMalloc = Module._xmlMalloc = 15139244, _xmlRealloc = Module._xmlRealloc = 15139252, _xmlGetWarningsDefaultValue = Module._xmlGetWarningsDefaultValue = 15139268, _xmlLastError = Module._xmlLastError = 15308424, _xmlMallocAtomic = Module._xmlMallocAtomic = 15139248, _xmlMemStrdup = Module._xmlMemStrdup = 15139256, _xmlBufferAllocScheme = Module._xmlBufferAllocScheme = 15139260, _xmlDefaultBufferSize = Module._xmlDefaultBufferSize = 15139264, _xmlParserDebugEntities = Module._xmlParserDebugEntities = 15308364, _xmlDoValidityCheckingDefaultValue = Module._xmlDoValidityCheckingDefaultValue = 15308368, _xmlLoadExtDtdDefaultValue = Module._xmlLoadExtDtdDefaultValue = 15308372, _xmlPedanticParserDefaultValue = Module._xmlPedanticParserDefaultValue = 15308376, _xmlLineNumbersDefaultValue = Module._xmlLineNumbersDefaultValue = 15308380, _xmlKeepBlanksDefaultValue = Module._xmlKeepBlanksDefaultValue = 15139272, _xmlSubstituteEntitiesDefaultValue = Module._xmlSubstituteEntitiesDefaultValue = 15308384, _xmlRegisterNodeDefaultValue = Module._xmlRegisterNodeDefaultValue = 15308388, _xmlDeregisterNodeDefaultValue = Module._xmlDeregisterNodeDefaultValue = 15308392, _xmlParserInputBufferCreateFilenameValue = Module._xmlParserInputBufferCreateFilenameValue = 15308396, _xmlOutputBufferCreateFilenameValue = Module._xmlOutputBufferCreateFilenameValue = 15308400, _xmlIndentTreeOutput = Module._xmlIndentTreeOutput = 15139280, _xmlTreeIndentString = Module._xmlTreeIndentString = 15139284, _xmlSaveNoEmptyTags = Module._xmlSaveNoEmptyTags = 15308416, _xmlDefaultSAXHandler = Module._xmlDefaultSAXHandler = 15139288, _xmlDefaultSAXLocator = Module._xmlDefaultSAXLocator = 15139400, _xmlParserMaxDepth = Module._xmlParserMaxDepth = 15139668, _xmlStringText = Module._xmlStringText = 14786464, _xmlStringComment = Module._xmlStringComment = 14786479, _xmlStringTextNoenc = Module._xmlStringTextNoenc = 14786469, _xmlXPathNAN = Module._xmlXPathNAN = 15309080, _xmlXPathNINF = Module._xmlXPathNINF = 15309096, _xmlXPathPINF = Module._xmlXPathPINF = 15309088, _z_errmsg = Module._z_errmsg = 15156224, __length_code = Module.__length_code = 14806128, __dist_code = Module.__dist_code = 14805616;
    function invoke_iii(e, t, r2) {
      var a = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2);
      } catch (o3) {
        if (stackRestore(a), o3 !== o3 + 0)
          throw o3;
        _setThrew(1, 0);
      }
    }
    function invoke_viiii(e, t, r2, a, o3) {
      var s2 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a, o3);
      } catch (l3) {
        if (stackRestore(s2), l3 !== l3 + 0)
          throw l3;
        _setThrew(1, 0);
      }
    }
    function invoke_vi(e, t) {
      var r2 = stackSave();
      try {
        getWasmTableEntry(e)(t);
      } catch (a) {
        if (stackRestore(r2), a !== a + 0)
          throw a;
        _setThrew(1, 0);
      }
    }
    function invoke_v(e) {
      var t = stackSave();
      try {
        getWasmTableEntry(e)();
      } catch (r2) {
        if (stackRestore(t), r2 !== r2 + 0)
          throw r2;
        _setThrew(1, 0);
      }
    }
    function invoke_j(e) {
      var t = stackSave();
      try {
        return getWasmTableEntry(e)();
      } catch (r2) {
        if (stackRestore(t), r2 !== r2 + 0)
          throw r2;
        return _setThrew(1, 0), 0n;
      }
    }
    function invoke_viiiiii(e, t, r2, a, o3, s2, l3) {
      var _2 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a, o3, s2, l3);
      } catch (n) {
        if (stackRestore(_2), n !== n + 0)
          throw n;
        _setThrew(1, 0);
      }
    }
    function invoke_vii(e, t, r2) {
      var a = stackSave();
      try {
        getWasmTableEntry(e)(t, r2);
      } catch (o3) {
        if (stackRestore(a), o3 !== o3 + 0)
          throw o3;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiii(e, t, r2, a, o3, s2) {
      var l3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a, o3, s2);
      } catch (_2) {
        if (stackRestore(l3), _2 !== _2 + 0)
          throw _2;
        _setThrew(1, 0);
      }
    }
    function invoke_i(e) {
      var t = stackSave();
      try {
        return getWasmTableEntry(e)();
      } catch (r2) {
        if (stackRestore(t), r2 !== r2 + 0)
          throw r2;
        _setThrew(1, 0);
      }
    }
    function invoke_ii(e, t) {
      var r2 = stackSave();
      try {
        return getWasmTableEntry(e)(t);
      } catch (a) {
        if (stackRestore(r2), a !== a + 0)
          throw a;
        _setThrew(1, 0);
      }
    }
    function invoke_viii(e, t, r2, a) {
      var o3 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a);
      } catch (s2) {
        if (stackRestore(o3), s2 !== s2 + 0)
          throw s2;
        _setThrew(1, 0);
      }
    }
    function invoke_iiii(e, t, r2, a) {
      var o3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a);
      } catch (s2) {
        if (stackRestore(o3), s2 !== s2 + 0)
          throw s2;
        _setThrew(1, 0);
      }
    }
    function invoke_vji(e, t, r2) {
      var a = stackSave();
      try {
        getWasmTableEntry(e)(t, r2);
      } catch (o3) {
        if (stackRestore(a), o3 !== o3 + 0)
          throw o3;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiii(e, t, r2, a, o3) {
      var s2 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a, o3);
      } catch (l3) {
        if (stackRestore(s2), l3 !== l3 + 0)
          throw l3;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiiii(e, t, r2, a, o3, s2, l3, _2) {
      var n = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a, o3, s2, l3, _2);
      } catch (m2) {
        if (stackRestore(n), m2 !== m2 + 0)
          throw m2;
        _setThrew(1, 0);
      }
    }
    function invoke_viiiiiiiii(e, t, r2, a, o3, s2, l3, _2, n, m2) {
      var p = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a, o3, s2, l3, _2, n, m2);
      } catch (d2) {
        if (stackRestore(p), d2 !== d2 + 0)
          throw d2;
        _setThrew(1, 0);
      }
    }
    function invoke_viiiii(e, t, r2, a, o3, s2) {
      var l3 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a, o3, s2);
      } catch (_2) {
        if (stackRestore(l3), _2 !== _2 + 0)
          throw _2;
        _setThrew(1, 0);
      }
    }
    function invoke_jii(e, t, r2) {
      var a = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2);
      } catch (o3) {
        if (stackRestore(a), o3 !== o3 + 0)
          throw o3;
        return _setThrew(1, 0), 0n;
      }
    }
    function invoke_ji(e, t) {
      var r2 = stackSave();
      try {
        return getWasmTableEntry(e)(t);
      } catch (a) {
        if (stackRestore(r2), a !== a + 0)
          throw a;
        return _setThrew(1, 0), 0n;
      }
    }
    function invoke_jiiiiiiiii(e, t, r2, a, o3, s2, l3, _2, n, m2) {
      var p = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a, o3, s2, l3, _2, n, m2);
      } catch (d2) {
        if (stackRestore(p), d2 !== d2 + 0)
          throw d2;
        return _setThrew(1, 0), 0n;
      }
    }
    function invoke_jiiiiii(e, t, r2, a, o3, s2, l3) {
      var _2 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a, o3, s2, l3);
      } catch (n) {
        if (stackRestore(_2), n !== n + 0)
          throw n;
        return _setThrew(1, 0), 0n;
      }
    }
    function invoke_iiiiiiiiiiiiii(e, t, r2, a, o3, s2, l3, _2, n, m2, p, d2, g3, u3) {
      var f = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a, o3, s2, l3, _2, n, m2, p, d2, g3, u3);
      } catch (c) {
        if (stackRestore(f), c !== c + 0)
          throw c;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiijii(e, t, r2, a, o3, s2, l3) {
      var _2 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a, o3, s2, l3);
      } catch (n) {
        if (stackRestore(_2), n !== n + 0)
          throw n;
        _setThrew(1, 0);
      }
    }
    function invoke_vijiji(e, t, r2, a, o3, s2) {
      var l3 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a, o3, s2);
      } catch (_2) {
        if (stackRestore(l3), _2 !== _2 + 0)
          throw _2;
        _setThrew(1, 0);
      }
    }
    function invoke_viji(e, t, r2, a) {
      var o3 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a);
      } catch (s2) {
        if (stackRestore(o3), s2 !== s2 + 0)
          throw s2;
        _setThrew(1, 0);
      }
    }
    function invoke_iiji(e, t, r2, a) {
      var o3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a);
      } catch (s2) {
        if (stackRestore(o3), s2 !== s2 + 0)
          throw s2;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiiiii(e, t, r2, a, o3, s2, l3, _2, n) {
      var m2 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a, o3, s2, l3, _2, n);
      } catch (p) {
        if (stackRestore(m2), p !== p + 0)
          throw p;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiiiiiiiiiiiiii(e, t, r2, a, o3, s2, l3, _2, n, m2, p, d2, g3, u3, f, c, w2, h3) {
      var v2 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a, o3, s2, l3, _2, n, m2, p, d2, g3, u3, f, c, w2, h3);
      } catch (x3) {
        if (stackRestore(v2), x3 !== x3 + 0)
          throw x3;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiij(e, t, r2, a, o3) {
      var s2 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a, o3);
      } catch (l3) {
        if (stackRestore(s2), l3 !== l3 + 0)
          throw l3;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiii(e, t, r2, a, o3, s2, l3) {
      var _2 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a, o3, s2, l3);
      } catch (n) {
        if (stackRestore(_2), n !== n + 0)
          throw n;
        _setThrew(1, 0);
      }
    }
    function invoke_vj(e, t) {
      var r2 = stackSave();
      try {
        getWasmTableEntry(e)(t);
      } catch (a) {
        if (stackRestore(r2), a !== a + 0)
          throw a;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiiiiii(e, t, r2, a, o3, s2, l3, _2, n, m2) {
      var p = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a, o3, s2, l3, _2, n, m2);
      } catch (d2) {
        if (stackRestore(p), d2 !== d2 + 0)
          throw d2;
        _setThrew(1, 0);
      }
    }
    function invoke_viiji(e, t, r2, a, o3) {
      var s2 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a, o3);
      } catch (l3) {
        if (stackRestore(s2), l3 !== l3 + 0)
          throw l3;
        _setThrew(1, 0);
      }
    }
    function invoke_viiiiiiii(e, t, r2, a, o3, s2, l3, _2, n) {
      var m2 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a, o3, s2, l3, _2, n);
      } catch (p) {
        if (stackRestore(m2), p !== p + 0)
          throw p;
        _setThrew(1, 0);
      }
    }
    function invoke_vij(e, t, r2) {
      var a = stackSave();
      try {
        getWasmTableEntry(e)(t, r2);
      } catch (o3) {
        if (stackRestore(a), o3 !== o3 + 0)
          throw o3;
        _setThrew(1, 0);
      }
    }
    function invoke_ij(e, t) {
      var r2 = stackSave();
      try {
        return getWasmTableEntry(e)(t);
      } catch (a) {
        if (stackRestore(r2), a !== a + 0)
          throw a;
        _setThrew(1, 0);
      }
    }
    function invoke_viiiiiii(e, t, r2, a, o3, s2, l3, _2) {
      var n = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a, o3, s2, l3, _2);
      } catch (m2) {
        if (stackRestore(n), m2 !== m2 + 0)
          throw m2;
        _setThrew(1, 0);
      }
    }
    function invoke_viiiji(e, t, r2, a, o3, s2) {
      var l3 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a, o3, s2);
      } catch (_2) {
        if (stackRestore(l3), _2 !== _2 + 0)
          throw _2;
        _setThrew(1, 0);
      }
    }
    function invoke_iiij(e, t, r2, a) {
      var o3 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a);
      } catch (s2) {
        if (stackRestore(o3), s2 !== s2 + 0)
          throw s2;
        _setThrew(1, 0);
      }
    }
    function invoke_vid(e, t, r2) {
      var a = stackSave();
      try {
        getWasmTableEntry(e)(t, r2);
      } catch (o3) {
        if (stackRestore(a), o3 !== o3 + 0)
          throw o3;
        _setThrew(1, 0);
      }
    }
    function invoke_ijiiiiii(e, t, r2, a, o3, s2, l3, _2) {
      var n = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a, o3, s2, l3, _2);
      } catch (m2) {
        if (stackRestore(n), m2 !== m2 + 0)
          throw m2;
        _setThrew(1, 0);
      }
    }
    function invoke_viijii(e, t, r2, a, o3, s2) {
      var l3 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a, o3, s2);
      } catch (_2) {
        if (stackRestore(l3), _2 !== _2 + 0)
          throw _2;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiji(e, t, r2, a, o3, s2, l3) {
      var _2 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a, o3, s2, l3);
      } catch (n) {
        if (stackRestore(_2), n !== n + 0)
          throw n;
        _setThrew(1, 0);
      }
    }
    function invoke_viijiiii(e, t, r2, a, o3, s2, l3, _2) {
      var n = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a, o3, s2, l3, _2);
      } catch (m2) {
        if (stackRestore(n), m2 !== m2 + 0)
          throw m2;
        _setThrew(1, 0);
      }
    }
    function invoke_viij(e, t, r2, a) {
      var o3 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a);
      } catch (s2) {
        if (stackRestore(o3), s2 !== s2 + 0)
          throw s2;
        _setThrew(1, 0);
      }
    }
    function invoke_jiiii(e, t, r2, a, o3) {
      var s2 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a, o3);
      } catch (l3) {
        if (stackRestore(s2), l3 !== l3 + 0)
          throw l3;
        return _setThrew(1, 0), 0n;
      }
    }
    function invoke_viiiiiiiiiiii(e, t, r2, a, o3, s2, l3, _2, n, m2, p, d2, g3) {
      var u3 = stackSave();
      try {
        getWasmTableEntry(e)(t, r2, a, o3, s2, l3, _2, n, m2, p, d2, g3);
      } catch (f) {
        if (stackRestore(u3), f !== f + 0)
          throw f;
        _setThrew(1, 0);
      }
    }
    function invoke_di(e, t) {
      var r2 = stackSave();
      try {
        return getWasmTableEntry(e)(t);
      } catch (a) {
        if (stackRestore(r2), a !== a + 0)
          throw a;
        _setThrew(1, 0);
      }
    }
    function invoke_id(e, t) {
      var r2 = stackSave();
      try {
        return getWasmTableEntry(e)(t);
      } catch (a) {
        if (stackRestore(r2), a !== a + 0)
          throw a;
        _setThrew(1, 0);
      }
    }
    function invoke_ijiiiii(e, t, r2, a, o3, s2, l3) {
      var _2 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a, o3, s2, l3);
      } catch (n) {
        if (stackRestore(_2), n !== n + 0)
          throw n;
        _setThrew(1, 0);
      }
    }
    function invoke_iiiiiiiiiii(e, t, r2, a, o3, s2, l3, _2, n, m2, p) {
      var d2 = stackSave();
      try {
        return getWasmTableEntry(e)(t, r2, a, o3, s2, l3, _2, n, m2, p);
      } catch (g3) {
        if (stackRestore(d2), g3 !== g3 + 0)
          throw g3;
        _setThrew(1, 0);
      }
    }
    Module.addRunDependency = addRunDependency, Module.removeRunDependency = removeRunDependency, Module.setValue = setValue, Module.getValue = getValue, Module.UTF8ToString = UTF8ToString, Module.stringToNewUTF8 = stringToNewUTF8, Module.stringToUTF8OnStack = stringToUTF8OnStack, Module.FS_createPreloadedFile = FS_createPreloadedFile, Module.FS_unlink = FS_unlink, Module.FS_createPath = FS_createPath, Module.FS_createDevice = FS_createDevice, Module.FS = FS, Module.FS_createDataFile = FS_createDataFile, Module.FS_createLazyFile = FS_createLazyFile, Module.MEMFS = MEMFS, Module.IDBFS = IDBFS;
    var calledRun;
    dependenciesFulfilled = function e() {
      calledRun || run(), calledRun || (dependenciesFulfilled = e);
    };
    function callMain(e = []) {
      var t = resolveGlobalSymbol("main").sym;
      if (t) {
        e.unshift(thisProgram);
        var r2 = e.length, a = stackAlloc((r2 + 1) * 4), o3 = a;
        e.forEach((l3) => {
          HEAPU32[o3 >> 2] = stringToUTF8OnStack(l3), o3 += 4;
        }), HEAPU32[o3 >> 2] = 0;
        try {
          var s2 = t(r2, a);
          return exitJS(s2, true), s2;
        } catch (l3) {
          return handleException(l3);
        }
      }
    }
    function run(e = arguments_) {
      if (runDependencies > 0 || (preRun(), runDependencies > 0))
        return;
      function t() {
        calledRun || (calledRun = true, Module.calledRun = true, !ABORT && (initRuntime(), preMain(), readyPromiseResolve(Module), Module.onRuntimeInitialized?.(), shouldRunNow && callMain(e), postRun()));
      }
      Module.setStatus ? (Module.setStatus("Running..."), setTimeout(() => {
        setTimeout(() => Module.setStatus(""), 1), t();
      }, 1)) : t();
    }
    if (Module.preInit)
      for (typeof Module.preInit == "function" && (Module.preInit = [Module.preInit]);Module.preInit.length > 0; )
        Module.preInit.pop()();
    var shouldRunNow = true;
    return Module.noInitialRun && (shouldRunNow = false), run(), moduleRtn = readyPromise, moduleRtn;
  };
})();
var Ue2 = Ze2;
var Re2 = Ue2;
var J2;
var j2;
var V;
var Q2;
var $2;
var ie;
var me2;
var pe2;
var de2;
var Z2;
var ae;
var oe;
var se2;
var le2;
var K2;
var H2;
var A2;
var Y2;
var T2;
var De2;
var re2;
var ze2;
var Ne2;
var ue2 = class ue3 extends z2 {
  constructor(r2 = {}, a = {}) {
    super();
    R(this, T2);
    R(this, J2, false);
    R(this, j2, false);
    R(this, V, false);
    R(this, Q2, false);
    R(this, $2, false);
    R(this, ie, new X2);
    R(this, me2, new X2);
    R(this, pe2, new X2);
    R(this, de2, new X2);
    R(this, Z2, false);
    R(this, ae, "cma");
    this.debug = 0;
    R(this, oe);
    R(this, se2, []);
    R(this, le2, new ye);
    R(this, K2);
    R(this, H2);
    R(this, A2, new Map);
    R(this, Y2, new Set);
    typeof r2 == "string" ? a = { dataDir: r2, ...a } : a = r2, this.dataDir = a.dataDir, a.parsers !== undefined && (this.parsers = { ...this.parsers, ...a.parsers }), a.serializers !== undefined && (this.serializers = { ...this.serializers, ...a.serializers }), a?.debug !== undefined && (this.debug = a.debug), a?.relaxedDurability !== undefined && x(this, $2, a.relaxedDurability), a?.defaultDataTransferContainer !== undefined && x(this, ae, a.defaultDataTransferContainer), x(this, oe, a.extensions ?? {}), this.waitReady = T(this, T2, De2).call(this, a ?? {});
  }
  static async create(r2, a) {
    let o3 = typeof r2 == "string" ? { dataDir: r2, ...a ?? {} } : r2 ?? {}, s2 = new ue3(o3);
    return await s2.waitReady, s2;
  }
  get Module() {
    return this.mod;
  }
  get ready() {
    return h(this, J2) && !h(this, j2) && !h(this, V);
  }
  get closed() {
    return h(this, V);
  }
  async close() {
    await this._checkReady(), x(this, j2, true);
    for (let r2 of h(this, se2))
      await r2();
    try {
      await this.execProtocol(O.end()), this.mod._pgl_shutdown();
    } catch (r2) {
      let a = r2;
      if (!(a.name === "ExitStatus" && a.status === 0))
        throw r2;
    }
    await this.fs.closeFs(), x(this, V, true), x(this, j2, false);
  }
  async[Symbol.asyncDispose]() {
    await this.close();
  }
  async _handleBlob(r2) {
    x(this, K2, r2 ? await r2.arrayBuffer() : undefined);
  }
  async _cleanupBlob() {
    x(this, K2, undefined);
  }
  async _getWrittenBlob() {
    if (!h(this, H2))
      return;
    let r2 = new Blob(h(this, H2));
    return x(this, H2, undefined), r2;
  }
  async _checkReady() {
    if (h(this, j2))
      throw new Error("PGlite is closing");
    if (h(this, V))
      throw new Error("PGlite is closed");
    h(this, J2) || await this.waitReady;
  }
  execProtocolRawSync(r2, a = {}) {
    let o3, s2 = this.mod;
    s2._use_wire(1);
    let l3 = r2.length, _2 = a.dataTransferContainer ?? h(this, ae);
    switch (r2.length >= s2.FD_BUFFER_MAX && (_2 = "file"), _2) {
      case "cma": {
        s2._interactive_write(r2.length), s2.HEAPU8.set(r2, 1);
        break;
      }
      case "file": {
        let m2 = "/tmp/pglite/base/.s.PGSQL.5432.lck.in", p = "/tmp/pglite/base/.s.PGSQL.5432.in";
        s2._interactive_write(0), s2.FS.writeFile(m2, r2), s2.FS.rename(m2, p);
        break;
      }
      default:
        throw new Error(`Unknown data transfer container: ${_2}`);
    }
    s2._interactive_one();
    let n = s2._get_channel();
    switch (n < 0 && (_2 = "file"), n > 0 && (_2 = "cma"), _2) {
      case "cma": {
        let m2 = l3 + 2, p = m2 + s2._interactive_read();
        o3 = s2.HEAPU8.subarray(m2, p);
        break;
      }
      case "file": {
        let m2 = "/tmp/pglite/base/.s.PGSQL.5432.out";
        try {
          let p = s2.FS.stat(m2), d2 = s2.FS.open(m2, "r");
          o3 = new Uint8Array(p.size), s2.FS.read(d2, o3, 0, p.size, 0), s2.FS.unlink(m2);
        } catch {
          o3 = new Uint8Array(0);
        }
        break;
      }
      default:
        throw new Error(`Unknown data transfer container: ${_2}`);
    }
    return o3;
  }
  async execProtocolRaw(r2, { syncToFs: a = true, dataTransferContainer: o3 } = {}) {
    let s2 = this.execProtocolRawSync(r2, { dataTransferContainer: o3 });
    return a && await this.syncToFs(), s2;
  }
  async execProtocol(r2, { syncToFs: a = true, throwOnError: o3 = true, onNotice: s2 } = {}) {
    let l3 = await this.execProtocolRaw(r2, { syncToFs: a }), _2 = [];
    return h(this, le2).parse(l3, (n) => {
      if (n instanceof E) {
        if (x(this, le2, new ye), o3)
          throw n;
      } else if (n instanceof ne2)
        this.debug > 0 && console.warn(n), s2 && s2(n);
      else if (n instanceof ee)
        switch (n.text) {
          case "BEGIN":
            x(this, Q2, true);
            break;
          case "COMMIT":
          case "ROLLBACK":
            x(this, Q2, false);
            break;
        }
      else if (n instanceof X) {
        let m2 = h(this, A2).get(n.channel);
        m2 && m2.forEach((p) => {
          queueMicrotask(() => p(n.payload));
        }), h(this, Y2).forEach((p) => {
          queueMicrotask(() => p(n.channel, n.payload));
        });
      }
      _2.push(n);
    }), { messages: _2, data: l3 };
  }
  isInTransaction() {
    return h(this, Q2);
  }
  async syncToFs() {
    if (h(this, Z2))
      return;
    x(this, Z2, true);
    let r2 = async () => {
      await h(this, de2).runExclusive(async () => {
        x(this, Z2, false), await this.fs.syncToFs(h(this, $2));
      });
    };
    h(this, $2) ? r2() : await r2();
  }
  async listen(r2, a) {
    return this._runExclusiveListen(() => T(this, T2, ze2).call(this, r2, a));
  }
  async unlisten(r2, a) {
    return this._runExclusiveListen(() => T(this, T2, Ne2).call(this, r2, a));
  }
  onNotification(r2) {
    return h(this, Y2).add(r2), () => {
      h(this, Y2).delete(r2);
    };
  }
  offNotification(r2) {
    h(this, Y2).delete(r2);
  }
  async dumpDataDir(r2) {
    await this._checkReady();
    let a = this.dataDir?.split("/").pop() ?? "pgdata";
    return this.fs.dumpTar(a, r2);
  }
  _runExclusiveQuery(r2) {
    return h(this, ie).runExclusive(r2);
  }
  _runExclusiveTransaction(r2) {
    return h(this, me2).runExclusive(r2);
  }
  async clone() {
    let r2 = await this.dumpDataDir("none");
    return ue3.create({ loadDataDir: r2 });
  }
  _runExclusiveListen(r2) {
    return h(this, pe2).runExclusive(r2);
  }
};
J2 = new WeakMap, j2 = new WeakMap, V = new WeakMap, Q2 = new WeakMap, $2 = new WeakMap, ie = new WeakMap, me2 = new WeakMap, pe2 = new WeakMap, de2 = new WeakMap, Z2 = new WeakMap, ae = new WeakMap, oe = new WeakMap, se2 = new WeakMap, le2 = new WeakMap, K2 = new WeakMap, H2 = new WeakMap, A2 = new WeakMap, Y2 = new WeakMap, T2 = new WeakSet, De2 = async function(r2) {
  if (r2.fs)
    this.fs = r2.fs;
  else {
    let { dataDir: d2, fsType: g3 } = Ae2(r2.dataDir);
    this.fs = await Te2(d2, g3);
  }
  let a = {}, o3 = [], s2 = [`PGDATA=${C}`, `PREFIX=${Vr}`, `PGUSER=${r2.username ?? "postgres"}`, `PGDATABASE=${r2.database ?? "template1"}`, "MODE=REACT", "REPL=N", ...this.debug ? ["-d", this.debug.toString()] : []];
  r2.wasmModule || Rr();
  let l3 = r2.fsBundle ? r2.fsBundle.arrayBuffer() : Er(), _2;
  l3.then((d2) => {
    _2 = d2;
  });
  let n = { WASM_PREFIX: Vr, arguments: s2, INITIAL_MEMORY: r2.initialMemory, noExitRuntime: true, ...this.debug > 0 ? { print: console.info, printErr: console.error } : { print: () => {
  }, printErr: () => {
  } }, instantiateWasm: (d2, g3) => (Tr(d2, r2.wasmModule).then(({ instance: u3, module: f }) => {
    g3(u3, f);
  }), {}), getPreloadedPackage: (d2, g3) => {
    if (d2 === "pglite.data") {
      if (_2.byteLength !== g3)
        throw new Error(`Invalid FS bundle size: ${_2.byteLength} !== ${g3}`);
      return _2;
    }
    throw new Error(`Unknown package: ${d2}`);
  }, preRun: [(d2) => {
    let g3 = d2.FS.makedev(64, 0), u3 = { open: (f) => {
    }, close: (f) => {
    }, read: (f, c, w2, h3, v2) => {
      let x3 = h(this, K2);
      if (!x3)
        throw new Error("No /dev/blob File or Blob provided to read from");
      let y2 = new Uint8Array(x3);
      if (v2 >= y2.length)
        return 0;
      let M2 = Math.min(y2.length - v2, h3);
      for (let E2 = 0;E2 < M2; E2++)
        c[w2 + E2] = y2[v2 + E2];
      return M2;
    }, write: (f, c, w2, h3, v2) => (h(this, H2) ?? x(this, H2, []), h(this, H2).push(c.slice(w2, w2 + h3)), h3), llseek: (f, c, w2) => {
      let h3 = h(this, K2);
      if (!h3)
        throw new Error("No /dev/blob File or Blob provided to llseek");
      let v2 = c;
      if (w2 === 1 ? v2 += f.position : w2 === 2 && (v2 = new Uint8Array(h3).length), v2 < 0)
        throw new d2.FS.ErrnoError(28);
      return v2;
    } };
    d2.FS.registerDevice(g3, u3), d2.FS.mkdev("/dev/blob", g3);
  }] }, { emscriptenOpts: m2 } = await this.fs.init(this, n);
  n = m2;
  for (let [d2, g3] of Object.entries(h(this, oe)))
    if (g3 instanceof URL)
      a[d2] = xe2(g3);
    else {
      let u3 = await g3.setup(this, n);
      if (u3.emscriptenOpts && (n = u3.emscriptenOpts), u3.namespaceObj) {
        let f = this;
        f[d2] = u3.namespaceObj;
      }
      u3.bundlePath && (a[d2] = xe2(u3.bundlePath)), u3.init && o3.push(u3.init), u3.close && h(this, se2).push(u3.close);
    }
  if (n.pg_extensions = a, await l3, this.mod = await Re2(n), await this.fs.initialSyncFs(), r2.loadDataDir) {
    if (this.mod.FS.analyzePath(C + "/PG_VERSION").exists)
      throw new Error("Database already exists, cannot load from tarball");
    T(this, T2, re2).call(this, "pglite: loading data from tarball"), await ce(this.mod.FS, r2.loadDataDir, C);
  }
  this.mod.FS.analyzePath(C + "/PG_VERSION").exists ? T(this, T2, re2).call(this, "pglite: found DB, resuming") : T(this, T2, re2).call(this, "pglite: no db"), await ke2(this.mod, (...d2) => T(this, T2, re2).call(this, ...d2));
  let p = this.mod._pgl_initdb();
  if (!p)
    throw new Error("INITDB failed to return value");
  if (p & 1)
    throw new Error("INITDB: failed to execute");
  if (p & 2) {
    let d2 = r2.username ?? "postgres", g3 = r2.database ?? "template1";
    if (p & 4) {
      if (!(p & 12))
        throw new Error(`INITDB: Invalid db ${g3}/user ${d2} combination`);
    } else if (g3 !== "template1" && d2 !== "postgres")
      throw new Error(`INITDB: created a new datadir ${C}, but an alternative db ${g3}/user ${d2} was requested`);
  }
  this.mod._pgl_backend(), await this.syncToFs(), x(this, J2, true), await this.exec("SET search_path TO public;"), await this._initArrayTypes();
  for (let d2 of o3)
    await d2();
}, re2 = function(...r2) {
  this.debug > 0 && console.log(...r2);
}, ze2 = async function(r2, a) {
  let o3 = Nr(r2);
  h(this, A2).has(o3) || h(this, A2).set(o3, new Set), h(this, A2).get(o3).add(a);
  try {
    await this.exec(`LISTEN ${r2}`);
  } catch (s2) {
    throw h(this, A2).get(o3).delete(a), h(this, A2).get(o3)?.size === 0 && h(this, A2).delete(o3), s2;
  }
  return async () => {
    await this.unlisten(o3, a);
  };
}, Ne2 = async function(r2, a) {
  let o3 = Nr(r2), s2 = async () => {
    await this.exec(`UNLISTEN ${r2}`), h(this, A2).get(o3)?.size === 0 && h(this, A2).delete(o3);
  };
  a ? (h(this, A2).get(o3)?.delete(a), h(this, A2).get(o3)?.size === 0 && await s2()) : await s2();
};
var qe2 = ue2;
u();

// ../../node_modules/.pnpm/@electric-sql+client@1.0.0/node_modules/@electric-sql/client/dist/index.mjs
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp.call(b3, prop))
      __defNormalProp(a, prop, b3[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b3)) {
      if (__propIsEnum.call(b3, prop))
        __defNormalProp(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps = (a, b3) => __defProps(a, __getOwnPropDescs(b3));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x3) => x3.done ? resolve(x3.value) : Promise.resolve(x3.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var FetchError = class _FetchError extends Error {
  constructor(status, text2, json2, headers, url, message) {
    super(message || `HTTP Error ${status} at ${url}: ${text2 != null ? text2 : JSON.stringify(json2)}`);
    this.url = url;
    this.name = `FetchError`;
    this.status = status;
    this.text = text2;
    this.json = json2;
    this.headers = headers;
  }
  static fromResponse(response, url) {
    return __async(this, null, function* () {
      const status = response.status;
      const headers = Object.fromEntries([...response.headers.entries()]);
      let text2 = undefined;
      let json2 = undefined;
      const contentType = response.headers.get(`content-type`);
      if (contentType && contentType.includes(`application/json`)) {
        json2 = yield response.json();
      } else {
        text2 = yield response.text();
      }
      return new _FetchError(status, text2, json2, headers, url);
    });
  }
};
var FetchBackoffAbortError = class extends Error {
  constructor() {
    super(`Fetch with backoff aborted`);
    this.name = `FetchBackoffAbortError`;
  }
};
var MissingShapeUrlError = class extends Error {
  constructor() {
    super(`Invalid shape options: missing required url parameter`);
    this.name = `MissingShapeUrlError`;
  }
};
var InvalidSignalError = class extends Error {
  constructor() {
    super(`Invalid signal option. It must be an instance of AbortSignal.`);
    this.name = `InvalidSignalError`;
  }
};
var MissingShapeHandleError = class extends Error {
  constructor() {
    super(`shapeHandle is required if this isn't an initial fetch (i.e. offset > -1)`);
    this.name = `MissingShapeHandleError`;
  }
};
var ReservedParamError = class extends Error {
  constructor(reservedParams) {
    super(`Cannot use reserved Electric parameter names in custom params: ${reservedParams.join(`, `)}`);
    this.name = `ReservedParamError`;
  }
};
var ParserNullValueError = class extends Error {
  constructor(columnName) {
    super(`Column "${columnName != null ? columnName : `unknown`}" does not allow NULL values`);
    this.name = `ParserNullValueError`;
  }
};
var MissingHeadersError = class extends Error {
  constructor(url, missingHeaders) {
    let msg = `The response for the shape request to ${url} didn't include the following required headers:
`;
    missingHeaders.forEach((h3) => {
      msg += `- ${h3}
`;
    });
    msg += `
This is often due to a proxy not setting CORS correctly so that all Electric headers can be read by the client.`;
    msg += `
For more information visit the troubleshooting guide: /docs/guides/troubleshooting/missing-headers`;
    super(msg);
  }
};
var parseNumber = (value) => Number(value);
var parseBool = (value) => value === `true` || value === `t`;
var parseBigInt = (value) => BigInt(value);
var parseJson = (value) => JSON.parse(value);
var identityParser = (v2) => v2;
var defaultParser = {
  int2: parseNumber,
  int4: parseNumber,
  int8: parseBigInt,
  bool: parseBool,
  float4: parseNumber,
  float8: parseNumber,
  json: parseJson,
  jsonb: parseJson
};
function pgArrayParser(value, parser) {
  let i2 = 0;
  let char2 = null;
  let str = ``;
  let quoted = false;
  let last = 0;
  let p = undefined;
  function loop(x3) {
    const xs = [];
    for (;i2 < x3.length; i2++) {
      char2 = x3[i2];
      if (quoted) {
        if (char2 === `\\`) {
          str += x3[++i2];
        } else if (char2 === `"`) {
          xs.push(parser ? parser(str) : str);
          str = ``;
          quoted = x3[i2 + 1] === `"`;
          last = i2 + 2;
        } else {
          str += char2;
        }
      } else if (char2 === `"`) {
        quoted = true;
      } else if (char2 === `{`) {
        last = ++i2;
        xs.push(loop(x3));
      } else if (char2 === `}`) {
        quoted = false;
        last < i2 && xs.push(parser ? parser(x3.slice(last, i2)) : x3.slice(last, i2));
        last = i2 + 1;
        break;
      } else if (char2 === `,` && p !== `}` && p !== `"`) {
        xs.push(parser ? parser(x3.slice(last, i2)) : x3.slice(last, i2));
        last = i2 + 1;
      }
      p = char2;
    }
    last < i2 && xs.push(parser ? parser(x3.slice(last, i2 + 1)) : x3.slice(last, i2 + 1));
    return xs;
  }
  return loop(value)[0];
}
var MessageParser = class {
  constructor(parser) {
    this.parser = __spreadValues(__spreadValues({}, defaultParser), parser);
  }
  parse(messages2, schema) {
    return JSON.parse(messages2, (key, value) => {
      if ((key === `value` || key === `old_value`) && typeof value === `object` && value !== null) {
        const row = value;
        Object.keys(row).forEach((key2) => {
          row[key2] = this.parseRow(key2, row[key2], schema);
        });
      }
      return value;
    });
  }
  parseRow(key, value, schema) {
    var _b;
    const columnInfo = schema[key];
    if (!columnInfo) {
      return value;
    }
    const _a = columnInfo, { type: typ, dims: dimensions } = _a, additionalInfo = __objRest(_a, ["type", "dims"]);
    const typeParser = (_b = this.parser[typ]) != null ? _b : identityParser;
    const parser = makeNullableParser(typeParser, columnInfo, key);
    if (dimensions && dimensions > 0) {
      const nullablePgArrayParser = makeNullableParser((value2, _2) => pgArrayParser(value2, parser), columnInfo, key);
      return nullablePgArrayParser(value);
    }
    return parser(value, additionalInfo);
  }
};
function makeNullableParser(parser, columnInfo, columnName) {
  var _a;
  const isNullable = !((_a = columnInfo.not_null) != null ? _a : false);
  return (value) => {
    if (isPgNull(value)) {
      if (!isNullable) {
        throw new ParserNullValueError(columnName != null ? columnName : `unknown`);
      }
      return null;
    }
    return parser(value, columnInfo);
  };
}
function isPgNull(value) {
  return value === null || value === `NULL`;
}
function isChangeMessage(message) {
  return `key` in message;
}
function isControlMessage(message) {
  return !isChangeMessage(message);
}
function isUpToDateMessage(message) {
  return isControlMessage(message) && message.headers.control === `up-to-date`;
}
var LIVE_CACHE_BUSTER_HEADER = `electric-cursor`;
var SHAPE_HANDLE_HEADER = `electric-handle`;
var CHUNK_LAST_OFFSET_HEADER = `electric-offset`;
var SHAPE_SCHEMA_HEADER = `electric-schema`;
var CHUNK_UP_TO_DATE_HEADER = `electric-up-to-date`;
var COLUMNS_QUERY_PARAM = `columns`;
var LIVE_CACHE_BUSTER_QUERY_PARAM = `cursor`;
var SHAPE_HANDLE_QUERY_PARAM = `handle`;
var LIVE_QUERY_PARAM = `live`;
var OFFSET_QUERY_PARAM = `offset`;
var TABLE_QUERY_PARAM = `table`;
var WHERE_QUERY_PARAM = `where`;
var REPLICA_PARAM = `replica`;
var WHERE_PARAMS_PARAM = `params`;
var FORCE_DISCONNECT_AND_REFRESH = `force-disconnect-and-refresh`;
var HTTP_RETRY_STATUS_CODES = [429];
var BackoffDefaults = {
  initialDelay: 100,
  maxDelay: 1e4,
  multiplier: 1.3
};
function createFetchWithBackoff(fetchClient, backoffOptions = BackoffDefaults) {
  const {
    initialDelay,
    maxDelay,
    multiplier,
    debug = false,
    onFailedAttempt
  } = backoffOptions;
  return (...args2) => __async(this, null, function* () {
    var _a;
    const url = args2[0];
    const options = args2[1];
    let delay = initialDelay;
    let attempt = 0;
    while (true) {
      try {
        const result = yield fetchClient(...args2);
        if (result.ok)
          return result;
        else
          throw yield FetchError.fromResponse(result, url.toString());
      } catch (e) {
        onFailedAttempt == null || onFailedAttempt();
        if ((_a = options == null ? undefined : options.signal) == null ? undefined : _a.aborted) {
          throw new FetchBackoffAbortError;
        } else if (e instanceof FetchError && !HTTP_RETRY_STATUS_CODES.includes(e.status) && e.status >= 400 && e.status < 500) {
          throw e;
        } else {
          yield new Promise((resolve) => setTimeout(resolve, delay));
          delay = Math.min(delay * multiplier, maxDelay);
          if (debug) {
            attempt++;
            console.log(`Retry attempt #${attempt} after ${delay}ms`);
          }
        }
      }
    }
  });
}
var ChunkPrefetchDefaults = {
  maxChunksToPrefetch: 2
};
function createFetchWithChunkBuffer(fetchClient, prefetchOptions = ChunkPrefetchDefaults) {
  const { maxChunksToPrefetch } = prefetchOptions;
  let prefetchQueue;
  const prefetchClient = (...args2) => __async(this, null, function* () {
    const url = args2[0].toString();
    const prefetchedRequest = prefetchQueue == null ? undefined : prefetchQueue.consume(...args2);
    if (prefetchedRequest) {
      return prefetchedRequest;
    }
    prefetchQueue == null || prefetchQueue.abort();
    const response = yield fetchClient(...args2);
    const nextUrl = getNextChunkUrl(url, response);
    if (nextUrl) {
      prefetchQueue = new PrefetchQueue({
        fetchClient,
        maxPrefetchedRequests: maxChunksToPrefetch,
        url: nextUrl,
        requestInit: args2[1]
      });
    }
    return response;
  });
  return prefetchClient;
}
var requiredElectricResponseHeaders = [
  `electric-offset`,
  `electric-handle`
];
var requiredLiveResponseHeaders = [`electric-cursor`];
var requiredNonLiveResponseHeaders = [`electric-schema`];
function createFetchWithResponseHeadersCheck(fetchClient) {
  return (...args2) => __async(this, null, function* () {
    const response = yield fetchClient(...args2);
    if (response.ok) {
      const headers = response.headers;
      const missingHeaders = [];
      const addMissingHeaders = (requiredHeaders) => missingHeaders.push(...requiredHeaders.filter((h3) => !headers.has(h3)));
      addMissingHeaders(requiredElectricResponseHeaders);
      const input = args2[0];
      const urlString = input.toString();
      const url = new URL(urlString);
      if (url.searchParams.get(LIVE_QUERY_PARAM) === `true`) {
        addMissingHeaders(requiredLiveResponseHeaders);
      }
      if (!url.searchParams.has(LIVE_QUERY_PARAM) || url.searchParams.get(LIVE_QUERY_PARAM) === `false`) {
        addMissingHeaders(requiredNonLiveResponseHeaders);
      }
      if (missingHeaders.length > 0) {
        throw new MissingHeadersError(urlString, missingHeaders);
      }
    }
    return response;
  });
}
var _fetchClient;
var _maxPrefetchedRequests;
var _prefetchQueue;
var _queueHeadUrl;
var _queueTailUrl;
var _PrefetchQueue_instances;
var prefetch_fn;
var PrefetchQueue = class {
  constructor(options) {
    __privateAdd(this, _PrefetchQueue_instances);
    __privateAdd(this, _fetchClient);
    __privateAdd(this, _maxPrefetchedRequests);
    __privateAdd(this, _prefetchQueue, /* @__PURE__ */ new Map);
    __privateAdd(this, _queueHeadUrl);
    __privateAdd(this, _queueTailUrl);
    var _a;
    __privateSet(this, _fetchClient, (_a = options.fetchClient) != null ? _a : (...args2) => fetch(...args2));
    __privateSet(this, _maxPrefetchedRequests, options.maxPrefetchedRequests);
    __privateSet(this, _queueHeadUrl, options.url.toString());
    __privateSet(this, _queueTailUrl, __privateGet(this, _queueHeadUrl));
    __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, options.url, options.requestInit);
  }
  abort() {
    __privateGet(this, _prefetchQueue).forEach(([_2, aborter]) => aborter.abort());
  }
  consume(...args2) {
    var _a;
    const url = args2[0].toString();
    const request = (_a = __privateGet(this, _prefetchQueue).get(url)) == null ? undefined : _a[0];
    if (!request || url !== __privateGet(this, _queueHeadUrl))
      return;
    __privateGet(this, _prefetchQueue).delete(url);
    request.then((response) => {
      const nextUrl = getNextChunkUrl(url, response);
      __privateSet(this, _queueHeadUrl, nextUrl);
      if (__privateGet(this, _queueTailUrl) && !__privateGet(this, _prefetchQueue).has(__privateGet(this, _queueTailUrl))) {
        __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, __privateGet(this, _queueTailUrl), args2[1]);
      }
    }).catch(() => {
    });
    return request;
  }
};
_fetchClient = new WeakMap;
_maxPrefetchedRequests = new WeakMap;
_prefetchQueue = new WeakMap;
_queueHeadUrl = new WeakMap;
_queueTailUrl = new WeakMap;
_PrefetchQueue_instances = new WeakSet;
prefetch_fn = function(...args2) {
  var _a, _b;
  const url = args2[0].toString();
  if (__privateGet(this, _prefetchQueue).size >= __privateGet(this, _maxPrefetchedRequests))
    return;
  const aborter = new AbortController;
  try {
    const { signal, cleanup } = chainAborter(aborter, (_a = args2[1]) == null ? undefined : _a.signal);
    const request = __privateGet(this, _fetchClient).call(this, url, __spreadProps(__spreadValues({}, (_b = args2[1]) != null ? _b : {}), { signal }));
    __privateGet(this, _prefetchQueue).set(url, [request, aborter]);
    request.then((response) => {
      if (!response.ok || aborter.signal.aborted)
        return;
      const nextUrl = getNextChunkUrl(url, response);
      if (!nextUrl || nextUrl === url) {
        __privateSet(this, _queueTailUrl, undefined);
        return;
      }
      __privateSet(this, _queueTailUrl, nextUrl);
      return __privateMethod(this, _PrefetchQueue_instances, prefetch_fn).call(this, nextUrl, args2[1]);
    }).catch(() => {
    }).finally(cleanup);
  } catch (_2) {
  }
};
function getNextChunkUrl(url, res) {
  const shapeHandle = res.headers.get(SHAPE_HANDLE_HEADER);
  const lastOffset = res.headers.get(CHUNK_LAST_OFFSET_HEADER);
  const isUpToDate = res.headers.has(CHUNK_UP_TO_DATE_HEADER);
  if (!shapeHandle || !lastOffset || isUpToDate)
    return;
  const nextUrl = new URL(url);
  if (nextUrl.searchParams.has(LIVE_QUERY_PARAM))
    return;
  nextUrl.searchParams.set(SHAPE_HANDLE_QUERY_PARAM, shapeHandle);
  nextUrl.searchParams.set(OFFSET_QUERY_PARAM, lastOffset);
  nextUrl.searchParams.sort();
  return nextUrl.toString();
}
function chainAborter(aborter, sourceSignal) {
  let cleanup = noop;
  if (!sourceSignal) {
  } else if (sourceSignal.aborted) {
    aborter.abort();
  } else {
    const abortParent = () => aborter.abort();
    sourceSignal.addEventListener(`abort`, abortParent, {
      once: true,
      signal: aborter.signal
    });
    cleanup = () => sourceSignal.removeEventListener(`abort`, abortParent);
  }
  return {
    signal: aborter.signal,
    cleanup
  };
}
function noop() {
}
var RESERVED_PARAMS = /* @__PURE__ */ new Set([
  LIVE_CACHE_BUSTER_QUERY_PARAM,
  SHAPE_HANDLE_QUERY_PARAM,
  LIVE_QUERY_PARAM,
  OFFSET_QUERY_PARAM
]);
function resolveValue(value) {
  return __async(this, null, function* () {
    if (typeof value === `function`) {
      return value();
    }
    return value;
  });
}
function toInternalParams(params) {
  return __async(this, null, function* () {
    const entries = Object.entries(params);
    const resolvedEntries = yield Promise.all(entries.map((_0) => __async(this, [_0], function* ([key, value]) {
      if (value === undefined)
        return [key, undefined];
      const resolvedValue = yield resolveValue(value);
      return [
        key,
        Array.isArray(resolvedValue) ? resolvedValue.join(`,`) : resolvedValue
      ];
    })));
    return Object.fromEntries(resolvedEntries.filter(([_2, value]) => value !== undefined));
  });
}
function resolveHeaders(headers) {
  return __async(this, null, function* () {
    if (!headers)
      return {};
    const entries = Object.entries(headers);
    const resolvedEntries = yield Promise.all(entries.map((_0) => __async(this, [_0], function* ([key, value]) {
      return [key, yield resolveValue(value)];
    })));
    return Object.fromEntries(resolvedEntries);
  });
}
var _error;
var _fetchClient2;
var _messageParser;
var _subscribers;
var _started;
var _lastOffset;
var _liveCacheBuster;
var _lastSyncedAt;
var _isUpToDate;
var _connected;
var _shapeHandle;
var _schema;
var _onError;
var _requestAbortController;
var _isRefreshing;
var _tickPromise;
var _tickPromiseResolver;
var _tickPromiseRejecter;
var _ShapeStream_instances;
var start_fn;
var nextTick_fn;
var publish_fn;
var sendErrorToSubscribers_fn;
var reset_fn;
var ShapeStream = class {
  constructor(options) {
    __privateAdd(this, _ShapeStream_instances);
    __privateAdd(this, _error, null);
    __privateAdd(this, _fetchClient2);
    __privateAdd(this, _messageParser);
    __privateAdd(this, _subscribers, /* @__PURE__ */ new Map);
    __privateAdd(this, _started, false);
    __privateAdd(this, _lastOffset);
    __privateAdd(this, _liveCacheBuster);
    __privateAdd(this, _lastSyncedAt);
    __privateAdd(this, _isUpToDate, false);
    __privateAdd(this, _connected, false);
    __privateAdd(this, _shapeHandle);
    __privateAdd(this, _schema);
    __privateAdd(this, _onError);
    __privateAdd(this, _requestAbortController);
    __privateAdd(this, _isRefreshing, false);
    __privateAdd(this, _tickPromise);
    __privateAdd(this, _tickPromiseResolver);
    __privateAdd(this, _tickPromiseRejecter);
    var _a, _b, _c;
    this.options = __spreadValues({ subscribe: true }, options);
    validateOptions(this.options);
    __privateSet(this, _lastOffset, (_a = this.options.offset) != null ? _a : `-1`);
    __privateSet(this, _liveCacheBuster, ``);
    __privateSet(this, _shapeHandle, this.options.handle);
    __privateSet(this, _messageParser, new MessageParser(options.parser));
    __privateSet(this, _onError, this.options.onError);
    const baseFetchClient = (_b = options.fetchClient) != null ? _b : (...args2) => fetch(...args2);
    const fetchWithBackoffClient = createFetchWithBackoff(baseFetchClient, __spreadProps(__spreadValues({}, (_c = options.backoffOptions) != null ? _c : BackoffDefaults), {
      onFailedAttempt: () => {
        var _a2, _b2;
        __privateSet(this, _connected, false);
        (_b2 = (_a2 = options.backoffOptions) == null ? undefined : _a2.onFailedAttempt) == null || _b2.call(_a2);
      }
    }));
    __privateSet(this, _fetchClient2, createFetchWithResponseHeadersCheck(createFetchWithChunkBuffer(fetchWithBackoffClient)));
  }
  get shapeHandle() {
    return __privateGet(this, _shapeHandle);
  }
  get error() {
    return __privateGet(this, _error);
  }
  get isUpToDate() {
    return __privateGet(this, _isUpToDate);
  }
  get lastOffset() {
    return __privateGet(this, _lastOffset);
  }
  subscribe(callback, onError = () => {
  }) {
    const subscriptionId = Math.random();
    __privateGet(this, _subscribers).set(subscriptionId, [callback, onError]);
    if (!__privateGet(this, _started))
      __privateMethod(this, _ShapeStream_instances, start_fn).call(this);
    return () => {
      __privateGet(this, _subscribers).delete(subscriptionId);
    };
  }
  unsubscribeAll() {
    __privateGet(this, _subscribers).clear();
  }
  lastSyncedAt() {
    return __privateGet(this, _lastSyncedAt);
  }
  lastSynced() {
    if (__privateGet(this, _lastSyncedAt) === undefined)
      return Infinity;
    return Date.now() - __privateGet(this, _lastSyncedAt);
  }
  isConnected() {
    return __privateGet(this, _connected);
  }
  isLoading() {
    return !__privateGet(this, _isUpToDate);
  }
  hasStarted() {
    return __privateGet(this, _started);
  }
  forceDisconnectAndRefresh() {
    return __async(this, null, function* () {
      var _a, _b;
      __privateSet(this, _isRefreshing, true);
      if (__privateGet(this, _isUpToDate) && !((_a = __privateGet(this, _requestAbortController)) == null ? undefined : _a.signal.aborted)) {
        (_b = __privateGet(this, _requestAbortController)) == null || _b.abort(FORCE_DISCONNECT_AND_REFRESH);
      }
      yield __privateMethod(this, _ShapeStream_instances, nextTick_fn).call(this);
      __privateSet(this, _isRefreshing, false);
    });
  }
};
_error = new WeakMap;
_fetchClient2 = new WeakMap;
_messageParser = new WeakMap;
_subscribers = new WeakMap;
_started = new WeakMap;
_lastOffset = new WeakMap;
_liveCacheBuster = new WeakMap;
_lastSyncedAt = new WeakMap;
_isUpToDate = new WeakMap;
_connected = new WeakMap;
_shapeHandle = new WeakMap;
_schema = new WeakMap;
_onError = new WeakMap;
_requestAbortController = new WeakMap;
_isRefreshing = new WeakMap;
_tickPromise = new WeakMap;
_tickPromiseResolver = new WeakMap;
_tickPromiseRejecter = new WeakMap;
_ShapeStream_instances = new WeakSet;
start_fn = function() {
  return __async(this, null, function* () {
    var _a, _b, _c, _d, _e2;
    if (__privateGet(this, _started))
      throw new Error(`Cannot start stream twice`);
    __privateSet(this, _started, true);
    try {
      while (!((_a = this.options.signal) == null ? undefined : _a.aborted) && !__privateGet(this, _isUpToDate) || this.options.subscribe) {
        const { url, signal } = this.options;
        const [requestHeaders, params] = yield Promise.all([
          resolveHeaders(this.options.headers),
          this.options.params ? toInternalParams(convertWhereParamsToObj(this.options.params)) : undefined
        ]);
        if (params) {
          validateParams(params);
        }
        const fetchUrl = new URL(url);
        if (params) {
          if (params.table)
            setQueryParam(fetchUrl, TABLE_QUERY_PARAM, params.table);
          if (params.where)
            setQueryParam(fetchUrl, WHERE_QUERY_PARAM, params.where);
          if (params.columns)
            setQueryParam(fetchUrl, COLUMNS_QUERY_PARAM, params.columns);
          if (params.replica)
            setQueryParam(fetchUrl, REPLICA_PARAM, params.replica);
          if (params.params)
            setQueryParam(fetchUrl, WHERE_PARAMS_PARAM, params.params);
          const customParams = __spreadValues({}, params);
          delete customParams.table;
          delete customParams.where;
          delete customParams.columns;
          delete customParams.replica;
          delete customParams.params;
          for (const [key, value] of Object.entries(customParams)) {
            setQueryParam(fetchUrl, key, value);
          }
        }
        fetchUrl.searchParams.set(OFFSET_QUERY_PARAM, __privateGet(this, _lastOffset));
        if (__privateGet(this, _isUpToDate)) {
          if (!__privateGet(this, _isRefreshing)) {
            fetchUrl.searchParams.set(LIVE_QUERY_PARAM, `true`);
          }
          fetchUrl.searchParams.set(LIVE_CACHE_BUSTER_QUERY_PARAM, __privateGet(this, _liveCacheBuster));
        }
        if (__privateGet(this, _shapeHandle)) {
          fetchUrl.searchParams.set(SHAPE_HANDLE_QUERY_PARAM, __privateGet(this, _shapeHandle));
        }
        fetchUrl.searchParams.sort();
        __privateSet(this, _requestAbortController, new AbortController);
        let abortListener;
        if (signal) {
          abortListener = () => {
            var _a2;
            (_a2 = __privateGet(this, _requestAbortController)) == null || _a2.abort(signal.reason);
          };
          signal.addEventListener(`abort`, abortListener, { once: true });
          if (signal.aborted) {
            (_b = __privateGet(this, _requestAbortController)) == null || _b.abort(signal.reason);
          }
        }
        let response;
        try {
          response = yield __privateGet(this, _fetchClient2).call(this, fetchUrl.toString(), {
            signal: __privateGet(this, _requestAbortController).signal,
            headers: requestHeaders
          });
          __privateSet(this, _connected, true);
        } catch (e) {
          if ((e instanceof FetchError || e instanceof FetchBackoffAbortError) && __privateGet(this, _requestAbortController).signal.aborted && __privateGet(this, _requestAbortController).signal.reason === FORCE_DISCONNECT_AND_REFRESH) {
            continue;
          }
          if (e instanceof FetchBackoffAbortError)
            break;
          if (!(e instanceof FetchError))
            throw e;
          if (e.status == 409) {
            const newShapeHandle = e.headers[SHAPE_HANDLE_HEADER];
            __privateMethod(this, _ShapeStream_instances, reset_fn).call(this, newShapeHandle);
            yield __privateMethod(this, _ShapeStream_instances, publish_fn).call(this, e.json);
            continue;
          } else if (e.status >= 400 && e.status < 500) {
            __privateMethod(this, _ShapeStream_instances, sendErrorToSubscribers_fn).call(this, e);
            throw e;
          }
        } finally {
          if (abortListener && signal) {
            signal.removeEventListener(`abort`, abortListener);
          }
          __privateSet(this, _requestAbortController, undefined);
        }
        const { headers, status } = response;
        const shapeHandle = headers.get(SHAPE_HANDLE_HEADER);
        if (shapeHandle) {
          __privateSet(this, _shapeHandle, shapeHandle);
        }
        const lastOffset = headers.get(CHUNK_LAST_OFFSET_HEADER);
        if (lastOffset) {
          __privateSet(this, _lastOffset, lastOffset);
        }
        const liveCacheBuster = headers.get(LIVE_CACHE_BUSTER_HEADER);
        if (liveCacheBuster) {
          __privateSet(this, _liveCacheBuster, liveCacheBuster);
        }
        const getSchema = () => {
          const schemaHeader = headers.get(SHAPE_SCHEMA_HEADER);
          return schemaHeader ? JSON.parse(schemaHeader) : {};
        };
        __privateSet(this, _schema, (_c = __privateGet(this, _schema)) != null ? _c : getSchema());
        const messages2 = status === 204 ? `[]` : yield response.text();
        if (status === 204) {
          __privateSet(this, _lastSyncedAt, Date.now());
        }
        const batch = __privateGet(this, _messageParser).parse(messages2, __privateGet(this, _schema));
        if (batch.length > 0) {
          const lastMessage = batch[batch.length - 1];
          if (isUpToDateMessage(lastMessage)) {
            __privateSet(this, _lastSyncedAt, Date.now());
            __privateSet(this, _isUpToDate, true);
          }
          yield __privateMethod(this, _ShapeStream_instances, publish_fn).call(this, batch);
        }
        (_d = __privateGet(this, _tickPromiseResolver)) == null || _d.call(this);
      }
    } catch (err2) {
      __privateSet(this, _error, err2);
      if (__privateGet(this, _onError)) {
        const retryOpts = yield __privateGet(this, _onError).call(this, err2);
        if (typeof retryOpts === `object`) {
          __privateMethod(this, _ShapeStream_instances, reset_fn).call(this);
          if (`params` in retryOpts) {
            this.options.params = retryOpts.params;
          }
          if (`headers` in retryOpts) {
            this.options.headers = retryOpts.headers;
          }
          __privateSet(this, _started, false);
          __privateMethod(this, _ShapeStream_instances, start_fn).call(this);
        }
        return;
      }
      throw err2;
    } finally {
      __privateSet(this, _connected, false);
      (_e2 = __privateGet(this, _tickPromiseRejecter)) == null || _e2.call(this);
    }
  });
};
nextTick_fn = function() {
  return __async(this, null, function* () {
    if (__privateGet(this, _tickPromise)) {
      return __privateGet(this, _tickPromise);
    }
    __privateSet(this, _tickPromise, new Promise((resolve, reject) => {
      __privateSet(this, _tickPromiseResolver, resolve);
      __privateSet(this, _tickPromiseRejecter, reject);
    }));
    __privateGet(this, _tickPromise).finally(() => {
      __privateSet(this, _tickPromise, undefined);
      __privateSet(this, _tickPromiseResolver, undefined);
      __privateSet(this, _tickPromiseRejecter, undefined);
    });
    return __privateGet(this, _tickPromise);
  });
};
publish_fn = function(messages2) {
  return __async(this, null, function* () {
    yield Promise.all(Array.from(__privateGet(this, _subscribers).values()).map((_0) => __async(this, [_0], function* ([callback, __]) {
      try {
        yield callback(messages2);
      } catch (err2) {
        queueMicrotask(() => {
          throw err2;
        });
      }
    })));
  });
};
sendErrorToSubscribers_fn = function(error) {
  __privateGet(this, _subscribers).forEach(([_2, errorFn]) => {
    errorFn == null || errorFn(error);
  });
};
reset_fn = function(handle2) {
  __privateSet(this, _lastOffset, `-1`);
  __privateSet(this, _liveCacheBuster, ``);
  __privateSet(this, _shapeHandle, handle2);
  __privateSet(this, _isUpToDate, false);
  __privateSet(this, _connected, false);
  __privateSet(this, _schema, undefined);
};
ShapeStream.Replica = {
  FULL: `full`,
  DEFAULT: `default`
};
function validateParams(params) {
  if (!params)
    return;
  const reservedParams = Object.keys(params).filter((key) => RESERVED_PARAMS.has(key));
  if (reservedParams.length > 0) {
    throw new ReservedParamError(reservedParams);
  }
}
function validateOptions(options) {
  if (!options.url) {
    throw new MissingShapeUrlError;
  }
  if (options.signal && !(options.signal instanceof AbortSignal)) {
    throw new InvalidSignalError;
  }
  if (options.offset !== undefined && options.offset !== `-1` && !options.handle) {
    throw new MissingShapeHandleError;
  }
  validateParams(options.params);
  return;
}
function setQueryParam(url, key, value) {
  if (value === undefined || value == null) {
    return;
  } else if (typeof value === `string`) {
    url.searchParams.set(key, value);
  } else if (typeof value === `object`) {
    for (const [k2, v2] of Object.entries(value)) {
      url.searchParams.set(`${key}[${k2}]`, v2);
    }
  } else {
    url.searchParams.set(key, value.toString());
  }
}
function convertWhereParamsToObj(allPgParams) {
  if (Array.isArray(allPgParams.params)) {
    return __spreadProps(__spreadValues({}, allPgParams), {
      params: Object.fromEntries(allPgParams.params.map((v2, i2) => [i2 + 1, v2]))
    });
  }
  return allPgParams;
}
var _data;
var _subscribers2;
var _status;
var _error2;
var _Shape_instances;
var process_fn;
var updateShapeStatus_fn;
var handleError_fn;
var notify_fn;
_data = new WeakMap;
_subscribers2 = new WeakMap;
_status = new WeakMap;
_error2 = new WeakMap;
_Shape_instances = new WeakSet;
process_fn = function(messages2) {
  let shouldNotify = false;
  messages2.forEach((message) => {
    if (isChangeMessage(message)) {
      shouldNotify = __privateMethod(this, _Shape_instances, updateShapeStatus_fn).call(this, `syncing`);
      switch (message.headers.operation) {
        case `insert`:
          __privateGet(this, _data).set(message.key, message.value);
          break;
        case `update`:
          __privateGet(this, _data).set(message.key, __spreadValues(__spreadValues({}, __privateGet(this, _data).get(message.key)), message.value));
          break;
        case `delete`:
          __privateGet(this, _data).delete(message.key);
          break;
      }
    }
    if (isControlMessage(message)) {
      switch (message.headers.control) {
        case `up-to-date`:
          shouldNotify = __privateMethod(this, _Shape_instances, updateShapeStatus_fn).call(this, `up-to-date`);
          break;
        case `must-refetch`:
          __privateGet(this, _data).clear();
          __privateSet(this, _error2, false);
          shouldNotify = __privateMethod(this, _Shape_instances, updateShapeStatus_fn).call(this, `syncing`);
          break;
      }
    }
  });
  if (shouldNotify)
    __privateMethod(this, _Shape_instances, notify_fn).call(this);
};
updateShapeStatus_fn = function(status) {
  const stateChanged = __privateGet(this, _status) !== status;
  __privateSet(this, _status, status);
  return stateChanged && status === `up-to-date`;
};
handleError_fn = function(e) {
  if (e instanceof FetchError) {
    __privateSet(this, _error2, e);
    __privateMethod(this, _Shape_instances, notify_fn).call(this);
  }
};
notify_fn = function() {
  __privateGet(this, _subscribers2).forEach((callback) => {
    callback({ value: this.currentValue, rows: this.currentRows });
  });
};

// ../../node_modules/.pnpm/@electric-sql+experimental@1.0.0_@electric-sql+client@1.0.0/node_modules/@electric-sql/experimental/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __defProps2 = Object.defineProperties;
var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp2 = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b3) => {
  for (var prop in b3 || (b3 = {}))
    if (__hasOwnProp2.call(b3, prop))
      __defNormalProp2(a, prop, b3[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b3)) {
      if (__propIsEnum2.call(b3, prop))
        __defNormalProp2(a, prop, b3[prop]);
    }
  return a;
};
var __spreadProps2 = (a, b3) => __defProps2(a, __getOwnPropDescs2(b3));
var __accessCheck2 = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
var __privateGet2 = (obj, member, getter) => (__accessCheck2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd2 = (obj, member, value) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet2 = (obj, member, value, setter) => (__accessCheck2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod2 = (obj, member, method) => (__accessCheck2(obj, member, "access private method"), method);
var __async2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x3) => x3.done ? resolve(x3.value) : Promise.resolve(x3.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function bigIntMax(...args2) {
  return BigInt(args2.reduce((m2, e) => e > m2 ? e : m2));
}
function bigIntMin(...args2) {
  return BigInt(args2.reduce((m2, e) => e < m2 ? e : m2));
}
var _shapes;
var _started2;
var _checkForUpdatesTimeout;
var _lastDataLsns;
var _lastUpToDateLsns;
var _subscribers3;
var _MultiShapeStream_instances;
var start_fn2;
var scheduleCheckForUpdates_fn;
var checkForUpdates_fn;
var onError_fn;
var shapeEntries_fn;
var MultiShapeStream = class {
  constructor(options) {
    __privateAdd2(this, _MultiShapeStream_instances);
    __privateAdd2(this, _shapes);
    __privateAdd2(this, _started2, false);
    __privateAdd2(this, _checkForUpdatesTimeout);
    __privateAdd2(this, _lastDataLsns);
    __privateAdd2(this, _lastUpToDateLsns);
    __privateAdd2(this, _subscribers3, /* @__PURE__ */ new Map);
    const {
      start: start2 = true,
      checkForUpdatesAfterMs = 100,
      shapes
    } = options;
    this.checkForUpdatesAfterMs = checkForUpdatesAfterMs;
    __privateSet2(this, _shapes, Object.fromEntries(Object.entries(shapes).map(([key, shape]) => [
      key,
      shape instanceof ShapeStream ? shape : new ShapeStream(__spreadProps2(__spreadValues2({}, shape), {
        start: false
      }))
    ])));
    __privateSet2(this, _lastDataLsns, Object.fromEntries(Object.entries(shapes).map(([key]) => [key, BigInt(-1)])));
    __privateSet2(this, _lastUpToDateLsns, Object.fromEntries(Object.entries(shapes).map(([key]) => [key, BigInt(-1)])));
    if (start2)
      __privateMethod2(this, _MultiShapeStream_instances, start_fn2).call(this);
  }
  _publish(messages2) {
    return __async2(this, null, function* () {
      yield Promise.all(Array.from(__privateGet2(this, _subscribers3).values()).map((_0) => __async2(this, [_0], function* ([callback, __]) {
        try {
          yield callback(messages2);
        } catch (err2) {
          queueMicrotask(() => {
            throw err2;
          });
        }
      })));
    });
  }
  get shapes() {
    return __privateGet2(this, _shapes);
  }
  subscribe(callback, onError) {
    const subscriptionId = Math.random();
    __privateGet2(this, _subscribers3).set(subscriptionId, [callback, onError]);
    if (!__privateGet2(this, _started2))
      __privateMethod2(this, _MultiShapeStream_instances, start_fn2).call(this);
    return () => {
      __privateGet2(this, _subscribers3).delete(subscriptionId);
    };
  }
  unsubscribeAll() {
    __privateGet2(this, _subscribers3).clear();
  }
  lastSyncedAt() {
    return Math.min(...__privateMethod2(this, _MultiShapeStream_instances, shapeEntries_fn).call(this).map(([_2, shape]) => {
      var _a;
      return (_a = shape.lastSyncedAt()) != null ? _a : Infinity;
    }));
  }
  lastSynced() {
    const lastSyncedAt = this.lastSyncedAt();
    if (lastSyncedAt === undefined)
      return Infinity;
    return Date.now() - lastSyncedAt;
  }
  isConnected() {
    return __privateMethod2(this, _MultiShapeStream_instances, shapeEntries_fn).call(this).every(([_2, shape]) => shape.isConnected());
  }
  isLoading() {
    return __privateMethod2(this, _MultiShapeStream_instances, shapeEntries_fn).call(this).some(([_2, shape]) => shape.isLoading());
  }
  get isUpToDate() {
    return __privateMethod2(this, _MultiShapeStream_instances, shapeEntries_fn).call(this).every(([_2, shape]) => shape.isUpToDate);
  }
};
_shapes = new WeakMap;
_started2 = new WeakMap;
_checkForUpdatesTimeout = new WeakMap;
_lastDataLsns = new WeakMap;
_lastUpToDateLsns = new WeakMap;
_subscribers3 = new WeakMap;
_MultiShapeStream_instances = new WeakSet;
start_fn2 = function() {
  if (__privateGet2(this, _started2))
    throw new Error(`Cannot start multi-shape stream twice`);
  for (const [key, shape] of __privateMethod2(this, _MultiShapeStream_instances, shapeEntries_fn).call(this)) {
    if (shape.hasStarted()) {
      throw new Error(`Shape ${key} already started`);
    }
    shape.subscribe((messages2) => __async2(this, null, function* () {
      const upToDateLsns = messages2.filter(isControlMessage).map(({ headers }) => typeof headers.global_last_seen_lsn === `string` ? BigInt(headers.global_last_seen_lsn) : BigInt(0));
      if (upToDateLsns.length > 0) {
        const maxUpToDateLsn = bigIntMax(...upToDateLsns);
        const lastMaxUpToDateLsn = __privateGet2(this, _lastUpToDateLsns)[key];
        if (maxUpToDateLsn > lastMaxUpToDateLsn) {
          __privateGet2(this, _lastUpToDateLsns)[key] = maxUpToDateLsn;
        }
      }
      const dataLsns = messages2.filter(isChangeMessage).map(({ headers }) => typeof headers.lsn === `string` ? BigInt(headers.lsn) : BigInt(0));
      if (dataLsns.length > 0) {
        const maxDataLsn = bigIntMax(...dataLsns);
        const lastMaxDataLsn = __privateGet2(this, _lastDataLsns)[key];
        if (maxDataLsn > lastMaxDataLsn) {
          __privateGet2(this, _lastDataLsns)[key] = maxDataLsn;
        }
        __privateMethod2(this, _MultiShapeStream_instances, scheduleCheckForUpdates_fn).call(this);
      }
      const multiShapeMessages = messages2.map((message) => __spreadProps2(__spreadValues2({}, message), {
        shape: key
      }));
      yield this._publish(multiShapeMessages);
    }), (error) => __privateMethod2(this, _MultiShapeStream_instances, onError_fn).call(this, error));
  }
  __privateSet2(this, _started2, true);
};
scheduleCheckForUpdates_fn = function() {
  var _a;
  (_a = __privateGet2(this, _checkForUpdatesTimeout)) != null || __privateSet2(this, _checkForUpdatesTimeout, setTimeout(() => {
    __privateMethod2(this, _MultiShapeStream_instances, checkForUpdates_fn).call(this);
    __privateSet2(this, _checkForUpdatesTimeout, undefined);
  }, this.checkForUpdatesAfterMs));
};
checkForUpdates_fn = function() {
  return __async2(this, null, function* () {
    const maxDataLsn = bigIntMax(...Object.values(__privateGet2(this, _lastDataLsns)));
    const refreshPromises = __privateMethod2(this, _MultiShapeStream_instances, shapeEntries_fn).call(this).filter(([key]) => {
      const lastUpToDateLsn = __privateGet2(this, _lastUpToDateLsns)[key];
      return lastUpToDateLsn < maxDataLsn;
    }).map(([_2, shape]) => {
      return shape.forceDisconnectAndRefresh();
    });
    yield Promise.all(refreshPromises);
  });
};
onError_fn = function(error) {
  __privateGet2(this, _subscribers3).forEach(([_2, errorFn]) => {
    errorFn == null || errorFn(error);
  });
};
shapeEntries_fn = function() {
  return Object.entries(__privateGet2(this, _shapes));
};
var _changeMessages;
var _completeLsns;
var _TransactionalMultiShapeStream_instances;
var getLowestCompleteLsn_fn;
var accumulate_fn;
_changeMessages = new WeakMap;
_completeLsns = new WeakMap;
_TransactionalMultiShapeStream_instances = new WeakSet;
getLowestCompleteLsn_fn = function() {
  return bigIntMin(...Object.values(__privateGet2(this, _completeLsns)));
};
accumulate_fn = function(messages2) {
  const isUpToDate = this.isUpToDate;
  messages2.forEach((message) => {
    var _a;
    const { shape, headers } = message;
    if (isChangeMessage(message)) {
      const lsn = typeof headers.lsn === `string` ? BigInt(headers.lsn) : BigInt(0);
      if (!__privateGet2(this, _changeMessages).has(lsn)) {
        __privateGet2(this, _changeMessages).set(lsn, []);
      }
      (_a = __privateGet2(this, _changeMessages).get(lsn)) == null || _a.push(message);
      if (isUpToDate && typeof headers.last === `boolean` && headers.last === true) {
        __privateGet2(this, _completeLsns)[shape] = bigIntMax(__privateGet2(this, _completeLsns)[shape], lsn);
      }
    } else if (isControlMessage(message)) {
      if (headers.control === `up-to-date`) {
        if (typeof headers.global_last_seen_lsn !== `string`) {
          throw new Error(`global_last_seen_lsn is not a number`);
        }
        __privateGet2(this, _completeLsns)[shape] = bigIntMax(__privateGet2(this, _completeLsns)[shape], BigInt(headers.global_last_seen_lsn));
      }
    }
  });
};

// ../../node_modules/.pnpm/@electric-sql+pglite-sync@0.3.6_@electric-sql+pglite@0.3.3/node_modules/@electric-sql/pglite-sync/dist/index.js
var te3 = "subscriptions_metadata";
async function H3({ pg: n, metadataSchema: o3, subscriptionKey: e }) {
  let a = await n.query(`
      SELECT key, shape_metadata, last_lsn
      FROM ${B(o3)}
      WHERE key = $1
    `, [e]);
  if (a.rows.length === 0)
    return null;
  if (a.rows.length > 1)
    throw new Error(`Multiple subscriptions found for key: ${e}`);
  let u3 = a.rows[0];
  if (typeof u3.last_lsn == "string")
    return { ...u3, last_lsn: BigInt(u3.last_lsn) };
  throw new Error(`Invalid last_lsn type: ${typeof u3.last_lsn}`);
}
async function Y3({ pg: n, metadataSchema: o3, subscriptionKey: e, shapeMetadata: a, lastLsn: u3, debug: b3 }) {
  b3 && console.log("updating subscription state", e, a, u3), await n.query(`
      INSERT INTO ${B(o3)}
        (key, shape_metadata, last_lsn)
      VALUES
        ($1, $2, $3)
      ON CONFLICT(key)
      DO UPDATE SET
        shape_metadata = EXCLUDED.shape_metadata,
        last_lsn = EXCLUDED.last_lsn;
    `, [e, a, u3.toString()]);
}
async function V2({ pg: n, metadataSchema: o3, subscriptionKey: e }) {
  await n.query(`DELETE FROM ${B(o3)} WHERE key = $1`, [e]);
}
async function J3({ pg: n, metadataSchema: o3 }) {
  await n.exec(`
      SET ${o3}.syncing = false;
      CREATE SCHEMA IF NOT EXISTS "${o3}";
      CREATE TABLE IF NOT EXISTS ${B(o3)} (
        key TEXT PRIMARY KEY,
        shape_metadata JSONB NOT NULL,
        last_lsn TEXT NOT NULL
      );
    `);
}
function B(n) {
  return `"${n}"."${te3}"`;
}
async function Q3({ pg: n, table: o3, schema: e = "public", message: a, mapColumns: u3, primaryKey: b3, debug: m2 }) {
  let f = u3 ? U3(u3, a) : a.value;
  switch (a.headers.operation) {
    case "insert": {
      m2 && console.log("inserting", f);
      let g3 = Object.keys(f);
      return await n.query(`
            INSERT INTO "${e}"."${o3}"
            (${g3.map((s2) => '"' + s2 + '"').join(", ")})
            VALUES
            (${g3.map((s2, y2) => "$" + (y2 + 1)).join(", ")})
          `, g3.map((s2) => f[s2]));
    }
    case "update": {
      m2 && console.log("updating", f);
      let g3 = Object.keys(f).filter((s2) => !b3.includes(s2));
      return g3.length === 0 ? undefined : await n.query(`
            UPDATE "${e}"."${o3}"
            SET ${g3.map((s2, y2) => '"' + s2 + '" = $' + (y2 + 1)).join(", ")}
            WHERE ${b3.map((s2, y2) => '"' + s2 + '" = $' + (g3.length + y2 + 1)).join(" AND ")}
          `, [...g3.map((s2) => f[s2]), ...b3.map((s2) => f[s2])]);
    }
    case "delete":
      return m2 && console.log("deleting", f), await n.query(`
            DELETE FROM "${e}"."${o3}"
            WHERE ${b3.map((g3, s2) => '"' + g3 + '" = $' + (s2 + 1)).join(" AND ")}
          `, [...b3.map((g3) => f[g3])]);
  }
}
async function G2({ pg: n, table: o3, schema: e = "public", messages: a, mapColumns: u3, debug: b3 }) {
  let m2 = a.map((t) => u3 ? U3(u3, t) : t.value);
  b3 && console.log("inserting", m2);
  let f = Object.keys(m2[0]), g3 = (t) => {
    if (t === null)
      return 0;
    if (t instanceof ArrayBuffer)
      return t.byteLength;
    if (t instanceof Blob)
      return t.size;
    if (t instanceof Uint8Array || t instanceof DataView || ArrayBuffer.isView(t))
      return t.byteLength;
    switch (typeof t) {
      case "string":
        return t.length;
      case "number":
        return 8;
      case "boolean":
        return 1;
      default:
        return t instanceof Date ? 8 : t?.toString()?.length || 0;
    }
  }, s2 = (t) => f.reduce((d2, E2) => {
    let l3 = t[E2];
    if (l3 === null)
      return d2;
    if (Array.isArray(l3)) {
      if (l3.length === 0)
        return d2;
      let _2 = l3[0];
      switch (typeof _2) {
        case "number":
          return d2 + l3.length * 8;
        case "string":
          return d2 + l3.reduce((j3, $3) => j3 + $3.length, 0);
        case "boolean":
          return d2 + l3.length;
        default:
          return _2 instanceof Date ? d2 + l3.length * 8 : d2 + l3.reduce((j3, $3) => j3 + g3($3), 0);
      }
    }
    return d2 + g3(l3);
  }, 0), y2 = 32000, I = 50 * 1024 * 1024, O2 = async (t) => {
    let d2 = `
      INSERT INTO "${e}"."${o3}"
      (${f.map((l3) => `"${l3}"`).join(", ")})
      VALUES
      ${t.map((l3, _2) => `(${f.map((j3, $3) => "$" + (_2 * f.length + $3 + 1)).join(", ")})`).join(", ")}
    `, E2 = t.flatMap((l3) => f.map((_2) => l3[_2]));
    await n.query(d2, E2);
  }, c = [], h3 = 0, P3 = 0;
  for (let t = 0;t < m2.length; t++) {
    let d2 = m2[t], E2 = s2(d2), l3 = f.length;
    c.length > 0 && (h3 + E2 > I || P3 + l3 > y2) && (b3 && h3 + E2 > I && console.log("batch size limit exceeded, executing batch"), b3 && P3 + l3 > y2 && console.log("batch params limit exceeded, executing batch"), await O2(c), c = [], h3 = 0, P3 = 0), c.push(d2), h3 += E2, P3 += l3;
  }
  c.length > 0 && await O2(c), b3 && console.log(`Inserted ${a.length} rows using INSERT`);
}
async function z3({ pg: n, table: o3, schema: e = "public", messages: a, mapColumns: u3, debug: b3 }) {
  b3 && console.log("applying messages with json_to_recordset");
  let m2 = a.map((s2) => u3 ? U3(u3, s2) : s2.value), f = (await n.query(`
        SELECT column_name, udt_name, data_type
        FROM information_schema.columns
        WHERE table_name = $1 AND table_schema = $2
      `, [o3, e])).rows.filter((s2) => Object.prototype.hasOwnProperty.call(m2[0], s2.column_name)), g3 = 1e4;
  for (let s2 = 0;s2 < m2.length; s2 += g3) {
    let y2 = m2.slice(s2, s2 + g3);
    await n.query(`
        INSERT INTO "${e}"."${o3}"
        SELECT x.* from json_to_recordset($1) as x(${f.map((I) => `${I.column_name} ${I.udt_name.replace(/^_/, "")}` + (I.data_type === "ARRAY" ? "[]" : "")).join(", ")})
      `, [y2]);
  }
  b3 && console.log(`Inserted ${a.length} rows using json_to_recordset`);
}
async function F3({ pg: n, table: o3, schema: e = "public", messages: a, mapColumns: u3, debug: b3 }) {
  b3 && console.log("applying messages with COPY");
  let m2 = a.map((y2) => u3 ? U3(u3, y2) : y2.value), f = Object.keys(m2[0]), g3 = m2.map((y2) => f.map((I) => {
    let O2 = y2[I];
    return typeof O2 == "string" && (O2.includes(",") || O2.includes('"') || O2.includes(`
`)) ? `"${O2.replace(/"/g, '""')}"` : O2 === null ? "\\N" : O2;
  }).join(",")).join(`
`), s2 = new Blob([g3], { type: "text/csv" });
  await n.query(`
      COPY "${e}"."${o3}" (${f.map((y2) => `"${y2}"`).join(", ")})
      FROM '/dev/blob'
      WITH (FORMAT csv, NULL '\\N')
    `, [], { blob: s2 }), b3 && console.log(`Inserted ${a.length} rows using COPY`);
}
function U3(n, o3) {
  if (typeof n == "function")
    return n(o3);
  let e = {};
  for (let [a, u3] of Object.entries(n))
    e[a] = o3.value[u3];
  return e;
}
async function oe2(n, o3) {
  let e = o3?.debug ?? false, a = o3?.metadataSchema ?? "electric", u3 = [], b3 = new Map, m2 = false, f = async () => {
    m2 || (m2 = true, await J3({ pg: n, metadataSchema: a }));
  }, g3 = async ({ key: c, shapes: h3, useCopy: P3 = false, initialInsertMethod: t = "insert", onInitialSync: d2 }) => {
    let E2 = false;
    await f(), Object.values(h3).filter((r2) => !r2.onMustRefetch).forEach((r2) => {
      if (b3.has(r2.table))
        throw new Error("Already syncing shape for table " + r2.table);
      b3.set(r2.table);
    });
    let l3 = null;
    c !== null && (l3 = await H3({ pg: n, metadataSchema: a, subscriptionKey: c }), e && l3 && console.log("resuming from subscription state", l3));
    let _2 = l3 === null;
    P3 && t === "insert" && (t = "csv", console.warn("The useCopy option is deprecated and will be removed in a future version. Use initialInsertMethod instead."));
    let j3 = !_2 || t === "insert", $3 = false, v2 = new Map(Object.keys(h3).map((r2) => [r2, new Map])), k2 = new Map(Object.keys(h3).map((r2) => [r2, BigInt(-1)])), x3 = new Set, K3 = l3?.last_lsn ?? BigInt(-1), D2 = new AbortController;
    Object.values(h3).filter((r2) => !!r2.shape.signal).forEach((r2) => {
      r2.shape.signal.addEventListener("abort", () => D2.abort(), { once: true });
    });
    let R4 = new MultiShapeStream({ shapes: Object.fromEntries(Object.entries(h3).map(([r2, L3]) => {
      let S2 = l3?.shape_metadata[r2];
      return [r2, { ...L3.shape, ...S2 ? { offset: S2.offset, handle: S2.handle } : {}, signal: D2.signal }];
    })) }), Z3 = { json: z3, csv: F3, useCopy: F3, insert: G2 }, ee3 = async (r2) => {
      let L3 = new Map(Object.keys(h3).map((S2) => [S2, []]));
      for (let [S2, w2] of v2.entries()) {
        let i2 = L3.get(S2);
        for (let p of w2.keys())
          if (p <= r2) {
            for (let T3 of w2.get(p))
              i2.push(T3);
            w2.delete(p);
          }
      }
      await n.transaction(async (S2) => {
        e && console.time("commit"), await S2.exec(`SET LOCAL ${a}.syncing = true;`);
        for (let [w2, i2] of L3.entries()) {
          let p = h3[w2], T3 = i2;
          if (x3.has(w2)) {
            if (e && console.log("truncating table", p.table), p.onMustRefetch)
              await p.onMustRefetch(S2);
            else {
              let M2 = p.schema || "public";
              await S2.exec(`DELETE FROM "${M2}"."${p.table}";`);
            }
            x3.delete(w2);
          }
          if (!j3) {
            let M2 = [], N2 = [], X3 = false;
            for (let q2 of T3)
              !X3 && q2.headers.operation === "insert" ? M2.push(q2) : (X3 = true, N2.push(q2));
            M2.length > 0 && t === "csv" && N2.unshift(M2.pop()), T3 = N2, M2.length > 0 && (await Z3[t]({ pg: S2, table: p.table, schema: p.schema, messages: M2, mapColumns: p.mapColumns, debug: e }), j3 = true);
          }
          let C3 = [], A3 = null, W2 = T3.length;
          for (let M2 = 0;M2 < W2; M2++) {
            let N2 = T3[M2];
            N2.headers.operation === "insert" ? C3.push(N2) : A3 = N2, (A3 || M2 === W2 - 1) && (C3.length > 0 && (await G2({ pg: S2, table: p.table, schema: p.schema, messages: C3, mapColumns: p.mapColumns, debug: e }), C3.length = 0), A3 && (await Q3({ pg: S2, table: p.table, schema: p.schema, message: A3, mapColumns: p.mapColumns, primaryKey: p.primaryKey, debug: e }), A3 = null));
          }
        }
        c && await Y3({ pg: S2, metadataSchema: a, subscriptionKey: c, shapeMetadata: Object.fromEntries(Object.keys(h3).map((w2) => [w2, { handle: R4.shapes[w2].shapeHandle, offset: R4.shapes[w2].lastOffset }])), lastLsn: r2, debug: e }), E2 && await S2.rollback();
      }), e && console.timeEnd("commit"), d2 && !$3 && R4.isUpToDate && (d2(), $3 = true);
    };
    return R4.subscribe(async (r2) => {
      if (E2)
        return;
      e && console.log("received messages", r2.length), r2.forEach((i2) => {
        let p = k2.get(i2.shape) ?? BigInt(-1);
        if (isChangeMessage(i2)) {
          let T3 = v2.get(i2.shape), C3 = typeof i2.headers.lsn == "string" ? BigInt(i2.headers.lsn) : BigInt(0);
          if (C3 <= p)
            return;
          let A3 = i2.headers.last ?? false;
          T3.has(C3) || T3.set(C3, []), T3.get(C3).push(i2), A3 && k2.set(i2.shape, C3);
        } else if (isControlMessage(i2))
          switch (i2.headers.control) {
            case "up-to-date": {
              if (e && console.log("received up-to-date", i2), typeof i2.headers.global_last_seen_lsn != "string")
                throw new Error("global_last_seen_lsn is not a string");
              let T3 = BigInt(i2.headers.global_last_seen_lsn);
              if (T3 <= p)
                return;
              k2.set(i2.shape, T3);
              break;
            }
            case "must-refetch": {
              e && console.log("received must-refetch", i2), v2.get(i2.shape).clear(), k2.set(i2.shape, BigInt(-1)), x3.add(i2.shape);
              break;
            }
          }
      });
      let L3 = Array.from(k2.values()).reduce((i2, p) => p < i2 ? p : i2), S2 = L3 > K3, w2 = L3 >= K3 && x3.size > 0;
      (S2 || w2) && (ee3(L3), await new Promise((i2) => setTimeout(i2)));
    }), u3.push({ stream: R4, aborter: D2 }), { unsubscribe: () => {
      e && console.log("unsubscribing"), E2 = true, R4.unsubscribeAll(), D2.abort();
      for (let r2 of Object.values(h3))
        b3.delete(r2.table);
    }, get isUpToDate() {
      return R4.isUpToDate;
    }, streams: Object.fromEntries(Object.keys(h3).map((r2) => [r2, R4.shapes[r2]])) };
  };
  return { namespaceObj: { initMetadataTables: f, syncShapesToTables: g3, syncShapeToTable: async (c) => {
    let h3 = await g3({ shapes: { shape: { shape: c.shape, table: c.table, schema: c.schema, mapColumns: c.mapColumns, primaryKey: c.primaryKey, onMustRefetch: c.onMustRefetch } }, key: c.shapeKey, useCopy: c.useCopy, initialInsertMethod: c.initialInsertMethod, onInitialSync: c.onInitialSync });
    return { unsubscribe: h3.unsubscribe, get isUpToDate() {
      return h3.isUpToDate;
    }, stream: h3.streams.shape };
  }, deleteSubscription: async (c) => {
    await V2({ pg: n, metadataSchema: a, subscriptionKey: c });
  } }, close: async () => {
    for (let { stream: c, aborter: h3 } of u3)
      c.unsubscribeAll(), h3.abort();
  } };
}
function me3(n) {
  return { name: "ElectricSQL Sync", setup: async (o3) => {
    let { namespaceObj: e, close: a } = await oe2(o3, n);
    return { namespaceObj: e, close: a };
  } };
}

// ../../node_modules/.pnpm/@electric-sql+pglite@0.3.3/node_modules/@electric-sql/pglite/dist/live/index.js
u();
var M2 = 5;
var U4 = async (l3, w2) => {
  let g3 = new Set, h3 = { async query(e, $3, s2) {
    let v2, c, r2;
    if (typeof e != "string" && (v2 = e.signal, $3 = e.params, s2 = e.callback, c = e.offset, r2 = e.limit, e = e.query), c === undefined != (r2 === undefined))
      throw new Error("offset and limit must be provided together");
    let a = c !== undefined && r2 !== undefined, d2;
    if (a && (typeof c != "number" || isNaN(c) || typeof r2 != "number" || isNaN(r2)))
      throw new Error("offset and limit must be numbers");
    let u3 = s2 ? [s2] : [], _2 = Cr().replace(/-/g, ""), f = false, T3, y2, N2 = async () => {
      await l3.transaction(async (t) => {
        let i2 = $3 && $3.length > 0 ? await Pr(l3, e, $3, t) : e;
        await t.exec(`CREATE OR REPLACE TEMP VIEW live_query_${_2}_view AS ${i2}`), y2 = await q2(t, `live_query_${_2}_view`), await F4(t, y2, g3), a ? (await t.exec(`
              PREPARE live_query_${_2}_get(int, int) AS
              SELECT * FROM live_query_${_2}_view
              LIMIT $1 OFFSET $2;
            `), await t.exec(`
              PREPARE live_query_${_2}_get_total_count AS
              SELECT COUNT(*) FROM live_query_${_2}_view;
            `), d2 = (await t.query(`EXECUTE live_query_${_2}_get_total_count;`)).rows[0].count, T3 = { ...await t.query(`EXECUTE live_query_${_2}_get(${r2}, ${c});`), offset: c, limit: r2, totalCount: d2 }) : (await t.exec(`
              PREPARE live_query_${_2}_get AS
              SELECT * FROM live_query_${_2}_view;
            `), T3 = await t.query(`EXECUTE live_query_${_2}_get;`));
      });
    };
    await N2();
    let A3 = Ur(async ({ offset: t, limit: i2 } = {}) => {
      if (!a && (t !== undefined || i2 !== undefined))
        throw new Error("offset and limit cannot be provided for non-windowed queries");
      if (t && (typeof t != "number" || isNaN(t)) || i2 && (typeof i2 != "number" || isNaN(i2)))
        throw new Error("offset and limit must be numbers");
      c = t ?? c, r2 = i2 ?? r2;
      let m2 = async (E2 = 0) => {
        if (u3.length !== 0) {
          try {
            a ? T3 = { ...await l3.query(`EXECUTE live_query_${_2}_get(${r2}, ${c});`), offset: c, limit: r2, totalCount: d2 } : T3 = await l3.query(`EXECUTE live_query_${_2}_get;`);
          } catch (n) {
            let p = n.message;
            if (p.startsWith(`prepared statement "live_query_${_2}`) && p.endsWith("does not exist")) {
              if (E2 > M2)
                throw n;
              await N2(), m2(E2 + 1);
            } else
              throw n;
          }
          if (S2(u3, T3), a) {
            let n = (await l3.query(`EXECUTE live_query_${_2}_get_total_count;`)).rows[0].count;
            n !== d2 && (d2 = n, A3());
          }
        }
      };
      await m2();
    }), R4 = await Promise.all(y2.map((t) => l3.listen(`"table_change__${t.schema_name}__${t.table_name}"`, async () => {
      A3();
    }))), L3 = (t) => {
      if (f)
        throw new Error("Live query is no longer active and cannot be subscribed to");
      u3.push(t);
    }, o3 = async (t) => {
      t ? u3 = u3.filter((i2) => i2 !== i2) : u3 = [], u3.length === 0 && !f && (f = true, await Promise.all(R4.map((i2) => i2())), await l3.exec(`
            DROP VIEW IF EXISTS live_query_${_2}_view;
            DEALLOCATE live_query_${_2}_get;
          `));
    };
    return v2?.aborted ? await o3() : v2?.addEventListener("abort", () => {
      o3();
    }, { once: true }), S2(u3, T3), { initialResults: T3, subscribe: L3, unsubscribe: o3, refresh: A3 };
  }, async changes(e, $3, s2, v2) {
    let c;
    if (typeof e != "string" && (c = e.signal, $3 = e.params, s2 = e.key, v2 = e.callback, e = e.query), !s2)
      throw new Error("key is required for changes queries");
    let r2 = v2 ? [v2] : [], a = Cr().replace(/-/g, ""), d2 = false, u3, _2 = 1, f, T3 = async () => {
      await l3.transaction(async (o3) => {
        let t = await Pr(l3, e, $3, o3);
        await o3.query(`CREATE OR REPLACE TEMP VIEW live_query_${a}_view AS ${t}`), u3 = await q2(o3, `live_query_${a}_view`), await F4(o3, u3, g3);
        let i2 = [...(await o3.query(`
                SELECT column_name, data_type, udt_name
                FROM information_schema.columns 
                WHERE table_name = 'live_query_${a}_view'
              `)).rows, { column_name: "__after__", data_type: "integer" }];
        await o3.exec(`
            CREATE TEMP TABLE live_query_${a}_state1 (LIKE live_query_${a}_view INCLUDING ALL);
            CREATE TEMP TABLE live_query_${a}_state2 (LIKE live_query_${a}_view INCLUDING ALL);
          `);
        for (let m2 of [1, 2]) {
          let E2 = m2 === 1 ? 2 : 1;
          await o3.exec(`
              PREPARE live_query_${a}_diff${m2} AS
              WITH
                prev AS (SELECT LAG("${s2}") OVER () as __after__, * FROM live_query_${a}_state${E2}),
                curr AS (SELECT LAG("${s2}") OVER () as __after__, * FROM live_query_${a}_state${m2}),
                data_diff AS (
                  -- INSERT operations: Include all columns
                  SELECT 
                    'INSERT' AS __op__,
                    ${i2.map(({ column_name: n }) => `curr."${n}" AS "${n}"`).join(`,
`)},
                    ARRAY[]::text[] AS __changed_columns__
                  FROM curr
                  LEFT JOIN prev ON curr.${s2} = prev.${s2}
                  WHERE prev.${s2} IS NULL
                UNION ALL
                  -- DELETE operations: Include only the primary key
                  SELECT 
                    'DELETE' AS __op__,
                    ${i2.map(({ column_name: n, data_type: p, udt_name: b3 }) => n === s2 ? `prev."${n}" AS "${n}"` : `NULL${p === "USER-DEFINED" ? `::${b3}` : ""} AS "${n}"`).join(`,
`)},
                      ARRAY[]::text[] AS __changed_columns__
                  FROM prev
                  LEFT JOIN curr ON prev.${s2} = curr.${s2}
                  WHERE curr.${s2} IS NULL
                UNION ALL
                  -- UPDATE operations: Include only changed columns
                  SELECT 
                    'UPDATE' AS __op__,
                    ${i2.map(({ column_name: n, data_type: p, udt_name: b3 }) => n === s2 ? `curr."${n}" AS "${n}"` : `CASE 
                              WHEN curr."${n}" IS DISTINCT FROM prev."${n}" 
                              THEN curr."${n}"
                              ELSE NULL${p === "USER-DEFINED" ? `::${b3}` : ""}
                              END AS "${n}"`).join(`,
`)},
                      ARRAY(SELECT unnest FROM unnest(ARRAY[${i2.filter(({ column_name: n }) => n !== s2).map(({ column_name: n }) => `CASE
                              WHEN curr."${n}" IS DISTINCT FROM prev."${n}" 
                              THEN '${n}' 
                              ELSE NULL 
                              END`).join(", ")}]) WHERE unnest IS NOT NULL) AS __changed_columns__
                  FROM curr
                  INNER JOIN prev ON curr.${s2} = prev.${s2}
                  WHERE NOT (curr IS NOT DISTINCT FROM prev)
                )
              SELECT * FROM data_diff;
            `);
        }
      });
    };
    await T3();
    let y2 = Ur(async () => {
      if (r2.length === 0 && f)
        return;
      let o3 = false;
      for (let t = 0;t < 5; t++)
        try {
          await l3.transaction(async (i2) => {
            await i2.exec(`
                INSERT INTO live_query_${a}_state${_2} 
                  SELECT * FROM live_query_${a}_view;
              `), f = await i2.query(`EXECUTE live_query_${a}_diff${_2};`), _2 = _2 === 1 ? 2 : 1, await i2.exec(`
                TRUNCATE live_query_${a}_state${_2};
              `);
          });
          break;
        } catch (i2) {
          if (i2.message === `relation "live_query_${a}_state${_2}" does not exist`) {
            o3 = true, await T3();
            continue;
          } else
            throw i2;
        }
      D2(r2, [...o3 ? [{ __op__: "RESET" }] : [], ...f.rows]);
    }), N2 = await Promise.all(u3.map((o3) => l3.listen(`table_change__${o3.schema_name}__${o3.table_name}`, async () => y2()))), A3 = (o3) => {
      if (d2)
        throw new Error("Live query is no longer active and cannot be subscribed to");
      r2.push(o3);
    }, R4 = async (o3) => {
      o3 ? r2 = r2.filter((t) => t !== t) : r2 = [], r2.length === 0 && !d2 && (d2 = true, await Promise.all(N2.map((t) => t())), await l3.exec(`
            DROP VIEW IF EXISTS live_query_${a}_view;
            DROP TABLE IF EXISTS live_query_${a}_state1;
            DROP TABLE IF EXISTS live_query_${a}_state2;
            DEALLOCATE live_query_${a}_diff1;
            DEALLOCATE live_query_${a}_diff2;
          `));
    };
    return c?.aborted ? await R4() : c?.addEventListener("abort", () => {
      R4();
    }, { once: true }), await y2(), { fields: f.fields.filter((o3) => !["__after__", "__op__", "__changed_columns__"].includes(o3.name)), initialChanges: f.rows, subscribe: A3, unsubscribe: R4, refresh: y2 };
  }, async incrementalQuery(e, $3, s2, v2) {
    let c;
    if (typeof e != "string" && (c = e.signal, $3 = e.params, s2 = e.key, v2 = e.callback, e = e.query), !s2)
      throw new Error("key is required for incremental queries");
    let r2 = v2 ? [v2] : [], a = new Map, d2 = new Map, u3 = [], _2 = true, { fields: f, unsubscribe: T3, refresh: y2 } = await h3.changes(e, $3, s2, (R4) => {
      for (let t of R4) {
        let { __op__: i2, __changed_columns__: m2, ...E2 } = t;
        switch (i2) {
          case "RESET":
            a.clear(), d2.clear();
            break;
          case "INSERT":
            a.set(E2[s2], E2), d2.set(E2.__after__, E2[s2]);
            break;
          case "DELETE": {
            let n = a.get(E2[s2]);
            a.delete(E2[s2]), n.__after__ !== null && d2.delete(n.__after__);
            break;
          }
          case "UPDATE": {
            let n = { ...a.get(E2[s2]) ?? {} };
            for (let p of m2)
              n[p] = E2[p], p === "__after__" && d2.set(E2.__after__, E2[s2]);
            a.set(E2[s2], n);
            break;
          }
        }
      }
      let L3 = [], o3 = null;
      for (let t = 0;t < a.size; t++) {
        let i2 = d2.get(o3), m2 = a.get(i2);
        if (!m2)
          break;
        let E2 = { ...m2 };
        delete E2.__after__, L3.push(E2), o3 = i2;
      }
      u3 = L3, _2 || S2(r2, { rows: L3, fields: f });
    });
    _2 = false, S2(r2, { rows: u3, fields: f });
    let N2 = (R4) => {
      r2.push(R4);
    }, A3 = async (R4) => {
      R4 ? r2 = r2.filter((L3) => L3 !== L3) : r2 = [], r2.length === 0 && await T3();
    };
    return c?.aborted ? await A3() : c?.addEventListener("abort", () => {
      A3();
    }, { once: true }), { initialResults: { rows: u3, fields: f }, subscribe: N2, unsubscribe: A3, refresh: y2 };
  } };
  return { namespaceObj: h3 };
};
var j3 = { name: "Live Queries", setup: U4 };
async function q2(l3, w2) {
  return (await l3.query(`
      WITH RECURSIVE view_dependencies AS (
        -- Base case: Get the initial view's dependencies
        SELECT DISTINCT
          cl.relname AS dependent_name,
          n.nspname AS schema_name,
          cl.relkind = 'v' AS is_view
        FROM pg_rewrite r
        JOIN pg_depend d ON r.oid = d.objid
        JOIN pg_class cl ON d.refobjid = cl.oid
        JOIN pg_namespace n ON cl.relnamespace = n.oid
        WHERE
          r.ev_class = (
              SELECT oid FROM pg_class WHERE relname = $1 AND relkind = 'v'
          )
          AND d.deptype = 'n'

        UNION ALL

        -- Recursive case: Traverse dependencies for views
        SELECT DISTINCT
          cl.relname AS dependent_name,
          n.nspname AS schema_name,
          cl.relkind = 'v' AS is_view
        FROM view_dependencies vd
        JOIN pg_rewrite r ON vd.dependent_name = (
          SELECT relname FROM pg_class WHERE oid = r.ev_class AND relkind = 'v'
        )
        JOIN pg_depend d ON r.oid = d.objid
        JOIN pg_class cl ON d.refobjid = cl.oid
        JOIN pg_namespace n ON cl.relnamespace = n.oid
        WHERE d.deptype = 'n'
      )
      SELECT DISTINCT
        dependent_name AS table_name,
        schema_name
      FROM view_dependencies
      WHERE NOT is_view; -- Exclude intermediate views
    `, [w2])).rows.map((h3) => ({ table_name: h3.table_name, schema_name: h3.schema_name }));
}
async function F4(l3, w2, g3) {
  let h3 = w2.filter((e) => !g3.has(`${e.schema_name}_${e.table_name}`)).map((e) => `
      CREATE OR REPLACE FUNCTION "_notify_${e.schema_name}_${e.table_name}"() RETURNS TRIGGER AS $$
      BEGIN
        PERFORM pg_notify('table_change__${e.schema_name}__${e.table_name}', '');
        RETURN NULL;
      END;
      $$ LANGUAGE plpgsql;
      CREATE OR REPLACE TRIGGER "_notify_trigger_${e.schema_name}_${e.table_name}"
      AFTER INSERT OR UPDATE OR DELETE ON "${e.schema_name}"."${e.table_name}"
      FOR EACH STATEMENT EXECUTE FUNCTION "_notify_${e.schema_name}_${e.table_name}"();
      `).join(`
`);
  h3.trim() !== "" && await l3.exec(h3), w2.map((e) => g3.add(`${e.schema_name}_${e.table_name}`));
}
var S2 = (l3, w2) => {
  for (let g3 of l3)
    g3(w2);
};
var D2 = (l3, w2) => {
  for (let g3 of l3)
    g3(w2);
};

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/logger.js
class ConsoleLogWriter {
  static [entityKind] = "ConsoleLogWriter";
  write(message) {
    console.log(message);
  }
}

class DefaultLogger {
  static [entityKind] = "DefaultLogger";
  writer;
  constructor(config) {
    this.writer = config?.writer ?? new ConsoleLogWriter;
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p) => {
      try {
        return JSON.stringify(p);
      } catch {
        return String(p);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
}

class NoopLogger {
  static [entityKind] = "NoopLogger";
  logQuery() {
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pglite/session.js
class PglitePreparedQuery extends PgPreparedQuery {
  constructor(client, queryString, params, logger, cache, queryMetadata, cacheConfig, fields, name2, _isResponseInArrayMode, customResultMapper) {
    super({ sql: queryString, params }, cache, queryMetadata, cacheConfig);
    this.client = client;
    this.queryString = queryString;
    this.params = params;
    this.logger = logger;
    this.fields = fields;
    this._isResponseInArrayMode = _isResponseInArrayMode;
    this.customResultMapper = customResultMapper;
    this.rawQueryConfig = {
      rowMode: "object",
      parsers: {
        [hn.TIMESTAMP]: (value) => value,
        [hn.TIMESTAMPTZ]: (value) => value,
        [hn.INTERVAL]: (value) => value,
        [hn.DATE]: (value) => value,
        [1231]: (value) => value,
        [1115]: (value) => value,
        [1185]: (value) => value,
        [1187]: (value) => value,
        [1182]: (value) => value
      }
    };
    this.queryConfig = {
      rowMode: "array",
      parsers: {
        [hn.TIMESTAMP]: (value) => value,
        [hn.TIMESTAMPTZ]: (value) => value,
        [hn.INTERVAL]: (value) => value,
        [hn.DATE]: (value) => value,
        [1231]: (value) => value,
        [1115]: (value) => value,
        [1185]: (value) => value,
        [1187]: (value) => value,
        [1182]: (value) => value
      }
    };
  }
  static [entityKind] = "PglitePreparedQuery";
  rawQueryConfig;
  queryConfig;
  async execute(placeholderValues = {}) {
    const params = fillPlaceholders(this.params, placeholderValues);
    this.logger.logQuery(this.queryString, params);
    const { fields, client, queryConfig, joinsNotNullableMap, customResultMapper, queryString, rawQueryConfig } = this;
    if (!fields && !customResultMapper) {
      return this.queryWithCache(queryString, params, async () => {
        return await client.query(queryString, params, rawQueryConfig);
      });
    }
    const result = await this.queryWithCache(queryString, params, async () => {
      return await client.query(queryString, params, queryConfig);
    });
    return customResultMapper ? customResultMapper(result.rows) : result.rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
  }
  all(placeholderValues = {}) {
    const params = fillPlaceholders(this.params, placeholderValues);
    this.logger.logQuery(this.queryString, params);
    return this.queryWithCache(this.queryString, params, async () => {
      return await this.client.query(this.queryString, params, this.rawQueryConfig);
    }).then((result) => result.rows);
  }
  isResponseInArrayMode() {
    return this._isResponseInArrayMode;
  }
}

class PgliteSession extends PgSession {
  constructor(client, dialect, schema, options = {}) {
    super(dialect);
    this.client = client;
    this.schema = schema;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger;
    this.cache = options.cache ?? new NoopCache;
  }
  static [entityKind] = "PgliteSession";
  logger;
  cache;
  prepareQuery(query, fields, name2, isResponseInArrayMode, customResultMapper, queryMetadata, cacheConfig) {
    return new PglitePreparedQuery(this.client, query.sql, query.params, this.logger, this.cache, queryMetadata, cacheConfig, fields, name2, isResponseInArrayMode, customResultMapper);
  }
  async transaction(transaction, config) {
    return this.client.transaction(async (client) => {
      const session = new PgliteSession(client, this.dialect, this.schema, this.options);
      const tx = new PgliteTransaction(this.dialect, session, this.schema);
      if (config) {
        await tx.setTransaction(config);
      }
      return transaction(tx);
    });
  }
  async count(sql2) {
    const res = await this.execute(sql2);
    return Number(res["rows"][0]["count"]);
  }
}

class PgliteTransaction extends PgTransaction {
  static [entityKind] = "PgliteTransaction";
  async transaction(transaction) {
    const savepointName = `sp${this.nestedIndex + 1}`;
    const tx = new PgliteTransaction(this.dialect, this.session, this.schema, this.nestedIndex + 1);
    await tx.execute(sql.raw(`savepoint ${savepointName}`));
    try {
      const result = await transaction(tx);
      await tx.execute(sql.raw(`release savepoint ${savepointName}`));
      return result;
    } catch (err2) {
      await tx.execute(sql.raw(`rollback to savepoint ${savepointName}`));
      throw err2;
    }
  }
}

// ../../node_modules/.pnpm/drizzle-orm@0.44.2_@electric-sql+pglite@0.3.3/node_modules/drizzle-orm/pglite/driver.js
class PgliteDriver {
  constructor(client, dialect, options = {}) {
    this.client = client;
    this.dialect = dialect;
    this.options = options;
  }
  static [entityKind] = "PgliteDriver";
  createSession(schema) {
    return new PgliteSession(this.client, this.dialect, schema, {
      logger: this.options.logger,
      cache: this.options.cache
    });
  }
}

class PgliteDatabase extends PgDatabase {
  static [entityKind] = "PgliteDatabase";
}
function construct(client, config = {}) {
  const dialect = new PgDialect({ casing: config.casing });
  let logger;
  if (config.logger === true) {
    logger = new DefaultLogger;
  } else if (config.logger !== false) {
    logger = config.logger;
  }
  let schema;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(config.schema, createTableRelationsHelpers);
    schema = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const driver = new PgliteDriver(client, dialect, { logger, cache: config.cache });
  const session = driver.createSession(schema);
  const db = new PgliteDatabase(dialect, session, schema);
  db.$client = client;
  db.$cache = config.cache;
  if (db.$cache) {
    db.$cache["invalidate"] = config.cache?.onMutate;
  }
  return db;
}
function drizzle(...params) {
  if (params[0] === undefined || typeof params[0] === "string") {
    const instance2 = new qe2(params[0]);
    return construct(instance2, params[1]);
  }
  if (isConfig(params[0])) {
    const { connection, client, ...drizzleConfig } = params[0];
    if (client)
      return construct(client, drizzleConfig);
    if (typeof connection === "object") {
      const { dataDir, ...options } = connection;
      const instance22 = new qe2(dataDir, options);
      return construct(instance22, drizzleConfig);
    }
    const instance2 = new qe2(connection);
    return construct(instance2, drizzleConfig);
  }
  return construct(params[0], params[1]);
}
((drizzle2) => {
  function mock(config) {
    return construct({}, config);
  }
  drizzle2.mock = mock;
})(drizzle || (drizzle = {}));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Function.js
var isFunction = (input) => typeof input === "function";
var dual = function(arity2, body2) {
  if (typeof arity2 === "function") {
    return function() {
      if (arity2(arguments)) {
        return body2.apply(this, arguments);
      }
      return (self2) => body2(self2, ...arguments);
    };
  }
  switch (arity2) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity2}`);
    case 2:
      return function(a, b3) {
        if (arguments.length >= 2) {
          return body2(a, b3);
        }
        return function(self2) {
          return body2(self2, a);
        };
      };
    case 3:
      return function(a, b3, c) {
        if (arguments.length >= 3) {
          return body2(a, b3, c);
        }
        return function(self2) {
          return body2(self2, a, b3);
        };
      };
    case 4:
      return function(a, b3, c, d2) {
        if (arguments.length >= 4) {
          return body2(a, b3, c, d2);
        }
        return function(self2) {
          return body2(self2, a, b3, c);
        };
      };
    case 5:
      return function(a, b3, c, d2, e) {
        if (arguments.length >= 5) {
          return body2(a, b3, c, d2, e);
        }
        return function(self2) {
          return body2(self2, a, b3, c, d2);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity2) {
          return body2.apply(this, arguments);
        }
        const args2 = arguments;
        return function(self2) {
          return body2(self2, ...args2);
        };
      };
  }
};
var identity = (a) => a;
var constant = (value) => () => value;
var constTrue = /* @__PURE__ */ constant(true);
var constFalse = /* @__PURE__ */ constant(false);
var constNull = /* @__PURE__ */ constant(null);
var constUndefined = /* @__PURE__ */ constant(undefined);
var constVoid = constUndefined;
function pipe(a, ab, bc, cd, de3, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de3(cd(bc(ab(a))));
    case 6:
      return ef(de3(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de3(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de3(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de3(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i2 = 1;i2 < arguments.length; i2++) {
        ret = arguments[i2](ret);
      }
      return ret;
    }
  }
}
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Equivalence.js
var make = (isEquivalent) => (self2, that) => self2 === that || isEquivalent(self2, that);
var isStrictEquivalent = (x3, y2) => x3 === y2;
var strict = () => isStrictEquivalent;
var number = /* @__PURE__ */ strict();
var mapInput = /* @__PURE__ */ dual(2, (self2, f) => make((x3, y2) => self2(f(x3), f(y2))));
var Date2 = /* @__PURE__ */ mapInput(number, (date2) => date2.getTime());
var array = (item) => make((self2, that) => {
  if (self2.length !== that.length) {
    return false;
  }
  for (let i2 = 0;i2 < self2.length; i2++) {
    const isEq = item(self2[i2], that[i2]);
    if (!isEq) {
      return false;
    }
  }
  return true;
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/doNotation.js
var let_ = (map) => dual(3, (self2, name2, f) => map(self2, (a) => ({
  ...a,
  [name2]: f(a)
})));
var bindTo = (map) => dual(2, (self2, name2) => map(self2, (a) => ({
  [name2]: a
})));
var bind = (map, flatMap) => dual(3, (self2, name2, f) => flatMap(self2, (a) => map(f(a), (b3) => ({
  ...a,
  [name2]: b3
}))));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.16.8";
var getCurrentVersion = () => moduleVersion;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId = `effect/GlobalValue/globalStoreId/${/* @__PURE__ */ getCurrentVersion()}`;
var globalStore;
var globalValue = (id, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ??= new Map;
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id)) {
    globalStore.set(id, compute());
  }
  return globalStore.get(id);
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Predicate.js
var isTruthy = (input) => !!input;
var isSet = (input) => input instanceof Set;
var isMap = (input) => input instanceof Map;
var isString = (input) => typeof input === "string";
var isNumber = (input) => typeof input === "number";
var isBoolean = (input) => typeof input === "boolean";
var isBigInt = (input) => typeof input === "bigint";
var isSymbol = (input) => typeof input === "symbol";
var isFunction2 = isFunction;
var isUndefined = (input) => input === undefined;
var isNotUndefined = (input) => input !== undefined;
var isNotNull2 = (input) => input !== null;
var isNever = (_2) => false;
var isRecordOrArray = (input) => typeof input === "object" && input !== null;
var isObject = (input) => isRecordOrArray(input) || isFunction2(input);
var hasProperty = /* @__PURE__ */ dual(2, (self2, property) => isObject(self2) && (property in self2));
var isTagged = /* @__PURE__ */ dual(2, (self2, tag) => hasProperty(self2, "_tag") && self2["_tag"] === tag);
var isNullable = (input) => input === null || input === undefined;
var isNotNullable = (input) => input !== null && input !== undefined;
var isUint8Array = (input) => input instanceof Uint8Array;
var isDate = (input) => input instanceof Date;
var isIterable = (input) => hasProperty(input, Symbol.iterator);
var isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);
var isPromiseLike = (input) => hasProperty(input, "then") && isFunction2(input.then);

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Utils.js
class SingleShotGen {
  self;
  called = false;
  constructor(self2) {
    this.self = self2;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new SingleShotGen(this.self);
  }
}
var defaultIncHi = 335903614;
var defaultIncLo = 4150755663;
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var BIT_53 = 9007199254740992;
var BIT_27 = 134217728;

class PCGRandom {
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  integer(max) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max;
  }
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
}
function mul64(out2, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out2[0] = hi;
  out2[1] = lo;
}
function add64(out2, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out2[0] = hi;
  out2[1] = lo;
}
var YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");

class YieldWrap {
  #value;
  constructor(value) {
    this.#value = value;
  }
  [YieldWrapTypeId]() {
    return this.#value;
  }
}
function yieldWrapGet(self2) {
  if (typeof self2 === "object" && self2 !== null && YieldWrapTypeId in self2) {
    return self2[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
var structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: undefined
}));
var standard = {
  effect_internal_function: (body2) => {
    return body2();
  }
};
var forced = {
  effect_internal_function: (body2) => {
    try {
      return body2();
    } finally {
    }
  }
};
var isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
var genConstructor = function* () {
}.constructor;
var isGeneratorFunction = (u3) => isObject(u3) && u3.constructor === genConstructor;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Hash.js
var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => new WeakMap);
var symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
var hash = (self2) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self2) {
    case "number":
      return number2(self2);
    case "bigint":
      return string(self2.toString(10));
    case "boolean":
      return string(String(self2));
    case "symbol":
      return string(String(self2));
    case "string":
      return string(self2);
    case "undefined":
      return string("undefined");
    case "function":
    case "object": {
      if (self2 === null) {
        return string("null");
      } else if (self2 instanceof Date) {
        return hash(self2.toISOString());
      } else if (self2 instanceof URL) {
        return hash(self2.href);
      } else if (isHash(self2)) {
        return self2[symbol]();
      } else {
        return random(self2);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self2} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
var random = (self2) => {
  if (!randomHashCache.has(self2)) {
    randomHashCache.set(self2, number2(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self2);
};
var combine = (b3) => (self2) => self2 * 53 ^ b3;
var optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
var isHash = (u3) => hasProperty(u3, symbol);
var number2 = (n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h3 = n | 0;
  if (h3 !== n) {
    h3 ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h3 ^= n /= 4294967295;
  }
  return optimize(h3);
};
var string = (str) => {
  let h3 = 5381, i2 = str.length;
  while (i2) {
    h3 = h3 * 33 ^ str.charCodeAt(--i2);
  }
  return optimize(h3);
};
var structureKeys = (o3, keys) => {
  let h3 = 12289;
  for (let i2 = 0;i2 < keys.length; i2++) {
    h3 ^= pipe(string(keys[i2]), combine(hash(o3[keys[i2]])));
  }
  return optimize(h3);
};
var structure = (o3) => structureKeys(o3, Object.keys(o3));
var array2 = (arr) => {
  let h3 = 6151;
  for (let i2 = 0;i2 < arr.length; i2++) {
    h3 = pipe(h3, combine(hash(arr[i2])));
  }
  return optimize(h3);
};
var cached = function() {
  if (arguments.length === 1) {
    const self3 = arguments[0];
    return function(hash3) {
      Object.defineProperty(self3, symbol, {
        value() {
          return hash3;
        },
        enumerable: false
      });
      return hash3;
    };
  }
  const self2 = arguments[0];
  const hash2 = arguments[1];
  Object.defineProperty(self2, symbol, {
    value() {
      return hash2;
    },
    enumerable: false
  });
  return hash2;
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Equal.js
var symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self2) => compareBoth(self2, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self2, that) {
  if (self2 === that) {
    return true;
  }
  const selfType = typeof self2;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self2 !== null && that !== null) {
      if (isEqual(self2) && isEqual(that)) {
        if (hash(self2) === hash(that) && self2[symbol2](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
        }
      } else if (self2 instanceof Date && that instanceof Date) {
        return self2.toISOString() === that.toISOString();
      } else if (self2 instanceof URL && that instanceof URL) {
        return self2.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self2) && Array.isArray(that)) {
        return self2.length === that.length && self2.every((v2, i2) => compareBoth(v2, that[i2]));
      }
      if (Object.getPrototypeOf(self2) === Object.prototype && Object.getPrototypeOf(self2) === Object.prototype) {
        const keysSelf = Object.keys(self2);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!((key in that) && compareBoth(self2[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
}
var isEqual = (u3) => hasProperty(u3, symbol2);
var equivalence = () => equals;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Inspectable.js
var NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var toJSON = (x3) => {
  try {
    if (hasProperty(x3, "toJSON") && isFunction2(x3["toJSON"]) && x3["toJSON"].length === 0) {
      return x3.toJSON();
    } else if (Array.isArray(x3)) {
      return x3.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x3);
};
var format = (x3) => JSON.stringify(x3, null, 2);
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var toStringUnknown = (u3, whitespace = 2) => {
  if (typeof u3 === "string") {
    return u3;
  }
  try {
    return typeof u3 === "object" ? stringifyCircular(u3, whitespace) : String(u3);
  } catch {
    return String(u3);
  }
};
var stringifyCircular = (obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value) => typeof value === "object" && value !== null ? cache.includes(value) ? undefined : cache.push(value) && (redactableState.fiberRefs !== undefined && isRedactable(value) ? value[symbolRedactable](redactableState.fiberRefs) : value) : value, whitespace);
  cache = undefined;
  return retVal;
};
var symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
var isRedactable = (u3) => typeof u3 === "object" && u3 !== null && (symbolRedactable in u3);
var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: undefined
}));
var withRedactableContext = (context, f) => {
  const prev = redactableState.fiberRefs;
  redactableState.fiberRefs = context;
  try {
    return f();
  } finally {
    redactableState.fiberRefs = prev;
  }
};
var redact = (u3) => {
  if (isRedactable(u3) && redactableState.fiberRefs !== undefined) {
    return u3[symbolRedactable](redactableState.fiberRefs);
  }
  return u3;
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Pipeable.js
var pipeArguments = (self2, args2) => {
  switch (args2.length) {
    case 0:
      return self2;
    case 1:
      return args2[0](self2);
    case 2:
      return args2[1](args2[0](self2));
    case 3:
      return args2[2](args2[1](args2[0](self2)));
    case 4:
      return args2[3](args2[2](args2[1](args2[0](self2))));
    case 5:
      return args2[4](args2[3](args2[2](args2[1](args2[0](self2)))));
    case 6:
      return args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2))))));
    case 7:
      return args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2)))))));
    case 8:
      return args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2))))))));
    case 9:
      return args2[8](args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2)))))))));
    default: {
      let ret = self2;
      for (let i2 = 0, len = args2.length;i2 < len; i2++) {
        ret = args2[i2](ret);
      }
      return ret;
    }
  }
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_ASYNC = "Async";
var OP_COMMIT = "Commit";
var OP_FAILURE = "Failure";
var OP_ON_FAILURE = "OnFailure";
var OP_ON_SUCCESS = "OnSuccess";
var OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
var OP_SUCCESS = "Success";
var OP_SYNC = "Sync";
var OP_TAG = "Tag";
var OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
var OP_WHILE = "While";
var OP_ITERATOR = "Iterator";
var OP_WITH_RUNTIME = "WithRuntime";
var OP_YIELD = "Yield";
var OP_REVERT_FLAGS = "RevertFlags";

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
var StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
var SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
var ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
var effectVariance = {
  _R: (_2) => _2,
  _E: (_2) => _2,
  _A: (_2) => _2,
  _V: /* @__PURE__ */ getCurrentVersion()
};
var sinkVariance = {
  _A: (_2) => _2,
  _In: (_2) => _2,
  _L: (_2) => _2,
  _E: (_2) => _2,
  _R: (_2) => _2
};
var channelVariance = {
  _Env: (_2) => _2,
  _InErr: (_2) => _2,
  _InElem: (_2) => _2,
  _InDone: (_2) => _2,
  _OutErr: (_2) => _2,
  _OutElem: (_2) => _2,
  _OutDone: (_2) => _2
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol2](that) {
    return this === that;
  },
  [symbol]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol]() {
    return cached(this, structure(this));
  },
  [symbol2](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!((key in that) && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};
var Base = /* @__PURE__ */ function() {
  function Base2() {
  }
  Base2.prototype = CommitPrototype;
  return Base2;
}();

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/option.js
var TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: (_2) => _2
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol2](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol]() {
    return cached(this, combine(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = /* @__PURE__ */ hash("None");
var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol2](that) {
    return isOption(that) && isNone(that);
  },
  [symbol]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = (input) => hasProperty(input, TypeId);
var isNone = (fa) => fa._tag === "None";
var isSome = (fa) => fa._tag === "Some";
var none = /* @__PURE__ */ Object.create(NoneProto);
var some = (value) => {
  const a = Object.create(SomeProto);
  a.value = value;
  return a;
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/either.js
var TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId2]: {
    _R: (_2) => _2
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol2](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol2](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = (input) => hasProperty(input, TypeId2);
var isLeft = (ma) => ma._tag === "Left";
var isRight = (ma) => ma._tag === "Right";
var left = (left2) => {
  const a = Object.create(LeftProto);
  a.left = left2;
  return a;
};
var right = (right2) => {
  const a = Object.create(RightProto);
  a.right = right2;
  return a;
};
var getRight = (self2) => isLeft(self2) ? none : some(self2.right);
var fromOption = /* @__PURE__ */ dual(2, (self2, onNone) => isNone(self2) ? left(onNone()) : right(self2.value));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Either.js
var right2 = right;
var left2 = left;
var fromOption2 = fromOption;
var try_ = (evaluate) => {
  if (isFunction2(evaluate)) {
    try {
      return right2(evaluate());
    } catch (e) {
      return left2(e);
    }
  } else {
    try {
      return right2(evaluate.try());
    } catch (e) {
      return left2(evaluate.catch(e));
    }
  }
};
var isEither2 = isEither;
var isLeft2 = isLeft;
var isRight2 = isRight;
var getEquivalence = ({
  left: left3,
  right: right3
}) => make((x3, y2) => isLeft2(x3) ? isLeft2(y2) && left3(x3.left, y2.left) : isRight2(y2) && right3(x3.right, y2.right));
var mapBoth = /* @__PURE__ */ dual(2, (self2, {
  onLeft,
  onRight
}) => isLeft2(self2) ? left2(onLeft(self2.left)) : right2(onRight(self2.right)));
var mapLeft = /* @__PURE__ */ dual(2, (self2, f) => isLeft2(self2) ? left2(f(self2.left)) : right2(self2.right));
var map = /* @__PURE__ */ dual(2, (self2, f) => isRight2(self2) ? right2(f(self2.right)) : left2(self2.left));
var match = /* @__PURE__ */ dual(2, (self2, {
  onLeft,
  onRight
}) => isLeft2(self2) ? onLeft(self2.left) : onRight(self2.right));
var merge = /* @__PURE__ */ match({
  onLeft: identity,
  onRight: identity
});
var getOrThrowWith = /* @__PURE__ */ dual(2, (self2, onLeft) => {
  if (isRight2(self2)) {
    return self2.right;
  }
  throw onLeft(self2.left);
});
var getOrThrow = /* @__PURE__ */ getOrThrowWith(() => new Error("getOrThrow called on a Left"));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray = (self2) => self2.length > 0;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Order.js
var make2 = (compare) => (self2, that) => self2 === that ? 0 : compare(self2, that);
var number3 = /* @__PURE__ */ make2((self2, that) => self2 < that ? -1 : 1);
var bigint2 = /* @__PURE__ */ make2((self2, that) => self2 < that ? -1 : 1);
var mapInput2 = /* @__PURE__ */ dual(2, (self2, f) => make2((b1, b22) => self2(f(b1), f(b22))));
var lessThan = (O2) => dual(2, (self2, that) => O2(self2, that) === -1);
var greaterThan = (O2) => dual(2, (self2, that) => O2(self2, that) === 1);
var lessThanOrEqualTo = (O2) => dual(2, (self2, that) => O2(self2, that) !== 1);
var greaterThanOrEqualTo = (O2) => dual(2, (self2, that) => O2(self2, that) !== -1);
var min = (O2) => dual(2, (self2, that) => self2 === that || O2(self2, that) < 1 ? self2 : that);
var max = (O2) => dual(2, (self2, that) => self2 === that || O2(self2, that) > -1 ? self2 : that);
var clamp = (O2) => dual(2, (self2, options) => min(O2)(options.maximum, max(O2)(options.minimum, self2)));
var between2 = (O2) => dual(2, (self2, options) => !lessThan(O2)(self2, options.minimum) && !greaterThan(O2)(self2, options.maximum));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Option.js
var none2 = () => none;
var some2 = some;
var isOption2 = isOption;
var isNone2 = isNone;
var isSome2 = isSome;
var match2 = /* @__PURE__ */ dual(2, (self2, {
  onNone,
  onSome
}) => isNone2(self2) ? onNone() : onSome(self2.value));
var getRight2 = getRight;
var getOrElse = /* @__PURE__ */ dual(2, (self2, onNone) => isNone2(self2) ? onNone() : self2.value);
var orElse = /* @__PURE__ */ dual(2, (self2, that) => isNone2(self2) ? that() : self2);
var orElseSome = /* @__PURE__ */ dual(2, (self2, onNone) => isNone2(self2) ? some2(onNone()) : self2);
var fromNullable = (nullableValue) => nullableValue == null ? none2() : some2(nullableValue);
var getOrNull = /* @__PURE__ */ getOrElse(constNull);
var getOrUndefined = /* @__PURE__ */ getOrElse(constUndefined);
var liftThrowable = (f) => (...a) => {
  try {
    return some2(f(...a));
  } catch {
    return none2();
  }
};
var getOrThrowWith2 = /* @__PURE__ */ dual(2, (self2, onNone) => {
  if (isSome2(self2)) {
    return self2.value;
  }
  throw onNone();
});
var getOrThrow2 = /* @__PURE__ */ getOrThrowWith2(() => new Error("getOrThrow called on a None"));
var map2 = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : some2(f(self2.value)));
var flatMap = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : f(self2.value));
var flatMapNullable = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : fromNullable(f(self2.value)));
var filterMap = flatMap;
var filter = /* @__PURE__ */ dual(2, (self2, predicate) => filterMap(self2, (b3) => predicate(b3) ? some(b3) : none));
var getEquivalence2 = (isEquivalent) => make((x3, y2) => isNone2(x3) ? isNone2(y2) : isNone2(y2) ? false : isEquivalent(x3.value, y2.value));
var containsWith = (isEquivalent) => dual(2, (self2, a) => isNone2(self2) ? false : isEquivalent(self2.value, a));
var _equivalence = /* @__PURE__ */ equivalence();
var contains = /* @__PURE__ */ containsWith(_equivalence);
var exists2 = /* @__PURE__ */ dual(2, (self2, refinement) => isNone2(self2) ? false : refinement(self2.value));
var mergeWith = (f) => (o1, o22) => {
  if (isNone2(o1)) {
    return o22;
  } else if (isNone2(o22)) {
    return o1;
  }
  return some2(f(o1.value, o22.value));
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Tuple.js
var make3 = (...elements) => elements;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Iterable.js
var unsafeHead = (self2) => {
  const iterator = self2[Symbol.iterator]();
  const result = iterator.next();
  if (result.done)
    throw new Error("unsafeHead: empty iterable");
  return result.value;
};
var findFirst = /* @__PURE__ */ dual(2, (self2, f) => {
  let i2 = 0;
  for (const a of self2) {
    const o3 = f(a, i2);
    if (isBoolean(o3)) {
      if (o3) {
        return some2(a);
      }
    } else {
      if (isSome2(o3)) {
        return o3;
      }
    }
    i2++;
  }
  return none2();
});
var constEmpty = {
  [Symbol.iterator]() {
    return constEmptyIterator;
  }
};
var constEmptyIterator = {
  next() {
    return {
      done: true,
      value: undefined
    };
  }
};
var empty = () => constEmpty;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Array.js
var allocate = (n) => new Array(n);
var makeBy = /* @__PURE__ */ dual(2, (n, f) => {
  const max2 = Math.max(1, Math.floor(n));
  const out2 = new Array(max2);
  for (let i2 = 0;i2 < max2; i2++) {
    out2[i2] = f(i2);
  }
  return out2;
});
var fromIterable = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
var ensure = (self2) => Array.isArray(self2) ? self2 : [self2];
var match3 = /* @__PURE__ */ dual(2, (self2, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(self2) : onEmpty());
var matchLeft = /* @__PURE__ */ dual(2, (self2, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(headNonEmpty(self2), tailNonEmpty(self2)) : onEmpty());
var prepend = /* @__PURE__ */ dual(2, (self2, head) => [head, ...self2]);
var append = /* @__PURE__ */ dual(2, (self2, last) => [...self2, last]);
var appendAll = /* @__PURE__ */ dual(2, (self2, that) => fromIterable(self2).concat(fromIterable(that)));
var isArray = Array.isArray;
var isEmptyArray = (self2) => self2.length === 0;
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyArray2 = isNonEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var isOutOfBounds = (i2, as) => i2 < 0 || i2 >= as.length;
var clamp2 = (i2, as) => Math.floor(Math.min(Math.max(0, i2), as.length));
var get = /* @__PURE__ */ dual(2, (self2, index2) => {
  const i2 = Math.floor(index2);
  return isOutOfBounds(i2, self2) ? none2() : some2(self2[i2]);
});
var unsafeGet = /* @__PURE__ */ dual(2, (self2, index2) => {
  const i2 = Math.floor(index2);
  if (isOutOfBounds(i2, self2)) {
    throw new Error(`Index ${i2} out of bounds`);
  }
  return self2[i2];
});
var head = /* @__PURE__ */ get(0);
var headNonEmpty = /* @__PURE__ */ unsafeGet(0);
var last = (self2) => isNonEmptyReadonlyArray(self2) ? some2(lastNonEmpty(self2)) : none2();
var lastNonEmpty = (self2) => self2[self2.length - 1];
var tailNonEmpty = (self2) => self2.slice(1);
var spanIndex = (self2, predicate) => {
  let i2 = 0;
  for (const a of self2) {
    if (!predicate(a, i2)) {
      break;
    }
    i2++;
  }
  return i2;
};
var span = /* @__PURE__ */ dual(2, (self2, predicate) => splitAt(self2, spanIndex(self2, predicate)));
var drop = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable(self2);
  return input.slice(clamp2(n, input), input.length);
});
var findFirst2 = findFirst;
var reverse = (self2) => Array.from(self2).reverse();
var sort = /* @__PURE__ */ dual(2, (self2, O2) => {
  const out2 = Array.from(self2);
  out2.sort(O2);
  return out2;
});
var zip = /* @__PURE__ */ dual(2, (self2, that) => zipWith(self2, that, make3));
var zipWith = /* @__PURE__ */ dual(3, (self2, that, f) => {
  const as = fromIterable(self2);
  const bs = fromIterable(that);
  if (isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs)) {
    const out2 = [f(headNonEmpty(as), headNonEmpty(bs))];
    const len = Math.min(as.length, bs.length);
    for (let i2 = 1;i2 < len; i2++) {
      out2[i2] = f(as[i2], bs[i2]);
    }
    return out2;
  }
  return [];
});
var containsWith2 = (isEquivalent) => dual(2, (self2, a) => {
  for (const i2 of self2) {
    if (isEquivalent(a, i2)) {
      return true;
    }
  }
  return false;
});
var _equivalence2 = /* @__PURE__ */ equivalence();
var splitAt = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = Array.from(self2);
  const _n2 = Math.floor(n);
  if (isNonEmptyReadonlyArray(input)) {
    if (_n2 >= 1) {
      return splitNonEmptyAt(input, _n2);
    }
    return [[], input];
  }
  return [input, []];
});
var splitNonEmptyAt = /* @__PURE__ */ dual(2, (self2, n) => {
  const _n2 = Math.max(1, Math.floor(n));
  return _n2 >= self2.length ? [copy(self2), []] : [prepend(self2.slice(1, _n2), headNonEmpty(self2)), self2.slice(_n2)];
});
var copy = (self2) => self2.slice();
var unionWith = /* @__PURE__ */ dual(3, (self2, that, isEquivalent) => {
  const a = fromIterable(self2);
  const b3 = fromIterable(that);
  if (isNonEmptyReadonlyArray(a)) {
    if (isNonEmptyReadonlyArray(b3)) {
      const dedupe = dedupeWith(isEquivalent);
      return dedupe(appendAll(a, b3));
    }
    return a;
  }
  return b3;
});
var union2 = /* @__PURE__ */ dual(2, (self2, that) => unionWith(self2, that, _equivalence2));
var intersectionWith = (isEquivalent) => {
  const has = containsWith2(isEquivalent);
  return dual(2, (self2, that) => fromIterable(self2).filter((a) => has(that, a)));
};
var intersection = /* @__PURE__ */ intersectionWith(_equivalence2);
var empty2 = () => [];
var of = (a) => [a];
var map3 = /* @__PURE__ */ dual(2, (self2, f) => self2.map(f));
var flatMap2 = /* @__PURE__ */ dual(2, (self2, f) => {
  if (isEmptyReadonlyArray(self2)) {
    return [];
  }
  const out2 = [];
  for (let i2 = 0;i2 < self2.length; i2++) {
    const inner = f(self2[i2], i2);
    for (let j4 = 0;j4 < inner.length; j4++) {
      out2.push(inner[j4]);
    }
  }
  return out2;
});
var flatten = /* @__PURE__ */ flatMap2(identity);
var filterMap2 = /* @__PURE__ */ dual(2, (self2, f) => {
  const as = fromIterable(self2);
  const out2 = [];
  for (let i2 = 0;i2 < as.length; i2++) {
    const o3 = f(as[i2], i2);
    if (isSome2(o3)) {
      out2.push(o3.value);
    }
  }
  return out2;
});
var partitionMap = /* @__PURE__ */ dual(2, (self2, f) => {
  const left3 = [];
  const right3 = [];
  const as = fromIterable(self2);
  for (let i2 = 0;i2 < as.length; i2++) {
    const e = f(as[i2], i2);
    if (isLeft2(e)) {
      left3.push(e.left);
    } else {
      right3.push(e.right);
    }
  }
  return [left3, right3];
});
var getSomes = /* @__PURE__ */ filterMap2(identity);
var reduce = /* @__PURE__ */ dual(3, (self2, b3, f) => fromIterable(self2).reduce((b4, a, i2) => f(b4, a, i2), b3));
var reduceRight = /* @__PURE__ */ dual(3, (self2, b3, f) => fromIterable(self2).reduceRight((b4, a, i2) => f(b4, a, i2), b3));
var every = /* @__PURE__ */ dual(2, (self2, refinement) => self2.every(refinement));
var unfold = (b3, f) => {
  const out2 = [];
  let next = b3;
  let o3;
  while (isSome2(o3 = f(next))) {
    const [a, b4] = o3.value;
    out2.push(a);
    next = b4;
  }
  return out2;
};
var getEquivalence3 = array;
var dedupeWith = /* @__PURE__ */ dual(2, (self2, isEquivalent) => {
  const input = fromIterable(self2);
  if (isNonEmptyReadonlyArray(input)) {
    const out2 = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r2 of rest) {
      if (out2.every((a) => !isEquivalent(r2, a))) {
        out2.push(r2);
      }
    }
    return out2;
  }
  return [];
});
var dedupe = (self2) => dedupeWith(self2, equivalence());
var join = /* @__PURE__ */ dual(2, (self2, sep) => fromIterable(self2).join(sep));

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/StreamHelpers.js
class Nil {
  [Symbol.iterator]() {
    return this;
  }
  next(value) {
    return { value, done: true };
  }
}
Nil.nil = new Nil;
function nilHelper() {
  return Nil.nil;
}
function* mapHelper(g3, f) {
  for (const v2 of g3) {
    yield f(v2);
  }
}
function* flatMapHelper(g3, f) {
  for (const v2 of g3) {
    yield* f(v2);
  }
}
function* filterHelper(g3, f) {
  for (const v2 of g3) {
    if (f(v2)) {
      yield v2;
    }
  }
}
function* takeNHelper(g3, n) {
  for (let i2 = 0;i2 < n; ++i2) {
    const cur = g3.next();
    if (cur.done) {
      break;
    }
    yield cur.value;
  }
}
function* takeWhileHelper(g3, f) {
  let cur = g3.next();
  while (!cur.done && f(cur.value)) {
    yield cur.value;
    cur = g3.next();
  }
}
function* joinHelper(g3, others) {
  for (let cur = g3.next();!cur.done; cur = g3.next()) {
    yield cur.value;
  }
  for (const s2 of others) {
    for (let cur = s2.next();!cur.done; cur = s2.next()) {
      yield cur.value;
    }
  }
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/Stream.js
var safeSymbolIterator = Symbol.iterator;

class Stream {
  static nil() {
    return new Stream(nilHelper());
  }
  static of(...elements) {
    return new Stream(elements[safeSymbolIterator]());
  }
  constructor(g3) {
    this.g = g3;
  }
  next() {
    return this.g.next();
  }
  [Symbol.iterator]() {
    return this.g;
  }
  map(f) {
    return new Stream(mapHelper(this.g, f));
  }
  flatMap(f) {
    return new Stream(flatMapHelper(this.g, f));
  }
  dropWhile(f) {
    let foundEligible = false;
    function* helper(v2) {
      if (foundEligible || !f(v2)) {
        foundEligible = true;
        yield v2;
      }
    }
    return this.flatMap(helper);
  }
  drop(n) {
    if (n <= 0) {
      return this;
    }
    let idx = 0;
    function helper() {
      return idx++ < n;
    }
    return this.dropWhile(helper);
  }
  takeWhile(f) {
    return new Stream(takeWhileHelper(this.g, f));
  }
  take(n) {
    return new Stream(takeNHelper(this.g, n));
  }
  filter(f) {
    return new Stream(filterHelper(this.g, f));
  }
  every(f) {
    for (const v2 of this.g) {
      if (!f(v2)) {
        return false;
      }
    }
    return true;
  }
  has(f) {
    for (const v2 of this.g) {
      if (f(v2)) {
        return [true, v2];
      }
    }
    return [false, null];
  }
  join(...others) {
    return new Stream(joinHelper(this.g, others));
  }
  getNthOrLast(nth) {
    let remaining = nth;
    let last2 = null;
    for (const v2 of this.g) {
      if (remaining-- === 0)
        return v2;
      last2 = v2;
    }
    return last2;
  }
}
function stream(g3) {
  return new Stream(g3);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/symbols.js
var cloneMethod = Symbol.for("fast-check/cloneMethod");
function hasCloneMethod(instance2) {
  return instance2 !== null && (typeof instance2 === "object" || typeof instance2 === "function") && cloneMethod in instance2 && typeof instance2[cloneMethod] === "function";
}
function cloneIfNeeded(instance2) {
  return hasCloneMethod(instance2) ? instance2[cloneMethod]() : instance2;
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/arbitrary/definition/Value.js
var safeObjectDefineProperty = Object.defineProperty;

class Value {
  constructor(value_, context, customGetValue = undefined) {
    this.value_ = value_;
    this.context = context;
    this.hasToBeCloned = customGetValue !== undefined || hasCloneMethod(value_);
    this.readOnce = false;
    if (this.hasToBeCloned) {
      safeObjectDefineProperty(this, "value", { get: customGetValue !== undefined ? customGetValue : this.getValue });
    } else {
      this.value = value_;
    }
  }
  getValue() {
    if (this.hasToBeCloned) {
      if (!this.readOnce) {
        this.readOnce = true;
        return this.value_;
      }
      return this.value_[cloneMethod]();
    }
    return this.value_;
  }
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/arbitrary/definition/Arbitrary.js
var safeObjectAssign = Object.assign;

class Arbitrary {
  filter(refinement) {
    return new FilterArbitrary(this, refinement);
  }
  map(mapper, unmapper) {
    return new MapArbitrary(this, mapper, unmapper);
  }
  chain(chainer) {
    return new ChainArbitrary(this, chainer);
  }
  noShrink() {
    return new NoShrinkArbitrary(this);
  }
  noBias() {
    return new NoBiasArbitrary(this);
  }
}

class ChainArbitrary extends Arbitrary {
  constructor(arb, chainer) {
    super();
    this.arb = arb;
    this.chainer = chainer;
  }
  generate(mrng, biasFactor) {
    const clonedMrng = mrng.clone();
    const src = this.arb.generate(mrng, biasFactor);
    return this.valueChainer(src, mrng, clonedMrng, biasFactor);
  }
  canShrinkWithoutContext(value) {
    return false;
  }
  shrink(value, context) {
    if (this.isSafeContext(context)) {
      return (!context.stoppedForOriginal ? this.arb.shrink(context.originalValue, context.originalContext).map((v2) => this.valueChainer(v2, context.clonedMrng.clone(), context.clonedMrng, context.originalBias)) : Stream.nil()).join(context.chainedArbitrary.shrink(value, context.chainedContext).map((dst) => {
        const newContext = safeObjectAssign(safeObjectAssign({}, context), {
          chainedContext: dst.context,
          stoppedForOriginal: true
        });
        return new Value(dst.value_, newContext);
      }));
    }
    return Stream.nil();
  }
  valueChainer(v2, generateMrng, clonedMrng, biasFactor) {
    const chainedArbitrary = this.chainer(v2.value_);
    const dst = chainedArbitrary.generate(generateMrng, biasFactor);
    const context = {
      originalBias: biasFactor,
      originalValue: v2.value_,
      originalContext: v2.context,
      stoppedForOriginal: false,
      chainedArbitrary,
      chainedContext: dst.context,
      clonedMrng
    };
    return new Value(dst.value_, context);
  }
  isSafeContext(context) {
    return context != null && typeof context === "object" && "originalBias" in context && "originalValue" in context && "originalContext" in context && "stoppedForOriginal" in context && "chainedArbitrary" in context && "chainedContext" in context && "clonedMrng" in context;
  }
}

class MapArbitrary extends Arbitrary {
  constructor(arb, mapper, unmapper) {
    super();
    this.arb = arb;
    this.mapper = mapper;
    this.unmapper = unmapper;
    this.bindValueMapper = (v2) => this.valueMapper(v2);
  }
  generate(mrng, biasFactor) {
    const g3 = this.arb.generate(mrng, biasFactor);
    return this.valueMapper(g3);
  }
  canShrinkWithoutContext(value) {
    if (this.unmapper !== undefined) {
      try {
        const unmapped = this.unmapper(value);
        return this.arb.canShrinkWithoutContext(unmapped);
      } catch (_err) {
        return false;
      }
    }
    return false;
  }
  shrink(value, context) {
    if (this.isSafeContext(context)) {
      return this.arb.shrink(context.originalValue, context.originalContext).map(this.bindValueMapper);
    }
    if (this.unmapper !== undefined) {
      const unmapped = this.unmapper(value);
      return this.arb.shrink(unmapped, undefined).map(this.bindValueMapper);
    }
    return Stream.nil();
  }
  mapperWithCloneIfNeeded(v2) {
    const sourceValue = v2.value;
    const mappedValue = this.mapper(sourceValue);
    if (v2.hasToBeCloned && (typeof mappedValue === "object" && mappedValue !== null || typeof mappedValue === "function") && Object.isExtensible(mappedValue) && !hasCloneMethod(mappedValue)) {
      Object.defineProperty(mappedValue, cloneMethod, { get: () => () => this.mapperWithCloneIfNeeded(v2)[0] });
    }
    return [mappedValue, sourceValue];
  }
  valueMapper(v2) {
    const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v2);
    const context = { originalValue: sourceValue, originalContext: v2.context };
    return new Value(mappedValue, context);
  }
  isSafeContext(context) {
    return context != null && typeof context === "object" && "originalValue" in context && "originalContext" in context;
  }
}

class FilterArbitrary extends Arbitrary {
  constructor(arb, refinement) {
    super();
    this.arb = arb;
    this.refinement = refinement;
    this.bindRefinementOnValue = (v2) => this.refinementOnValue(v2);
  }
  generate(mrng, biasFactor) {
    while (true) {
      const g3 = this.arb.generate(mrng, biasFactor);
      if (this.refinementOnValue(g3)) {
        return g3;
      }
    }
  }
  canShrinkWithoutContext(value) {
    return this.arb.canShrinkWithoutContext(value) && this.refinement(value);
  }
  shrink(value, context) {
    return this.arb.shrink(value, context).filter(this.bindRefinementOnValue);
  }
  refinementOnValue(v2) {
    return this.refinement(v2.value);
  }
}

class NoShrinkArbitrary extends Arbitrary {
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, biasFactor) {
    return this.arb.generate(mrng, biasFactor);
  }
  canShrinkWithoutContext(value) {
    return this.arb.canShrinkWithoutContext(value);
  }
  shrink(_value, _context) {
    return Stream.nil();
  }
  noShrink() {
    return this;
  }
}

class NoBiasArbitrary extends Arbitrary {
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, _biasFactor) {
    return this.arb.generate(mrng, undefined);
  }
  canShrinkWithoutContext(value) {
    return this.arb.canShrinkWithoutContext(value);
  }
  shrink(value, context) {
    return this.arb.shrink(value, context);
  }
  noBias() {
    return this;
  }
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/apply.js
var untouchedApply = Function.prototype.apply;
var ApplySymbol = Symbol("apply");
function safeExtractApply(f) {
  try {
    return f.apply;
  } catch (err2) {
    return;
  }
}
function safeApplyHacky(f, instance2, args2) {
  const ff = f;
  ff[ApplySymbol] = untouchedApply;
  const out2 = ff[ApplySymbol](instance2, args2);
  delete ff[ApplySymbol];
  return out2;
}
function safeApply(f, instance2, args2) {
  if (safeExtractApply(f) === untouchedApply) {
    return f.apply(instance2, args2);
  }
  return safeApplyHacky(f, instance2, args2);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/globals.js
var untouchedForEach = Array.prototype.forEach;
var untouchedIndexOf = Array.prototype.indexOf;
var untouchedJoin = Array.prototype.join;
var untouchedMap = Array.prototype.map;
var untouchedFilter = Array.prototype.filter;
var untouchedPush = Array.prototype.push;
var untouchedPop = Array.prototype.pop;
var untouchedSplice = Array.prototype.splice;
var untouchedSlice = Array.prototype.slice;
var untouchedSort = Array.prototype.sort;
var untouchedEvery = Array.prototype.every;
function extractIndexOf(instance2) {
  try {
    return instance2.indexOf;
  } catch (err2) {
    return;
  }
}
function extractMap(instance2) {
  try {
    return instance2.map;
  } catch (err2) {
    return;
  }
}
function extractPush(instance2) {
  try {
    return instance2.push;
  } catch (err2) {
    return;
  }
}
function extractSlice(instance2) {
  try {
    return instance2.slice;
  } catch (err2) {
    return;
  }
}
function safeIndexOf(instance2, ...args2) {
  if (extractIndexOf(instance2) === untouchedIndexOf) {
    return instance2.indexOf(...args2);
  }
  return safeApply(untouchedIndexOf, instance2, args2);
}
function safeMap(instance2, fn2) {
  if (extractMap(instance2) === untouchedMap) {
    return instance2.map(fn2);
  }
  return safeApply(untouchedMap, instance2, [fn2]);
}
function safePush(instance2, ...args2) {
  if (extractPush(instance2) === untouchedPush) {
    return instance2.push(...args2);
  }
  return safeApply(untouchedPush, instance2, args2);
}
function safeSlice(instance2, ...args2) {
  if (extractSlice(instance2) === untouchedSlice) {
    return instance2.slice(...args2);
  }
  return safeApply(untouchedSlice, instance2, args2);
}
var untouchedGetTime = Date.prototype.getTime;
var untouchedToISOString = Date.prototype.toISOString;
var untouchedAdd = Set.prototype.add;
var untouchedHas = Set.prototype.has;
var untouchedSet = WeakMap.prototype.set;
var untouchedGet = WeakMap.prototype.get;
var untouchedMapSet = Map.prototype.set;
var untouchedMapGet = Map.prototype.get;
function extractMapSet(instance2) {
  try {
    return instance2.set;
  } catch (err2) {
    return;
  }
}
function extractMapGet(instance2) {
  try {
    return instance2.get;
  } catch (err2) {
    return;
  }
}
function safeMapSet(instance2, key, value) {
  if (extractMapSet(instance2) === untouchedMapSet) {
    return instance2.set(key, value);
  }
  return safeApply(untouchedMapSet, instance2, [key, value]);
}
function safeMapGet(instance2, key) {
  if (extractMapGet(instance2) === untouchedMapGet) {
    return instance2.get(key);
  }
  return safeApply(untouchedMapGet, instance2, [key]);
}
var untouchedSplit = String.prototype.split;
var untouchedStartsWith = String.prototype.startsWith;
var untouchedEndsWith = String.prototype.endsWith;
var untouchedSubstring = String.prototype.substring;
var untouchedToLowerCase = String.prototype.toLowerCase;
var untouchedToUpperCase = String.prototype.toUpperCase;
var untouchedPadStart = String.prototype.padStart;
var untouchedCharCodeAt = String.prototype.charCodeAt;
var untouchedNormalize = String.prototype.normalize;
var untouchedReplace = String.prototype.replace;
var untouchedNumberToString = Number.prototype.toString;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/LazyIterableIterator.js
class LazyIterableIterator {
  constructor(producer) {
    this.producer = producer;
  }
  [Symbol.iterator]() {
    if (this.it === undefined) {
      this.it = this.producer();
    }
    return this.it;
  }
  next() {
    if (this.it === undefined) {
      this.it = this.producer();
    }
    return this.it.next();
  }
}
function makeLazy(producer) {
  return new LazyIterableIterator(producer);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/configuration/GlobalParameters.js
var globalParameters = {};
function readConfigureGlobal() {
  return globalParameters;
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BiasNumericRange.js
var safeMathFloor = Math.floor;
var safeMathLog = Math.log;
function integerLogLike(v2) {
  return safeMathFloor(safeMathLog(v2) / safeMathLog(2));
}
function biasNumericRange(min2, max2, logLike) {
  if (min2 === max2) {
    return [{ min: min2, max: max2 }];
  }
  if (min2 < 0 && max2 > 0) {
    const logMin = logLike(-min2);
    const logMax = logLike(max2);
    return [
      { min: -logMin, max: logMax },
      { min: max2 - logMax, max: max2 },
      { min: min2, max: min2 + logMin }
    ];
  }
  const logGap = logLike(max2 - min2);
  const arbCloseToMin = { min: min2, max: min2 + logGap };
  const arbCloseToMax = { min: max2 - logGap, max: max2 };
  return min2 < 0 ? [arbCloseToMax, arbCloseToMin] : [arbCloseToMin, arbCloseToMax];
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkInteger.js
var safeMathCeil = Math.ceil;
var safeMathFloor2 = Math.floor;
function halvePosInteger(n) {
  return safeMathFloor2(n / 2);
}
function halveNegInteger(n) {
  return safeMathCeil(n / 2);
}
function shrinkInteger(current, target, tryTargetAsap) {
  const realGap = current - target;
  function* shrinkDecr() {
    let previous = tryTargetAsap ? undefined : target;
    const gap = tryTargetAsap ? realGap : halvePosInteger(realGap);
    for (let toremove = gap;toremove > 0; toremove = halvePosInteger(toremove)) {
      const next = toremove === realGap ? target : current - toremove;
      yield new Value(next, previous);
      previous = next;
    }
  }
  function* shrinkIncr() {
    let previous = tryTargetAsap ? undefined : target;
    const gap = tryTargetAsap ? realGap : halveNegInteger(realGap);
    for (let toremove = gap;toremove < 0; toremove = halveNegInteger(toremove)) {
      const next = toremove === realGap ? target : current - toremove;
      yield new Value(next, previous);
      previous = next;
    }
  }
  return realGap > 0 ? stream(shrinkDecr()) : stream(shrinkIncr());
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/IntegerArbitrary.js
var safeMathSign = Math.sign;
var safeNumberIsInteger = Number.isInteger;
var safeObjectIs = Object.is;

class IntegerArbitrary extends Arbitrary {
  constructor(min2, max2) {
    super();
    this.min = min2;
    this.max = max2;
  }
  generate(mrng, biasFactor) {
    const range = this.computeGenerateRange(mrng, biasFactor);
    return new Value(mrng.nextInt(range.min, range.max), undefined);
  }
  canShrinkWithoutContext(value) {
    return typeof value === "number" && safeNumberIsInteger(value) && !safeObjectIs(value, -0) && this.min <= value && value <= this.max;
  }
  shrink(current, context) {
    if (!IntegerArbitrary.isValidContext(current, context)) {
      const target = this.defaultTarget();
      return shrinkInteger(current, target, true);
    }
    if (this.isLastChanceTry(current, context)) {
      return Stream.of(new Value(context, undefined));
    }
    return shrinkInteger(current, context, false);
  }
  defaultTarget() {
    if (this.min <= 0 && this.max >= 0) {
      return 0;
    }
    return this.min < 0 ? this.max : this.min;
  }
  computeGenerateRange(mrng, biasFactor) {
    if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {
      return { min: this.min, max: this.max };
    }
    const ranges = biasNumericRange(this.min, this.max, integerLogLike);
    if (ranges.length === 1) {
      return ranges[0];
    }
    const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
    return id < 0 ? ranges[0] : ranges[id + 1];
  }
  isLastChanceTry(current, context) {
    if (current > 0)
      return current === context + 1 && current > this.min;
    if (current < 0)
      return current === context - 1 && current < this.max;
    return false;
  }
  static isValidContext(current, context) {
    if (context === undefined) {
      return false;
    }
    if (typeof context !== "number") {
      throw new Error(`Invalid context type passed to IntegerArbitrary (#1)`);
    }
    if (context !== 0 && safeMathSign(current) !== safeMathSign(context)) {
      throw new Error(`Invalid context value passed to IntegerArbitrary (#2)`);
    }
    return true;
  }
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/integer.js
var safeNumberIsInteger2 = Number.isInteger;
function buildCompleteIntegerConstraints(constraints) {
  const min2 = constraints.min !== undefined ? constraints.min : -2147483648;
  const max2 = constraints.max !== undefined ? constraints.max : 2147483647;
  return { min: min2, max: max2 };
}
function integer2(constraints = {}) {
  const fullConstraints = buildCompleteIntegerConstraints(constraints);
  if (fullConstraints.min > fullConstraints.max) {
    throw new Error("fc.integer maximum value should be equal or greater than the minimum one");
  }
  if (!safeNumberIsInteger2(fullConstraints.min)) {
    throw new Error("fc.integer minimum value should be an integer");
  }
  if (!safeNumberIsInteger2(fullConstraints.max)) {
    throw new Error("fc.integer maximum value should be an integer");
  }
  return new IntegerArbitrary(fullConstraints.min, fullConstraints.max);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DepthContext.js
var depthContextCache = new Map;
function getDepthContextFor(contextMeta) {
  if (contextMeta === undefined) {
    return { depth: 0 };
  }
  if (typeof contextMeta !== "string") {
    return contextMeta;
  }
  const cachedContext = safeMapGet(depthContextCache, contextMeta);
  if (cachedContext !== undefined) {
    return cachedContext;
  }
  const context = { depth: 0 };
  safeMapSet(depthContextCache, contextMeta, context);
  return context;
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/NoopSlicedGenerator.js
class NoopSlicedGenerator {
  constructor(arb, mrng, biasFactor) {
    this.arb = arb;
    this.mrng = mrng;
    this.biasFactor = biasFactor;
  }
  attemptExact() {
    return;
  }
  next() {
    return this.arb.generate(this.mrng, this.biasFactor);
  }
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SlicedBasedGenerator.js
var safeMathMin = Math.min;
var safeMathMax = Math.max;

class SlicedBasedGenerator {
  constructor(arb, mrng, slices, biasFactor) {
    this.arb = arb;
    this.mrng = mrng;
    this.slices = slices;
    this.biasFactor = biasFactor;
    this.activeSliceIndex = 0;
    this.nextIndexInSlice = 0;
    this.lastIndexInSlice = -1;
  }
  attemptExact(targetLength) {
    if (targetLength !== 0 && this.mrng.nextInt(1, this.biasFactor) === 1) {
      const eligibleIndices = [];
      for (let index2 = 0;index2 !== this.slices.length; ++index2) {
        const slice = this.slices[index2];
        if (slice.length === targetLength) {
          safePush(eligibleIndices, index2);
        }
      }
      if (eligibleIndices.length === 0) {
        return;
      }
      this.activeSliceIndex = eligibleIndices[this.mrng.nextInt(0, eligibleIndices.length - 1)];
      this.nextIndexInSlice = 0;
      this.lastIndexInSlice = targetLength - 1;
    }
  }
  next() {
    if (this.nextIndexInSlice <= this.lastIndexInSlice) {
      return new Value(this.slices[this.activeSliceIndex][this.nextIndexInSlice++], undefined);
    }
    if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
      return this.arb.generate(this.mrng, this.biasFactor);
    }
    this.activeSliceIndex = this.mrng.nextInt(0, this.slices.length - 1);
    const slice = this.slices[this.activeSliceIndex];
    if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
      this.nextIndexInSlice = 1;
      this.lastIndexInSlice = slice.length - 1;
      return new Value(slice[0], undefined);
    }
    const rangeBoundaryA = this.mrng.nextInt(0, slice.length - 1);
    const rangeBoundaryB = this.mrng.nextInt(0, slice.length - 1);
    this.nextIndexInSlice = safeMathMin(rangeBoundaryA, rangeBoundaryB);
    this.lastIndexInSlice = safeMathMax(rangeBoundaryA, rangeBoundaryB);
    return new Value(slice[this.nextIndexInSlice++], undefined);
  }
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSlicedGenerator.js
function buildSlicedGenerator(arb, mrng, slices, biasFactor) {
  if (biasFactor === undefined || slices.length === 0 || mrng.nextInt(1, biasFactor) !== 1) {
    return new NoopSlicedGenerator(arb, mrng, biasFactor);
  }
  return new SlicedBasedGenerator(arb, mrng, slices, biasFactor);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayArbitrary.js
var safeMathFloor3 = Math.floor;
var safeMathLog2 = Math.log;
var safeMathMax2 = Math.max;
var safeArrayIsArray = Array.isArray;
function biasedMaxLength(minLength, maxLength) {
  if (minLength === maxLength) {
    return minLength;
  }
  return minLength + safeMathFloor3(safeMathLog2(maxLength - minLength) / safeMathLog2(2));
}

class ArrayArbitrary extends Arbitrary {
  constructor(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, setBuilder, customSlices) {
    super();
    this.arb = arb;
    this.minLength = minLength;
    this.maxGeneratedLength = maxGeneratedLength;
    this.maxLength = maxLength;
    this.setBuilder = setBuilder;
    this.customSlices = customSlices;
    this.lengthArb = integer2({ min: minLength, max: maxGeneratedLength });
    this.depthContext = getDepthContextFor(depthIdentifier);
  }
  preFilter(tab) {
    if (this.setBuilder === undefined) {
      return tab;
    }
    const s2 = this.setBuilder();
    for (let index2 = 0;index2 !== tab.length; ++index2) {
      s2.tryAdd(tab[index2]);
    }
    return s2.getData();
  }
  static makeItCloneable(vs, shrinkables) {
    vs[cloneMethod] = () => {
      const cloned = [];
      for (let idx = 0;idx !== shrinkables.length; ++idx) {
        safePush(cloned, shrinkables[idx].value);
      }
      this.makeItCloneable(cloned, shrinkables);
      return cloned;
    };
    return vs;
  }
  generateNItemsNoDuplicates(setBuilder, N2, mrng, biasFactorItems) {
    let numSkippedInRow = 0;
    const s2 = setBuilder();
    const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
    while (s2.size() < N2 && numSkippedInRow < this.maxGeneratedLength) {
      const current = slicedGenerator.next();
      if (s2.tryAdd(current)) {
        numSkippedInRow = 0;
      } else {
        numSkippedInRow += 1;
      }
    }
    return s2.getData();
  }
  safeGenerateNItemsNoDuplicates(setBuilder, N2, mrng, biasFactorItems) {
    const depthImpact = safeMathMax2(0, N2 - biasedMaxLength(this.minLength, this.maxGeneratedLength));
    this.depthContext.depth += depthImpact;
    try {
      return this.generateNItemsNoDuplicates(setBuilder, N2, mrng, biasFactorItems);
    } finally {
      this.depthContext.depth -= depthImpact;
    }
  }
  generateNItems(N2, mrng, biasFactorItems) {
    const items = [];
    const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
    slicedGenerator.attemptExact(N2);
    for (let index2 = 0;index2 !== N2; ++index2) {
      const current = slicedGenerator.next();
      safePush(items, current);
    }
    return items;
  }
  safeGenerateNItems(N2, mrng, biasFactorItems) {
    const depthImpact = safeMathMax2(0, N2 - biasedMaxLength(this.minLength, this.maxGeneratedLength));
    this.depthContext.depth += depthImpact;
    try {
      return this.generateNItems(N2, mrng, biasFactorItems);
    } finally {
      this.depthContext.depth -= depthImpact;
    }
  }
  wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext, startIndex) {
    const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;
    let cloneable = false;
    const vs = [];
    const itemsContexts = [];
    for (let idx = 0;idx !== items.length; ++idx) {
      const s2 = items[idx];
      cloneable = cloneable || s2.hasToBeCloned;
      safePush(vs, s2.value);
      safePush(itemsContexts, s2.context);
    }
    if (cloneable) {
      ArrayArbitrary.makeItCloneable(vs, items);
    }
    const context = {
      shrunkOnce,
      lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== undefined ? itemsRawLengthContext : undefined,
      itemsContexts,
      startIndex
    };
    return new Value(vs, context);
  }
  generate(mrng, biasFactor) {
    const biasMeta = this.applyBias(mrng, biasFactor);
    const targetSize = biasMeta.size;
    const items = this.setBuilder !== undefined ? this.safeGenerateNItemsNoDuplicates(this.setBuilder, targetSize, mrng, biasMeta.biasFactorItems) : this.safeGenerateNItems(targetSize, mrng, biasMeta.biasFactorItems);
    return this.wrapper(items, false, undefined, 0);
  }
  applyBias(mrng, biasFactor) {
    if (biasFactor === undefined) {
      return { size: this.lengthArb.generate(mrng, undefined).value };
    }
    if (this.minLength === this.maxGeneratedLength) {
      return { size: this.lengthArb.generate(mrng, undefined).value, biasFactorItems: biasFactor };
    }
    if (mrng.nextInt(1, biasFactor) !== 1) {
      return { size: this.lengthArb.generate(mrng, undefined).value };
    }
    if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxGeneratedLength) {
      return { size: this.lengthArb.generate(mrng, undefined).value, biasFactorItems: biasFactor };
    }
    const maxBiasedLength = biasedMaxLength(this.minLength, this.maxGeneratedLength);
    const targetSizeValue = integer2({ min: this.minLength, max: maxBiasedLength }).generate(mrng, undefined);
    return { size: targetSizeValue.value, biasFactorItems: biasFactor };
  }
  canShrinkWithoutContext(value) {
    if (!safeArrayIsArray(value) || this.minLength > value.length || value.length > this.maxLength) {
      return false;
    }
    for (let index2 = 0;index2 !== value.length; ++index2) {
      if (!(index2 in value)) {
        return false;
      }
      if (!this.arb.canShrinkWithoutContext(value[index2])) {
        return false;
      }
    }
    const filtered = this.preFilter(safeMap(value, (item) => new Value(item, undefined)));
    return filtered.length === value.length;
  }
  shrinkItemByItem(value, safeContext, endIndex) {
    const shrinks = [];
    for (let index2 = safeContext.startIndex;index2 < endIndex; ++index2) {
      safePush(shrinks, makeLazy(() => this.arb.shrink(value[index2], safeContext.itemsContexts[index2]).map((v2) => {
        const beforeCurrent = safeMap(safeSlice(value, 0, index2), (v3, i2) => new Value(cloneIfNeeded(v3), safeContext.itemsContexts[i2]));
        const afterCurrent = safeMap(safeSlice(value, index2 + 1), (v3, i2) => new Value(cloneIfNeeded(v3), safeContext.itemsContexts[i2 + index2 + 1]));
        return [
          [...beforeCurrent, v2, ...afterCurrent],
          undefined,
          index2
        ];
      })));
    }
    return Stream.nil().join(...shrinks);
  }
  shrinkImpl(value, context) {
    if (value.length === 0) {
      return Stream.nil();
    }
    const safeContext = context !== undefined ? context : { shrunkOnce: false, lengthContext: undefined, itemsContexts: [], startIndex: 0 };
    return this.lengthArb.shrink(value.length, safeContext.lengthContext).drop(safeContext.shrunkOnce && safeContext.lengthContext === undefined && value.length > this.minLength + 1 ? 1 : 0).map((lengthValue) => {
      const sliceStart = value.length - lengthValue.value;
      return [
        safeMap(safeSlice(value, sliceStart), (v2, index2) => new Value(cloneIfNeeded(v2), safeContext.itemsContexts[index2 + sliceStart])),
        lengthValue.context,
        0
      ];
    }).join(makeLazy(() => value.length > this.minLength ? this.shrinkItemByItem(value, safeContext, 1) : this.shrinkItemByItem(value, safeContext, value.length))).join(value.length > this.minLength ? makeLazy(() => {
      const subContext = {
        shrunkOnce: false,
        lengthContext: undefined,
        itemsContexts: safeSlice(safeContext.itemsContexts, 1),
        startIndex: 0
      };
      return this.shrinkImpl(safeSlice(value, 1), subContext).filter((v2) => this.minLength <= v2[0].length + 1).map((v2) => {
        return [[new Value(cloneIfNeeded(value[0]), safeContext.itemsContexts[0]), ...v2[0]], undefined, 0];
      });
    }) : Stream.nil());
  }
  shrink(value, context) {
    return this.shrinkImpl(value, context).map((contextualValue) => this.wrapper(contextualValue[0], true, contextualValue[1], contextualValue[2]));
  }
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/MaxLengthFromMinLength.js
var safeMathFloor4 = Math.floor;
var safeMathMin2 = Math.min;
var MaxLengthUpperBound = 2147483647;
var orderedSize = ["xsmall", "small", "medium", "large", "xlarge"];
var orderedRelativeSize = ["-4", "-3", "-2", "-1", "=", "+1", "+2", "+3", "+4"];
var DefaultSize = "small";
function maxLengthFromMinLength(minLength, size) {
  switch (size) {
    case "xsmall":
      return safeMathFloor4(1.1 * minLength) + 1;
    case "small":
      return 2 * minLength + 10;
    case "medium":
      return 11 * minLength + 100;
    case "large":
      return 101 * minLength + 1000;
    case "xlarge":
      return 1001 * minLength + 1e4;
    default:
      throw new Error(`Unable to compute lengths based on received size: ${size}`);
  }
}
function relativeSizeToSize(size, defaultSize) {
  const sizeInRelative = safeIndexOf(orderedRelativeSize, size);
  if (sizeInRelative === -1) {
    return size;
  }
  const defaultSizeInSize = safeIndexOf(orderedSize, defaultSize);
  if (defaultSizeInSize === -1) {
    throw new Error(`Unable to offset size based on the unknown defaulted one: ${defaultSize}`);
  }
  const resultingSizeInSize = defaultSizeInSize + sizeInRelative - 4;
  return resultingSizeInSize < 0 ? orderedSize[0] : resultingSizeInSize >= orderedSize.length ? orderedSize[orderedSize.length - 1] : orderedSize[resultingSizeInSize];
}
function maxGeneratedLengthFromSizeForArbitrary(size, minLength, maxLength, specifiedMaxLength) {
  const { baseSize: defaultSize = DefaultSize, defaultSizeToMaxWhenMaxSpecified } = readConfigureGlobal() || {};
  const definedSize = size !== undefined ? size : specifiedMaxLength && defaultSizeToMaxWhenMaxSpecified ? "max" : defaultSize;
  if (definedSize === "max") {
    return maxLength;
  }
  const finalSize = relativeSizeToSize(definedSize, defaultSize);
  return safeMathMin2(maxLengthFromMinLength(minLength, finalSize), maxLength);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/array.js
function array4(arb, constraints = {}) {
  const size = constraints.size;
  const minLength = constraints.minLength || 0;
  const maxLengthOrUnset = constraints.maxLength;
  const depthIdentifier = constraints.depthIdentifier;
  const maxLength = maxLengthOrUnset !== undefined ? maxLengthOrUnset : MaxLengthUpperBound;
  const specifiedMaxLength = maxLengthOrUnset !== undefined;
  const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size, minLength, maxLength, specifiedMaxLength);
  const customSlices = constraints.experimentalCustomSlices || [];
  return new ArrayArbitrary(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, undefined, customSlices);
}
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/schema/util.js
var getKeysForIndexSignature = (input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature(input, parameter.from);
  }
};
var ownKeys = (o3) => Object.keys(o3).concat(Object.getOwnPropertySymbols(o3));
var memoizeThunk = (f) => {
  let done = false;
  let a;
  return () => {
    if (done) {
      return a;
    }
    a = f();
    done = true;
    return a;
  };
};
var formatDate = (date2) => {
  try {
    return date2.toISOString();
  } catch {
    return String(date2);
  }
};
var formatUnknown = (u3, checkCircular = true) => {
  if (Array.isArray(u3)) {
    return `[${u3.map((i2) => formatUnknown(i2, checkCircular)).join(",")}]`;
  }
  if (isDate(u3)) {
    return formatDate(u3);
  }
  if (hasProperty(u3, "toString") && isFunction2(u3["toString"]) && u3["toString"] !== Object.prototype.toString) {
    return u3["toString"]();
  }
  if (isString(u3)) {
    return JSON.stringify(u3);
  }
  if (isNumber(u3) || u3 == null || isBoolean(u3) || isSymbol(u3)) {
    return String(u3);
  }
  if (isBigInt(u3)) {
    return String(u3) + "n";
  }
  if (isIterable(u3)) {
    return `${u3.constructor.name}(${formatUnknown(Array.from(u3), checkCircular)})`;
  }
  try {
    if (checkCircular) {
      JSON.stringify(u3);
    }
    const pojo = `{${ownKeys(u3).map((k2) => `${isString(k2) ? JSON.stringify(k2) : String(k2)}:${formatUnknown(u3[k2], false)}`).join(",")}}`;
    const name2 = u3.constructor.name;
    return u3.constructor !== Object.prototype.constructor ? `${name2}(${pojo})` : pojo;
  } catch {
    return "<circular structure>";
  }
};
var formatPropertyKey = (name2) => typeof name2 === "string" ? JSON.stringify(name2) : String(name2);
var isNonEmpty = (x3) => Array.isArray(x3);
var isSingle = (x3) => !Array.isArray(x3);
var formatPathKey = (key) => `[${formatPropertyKey(key)}]`;
var formatPath = (path) => isNonEmpty(path) ? path.map(formatPathKey).join("") : formatPathKey(path);

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/schema/errors.js
var getErrorMessage = (reason, details, path, ast) => {
  let out2 = reason;
  if (path && isNonEmptyReadonlyArray(path)) {
    out2 += `
at path: ${formatPath(path)}`;
  }
  if (details !== undefined) {
    out2 += `
details: ${details}`;
  }
  if (ast) {
    out2 += `
schema (${ast._tag}): ${ast}`;
  }
  return out2;
};
var getInvalidArgumentErrorMessage = (details) => getErrorMessage("Invalid Argument", details);
var getUnsupportedSchemaErrorMessage = (details, path, ast) => getErrorMessage("Unsupported schema", details, path, ast);
var getEquivalenceUnsupportedErrorMessage = (ast, path) => getUnsupportedSchemaErrorMessage("Cannot build an Equivalence", path, ast);
var getSchemaExtendErrorMessage = (x3, y2, path) => getErrorMessage("Unsupported schema or overlapping types", `cannot extend ${x3} with ${y2}`, path);
var getSchemaUnsupportedLiteralSpanErrorMessage = (ast) => getErrorMessage("Unsupported template literal span", undefined, undefined, ast);
var getASTUnsupportedSchemaErrorMessage = (ast) => getUnsupportedSchemaErrorMessage(undefined, undefined, ast);
var getASTUnsupportedKeySchemaErrorMessage = (ast) => getErrorMessage("Unsupported key schema", undefined, undefined, ast);
var getASTUnsupportedLiteralErrorMessage = (literal) => getErrorMessage("Unsupported literal", `literal value: ${formatUnknown(literal)}`);
var getASTDuplicateIndexSignatureErrorMessage = (type) => getErrorMessage("Duplicate index signature", `${type} index signature`);
var getASTIndexSignatureParameterErrorMessage = /* @__PURE__ */ getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
var getASTRequiredElementFollowinAnOptionalElementErrorMessage = /* @__PURE__ */ getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
var getASTDuplicatePropertySignatureTransformationErrorMessage = (key) => getErrorMessage("Duplicate property signature transformation", `Duplicate key ${formatUnknown(key)}`);
var getASTUnsupportedRenameSchemaErrorMessage = (ast) => getUnsupportedSchemaErrorMessage(undefined, undefined, ast);
var getASTDuplicatePropertySignatureErrorMessage = (key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`);

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/schema/schemaId.js
var DateFromSelfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/DateFromSelf");
var GreaterThanSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThan");
var GreaterThanOrEqualToSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanOrEqualTo");
var LessThanSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThan");
var LessThanOrEqualToSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanOrEqualTo");
var IntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Int");
var NonNaNSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/NonNaN");
var FiniteSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Finite");
var JsonNumberSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/JsonNumber");
var BetweenSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Between");
var GreaterThanBigintSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanBigint");
var GreaterThanOrEqualToBigIntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanOrEqualToBigint");
var LessThanBigIntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanBigint");
var LessThanOrEqualToBigIntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanOrEqualToBigint");
var BetweenBigintSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenBigint");
var MinLengthSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MinLength");
var MaxLengthSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MaxLength");
var LengthSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Length");
var MinItemsSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MinItems");
var MaxItemsSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MaxItems");
var ItemsCountSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ItemsCount");

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Number.js
var Order = number3;
var clamp3 = /* @__PURE__ */ clamp(Order);
var remainder = /* @__PURE__ */ dual(2, (dividend, divisor) => {
  const selfDecCount = (dividend.toString().split(".")[1] || "").length;
  const divisorDecCount = (divisor.toString().split(".")[1] || "").length;
  const decCount = selfDecCount > divisorDecCount ? selfDecCount : divisorDecCount;
  const selfInt = parseInt(dividend.toFixed(decCount).replace(".", ""));
  const divisorInt = parseInt(divisor.toFixed(decCount).replace(".", ""));
  return selfInt % divisorInt / Math.pow(10, decCount);
});
var parse = (s2) => {
  if (s2 === "NaN") {
    return some(NaN);
  }
  if (s2 === "Infinity") {
    return some(Infinity);
  }
  if (s2 === "-Infinity") {
    return some(-Infinity);
  }
  if (s2.trim() === "") {
    return none;
  }
  const n = Number(s2);
  return Number.isNaN(n) ? none : some(n);
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/RegExp.js
var escape = (string2) => string2.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/SchemaAST.js
var BrandAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Brand");
var SchemaIdAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/SchemaId");
var MessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Message");
var MissingMessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/MissingMessage");
var IdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Identifier");
var TitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Title");
var AutoTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/AutoTitle");
var DescriptionAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Description");
var ExamplesAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Examples");
var DefaultAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Default");
var JSONSchemaAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONSchema");
var ArbitraryAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Arbitrary");
var PrettyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Pretty");
var EquivalenceAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Equivalence");
var DocumentationAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Documentation");
var ConcurrencyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Concurrency");
var BatchingAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Batching");
var ParseIssueTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseIssueTitle");
var ParseOptionsAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseOptions");
var DecodingFallbackAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/DecodingFallback");
var SurrogateAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Surrogate");
var StableFilterAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/StableFilter");
var getAnnotation = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some2(annotated.annotations[key]) : none2());
var getBrandAnnotation = /* @__PURE__ */ getAnnotation(BrandAnnotationId);
var getMessageAnnotation = /* @__PURE__ */ getAnnotation(MessageAnnotationId);
var getMissingMessageAnnotation = /* @__PURE__ */ getAnnotation(MissingMessageAnnotationId);
var getTitleAnnotation = /* @__PURE__ */ getAnnotation(TitleAnnotationId);
var getAutoTitleAnnotation = /* @__PURE__ */ getAnnotation(AutoTitleAnnotationId);
var getIdentifierAnnotation = /* @__PURE__ */ getAnnotation(IdentifierAnnotationId);
var getDescriptionAnnotation = /* @__PURE__ */ getAnnotation(DescriptionAnnotationId);
var getConcurrencyAnnotation = /* @__PURE__ */ getAnnotation(ConcurrencyAnnotationId);
var getBatchingAnnotation = /* @__PURE__ */ getAnnotation(BatchingAnnotationId);
var getParseIssueTitleAnnotation = /* @__PURE__ */ getAnnotation(ParseIssueTitleAnnotationId);
var getParseOptionsAnnotation = /* @__PURE__ */ getAnnotation(ParseOptionsAnnotationId);
var getDecodingFallbackAnnotation = /* @__PURE__ */ getAnnotation(DecodingFallbackAnnotationId);
var getSurrogateAnnotation = /* @__PURE__ */ getAnnotation(SurrogateAnnotationId);
var getStableFilterAnnotation = /* @__PURE__ */ getAnnotation(StableFilterAnnotationId);
var hasStableFilter = (annotated) => exists2(getStableFilterAnnotation(annotated), (b3) => b3 === true);
var JSONIdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONIdentifier");
var getJSONIdentifierAnnotation = /* @__PURE__ */ getAnnotation(JSONIdentifierAnnotationId);
var getJSONIdentifier = (annotated) => orElse(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
var ParseJsonSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/ParseJson");

class Declaration {
  typeParameters;
  decodeUnknown;
  encodeUnknown;
  annotations;
  _tag = "Declaration";
  constructor(typeParameters, decodeUnknown, encodeUnknown, annotations = {}) {
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown;
    this.encodeUnknown = encodeUnknown;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => "<declaration schema>");
  }
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var createASTGuard = (tag) => (ast) => ast._tag === tag;
class Literal {
  literal;
  annotations;
  _tag = "Literal";
  constructor(literal, annotations = {}) {
    this.literal = literal;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatUnknown(this.literal));
  }
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isLiteral = /* @__PURE__ */ createASTGuard("Literal");
var $null = /* @__PURE__ */ new Literal(null);
class UniqueSymbol {
  symbol;
  annotations;
  _tag = "UniqueSymbol";
  constructor(symbol3, annotations = {}) {
    this.symbol = symbol3;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatUnknown(this.symbol));
  }
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isUniqueSymbol = /* @__PURE__ */ createASTGuard("UniqueSymbol");

class UndefinedKeyword {
  annotations;
  _tag = "UndefinedKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var undefinedKeyword = /* @__PURE__ */ new UndefinedKeyword({
  [TitleAnnotationId]: "undefined"
});
class VoidKeyword {
  annotations;
  _tag = "VoidKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var voidKeyword = /* @__PURE__ */ new VoidKeyword({
  [TitleAnnotationId]: "void"
});
class NeverKeyword {
  annotations;
  _tag = "NeverKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var neverKeyword = /* @__PURE__ */ new NeverKeyword({
  [TitleAnnotationId]: "never"
});
var isNeverKeyword = /* @__PURE__ */ createASTGuard("NeverKeyword");

class UnknownKeyword {
  annotations;
  _tag = "UnknownKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var unknownKeyword = /* @__PURE__ */ new UnknownKeyword({
  [TitleAnnotationId]: "unknown"
});
class AnyKeyword {
  annotations;
  _tag = "AnyKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var anyKeyword = /* @__PURE__ */ new AnyKeyword({
  [TitleAnnotationId]: "any"
});
class StringKeyword {
  annotations;
  _tag = "StringKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var stringKeyword = /* @__PURE__ */ new StringKeyword({
  [TitleAnnotationId]: "string",
  [DescriptionAnnotationId]: "a string"
});
var isStringKeyword = /* @__PURE__ */ createASTGuard("StringKeyword");

class NumberKeyword {
  annotations;
  _tag = "NumberKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var numberKeyword = /* @__PURE__ */ new NumberKeyword({
  [TitleAnnotationId]: "number",
  [DescriptionAnnotationId]: "a number"
});
var isNumberKeyword = /* @__PURE__ */ createASTGuard("NumberKeyword");

class BooleanKeyword {
  annotations;
  _tag = "BooleanKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var booleanKeyword = /* @__PURE__ */ new BooleanKeyword({
  [TitleAnnotationId]: "boolean",
  [DescriptionAnnotationId]: "a boolean"
});
var isBooleanKeyword = /* @__PURE__ */ createASTGuard("BooleanKeyword");

class BigIntKeyword {
  annotations;
  _tag = "BigIntKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var bigIntKeyword = /* @__PURE__ */ new BigIntKeyword({
  [TitleAnnotationId]: "bigint",
  [DescriptionAnnotationId]: "a bigint"
});
class SymbolKeyword {
  annotations;
  _tag = "SymbolKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var symbolKeyword = /* @__PURE__ */ new SymbolKeyword({
  [TitleAnnotationId]: "symbol",
  [DescriptionAnnotationId]: "a symbol"
});
var isSymbolKeyword = /* @__PURE__ */ createASTGuard("SymbolKeyword");

class ObjectKeyword {
  annotations;
  _tag = "ObjectKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var objectKeyword = /* @__PURE__ */ new ObjectKeyword({
  [TitleAnnotationId]: "object",
  [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
});
class Enums {
  enums;
  annotations;
  _tag = "Enums";
  constructor(enums, annotations = {}) {
    this.enums = enums;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => `<enum ${this.enums.length} value(s): ${this.enums.map(([_2, value]) => JSON.stringify(value)).join(" | ")}>`);
  }
  toJSON() {
    return {
      _tag: this._tag,
      enums: this.enums,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isEnums = /* @__PURE__ */ createASTGuard("Enums");
var isTemplateLiteralSpanType = (ast) => {
  switch (ast._tag) {
    case "Literal":
    case "NumberKeyword":
    case "StringKeyword":
    case "TemplateLiteral":
      return true;
    case "Union":
      return ast.types.every(isTemplateLiteralSpanType);
  }
  return false;
};
var templateLiteralSpanUnionTypeToString = (type) => {
  switch (type._tag) {
    case "Literal":
      return JSON.stringify(String(type.literal));
    case "StringKeyword":
      return "string";
    case "NumberKeyword":
      return "number";
    case "TemplateLiteral":
      return String(type);
    case "Union":
      return type.types.map(templateLiteralSpanUnionTypeToString).join(" | ");
  }
};
var templateLiteralSpanTypeToString = (type) => {
  switch (type._tag) {
    case "Literal":
      return String(type.literal);
    case "StringKeyword":
      return "${string}";
    case "NumberKeyword":
      return "${number}";
    case "TemplateLiteral":
      return "${" + String(type) + "}";
    case "Union":
      return "${" + type.types.map(templateLiteralSpanUnionTypeToString).join(" | ") + "}";
  }
};

class TemplateLiteralSpan {
  literal;
  type;
  constructor(type, literal) {
    this.literal = literal;
    if (isTemplateLiteralSpanType(type)) {
      this.type = type;
    } else {
      throw new Error(getSchemaUnsupportedLiteralSpanErrorMessage(type));
    }
  }
  toString() {
    return templateLiteralSpanTypeToString(this.type) + this.literal;
  }
  toJSON() {
    return {
      type: this.type.toJSON(),
      literal: this.literal
    };
  }
}

class TemplateLiteral {
  head;
  spans;
  annotations;
  _tag = "TemplateLiteral";
  constructor(head2, spans, annotations = {}) {
    this.head = head2;
    this.spans = spans;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatTemplateLiteral(this));
  }
  toJSON() {
    return {
      _tag: this._tag,
      head: this.head,
      spans: this.spans.map((span2) => span2.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var formatTemplateLiteral = (ast) => "`" + ast.head + ast.spans.map(String).join("") + "`";
var isTemplateLiteral = /* @__PURE__ */ createASTGuard("TemplateLiteral");

class Type {
  type;
  annotations;
  constructor(type, annotations = {}) {
    this.type = type;
    this.annotations = annotations;
  }
  toJSON() {
    return {
      type: this.type.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  toString() {
    return String(this.type);
  }
}

class OptionalType extends Type {
  isOptional;
  constructor(type, isOptional, annotations = {}) {
    super(type, annotations);
    this.isOptional = isOptional;
  }
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
}
var getRestASTs = (rest) => rest.map((annotatedAST) => annotatedAST.type);

class TupleType {
  elements;
  rest;
  isReadonly;
  annotations;
  _tag = "TupleType";
  constructor(elements, rest, isReadonly, annotations = {}) {
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
    }
  }
  toString() {
    return getOrElse(getExpected(this), () => formatTuple(this));
  }
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map((e) => e.toJSON()),
      rest: this.rest.map((ast) => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var formatTuple = (ast) => {
  const formattedElements = ast.elements.map(String).join(", ");
  return matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head2, tail) => {
      const formattedHead = String(head2);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail.length > 0) {
        const formattedTail = tail.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
};
class PropertySignature extends OptionalType {
  name;
  isReadonly;
  constructor(name2, type, isOptional, isReadonly, annotations) {
    super(type, isOptional, annotations);
    this.name = name2;
    this.isReadonly = isReadonly;
  }
  toString() {
    return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
  }
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter(ast.from);
  }
  return false;
};

class IndexSignature {
  type;
  isReadonly;
  parameter;
  constructor(parameter, type, isReadonly) {
    this.type = type;
    this.isReadonly = isReadonly;
    if (isParameter(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(getASTIndexSignatureParameterErrorMessage);
    }
  }
  toString() {
    return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
  }
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
}

class TypeLiteral {
  annotations;
  _tag = "TypeLiteral";
  propertySignatures;
  indexSignatures;
  constructor(propertySignatures, indexSignatures, annotations = {}) {
    this.annotations = annotations;
    const keys = {};
    for (let i2 = 0;i2 < propertySignatures.length; i2++) {
      const name2 = propertySignatures[i2].name;
      if (Object.prototype.hasOwnProperty.call(keys, name2)) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage(name2));
      }
      keys[name2] = null;
    }
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i2 = 0;i2 < indexSignatures.length; i2++) {
      const encodedParameter = getEncodedParameter(indexSignatures[i2].parameter);
      if (isStringKeyword(encodedParameter)) {
        if (parameters.string) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword(encodedParameter)) {
        if (parameters.symbol) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = propertySignatures;
    this.indexSignatures = indexSignatures;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatTypeLiteral(this));
  }
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var formatIndexSignatures = (iss) => iss.map(String).join("; ");
var formatTypeLiteral = (ast) => {
  if (ast.propertySignatures.length > 0) {
    const pss = ast.propertySignatures.map(String).join("; ");
    if (ast.indexSignatures.length > 0) {
      return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return `{ ${pss} }`;
    }
  } else {
    if (ast.indexSignatures.length > 0) {
      return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return "{}";
    }
  }
};
var isTypeLiteral = /* @__PURE__ */ createASTGuard("TypeLiteral");
var sortCandidates = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput2(Order, (ast) => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
var literalMap = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
var flatten2 = (candidates) => flatMap2(candidates, (ast) => isUnion(ast) ? flatten2(ast.types) : [ast]);
var unify = (candidates) => {
  const cs = sortCandidates(candidates);
  const out2 = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword];
      case "UnknownKeyword":
        return [unknownKeyword];
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword": {
        if (!uniques[ast._tag]) {
          uniques[ast._tag] = ast;
          out2.push(ast);
        }
        break;
      }
      case "Literal": {
        const type = typeof ast.literal;
        switch (type) {
          case "string":
          case "number":
          case "bigint":
          case "boolean": {
            const _tag = literalMap[type];
            if (!uniques[_tag] && !literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out2.push(ast);
            }
            break;
          }
          case "object": {
            if (!literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out2.push(ast);
            }
            break;
          }
        }
        break;
      }
      case "UniqueSymbol": {
        if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
          literals.push(ast.symbol);
          out2.push(ast);
        }
        break;
      }
      case "TupleType": {
        if (!uniques["ObjectKeyword"]) {
          out2.push(ast);
        }
        break;
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          if (!uniques["{}"]) {
            uniques["{}"] = ast;
            out2.push(ast);
          }
        } else if (!uniques["ObjectKeyword"]) {
          out2.push(ast);
        }
        break;
      }
      default:
        out2.push(ast);
    }
  }
  return out2;
};

class Union {
  types;
  annotations;
  static make = (types, annotations) => {
    return isMembers(types) ? new Union(types, annotations) : types.length === 1 ? types[0] : neverKeyword;
  };
  static unify = (candidates, annotations) => {
    return Union.make(unify(flatten2(candidates)), annotations);
  };
  _tag = "Union";
  constructor(types, annotations = {}) {
    this.types = types;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => this.types.map(String).join(" | "));
  }
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var mapMembers = (members, f) => members.map(f);
var isMembers = (as) => as.length > 1;
var isUnion = /* @__PURE__ */ createASTGuard("Union");
var toJSONMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => new WeakMap);

class Suspend {
  f;
  annotations;
  _tag = "Suspend";
  constructor(f, annotations = {}) {
    this.f = f;
    this.annotations = annotations;
    this.f = memoizeThunk(f);
  }
  toString() {
    return getExpected(this).pipe(orElse(() => flatMap(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse(() => "<suspended schema>"));
  }
  toJSON() {
    const ast = this.f();
    let out2 = toJSONMemoMap.get(ast);
    if (out2) {
      return out2;
    }
    toJSONMemoMap.set(ast, {
      _tag: this._tag
    });
    out2 = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
    toJSONMemoMap.set(ast, out2);
    return out2;
  }
}
class Refinement {
  from;
  filter;
  annotations;
  _tag = "Refinement";
  constructor(from, filter2, annotations = {}) {
    this.from = from;
    this.filter = filter2;
    this.annotations = annotations;
  }
  toString() {
    return getIdentifierAnnotation(this).pipe(getOrElse(() => match2(getOrElseExpected(this), {
      onNone: () => `{ ${this.from} | filter }`,
      onSome: (expected) => isRefinement(this.from) ? String(this.from) + " & " + expected : expected
    })));
  }
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isRefinement = /* @__PURE__ */ createASTGuard("Refinement");
var defaultParseOption = {};

class Transformation {
  from;
  to;
  transformation;
  annotations;
  _tag = "Transformation";
  constructor(from, to, transformation, annotations = {}) {
    this.from = from;
    this.to = to;
    this.transformation = transformation;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
  }
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isTransformation = /* @__PURE__ */ createASTGuard("Transformation");

class FinalTransformation {
  decode;
  encode;
  _tag = "FinalTransformation";
  constructor(decode, encode) {
    this.decode = decode;
    this.encode = encode;
  }
}
var createTransformationGuard = (tag) => (ast) => ast._tag === tag;
class ComposeTransformation {
  _tag = "ComposeTransformation";
}
var composeTransformation = /* @__PURE__ */ new ComposeTransformation;
class PropertySignatureTransformation {
  from;
  to;
  decode;
  encode;
  constructor(from, to, decode, encode) {
    this.from = from;
    this.to = to;
    this.decode = decode;
    this.encode = encode;
  }
}
var isRenamingPropertySignatureTransformation = (t) => t.decode === identity && t.encode === identity;

class TypeLiteralTransformation {
  propertySignatureTransformations;
  _tag = "TypeLiteralTransformation";
  constructor(propertySignatureTransformations) {
    this.propertySignatureTransformations = propertySignatureTransformations;
    const fromKeys = {};
    const toKeys = {};
    for (const pst of propertySignatureTransformations) {
      const from = pst.from;
      if (fromKeys[from]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(from));
      }
      fromKeys[from] = true;
      const to = pst.to;
      if (toKeys[to]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(to));
      }
      toKeys[to] = true;
    }
  }
}
var isTypeLiteralTransformation = /* @__PURE__ */ createTransformationGuard("TypeLiteralTransformation");
var annotations = (ast, overrides) => {
  const d2 = Object.getOwnPropertyDescriptors(ast);
  const value = {
    ...ast.annotations,
    ...overrides
  };
  const surrogate = getSurrogateAnnotation(ast);
  if (isSome2(surrogate)) {
    value[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
  }
  d2.annotations.value = value;
  return Object.create(Object.getPrototypeOf(ast), d2);
};
var keyof = (ast) => Union.unify(_keyof(ast));
var STRING_KEYWORD_PATTERN = "[\\s\\S]*";
var NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
var getTemplateLiteralSpanTypePattern = (type, capture) => {
  switch (type._tag) {
    case "Literal":
      return escape(String(type.literal));
    case "StringKeyword":
      return STRING_KEYWORD_PATTERN;
    case "NumberKeyword":
      return NUMBER_KEYWORD_PATTERN;
    case "TemplateLiteral":
      return getTemplateLiteralPattern(type, capture, false);
    case "Union":
      return type.types.map((type2) => getTemplateLiteralSpanTypePattern(type2, capture)).join("|");
  }
};
var handleTemplateLiteralSpanTypeParens = (type, s2, capture, top) => {
  if (isUnion(type)) {
    if (capture && !top) {
      return `(?:${s2})`;
    }
  } else if (!capture || !top) {
    return s2;
  }
  return `(${s2})`;
};
var getTemplateLiteralPattern = (ast, capture, top) => {
  let pattern = ``;
  if (ast.head !== "") {
    const head2 = escape(ast.head);
    pattern += capture && top ? `(${head2})` : head2;
  }
  for (const span2 of ast.spans) {
    const spanPattern = getTemplateLiteralSpanTypePattern(span2.type, capture);
    pattern += handleTemplateLiteralSpanTypeParens(span2.type, spanPattern, capture, top);
    if (span2.literal !== "") {
      const literal = escape(span2.literal);
      pattern += capture && top ? `(${literal})` : literal;
    }
  }
  return pattern;
};
var getTemplateLiteralRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`);
var getTemplateLiteralCapturingRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast, true, true)}$`);
var getIndexSignatures = (ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getIndexSignatures(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.indexSignatures.slice();
    case "Suspend":
      return getIndexSignatures(ast.f());
    case "Refinement":
      return getIndexSignatures(ast.from);
  }
  return [];
};
var getNumberIndexedAccess = (ast) => {
  switch (ast._tag) {
    case "TupleType": {
      let hasOptional = false;
      let out2 = [];
      for (const e of ast.elements) {
        if (e.isOptional) {
          hasOptional = true;
        }
        out2.push(e.type);
      }
      if (hasOptional) {
        out2.push(undefinedKeyword);
      }
      out2 = out2.concat(getRestASTs(ast.rest));
      return Union.make(out2);
    }
    case "Refinement":
      return getNumberIndexedAccess(ast.from);
    case "Union":
      return Union.make(ast.types.map(getNumberIndexedAccess));
    case "Suspend":
      return getNumberIndexedAccess(ast.f());
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var getTypeLiteralPropertySignature = (ast, name2) => {
  const ops = findFirst2(ast.propertySignatures, (ps) => ps.name === name2);
  if (isSome2(ops)) {
    return ops.value;
  }
  if (isString(name2)) {
    let out2 = undefined;
    for (const is2 of ast.indexSignatures) {
      const encodedParameter = getEncodedParameter(is2.parameter);
      switch (encodedParameter._tag) {
        case "TemplateLiteral": {
          const regex = getTemplateLiteralRegExp(encodedParameter);
          if (regex.test(name2)) {
            return new PropertySignature(name2, is2.type, false, true);
          }
          break;
        }
        case "StringKeyword": {
          if (out2 === undefined) {
            out2 = new PropertySignature(name2, is2.type, false, true);
          }
        }
      }
    }
    if (out2) {
      return out2;
    }
  } else if (isSymbol(name2)) {
    for (const is2 of ast.indexSignatures) {
      const encodedParameter = getEncodedParameter(is2.parameter);
      if (isSymbolKeyword(encodedParameter)) {
        return new PropertySignature(name2, is2.type, false, true);
      }
    }
  }
};
var getPropertyKeyIndexedAccess = (ast, name2) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertyKeyIndexedAccess(annotation.value, name2);
  }
  switch (ast._tag) {
    case "TypeLiteral": {
      const ps = getTypeLiteralPropertySignature(ast, name2);
      if (ps) {
        return ps;
      }
      break;
    }
    case "Union":
      return new PropertySignature(name2, Union.make(ast.types.map((ast2) => getPropertyKeyIndexedAccess(ast2, name2).type)), false, true);
    case "Suspend":
      return getPropertyKeyIndexedAccess(ast.f(), name2);
    case "Refinement":
      return getPropertyKeyIndexedAccess(ast.from, name2);
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var getPropertyKeys = (ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertyKeys(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.propertySignatures.map((ps) => ps.name);
    case "Union":
      return ast.types.slice(1).reduce((out2, ast2) => intersection(out2, getPropertyKeys(ast2)), getPropertyKeys(ast.types[0]));
    case "Suspend":
      return getPropertyKeys(ast.f());
    case "Refinement":
      return getPropertyKeys(ast.from);
    case "Transformation":
      return getPropertyKeys(ast.to);
  }
  return [];
};
var record = (key, value) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go = (key2) => {
    switch (key2._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(new IndexSignature(key2, value, true));
        break;
      case "Literal":
        if (isString(key2.literal) || isNumber(key2.literal)) {
          propertySignatures.push(new PropertySignature(key2.literal, value, false, true));
        } else {
          throw new Error(getASTUnsupportedLiteralErrorMessage(key2.literal));
        }
        break;
      case "Enums": {
        for (const [_2, name2] of key2.enums) {
          propertySignatures.push(new PropertySignature(name2, value, false, true));
        }
        break;
      }
      case "UniqueSymbol":
        propertySignatures.push(new PropertySignature(key2.symbol, value, false, true));
        break;
      case "Union":
        key2.types.forEach(go);
        break;
      default:
        throw new Error(getASTUnsupportedKeySchemaErrorMessage(key2));
    }
  };
  go(key);
  return {
    propertySignatures,
    indexSignatures
  };
};
var pick = (ast, keys) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return pick(annotation.value, keys);
  }
  switch (ast._tag) {
    case "TypeLiteral": {
      const pss = [];
      const names = {};
      for (const ps of ast.propertySignatures) {
        names[ps.name] = null;
        if (keys.includes(ps.name)) {
          pss.push(ps);
        }
      }
      for (const key of keys) {
        if (!(key in names)) {
          const ps = getTypeLiteralPropertySignature(ast, key);
          if (ps) {
            pss.push(ps);
          }
        }
      }
      return new TypeLiteral(pss, []);
    }
    case "Union":
      return new TypeLiteral(keys.map((name2) => getPropertyKeyIndexedAccess(ast, name2)), []);
    case "Suspend":
      return pick(ast.f(), keys);
    case "Refinement":
      return pick(ast.from, keys);
    case "Transformation": {
      switch (ast.transformation._tag) {
        case "ComposeTransformation":
          return new Transformation(pick(ast.from, keys), pick(ast.to, keys), composeTransformation);
        case "TypeLiteralTransformation": {
          const ts = [];
          const fromKeys = [];
          for (const k2 of keys) {
            const t = ast.transformation.propertySignatureTransformations.find((t2) => t2.to === k2);
            if (t) {
              ts.push(t);
              fromKeys.push(t.from);
            } else {
              fromKeys.push(k2);
            }
          }
          return isNonEmptyReadonlyArray(ts) ? new Transformation(pick(ast.from, fromKeys), pick(ast.to, keys), new TypeLiteralTransformation(ts)) : pick(ast.from, fromKeys);
        }
      }
    }
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var omit = (ast, keys) => {
  let indexSignatures = getIndexSignatures(ast);
  if (indexSignatures.length > 0) {
    if (indexSignatures.some((is2) => isStringKeyword(getEncodedParameter(is2.parameter)))) {
      indexSignatures = indexSignatures.filter((is2) => !isTemplateLiteral(getEncodedParameter(is2.parameter)));
    }
    return new TypeLiteral([], indexSignatures);
  }
  return pick(ast, getPropertyKeys(ast).filter((name2) => !keys.includes(name2)));
};
var orUndefined = (ast) => Union.make([ast, undefinedKeyword]);
var partial = (ast, options) => {
  const exact = options?.exact === true;
  switch (ast._tag) {
    case "TupleType":
      return new TupleType(ast.elements.map((e) => new OptionalType(exact ? e.type : orUndefined(e.type), true)), match3(ast.rest, {
        onEmpty: () => ast.rest,
        onNonEmpty: (rest) => [new Type(Union.make([...getRestASTs(rest), undefinedKeyword]))]
      }), ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral(ast.propertySignatures.map((ps) => new PropertySignature(ps.name, exact ? ps.type : orUndefined(ps.type), true, ps.isReadonly, ps.annotations)), ast.indexSignatures.map((is2) => new IndexSignature(is2.parameter, orUndefined(is2.type), is2.isReadonly)));
    case "Union":
      return Union.make(ast.types.map((member) => partial(member, options)));
    case "Suspend":
      return new Suspend(() => partial(ast.f(), options));
    case "Declaration":
    case "Refinement":
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    case "Transformation": {
      if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
        return new Transformation(partial(ast.from, options), partial(ast.to, options), ast.transformation);
      }
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    }
  }
  return ast;
};
var required = (ast) => {
  switch (ast._tag) {
    case "TupleType":
      return new TupleType(ast.elements.map((e) => new OptionalType(e.type, false)), ast.rest, ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral(ast.propertySignatures.map((f) => new PropertySignature(f.name, f.type, false, f.isReadonly, f.annotations)), ast.indexSignatures);
    case "Union":
      return Union.make(ast.types.map((member) => required(member)));
    case "Suspend":
      return new Suspend(() => required(ast.f()));
    case "Declaration":
    case "Refinement":
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    case "Transformation": {
      if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
        return new Transformation(required(ast.from), required(ast.to), ast.transformation);
      }
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    }
  }
  return ast;
};
var mutable = (ast) => {
  switch (ast._tag) {
    case "TupleType":
      return ast.isReadonly === false ? ast : new TupleType(ast.elements, ast.rest, false, ast.annotations);
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => ps.isReadonly === false ? ps : new PropertySignature(ps.name, ps.type, ps.isOptional, false, ps.annotations));
      const indexSignatures = changeMap(ast.indexSignatures, (is2) => is2.isReadonly === false ? is2 : new IndexSignature(is2.parameter, is2.type, false));
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap(ast.types, mutable);
      return types === ast.types ? ast : Union.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => mutable(ast.f()), ast.annotations);
    case "Refinement": {
      const from = mutable(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const from = mutable(ast.from);
      const to = mutable(ast.to);
      return from === ast.from && to === ast.to ? ast : new Transformation(from, to, ast.transformation, ast.annotations);
    }
  }
  return ast;
};
var pickAnnotations = (annotationIds) => (annotated) => {
  let out2 = undefined;
  for (const id of annotationIds) {
    if (Object.prototype.hasOwnProperty.call(annotated.annotations, id)) {
      if (out2 === undefined) {
        out2 = {};
      }
      out2[id] = annotated.annotations[id];
    }
  }
  return out2;
};
var omitAnnotations = (annotationIds) => (annotated) => {
  const out2 = {
    ...annotated.annotations
  };
  for (const id of annotationIds) {
    delete out2[id];
  }
  return out2;
};
var preserveTransformationAnnotations = /* @__PURE__ */ pickAnnotations([ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId]);
var typeAST = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, typeAST);
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type = typeAST(e.type);
        return type === e.type ? e : new OptionalType(type, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, typeAST);
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type) => new Type(type)), ast.isReadonly, ast.annotations);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (p) => {
        const type = typeAST(p.type);
        return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is2) => {
        const type = typeAST(is2.type);
        return type === is2.type ? is2 : new IndexSignature(is2.parameter, type, is2.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap(ast.types, typeAST);
      return types === ast.types ? ast : Union.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => typeAST(ast.f()), ast.annotations);
    case "Refinement": {
      const from = typeAST(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const preserve = preserveTransformationAnnotations(ast);
      return typeAST(preserve !== undefined ? annotations(ast.to, preserve) : ast.to);
    }
  }
  return ast;
};
var createJSONIdentifierAnnotation = (annotated) => match2(getJSONIdentifier(annotated), {
  onNone: () => {
    return;
  },
  onSome: (identifier) => ({
    [JSONIdentifierAnnotationId]: identifier
  })
});
function changeMap(as, f) {
  let changed = false;
  const out2 = allocate(as.length);
  for (let i2 = 0;i2 < as.length; i2++) {
    const a = as[i2];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out2[i2] = fa;
  }
  return changed ? out2 : as;
}
var getTransformationFrom = (ast) => {
  switch (ast._tag) {
    case "Transformation":
      return ast.from;
    case "Refinement":
      return getTransformationFrom(ast.from);
    case "Suspend":
      return getTransformationFrom(ast.f());
  }
};
var encodedAST_ = (ast, isBound) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, (ast2) => encodedAST_(ast2, isBound));
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type = encodedAST_(e.type, isBound);
        return type === e.type ? e : new OptionalType(type, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, (ast2) => encodedAST_(ast2, isBound));
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast2) => new Type(ast2)), ast.isReadonly, createJSONIdentifierAnnotation(ast));
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
        const type = encodedAST_(ps.type, isBound);
        return type === ps.type ? ps : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is2) => {
        const type = encodedAST_(is2.type, isBound);
        return type === is2.type ? is2 : new IndexSignature(is2.parameter, type, is2.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, createJSONIdentifierAnnotation(ast));
    }
    case "Union": {
      const types = changeMap(ast.types, (ast2) => encodedAST_(ast2, isBound));
      return types === ast.types ? ast : Union.make(types, createJSONIdentifierAnnotation(ast));
    }
    case "Suspend":
      return new Suspend(() => encodedAST_(ast.f(), isBound), createJSONIdentifierAnnotation(ast));
    case "Refinement": {
      const from = encodedAST_(ast.from, isBound);
      if (isBound) {
        if (from === ast.from) {
          return ast;
        }
        if (getTransformationFrom(ast.from) === undefined && hasStableFilter(ast)) {
          return new Refinement(from, ast.filter, ast.annotations);
        }
      }
      const identifier = createJSONIdentifierAnnotation(ast);
      return identifier ? annotations(from, identifier) : from;
    }
    case "Transformation": {
      const identifier = createJSONIdentifierAnnotation(ast);
      return encodedAST_(identifier ? annotations(ast.from, identifier) : ast.from, isBound);
    }
  }
  return ast;
};
var encodedAST = (ast) => encodedAST_(ast, false);
var encodedBoundAST = (ast) => encodedAST_(ast, true);
var toJSONAnnotations = (annotations2) => {
  const out2 = {};
  for (const k2 of Object.getOwnPropertySymbols(annotations2)) {
    out2[String(k2)] = annotations2[k2];
  }
  return out2;
};
var getEncodedParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getEncodedParameter(ast.from);
  }
};
var equals2 = (self2, that) => {
  switch (self2._tag) {
    case "Literal":
      return isLiteral(that) && that.literal === self2.literal;
    case "UniqueSymbol":
      return isUniqueSymbol(that) && that.symbol === self2.symbol;
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "NeverKeyword":
    case "UnknownKeyword":
    case "AnyKeyword":
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
    case "ObjectKeyword":
      return that._tag === self2._tag;
    case "TemplateLiteral":
      return isTemplateLiteral(that) && that.head === self2.head && equalsTemplateLiteralSpan(that.spans, self2.spans);
    case "Enums":
      return isEnums(that) && equalsEnums(that.enums, self2.enums);
    case "Union":
      return isUnion(that) && equalsUnion(self2.types, that.types);
    case "Refinement":
    case "TupleType":
    case "TypeLiteral":
    case "Suspend":
    case "Transformation":
    case "Declaration":
      return self2 === that;
  }
};
var equalsTemplateLiteralSpan = /* @__PURE__ */ getEquivalence3((self2, that) => {
  return self2.literal === that.literal && equals2(self2.type, that.type);
});
var equalsEnums = /* @__PURE__ */ getEquivalence3((self2, that) => that[0] === self2[0] && that[1] === self2[1]);
var equalsUnion = /* @__PURE__ */ getEquivalence3(equals2);
var intersection2 = /* @__PURE__ */ intersectionWith(equals2);
var _keyof = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return _keyof(annotation.value);
      }
      break;
    }
    case "TypeLiteral":
      return ast.propertySignatures.map((p) => isSymbol(p.name) ? new UniqueSymbol(p.name) : new Literal(p.name)).concat(ast.indexSignatures.map((is2) => getEncodedParameter(is2.parameter)));
    case "Suspend":
      return _keyof(ast.f());
    case "Union":
      return ast.types.slice(1).reduce((out2, ast2) => intersection2(out2, _keyof(ast2)), _keyof(ast.types[0]));
    case "Transformation":
      return _keyof(ast.to);
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var compose = (ab, cd) => new Transformation(ab, cd, composeTransformation);
var rename = (ast, mapping) => {
  switch (ast._tag) {
    case "TypeLiteral": {
      const propertySignatureTransformations = [];
      for (const key of ownKeys(mapping)) {
        const name2 = mapping[key];
        if (name2 !== undefined) {
          propertySignatureTransformations.push(new PropertySignatureTransformation(key, name2, identity, identity));
        }
      }
      if (propertySignatureTransformations.length === 0) {
        return ast;
      }
      return new Transformation(ast, new TypeLiteral(ast.propertySignatures.map((ps) => {
        const name2 = mapping[ps.name];
        return new PropertySignature(name2 === undefined ? ps.name : name2, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations);
      }), ast.indexSignatures), new TypeLiteralTransformation(propertySignatureTransformations));
    }
    case "Union":
      return Union.make(ast.types.map((ast2) => rename(ast2, mapping)));
    case "Suspend":
      return new Suspend(() => rename(ast.f(), mapping));
    case "Transformation":
      return compose(ast, rename(typeAST(ast), mapping));
  }
  throw new Error(getASTUnsupportedRenameSchemaErrorMessage(ast));
};
var formatKeyword = (ast) => getOrElse(getExpected(ast), () => ast._tag);
function getBrands(ast) {
  return match2(getBrandAnnotation(ast), {
    onNone: () => "",
    onSome: (brands) => brands.map((brand) => ` & Brand<${formatUnknown(brand)}>`).join("")
  });
}
var getOrElseExpected = (ast) => getTitleAnnotation(ast).pipe(orElse(() => getDescriptionAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), map2((s2) => s2 + getBrands(ast)));
var getExpected = (ast) => orElse(getIdentifierAnnotation(ast), () => getOrElseExpected(ast));
var pruneUndefined = (ast, self2, onTransformation) => {
  switch (ast._tag) {
    case "UndefinedKeyword":
      return neverKeyword;
    case "Union": {
      const types = [];
      let hasUndefined = false;
      for (const type of ast.types) {
        const pruned = self2(type);
        if (pruned) {
          hasUndefined = true;
          if (!isNeverKeyword(pruned)) {
            types.push(pruned);
          }
        } else {
          types.push(type);
        }
      }
      if (hasUndefined) {
        return Union.make(types);
      }
      break;
    }
    case "Suspend":
      return self2(ast.f());
    case "Transformation":
      return onTransformation(ast);
  }
};
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/BigDecimal.js
var FINITE_INT_REGEX = /^[+-]?\d+$/;
var TypeId3 = /* @__PURE__ */ Symbol.for("effect/BigDecimal");
var BigDecimalProto = {
  [TypeId3]: TypeId3,
  [symbol]() {
    const normalized = normalize(this);
    return pipe(hash(normalized.value), combine(number2(normalized.scale)), cached(this));
  },
  [symbol2](that) {
    return isBigDecimal(that) && equals3(this, that);
  },
  toString() {
    return `BigDecimal(${format2(this)})`;
  },
  toJSON() {
    return {
      _id: "BigDecimal",
      value: String(this.value),
      scale: this.scale
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isBigDecimal = (u3) => hasProperty(u3, TypeId3);
var make4 = (value, scale) => {
  const o3 = Object.create(BigDecimalProto);
  o3.value = value;
  o3.scale = scale;
  return o3;
};
var unsafeMakeNormalized = (value, scale) => {
  if (value !== bigint0 && value % bigint10 === bigint0) {
    throw new RangeError("Value must be normalized");
  }
  const o3 = make4(value, scale);
  o3.normalized = o3;
  return o3;
};
var bigint0 = /* @__PURE__ */ BigInt(0);
var bigint10 = /* @__PURE__ */ BigInt(10);
var zero = /* @__PURE__ */ unsafeMakeNormalized(bigint0, 0);
var normalize = (self2) => {
  if (self2.normalized === undefined) {
    if (self2.value === bigint0) {
      self2.normalized = zero;
    } else {
      const digits = `${self2.value}`;
      let trail = 0;
      for (let i2 = digits.length - 1;i2 >= 0; i2--) {
        if (digits[i2] === "0") {
          trail++;
        } else {
          break;
        }
      }
      if (trail === 0) {
        self2.normalized = self2;
      }
      const value = BigInt(digits.substring(0, digits.length - trail));
      const scale = self2.scale - trail;
      self2.normalized = unsafeMakeNormalized(value, scale);
    }
  }
  return self2.normalized;
};
var scale = /* @__PURE__ */ dual(2, (self2, scale2) => {
  if (scale2 > self2.scale) {
    return make4(self2.value * bigint10 ** BigInt(scale2 - self2.scale), scale2);
  }
  if (scale2 < self2.scale) {
    return make4(self2.value / bigint10 ** BigInt(self2.scale - scale2), scale2);
  }
  return self2;
});
var Order2 = /* @__PURE__ */ make2((self2, that) => {
  const scmp = number3(sign(self2), sign(that));
  if (scmp !== 0) {
    return scmp;
  }
  if (self2.scale > that.scale) {
    return bigint2(self2.value, scale(that, self2.scale).value);
  }
  if (self2.scale < that.scale) {
    return bigint2(scale(self2, that.scale).value, that.value);
  }
  return bigint2(self2.value, that.value);
});
var lessThan2 = /* @__PURE__ */ lessThan(Order2);
var lessThanOrEqualTo2 = /* @__PURE__ */ lessThanOrEqualTo(Order2);
var greaterThan2 = /* @__PURE__ */ greaterThan(Order2);
var greaterThanOrEqualTo2 = /* @__PURE__ */ greaterThanOrEqualTo(Order2);
var between3 = /* @__PURE__ */ between2(Order2);
var clamp4 = /* @__PURE__ */ clamp(Order2);
var sign = (n) => n.value === bigint0 ? 0 : n.value < bigint0 ? -1 : 1;
var abs = (n) => n.value < bigint0 ? make4(-n.value, n.scale) : n;
var Equivalence = /* @__PURE__ */ make((self2, that) => {
  if (self2.scale > that.scale) {
    return scale(that, self2.scale).value === self2.value;
  }
  if (self2.scale < that.scale) {
    return scale(self2, that.scale).value === that.value;
  }
  return self2.value === that.value;
});
var equals3 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence(self2, that));
var unsafeFromNumber = (n) => getOrThrowWith2(safeFromNumber(n), () => new RangeError(`Number must be finite, got ${n}`));
var safeFromNumber = (n) => {
  if (!Number.isFinite(n)) {
    return none2();
  }
  const string2 = `${n}`;
  if (string2.includes("e")) {
    return fromString(string2);
  }
  const [lead, trail = ""] = string2.split(".");
  return some2(make4(BigInt(`${lead}${trail}`), trail.length));
};
var fromString = (s2) => {
  if (s2 === "") {
    return some2(zero);
  }
  let base;
  let exp;
  const seperator = s2.search(/[eE]/);
  if (seperator !== -1) {
    const trail = s2.slice(seperator + 1);
    base = s2.slice(0, seperator);
    exp = Number(trail);
    if (base === "" || !Number.isSafeInteger(exp) || !FINITE_INT_REGEX.test(trail)) {
      return none2();
    }
  } else {
    base = s2;
    exp = 0;
  }
  let digits;
  let offset;
  const dot = base.search(/\./);
  if (dot !== -1) {
    const lead = base.slice(0, dot);
    const trail = base.slice(dot + 1);
    digits = `${lead}${trail}`;
    offset = trail.length;
  } else {
    digits = base;
    offset = 0;
  }
  if (!FINITE_INT_REGEX.test(digits)) {
    return none2();
  }
  const scale2 = offset - exp;
  if (!Number.isSafeInteger(scale2)) {
    return none2();
  }
  return some2(make4(BigInt(digits), scale2));
};
var format2 = (n) => {
  const normalized = normalize(n);
  if (Math.abs(normalized.scale) >= 16) {
    return toExponential(normalized);
  }
  const negative = normalized.value < bigint0;
  const absolute = negative ? `${normalized.value}`.substring(1) : `${normalized.value}`;
  let before;
  let after;
  if (normalized.scale >= absolute.length) {
    before = "0";
    after = "0".repeat(normalized.scale - absolute.length) + absolute;
  } else {
    const location2 = absolute.length - normalized.scale;
    if (location2 > absolute.length) {
      const zeros = location2 - absolute.length;
      before = `${absolute}${"0".repeat(zeros)}`;
      after = "";
    } else {
      after = absolute.slice(location2);
      before = absolute.slice(0, location2);
    }
  }
  const complete = after === "" ? before : `${before}.${after}`;
  return negative ? `-${complete}` : complete;
};
var toExponential = (n) => {
  if (isZero(n)) {
    return "0e+0";
  }
  const normalized = normalize(n);
  const digits = `${abs(normalized).value}`;
  const head2 = digits.slice(0, 1);
  const tail = digits.slice(1);
  let output = `${isNegative(normalized) ? "-" : ""}${head2}`;
  if (tail !== "") {
    output += `.${tail}`;
  }
  const exp = tail.length - normalized.scale;
  return `${output}e${exp >= 0 ? "+" : ""}${exp}`;
};
var unsafeToNumber = (n) => Number(format2(n));
var isZero = (n) => n.value === bigint0;
var isNegative = (n) => n.value < bigint0;
var isPositive = (n) => n.value > bigint0;
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/BigInt.js
var Order3 = bigint2;
var clamp5 = /* @__PURE__ */ clamp(Order3);
var toNumber = (b3) => {
  if (b3 > BigInt(Number.MAX_SAFE_INTEGER) || b3 < BigInt(Number.MIN_SAFE_INTEGER)) {
    return none2();
  }
  return some2(Number(b3));
};
var fromString2 = (s2) => {
  try {
    return s2.trim() === "" ? none2() : some2(BigInt(s2));
  } catch {
    return none2();
  }
};
var fromNumber = (n) => {
  if (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER) {
    return none2();
  }
  try {
    return some2(BigInt(n));
  } catch {
    return none2();
  }
};
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Boolean.js
var not2 = (self2) => !self2;
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Context.js
var exports_Context = {};
__export(exports_Context, {
  unsafeMake: () => unsafeMake,
  unsafeGet: () => unsafeGet3,
  pick: () => pick3,
  omit: () => omit3,
  mergeAll: () => mergeAll2,
  merge: () => merge3,
  make: () => make6,
  isTag: () => isTag2,
  isReference: () => isReference2,
  isContext: () => isContext2,
  getOrElse: () => getOrElse3,
  getOption: () => getOption2,
  get: () => get3,
  empty: () => empty4,
  add: () => add2,
  Tag: () => Tag2,
  Reference: () => Reference2,
  GenericTag: () => GenericTag
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/context.js
var TagTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
var ReferenceTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
var STMSymbolKey = "effect/STM";
var STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
var TagProto = {
  ...EffectPrototype,
  _op: "Tag",
  [STMTypeId]: effectVariance,
  [TagTypeId]: {
    _Service: (_2) => _2,
    _Identifier: (_2) => _2
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self2) {
    return self2;
  },
  context(self2) {
    return make5(this, self2);
  }
};
var ReferenceProto = {
  ...TagProto,
  [ReferenceTypeId]: ReferenceTypeId
};
var makeGenericTag = (key) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  const tag = Object.create(TagProto);
  Object.defineProperty(tag, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag.key = key;
  return tag;
};
var Tag = (id) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return TagClass;
};
var Reference = () => (id, options) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  function ReferenceClass() {
  }
  Object.setPrototypeOf(ReferenceClass, ReferenceProto);
  ReferenceClass.key = id;
  ReferenceClass.defaultValue = options.defaultValue;
  Object.defineProperty(ReferenceClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return ReferenceClass;
};
var TypeId4 = /* @__PURE__ */ Symbol.for("effect/Context");
var ContextProto = {
  [TypeId4]: {
    _Services: (_2) => _2
  },
  [symbol2](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k2 of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k2) || !equals(this.unsafeMap.get(k2), that.unsafeMap.get(k2))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol]() {
    return cached(this, number2(this.unsafeMap.size));
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var makeContext = (unsafeMap) => {
  const context = Object.create(ContextProto);
  context.unsafeMap = unsafeMap;
  return context;
};
var serviceNotFoundError = (tag) => {
  const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : ""}`);
  if (tag.stack) {
    const lines = tag.stack.split(`
`);
    if (lines.length > 2) {
      const afterAt = lines[2].match(/at (.*)/);
      if (afterAt) {
        error.message = error.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error.stack) {
    const lines = error.stack.split(`
`);
    lines.splice(1, 3);
    error.stack = lines.join(`
`);
  }
  return error;
};
var isContext = (u3) => hasProperty(u3, TypeId4);
var isTag = (u3) => hasProperty(u3, TagTypeId);
var isReference = (u3) => hasProperty(u3, ReferenceTypeId);
var _empty = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map);
var empty3 = () => _empty;
var make5 = (tag, service) => makeContext(new Map([[tag.key, service]]));
var add = /* @__PURE__ */ dual(3, (self2, tag, service) => {
  const map4 = new Map(self2.unsafeMap);
  map4.set(tag.key, service);
  return makeContext(map4);
});
var defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => new Map);
var getDefaultValue = (tag) => {
  if (defaultValueCache.has(tag.key)) {
    return defaultValueCache.get(tag.key);
  }
  const value = tag.defaultValue();
  defaultValueCache.set(tag.key, value);
  return value;
};
var unsafeGetReference = (self2, tag) => {
  return self2.unsafeMap.has(tag.key) ? self2.unsafeMap.get(tag.key) : getDefaultValue(tag);
};
var unsafeGet2 = /* @__PURE__ */ dual(2, (self2, tag) => {
  if (!self2.unsafeMap.has(tag.key)) {
    if (ReferenceTypeId in tag)
      return getDefaultValue(tag);
    throw serviceNotFoundError(tag);
  }
  return self2.unsafeMap.get(tag.key);
});
var get2 = unsafeGet2;
var getOrElse2 = /* @__PURE__ */ dual(3, (self2, tag, orElse2) => {
  if (!self2.unsafeMap.has(tag.key)) {
    return isReference(tag) ? getDefaultValue(tag) : orElse2();
  }
  return self2.unsafeMap.get(tag.key);
});
var getOption = /* @__PURE__ */ dual(2, (self2, tag) => {
  if (!self2.unsafeMap.has(tag.key)) {
    return isReference(tag) ? some(getDefaultValue(tag)) : none;
  }
  return some(self2.unsafeMap.get(tag.key));
});
var merge2 = /* @__PURE__ */ dual(2, (self2, that) => {
  const map4 = new Map(self2.unsafeMap);
  for (const [tag, s2] of that.unsafeMap) {
    map4.set(tag, s2);
  }
  return makeContext(map4);
});
var mergeAll = (...ctxs) => {
  const map4 = new Map;
  for (const ctx of ctxs) {
    for (const [tag, s2] of ctx.unsafeMap) {
      map4.set(tag, s2);
    }
  }
  return makeContext(map4);
};
var pick2 = (...tags) => (self2) => {
  const tagSet = new Set(tags.map((_2) => _2.key));
  const newEnv = new Map;
  for (const [tag, s2] of self2.unsafeMap.entries()) {
    if (tagSet.has(tag)) {
      newEnv.set(tag, s2);
    }
  }
  return makeContext(newEnv);
};
var omit2 = (...tags) => (self2) => {
  const newEnv = new Map(self2.unsafeMap);
  for (const tag of tags) {
    newEnv.delete(tag.key);
  }
  return makeContext(newEnv);
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Context.js
var GenericTag = makeGenericTag;
var unsafeMake = makeContext;
var isContext2 = isContext;
var isTag2 = isTag;
var isReference2 = isReference;
var empty4 = empty3;
var make6 = make5;
var add2 = add;
var get3 = get2;
var getOrElse3 = getOrElse2;
var unsafeGet3 = unsafeGet2;
var getOption2 = getOption;
var merge3 = merge2;
var mergeAll2 = mergeAll;
var pick3 = pick2;
var omit3 = omit2;
var Tag2 = Tag;
var Reference2 = Reference;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Chunk.js
var TypeId5 = /* @__PURE__ */ Symbol.for("effect/Chunk");
function copy2(src, srcPos, dest, destPos, len) {
  for (let i2 = srcPos;i2 < Math.min(src.length, srcPos + len); i2++) {
    dest[destPos + i2 - srcPos] = src[i2];
  }
  return dest;
}
var emptyArray = [];
var getEquivalence4 = (isEquivalent) => make((self2, that) => self2.length === that.length && toReadonlyArray(self2).every((value, i2) => isEquivalent(value, unsafeGet4(that, i2))));
var _equivalence3 = /* @__PURE__ */ getEquivalence4(equals);
var ChunkProto = {
  [TypeId5]: {
    _A: (_2) => _2
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isChunk(that) && _equivalence3(this, that);
  },
  [symbol]() {
    return cached(this, array2(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeChunk = (backing) => {
  const chunk = Object.create(ChunkProto);
  chunk.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk.length = 0;
      chunk.depth = 0;
      chunk.left = chunk;
      chunk.right = chunk;
      break;
    }
    case "IConcat": {
      chunk.length = backing.left.length + backing.right.length;
      chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk.left = backing.left;
      chunk.right = backing.right;
      break;
    }
    case "IArray": {
      chunk.length = backing.array.length;
      chunk.depth = 0;
      chunk.left = _empty2;
      chunk.right = _empty2;
      break;
    }
    case "ISingleton": {
      chunk.length = 1;
      chunk.depth = 0;
      chunk.left = _empty2;
      chunk.right = _empty2;
      break;
    }
    case "ISlice": {
      chunk.length = backing.length;
      chunk.depth = backing.chunk.depth + 1;
      chunk.left = _empty2;
      chunk.right = _empty2;
      break;
    }
  }
  return chunk;
};
var isChunk = (u3) => hasProperty(u3, TypeId5);
var _empty2 = /* @__PURE__ */ makeChunk({
  _tag: "IEmpty"
});
var empty5 = () => _empty2;
var make7 = (...as) => unsafeFromNonEmptyArray(as);
var of2 = (a) => makeChunk({
  _tag: "ISingleton",
  a
});
var fromIterable2 = (self2) => isChunk(self2) ? self2 : unsafeFromArray(fromIterable(self2));
var copyToArray = (self2, array5, initial) => {
  switch (self2.backing._tag) {
    case "IArray": {
      copy2(self2.backing.array, 0, array5, initial, self2.length);
      break;
    }
    case "IConcat": {
      copyToArray(self2.left, array5, initial);
      copyToArray(self2.right, array5, initial + self2.left.length);
      break;
    }
    case "ISingleton": {
      array5[initial] = self2.backing.a;
      break;
    }
    case "ISlice": {
      let i2 = 0;
      let j4 = initial;
      while (i2 < self2.length) {
        array5[j4] = unsafeGet4(self2, i2);
        i2 += 1;
        j4 += 1;
      }
      break;
    }
  }
};
var toReadonlyArray_ = (self2) => {
  switch (self2.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self2.backing.array;
    }
    default: {
      const arr = new Array(self2.length);
      copyToArray(self2, arr, 0);
      self2.backing = {
        _tag: "IArray",
        array: arr
      };
      self2.left = _empty2;
      self2.right = _empty2;
      self2.depth = 0;
      return arr;
    }
  }
};
var toReadonlyArray = toReadonlyArray_;
var reverseChunk = (self2) => {
  switch (self2.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self2;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse(self2.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse2(self2.backing.right),
        right: reverse2(self2.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse(toReadonlyArray(self2)));
  }
};
var reverse2 = reverseChunk;
var get4 = /* @__PURE__ */ dual(2, (self2, index2) => index2 < 0 || index2 >= self2.length ? none2() : some2(unsafeGet4(self2, index2)));
var unsafeFromArray = (self2) => self2.length === 0 ? empty5() : self2.length === 1 ? of2(self2[0]) : makeChunk({
  _tag: "IArray",
  array: self2
});
var unsafeFromNonEmptyArray = (self2) => unsafeFromArray(self2);
var unsafeGet4 = /* @__PURE__ */ dual(2, (self2, index2) => {
  switch (self2.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index2 !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self2.backing.a;
    }
    case "IArray": {
      if (index2 >= self2.length || index2 < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self2.backing.array[index2];
    }
    case "IConcat": {
      return index2 < self2.left.length ? unsafeGet4(self2.left, index2) : unsafeGet4(self2.right, index2 - self2.left.length);
    }
    case "ISlice": {
      return unsafeGet4(self2.backing.chunk, index2 + self2.backing.offset);
    }
  }
});
var append2 = /* @__PURE__ */ dual(2, (self2, a) => appendAll2(self2, of2(a)));
var prepend2 = /* @__PURE__ */ dual(2, (self2, elem) => appendAll2(of2(elem), self2));
var take = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return _empty2;
  } else if (n >= self2.length) {
    return self2;
  } else {
    switch (self2.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2.backing.chunk,
          length: n,
          offset: self2.backing.offset
        });
      }
      case "IConcat": {
        if (n > self2.left.length) {
          return makeChunk({
            _tag: "IConcat",
            left: self2.left,
            right: take(self2.right, n - self2.left.length)
          });
        }
        return take(self2.left, n);
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2,
          offset: 0,
          length: n
        });
      }
    }
  }
});
var drop2 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return self2;
  } else if (n >= self2.length) {
    return _empty2;
  } else {
    switch (self2.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2.backing.chunk,
          offset: self2.backing.offset + n,
          length: self2.backing.length - n
        });
      }
      case "IConcat": {
        if (n > self2.left.length) {
          return drop2(self2.right, n - self2.left.length);
        }
        return makeChunk({
          _tag: "IConcat",
          left: drop2(self2.left, n),
          right: self2.right
        });
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2,
          offset: n,
          length: self2.length - n
        });
      }
    }
  }
});
var appendAll2 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self2;
  }
  const diff = that.depth - self2.depth;
  if (Math.abs(diff) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self2,
      right: that
    });
  } else if (diff < -1) {
    if (self2.left.depth >= self2.right.depth) {
      const nr = appendAll2(self2.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self2.left,
        right: nr
      });
    } else {
      const nrr = appendAll2(self2.right.right, that);
      if (nrr.depth === self2.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self2.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self2.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self2.left,
          right: self2.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll2(self2, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll2(self2, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var isEmpty = (self2) => self2.length === 0;
var isNonEmpty2 = (self2) => self2.length > 0;
var head2 = /* @__PURE__ */ get4(0);
var unsafeHead2 = (self2) => unsafeGet4(self2, 0);
var headNonEmpty2 = unsafeHead2;
var splitAt2 = /* @__PURE__ */ dual(2, (self2, n) => [take(self2, n), drop2(self2, n)]);
var tailNonEmpty2 = (self2) => drop2(self2, 1);

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Duration.js
var TypeId6 = /* @__PURE__ */ Symbol.for("effect/Duration");
var bigint02 = /* @__PURE__ */ BigInt(0);
var bigint24 = /* @__PURE__ */ BigInt(24);
var bigint60 = /* @__PURE__ */ BigInt(60);
var bigint1e3 = /* @__PURE__ */ BigInt(1000);
var bigint1e6 = /* @__PURE__ */ BigInt(1e6);
var bigint1e9 = /* @__PURE__ */ BigInt(1e9);
var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
var decode = (input) => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return millis(input);
  } else if (isBigInt(input)) {
    return nanos(input);
  } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
      return zero2;
    }
    if (input[0] === Infinity || input[1] === Infinity) {
      return infinity;
    }
    return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
  } else if (isString(input)) {
    const match4 = DURATION_REGEX.exec(input);
    if (match4) {
      const [_2, valueStr, unit] = match4;
      const value = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value);
        case "second":
        case "seconds":
          return seconds(value);
        case "minute":
        case "minutes":
          return minutes(value);
        case "hour":
        case "hours":
          return hours(value);
        case "day":
        case "days":
          return days(value);
        case "week":
        case "weeks":
          return weeks(value);
      }
    }
  }
  throw new Error("Invalid DurationInput");
};
var zeroValue = {
  _tag: "Millis",
  millis: 0
};
var infinityValue = {
  _tag: "Infinity"
};
var DurationProto = {
  [TypeId6]: TypeId6,
  [symbol]() {
    return cached(this, structure(this.value));
  },
  [symbol2](that) {
    return isDuration(that) && equals4(this, that);
  },
  toString() {
    return `Duration(${format3(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make8 = (input) => {
  const duration = Object.create(DurationProto);
  if (isNumber(input)) {
    if (isNaN(input) || input <= 0) {
      duration.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1e6))
      };
    } else {
      duration.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint02) {
    duration.value = zeroValue;
  } else {
    duration.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration;
};
var isDuration = (u3) => hasProperty(u3, TypeId6);
var isFinite = (self2) => self2.value._tag !== "Infinity";
var isZero2 = (self2) => {
  switch (self2.value._tag) {
    case "Millis": {
      return self2.value.millis === 0;
    }
    case "Nanos": {
      return self2.value.nanos === bigint02;
    }
    case "Infinity": {
      return false;
    }
  }
};
var zero2 = /* @__PURE__ */ make8(0);
var infinity = /* @__PURE__ */ make8(Infinity);
var nanos = (nanos2) => make8(nanos2);
var micros = (micros2) => make8(micros2 * bigint1e3);
var millis = (millis2) => make8(millis2);
var seconds = (seconds2) => make8(seconds2 * 1000);
var minutes = (minutes2) => make8(minutes2 * 60000);
var hours = (hours2) => make8(hours2 * 3600000);
var days = (days2) => make8(days2 * 86400000);
var weeks = (weeks2) => make8(weeks2 * 604800000);
var toMillis = (self2) => match4(self2, {
  onMillis: (millis2) => millis2,
  onNanos: (nanos2) => Number(nanos2) / 1e6
});
var toNanos = (self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      return none2();
    case "Nanos":
      return some2(_self.value.nanos);
    case "Millis":
      return some2(BigInt(Math.round(_self.value.millis * 1e6)));
  }
};
var unsafeToNanos = (self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1e6));
  }
};
var toHrTime = (self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1000), Math.round(_self.value.millis % 1000 * 1e6)];
  }
};
var match4 = /* @__PURE__ */ dual(2, (self2, options) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Nanos":
      return options.onNanos(_self.value.nanos);
    case "Infinity":
      return options.onMillis(Infinity);
    case "Millis":
      return options.onMillis(_self.value.millis);
  }
});
var matchWith = /* @__PURE__ */ dual(3, (self2, that, options) => {
  const _self = decode(self2);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
var Order4 = /* @__PURE__ */ make2((self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 < that2 ? -1 : self3 > that2 ? 1 : 0,
  onNanos: (self3, that2) => self3 < that2 ? -1 : self3 > that2 ? 1 : 0
}));
var between4 = /* @__PURE__ */ between2(/* @__PURE__ */ mapInput2(Order4, decode));
var Equivalence2 = (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 === that2,
  onNanos: (self3, that2) => self3 === that2
});
var _clamp = /* @__PURE__ */ clamp(Order4);
var clamp6 = /* @__PURE__ */ dual(2, (self2, options) => _clamp(decode(self2), {
  minimum: decode(options.minimum),
  maximum: decode(options.maximum)
}));
var lessThan3 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 < that2,
  onNanos: (self3, that2) => self3 < that2
}));
var lessThanOrEqualTo3 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 <= that2,
  onNanos: (self3, that2) => self3 <= that2
}));
var greaterThan3 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 > that2,
  onNanos: (self3, that2) => self3 > that2
}));
var greaterThanOrEqualTo3 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 >= that2,
  onNanos: (self3, that2) => self3 >= that2
}));
var equals4 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence2(decode(self2), decode(that)));
var parts2 = (self2) => {
  const duration = decode(self2);
  if (duration.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos2 = unsafeToNanos(duration);
  const ms = nanos2 / bigint1e6;
  const sec = ms / bigint1e3;
  const min2 = sec / bigint60;
  const hr = min2 / bigint60;
  const days2 = hr / bigint24;
  return {
    days: Number(days2),
    hours: Number(hr % bigint24),
    minutes: Number(min2 % bigint60),
    seconds: Number(sec % bigint60),
    millis: Number(ms % bigint1e3),
    nanos: Number(nanos2 % bigint1e6)
  };
};
var format3 = (self2) => {
  const duration = decode(self2);
  if (duration.value._tag === "Infinity") {
    return "Infinity";
  }
  if (isZero2(duration)) {
    return "0";
  }
  const fragments = parts2(duration);
  const pieces = [];
  if (fragments.days !== 0) {
    pieces.push(`${fragments.days}d`);
  }
  if (fragments.hours !== 0) {
    pieces.push(`${fragments.hours}h`);
  }
  if (fragments.minutes !== 0) {
    pieces.push(`${fragments.minutes}m`);
  }
  if (fragments.seconds !== 0) {
    pieces.push(`${fragments.seconds}s`);
  }
  if (fragments.millis !== 0) {
    pieces.push(`${fragments.millis}ms`);
  }
  if (fragments.nanos !== 0) {
    pieces.push(`${fragments.nanos}ns`);
  }
  return pieces.join(" ");
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE = 5;
var BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
var MASK = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x3) {
  x3 -= x3 >> 1 & 1431655765;
  x3 = (x3 & 858993459) + (x3 >> 2 & 858993459);
  x3 = x3 + (x3 >> 4) & 252645135;
  x3 += x3 >> 8;
  x3 += x3 >> 16;
  return x3 & 127;
}
function hashFragment(shift, h3) {
  return h3 >>> shift & MASK;
}
function toBitmap(x3) {
  return 1 << x3;
}
function fromBitmap(bitmap, bit2) {
  return popcount(bitmap & bit2 - 1);
}

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/stack.js
var make9 = (value, previous) => ({
  value,
  previous
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate(mutate, at2, v2, arr) {
  let out2 = arr;
  if (!mutate) {
    const len = arr.length;
    out2 = new Array(len);
    for (let i2 = 0;i2 < len; ++i2)
      out2[i2] = arr[i2];
  }
  out2[at2] = v2;
  return out2;
}
function arraySpliceOut(mutate, at2, arr) {
  const newLen = arr.length - 1;
  let i2 = 0;
  let g3 = 0;
  let out2 = arr;
  if (mutate) {
    i2 = g3 = at2;
  } else {
    out2 = new Array(newLen);
    while (i2 < at2)
      out2[g3++] = arr[i2++];
  }
  ++i2;
  while (i2 <= newLen)
    out2[g3++] = arr[i2++];
  if (mutate) {
    out2.length = newLen;
  }
  return out2;
}
function arraySpliceIn(mutate, at2, v2, arr) {
  const len = arr.length;
  if (mutate) {
    let i3 = len;
    while (i3 >= at2)
      arr[i3--] = arr[i3];
    arr[at2] = v2;
    return arr;
  }
  let i2 = 0, g3 = 0;
  const out2 = new Array(len + 1);
  while (i2 < at2)
    out2[g3++] = arr[i2++];
  out2[at2] = v2;
  while (i2 < len)
    out2[++g3] = arr[i2++];
  return out2;
}

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/hashMap/node.js
class EmptyNode {
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash2, key, size) {
    const v2 = f(none2());
    if (isNone2(v2))
      return new EmptyNode;
    ++size.value;
    return new LeafNode(edit, hash2, key, v2);
  }
}
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}

class LeafNode {
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash2, key, value) {
    this.edit = edit;
    this.hash = hash2;
    this.key = key;
    this.value = value;
  }
  modify(edit, shift, f, hash2, key, size) {
    if (equals(key, this.key)) {
      const v3 = f(this.value);
      if (v3 === this.value)
        return this;
      else if (isNone2(v3)) {
        --size.value;
        return new EmptyNode;
      }
      if (canEditNode(this, edit)) {
        this.value = v3;
        return this;
      }
      return new LeafNode(edit, hash2, key, v3);
    }
    const v2 = f(none2());
    if (isNone2(v2))
      return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v2));
  }
}

class CollisionNode {
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash2, children) {
    this.edit = edit;
    this.hash = hash2;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size) {
    if (hash2 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size);
      if (list === this.children)
        return this;
      return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0];
    }
    const v2 = f(none2());
    if (isNone2(v2))
      return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v2));
  }
  updateCollisionList(mutate, edit, hash2, list, f, key, size) {
    const len = list.length;
    for (let i2 = 0;i2 < len; ++i2) {
      const child = list[i2];
      if ("key" in child && equals(key, child.key)) {
        const value = child.value;
        const newValue2 = f(value);
        if (newValue2 === value)
          return list;
        if (isNone2(newValue2)) {
          --size.value;
          return arraySpliceOut(mutate, i2, list);
        }
        return arrayUpdate(mutate, i2, new LeafNode(edit, hash2, key, newValue2), list);
      }
    }
    const newValue = f(none2());
    if (isNone2(newValue))
      return list;
    ++size.value;
    return arrayUpdate(mutate, len, new LeafNode(edit, hash2, key, newValue), list);
  }
}

class IndexedNode {
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children) {
    this.edit = edit;
    this.mask = mask;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size) {
    const mask = this.mask;
    const children = this.children;
    const frag = hashFragment(shift, hash2);
    const bit2 = toBitmap(frag);
    const indx = fromBitmap(mask, bit2);
    const exists3 = mask & bit2;
    const canEdit = canEditNode(this, edit);
    if (!exists3) {
      const _newChild = new EmptyNode().modify(edit, shift + SIZE, f, hash2, key, size);
      if (!_newChild)
        return this;
      return children.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children) : new IndexedNode(edit, mask | bit2, arraySpliceIn(canEdit, indx, _newChild, children));
    }
    const current = children[indx];
    const child = current.modify(edit, shift + SIZE, f, hash2, key, size);
    if (current === child)
      return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit2;
      if (!bitmap)
        return new EmptyNode;
      if (children.length <= 2 && isLeafNode(children[indx ^ 1])) {
        return children[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new IndexedNode(edit, bitmap, newChildren);
  }
}

class ArrayNode {
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size, children) {
    this.edit = edit;
    this.size = size;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size) {
    let count = this.size;
    const children = this.children;
    const frag = hashFragment(shift, hash2);
    const child = children[frag];
    const newChild = (child || new EmptyNode).modify(edit, shift + SIZE, f, hash2, key, size);
    if (child === newChild)
      return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count;
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count;
      if (count <= MIN_ARRAY_NODE) {
        return pack(edit, count, frag, children);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode, children);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    }
    if (canEdit) {
      this.size = count;
      this.children = newChildren;
      return this;
    }
    return new ArrayNode(edit, count, newChildren);
  }
}
function pack(edit, count, removed, elements) {
  const children = new Array(count - 1);
  let g3 = 0;
  let bitmap = 0;
  for (let i2 = 0, len = elements.length;i2 < len; ++i2) {
    if (i2 !== removed) {
      const elem = elements[i2];
      if (elem && !isEmptyNode(elem)) {
        children[g3++] = elem;
        bitmap |= 1 << i2;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit2 = bitmap;
  let count = 0;
  for (let i2 = 0;bit2; ++i2) {
    if (bit2 & 1)
      arr[i2] = subNodes[count++];
    bit2 >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count + 1, arr);
}
function mergeLeavesInner(edit, shift, h1, n1, h22, n2) {
  if (h1 === h22)
    return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift, h1);
  const subH2 = hashFragment(shift, h22);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children);
  }
}
function mergeLeaves(edit, shift, h1, n1, h22, n2) {
  let stack = undefined;
  let currentShift = shift;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h22, n2);
    if (typeof res === "function") {
      stack = make9(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap";
var HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
var HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k2, v2) => [k2, v2]);
  },
  [symbol]() {
    let hash2 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash2);
  },
  [symbol2](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone2(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl = (editable, edit, root, size) => {
  const map4 = Object.create(HashMapProto);
  map4._editable = editable;
  map4._edit = edit;
  map4._root = root;
  map4._size = size;
  return map4;
};

class HashMapIterator {
  map;
  f;
  v;
  constructor(map4, f) {
    this.map = map4;
    this.f = f;
    this.v = visitLazy(this.map._root, this.f, undefined);
  }
  next() {
    if (isNone2(this.v)) {
      return {
        done: true,
        value: undefined
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new HashMapIterator(this.map, this.f);
  }
}
var applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2();
var visitLazy = (node, f, cont = undefined) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome2(node.value)) {
        return some2({
          value: f(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children = node.children;
      return visitLazyChildren(children.length, children, 0, f, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
};
var visitLazyChildren = (len, children, i2, f, cont) => {
  while (i2 < len) {
    const child = children[i2++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f, [len, children, i2, f, cont]);
    }
  }
  return applyCont(cont);
};
var _empty3 = /* @__PURE__ */ makeImpl(false, 0, /* @__PURE__ */ new EmptyNode, 0);
var empty6 = () => _empty3;
var fromIterable3 = (entries) => {
  const map4 = beginMutation(empty6());
  for (const entry of entries) {
    set(map4, entry[0], entry[1]);
  }
  return endMutation(map4);
};
var isHashMap = (u3) => hasProperty(u3, HashMapTypeId);
var isEmpty2 = (self2) => self2 && isEmptyNode(self2._root);
var get5 = /* @__PURE__ */ dual(2, (self2, key) => getHash(self2, key, hash(key)));
var getHash = /* @__PURE__ */ dual(3, (self2, key, hash2) => {
  let node = self2._root;
  let shift = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none2();
      }
      case "CollisionNode": {
        if (hash2 === node.hash) {
          const children = node.children;
          for (let i2 = 0, len = children.length;i2 < len; ++i2) {
            const child = children[i2];
            if ("key" in child && equals(key, child.key)) {
              return child.value;
            }
          }
        }
        return none2();
      }
      case "IndexedNode": {
        const frag = hashFragment(shift, hash2);
        const bit2 = toBitmap(frag);
        if (node.mask & bit2) {
          node = node.children[fromBitmap(node.mask, bit2)];
          shift += SIZE;
          break;
        }
        return none2();
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift, hash2)];
        if (node) {
          shift += SIZE;
          break;
        }
        return none2();
      }
      default:
        return none2();
    }
  }
});
var has = /* @__PURE__ */ dual(2, (self2, key) => isSome2(getHash(self2, key, hash(key))));
var set = /* @__PURE__ */ dual(3, (self2, key, value) => modifyAt(self2, key, () => some2(value)));
var setTree = /* @__PURE__ */ dual(3, (self2, newRoot, newSize) => {
  if (self2._editable) {
    self2._root = newRoot;
    self2._size = newSize;
    return self2;
  }
  return newRoot === self2._root ? self2 : makeImpl(self2._editable, self2._edit, newRoot, newSize);
});
var keys = (self2) => new HashMapIterator(self2, (key) => key);
var size = (self2) => self2._size;
var beginMutation = (self2) => makeImpl(true, self2._edit + 1, self2._root, self2._size);
var endMutation = (self2) => {
  self2._editable = false;
  return self2;
};
var mutate = /* @__PURE__ */ dual(2, (self2, f) => {
  const transient = beginMutation(self2);
  f(transient);
  return endMutation(transient);
});
var modifyAt = /* @__PURE__ */ dual(3, (self2, key, f) => modifyHash(self2, key, hash(key), f));
var modifyHash = /* @__PURE__ */ dual(4, (self2, key, hash2, f) => {
  const size2 = {
    value: self2._size
  };
  const newRoot = self2._root.modify(self2._editable ? self2._edit : NaN, 0, f, hash2, key, size2);
  return pipe(self2, setTree(newRoot, size2.value));
});
var remove2 = /* @__PURE__ */ dual(2, (self2, key) => modifyAt(self2, key, none2));
var map4 = /* @__PURE__ */ dual(2, (self2, f) => reduce3(self2, empty6(), (map5, value, key) => set(map5, key, f(value, key))));
var forEach = /* @__PURE__ */ dual(2, (self2, f) => reduce3(self2, undefined, (_2, value, key) => f(value, key)));
var reduce3 = /* @__PURE__ */ dual(3, (self2, zero3, f) => {
  const root = self2._root;
  if (root._tag === "LeafNode") {
    return isSome2(root.value) ? f(zero3, root.value.value, root.key) : zero3;
  }
  if (root._tag === "EmptyNode") {
    return zero3;
  }
  const toVisit = [root.children];
  let children;
  while (children = toVisit.pop()) {
    for (let i2 = 0, len = children.length;i2 < len; ) {
      const child = children[i2++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome2(child.value)) {
            zero3 = f(zero3, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero3;
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet";
var HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
var HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys(this._keyMap);
  },
  [symbol]() {
    return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol2](that) {
    if (isHashSet(that)) {
      return size(this._keyMap) === size(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = (keyMap) => {
  const set2 = Object.create(HashSetProto);
  set2._keyMap = keyMap;
  return set2;
};
var isHashSet = (u3) => hasProperty(u3, HashSetTypeId);
var _empty4 = /* @__PURE__ */ makeImpl2(/* @__PURE__ */ empty6());
var empty7 = () => _empty4;
var fromIterable4 = (elements) => {
  const set2 = beginMutation2(empty7());
  for (const value of elements) {
    add3(set2, value);
  }
  return endMutation2(set2);
};
var make10 = (...elements) => {
  const set2 = beginMutation2(empty7());
  for (const value of elements) {
    add3(set2, value);
  }
  return endMutation2(set2);
};
var has2 = /* @__PURE__ */ dual(2, (self2, value) => has(self2._keyMap, value));
var size2 = (self2) => size(self2._keyMap);
var beginMutation2 = (self2) => makeImpl2(beginMutation(self2._keyMap));
var endMutation2 = (self2) => {
  self2._keyMap._editable = false;
  return self2;
};
var mutate2 = /* @__PURE__ */ dual(2, (self2, f) => {
  const transient = beginMutation2(self2);
  f(transient);
  return endMutation2(transient);
});
var add3 = /* @__PURE__ */ dual(2, (self2, value) => self2._keyMap._editable ? (set(value, true)(self2._keyMap), self2) : makeImpl2(set(value, true)(self2._keyMap)));
var remove3 = /* @__PURE__ */ dual(2, (self2, value) => self2._keyMap._editable ? (remove2(value)(self2._keyMap), self2) : makeImpl2(remove2(value)(self2._keyMap)));
var difference2 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(self2, (set2) => {
  for (const value of that) {
    remove3(set2, value);
  }
}));
var union3 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(empty7(), (set2) => {
  forEach2(self2, (value) => add3(set2, value));
  for (const value of that) {
    add3(set2, value);
  }
}));
var forEach2 = /* @__PURE__ */ dual(2, (self2, f) => forEach(self2._keyMap, (_2, k2) => f(k2)));
var reduce4 = /* @__PURE__ */ dual(3, (self2, zero3, f) => reduce3(self2._keyMap, zero3, (z4, _2, a) => f(z4, a)));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/HashSet.js
var isHashSet2 = isHashSet;
var empty8 = empty7;
var fromIterable5 = fromIterable4;
var make11 = make10;
var has3 = has2;
var size3 = size2;
var add4 = add3;
var remove4 = remove3;
var difference3 = difference2;
var union4 = union3;
var forEach3 = forEach2;
var reduce5 = reduce4;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/MutableRef.js
var TypeId7 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
var MutableRefProto = {
  [TypeId7]: TypeId7,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON(this.current)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make12 = (value) => {
  const ref = Object.create(MutableRefProto);
  ref.current = value;
  return ref;
};
var compareAndSet = /* @__PURE__ */ dual(3, (self2, oldValue, newValue) => {
  if (equals(oldValue, self2.current)) {
    self2.current = newValue;
    return true;
  }
  return false;
});
var get6 = (self2) => self2.current;
var set2 = /* @__PURE__ */ dual(2, (self2, value) => {
  self2.current = value;
  return self2;
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey = "effect/FiberId";
var FiberIdTypeId = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
var OP_NONE = "None";
var OP_RUNTIME = "Runtime";
var OP_COMPOSITE = "Composite";
var emptyHash = /* @__PURE__ */ string(`${FiberIdSymbolKey}-${OP_NONE}`);

class None {
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_NONE;
  id = -1;
  startTimeMillis = -1;
  [symbol]() {
    return emptyHash;
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_NONE;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}

class Runtime {
  id;
  startTimeMillis;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_RUNTIME;
  constructor(id, startTimeMillis) {
    this.id = id;
    this.startTimeMillis = startTimeMillis;
  }
  [symbol]() {
    return cached(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}

class Composite {
  left;
  right;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_COMPOSITE;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  _hash;
  [symbol]() {
    return pipe(string(`${FiberIdSymbolKey}-${this._tag}`), combine(hash(this.left)), combine(hash(this.right)), cached(this));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON(this.left),
      right: toJSON(this.right)
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}
var none3 = /* @__PURE__ */ new None;
var runtime = (id, startTimeMillis) => {
  return new Runtime(id, startTimeMillis);
};
var composite = (left3, right3) => {
  return new Composite(left3, right3);
};
var isFiberId = (self2) => hasProperty(self2, FiberIdTypeId);
var combine2 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2._tag === OP_NONE) {
    return that;
  }
  if (that._tag === OP_NONE) {
    return self2;
  }
  return new Composite(self2, that);
});
var ids = (self2) => {
  switch (self2._tag) {
    case OP_NONE: {
      return empty8();
    }
    case OP_RUNTIME: {
      return make11(self2.id);
    }
    case OP_COMPOSITE: {
      return pipe(ids(self2.left), union4(ids(self2.right)));
    }
  }
};
var _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make12(0));
var threadName = (self2) => {
  const identifiers = Array.from(ids(self2)).map((n) => `#${n}`).join(",");
  return identifiers;
};
var unsafeMake2 = () => {
  const id = get6(_fiberCounter);
  pipe(_fiberCounter, set2(id + 1));
  return new Runtime(id, Date.now());
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/FiberId.js
var none4 = none3;
var runtime2 = runtime;
var composite2 = composite;
var isFiberId2 = isFiberId;
var combine3 = combine2;
var threadName2 = threadName;
var unsafeMake3 = unsafeMake2;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/HashMap.js
var isHashMap2 = isHashMap;
var empty9 = empty6;
var fromIterable6 = fromIterable3;
var isEmpty3 = isEmpty2;
var get7 = get5;
var set3 = set;
var keys2 = keys;
var mutate3 = mutate;
var modifyAt2 = modifyAt;
var map6 = map4;
var forEach4 = forEach;
var reduce6 = reduce3;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/List.js
var TypeId8 = /* @__PURE__ */ Symbol.for("effect/List");
var toArray2 = (self2) => fromIterable(self2);
var getEquivalence5 = (isEquivalent) => mapInput(getEquivalence3(isEquivalent), toArray2);
var _equivalence4 = /* @__PURE__ */ getEquivalence5(equals);
var ConsProto = {
  [TypeId8]: TypeId8,
  _tag: "Cons",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: toArray2(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag && _equivalence4(this, that);
  },
  [symbol]() {
    return cached(this, array2(toArray2(this)));
  },
  [Symbol.iterator]() {
    let done = false;
    let self2 = this;
    return {
      next() {
        if (done) {
          return this.return();
        }
        if (self2._tag === "Nil") {
          done = true;
          return this.return();
        }
        const value = self2.head;
        self2 = self2.tail;
        return {
          done,
          value
        };
      },
      return(value) {
        if (!done) {
          done = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeCons = (head3, tail) => {
  const cons = Object.create(ConsProto);
  cons.head = head3;
  cons.tail = tail;
  return cons;
};
var NilHash = /* @__PURE__ */ string("Nil");
var NilProto = {
  [TypeId8]: TypeId8,
  _tag: "Nil",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol]() {
    return NilHash;
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: undefined
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _Nil = /* @__PURE__ */ Object.create(NilProto);
var isList = (u3) => hasProperty(u3, TypeId8);
var isNil = (self2) => self2._tag === "Nil";
var isCons = (self2) => self2._tag === "Cons";
var nil = () => _Nil;
var cons = (head3, tail) => makeCons(head3, tail);
var empty10 = nil;
var of3 = (value) => makeCons(value, _Nil);
var fromIterable7 = (prefix) => {
  const iterator = prefix[Symbol.iterator]();
  let next;
  if ((next = iterator.next()) && !next.done) {
    const result = makeCons(next.value, _Nil);
    let curr = result;
    while ((next = iterator.next()) && !next.done) {
      const temp = makeCons(next.value, _Nil);
      curr.tail = temp;
      curr = temp;
    }
    return result;
  } else {
    return _Nil;
  }
};
var appendAll3 = /* @__PURE__ */ dual(2, (self2, that) => prependAll(that, self2));
var prepend3 = /* @__PURE__ */ dual(2, (self2, element) => cons(element, self2));
var prependAll = /* @__PURE__ */ dual(2, (self2, prefix) => {
  if (isNil(self2)) {
    return prefix;
  } else if (isNil(prefix)) {
    return self2;
  } else {
    const result = makeCons(prefix.head, self2);
    let curr = result;
    let that = prefix.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self2);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
var reduce7 = /* @__PURE__ */ dual(3, (self2, zero3, f) => {
  let acc = zero3;
  let these = self2;
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reverse3 = (self2) => {
  let result = empty10();
  let these = self2;
  while (!isNil(these)) {
    result = prepend3(result, these.head);
    these = these.tail;
  }
  return result;
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/data.js
var ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
  [symbol]() {
    return cached(this, array2(this));
  },
  [symbol2](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v2, i2) => equals(v2, that[i2]));
    } else {
      return false;
    }
  }
});
var Structural = /* @__PURE__ */ function() {
  function Structural2(args2) {
    if (args2) {
      Object.assign(this, args2);
    }
  }
  Structural2.prototype = StructuralPrototype;
  return Structural2;
}();
var struct = (as) => Object.assign(Object.create(StructuralPrototype), as);

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/differ/chunkPatch.js
var ChunkPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferChunkPatch");
function variance(a) {
  return a;
}
var PatchProto = {
  ...Structural.prototype,
  [ChunkPatchTypeId]: {
    _Value: variance,
    _Patch: variance
  }
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/differ/contextPatch.js
var ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
function variance2(a) {
  return a;
}
var PatchProto2 = {
  ...Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: variance2,
    _Patch: variance2
  }
};
var EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Empty"
});
var _empty5 = /* @__PURE__ */ Object.create(EmptyProto);
var empty11 = () => _empty5;
var AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "AndThen"
});
var makeAndThen = (first, second) => {
  const o3 = Object.create(AndThenProto);
  o3.first = first;
  o3.second = second;
  return o3;
};
var AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "AddService"
});
var makeAddService = (key, service) => {
  const o3 = Object.create(AddServiceProto);
  o3.key = key;
  o3.service = service;
  return o3;
};
var RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "RemoveService"
});
var makeRemoveService = (key) => {
  const o3 = Object.create(RemoveServiceProto);
  o3.key = key;
  return o3;
};
var UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "UpdateService"
});
var makeUpdateService = (key, update) => {
  const o3 = Object.create(UpdateServiceProto);
  o3.key = key;
  o3.update = update;
  return o3;
};
var diff = (oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch = empty11();
  for (const [tag, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag)) {
      const old = missingServices.get(tag);
      missingServices.delete(tag);
      if (!equals(old, newService)) {
        patch = combine4(makeUpdateService(tag, () => newService))(patch);
      }
    } else {
      missingServices.delete(tag);
      patch = combine4(makeAddService(tag, newService))(patch);
    }
  }
  for (const [tag] of missingServices.entries()) {
    patch = combine4(makeRemoveService(tag))(patch);
  }
  return patch;
};
var combine4 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen(self2, that));
var patch = /* @__PURE__ */ dual(2, (self2, context) => {
  if (self2._tag === "Empty") {
    return context;
  }
  let wasServiceUpdated = false;
  let patches = of2(self2);
  const updatedContext = new Map(context.unsafeMap);
  while (isNonEmpty2(patches)) {
    const head3 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head3._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AddService": {
        updatedContext.set(head3.key, head3.service);
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend2(prepend2(tail, head3.second), head3.first);
        break;
      }
      case "RemoveService": {
        updatedContext.delete(head3.key);
        patches = tail;
        break;
      }
      case "UpdateService": {
        updatedContext.set(head3.key, head3.update(updatedContext.get(head3.key)));
        wasServiceUpdated = true;
        patches = tail;
        break;
      }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext(updatedContext);
  }
  const map7 = new Map;
  for (const [tag] of context.unsafeMap) {
    if (updatedContext.has(tag)) {
      map7.set(tag, updatedContext.get(tag));
      updatedContext.delete(tag);
    }
  }
  for (const [tag, s2] of updatedContext) {
    map7.set(tag, s2);
  }
  return makeContext(map7);
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/differ/hashMapPatch.js
var HashMapPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashMapPatch");
function variance3(a) {
  return a;
}
var PatchProto3 = {
  ...Structural.prototype,
  [HashMapPatchTypeId]: {
    _Value: variance3,
    _Key: variance3,
    _Patch: variance3
  }
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
var HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
function variance4(a) {
  return a;
}
var PatchProto4 = {
  ...Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: variance4,
    _Key: variance4,
    _Patch: variance4
  }
};
var EmptyProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "Empty"
});
var _empty6 = /* @__PURE__ */ Object.create(EmptyProto2);
var empty12 = () => _empty6;
var AndThenProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "AndThen"
});
var makeAndThen2 = (first, second) => {
  const o3 = Object.create(AndThenProto2);
  o3.first = first;
  o3.second = second;
  return o3;
};
var AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "Add"
});
var makeAdd = (value) => {
  const o3 = Object.create(AddProto);
  o3.value = value;
  return o3;
};
var RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "Remove"
});
var makeRemove = (value) => {
  const o3 = Object.create(RemoveProto);
  o3.value = value;
  return o3;
};
var diff2 = (oldValue, newValue) => {
  const [removed, patch2] = reduce5([oldValue, empty12()], ([set4, patch3], value) => {
    if (has3(value)(set4)) {
      return [remove4(value)(set4), patch3];
    }
    return [set4, combine5(makeAdd(value))(patch3)];
  })(newValue);
  return reduce5(patch2, (patch3, value) => combine5(makeRemove(value))(patch3))(removed);
};
var combine5 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen2(self2, that));
var patch2 = /* @__PURE__ */ dual(2, (self2, oldValue) => {
  if (self2._tag === "Empty") {
    return oldValue;
  }
  let set4 = oldValue;
  let patches = of2(self2);
  while (isNonEmpty2(patches)) {
    const head3 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head3._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend2(head3.first)(prepend2(head3.second)(tail));
        break;
      }
      case "Add": {
        set4 = add4(head3.value)(set4);
        patches = tail;
        break;
      }
      case "Remove": {
        set4 = remove4(head3.value)(set4);
        patches = tail;
      }
    }
  }
  return set4;
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/differ/orPatch.js
var OrPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferOrPatch");
function variance5(a) {
  return a;
}
var PatchProto5 = {
  ...Structural.prototype,
  [OrPatchTypeId]: {
    _Value: variance5,
    _Key: variance5,
    _Patch: variance5
  }
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
var ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
function variance6(a) {
  return a;
}
var PatchProto6 = {
  ...Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: variance6,
    _Patch: variance6
  }
};
var EmptyProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Empty"
});
var _empty7 = /* @__PURE__ */ Object.create(EmptyProto3);
var empty13 = () => _empty7;
var AndThenProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "AndThen"
});
var makeAndThen3 = (first, second) => {
  const o3 = Object.create(AndThenProto3);
  o3.first = first;
  o3.second = second;
  return o3;
};
var AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Append"
});
var makeAppend = (values3) => {
  const o3 = Object.create(AppendProto);
  o3.values = values3;
  return o3;
};
var SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Slice"
});
var makeSlice = (from, until) => {
  const o3 = Object.create(SliceProto);
  o3.from = from;
  o3.until = until;
  return o3;
};
var UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Update"
});
var makeUpdate = (index2, patch3) => {
  const o3 = Object.create(UpdateProto);
  o3.index = index2;
  o3.patch = patch3;
  return o3;
};
var diff3 = (options) => {
  let i2 = 0;
  let patch3 = empty13();
  while (i2 < options.oldValue.length && i2 < options.newValue.length) {
    const oldElement = options.oldValue[i2];
    const newElement = options.newValue[i2];
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options.differ.empty)) {
      patch3 = combine6(patch3, makeUpdate(i2, valuePatch));
    }
    i2 = i2 + 1;
  }
  if (i2 < options.oldValue.length) {
    patch3 = combine6(patch3, makeSlice(0, i2));
  }
  if (i2 < options.newValue.length) {
    patch3 = combine6(patch3, makeAppend(drop(i2)(options.newValue)));
  }
  return patch3;
};
var combine6 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen3(self2, that));
var patch3 = /* @__PURE__ */ dual(3, (self2, oldValue, differ) => {
  if (self2._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray = oldValue.slice();
  let patches = of(self2);
  while (isNonEmptyArray2(patches)) {
    const head3 = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head3._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        tail.unshift(head3.first, head3.second);
        patches = tail;
        break;
      }
      case "Append": {
        for (const value of head3.values) {
          readonlyArray.push(value);
        }
        patches = tail;
        break;
      }
      case "Slice": {
        readonlyArray = readonlyArray.slice(head3.from, head3.until);
        patches = tail;
        break;
      }
      case "Update": {
        readonlyArray[head3.index] = differ.patch(head3.patch, readonlyArray[head3.index]);
        patches = tail;
        break;
      }
    }
  }
  return readonlyArray;
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
var DifferProto = {
  [DifferTypeId]: {
    _P: identity,
    _V: identity
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make15 = (params) => {
  const differ = Object.create(DifferProto);
  differ.empty = params.empty;
  differ.diff = params.diff;
  differ.combine = params.combine;
  differ.patch = params.patch;
  return differ;
};
var environment = () => make15({
  empty: empty11(),
  combine: (first, second) => combine4(second)(first),
  diff: (oldValue, newValue) => diff(oldValue, newValue),
  patch: (patch7, oldValue) => patch(oldValue)(patch7)
});
var hashSet = () => make15({
  empty: empty12(),
  combine: (first, second) => combine5(second)(first),
  diff: (oldValue, newValue) => diff2(oldValue, newValue),
  patch: (patch7, oldValue) => patch2(oldValue)(patch7)
});
var readonlyArray = (differ) => make15({
  empty: empty13(),
  combine: (first, second) => combine6(first, second),
  diff: (oldValue, newValue) => diff3({
    oldValue,
    newValue,
    differ
  }),
  patch: (patch7, oldValue) => patch3(patch7, oldValue, differ)
});
var update = () => updateWith((_2, a) => a);
var updateWith = (f) => make15({
  empty: identity,
  combine: (first, second) => {
    if (first === identity) {
      return second;
    }
    if (second === identity) {
      return first;
    }
    return (a) => second(first(a));
  },
  diff: (oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return identity;
    }
    return constant(newValue);
  },
  patch: (patch7, oldValue) => f(oldValue, patch7(oldValue))
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
var BIT_MASK = 255;
var BIT_SHIFT = 8;
var active = (patch7) => patch7 & BIT_MASK;
var enabled = (patch7) => patch7 >> BIT_SHIFT & BIT_MASK;
var make16 = (active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT);
var empty17 = /* @__PURE__ */ make16(0, 0);
var enable = (flag) => make16(flag, flag);
var disable = (flag) => make16(flag, 0);
var exclude = /* @__PURE__ */ dual(2, (self2, flag) => make16(active(self2) & ~flag, enabled(self2)));
var andThen = /* @__PURE__ */ dual(2, (self2, that) => self2 | that);
var invert = (n) => ~n >>> 0 & BIT_MASK;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/runtimeFlags.js
var None2 = 0;
var Interruption = 1 << 0;
var OpSupervision = 1 << 1;
var RuntimeMetrics = 1 << 2;
var WindDown = 1 << 4;
var CooperativeYielding = 1 << 5;
var cooperativeYielding = (self2) => isEnabled(self2, CooperativeYielding);
var disable2 = /* @__PURE__ */ dual(2, (self2, flag) => self2 & ~flag);
var enable2 = /* @__PURE__ */ dual(2, (self2, flag) => self2 | flag);
var interruptible = (self2) => interruption(self2) && !windDown(self2);
var interruption = (self2) => isEnabled(self2, Interruption);
var isEnabled = /* @__PURE__ */ dual(2, (self2, flag) => (self2 & flag) !== 0);
var make17 = (...flags2) => flags2.reduce((a, b3) => a | b3, 0);
var none5 = /* @__PURE__ */ make17(None2);
var runtimeMetrics = (self2) => isEnabled(self2, RuntimeMetrics);
var windDown = (self2) => isEnabled(self2, WindDown);
var diff7 = /* @__PURE__ */ dual(2, (self2, that) => make16(self2 ^ that, that));
var patch7 = /* @__PURE__ */ dual(2, (self2, patch8) => self2 & (invert(active(patch8)) | enabled(patch8)) | active(patch8) & enabled(patch8));
var differ = /* @__PURE__ */ make15({
  empty: empty17,
  diff: (oldValue, newValue) => diff7(oldValue, newValue),
  combine: (first, second) => andThen(second)(first),
  patch: (_patch, oldValue) => patch7(oldValue, _patch)
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var empty18 = empty17;
var enable3 = enable;
var disable3 = disable;
var exclude2 = exclude;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/blockedRequests.js
var empty19 = {
  _tag: "Empty"
};
var par = (self2, that) => ({
  _tag: "Par",
  left: self2,
  right: that
});
var seq = (self2, that) => ({
  _tag: "Seq",
  left: self2,
  right: that
});
var single = (dataSource, blockedRequest) => ({
  _tag: "Single",
  dataSource,
  blockedRequest
});
var flatten3 = (self2) => {
  let current = of3(self2);
  let updated = empty10();
  while (true) {
    const [parallel, sequential] = reduce7(current, [parallelCollectionEmpty(), empty10()], ([parallel2, sequential2], blockedRequest) => {
      const [par2, seq2] = step(blockedRequest);
      return [parallelCollectionCombine(parallel2, par2), appendAll3(sequential2, seq2)];
    });
    updated = merge4(updated, parallel);
    if (isNil(sequential)) {
      return reverse3(updated);
    }
    current = sequential;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var step = (requests) => {
  let current = requests;
  let parallel = parallelCollectionEmpty();
  let stack = empty10();
  let sequential = empty10();
  while (true) {
    switch (current._tag) {
      case "Empty": {
        if (isNil(stack)) {
          return [parallel, sequential];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
      case "Par": {
        stack = cons(current.right, stack);
        current = current.left;
        break;
      }
      case "Seq": {
        const left3 = current.left;
        const right3 = current.right;
        switch (left3._tag) {
          case "Empty": {
            current = right3;
            break;
          }
          case "Par": {
            const l3 = left3.left;
            const r2 = left3.right;
            current = par(seq(l3, right3), seq(r2, right3));
            break;
          }
          case "Seq": {
            const l3 = left3.left;
            const r2 = left3.right;
            current = seq(l3, seq(r2, right3));
            break;
          }
          case "Single": {
            current = left3;
            sequential = cons(right3, sequential);
            break;
          }
        }
        break;
      }
      case "Single": {
        parallel = parallelCollectionAdd(parallel, current);
        if (isNil(stack)) {
          return [parallel, sequential];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var merge4 = (sequential, parallel) => {
  if (isNil(sequential)) {
    return of3(parallelCollectionToSequentialCollection(parallel));
  }
  if (parallelCollectionIsEmpty(parallel)) {
    return sequential;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential.head);
  const parKeys = parallelCollectionKeys(parallel);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential.head, parallelCollectionToSequentialCollection(parallel)), sequential.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel), sequential);
};
var EntryTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/Entry");

class EntryImpl {
  request;
  result;
  listeners;
  ownerId;
  state;
  [EntryTypeId] = blockedRequestVariance;
  constructor(request, result, listeners, ownerId, state) {
    this.request = request;
    this.result = result;
    this.listeners = listeners;
    this.ownerId = ownerId;
    this.state = state;
  }
}
var blockedRequestVariance = {
  _R: (_2) => _2
};
var makeEntry = (options) => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state);
var RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
var parallelVariance = {
  _R: (_2) => _2
};

class ParallelImpl {
  map;
  [RequestBlockParallelTypeId] = parallelVariance;
  constructor(map7) {
    this.map = map7;
  }
}
var parallelCollectionEmpty = () => new ParallelImpl(empty9());
var parallelCollectionAdd = (self2, blockedRequest) => new ParallelImpl(modifyAt2(self2.map, blockedRequest.dataSource, (_2) => orElseSome(map2(_2, append2(blockedRequest.blockedRequest)), () => of2(blockedRequest.blockedRequest))));
var parallelCollectionCombine = (self2, that) => new ParallelImpl(reduce6(self2.map, that.map, (map7, value, key) => set3(map7, key, match2(get7(map7, key), {
  onNone: () => value,
  onSome: (other) => appendAll2(value, other)
}))));
var parallelCollectionIsEmpty = (self2) => isEmpty3(self2.map);
var parallelCollectionKeys = (self2) => Array.from(keys2(self2.map));
var parallelCollectionToSequentialCollection = (self2) => sequentialCollectionMake(map6(self2.map, (x3) => of2(x3)));
var SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
var sequentialVariance = {
  _R: (_2) => _2
};

class SequentialImpl {
  map;
  [SequentialCollectionTypeId] = sequentialVariance;
  constructor(map7) {
    this.map = map7;
  }
}
var sequentialCollectionMake = (map7) => new SequentialImpl(map7);
var sequentialCollectionCombine = (self2, that) => new SequentialImpl(reduce6(that.map, self2.map, (map7, value, key) => set3(map7, key, match2(get7(map7, key), {
  onNone: () => empty5(),
  onSome: (a) => appendAll2(a, value)
}))));
var sequentialCollectionKeys = (self2) => Array.from(keys2(self2.map));
var sequentialCollectionToChunk = (self2) => Array.from(self2.map);

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE = "Die";
var OP_EMPTY = "Empty";
var OP_FAIL = "Fail";
var OP_INTERRUPT = "Interrupt";
var OP_PARALLEL = "Parallel";
var OP_SEQUENTIAL = "Sequential";

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause";
var CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
var variance7 = {
  _E: (_2) => _2
};
var proto = {
  [CauseTypeId]: variance7,
  [symbol]() {
    return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
  },
  [symbol2](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var empty20 = /* @__PURE__ */ (() => {
  const o3 = /* @__PURE__ */ Object.create(proto);
  o3._tag = OP_EMPTY;
  return o3;
})();
var fail = (error) => {
  const o3 = Object.create(proto);
  o3._tag = OP_FAIL;
  o3.error = error;
  return o3;
};
var die = (defect) => {
  const o3 = Object.create(proto);
  o3._tag = OP_DIE;
  o3.defect = defect;
  return o3;
};
var interrupt = (fiberId) => {
  const o3 = Object.create(proto);
  o3._tag = OP_INTERRUPT;
  o3.fiberId = fiberId;
  return o3;
};
var parallel = (left3, right3) => {
  const o3 = Object.create(proto);
  o3._tag = OP_PARALLEL;
  o3.left = left3;
  o3.right = right3;
  return o3;
};
var sequential = (left3, right3) => {
  const o3 = Object.create(proto);
  o3._tag = OP_SEQUENTIAL;
  o3.left = left3;
  o3.right = right3;
  return o3;
};
var isCause = (u3) => hasProperty(u3, CauseTypeId);
var isEmptyType = (self2) => self2._tag === OP_EMPTY;
var isFailType = (self2) => self2._tag === OP_FAIL;
var isDieType = (self2) => self2._tag === OP_DIE;
var isEmpty5 = (self2) => {
  if (self2._tag === OP_EMPTY) {
    return true;
  }
  return reduce8(self2, true, (acc, cause) => {
    switch (cause._tag) {
      case OP_EMPTY: {
        return some2(acc);
      }
      case OP_DIE:
      case OP_FAIL:
      case OP_INTERRUPT: {
        return some2(false);
      }
      default: {
        return none2();
      }
    }
  });
};
var isInterrupted = (self2) => isSome2(interruptOption(self2));
var isInterruptedOnly = (self2) => reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)(self2);
var failures = (self2) => reverse2(reduce8(self2, empty5(), (list, cause) => cause._tag === OP_FAIL ? some2(pipe(list, prepend2(cause.error))) : none2()));
var defects = (self2) => reverse2(reduce8(self2, empty5(), (list, cause) => cause._tag === OP_DIE ? some2(pipe(list, prepend2(cause.defect))) : none2()));
var interruptors = (self2) => reduce8(self2, empty8(), (set4, cause) => cause._tag === OP_INTERRUPT ? some2(pipe(set4, add4(cause.fiberId))) : none2());
var failureOption = (self2) => find(self2, (cause) => cause._tag === OP_FAIL ? some2(cause.error) : none2());
var failureOrCause = (self2) => {
  const option = failureOption(self2);
  switch (option._tag) {
    case "None": {
      return right2(self2);
    }
    case "Some": {
      return left2(option.value);
    }
  }
};
var interruptOption = (self2) => find(self2, (cause) => cause._tag === OP_INTERRUPT ? some2(cause.fiberId) : none2());
var keepDefects = (self2) => match5(self2, {
  onEmpty: none2(),
  onFail: () => none2(),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var keepDefectsAndElectFailures = (self2) => match5(self2, {
  onEmpty: none2(),
  onFail: (failure) => some2(die(failure)),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var stripFailures = (self2) => match5(self2, {
  onEmpty: empty20,
  onFail: () => empty20,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var electFailures = (self2) => match5(self2, {
  onEmpty: empty20,
  onFail: die,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var flatMap6 = /* @__PURE__ */ dual(2, (self2, f) => match5(self2, {
  onEmpty: empty20,
  onFail: (error) => f(error),
  onDie: (defect) => die(defect),
  onInterrupt: (fiberId) => interrupt(fiberId),
  onSequential: (left3, right3) => sequential(left3, right3),
  onParallel: (left3, right3) => parallel(left3, right3)
}));
var flatten4 = (self2) => flatMap6(self2, identity);
var causeEquals = (left3, right3) => {
  let leftStack = of2(left3);
  let rightStack = of2(right3);
  while (isNonEmpty2(leftStack) && isNonEmpty2(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce8([empty8(), empty5()], ([parallel2, sequential2], cause) => {
      const [par2, seq2] = evaluateCause(cause);
      return some2([pipe(parallel2, union4(par2)), pipe(sequential2, appendAll2(seq2))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce8([empty8(), empty5()], ([parallel2, sequential2], cause) => {
      const [par2, seq2] = evaluateCause(cause);
      return some2([pipe(parallel2, union4(par2)), pipe(sequential2, appendAll2(seq2))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
};
var flattenCause = (cause) => {
  return flattenCauseLoop(of2(cause), empty5());
};
var flattenCauseLoop = (causes, flattened) => {
  while (true) {
    const [parallel2, sequential2] = pipe(causes, reduce([empty8(), empty5()], ([parallel3, sequential3], cause) => {
      const [par2, seq2] = evaluateCause(cause);
      return [pipe(parallel3, union4(par2)), pipe(sequential3, appendAll2(seq2))];
    }));
    const updated = size3(parallel2) > 0 ? pipe(flattened, prepend2(parallel2)) : flattened;
    if (isEmpty(sequential2)) {
      return reverse2(updated);
    }
    causes = sequential2;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
var find = /* @__PURE__ */ dual(2, (self2, pf) => {
  const stack = [self2];
  while (stack.length > 0) {
    const item = stack.pop();
    const option = pf(item);
    switch (option._tag) {
      case "None": {
        switch (item._tag) {
          case OP_SEQUENTIAL:
          case OP_PARALLEL: {
            stack.push(item.right);
            stack.push(item.left);
            break;
          }
        }
        break;
      }
      case "Some": {
        return option;
      }
    }
  }
  return none2();
});
var evaluateCause = (self2) => {
  let cause = self2;
  const stack = [];
  let _parallel = empty8();
  let _sequential = empty5();
  while (cause !== undefined) {
    switch (cause._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add4(_parallel, make7(cause._tag, cause.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add4(_parallel, make7(cause._tag, cause.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add4(_parallel, make7(cause._tag, cause.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause.left._tag) {
          case OP_EMPTY: {
            cause = cause.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));
            break;
          }
          case OP_PARALLEL: {
            cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));
            break;
          }
          default: {
            _sequential = prepend2(_sequential, cause.right);
            cause = cause.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause.right);
        cause = cause.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
var IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: (_2, left3, right3) => left3 && right3,
  parallelCase: (_2, left3, right3) => left3 && right3
};
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
var match5 = /* @__PURE__ */ dual(2, (self2, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt,
  onParallel,
  onSequential
}) => {
  return reduceWithContext(self2, undefined, {
    emptyCase: () => onEmpty,
    failCase: (_2, error) => onFail(error),
    dieCase: (_2, defect) => onDie(defect),
    interruptCase: (_2, fiberId) => onInterrupt(fiberId),
    sequentialCase: (_2, left3, right3) => onSequential(left3, right3),
    parallelCase: (_2, left3, right3) => onParallel(left3, right3)
  });
});
var reduce8 = /* @__PURE__ */ dual(3, (self2, zero3, pf) => {
  let accumulator = zero3;
  let cause = self2;
  const causes = [];
  while (cause !== undefined) {
    const option = pf(accumulator, cause);
    accumulator = isSome2(option) ? option.value : accumulator;
    switch (cause._tag) {
      case OP_SEQUENTIAL: {
        causes.push(cause.right);
        cause = cause.left;
        break;
      }
      case OP_PARALLEL: {
        causes.push(cause.right);
        cause = cause.left;
        break;
      }
      default: {
        cause = undefined;
        break;
      }
    }
    if (cause === undefined && causes.length > 0) {
      cause = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext = /* @__PURE__ */ dual(3, (self2, context, reducer) => {
  const input = [self2];
  const output = [];
  while (input.length > 0) {
    const cause = input.pop();
    switch (cause._tag) {
      case OP_EMPTY: {
        output.push(right2(reducer.emptyCase(context)));
        break;
      }
      case OP_FAIL: {
        output.push(right2(reducer.failCase(context, cause.error)));
        break;
      }
      case OP_DIE: {
        output.push(right2(reducer.dieCase(context, cause.defect)));
        break;
      }
      case OP_INTERRUPT: {
        output.push(right2(reducer.interruptCase(context, cause.fiberId)));
        break;
      }
      case OP_SEQUENTIAL: {
        input.push(cause.right);
        input.push(cause.left);
        output.push(left2({
          _tag: OP_SEQUENTIAL_CASE
        }));
        break;
      }
      case OP_PARALLEL: {
        input.push(cause.right);
        input.push(cause.left);
        output.push(left2({
          _tag: OP_PARALLEL_CASE
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either2 = output.pop();
    switch (either2._tag) {
      case "Left": {
        switch (either2.left._tag) {
          case OP_SEQUENTIAL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.sequentialCase(context, left3, right3);
            accumulator.push(value);
            break;
          }
          case OP_PARALLEL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.parallelCase(context, left3, right3);
            accumulator.push(value);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either2.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var pretty = (cause, options) => {
  if (isInterruptedOnly(cause)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause).map(function(e) {
    if (options?.renderErrorCause !== true || e.cause === undefined) {
      return e.stack;
    }
    return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
  }).join(`
`);
};
var renderErrorCause = (cause, prefix) => {
  const lines = cause.stack.split(`
`);
  let stack = `${prefix}[cause]: ${lines[0]}`;
  for (let i2 = 1, len = lines.length;i2 < len; i2++) {
    stack += `
${prefix}${lines[i2]}`;
  }
  if (cause.cause) {
    stack += ` {
${renderErrorCause(cause.cause, `${prefix}  `)}
${prefix}}`;
  }
  return stack;
};

class PrettyError extends globalThis.Error {
  span = undefined;
  constructor(originalError) {
    const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
      cause: new PrettyError(originalError.cause)
    } : undefined);
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError instanceof Error ? originalError.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol in originalError) {
        this.span = originalError[spanSymbol];
      }
      Object.keys(originalError).forEach((key) => {
        if (!(key in this)) {
          this[key] = originalError[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
  }
}
var prettyErrorMessage = (u3) => {
  if (typeof u3 === "string") {
    return u3;
  }
  if (typeof u3 === "object" && u3 !== null && u3 instanceof Error) {
    return u3.message;
  }
  try {
    if (hasProperty(u3, "toString") && isFunction2(u3["toString"]) && u3["toString"] !== Object.prototype.toString && u3["toString"] !== globalThis.Array.prototype.toString) {
      return u3["toString"]();
    }
  } catch {
  }
  return stringifyCircular(u3);
};
var locationRegex = /\((.*)\)/g;
var spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => new WeakMap);
var prettyErrorStack = (message, stack, span2) => {
  const out2 = [message];
  const lines = stack.startsWith(message) ? stack.slice(message.length).split(`
`) : stack.split(`
`);
  for (let i2 = 1;i2 < lines.length; i2++) {
    if (lines[i2].includes(" at new BaseEffectError") || lines[i2].includes(" at new YieldableError")) {
      i2++;
      continue;
    }
    if (lines[i2].includes("Generator.next")) {
      break;
    }
    if (lines[i2].includes("effect_internal_function")) {
      break;
    }
    out2.push(lines[i2].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span2) {
    let current = span2;
    let i2 = 0;
    while (current && current._tag === "Span" && i2 < 10) {
      const stackFn = spanToTrace.get(current);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex);
          let match6 = false;
          for (const [, location2] of locationMatchAll) {
            match6 = true;
            out2.push(`    at ${current.name} (${location2})`);
          }
          if (!match6) {
            out2.push(`    at ${current.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out2.push(`    at ${current.name}`);
        }
      } else {
        out2.push(`    at ${current.name}`);
      }
      current = getOrUndefined(current.parent);
      i2++;
    }
  }
  return out2.join(`
`);
};
var spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
var prettyErrors = (cause) => reduceWithContext(cause, undefined, {
  emptyCase: () => [],
  dieCase: (_2, unknownError) => {
    return [new PrettyError(unknownError)];
  },
  failCase: (_2, error) => {
    return [new PrettyError(error)];
  },
  interruptCase: () => [],
  parallelCase: (_2, l3, r2) => [...l3, ...r2],
  sequentialCase: (_2, l3, r2) => [...l3, ...r2]
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/opCodes/deferred.js
var OP_STATE_PENDING = "Pending";
var OP_STATE_DONE = "Done";

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey = "effect/Deferred";
var DeferredTypeId = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
var deferredVariance = {
  _E: (_2) => _2,
  _A: (_2) => _2
};
var pending = (joiners) => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
};
var done = (effect) => {
  return {
    _tag: OP_STATE_DONE,
    effect
  };
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/singleShotGen.js
class SingleShotGen2 {
  self;
  called = false;
  constructor(self2) {
    this.self = self2;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(this.self);
  }
}

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/core.js
var blocked = (blockedRequests, _continue) => {
  const effect = new EffectPrimitive("Blocked");
  effect.effect_instruction_i0 = blockedRequests;
  effect.effect_instruction_i1 = _continue;
  return effect;
};
var runRequestBlock = (blockedRequests) => {
  const effect = new EffectPrimitive("RunBlocked");
  effect.effect_instruction_i0 = blockedRequests;
  return effect;
};
var EffectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Effect");

class RevertFlags {
  patch;
  op;
  _op = OP_REVERT_FLAGS;
  constructor(patch8, op) {
    this.patch = patch8;
    this.op = op;
  }
}

class EffectPrimitive {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
}

class EffectPrimitiveFailure {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Failure" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(string(this._tag), combine(hash(this.effect_instruction_i0)), cached(this));
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
}

class EffectPrimitiveSuccess {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Success" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(string(this._tag), combine(hash(this.effect_instruction_i0)), cached(this));
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
}
var isEffect = (u3) => hasProperty(u3, EffectTypeId2);
var withFiberRuntime = (withRuntime) => {
  const effect = new EffectPrimitive(OP_WITH_RUNTIME);
  effect.effect_instruction_i0 = withRuntime;
  return effect;
};
var acquireUseRelease = /* @__PURE__ */ dual(3, (acquire, use, release) => uninterruptibleMask((restore) => flatMap7(acquire, (a) => flatMap7(exit(suspend(() => restore(use(a)))), (exit) => {
  return suspend(() => release(a, exit)).pipe(matchCauseEffect({
    onFailure: (cause) => {
      switch (exit._tag) {
        case OP_FAILURE:
          return failCause(sequential(exit.effect_instruction_i0, cause));
        case OP_SUCCESS:
          return failCause(cause);
      }
    },
    onSuccess: () => exit
  }));
}))));
var as = /* @__PURE__ */ dual(2, (self2, value) => flatMap7(self2, () => succeed(value)));
var asVoid = (self2) => as(self2, undefined);
var custom = function() {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.commit = arguments[1];
      break;
    }
    case 3: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.commit = arguments[2];
      break;
    }
    case 4: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.effect_instruction_i2 = arguments[2];
      wrapper.commit = arguments[3];
      break;
    }
    default: {
      throw new Error(getBugErrorMessage("you're not supposed to end up here"));
    }
  }
  return wrapper;
};
var unsafeAsync = (register, blockingOn = none4) => {
  const effect = new EffectPrimitive(OP_ASYNC);
  let cancelerRef = undefined;
  effect.effect_instruction_i0 = (resume) => {
    cancelerRef = register(resume);
  };
  effect.effect_instruction_i1 = blockingOn;
  return onInterrupt(effect, (_2) => isEffect(cancelerRef) ? cancelerRef : void_);
};
var asyncInterrupt = (register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn));
var async_ = (resume, blockingOn = none4) => {
  return custom(resume, function() {
    let backingResume = undefined;
    let pendingEffect = undefined;
    function proxyResume(effect2) {
      if (backingResume) {
        backingResume(effect2);
      } else if (pendingEffect === undefined) {
        pendingEffect = effect2;
      }
    }
    const effect = new EffectPrimitive(OP_ASYNC);
    effect.effect_instruction_i0 = (resume2) => {
      backingResume = resume2;
      if (pendingEffect) {
        resume2(pendingEffect);
      }
    };
    effect.effect_instruction_i1 = blockingOn;
    let cancelerRef = undefined;
    let controllerRef = undefined;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController;
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
    } else {
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
    }
    return cancelerRef || controllerRef ? onInterrupt(effect, (_2) => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_;
    }) : effect;
  });
};
var catchAllCause = /* @__PURE__ */ dual(2, (self2, f) => {
  const effect = new EffectPrimitive(OP_ON_FAILURE);
  effect.effect_instruction_i0 = self2;
  effect.effect_instruction_i1 = f;
  return effect;
});
var catchAll = /* @__PURE__ */ dual(2, (self2, f) => matchEffect(self2, {
  onFailure: f,
  onSuccess: succeed
}));
var catchIf = /* @__PURE__ */ dual(3, (self2, predicate, f) => catchAllCause(self2, (cause) => {
  const either2 = failureOrCause(cause);
  switch (either2._tag) {
    case "Left":
      return predicate(either2.left) ? f(either2.left) : failCause(cause);
    case "Right":
      return failCause(either2.right);
  }
}));
var catchSome = /* @__PURE__ */ dual(2, (self2, pf) => catchAllCause(self2, (cause) => {
  const either2 = failureOrCause(cause);
  switch (either2._tag) {
    case "Left":
      return pipe(pf(either2.left), getOrElse(() => failCause(cause)));
    case "Right":
      return failCause(either2.right);
  }
}));
var checkInterruptible = (f) => withFiberRuntime((_2, status) => f(interruption(status.runtimeFlags)));
var originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
var capture = (obj, span2) => {
  if (isSome2(span2)) {
    return new Proxy(obj, {
      has(target, p) {
        return p === spanSymbol || p === originalSymbol || p in target;
      },
      get(target, p) {
        if (p === spanSymbol) {
          return span2.value;
        }
        if (p === originalSymbol) {
          return obj;
        }
        return target[p];
      }
    });
  }
  return obj;
};
var die2 = (defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect));
var dieMessage = (message) => failCauseSync(() => die(new RuntimeException(message)));
var dieSync = (evaluate) => flatMap7(sync(evaluate), die2);
var either2 = (self2) => matchEffect(self2, {
  onFailure: (e) => succeed(left2(e)),
  onSuccess: (a) => succeed(right2(a))
});
var exit = (self2) => matchCause(self2, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
});
var fail2 = (error) => isObject(error) && !(spanSymbol in error) ? withFiberRuntime((fiber) => failCause(fail(capture(error, currentSpanFromFiber(fiber))))) : failCause(fail(error));
var failSync = (evaluate) => flatMap7(sync(evaluate), fail2);
var failCause = (cause) => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause;
  return effect;
};
var failCauseSync = (evaluate) => flatMap7(sync(evaluate), failCause);
var fiberId = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.id()));
var fiberIdWith = (f) => withFiberRuntime((state) => f(state.id()));
var flatMap7 = /* @__PURE__ */ dual(2, (self2, f) => {
  const effect = new EffectPrimitive(OP_ON_SUCCESS);
  effect.effect_instruction_i0 = self2;
  effect.effect_instruction_i1 = f;
  return effect;
});
var andThen2 = /* @__PURE__ */ dual(2, (self2, f) => flatMap7(self2, (a) => {
  const b3 = typeof f === "function" ? f(a) : f;
  if (isEffect(b3)) {
    return b3;
  } else if (isPromiseLike(b3)) {
    return unsafeAsync((resume) => {
      b3.then((a2) => resume(succeed(a2)), (e) => resume(fail2(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
    });
  }
  return succeed(b3);
}));
var step2 = (self2) => {
  const effect = new EffectPrimitive("OnStep");
  effect.effect_instruction_i0 = self2;
  return effect;
};
var flatten5 = (self2) => flatMap7(self2, identity);
var flip = (self2) => matchEffect(self2, {
  onFailure: succeed,
  onSuccess: fail2
});
var matchCause = /* @__PURE__ */ dual(2, (self2, options) => matchCauseEffect(self2, {
  onFailure: (cause) => succeed(options.onFailure(cause)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var matchCauseEffect = /* @__PURE__ */ dual(2, (self2, options) => {
  const effect = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
  effect.effect_instruction_i0 = self2;
  effect.effect_instruction_i1 = options.onFailure;
  effect.effect_instruction_i2 = options.onSuccess;
  return effect;
});
var matchEffect = /* @__PURE__ */ dual(2, (self2, options) => matchCauseEffect(self2, {
  onFailure: (cause) => {
    const defects2 = defects(cause);
    if (defects2.length > 0) {
      return failCause(electFailures(cause));
    }
    const failures2 = failures(cause);
    if (failures2.length > 0) {
      return options.onFailure(unsafeHead2(failures2));
    }
    return failCause(cause);
  },
  onSuccess: options.onSuccess
}));
var forEachSequential = /* @__PURE__ */ dual(2, (self2, f) => suspend(() => {
  const arr = fromIterable(self2);
  const ret = allocate(arr.length);
  let i2 = 0;
  return as(whileLoop({
    while: () => i2 < arr.length,
    body: () => f(arr[i2], i2),
    step: (b3) => {
      ret[i2++] = b3;
    }
  }), ret);
}));
var forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self2, f) => suspend(() => {
  const arr = fromIterable(self2);
  let i2 = 0;
  return whileLoop({
    while: () => i2 < arr.length,
    body: () => f(arr[i2], i2),
    step: () => {
      i2++;
    }
  });
}));
var if_ = /* @__PURE__ */ dual((args2) => typeof args2[0] === "boolean" || isEffect(args2[0]), (self2, options) => isEffect(self2) ? flatMap7(self2, (b3) => b3 ? options.onTrue() : options.onFalse()) : self2 ? options.onTrue() : options.onFalse());
var interrupt2 = /* @__PURE__ */ flatMap7(fiberId, (fiberId2) => interruptWith(fiberId2));
var interruptWith = (fiberId2) => failCause(interrupt(fiberId2));
var interruptible2 = (self2) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = enable3(Interruption);
  effect.effect_instruction_i1 = () => self2;
  return effect;
};
var interruptibleMask = (f) => custom(f, function() {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = enable3(Interruption);
  effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect;
});
var intoDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => uninterruptibleMask((restore) => flatMap7(exit(restore(self2)), (exit2) => deferredDone(deferred, exit2))));
var map9 = /* @__PURE__ */ dual(2, (self2, f) => flatMap7(self2, (a) => sync(() => f(a))));
var mapBoth2 = /* @__PURE__ */ dual(2, (self2, options) => matchEffect(self2, {
  onFailure: (e) => failSync(() => options.onFailure(e)),
  onSuccess: (a) => sync(() => options.onSuccess(a))
}));
var mapError = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause) => {
    const either3 = failureOrCause(cause);
    switch (either3._tag) {
      case "Left": {
        return failSync(() => f(either3.left));
      }
      case "Right": {
        return failCause(either3.right);
      }
    }
  },
  onSuccess: succeed
}));
var onError = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit(self2, (exit2) => exitIsSuccess(exit2) ? void_ : cleanup(exit2.effect_instruction_i0)));
var onExit = /* @__PURE__ */ dual(2, (self2, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self2), {
  onFailure: (cause1) => {
    const result = exitFailCause(cause1);
    return matchCauseEffect(cleanup(result), {
      onFailure: (cause2) => exitFailCause(sequential(cause1, cause2)),
      onSuccess: () => result
    });
  },
  onSuccess: (success) => {
    const result = exitSucceed(success);
    return zipRight(cleanup(result), result);
  }
})));
var onInterrupt = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit(self2, exitMatch({
  onFailure: (cause) => isInterruptedOnly(cause) ? asVoid(cleanup(interruptors(cause))) : void_,
  onSuccess: () => void_
})));
var orElse2 = /* @__PURE__ */ dual(2, (self2, that) => attemptOrElse(self2, that, succeed));
var orDie = (self2) => orDieWith(self2, identity);
var orDieWith = /* @__PURE__ */ dual(2, (self2, f) => matchEffect(self2, {
  onFailure: (e) => die2(f(e)),
  onSuccess: succeed
}));
var partitionMap2 = partitionMap;
var runtimeFlags = /* @__PURE__ */ withFiberRuntime((_2, status) => succeed(status.runtimeFlags));
var succeed = (value) => {
  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
};
var suspend = (evaluate) => {
  const effect = new EffectPrimitive(OP_COMMIT);
  effect.commit = evaluate;
  return effect;
};
var sync = (thunk) => {
  const effect = new EffectPrimitive(OP_SYNC);
  effect.effect_instruction_i0 = thunk;
  return effect;
};
var tap = /* @__PURE__ */ dual((args2) => args2.length === 3 || args2.length === 2 && !(isObject(args2[1]) && ("onlyEffect" in args2[1])), (self2, f) => flatMap7(self2, (a) => {
  const b3 = typeof f === "function" ? f(a) : f;
  if (isEffect(b3)) {
    return as(b3, a);
  } else if (isPromiseLike(b3)) {
    return unsafeAsync((resume) => {
      b3.then((_2) => resume(succeed(a)), (e) => resume(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
    });
  }
  return succeed(a);
}));
var transplant = (f) => withFiberRuntime((state) => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride);
  const scope = pipe(scopeOverride, getOrElse(() => state.scope()));
  return f(fiberRefLocally(currentForkScopeOverride, some2(scope)));
});
var attemptOrElse = /* @__PURE__ */ dual(3, (self2, that, onSuccess) => matchCauseEffect(self2, {
  onFailure: (cause) => {
    const defects2 = defects(cause);
    if (defects2.length > 0) {
      return failCause(getOrThrow2(keepDefectsAndElectFailures(cause)));
    }
    return that();
  },
  onSuccess
}));
var uninterruptible = (self2) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = disable3(Interruption);
  effect.effect_instruction_i1 = () => self2;
  return effect;
};
var uninterruptibleMask = (f) => custom(f, function() {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = disable3(Interruption);
  effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect;
});
var void_ = /* @__PURE__ */ succeed(undefined);
var updateRuntimeFlags = (patch8) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = patch8;
  effect.effect_instruction_i1 = undefined;
  return effect;
};
var whenEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap7(condition, (b3) => {
  if (b3) {
    return pipe(self2, map9(some2));
  }
  return succeed(none2());
}));
var whileLoop = (options) => {
  const effect = new EffectPrimitive(OP_WHILE);
  effect.effect_instruction_i0 = options.while;
  effect.effect_instruction_i1 = options.body;
  effect.effect_instruction_i2 = options.step;
  return effect;
};
var fromIterator = (iterator) => suspend(() => {
  const effect = new EffectPrimitive(OP_ITERATOR);
  effect.effect_instruction_i0 = iterator();
  return effect;
});
var gen = function() {
  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
  return fromIterator(() => f(pipe));
};
var fnUntraced = (body2, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args2) {
  return fromIterator(() => body2.apply(this, args2));
} : function(...args2) {
  let effect = fromIterator(() => body2.apply(this, args2));
  for (const x3 of pipeables) {
    effect = x3(effect, ...args2);
  }
  return effect;
}, "length", {
  value: body2.length,
  configurable: true
});
var withConcurrency = /* @__PURE__ */ dual(2, (self2, concurrency) => fiberRefLocally(self2, currentConcurrency, concurrency));
var withRequestBatching = /* @__PURE__ */ dual(2, (self2, requestBatching) => fiberRefLocally(self2, currentRequestBatching, requestBatching));
var withRuntimeFlags = /* @__PURE__ */ dual(2, (self2, update2) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = update2;
  effect.effect_instruction_i1 = () => self2;
  return effect;
});
var withTracerEnabled = /* @__PURE__ */ dual(2, (effect, enabled2) => fiberRefLocally(effect, currentTracerEnabled, enabled2));
var withTracerTiming = /* @__PURE__ */ dual(2, (effect, enabled2) => fiberRefLocally(effect, currentTracerTimingEnabled, enabled2));
var yieldNow = (options) => {
  const effect = new EffectPrimitive(OP_YIELD);
  return typeof options?.priority !== "undefined" ? withSchedulingPriority(effect, options.priority) : effect;
};
var zip2 = /* @__PURE__ */ dual(2, (self2, that) => flatMap7(self2, (a) => map9(that, (b3) => [a, b3])));
var zipLeft = /* @__PURE__ */ dual(2, (self2, that) => flatMap7(self2, (a) => as(that, a)));
var zipRight = /* @__PURE__ */ dual(2, (self2, that) => flatMap7(self2, () => that));
var zipWith2 = /* @__PURE__ */ dual(3, (self2, that, f) => flatMap7(self2, (a) => map9(that, (b3) => f(a, b3))));
var never = /* @__PURE__ */ asyncInterrupt(() => {
  const interval2 = setInterval(() => {
  }, 2 ** 31 - 1);
  return sync(() => clearInterval(interval2));
});
var interruptFiber = (self2) => flatMap7(fiberId, (fiberId2) => pipe(self2, interruptAsFiber(fiberId2)));
var interruptAsFiber = /* @__PURE__ */ dual(2, (self2, fiberId2) => flatMap7(self2.interruptAsFork(fiberId2), () => self2.await));
var logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 50000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 40000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 30000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 20000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 1e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var FiberRefSymbolKey = "effect/FiberRef";
var FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
var fiberRefVariance = {
  _A: (_2) => _2
};
var fiberRefGet = (self2) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self2)));
var fiberRefGetWith = /* @__PURE__ */ dual(2, (self2, f) => flatMap7(fiberRefGet(self2), f));
var fiberRefSet = /* @__PURE__ */ dual(2, (self2, value) => fiberRefModify(self2, () => [undefined, value]));
var fiberRefModify = /* @__PURE__ */ dual(2, (self2, f) => withFiberRuntime((state) => {
  const [b3, a] = f(state.getFiberRef(self2));
  state.setFiberRef(self2, a);
  return succeed(b3);
}));
var fiberRefLocally = /* @__PURE__ */ dual(3, (use, self2, value) => acquireUseRelease(zipLeft(fiberRefGet(self2), fiberRefSet(self2, value)), () => use, (oldValue) => fiberRefSet(self2, oldValue)));
var fiberRefLocallyWith = /* @__PURE__ */ dual(3, (use, self2, f) => fiberRefGetWith(self2, (a) => fiberRefLocally(use, self2, f(a))));
var fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
  differ: update(),
  fork: options?.fork ?? identity,
  join: options?.join
});
var fiberRefUnsafeMakeHashSet = (initial) => {
  const differ2 = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: differ2.empty
  });
};
var fiberRefUnsafeMakeReadonlyArray = (initial) => {
  const differ2 = readonlyArray(update());
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: differ2.empty
  });
};
var fiberRefUnsafeMakeContext = (initial) => {
  const differ2 = environment();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: differ2.empty
  });
};
var fiberRefUnsafeMakePatch = (initial, options) => {
  const _fiberRef = {
    ...CommitPrototype,
    [FiberRefTypeId]: fiberRefVariance,
    initial,
    commit() {
      return fiberRefGet(this);
    },
    diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
    combine: (first, second) => options.differ.combine(first, second),
    patch: (patch8) => (oldValue) => options.differ.patch(patch8, oldValue),
    fork: options.fork,
    join: options.join ?? ((_2, n) => n)
  };
  return _fiberRef;
};
var fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ,
  fork: differ.empty
});
var currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty4()));
var currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
var currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
var currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty9()));
var currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
var currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty10()));
var withSchedulingPriority = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentSchedulingPriority, scheduler));
var withMaxOpsBeforeYield = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentMaxOpsBeforeYield, scheduler));
var currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
var currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
var currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelDebug)));
var withUnhandledErrorLogLevel = /* @__PURE__ */ dual(2, (self2, level) => fiberRefLocally(self2, currentUnhandledErrorLogLevel, level));
var currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty2()));
var metricLabels = /* @__PURE__ */ fiberRefGet(currentMetricLabels);
var currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
  fork: () => none2(),
  join: (parent, _2) => parent
}));
var currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty20, {
  fork: () => empty20,
  join: (parent, _2) => parent
}));
var currentTracerEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
var currentTracerTimingEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
var currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty9()));
var currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty5()));
var ScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Scope");
var CloseableScopeTypeId = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
var scopeAddFinalizer = (self2, finalizer) => self2.addFinalizer(() => asVoid(finalizer));
var scopeAddFinalizerExit = (self2, finalizer) => self2.addFinalizer(finalizer);
var scopeClose = (self2, exit2) => self2.close(exit2);
var scopeFork = (self2, strategy) => self2.fork(strategy);
var YieldableError = /* @__PURE__ */ function() {
  class YieldableError2 extends globalThis.Error {
    commit() {
      return fail2(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message)
        obj.message = this.message;
      if (this.cause)
        obj.cause = this.cause;
      return obj;
    }
    [NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}
${this.stack.split(`
`).slice(1).join(`
`)}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty(fail(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  Object.assign(YieldableError2.prototype, StructuralCommitPrototype);
  return YieldableError2;
}();
var makeException = (proto2, tag) => {

  class Base2 extends YieldableError {
    _tag = tag;
  }
  Object.assign(Base2.prototype, proto2);
  Base2.prototype.name = tag;
  return Base2;
};
var RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException = /* @__PURE__ */ makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
var InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException = /* @__PURE__ */ makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
var isInterruptedException = (u3) => hasProperty(u3, InterruptedExceptionTypeId);
var IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
var IllegalArgumentException = /* @__PURE__ */ makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
var NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException = /* @__PURE__ */ makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
var isNoSuchElementException = (u3) => hasProperty(u3, NoSuchElementExceptionTypeId);
var InvalidPubSubCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
var InvalidPubSubCapacityException = /* @__PURE__ */ makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
var ExceededCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
var ExceededCapacityException = /* @__PURE__ */ makeException({
  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}, "ExceededCapacityException");
var TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException = /* @__PURE__ */ makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
var timeoutExceptionFromDuration = (duration) => new TimeoutException(`Operation timed out after '${format3(duration)}'`);
var UnknownExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
var UnknownException = /* @__PURE__ */ function() {

  class UnknownException2 extends YieldableError {
    _tag = "UnknownException";
    error;
    constructor(cause, message) {
      super(message ?? "An unknown error occurred", {
        cause
      });
      this.error = cause;
    }
  }
  Object.assign(UnknownException2.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException2;
}();
var exitIsExit = (u3) => isEffect(u3) && ("_tag" in u3) && (u3._tag === "Success" || u3._tag === "Failure");
var exitIsFailure = (self2) => self2._tag === "Failure";
var exitIsSuccess = (self2) => self2._tag === "Success";
var exitAs = /* @__PURE__ */ dual(2, (self2, value) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      return exitFailCause(self2.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return exitSucceed(value);
    }
  }
});
var exitAsVoid = (self2) => exitAs(self2, undefined);
var exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel : sequential);
var exitDie = (defect) => exitFailCause(die(defect));
var exitFail = (error) => exitFailCause(fail(error));
var exitFailCause = (cause) => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause;
  return effect;
};
var exitFlatMap = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      return exitFailCause(self2.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return f(self2.effect_instruction_i0);
    }
  }
});
var exitFlatten = (self2) => pipe(self2, exitFlatMap(identity));
var exitInterrupt = (fiberId2) => exitFailCause(interrupt(fiberId2));
var exitMap = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return exitFailCause(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return exitSucceed(f(self2.effect_instruction_i0));
  }
});
var exitMatch = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return onFailure(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self2.effect_instruction_i0);
  }
});
var exitMatchEffect = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return onFailure(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self2.effect_instruction_i0);
  }
});
var exitSucceed = (value) => {
  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
};
var exitVoid = /* @__PURE__ */ exitSucceed(undefined);
var exitZipWith = /* @__PURE__ */ dual(3, (self2, that, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitFailCause(self2.effect_instruction_i0);
        case OP_FAILURE: {
          return exitFailCause(onFailure(self2.effect_instruction_i0, that.effect_instruction_i0));
        }
      }
    }
    case OP_SUCCESS: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitSucceed(onSuccess(self2.effect_instruction_i0, that.effect_instruction_i0));
        case OP_FAILURE:
          return exitFailCause(that.effect_instruction_i0);
      }
    }
  }
});
var exitCollectAllInternal = (exits, combineCauses) => {
  const list = fromIterable2(exits);
  if (!isNonEmpty2(list)) {
    return none2();
  }
  return pipe(tailNonEmpty2(list), reduce(pipe(headNonEmpty2(list), exitMap(of2)), (accumulator, current) => pipe(accumulator, exitZipWith(current, {
    onSuccess: (list2, value) => pipe(list2, prepend2(value)),
    onFailure: combineCauses
  }))), exitMap(reverse2), exitMap((chunk) => toReadonlyArray(chunk)), some2);
};
var deferredUnsafeMake = (fiberId2) => {
  const _deferred = {
    ...CommitPrototype,
    [DeferredTypeId]: deferredVariance,
    state: make12(pending([])),
    commit() {
      return deferredAwait(this);
    },
    blockingOn: fiberId2
  };
  return _deferred;
};
var deferredMake = () => flatMap7(fiberId, (id) => deferredMakeAs(id));
var deferredMakeAs = (fiberId2) => sync(() => deferredUnsafeMake(fiberId2));
var deferredAwait = (self2) => asyncInterrupt((resume) => {
  const state = get6(self2.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return resume(state.effect);
    }
    case OP_STATE_PENDING: {
      state.joiners.push(resume);
      return deferredInterruptJoiner(self2, resume);
    }
  }
}, self2.blockingOn);
var deferredComplete = /* @__PURE__ */ dual(2, (self2, effect) => intoDeferred(effect, self2));
var deferredCompleteWith = /* @__PURE__ */ dual(2, (self2, effect) => sync(() => {
  const state = get6(self2.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return false;
    }
    case OP_STATE_PENDING: {
      set2(self2.state, done(effect));
      for (let i2 = 0, len = state.joiners.length;i2 < len; i2++) {
        state.joiners[i2](effect);
      }
      return true;
    }
  }
}));
var deferredDone = /* @__PURE__ */ dual(2, (self2, exit2) => deferredCompleteWith(self2, exit2));
var deferredFailCause = /* @__PURE__ */ dual(2, (self2, cause) => deferredCompleteWith(self2, failCause(cause)));
var deferredInterrupt = (self2) => flatMap7(fiberId, (fiberId2) => deferredCompleteWith(self2, interruptWith(fiberId2)));
var deferredSucceed = /* @__PURE__ */ dual(2, (self2, value) => deferredCompleteWith(self2, succeed(value)));
var deferredUnsafeDone = (self2, effect) => {
  const state = get6(self2.state);
  if (state._tag === OP_STATE_PENDING) {
    set2(self2.state, done(effect));
    for (let i2 = 0, len = state.joiners.length;i2 < len; i2++) {
      state.joiners[i2](effect);
    }
  }
};
var deferredInterruptJoiner = (self2, joiner) => sync(() => {
  const state = get6(self2.state);
  if (state._tag === OP_STATE_PENDING) {
    const index2 = state.joiners.indexOf(joiner);
    if (index2 >= 0) {
      state.joiners.splice(index2, 1);
    }
  }
});
var constContext = /* @__PURE__ */ withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
var context = () => constContext;
var contextWithEffect = (f) => flatMap7(context(), f);
var provideContext = /* @__PURE__ */ dual(2, (self2, context2) => fiberRefLocally(currentContext, context2)(self2));
var provideSomeContext = /* @__PURE__ */ dual(2, (self2, context2) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context2))(self2));
var mapInputContext = /* @__PURE__ */ dual(2, (self2, f) => contextWithEffect((context2) => provideContext(self2, f(context2))));
var filterEffectOrElse = /* @__PURE__ */ dual(2, (self2, options) => flatMap7(self2, (a) => flatMap7(options.predicate(a), (pass) => pass ? succeed(a) : options.orElse(a))));
var filterEffectOrFail = /* @__PURE__ */ dual(2, (self2, options) => filterEffectOrElse(self2, {
  predicate: options.predicate,
  orElse: (a) => fail2(options.orFailWith(a))
}));
var currentSpanFromFiber = (fiber) => {
  const span2 = fiber.currentSpan;
  return span2 !== undefined && span2._tag === "Span" ? some2(span2) : none2();
};
var NoopSpanProto = {
  _tag: "Span",
  spanId: "noop",
  traceId: "noop",
  sampled: false,
  status: {
    _tag: "Ended",
    startTime: /* @__PURE__ */ BigInt(0),
    endTime: /* @__PURE__ */ BigInt(0),
    exit: exitVoid
  },
  attributes: /* @__PURE__ */ new Map,
  links: [],
  kind: "internal",
  attribute() {
  },
  event() {
  },
  end() {
  },
  addLinks() {
  }
};
var noopSpan = (options) => Object.assign(Object.create(NoopSpanProto), options);

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Deferred.js
var _await = deferredAwait;
var done2 = deferredDone;
var interrupt3 = deferredInterrupt;
var unsafeMake4 = deferredUnsafeMake;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Exit.js
var isExit = exitIsExit;
var isSuccess = exitIsSuccess;
var die3 = exitDie;
var fail3 = exitFail;
var failCause2 = exitFailCause;
var flatten6 = exitFlatten;
var interrupt4 = exitInterrupt;
var match6 = exitMatch;
var succeed2 = exitSucceed;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/MutableHashMap.js
var TypeId9 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
var MutableHashMapProto = {
  [TypeId9]: TypeId9,
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};

class MutableHashMapIterator {
  self;
  referentialIterator;
  bucketIterator;
  constructor(self2) {
    this.self = self2;
    this.referentialIterator = self2.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== undefined) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this.self);
  }
}

class BucketIterator {
  backing;
  constructor(backing) {
    this.backing = backing;
  }
  currentBucket;
  next() {
    if (this.currentBucket === undefined) {
      const result2 = this.backing.next();
      if (result2.done) {
        return result2;
      }
      this.currentBucket = result2.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = undefined;
      return this.next();
    }
    return result;
  }
}
var empty21 = () => {
  const self2 = Object.create(MutableHashMapProto);
  self2.referential = new Map;
  self2.buckets = new Map;
  self2.bucketsSize = 0;
  return self2;
};
var get8 = /* @__PURE__ */ dual(2, (self2, key) => {
  if (isEqual(key) === false) {
    return self2.referential.has(key) ? some2(self2.referential.get(key)) : none2();
  }
  const hash2 = key[symbol]();
  const bucket = self2.buckets.get(hash2);
  if (bucket === undefined) {
    return none2();
  }
  return getFromBucket(self2, bucket, key);
});
var getFromBucket = (self2, bucket, key, remove6 = false) => {
  for (let i2 = 0, len = bucket.length;i2 < len; i2++) {
    if (key[symbol2](bucket[i2][0])) {
      const value = bucket[i2][1];
      if (remove6) {
        bucket.splice(i2, 1);
        self2.bucketsSize--;
      }
      return some2(value);
    }
  }
  return none2();
};
var has4 = /* @__PURE__ */ dual(2, (self2, key) => isSome2(get8(self2, key)));
var set4 = /* @__PURE__ */ dual(3, (self2, key, value) => {
  if (isEqual(key) === false) {
    self2.referential.set(key, value);
    return self2;
  }
  const hash2 = key[symbol]();
  const bucket = self2.buckets.get(hash2);
  if (bucket === undefined) {
    self2.buckets.set(hash2, [[key, value]]);
    self2.bucketsSize++;
    return self2;
  }
  removeFromBucket(self2, bucket, key);
  bucket.push([key, value]);
  self2.bucketsSize++;
  return self2;
});
var removeFromBucket = (self2, bucket, key) => {
  for (let i2 = 0, len = bucket.length;i2 < len; i2++) {
    if (key[symbol2](bucket[i2][0])) {
      bucket.splice(i2, 1);
      self2.bucketsSize--;
      return;
    }
  }
};
var remove6 = /* @__PURE__ */ dual(2, (self2, key) => {
  if (isEqual(key) === false) {
    self2.referential.delete(key);
    return self2;
  }
  const hash2 = key[symbol]();
  const bucket = self2.buckets.get(hash2);
  if (bucket === undefined) {
    return self2;
  }
  removeFromBucket(self2, bucket, key);
  if (bucket.length === 0) {
    self2.buckets.delete(hash2);
  }
  return self2;
});
var size4 = (self2) => {
  return self2.referential.size + self2.bucketsSize;
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/MutableList.js
var TypeId10 = /* @__PURE__ */ Symbol.for("effect/MutableList");
var MutableListProto = {
  [TypeId10]: TypeId10,
  [Symbol.iterator]() {
    let done3 = false;
    let head3 = this.head;
    return {
      next() {
        if (done3) {
          return this.return();
        }
        if (head3 == null) {
          done3 = true;
          return this.return();
        }
        const value = head3.value;
        head3 = head3.next;
        return {
          done: done3,
          value
        };
      },
      return(value) {
        if (!done3) {
          done3 = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeNode = (value) => ({
  value,
  removed: false,
  prev: undefined,
  next: undefined
});
var empty22 = () => {
  const list = Object.create(MutableListProto);
  list.head = undefined;
  list.tail = undefined;
  list._length = 0;
  return list;
};
var isEmpty6 = (self2) => length(self2) === 0;
var length = (self2) => self2._length;
var append3 = /* @__PURE__ */ dual(2, (self2, value) => {
  const node = makeNode(value);
  if (self2.head === undefined) {
    self2.head = node;
  }
  if (self2.tail === undefined) {
    self2.tail = node;
  } else {
    self2.tail.next = node;
    node.prev = self2.tail;
    self2.tail = node;
  }
  self2._length += 1;
  return self2;
});
var shift = (self2) => {
  const head3 = self2.head;
  if (head3 !== undefined) {
    remove7(self2, head3);
    return head3.value;
  }
  return;
};
var remove7 = (self2, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== undefined && node.next !== undefined) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== undefined) {
    self2.tail = node.prev;
    node.prev.next = undefined;
  } else if (node.next !== undefined) {
    self2.head = node.next;
    node.next.prev = undefined;
  } else {
    self2.tail = undefined;
    self2.head = undefined;
  }
  if (self2._length > 0) {
    self2._length -= 1;
  }
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/MutableQueue.js
var TypeId11 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
var EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
var MutableQueueProto = {
  [TypeId11]: TypeId11,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make19 = (capacity) => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = empty22();
  queue.capacity = capacity;
  return queue;
};
var unbounded = () => make19(undefined);
var offer = /* @__PURE__ */ dual(2, (self2, value) => {
  const queueLength = length(self2.queue);
  if (self2.capacity !== undefined && queueLength === self2.capacity) {
    return false;
  }
  append3(value)(self2.queue);
  return true;
});
var poll = /* @__PURE__ */ dual(2, (self2, def) => {
  if (isEmpty6(self2.queue)) {
    return def;
  }
  return shift(self2.queue);
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/clock.js
var ClockSymbolKey = "effect/Clock";
var ClockTypeId = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
var clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
var MAX_TIMER_MILLIS = 2 ** 31 - 1;
var globalClockScheduler = {
  unsafeSchedule(task, duration) {
    const millis2 = toMillis(duration);
    if (millis2 > MAX_TIMER_MILLIS) {
      return constFalse;
    }
    let completed = false;
    const handle2 = setTimeout(() => {
      completed = true;
      task();
    }, millis2);
    return () => {
      clearTimeout(handle2);
      return !completed;
    };
  }
};
var performanceNowNanos = /* @__PURE__ */ function() {
  const bigint1e62 = /* @__PURE__ */ BigInt(1e6);
  if (typeof performance === "undefined") {
    return () => BigInt(Date.now()) * bigint1e62;
  }
  let origin;
  return () => {
    if (origin === undefined) {
      origin = BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
    }
    return origin + BigInt(Math.round(performance.now() * 1e6));
  };
}();
var processOrPerformanceNow = /* @__PURE__ */ function() {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : undefined;
  if (!processHrtime) {
    return performanceNowNanos;
  }
  const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
  return () => origin + processHrtime.bigint();
}();

class ClockImpl {
  [ClockTypeId] = ClockTypeId;
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow();
  }
  currentTimeMillis = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeMillis());
  currentTimeNanos = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeNanos());
  scheduler() {
    return succeed(globalClockScheduler);
  }
  sleep(duration) {
    return async_((resume) => {
      const canceler = globalClockScheduler.unsafeSchedule(() => resume(void_), duration);
      return asVoid(sync(canceler));
    });
  }
}
var make20 = () => new ClockImpl;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/opCodes/configError.js
var OP_AND = "And";
var OP_OR = "Or";
var OP_INVALID_DATA = "InvalidData";
var OP_MISSING_DATA = "MissingData";
var OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
var OP_UNSUPPORTED = "Unsupported";

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey = "effect/ConfigError";
var ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
var proto2 = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
var And = (self2, that) => {
  const error = Object.create(proto2);
  error._op = OP_AND;
  error.left = self2;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  Object.defineProperty(error, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error;
};
var Or = (self2, that) => {
  const error = Object.create(proto2);
  error._op = OP_OR;
  error.left = self2;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  Object.defineProperty(error, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error;
};
var InvalidData = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_INVALID_DATA;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Invalid data at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var MissingData = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_MISSING_DATA;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Missing data at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var SourceUnavailable = (path, message, cause, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_SOURCE_UNAVAILABLE;
  error.path = path;
  error.message = message;
  error.cause = cause;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Source unavailable at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var Unsupported = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_UNSUPPORTED;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Unsupported operation at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var prefixed = /* @__PURE__ */ dual(2, (self2, prefix) => {
  switch (self2._op) {
    case OP_AND: {
      return And(prefixed(self2.left, prefix), prefixed(self2.right, prefix));
    }
    case OP_OR: {
      return Or(prefixed(self2.left, prefix), prefixed(self2.right, prefix));
    }
    case OP_INVALID_DATA: {
      return InvalidData([...prefix, ...self2.path], self2.message);
    }
    case OP_MISSING_DATA: {
      return MissingData([...prefix, ...self2.path], self2.message);
    }
    case OP_SOURCE_UNAVAILABLE: {
      return SourceUnavailable([...prefix, ...self2.path], self2.message, self2.cause);
    }
    case OP_UNSUPPORTED: {
      return Unsupported([...prefix, ...self2.path], self2.message);
    }
  }
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
var empty23 = {
  _tag: "Empty"
};
var patch8 = /* @__PURE__ */ dual(2, (path, patch9) => {
  let input = of3(patch9);
  let output = path;
  while (isCons(input)) {
    const patch10 = input.head;
    switch (patch10._tag) {
      case "Empty": {
        input = input.tail;
        break;
      }
      case "AndThen": {
        input = cons(patch10.first, cons(patch10.second, input.tail));
        break;
      }
      case "MapName": {
        output = map3(output, patch10.f);
        input = input.tail;
        break;
      }
      case "Nested": {
        output = prepend(output, patch10.name);
        input = input.tail;
        break;
      }
      case "Unnested": {
        const containsName = pipe(head(output), contains(patch10.name));
        if (containsName) {
          output = tailNonEmpty(output);
          input = input.tail;
        } else {
          return left2(MissingData(output, `Expected ${patch10.name} to be in path in ConfigProvider#unnested`));
        }
        break;
      }
    }
  }
  return right2(output);
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/opCodes/config.js
var OP_CONSTANT = "Constant";
var OP_FAIL2 = "Fail";
var OP_FALLBACK = "Fallback";
var OP_DESCRIBED = "Described";
var OP_LAZY = "Lazy";
var OP_MAP_OR_FAIL = "MapOrFail";
var OP_NESTED = "Nested";
var OP_PRIMITIVE = "Primitive";
var OP_SEQUENCE = "Sequence";
var OP_HASHMAP = "HashMap";
var OP_ZIP_WITH = "ZipWith";

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/configProvider.js
var concat = (l3, r2) => [...l3, ...r2];
var ConfigProviderSymbolKey = "effect/ConfigProvider";
var ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
var configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
var FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
var FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
var make22 = (options) => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var makeFlat = (options) => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options.patch,
  load: (path, config, split = true) => options.load(path, config, split),
  enumerateChildren: options.enumerateChildren
});
var fromFlat = (flat) => make22({
  load: (config) => flatMap7(fromFlatLoop(flat, empty2(), config, false), (chunk) => match2(head(chunk), {
    onNone: () => fail2(MissingData(empty2(), `Expected a single value having structure: ${config}`)),
    onSome: succeed
  })),
  flattened: flat
});
var fromEnv = (options) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options);
  const makePathString = (path) => pipe(path, join(pathDelim));
  const unmakePathString = (pathString) => pathString.split(pathDelim);
  const getEnv = () => typeof process !== "undefined" && ("env" in process) && typeof process.env === "object" ? process.env : {};
  const load = (path, primitive, split = true) => {
    const pathString = makePathString(path);
    const current = getEnv();
    const valueOpt = pathString in current ? some2(current[pathString]) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap7((value) => parsePrimitive(value, path, primitive, seqDelim, split)));
  };
  const enumerateChildren = (path) => sync(() => {
    const current = getEnv();
    const keys3 = Object.keys(current);
    const keyPaths = keys3.map((value) => unmakePathString(value.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i2 = 0;i2 < path.length; i2++) {
        const pathComponent = pipe(path, unsafeGet(i2));
        const currentElement = keyPath[i2];
        if (currentElement === undefined || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
    return fromIterable5(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty23
  }));
};
var extend = (leftDef, rightDef, left3, right3) => {
  const leftPad = unfold(left3.length, (index2) => index2 >= right3.length ? none2() : some2([leftDef(index2), index2 + 1]));
  const rightPad = unfold(right3.length, (index2) => index2 >= left3.length ? none2() : some2([rightDef(index2), index2 + 1]));
  const leftExtension = concat(left3, leftPad);
  const rightExtension = concat(right3, rightPad);
  return [leftExtension, rightExtension];
};
var appendConfigPath = (path, config) => {
  let op = config;
  if (op._tag === "Nested") {
    const out2 = path.slice();
    while (op._tag === "Nested") {
      out2.push(op.name);
      op = op.config;
    }
    return out2;
  }
  return path;
};
var fromFlatLoop = (flat, prefix, config, split) => {
  const op = config;
  switch (op._tag) {
    case OP_CONSTANT: {
      return succeed(of(op.value));
    }
    case OP_DESCRIBED: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config, split));
    }
    case OP_FAIL2: {
      return fail2(MissingData(prefix, op.message));
    }
    case OP_FALLBACK: {
      return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split)), catchAll((error1) => {
        if (op.condition(error1)) {
          return pipe(fromFlatLoop(flat, prefix, op.second, split), catchAll((error2) => fail2(Or(error1, error2))));
        }
        return fail2(error1);
      }));
    }
    case OP_LAZY: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config(), split));
    }
    case OP_MAP_OR_FAIL: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split), flatMap7(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
    }
    case OP_NESTED: {
      return suspend(() => fromFlatLoop(flat, concat(prefix, of(op.name)), op.config, split));
    }
    case OP_PRIMITIVE: {
      return pipe(patch8(prefix, flat.patch), flatMap7((prefix2) => pipe(flat.load(prefix2, op, split), flatMap7((values3) => {
        if (values3.length === 0) {
          const name2 = pipe(last(prefix2), getOrElse(() => "<n/a>"));
          return fail2(MissingData([], `Expected ${op.description} with name ${name2}`));
        }
        return succeed(values3);
      }))));
    }
    case OP_SEQUENCE: {
      return pipe(patch8(prefix, flat.patch), flatMap7((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap7(indicesFrom), flatMap7((indices) => {
        if (indices.length === 0) {
          return suspend(() => map9(fromFlatLoop(flat, prefix, op.config, true), of));
        }
        return pipe(forEachSequential(indices, (index2) => fromFlatLoop(flat, append(prefix, `[${index2}]`), op.config, true)), map9((chunkChunk) => {
          const flattened = flatten(chunkChunk);
          if (flattened.length === 0) {
            return of(empty2());
          }
          return of(flattened);
        }));
      }))));
    }
    case OP_HASHMAP: {
      return suspend(() => pipe(patch8(prefix, flat.patch), flatMap7((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap7((keys3) => {
        return pipe(keys3, forEachSequential((key) => fromFlatLoop(flat, concat(prefix2, of(key)), op.valueConfig, split)), map9((matrix) => {
          if (matrix.length === 0) {
            return of(empty9());
          }
          return pipe(transpose(matrix), map3((values3) => fromIterable6(zip(fromIterable(keys3), values3))));
        }));
      })))));
    }
    case OP_ZIP_WITH: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split), either2, flatMap7((left3) => pipe(fromFlatLoop(flat, prefix, op.right, split), either2, flatMap7((right3) => {
        if (isLeft2(left3) && isLeft2(right3)) {
          return fail2(And(left3.left, right3.left));
        }
        if (isLeft2(left3) && isRight2(right3)) {
          return fail2(left3.left);
        }
        if (isRight2(left3) && isLeft2(right3)) {
          return fail2(right3.left);
        }
        if (isRight2(left3) && isRight2(right3)) {
          const path = pipe(prefix, join("."));
          const fail4 = fromFlatLoopFail(prefix, path);
          const [lefts, rights] = extend(fail4, fail4, pipe(left3.right, map3(right2)), pipe(right3.right, map3(right2)));
          return pipe(lefts, zip(rights), forEachSequential(([left4, right4]) => pipe(zip2(left4, right4), map9(([left5, right5]) => op.zip(left5, right5)))));
        }
        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
      })))));
    }
  }
};
var fromFlatLoopFail = (prefix, path) => (index2) => left2(MissingData(prefix, `The element at index ${index2} in a sequence at path "${path}" was missing`));
var splitPathString = (text2, delim) => {
  const split = text2.split(new RegExp(`\\s*${escape(delim)}\\s*`));
  return split;
};
var parsePrimitive = (text2, path, primitive, delimiter, split) => {
  if (!split) {
    return pipe(primitive.parse(text2), mapBoth2({
      onFailure: prefixed(path),
      onSuccess: of
    }));
  }
  return pipe(splitPathString(text2, delimiter), forEachSequential((char2) => primitive.parse(char2.trim())), mapError(prefixed(path)));
};
var transpose = (array5) => {
  return Object.keys(array5[0]).map((column) => array5.map((row) => row[column]));
};
var indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth2({
  onFailure: () => empty2(),
  onSuccess: sort(Order)
}), either2, map9(merge));
var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
var parseQuotedIndex = (str) => {
  const match7 = str.match(QUOTED_INDEX_REGEX);
  if (match7 !== null) {
    const matchedIndex = match7[2];
    return pipe(matchedIndex !== undefined && matchedIndex.length > 0 ? some2(matchedIndex) : none2(), flatMap(parseInteger));
  }
  return none2();
};
var parseInteger = (str) => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none2() : some2(parsedIndex);
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/defaultServices/console.js
var TypeId12 = /* @__PURE__ */ Symbol.for("effect/Console");
var consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
var defaultConsole = {
  [TypeId12]: TypeId12,
  assert(condition, ...args2) {
    return sync(() => {
      console.assert(condition, ...args2);
    });
  },
  clear: /* @__PURE__ */ sync(() => {
    console.clear();
  }),
  count(label) {
    return sync(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync(() => {
      console.countReset(label);
    });
  },
  debug(...args2) {
    return sync(() => {
      console.debug(...args2);
    });
  },
  dir(item, options) {
    return sync(() => {
      console.dir(item, options);
    });
  },
  dirxml(...args2) {
    return sync(() => {
      console.dirxml(...args2);
    });
  },
  error(...args2) {
    return sync(() => {
      console.error(...args2);
    });
  },
  group(options) {
    return options?.collapsed ? sync(() => console.groupCollapsed(options?.label)) : sync(() => console.group(options?.label));
  },
  groupEnd: /* @__PURE__ */ sync(() => {
    console.groupEnd();
  }),
  info(...args2) {
    return sync(() => {
      console.info(...args2);
    });
  },
  log(...args2) {
    return sync(() => {
      console.log(...args2);
    });
  },
  table(tabularData, properties) {
    return sync(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync(() => console.time(label));
  },
  timeEnd(label) {
    return sync(() => console.timeEnd(label));
  },
  timeLog(label, ...args2) {
    return sync(() => {
      console.timeLog(label, ...args2);
    });
  },
  trace(...args2) {
    return sync(() => {
      console.trace(...args2);
    });
  },
  warn(...args2) {
    return sync(() => {
      console.warn(...args2);
    });
  },
  unsafe: console
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/random.js
var RandomSymbolKey = "effect/Random";
var RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
var randomTag = /* @__PURE__ */ GenericTag("effect/Random");

class RandomImpl {
  seed;
  [RandomTypeId] = RandomTypeId;
  PRNG;
  constructor(seed) {
    this.seed = seed;
    this.PRNG = new PCGRandom(seed);
  }
  get next() {
    return sync(() => this.PRNG.number());
  }
  get nextBoolean() {
    return map9(this.next, (n) => n > 0.5);
  }
  get nextInt() {
    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min2, max2) {
    return map9(this.next, (n) => (max2 - min2) * n + min2);
  }
  nextIntBetween(min2, max2) {
    return sync(() => this.PRNG.integer(max2 - min2) + min2);
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
}
var shuffleWith = (elements, nextIntBounded) => {
  return suspend(() => pipe(sync(() => Array.from(elements)), flatMap7((buffer) => {
    const numbers = [];
    for (let i2 = buffer.length;i2 >= 2; i2 = i2 - 1) {
      numbers.push(i2);
    }
    return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map9((k2) => swap(buffer, n - 1, k2)))), as(fromIterable2(buffer)));
  })));
};
var swap = (buffer, index1, index2) => {
  const tmp = buffer[index1];
  buffer[index1] = buffer[index2];
  buffer[index2] = tmp;
  return buffer;
};
var make23 = (seed) => new RandomImpl(hash(seed));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/tracer.js
var TracerTypeId = /* @__PURE__ */ Symbol.for("effect/Tracer");
var make24 = (options) => ({
  [TracerTypeId]: TracerTypeId,
  ...options
});
var tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
var spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
var randomHexString = /* @__PURE__ */ function() {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function(length2) {
    let result = "";
    for (let i2 = 0;i2 < length2; i2++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
}();

class NativeSpan {
  name;
  parent;
  context;
  startTime;
  kind;
  _tag = "Span";
  spanId;
  traceId = "native";
  sampled = true;
  status;
  attributes;
  events = [];
  links;
  constructor(name2, parent, context2, links, startTime, kind) {
    this.name = name2;
    this.parent = parent;
    this.context = context2;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = new Map;
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
    this.links = Array.from(links);
  }
  end(endTime, exit2) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit2,
      startTime: this.status.startTime
    };
  }
  attribute(key, value) {
    this.attributes.set(key, value);
  }
  event(name2, startTime, attributes) {
    this.events.push([name2, startTime, attributes ?? {}]);
  }
  addLinks(links) {
    this.links.push(...links);
  }
}
var nativeTracer = /* @__PURE__ */ make24({
  span: (name2, parent, context2, links, startTime, kind) => new NativeSpan(name2, parent, context2, links, startTime, kind),
  context: (f) => f()
});
var addSpanStackTrace = (options) => {
  if (options?.captureStackTrace === false) {
    return options;
  } else if (options?.captureStackTrace !== undefined && typeof options.captureStackTrace !== "boolean") {
    return options;
  }
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 3;
  const traceError = new Error;
  Error.stackTraceLimit = limit;
  let cache = false;
  return {
    ...options,
    captureStackTrace: () => {
      if (cache !== false) {
        return cache;
      }
      if (traceError.stack !== undefined) {
        const stack = traceError.stack.split(`
`);
        if (stack[3] !== undefined) {
          cache = stack[3].trim();
          return cache;
        }
      }
    }
  };
};
var DisablePropagation = /* @__PURE__ */ Reference2()("effect/Tracer/DisablePropagation", {
  defaultValue: constFalse
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty4(), /* @__PURE__ */ add2(clockTag, /* @__PURE__ */ make20()), /* @__PURE__ */ add2(consoleTag, defaultConsole), /* @__PURE__ */ add2(randomTag, /* @__PURE__ */ make23(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add2(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add2(tracerTag, nativeTracer));
var currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
var sleep = (duration) => {
  const decodedDuration = decode(duration);
  return clockWith((clock) => clock.sleep(decodedDuration));
};
var defaultServicesWith = (f) => withFiberRuntime((fiber) => f(fiber.currentDefaultServices));
var clockWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key)));
var currentTimeMillis = /* @__PURE__ */ clockWith((clock) => clock.currentTimeMillis);
var currentTimeNanos = /* @__PURE__ */ clockWith((clock) => clock.currentTimeNanos);
var withClock = /* @__PURE__ */ dual(2, (effect, c) => fiberRefLocallyWith(currentServices, add2(clockTag, c))(effect));
var withConfigProvider = /* @__PURE__ */ dual(2, (self2, provider) => fiberRefLocallyWith(currentServices, add2(configProviderTag, provider))(self2));
var configProviderWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(configProviderTag.key)));
var config = (config2) => configProviderWith((_2) => _2.load(config2));
var randomWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(randomTag.key)));
var withRandom = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add2(randomTag, value))(effect));
var tracerWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(tracerTag.key)));
var withTracer = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add2(tracerTag, value))(effect));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Clock.js
var sleep2 = sleep;
var currentTimeMillis2 = currentTimeMillis;
var currentTimeNanos2 = currentTimeNanos;
var clockWith2 = clockWith;
var Clock = clockTag;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/fiberRefs.js
function unsafeMake5(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
function empty24() {
  return unsafeMake5(new Map);
}
var FiberRefsSym = /* @__PURE__ */ Symbol.for("effect/FiberRefs");

class FiberRefsImpl {
  locals;
  [FiberRefsSym] = FiberRefsSym;
  constructor(locals) {
    this.locals = locals;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = undefined;
  while (ret === undefined) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty(parentStack)[0];
      const parentAncestors = tailNonEmpty(parentStack);
      const childFiberId = headNonEmpty(childStack)[0];
      const childRefValue = headNonEmpty(childStack)[1];
      const childAncestors = tailNonEmpty(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
};
var joinAs = /* @__PURE__ */ dual(3, (self2, fiberId2, that) => {
  const parentFiberRefs = new Map(self2.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][symbol2](fiberId2)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId2, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch9 = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch9)(oldValue));
        if (!equals(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[symbol2](fiberId2)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId2, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
var forkAs = /* @__PURE__ */ dual(2, (self2, childId) => {
  const map10 = new Map;
  unsafeForkAs(self2, map10, childId);
  return new FiberRefsImpl(map10);
});
var unsafeForkAs = (self2, map10, fiberId2) => {
  self2.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals(oldValue, newValue)) {
      map10.set(fiberRef, stack);
    } else {
      map10.set(fiberRef, [[fiberId2, newValue], ...stack]);
    }
  });
};
var fiberRefs = (self2) => fromIterable5(self2.locals.keys());
var setAll = (self2) => forEachSequentialDiscard(fiberRefs(self2), (fiberRef) => fiberRefSet(fiberRef, getOrDefault(self2, fiberRef)));
var delete_ = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
  const locals = new Map(self2.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl(locals);
});
var get9 = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
  if (!self2.locals.has(fiberRef)) {
    return none2();
  }
  return some2(headNonEmpty(self2.locals.get(fiberRef))[1]);
});
var getOrDefault = /* @__PURE__ */ dual(2, (self2, fiberRef) => pipe(get9(self2, fiberRef), getOrElse(() => fiberRef.initial)));
var updateAs = /* @__PURE__ */ dual(2, (self2, {
  fiberId: fiberId2,
  fiberRef,
  value
}) => {
  if (self2.locals.size === 0) {
    return new FiberRefsImpl(new Map([[fiberRef, [[fiberId2, value]]]]));
  }
  const locals = new Map(self2.locals);
  unsafeUpdateAs(locals, fiberId2, fiberRef, value);
  return new FiberRefsImpl(locals);
});
var unsafeUpdateAs = (locals, fiberId2, fiberRef, value) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty(oldStack);
    if (currentId[symbol2](fiberId2)) {
      if (equals(currentValue, value)) {
        return;
      } else {
        newStack = [[fiberId2, value], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId2, value], ...oldStack];
    }
  } else {
    newStack = [[fiberId2, value]];
  }
  locals.set(fiberRef, newStack);
};
var updateManyAs = /* @__PURE__ */ dual(2, (self2, {
  entries: entries2,
  forkAs: forkAs2
}) => {
  if (self2.locals.size === 0) {
    return new FiberRefsImpl(new Map(entries2));
  }
  const locals = new Map(self2.locals);
  if (forkAs2 !== undefined) {
    unsafeForkAs(self2, locals, forkAs2);
  }
  entries2.forEach(([fiberRef, values3]) => {
    if (values3.length === 1) {
      unsafeUpdateAs(locals, values3[0][0], fiberRef, values3[0][1]);
    } else {
      values3.forEach(([fiberId2, value]) => {
        unsafeUpdateAs(locals, fiberId2, fiberRef, value);
      });
    }
  });
  return new FiberRefsImpl(locals);
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/FiberRefs.js
var delete_2 = delete_;
var get10 = get9;
var getOrDefault2 = getOrDefault;
var joinAs2 = joinAs;
var setAll2 = setAll;
var updateAs2 = updateAs;
var updateManyAs2 = updateManyAs;
var empty25 = empty24;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/LogLevel.js
var All = logLevelAll;
var Fatal = logLevelFatal;
var Error2 = logLevelError;
var Warning = logLevelWarning;
var Info = logLevelInfo;
var Debug = logLevelDebug;
var Trace = logLevelTrace;
var None3 = logLevelNone;
var Order5 = /* @__PURE__ */ pipe(Order, /* @__PURE__ */ mapInput2((level) => level.ordinal));
var greaterThan4 = /* @__PURE__ */ greaterThan(Order5);
var fromLiteral = (literal) => {
  switch (literal) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return Error2;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return None3;
    case "Warning":
      return Warning;
  }
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/logSpan.js
var make25 = (label, startTime) => ({
  label,
  startTime
});
var formatLabel = (key) => key.replace(/[\s="]/g, "_");
var render = (now) => (self2) => {
  const label = formatLabel(self2.label);
  return `${label}=${now - self2.startTime}ms`;
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/LogSpan.js
var make26 = make25;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Effectable.js
var EffectPrototype2 = EffectPrototype;
var CommitPrototype2 = CommitPrototype;
var Base2 = Base;
class Class extends Base2 {
}

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Readable.js
var TypeId13 = /* @__PURE__ */ Symbol.for("effect/Readable");
var Proto = {
  [TypeId13]: TypeId13,
  pipe() {
    return pipeArguments(this, arguments);
  }
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/ref.js
var RefTypeId = /* @__PURE__ */ Symbol.for("effect/Ref");
var refVariance = {
  _A: (_2) => _2
};

class RefImpl extends Class {
  ref;
  commit() {
    return this.get;
  }
  [RefTypeId] = refVariance;
  [TypeId13] = TypeId13;
  constructor(ref) {
    super();
    this.ref = ref;
    this.get = sync(() => get6(this.ref));
  }
  get;
  modify(f) {
    return sync(() => {
      const current = get6(this.ref);
      const [b3, a] = f(current);
      if (current !== a) {
        set2(a)(this.ref);
      }
      return b3;
    });
  }
}
var unsafeMake6 = (value) => new RefImpl(make12(value));
var make27 = (value) => sync(() => unsafeMake6(value));
var get11 = (self2) => self2.get;
var set5 = /* @__PURE__ */ dual(2, (self2, value) => self2.modify(() => [undefined, value]));
var getAndSet = /* @__PURE__ */ dual(2, (self2, value) => self2.modify((a) => [a, value]));
var modify3 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify(f));
var update2 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [undefined, f(a)]));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Ref.js
var make28 = make27;
var get12 = get11;
var getAndSet2 = getAndSet;
var modify4 = modify3;
var update3 = update2;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Tracer.js
var tracerWith2 = tracerWith;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/fiberRefs/patch.js
var OP_EMPTY2 = "Empty";
var OP_ADD = "Add";
var OP_REMOVE = "Remove";
var OP_UPDATE = "Update";
var OP_AND_THEN = "AndThen";
var empty26 = {
  _tag: OP_EMPTY2
};
var diff8 = (oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch9 = empty26;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue2 = headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== undefined) {
      const oldValue2 = headNonEmpty(old)[1];
      if (!equals(oldValue2, newValue2)) {
        patch9 = combine10({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue2, newValue2)
        })(patch9);
      }
    } else {
      patch9 = combine10({
        _tag: OP_ADD,
        fiberRef,
        value: newValue2
      })(patch9);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch9 = combine10({
      _tag: OP_REMOVE,
      fiberRef
    })(patch9);
  }
  return patch9;
};
var combine10 = /* @__PURE__ */ dual(2, (self2, that) => ({
  _tag: OP_AND_THEN,
  first: self2,
  second: that
}));
var patch9 = /* @__PURE__ */ dual(3, (self2, fiberId2, oldValue) => {
  let fiberRefs2 = oldValue;
  let patches = of(self2);
  while (isNonEmptyReadonlyArray(patches)) {
    const head3 = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head3._tag) {
      case OP_EMPTY2: {
        patches = tail;
        break;
      }
      case OP_ADD: {
        fiberRefs2 = updateAs(fiberRefs2, {
          fiberId: fiberId2,
          fiberRef: head3.fiberRef,
          value: head3.value
        });
        patches = tail;
        break;
      }
      case OP_REMOVE: {
        fiberRefs2 = delete_(fiberRefs2, head3.fiberRef);
        patches = tail;
        break;
      }
      case OP_UPDATE: {
        const value = getOrDefault(fiberRefs2, head3.fiberRef);
        fiberRefs2 = updateAs(fiberRefs2, {
          fiberId: fiberId2,
          fiberRef: head3.fiberRef,
          value: head3.fiberRef.patch(head3.patch)(value)
        });
        patches = tail;
        break;
      }
      case OP_AND_THEN: {
        patches = prepend(head3.first)(prepend(head3.second)(tail));
        break;
      }
    }
  }
  return fiberRefs2;
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/metric/label.js
var MetricLabelSymbolKey = "effect/MetricLabel";
var MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);

class MetricLabelImpl {
  key;
  value;
  [MetricLabelTypeId] = MetricLabelTypeId;
  _hash;
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this._hash = string(MetricLabelSymbolKey + this.key + this.value);
  }
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var make29 = (key, value) => {
  return new MetricLabelImpl(key, value);
};
var isMetricLabel = (u3) => hasProperty(u3, MetricLabelTypeId);

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations2) => Object.entries(args2[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
});
var asSome = (self2) => map9(self2, some2);
var asSomeError = (self2) => mapError(self2, some2);
var try_2 = (arg) => {
  let evaluate;
  let onFailure = undefined;
  if (typeof arg === "function") {
    evaluate = arg;
  } else {
    evaluate = arg.try;
    onFailure = arg.catch;
  }
  return suspend(() => {
    try {
      return succeed(internalCall(evaluate));
    } catch (error) {
      return fail2(onFailure ? internalCall(() => onFailure(error)) : new UnknownException(error, "An unknown error occurred in Effect.try"));
    }
  });
};
var _catch = /* @__PURE__ */ dual(3, (self2, tag, options) => catchAll(self2, (e) => {
  if (hasProperty(e, tag) && e[tag] === options.failure) {
    return options.onFailure(e);
  }
  return fail2(e);
}));
var catchAllDefect = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause(self2, (cause) => {
  const option = find(cause, (_2) => isDieType(_2) ? some2(_2) : none2());
  switch (option._tag) {
    case "None": {
      return failCause(cause);
    }
    case "Some": {
      return f(option.value.defect);
    }
  }
}));
var catchSomeCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause) => {
    const option = f(cause);
    switch (option._tag) {
      case "None": {
        return failCause(cause);
      }
      case "Some": {
        return option.value;
      }
    }
  },
  onSuccess: succeed
}));
var catchSomeDefect = /* @__PURE__ */ dual(2, (self2, pf) => catchAllCause(self2, (cause) => {
  const option = find(cause, (_2) => isDieType(_2) ? some2(_2) : none2());
  switch (option._tag) {
    case "None": {
      return failCause(cause);
    }
    case "Some": {
      const optionEffect = pf(option.value.defect);
      return optionEffect._tag === "Some" ? optionEffect.value : failCause(cause);
    }
  }
}));
var catchTag = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, ...args2) => {
  const f = args2[args2.length - 1];
  let predicate;
  if (args2.length === 2) {
    predicate = isTagged(args2[0]);
  } else {
    predicate = (e) => {
      const tag = hasProperty(e, "_tag") ? e["_tag"] : undefined;
      if (!tag)
        return false;
      for (let i2 = 0;i2 < args2.length - 1; i2++) {
        if (args2[i2] === tag)
          return true;
      }
      return false;
    };
  }
  return catchIf(self2, predicate, f);
});
var catchTags = /* @__PURE__ */ dual(2, (self2, cases) => {
  let keys3;
  return catchIf(self2, (e) => {
    keys3 ??= Object.keys(cases);
    return hasProperty(e, "_tag") && isString(e["_tag"]) && keys3.includes(e["_tag"]);
  }, (e) => cases[e["_tag"]](e));
});
var cause = (self2) => matchCause(self2, {
  onFailure: identity,
  onSuccess: () => empty20
});
var clockWith3 = clockWith2;
var clock = /* @__PURE__ */ clockWith3(succeed);
var delay = /* @__PURE__ */ dual(2, (self2, duration) => zipRight(sleep2(duration), self2));
var descriptorWith = (f) => withFiberRuntime((state, status) => f({
  id: state.id(),
  status,
  interruptors: interruptors(state.getFiberRef(currentInterruptedCause))
}));
var allowInterrupt = /* @__PURE__ */ descriptorWith((descriptor) => size3(descriptor.interruptors) > 0 ? interrupt2 : void_);
var descriptor = /* @__PURE__ */ descriptorWith(succeed);
var diffFiberRefs = (self2) => summarized(self2, fiberRefs2, diff8);
var diffFiberRefsAndRuntimeFlags = (self2) => summarized(self2, zip2(fiberRefs2, runtimeFlags), ([refs, flags2], [refsNew, flagsNew]) => [diff8(refs, refsNew), diff7(flags2, flagsNew)]);
var Do = /* @__PURE__ */ succeed({});
var bind2 = /* @__PURE__ */ bind(map9, flatMap7);
var bindTo2 = /* @__PURE__ */ bindTo(map9);
var let_2 = /* @__PURE__ */ let_(map9);
var dropUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let dropping = succeed(false);
  let i2 = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index2 = i2++;
    dropping = flatMap7(dropping, (bool) => {
      if (bool) {
        builder.push(a);
        return succeed(true);
      }
      return predicate(a, index2);
    });
  }
  return map9(dropping, () => builder);
}));
var dropWhile = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let dropping = succeed(true);
  let i2 = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index2 = i2++;
    dropping = flatMap7(dropping, (d2) => map9(d2 ? predicate(a, index2) : succeed(false), (b3) => {
      if (!b3) {
        builder.push(a);
      }
      return b3;
    }));
  }
  return map9(dropping, () => builder);
}));
var contextWith = (f) => map9(context(), f);
var eventually = (self2) => orElse2(self2, () => flatMap7(yieldNow(), () => eventually(self2)));
var filterMap4 = /* @__PURE__ */ dual(2, (elements, pf) => map9(forEachSequential(elements, identity), filterMap2(pf)));
var filterOrDie = /* @__PURE__ */ dual(3, (self2, predicate, orDieWith2) => filterOrElse(self2, predicate, (a) => dieSync(() => orDieWith2(a))));
var filterOrDieMessage = /* @__PURE__ */ dual(3, (self2, predicate, message) => filterOrElse(self2, predicate, () => dieMessage(message)));
var filterOrElse = /* @__PURE__ */ dual(3, (self2, predicate, orElse3) => flatMap7(self2, (a) => predicate(a) ? succeed(a) : orElse3(a)));
var liftPredicate = /* @__PURE__ */ dual(3, (self2, predicate, orFailWith) => suspend(() => predicate(self2) ? succeed(self2) : fail2(orFailWith(self2))));
var filterOrFail = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, predicate, orFailWith) => filterOrElse(self2, predicate, (a) => orFailWith === undefined ? fail2(new NoSuchElementException) : failSync(() => orFailWith(a))));
var findFirst4 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const next = iterator.next();
  if (!next.done) {
    return findLoop(iterator, 0, predicate, next.value);
  }
  return succeed(none2());
}));
var findLoop = (iterator, index2, f, value) => flatMap7(f(value, index2), (result) => {
  if (result) {
    return succeed(some2(value));
  }
  const next = iterator.next();
  if (!next.done) {
    return findLoop(iterator, index2 + 1, f, next.value);
  }
  return succeed(none2());
});
var firstSuccessOf = (effects) => suspend(() => {
  const list = fromIterable2(effects);
  if (!isNonEmpty2(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  return pipe(tailNonEmpty2(list), reduce(headNonEmpty2(list), (left3, right3) => orElse2(left3, () => right3)));
});
var flipWith = /* @__PURE__ */ dual(2, (self2, f) => flip(f(flip(self2))));
var match7 = /* @__PURE__ */ dual(2, (self2, options) => matchEffect(self2, {
  onFailure: (e) => succeed(options.onFailure(e)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var every5 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));
var forAllLoop = (iterator, index2, f) => {
  const next = iterator.next();
  return next.done ? succeed(true) : flatMap7(f(next.value, index2), (b3) => b3 ? forAllLoop(iterator, index2 + 1, f) : succeed(b3));
};
var forever = (self2) => {
  const loop = flatMap7(flatMap7(self2, () => yieldNow()), () => loop);
  return loop;
};
var fiberRefs2 = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.getFiberRefs()));
var head3 = (self2) => flatMap7(self2, (as2) => {
  const iterator = as2[Symbol.iterator]();
  const next = iterator.next();
  if (next.done) {
    return fail2(new NoSuchElementException);
  }
  return succeed(next.value);
});
var ignore = (self2) => match7(self2, {
  onFailure: constVoid,
  onSuccess: constVoid
});
var ignoreLogged = (self2) => matchCauseEffect(self2, {
  onFailure: (cause2) => logDebug(cause2, "An error was silently ignored because it is not anticipated to be useful"),
  onSuccess: () => void_
});
var inheritFiberRefs = (childFiberRefs) => updateFiberRefs((parentFiberId, parentFiberRefs) => joinAs2(parentFiberRefs, parentFiberId, childFiberRefs));
var isFailure = (self2) => match7(self2, {
  onFailure: constTrue,
  onSuccess: constFalse
});
var isSuccess2 = (self2) => match7(self2, {
  onFailure: constFalse,
  onSuccess: constTrue
});
var iterate = (initial, options) => suspend(() => {
  if (options.while(initial)) {
    return flatMap7(options.body(initial), (z22) => iterate(z22, options));
  }
  return succeed(initial);
});
var logWithLevel = (level) => (...message) => {
  const levelOption = fromNullable(level);
  let cause2 = undefined;
  for (let i2 = 0, len = message.length;i2 < len; i2++) {
    const msg = message[i2];
    if (isCause(msg)) {
      if (cause2 !== undefined) {
        cause2 = sequential(cause2, msg);
      } else {
        cause2 = msg;
      }
      message = [...message.slice(0, i2), ...message.slice(i2 + 1)];
      i2--;
    }
  }
  if (cause2 === undefined) {
    cause2 = empty20;
  }
  return withFiberRuntime((fiberState) => {
    fiberState.log(message, cause2, levelOption);
    return void_;
  });
};
var log = /* @__PURE__ */ logWithLevel();
var logTrace = /* @__PURE__ */ logWithLevel(Trace);
var logDebug = /* @__PURE__ */ logWithLevel(Debug);
var logInfo = /* @__PURE__ */ logWithLevel(Info);
var logWarning = /* @__PURE__ */ logWithLevel(Warning);
var logError = /* @__PURE__ */ logWithLevel(Error2);
var logFatal = /* @__PURE__ */ logWithLevel(Fatal);
var withLogSpan = /* @__PURE__ */ dual(2, (effect, label) => flatMap7(currentTimeMillis2, (now) => fiberRefLocallyWith(effect, currentLogSpan, prepend3(make26(label, now)))));
var logAnnotations = /* @__PURE__ */ fiberRefGet(currentLogAnnotations);
var loop = (initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : map9(loopInternal(initial, options.while, options.step, options.body), fromIterable);
var loopInternal = (initial, cont, inc, body2) => suspend(() => cont(initial) ? flatMap7(body2(initial), (a) => map9(loopInternal(inc(initial), cont, inc, body2), prepend3(a))) : sync(() => empty10()));
var loopDiscard = (initial, cont, inc, body2) => suspend(() => cont(initial) ? flatMap7(body2(initial), () => loopDiscard(inc(initial), cont, inc, body2)) : void_);
var mapAccum2 = /* @__PURE__ */ dual(3, (elements, initial, f) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let result = succeed(initial);
  let next;
  let i2 = 0;
  while (!(next = iterator.next()).done) {
    const index2 = i2++;
    const value = next.value;
    result = flatMap7(result, (state) => map9(f(state, value, index2), ([z4, b3]) => {
      builder.push(b3);
      return z4;
    }));
  }
  return map9(result, (z4) => [z4, builder]);
}));
var mapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (c) => failCauseSync(() => f(c)),
  onSuccess: succeed
}));
var memoize = (self2) => pipe(deferredMake(), flatMap7((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self2), intoDeferred(deferred), once, map9((complete) => zipRight(complete, pipe(deferredAwait(deferred), flatMap7(([patch10, a]) => as(zip2(patchFiberRefs(patch10[0]), updateRuntimeFlags(patch10[1])), a))))))));
var merge5 = (self2) => matchEffect(self2, {
  onFailure: (e) => succeed(e),
  onSuccess: succeed
});
var negate = (self2) => map9(self2, (b3) => !b3);
var none6 = (self2) => flatMap7(self2, (option) => {
  switch (option._tag) {
    case "None":
      return void_;
    case "Some":
      return fail2(new NoSuchElementException);
  }
});
var once = (self2) => map9(make28(true), (ref) => asVoid(whenEffect(self2, getAndSet2(ref, false))));
var option = (self2) => matchEffect(self2, {
  onFailure: () => succeed(none2()),
  onSuccess: (a) => succeed(some2(a))
});
var orElseFail = /* @__PURE__ */ dual(2, (self2, evaluate) => orElse2(self2, () => failSync(evaluate)));
var orElseSucceed = /* @__PURE__ */ dual(2, (self2, evaluate) => orElse2(self2, () => sync(evaluate)));
var parallelErrors = (self2) => matchCauseEffect(self2, {
  onFailure: (cause2) => {
    const errors = fromIterable(failures(cause2));
    return errors.length === 0 ? failCause(cause2) : fail2(errors);
  },
  onSuccess: succeed
});
var patchFiberRefs = (patch10) => updateFiberRefs((fiberId2, fiberRefs3) => pipe(patch10, patch9(fiberId2, fiberRefs3)));
var promise = (evaluate) => evaluate.length >= 1 ? async_((resolve, signal) => {
  try {
    evaluate(signal).then((a) => resolve(exitSucceed(a)), (e) => resolve(exitDie(e)));
  } catch (e) {
    resolve(exitDie(e));
  }
}) : async_((resolve) => {
  try {
    evaluate().then((a) => resolve(exitSucceed(a)), (e) => resolve(exitDie(e)));
  } catch (e) {
    resolve(exitDie(e));
  }
});
var provideService = /* @__PURE__ */ dual(3, (self2, tag, service) => contextWithEffect((env) => provideContext(self2, add2(env, tag, service))));
var provideServiceEffect = /* @__PURE__ */ dual(3, (self2, tag, effect) => contextWithEffect((env) => flatMap7(effect, (service) => provideContext(self2, pipe(env, add2(tag, service))))));
var random2 = /* @__PURE__ */ randomWith(succeed);
var reduce10 = /* @__PURE__ */ dual(3, (elements, zero3, f) => fromIterable(elements).reduce((acc, el, i2) => flatMap7(acc, (a) => f(a, el, i2)), succeed(zero3)));
var reduceRight2 = /* @__PURE__ */ dual(3, (elements, zero3, f) => fromIterable(elements).reduceRight((acc, el, i2) => flatMap7(acc, (a) => f(el, a, i2)), succeed(zero3)));
var reduceWhile = /* @__PURE__ */ dual(3, (elements, zero3, options) => flatMap7(sync(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop(iterator, 0, zero3, options.while, options.body)));
var reduceWhileLoop = (iterator, index2, state, predicate, f) => {
  const next = iterator.next();
  if (!next.done && predicate(state)) {
    return flatMap7(f(state, next.value, index2), (nextState) => reduceWhileLoop(iterator, index2 + 1, nextState, predicate, f));
  }
  return succeed(state);
};
var repeatN = /* @__PURE__ */ dual(2, (self2, n) => suspend(() => repeatNLoop(self2, n)));
var repeatNLoop = (self2, n) => flatMap7(self2, (a) => n <= 0 ? succeed(a) : zipRight(yieldNow(), repeatNLoop(self2, n - 1)));
var sandbox = (self2) => matchCauseEffect(self2, {
  onFailure: fail2,
  onSuccess: succeed
});
var setFiberRefs = (fiberRefs3) => suspend(() => setAll2(fiberRefs3));
var sleep3 = sleep2;
var succeedNone = /* @__PURE__ */ succeed(/* @__PURE__ */ none2());
var succeedSome = (value) => succeed(some2(value));
var summarized = /* @__PURE__ */ dual(3, (self2, summary, f) => flatMap7(summary, (start2) => flatMap7(self2, (value) => map9(summary, (end) => [f(start2, end), value]))));
var tagMetrics = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [make29(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k2, v2]) => make29(k2, v2)));
});
var labelMetrics = /* @__PURE__ */ dual(2, (self2, labels) => fiberRefLocallyWith(self2, currentMetricLabels, (old) => union2(old, labels)));
var takeUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let effect = succeed(false);
  let i2 = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index2 = i2++;
    effect = flatMap7(effect, (bool) => {
      if (bool) {
        return succeed(true);
      }
      builder.push(a);
      return predicate(a, index2);
    });
  }
  return map9(effect, () => builder);
}));
var takeWhile = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let taking = succeed(true);
  let i2 = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index2 = i2++;
    taking = flatMap7(taking, (taking2) => pipe(taking2 ? predicate(a, index2) : succeed(false), map9((bool) => {
      if (bool) {
        builder.push(a);
      }
      return bool;
    })));
  }
  return map9(taking, () => builder);
}));
var tapBoth = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => matchCauseEffect(self2, {
  onFailure: (cause2) => {
    const either3 = failureOrCause(cause2);
    switch (either3._tag) {
      case "Left": {
        return zipRight(onFailure(either3.left), failCause(cause2));
      }
      case "Right": {
        return failCause(cause2);
      }
    }
  },
  onSuccess: (a) => as(onSuccess(a), a)
}));
var tapDefect = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause(self2, (cause2) => match2(keepDefects(cause2), {
  onNone: () => failCause(cause2),
  onSome: (a) => zipRight(f(a), failCause(cause2))
})));
var tapError = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause2) => {
    const either3 = failureOrCause(cause2);
    switch (either3._tag) {
      case "Left":
        return zipRight(f(either3.left), failCause(cause2));
      case "Right":
        return failCause(cause2);
    }
  },
  onSuccess: succeed
}));
var tapErrorTag = /* @__PURE__ */ dual(3, (self2, k2, f) => tapError(self2, (e) => {
  if (isTagged(e, k2)) {
    return f(e);
  }
  return void_;
}));
var tapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause2) => zipRight(f(cause2), failCause(cause2)),
  onSuccess: succeed
}));
var timed = (self2) => timedWith(self2, currentTimeNanos2);
var timedWith = /* @__PURE__ */ dual(2, (self2, nanos2) => summarized(self2, nanos2, (start2, end) => nanos(end - start2)));
var tracerWith3 = tracerWith2;
var tracer2 = /* @__PURE__ */ tracerWith3(succeed);
var tryPromise = (arg) => {
  let evaluate;
  let catcher = undefined;
  if (typeof arg === "function") {
    evaluate = arg;
  } else {
    evaluate = arg.try;
    catcher = arg.catch;
  }
  const fail4 = (e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
  if (evaluate.length >= 1) {
    return async_((resolve, signal) => {
      try {
        evaluate(signal).then((a) => resolve(exitSucceed(a)), (e) => resolve(fail4(e)));
      } catch (e) {
        resolve(fail4(e));
      }
    });
  }
  return async_((resolve) => {
    try {
      evaluate().then((a) => resolve(exitSucceed(a)), (e) => resolve(fail4(e)));
    } catch (e) {
      resolve(fail4(e));
    }
  });
};
var tryMap = /* @__PURE__ */ dual(2, (self2, options) => flatMap7(self2, (a) => try_2({
  try: () => options.try(a),
  catch: options.catch
})));
var tryMapPromise = /* @__PURE__ */ dual(2, (self2, options) => flatMap7(self2, (a) => tryPromise({
  try: options.try.length >= 1 ? (signal) => options.try(a, signal) : () => options.try(a),
  catch: options.catch
})));
var unless = /* @__PURE__ */ dual(2, (self2, condition) => suspend(() => condition() ? succeedNone : asSome(self2)));
var unlessEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap7(condition, (b3) => b3 ? succeedNone : asSome(self2)));
var unsandbox = (self2) => mapErrorCause(self2, flatten4);
var updateFiberRefs = (f) => withFiberRuntime((state) => {
  state.setFiberRefs(f(state.id(), state.getFiberRefs()));
  return void_;
});
var updateService = /* @__PURE__ */ dual(3, (self2, tag, f) => mapInputContext(self2, (context2) => add2(context2, tag, f(unsafeGet3(context2, tag)))));
var when = /* @__PURE__ */ dual(2, (self2, condition) => suspend(() => condition() ? map9(self2, some2) : succeed(none2())));
var whenFiberRef = /* @__PURE__ */ dual(3, (self2, fiberRef, predicate) => flatMap7(fiberRefGet(fiberRef), (s2) => predicate(s2) ? map9(self2, (a) => [s2, some2(a)]) : succeed([s2, none2()])));
var whenRef = /* @__PURE__ */ dual(3, (self2, ref, predicate) => flatMap7(get12(ref), (s2) => predicate(s2) ? map9(self2, (a) => [s2, some2(a)]) : succeed([s2, none2()])));
var withMetric = /* @__PURE__ */ dual(2, (self2, metric) => metric(self2));
var serviceFunctionEffect = (getService, f) => (...args2) => flatMap7(getService, (a) => f(a)(...args2));
var serviceFunction = (getService, f) => (...args2) => map9(getService, (a) => f(a)(...args2));
var serviceFunctions = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return (...args2) => flatMap7(getService, (s2) => s2[prop](...args2));
  }
});
var serviceConstants = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return flatMap7(getService, (s2) => isEffect(s2[prop]) ? s2[prop] : succeed(s2[prop]));
  }
});
var serviceMembers = (getService) => ({
  functions: serviceFunctions(getService),
  constants: serviceConstants(getService)
});
var serviceOption = (tag) => map9(context(), getOption2(tag));
var serviceOptional = (tag) => flatMap7(context(), getOption2(tag));
var annotateCurrentSpan = function() {
  const args2 = arguments;
  return ignore(flatMap7(currentSpan, (span2) => sync(() => {
    if (typeof args2[0] === "string") {
      span2.attribute(args2[0], args2[1]);
    } else {
      for (const key in args2[0]) {
        span2.attribute(key, args2[0][key]);
      }
    }
  })));
};
var linkSpanCurrent = function() {
  const args2 = arguments;
  const links = Array.isArray(args2[0]) ? args2[0] : [{
    _tag: "SpanLink",
    span: args2[0],
    attributes: args2[1] ?? {}
  }];
  return ignore(flatMap7(currentSpan, (span2) => sync(() => span2.addLinks(links))));
};
var annotateSpans = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations2) => Object.entries(args2[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
});
var currentParentSpan = /* @__PURE__ */ serviceOptional(spanTag);
var currentSpan = /* @__PURE__ */ flatMap7(/* @__PURE__ */ context(), (context2) => {
  const span2 = context2.unsafeMap.get(spanTag.key);
  return span2 !== undefined && span2._tag === "Span" ? succeed(span2) : fail2(new NoSuchElementException);
});
var linkSpans = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, span2, attributes) => fiberRefLocallyWith(self2, currentTracerSpanLinks, append2({
  _tag: "SpanLink",
  span: span2,
  attributes: attributes ?? {}
})));
var bigint03 = /* @__PURE__ */ BigInt(0);
var filterDisablePropagation = /* @__PURE__ */ flatMap((span2) => get3(span2.context, DisablePropagation) ? span2._tag === "Span" ? filterDisablePropagation(span2.parent) : none2() : some2(span2));
var unsafeMakeSpan = (fiber, name2, options) => {
  const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options.context && get3(options.context, DisablePropagation);
  const context2 = fiber.getFiberRef(currentContext);
  const parent = options.parent ? some2(options.parent) : options.root ? none2() : filterDisablePropagation(getOption2(context2, spanTag));
  let span2;
  if (disablePropagation) {
    span2 = noopSpan({
      name: name2,
      parent,
      context: add2(options.context ?? empty4(), DisablePropagation, true)
    });
  } else {
    const services = fiber.getFiberRef(currentServices);
    const tracer3 = get3(services, tracerTag);
    const clock2 = get3(services, Clock);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const fiberRefs3 = fiber.getFiberRefs();
    const annotationsFromEnv = get10(fiberRefs3, currentTracerSpanAnnotations);
    const linksFromEnv = get10(fiberRefs3, currentTracerSpanLinks);
    const links = linksFromEnv._tag === "Some" ? options.links !== undefined ? [...toReadonlyArray(linksFromEnv.value), ...options.links ?? []] : toReadonlyArray(linksFromEnv.value) : options.links ?? empty2();
    span2 = tracer3.span(name2, parent, options.context ?? empty4(), links, timingEnabled ? clock2.unsafeCurrentTimeNanos() : bigint03, options.kind ?? "internal");
    if (annotationsFromEnv._tag === "Some") {
      forEach4(annotationsFromEnv.value, (value, key) => span2.attribute(key, value));
    }
    if (options.attributes !== undefined) {
      Object.entries(options.attributes).forEach(([k2, v2]) => span2.attribute(k2, v2));
    }
  }
  if (typeof options.captureStackTrace === "function") {
    spanToTrace.set(span2, options.captureStackTrace);
  }
  return span2;
};
var makeSpan = (name2, options) => {
  options = addSpanStackTrace(options);
  return withFiberRuntime((fiber) => succeed(unsafeMakeSpan(fiber, name2, options)));
};
var spanAnnotations = /* @__PURE__ */ fiberRefGet(currentTracerSpanAnnotations);
var spanLinks = /* @__PURE__ */ fiberRefGet(currentTracerSpanLinks);
var endSpan = (span2, exit2, clock2, timingEnabled) => sync(() => {
  if (span2.status._tag === "Ended") {
    return;
  }
  if (exitIsFailure(exit2) && spanToTrace.has(span2)) {
    span2.attribute("code.stacktrace", spanToTrace.get(span2)());
  }
  span2.end(timingEnabled ? clock2.unsafeCurrentTimeNanos() : bigint03, exit2);
});
var useSpan = (name2, ...args2) => {
  const options = addSpanStackTrace(args2.length === 1 ? undefined : args2[0]);
  const evaluate = args2[args2.length - 1];
  return withFiberRuntime((fiber) => {
    const span2 = unsafeMakeSpan(fiber, name2, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock2 = get3(fiber.getFiberRef(currentServices), clockTag);
    return onExit(evaluate(span2), (exit2) => endSpan(span2, exit2, clock2, timingEnabled));
  });
};
var withParentSpan = /* @__PURE__ */ dual(2, (self2, span2) => provideService(self2, spanTag, span2));
var withSpan = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name2 = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return useSpan(name2, options, (span2) => withParentSpan(self2, span2));
  }
  return (self2) => useSpan(name2, options, (span2) => withParentSpan(self2, span2));
};
var functionWithSpan = (options) => function() {
  let captureStackTrace = options.captureStackTrace ?? false;
  if (options.captureStackTrace !== false) {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error = new Error;
    Error.stackTraceLimit = limit;
    let cache = false;
    captureStackTrace = () => {
      if (cache !== false) {
        return cache;
      }
      if (error.stack) {
        const stack = error.stack.trim().split(`
`);
        cache = stack.slice(2).join(`
`).trim();
        return cache;
      }
    };
  }
  return suspend(() => {
    const opts = typeof options.options === "function" ? options.options.apply(null, arguments) : options.options;
    return withSpan(suspend(() => internalCall(() => options.body.apply(this, arguments))), opts.name, {
      ...opts,
      captureStackTrace
    });
  });
};
var fromNullable2 = (value) => value == null ? fail2(new NoSuchElementException) : succeed(value);
var optionFromOptional = (self2) => catchAll(map9(self2, some2), (error) => isNoSuchElementException(error) ? succeedNone : fail2(error));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/executionStrategy.js
var OP_SEQUENTIAL2 = "Sequential";
var OP_PARALLEL2 = "Parallel";
var OP_PARALLEL_N = "ParallelN";
var sequential2 = {
  _tag: OP_SEQUENTIAL2
};
var parallel2 = {
  _tag: OP_PARALLEL2
};
var parallelN = (parallelism) => ({
  _tag: OP_PARALLEL_N,
  parallelism
});
var isSequential = (self2) => self2._tag === OP_SEQUENTIAL2;
var isParallel = (self2) => self2._tag === OP_PARALLEL2;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential3 = sequential2;
var parallel3 = parallel2;
var parallelN2 = parallelN;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/FiberRefsPatch.js
var diff9 = diff8;
var patch10 = patch9;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/fiberStatus.js
var FiberStatusSymbolKey = "effect/FiberStatus";
var FiberStatusTypeId = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
var OP_DONE = "Done";
var OP_RUNNING = "Running";
var OP_SUSPENDED = "Suspended";
var DoneHash = /* @__PURE__ */ string(`${FiberStatusSymbolKey}-${OP_DONE}`);

class Done {
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_DONE;
  [symbol]() {
    return DoneHash;
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
}

class Running {
  runtimeFlags;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_RUNNING;
  constructor(runtimeFlags2) {
    this.runtimeFlags = runtimeFlags2;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
}

class Suspended {
  runtimeFlags;
  blockingOn;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_SUSPENDED;
  constructor(runtimeFlags2, blockingOn) {
    this.runtimeFlags = runtimeFlags2;
    this.blockingOn = blockingOn;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), combine(hash(this.blockingOn)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
  }
}
var done3 = /* @__PURE__ */ new Done;
var running = (runtimeFlags2) => new Running(runtimeFlags2);
var suspended = (runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn);
var isFiberStatus = (u3) => hasProperty(u3, FiberStatusTypeId);
var isDone = (self2) => self2._tag === OP_DONE;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/FiberStatus.js
var done4 = done3;
var running2 = running;
var suspended2 = suspended;
var isDone2 = isDone;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Micro.js
var TypeId14 = /* @__PURE__ */ Symbol.for("effect/Micro");
var MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
var MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
var microCauseVariance = {
  _E: identity
};

class MicroCauseImpl extends globalThis.Error {
  _tag;
  traces;
  [MicroCauseTypeId];
  constructor(_tag, originalError, traces) {
    const causeName = `MicroCause.${_tag}`;
    let name2;
    let message;
    let stack;
    if (originalError instanceof globalThis.Error) {
      name2 = `(${causeName}) ${originalError.name}`;
      message = originalError.message;
      const messageLines = message.split(`
`).length;
      stack = originalError.stack ? `(${causeName}) ${originalError.stack.split(`
`).slice(0, messageLines + 3).join(`
`)}` : `${name2}: ${message}`;
    } else {
      name2 = causeName;
      message = toStringUnknown(originalError, 0);
      stack = `${name2}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `
    ${traces.join(`
    `)}`;
    }
    super(message);
    this._tag = _tag;
    this.traces = traces;
    this[MicroCauseTypeId] = microCauseVariance;
    this.name = name2;
    this.stack = stack;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [NodeInspectSymbol]() {
    return this.stack;
  }
}
class Die extends MicroCauseImpl {
  defect;
  constructor(defect, traces = []) {
    super("Die", defect, traces);
    this.defect = defect;
  }
}
var causeDie = (defect, traces = []) => new Die(defect, traces);

class Interrupt extends MicroCauseImpl {
  constructor(traces = []) {
    super("Interrupt", "interrupted", traces);
  }
}
var causeInterrupt = (traces = []) => new Interrupt(traces);
var causeIsInterrupt = (self2) => self2._tag === "Interrupt";
var MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
var fiberVariance = {
  _A: identity,
  _E: identity
};

class MicroFiberImpl {
  context;
  interruptible;
  [MicroFiberTypeId];
  _stack = [];
  _observers = [];
  _exit;
  _children;
  currentOpCount = 0;
  constructor(context2, interruptible3 = true) {
    this.context = context2;
    this.interruptible = interruptible3;
    this[MicroFiberTypeId] = fiberVariance;
  }
  getRef(ref) {
    return unsafeGetReference(this.context, ref);
  }
  addObserver(cb) {
    if (this._exit) {
      cb(this._exit);
      return constVoid;
    }
    this._observers.push(cb);
    return () => {
      const index2 = this._observers.indexOf(cb);
      if (index2 >= 0) {
        this._observers.splice(index2, 1);
      }
    };
  }
  _interrupted = false;
  unsafeInterrupt() {
    if (this._exit) {
      return;
    }
    this._interrupted = true;
    if (this.interruptible) {
      this.evaluate(exitInterrupt2);
    }
  }
  unsafePoll() {
    return this._exit;
  }
  evaluate(effect) {
    if (this._exit) {
      return;
    } else if (this._yielded !== undefined) {
      const yielded = this._yielded;
      this._yielded = undefined;
      yielded();
    }
    const exit2 = this.runLoop(effect);
    if (exit2 === Yield) {
      return;
    }
    const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
    if (interruptChildren !== undefined) {
      return this.evaluate(flatMap8(interruptChildren, () => exit2));
    }
    this._exit = exit2;
    for (let i2 = 0;i2 < this._observers.length; i2++) {
      this._observers[i2](exit2);
    }
    this._observers.length = 0;
  }
  runLoop(effect) {
    let yielding = false;
    let current = effect;
    this.currentOpCount = 0;
    try {
      while (true) {
        this.currentOpCount++;
        if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
          yielding = true;
          const prev = current;
          current = flatMap8(yieldNow2, () => prev);
        }
        current = current[evaluate](this);
        if (current === Yield) {
          const yielded = this._yielded;
          if (MicroExitTypeId in yielded) {
            this._yielded = undefined;
            return yielded;
          }
          return Yield;
        }
      }
    } catch (error) {
      if (!hasProperty(current, evaluate)) {
        return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
      }
      return exitDie2(error);
    }
  }
  getCont(symbol3) {
    while (true) {
      const op = this._stack.pop();
      if (!op)
        return;
      const cont = op[ensureCont] && op[ensureCont](this);
      if (cont)
        return {
          [symbol3]: cont
        };
      if (op[symbol3])
        return op;
    }
  }
  _yielded = undefined;
  yieldWith(value) {
    this._yielded = value;
    return Yield;
  }
  children() {
    return this._children ??= new Set;
  }
}
var fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({
  interruptChildren: undefined
}));
var identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
var args2 = /* @__PURE__ */ Symbol.for("effect/Micro/args");
var evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
var successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
var failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
var ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
var Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
var microVariance = {
  _A: identity,
  _E: identity,
  _R: identity
};
var MicroProto = {
  ...EffectPrototype2,
  _op: "Micro",
  [TypeId14]: microVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  toJSON() {
    return {
      _id: "Micro",
      op: this[identifier],
      ...args2 in this ? {
        args: this[args2]
      } : undefined
    };
  },
  toString() {
    return format(this);
  },
  [NodeInspectSymbol]() {
    return format(this);
  }
};
function defaultEvaluate(_fiber) {
  return exitDie2(`Micro.evaluate: Not implemented`);
}
var makePrimitiveProto = (options) => ({
  ...MicroProto,
  [identifier]: options.op,
  [evaluate]: options.eval ?? defaultEvaluate,
  [successCont]: options.contA,
  [failureCont]: options.contE,
  [ensureCont]: options.ensure
});
var makePrimitive = (options) => {
  const Proto2 = makePrimitiveProto(options);
  return function() {
    const self2 = Object.create(Proto2);
    self2[args2] = options.single === false ? arguments : arguments[0];
    return self2;
  };
};
var makeExit = (options) => {
  const Proto2 = {
    ...makePrimitiveProto(options),
    [MicroExitTypeId]: MicroExitTypeId,
    _tag: options.op,
    get [options.prop]() {
      return this[args2];
    },
    toJSON() {
      return {
        _id: "MicroExit",
        _tag: options.op,
        [options.prop]: this[args2]
      };
    },
    [symbol2](that) {
      return isMicroExit(that) && that._tag === options.op && equals(this[args2], that[args2]);
    },
    [symbol]() {
      return cached(this, combine(string(options.op))(hash(this[args2])));
    }
  };
  return function(value) {
    const self2 = Object.create(Proto2);
    self2[args2] = value;
    self2[successCont] = undefined;
    self2[failureCont] = undefined;
    self2[ensureCont] = undefined;
    return self2;
  };
};
var succeed3 = /* @__PURE__ */ makeExit({
  op: "Success",
  prop: "value",
  eval(fiber) {
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](this[args2], fiber) : fiber.yieldWith(this);
  }
});
var failCause3 = /* @__PURE__ */ makeExit({
  op: "Failure",
  prop: "cause",
  eval(fiber) {
    let cont = fiber.getCont(failureCont);
    while (causeIsInterrupt(this[args2]) && cont && fiber.interruptible) {
      cont = fiber.getCont(failureCont);
    }
    return cont ? cont[failureCont](this[args2], fiber) : fiber.yieldWith(this);
  }
});
var yieldNowWith = /* @__PURE__ */ makePrimitive({
  op: "Yield",
  eval(fiber) {
    let resumed = false;
    fiber.getRef(CurrentScheduler).scheduleTask(() => {
      if (resumed)
        return;
      fiber.evaluate(exitVoid2);
    }, this[args2] ?? 0);
    return fiber.yieldWith(() => {
      resumed = true;
    });
  }
});
var yieldNow2 = /* @__PURE__ */ yieldNowWith(0);
var void_2 = /* @__PURE__ */ succeed3(undefined);
var withMicroFiber = /* @__PURE__ */ makePrimitive({
  op: "WithMicroFiber",
  eval(fiber) {
    return this[args2](fiber);
  }
});
var flatMap8 = /* @__PURE__ */ dual(2, (self2, f) => {
  const onSuccess = Object.create(OnSuccessProto);
  onSuccess[args2] = self2;
  onSuccess[successCont] = f;
  return onSuccess;
});
var OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccess",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args2];
  }
});
var isMicroExit = (u3) => hasProperty(u3, MicroExitTypeId);
var exitSucceed2 = succeed3;
var exitFailCause2 = failCause3;
var exitInterrupt2 = /* @__PURE__ */ exitFailCause2(/* @__PURE__ */ causeInterrupt());
var exitDie2 = (defect) => exitFailCause2(causeDie(defect));
var exitVoid2 = /* @__PURE__ */ exitSucceed2(undefined);
var setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);

class MicroSchedulerDefault {
  tasks = [];
  running = false;
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate(this.afterScheduled);
    }
  }
  afterScheduled = () => {
    this.running = false;
    this.runTasks();
  };
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i2 = 0, len = tasks.length;i2 < len; i2++) {
      tasks[i2]();
    }
  }
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
  }
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
}
var updateContext = /* @__PURE__ */ dual(2, (self2, f) => withMicroFiber((fiber) => {
  const prev = fiber.context;
  fiber.context = f(prev);
  return onExit2(self2, () => {
    fiber.context = prev;
    return void_2;
  });
}));
var provideContext2 = /* @__PURE__ */ dual(2, (self2, provided) => updateContext(self2, merge3(provided)));
class MaxOpsBeforeYield extends (/* @__PURE__ */ Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
  defaultValue: () => 2048
})) {
}
class CurrentScheduler extends (/* @__PURE__ */ Reference2()("effect/Micro/currentScheduler", {
  defaultValue: () => new MicroSchedulerDefault
})) {
}
var matchCauseEffect2 = /* @__PURE__ */ dual(2, (self2, options) => {
  const primitive = Object.create(OnSuccessAndFailureProto);
  primitive[args2] = self2;
  primitive[successCont] = options.onSuccess;
  primitive[failureCont] = options.onFailure;
  return primitive;
});
var OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccessAndFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args2];
  }
});
var onExit2 = /* @__PURE__ */ dual(2, (self2, f) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self2), {
  onFailure: (cause2) => flatMap8(f(exitFailCause2(cause2)), () => failCause3(cause2)),
  onSuccess: (a) => flatMap8(f(exitSucceed2(a)), () => succeed3(a))
})));
var setInterruptible = /* @__PURE__ */ makePrimitive({
  op: "SetInterruptible",
  ensure(fiber) {
    fiber.interruptible = this[args2];
    if (fiber._interrupted && fiber.interruptible) {
      return () => exitInterrupt2;
    }
  }
});
var interruptible3 = (self2) => withMicroFiber((fiber) => {
  if (fiber.interruptible)
    return self2;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible(false));
  if (fiber._interrupted)
    return exitInterrupt2;
  return self2;
});
var uninterruptibleMask2 = (f) => withMicroFiber((fiber) => {
  if (!fiber.interruptible)
    return f(identity);
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return f(interruptible3);
});
var runFork = (effect, options) => {
  const fiber = new MicroFiberImpl(CurrentScheduler.context(options?.scheduler ?? new MicroSchedulerDefault));
  fiber.evaluate(effect);
  if (options?.signal) {
    if (options.signal.aborted) {
      fiber.unsafeInterrupt();
    } else {
      const abort2 = () => fiber.unsafeInterrupt();
      options.signal.addEventListener("abort", abort2, {
        once: true
      });
      fiber.addObserver(() => options.signal.removeEventListener("abort", abort2));
    }
  }
  return fiber;
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Scheduler.js
class PriorityBuckets {
  buckets = [];
  scheduleTask(task, priority) {
    const length2 = this.buckets.length;
    let bucket = undefined;
    let index2 = 0;
    for (;index2 < length2; index2++) {
      if (this.buckets[index2][0] <= priority) {
        bucket = this.buckets[index2];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index2 === length2) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index2, 0, [priority, [task]]);
    }
  }
}

class MixedScheduler {
  maxNextTickBeforeTimer;
  running = false;
  tasks = /* @__PURE__ */ new PriorityBuckets;
  constructor(maxNextTickBeforeTimer) {
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_2, toRun] of tasks) {
      for (let i2 = 0;i2 < toRun.length; i2++) {
        toRun[i2]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(undefined).then(() => this.starveInternal(depth + 1));
    }
  }
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
}
var defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));

class SyncScheduler {
  tasks = /* @__PURE__ */ new PriorityBuckets;
  deferred = false;
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_2, toRun] of tasks) {
        for (let i2 = 0;i2 < toRun.length; i2++) {
          toRun[i2]();
        }
      }
    }
    this.deferred = true;
  }
}
var currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
var withScheduler = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentScheduler, scheduler));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/completedRequestMap.js
var currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(new Map));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/concurrency.js
var match9 = (concurrency, sequential4, unbounded2, bounded) => {
  switch (concurrency) {
    case undefined:
      return sequential4();
    case "unbounded":
      return unbounded2();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded2() : concurrency2 > 1 ? bounded(concurrency2) : sequential4());
    default:
      return concurrency > 1 ? bounded(concurrency) : sequential4();
  }
};
var matchSimple = (concurrency, sequential4, concurrent) => {
  switch (concurrency) {
    case undefined:
      return sequential4();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential4());
    default:
      return concurrency > 1 ? concurrent() : sequential4();
  }
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/fiberMessage.js
var OP_INTERRUPT_SIGNAL = "InterruptSignal";
var OP_STATEFUL = "Stateful";
var OP_RESUME = "Resume";
var OP_YIELD_NOW = "YieldNow";
var interruptSignal = (cause2) => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause: cause2
});
var stateful = (onFiber) => ({
  _tag: OP_STATEFUL,
  onFiber
});
var resume = (effect) => ({
  _tag: OP_RESUME,
  effect
});
var yieldNow3 = () => ({
  _tag: OP_YIELD_NOW
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey = "effect/FiberScope";
var FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);

class Global {
  [FiberScopeTypeId] = FiberScopeTypeId;
  fiberId = none4;
  roots = /* @__PURE__ */ new Set;
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
}

class Local {
  fiberId;
  parent;
  [FiberScopeTypeId] = FiberScopeTypeId;
  constructor(fiberId2, parent) {
    this.fiberId = fiberId2;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful((parentFiber) => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
}
var unsafeMake7 = (fiber) => {
  return new Local(fiber.id(), fiber);
};
var globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global);

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey = "effect/Fiber";
var FiberTypeId = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
var fiberVariance2 = {
  _E: (_2) => _2,
  _A: (_2) => _2
};
var fiberProto = {
  [FiberTypeId]: fiberVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var RuntimeFiberSymbolKey = "effect/Fiber";
var RuntimeFiberTypeId = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
var _await2 = (self2) => self2.await;
var inheritAll = (self2) => self2.inheritAll;
var interruptAsFork = /* @__PURE__ */ dual(2, (self2, fiberId2) => self2.interruptAsFork(fiberId2));
var join2 = (self2) => zipLeft(flatten5(self2.await), self2.inheritAll);
var _never = {
  ...CommitPrototype,
  commit() {
    return join2(this);
  },
  ...fiberProto,
  id: () => none4,
  await: never,
  children: /* @__PURE__ */ succeed([]),
  inheritAll: never,
  poll: /* @__PURE__ */ succeed(/* @__PURE__ */ none2()),
  interruptAsFork: () => never
};
var currentFiberURI = "effect/FiberCurrent";

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/logger.js
var LoggerSymbolKey = "effect/Logger";
var LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
var loggerVariance = {
  _Message: (_2) => _2,
  _Output: (_2) => _2
};
var makeLogger = (log2) => ({
  [LoggerTypeId]: loggerVariance,
  log: log2,
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var none7 = {
  [LoggerTypeId]: loggerVariance,
  log: constVoid,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var textOnly = /^[^\s"=]*$/;
var format4 = (quoteValue, whitespace) => ({
  annotations: annotations2,
  cause: cause2,
  date: date2,
  fiberId: fiberId2,
  logLevel,
  message,
  spans
}) => {
  const formatValue = (value) => value.match(textOnly) ? value : quoteValue(value);
  const format5 = (label, value) => `${formatLabel(label)}=${formatValue(value)}`;
  const append4 = (label, value) => " " + format5(label, value);
  let out2 = format5("timestamp", date2.toISOString());
  out2 += append4("level", logLevel.label);
  out2 += append4("fiber", threadName(fiberId2));
  const messages2 = ensure(message);
  for (let i2 = 0;i2 < messages2.length; i2++) {
    out2 += append4("message", toStringUnknown(messages2[i2], whitespace));
  }
  if (!isEmptyType(cause2)) {
    out2 += append4("cause", pretty(cause2, {
      renderErrorCause: true
    }));
  }
  for (const span2 of spans) {
    out2 += " " + render(date2.getTime())(span2);
  }
  for (const [label, value] of annotations2) {
    out2 += append4(label, toStringUnknown(value, whitespace));
  }
  return out2;
};
var escapeDoubleQuotes = (s2) => `"${s2.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
var stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format4(escapeDoubleQuotes));
var logfmtLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format4(JSON.stringify, 0));
var colors = {
  bold: "1",
  red: "31",
  green: "32",
  yellow: "33",
  blue: "34",
  cyan: "36",
  white: "37",
  gray: "90",
  black: "30",
  bgBrightRed: "101"
};
var logLevelColors = {
  None: [],
  All: [],
  Trace: [colors.gray],
  Debug: [colors.blue],
  Info: [colors.green],
  Warning: [colors.yellow],
  Error: [colors.red],
  Fatal: [colors.bgBrightRed, colors.black]
};
var hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
var processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
var hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/metric/boundaries.js
var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
var MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);

class MetricBoundariesImpl {
  values;
  [MetricBoundariesTypeId] = MetricBoundariesTypeId;
  constructor(values3) {
    this.values = values3;
    this._hash = pipe(string(MetricBoundariesSymbolKey), combine(array2(this.values)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u3) {
    return isMetricBoundaries(u3) && equals(this.values, u3.values);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var isMetricBoundaries = (u3) => hasProperty(u3, MetricBoundariesTypeId);
var fromIterable8 = (iterable) => {
  const values3 = pipe(iterable, appendAll(of2(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values3);
};
var exponential = (options) => pipe(makeBy(options.count - 1, (i2) => options.start * Math.pow(options.factor, i2)), unsafeFromArray, fromIterable8);

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/metric/keyType.js
var MetricKeyTypeSymbolKey = "effect/MetricKeyType";
var MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
var CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
var FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
var FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
var GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
var GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
var HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
var SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
var SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
var metricKeyTypeVariance = {
  _In: (_2) => _2,
  _Out: (_2) => _2
};

class CounterKeyType {
  incremental;
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
  constructor(incremental, bigint4) {
    this.incremental = incremental;
    this.bigint = bigint4;
    this._hash = string(CounterKeyTypeSymbolKey);
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isCounterKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
class HistogramKeyType {
  boundaries;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
  constructor(boundaries) {
    this.boundaries = boundaries;
    this._hash = pipe(string(HistogramKeyTypeSymbolKey), combine(hash(this.boundaries)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var counter = (options) => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);
var histogram = (boundaries) => {
  return new HistogramKeyType(boundaries);
};
var isCounterKey = (u3) => hasProperty(u3, CounterKeyTypeTypeId);
var isFrequencyKey = (u3) => hasProperty(u3, FrequencyKeyTypeTypeId);
var isGaugeKey = (u3) => hasProperty(u3, GaugeKeyTypeTypeId);
var isHistogramKey = (u3) => hasProperty(u3, HistogramKeyTypeTypeId);
var isSummaryKey = (u3) => hasProperty(u3, SummaryKeyTypeTypeId);

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey = "effect/MetricKey";
var MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
var metricKeyVariance = {
  _Type: (_2) => _2
};
var arrayEquivilence = /* @__PURE__ */ getEquivalence3(equals);

class MetricKeyImpl {
  name;
  keyType;
  description;
  tags;
  [MetricKeyTypeId] = metricKeyVariance;
  constructor(name2, keyType, description, tags = []) {
    this.name = name2;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags;
    this._hash = pipe(string(this.name + this.description), combine(hash(this.keyType)), combine(array2(this.tags)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u3) {
    return isMetricKey(u3) && this.name === u3.name && equals(this.keyType, u3.keyType) && equals(this.description, u3.description) && arrayEquivilence(this.tags, u3.tags);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var isMetricKey = (u3) => hasProperty(u3, MetricKeyTypeId);
var counter2 = (name2, options) => new MetricKeyImpl(name2, counter(options), fromNullable(options?.description));
var histogram2 = (name2, boundaries, description) => new MetricKeyImpl(name2, histogram(boundaries), fromNullable(description));
var taggedWithLabels = /* @__PURE__ */ dual(2, (self2, extraTags) => extraTags.length === 0 ? self2 : new MetricKeyImpl(self2.name, self2.keyType, self2.description, union2(self2.tags, extraTags)));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/metric/state.js
var MetricStateSymbolKey = "effect/MetricState";
var MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
var CounterStateSymbolKey = "effect/MetricState/Counter";
var CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
var FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
var GaugeStateSymbolKey = "effect/MetricState/Gauge";
var GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
var HistogramStateSymbolKey = "effect/MetricState/Histogram";
var HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
var SummaryStateSymbolKey = "effect/MetricState/Summary";
var SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
var metricStateVariance = {
  _A: (_2) => _2
};

class CounterState {
  count;
  [MetricStateTypeId] = metricStateVariance;
  [CounterStateTypeId] = CounterStateTypeId;
  constructor(count) {
    this.count = count;
  }
  [symbol]() {
    return pipe(hash(CounterStateSymbolKey), combine(hash(this.count)), cached(this));
  }
  [symbol2](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var arrayEquals = /* @__PURE__ */ getEquivalence3(equals);

class FrequencyState {
  occurrences;
  [MetricStateTypeId] = metricStateVariance;
  [FrequencyStateTypeId] = FrequencyStateTypeId;
  constructor(occurrences) {
    this.occurrences = occurrences;
  }
  _hash;
  [symbol]() {
    return pipe(string(FrequencyStateSymbolKey), combine(array2(fromIterable(this.occurrences.entries()))), cached(this));
  }
  [symbol2](that) {
    return isFrequencyState(that) && arrayEquals(fromIterable(this.occurrences.entries()), fromIterable(that.occurrences.entries()));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}

class GaugeState {
  value;
  [MetricStateTypeId] = metricStateVariance;
  [GaugeStateTypeId] = GaugeStateTypeId;
  constructor(value) {
    this.value = value;
  }
  [symbol]() {
    return pipe(hash(GaugeStateSymbolKey), combine(hash(this.value)), cached(this));
  }
  [symbol2](u3) {
    return isGaugeState(u3) && this.value === u3.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}

class HistogramState {
  buckets;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [HistogramStateTypeId] = HistogramStateTypeId;
  constructor(buckets, count, min2, max2, sum) {
    this.buckets = buckets;
    this.count = count;
    this.min = min2;
    this.max = max2;
    this.sum = sum;
  }
  [symbol]() {
    return pipe(hash(HistogramStateSymbolKey), combine(hash(this.buckets)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}

class SummaryState {
  error;
  quantiles;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [SummaryStateTypeId] = SummaryStateTypeId;
  constructor(error, quantiles, count, min2, max2, sum) {
    this.error = error;
    this.quantiles = quantiles;
    this.count = count;
    this.min = min2;
    this.max = max2;
    this.sum = sum;
  }
  [symbol]() {
    return pipe(hash(SummaryStateSymbolKey), combine(hash(this.error)), combine(hash(this.quantiles)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var counter3 = (count) => new CounterState(count);
var frequency2 = (occurrences) => {
  return new FrequencyState(occurrences);
};
var gauge2 = (count) => new GaugeState(count);
var histogram3 = (options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
var summary2 = (options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
var isCounterState = (u3) => hasProperty(u3, CounterStateTypeId);
var isFrequencyState = (u3) => hasProperty(u3, FrequencyStateTypeId);
var isGaugeState = (u3) => hasProperty(u3, GaugeStateTypeId);
var isHistogramState = (u3) => hasProperty(u3, HistogramStateTypeId);
var isSummaryState = (u3) => hasProperty(u3, SummaryStateTypeId);

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey = "effect/MetricHook";
var MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
var metricHookVariance = {
  _In: (_2) => _2,
  _Out: (_2) => _2
};
var make30 = (options) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var bigint04 = /* @__PURE__ */ BigInt(0);
var counter4 = (key) => {
  let sum = key.keyType.bigint ? bigint04 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value) => value >= bigint04 : (value) => value >= 0 : (_value) => true;
  const update4 = (value) => {
    if (canUpdate(value)) {
      sum = sum + value;
    }
  };
  return make30({
    get: () => counter3(sum),
    update: update4,
    modify: update4
  });
};
var frequency3 = (key) => {
  const values3 = new Map;
  for (const word of key.keyType.preregisteredWords) {
    values3.set(word, 0);
  }
  const update4 = (word) => {
    const slotCount = values3.get(word) ?? 0;
    values3.set(word, slotCount + 1);
  };
  return make30({
    get: () => frequency2(values3),
    update: update4,
    modify: update4
  });
};
var gauge3 = (_key, startAt) => {
  let value = startAt;
  return make30({
    get: () => gauge2(value),
    update: (v2) => {
      value = v2;
    },
    modify: (v2) => {
      value = value + v2;
    }
  });
};
var histogram4 = (key) => {
  const bounds = key.keyType.boundaries.values;
  const size6 = bounds.length;
  const values3 = new Uint32Array(size6 + 1);
  const boundaries = new Float32Array(size6);
  let count = 0;
  let sum = 0;
  let min2 = Number.MAX_VALUE;
  let max2 = Number.MIN_VALUE;
  pipe(bounds, sort(Order), map3((n, i2) => {
    boundaries[i2] = n;
  }));
  const update4 = (value) => {
    let from = 0;
    let to = size6;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      if (to === from + 1) {
        if (value <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values3[from] = values3[from] + 1;
    count = count + 1;
    sum = sum + value;
    if (value < min2) {
      min2 = value;
    }
    if (value > max2) {
      max2 = value;
    }
  };
  const getBuckets = () => {
    const builder = allocate(size6);
    let cumulated = 0;
    for (let i2 = 0;i2 < size6; i2++) {
      const boundary = boundaries[i2];
      const value = values3[i2];
      cumulated = cumulated + value;
      builder[i2] = [boundary, cumulated];
    }
    return builder;
  };
  return make30({
    get: () => histogram3({
      buckets: getBuckets(),
      count,
      min: min2,
      max: max2,
      sum
    }),
    update: update4,
    modify: update4
  });
};
var summary3 = (key) => {
  const {
    error,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe(quantiles, sort(Order));
  const values3 = allocate(maxSize);
  let head4 = 0;
  let count = 0;
  let sum = 0;
  let min2 = 0;
  let max2 = 0;
  const snapshot = (now) => {
    const builder = [];
    let i2 = 0;
    while (i2 !== maxSize - 1) {
      const item = values3[i2];
      if (item != null) {
        const [t, v2] = item;
        const age = millis(now - t);
        if (greaterThanOrEqualTo3(age, zero2) && lessThanOrEqualTo3(age, maxAge)) {
          builder.push(v2);
        }
      }
      i2 = i2 + 1;
    }
    return calculateQuantiles(error, sortedQuantiles, sort(builder, Order));
  };
  const observe = (value, timestamp2) => {
    if (maxSize > 0) {
      head4 = head4 + 1;
      const target = head4 % maxSize;
      values3[target] = [timestamp2, value];
    }
    min2 = count === 0 ? value : Math.min(min2, value);
    max2 = count === 0 ? value : Math.max(max2, value);
    count = count + 1;
    sum = sum + value;
  };
  return make30({
    get: () => summary2({
      error,
      quantiles: snapshot(Date.now()),
      count,
      min: min2,
      max: max2,
      sum
    }),
    update: ([value, timestamp2]) => observe(value, timestamp2),
    modify: ([value, timestamp2]) => observe(value, timestamp2)
  });
};
var calculateQuantiles = (error, sortedQuantiles, sortedSamples) => {
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return empty2();
  }
  const head4 = sortedQuantiles[0];
  const tail = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error, sampleCount, none2(), 0, head4, sortedSamples);
  const resolved = of(resolvedHead);
  tail.forEach((quantile) => {
    resolved.push(resolveQuantile(error, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map3(resolved, (rq) => [rq.quantile, rq.value]);
};
var resolveQuantile = (error, sampleCount, current, consumed, quantile, rest) => {
  let error_1 = error;
  let sampleCount_1 = sampleCount;
  let current_1 = current;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error;
  let sampleCount_2 = sampleCount;
  let current_2 = current;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  while (true) {
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: none2(),
        consumed: consumed_1,
        rest: []
      };
    }
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some2(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    const headValue = headNonEmpty(rest_1);
    const sameHead = span(rest_1, (n) => n === headValue);
    const desired = quantile_1 * sampleCount_1;
    const allowedError = error_1 / 2 * desired;
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    if (candConsumed > desired + allowedError) {
      const valueToReturn = isNone2(current_1) ? some2(headValue) : current_1;
      return {
        quantile: quantile_1,
        value: valueToReturn,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    switch (current_1._tag) {
      case "None": {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      case "Some": {
        const prevError = Math.abs(desired - current_1.value);
        if (candError < prevError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        return {
          quantile: quantile_1,
          value: some2(current_1.value),
          consumed: consumed_1,
          rest: rest_1
        };
      }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/metric/pair.js
var MetricPairSymbolKey = "effect/MetricPair";
var MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
var metricPairVariance = {
  _Type: (_2) => _2
};
var unsafeMake8 = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey = "effect/MetricRegistry";
var MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);

class MetricRegistryImpl {
  [MetricRegistryTypeId] = MetricRegistryTypeId;
  map = /* @__PURE__ */ empty21();
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(unsafeMake8(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = pipe(this.map, get8(key), getOrUndefined);
    if (hook == null) {
      if (isCounterKey(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const counter5 = counter4(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set4(key, counter5));
      }
      value = counter5;
    }
    return value;
  }
  getFrequency(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const frequency4 = frequency3(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set4(key, frequency4));
      }
      value = frequency4;
    }
    return value;
  }
  getGauge(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const gauge4 = gauge3(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set4(key, gauge4));
      }
      value = gauge4;
    }
    return value;
  }
  getHistogram(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const histogram5 = histogram4(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set4(key, histogram5));
      }
      value = histogram5;
    }
    return value;
  }
  getSummary(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const summary4 = summary3(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set4(key, summary4));
      }
      value = summary4;
    }
    return value;
  }
}
var make31 = () => {
  return new MetricRegistryImpl;
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey = "effect/Metric";
var MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
var metricVariance = {
  _Type: (_2) => _2,
  _In: (_2) => _2,
  _Out: (_2) => _2
};
var globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make31());
var make32 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign((effect) => tap(effect, (a) => update4(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  return metric;
};
var counter5 = (name2, options) => fromMetricKey(counter2(name2, options));
var fromMetricKey = (key) => {
  let untaggedHook;
  const hookCache = new WeakMap;
  const hook = (extraTags) => {
    if (extraTags.length === 0) {
      if (untaggedHook !== undefined) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook2 = hookCache.get(extraTags);
    if (hook2 !== undefined) {
      return hook2;
    }
    hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook2);
    return hook2;
  };
  return make32(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
};
var histogram5 = (name2, boundaries, description) => fromMetricKey(histogram2(name2, boundaries, description));
var tagged = /* @__PURE__ */ dual(3, (self2, key, value) => taggedWithLabels2(self2, [make29(key, value)]));
var taggedWithLabels2 = /* @__PURE__ */ dual(2, (self2, extraTags) => {
  return make32(self2.keyType, (input, extraTags1) => self2.unsafeUpdate(input, union2(extraTags, extraTags1)), (extraTags1) => self2.unsafeValue(union2(extraTags, extraTags1)), (input, extraTags1) => self2.unsafeModify(input, union2(extraTags, extraTags1)));
});
var update4 = /* @__PURE__ */ dual(2, (self2, input) => fiberRefGetWith(currentMetricLabels, (tags) => sync(() => self2.unsafeUpdate(input, tags))));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/request.js
var RequestSymbolKey = "effect/Request";
var RequestTypeId = /* @__PURE__ */ Symbol.for(RequestSymbolKey);
var requestVariance = {
  _E: (_2) => _2,
  _A: (_2) => _2
};
var RequestPrototype = {
  ...StructuralPrototype,
  [RequestTypeId]: requestVariance
};
var isRequest = (u3) => hasProperty(u3, RequestTypeId);
var Class2 = /* @__PURE__ */ function() {
  function Class3(args3) {
    if (args3) {
      Object.assign(this, args3);
    }
  }
  Class3.prototype = RequestPrototype;
  return Class3;
}();
var complete = /* @__PURE__ */ dual(2, (self2, result) => fiberRefGetWith(currentRequestMap, (map10) => sync(() => {
  if (map10.has(self2)) {
    const entry = map10.get(self2);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone(entry.result, result);
    }
  }
})));
class Listeners {
  count = 0;
  observers = /* @__PURE__ */ new Set;
  interrupted = false;
  addObserver(f) {
    this.observers.add(f);
  }
  removeObserver(f) {
    this.observers.delete(f);
  }
  increment() {
    this.count++;
    this.observers.forEach((f) => f(this.count));
  }
  decrement() {
    this.count--;
    this.observers.forEach((f) => f(this.count));
  }
}

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/redBlackTree/iterator.js
var Direction = {
  Forward: 0,
  Backward: 1 << 0
};

class RedBlackTreeIterator {
  self;
  stack;
  direction;
  count = 0;
  constructor(self2, stack, direction) {
    this.self = self2;
    this.stack = stack;
    this.direction = direction;
  }
  clone() {
    return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
  }
  reversed() {
    return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction.Forward ? Direction.Backward : Direction.Forward);
  }
  next() {
    const entry = this.entry;
    this.count++;
    if (this.direction === Direction.Forward) {
      this.moveNext();
    } else {
      this.movePrev();
    }
    switch (entry._tag) {
      case "None": {
        return {
          done: true,
          value: this.count
        };
      }
      case "Some": {
        return {
          done: false,
          value: entry.value
        };
      }
    }
  }
  get key() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].key);
    }
    return none2();
  }
  get value() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].value);
    }
    return none2();
  }
  get entry() {
    return map2(last(this.stack), (node) => [node.key, node.value]);
  }
  get index() {
    let idx = 0;
    const stack = this.stack;
    if (stack.length === 0) {
      const r2 = this.self._root;
      if (r2 != null) {
        return r2.count;
      }
      return 0;
    } else if (stack[stack.length - 1].left != null) {
      idx = stack[stack.length - 1].left.count;
    }
    for (let s2 = stack.length - 2;s2 >= 0; --s2) {
      if (stack[s2 + 1] === stack[s2].right) {
        ++idx;
        if (stack[s2].left != null) {
          idx += stack[s2].left.count;
        }
      }
    }
    return idx;
  }
  moveNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n.right != null) {
      n = n.right;
      while (n != null) {
        stack.push(n);
        n = n.left;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].right === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  get hasNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].right != null) {
      return true;
    }
    for (let s2 = stack.length - 1;s2 > 0; --s2) {
      if (stack[s2 - 1].left === stack[s2]) {
        return true;
      }
    }
    return false;
  }
  movePrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n != null && n.left != null) {
      n = n.left;
      while (n != null) {
        stack.push(n);
        n = n.right;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].left === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  get hasPrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].left != null) {
      return true;
    }
    for (let s2 = stack.length - 1;s2 > 0; --s2) {
      if (stack[s2 - 1].right === stack[s2]) {
        return true;
      }
    }
    return false;
  }
}

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/redBlackTree/node.js
var Color = {
  Red: 0,
  Black: 1 << 0
};
var repaint = ({
  count,
  key,
  left: left3,
  right: right3,
  value
}, color) => ({
  color,
  key,
  value,
  left: left3,
  right: right3,
  count
});
var recount = (node) => {
  node.count = 1 + (node.left?.count ?? 0) + (node.right?.count ?? 0);
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/redBlackTree.js
var RedBlackTreeSymbolKey = "effect/RedBlackTree";
var RedBlackTreeTypeId = /* @__PURE__ */ Symbol.for(RedBlackTreeSymbolKey);
var redBlackTreeVariance = {
  _Key: (_2) => _2,
  _Value: (_2) => _2
};
var RedBlackTreeProto = {
  [RedBlackTreeTypeId]: redBlackTreeVariance,
  [symbol]() {
    let hash2 = hash(RedBlackTreeSymbolKey);
    for (const item of this) {
      hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash2);
  },
  [symbol2](that) {
    if (isRedBlackTree(that)) {
      if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) {
        return false;
      }
      const entries2 = Array.from(that);
      return Array.from(this).every((itemSelf, i2) => {
        const itemThat = entries2[i2];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  [Symbol.iterator]() {
    const stack = [];
    let n = this._root;
    while (n != null) {
      stack.push(n);
      n = n.left;
    }
    return new RedBlackTreeIterator(this, stack, Direction.Forward);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "RedBlackTree",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl3 = (ord, root) => {
  const tree = Object.create(RedBlackTreeProto);
  tree._ord = ord;
  tree._root = root;
  return tree;
};
var isRedBlackTree = (u3) => hasProperty(u3, RedBlackTreeTypeId);
var empty27 = (ord) => makeImpl3(ord, undefined);
var fromIterable9 = /* @__PURE__ */ dual(2, (entries2, ord) => {
  let tree = empty27(ord);
  for (const [key, value] of entries2) {
    tree = insert(tree, key, value);
  }
  return tree;
});
var findFirst5 = /* @__PURE__ */ dual(2, (self2, key) => {
  const cmp = self2._ord;
  let node = self2._root;
  while (node !== undefined) {
    const d2 = cmp(key, node.key);
    if (equals(key, node.key)) {
      return some2(node.value);
    }
    if (d2 <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  return none2();
});
var has5 = /* @__PURE__ */ dual(2, (self2, key) => isSome2(findFirst5(self2, key)));
var insert = /* @__PURE__ */ dual(3, (self2, key, value) => {
  const cmp = self2._ord;
  let n = self2._root;
  const n_stack = [];
  const d_stack = [];
  while (n != null) {
    const d2 = cmp(key, n.key);
    n_stack.push(n);
    d_stack.push(d2);
    if (d2 <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  n_stack.push({
    color: Color.Red,
    key,
    value,
    left: undefined,
    right: undefined,
    count: 1
  });
  for (let s2 = n_stack.length - 2;s2 >= 0; --s2) {
    const n2 = n_stack[s2];
    if (d_stack[s2] <= 0) {
      n_stack[s2] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n_stack[s2 + 1],
        right: n2.right,
        count: n2.count + 1
      };
    } else {
      n_stack[s2] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n2.left,
        right: n_stack[s2 + 1],
        count: n2.count + 1
      };
    }
  }
  for (let s2 = n_stack.length - 1;s2 > 1; --s2) {
    const p = n_stack[s2 - 1];
    const n3 = n_stack[s2];
    if (p.color === Color.Black || n3.color === Color.Black) {
      break;
    }
    const pp = n_stack[s2 - 2];
    if (pp.left === p) {
      if (p.left === n3) {
        const y2 = pp.right;
        if (y2 && y2.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y2, Color.Black);
          pp.color = Color.Red;
          s2 -= 1;
        } else {
          pp.color = Color.Red;
          pp.left = p.right;
          p.color = Color.Black;
          p.right = pp;
          n_stack[s2 - 2] = p;
          n_stack[s2 - 1] = n3;
          recount(pp);
          recount(p);
          if (s2 >= 3) {
            const ppp = n_stack[s2 - 3];
            if (ppp.left === pp) {
              ppp.left = p;
            } else {
              ppp.right = p;
            }
          }
          break;
        }
      } else {
        const y2 = pp.right;
        if (y2 && y2.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y2, Color.Black);
          pp.color = Color.Red;
          s2 -= 1;
        } else {
          p.right = n3.left;
          pp.color = Color.Red;
          pp.left = n3.right;
          n3.color = Color.Black;
          n3.left = p;
          n3.right = pp;
          n_stack[s2 - 2] = n3;
          n_stack[s2 - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s2 >= 3) {
            const ppp = n_stack[s2 - 3];
            if (ppp.left === pp) {
              ppp.left = n3;
            } else {
              ppp.right = n3;
            }
          }
          break;
        }
      }
    } else {
      if (p.right === n3) {
        const y2 = pp.left;
        if (y2 && y2.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y2, Color.Black);
          pp.color = Color.Red;
          s2 -= 1;
        } else {
          pp.color = Color.Red;
          pp.right = p.left;
          p.color = Color.Black;
          p.left = pp;
          n_stack[s2 - 2] = p;
          n_stack[s2 - 1] = n3;
          recount(pp);
          recount(p);
          if (s2 >= 3) {
            const ppp = n_stack[s2 - 3];
            if (ppp.right === pp) {
              ppp.right = p;
            } else {
              ppp.left = p;
            }
          }
          break;
        }
      } else {
        const y2 = pp.left;
        if (y2 && y2.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y2, Color.Black);
          pp.color = Color.Red;
          s2 -= 1;
        } else {
          p.left = n3.right;
          pp.color = Color.Red;
          pp.right = n3.left;
          n3.color = Color.Black;
          n3.right = p;
          n3.left = pp;
          n_stack[s2 - 2] = n3;
          n_stack[s2 - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s2 >= 3) {
            const ppp = n_stack[s2 - 3];
            if (ppp.right === pp) {
              ppp.right = n3;
            } else {
              ppp.left = n3;
            }
          }
          break;
        }
      }
    }
  }
  n_stack[0].color = Color.Black;
  return makeImpl3(self2._ord, n_stack[0]);
});
var keysForward = (self2) => keys3(self2, Direction.Forward);
var keys3 = (self2, direction) => {
  const begin = self2[Symbol.iterator]();
  let count = 0;
  return {
    [Symbol.iterator]: () => keys3(self2, direction),
    next: () => {
      count++;
      const entry = begin.key;
      if (direction === Direction.Forward) {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      switch (entry._tag) {
        case "None": {
          return {
            done: true,
            value: count
          };
        }
        case "Some": {
          return {
            done: false,
            value: entry.value
          };
        }
      }
    }
  };
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/RedBlackTree.js
var fromIterable10 = fromIterable9;
var has6 = has5;
var keys4 = keysForward;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/SortedSet.js
var TypeId15 = /* @__PURE__ */ Symbol.for("effect/SortedSet");
var SortedSetProto = {
  [TypeId15]: {
    _A: (_2) => _2
  },
  [symbol]() {
    return pipe(hash(this.keyTree), combine(hash(TypeId15)), cached(this));
  },
  [symbol2](that) {
    return isSortedSet(that) && equals(this.keyTree, that.keyTree);
  },
  [Symbol.iterator]() {
    return keys4(this.keyTree);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var fromTree = (keyTree) => {
  const a = Object.create(SortedSetProto);
  a.keyTree = keyTree;
  return a;
};
var isSortedSet = (u3) => hasProperty(u3, TypeId15);
var fromIterable11 = /* @__PURE__ */ dual(2, (iterable, ord) => fromTree(fromIterable10(Array.from(iterable).map((k2) => [k2, true]), ord)));
var every6 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  for (const value of self2) {
    if (!predicate(value)) {
      return false;
    }
  }
  return true;
});
var has7 = /* @__PURE__ */ dual(2, (self2, value) => has6(self2.keyTree, value));
var isSubset2 = /* @__PURE__ */ dual(2, (self2, that) => every6(self2, (a) => has7(that, a)));
var values3 = (self2) => keys4(self2.keyTree);
var getEquivalence6 = () => (a, b3) => isSubset2(a, b3) && isSubset2(b3, a);

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey = "effect/Supervisor";
var SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
var supervisorVariance = {
  _T: (_2) => _2
};

class ProxySupervisor {
  underlying;
  value0;
  [SupervisorTypeId] = supervisorVariance;
  constructor(underlying, value0) {
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context2, effect, parent, fiber) {
    this.underlying.onStart(context2, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.underlying.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.underlying.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map9(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
}

class Zip {
  left;
  right;
  _tag = "Zip";
  [SupervisorTypeId] = supervisorVariance;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  get value() {
    return zip2(this.left.value, this.right.value);
  }
  onStart(context2, effect, parent, fiber) {
    this.left.onStart(context2, effect, parent, fiber);
    this.right.onStart(context2, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.left.onEnd(value, fiber);
    this.right.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.left.onEffect(fiber, effect);
    this.right.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map9(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
}
var isZip = (self2) => hasProperty(self2, SupervisorTypeId) && isTagged(self2, "Zip");

class Track {
  [SupervisorTypeId] = supervisorVariance;
  fibers = /* @__PURE__ */ new Set;
  get value() {
    return sync(() => Array.from(this.fibers));
  }
  onStart(_context, _effect, _parent, fiber) {
    this.fibers.add(fiber);
  }
  onEnd(_value, fiber) {
    this.fibers.delete(fiber);
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map9(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
}

class Const {
  effect;
  [SupervisorTypeId] = supervisorVariance;
  constructor(effect) {
    this.effect = effect;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {
  }
  onEnd(_value, _fiber) {
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map9(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
}
var unsafeTrack = () => {
  return new Track;
};
var track = /* @__PURE__ */ sync(unsafeTrack);
var fromEffect = (effect) => {
  return new Const(effect);
};
var none8 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect(void_));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Differ.js
var make34 = make15;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY3 = "Empty";
var OP_ADD_SUPERVISOR = "AddSupervisor";
var OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
var OP_AND_THEN2 = "AndThen";
var empty29 = {
  _tag: OP_EMPTY3
};
var combine11 = (self2, that) => {
  return {
    _tag: OP_AND_THEN2,
    first: self2,
    second: that
  };
};
var patch11 = (self2, supervisor) => {
  return patchLoop(supervisor, of2(self2));
};
var patchLoop = (_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty2(patches)) {
    const head4 = headNonEmpty2(patches);
    switch (head4._tag) {
      case OP_EMPTY3: {
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_ADD_SUPERVISOR: {
        supervisor = supervisor.zip(head4.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_REMOVE_SUPERVISOR: {
        supervisor = removeSupervisor(supervisor, head4.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_AND_THEN2: {
        patches = prepend2(head4.first)(prepend2(head4.second)(tailNonEmpty2(patches)));
        break;
      }
    }
  }
  return supervisor;
};
var removeSupervisor = (self2, that) => {
  if (equals(self2, that)) {
    return none8;
  } else {
    if (isZip(self2)) {
      return removeSupervisor(self2.left, that).zip(removeSupervisor(self2.right, that));
    } else {
      return self2;
    }
  }
};
var toSet2 = (self2) => {
  if (equals(self2, none8)) {
    return empty8();
  } else {
    if (isZip(self2)) {
      return pipe(toSet2(self2.left), union4(toSet2(self2.right)));
    } else {
      return make11(self2);
    }
  }
};
var diff10 = (oldValue, newValue) => {
  if (equals(oldValue, newValue)) {
    return empty29;
  }
  const oldSupervisors = toSet2(oldValue);
  const newSupervisors = toSet2(newValue);
  const added = pipe(newSupervisors, difference3(oldSupervisors), reduce5(empty29, (patch12, supervisor) => combine11(patch12, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = pipe(oldSupervisors, difference3(newSupervisors), reduce5(empty29, (patch12, supervisor) => combine11(patch12, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine11(added, removed);
};
var differ2 = /* @__PURE__ */ make34({
  empty: empty29,
  patch: patch11,
  combine: combine11,
  diff: diff10
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted = /* @__PURE__ */ counter5("effect_fiber_started", {
  incremental: true
});
var fiberActive = /* @__PURE__ */ counter5("effect_fiber_active");
var fiberSuccesses = /* @__PURE__ */ counter5("effect_fiber_successes", {
  incremental: true
});
var fiberFailures = /* @__PURE__ */ counter5("effect_fiber_failures", {
  incremental: true
});
var fiberLifetimes = /* @__PURE__ */ tagged(/* @__PURE__ */ histogram5("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
var EvaluationSignalContinue = "Continue";
var EvaluationSignalDone = "Done";
var EvaluationSignalYieldNow = "Yield";
var runtimeFiberVariance = {
  _E: (_2) => _2,
  _A: (_2) => _2
};
var absurd = (_2) => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_2)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
var YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
var yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
var contOpSuccess = {
  [OP_ON_SUCCESS]: (_2, cont, value) => {
    return internalCall(() => cont.effect_instruction_i1(value));
  },
  ["OnStep"]: (_2, _cont, value) => {
    return exitSucceed(exitSucceed(value));
  },
  [OP_ON_SUCCESS_AND_FAILURE]: (_2, cont, value) => {
    return internalCall(() => cont.effect_instruction_i2(value));
  },
  [OP_REVERT_FLAGS]: (self2, cont, value) => {
    self2.patchRuntimeFlags(self2.currentRuntimeFlags, cont.patch);
    if (interruptible(self2.currentRuntimeFlags) && self2.isInterrupted()) {
      return exitFailCause(self2.getInterruptedCause());
    } else {
      return exitSucceed(value);
    }
  },
  [OP_WHILE]: (self2, cont, value) => {
    internalCall(() => cont.effect_instruction_i2(value));
    if (internalCall(() => cont.effect_instruction_i0())) {
      self2.pushStack(cont);
      return internalCall(() => cont.effect_instruction_i1());
    } else {
      return void_;
    }
  },
  [OP_ITERATOR]: (self2, cont, value) => {
    const state = internalCall(() => cont.effect_instruction_i0.next(value));
    if (state.done)
      return exitSucceed(state.value);
    self2.pushStack(cont);
    return yieldWrapGet(state.value);
  }
};
var drainQueueWhileRunningTable = {
  [OP_INTERRUPT_SIGNAL]: (self2, runtimeFlags2, cur, message) => {
    self2.processNewInterruptSignal(message.cause);
    return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
  },
  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL]: (self2, runtimeFlags2, cur, message) => {
    message.onFiber(self2, running2(runtimeFlags2));
    return cur;
  },
  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return flatMap7(yieldNow(), () => cur);
  }
};
var runBlockedRequests = (self2) => forEachSequentialDiscard(flatten3(self2), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential4]) => {
  const map10 = new Map;
  const arr = [];
  for (const block of sequential4) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map10.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map10);
}, false, false));
var _version = /* @__PURE__ */ getCurrentVersion();

class FiberRuntime extends Class {
  [FiberTypeId] = fiberVariance2;
  [RuntimeFiberTypeId] = runtimeFiberVariance;
  _fiberRefs;
  _fiberId;
  _queue = /* @__PURE__ */ new Array;
  _children = null;
  _observers = /* @__PURE__ */ new Array;
  _running = false;
  _stack = [];
  _asyncInterruptor = null;
  _asyncBlockingOn = null;
  _exitValue = null;
  _steps = [];
  _isYielding = false;
  currentRuntimeFlags;
  currentOpCount = 0;
  currentSupervisor;
  currentScheduler;
  currentTracer;
  currentSpan;
  currentContext;
  currentDefaultServices;
  constructor(fiberId2, fiberRefs0, runtimeFlags0) {
    super();
    this.currentRuntimeFlags = runtimeFlags0;
    this._fiberId = fiberId2;
    this._fiberRefs = fiberRefs0;
    if (runtimeMetrics(runtimeFlags0)) {
      const tags = this.getFiberRef(currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags);
      fiberActive.unsafeUpdate(1, tags);
    }
    this.refreshRefCache();
  }
  commit() {
    return join2(this);
  }
  id() {
    return this._fiberId;
  }
  resume(effect) {
    this.tell(resume(effect));
  }
  get status() {
    return this.ask((_2, status) => status);
  }
  get runtimeFlags() {
    return this.ask((state, status) => {
      if (isDone2(status)) {
        return state.currentRuntimeFlags;
      }
      return status.runtimeFlags;
    });
  }
  scope() {
    return unsafeMake7(this);
  }
  get children() {
    return this.ask((fiber) => Array.from(fiber.getChildren()));
  }
  getChildren() {
    if (this._children === null) {
      this._children = new Set;
    }
    return this._children;
  }
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause);
  }
  fiberRefs() {
    return this.ask((fiber) => fiber.getFiberRefs());
  }
  ask(f) {
    return suspend(() => {
      const deferred = deferredUnsafeMake(this._fiberId);
      this.tell(stateful((fiber, status) => {
        deferredUnsafeDone(deferred, sync(() => f(fiber, status)));
      }));
      return deferredAwait(deferred);
    });
  }
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return async_((resume2) => {
      const cb = (exit2) => resume2(succeed(exit2));
      this.tell(stateful((fiber, _2) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync(() => this.tell(stateful((fiber, _2) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch12 = pipe(diff7(parentRuntimeFlags, updatedRuntimeFlags), exclude2(Interruption), exclude2(WindDown));
      return updateRuntimeFlags(patch12);
    });
  }
  get poll() {
    return sync(() => fromNullable(this._exitValue));
  }
  unsafePoll() {
    return this._exitValue;
  }
  interruptAsFork(fiberId2) {
    return sync(() => this.tell(interruptSignal(interrupt(fiberId2))));
  }
  unsafeInterruptAsFork(fiberId2) {
    this.tell(interruptSignal(interrupt(fiberId2)));
  }
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  removeObserver(observer) {
    this._observers = this._observers.filter((o3) => o3 !== observer);
  }
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
    return this._fiberRefs;
  }
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_(this._fiberRefs, fiberRef);
  }
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  setFiberRef(fiberRef, value) {
    this._fiberRefs = updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(currentServices);
    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
    this.currentSupervisor = this.getFiberRef(currentSupervisor);
    this.currentScheduler = this.getFiberRef(currentScheduler);
    this.currentContext = this.getFiberRef(currentContext);
    this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
  }
  setFiberRefs(fiberRefs3) {
    this._fiberRefs = fiberRefs3;
    this.refreshRefCache();
  }
  addChild(child) {
    this.getChildren().add(child);
  }
  removeChild(child) {
    this.getChildren().delete(child);
  }
  transferChildren(scope) {
    const children = this._children;
    this._children = null;
    if (children !== null && children.size > 0) {
      for (const child of children) {
        if (child._exitValue === null) {
          scope.add(this.currentRuntimeFlags, child);
        }
      }
    }
  }
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
      }
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
  }
  drainQueueWhileRunning(runtimeFlags2, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
    }
    return cur;
  }
  isInterrupted() {
    return !isEmpty5(this.getFiberRef(currentInterruptedCause));
  }
  addInterruptedCause(cause2) {
    const oldSC = this.getFiberRef(currentInterruptedCause);
    this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause2));
  }
  processNewInterruptSignal(cause2) {
    this.addInterruptedCause(cause2);
    this.sendInterruptSignalToAllChildren();
  }
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal(interrupt(this.id())));
      told = true;
    }
    return told;
  }
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it2 = this._children.values();
      this._children = null;
      let isDone3 = false;
      const body2 = () => {
        const next = it2.next();
        if (!next.done) {
          return asVoid(next.value.await);
        } else {
          return sync(() => {
            isDone3 = true;
          });
        }
      };
      return whileLoop({
        while: () => !isDone3,
        body: body2,
        step: () => {
        }
      });
    }
    return null;
  }
  reportExitValue(exit2) {
    if (runtimeMetrics(this.currentRuntimeFlags)) {
      const tags = this.getFiberRef(currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
      fiberActive.unsafeUpdate(-1, tags);
      switch (exit2._tag) {
        case OP_SUCCESS: {
          fiberSuccesses.unsafeUpdate(1, tags);
          break;
        }
        case OP_FAILURE: {
          fiberFailures.unsafeUpdate(1, tags);
          break;
        }
      }
    }
    if (exit2._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel);
      if (!isInterruptedOnly(exit2.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit2.cause, level);
      }
    }
  }
  setExitValue(exit2) {
    this._exitValue = exit2;
    this.reportExitValue(exit2);
    for (let i2 = this._observers.length - 1;i2 >= 0; i2--) {
      this._observers[i2](exit2);
    }
    this._observers = [];
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause2, overrideLogLevel) {
    const logLevel = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
    const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
    if (greaterThan4(minimumLogLevel, logLevel)) {
      return;
    }
    const spans = this.getFiberRef(currentLogSpan);
    const annotations2 = this.getFiberRef(currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (size3(loggers) > 0) {
      const clockService = get3(this.getFiberRef(currentServices), clockTag);
      const date2 = new Date(clockService.unsafeCurrentTimeMillis());
      withRedactableContext(contextMap, () => {
        for (const logger of loggers) {
          logger.log({
            fiberId: this.id(),
            logLevel,
            message,
            cause: cause2,
            context: contextMap,
            spans,
            annotations: annotations2,
            date: date2
          });
        }
      });
    }
  }
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW: {
        return EvaluationSignalYieldNow;
      }
      case OP_INTERRUPT_SIGNAL: {
        this.processNewInterruptSignal(message.cause);
        if (this._asyncInterruptor !== null) {
          this._asyncInterruptor(exitFailCause(message.cause));
          this._asyncInterruptor = null;
        }
        return EvaluationSignalContinue;
      }
      case OP_RESUME: {
        this._asyncInterruptor = null;
        this._asyncBlockingOn = null;
        this.evaluateEffect(message.effect);
        return EvaluationSignalContinue;
      }
      case OP_STATEFUL: {
        message.onFiber(this, this._exitValue !== null ? done4 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
        return EvaluationSignalContinue;
      }
      default: {
        return absurd(message);
      }
    }
  }
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this);
    try {
      let effect = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
      while (effect !== null) {
        const eff = effect;
        const exit2 = this.runLoop(eff);
        if (exit2 === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OP_YIELD) {
            if (cooperativeYielding(this.currentRuntimeFlags)) {
              this.tell(yieldNow3());
              this.tell(resume(exitVoid));
              effect = null;
            } else {
              effect = exitVoid;
            }
          } else if (op._op === OP_ASYNC) {
            effect = null;
          }
        } else {
          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
          const interruption2 = this.interruptAllChildren();
          if (interruption2 !== null) {
            effect = flatMap7(interruption2, () => exit2);
          } else {
            if (this._queue.length === 0) {
              this.setExitValue(exit2);
            } else {
              this.tell(resume(exit2));
            }
            effect = null;
          }
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this);
    }
  }
  start(effect) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        this.evaluateEffect(effect);
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume(effect));
    }
  }
  startFork(effect) {
    this.tell(resume(effect));
  }
  patchRuntimeFlags(oldRuntimeFlags, patch12) {
    const newRuntimeFlags = patch7(oldRuntimeFlags, patch12);
    globalThis[currentFiberURI] = this;
    this.currentRuntimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  initiateAsync(runtimeFlags2, asyncRegister) {
    let alreadyCalled = false;
    const callback = (effect) => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume(effect));
      }
    };
    if (interruptible(runtimeFlags2)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause(die(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this.currentRuntimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [OP_TAG](op) {
    return sync(() => unsafeGet3(this.currentContext, op));
  }
  ["Left"](op) {
    return fail2(op.left);
  }
  ["None"](_2) {
    return fail2(new NoSuchElementException);
  }
  ["Right"](op) {
    return exitSucceed(op.right);
  }
  ["Some"](op) {
    return exitSucceed(op.value);
  }
  ["Micro"](op) {
    return unsafeAsync((microResume) => {
      let resume2 = microResume;
      const fiber = runFork(provideContext2(op, this.currentContext));
      fiber.addObserver((exit2) => {
        if (exit2._tag === "Success") {
          return resume2(exitSucceed(exit2.value));
        }
        switch (exit2.cause._tag) {
          case "Interrupt": {
            return resume2(exitFailCause(interrupt(none4)));
          }
          case "Fail": {
            return resume2(fail2(exit2.cause.error));
          }
          case "Die": {
            return resume2(die2(exit2.cause.defect));
          }
        }
      });
      return unsafeAsync((abortResume) => {
        resume2 = (_2) => {
          abortResume(void_);
        };
        fiber.unsafeInterrupt();
      });
    });
  }
  [OP_SYNC](op) {
    const value = internalCall(() => op.effect_instruction_i0());
    const cont = this.getNextSuccessCont();
    if (cont !== undefined) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, value);
    } else {
      yieldedOpChannel.currentOp = exitSucceed(value);
      return YieldedOp;
    }
  }
  [OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== undefined) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OP_FAILURE](op) {
    const cause2 = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== undefined) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE: {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return internalCall(() => cont.effect_instruction_i1(cause2));
          } else {
            return exitFailCause(stripFailures(cause2));
          }
        }
        case "OnStep": {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return exitSucceed(exitFailCause(cause2));
          } else {
            return exitFailCause(stripFailures(cause2));
          }
        }
        case OP_REVERT_FLAGS: {
          this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
          if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
            return exitFailCause(sequential(cause2, this.getInterruptedCause()));
          } else {
            return exitFailCause(cause2);
          }
        }
        default: {
          absurd(cont);
        }
      }
    } else {
      yieldedOpChannel.currentOp = exitFailCause(cause2);
      return YieldedOp;
    }
  }
  [OP_WITH_RUNTIME](op) {
    return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags2 = this.currentRuntimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this.currentRuntimeFlags = snap.flags;
      const patchRefs = diff9(snap.refs, refs);
      const patchFlags = diff7(snap.flags, flags2);
      return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(patch10(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber.currentRuntimeFlags = patch7(patchFlags)(newFiber.currentRuntimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask((restore) => flatMap7(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this.currentRuntimeFlags;
    const newRuntimeFlags = patch7(oldRuntimeFlags, updateFlags);
    if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause(this.getInterruptedCause());
    } else {
      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        const revertFlags = diff7(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags(revertFlags, op));
        return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
      } else {
        return exitVoid;
      }
    }
  }
  [OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_YIELD](op) {
    this._isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_WHILE](op) {
    const check = op.effect_instruction_i0;
    const body2 = op.effect_instruction_i1;
    if (check()) {
      this.pushStack(op);
      return body2();
    } else {
      return exitVoid;
    }
  }
  [OP_ITERATOR](op) {
    return contOpSuccess[OP_ITERATOR](this, op, undefined);
  }
  [OP_COMMIT](op) {
    return internalCall(() => op.commit());
  }
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
        this.currentSupervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
      }
      if (!this._isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this.currentScheduler.shouldYield(this);
        if (shouldYield !== false) {
          this._isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = flatMap7(yieldNow({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        cur = this.currentTracer.context(() => {
          if (_version !== cur[EffectTypeId2]._V) {
            return dieMessage(`Cannot execute an Effect versioned ${cur[EffectTypeId2]._V} with a Runtime of version ${getCurrentVersion()}`);
          }
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OP_YIELD || op._op === OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
        }
      } catch (e) {
        if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
          cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
        } else if (isInterruptedException(e)) {
          cur = exitFailCause(sequential(die(e), interrupt(none4)));
        } else {
          cur = die2(e);
        }
      }
    }
  }
  run = () => {
    this.drainQueueOnCurrentThread();
  };
}
var currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
var loggerWithConsoleLog = (self2) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get3(services, consoleTag).unsafe.log(self2.log(opts));
});
var defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
var tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
  annotations: annotations2,
  cause: cause2,
  context: context2,
  fiberId: fiberId2,
  logLevel,
  message
}) => {
  const span2 = getOption2(getOrDefault(context2, currentContext), spanTag);
  if (span2._tag === "None" || span2.value._tag === "ExternalSpan") {
    return;
  }
  const clockService = unsafeGet3(getOrDefault(context2, currentServices), clockTag);
  const attributes = {};
  for (const [key, value] of annotations2) {
    attributes[key] = value;
  }
  attributes["effect.fiberId"] = threadName2(fiberId2);
  attributes["effect.logLevel"] = logLevel.label;
  if (cause2 !== null && cause2._tag !== "Empty") {
    attributes["effect.cause"] = pretty(cause2, {
      renderErrorCause: true
    });
  }
  span2.value.event(toStringUnknown(Array.isArray(message) ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
var currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make11(defaultLogger, tracerLogger)));
var annotateLogsScoped = function() {
  if (typeof arguments[0] === "string") {
    return fiberRefLocallyScopedWith(currentLogAnnotations, set3(arguments[0], arguments[1]));
  }
  const entries2 = Object.entries(arguments[0]);
  return fiberRefLocallyScopedWith(currentLogAnnotations, mutate3((annotations2) => {
    for (let i2 = 0;i2 < entries2.length; i2++) {
      const [key, value] = entries2[i2];
      set3(annotations2, key, value);
    }
    return annotations2;
  }));
};
var whenLogLevel = /* @__PURE__ */ dual(2, (effect, level) => {
  const requiredLogLevel = typeof level === "string" ? fromLiteral(level) : level;
  return withFiberRuntime((fiberState) => {
    const minimumLogLevel = fiberState.getFiberRef(currentMinimumLogLevel);
    if (greaterThan4(minimumLogLevel, requiredLogLevel)) {
      return succeed(none2());
    }
    return map9(effect, some2);
  });
});
var acquireRelease = /* @__PURE__ */ dual((args3) => isEffect(args3[0]), (acquire, release) => uninterruptible(tap(acquire, (a) => addFinalizer((exit2) => release(a, exit2)))));
var acquireReleaseInterruptible = /* @__PURE__ */ dual((args3) => isEffect(args3[0]), (acquire, release) => ensuring(acquire, addFinalizer((exit2) => release(exit2))));
var addFinalizer = (finalizer) => withFiberRuntime((runtime3) => {
  const acquireRefs = runtime3.getFiberRefs();
  const acquireFlags = disable2(runtime3.currentRuntimeFlags, Interruption);
  return flatMap7(scope, (scope) => scopeAddFinalizerExit(scope, (exit2) => withFiberRuntime((runtimeFinalizer) => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer.currentRuntimeFlags;
    const patchRefs = diff9(preRefs, acquireRefs);
    const patchFlags = diff7(preFlags, acquireFlags);
    const inverseRefs = diff9(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(patch10(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring(withRuntimeFlags(finalizer(exit2), patchFlags), sync(() => {
      runtimeFinalizer.setFiberRefs(patch10(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
});
var daemonChildren = (self2) => {
  const forkScope = fiberRefLocally(currentForkScopeOverride, some2(globalScope));
  return forkScope(self2);
};
var _existsParFound = /* @__PURE__ */ Symbol.for("effect/Effect/existsPar/found");
var exists3 = /* @__PURE__ */ dual((args3) => isIterable(args3[0]) && !isEffect(args3[0]), (elements, predicate, options) => matchSimple(options?.concurrency, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => matchEffect(forEach7(elements, (a, i2) => if_(predicate(a, i2), {
  onTrue: () => fail2(_existsParFound),
  onFalse: () => void_
}), options), {
  onFailure: (e) => e === _existsParFound ? succeed(true) : fail2(e),
  onSuccess: () => succeed(false)
})));
var existsLoop = (iterator, index2, f) => {
  const next = iterator.next();
  if (next.done) {
    return succeed(false);
  }
  return pipe(flatMap7(f(next.value, index2), (b3) => b3 ? succeed(b3) : existsLoop(iterator, index2 + 1, f)));
};
var filter5 = /* @__PURE__ */ dual((args3) => isIterable(args3[0]) && !isEffect(args3[0]), (elements, predicate, options) => {
  const predicate_ = options?.negate ? (a, i2) => map9(predicate(a, i2), not2) : predicate;
  return matchSimple(options?.concurrency, () => suspend(() => fromIterable(elements).reduceRight((effect, a, i2) => zipWith2(effect, suspend(() => predicate_(a, i2)), (list, b3) => b3 ? [a, ...list] : list), sync(() => new Array))), () => map9(forEach7(elements, (a, i2) => map9(predicate_(a, i2), (b3) => b3 ? some2(a) : none2()), options), getSomes));
});
var allResolveInput = (input) => {
  if (Array.isArray(input) || isIterable(input)) {
    return [input, none2()];
  }
  const keys5 = Object.keys(input);
  const size8 = keys5.length;
  return [keys5.map((k2) => input[k2]), some2((values4) => {
    const res = {};
    for (let i2 = 0;i2 < size8; i2++) {
      res[keys5[i2]] = values4[i2];
    }
    return res;
  })];
};
var allValidate = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect of effects) {
    eitherEffects.push(either2(effect));
  }
  return flatMap7(forEach7(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => {
    const none9 = none2();
    const size8 = eithers.length;
    const errors = new Array(size8);
    const successes = new Array(size8);
    let errored = false;
    for (let i2 = 0;i2 < size8; i2++) {
      const either3 = eithers[i2];
      if (either3._tag === "Left") {
        errors[i2] = some2(either3.left);
        errored = true;
      } else {
        successes[i2] = either3.right;
        errors[i2] = none9;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? fail2(reconcile.value(errors)) : fail2(errors);
    } else if (options?.discard) {
      return void_;
    }
    return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
  });
};
var allEither = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect of effects) {
    eitherEffects.push(either2(effect));
  }
  if (options?.discard) {
    return forEach7(eitherEffects, identity, {
      concurrency: options?.concurrency,
      batching: options?.batching,
      discard: true,
      concurrentFinalizers: options?.concurrentFinalizers
    });
  }
  return map9(forEach7(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
};
var all2 = (arg, options) => {
  const [effects, reconcile] = allResolveInput(arg);
  if (options?.mode === "validate") {
    return allValidate(effects, reconcile, options);
  } else if (options?.mode === "either") {
    return allEither(effects, reconcile, options);
  }
  return options?.discard !== true && reconcile._tag === "Some" ? map9(forEach7(effects, identity, options), reconcile.value) : forEach7(effects, identity, options);
};
var allWith = (options) => (arg) => all2(arg, options);
var allSuccesses = (elements, options) => map9(all2(fromIterable(elements).map(exit), options), filterMap2((exit2) => exitIsSuccess(exit2) ? some2(exit2.effect_instruction_i0) : none2()));
var replicate = /* @__PURE__ */ dual(2, (self2, n) => Array.from({
  length: n
}, () => self2));
var replicateEffect = /* @__PURE__ */ dual((args3) => isEffect(args3[0]), (self2, n, options) => all2(replicate(self2, n), options));
var forEach7 = /* @__PURE__ */ dual((args3) => isIterable(args3[0]), (self2, f, options) => withFiberRuntime((r2) => {
  const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r2.getFiberRef(currentRequestBatching);
  if (options?.discard) {
    return match9(options.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self2, (a, i2) => restore(f(a, i2)), true, false, 1) : forEachSequentialDiscard(self2, (a, i2) => restore(f(a, i2)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a, i2) => restore(f(a, i2)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a, i2) => restore(f(a, i2)), isRequestBatchingEnabled, false, n)));
  }
  return match9(options?.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self2, 1, (a, i2) => restore(f(a, i2)), true) : forEachSequential(self2, (a, i2) => restore(f(a, i2)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachParUnbounded(self2, (a, i2) => restore(f(a, i2)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachParN(self2, n, (a, i2) => restore(f(a, i2)), isRequestBatchingEnabled)));
}));
var forEachParUnbounded = (self2, f, batching) => suspend(() => {
  const as2 = fromIterable(self2);
  const array5 = new Array(as2.length);
  const fn2 = (a, i2) => flatMap7(f(a, i2), (b3) => sync(() => array5[i2] = b3));
  return zipRight(forEachConcurrentDiscard(as2, fn2, batching, false), succeed(array5));
});
var forEachConcurrentDiscard = (self2, f, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
  let todos = Array.from(self2).reverse();
  let target = todos.length;
  if (target === 0) {
    return void_;
  }
  let counter6 = 0;
  let interrupted = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers = new Set;
  const results = new Array;
  const interruptAll = () => fibers.forEach((fiber) => {
    fiber.currentScheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  });
  const startOrder = new Array;
  const joinOrder = new Array;
  const residual = new Array;
  const collectExits = () => {
    const exits = results.filter(({
      exit: exit2
    }) => exit2._tag === "Failure").sort((a, b3) => a.index < b3.index ? -1 : a.index === b3.index ? 0 : 1).map(({
      exit: exit2
    }) => exit2);
    if (exits.length === 0) {
      exits.push(exitVoid);
    }
    return exits;
  };
  const runFiber = (eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
    parent.currentScheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  };
  const onInterruptSignal = () => {
    if (!processAll) {
      target -= todos.length;
      todos = [];
    }
    interrupted = true;
    interruptAll();
  };
  const stepOrExit = batching ? step2 : exit;
  const processingFiber = runFiber(async_((resume2) => {
    const pushResult = (res, index2) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index: index2,
          exit: res
        });
        if (res._op === "Failure" && !interrupted) {
          onInterruptSignal();
        }
      }
    };
    const next = () => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index2 = counter6++;
        const returnNextElement = () => {
          const a2 = todos.pop();
          index2 = counter6++;
          return flatMap7(yieldNow(), () => flatMap7(stepOrExit(restore(f(a2, index2))), onRes));
        };
        const onRes = (res) => {
          if (todos.length > 0) {
            pushResult(res, index2);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed(res);
        };
        const todo = flatMap7(stepOrExit(restore(f(a, index2))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers.add(fiber);
        if (interrupted) {
          fiber.currentScheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver((wrapped) => {
          let exit2;
          if (wrapped._op === "Failure") {
            exit2 = wrapped;
          } else {
            exit2 = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers.delete(fiber);
          pushResult(exit2, index2);
          if (results.length === target) {
            resume2(succeed(getOrElse(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid)));
          } else if (residual.length + results.length === target) {
            const exits = collectExits();
            const requests = residual.map((blocked2) => blocked2.effect_instruction_i0).reduce(par);
            resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse(exitCollectAll(exits, {
              parallel: true
            }), () => exitVoid), ...residual.map((blocked2) => blocked2.effect_instruction_i1)], (i2) => i2, batching, true, n))));
          } else {
            next();
          }
        });
      }
    };
    for (let i2 = 0;i2 < fibersCount; i2++) {
      next();
    }
  }));
  return asVoid(onExit(flatten5(restore(join2(processingFiber))), exitMatch({
    onFailure: (cause2) => {
      onInterruptSignal();
      const target2 = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async_((cb) => {
        const exits = [];
        let count = 0;
        let index2 = 0;
        const check = (index3, hitNext) => (exit2) => {
          exits[index3] = exit2;
          count++;
          if (count === target2) {
            cb(exitSucceed(exitFailCause(cause2)));
          }
          if (toPop.length > 0 && hitNext) {
            next();
          }
        };
        const next = () => {
          runFiber(toPop.pop(), true).addObserver(check(index2, true));
          index2++;
        };
        processingFiber.addObserver(check(index2, false));
        index2++;
        for (let i2 = 0;i2 < concurrency; i2++) {
          next();
        }
      });
    },
    onSuccess: () => forEachSequential(joinOrder, (f2) => f2.inheritAll)
  })));
})));
var forEachParN = (self2, n, f, batching) => suspend(() => {
  const as2 = fromIterable(self2);
  const array5 = new Array(as2.length);
  const fn2 = (a, i2) => map9(f(a, i2), (b3) => array5[i2] = b3);
  return zipRight(forEachConcurrentDiscard(as2, fn2, batching, false, n), succeed(array5));
});
var fork = (self2) => withFiberRuntime((state, status) => succeed(unsafeFork(self2, state, status.runtimeFlags)));
var forkDaemon = (self2) => forkWithScopeOverride(self2, globalScope);
var forkWithErrorHandler = /* @__PURE__ */ dual(2, (self2, handler) => fork(onError(self2, (cause2) => {
  const either3 = failureOrCause(cause2);
  switch (either3._tag) {
    case "Left":
      return handler(either3.left);
    case "Right":
      return failCause(either3.right);
  }
})));
var unsafeFork = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect);
  return childFiber;
};
var unsafeForkUnstarted = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
};
var unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake3();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault(childFiberRefs, currentContext);
  const supervisor = childFiber.currentSupervisor;
  supervisor.onStart(childContext, effect, some2(parentFiber), childFiber);
  childFiber.addObserver((exit2) => supervisor.onEnd(exit2, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
};
var forkWithScopeOverride = (self2, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork(self2, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
var mergeAll3 = /* @__PURE__ */ dual((args3) => isFunction2(args3[2]), (elements, zero3, f, options) => matchSimple(options?.concurrency, () => fromIterable(elements).reduce((acc, a, i2) => zipWith2(acc, a, (acc2, a2) => f(acc2, a2, i2)), succeed(zero3)), () => flatMap7(make28(zero3), (acc) => flatMap7(forEach7(elements, (effect, i2) => flatMap7(effect, (a) => update3(acc, (b3) => f(b3, a, i2))), options), () => get12(acc)))));
var partition3 = /* @__PURE__ */ dual((args3) => isIterable(args3[0]), (elements, f, options) => pipe(forEach7(elements, (a, i2) => either2(f(a, i2)), options), map9((chunk2) => partitionMap2(chunk2, identity))));
var validateAll = /* @__PURE__ */ dual((args3) => isIterable(args3[0]), (elements, f, options) => flatMap7(partition3(elements, f, {
  concurrency: options?.concurrency,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([es, bs]) => isNonEmptyArray2(es) ? fail2(es) : options?.discard ? void_ : succeed(bs)));
var raceAll = (all3) => {
  const list = fromIterable2(all3);
  if (!isNonEmpty2(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  const self2 = headNonEmpty2(list);
  const effects = tailNonEmpty2(list);
  const inheritAll2 = (res) => pipe(inheritAll(res[1]), as(res[0]));
  return pipe(deferredMake(), flatMap7((done5) => pipe(make28(effects.length), flatMap7((fails) => uninterruptibleMask((restore) => pipe(fork(interruptible2(self2)), flatMap7((head4) => pipe(effects, forEachSequential((effect) => fork(interruptible2(effect))), map9((fibers) => unsafeFromArray(fibers)), map9((tail) => pipe(tail, prepend2(head4))), tap((fibers) => pipe(fibers, reduce(void_, (effect, fiber) => pipe(effect, zipRight(pipe(_await2(fiber), flatMap7(raceAllArbiter(fibers, fiber, done5, fails)), fork, asVoid)))))), flatMap7((fibers) => pipe(restore(pipe(_await(done5), flatMap7(inheritAll2))), onInterrupt(() => pipe(fibers, reduce(void_, (effect, fiber) => pipe(effect, zipLeft(interruptFiber(fiber))))))))))))))));
};
var raceAllArbiter = (fibers, winner, deferred, fails) => (exit2) => exitMatchEffect(exit2, {
  onFailure: (cause2) => pipe(modify4(fails, (fails2) => [fails2 === 0 ? pipe(deferredFailCause(deferred, cause2), asVoid) : void_, fails2 - 1]), flatten5),
  onSuccess: (value) => pipe(deferredSucceed(deferred, [value, winner]), flatMap7((set6) => set6 ? pipe(fromIterable2(fibers), reduce(void_, (effect, fiber) => fiber === winner ? effect : pipe(effect, zipLeft(interruptFiber(fiber))))) : void_))
});
var reduceEffect = /* @__PURE__ */ dual((args3) => isIterable(args3[0]) && !isEffect(args3[0]), (elements, zero3, f, options) => matchSimple(options?.concurrency, () => fromIterable(elements).reduce((acc, a, i2) => zipWith2(acc, a, (acc2, a2) => f(acc2, a2, i2)), zero3), () => suspend(() => pipe(mergeAll3([zero3, ...elements], none2(), (acc, elem, i2) => {
  switch (acc._tag) {
    case "None": {
      return some2(elem);
    }
    case "Some": {
      return some2(f(acc.value, elem, i2));
    }
  }
}, options), map9((option2) => {
  switch (option2._tag) {
    case "None": {
      throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    case "Some": {
      return option2.value;
    }
  }
})))));
var parallelFinalizers = (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self2,
  onSome: (scope) => {
    switch (scope.strategy._tag) {
      case "Parallel":
        return self2;
      case "Sequential":
      case "ParallelN":
        return flatMap7(scopeFork(scope, parallel3), (inner) => scopeExtend(self2, inner));
    }
  }
}));
var parallelNFinalizers = (parallelism) => (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self2,
  onSome: (scope) => {
    if (scope.strategy._tag === "ParallelN" && scope.strategy.parallelism === parallelism) {
      return self2;
    }
    return flatMap7(scopeFork(scope, parallelN2(parallelism)), (inner) => scopeExtend(self2, inner));
  }
}));
var finalizersMask = (strategy) => (self2) => finalizersMaskInternal(strategy, true)(self2);
var finalizersMaskInternal = (strategy, concurrentFinalizers) => (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self2(identity),
  onSome: (scope) => {
    if (concurrentFinalizers === true) {
      const patch12 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
      switch (scope.strategy._tag) {
        case "Parallel":
          return patch12(self2(parallelFinalizers));
        case "Sequential":
          return patch12(self2(sequentialFinalizers));
        case "ParallelN":
          return patch12(self2(parallelNFinalizers(scope.strategy.parallelism)));
      }
    } else {
      return self2(identity);
    }
  }
}));
var scopeWith = (f) => flatMap7(scopeTag, f);
var scopedWith = (f) => flatMap7(scopeMake(), (scope) => onExit(f(scope), (exit2) => scope.close(exit2)));
var scopedEffect = (effect) => flatMap7(scopeMake(), (scope) => scopeUse(effect, scope));
var sequentialFinalizers = (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self2,
  onSome: (scope) => {
    switch (scope.strategy._tag) {
      case "Sequential":
        return self2;
      case "Parallel":
      case "ParallelN":
        return flatMap7(scopeFork(scope, sequential3), (inner) => scopeExtend(self2, inner));
    }
  }
}));
var tagMetricsScoped = (key, value) => labelMetricsScoped([make29(key, value)]);
var labelMetricsScoped = (labels) => fiberRefLocallyScopedWith(currentMetricLabels, (old) => union2(old, labels));
var using = /* @__PURE__ */ dual(2, (self2, use) => scopedWith((scope) => flatMap7(scopeExtend(self2, scope), use)));
var validate = /* @__PURE__ */ dual((args3) => isEffect(args3[1]), (self2, that, options) => validateWith(self2, that, (a, b3) => [a, b3], options));
var validateWith = /* @__PURE__ */ dual((args3) => isEffect(args3[1]), (self2, that, f, options) => flatten5(zipWithOptions(exit(self2), exit(that), (ea, eb) => exitZipWith(ea, eb, {
  onSuccess: f,
  onFailure: (ca, cb) => options?.concurrent ? parallel(ca, cb) : sequential(ca, cb)
}), options)));
var validateFirst = /* @__PURE__ */ dual((args3) => isIterable(args3[0]), (elements, f, options) => flip(forEach7(elements, (a, i2) => flip(f(a, i2)), options)));
var withClockScoped = (c) => fiberRefLocallyScopedWith(currentServices, add2(clockTag, c));
var withRandomScoped = (value) => fiberRefLocallyScopedWith(currentServices, add2(randomTag, value));
var withConfigProviderScoped = (provider) => fiberRefLocallyScopedWith(currentServices, add2(configProviderTag, provider));
var withEarlyRelease = (self2) => scopeWith((parent) => flatMap7(scopeFork(parent, sequential2), (child) => pipe(self2, scopeExtend(child), map9((value) => [fiberIdWith((fiberId2) => scopeClose(child, exitInterrupt(fiberId2))), value]))));
var zipOptions = /* @__PURE__ */ dual((args3) => isEffect(args3[1]), (self2, that, options) => zipWithOptions(self2, that, (a, b3) => [a, b3], options));
var zipLeftOptions = /* @__PURE__ */ dual((args3) => isEffect(args3[1]), (self2, that, options) => {
  if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
    return zipLeft(self2, that);
  }
  return zipWithOptions(self2, that, (a, _2) => a, options);
});
var zipRightOptions = /* @__PURE__ */ dual((args3) => isEffect(args3[1]), (self2, that, options) => {
  if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
    return zipRight(self2, that);
  }
  return zipWithOptions(self2, that, (_2, b3) => b3, options);
});
var zipWithOptions = /* @__PURE__ */ dual((args3) => isEffect(args3[1]), (self2, that, f, options) => map9(all2([self2, that], {
  concurrency: options?.concurrent ? 2 : 1,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([a, a2]) => f(a, a2)));
var withRuntimeFlagsScoped = (update5) => {
  if (update5 === empty18) {
    return void_;
  }
  return pipe(runtimeFlags, flatMap7((runtimeFlags2) => {
    const updatedRuntimeFlags = patch7(runtimeFlags2, update5);
    const revertRuntimeFlags = diff7(updatedRuntimeFlags, runtimeFlags2);
    return pipe(updateRuntimeFlags(update5), zipRight(addFinalizer(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid);
  }), uninterruptible);
};
var scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
var scope = scopeTag;
var scopeUnsafeAddFinalizer = (scope2, fin) => {
  if (scope2.state._tag === "Open") {
    scope2.state.finalizers.set({}, fin);
  }
};
var ScopeImplProto = {
  [ScopeTypeId]: ScopeTypeId,
  [CloseableScopeTypeId]: CloseableScopeTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  fork(strategy) {
    return sync(() => {
      const newScope = scopeUnsafeMake(strategy);
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      const key = {};
      const fin = (exit2) => newScope.close(exit2);
      this.state.finalizers.set(key, fin);
      scopeUnsafeAddFinalizer(newScope, (_2) => sync(() => {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(key);
        }
      }));
      return newScope;
    });
  },
  close(exit2) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return void_;
      }
      const finalizers = Array.from(this.state.finalizers.values()).reverse();
      this.state = {
        _tag: "Closed",
        exit: exit2
      };
      if (finalizers.length === 0) {
        return void_;
      }
      return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit(fin(exit2))), flatMap7((results) => pipe(exitCollectAll(results), map2(exitAsVoid), getOrElse(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit(fin(exit2)), false), flatMap7((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit(fin(exit2)), false), flatMap7((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse(() => exitVoid))));
    });
  },
  addFinalizer(fin) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return fin(this.state.exit);
      }
      this.state.finalizers.set({}, fin);
      return void_;
    });
  }
};
var scopeUnsafeMake = (strategy = sequential2) => {
  const scope2 = Object.create(ScopeImplProto);
  scope2.strategy = strategy;
  scope2.state = {
    _tag: "Open",
    finalizers: new Map
  };
  return scope2;
};
var scopeMake = (strategy = sequential2) => sync(() => scopeUnsafeMake(strategy));
var scopeExtend = /* @__PURE__ */ dual(2, (effect, scope2) => mapInputContext(effect, merge3(make6(scopeTag, scope2))));
var scopeUse = /* @__PURE__ */ dual(2, (effect, scope2) => pipe(effect, scopeExtend(scope2), onExit((exit2) => scope2.close(exit2))));
var fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ: differ2,
  fork: empty29
});
var fiberRefLocallyScoped = /* @__PURE__ */ dual(2, (self2, value) => asVoid(acquireRelease(flatMap7(fiberRefGet(self2), (oldValue) => as(fiberRefSet(self2, value), oldValue)), (oldValue) => fiberRefSet(self2, oldValue))));
var fiberRefLocallyScopedWith = /* @__PURE__ */ dual(2, (self2, f) => fiberRefGetWith(self2, (a) => fiberRefLocallyScoped(self2, f(a))));
var currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none5);
var currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none8);
var fiberAwaitAll = (fibers) => forEach7(fibers, _await2);
var fiberAll = (fibers) => {
  const _fiberAll = {
    ...CommitPrototype2,
    commit() {
      return join2(this);
    },
    [FiberTypeId]: fiberVariance2,
    id: () => fromIterable(fibers).reduce((id, fiber) => combine3(id, fiber.id()), none4),
    await: exit(forEachParUnbounded(fibers, (fiber) => flatten5(fiber.await), false)),
    children: map9(forEachParUnbounded(fibers, (fiber) => fiber.children, false), flatten),
    inheritAll: forEachSequentialDiscard(fibers, (fiber) => fiber.inheritAll),
    poll: map9(forEachSequential(fibers, (fiber) => fiber.poll), reduceRight(some2(exitSucceed(new Array)), (optionB, optionA) => {
      switch (optionA._tag) {
        case "None": {
          return none2();
        }
        case "Some": {
          switch (optionB._tag) {
            case "None": {
              return none2();
            }
            case "Some": {
              return some2(exitZipWith(optionA.value, optionB.value, {
                onSuccess: (a, chunk2) => [a, ...chunk2],
                onFailure: parallel
              }));
            }
          }
        }
      }
    })),
    interruptAsFork: (fiberId2) => forEachSequentialDiscard(fibers, (fiber) => fiber.interruptAsFork(fiberId2))
  };
  return _fiberAll;
};
var raceWith = /* @__PURE__ */ dual(3, (self2, other, options) => raceFibersWith(self2, other, {
  onSelfWin: (winner, loser) => flatMap7(winner.await, (exit2) => {
    switch (exit2._tag) {
      case OP_SUCCESS: {
        return flatMap7(winner.inheritAll, () => options.onSelfDone(exit2, loser));
      }
      case OP_FAILURE: {
        return options.onSelfDone(exit2, loser);
      }
    }
  }),
  onOtherWin: (winner, loser) => flatMap7(winner.await, (exit2) => {
    switch (exit2._tag) {
      case OP_SUCCESS: {
        return flatMap7(winner.inheritAll, () => options.onOtherDone(exit2, loser));
      }
      case OP_FAILURE: {
        return options.onOtherDone(exit2, loser);
      }
    }
  })
}));
var disconnect = (self2) => uninterruptibleMask((restore) => fiberIdWith((fiberId2) => flatMap7(forkDaemon(restore(self2)), (fiber) => pipe(restore(join2(fiber)), onInterrupt(() => pipe(fiber, interruptAsFork(fiberId2)))))));
var race = /* @__PURE__ */ dual(2, (self2, that) => fiberIdWith((parentFiberId) => raceWith(self2, that, {
  onSelfDone: (exit2, right3) => exitMatchEffect(exit2, {
    onFailure: (cause2) => pipe(join2(right3), mapErrorCause((cause22) => parallel(cause2, cause22))),
    onSuccess: (value) => pipe(right3, interruptAsFiber(parentFiberId), as(value))
  }),
  onOtherDone: (exit2, left3) => exitMatchEffect(exit2, {
    onFailure: (cause2) => pipe(join2(left3), mapErrorCause((cause22) => parallel(cause22, cause2))),
    onSuccess: (value) => pipe(left3, interruptAsFiber(parentFiberId), as(value))
  })
})));
var raceFibersWith = /* @__PURE__ */ dual(3, (self2, other, options) => withFiberRuntime((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = make12(true);
  const leftFiber = unsafeMakeChildFiber(self2, parentFiber, parentRuntimeFlags, options.selfScope);
  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
  return async_((cb) => {
    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self2);
    rightFiber.startFork(other);
  }, combine3(leftFiber.id(), rightFiber.id()));
}));
var completeRace = (winner, loser, cont, ab, cb) => {
  if (compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
};
var ensuring = /* @__PURE__ */ dual(2, (self2, finalizer) => uninterruptibleMask((restore) => matchCauseEffect(restore(self2), {
  onFailure: (cause1) => matchCauseEffect(finalizer, {
    onFailure: (cause2) => failCause(sequential(cause1, cause2)),
    onSuccess: () => failCause(cause1)
  }),
  onSuccess: (a) => as(finalizer, a)
})));
var invokeWithInterrupt = (self2, entries2, onInterrupt2) => fiberIdWith((id) => flatMap7(flatMap7(forkDaemon(interruptible2(self2)), (processing) => async_((cb) => {
  const counts = entries2.map((_2) => _2.listeners.count);
  const checkDone = () => {
    if (counts.every((count) => count === 0)) {
      if (entries2.every((_2) => {
        if (_2.result.state.current._tag === "Pending") {
          return true;
        } else if (_2.result.state.current._tag === "Done" && exitIsExit(_2.result.state.current.effect) && _2.result.state.current.effect._tag === "Failure" && isInterrupted(_2.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach((f) => f());
        onInterrupt2?.();
        cb(interruptFiber(processing));
      }
    }
  };
  processing.addObserver((exit2) => {
    cleanup.forEach((f) => f());
    cb(exit2);
  });
  const cleanup = entries2.map((r2, i2) => {
    const observer = (count) => {
      counts[i2] = count;
      checkDone();
    };
    r2.listeners.addObserver(observer);
    return () => r2.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach((f) => f());
  });
})), () => suspend(() => {
  const residual = entries2.flatMap((entry) => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, (entry) => complete(entry.request, exitInterrupt(id)));
})));
var makeSpanScoped = (name2, options) => {
  options = addSpanStackTrace(options);
  return uninterruptible(withFiberRuntime((fiber) => {
    const scope2 = unsafeGet3(fiber.getFiberRef(currentContext), scopeTag);
    const span2 = unsafeMakeSpan(fiber, name2, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock_ = get3(fiber.getFiberRef(currentServices), clockTag);
    return as(scopeAddFinalizerExit(scope2, (exit2) => endSpan(span2, exit2, clock_, timingEnabled)), span2);
  }));
};
var withTracerScoped = (value) => fiberRefLocallyScopedWith(currentServices, add2(tracerTag, value));
var withSpanScoped = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name2 = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return flatMap7(makeSpanScoped(name2, addSpanStackTrace(options)), (span2) => provideService(self2, spanTag, span2));
  }
  return (self2) => flatMap7(makeSpanScoped(name2, addSpanStackTrace(options)), (span2) => provideService(self2, spanTag, span2));
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/cache.js
var complete2 = (key, exit2, entryStats, timeToLiveMillis) => struct({
  _tag: "Complete",
  key,
  exit: exit2,
  entryStats,
  timeToLiveMillis
});
var pending2 = (key, deferred) => struct({
  _tag: "Pending",
  key,
  deferred
});
var refreshing = (deferred, complete3) => struct({
  _tag: "Refreshing",
  deferred,
  complete: complete3
});
var MapKeyTypeId = /* @__PURE__ */ Symbol.for("effect/Cache/MapKey");

class MapKeyImpl {
  current;
  [MapKeyTypeId] = MapKeyTypeId;
  previous = undefined;
  next = undefined;
  constructor(current) {
    this.current = current;
  }
  [symbol]() {
    return pipe(hash(this.current), combine(hash(this.previous)), combine(hash(this.next)), cached(this));
  }
  [symbol2](that) {
    if (this === that) {
      return true;
    }
    return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
  }
}
var makeMapKey = (current) => new MapKeyImpl(current);
var isMapKey = (u3) => hasProperty(u3, MapKeyTypeId);

class KeySetImpl {
  head = undefined;
  tail = undefined;
  add(key) {
    if (key !== this.tail) {
      if (this.tail === undefined) {
        this.head = key;
        this.tail = key;
      } else {
        const previous = key.previous;
        const next = key.next;
        if (next !== undefined) {
          key.next = undefined;
          if (previous !== undefined) {
            previous.next = next;
            next.previous = previous;
          } else {
            this.head = next;
            this.head.previous = undefined;
          }
        }
        this.tail.next = key;
        key.previous = this.tail;
        this.tail = key;
      }
    }
  }
  remove() {
    const key = this.head;
    if (key !== undefined) {
      const next = key.next;
      if (next !== undefined) {
        key.next = undefined;
        this.head = next;
        this.head.previous = undefined;
      } else {
        this.head = undefined;
        this.tail = undefined;
      }
    }
    return key;
  }
}
var makeKeySet = () => new KeySetImpl;
var makeCacheState = (map10, keys5, accesses, updating, hits, misses) => ({
  map: map10,
  keys: keys5,
  accesses,
  updating,
  hits,
  misses
});
var initialCacheState = () => makeCacheState(empty21(), makeKeySet(), unbounded(), make12(false), 0, 0);
var CacheSymbolKey = "effect/Cache";
var CacheTypeId = /* @__PURE__ */ Symbol.for(CacheSymbolKey);
var cacheVariance = {
  _Key: (_2) => _2,
  _Error: (_2) => _2,
  _Value: (_2) => _2
};
var ConsumerCacheSymbolKey = "effect/ConsumerCache";
var ConsumerCacheTypeId = /* @__PURE__ */ Symbol.for(ConsumerCacheSymbolKey);
var consumerCacheVariance = {
  _Key: (_2) => _2,
  _Error: (_2) => _2,
  _Value: (_2) => _2
};
var makeCacheStats = (options) => options;
var makeEntryStats = (loadedMillis) => ({
  loadedMillis
});

class CacheImpl {
  capacity;
  context;
  fiberId;
  lookup;
  timeToLive;
  [CacheTypeId] = cacheVariance;
  [ConsumerCacheTypeId] = consumerCacheVariance;
  cacheState;
  constructor(capacity, context2, fiberId2, lookup, timeToLive) {
    this.capacity = capacity;
    this.context = context2;
    this.fiberId = fiberId2;
    this.lookup = lookup;
    this.timeToLive = timeToLive;
    this.cacheState = initialCacheState();
  }
  get(key) {
    return map9(this.getEither(key), merge);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size4(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match2(get8(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value) => this.resolveMapValue(value)
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match2(get8(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value) => this.resolveMapValue(value, true)
    }));
  }
  contains(key) {
    return sync(() => has4(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const option2 = get8(this.cacheState.map, key);
      if (isSome2(option2)) {
        switch (option2.value._tag) {
          case "Complete": {
            const loaded = option2.value.entryStats.loadedMillis;
            return some2(makeEntryStats(loaded));
          }
          case "Pending": {
            return none2();
          }
          case "Refreshing": {
            const loaded = option2.value.complete.entryStats.loadedMillis;
            return some2(makeEntryStats(loaded));
          }
        }
      }
      return none2();
    });
  }
  getEither(key) {
    return suspend(() => {
      const k2 = key;
      let mapKey = undefined;
      let deferred = undefined;
      let value = getOrUndefined(get8(this.cacheState.map, k2));
      if (value === undefined) {
        deferred = unsafeMake4(this.fiberId);
        mapKey = makeMapKey(k2);
        if (has4(this.cacheState.map, k2)) {
          value = getOrUndefined(get8(this.cacheState.map, k2));
        } else {
          set4(this.cacheState.map, k2, pending2(mapKey, deferred));
        }
      }
      if (value === undefined) {
        this.trackAccess(mapKey);
        this.trackMiss();
        return map9(this.lookupValueOf(key, deferred), right2);
      } else {
        return flatMap7(this.resolveMapValue(value), match2({
          onNone: () => this.getEither(key),
          onSome: (value2) => succeed(left2(value2))
        }));
      }
    });
  }
  invalidate(key) {
    return sync(() => {
      remove6(this.cacheState.map, key);
    });
  }
  invalidateWhen(key, when2) {
    return sync(() => {
      const value = get8(this.cacheState.map, key);
      if (isSome2(value) && value.value._tag === "Complete") {
        if (value.value.exit._tag === "Success") {
          if (when2(value.value.exit.value)) {
            remove6(this.cacheState.map, key);
          }
        }
      }
    });
  }
  get invalidateAll() {
    return sync(() => {
      this.cacheState.map = empty21();
    });
  }
  refresh(key) {
    return clockWith3((clock2) => suspend(() => {
      const k2 = key;
      const deferred = unsafeMake4(this.fiberId);
      let value = getOrUndefined(get8(this.cacheState.map, k2));
      if (value === undefined) {
        if (has4(this.cacheState.map, k2)) {
          value = getOrUndefined(get8(this.cacheState.map, k2));
        } else {
          set4(this.cacheState.map, k2, pending2(makeMapKey(k2), deferred));
        }
      }
      if (value === undefined) {
        return asVoid(this.lookupValueOf(key, deferred));
      } else {
        switch (value._tag) {
          case "Complete": {
            if (this.hasExpired(clock2, value.timeToLiveMillis)) {
              const found = getOrUndefined(get8(this.cacheState.map, k2));
              if (equals(found, value)) {
                remove6(this.cacheState.map, k2);
              }
              return asVoid(this.get(key));
            }
            return pipe(this.lookupValueOf(key, deferred), when(() => {
              const current = getOrUndefined(get8(this.cacheState.map, k2));
              if (equals(current, value)) {
                const mapValue = refreshing(deferred, value);
                set4(this.cacheState.map, k2, mapValue);
                return true;
              }
              return false;
            }), asVoid);
          }
          case "Pending": {
            return _await(value.deferred);
          }
          case "Refreshing": {
            return _await(value.deferred);
          }
        }
      }
    }));
  }
  set(key, value) {
    return clockWith3((clock2) => sync(() => {
      const now = clock2.unsafeCurrentTimeMillis();
      const k2 = key;
      const lookupResult = succeed2(value);
      const mapValue = complete2(makeMapKey(k2), lookupResult, makeEntryStats(now), now + toMillis(decode(this.timeToLive(lookupResult))));
      set4(this.cacheState.map, k2, mapValue);
    }));
  }
  get size() {
    return sync(() => {
      return size4(this.cacheState.map);
    });
  }
  get values() {
    return sync(() => {
      const values4 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values4.push(entry[1].exit.value);
        }
      }
      return values4;
    });
  }
  get entries() {
    return sync(() => {
      const values4 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values4.push([entry[0], entry[1].exit.value]);
        }
      }
      return values4;
    });
  }
  get keys() {
    return sync(() => {
      const keys5 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          keys5.push(entry[0]);
        }
      }
      return keys5;
    });
  }
  resolveMapValue(value, ignorePending = false) {
    return clockWith3((clock2) => {
      switch (value._tag) {
        case "Complete": {
          this.trackAccess(value.key);
          if (this.hasExpired(clock2, value.timeToLiveMillis)) {
            remove6(this.cacheState.map, value.key.current);
            return succeed(none2());
          }
          this.trackHit();
          return map9(value.exit, some2);
        }
        case "Pending": {
          this.trackAccess(value.key);
          this.trackHit();
          if (ignorePending) {
            return succeed(none2());
          }
          return map9(_await(value.deferred), some2);
        }
        case "Refreshing": {
          this.trackAccess(value.complete.key);
          this.trackHit();
          if (this.hasExpired(clock2, value.complete.timeToLiveMillis)) {
            if (ignorePending) {
              return succeed(none2());
            }
            return map9(_await(value.deferred), some2);
          }
          return map9(value.complete.exit, some2);
        }
      }
    });
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop2 = true;
      while (loop2) {
        const key2 = poll(this.cacheState.accesses, EmptyMutableQueue);
        if (key2 === EmptyMutableQueue) {
          loop2 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size8 = size4(this.cacheState.map);
      loop2 = size8 > this.capacity;
      while (loop2) {
        const key2 = this.cacheState.keys.remove();
        if (key2 !== undefined) {
          if (has4(this.cacheState.map, key2.current)) {
            remove6(this.cacheState.map, key2.current);
            size8 = size8 - 1;
            loop2 = size8 > this.capacity;
          }
        } else {
          loop2 = false;
        }
      }
      set2(this.cacheState.updating, false);
    }
  }
  hasExpired(clock2, timeToLiveMillis) {
    return clock2.unsafeCurrentTimeMillis() > timeToLiveMillis;
  }
  lookupValueOf(input, deferred) {
    return clockWith3((clock2) => suspend(() => {
      const key = input;
      return pipe(this.lookup(input), provideContext(this.context), exit, flatMap7((exit2) => {
        const now = clock2.unsafeCurrentTimeMillis();
        const stats = makeEntryStats(now);
        const value = complete2(makeMapKey(key), exit2, stats, now + toMillis(decode(this.timeToLive(exit2))));
        set4(this.cacheState.map, key, value);
        return zipRight(done2(deferred, exit2), exit2);
      }), onInterrupt(() => zipRight(interrupt3(deferred), sync(() => {
        remove6(this.cacheState.map, key);
      }))));
    }));
  }
}
var unsafeMakeWith = (capacity, lookup, timeToLive) => new CacheImpl(capacity, empty4(), none3, lookup, (exit2) => decode(timeToLive(exit2)));
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Cause.js
var empty30 = empty20;
var fail4 = fail;
var die4 = die;
var interrupt5 = interrupt;
var parallel4 = parallel;
var sequential4 = sequential;
var isCause2 = isCause;
var isFailType2 = isFailType;
var failureOrCause2 = failureOrCause;
var IllegalArgumentException2 = IllegalArgumentException;
var NoSuchElementException2 = NoSuchElementException;
var pretty2 = pretty;
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Effect.js
var exports_Effect = {};
__export(exports_Effect, {
  zipWith: () => zipWith6,
  zipRight: () => zipRight2,
  zipLeft: () => zipLeft2,
  zip: () => zip4,
  yieldNow: () => yieldNow4,
  withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel2,
  withTracerTiming: () => withTracerTiming2,
  withTracerScoped: () => withTracerScoped2,
  withTracerEnabled: () => withTracerEnabled2,
  withTracer: () => withTracer2,
  withSpanScoped: () => withSpanScoped2,
  withSpan: () => withSpan3,
  withSchedulingPriority: () => withSchedulingPriority2,
  withScheduler: () => withScheduler2,
  withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped,
  withRuntimeFlagsPatch: () => withRuntimeFlagsPatch,
  withRequestCaching: () => withRequestCaching2,
  withRequestCache: () => withRequestCache2,
  withRequestBatching: () => withRequestBatching2,
  withRandomScoped: () => withRandomScoped2,
  withRandom: () => withRandom2,
  withParentSpan: () => withParentSpan3,
  withMetric: () => withMetric2,
  withMaxOpsBeforeYield: () => withMaxOpsBeforeYield2,
  withLogSpan: () => withLogSpan2,
  withFiberRuntime: () => withFiberRuntime2,
  withExecutionPlan: () => withExecutionPlan2,
  withEarlyRelease: () => withEarlyRelease2,
  withConsoleScoped: () => withConsoleScoped2,
  withConsole: () => withConsole2,
  withConfigProviderScoped: () => withConfigProviderScoped2,
  withConfigProvider: () => withConfigProvider2,
  withConcurrency: () => withConcurrency2,
  withClockScoped: () => withClockScoped2,
  withClock: () => withClock2,
  whileLoop: () => whileLoop2,
  whenRef: () => whenRef2,
  whenLogLevel: () => whenLogLevel2,
  whenFiberRef: () => whenFiberRef2,
  whenEffect: () => whenEffect2,
  when: () => when2,
  void: () => _void,
  validateWith: () => validateWith2,
  validateFirst: () => validateFirst2,
  validateAll: () => validateAll2,
  validate: () => validate2,
  using: () => using2,
  useSpan: () => useSpan2,
  updateService: () => updateService2,
  updateFiberRefs: () => updateFiberRefs3,
  unsandbox: () => unsandbox2,
  unsafeMakeSemaphore: () => unsafeMakeSemaphore2,
  unsafeMakeLatch: () => unsafeMakeLatch2,
  unlessEffect: () => unlessEffect2,
  unless: () => unless2,
  uninterruptibleMask: () => uninterruptibleMask3,
  uninterruptible: () => uninterruptible2,
  tryPromise: () => tryPromise2,
  tryMapPromise: () => tryMapPromise2,
  tryMap: () => tryMap2,
  try: () => try_3,
  transposeOption: () => transposeOption,
  transposeMapOption: () => transposeMapOption,
  transplant: () => transplant2,
  tracerWith: () => tracerWith4,
  tracer: () => tracer3,
  timeoutTo: () => timeoutTo2,
  timeoutOption: () => timeoutOption2,
  timeoutFailCause: () => timeoutFailCause2,
  timeoutFail: () => timeoutFail2,
  timeout: () => timeout2,
  timedWith: () => timedWith2,
  timed: () => timed2,
  tapErrorTag: () => tapErrorTag2,
  tapErrorCause: () => tapErrorCause3,
  tapError: () => tapError3,
  tapDefect: () => tapDefect2,
  tapBoth: () => tapBoth2,
  tap: () => tap3,
  takeWhile: () => takeWhile2,
  takeUntil: () => takeUntil2,
  tagMetricsScoped: () => tagMetricsScoped2,
  tagMetrics: () => tagMetrics2,
  sync: () => sync3,
  suspend: () => suspend3,
  supervised: () => supervised2,
  summarized: () => summarized2,
  succeedSome: () => succeedSome2,
  succeedNone: () => succeedNone2,
  succeed: () => succeed7,
  step: () => step3,
  spanLinks: () => spanLinks2,
  spanAnnotations: () => spanAnnotations2,
  sleep: () => sleep4,
  setFiberRefs: () => setFiberRefs2,
  serviceOptional: () => serviceOptional2,
  serviceOption: () => serviceOption2,
  serviceMembers: () => serviceMembers2,
  serviceFunctions: () => serviceFunctions2,
  serviceFunctionEffect: () => serviceFunctionEffect2,
  serviceFunction: () => serviceFunction2,
  serviceConstants: () => serviceConstants2,
  sequentialFinalizers: () => sequentialFinalizers2,
  scopedWith: () => scopedWith2,
  scoped: () => scoped2,
  scopeWith: () => scopeWith2,
  scope: () => scope3,
  scheduleFrom: () => scheduleFrom,
  scheduleForked: () => scheduleForked2,
  schedule: () => schedule,
  sandbox: () => sandbox2,
  runtime: () => runtime4,
  runSyncExit: () => runSyncExit,
  runSync: () => runSync,
  runRequestBlock: () => runRequestBlock2,
  runPromiseExit: () => runPromiseExit,
  runPromise: () => runPromise,
  runFork: () => runFork2,
  runCallback: () => runCallback,
  retryOrElse: () => retryOrElse,
  retry: () => retry2,
  request: () => request,
  replicateEffect: () => replicateEffect2,
  replicate: () => replicate2,
  repeatOrElse: () => repeatOrElse,
  repeatN: () => repeatN2,
  repeat: () => repeat,
  reduceWhile: () => reduceWhile2,
  reduceRight: () => reduceRight3,
  reduceEffect: () => reduceEffect2,
  reduce: () => reduce12,
  randomWith: () => randomWith2,
  random: () => random3,
  raceWith: () => raceWith2,
  raceFirst: () => raceFirst2,
  raceAll: () => raceAll2,
  race: () => race2,
  provideServiceEffect: () => provideServiceEffect2,
  provideService: () => provideService3,
  provide: () => provide2,
  promise: () => promise2,
  patchRuntimeFlags: () => patchRuntimeFlags,
  patchFiberRefs: () => patchFiberRefs2,
  partition: () => partition4,
  parallelFinalizers: () => parallelFinalizers2,
  parallelErrors: () => parallelErrors2,
  orElseSucceed: () => orElseSucceed2,
  orElseFail: () => orElseFail2,
  orElse: () => orElse5,
  orDieWith: () => orDieWith2,
  orDie: () => orDie3,
  optionFromOptional: () => optionFromOptional2,
  option: () => option2,
  once: () => once3,
  onInterrupt: () => onInterrupt2,
  onExit: () => onExit3,
  onError: () => onError2,
  none: () => none9,
  never: () => never3,
  negate: () => negate2,
  metricLabels: () => metricLabels2,
  mergeAll: () => mergeAll5,
  merge: () => merge7,
  matchEffect: () => matchEffect2,
  matchCauseEffect: () => matchCauseEffect3,
  matchCause: () => matchCause3,
  match: () => match13,
  mapInputContext: () => mapInputContext2,
  mapErrorCause: () => mapErrorCause2,
  mapError: () => mapError3,
  mapBoth: () => mapBoth3,
  mapAccum: () => mapAccum3,
  map: () => map13,
  makeSpanScoped: () => makeSpanScoped2,
  makeSpan: () => makeSpan2,
  makeSemaphore: () => makeSemaphore2,
  makeLatch: () => makeLatch2,
  loop: () => loop2,
  logWithLevel: () => logWithLevel2,
  logWarning: () => logWarning2,
  logTrace: () => logTrace2,
  logInfo: () => logInfo2,
  logFatal: () => logFatal2,
  logError: () => logError2,
  logDebug: () => logDebug2,
  logAnnotations: () => logAnnotations2,
  log: () => log2,
  locallyWith: () => locallyWith,
  locallyScopedWith: () => locallyScopedWith,
  locallyScoped: () => locallyScoped,
  locally: () => locally,
  linkSpans: () => linkSpans2,
  linkSpanCurrent: () => linkSpanCurrent2,
  liftPredicate: () => liftPredicate2,
  let: () => let_3,
  labelMetricsScoped: () => labelMetricsScoped2,
  labelMetrics: () => labelMetrics2,
  iterate: () => iterate2,
  isSuccess: () => isSuccess3,
  isFailure: () => isFailure3,
  isEffect: () => isEffect2,
  intoDeferred: () => intoDeferred2,
  interruptibleMask: () => interruptibleMask2,
  interruptible: () => interruptible4,
  interruptWith: () => interruptWith2,
  interrupt: () => interrupt6,
  inheritFiberRefs: () => inheritFiberRefs2,
  ignoreLogged: () => ignoreLogged2,
  ignore: () => ignore2,
  if: () => if_2,
  head: () => head4,
  getRuntimeFlags: () => getRuntimeFlags,
  getFiberRefs: () => getFiberRefs,
  gen: () => gen2,
  functionWithSpan: () => functionWithSpan2,
  fromNullable: () => fromNullable3,
  fromFiberEffect: () => fromFiberEffect2,
  fromFiber: () => fromFiber2,
  forkWithErrorHandler: () => forkWithErrorHandler2,
  forkScoped: () => forkScoped2,
  forkIn: () => forkIn2,
  forkDaemon: () => forkDaemon2,
  forkAll: () => forkAll2,
  fork: () => fork3,
  forever: () => forever3,
  forEach: () => forEach8,
  fnUntraced: () => fnUntraced2,
  fn: () => fn2,
  flipWith: () => flipWith2,
  flip: () => flip2,
  flatten: () => flatten8,
  flatMap: () => flatMap10,
  firstSuccessOf: () => firstSuccessOf2,
  findFirst: () => findFirst6,
  finalizersMask: () => finalizersMask2,
  filterOrFail: () => filterOrFail2,
  filterOrElse: () => filterOrElse2,
  filterOrDieMessage: () => filterOrDieMessage2,
  filterOrDie: () => filterOrDie2,
  filterMap: () => filterMap5,
  filterEffectOrFail: () => filterEffectOrFail2,
  filterEffectOrElse: () => filterEffectOrElse2,
  filter: () => filter7,
  fiberIdWith: () => fiberIdWith2,
  fiberId: () => fiberId2,
  failSync: () => failSync3,
  failCauseSync: () => failCauseSync3,
  failCause: () => failCause7,
  fail: () => fail8,
  exit: () => exit2,
  exists: () => exists4,
  every: () => every7,
  eventually: () => eventually2,
  ensuringChildren: () => ensuringChildren2,
  ensuringChild: () => ensuringChild2,
  ensuring: () => ensuring2,
  either: () => either3,
  dropWhile: () => dropWhile2,
  dropUntil: () => dropUntil2,
  disconnect: () => disconnect2,
  diffFiberRefs: () => diffFiberRefs2,
  dieSync: () => dieSync3,
  dieMessage: () => dieMessage2,
  die: () => die6,
  descriptorWith: () => descriptorWith2,
  descriptor: () => descriptor2,
  delay: () => delay2,
  daemonChildren: () => daemonChildren2,
  custom: () => custom2,
  currentSpan: () => currentSpan2,
  currentParentSpan: () => currentParentSpan2,
  contextWithEffect: () => contextWithEffect2,
  contextWith: () => contextWith2,
  context: () => context3,
  consoleWith: () => consoleWith2,
  console: () => console3,
  configProviderWith: () => configProviderWith2,
  clockWith: () => clockWith4,
  clock: () => clock2,
  checkInterruptible: () => checkInterruptible2,
  cause: () => cause2,
  catchTags: () => catchTags2,
  catchTag: () => catchTag2,
  catchSomeDefect: () => catchSomeDefect2,
  catchSomeCause: () => catchSomeCause2,
  catchSome: () => catchSome2,
  catchIf: () => catchIf2,
  catchAllDefect: () => catchAllDefect2,
  catchAllCause: () => catchAllCause3,
  catchAll: () => catchAll3,
  catch: () => _catch2,
  cachedWithTTL: () => cachedWithTTL,
  cachedInvalidateWithTTL: () => cachedInvalidateWithTTL2,
  cachedFunction: () => cachedFunction2,
  cached: () => cached3,
  cacheRequestResult: () => cacheRequestResult,
  blocked: () => blocked2,
  bindTo: () => bindTo3,
  bindAll: () => bindAll2,
  bind: () => bind3,
  awaitAllChildren: () => awaitAllChildren2,
  asyncEffect: () => asyncEffect2,
  async: () => async,
  asVoid: () => asVoid3,
  asSomeError: () => asSomeError2,
  asSome: () => asSome2,
  as: () => as3,
  ap: () => ap,
  annotateSpans: () => annotateSpans3,
  annotateLogsScoped: () => annotateLogsScoped2,
  annotateLogs: () => annotateLogs3,
  annotateCurrentSpan: () => annotateCurrentSpan2,
  andThen: () => andThen4,
  allowInterrupt: () => allowInterrupt2,
  allWith: () => allWith2,
  allSuccesses: () => allSuccesses2,
  all: () => all4,
  addFinalizer: () => addFinalizer2,
  acquireUseRelease: () => acquireUseRelease2,
  acquireReleaseInterruptible: () => acquireReleaseInterruptible2,
  acquireRelease: () => acquireRelease2,
  Tag: () => Tag3,
  Service: () => Service,
  EffectTypeId: () => EffectTypeId3,
  Do: () => Do2
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/schedule/interval.js
var IntervalSymbolKey = "effect/ScheduleInterval";
var IntervalTypeId = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
var empty31 = {
  [IntervalTypeId]: IntervalTypeId,
  startMillis: 0,
  endMillis: 0
};
var make36 = (startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty31;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
};
var lessThan4 = /* @__PURE__ */ dual(2, (self2, that) => min2(self2, that) === self2);
var min2 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2.endMillis <= that.startMillis)
    return self2;
  if (that.endMillis <= self2.startMillis)
    return that;
  if (self2.startMillis < that.startMillis)
    return self2;
  if (that.startMillis < self2.startMillis)
    return that;
  if (self2.endMillis <= that.endMillis)
    return self2;
  return that;
});
var isEmpty7 = (self2) => {
  return self2.startMillis >= self2.endMillis;
};
var intersect2 = /* @__PURE__ */ dual(2, (self2, that) => {
  const start2 = Math.max(self2.startMillis, that.startMillis);
  const end = Math.min(self2.endMillis, that.endMillis);
  return make36(start2, end);
});
var after = (startMilliseconds) => {
  return make36(startMilliseconds, Number.POSITIVE_INFINITY);
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/ScheduleInterval.js
var empty32 = empty31;
var lessThan5 = lessThan4;
var isEmpty8 = isEmpty7;
var intersect3 = intersect2;
var after2 = after;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey = "effect/ScheduleIntervals";
var IntervalsTypeId = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
var make38 = (intervals) => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
};
var intersect4 = /* @__PURE__ */ dual(2, (self2, that) => intersectLoop(self2.intervals, that.intervals, empty5()));
var intersectLoop = (_left, _right, _acc) => {
  let left3 = _left;
  let right3 = _right;
  let acc = _acc;
  while (isNonEmpty2(left3) && isNonEmpty2(right3)) {
    const interval2 = pipe(headNonEmpty2(left3), intersect3(headNonEmpty2(right3)));
    const intervals = isEmpty8(interval2) ? acc : pipe(acc, prepend2(interval2));
    if (pipe(headNonEmpty2(left3), lessThan5(headNonEmpty2(right3)))) {
      left3 = tailNonEmpty2(left3);
    } else {
      right3 = tailNonEmpty2(right3);
    }
    acc = intervals;
  }
  return make38(reverse2(acc));
};
var start2 = (self2) => {
  return pipe(self2.intervals, head2, getOrElse(() => empty32)).startMillis;
};
var end = (self2) => {
  return pipe(self2.intervals, head2, getOrElse(() => empty32)).endMillis;
};
var lessThan6 = /* @__PURE__ */ dual(2, (self2, that) => start2(self2) < start2(that));
var isNonEmpty4 = (self2) => {
  return isNonEmpty2(self2.intervals);
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/ScheduleIntervals.js
var make39 = make38;
var intersect5 = intersect4;
var start3 = start2;
var end2 = end;
var lessThan7 = lessThan6;
var isNonEmpty5 = isNonEmpty4;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE = "Continue";
var OP_DONE2 = "Done";
var _continue = (intervals) => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
};
var continueWith = (interval2) => {
  return {
    _tag: OP_CONTINUE,
    intervals: make39(of2(interval2))
  };
};
var done5 = {
  _tag: OP_DONE2
};
var isContinue = (self2) => {
  return self2._tag === OP_CONTINUE;
};
var isDone3 = (self2) => {
  return self2._tag === OP_DONE2;
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/ScheduleDecision.js
var _continue2 = _continue;
var continueWith2 = continueWith;
var done6 = done5;
var isContinue2 = isContinue;
var isDone4 = isDone3;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Scope.js
var Scope = scopeTag;
var close = scopeClose;
var extend2 = scopeExtend;
var fork2 = scopeFork;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/effect/circular.js
class Semaphore {
  permits;
  waiters = /* @__PURE__ */ new Set;
  taken = 0;
  constructor(permits) {
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
  take = (n) => asyncInterrupt((resume2) => {
    if (this.free < n) {
      const observer = () => {
        if (this.free < n) {
          return;
        }
        this.waiters.delete(observer);
        this.taken += n;
        resume2(succeed(n));
      };
      this.waiters.add(observer);
      return sync(() => {
        this.waiters.delete(observer);
      });
    }
    this.taken += n;
    return resume2(succeed(n));
  });
  updateTaken = (f) => withFiberRuntime((fiber) => {
    this.taken = f(this.taken);
    if (this.waiters.size > 0) {
      fiber.getFiberRef(currentScheduler).scheduleTask(() => {
        const iter = this.waiters.values();
        let item = iter.next();
        while (item.done === false && this.free > 0) {
          item.value();
          item = iter.next();
        }
      }, fiber.getFiberRef(currentSchedulingPriority));
    }
    return succeed(this.free);
  });
  release = (n) => this.updateTaken((taken) => taken - n);
  releaseAll = /* @__PURE__ */ this.updateTaken((_2) => 0);
  withPermits = (n) => (self2) => uninterruptibleMask((restore) => flatMap7(restore(this.take(n)), (permits) => ensuring(restore(self2), this.release(permits))));
  withPermitsIfAvailable = (n) => (self2) => uninterruptibleMask((restore) => suspend(() => {
    if (this.free < n) {
      return succeedNone;
    }
    this.taken += n;
    return ensuring(restore(asSome(self2)), this.release(n));
  }));
}
var unsafeMakeSemaphore = (permits) => new Semaphore(permits);
var makeSemaphore = (permits) => sync(() => unsafeMakeSemaphore(permits));

class Latch extends Class {
  isOpen;
  waiters = [];
  scheduled = false;
  constructor(isOpen) {
    super();
    this.isOpen = isOpen;
  }
  commit() {
    return this.await;
  }
  unsafeSchedule(fiber) {
    if (this.scheduled || this.waiters.length === 0) {
      return void_;
    }
    this.scheduled = true;
    fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
    return void_;
  }
  flushWaiters = () => {
    this.scheduled = false;
    const waiters = this.waiters;
    this.waiters = [];
    for (let i2 = 0;i2 < waiters.length; i2++) {
      waiters[i2](exitVoid);
    }
  };
  open = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_;
    }
    this.isOpen = true;
    return this.unsafeSchedule(fiber);
  });
  unsafeOpen() {
    if (this.isOpen)
      return;
    this.isOpen = true;
    this.flushWaiters();
  }
  release = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_;
    }
    return this.unsafeSchedule(fiber);
  });
  await = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.isOpen) {
      return resume2(void_);
    }
    this.waiters.push(resume2);
    return sync(() => {
      const index2 = this.waiters.indexOf(resume2);
      if (index2 !== -1) {
        this.waiters.splice(index2, 1);
      }
    });
  });
  unsafeClose() {
    this.isOpen = false;
  }
  close = /* @__PURE__ */ sync(() => {
    this.isOpen = false;
  });
  whenOpen = (self2) => {
    return zipRight(this.await, self2);
  };
}
var unsafeMakeLatch = (open) => new Latch(open ?? false);
var makeLatch = (open) => sync(() => unsafeMakeLatch(open));
var awaitAllChildren = (self2) => ensuringChildren(self2, fiberAwaitAll);
var cached2 = /* @__PURE__ */ dual(2, (self2, timeToLive) => map9(cachedInvalidateWithTTL(self2, timeToLive), (tuple3) => tuple3[0]));
var cachedInvalidateWithTTL = /* @__PURE__ */ dual(2, (self2, timeToLive) => {
  const duration = decode(timeToLive);
  return flatMap7(context(), (env) => map9(makeSynchronized(none2()), (cache) => [provideContext(getCachedValue(self2, duration, cache), env), invalidateCache(cache)]));
});
var computeCachedValue = (self2, timeToLive, start4) => {
  const timeToLiveMillis = toMillis(decode(timeToLive));
  return pipe(deferredMake(), tap((deferred) => intoDeferred(self2, deferred)), map9((deferred) => some2([start4 + timeToLiveMillis, deferred])));
};
var getCachedValue = (self2, timeToLive, cache) => uninterruptibleMask((restore) => pipe(clockWith3((clock2) => clock2.currentTimeMillis), flatMap7((time2) => updateSomeAndGetEffectSynchronized(cache, (option2) => {
  switch (option2._tag) {
    case "None": {
      return some2(computeCachedValue(self2, timeToLive, time2));
    }
    case "Some": {
      const [end3] = option2.value;
      return end3 - time2 <= 0 ? some2(computeCachedValue(self2, timeToLive, time2)) : none2();
    }
  }
})), flatMap7((option2) => isNone2(option2) ? dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option2.value[1])))));
var invalidateCache = (cache) => set5(cache, none2());
var ensuringChild = /* @__PURE__ */ dual(2, (self2, f) => ensuringChildren(self2, (children) => f(fiberAll(children))));
var ensuringChildren = /* @__PURE__ */ dual(2, (self2, children) => flatMap7(track, (supervisor) => pipe(supervised(self2, supervisor), ensuring(flatMap7(supervisor.value, children)))));
var forkAll = /* @__PURE__ */ dual((args3) => isIterable(args3[0]), (effects, options) => options?.discard ? forEachSequentialDiscard(effects, fork) : map9(forEachSequential(effects, fork), fiberAll));
var forkIn = /* @__PURE__ */ dual(2, (self2, scope2) => withFiberRuntime((parent, parentStatus) => {
  const scopeImpl = scope2;
  const fiber = unsafeFork(self2, parent, parentStatus.runtimeFlags, globalScope);
  if (scopeImpl.state._tag === "Open") {
    const finalizer = () => fiberIdWith((fiberId2) => equals(fiberId2, fiber.id()) ? void_ : asVoid(interruptFiber(fiber)));
    const key = {};
    scopeImpl.state.finalizers.set(key, finalizer);
    fiber.addObserver(() => {
      if (scopeImpl.state._tag === "Closed")
        return;
      scopeImpl.state.finalizers.delete(key);
    });
  } else {
    fiber.unsafeInterruptAsFork(parent.id());
  }
  return succeed(fiber);
}));
var forkScoped = (self2) => scopeWith((scope2) => forkIn(self2, scope2));
var fromFiber = (fiber) => join2(fiber);
var fromFiberEffect = (fiber) => suspend(() => flatMap7(fiber, join2));
var memoKeySymbol = /* @__PURE__ */ Symbol.for("effect/Effect/memoizeFunction.key");

class Key {
  a;
  eq;
  [memoKeySymbol] = memoKeySymbol;
  constructor(a, eq2) {
    this.a = a;
    this.eq = eq2;
  }
  [symbol2](that) {
    if (hasProperty(that, memoKeySymbol)) {
      if (this.eq) {
        return this.eq(this.a, that.a);
      } else {
        return equals(this.a, that.a);
      }
    }
    return false;
  }
  [symbol]() {
    return this.eq ? 0 : cached(this, hash(this.a));
  }
}
var cachedFunction = (f, eq2) => {
  return pipe(sync(() => empty21()), flatMap7(makeSynchronized), map9((ref) => (a) => pipe(ref.modifyEffect((map10) => {
    const result = pipe(map10, get8(new Key(a, eq2)));
    if (isNone2(result)) {
      return pipe(deferredMake(), tap((deferred) => pipe(diffFiberRefs(f(a)), intoDeferred(deferred), fork)), map9((deferred) => [deferred, pipe(map10, set4(new Key(a, eq2), deferred))]));
    }
    return succeed([result.value, map10]);
  }), flatMap7(deferredAwait), flatMap7(([patch12, b3]) => pipe(patchFiberRefs(patch12), as(b3))))));
};
var raceFirst = /* @__PURE__ */ dual(2, (self2, that) => pipe(exit(self2), race(exit(that)), (effect) => flatten5(effect)));
var supervised = /* @__PURE__ */ dual(2, (self2, supervisor) => {
  const supervise = fiberRefLocallyWith(currentSupervisor, (s2) => s2.zip(supervisor));
  return supervise(self2);
});
var timeout = /* @__PURE__ */ dual(2, (self2, duration) => timeoutFail(self2, {
  onTimeout: () => timeoutExceptionFromDuration(duration),
  duration
}));
var timeoutFail = /* @__PURE__ */ dual(2, (self2, {
  duration,
  onTimeout
}) => flatten5(timeoutTo(self2, {
  onTimeout: () => failSync(onTimeout),
  onSuccess: succeed,
  duration
})));
var timeoutFailCause = /* @__PURE__ */ dual(2, (self2, {
  duration,
  onTimeout
}) => flatten5(timeoutTo(self2, {
  onTimeout: () => failCauseSync(onTimeout),
  onSuccess: succeed,
  duration
})));
var timeoutOption = /* @__PURE__ */ dual(2, (self2, duration) => timeoutTo(self2, {
  duration,
  onSuccess: some2,
  onTimeout: none2
}));
var timeoutTo = /* @__PURE__ */ dual(2, (self2, {
  duration,
  onSuccess,
  onTimeout
}) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self2), interruptible2(sleep3(duration)), {
  onSelfWin: (winner, loser) => flatMap7(winner.await, (exit2) => {
    if (exit2._tag === "Success") {
      return flatMap7(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onSuccess(exit2.value)));
    } else {
      return flatMap7(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit2.cause));
    }
  }),
  onOtherWin: (winner, loser) => flatMap7(winner.await, (exit2) => {
    if (exit2._tag === "Success") {
      return flatMap7(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onTimeout()));
    } else {
      return flatMap7(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit2.cause));
    }
  }),
  otherScope: globalScope
}))));
var SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
var SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
var synchronizedVariance = {
  _A: (_2) => _2
};

class SynchronizedImpl extends Class {
  ref;
  withLock;
  [SynchronizedTypeId] = synchronizedVariance;
  [RefTypeId] = refVariance;
  [TypeId13] = TypeId13;
  constructor(ref, withLock) {
    super();
    this.ref = ref;
    this.withLock = withLock;
    this.get = get11(this.ref);
  }
  get;
  commit() {
    return this.get;
  }
  modify(f) {
    return this.modifyEffect((a) => succeed(f(a)));
  }
  modifyEffect(f) {
    return this.withLock(pipe(flatMap7(get11(this.ref), f), flatMap7(([b3, a]) => as(set5(this.ref, a), b3))));
  }
}
var makeSynchronized = (value) => sync(() => unsafeMakeSynchronized(value));
var unsafeMakeSynchronized = (value) => {
  const ref = unsafeMake6(value);
  const sem = unsafeMakeSemaphore(1);
  return new SynchronizedImpl(ref, sem.withPermits(1));
};
var updateSomeAndGetEffectSynchronized = /* @__PURE__ */ dual(2, (self2, pf) => self2.modifyEffect((value) => {
  const result = pf(value);
  switch (result._tag) {
    case "None": {
      return succeed([value, value]);
    }
    case "Some": {
      return map9(result.value, (a) => [a, a]);
    }
  }
}));
var bindAll = /* @__PURE__ */ dual((args3) => isEffect(args3[0]), (self2, f, options) => flatMap7(self2, (a) => all2(f(a), options).pipe(map9((record2) => Object.assign({}, a, record2)))));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/managedRuntime/circular.js
var TypeId16 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/opCodes/layer.js
var OP_EXTEND_SCOPE = "ExtendScope";
var OP_FOLD = "Fold";
var OP_FRESH = "Fresh";
var OP_FROM_EFFECT = "FromEffect";
var OP_SCOPED = "Scoped";
var OP_SUSPEND = "Suspend";
var OP_PROVIDE = "Provide";
var OP_PROVIDE_MERGE = "ProvideMerge";
var OP_ZIP_WITH2 = "ZipWith";

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Fiber.js
var interruptAs = interruptAsFiber;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/runtime.js
var makeDual = (f) => function() {
  if (arguments.length === 1) {
    const runtime3 = arguments[0];
    return (effect, ...args3) => f(runtime3, effect, ...args3);
  }
  return f.apply(this, arguments);
};
var unsafeFork2 = /* @__PURE__ */ makeDual((runtime3, self2, options) => {
  const fiberId2 = unsafeMake3();
  const fiberRefUpdates = [[currentContext, [[fiberId2, runtime3.context]]]];
  if (options?.scheduler) {
    fiberRefUpdates.push([currentScheduler, [[fiberId2, options.scheduler]]]);
  }
  let fiberRefs3 = updateManyAs2(runtime3.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId2
  });
  if (options?.updateRefs) {
    fiberRefs3 = options.updateRefs(fiberRefs3, fiberId2);
  }
  const fiberRuntime = new FiberRuntime(fiberId2, fiberRefs3, runtime3.runtimeFlags);
  let effect = self2;
  if (options?.scope) {
    effect = flatMap7(fork2(options.scope, sequential2), (closeableScope) => zipRight(scopeAddFinalizer(closeableScope, fiberIdWith((id2) => equals(id2, fiberRuntime.id()) ? void_ : interruptAsFiber(fiberRuntime, id2))), onExit(self2, (exit2) => close(closeableScope, exit2))));
  }
  const supervisor = fiberRuntime.currentSupervisor;
  if (supervisor !== none8) {
    supervisor.onStart(runtime3.context, effect, none2(), fiberRuntime);
    fiberRuntime.addObserver((exit2) => supervisor.onEnd(exit2, fiberRuntime));
  }
  globalScope.add(runtime3.runtimeFlags, fiberRuntime);
  if (options?.immediate === false) {
    fiberRuntime.resume(effect);
  } else {
    fiberRuntime.start(effect);
  }
  return fiberRuntime;
});
var unsafeRunCallback = /* @__PURE__ */ makeDual((runtime3, effect, options = {}) => {
  const fiberRuntime = unsafeFork2(runtime3, effect, options);
  if (options.onExit) {
    fiberRuntime.addObserver((exit2) => {
      options.onExit(exit2);
    });
  }
  return (id2, cancelOptions) => unsafeRunCallback(runtime3)(pipe(fiberRuntime, interruptAs(id2 ?? none4)), {
    ...cancelOptions,
    onExit: cancelOptions?.onExit ? (exit2) => cancelOptions.onExit(flatten6(exit2)) : undefined
  });
});
var unsafeRunSync = /* @__PURE__ */ makeDual((runtime3, effect) => {
  const result = unsafeRunSyncExit(runtime3)(effect);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  }
  return result.effect_instruction_i0;
});

class AsyncFiberExceptionImpl extends Error {
  fiber;
  _tag = "AsyncFiberException";
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
}
var asyncFiberException = (fiber) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit;
  return error;
};
var isAsyncFiberException = (u3) => isTagged(u3, "AsyncFiberException") && ("fiber" in u3);
var FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");

class FiberFailureImpl extends Error {
  [FiberFailureId];
  [FiberFailureCauseId];
  constructor(cause2) {
    const head4 = prettyErrors(cause2)[0];
    super(head4?.message || "An error has occurred");
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause2;
    this.name = head4 ? `(FiberFailure) ${head4.name}` : "FiberFailure";
    if (head4?.stack) {
      this.stack = head4.stack;
    }
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
      renderErrorCause: true
    });
  }
  [NodeInspectSymbol]() {
    return this.toString();
  }
}
var fiberFailure = (cause2) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new FiberFailureImpl(cause2);
  Error.stackTraceLimit = limit;
  return error;
};
var isFiberFailure = (u3) => hasProperty(u3, FiberFailureId);
var fastPath = (effect) => {
  const op = effect;
  switch (op._op) {
    case "Failure":
    case "Success": {
      return op;
    }
    case "Left": {
      return exitFail(op.left);
    }
    case "Right": {
      return exitSucceed(op.right);
    }
    case "Some": {
      return exitSucceed(op.value);
    }
    case "None": {
      return exitFail(NoSuchElementException());
    }
  }
};
var unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime3, effect) => {
  const op = fastPath(effect);
  if (op) {
    return op;
  }
  const scheduler = new SyncScheduler;
  const fiberRuntime = unsafeFork2(runtime3)(effect, {
    scheduler
  });
  scheduler.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
});
var unsafeRunPromise = /* @__PURE__ */ makeDual((runtime3, effect, options) => unsafeRunPromiseExit(runtime3, effect, options).then((result) => {
  switch (result._tag) {
    case OP_SUCCESS: {
      return result.effect_instruction_i0;
    }
    case OP_FAILURE: {
      throw fiberFailure(result.effect_instruction_i0);
    }
  }
}));
var unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime3, effect, options) => new Promise((resolve) => {
  const op = fastPath(effect);
  if (op) {
    resolve(op);
  }
  const fiber = unsafeFork2(runtime3)(effect);
  fiber.addObserver((exit2) => {
    resolve(exit2);
  });
  if (options?.signal !== undefined) {
    if (options.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      }, {
        once: true
      });
    }
  }
}));

class RuntimeImpl {
  context;
  runtimeFlags;
  fiberRefs;
  constructor(context2, runtimeFlags2, fiberRefs3) {
    this.context = context2;
    this.runtimeFlags = runtimeFlags2;
    this.fiberRefs = fiberRefs3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var make40 = (options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
var runtime3 = () => withFiberRuntime((state, status2) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status2.runtimeFlags, state.getFiberRefs())));
var defaultRuntimeFlags = /* @__PURE__ */ make17(Interruption, CooperativeYielding, RuntimeMetrics);
var defaultRuntime = /* @__PURE__ */ make40({
  context: /* @__PURE__ */ empty4(),
  runtimeFlags: defaultRuntimeFlags,
  fiberRefs: /* @__PURE__ */ empty25()
});
var updateRuntimeFlags2 = /* @__PURE__ */ dual(2, (self2, f) => make40({
  context: self2.context,
  runtimeFlags: f(self2.runtimeFlags),
  fiberRefs: self2.fiberRefs
}));
var disableRuntimeFlag = /* @__PURE__ */ dual(2, (self2, flag) => updateRuntimeFlags2(self2, disable2(flag)));
var enableRuntimeFlag = /* @__PURE__ */ dual(2, (self2, flag) => updateRuntimeFlags2(self2, enable2(flag)));
var updateContext2 = /* @__PURE__ */ dual(2, (self2, f) => make40({
  context: f(self2.context),
  runtimeFlags: self2.runtimeFlags,
  fiberRefs: self2.fiberRefs
}));
var provideService2 = /* @__PURE__ */ dual(3, (self2, tag, service) => updateContext2(self2, add2(tag, service)));
var updateFiberRefs2 = /* @__PURE__ */ dual(2, (self2, f) => make40({
  context: self2.context,
  runtimeFlags: self2.runtimeFlags,
  fiberRefs: f(self2.fiberRefs)
}));
var setFiberRef = /* @__PURE__ */ dual(3, (self2, fiberRef, value) => updateFiberRefs2(self2, updateAs2({
  fiberId: none4,
  fiberRef,
  value
})));
var deleteFiberRef = /* @__PURE__ */ dual(2, (self2, fiberRef) => updateFiberRefs2(self2, delete_2(fiberRef)));
var unsafeRunEffect = /* @__PURE__ */ unsafeRunCallback(defaultRuntime);
var unsafeForkEffect = /* @__PURE__ */ unsafeFork2(defaultRuntime);
var unsafeRunPromiseEffect = /* @__PURE__ */ unsafeRunPromise(defaultRuntime);
var unsafeRunPromiseExitEffect = /* @__PURE__ */ unsafeRunPromiseExit(defaultRuntime);
var unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);
var unsafeRunSyncExitEffect = /* @__PURE__ */ unsafeRunSyncExit(defaultRuntime);
var asyncEffect = (register) => suspend(() => {
  let cleanup = undefined;
  return flatMap7(deferredMake(), (deferred) => flatMap7(runtime3(), (runtime4) => uninterruptibleMask((restore) => zipRight(fork(restore(matchCauseEffect(register((cb) => unsafeRunCallback(runtime4)(intoDeferred(cb, deferred))), {
    onFailure: (cause2) => deferredFailCause(deferred, cause2),
    onSuccess: (cleanup_) => {
      cleanup = cleanup_;
      return void_;
    }
  }))), restore(onInterrupt(deferredAwait(deferred), () => cleanup ?? void_))))));
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/synchronizedRef.js
var modifyEffect = /* @__PURE__ */ dual(2, (self2, f) => self2.modifyEffect(f));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/layer.js
var LayerSymbolKey = "effect/Layer";
var LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
var layerVariance = {
  _RIn: (_2) => _2,
  _E: (_2) => _2,
  _ROut: (_2) => _2
};
var proto3 = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MemoMapTypeIdKey = "effect/Layer/MemoMap";
var MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
var CurrentMemoMap = /* @__PURE__ */ Reference2()("effect/Layer/CurrentMemoMap", {
  defaultValue: () => unsafeMakeMemoMap()
});
var isLayer = (u3) => hasProperty(u3, LayerTypeId);
var isFresh = (self2) => {
  return self2._op_layer === OP_FRESH;
};

class MemoMapImpl {
  ref;
  [MemoMapTypeId];
  constructor(ref) {
    this.ref = ref;
    this[MemoMapTypeId] = MemoMapTypeId;
  }
  getOrElseMemoize(layer, scope2) {
    return pipe(modifyEffect(this.ref, (map11) => {
      const inMap = map11.get(layer);
      if (inMap !== undefined) {
        const [acquire, release] = inMap;
        const cached3 = pipe(acquire, flatMap7(([patch12, b3]) => pipe(patchFiberRefs(patch12), as(b3))), onExit(exitMatch({
          onFailure: () => void_,
          onSuccess: () => scopeAddFinalizerExit(scope2, release)
        })));
        return succeed([cached3, map11]);
      }
      return pipe(make27(0), flatMap7((observers) => pipe(deferredMake(), flatMap7((deferred) => pipe(make27(() => void_), map9((finalizerRef) => {
        const resource = uninterruptibleMask((restore) => pipe(scopeMake(), flatMap7((innerScope) => pipe(restore(flatMap7(makeBuilder(layer, innerScope, true), (f) => diffFiberRefs(f(this)))), exit, flatMap7((exit2) => {
          switch (exit2._tag) {
            case OP_FAILURE: {
              return pipe(deferredFailCause(deferred, exit2.effect_instruction_i0), zipRight(scopeClose(innerScope, exit2)), zipRight(failCause(exit2.effect_instruction_i0)));
            }
            case OP_SUCCESS: {
              return pipe(set5(finalizerRef, (exit3) => pipe(scopeClose(innerScope, exit3), whenEffect(modify3(observers, (n) => [n === 1, n - 1])), asVoid)), zipRight(update2(observers, (n) => n + 1)), zipRight(scopeAddFinalizerExit(scope2, (exit3) => pipe(sync(() => map11.delete(layer)), zipRight(get11(finalizerRef)), flatMap7((finalizer) => finalizer(exit3))))), zipRight(deferredSucceed(deferred, exit2.effect_instruction_i0)), as(exit2.effect_instruction_i0[1]));
            }
          }
        })))));
        const memoized = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
          onFailure: () => void_,
          onSuccess: () => update2(observers, (n) => n + 1)
        }))), (exit2) => pipe(get11(finalizerRef), flatMap7((finalizer) => finalizer(exit2)))];
        return [resource, isFresh(layer) ? map11 : map11.set(layer, memoized)];
      }))))));
    }), flatten5);
  }
}
var makeMemoMap = /* @__PURE__ */ suspend(() => map9(makeSynchronized(new Map), (ref) => new MemoMapImpl(ref)));
var unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(new Map));
var build = (self2) => scopeWith((scope2) => buildWithScope(self2, scope2));
var buildWithScope = /* @__PURE__ */ dual(2, (self2, scope2) => flatMap7(makeMemoMap, (memoMap) => buildWithMemoMap(self2, memoMap, scope2)));
var buildWithMemoMap = /* @__PURE__ */ dual(3, (self2, memoMap, scope2) => flatMap7(makeBuilder(self2, scope2), (run2) => provideService(run2(memoMap), CurrentMemoMap, memoMap)));
var makeBuilder = (self2, scope2, inMemoMap = false) => {
  const op = self2;
  switch (op._op_layer) {
    case "Locally": {
      return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope2)));
    }
    case "ExtendScope": {
      return sync(() => (memoMap) => scopeWith((scope3) => memoMap.getOrElseMemoize(op.layer, scope3)));
    }
    case "Fold": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope2), matchCauseEffect({
        onFailure: (cause2) => memoMap.getOrElseMemoize(op.failureK(cause2), scope2),
        onSuccess: (value) => memoMap.getOrElseMemoize(op.successK(value), scope2)
      })));
    }
    case "Fresh": {
      return sync(() => (_2) => pipe(op.layer, buildWithScope(scope2)));
    }
    case "FromEffect": {
      return inMemoMap ? sync(() => (_2) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope2));
    }
    case "Provide": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), flatMap7((env) => pipe(memoMap.getOrElseMemoize(op.second, scope2), provideContext(env)))));
    }
    case "Scoped": {
      return inMemoMap ? sync(() => (_2) => scopeExtend(op.effect, scope2)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope2));
    }
    case "Suspend": {
      return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope2));
    }
    case "ProvideMerge": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), zipWith2(memoMap.getOrElseMemoize(op.second, scope2), op.zipK)));
    }
    case "ZipWith": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), zipWithOptions(memoMap.getOrElseMemoize(op.second, scope2), op.zipK, {
        concurrent: true
      })));
    }
  }
};
var catchAll2 = /* @__PURE__ */ dual(2, (self2, onFailure) => match11(self2, {
  onFailure,
  onSuccess: succeedContext
}));
var catchAllCause2 = /* @__PURE__ */ dual(2, (self2, onFailure) => matchCause2(self2, {
  onFailure,
  onSuccess: succeedContext
}));
var die5 = (defect) => failCause5(die4(defect));
var dieSync2 = (evaluate2) => failCauseSync2(() => die4(evaluate2()));
var discard = (self2) => map11(self2, () => empty4());
var context2 = () => fromEffectContext(context());
var extendScope = (self2) => {
  const extendScope2 = Object.create(proto3);
  extendScope2._op_layer = OP_EXTEND_SCOPE;
  extendScope2.layer = self2;
  return extendScope2;
};
var fail6 = (error) => failCause5(fail4(error));
var failSync2 = (evaluate2) => failCauseSync2(() => fail4(evaluate2()));
var failCause5 = (cause2) => fromEffectContext(failCause(cause2));
var failCauseSync2 = (evaluate2) => fromEffectContext(failCauseSync(evaluate2));
var flatMap9 = /* @__PURE__ */ dual(2, (self2, f) => match11(self2, {
  onFailure: fail6,
  onSuccess: f
}));
var flatten7 = /* @__PURE__ */ dual(2, (self2, tag) => flatMap9(self2, get3(tag)));
var fresh = (self2) => {
  const fresh2 = Object.create(proto3);
  fresh2._op_layer = OP_FRESH;
  fresh2.layer = self2;
  return fresh2;
};
var fromEffect3 = /* @__PURE__ */ dual(2, (a, b3) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b3;
  const effect = tagFirst ? b3 : a;
  return fromEffectContext(map9(effect, (service) => make6(tag, service)));
});
var fromEffectDiscard = (effect) => fromEffectContext(map9(effect, () => empty4()));
function fromEffectContext(effect) {
  const fromEffect4 = Object.create(proto3);
  fromEffect4._op_layer = OP_FROM_EFFECT;
  fromEffect4.effect = effect;
  return fromEffect4;
}
var fiberRefLocally2 = /* @__PURE__ */ dual(3, (self2, ref, value) => locallyEffect(self2, fiberRefLocally(ref, value)));
var locallyEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  const locally = Object.create(proto3);
  locally._op_layer = "Locally";
  locally.self = self2;
  locally.f = f;
  return locally;
});
var fiberRefLocallyWith2 = /* @__PURE__ */ dual(3, (self2, ref, value) => locallyEffect(self2, fiberRefLocallyWith(ref, value)));
var fiberRefLocallyScoped2 = (self2, value) => scopedDiscard(fiberRefLocallyScoped(self2, value));
var fiberRefLocallyScopedWith2 = (self2, value) => scopedDiscard(fiberRefLocallyScopedWith(self2, value));
var fromFunction = (tagA, tagB, f) => fromEffectContext(map9(tagA, (a) => make6(tagB, f(a))));
var launch = (self2) => scopedEffect(zipRight(scopeWith((scope2) => pipe(self2, buildWithScope(scope2))), never));
var map11 = /* @__PURE__ */ dual(2, (self2, f) => flatMap9(self2, (context3) => succeedContext(f(context3))));
var mapError2 = /* @__PURE__ */ dual(2, (self2, f) => catchAll2(self2, (error) => failSync2(() => f(error))));
var matchCause2 = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  const fold = Object.create(proto3);
  fold._op_layer = OP_FOLD;
  fold.layer = self2;
  fold.failureK = onFailure;
  fold.successK = onSuccess;
  return fold;
});
var match11 = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => matchCause2(self2, {
  onFailure: (cause2) => {
    const failureOrCause3 = failureOrCause2(cause2);
    switch (failureOrCause3._tag) {
      case "Left": {
        return onFailure(failureOrCause3.left);
      }
      case "Right": {
        return failCause5(failureOrCause3.right);
      }
    }
  },
  onSuccess
}));
var memoize2 = (self2) => scopeWith((scope2) => map9(memoize(buildWithScope(self2, scope2)), fromEffectContext));
var merge6 = /* @__PURE__ */ dual(2, (self2, that) => zipWith5(self2, that, (a, b3) => merge3(a, b3)));
var mergeAll4 = (...layers) => {
  let final = layers[0];
  for (let i2 = 1;i2 < layers.length; i2++) {
    final = merge6(final, layers[i2]);
  }
  return final;
};
var orDie2 = (self2) => catchAll2(self2, (defect) => die5(defect));
var orElse4 = /* @__PURE__ */ dual(2, (self2, that) => catchAll2(self2, that));
var passthrough = (self2) => merge6(context2(), self2);
var project = /* @__PURE__ */ dual(4, (self2, tagA, tagB, f) => map11(self2, (context3) => make6(tagB, f(unsafeGet3(context3, tagA)))));
var retry = /* @__PURE__ */ dual(2, (self2, schedule) => suspend2(() => {
  const stateTag = GenericTag("effect/Layer/retry/{ state: unknown }");
  return pipe(succeed5(stateTag, {
    state: schedule.initial
  }), flatMap9((env) => retryLoop(self2, schedule, stateTag, pipe(env, get3(stateTag)).state)));
}));
var retryLoop = (self2, schedule, stateTag, state) => {
  return pipe(self2, catchAll2((error) => pipe(retryUpdate(schedule, stateTag, error, state), flatMap9((env) => fresh(retryLoop(self2, schedule, stateTag, pipe(env, get3(stateTag)).state))))));
};
var retryUpdate = (schedule, stateTag, error, state) => {
  return fromEffect3(stateTag, pipe(currentTimeMillis2, flatMap7((now) => pipe(schedule.step(now, error, state), flatMap7(([state2, _2, decision]) => isDone4(decision) ? fail2(error) : pipe(sleep2(millis(start3(decision.intervals) - now)), as({
    state: state2
  })))))));
};
var scoped = /* @__PURE__ */ dual(2, (a, b3) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b3;
  const effect = tagFirst ? b3 : a;
  return scopedContext(map9(effect, (service) => make6(tag, service)));
});
var scopedDiscard = (effect) => scopedContext(pipe(effect, as(empty4())));
var scopedContext = (effect) => {
  const scoped2 = Object.create(proto3);
  scoped2._op_layer = OP_SCOPED;
  scoped2.effect = effect;
  return scoped2;
};
var scope2 = /* @__PURE__ */ scopedContext(/* @__PURE__ */ map9(/* @__PURE__ */ acquireRelease(/* @__PURE__ */ scopeMake(), (scope3, exit2) => scope3.close(exit2)), (scope3) => make6(Scope, scope3)));
var service = (tag) => fromEffect3(tag, tag);
var succeed5 = /* @__PURE__ */ dual(2, (a, b3) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b3;
  const resource = tagFirst ? b3 : a;
  return fromEffectContext(succeed(make6(tag, resource)));
});
var succeedContext = (context3) => {
  return fromEffectContext(succeed(context3));
};
var empty34 = /* @__PURE__ */ succeedContext(/* @__PURE__ */ empty4());
var suspend2 = (evaluate2) => {
  const suspend3 = Object.create(proto3);
  suspend3._op_layer = OP_SUSPEND;
  suspend3.evaluate = evaluate2;
  return suspend3;
};
var sync2 = /* @__PURE__ */ dual(2, (a, b3) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b3;
  const evaluate2 = tagFirst ? b3 : a;
  return fromEffectContext(sync(() => make6(tag, evaluate2())));
});
var syncContext = (evaluate2) => {
  return fromEffectContext(sync(evaluate2));
};
var tap2 = /* @__PURE__ */ dual(2, (self2, f) => flatMap9(self2, (context3) => fromEffectContext(as(f(context3), context3))));
var tapError2 = /* @__PURE__ */ dual(2, (self2, f) => catchAll2(self2, (e) => fromEffectContext(flatMap7(f(e), () => fail2(e)))));
var tapErrorCause2 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause2(self2, (cause2) => fromEffectContext(flatMap7(f(cause2), () => failCause(cause2)))));
var toRuntime = (self2) => pipe(scopeWith((scope3) => buildWithScope(self2, scope3)), flatMap7((context3) => pipe(runtime3(), provideContext(context3))));
var toRuntimeWithMemoMap = /* @__PURE__ */ dual(2, (self2, memoMap) => flatMap7(scopeWith((scope3) => buildWithMemoMap(self2, memoMap, scope3)), (context3) => pipe(runtime3(), provideContext(context3))));
var provide = /* @__PURE__ */ dual(2, (self2, that) => suspend2(() => {
  const provideTo = Object.create(proto3);
  provideTo._op_layer = OP_PROVIDE;
  provideTo.first = Object.create(proto3, {
    _op_layer: {
      value: OP_PROVIDE_MERGE,
      enumerable: true
    },
    first: {
      value: context2(),
      enumerable: true
    },
    second: {
      value: Array.isArray(that) ? mergeAll4(...that) : that
    },
    zipK: {
      value: (a, b3) => pipe(a, merge3(b3))
    }
  });
  provideTo.second = self2;
  return provideTo;
}));
var provideMerge = /* @__PURE__ */ dual(2, (that, self2) => {
  const zipWith5 = Object.create(proto3);
  zipWith5._op_layer = OP_PROVIDE_MERGE;
  zipWith5.first = self2;
  zipWith5.second = provide(that, self2);
  zipWith5.zipK = (a, b3) => {
    return pipe(a, merge3(b3));
  };
  return zipWith5;
});
var zipWith5 = /* @__PURE__ */ dual(3, (self2, that, f) => suspend2(() => {
  const zipWith6 = Object.create(proto3);
  zipWith6._op_layer = OP_ZIP_WITH2;
  zipWith6.first = self2;
  zipWith6.second = that;
  zipWith6.zipK = f;
  return zipWith6;
}));
var unwrapEffect = (self2) => {
  const tag = GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
  return flatMap9(fromEffect3(tag, self2), (context3) => get3(context3, tag));
};
var unwrapScoped = (self2) => {
  const tag = GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
  return flatMap9(scoped(tag, self2), (context3) => get3(context3, tag));
};
var annotateLogs2 = /* @__PURE__ */ dual((args3) => isLayer(args3[0]), function() {
  const args3 = arguments;
  return fiberRefLocallyWith2(args3[0], currentLogAnnotations, typeof args3[1] === "string" ? set3(args3[1], args3[2]) : (annotations2) => Object.entries(args3[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
});
var annotateSpans2 = /* @__PURE__ */ dual((args3) => isLayer(args3[0]), function() {
  const args3 = arguments;
  return fiberRefLocallyWith2(args3[0], currentTracerSpanAnnotations, typeof args3[1] === "string" ? set3(args3[1], args3[2]) : (annotations2) => Object.entries(args3[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
});
var withSpan2 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name2 = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return unwrapScoped(map9(options?.onEnd ? tap(makeSpanScoped(name2, options), (span2) => addFinalizer((exit2) => options.onEnd(span2, exit2))) : makeSpanScoped(name2, options), (span2) => withParentSpan2(self2, span2)));
  }
  return (self2) => unwrapScoped(map9(options?.onEnd ? tap(makeSpanScoped(name2, options), (span2) => addFinalizer((exit2) => options.onEnd(span2, exit2))) : makeSpanScoped(name2, options), (span2) => withParentSpan2(self2, span2)));
};
var withParentSpan2 = /* @__PURE__ */ dual(2, (self2, span2) => provide(self2, succeedContext(make6(spanTag, span2))));
var provideSomeLayer = /* @__PURE__ */ dual(2, (self2, layer) => scopedWith((scope3) => flatMap7(buildWithScope(layer, scope3), (context3) => provideSomeContext(self2, context3))));
var provideSomeRuntime = /* @__PURE__ */ dual(2, (self2, rt2) => {
  const patchRefs = diff9(defaultRuntime.fiberRefs, rt2.fiberRefs);
  const patchFlags = diff7(defaultRuntime.runtimeFlags, rt2.runtimeFlags);
  return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
    const oldContext = fiber.getFiberRef(currentContext);
    const oldRefs = fiber.getFiberRefs();
    const newRefs = patch10(fiber.id(), oldRefs)(patchRefs);
    const oldFlags = fiber.currentRuntimeFlags;
    const newFlags = patch7(patchFlags)(oldFlags);
    const rollbackRefs = diff9(newRefs, oldRefs);
    const rollbackFlags = diff7(newFlags, oldFlags);
    fiber.setFiberRefs(newRefs);
    fiber.currentRuntimeFlags = newFlags;
    return ensuring(provideSomeContext(restore(self2), merge3(oldContext, rt2.context)), withFiberRuntime((fiber2) => {
      fiber2.setFiberRefs(patch10(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
      fiber2.currentRuntimeFlags = patch7(rollbackFlags)(fiber2.currentRuntimeFlags);
      return void_;
    }));
  }));
});
var effect_provide = /* @__PURE__ */ dual(2, (self2, source) => {
  if (Array.isArray(source)) {
    return provideSomeLayer(self2, mergeAll4(...source));
  } else if (isLayer(source)) {
    return provideSomeLayer(self2, source);
  } else if (isContext2(source)) {
    return provideSomeContext(self2, source);
  } else if (TypeId16 in source) {
    return flatMap7(source.runtimeEffect, (rt2) => provideSomeRuntime(self2, rt2));
  } else {
    return provideSomeRuntime(self2, source);
  }
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/console.js
var console2 = /* @__PURE__ */ map9(/* @__PURE__ */ fiberRefGet(currentServices), /* @__PURE__ */ get3(consoleTag));
var consoleWith = (f) => fiberRefGetWith(currentServices, (services) => f(get3(services, consoleTag)));
var withConsole = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(effect, currentServices, add2(consoleTag, value)));
var withConsoleScoped = (console3) => fiberRefLocallyScopedWith(currentServices, add2(consoleTag, console3));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Data.js
var struct2 = struct;
var array5 = (as3) => unsafeArray(as3.slice(0));
var unsafeArray = (as3) => Object.setPrototypeOf(as3, ArrayProto);
var Class3 = Structural;
var Error3 = /* @__PURE__ */ function() {
  const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
  const O2 = {
    BaseEffectError: class extends YieldableError {
      constructor(args3) {
        super(args3?.message, args3?.cause ? {
          cause: args3.cause
        } : undefined);
        if (args3) {
          Object.assign(this, args3);
          Object.defineProperty(this, plainArgsSymbol, {
            value: args3,
            enumerable: false
          });
        }
      }
      toJSON() {
        return {
          ...this[plainArgsSymbol],
          ...this
        };
      }
    }
  };
  return O2.BaseEffectError;
}();
var TaggedError = (tag) => {
  const O2 = {
    BaseEffectError: class extends Error3 {
      _tag = tag;
    }
  };
  O2.BaseEffectError.prototype.name = tag;
  return O2.BaseEffectError;
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/dateTime.js
var TypeId17 = /* @__PURE__ */ Symbol.for("effect/DateTime");
var TimeZoneTypeId = /* @__PURE__ */ Symbol.for("effect/DateTime/TimeZone");
var Proto2 = {
  [TypeId17]: TypeId17,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [NodeInspectSymbol]() {
    return this.toString();
  },
  toJSON() {
    return toDateUtc(this).toJSON();
  }
};
var ProtoUtc = {
  ...Proto2,
  _tag: "Utc",
  [symbol]() {
    return cached(this, number2(this.epochMillis));
  },
  [symbol2](that) {
    return isDateTime(that) && that._tag === "Utc" && this.epochMillis === that.epochMillis;
  },
  toString() {
    return `DateTime.Utc(${toDateUtc(this).toJSON()})`;
  }
};
var ProtoZoned = {
  ...Proto2,
  _tag: "Zoned",
  [symbol]() {
    return pipe(number2(this.epochMillis), combine(hash(this.zone)), cached(this));
  },
  [symbol2](that) {
    return isDateTime(that) && that._tag === "Zoned" && this.epochMillis === that.epochMillis && equals(this.zone, that.zone);
  },
  toString() {
    return `DateTime.Zoned(${formatIsoZoned(this)})`;
  }
};
var ProtoTimeZone = {
  [TimeZoneTypeId]: TimeZoneTypeId,
  [NodeInspectSymbol]() {
    return this.toString();
  }
};
var ProtoTimeZoneNamed = {
  ...ProtoTimeZone,
  _tag: "Named",
  [symbol]() {
    return cached(this, string(`Named:${this.id}`));
  },
  [symbol2](that) {
    return isTimeZone(that) && that._tag === "Named" && this.id === that.id;
  },
  toString() {
    return `TimeZone.Named(${this.id})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Named",
      id: this.id
    };
  }
};
var ProtoTimeZoneOffset = {
  ...ProtoTimeZone,
  _tag: "Offset",
  [symbol]() {
    return cached(this, string(`Offset:${this.offset}`));
  },
  [symbol2](that) {
    return isTimeZone(that) && that._tag === "Offset" && this.offset === that.offset;
  },
  toString() {
    return `TimeZone.Offset(${offsetToString(this.offset)})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Offset",
      offset: this.offset
    };
  }
};
var makeZonedProto = (epochMillis, zone, partsUtc) => {
  const self2 = Object.create(ProtoZoned);
  self2.epochMillis = epochMillis;
  self2.zone = zone;
  Object.defineProperty(self2, "partsUtc", {
    value: partsUtc,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(self2, "adjustedEpochMillis", {
    value: undefined,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(self2, "partsAdjusted", {
    value: undefined,
    enumerable: false,
    writable: true
  });
  return self2;
};
var isDateTime = (u3) => hasProperty(u3, TypeId17);
var isTimeZone = (u3) => hasProperty(u3, TimeZoneTypeId);
var isTimeZoneOffset = (u3) => isTimeZone(u3) && u3._tag === "Offset";
var isTimeZoneNamed = (u3) => isTimeZone(u3) && u3._tag === "Named";
var isUtc = (self2) => self2._tag === "Utc";
var isZoned = (self2) => self2._tag === "Zoned";
var Equivalence3 = /* @__PURE__ */ make((a, b3) => a.epochMillis === b3.epochMillis);
var makeUtc = (epochMillis) => {
  const self2 = Object.create(ProtoUtc);
  self2.epochMillis = epochMillis;
  Object.defineProperty(self2, "partsUtc", {
    value: undefined,
    enumerable: false,
    writable: true
  });
  return self2;
};
var unsafeFromDate = (date2) => {
  const epochMillis = date2.getTime();
  if (Number.isNaN(epochMillis)) {
    throw new IllegalArgumentException2("Invalid date");
  }
  return makeUtc(epochMillis);
};
var unsafeMake9 = (input) => {
  if (isDateTime(input)) {
    return input;
  } else if (input instanceof Date) {
    return unsafeFromDate(input);
  } else if (typeof input === "object") {
    const date2 = new Date(0);
    setPartsDate(date2, input);
    return unsafeFromDate(date2);
  } else if (typeof input === "string" && !hasZone(input)) {
    return unsafeFromDate(new Date(input + "Z"));
  }
  return unsafeFromDate(new Date(input));
};
var hasZone = (input) => /Z|[+-]\d{2}$|[+-]\d{2}:\d{2}$|\]$/.test(input);
var minEpochMillis = -8640000000000000 + 12 * 60 * 60 * 1000;
var maxEpochMillis = 8640000000000000 - 14 * 60 * 60 * 1000;
var unsafeMakeZoned = (input, options) => {
  if (options?.timeZone === undefined && isDateTime(input) && isZoned(input)) {
    return input;
  }
  const self2 = unsafeMake9(input);
  if (self2.epochMillis < minEpochMillis || self2.epochMillis > maxEpochMillis) {
    throw new IllegalArgumentException2(`Epoch millis out of range: ${self2.epochMillis}`);
  }
  let zone;
  if (options?.timeZone === undefined) {
    const offset = new Date(self2.epochMillis).getTimezoneOffset() * -60 * 1000;
    zone = zoneMakeOffset(offset);
  } else if (isTimeZone(options?.timeZone)) {
    zone = options.timeZone;
  } else if (typeof options?.timeZone === "number") {
    zone = zoneMakeOffset(options.timeZone);
  } else {
    const parsedZone = zoneFromString(options.timeZone);
    if (isNone2(parsedZone)) {
      throw new IllegalArgumentException2(`Invalid time zone: ${options.timeZone}`);
    }
    zone = parsedZone.value;
  }
  if (options?.adjustForTimeZone !== true) {
    return makeZonedProto(self2.epochMillis, zone, self2.partsUtc);
  }
  return makeZonedFromAdjusted(self2.epochMillis, zone);
};
var makeZoned = /* @__PURE__ */ liftThrowable(unsafeMakeZoned);
var zonedStringRegex = /^(.{17,35})\[(.+)\]$/;
var makeZonedFromString = (input) => {
  const match12 = zonedStringRegex.exec(input);
  if (match12 === null) {
    const offset = parseOffset(input);
    return offset !== null ? makeZoned(input, {
      timeZone: offset
    }) : none2();
  }
  const [, isoString, timeZone] = match12;
  return makeZoned(isoString, {
    timeZone
  });
};
var validZoneCache = /* @__PURE__ */ globalValue("effect/DateTime/validZoneCache", () => new Map);
var formatOptions = {
  day: "numeric",
  month: "numeric",
  year: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric",
  timeZoneName: "longOffset",
  fractionalSecondDigits: 3,
  hourCycle: "h23"
};
var zoneMakeIntl = (format5) => {
  const zoneId = format5.resolvedOptions().timeZone;
  if (validZoneCache.has(zoneId)) {
    return validZoneCache.get(zoneId);
  }
  const zone = Object.create(ProtoTimeZoneNamed);
  zone.id = zoneId;
  zone.format = format5;
  validZoneCache.set(zoneId, zone);
  return zone;
};
var zoneUnsafeMakeNamed = (zoneId) => {
  if (validZoneCache.has(zoneId)) {
    return validZoneCache.get(zoneId);
  }
  try {
    return zoneMakeIntl(new Intl.DateTimeFormat("en-US", {
      ...formatOptions,
      timeZone: zoneId
    }));
  } catch {
    throw new IllegalArgumentException2(`Invalid time zone: ${zoneId}`);
  }
};
var zoneMakeOffset = (offset) => {
  const zone = Object.create(ProtoTimeZoneOffset);
  zone.offset = offset;
  return zone;
};
var zoneMakeNamed = /* @__PURE__ */ liftThrowable(zoneUnsafeMakeNamed);
var offsetZoneRegex = /^(?:GMT|[+-])/;
var zoneFromString = (zone) => {
  if (offsetZoneRegex.test(zone)) {
    const offset = parseOffset(zone);
    return offset === null ? none2() : some2(zoneMakeOffset(offset));
  }
  return zoneMakeNamed(zone);
};
var zoneToString = (self2) => {
  if (self2._tag === "Offset") {
    return offsetToString(self2.offset);
  }
  return self2.id;
};
var toDateUtc = (self2) => new Date(self2.epochMillis);
var toDate = (self2) => {
  if (self2._tag === "Utc") {
    return new Date(self2.epochMillis);
  } else if (self2.zone._tag === "Offset") {
    return new Date(self2.epochMillis + self2.zone.offset);
  } else if (self2.adjustedEpochMillis !== undefined) {
    return new Date(self2.adjustedEpochMillis);
  }
  const parts3 = self2.zone.format.formatToParts(self2.epochMillis).filter((_2) => _2.type !== "literal");
  const date2 = new Date(0);
  date2.setUTCFullYear(Number(parts3[2].value), Number(parts3[0].value) - 1, Number(parts3[1].value));
  date2.setUTCHours(Number(parts3[3].value), Number(parts3[4].value), Number(parts3[5].value), Number(parts3[6].value));
  self2.adjustedEpochMillis = date2.getTime();
  return date2;
};
var zonedOffset = (self2) => {
  const date2 = toDate(self2);
  return date2.getTime() - toEpochMillis(self2);
};
var offsetToString = (offset) => {
  const abs2 = Math.abs(offset);
  let hours2 = Math.floor(abs2 / (60 * 60 * 1000));
  let minutes2 = Math.round(abs2 % (60 * 60 * 1000) / (60 * 1000));
  if (minutes2 === 60) {
    hours2 += 1;
    minutes2 = 0;
  }
  return `${offset < 0 ? "-" : "+"}${String(hours2).padStart(2, "0")}:${String(minutes2).padStart(2, "0")}`;
};
var zonedOffsetIso = (self2) => offsetToString(zonedOffset(self2));
var toEpochMillis = (self2) => self2.epochMillis;
var setPartsDate = (date2, parts3) => {
  if (parts3.year !== undefined) {
    date2.setUTCFullYear(parts3.year);
  }
  if (parts3.month !== undefined) {
    date2.setUTCMonth(parts3.month - 1);
  }
  if (parts3.day !== undefined) {
    date2.setUTCDate(parts3.day);
  }
  if (parts3.weekDay !== undefined) {
    const diff11 = parts3.weekDay - date2.getUTCDay();
    date2.setUTCDate(date2.getUTCDate() + diff11);
  }
  if (parts3.hours !== undefined) {
    date2.setUTCHours(parts3.hours);
  }
  if (parts3.minutes !== undefined) {
    date2.setUTCMinutes(parts3.minutes);
  }
  if (parts3.seconds !== undefined) {
    date2.setUTCSeconds(parts3.seconds);
  }
  if (parts3.millis !== undefined) {
    date2.setUTCMilliseconds(parts3.millis);
  }
};
var makeZonedFromAdjusted = (adjustedMillis, zone) => {
  const offset = zone._tag === "Offset" ? zone.offset : calculateNamedOffset(adjustedMillis, zone);
  return makeZonedProto(adjustedMillis - offset, zone);
};
var offsetRegex = /([+-])(\d{2}):(\d{2})$/;
var parseOffset = (offset) => {
  const match12 = offsetRegex.exec(offset);
  if (match12 === null) {
    return null;
  }
  const [, sign2, hours2, minutes2] = match12;
  return (sign2 === "+" ? 1 : -1) * (Number(hours2) * 60 + Number(minutes2)) * 60 * 1000;
};
var calculateNamedOffset = (adjustedMillis, zone) => {
  const offset = zone.format.formatToParts(adjustedMillis).find((_2) => _2.type === "timeZoneName")?.value ?? "";
  if (offset === "GMT") {
    return 0;
  }
  const result = parseOffset(offset);
  if (result === null) {
    return zonedOffset(makeZonedProto(adjustedMillis, zone));
  }
  return result;
};
var formatIso = (self2) => toDateUtc(self2).toISOString();
var formatIsoOffset = (self2) => {
  const date2 = toDate(self2);
  return self2._tag === "Utc" ? date2.toISOString() : `${date2.toISOString().slice(0, -1)}${zonedOffsetIso(self2)}`;
};
var formatIsoZoned = (self2) => self2.zone._tag === "Offset" ? formatIsoOffset(self2) : `${formatIsoOffset(self2)}[${self2.zone.id}]`;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/String.js
var toUpperCase = (self2) => self2.toUpperCase();
var toLowerCase = (self2) => self2.toLowerCase();
var capitalize = (self2) => {
  if (self2.length === 0)
    return self2;
  return toUpperCase(self2[0]) + self2.slice(1);
};
var uncapitalize = (self2) => {
  if (self2.length === 0)
    return self2;
  return toLowerCase(self2[0]) + self2.slice(1);
};
var isNonEmpty6 = (self2) => self2.length > 0;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Cron.js
var TypeId18 = /* @__PURE__ */ Symbol.for("effect/Cron");
var CronProto = {
  [TypeId18]: TypeId18,
  [symbol2](that) {
    return isCron(that) && equals5(this, that);
  },
  [symbol]() {
    return pipe(hash(this.tz), combine(array2(fromIterable(this.seconds))), combine(array2(fromIterable(this.minutes))), combine(array2(fromIterable(this.hours))), combine(array2(fromIterable(this.days))), combine(array2(fromIterable(this.months))), combine(array2(fromIterable(this.weekdays))), cached(this));
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Cron",
      tz: this.tz,
      seconds: fromIterable(this.seconds),
      minutes: fromIterable(this.minutes),
      hours: fromIterable(this.hours),
      days: fromIterable(this.days),
      months: fromIterable(this.months),
      weekdays: fromIterable(this.weekdays)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isCron = (u3) => hasProperty(u3, TypeId18);
var Equivalence4 = /* @__PURE__ */ make((self2, that) => restrictionsEquals(self2.seconds, that.seconds) && restrictionsEquals(self2.minutes, that.minutes) && restrictionsEquals(self2.hours, that.hours) && restrictionsEquals(self2.days, that.days) && restrictionsEquals(self2.months, that.months) && restrictionsEquals(self2.weekdays, that.weekdays));
var restrictionsArrayEquals = /* @__PURE__ */ array(number);
var restrictionsEquals = (self2, that) => restrictionsArrayEquals(fromIterable(self2), fromIterable(that));
var equals5 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence4(self2, that));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey = "effect/Schedule";
var ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
var isSchedule = (u3) => hasProperty(u3, ScheduleTypeId);
var ScheduleDriverSymbolKey = "effect/ScheduleDriver";
var ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
var defaultIterationMetadata = {
  start: 0,
  now: 0,
  input: undefined,
  elapsed: zero2,
  elapsedSincePrevious: zero2,
  recurrence: 0
};
var CurrentIterationMetadata = /* @__PURE__ */ Reference2()("effect/Schedule/CurrentIterationMetadata", {
  defaultValue: () => defaultIterationMetadata
});
var scheduleVariance = {
  _Out: (_2) => _2,
  _In: (_2) => _2,
  _R: (_2) => _2
};
var scheduleDriverVariance = {
  _Out: (_2) => _2,
  _In: (_2) => _2,
  _R: (_2) => _2
};

class ScheduleImpl {
  initial;
  step;
  [ScheduleTypeId] = scheduleVariance;
  constructor(initial, step3) {
    this.initial = initial;
    this.step = step3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var updateInfo = (iterationMetaRef, now, input) => update2(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
  now,
  input,
  recurrence: prev.recurrence + 1,
  elapsed: zero2,
  elapsedSincePrevious: zero2,
  start: now
} : {
  now,
  input,
  recurrence: prev.recurrence + 1,
  elapsed: millis(now - prev.start),
  elapsedSincePrevious: millis(now - prev.now),
  start: prev.start
});

class ScheduleDriverImpl {
  schedule;
  ref;
  [ScheduleDriverTypeId] = scheduleDriverVariance;
  constructor(schedule, ref) {
    this.schedule = schedule;
    this.ref = ref;
  }
  get state() {
    return map9(get11(this.ref), (tuple3) => tuple3[1]);
  }
  get last() {
    return flatMap7(get11(this.ref), ([element, _2]) => {
      switch (element._tag) {
        case "None": {
          return failSync(() => new NoSuchElementException);
        }
        case "Some": {
          return succeed(element.value);
        }
      }
    });
  }
  iterationMeta = /* @__PURE__ */ unsafeMake6(defaultIterationMetadata);
  get reset() {
    return set5(this.ref, [none2(), this.schedule.initial]).pipe(zipLeft(set5(this.iterationMeta, defaultIterationMetadata)));
  }
  next(input) {
    return pipe(map9(get11(this.ref), (tuple3) => tuple3[1]), flatMap7((state) => pipe(currentTimeMillis2, flatMap7((now) => pipe(suspend(() => this.schedule.step(now, input, state)), flatMap7(([state2, out2, decision]) => {
      const setState = set5(this.ref, [some2(out2), state2]);
      if (isDone4(decision)) {
        return setState.pipe(zipRight(fail2(none2())));
      }
      const millis2 = start3(decision.intervals) - now;
      if (millis2 <= 0) {
        return setState.pipe(zipRight(updateInfo(this.iterationMeta, now, input)), as(out2));
      }
      const duration = millis(millis2);
      return pipe(setState, zipRight(updateInfo(this.iterationMeta, now, input)), zipRight(sleep3(duration)), as(out2));
    }))))));
  }
}
var makeWithState = (initial, step3) => new ScheduleImpl(initial, step3);
var asVoid2 = (self2) => map12(self2, constVoid);
var check = /* @__PURE__ */ dual(2, (self2, test) => checkEffect(self2, (input, out2) => sync(() => test(input, out2))));
var checkEffect = /* @__PURE__ */ dual(2, (self2, test) => makeWithState(self2.initial, (now, input, state) => flatMap7(self2.step(now, input, state), ([state2, out2, decision]) => {
  if (isDone4(decision)) {
    return succeed([state2, out2, done6]);
  }
  return map9(test(input, out2), (cont) => cont ? [state2, out2, decision] : [state2, out2, done6]);
})));
var driver = (self2) => pipe(make27([none2(), self2.initial]), map9((ref) => new ScheduleDriverImpl(self2, ref)));
var intersect6 = /* @__PURE__ */ dual(2, (self2, that) => intersectWith(self2, that, intersect5));
var intersectWith = /* @__PURE__ */ dual(3, (self2, that, f) => makeWithState([self2.initial, that.initial], (now, input, state) => pipe(zipWith2(self2.step(now, input, state[0]), that.step(now, input, state[1]), (a, b3) => [a, b3]), flatMap7(([[lState, out2, lDecision], [rState, out22, rDecision]]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    return intersectWithLoop(self2, that, input, lState, out2, lDecision.intervals, rState, out22, rDecision.intervals, f);
  }
  return succeed([[lState, rState], [out2, out22], done6]);
}))));
var intersectWithLoop = (self2, that, input, lState, out2, lInterval, rState, out22, rInterval, f) => {
  const combined = f(lInterval, rInterval);
  if (isNonEmpty5(combined)) {
    return succeed([[lState, rState], [out2, out22], _continue2(combined)]);
  }
  if (pipe(lInterval, lessThan7(rInterval))) {
    return flatMap7(self2.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
      if (isDone4(decision)) {
        return succeed([[lState2, rState], [out3, out22], done6]);
      }
      return intersectWithLoop(self2, that, input, lState2, out3, decision.intervals, rState, out22, rInterval, f);
    });
  }
  return flatMap7(that.step(end2(rInterval), input, rState), ([rState2, out23, decision]) => {
    if (isDone4(decision)) {
      return succeed([[lState, rState2], [out2, out23], done6]);
    }
    return intersectWithLoop(self2, that, input, lState, out2, lInterval, rState2, out23, decision.intervals, f);
  });
};
var map12 = /* @__PURE__ */ dual(2, (self2, f) => mapEffect2(self2, (out2) => sync(() => f(out2))));
var mapEffect2 = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now, input, state) => flatMap7(self2.step(now, input, state), ([state2, out2, decision]) => map9(f(out2), (out22) => [state2, out22, decision]))));
var passthrough2 = (self2) => makeWithState(self2.initial, (now, input, state) => pipe(self2.step(now, input, state), map9(([state2, _2, decision]) => [state2, input, decision])));
var recurs = (n) => whileOutput(forever2, (out2) => out2 < n);
var unfold2 = (initial, f) => makeWithState(initial, (now, _2, state) => sync(() => [f(state), state, continueWith2(after2(now))]));
var untilInputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (input, _2) => negate(f(input))));
var whileInputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (input, _2) => f(input)));
var whileOutput = /* @__PURE__ */ dual(2, (self2, f) => check(self2, (_2, out2) => f(out2)));
var ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");

class ScheduleDefect {
  error;
  [ScheduleDefectTypeId];
  constructor(error) {
    this.error = error;
    this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
  }
}
var isScheduleDefect = (u3) => hasProperty(u3, ScheduleDefectTypeId);
var scheduleDefectWrap = (self2) => catchAll(self2, (e) => die2(new ScheduleDefect(e)));
var scheduleDefectRefailCause = (cause2) => match2(find(cause2, (_2) => isDieType(_2) && isScheduleDefect(_2.defect) ? some2(_2.defect) : none2()), {
  onNone: () => cause2,
  onSome: (error) => fail(error.error)
});
var scheduleDefectRefail = (effect) => catchAllCause(effect, (cause2) => failCause(scheduleDefectRefailCause(cause2)));
var repeat_Effect = /* @__PURE__ */ dual(2, (self2, schedule) => repeatOrElse_Effect(self2, schedule, (e, _2) => fail2(e)));
var repeat_combined = /* @__PURE__ */ dual(2, (self2, options) => {
  if (isSchedule(options)) {
    return repeat_Effect(self2, options);
  }
  const base = options.schedule ?? passthrough2(forever2);
  const withWhile = options.while ? whileInputEffect(base, (a) => {
    const applied = options.while(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (a) => {
    const applied = options.until(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options.times ? intersect6(withUntil, recurs(options.times)).pipe(map12((intersectionPair) => intersectionPair[0])) : withUntil;
  return scheduleDefectRefail(repeat_Effect(self2, withTimes));
});
var repeatOrElse_Effect = /* @__PURE__ */ dual(3, (self2, schedule, orElse5) => flatMap7(driver(schedule), (driver2) => matchEffect(self2, {
  onFailure: (error) => orElse5(error, none2()),
  onSuccess: (value) => repeatOrElseEffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver2.iterationMeta)), driver2, (error, option2) => provideServiceEffect(orElse5(error, option2), CurrentIterationMetadata, get11(driver2.iterationMeta)), value)
})));
var repeatOrElseEffectLoop = (self2, driver2, orElse5, value) => matchEffect(driver2.next(value), {
  onFailure: () => orDie(driver2.last),
  onSuccess: (b3) => matchEffect(self2, {
    onFailure: (error) => orElse5(error, some2(b3)),
    onSuccess: (value2) => repeatOrElseEffectLoop(self2, driver2, orElse5, value2)
  })
});
var retry_Effect = /* @__PURE__ */ dual(2, (self2, policy) => retryOrElse_Effect(self2, policy, (e, _2) => fail2(e)));
var retry_combined = /* @__PURE__ */ dual(2, (self2, options) => {
  if (isSchedule(options)) {
    return retry_Effect(self2, options);
  }
  return scheduleDefectRefail(retry_Effect(self2, fromRetryOptions(options)));
});
var fromRetryOptions = (options) => {
  const base = options.schedule ?? forever2;
  const withWhile = options.while ? whileInputEffect(base, (e) => {
    const applied = options.while(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (e) => {
    const applied = options.until(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  return options.times ? intersect6(withUntil, recurs(options.times)) : withUntil;
};
var retryOrElse_Effect = /* @__PURE__ */ dual(3, (self2, policy, orElse5) => flatMap7(driver(policy), (driver2) => retryOrElse_EffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver2.iterationMeta)), driver2, (e, out2) => provideServiceEffect(orElse5(e, out2), CurrentIterationMetadata, get11(driver2.iterationMeta)))));
var retryOrElse_EffectLoop = (self2, driver2, orElse5) => {
  return catchAll(self2, (e) => matchEffect(driver2.next(e), {
    onFailure: () => pipe(driver2.last, orDie, flatMap7((out2) => orElse5(e, out2))),
    onSuccess: () => retryOrElse_EffectLoop(self2, driver2, orElse5)
  }));
};
var schedule_Effect = /* @__PURE__ */ dual(2, (self2, schedule) => scheduleFrom_Effect(self2, undefined, schedule));
var scheduleFrom_Effect = /* @__PURE__ */ dual(3, (self2, initial, schedule) => flatMap7(driver(schedule), (driver2) => scheduleFrom_EffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver2.iterationMeta)), initial, driver2)));
var scheduleFrom_EffectLoop = (self2, initial, driver2) => matchEffect(driver2.next(initial), {
  onFailure: () => orDie(driver2.last),
  onSuccess: () => flatMap7(self2, (a) => scheduleFrom_EffectLoop(self2, a, driver2))
});
var forever2 = /* @__PURE__ */ unfold2(0, (n) => n + 1);
var once2 = /* @__PURE__ */ asVoid2(/* @__PURE__ */ recurs(1));
var scheduleForked = /* @__PURE__ */ dual(2, (self2, schedule) => forkScoped(schedule_Effect(self2, schedule)));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/executionPlan.js
var TypeId19 = /* @__PURE__ */ Symbol.for("effect/ExecutionPlan");
var withExecutionPlan = /* @__PURE__ */ dual(2, (effect, plan) => suspend(() => {
  let i2 = 0;
  let result;
  return flatMap7(whileLoop({
    while: () => i2 < plan.steps.length && (result === undefined || isLeft2(result)),
    body: () => {
      const step3 = plan.steps[i2];
      let nextEffect = effect_provide(effect, step3.provide);
      if (result) {
        let attempted = false;
        const wrapped = nextEffect;
        nextEffect = suspend(() => {
          if (attempted)
            return wrapped;
          attempted = true;
          return result;
        });
        nextEffect = scheduleDefectRefail(retry_Effect(nextEffect, scheduleFromStep(step3, false)));
      } else {
        const schedule = scheduleFromStep(step3, true);
        nextEffect = schedule ? scheduleDefectRefail(retry_Effect(nextEffect, schedule)) : nextEffect;
      }
      return either2(nextEffect);
    },
    step: (either3) => {
      result = either3;
      i2++;
    }
  }), () => result);
}));
var scheduleFromStep = (step3, first2) => {
  if (!first2) {
    return fromRetryOptions({
      schedule: step3.schedule ? step3.schedule : step3.attempts ? undefined : once2,
      times: step3.attempts,
      while: step3.while
    });
  } else if (step3.attempts === 1 || !(step3.schedule || step3.attempts)) {
    return;
  }
  return fromRetryOptions({
    schedule: step3.schedule,
    while: step3.while,
    times: step3.attempts ? step3.attempts - 1 : undefined
  });
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/query.js
var currentCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map9(deferredMake(), (handle2) => ({
  listeners: new Listeners,
  handle: handle2
})), () => seconds(60))));
var currentCacheEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
var fromRequest = (request, dataSource) => flatMap7(isEffect(dataSource) ? dataSource : succeed(dataSource), (ds) => fiberIdWith((id2) => {
  const proxy2 = new Proxy(request, {});
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      const cached3 = fiberRefGetWith(currentCache, (cache) => flatMap7(cache.getEither(proxy2), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            if (orNew.left.listeners.interrupted) {
              return flatMap7(cache.invalidateWhen(proxy2, (entry) => entry.handle === orNew.left.handle), () => cached3);
            }
            orNew.left.listeners.increment();
            return uninterruptibleMask((restore) => flatMap7(exit(blocked(empty19, restore(deferredAwait(orNew.left.handle)))), (exit2) => {
              orNew.left.listeners.decrement();
              return exit2;
            }));
          }
          case "Right": {
            orNew.right.listeners.increment();
            return uninterruptibleMask((restore) => flatMap7(exit(blocked(single(ds, makeEntry({
              request: proxy2,
              result: orNew.right.handle,
              listeners: orNew.right.listeners,
              ownerId: id2,
              state: {
                completed: false
              }
            })), restore(deferredAwait(orNew.right.handle)))), () => {
              orNew.right.listeners.decrement();
              return deferredAwait(orNew.right.handle);
            }));
          }
        }
      }));
      return cached3;
    }
    const listeners = new Listeners;
    listeners.increment();
    return flatMap7(deferredMake(), (ref) => ensuring(blocked(single(ds, makeEntry({
      request: proxy2,
      result: ref,
      listeners,
      ownerId: id2,
      state: {
        completed: false
      }
    })), deferredAwait(ref)), sync(() => listeners.decrement())));
  });
}));
var cacheRequest = (request, result) => {
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      return fiberRefGetWith(currentCache, (cache) => flatMap7(cache.getEither(request), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            return void_;
          }
          case "Right": {
            return deferredComplete(orNew.right.handle, result);
          }
        }
      }));
    }
    return void_;
  });
};
var withRequestCaching = /* @__PURE__ */ dual(2, (self2, strategy) => fiberRefLocally(self2, currentCacheEnabled, strategy));
var withRequestCache = /* @__PURE__ */ dual(2, (self2, cache) => fiberRefLocally(self2, currentCache, cache));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Request.js
var isRequest2 = isRequest;
var Class4 = Class2;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Effect.js
var EffectTypeId3 = EffectTypeId2;
var isEffect2 = isEffect;
var cachedWithTTL = cached2;
var cachedInvalidateWithTTL2 = cachedInvalidateWithTTL;
var cached3 = memoize;
var cachedFunction2 = cachedFunction;
var once3 = once;
var all4 = all2;
var allWith2 = allWith;
var allSuccesses2 = allSuccesses;
var dropUntil2 = dropUntil;
var dropWhile2 = dropWhile;
var takeUntil2 = takeUntil;
var takeWhile2 = takeWhile;
var every7 = every5;
var exists4 = exists3;
var filter7 = filter5;
var filterMap5 = filterMap4;
var findFirst6 = findFirst4;
var forEach8 = forEach7;
var head4 = head3;
var mergeAll5 = mergeAll3;
var partition4 = partition3;
var reduce12 = reduce10;
var reduceWhile2 = reduceWhile;
var reduceRight3 = reduceRight2;
var reduceEffect2 = reduceEffect;
var replicate2 = replicate;
var replicateEffect2 = replicateEffect;
var validateAll2 = validateAll;
var validateFirst2 = validateFirst;
var async = async_;
var asyncEffect2 = asyncEffect;
var custom2 = custom;
var withFiberRuntime2 = withFiberRuntime;
var fail8 = fail2;
var failSync3 = failSync;
var failCause7 = failCause;
var failCauseSync3 = failCauseSync;
var die6 = die2;
var dieMessage2 = dieMessage;
var dieSync3 = dieSync;
var gen2 = gen;
var never3 = never;
var none9 = none6;
var promise2 = promise;
var succeed7 = succeed;
var succeedNone2 = succeedNone;
var succeedSome2 = succeedSome;
var suspend3 = suspend;
var sync3 = sync;
var _void = void_;
var yieldNow4 = yieldNow;
var _catch2 = _catch;
var catchAll3 = catchAll;
var catchAllCause3 = catchAllCause;
var catchAllDefect2 = catchAllDefect;
var catchIf2 = catchIf;
var catchSome2 = catchSome;
var catchSomeCause2 = catchSomeCause;
var catchSomeDefect2 = catchSomeDefect;
var catchTag2 = catchTag;
var catchTags2 = catchTags;
var cause2 = cause;
var eventually2 = eventually;
var ignore2 = ignore;
var ignoreLogged2 = ignoreLogged;
var parallelErrors2 = parallelErrors;
var sandbox2 = sandbox;
var retry2 = retry_combined;
var withExecutionPlan2 = withExecutionPlan;
var retryOrElse = retryOrElse_Effect;
var try_3 = try_2;
var tryMap2 = tryMap;
var tryMapPromise2 = tryMapPromise;
var tryPromise2 = tryPromise;
var unsandbox2 = unsandbox;
var allowInterrupt2 = allowInterrupt;
var checkInterruptible2 = checkInterruptible;
var disconnect2 = disconnect;
var interrupt6 = interrupt2;
var interruptWith2 = interruptWith;
var interruptible4 = interruptible2;
var interruptibleMask2 = interruptibleMask;
var onInterrupt2 = onInterrupt;
var uninterruptible2 = uninterruptible;
var uninterruptibleMask3 = uninterruptibleMask;
var liftPredicate2 = liftPredicate;
var as3 = as;
var asSome2 = asSome;
var asSomeError2 = asSomeError;
var asVoid3 = asVoid;
var flip2 = flip;
var flipWith2 = flipWith;
var map13 = map9;
var mapAccum3 = mapAccum2;
var mapBoth3 = mapBoth2;
var mapError3 = mapError;
var mapErrorCause2 = mapErrorCause;
var merge7 = merge5;
var negate2 = negate;
var acquireRelease2 = acquireRelease;
var acquireReleaseInterruptible2 = acquireReleaseInterruptible;
var acquireUseRelease2 = acquireUseRelease;
var addFinalizer2 = addFinalizer;
var ensuring2 = ensuring;
var onError2 = onError;
var onExit3 = onExit;
var parallelFinalizers2 = parallelFinalizers;
var sequentialFinalizers2 = sequentialFinalizers;
var finalizersMask2 = finalizersMask;
var scope3 = scope;
var scopeWith2 = scopeWith;
var scopedWith2 = scopedWith;
var scoped2 = scopedEffect;
var using2 = using;
var withEarlyRelease2 = withEarlyRelease;
var awaitAllChildren2 = awaitAllChildren;
var daemonChildren2 = daemonChildren;
var descriptor2 = descriptor;
var descriptorWith2 = descriptorWith;
var diffFiberRefs2 = diffFiberRefs;
var ensuringChild2 = ensuringChild;
var ensuringChildren2 = ensuringChildren;
var fiberId2 = fiberId;
var fiberIdWith2 = fiberIdWith;
var fork3 = fork;
var forkDaemon2 = forkDaemon;
var forkAll2 = forkAll;
var forkIn2 = forkIn;
var forkScoped2 = forkScoped;
var forkWithErrorHandler2 = forkWithErrorHandler;
var fromFiber2 = fromFiber;
var fromFiberEffect2 = fromFiberEffect;
var supervised2 = supervised;
var transplant2 = transplant;
var withConcurrency2 = withConcurrency;
var withScheduler2 = withScheduler;
var withSchedulingPriority2 = withSchedulingPriority;
var withMaxOpsBeforeYield2 = withMaxOpsBeforeYield;
var clock2 = clock;
var clockWith4 = clockWith3;
var withClockScoped2 = withClockScoped;
var withClock2 = withClock;
var console3 = console2;
var consoleWith2 = consoleWith;
var withConsoleScoped2 = withConsoleScoped;
var withConsole2 = withConsole;
var delay2 = delay;
var sleep4 = sleep3;
var timed2 = timed;
var timedWith2 = timedWith;
var timeout2 = timeout;
var timeoutOption2 = timeoutOption;
var timeoutFail2 = timeoutFail;
var timeoutFailCause2 = timeoutFailCause;
var timeoutTo2 = timeoutTo;
var configProviderWith2 = configProviderWith;
var withConfigProvider2 = withConfigProvider;
var withConfigProviderScoped2 = withConfigProviderScoped;
var context3 = context;
var contextWith2 = contextWith;
var contextWithEffect2 = contextWithEffect;
var mapInputContext2 = mapInputContext;
var provide2 = effect_provide;
var provideService3 = provideService;
var provideServiceEffect2 = provideServiceEffect;
var serviceFunction2 = serviceFunction;
var serviceFunctionEffect2 = serviceFunctionEffect;
var serviceFunctions2 = serviceFunctions;
var serviceConstants2 = serviceConstants;
var serviceMembers2 = serviceMembers;
var serviceOption2 = serviceOption;
var serviceOptional2 = serviceOptional;
var updateService2 = updateService;
var Do2 = Do;
var bind3 = bind2;
var bindAll2 = bindAll;
var bindTo3 = bindTo2;
var let_3 = let_2;
var option2 = option;
var either3 = either2;
var exit2 = exit;
var intoDeferred2 = intoDeferred;
var if_2 = if_;
var filterOrDie2 = filterOrDie;
var filterOrDieMessage2 = filterOrDieMessage;
var filterOrElse2 = filterOrElse;
var filterOrFail2 = filterOrFail;
var filterEffectOrElse2 = filterEffectOrElse;
var filterEffectOrFail2 = filterEffectOrFail;
var unless2 = unless;
var unlessEffect2 = unlessEffect;
var when2 = when;
var whenEffect2 = whenEffect;
var whenFiberRef2 = whenFiberRef;
var whenRef2 = whenRef;
var flatMap10 = flatMap7;
var andThen4 = andThen2;
var flatten8 = flatten5;
var race2 = race;
var raceAll2 = raceAll;
var raceFirst2 = raceFirst;
var raceWith2 = raceWith;
var summarized2 = summarized;
var tap3 = tap;
var tapBoth2 = tapBoth;
var tapDefect2 = tapDefect;
var tapError3 = tapError;
var tapErrorTag2 = tapErrorTag;
var tapErrorCause3 = tapErrorCause;
var forever3 = forever;
var iterate2 = iterate;
var loop2 = loop;
var repeat = repeat_combined;
var repeatN2 = repeatN;
var repeatOrElse = repeatOrElse_Effect;
var schedule = schedule_Effect;
var scheduleForked2 = scheduleForked;
var scheduleFrom = scheduleFrom_Effect;
var whileLoop2 = whileLoop;
var getFiberRefs = fiberRefs2;
var inheritFiberRefs2 = inheritFiberRefs;
var locally = fiberRefLocally;
var locallyWith = fiberRefLocallyWith;
var locallyScoped = fiberRefLocallyScoped;
var locallyScopedWith = fiberRefLocallyScopedWith;
var patchFiberRefs2 = patchFiberRefs;
var setFiberRefs2 = setFiberRefs;
var updateFiberRefs3 = updateFiberRefs;
var isFailure3 = isFailure;
var isSuccess3 = isSuccess2;
var match13 = match7;
var matchCause3 = matchCause;
var matchCauseEffect3 = matchCauseEffect;
var matchEffect2 = matchEffect;
var log2 = log;
var logWithLevel2 = (level, ...message) => logWithLevel(level)(...message);
var logTrace2 = logTrace;
var logDebug2 = logDebug;
var logInfo2 = logInfo;
var logWarning2 = logWarning;
var logError2 = logError;
var logFatal2 = logFatal;
var withLogSpan2 = withLogSpan;
var annotateLogs3 = annotateLogs;
var annotateLogsScoped2 = annotateLogsScoped;
var logAnnotations2 = logAnnotations;
var withUnhandledErrorLogLevel2 = withUnhandledErrorLogLevel;
var whenLogLevel2 = whenLogLevel;
var orDie3 = orDie;
var orDieWith2 = orDieWith;
var orElse5 = orElse2;
var orElseFail2 = orElseFail;
var orElseSucceed2 = orElseSucceed;
var firstSuccessOf2 = firstSuccessOf;
var random3 = random2;
var randomWith2 = randomWith;
var withRandom2 = withRandom;
var withRandomScoped2 = withRandomScoped;
var runtime4 = runtime3;
var getRuntimeFlags = runtimeFlags;
var patchRuntimeFlags = updateRuntimeFlags;
var withRuntimeFlagsPatch = withRuntimeFlags;
var withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
var tagMetrics2 = tagMetrics;
var labelMetrics2 = labelMetrics;
var tagMetricsScoped2 = tagMetricsScoped;
var labelMetricsScoped2 = labelMetricsScoped;
var metricLabels2 = metricLabels;
var withMetric2 = withMetric;
var unsafeMakeSemaphore2 = unsafeMakeSemaphore;
var makeSemaphore2 = makeSemaphore;
var unsafeMakeLatch2 = unsafeMakeLatch;
var makeLatch2 = makeLatch;
var runFork2 = unsafeForkEffect;
var runCallback = unsafeRunEffect;
var runPromise = unsafeRunPromiseEffect;
var runPromiseExit = unsafeRunPromiseExitEffect;
var runSync = unsafeRunSyncEffect;
var runSyncExit = unsafeRunSyncExitEffect;
var validate2 = validate;
var validateWith2 = validateWith;
var zip4 = zipOptions;
var zipLeft2 = zipLeftOptions;
var zipRight2 = zipRightOptions;
var zipWith6 = zipWithOptions;
var ap = /* @__PURE__ */ dual(2, (self2, that) => zipWith6(self2, that, (f, a) => f(a)));
var blocked2 = blocked;
var runRequestBlock2 = runRequestBlock;
var step3 = step2;
var request = /* @__PURE__ */ dual((args3) => isRequest2(args3[0]), fromRequest);
var cacheRequestResult = cacheRequest;
var withRequestBatching2 = withRequestBatching;
var withRequestCaching2 = withRequestCaching;
var withRequestCache2 = withRequestCache;
var tracer3 = tracer2;
var tracerWith4 = tracerWith;
var withTracer2 = withTracer;
var withTracerScoped2 = withTracerScoped;
var withTracerEnabled2 = withTracerEnabled;
var withTracerTiming2 = withTracerTiming;
var annotateSpans3 = annotateSpans;
var annotateCurrentSpan2 = annotateCurrentSpan;
var currentSpan2 = currentSpan;
var currentParentSpan2 = currentParentSpan;
var spanAnnotations2 = spanAnnotations;
var spanLinks2 = spanLinks;
var linkSpans2 = linkSpans;
var linkSpanCurrent2 = linkSpanCurrent;
var makeSpan2 = makeSpan;
var makeSpanScoped2 = makeSpanScoped;
var useSpan2 = useSpan;
var withSpan3 = withSpan;
var functionWithSpan2 = functionWithSpan;
var withSpanScoped2 = withSpanScoped;
var withParentSpan3 = withParentSpan;
var fromNullable3 = fromNullable2;
var optionFromOptional2 = optionFromOptional;
var transposeOption = (self2) => {
  return isNone(self2) ? succeedNone2 : map13(self2.value, some);
};
var transposeMapOption = /* @__PURE__ */ dual(2, (self2, f) => isNone(self2) ? succeedNone2 : map13(f(self2.value), some));
var makeTagProxy = (TagClass) => {
  const cache = new Map;
  return new Proxy(TagClass, {
    get(target, prop, receiver) {
      if (prop in target) {
        return Reflect.get(target, prop, receiver);
      }
      if (cache.has(prop)) {
        return cache.get(prop);
      }
      const fn2 = (...args3) => andThen2(target, (s2) => {
        if (typeof s2[prop] === "function") {
          cache.set(prop, (...args4) => andThen2(target, (s3) => s3[prop](...args4)));
          return s2[prop](...args3);
        }
        cache.set(prop, andThen2(target, (s3) => s3[prop]));
        return s2[prop];
      });
      const cn2 = andThen2(target, (s2) => s2[prop]);
      Object.assign(fn2, cn2);
      Object.setPrototypeOf(fn2, Object.getPrototypeOf(cn2));
      cache.set(prop, fn2);
      return fn2;
    }
  });
};
var Tag3 = (id2) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id2;
  Object.defineProperty(TagClass, "use", {
    get() {
      return (body2) => andThen2(this, body2);
    }
  });
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return makeTagProxy(TagClass);
};
var Service = function() {
  return function() {
    const [id2, maker] = arguments;
    const proxy2 = "accessors" in maker ? maker["accessors"] : false;
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error;
    Error.stackTraceLimit = limit;
    let patchState = "unchecked";
    const TagClass = function(service2) {
      if (patchState === "unchecked") {
        const proto4 = Object.getPrototypeOf(service2);
        if (proto4 === Object.prototype || proto4 === null) {
          patchState = "plain";
        } else {
          const selfProto = Object.getPrototypeOf(this);
          Object.setPrototypeOf(selfProto, proto4);
          patchState = "patched";
        }
      }
      if (patchState === "plain") {
        Object.assign(this, service2);
      } else if (patchState === "patched") {
        Object.setPrototypeOf(service2, Object.getPrototypeOf(this));
        return service2;
      }
    };
    TagClass.prototype._tag = id2;
    Object.defineProperty(TagClass, "make", {
      get() {
        return (service2) => new this(service2);
      }
    });
    Object.defineProperty(TagClass, "use", {
      get() {
        return (body2) => andThen2(this, body2);
      }
    });
    TagClass.key = id2;
    Object.assign(TagClass, TagProto);
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
    const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
    let layerCache;
    let isFunction3 = false;
    if ("effect" in maker) {
      isFunction3 = typeof maker.effect === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return function() {
              return fromEffect3(TagClass, map13(maker.effect.apply(null, arguments), (_2) => new this(_2)));
            }.bind(this);
          }
          return layerCache ??= fromEffect3(TagClass, map13(maker.effect, (_2) => new this(_2)));
        }
      });
    } else if ("scoped" in maker) {
      isFunction3 = typeof maker.scoped === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return function() {
              return scoped(TagClass, map13(maker.scoped.apply(null, arguments), (_2) => new this(_2)));
            }.bind(this);
          }
          return layerCache ??= scoped(TagClass, map13(maker.scoped, (_2) => new this(_2)));
        }
      });
    } else if ("sync" in maker) {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= sync2(TagClass, () => new this(maker.sync()));
        }
      });
    } else {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= succeed5(TagClass, new this(maker.succeed));
        }
      });
    }
    if (hasDeps) {
      let layerWithDepsCache;
      Object.defineProperty(TagClass, "Default", {
        get() {
          if (isFunction3) {
            return function() {
              return provide(this.DefaultWithoutDependencies.apply(null, arguments), maker.dependencies);
            };
          }
          return layerWithDepsCache ??= provide(this.DefaultWithoutDependencies, maker.dependencies);
        }
      });
    }
    return proxy2 === true ? makeTagProxy(TagClass) : TagClass;
  };
};
var fn2 = function(nameOrBody, ...pipeables) {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const errorDef = new Error;
  Error.stackTraceLimit = limit;
  if (typeof nameOrBody !== "string") {
    return defineLength(nameOrBody.length, function(...args3) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error;
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body: nameOrBody,
        args: args3,
        pipeables,
        spanName: "<anonymous>",
        spanOptions: {
          context: DisablePropagation.context(true)
        },
        errorDef,
        errorCall
      });
    });
  }
  const name2 = nameOrBody;
  const options = pipeables[0];
  return (body2, ...pipeables2) => defineLength(body2.length, {
    [name2](...args3) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error;
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body: body2,
        args: args3,
        pipeables: pipeables2,
        spanName: name2,
        spanOptions: options,
        errorDef,
        errorCall
      });
    }
  }[name2]);
};
function defineLength(length2, fn3) {
  return Object.defineProperty(fn3, "length", {
    value: length2,
    configurable: true
  });
}
function fnApply(options) {
  let effect;
  let fnError = undefined;
  if (isGeneratorFunction(options.body)) {
    effect = fromIterator(() => options.body.apply(options.self, options.args));
  } else {
    try {
      effect = options.body.apply(options.self, options.args);
    } catch (error) {
      fnError = error;
      effect = die6(error);
    }
  }
  if (options.pipeables.length > 0) {
    try {
      for (const x3 of options.pipeables) {
        effect = x3(effect, ...options.args);
      }
    } catch (error) {
      effect = fnError ? failCause7(sequential(die(fnError), die(error))) : die6(error);
    }
  }
  let cache = false;
  const captureStackTrace = () => {
    if (cache !== false) {
      return cache;
    }
    if (options.errorCall.stack) {
      const stackDef = options.errorDef.stack.trim().split(`
`);
      const stackCall = options.errorCall.stack.trim().split(`
`);
      let endStackDef = stackDef.slice(2).join(`
`).trim();
      if (!endStackDef.includes(`(`)) {
        endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
      }
      let endStackCall = stackCall.slice(2).join(`
`).trim();
      if (!endStackCall.includes(`(`)) {
        endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
      }
      cache = `${endStackDef}
${endStackCall}`;
      return cache;
    }
  };
  const opts = options.spanOptions && "captureStackTrace" in options.spanOptions ? options.spanOptions : {
    captureStackTrace,
    ...options.spanOptions
  };
  return withSpan3(effect, options.spanName, opts);
}
var fnUntraced2 = fnUntraced;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/FiberRef.js
var currentContext2 = currentContext;
var currentSchedulingPriority2 = currentSchedulingPriority;
var currentScheduler2 = currentScheduler;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Layer.js
var exports_Layer = {};
__export(exports_Layer, {
  zipWith: () => zipWith7,
  withSpan: () => withSpan4,
  withParentSpan: () => withParentSpan4,
  updateService: () => updateService3,
  unwrapScoped: () => unwrapScoped2,
  unwrapEffect: () => unwrapEffect2,
  toRuntimeWithMemoMap: () => toRuntimeWithMemoMap2,
  toRuntime: () => toRuntime2,
  tapErrorCause: () => tapErrorCause4,
  tapError: () => tapError4,
  tap: () => tap4,
  syncContext: () => syncContext2,
  sync: () => sync4,
  suspend: () => suspend4,
  succeedContext: () => succeedContext2,
  succeed: () => succeed8,
  span: () => span3,
  setUnhandledErrorLogLevel: () => setUnhandledErrorLogLevel,
  setTracerTiming: () => setTracerTiming,
  setTracerEnabled: () => setTracerEnabled,
  setTracer: () => setTracer2,
  setScheduler: () => setScheduler,
  setRequestCaching: () => setRequestCaching,
  setRequestCache: () => setRequestCache,
  setRequestBatching: () => setRequestBatching,
  setRandom: () => setRandom,
  setConfigProvider: () => setConfigProvider2,
  setClock: () => setClock,
  service: () => service2,
  scopedDiscard: () => scopedDiscard2,
  scopedContext: () => scopedContext2,
  scoped: () => scoped3,
  scope: () => scope4,
  retry: () => retry3,
  provideMerge: () => provideMerge2,
  provide: () => provide3,
  project: () => project2,
  passthrough: () => passthrough3,
  parentSpan: () => parentSpan2,
  orElse: () => orElse6,
  orDie: () => orDie4,
  mergeAll: () => mergeAll6,
  merge: () => merge8,
  memoize: () => memoize3,
  matchCause: () => matchCause4,
  match: () => match14,
  mapError: () => mapError4,
  map: () => map14,
  makeMemoMap: () => makeMemoMap2,
  locallyWith: () => locallyWith2,
  locallyScoped: () => locallyScoped2,
  locallyEffect: () => locallyEffect2,
  locally: () => locally2,
  launch: () => launch2,
  isLayer: () => isLayer2,
  isFresh: () => isFresh2,
  function: () => fromFunction2,
  fresh: () => fresh2,
  flatten: () => flatten9,
  flatMap: () => flatMap11,
  fiberRefLocallyScopedWith: () => fiberRefLocallyScopedWith3,
  failSync: () => failSync4,
  failCauseSync: () => failCauseSync4,
  failCause: () => failCause8,
  fail: () => fail9,
  extendScope: () => extendScope2,
  empty: () => empty35,
  effectDiscard: () => effectDiscard,
  effectContext: () => effectContext,
  effect: () => effect,
  discard: () => discard2,
  dieSync: () => dieSync4,
  die: () => die7,
  context: () => context4,
  catchAllCause: () => catchAllCause4,
  catchAll: () => catchAll4,
  buildWithScope: () => buildWithScope2,
  buildWithMemoMap: () => buildWithMemoMap2,
  build: () => build2,
  annotateSpans: () => annotateSpans4,
  annotateLogs: () => annotateLogs4,
  MemoMapTypeId: () => MemoMapTypeId2,
  LayerTypeId: () => LayerTypeId2,
  CurrentMemoMap: () => CurrentMemoMap2
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/layer/circular.js
var setConfigProvider = (configProvider) => scopedDiscard(withConfigProviderScoped(configProvider));
var parentSpan = (span2) => succeedContext(make6(spanTag, span2));
var span2 = (name2, options) => {
  options = addSpanStackTrace(options);
  return scoped(spanTag, options?.onEnd ? tap(makeSpanScoped(name2, options), (span3) => addFinalizer((exit3) => options.onEnd(span3, exit3))) : makeSpanScoped(name2, options));
};
var setTracer = (tracer4) => scopedDiscard(withTracerScoped(tracer4));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Layer.js
var LayerTypeId2 = LayerTypeId;
var MemoMapTypeId2 = MemoMapTypeId;
var CurrentMemoMap2 = CurrentMemoMap;
var isLayer2 = isLayer;
var isFresh2 = isFresh;
var annotateLogs4 = annotateLogs2;
var annotateSpans4 = annotateSpans2;
var build2 = build;
var buildWithScope2 = buildWithScope;
var catchAll4 = catchAll2;
var catchAllCause4 = catchAllCause2;
var context4 = context2;
var die7 = die5;
var dieSync4 = dieSync2;
var discard2 = discard;
var effect = fromEffect3;
var effectDiscard = fromEffectDiscard;
var effectContext = fromEffectContext;
var empty35 = empty34;
var extendScope2 = extendScope;
var fail9 = fail6;
var failSync4 = failSync2;
var failCause8 = failCause5;
var failCauseSync4 = failCauseSync2;
var flatMap11 = flatMap9;
var flatten9 = flatten7;
var fresh2 = fresh;
var fromFunction2 = fromFunction;
var launch2 = launch;
var map14 = map11;
var mapError4 = mapError2;
var match14 = match11;
var matchCause4 = matchCause2;
var memoize3 = memoize2;
var merge8 = merge6;
var mergeAll6 = mergeAll4;
var orDie4 = orDie2;
var orElse6 = orElse4;
var passthrough3 = passthrough;
var project2 = project;
var locallyEffect2 = locallyEffect;
var locally2 = fiberRefLocally2;
var locallyWith2 = fiberRefLocallyWith2;
var locallyScoped2 = fiberRefLocallyScoped2;
var fiberRefLocallyScopedWith3 = fiberRefLocallyScopedWith2;
var retry3 = retry;
var scope4 = scope2;
var scoped3 = scoped;
var scopedDiscard2 = scopedDiscard;
var scopedContext2 = scopedContext;
var service2 = service;
var succeed8 = succeed5;
var succeedContext2 = succeedContext;
var suspend4 = suspend2;
var sync4 = sync2;
var syncContext2 = syncContext;
var tap4 = tap2;
var tapError4 = tapError2;
var tapErrorCause4 = tapErrorCause2;
var toRuntime2 = toRuntime;
var toRuntimeWithMemoMap2 = toRuntimeWithMemoMap;
var provide3 = provide;
var provideMerge2 = provideMerge;
var zipWith7 = zipWith5;
var unwrapEffect2 = unwrapEffect;
var unwrapScoped2 = unwrapScoped;
var setClock = (clock3) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(clockTag, clock3)));
var setConfigProvider2 = setConfigProvider;
var parentSpan2 = parentSpan;
var setRandom = (random4) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(randomTag, random4)));
var setRequestBatching = (requestBatching) => scopedDiscard2(fiberRefLocallyScoped(currentRequestBatching, requestBatching));
var setRequestCaching = (requestCaching) => scopedDiscard2(fiberRefLocallyScoped(currentCacheEnabled, requestCaching));
var setRequestCache = (cache) => scopedDiscard2(isEffect(cache) ? flatMap7(cache, (x3) => fiberRefLocallyScoped(currentCache, x3)) : fiberRefLocallyScoped(currentCache, cache));
var setScheduler = (scheduler) => scopedDiscard2(fiberRefLocallyScoped(currentScheduler, scheduler));
var span3 = span2;
var setTracer2 = setTracer;
var setTracerEnabled = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerEnabled, enabled2));
var setTracerTiming = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerTimingEnabled, enabled2));
var setUnhandledErrorLogLevel = (level) => scopedDiscard2(fiberRefLocallyScoped(currentUnhandledErrorLogLevel, level));
var withSpan4 = withSpan2;
var withParentSpan4 = withParentSpan2;
var makeMemoMap2 = makeMemoMap;
var buildWithMemoMap2 = buildWithMemoMap;
var updateService3 = /* @__PURE__ */ dual(3, (layer, tag, f) => provide3(layer, map14(context4(), (c) => add2(c, tag, f(unsafeGet3(c, tag))))));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/pubsub.js
var AbsentValue = /* @__PURE__ */ Symbol.for("effect/PubSub/AbsentValue");
class UnboundedPubSub {
  replayBuffer;
  publisherHead = {
    value: AbsentValue,
    subscribers: 0,
    next: null
  };
  publisherTail = this.publisherHead;
  publisherIndex = 0;
  subscribersIndex = 0;
  capacity = Number.MAX_SAFE_INTEGER;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherHead === this.publisherTail;
  }
  isFull() {
    return false;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value) {
    const subscribers = this.publisherTail.subscribers;
    if (subscribers !== 0) {
      this.publisherTail.next = {
        value,
        subscribers,
        next: null
      };
      this.publisherTail = this.publisherTail.next;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.publisherTail.subscribers !== 0) {
      for (const a of elements) {
        this.publish(a);
      }
    } else if (this.replayBuffer) {
      this.replayBuffer.offerAll(elements);
    }
    return empty5();
  }
  slide() {
    if (this.publisherHead !== this.publisherTail) {
      this.publisherHead = this.publisherHead.next;
      this.publisherHead.value = AbsentValue;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.publisherTail.subscribers += 1;
    return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
  }
}

class UnboundedPubSubSubscription {
  self;
  subscriberHead;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberHead, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberHead = subscriberHead;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    if (this.unsubscribed) {
      return true;
    }
    let empty36 = true;
    let loop3 = true;
    while (loop3) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop3 = false;
      } else {
        if (this.subscriberHead.next.value !== AbsentValue) {
          empty36 = false;
          loop3 = false;
        } else {
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
    }
    return empty36;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    let loop3 = true;
    let polled = default_;
    while (loop3) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop3 = false;
      } else {
        const elem = this.subscriberHead.next.value;
        if (elem !== AbsentValue) {
          polled = elem;
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          loop3 = false;
        }
        this.subscriberHead = this.subscriberHead.next;
        this.subscriberIndex += 1;
      }
    }
    return polled;
  }
  pollUpTo(n) {
    const builder = [];
    const default_ = AbsentValue;
    let i2 = 0;
    while (i2 !== n) {
      const a = this.poll(default_);
      if (a === default_) {
        i2 = n;
      } else {
        builder.push(a);
        i2 += 1;
      }
    }
    return fromIterable2(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.publisherTail.subscribers -= 1;
      while (this.subscriberHead !== this.self.publisherTail) {
        if (this.subscriberHead.next.value !== AbsentValue) {
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
        }
        this.subscriberHead = this.subscriberHead.next;
      }
    }
  }
}
class ReplayBuffer {
  capacity;
  constructor(capacity2) {
    this.capacity = capacity2;
  }
  head = {
    value: AbsentValue,
    next: null
  };
  tail = this.head;
  size = 0;
  index = 0;
  slide() {
    this.index++;
  }
  offer(a) {
    this.tail.value = a;
    this.tail.next = {
      value: AbsentValue,
      next: null
    };
    this.tail = this.tail.next;
    if (this.size === this.capacity) {
      this.head = this.head.next;
    } else {
      this.size += 1;
    }
  }
  offerAll(as4) {
    for (const a of as4) {
      this.offer(a);
    }
  }
}

class ReplayWindowImpl {
  buffer;
  head;
  index;
  remaining;
  constructor(buffer) {
    this.buffer = buffer;
    this.index = buffer.index;
    this.remaining = buffer.size;
    this.head = buffer.head;
  }
  fastForward() {
    while (this.index < this.buffer.index) {
      this.head = this.head.next;
      this.index++;
    }
  }
  take() {
    if (this.remaining === 0) {
      return;
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    this.remaining--;
    const value = this.head.value;
    this.head = this.head.next;
    return value;
  }
  takeN(n) {
    if (this.remaining === 0) {
      return empty5();
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    const len = Math.min(n, this.remaining);
    const items = new Array(len);
    for (let i2 = 0;i2 < len; i2++) {
      const value = this.head.value;
      this.head = this.head.next;
      items[i2] = value;
    }
    this.remaining -= len;
    return unsafeFromArray(items);
  }
  takeAll() {
    return this.takeN(this.remaining);
  }
}
var emptyReplayWindow = {
  remaining: 0,
  take: () => {
    return;
  },
  takeN: () => empty5(),
  takeAll: () => empty5()
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
var ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
var ChildExecutorDecisionTypeId = /* @__PURE__ */ Symbol.for(ChildExecutorDecisionSymbolKey);
var proto4 = {
  [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
var UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
var UpstreamPullStrategyTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullStrategySymbolKey);
var upstreamPullStrategyVariance = {
  _A: (_2) => _2
};
var proto5 = {
  [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/core-stream.js
var ChannelSymbolKey = "effect/Channel";
var ChannelTypeId2 = /* @__PURE__ */ Symbol.for(ChannelSymbolKey);
var channelVariance2 = {
  _Env: (_2) => _2,
  _InErr: (_2) => _2,
  _InElem: (_2) => _2,
  _InDone: (_2) => _2,
  _OutErr: (_2) => _2,
  _OutElem: (_2) => _2,
  _OutDone: (_2) => _2
};
var proto6 = {
  [ChannelTypeId2]: channelVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/channel/channelState.js
var ChannelStateTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelState");
var channelStateVariance = {
  _E: (_2) => _2,
  _R: (_2) => _2
};
var proto7 = {
  [ChannelStateTypeId]: channelStateVariance
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
var UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
var UpstreamPullRequestTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullRequestSymbolKey);
var upstreamPullRequestVariance = {
  _A: (_2) => _2
};
var proto8 = {
  [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/channel/mergeDecision.js
var MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
var MergeDecisionTypeId = /* @__PURE__ */ Symbol.for(MergeDecisionSymbolKey);
var proto9 = {
  [MergeDecisionTypeId]: {
    _R: (_2) => _2,
    _E0: (_2) => _2,
    _Z0: (_2) => _2,
    _E: (_2) => _2,
    _Z: (_2) => _2
  }
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/channel/mergeState.js
var MergeStateSymbolKey = "effect/ChannelMergeState";
var MergeStateTypeId = /* @__PURE__ */ Symbol.for(MergeStateSymbolKey);
var proto10 = {
  [MergeStateTypeId]: MergeStateTypeId
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
var MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
var MergeStrategyTypeId = /* @__PURE__ */ Symbol.for(MergeStrategySymbolKey);
var proto11 = {
  [MergeStrategyTypeId]: MergeStrategyTypeId
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/sink.js
var SinkTypeId2 = /* @__PURE__ */ Symbol.for("effect/Sink");

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Runtime.js
var exports_Runtime = {};
__export(exports_Runtime, {
  updateRuntimeFlags: () => updateRuntimeFlags3,
  updateFiberRefs: () => updateFiberRefs4,
  updateContext: () => updateContext3,
  setFiberRef: () => setFiberRef2,
  runSyncExit: () => runSyncExit2,
  runSync: () => runSync2,
  runPromiseExit: () => runPromiseExit2,
  runPromise: () => runPromise2,
  runFork: () => runFork3,
  runCallback: () => runCallback2,
  provideService: () => provideService4,
  makeFiberFailure: () => makeFiberFailure,
  make: () => make46,
  isFiberFailure: () => isFiberFailure2,
  isAsyncFiberException: () => isAsyncFiberException2,
  enableRuntimeFlag: () => enableRuntimeFlag2,
  disableRuntimeFlag: () => disableRuntimeFlag2,
  deleteFiberRef: () => deleteFiberRef2,
  defaultRuntimeFlags: () => defaultRuntimeFlags2,
  defaultRuntime: () => defaultRuntime2,
  FiberFailureId: () => FiberFailureId2,
  FiberFailureCauseId: () => FiberFailureCauseId2
});
var runFork3 = unsafeFork2;
var runSyncExit2 = unsafeRunSyncExit;
var runSync2 = unsafeRunSync;
var runCallback2 = unsafeRunCallback;
var runPromise2 = unsafeRunPromise;
var runPromiseExit2 = unsafeRunPromiseExit;
var defaultRuntime2 = defaultRuntime;
var defaultRuntimeFlags2 = defaultRuntimeFlags;
var make46 = make40;
var FiberFailureId2 = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId2 = FiberFailureCauseId;
var isAsyncFiberException2 = isAsyncFiberException;
var isFiberFailure2 = isFiberFailure;
var makeFiberFailure = fiberFailure;
var updateRuntimeFlags3 = updateRuntimeFlags2;
var enableRuntimeFlag2 = enableRuntimeFlag;
var disableRuntimeFlag2 = disableRuntimeFlag;
var updateContext3 = updateContext2;
var provideService4 = provideService2;
var updateFiberRefs4 = updateFiberRefs2;
var setFiberRef2 = setFiberRef;
var deleteFiberRef2 = deleteFiberRef;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/stm/versioned.js
class Versioned {
  value;
  constructor(value) {
    this.value = value;
  }
}

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/stm/entry.js
var make47 = (ref, isNew) => ({
  ref,
  isNew,
  isChanged: false,
  expected: ref.versioned,
  newValue: ref.versioned.value
});
var unsafeGet7 = (self2) => {
  return self2.newValue;
};
var unsafeSet = (self2, value) => {
  self2.isChanged = true;
  self2.newValue = value;
};
var commit = (self2) => {
  self2.ref.versioned = new Versioned(self2.newValue);
};
var isInvalid = (self2) => {
  return self2.ref.versioned !== self2.expected;
};
var isChanged = (self2) => {
  return self2.isChanged;
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/stm/journal.js
var JournalAnalysisInvalid = "Invalid";
var JournalAnalysisReadWrite = "ReadWrite";
var JournalAnalysisReadOnly = "ReadOnly";
var commitJournal = (journal) => {
  for (const entry of journal) {
    commit(entry[1]);
  }
};
var analyzeJournal = (journal) => {
  let val = JournalAnalysisReadOnly;
  for (const [, entry] of journal) {
    val = isInvalid(entry) ? JournalAnalysisInvalid : isChanged(entry) ? JournalAnalysisReadWrite : val;
    if (val === JournalAnalysisInvalid) {
      return val;
    }
  }
  return val;
};
var collectTodos = (journal) => {
  const allTodos = new Map;
  for (const [, entry] of journal) {
    for (const todo of entry.ref.todos) {
      allTodos.set(todo[0], todo[1]);
    }
    entry.ref.todos = new Map;
  }
  return allTodos;
};
var execTodos = (todos) => {
  const todosSorted = Array.from(todos.entries()).sort((x3, y2) => x3[0] - y2[0]);
  for (const [_2, todo] of todosSorted) {
    todo();
  }
};
var addTodo = (txnId, journal, todoEffect) => {
  let added = false;
  for (const [, entry] of journal) {
    if (!entry.ref.todos.has(txnId)) {
      entry.ref.todos.set(txnId, todoEffect);
      added = true;
    }
  }
  return added;
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/stm/opCodes/stm.js
var OP_WITH_STM_RUNTIME = "WithSTMRuntime";
var OP_ON_FAILURE2 = "OnFailure";
var OP_ON_RETRY = "OnRetry";
var OP_ON_SUCCESS2 = "OnSuccess";
var OP_PROVIDE3 = "Provide";
var OP_SYNC2 = "Sync";
var OP_SUCCEED2 = "Succeed";
var OP_RETRY = "Retry";
var OP_FAIL4 = "Fail";
var OP_DIE2 = "Die";
var OP_INTERRUPT2 = "Interrupt";

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/stm/opCodes/tExit.js
var OP_FAIL5 = "Fail";
var OP_DIE3 = "Die";
var OP_INTERRUPT3 = "Interrupt";
var OP_SUCCEED3 = "Succeed";
var OP_RETRY2 = "Retry";

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/stm/opCodes/tryCommit.js
var OP_DONE5 = "Done";
var OP_SUSPEND3 = "Suspend";

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/stm/opCodes/stmState.js
var OP_DONE6 = "Done";
var OP_INTERRUPTED = "Interrupted";
var OP_RUNNING2 = "Running";

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/stm/stmState.js
var STMStateSymbolKey = "effect/STM/State";
var STMStateTypeId = /* @__PURE__ */ Symbol.for(STMStateSymbolKey);
var isSTMState = (u3) => hasProperty(u3, STMStateTypeId);
var isRunning3 = (self2) => {
  return self2._tag === OP_RUNNING2;
};
var isDone6 = (self2) => {
  return self2._tag === OP_DONE6;
};
var done8 = (exit3) => {
  return {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_DONE6,
    exit: exit3,
    [symbol]() {
      return pipe(hash(STMStateSymbolKey), combine(hash(OP_DONE6)), combine(hash(exit3)), cached(this));
    },
    [symbol2](that) {
      return isSTMState(that) && that._tag === OP_DONE6 && equals(exit3, that.exit);
    }
  };
};
var interruptedHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_INTERRUPTED)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("interrupted")));
var interrupted2 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_INTERRUPTED,
  [symbol]() {
    return interruptedHash;
  },
  [symbol2](that) {
    return isSTMState(that) && that._tag === OP_INTERRUPTED;
  }
};
var runningHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RUNNING2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("running")));
var running3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_RUNNING2,
  [symbol]() {
    return runningHash;
  },
  [symbol2](that) {
    return isSTMState(that) && that._tag === OP_RUNNING2;
  }
};
var fromTExit = (tExit) => {
  switch (tExit._tag) {
    case OP_FAIL5: {
      return done8(fail3(tExit.error));
    }
    case OP_DIE3: {
      return done8(die3(tExit.defect));
    }
    case OP_INTERRUPT3: {
      return done8(interrupt4(tExit.fiberId));
    }
    case OP_SUCCEED3: {
      return done8(succeed2(tExit.value));
    }
    case OP_RETRY2: {
      throw new Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
  }
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/stm/tExit.js
var TExitSymbolKey = "effect/TExit";
var TExitTypeId = /* @__PURE__ */ Symbol.for(TExitSymbolKey);
var variance8 = {
  _A: (_2) => _2,
  _E: (_2) => _2
};
var isExit2 = (u3) => hasProperty(u3, TExitTypeId);
var isSuccess4 = (self2) => {
  return self2._tag === OP_SUCCEED3;
};
var isRetry = (self2) => {
  return self2._tag === OP_RETRY2;
};
var fail11 = (error) => ({
  [TExitTypeId]: variance8,
  _tag: OP_FAIL5,
  error,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_FAIL5)), combine(hash(error)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_FAIL5 && equals(error, that.error);
  }
});
var die8 = (defect) => ({
  [TExitTypeId]: variance8,
  _tag: OP_DIE3,
  defect,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_DIE3)), combine(hash(defect)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_DIE3 && equals(defect, that.defect);
  }
});
var interrupt8 = (fiberId3) => ({
  [TExitTypeId]: variance8,
  _tag: OP_INTERRUPT3,
  fiberId: fiberId3,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_INTERRUPT3)), combine(hash(fiberId3)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_INTERRUPT3 && equals(fiberId3, that.fiberId);
  }
});
var succeed12 = (value) => ({
  [TExitTypeId]: variance8,
  _tag: OP_SUCCEED3,
  value,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_SUCCEED3)), combine(hash(value)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_SUCCEED3 && equals(value, that.value);
  }
});
var retryHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(TExitSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RETRY2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("retry")));
var retry4 = {
  [TExitTypeId]: variance8,
  _tag: OP_RETRY2,
  [symbol]() {
    return retryHash;
  },
  [symbol2](that) {
    return isExit2(that) && isRetry(that);
  }
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/stm/tryCommit.js
var done9 = (exit3) => {
  return {
    _tag: OP_DONE5,
    exit: exit3
  };
};
var suspend6 = (journal) => {
  return {
    _tag: OP_SUSPEND3,
    journal
  };
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/stm/txnId.js
var txnCounter = {
  ref: 0
};
var make48 = () => {
  const newId = txnCounter.ref + 1;
  txnCounter.ref = newId;
  return newId;
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/stm/core.js
var STMSymbolKey2 = "effect/STM";
var STMTypeId2 = /* @__PURE__ */ Symbol.for(STMSymbolKey2);
var stmVariance = {
  _R: (_2) => _2,
  _E: (_2) => _2,
  _A: (_2) => _2
};

class STMPrimitive {
  effect_instruction_i0;
  _op = OP_COMMIT;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  [EffectTypeId3];
  [StreamTypeId];
  [SinkTypeId2];
  [ChannelTypeId2];
  get [STMTypeId2]() {
    return stmVariance;
  }
  constructor(effect_instruction_i0) {
    this.effect_instruction_i0 = effect_instruction_i0;
    this[EffectTypeId3] = effectVariance;
    this[StreamTypeId] = stmVariance;
    this[SinkTypeId2] = stmVariance;
    this[ChannelTypeId2] = stmVariance;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
  commit() {
    return unsafeAtomically(this, constVoid, constVoid);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var unsafeAtomically = (self2, onDone, onInterrupt3) => withFiberRuntime((state) => {
  const fiberId3 = state.id();
  const env = state.getFiberRef(currentContext2);
  const scheduler = state.getFiberRef(currentScheduler2);
  const priority = state.getFiberRef(currentSchedulingPriority2);
  const commitResult = tryCommitSync(fiberId3, self2, env, scheduler, priority);
  switch (commitResult._tag) {
    case OP_DONE5: {
      onDone(commitResult.exit);
      return commitResult.exit;
    }
    case OP_SUSPEND3: {
      const txnId = make48();
      const state2 = {
        value: running3
      };
      const effect3 = async((k2) => tryCommitAsync(fiberId3, self2, txnId, state2, env, scheduler, priority, k2));
      return uninterruptibleMask3((restore) => pipe(restore(effect3), catchAllCause3((cause3) => {
        let currentState = state2.value;
        if (isRunning3(currentState)) {
          state2.value = interrupted2;
        }
        currentState = state2.value;
        if (isDone6(currentState)) {
          onDone(currentState.exit);
          return currentState.exit;
        }
        onInterrupt3();
        return failCause7(cause3);
      })));
    }
  }
});
var tryCommit = (fiberId3, stm, state, env, scheduler, priority) => {
  const journal = new Map;
  const tExit = new STMDriver(stm, journal, fiberId3, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      state.value = fromTExit(tExit);
      return completeTodos(succeed2(tExit.value), journal, scheduler, priority);
    }
    case OP_FAIL5: {
      state.value = fromTExit(tExit);
      const cause3 = fail4(tExit.error);
      return completeTodos(failCause2(cause3), journal, scheduler, priority);
    }
    case OP_DIE3: {
      state.value = fromTExit(tExit);
      const cause3 = die4(tExit.defect);
      return completeTodos(failCause2(cause3), journal, scheduler, priority);
    }
    case OP_INTERRUPT3: {
      state.value = fromTExit(tExit);
      const cause3 = interrupt5(fiberId3);
      return completeTodos(failCause2(cause3), journal, scheduler, priority);
    }
    case OP_RETRY2: {
      return suspend6(journal);
    }
  }
};
var tryCommitSync = (fiberId3, stm, env, scheduler, priority) => {
  const journal = new Map;
  const tExit = new STMDriver(stm, journal, fiberId3, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite && isSuccess4(tExit)) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      return completeTodos(succeed2(tExit.value), journal, scheduler, priority);
    }
    case OP_FAIL5: {
      const cause3 = fail4(tExit.error);
      return completeTodos(failCause2(cause3), journal, scheduler, priority);
    }
    case OP_DIE3: {
      const cause3 = die4(tExit.defect);
      return completeTodos(failCause2(cause3), journal, scheduler, priority);
    }
    case OP_INTERRUPT3: {
      const cause3 = interrupt5(fiberId3);
      return completeTodos(failCause2(cause3), journal, scheduler, priority);
    }
    case OP_RETRY2: {
      return suspend6(journal);
    }
  }
};
var tryCommitAsync = (fiberId3, self2, txnId, state, context5, scheduler, priority, k2) => {
  if (isRunning3(state.value)) {
    const result = tryCommit(fiberId3, self2, state, context5, scheduler, priority);
    switch (result._tag) {
      case OP_DONE5: {
        completeTryCommit(result.exit, k2);
        break;
      }
      case OP_SUSPEND3: {
        addTodo(txnId, result.journal, () => tryCommitAsync(fiberId3, self2, txnId, state, context5, scheduler, priority, k2));
        break;
      }
    }
  }
};
var completeTodos = (exit3, journal, scheduler, priority) => {
  const todos = collectTodos(journal);
  if (todos.size > 0) {
    scheduler.scheduleTask(() => execTodos(todos), priority);
  }
  return done9(exit3);
};
var completeTryCommit = (exit3, k2) => {
  k2(exit3);
};
class STMDriver {
  self;
  journal;
  fiberId;
  contStack = [];
  env;
  constructor(self2, journal, fiberId3, r0) {
    this.self = self2;
    this.journal = journal;
    this.fiberId = fiberId3;
    this.env = r0;
  }
  getEnv() {
    return this.env;
  }
  pushStack(cont) {
    this.contStack.push(cont);
  }
  popStack() {
    return this.contStack.pop();
  }
  nextSuccess() {
    let current = this.popStack();
    while (current !== undefined && current.effect_instruction_i0 !== OP_ON_SUCCESS2) {
      current = this.popStack();
    }
    return current;
  }
  nextFailure() {
    let current = this.popStack();
    while (current !== undefined && current.effect_instruction_i0 !== OP_ON_FAILURE2) {
      current = this.popStack();
    }
    return current;
  }
  nextRetry() {
    let current = this.popStack();
    while (current !== undefined && current.effect_instruction_i0 !== OP_ON_RETRY) {
      current = this.popStack();
    }
    return current;
  }
  run() {
    let curr = this.self;
    let exit3 = undefined;
    while (exit3 === undefined && curr !== undefined) {
      try {
        const current = curr;
        if (current) {
          switch (current._op) {
            case "Tag": {
              curr = effect3((_2, __, env) => unsafeGet3(env, current));
              break;
            }
            case "Left": {
              curr = fail12(current.left);
              break;
            }
            case "None": {
              curr = fail12(new NoSuchElementException2);
              break;
            }
            case "Right": {
              curr = succeed13(current.right);
              break;
            }
            case "Some": {
              curr = succeed13(current.value);
              break;
            }
            case "Commit": {
              switch (current.effect_instruction_i0) {
                case OP_DIE2: {
                  exit3 = die8(internalCall(() => current.effect_instruction_i1()));
                  break;
                }
                case OP_FAIL4: {
                  const cont = this.nextFailure();
                  if (cont === undefined) {
                    exit3 = fail11(internalCall(() => current.effect_instruction_i1()));
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(internalCall(() => current.effect_instruction_i1())));
                  }
                  break;
                }
                case OP_RETRY: {
                  const cont = this.nextRetry();
                  if (cont === undefined) {
                    exit3 = retry4;
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2());
                  }
                  break;
                }
                case OP_INTERRUPT2: {
                  exit3 = interrupt8(this.fiberId);
                  break;
                }
                case OP_WITH_STM_RUNTIME: {
                  curr = internalCall(() => current.effect_instruction_i1(this));
                  break;
                }
                case OP_ON_SUCCESS2:
                case OP_ON_FAILURE2:
                case OP_ON_RETRY: {
                  this.pushStack(current);
                  curr = current.effect_instruction_i1;
                  break;
                }
                case OP_PROVIDE3: {
                  const env = this.env;
                  this.env = internalCall(() => current.effect_instruction_i2(env));
                  curr = pipe(current.effect_instruction_i1, ensuring5(sync7(() => this.env = env)));
                  break;
                }
                case OP_SUCCEED2: {
                  const value = current.effect_instruction_i1;
                  const cont = this.nextSuccess();
                  if (cont === undefined) {
                    exit3 = succeed12(value);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value));
                  }
                  break;
                }
                case OP_SYNC2: {
                  const value = internalCall(() => current.effect_instruction_i1());
                  const cont = this.nextSuccess();
                  if (cont === undefined) {
                    exit3 = succeed12(value);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value));
                  }
                  break;
                }
              }
              break;
            }
          }
        }
      } catch (e) {
        curr = die9(e);
      }
    }
    return exit3;
  }
}
var catchAll6 = /* @__PURE__ */ dual(2, (self2, f) => {
  const stm = new STMPrimitive(OP_ON_FAILURE2);
  stm.effect_instruction_i1 = self2;
  stm.effect_instruction_i2 = f;
  return stm;
});
var die9 = (defect) => dieSync5(() => defect);
var dieSync5 = (evaluate2) => {
  const stm = new STMPrimitive(OP_DIE2);
  stm.effect_instruction_i1 = evaluate2;
  return stm;
};
var effect3 = (f) => withSTMRuntime((_2) => succeed13(f(_2.journal, _2.fiberId, _2.getEnv())));
var ensuring5 = /* @__PURE__ */ dual(2, (self2, finalizer) => matchSTM(self2, {
  onFailure: (e) => zipRight6(finalizer, fail12(e)),
  onSuccess: (a) => zipRight6(finalizer, succeed13(a))
}));
var fail12 = (error) => failSync6(() => error);
var failSync6 = (evaluate2) => {
  const stm = new STMPrimitive(OP_FAIL4);
  stm.effect_instruction_i1 = evaluate2;
  return stm;
};
var flatMap13 = /* @__PURE__ */ dual(2, (self2, f) => {
  const stm = new STMPrimitive(OP_ON_SUCCESS2);
  stm.effect_instruction_i1 = self2;
  stm.effect_instruction_i2 = f;
  return stm;
});
var matchSTM = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => pipe(self2, map19(right2), catchAll6((e) => pipe(onFailure(e), map19(left2))), flatMap13((either5) => {
  switch (either5._tag) {
    case "Left": {
      return succeed13(either5.left);
    }
    case "Right": {
      return onSuccess(either5.right);
    }
  }
})));
var withSTMRuntime = (f) => {
  const stm = new STMPrimitive(OP_WITH_STM_RUNTIME);
  stm.effect_instruction_i1 = f;
  return stm;
};
var interruptAs2 = (fiberId3) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = fiberId3;
  return stm;
};
var map19 = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, flatMap13((a) => sync7(() => f(a)))));
var retry5 = /* @__PURE__ */ new STMPrimitive(OP_RETRY);
var succeed13 = (value) => {
  const stm = new STMPrimitive(OP_SUCCEED2);
  stm.effect_instruction_i1 = value;
  return stm;
};
var sync7 = (evaluate2) => {
  const stm = new STMPrimitive(OP_SYNC2);
  stm.effect_instruction_i1 = evaluate2;
  return stm;
};
var zipRight6 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, flatMap13(() => that)));
var zipWith9 = /* @__PURE__ */ dual(3, (self2, that, f) => pipe(self2, flatMap13((a) => pipe(that, map19((b3) => f(a, b3))))));

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/stm/opCodes/strategy.js
var OP_BACKPRESSURE_STRATEGY = "BackPressure";
var OP_DROPPING_STRATEGY = "Dropping";
var OP_SLIDING_STRATEGY = "Sliding";

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/stm/stm.js
var flatten11 = (self2) => flatMap13(self2, identity);
var forEach9 = /* @__PURE__ */ dual((args3) => isIterable(args3[0]), (iterable, f, options) => {
  if (options?.discard) {
    return pipe(sync7(() => iterable[Symbol.iterator]()), flatMap13((iterator) => {
      const loop3 = suspend7(() => {
        const next4 = iterator.next();
        if (next4.done) {
          return void_6;
        }
        return pipe(f(next4.value), flatMap13(() => loop3));
      });
      return loop3;
    }));
  }
  return suspend7(() => fromIterable(iterable).reduce((acc, curr) => zipWith9(acc, f(curr), (array6, elem) => {
    array6.push(elem);
    return array6;
  }), succeed13([])));
});
var suspend7 = (evaluate2) => flatten11(sync7(evaluate2));
var void_6 = /* @__PURE__ */ succeed13(undefined);

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/stm/tRef.js
var TRefSymbolKey = "effect/TRef";
var TRefTypeId = /* @__PURE__ */ Symbol.for(TRefSymbolKey);
var tRefVariance = {
  _A: (_2) => _2
};

class TRefImpl {
  [TRefTypeId] = tRefVariance;
  todos;
  versioned;
  constructor(value) {
    this.versioned = new Versioned(value);
    this.todos = new Map;
  }
  modify(f) {
    return effect3((journal) => {
      const entry = getOrMakeEntry(this, journal);
      const [retValue, newValue] = f(unsafeGet7(entry));
      unsafeSet(entry, newValue);
      return retValue;
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var getOrMakeEntry = (self2, journal) => {
  if (journal.has(self2)) {
    return journal.get(self2);
  }
  const entry = make47(self2, false);
  journal.set(self2, entry);
  return entry;
};
var unsafeGet8 = /* @__PURE__ */ dual(2, (self2, journal) => unsafeGet7(getOrMakeEntry(self2, journal)));
var unsafeSet2 = /* @__PURE__ */ dual(3, (self2, value, journal) => {
  const entry = getOrMakeEntry(self2, journal);
  unsafeSet(entry, value);
  return;
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/stm/tQueue.js
var TEnqueueSymbolKey = "effect/TQueue/TEnqueue";
var TEnqueueTypeId = /* @__PURE__ */ Symbol.for(TEnqueueSymbolKey);
var TDequeueSymbolKey = "effect/TQueue/TDequeue";
var TDequeueTypeId = /* @__PURE__ */ Symbol.for(TDequeueSymbolKey);
var tDequeueVariance = {
  _Out: (_2) => _2
};
var tEnqueueVariance = {
  _In: (_2) => _2
};

class TQueueImpl {
  ref;
  requestedCapacity;
  strategy;
  [TDequeueTypeId] = tDequeueVariance;
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(ref, requestedCapacity, strategy) {
    this.ref = ref;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
  }
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    return succeed13(queue.length);
  });
  isFull = /* @__PURE__ */ map19(this.size, (size14) => size14 === this.requestedCapacity);
  isEmpty = /* @__PURE__ */ map19(this.size, (size14) => size14 === 0);
  shutdown = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    unsafeSet2(this.ref, undefined, runtime5.journal);
    return void_6;
  });
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const queue = unsafeGet8(this.ref, journal);
    return queue === undefined;
  });
  awaitShutdown = /* @__PURE__ */ flatMap13(this.isShutdown, (isShutdown3) => isShutdown3 ? void_6 : retry5);
  offer(value) {
    return withSTMRuntime((runtime5) => {
      const queue = pipe(this.ref, unsafeGet8(runtime5.journal));
      if (queue === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      if (queue.length < this.requestedCapacity) {
        queue.push(value);
        unsafeSet2(this.ref, queue, runtime5.journal);
        return succeed13(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry5;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed13(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (queue.length === 0) {
            return succeed13(true);
          }
          queue.shift();
          queue.push(value);
          unsafeSet2(this.ref, queue, runtime5.journal);
          return succeed13(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return withSTMRuntime((runtime5) => {
      const as6 = Array.from(iterable);
      const queue = unsafeGet8(this.ref, runtime5.journal);
      if (queue === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      if (queue.length + as6.length <= this.requestedCapacity) {
        unsafeSet2(this.ref, [...queue, ...as6], runtime5.journal);
        return succeed13(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry5;
        }
        case OP_DROPPING_STRATEGY: {
          const forQueue = as6.slice(0, this.requestedCapacity - queue.length);
          unsafeSet2(this.ref, [...queue, ...forQueue], runtime5.journal);
          return succeed13(false);
        }
        case OP_SLIDING_STRATEGY: {
          const forQueue = as6.slice(0, this.requestedCapacity - queue.length);
          const toDrop = queue.length + forQueue.length - this.requestedCapacity;
          const newQueue = queue.slice(toDrop);
          unsafeSet2(this.ref, [...newQueue, ...forQueue], runtime5.journal);
          return succeed13(true);
        }
      }
    });
  }
  peek = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    if (queue.length === 0) {
      return retry5;
    }
    return succeed13(queue[0]);
  });
  peekOption = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    return succeed13(fromNullable(queue[0]));
  });
  take = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    if (queue.length === 0) {
      return retry5;
    }
    const dequeued = queue.shift();
    unsafeSet2(this.ref, queue, runtime5.journal);
    return succeed13(dequeued);
  });
  takeAll = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    unsafeSet2(this.ref, [], runtime5.journal);
    return succeed13(queue);
  });
  takeUpTo(max5) {
    return withSTMRuntime((runtime5) => {
      const queue = unsafeGet8(this.ref, runtime5.journal);
      if (queue === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      const [toTake, remaining] = splitAt2(unsafeFromArray(queue), max5);
      unsafeSet2(this.ref, Array.from(remaining), runtime5.journal);
      return succeed13(Array.from(toTake));
    });
  }
}

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/stm/tPubSub.js
var TPubSubSymbolKey = "effect/TPubSub";
var TPubSubTypeId = /* @__PURE__ */ Symbol.for(TPubSubSymbolKey);
var AbsentValue2 = /* @__PURE__ */ Symbol.for("effect/TPubSub/AbsentValue");
var makeNode2 = (head5, subscribers, tail) => ({
  head: head5,
  subscribers,
  tail
});

class TPubSubImpl {
  pubsubSize;
  publisherHead;
  publisherTail;
  requestedCapacity;
  strategy;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = {
    _A: (_2) => _2
  };
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.publisherTail = publisherTail;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const currentPublisherTail = unsafeGet8(this.publisherTail, journal);
    return currentPublisherTail === undefined;
  });
  awaitShutdown = /* @__PURE__ */ flatMap13(this.isShutdown, (isShutdown3) => isShutdown3 ? void_6 : retry5);
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const currentPublisherTail = unsafeGet8(this.publisherTail, runtime5.journal);
    if (currentPublisherTail === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    return succeed13(unsafeGet8(this.pubsubSize, runtime5.journal));
  });
  isEmpty = /* @__PURE__ */ map19(this.size, (size14) => size14 === 0);
  isFull = /* @__PURE__ */ map19(this.size, (size14) => size14 === this.capacity());
  offer(value) {
    return withSTMRuntime((runtime5) => {
      const currentPublisherTail = unsafeGet8(this.publisherTail, runtime5.journal);
      if (currentPublisherTail === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      const currentSubscriberCount = unsafeGet8(this.subscriberCount, runtime5.journal);
      if (currentSubscriberCount === 0) {
        return succeed13(true);
      }
      const currentPubSubSize = unsafeGet8(this.pubsubSize, runtime5.journal);
      if (currentPubSubSize < this.requestedCapacity) {
        const updatedPublisherTail = new TRefImpl(undefined);
        const updatedNode = makeNode2(value, currentSubscriberCount, updatedPublisherTail);
        unsafeSet2(currentPublisherTail, updatedNode, runtime5.journal);
        unsafeSet2(this.publisherTail, updatedPublisherTail, runtime5.journal);
        unsafeSet2(this.pubsubSize, currentPubSubSize + 1, runtime5.journal);
        return succeed13(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry5;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed13(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (this.requestedCapacity > 0) {
            let currentPublisherHead = unsafeGet8(this.publisherHead, runtime5.journal);
            let loop3 = true;
            while (loop3) {
              const node = unsafeGet8(currentPublisherHead, runtime5.journal);
              if (node === undefined) {
                return retry5;
              }
              const head5 = node.head;
              const tail = node.tail;
              if (head5 !== AbsentValue2) {
                const updatedNode2 = makeNode2(AbsentValue2, node.subscribers, node.tail);
                unsafeSet2(currentPublisherHead, updatedNode2, runtime5.journal);
                unsafeSet2(this.publisherHead, tail, runtime5.journal);
                loop3 = false;
              } else {
                currentPublisherHead = tail;
              }
            }
          }
          const updatedPublisherTail = new TRefImpl(undefined);
          const updatedNode = makeNode2(value, currentSubscriberCount, updatedPublisherTail);
          unsafeSet2(currentPublisherTail, updatedNode, runtime5.journal);
          unsafeSet2(this.publisherTail, updatedPublisherTail, runtime5.journal);
          return succeed13(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return map19(forEach9(iterable, (a) => this.offer(a)), every(identity));
  }
  shutdown = /* @__PURE__ */ effect3((journal) => {
    const currentPublisherTail = unsafeGet8(this.publisherTail, journal);
    if (currentPublisherTail !== undefined) {
      unsafeSet2(this.publisherTail, undefined, journal);
      const currentSubscribers = unsafeGet8(this.subscribers, journal);
      forEach3(currentSubscribers, (subscriber) => {
        unsafeSet2(subscriber, undefined, journal);
      });
      unsafeSet2(this.subscribers, empty8(), journal);
    }
  });
}

class TPubSubSubscriptionImpl {
  pubsubSize;
  publisherHead;
  requestedCapacity;
  subscriberHead;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = TPubSubTypeId;
  [TDequeueTypeId] = tDequeueVariance;
  constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.requestedCapacity = requestedCapacity;
    this.subscriberHead = subscriberHead;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const currentSubscriberHead = unsafeGet8(this.subscriberHead, journal);
    return currentSubscriberHead === undefined;
  });
  awaitShutdown = /* @__PURE__ */ flatMap13(this.isShutdown, (isShutdown3) => isShutdown3 ? void_6 : retry5);
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    let loop3 = true;
    let size14 = 0;
    while (loop3) {
      const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
      if (node === undefined) {
        loop3 = false;
      } else {
        const head5 = node.head;
        const tail = node.tail;
        if (head5 !== AbsentValue2) {
          size14 = size14 + 1;
          if (size14 >= Number.MAX_SAFE_INTEGER) {
            loop3 = false;
          }
        }
        currentSubscriberHead = tail;
      }
    }
    return succeed13(size14);
  });
  isEmpty = /* @__PURE__ */ map19(this.size, (size14) => size14 === 0);
  isFull = /* @__PURE__ */ map19(this.size, (size14) => size14 === this.capacity());
  peek = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    let value = AbsentValue2;
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
      if (node === undefined) {
        return retry5;
      }
      const head5 = node.head;
      const tail = node.tail;
      if (head5 !== AbsentValue2) {
        value = head5;
        loop3 = false;
      } else {
        currentSubscriberHead = tail;
      }
    }
    return succeed13(value);
  });
  peekOption = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    let value = none2();
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
      if (node === undefined) {
        value = none2();
        loop3 = false;
      } else {
        const head5 = node.head;
        const tail = node.tail;
        if (head5 !== AbsentValue2) {
          value = some2(head5);
          loop3 = false;
        } else {
          currentSubscriberHead = tail;
        }
      }
    }
    return succeed13(value);
  });
  shutdown = /* @__PURE__ */ effect3((journal) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, journal);
    if (currentSubscriberHead !== undefined) {
      unsafeSet2(this.subscriberHead, undefined, journal);
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet8(currentSubscriberHead, journal);
        if (node === undefined) {
          loop3 = false;
        } else {
          const head5 = node.head;
          const tail = node.tail;
          if (head5 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size14 = unsafeGet8(this.pubsubSize, journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
              unsafeSet2(this.publisherHead, tail, journal);
              unsafeSet2(this.pubsubSize, size14 - 1, journal);
            } else {
              const updatedNode = makeNode2(head5, subscribers - 1, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
            }
          }
          currentSubscriberHead = tail;
        }
      }
      const currentSubscriberCount = unsafeGet8(this.subscriberCount, journal);
      unsafeSet2(this.subscriberCount, currentSubscriberCount - 1, journal);
      unsafeSet2(this.subscribers, remove4(unsafeGet8(this.subscribers, journal), this.subscriberHead), journal);
    }
  });
  take = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    let value = AbsentValue2;
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
      if (node === undefined) {
        return retry5;
      }
      const head5 = node.head;
      const tail = node.tail;
      if (head5 !== AbsentValue2) {
        const subscribers = node.subscribers;
        if (subscribers === 1) {
          const size14 = unsafeGet8(this.pubsubSize, runtime5.journal);
          const updatedNode = makeNode2(AbsentValue2, 0, tail);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
          unsafeSet2(this.publisherHead, tail, runtime5.journal);
          unsafeSet2(this.pubsubSize, size14 - 1, runtime5.journal);
        } else {
          const updatedNode = makeNode2(head5, subscribers - 1, tail);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
        }
        unsafeSet2(this.subscriberHead, tail, runtime5.journal);
        value = head5;
        loop3 = false;
      } else {
        currentSubscriberHead = tail;
      }
    }
    return succeed13(value);
  });
  takeAll = /* @__PURE__ */ this.takeUpTo(Number.POSITIVE_INFINITY);
  takeUpTo(max5) {
    return withSTMRuntime((runtime5) => {
      let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
      if (currentSubscriberHead === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      const builder = [];
      let n = 0;
      while (n !== max5) {
        const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
        if (node === undefined) {
          n = max5;
        } else {
          const head5 = node.head;
          const tail = node.tail;
          if (head5 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size14 = unsafeGet8(this.pubsubSize, runtime5.journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
              unsafeSet2(this.publisherHead, tail, runtime5.journal);
              unsafeSet2(this.pubsubSize, size14 - 1, runtime5.journal);
            } else {
              const updatedNode = makeNode2(head5, subscribers - 1, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
            }
            builder.push(head5);
            n = n + 1;
          }
          currentSubscriberHead = tail;
        }
      }
      unsafeSet2(this.subscriberHead, currentSubscriberHead, runtime5.journal);
      return succeed13(builder);
    });
  }
}
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/ConfigError.js
var InvalidData2 = InvalidData;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/redacted.js
var RedactedSymbolKey = "effect/Redacted";
var redactedRegistry = /* @__PURE__ */ globalValue("effect/Redacted/redactedRegistry", () => new WeakMap);
var RedactedTypeId = /* @__PURE__ */ Symbol.for(RedactedSymbolKey);
var proto12 = {
  [RedactedTypeId]: {
    _A: (_2) => _2
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return "<redacted>";
  },
  toJSON() {
    return "<redacted>";
  },
  [NodeInspectSymbol]() {
    return "<redacted>";
  },
  [symbol]() {
    return pipe(hash(RedactedSymbolKey), combine(hash(redactedRegistry.get(this))), cached(this));
  },
  [symbol2](that) {
    return isRedacted(that) && equals(redactedRegistry.get(this), redactedRegistry.get(that));
  }
};
var isRedacted = (u3) => hasProperty(u3, RedactedTypeId);
var make53 = (value) => {
  const redacted = Object.create(proto12);
  redactedRegistry.set(redacted, value);
  return redacted;
};
var value = (self2) => {
  if (redactedRegistry.has(self2)) {
    return redactedRegistry.get(self2);
  } else {
    throw new Error("Unable to get redacted value");
  }
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/secret.js
var SecretSymbolKey = "effect/Secret";
var SecretTypeId = /* @__PURE__ */ Symbol.for(SecretSymbolKey);
var SecretProto = {
  ...proto12,
  [SecretTypeId]: SecretTypeId
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/config.js
var ConfigSymbolKey = "effect/Config";
var ConfigTypeId = /* @__PURE__ */ Symbol.for(ConfigSymbolKey);
var configVariance = {
  _A: (_2) => _2
};
var proto13 = {
  ...CommitPrototype,
  [ConfigTypeId]: configVariance,
  commit() {
    return config(this);
  }
};
var mapOrFail = /* @__PURE__ */ dual(2, (self2, f) => {
  const mapOrFail2 = Object.create(proto13);
  mapOrFail2._tag = OP_MAP_OR_FAIL;
  mapOrFail2.original = self2;
  mapOrFail2.mapOrFail = f;
  return mapOrFail2;
});
var nested2 = /* @__PURE__ */ dual(2, (self2, name2) => {
  const nested3 = Object.create(proto13);
  nested3._tag = OP_NESTED;
  nested3.name = name2;
  nested3.config = self2;
  return nested3;
});
var primitive = (description, parse3) => {
  const primitive2 = Object.create(proto13);
  primitive2._tag = OP_PRIMITIVE;
  primitive2.description = description;
  primitive2.parse = parse3;
  return primitive2;
};
var string4 = (name2) => {
  const config2 = primitive("a text property", right2);
  return name2 === undefined ? config2 : nested2(config2, name2);
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Config.js
var mapOrFail2 = mapOrFail;
var string5 = string4;
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/DateTime.js
var isDateTime2 = isDateTime;
var isTimeZoneOffset2 = isTimeZoneOffset;
var isTimeZoneNamed2 = isTimeZoneNamed;
var isUtc2 = isUtc;
var isZoned2 = isZoned;
var Equivalence5 = Equivalence3;
var unsafeFromDate2 = unsafeFromDate;
var unsafeMake10 = unsafeMake9;
var unsafeMakeZoned2 = unsafeMakeZoned;
var makeZonedFromString2 = makeZonedFromString;
var zoneUnsafeMakeNamed2 = zoneUnsafeMakeNamed;
var zoneMakeOffset2 = zoneMakeOffset;
var zoneFromString2 = zoneFromString;
var zoneToString2 = zoneToString;
var toDateUtc2 = toDateUtc;
var toEpochMillis2 = toEpochMillis;
var formatIso2 = formatIso;
var formatIsoZoned2 = formatIsoZoned;
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/encoding/common.js
var DecodeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Encoding/errors/Decode");
var DecodeException = (input, message) => {
  const out2 = {
    _tag: "DecodeException",
    [DecodeExceptionTypeId]: DecodeExceptionTypeId,
    input
  };
  if (isString(message)) {
    out2.message = message;
  }
  return out2;
};
var EncodeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Encoding/errors/Encode");
var EncodeException = (input, message) => {
  const out2 = {
    _tag: "EncodeException",
    [EncodeExceptionTypeId]: EncodeExceptionTypeId,
    input
  };
  if (isString(message)) {
    out2.message = message;
  }
  return out2;
};
var encoder = /* @__PURE__ */ new TextEncoder;
var decoder = /* @__PURE__ */ new TextDecoder;

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/encoding/base64.js
var encode = (bytes) => {
  const length3 = bytes.length;
  let result = "";
  let i2;
  for (i2 = 2;i2 < length3; i2 += 3) {
    result += base64abc[bytes[i2 - 2] >> 2];
    result += base64abc[(bytes[i2 - 2] & 3) << 4 | bytes[i2 - 1] >> 4];
    result += base64abc[(bytes[i2 - 1] & 15) << 2 | bytes[i2] >> 6];
    result += base64abc[bytes[i2] & 63];
  }
  if (i2 === length3 + 1) {
    result += base64abc[bytes[i2 - 2] >> 2];
    result += base64abc[(bytes[i2 - 2] & 3) << 4];
    result += "==";
  }
  if (i2 === length3) {
    result += base64abc[bytes[i2 - 2] >> 2];
    result += base64abc[(bytes[i2 - 2] & 3) << 4 | bytes[i2 - 1] >> 4];
    result += base64abc[(bytes[i2 - 1] & 15) << 2];
    result += "=";
  }
  return result;
};
var decode2 = (str) => {
  const stripped = stripCrlf(str);
  const length3 = stripped.length;
  if (length3 % 4 !== 0) {
    return left2(DecodeException(stripped, `Length must be a multiple of 4, but is ${length3}`));
  }
  const index2 = stripped.indexOf("=");
  if (index2 !== -1 && (index2 < length3 - 2 || index2 === length3 - 2 && stripped[length3 - 1] !== "=")) {
    return left2(DecodeException(stripped, "Found a '=' character, but it is not at the end"));
  }
  try {
    const missingOctets = stripped.endsWith("==") ? 2 : stripped.endsWith("=") ? 1 : 0;
    const result = new Uint8Array(3 * (length3 / 4) - missingOctets);
    for (let i2 = 0, j4 = 0;i2 < length3; i2 += 4, j4 += 3) {
      const buffer2 = getBase64Code(stripped.charCodeAt(i2)) << 18 | getBase64Code(stripped.charCodeAt(i2 + 1)) << 12 | getBase64Code(stripped.charCodeAt(i2 + 2)) << 6 | getBase64Code(stripped.charCodeAt(i2 + 3));
      result[j4] = buffer2 >> 16;
      result[j4 + 1] = buffer2 >> 8 & 255;
      result[j4 + 2] = buffer2 & 255;
    }
    return right2(result);
  } catch (e) {
    return left2(DecodeException(stripped, e instanceof Error ? e.message : "Invalid input"));
  }
};
var stripCrlf = (str) => str.replace(/[\n\r]/g, "");
function getBase64Code(charCode) {
  if (charCode >= base64codes.length) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  const code = base64codes[charCode];
  if (code === 255) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  return code;
}
var base64abc = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];
var base64codes = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/encoding/base64Url.js
var encode2 = (data) => encode(data).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
var decode3 = (str) => {
  const stripped = stripCrlf(str);
  const length3 = stripped.length;
  if (length3 % 4 === 1) {
    return left2(DecodeException(stripped, `Length should be a multiple of 4, but is ${length3}`));
  }
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(stripped)) {
    return left2(DecodeException(stripped, "Invalid input"));
  }
  let sanitized = length3 % 4 === 2 ? `${stripped}==` : length3 % 4 === 3 ? `${stripped}=` : stripped;
  sanitized = sanitized.replace(/-/g, "+").replace(/_/g, "/");
  return decode2(sanitized);
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/encoding/hex.js
var encode3 = (bytes) => {
  let result = "";
  for (let i2 = 0;i2 < bytes.length; ++i2) {
    result += bytesToHex[bytes[i2]];
  }
  return result;
};
var decode4 = (str) => {
  const bytes = new TextEncoder().encode(str);
  if (bytes.length % 2 !== 0) {
    return left2(DecodeException(str, `Length must be a multiple of 2, but is ${bytes.length}`));
  }
  try {
    const length3 = bytes.length / 2;
    const result = new Uint8Array(length3);
    for (let i2 = 0;i2 < length3; i2++) {
      const a = fromHexChar(bytes[i2 * 2]);
      const b3 = fromHexChar(bytes[i2 * 2 + 1]);
      result[i2] = a << 4 | b3;
    }
    return right2(result);
  } catch (e) {
    return left2(DecodeException(str, e instanceof Error ? e.message : "Invalid input"));
  }
};
var bytesToHex = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var fromHexChar = (byte) => {
  if (48 <= byte && byte <= 57) {
    return byte - 48;
  }
  if (97 <= byte && byte <= 102) {
    return byte - 97 + 10;
  }
  if (65 <= byte && byte <= 70) {
    return byte - 65 + 10;
  }
  throw new TypeError("Invalid input");
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Encoding.js
var encodeBase64 = (input) => typeof input === "string" ? encode(encoder.encode(input)) : encode(input);
var decodeBase64 = (str) => decode2(str);
var decodeBase64String = (str) => map(decodeBase64(str), (_2) => decoder.decode(_2));
var encodeBase64Url = (input) => typeof input === "string" ? encode2(encoder.encode(input)) : encode2(input);
var decodeBase64Url = (str) => decode3(str);
var decodeBase64UrlString = (str) => map(decodeBase64Url(str), (_2) => decoder.decode(_2));
var encodeHex = (input) => typeof input === "string" ? encode3(encoder.encode(input)) : encode3(input);
var decodeHex = (str) => decode4(str);
var decodeHexString = (str) => map(decodeHex(str), (_2) => decoder.decode(_2));
var encodeUriComponent = (str) => try_({
  try: () => encodeURIComponent(str),
  catch: (e) => EncodeException2(str, e instanceof Error ? e.message : "Invalid input")
});
var decodeUriComponent = (str) => try_({
  try: () => decodeURIComponent(str),
  catch: (e) => DecodeException2(str, e instanceof Error ? e.message : "Invalid input")
});
var DecodeException2 = DecodeException;
var EncodeException2 = EncodeException;
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/ExecutionPlan.js
var TypeId21 = TypeId19;
var Proto3 = {
  [TypeId21]: TypeId21,
  get withRequirements() {
    const self2 = this;
    return contextWith2((context6) => makeProto(self2.steps.map((step4) => ({
      ...step4,
      provide: isLayer2(step4.provide) ? provide3(step4.provide, succeedContext2(context6)) : step4.provide
    }))));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeProto = (steps) => {
  const self2 = Object.create(Proto3);
  self2.steps = steps;
  return self2;
};
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/FiberHandle.js
var TypeId22 = /* @__PURE__ */ Symbol.for("effect/FiberHandle");
var Proto4 = {
  [TypeId22]: TypeId22,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberHandle",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/FiberMap.js
var TypeId23 = /* @__PURE__ */ Symbol.for("effect/FiberMap");
var Proto5 = {
  [TypeId23]: TypeId23,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/FiberSet.js
var TypeId24 = /* @__PURE__ */ Symbol.for("effect/FiberSet");
var Proto6 = {
  [TypeId24]: TypeId24,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/ParseResult.js
class Pointer {
  path;
  actual;
  issue;
  _tag = "Pointer";
  constructor(path, actual, issue) {
    this.path = path;
    this.actual = actual;
    this.issue = issue;
  }
}

class Unexpected {
  actual;
  message;
  _tag = "Unexpected";
  constructor(actual, message) {
    this.actual = actual;
    this.message = message;
  }
}

class Missing {
  ast;
  message;
  _tag = "Missing";
  actual = undefined;
  constructor(ast, message) {
    this.ast = ast;
    this.message = message;
  }
}

class Composite2 {
  ast;
  actual;
  issues;
  output;
  _tag = "Composite";
  constructor(ast, actual, issues, output) {
    this.ast = ast;
    this.actual = actual;
    this.issues = issues;
    this.output = output;
  }
}

class Refinement2 {
  ast;
  actual;
  kind;
  issue;
  _tag = "Refinement";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
}

class Transformation2 {
  ast;
  actual;
  kind;
  issue;
  _tag = "Transformation";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
}

class Type2 {
  ast;
  actual;
  message;
  _tag = "Type";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
}

class Forbidden {
  ast;
  actual;
  message;
  _tag = "Forbidden";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
}
var ParseErrorTypeId = /* @__PURE__ */ Symbol.for("effect/Schema/ParseErrorTypeId");
class ParseError extends (/* @__PURE__ */ TaggedError("ParseError")) {
  [ParseErrorTypeId] = ParseErrorTypeId;
  get message() {
    return this.toString();
  }
  toString() {
    return TreeFormatter.formatIssueSync(this.issue);
  }
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}
var parseError = (issue) => new ParseError({
  issue
});
var succeed15 = right2;
var fail16 = left2;
var _try = try_;
var fromOption4 = fromOption2;
var isEither4 = isEither2;
var flatMap16 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither4(self2) ? match(self2, {
    onLeft: left2,
    onRight: f
  }) : flatMap10(self2, f);
});
var map23 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither4(self2) ? map(self2, f) : map13(self2, f);
});
var mapError6 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither4(self2) ? mapLeft(self2, f) : mapError3(self2, f);
});
var mapBoth6 = /* @__PURE__ */ dual(2, (self2, options) => {
  return isEither4(self2) ? mapBoth(self2, {
    onLeft: options.onFailure,
    onRight: options.onSuccess
  }) : mapBoth3(self2, options);
});
var orElse10 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither4(self2) ? match(self2, {
    onLeft: f,
    onRight: right2
  }) : catchAll3(self2, f);
});
var mergeInternalOptions = (options, overrideOptions) => {
  if (overrideOptions === undefined || isNumber(overrideOptions)) {
    return options;
  }
  if (options === undefined) {
    return overrideOptions;
  }
  return {
    ...options,
    ...overrideOptions
  };
};
var getEither = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (u3, overrideOptions) => parser(u3, mergeInternalOptions(options, overrideOptions));
};
var getSync = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError);
};
var getOption3 = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => getRight2(parser(input, overrideOptions));
};
var getEffect = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (input, overrideOptions) => parser(input, {
    ...mergeInternalOptions(options, overrideOptions),
    isEffectAllowed: true
  });
};
var decodeUnknownSync = (schema, options) => getSync(schema.ast, true, options);
var decodeUnknownOption = (schema, options) => getOption3(schema.ast, true, options);
var decodeUnknownEither = (schema, options) => getEither(schema.ast, true, options);
var decodeUnknown2 = (schema, options) => getEffect(schema.ast, true, options);
var encodeUnknownSync = (schema, options) => getSync(schema.ast, false, options);
var encodeUnknownOption = (schema, options) => getOption3(schema.ast, false, options);
var encodeUnknownEither = (schema, options) => getEither(schema.ast, false, options);
var encodeUnknown = (schema, options) => getEffect(schema.ast, false, options);
var decodeSync = decodeUnknownSync;
var decodeOption = decodeUnknownOption;
var validateSync = (schema, options) => getSync(typeAST(schema.ast), true, options);
var validateOption = (schema, options) => getOption3(typeAST(schema.ast), true, options);
var validateEither = (schema, options) => getEither(typeAST(schema.ast), true, options);
var validate4 = (schema, options) => getEffect(typeAST(schema.ast), true, options);
var is2 = (schema, options) => {
  const parser = goMemo(typeAST(schema.ast), true);
  return (u3, overrideOptions) => isRight2(parser(u3, {
    exact: true,
    ...mergeInternalOptions(options, overrideOptions)
  }));
};
var asserts = (schema, options) => {
  const parser = goMemo(typeAST(schema.ast), true);
  return (u3, overrideOptions) => {
    const result = parser(u3, {
      exact: true,
      ...mergeInternalOptions(options, overrideOptions)
    });
    if (isLeft2(result)) {
      throw parseError(result.left);
    }
  };
};
var encodeSync = encodeUnknownSync;
var encodeOption = encodeUnknownOption;
var decodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/decodeMemoMap"), () => new WeakMap);
var encodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/encodeMemoMap"), () => new WeakMap);
var goMemo = (ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
  const memo = memoMap.get(ast);
  if (memo) {
    return memo;
  }
  const raw = go(ast, isDecoding);
  const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
  const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i2, options) => raw(i2, mergeInternalOptions(options, parseOptionsAnnotation.value)) : raw;
  const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
  const parser = isDecoding && isSome2(decodingFallbackAnnotation) ? (i2, options) => handleForbidden(orElse10(parserWithOptions(i2, options), decodingFallbackAnnotation.value), ast, i2, options) : parserWithOptions;
  memoMap.set(ast, parser);
  return parser;
};
var getConcurrency = (ast) => getOrUndefined(getConcurrencyAnnotation(ast));
var getBatching = (ast) => getOrUndefined(getBatchingAnnotation(ast));
var go = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement": {
      if (isDecoding) {
        const from = goMemo(ast.from, true);
        return (i2, options) => {
          options = options ?? defaultParseOption;
          const allErrors = options?.errors === "all";
          const result = flatMap16(orElse10(from(i2, options), (ef) => {
            const issue = new Refinement2(ast, i2, "From", ef);
            if (allErrors && hasStableFilter(ast) && isComposite2(ef)) {
              return match2(ast.filter(i2, options, ast), {
                onNone: () => left2(issue),
                onSome: (ep) => left2(new Composite2(ast, i2, [issue, new Refinement2(ast, i2, "Predicate", ep)]))
              });
            }
            return left2(issue);
          }), (a) => match2(ast.filter(a, options, ast), {
            onNone: () => right2(a),
            onSome: (ep) => left2(new Refinement2(ast, i2, "Predicate", ep))
          }));
          return handleForbidden(result, ast, i2, options);
        };
      } else {
        const from = goMemo(typeAST(ast), true);
        const to = goMemo(dropRightRefinement(ast.from), false);
        return (i2, options) => handleForbidden(flatMap16(from(i2, options), (a) => to(a, options)), ast, i2, options);
      }
    }
    case "Transformation": {
      const transform2 = getFinalTransformation(ast.transformation, isDecoding);
      const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
      const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
      return (i2, options) => handleForbidden(flatMap16(mapError6(from(i2, options), (e) => new Transformation2(ast, i2, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap16(mapError6(transform2(a, options ?? defaultParseOption, ast, i2), (e) => new Transformation2(ast, i2, "Transformation", e)), (i22) => mapError6(to(i22, options), (e) => new Transformation2(ast, i2, isDecoding ? "Type" : "Encoded", e)))), ast, i2, options);
    }
    case "Declaration": {
      const parse3 = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
      return (i2, options) => handleForbidden(parse3(i2, options ?? defaultParseOption, ast), ast, i2, options);
    }
    case "Literal":
      return fromRefinement(ast, (u3) => u3 === ast.literal);
    case "UniqueSymbol":
      return fromRefinement(ast, (u3) => u3 === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement(ast, isUndefined);
    case "NeverKeyword":
      return fromRefinement(ast, isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
    case "VoidKeyword":
      return right2;
    case "StringKeyword":
      return fromRefinement(ast, isString);
    case "NumberKeyword":
      return fromRefinement(ast, isNumber);
    case "BooleanKeyword":
      return fromRefinement(ast, isBoolean);
    case "BigIntKeyword":
      return fromRefinement(ast, isBigInt);
    case "SymbolKeyword":
      return fromRefinement(ast, isSymbol);
    case "ObjectKeyword":
      return fromRefinement(ast, isObject);
    case "Enums":
      return fromRefinement(ast, (u3) => ast.enums.some(([_2, value2]) => value2 === u3));
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp(ast);
      return fromRefinement(ast, (u3) => isString(u3) && regex.test(u3));
    }
    case "TupleType": {
      const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
      const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
      let requiredTypes = ast.elements.filter((e) => !e.isOptional);
      if (ast.rest.length > 0) {
        requiredTypes = requiredTypes.concat(ast.rest.slice(1));
      }
      const requiredLen = requiredTypes.length;
      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_2, i2) => i2).join(" | ") : "never";
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options) => {
        if (!isArray(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const output = [];
        const len = input.length;
        for (let i3 = len;i3 <= requiredLen - 1; i3++) {
          const e = new Pointer(i3, input, new Missing(requiredTypes[i3 - len]));
          if (allErrors) {
            es.push([stepKey++, e]);
            continue;
          } else {
            return left2(new Composite2(ast, input, e, output));
          }
        }
        if (ast.rest.length === 0) {
          for (let i3 = ast.elements.length;i3 <= len - 1; i3++) {
            const e = new Pointer(i3, input, new Unexpected(input[i3], `is unexpected, expected: ${expectedIndexes}`));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite2(ast, input, e, output));
            }
          }
        }
        let i2 = 0;
        let queue = undefined;
        for (;i2 < elements.length; i2++) {
          if (len < i2 + 1) {
            if (ast.elements[i2].isOptional) {
              continue;
            }
          } else {
            const parser = elements[i2];
            const te4 = parser(input[i2], options);
            if (isEither4(te4)) {
              if (isLeft2(te4)) {
                const e = new Pointer(i2, input, te4.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              }
              output.push([stepKey++, te4.right]);
            } else {
              const nk = stepKey++;
              const index2 = i2;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap10(either3(te4), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index2, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                }
                output2.push([nk, t.right]);
                return _void;
              }));
            }
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head6, ...tail] = rest;
          for (;i2 < len - tail.length; i2++) {
            const te4 = head6(input[i2], options);
            if (isEither4(te4)) {
              if (isLeft2(te4)) {
                const e = new Pointer(i2, input, te4.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              } else {
                output.push([stepKey++, te4.right]);
              }
            } else {
              const nk = stepKey++;
              const index2 = i2;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap10(either3(te4), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index2, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                } else {
                  output2.push([nk, t.right]);
                  return _void;
                }
              }));
            }
          }
          for (let j4 = 0;j4 < tail.length; j4++) {
            i2 += j4;
            if (len < i2 + 1) {
              continue;
            } else {
              const te4 = tail[j4](input[i2], options);
              if (isEither4(te4)) {
                if (isLeft2(te4)) {
                  const e = new Pointer(i2, input, te4.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output)));
                  }
                }
                output.push([stepKey++, te4.right]);
              } else {
                const nk = stepKey++;
                const index2 = i2;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap10(either3(te4), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index2, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                    }
                  }
                  output2.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => isNonEmptyArray2(es2) ? left2(new Composite2(ast, input, sortByIndex(es2), sortByIndex(output2))) : right2(sortByIndex(output2));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es),
              output: copy(output)
            };
            return flatMap10(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          output,
          es
        });
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return fromRefinement(ast, isNotNullable);
      }
      const propertySignatures = [];
      const expectedKeysMap = {};
      const expectedKeys = [];
      for (const ps of ast.propertySignatures) {
        propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
        expectedKeysMap[ps.name] = null;
        expectedKeys.push(ps.name);
      }
      const indexSignatures = ast.indexSignatures.map((is3) => [goMemo(is3.parameter, isDecoding), goMemo(is3.type, isDecoding), is3.parameter]);
      const expectedAST = Union.make(ast.indexSignatures.map((is3) => is3.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal(key))));
      const expected = goMemo(expectedAST, isDecoding);
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options) => {
        if (!isRecord(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const onExcessPropertyError = options?.onExcessProperty === "error";
        const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
        const output = {};
        let inputKeys;
        if (onExcessPropertyError || onExcessPropertyPreserve) {
          inputKeys = ownKeys(input);
          for (const key of inputKeys) {
            const te4 = expected(key, options);
            if (isEither4(te4) && isLeft2(te4)) {
              if (onExcessPropertyError) {
                const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output));
                }
              } else {
                output[key] = input[key];
              }
            }
          }
        }
        let queue = undefined;
        const isExact = options?.exact === true;
        for (let i2 = 0;i2 < propertySignatures.length; i2++) {
          const ps = propertySignatures[i2][1];
          const name2 = ps.name;
          const hasKey = Object.prototype.hasOwnProperty.call(input, name2);
          if (!hasKey) {
            if (ps.isOptional) {
              continue;
            } else if (isExact) {
              const e = new Pointer(name2, input, new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
          }
          const parser = propertySignatures[i2][0];
          const te4 = parser(input[name2], options);
          if (isEither4(te4)) {
            if (isLeft2(te4)) {
              const e = new Pointer(name2, input, hasKey ? te4.left : new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
            output[name2] = te4.right;
          } else {
            const nk = stepKey++;
            const index2 = name2;
            if (!queue) {
              queue = [];
            }
            queue.push(({
              es: es2,
              output: output2
            }) => flatMap10(either3(te4), (t) => {
              if (isLeft2(t)) {
                const e = new Pointer(index2, input, hasKey ? t.left : new Missing(ps));
                if (allErrors) {
                  es2.push([nk, e]);
                  return _void;
                } else {
                  return left2(new Composite2(ast, input, e, output2));
                }
              }
              output2[index2] = t.right;
              return _void;
            }));
          }
        }
        for (let i2 = 0;i2 < indexSignatures.length; i2++) {
          const indexSignature = indexSignatures[i2];
          const parameter = indexSignature[0];
          const type = indexSignature[1];
          const keys5 = getKeysForIndexSignature(input, indexSignature[2]);
          for (const key of keys5) {
            const keu = parameter(key, options);
            if (isEither4(keu) && isRight2(keu)) {
              const vpr = type(input[key], options);
              if (isEither4(vpr)) {
                if (isLeft2(vpr)) {
                  const e = new Pointer(key, input, vpr.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, output));
                  }
                } else {
                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                    output[key] = vpr.right;
                  }
                }
              } else {
                const nk = stepKey++;
                const index2 = key;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap10(either3(vpr), (tv) => {
                  if (isLeft2(tv)) {
                    const e = new Pointer(index2, input, tv.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, output2));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output2[key] = tv.right;
                    }
                    return _void;
                  }
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => {
          if (isNonEmptyArray2(es2)) {
            return left2(new Composite2(ast, input, sortByIndex(es2), output2));
          }
          if (options?.propertyOrder === "original") {
            const keys5 = inputKeys || ownKeys(input);
            for (const name2 of expectedKeys) {
              if (keys5.indexOf(name2) === -1) {
                keys5.push(name2);
              }
            }
            const out2 = {};
            for (const key of keys5) {
              if (Object.prototype.hasOwnProperty.call(output2, key)) {
                out2[key] = output2[key];
              }
            }
            return right2(out2);
          }
          return right2(output2);
        };
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es),
              output: Object.assign({}, output)
            };
            return flatMap10(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          es,
          output
        });
      };
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, isDecoding);
      const ownKeys2 = ownKeys(searchTree.keys);
      const ownKeysLen = ownKeys2.length;
      const astTypesLen = ast.types.length;
      const map24 = new Map;
      for (let i2 = 0;i2 < astTypesLen; i2++) {
        map24.set(ast.types[i2], goMemo(ast.types[i2], isDecoding));
      }
      const concurrency = getConcurrency(ast) ?? 1;
      const batching = getBatching(ast);
      return (input, options) => {
        const es = [];
        let stepKey = 0;
        let candidates = [];
        if (ownKeysLen > 0) {
          if (isRecordOrArray(input)) {
            for (let i2 = 0;i2 < ownKeysLen; i2++) {
              const name2 = ownKeys2[i2];
              const buckets = searchTree.keys[name2].buckets;
              if (Object.prototype.hasOwnProperty.call(input, name2)) {
                const literal2 = String(input[name2]);
                if (Object.prototype.hasOwnProperty.call(buckets, literal2)) {
                  candidates = candidates.concat(buckets[literal2]);
                } else {
                  const {
                    candidates: candidates2,
                    literals
                  } = searchTree.keys[name2];
                  const literalsUnion = Union.make(literals);
                  const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([new PropertySignature(name2, literalsUnion, false, true)], []) : Union.make(candidates2);
                  es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name2, input, new Type2(literalsUnion, input[name2])))]);
                }
              } else {
                const {
                  candidates: candidates2,
                  literals
                } = searchTree.keys[name2];
                const fakePropertySignature = new PropertySignature(name2, Union.make(literals), false, true);
                const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates2);
                es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name2, input, new Missing(fakePropertySignature)))]);
              }
            }
          } else {
            const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
            es.push([stepKey++, new Type2(errorAst, input)]);
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        let queue = undefined;
        for (let i2 = 0;i2 < candidates.length; i2++) {
          const candidate = candidates[i2];
          const pr = map24.get(candidate)(input, options);
          if (isEither4(pr) && (!queue || queue.length === 0)) {
            if (isRight2(pr)) {
              return pr;
            } else {
              es.push([stepKey++, pr.left]);
            }
          } else {
            const nk = stepKey++;
            if (!queue) {
              queue = [];
            }
            queue.push((state) => suspend3(() => {
              if ("finalResult" in state) {
                return _void;
              } else {
                return flatMap10(either3(pr), (t) => {
                  if (isRight2(t)) {
                    state.finalResult = t;
                  } else {
                    state.es.push([nk, t.left]);
                  }
                  return _void;
                });
              }
            }));
          }
        }
        const computeResult = (es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite2(ast, input, sortByIndex(es2))) : left2(new Type2(ast, input));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es)
            };
            return flatMap10(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => {
              if ("finalResult" in state) {
                return state.finalResult;
              }
              return computeResult(state.es);
            });
          });
        }
        return computeResult(es);
      };
    }
    case "Suspend": {
      const get17 = memoizeThunk(() => goMemo(annotations(ast.f(), ast.annotations), isDecoding));
      return (a, options) => get17()(a, options);
    }
  }
};
var fromRefinement = (ast, refinement) => (u3) => refinement(u3) ? right2(u3) : left2(new Type2(ast, u3));
var getLiterals = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return getLiterals(annotation.value, isDecoding);
      }
      break;
    }
    case "TypeLiteral": {
      const out2 = [];
      for (let i2 = 0;i2 < ast.propertySignatures.length; i2++) {
        const propertySignature = ast.propertySignatures[i2];
        const type = isDecoding ? encodedAST(propertySignature.type) : typeAST(propertySignature.type);
        if (isLiteral(type) && !propertySignature.isOptional) {
          out2.push([propertySignature.name, type]);
        }
      }
      return out2;
    }
    case "TupleType": {
      const out2 = [];
      for (let i2 = 0;i2 < ast.elements.length; i2++) {
        const element = ast.elements[i2];
        const type = isDecoding ? encodedAST(element.type) : typeAST(element.type);
        if (isLiteral(type) && !element.isOptional) {
          out2.push([i2, type]);
        }
      }
      return out2;
    }
    case "Refinement":
      return getLiterals(ast.from, isDecoding);
    case "Suspend":
      return getLiterals(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
};
var getSearchTree = (members, isDecoding) => {
  const keys5 = {};
  const otherwise = [];
  const candidates = [];
  for (let i2 = 0;i2 < members.length; i2++) {
    const member = members[i2];
    const tags = getLiterals(member, isDecoding);
    if (tags.length > 0) {
      candidates.push(member);
      for (let j4 = 0;j4 < tags.length; j4++) {
        const [key, literal2] = tags[j4];
        const hash2 = String(literal2.literal);
        keys5[key] = keys5[key] || {
          buckets: {},
          literals: [],
          candidates: []
        };
        const buckets = keys5[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash2)) {
          if (j4 < tags.length - 1) {
            continue;
          }
          buckets[hash2].push(member);
          keys5[key].literals.push(literal2);
          keys5[key].candidates.push(member);
        } else {
          buckets[hash2] = [member];
          keys5[key].literals.push(literal2);
          keys5[key].candidates.push(member);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys: keys5,
    otherwise,
    candidates
  };
};
var dropRightRefinement = (ast) => isRefinement(ast) ? dropRightRefinement(ast.from) : ast;
var handleForbidden = (effect4, ast, actual, options) => {
  if (options?.isEffectAllowed === true) {
    return effect4;
  }
  if (isEither4(effect4)) {
    return effect4;
  }
  const scheduler = new SyncScheduler;
  const fiber = runFork2(effect4, {
    scheduler
  });
  scheduler.flush();
  const exit3 = fiber.unsafePoll();
  if (exit3) {
    if (isSuccess(exit3)) {
      return right2(exit3.value);
    }
    const cause3 = exit3.cause;
    if (isFailType2(cause3)) {
      return left2(cause3.error);
    }
    return left2(new Forbidden(ast, actual, pretty2(cause3)));
  }
  return left2(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
};
var compare = ([a], [b3]) => a > b3 ? 1 : a < b3 ? -1 : 0;
function sortByIndex(es) {
  return es.sort(compare).map((t) => t[1]);
}
var getFinalTransformation = (transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return right2;
    case "TypeLiteralTransformation":
      return (input) => {
        let out2 = right2(input);
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation2 = isDecoding ? pst.decode : pst.encode;
          const f = (input2) => {
            const o3 = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some2(input2[from]) : none2());
            delete input2[from];
            if (isSome2(o3)) {
              input2[to] = o3.value;
            }
            return input2;
          };
          out2 = map23(out2, f);
        }
        return out2;
      };
  }
};
var makeTree = (value2, forest = []) => ({
  value: value2,
  forest
});
var TreeFormatter = {
  formatIssue: (issue) => map23(formatTree(issue), drawTree),
  formatIssueSync: (issue) => {
    const e = TreeFormatter.formatIssue(issue);
    return isEither4(e) ? getOrThrow(e) : runSync(e);
  },
  formatError: (error2) => TreeFormatter.formatIssue(error2.issue),
  formatErrorSync: (error2) => TreeFormatter.formatIssueSync(error2.issue)
};
var drawTree = (tree) => tree.value + draw(`
`, tree.forest);
var draw = (indentation, forest) => {
  let r2 = "";
  const len = forest.length;
  let tree;
  for (let i2 = 0;i2 < len; i2++) {
    tree = forest[i2];
    const isLast = i2 === len - 1;
    r2 += indentation + (isLast ? "" : "") + " " + tree.value;
    r2 += draw(indentation + (len > 1 && !isLast ? "  " : "   "), tree.forest);
  }
  return r2;
};
var formatTransformationKind = (kind) => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
};
var formatRefinementKind = (kind) => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
};
var getAnnotated = (issue) => ("ast" in issue) ? some2(issue.ast) : none2();
var Either_void = /* @__PURE__ */ right2(undefined);
var getCurrentMessage = (issue) => getAnnotated(issue).pipe(flatMap(getMessageAnnotation), match2({
  onNone: () => Either_void,
  onSome: (messageAnnotation) => {
    const union10 = messageAnnotation(issue);
    if (isString(union10)) {
      return right2({
        message: union10,
        override: false
      });
    }
    if (isEffect2(union10)) {
      return map13(union10, (message) => ({
        message,
        override: false
      }));
    }
    if (isString(union10.message)) {
      return right2({
        message: union10.message,
        override: union10.override
      });
    }
    return map13(union10.message, (message) => ({
      message,
      override: union10.override
    }));
  }
}));
var createParseIssueGuard = (tag) => (issue) => issue._tag === tag;
var isComposite2 = /* @__PURE__ */ createParseIssueGuard("Composite");
var isRefinement2 = /* @__PURE__ */ createParseIssueGuard("Refinement");
var isTransformation2 = /* @__PURE__ */ createParseIssueGuard("Transformation");
var getMessage = (issue) => flatMap16(getCurrentMessage(issue), (currentMessage) => {
  if (currentMessage !== undefined) {
    const useInnerMessage = !currentMessage.override && (isComposite2(issue) || isRefinement2(issue) && issue.kind === "From" || isTransformation2(issue) && issue.kind !== "Transformation");
    return useInnerMessage ? isTransformation2(issue) || isRefinement2(issue) ? getMessage(issue.issue) : Either_void : right2(currentMessage.message);
  }
  return Either_void;
});
var getParseIssueTitleAnnotation2 = (issue) => getAnnotated(issue).pipe(flatMap(getParseIssueTitleAnnotation), flatMapNullable((annotation) => annotation(issue)), getOrUndefined);
function getRefinementExpected(ast) {
  return getDescriptionAnnotation(ast).pipe(orElse(() => getTitleAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), orElse(() => getIdentifierAnnotation(ast)), getOrElse(() => `{ ${ast.from} | filter }`));
}
function getDefaultTypeMessage(issue) {
  if (issue.message !== undefined) {
    return issue.message;
  }
  const expected = isRefinement(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast);
  return `Expected ${expected}, actual ${formatUnknown(issue.actual)}`;
}
var formatTypeMessage = (issue) => map23(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation2(issue) ?? getDefaultTypeMessage(issue));
var getParseIssueTitle = (issue) => getParseIssueTitleAnnotation2(issue) ?? String(issue.ast);
var formatForbiddenMessage = (issue) => issue.message ?? "is forbidden";
var formatUnexpectedMessage = (issue) => issue.message ?? "is unexpected";
var formatMissingMessage = (issue) => {
  const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
  if (isSome2(missingMessageAnnotation)) {
    const annotation = missingMessageAnnotation.value();
    return isString(annotation) ? right2(annotation) : annotation;
  }
  return right2(issue.message ?? "is missing");
};
var formatTree = (issue) => {
  switch (issue._tag) {
    case "Type":
      return map23(formatTypeMessage(issue), makeTree);
    case "Forbidden":
      return right2(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
    case "Unexpected":
      return right2(makeTree(formatUnexpectedMessage(issue)));
    case "Missing":
      return map23(formatMissingMessage(issue), makeTree);
    case "Transformation":
      return flatMap16(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2(makeTree(message));
        }
        return map23(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
      });
    case "Refinement":
      return flatMap16(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2(makeTree(message));
        }
        return map23(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
      });
    case "Pointer":
      return map23(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
    case "Composite":
      return flatMap16(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2(makeTree(message));
        }
        const parseIssueTitle = getParseIssueTitle(issue);
        return isNonEmpty(issue.issues) ? map23(forEach8(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map23(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
      });
  }
};
var makeArrayFormatterIssue = (_tag, path, message) => ({
  _tag,
  path,
  message
});
var ArrayFormatter = {
  formatIssue: (issue) => getArrayFormatterIssues(issue, undefined, []),
  formatIssueSync: (issue) => {
    const e = ArrayFormatter.formatIssue(issue);
    return isEither4(e) ? getOrThrow(e) : runSync(e);
  },
  formatError: (error2) => ArrayFormatter.formatIssue(error2.issue),
  formatErrorSync: (error2) => ArrayFormatter.formatIssueSync(error2.issue)
};
var getArrayFormatterIssues = (issue, parentTag, path) => {
  const _tag = issue._tag;
  switch (_tag) {
    case "Type":
      return map23(formatTypeMessage(issue), (message) => [makeArrayFormatterIssue(parentTag ?? _tag, path, message)]);
    case "Forbidden":
      return right2([makeArrayFormatterIssue(_tag, path, formatForbiddenMessage(issue))]);
    case "Unexpected":
      return right2([makeArrayFormatterIssue(_tag, path, formatUnexpectedMessage(issue))]);
    case "Missing":
      return map23(formatMissingMessage(issue), (message) => [makeArrayFormatterIssue(_tag, path, message)]);
    case "Pointer":
      return getArrayFormatterIssues(issue.issue, undefined, path.concat(issue.path));
    case "Composite":
      return flatMap16(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2([makeArrayFormatterIssue(_tag, path, message)]);
        }
        return isNonEmpty(issue.issues) ? map23(forEach8(issue.issues, (issue2) => getArrayFormatterIssues(issue2, undefined, path)), flatten) : getArrayFormatterIssues(issue.issues, undefined, path);
      });
    case "Refinement":
      return flatMap16(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2([makeArrayFormatterIssue(_tag, path, message)]);
        }
        return getArrayFormatterIssues(issue.issue, issue.kind === "Predicate" ? _tag : undefined, path);
      });
    case "Transformation":
      return flatMap16(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2([makeArrayFormatterIssue(_tag, path, message)]);
        }
        return getArrayFormatterIssues(issue.issue, issue.kind === "Transformation" ? _tag : undefined, path);
      });
  }
};
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/pool.js
var PoolTypeId = /* @__PURE__ */ Symbol.for("effect/Pool");
var poolVariance = {
  _E: (_2) => _2,
  _A: (_2) => _2
};
class PoolImpl extends Class {
  scope;
  acquire;
  concurrency;
  minSize;
  maxSize;
  strategy;
  targetUtilization;
  [PoolTypeId];
  isShuttingDown = false;
  semaphore;
  items = /* @__PURE__ */ new Set;
  available = /* @__PURE__ */ new Set;
  availableLatch = /* @__PURE__ */ unsafeMakeLatch(false);
  invalidated = /* @__PURE__ */ new Set;
  waiters = 0;
  constructor(scope5, acquire, concurrency, minSize, maxSize, strategy, targetUtilization) {
    super();
    this.scope = scope5;
    this.acquire = acquire;
    this.concurrency = concurrency;
    this.minSize = minSize;
    this.maxSize = maxSize;
    this.strategy = strategy;
    this.targetUtilization = targetUtilization;
    this[PoolTypeId] = poolVariance;
    this.semaphore = unsafeMakeSemaphore(concurrency * maxSize);
  }
  allocate = /* @__PURE__ */ acquireUseRelease(/* @__PURE__ */ scopeMake(), (scope5) => this.acquire.pipe(scopeExtend(scope5), exit, flatMap7((exit3) => {
    const item = {
      exit: exit3,
      finalizer: catchAllCause(scope5.close(exit3), reportUnhandledError),
      refCount: 0,
      disableReclaim: false
    };
    this.items.add(item);
    this.available.add(item);
    return as(exit3._tag === "Success" ? this.strategy.onAcquire(item) : zipRight(item.finalizer, this.strategy.onAcquire(item)), item);
  })), (scope5, exit3) => exit3._tag === "Failure" ? scope5.close(exit3) : void_);
  get currentUsage() {
    let count4 = this.waiters;
    for (const item of this.items) {
      count4 += item.refCount;
    }
    return count4;
  }
  get targetSize() {
    if (this.isShuttingDown)
      return 0;
    const utilization = this.currentUsage / this.targetUtilization;
    const target = Math.ceil(utilization / this.concurrency);
    return Math.min(Math.max(this.minSize, target), this.maxSize);
  }
  get activeSize() {
    return this.items.size - this.invalidated.size;
  }
  resizeLoop = /* @__PURE__ */ suspend(() => {
    if (this.activeSize >= this.targetSize) {
      return void_;
    }
    const toAcquire = this.targetSize - this.activeSize;
    return this.strategy.reclaim(this).pipe(flatMap7(match2({
      onNone: () => this.allocate,
      onSome: succeed
    })), replicateEffect(toAcquire, {
      concurrency: toAcquire
    }), zipLeft(this.availableLatch.open), flatMap7((items) => items.some((_2) => _2.exit._tag === "Failure") ? void_ : this.resizeLoop));
  });
  resizeSemaphore = /* @__PURE__ */ unsafeMakeSemaphore(1);
  resize = /* @__PURE__ */ this.resizeSemaphore.withPermits(1)(this.resizeLoop);
  getPoolItem = /* @__PURE__ */ uninterruptibleMask((restore) => restore(this.semaphore.take(1)).pipe(zipRight(scopeTag), flatMap7((scope5) => suspend(() => {
    this.waiters++;
    if (this.isShuttingDown) {
      return interrupt2;
    } else if (this.targetSize > this.activeSize) {
      const self2 = this;
      return flatMap7(this.resizeSemaphore.withPermitsIfAvailable(1)(forkIn(interruptible2(this.resize), this.scope)), function loop() {
        if (self2.isShuttingDown) {
          return interrupt2;
        } else if (self2.available.size > 0) {
          return succeed(unsafeHead(self2.available));
        }
        self2.availableLatch.unsafeClose();
        return flatMap7(self2.availableLatch.await, loop);
      });
    }
    return succeed(unsafeHead(this.available));
  }).pipe(ensuring(sync(() => this.waiters--)), tap((item) => {
    if (item.exit._tag === "Failure") {
      this.items.delete(item);
      this.invalidated.delete(item);
      this.available.delete(item);
      return this.semaphore.release(1);
    }
    item.refCount++;
    this.available.delete(item);
    if (item.refCount < this.concurrency) {
      this.available.add(item);
    }
    return scope5.addFinalizer(() => zipRight(suspend(() => {
      item.refCount--;
      if (this.invalidated.has(item)) {
        return this.invalidatePoolItem(item);
      }
      this.available.add(item);
      return exitVoid;
    }), this.semaphore.release(1)));
  }), onInterrupt(() => this.semaphore.release(1))))));
  commit() {
    return this.get;
  }
  get = /* @__PURE__ */ flatMap7(/* @__PURE__ */ suspend(() => this.isShuttingDown ? interrupt2 : this.getPoolItem), (_2) => _2.exit);
  invalidate(item) {
    return suspend(() => {
      if (this.isShuttingDown)
        return void_;
      for (const poolItem of this.items) {
        if (poolItem.exit._tag === "Success" && poolItem.exit.value === item) {
          poolItem.disableReclaim = true;
          return uninterruptible(this.invalidatePoolItem(poolItem));
        }
      }
      return void_;
    });
  }
  invalidatePoolItem(poolItem) {
    return suspend(() => {
      if (!this.items.has(poolItem)) {
        return void_;
      } else if (poolItem.refCount === 0) {
        this.items.delete(poolItem);
        this.available.delete(poolItem);
        this.invalidated.delete(poolItem);
        return zipRight(poolItem.finalizer, forkIn(interruptible2(this.resize), this.scope));
      }
      this.invalidated.add(poolItem);
      this.available.delete(poolItem);
      return void_;
    });
  }
  get shutdown() {
    return suspend(() => {
      if (this.isShuttingDown)
        return void_;
      this.isShuttingDown = true;
      const size16 = this.items.size;
      const semaphore = unsafeMakeSemaphore(size16);
      return forEachSequentialDiscard(this.items, (item) => {
        if (item.refCount > 0) {
          item.finalizer = zipLeft(item.finalizer, semaphore.release(1));
          this.invalidated.add(item);
          return semaphore.take(1);
        }
        this.items.delete(item);
        this.available.delete(item);
        this.invalidated.delete(item);
        return item.finalizer;
      }).pipe(zipRight(this.semaphore.releaseAll), zipRight(this.availableLatch.open), zipRight(semaphore.take(size16)));
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var reportUnhandledError = (cause3) => withFiberRuntime((fiber) => {
  const unhandledLogLevel = fiber.getFiberRef(currentUnhandledErrorLogLevel);
  if (unhandledLogLevel._tag === "Some") {
    fiber.log("Unhandled error in pool finalizer", cause3, unhandledLogLevel);
  }
  return void_;
});
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/ManagedRuntime.js
var exports_ManagedRuntime = {};
__export(exports_ManagedRuntime, {
  make: () => make62,
  isManagedRuntime: () => isManagedRuntime2,
  TypeId: () => TypeId27
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/managedRuntime.js
var isManagedRuntime = (u3) => hasProperty(u3, TypeId16);
function provide4(managed, effect4) {
  return flatMap7(managed.runtimeEffect, (rt2) => withFiberRuntime((fiber) => {
    fiber.setFiberRefs(rt2.fiberRefs);
    fiber.currentRuntimeFlags = rt2.runtimeFlags;
    return provideContext(effect4, rt2.context);
  }));
}
var ManagedRuntimeProto = {
  ...CommitPrototype2,
  [TypeId16]: TypeId16,
  pipe() {
    return pipeArguments(this, arguments);
  },
  commit() {
    return this.runtimeEffect;
  }
};
var make61 = (layer, memoMap) => {
  memoMap = memoMap ?? unsafeMakeMemoMap();
  const scope5 = unsafeRunSyncEffect(scopeMake());
  let buildFiber;
  const runtimeEffect = withFiberRuntime((fiber) => {
    if (!buildFiber) {
      buildFiber = unsafeForkEffect(tap(extend2(toRuntimeWithMemoMap(layer, memoMap), scope5), (rt2) => {
        self2.cachedRuntime = rt2;
      }), {
        scope: scope5,
        scheduler: fiber.currentScheduler
      });
    }
    return flatten5(buildFiber.await);
  });
  const self2 = Object.assign(Object.create(ManagedRuntimeProto), {
    memoMap,
    scope: scope5,
    runtimeEffect,
    cachedRuntime: undefined,
    runtime() {
      return self2.cachedRuntime === undefined ? unsafeRunPromiseEffect(self2.runtimeEffect) : Promise.resolve(self2.cachedRuntime);
    },
    dispose() {
      return unsafeRunPromiseEffect(self2.disposeEffect);
    },
    disposeEffect: suspend(() => {
      self2.runtimeEffect = die2("ManagedRuntime disposed");
      self2.cachedRuntime = undefined;
      return close(self2.scope, exitVoid);
    }),
    runFork(effect4, options) {
      return self2.cachedRuntime === undefined ? unsafeForkEffect(provide4(self2, effect4), options) : unsafeFork2(self2.cachedRuntime)(effect4, options);
    },
    runSyncExit(effect4) {
      return self2.cachedRuntime === undefined ? unsafeRunSyncExitEffect(provide4(self2, effect4)) : unsafeRunSyncExit(self2.cachedRuntime)(effect4);
    },
    runSync(effect4) {
      return self2.cachedRuntime === undefined ? unsafeRunSyncEffect(provide4(self2, effect4)) : unsafeRunSync(self2.cachedRuntime)(effect4);
    },
    runPromiseExit(effect4, options) {
      return self2.cachedRuntime === undefined ? unsafeRunPromiseExitEffect(provide4(self2, effect4), options) : unsafeRunPromiseExit(self2.cachedRuntime)(effect4, options);
    },
    runCallback(effect4, options) {
      return self2.cachedRuntime === undefined ? unsafeRunCallback(defaultRuntime)(provide4(self2, effect4), options) : unsafeRunCallback(self2.cachedRuntime)(effect4, options);
    },
    runPromise(effect4, options) {
      return self2.cachedRuntime === undefined ? unsafeRunPromiseEffect(provide4(self2, effect4), options) : unsafeRunPromise(self2.cachedRuntime)(effect4, options);
    }
  });
  return self2;
};

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/ManagedRuntime.js
var TypeId27 = TypeId16;
var isManagedRuntime2 = isManagedRuntime;
var make62 = make61;
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/matcher.js
var TypeId28 = /* @__PURE__ */ Symbol.for("@effect/matcher/Matcher");
var TypeMatcherProto = {
  [TypeId28]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _return: identity
  },
  _tag: "TypeMatcher",
  add(_case) {
    return makeTypeMatcher([...this.cases, _case]);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeTypeMatcher(cases) {
  const matcher = Object.create(TypeMatcherProto);
  matcher.cases = cases;
  return matcher;
}
var ValueMatcherProto = {
  [TypeId28]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _provided: identity,
    _return: identity
  },
  _tag: "ValueMatcher",
  add(_case) {
    if (this.value._tag === "Right") {
      return this;
    }
    if (_case._tag === "When" && _case.guard(this.provided) === true) {
      return makeValueMatcher(this.provided, right2(_case.evaluate(this.provided)));
    } else if (_case._tag === "Not" && _case.guard(this.provided) === false) {
      return makeValueMatcher(this.provided, right2(_case.evaluate(this.provided)));
    }
    return this;
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeValueMatcher(provided, value2) {
  const matcher = Object.create(ValueMatcherProto);
  matcher.provided = provided;
  matcher.value = value2;
  return matcher;
}
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/MutableHashSet.js
var TypeId29 = /* @__PURE__ */ Symbol.for("effect/MutableHashSet");
var MutableHashSetProto = {
  [TypeId29]: TypeId29,
  [Symbol.iterator]() {
    return Array.from(this.keyMap).map(([_2]) => _2)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Redacted.js
var isRedacted2 = isRedacted;
var make67 = make53;
var value4 = value;
var getEquivalence7 = (isEquivalent) => make((x3, y2) => isEquivalent(value4(x3), value4(y2)));
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/scopedRef.js
var ScopedRefSymbolKey = "effect/ScopedRef";
var ScopedRefTypeId = /* @__PURE__ */ Symbol.for(ScopedRefSymbolKey);
var scopedRefVariance = {
  _A: (_2) => _2
};
var proto14 = {
  ...CommitPrototype,
  commit() {
    return get21(this);
  },
  [ScopedRefTypeId]: scopedRefVariance
};
var get21 = (self2) => map9(get11(self2.ref), (tuple3) => tuple3[1]);
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/resource.js
var ResourceSymbolKey = "effect/Resource";
var ResourceTypeId = /* @__PURE__ */ Symbol.for(ResourceSymbolKey);
var resourceVariance = {
  _E: (_2) => _2,
  _A: (_2) => _2
};
var proto15 = {
  ...CommitPrototype,
  commit() {
    return get23(this);
  },
  [ResourceTypeId]: resourceVariance
};
var get23 = (self2) => flatMap7(get21(self2.scopedRef), identity);
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Schema.js
var exports_Schema = {};
__export(exports_Schema, {
  withDefaults: () => withDefaults,
  withDecodingDefault: () => withDecodingDefault,
  withConstructorDefault: () => withConstructorDefault,
  validateSync: () => validateSync,
  validatePromise: () => validatePromise,
  validateOption: () => validateOption,
  validateEither: () => validateEither2,
  validate: () => validate5,
  validDate: () => validDate,
  uppercased: () => uppercased,
  uncapitalized: () => uncapitalized,
  typeSchema: () => typeSchema,
  trimmed: () => trimmed,
  transformOrFail: () => transformOrFail,
  transformLiterals: () => transformLiterals,
  transformLiteral: () => transformLiteral,
  transform: () => transform2,
  tag: () => tag2,
  symbolWithResult: () => symbolWithResult,
  symbolSerializable: () => symbolSerializable,
  suspend: () => suspend9,
  successSchema: () => successSchema,
  startsWith: () => startsWith,
  standardSchemaV1: () => standardSchemaV1,
  split: () => split,
  serializeSuccess: () => serializeSuccess,
  serializeFailure: () => serializeFailure,
  serializeExit: () => serializeExit,
  serialize: () => serialize,
  serializableSchema: () => serializableSchema,
  requiredToOptional: () => requiredToOptional,
  required: () => required2,
  rename: () => rename2,
  propertySignature: () => propertySignature,
  positiveBigInt: () => positiveBigInt,
  positiveBigDecimal: () => positiveBigDecimal,
  positive: () => positive,
  pluck: () => pluck,
  pickLiteral: () => pickLiteral,
  pick: () => pick5,
  pattern: () => pattern,
  partialWith: () => partialWith,
  partial: () => partial2,
  parseNumber: () => parseNumber2,
  parseJson: () => parseJson2,
  optionalWith: () => optionalWith,
  optionalToRequired: () => optionalToRequired,
  optionalToOptional: () => optionalToOptional,
  optionalElement: () => optionalElement,
  optional: () => optional,
  omit: () => omit5,
  nonPositiveBigInt: () => nonPositiveBigInt,
  nonPositiveBigDecimal: () => nonPositiveBigDecimal,
  nonPositive: () => nonPositive,
  nonNegativeBigInt: () => nonNegativeBigInt,
  nonNegativeBigDecimal: () => nonNegativeBigDecimal,
  nonNegative: () => nonNegative,
  nonNaN: () => nonNaN,
  nonEmptyString: () => nonEmptyString3,
  negativeBigInt: () => negativeBigInt,
  negativeBigDecimal: () => negativeBigDecimal,
  negative: () => negative,
  mutable: () => mutable2,
  multipleOf: () => multipleOf,
  minLength: () => minLength,
  minItems: () => minItems,
  maxLength: () => maxLength,
  maxItems: () => maxItems,
  makePropertySignature: () => makePropertySignature,
  make: () => make69,
  lowercased: () => lowercased,
  lessThanOrEqualToDuration: () => lessThanOrEqualToDuration,
  lessThanOrEqualToDate: () => lessThanOrEqualToDate,
  lessThanOrEqualToBigInt: () => lessThanOrEqualToBigInt,
  lessThanOrEqualToBigDecimal: () => lessThanOrEqualToBigDecimal,
  lessThanOrEqualTo: () => lessThanOrEqualTo5,
  lessThanDuration: () => lessThanDuration,
  lessThanDate: () => lessThanDate,
  lessThanBigInt: () => lessThanBigInt,
  lessThanBigDecimal: () => lessThanBigDecimal,
  lessThan: () => lessThan9,
  length: () => length3,
  keyof: () => keyof2,
  itemsCount: () => itemsCount,
  isSchema: () => isSchema,
  isPropertySignature: () => isPropertySignature,
  is: () => is2,
  int: () => int,
  instanceOf: () => instanceOf2,
  includes: () => includes,
  headOrElse: () => headOrElse,
  headNonEmpty: () => headNonEmpty3,
  head: () => head8,
  greaterThanOrEqualToDuration: () => greaterThanOrEqualToDuration,
  greaterThanOrEqualToDate: () => greaterThanOrEqualToDate,
  greaterThanOrEqualToBigInt: () => greaterThanOrEqualToBigInt,
  greaterThanOrEqualToBigDecimal: () => greaterThanOrEqualToBigDecimal,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo6,
  greaterThanDuration: () => greaterThanDuration,
  greaterThanDate: () => greaterThanDate,
  greaterThanBigInt: () => greaterThanBigInt,
  greaterThanBigDecimal: () => greaterThanBigDecimal,
  greaterThan: () => greaterThan6,
  getNumberIndexedAccess: () => getNumberIndexedAccess2,
  getClassTag: () => getClassTag,
  fromKey: () => fromKey,
  fromBrand: () => fromBrand,
  format: () => format6,
  finite: () => finite,
  filterEffect: () => filterEffect2,
  filter: () => filter12,
  failureSchema: () => failureSchema,
  extend: () => extend3,
  exitSchema: () => exitSchema,
  equivalence: () => equivalence2,
  endsWith: () => endsWith,
  encodedSchema: () => encodedSchema,
  encodedBoundSchema: () => encodedBoundSchema,
  encodeUnknownSync: () => encodeUnknownSync,
  encodeUnknownPromise: () => encodeUnknownPromise,
  encodeUnknownOption: () => encodeUnknownOption,
  encodeUnknownEither: () => encodeUnknownEither2,
  encodeUnknown: () => encodeUnknown2,
  encodeSync: () => encodeSync,
  encodePromise: () => encodePromise,
  encodeOption: () => encodeOption,
  encodeEither: () => encodeEither,
  encode: () => encode4,
  element: () => element,
  deserializeSuccess: () => deserializeSuccess,
  deserializeFailure: () => deserializeFailure,
  deserializeExit: () => deserializeExit,
  deserialize: () => deserialize,
  decodeUnknownSync: () => decodeUnknownSync,
  decodeUnknownPromise: () => decodeUnknownPromise,
  decodeUnknownOption: () => decodeUnknownOption,
  decodeUnknownEither: () => decodeUnknownEither2,
  decodeUnknown: () => decodeUnknown3,
  decodeSync: () => decodeSync,
  decodePromise: () => decodePromise,
  decodeOption: () => decodeOption,
  decodeEither: () => decodeEither,
  decode: () => decode5,
  declare: () => declare,
  compose: () => compose3,
  clampDuration: () => clampDuration,
  clampBigInt: () => clampBigInt,
  clampBigDecimal: () => clampBigDecimal,
  clamp: () => clamp8,
  capitalized: () => capitalized,
  brand: () => brand,
  betweenDuration: () => betweenDuration,
  betweenDate: () => betweenDate,
  betweenBigInt: () => betweenBigInt,
  betweenBigDecimal: () => betweenBigDecimal,
  between: () => between6,
  attachPropertySignature: () => attachPropertySignature,
  asserts: () => asserts,
  asWithResult: () => asWithResult,
  asSerializableWithResult: () => asSerializableWithResult,
  asSerializable: () => asSerializable,
  asSchema: () => asSchema,
  annotations: () => annotations2,
  Void: () => Void,
  ValidDateSchemaId: () => ValidDateSchemaId,
  ValidDateFromSelf: () => ValidDateFromSelf,
  UppercasedSchemaId: () => UppercasedSchemaId,
  Uppercased: () => Uppercased,
  Uppercase: () => Uppercase,
  Unknown: () => Unknown,
  UniqueSymbolFromSelf: () => UniqueSymbolFromSelf,
  Union: () => Union2,
  UndefinedOr: () => UndefinedOr,
  Undefined: () => Undefined,
  UncapitalizedSchemaId: () => UncapitalizedSchemaId,
  Uncapitalized: () => Uncapitalized,
  Uncapitalize: () => Uncapitalize,
  Uint8ArrayFromSelf: () => Uint8ArrayFromSelf,
  Uint8ArrayFromHex: () => Uint8ArrayFromHex,
  Uint8ArrayFromBase64Url: () => Uint8ArrayFromBase64Url,
  Uint8ArrayFromBase64: () => Uint8ArrayFromBase64,
  Uint8Array: () => Uint8Array$,
  Uint8: () => Uint8,
  UUIDSchemaId: () => UUIDSchemaId,
  UUID: () => UUID,
  URLFromSelf: () => URLFromSelf,
  URL: () => URL$,
  ULIDSchemaId: () => ULIDSchemaId,
  ULID: () => ULID,
  TypeId: () => TypeId30,
  Tuple: () => Tuple,
  TrimmedSchemaId: () => TrimmedSchemaId,
  Trimmed: () => Trimmed,
  Trim: () => Trim,
  ToPropertySignature: () => ToPropertySignature,
  TimeZoneOffsetFromSelf: () => TimeZoneOffsetFromSelf,
  TimeZoneOffset: () => TimeZoneOffset,
  TimeZoneNamedFromSelf: () => TimeZoneNamedFromSelf,
  TimeZoneNamed: () => TimeZoneNamed,
  TimeZoneFromSelf: () => TimeZoneFromSelf,
  TimeZone: () => TimeZone,
  TemplateLiteralParser: () => TemplateLiteralParser,
  TemplateLiteral: () => TemplateLiteral2,
  TaggedStruct: () => TaggedStruct,
  TaggedRequest: () => TaggedRequest,
  TaggedError: () => TaggedError2,
  TaggedClass: () => TaggedClass2,
  SymbolFromSelf: () => SymbolFromSelf,
  Symbol: () => Symbol$,
  Struct: () => Struct,
  StringFromUriComponent: () => StringFromUriComponent,
  StringFromHex: () => StringFromHex,
  StringFromBase64Url: () => StringFromBase64Url,
  StringFromBase64: () => StringFromBase64,
  String: () => String$,
  StartsWithSchemaId: () => StartsWithSchemaId,
  SortedSetFromSelf: () => SortedSetFromSelf,
  SortedSet: () => SortedSet,
  SetFromSelf: () => SetFromSelf,
  Set: () => set10,
  RefineSchemaId: () => RefineSchemaId,
  RedactedFromSelf: () => RedactedFromSelf,
  Redacted: () => Redacted,
  Record: () => Record,
  ReadonlySetFromSelf: () => ReadonlySetFromSelf,
  ReadonlySet: () => ReadonlySet,
  ReadonlyMapFromSelf: () => ReadonlyMapFromSelf,
  ReadonlyMapFromRecord: () => ReadonlyMapFromRecord,
  ReadonlyMap: () => ReadonlyMap,
  PropertySignatureTypeId: () => PropertySignatureTypeId,
  PropertySignatureTransformation: () => PropertySignatureTransformation2,
  PropertySignatureDeclaration: () => PropertySignatureDeclaration,
  PropertyKey: () => PropertyKey$,
  PositiveBigIntFromSelf: () => PositiveBigIntFromSelf,
  PositiveBigInt: () => PositiveBigInt,
  PositiveBigDecimalSchemaId: () => PositiveBigDecimalSchemaId,
  PositiveBigDecimalFromSelf: () => PositiveBigDecimalFromSelf,
  Positive: () => Positive,
  PatternSchemaId: () => PatternSchemaId,
  OptionFromUndefinedOr: () => OptionFromUndefinedOr,
  OptionFromSelf: () => OptionFromSelf,
  OptionFromNullishOr: () => OptionFromNullishOr,
  OptionFromNullOr: () => OptionFromNullOr,
  OptionFromNonEmptyTrimmedString: () => OptionFromNonEmptyTrimmedString,
  Option: () => Option,
  Object: () => Object$,
  NumberFromString: () => NumberFromString,
  Number: () => Number$,
  NullishOr: () => NullishOr,
  NullOr: () => NullOr,
  Null: () => Null,
  Not: () => Not,
  NonPositiveBigIntFromSelf: () => NonPositiveBigIntFromSelf,
  NonPositiveBigInt: () => NonPositiveBigInt,
  NonPositiveBigDecimalSchemaId: () => NonPositiveBigDecimalSchemaId,
  NonPositiveBigDecimalFromSelf: () => NonPositiveBigDecimalFromSelf,
  NonPositive: () => NonPositive,
  NonNegativeInt: () => NonNegativeInt,
  NonNegativeBigIntFromSelf: () => NonNegativeBigIntFromSelf,
  NonNegativeBigInt: () => NonNegativeBigInt,
  NonNegativeBigDecimalSchemaId: () => NonNegativeBigDecimalSchemaId,
  NonNegativeBigDecimalFromSelf: () => NonNegativeBigDecimalFromSelf,
  NonNegative: () => NonNegative,
  NonNaNSchemaId: () => NonNaNSchemaId2,
  NonNaN: () => NonNaN,
  NonEmptyTrimmedString: () => NonEmptyTrimmedString,
  NonEmptyString: () => NonEmptyString,
  NonEmptyChunkFromSelf: () => NonEmptyChunkFromSelf,
  NonEmptyChunk: () => NonEmptyChunk,
  NonEmptyArrayEnsure: () => NonEmptyArrayEnsure,
  NonEmptyArray: () => NonEmptyArray,
  Never: () => Never,
  NegativeBigIntFromSelf: () => NegativeBigIntFromSelf,
  NegativeBigInt: () => NegativeBigInt,
  NegativeBigDecimalSchemaId: () => NegativeBigDecimalSchemaId,
  NegativeBigDecimalFromSelf: () => NegativeBigDecimalFromSelf,
  Negative: () => Negative,
  MultipleOfSchemaId: () => MultipleOfSchemaId,
  MinLengthSchemaId: () => MinLengthSchemaId2,
  MinItemsSchemaId: () => MinItemsSchemaId2,
  MaxLengthSchemaId: () => MaxLengthSchemaId2,
  MaxItemsSchemaId: () => MaxItemsSchemaId2,
  MapFromSelf: () => MapFromSelf,
  MapFromRecord: () => MapFromRecord,
  Map: () => map26,
  LowercasedSchemaId: () => LowercasedSchemaId,
  Lowercased: () => Lowercased,
  Lowercase: () => Lowercase,
  Literal: () => Literal2,
  ListFromSelf: () => ListFromSelf,
  List: () => List,
  LessThanSchemaId: () => LessThanSchemaId2,
  LessThanOrEqualToSchemaId: () => LessThanOrEqualToSchemaId2,
  LessThanOrEqualToDurationSchemaId: () => LessThanOrEqualToDurationSchemaId,
  LessThanOrEqualToDateSchemaId: () => LessThanOrEqualToDateSchemaId,
  LessThanOrEqualToBigIntSchemaId: () => LessThanOrEqualToBigIntSchemaId2,
  LessThanOrEqualToBigDecimalSchemaId: () => LessThanOrEqualToBigDecimalSchemaId,
  LessThanDurationSchemaId: () => LessThanDurationSchemaId,
  LessThanDateSchemaId: () => LessThanDateSchemaId,
  LessThanBigIntSchemaId: () => LessThanBigIntSchemaId2,
  LessThanBigDecimalSchemaId: () => LessThanBigDecimalSchemaId,
  LengthSchemaId: () => LengthSchemaId2,
  JsonNumberSchemaId: () => JsonNumberSchemaId2,
  JsonNumber: () => JsonNumber,
  ItemsCountSchemaId: () => ItemsCountSchemaId2,
  IntSchemaId: () => IntSchemaId2,
  Int: () => Int,
  InstanceOfSchemaId: () => InstanceOfSchemaId,
  IncludesSchemaId: () => IncludesSchemaId,
  HashSetFromSelf: () => HashSetFromSelf,
  HashSet: () => HashSet,
  HashMapFromSelf: () => HashMapFromSelf,
  HashMap: () => HashMap,
  GreaterThanSchemaId: () => GreaterThanSchemaId2,
  GreaterThanOrEqualToSchemaId: () => GreaterThanOrEqualToSchemaId2,
  GreaterThanOrEqualToDurationSchemaId: () => GreaterThanOrEqualToDurationSchemaId,
  GreaterThanOrEqualToDateSchemaId: () => GreaterThanOrEqualToDateSchemaId,
  GreaterThanOrEqualToBigIntSchemaId: () => GreaterThanOrEqualToBigIntSchemaId2,
  GreaterThanOrEqualToBigDecimalSchemaId: () => GreaterThanOrEqualToBigDecimalSchemaId,
  GreaterThanDurationSchemaId: () => GreaterThanDurationSchemaId,
  GreaterThanDateSchemaId: () => GreaterThanDateSchemaId,
  GreaterThanBigIntSchemaId: () => GreaterThanBigIntSchemaId,
  GreaterThanBigDecimalSchemaId: () => GreaterThanBigDecimalSchemaId,
  FromPropertySignature: () => FromPropertySignature,
  FiniteSchemaId: () => FiniteSchemaId2,
  Finite: () => Finite,
  FiberIdFromSelf: () => FiberIdFromSelf,
  FiberId: () => FiberId,
  ExitFromSelf: () => ExitFromSelf,
  Exit: () => Exit,
  Enums: () => Enums2,
  EndsWithSchemaId: () => EndsWithSchemaId,
  EitherFromUnion: () => EitherFromUnion,
  EitherFromSelf: () => EitherFromSelf,
  Either: () => Either2,
  DurationFromSelf: () => DurationFromSelf,
  DurationFromNanos: () => DurationFromNanos,
  DurationFromMillis: () => DurationFromMillis,
  Duration: () => Duration,
  Defect: () => Defect,
  DateTimeZonedFromSelf: () => DateTimeZonedFromSelf,
  DateTimeZoned: () => DateTimeZoned,
  DateTimeUtcFromSelf: () => DateTimeUtcFromSelf,
  DateTimeUtcFromNumber: () => DateTimeUtcFromNumber,
  DateTimeUtcFromDate: () => DateTimeUtcFromDate,
  DateTimeUtc: () => DateTimeUtc,
  DateFromString: () => DateFromString,
  DateFromSelfSchemaId: () => DateFromSelfSchemaId2,
  DateFromSelf: () => DateFromSelf,
  DateFromNumber: () => DateFromNumber,
  Date: () => Date$,
  DataFromSelf: () => DataFromSelf,
  Data: () => Data,
  Config: () => Config,
  Class: () => Class5,
  ChunkFromSelf: () => ChunkFromSelf,
  Chunk: () => Chunk,
  Char: () => Char,
  CauseFromSelf: () => CauseFromSelf,
  Cause: () => Cause,
  CapitalizedSchemaId: () => CapitalizedSchemaId,
  Capitalized: () => Capitalized,
  Capitalize: () => Capitalize,
  BrandSchemaId: () => BrandSchemaId,
  BooleanFromUnknown: () => BooleanFromUnknown,
  BooleanFromString: () => BooleanFromString,
  Boolean: () => Boolean$,
  BigIntFromSelf: () => BigIntFromSelf,
  BigIntFromNumber: () => BigIntFromNumber,
  BigInt: () => BigInt$,
  BigDecimalFromSelf: () => BigDecimalFromSelf,
  BigDecimalFromNumber: () => BigDecimalFromNumber,
  BigDecimal: () => BigDecimal,
  BetweenSchemaId: () => BetweenSchemaId2,
  BetweenDurationSchemaId: () => BetweenDurationSchemaId,
  BetweenDateSchemaId: () => BetweenDateSchemaId,
  BetweenBigIntSchemaId: () => BetweenBigIntSchemaId,
  BetweenBigDecimalSchemaId: () => BetweenBigDecimalSchemaId,
  ArrayFormatterIssue: () => ArrayFormatterIssue,
  ArrayEnsure: () => ArrayEnsure,
  Array: () => Array$,
  Any: () => Any
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Struct.js
var pick4 = /* @__PURE__ */ dual((args3) => isObject(args3[0]), (s2, ...keys7) => {
  const out2 = {};
  for (const k2 of keys7) {
    if (k2 in s2) {
      out2[k2] = s2[k2];
    }
  }
  return out2;
});
var omit4 = /* @__PURE__ */ dual((args3) => isObject(args3[0]), (s2, ...keys7) => {
  const out2 = {
    ...s2
  };
  for (const k2 of keys7) {
    delete out2[k2];
  }
  return out2;
});

// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Schema.js
var TypeId30 = /* @__PURE__ */ Symbol.for("effect/Schema");
function make69(ast) {
  return class SchemaClass {
    [TypeId30] = variance9;
    static ast = ast;
    static annotations(annotations2) {
      return make69(mergeSchemaAnnotations(this.ast, annotations2));
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static toString() {
      return String(ast);
    }
    static Type;
    static Encoded;
    static Context;
    static [TypeId30] = variance9;
  };
}
var variance9 = {
  _A: (_2) => _2,
  _I: (_2) => _2,
  _R: (_2) => _2
};
var makeStandardResult = (exit3) => isSuccess(exit3) ? exit3.value : makeStandardFailureResult(pretty2(exit3.cause));
var makeStandardFailureResult = (message) => ({
  issues: [{
    message
  }]
});
var makeStandardFailureFromParseIssue = (issue) => map13(ArrayFormatter.formatIssue(issue), (issues) => ({
  issues: issues.map((issue2) => ({
    path: issue2.path,
    message: issue2.message
  }))
}));
var standardSchemaV1 = (schema, overrideOptions) => {
  const decodeUnknown3 = decodeUnknown2(schema, {
    errors: "all"
  });
  return class StandardSchemaV1Class extends make69(schema.ast) {
    static "~standard" = {
      version: 1,
      vendor: "effect",
      validate(value5) {
        const scheduler = new SyncScheduler;
        const fiber = runFork2(matchEffect2(decodeUnknown3(value5, overrideOptions), {
          onFailure: makeStandardFailureFromParseIssue,
          onSuccess: (value6) => succeed7({
            value: value6
          })
        }), {
          scheduler
        });
        scheduler.flush();
        const exit3 = fiber.unsafePoll();
        if (exit3) {
          return makeStandardResult(exit3);
        }
        return new Promise((resolve) => {
          fiber.addObserver((exit4) => {
            resolve(makeStandardResult(exit4));
          });
        });
      }
    };
  };
};
var builtInAnnotations = {
  schemaId: SchemaIdAnnotationId,
  message: MessageAnnotationId,
  missingMessage: MissingMessageAnnotationId,
  identifier: IdentifierAnnotationId,
  title: TitleAnnotationId,
  description: DescriptionAnnotationId,
  examples: ExamplesAnnotationId,
  default: DefaultAnnotationId,
  documentation: DocumentationAnnotationId,
  jsonSchema: JSONSchemaAnnotationId,
  arbitrary: ArbitraryAnnotationId,
  pretty: PrettyAnnotationId,
  equivalence: EquivalenceAnnotationId,
  concurrency: ConcurrencyAnnotationId,
  batching: BatchingAnnotationId,
  parseIssueTitle: ParseIssueTitleAnnotationId,
  parseOptions: ParseOptionsAnnotationId,
  decodingFallback: DecodingFallbackAnnotationId
};
var toASTAnnotations = (annotations2) => {
  if (!annotations2) {
    return {};
  }
  const out2 = {
    ...annotations2
  };
  for (const key in builtInAnnotations) {
    if (key in annotations2) {
      const id2 = builtInAnnotations[key];
      out2[id2] = annotations2[key];
      delete out2[key];
    }
  }
  return out2;
};
var mergeSchemaAnnotations = (ast, annotations2) => annotations(ast, toASTAnnotations(annotations2));
function asSchema(schema) {
  return schema;
}
var format6 = (schema) => String(schema.ast);
var encodedSchema = (schema) => make69(encodedAST(schema.ast));
var encodedBoundSchema = (schema) => make69(encodedBoundAST(schema.ast));
var typeSchema = (schema) => make69(typeAST(schema.ast));
var encodeUnknown2 = (schema, options) => {
  const encodeUnknown3 = encodeUnknown(schema, options);
  return (u3, overrideOptions) => mapError6(encodeUnknown3(u3, overrideOptions), parseError);
};
var encodeUnknownEither2 = (schema, options) => {
  const encodeUnknownEither3 = encodeUnknownEither(schema, options);
  return (u3, overrideOptions) => mapLeft(encodeUnknownEither3(u3, overrideOptions), parseError);
};
var encodeUnknownPromise = (schema, options) => {
  const parser = encodeUnknown2(schema, options);
  return (u3, overrideOptions) => runPromise(parser(u3, overrideOptions));
};
var encode4 = encodeUnknown2;
var encodeEither = encodeUnknownEither2;
var encodePromise = encodeUnknownPromise;
var decodeUnknown3 = (schema, options) => {
  const decodeUnknown4 = decodeUnknown2(schema, options);
  return (u3, overrideOptions) => mapError6(decodeUnknown4(u3, overrideOptions), parseError);
};
var decodeUnknownEither2 = (schema, options) => {
  const decodeUnknownEither3 = decodeUnknownEither(schema, options);
  return (u3, overrideOptions) => mapLeft(decodeUnknownEither3(u3, overrideOptions), parseError);
};
var decodeUnknownPromise = (schema, options) => {
  const parser = decodeUnknown3(schema, options);
  return (u3, overrideOptions) => runPromise(parser(u3, overrideOptions));
};
var decode5 = decodeUnknown3;
var decodeEither = decodeUnknownEither2;
var decodePromise = decodeUnknownPromise;
var validate5 = (schema, options) => {
  const validate6 = validate4(schema, options);
  return (u3, overrideOptions) => mapError6(validate6(u3, overrideOptions), parseError);
};
var validateEither2 = (schema, options) => {
  const validateEither3 = validateEither(schema, options);
  return (u3, overrideOptions) => mapLeft(validateEither3(u3, overrideOptions), parseError);
};
var validatePromise = (schema, options) => {
  const parser = validate5(schema, options);
  return (u3, overrideOptions) => runPromise(parser(u3, overrideOptions));
};
var isSchema = (u3) => hasProperty(u3, TypeId30) && isObject(u3[TypeId30]);
function getDefaultLiteralAST(literals) {
  return isMembers(literals) ? Union.make(mapMembers(literals, (literal2) => new Literal(literal2))) : new Literal(literals[0]);
}
function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
  return class LiteralClass extends make69(ast) {
    static annotations(annotations2) {
      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static literals = [...literals];
  };
}
function Literal2(...literals) {
  return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
}
var pickLiteral = (...literals) => (_schema2) => Literal2(...literals);
var UniqueSymbolFromSelf = (symbol3) => make69(new UniqueSymbol(symbol3));
var getDefaultEnumsAST = (enums) => new Enums(Object.keys(enums).filter((key) => typeof enums[enums[key]] !== "number").map((key) => [key, enums[key]]));
var makeEnumsClass = (enums, ast = getDefaultEnumsAST(enums)) => class EnumsClass extends make69(ast) {
  static annotations(annotations2) {
    return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations2));
  }
  static enums = {
    ...enums
  };
};
var Enums2 = (enums) => makeEnumsClass(enums);
var TemplateLiteral2 = (...[head8, ...tail]) => {
  const spans = [];
  let h3 = "";
  let ts = tail;
  if (isSchema(head8)) {
    if (isLiteral(head8.ast)) {
      h3 = String(head8.ast.literal);
    } else {
      ts = [head8, ...ts];
    }
  } else {
    h3 = String(head8);
  }
  for (let i2 = 0;i2 < ts.length; i2++) {
    const item = ts[i2];
    if (isSchema(item)) {
      if (i2 < ts.length - 1) {
        const next4 = ts[i2 + 1];
        if (isSchema(next4)) {
          if (isLiteral(next4.ast)) {
            spans.push(new TemplateLiteralSpan(item.ast, String(next4.ast.literal)));
            i2++;
            continue;
          }
        } else {
          spans.push(new TemplateLiteralSpan(item.ast, String(next4)));
          i2++;
          continue;
        }
      }
      spans.push(new TemplateLiteralSpan(item.ast, ""));
    } else {
      spans.push(new TemplateLiteralSpan(new Literal(item), ""));
    }
  }
  if (isNonEmptyArray2(spans)) {
    return make69(new TemplateLiteral(h3, spans));
  } else {
    return make69(new TemplateLiteral("", [new TemplateLiteralSpan(new Literal(h3), "")]));
  }
};
function getTemplateLiteralParserCoercedElement(encoded, schema) {
  const ast = encoded.ast;
  switch (ast._tag) {
    case "Literal": {
      const literal2 = ast.literal;
      if (!isString(literal2)) {
        const s2 = String(literal2);
        return transform2(Literal2(s2), schema, {
          strict: true,
          decode: () => literal2,
          encode: () => s2
        });
      }
      break;
    }
    case "NumberKeyword":
      return compose3(NumberFromString, schema);
    case "Union": {
      const members = [];
      let hasCoercions = false;
      for (const member of ast.types) {
        const schema2 = make69(member);
        const encoded2 = encodedSchema(schema2);
        const coerced = getTemplateLiteralParserCoercedElement(encoded2, schema2);
        if (coerced) {
          hasCoercions = true;
        }
        members.push(coerced ?? schema2);
      }
      return hasCoercions ? compose3(Union2(...members), schema) : schema;
    }
  }
}
var TemplateLiteralParser = (...params) => {
  const encodedSchemas = [];
  const elements = [];
  const schemas = [];
  let coerced = false;
  for (let i2 = 0;i2 < params.length; i2++) {
    const param = params[i2];
    const schema = isSchema(param) ? param : Literal2(param);
    schemas.push(schema);
    const encoded = encodedSchema(schema);
    encodedSchemas.push(encoded);
    const element = getTemplateLiteralParserCoercedElement(encoded, schema);
    if (element) {
      elements.push(element);
      coerced = true;
    } else {
      elements.push(schema);
    }
  }
  const from = TemplateLiteral2(...encodedSchemas);
  const re3 = getTemplateLiteralCapturingRegExp(from.ast);
  let to = Tuple(...elements);
  if (coerced) {
    to = to.annotations({
      [AutoTitleAnnotationId]: format6(Tuple(...schemas))
    });
  }
  return class TemplateLiteralParserClass extends transformOrFail(from, to, {
    strict: false,
    decode: (i2, _2, ast) => {
      const match23 = re3.exec(i2);
      return match23 ? succeed15(match23.slice(1, params.length + 1)) : fail16(new Type2(ast, i2, `${re3.source}: no match for ${JSON.stringify(i2)}`));
    },
    encode: (tuple3) => succeed15(tuple3.join(""))
  }) {
    static params = params.slice();
  };
};
var declareConstructor = (typeParameters, options, annotations2) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options.decode(...typeParameters2.map(make69)), (...typeParameters2) => options.encode(...typeParameters2.map(make69)), toASTAnnotations(annotations2)));
var declarePrimitive = (is4, annotations2) => {
  const decodeUnknown4 = () => (input, _2, ast) => is4(input) ? succeed15(input) : fail16(new Type2(ast, input));
  const encodeUnknown3 = decodeUnknown4;
  return makeDeclareClass([], new Declaration([], decodeUnknown4, encodeUnknown3, toASTAnnotations(annotations2)));
};
function makeDeclareClass(typeParameters, ast) {
  return class DeclareClass extends make69(ast) {
    static annotations(annotations2) {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static typeParameters = [...typeParameters];
  };
}
var declare = function() {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options = arguments[1];
    const annotations3 = arguments[2];
    return declareConstructor(typeParameters, options, annotations3);
  }
  const is4 = arguments[0];
  const annotations2 = arguments[1];
  return declarePrimitive(is4, annotations2);
};
var BrandSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Brand");
var fromBrand = (constructor, annotations2) => (self2) => {
  const out2 = makeBrandClass(self2, new Refinement(self2.ast, function predicate(a, _2, ast) {
    const either7 = constructor.either(a);
    return isLeft2(either7) ? some2(new Type2(ast, a, either7.left.map((v2) => v2.message).join(", "))) : none2();
  }, toASTAnnotations({
    schemaId: BrandSchemaId,
    [BrandSchemaId]: {
      constructor
    },
    ...annotations2
  })));
  return out2;
};
var InstanceOfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/InstanceOf");
var instanceOf2 = (constructor, annotations2) => declare((u3) => u3 instanceof constructor, {
  title: constructor.name,
  description: `an instance of ${constructor.name}`,
  pretty: () => String,
  schemaId: InstanceOfSchemaId,
  [InstanceOfSchemaId]: {
    constructor
  },
  ...annotations2
});

class Undefined extends (/* @__PURE__ */ make69(undefinedKeyword)) {
}

class Void extends (/* @__PURE__ */ make69(voidKeyword)) {
}

class Null extends (/* @__PURE__ */ make69($null)) {
}

class Never extends (/* @__PURE__ */ make69(neverKeyword)) {
}

class Unknown extends (/* @__PURE__ */ make69(unknownKeyword)) {
}

class Any extends (/* @__PURE__ */ make69(anyKeyword)) {
}

class BigIntFromSelf extends (/* @__PURE__ */ make69(bigIntKeyword)) {
}

class SymbolFromSelf extends (/* @__PURE__ */ make69(symbolKeyword)) {
}

class String$ extends (/* @__PURE__ */ make69(stringKeyword)) {
}

class Number$ extends (/* @__PURE__ */ make69(numberKeyword)) {
}

class Boolean$ extends (/* @__PURE__ */ make69(booleanKeyword)) {
}

class Object$ extends (/* @__PURE__ */ make69(objectKeyword)) {
}
var getDefaultUnionAST = (members) => Union.make(members.map((m2) => m2.ast));
function makeUnionClass(members, ast = getDefaultUnionAST(members)) {
  return class UnionClass extends make69(ast) {
    static annotations(annotations2) {
      return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static members = [...members];
  };
}
function Union2(...members) {
  return isMembers(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never;
}
var NullOr = (self2) => Union2(self2, Null);
var UndefinedOr = (self2) => Union2(self2, Undefined);
var NullishOr = (self2) => Union2(self2, Null, Undefined);
var keyof2 = (self2) => make69(keyof(self2.ast));
var element = (self2) => new ElementImpl(new OptionalType(self2.ast, false), self2);
var optionalElement = (self2) => new ElementImpl(new OptionalType(self2.ast, true), self2);

class ElementImpl {
  ast;
  from;
  [TypeId30];
  _Token;
  constructor(ast, from) {
    this.ast = ast;
    this.from = from;
  }
  annotations(annotations2) {
    return new ElementImpl(new OptionalType(this.ast.type, this.ast.isOptional, {
      ...this.ast.annotations,
      ...toASTAnnotations(annotations2)
    }), this.from);
  }
  toString() {
    return `${this.ast.type}${this.ast.isOptional ? "?" : ""}`;
  }
}
var getDefaultTupleTypeAST = (elements, rest) => new TupleType(elements.map((el) => isSchema(el) ? new OptionalType(el.ast, false) : el.ast), rest.map((el) => isSchema(el) ? new Type(el.ast) : el.ast), true);
function makeTupleTypeClass(elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) {
  return class TupleTypeClass extends make69(ast) {
    static annotations(annotations2) {
      return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static elements = [...elements];
    static rest = [...rest];
  };
}
function Tuple(...args3) {
  return Array.isArray(args3[0]) ? makeTupleTypeClass(args3[0], args3.slice(1)) : makeTupleTypeClass(args3, []);
}
function makeArrayClass(value5, ast) {
  return class ArrayClass extends makeTupleTypeClass([], [value5], ast) {
    static annotations(annotations2) {
      return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static value = value5;
  };
}
var Array$ = (value5) => makeArrayClass(value5);
function makeNonEmptyArrayClass(value5, ast) {
  return class NonEmptyArrayClass extends makeTupleTypeClass([value5], [value5], ast) {
    static annotations(annotations2) {
      return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static value = value5;
  };
}
var NonEmptyArray = (value5) => makeNonEmptyArrayClass(value5);
function ArrayEnsure(value5) {
  return transform2(Union2(value5, Array$(value5)), Array$(typeSchema(asSchema(value5))), {
    strict: true,
    decode: (i2) => ensure(i2),
    encode: (a) => a.length === 1 ? a[0] : a
  });
}
function NonEmptyArrayEnsure(value5) {
  return transform2(Union2(value5, NonEmptyArray(value5)), NonEmptyArray(typeSchema(asSchema(value5))), {
    strict: true,
    decode: (i2) => isNonEmptyReadonlyArray(i2) ? i2 : of(i2),
    encode: (a) => a.length === 1 ? a[0] : a
  });
}
var formatPropertySignatureToken = (isOptional) => isOptional ? '"?:"' : '":"';

class PropertySignatureDeclaration extends OptionalType {
  isReadonly;
  defaultValue;
  _tag = "PropertySignatureDeclaration";
  constructor(type2, isOptional, isReadonly, annotations2, defaultValue) {
    super(type2, isOptional, annotations2);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
  toString() {
    const token = formatPropertySignatureToken(this.isOptional);
    const type2 = String(this.type);
    return `PropertySignature<${token}, ${type2}, never, ${token}, ${type2}>`;
  }
}

class FromPropertySignature extends OptionalType {
  isReadonly;
  fromKey;
  constructor(type2, isOptional, isReadonly, annotations2, fromKey) {
    super(type2, isOptional, annotations2);
    this.isReadonly = isReadonly;
    this.fromKey = fromKey;
  }
}

class ToPropertySignature extends OptionalType {
  isReadonly;
  defaultValue;
  constructor(type2, isOptional, isReadonly, annotations2, defaultValue) {
    super(type2, isOptional, annotations2);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
}
var formatPropertyKey2 = (p) => {
  if (p === undefined) {
    return "never";
  }
  if (isString(p)) {
    return JSON.stringify(p);
  }
  return String(p);
};

class PropertySignatureTransformation2 {
  from;
  to;
  decode;
  encode;
  _tag = "PropertySignatureTransformation";
  constructor(from, to, decode6, encode5) {
    this.from = from;
    this.to = to;
    this.decode = decode6;
    this.encode = encode5;
  }
  toString() {
    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey2(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
  }
}
var mergeSignatureAnnotations = (ast, annotations2) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
        ...ast.annotations,
        ...annotations2
      }, ast.defaultValue);
    }
    case "PropertySignatureTransformation": {
      return new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
        ...ast.to.annotations,
        ...annotations2
      }, ast.to.defaultValue), ast.decode, ast.encode);
    }
  }
};
var PropertySignatureTypeId = /* @__PURE__ */ Symbol.for("effect/PropertySignature");
var isPropertySignature = (u3) => hasProperty(u3, PropertySignatureTypeId);

class PropertySignatureImpl {
  ast;
  [TypeId30];
  [PropertySignatureTypeId] = null;
  _TypeToken;
  _Key;
  _EncodedToken;
  _HasDefault;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  annotations(annotations2) {
    return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations2)));
  }
  toString() {
    return String(this.ast);
  }
}
var makePropertySignature = (ast) => new PropertySignatureImpl(ast);

class PropertySignatureWithFromImpl extends PropertySignatureImpl {
  from;
  constructor(ast, from) {
    super(ast);
    this.from = from;
  }
  annotations(annotations2) {
    return new PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations2)), this.from);
  }
}
var propertySignature = (self2) => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self2.ast, false, true, {}, undefined), self2);
var withConstructorDefault = /* @__PURE__ */ dual(2, (self2, defaultValue) => {
  const ast = self2.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
  }
});
var applyDefaultValue = (o3, defaultValue) => match2(o3, {
  onNone: () => some2(defaultValue()),
  onSome: (value5) => some2(value5 === undefined ? defaultValue() : value5)
});
var pruneUndefined2 = (ast) => pruneUndefined(ast, pruneUndefined2, (ast2) => {
  const pruned = pruneUndefined2(ast2.to);
  if (pruned) {
    return new Transformation(ast2.from, pruned, ast2.transformation);
  }
});
var withDecodingDefault = /* @__PURE__ */ dual(2, (self2, defaultValue) => {
  const ast = self2.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      const to = typeAST(ast.type);
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations), new ToPropertySignature(pruneUndefined2(to) ?? to, false, true, {}, ast.defaultValue), (o3) => applyDefaultValue(o3, defaultValue), identity));
    }
    case "PropertySignatureTransformation": {
      const to = ast.to.type;
      return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(pruneUndefined2(to) ?? to, false, ast.to.isReadonly, ast.to.annotations, ast.to.defaultValue), (o3) => applyDefaultValue(ast.decode(o3), defaultValue), ast.encode));
    }
  }
});
var withDefaults = /* @__PURE__ */ dual(2, (self2, defaults) => self2.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)));
var fromKey = /* @__PURE__ */ dual(2, (self2, key) => {
  const ast = self2.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, key), new ToPropertySignature(typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue), identity, identity));
    }
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations, key), ast.to, ast.decode, ast.encode));
  }
});
var optionalToRequired = (from, to, options) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from.ast, true, true, {}, undefined), new ToPropertySignature(to.ast, false, true, {}, undefined), (o3) => some2(options.decode(o3)), flatMap(options.encode)));
var requiredToOptional = (from, to, options) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from.ast, false, true, {}, undefined), new ToPropertySignature(to.ast, true, true, {}, undefined), flatMap(options.decode), (o3) => some2(options.encode(o3))));
var optionalToOptional = (from, to, options) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from.ast, true, true, {}, undefined), new ToPropertySignature(to.ast, true, true, {}, undefined), options.decode, options.encode));
var optionalPropertySignatureAST = (self2, options) => {
  const isExact = options?.exact;
  const defaultValue = options?.default;
  const isNullable2 = options?.nullable;
  const asOption = options?.as == "Option";
  const asOptionEncode = options?.onNoneEncoding ? orElse(options.onNoneEncoding) : identity;
  if (isExact) {
    if (defaultValue) {
      if (isNullable2) {
        return withConstructorDefault(optionalToRequired(NullOr(self2), typeSchema(self2), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a === null ? defaultValue() : a
          }),
          encode: some2
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(self2, typeSchema(self2), {
          decode: match2({
            onNone: defaultValue,
            onSome: identity
          }),
          encode: some2
        }), defaultValue).ast;
      }
    } else if (asOption) {
      if (isNullable2) {
        return optionalToRequired(NullOr(self2), OptionFromSelf(typeSchema(self2)), {
          decode: filter(isNotNull2),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(self2, OptionFromSelf(typeSchema(self2)), {
          decode: identity,
          encode: identity
        }).ast;
      }
    } else {
      if (isNullable2) {
        return optionalToOptional(NullOr(self2), typeSchema(self2), {
          decode: filter(isNotNull2),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(self2.ast, true, true, {}, undefined);
      }
    }
  } else {
    if (defaultValue) {
      if (isNullable2) {
        return withConstructorDefault(optionalToRequired(NullishOr(self2), typeSchema(self2), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a == null ? defaultValue() : a
          }),
          encode: some2
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(UndefinedOr(self2), typeSchema(self2), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a === undefined ? defaultValue() : a
          }),
          encode: some2
        }), defaultValue).ast;
      }
    } else if (asOption) {
      if (isNullable2) {
        return optionalToRequired(NullishOr(self2), OptionFromSelf(typeSchema(self2)), {
          decode: filter((a) => a != null),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(UndefinedOr(self2), OptionFromSelf(typeSchema(self2)), {
          decode: filter(isNotUndefined),
          encode: asOptionEncode
        }).ast;
      }
    } else {
      if (isNullable2) {
        return optionalToOptional(NullishOr(self2), UndefinedOr(typeSchema(self2)), {
          decode: filter(isNotNull2),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(UndefinedOr(self2).ast, true, true, {}, undefined);
      }
    }
  }
};
var optional = (self2) => {
  const ast = self2.ast === undefinedKeyword || self2.ast === neverKeyword ? undefinedKeyword : UndefinedOr(self2).ast;
  return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, undefined), self2);
};
var optionalWith = /* @__PURE__ */ dual((args3) => isSchema(args3[0]), (self2, options) => {
  return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(self2, options), self2);
});
var preserveMissingMessageAnnotation = /* @__PURE__ */ pickAnnotations([MissingMessageAnnotationId]);
var getDefaultTypeLiteralAST = (fields, records) => {
  const ownKeys2 = ownKeys(fields);
  const pss = [];
  if (ownKeys2.length > 0) {
    const from = [];
    const to = [];
    const transformations = [];
    for (let i2 = 0;i2 < ownKeys2.length; i2++) {
      const key = ownKeys2[i2];
      const field = fields[key];
      if (isPropertySignature(field)) {
        const ast = field.ast;
        switch (ast._tag) {
          case "PropertySignatureDeclaration": {
            const type2 = ast.type;
            const isOptional = ast.isOptional;
            const toAnnotations = ast.annotations;
            from.push(new PropertySignature(key, type2, isOptional, true, preserveMissingMessageAnnotation(ast)));
            to.push(new PropertySignature(key, typeAST(type2), isOptional, true, toAnnotations));
            pss.push(new PropertySignature(key, type2, isOptional, true, toAnnotations));
            break;
          }
          case "PropertySignatureTransformation": {
            const fromKey2 = ast.from.fromKey ?? key;
            from.push(new PropertySignature(fromKey2, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
            to.push(new PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
            transformations.push(new PropertySignatureTransformation(fromKey2, key, ast.decode, ast.encode));
            break;
          }
        }
      } else {
        from.push(new PropertySignature(key, field.ast, false, true));
        to.push(new PropertySignature(key, typeAST(field.ast), false, true));
        pss.push(new PropertySignature(key, field.ast, false, true));
      }
    }
    if (isNonEmptyReadonlyArray(transformations)) {
      const issFrom = [];
      const issTo = [];
      for (const r2 of records) {
        const {
          indexSignatures,
          propertySignatures
        } = record(r2.key.ast, r2.value.ast);
        propertySignatures.forEach((ps) => {
          from.push(ps);
          to.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
        });
        indexSignatures.forEach((is4) => {
          issFrom.push(is4);
          issTo.push(new IndexSignature(is4.parameter, typeAST(is4.type), is4.isReadonly));
        });
      }
      return new Transformation(new TypeLiteral(from, issFrom, {
        [AutoTitleAnnotationId]: "Struct (Encoded side)"
      }), new TypeLiteral(to, issTo, {
        [AutoTitleAnnotationId]: "Struct (Type side)"
      }), new TypeLiteralTransformation(transformations));
    }
  }
  const iss = [];
  for (const r2 of records) {
    const {
      indexSignatures,
      propertySignatures
    } = record(r2.key.ast, r2.value.ast);
    propertySignatures.forEach((ps) => pss.push(ps));
    indexSignatures.forEach((is4) => iss.push(is4));
  }
  return new TypeLiteral(pss, iss);
};
var lazilyMergeDefaults = (fields, out2) => {
  const ownKeys2 = ownKeys(fields);
  for (const key of ownKeys2) {
    const field = fields[key];
    if (out2[key] === undefined && isPropertySignature(field)) {
      const ast = field.ast;
      const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
      if (defaultValue !== undefined) {
        out2[key] = defaultValue();
      }
    }
  }
  return out2;
};
function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
  return class TypeLiteralClass extends make69(ast) {
    static annotations(annotations2) {
      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static fields = {
      ...fields
    };
    static records = [...records];
    static make = (props, options) => {
      const propsWithDefaults = lazilyMergeDefaults(fields, {
        ...props
      });
      return getDisableValidationMakeOption(options) ? propsWithDefaults : validateSync(this)(propsWithDefaults);
    };
    static pick(...keys7) {
      return Struct(pick4(fields, ...keys7));
    }
    static omit(...keys7) {
      return Struct(omit4(fields, ...keys7));
    }
  };
}
function Struct(fields, ...records) {
  return makeTypeLiteralClass(fields, records);
}
var tag2 = (tag3) => Literal2(tag3).pipe(propertySignature, withConstructorDefault(() => tag3));
var TaggedStruct = (value5, fields) => Struct({
  _tag: tag2(value5),
  ...fields
});
function makeRecordClass(key, value5, ast) {
  return class RecordClass extends makeTypeLiteralClass({}, [{
    key,
    value: value5
  }], ast) {
    static annotations(annotations2) {
      return makeRecordClass(key, value5, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static key = key;
    static value = value5;
  };
}
var Record = (options) => makeRecordClass(options.key, options.value);
var pick5 = (...keys7) => (self2) => make69(pick(self2.ast, keys7));
var omit5 = (...keys7) => (self2) => make69(omit(self2.ast, keys7));
var pluck = /* @__PURE__ */ dual(2, (schema, key) => {
  const ps = getPropertyKeyIndexedAccess(typeAST(schema.ast), key);
  const value5 = make69(ps.isOptional ? orUndefined(ps.type) : ps.type);
  const out2 = transform2(schema.pipe(pick5(key)), value5, {
    strict: true,
    decode: (i2) => i2[key],
    encode: (a) => ps.isOptional && a === undefined ? {} : {
      [key]: a
    }
  });
  return out2;
});
function makeBrandClass(from, ast) {
  return class BrandClass extends make69(ast) {
    static annotations(annotations2) {
      return makeBrandClass(this.from, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static make = (a, options) => {
      return getDisableValidationMakeOption(options) ? a : validateSync(this)(a);
    };
    static from = from;
  };
}
var brand = (brand2, annotations2) => (self2) => {
  const annotation = match2(getBrandAnnotation(self2.ast), {
    onNone: () => [brand2],
    onSome: (brands) => [...brands, brand2]
  });
  const ast = annotations(self2.ast, toASTAnnotations({
    [BrandAnnotationId]: annotation,
    ...annotations2
  }));
  return makeBrandClass(self2, ast);
};
var partial2 = (self2) => make69(partial(self2.ast));
var partialWith = /* @__PURE__ */ dual((args3) => isSchema(args3[0]), (self2, options) => make69(partial(self2.ast, options)));
var required2 = (self2) => make69(required(self2.ast));
var mutable2 = (schema) => make69(mutable(schema.ast));
var intersectTypeLiterals = (x3, y2, path) => {
  if (isTypeLiteral(x3) && isTypeLiteral(y2)) {
    const propertySignatures = [...x3.propertySignatures];
    for (const ps of y2.propertySignatures) {
      const name2 = ps.name;
      const i2 = propertySignatures.findIndex((ps2) => ps2.name === name2);
      if (i2 === -1) {
        propertySignatures.push(ps);
      } else {
        const {
          isOptional,
          type: type2
        } = propertySignatures[i2];
        propertySignatures[i2] = new PropertySignature(name2, extendAST(type2, ps.type, path.concat(name2)), isOptional, true);
      }
    }
    return new TypeLiteral(propertySignatures, x3.indexSignatures.concat(y2.indexSignatures));
  }
  throw new Error(getSchemaExtendErrorMessage(x3, y2, path));
};
var preserveRefinementAnnotations = /* @__PURE__ */ omitAnnotations([IdentifierAnnotationId]);
var addRefinementToMembers = (refinement, asts) => asts.map((ast) => new Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)));
var extendAST = (x3, y2, path) => Union.make(intersectUnionMembers([x3], [y2], path));
var getTypes = (ast) => isUnion(ast) ? ast.types : [ast];
var intersectUnionMembers = (xs, ys, path) => flatMap2(xs, (x3) => flatMap2(ys, (y2) => {
  switch (y2._tag) {
    case "Literal": {
      if (isString(y2.literal) && isStringKeyword(x3) || isNumber(y2.literal) && isNumberKeyword(x3) || isBoolean(y2.literal) && isBooleanKeyword(x3)) {
        return [y2];
      }
      break;
    }
    case "StringKeyword": {
      if (y2 === stringKeyword) {
        if (isStringKeyword(x3) || isLiteral(x3) && isString(x3.literal)) {
          return [x3];
        } else if (isRefinement(x3)) {
          return addRefinementToMembers(x3, intersectUnionMembers(getTypes(x3.from), [y2], path));
        }
      } else if (x3 === stringKeyword) {
        return [y2];
      }
      break;
    }
    case "NumberKeyword": {
      if (y2 === numberKeyword) {
        if (isNumberKeyword(x3) || isLiteral(x3) && isNumber(x3.literal)) {
          return [x3];
        } else if (isRefinement(x3)) {
          return addRefinementToMembers(x3, intersectUnionMembers(getTypes(x3.from), [y2], path));
        }
      } else if (x3 === numberKeyword) {
        return [y2];
      }
      break;
    }
    case "BooleanKeyword": {
      if (y2 === booleanKeyword) {
        if (isBooleanKeyword(x3) || isLiteral(x3) && isBoolean(x3.literal)) {
          return [x3];
        } else if (isRefinement(x3)) {
          return addRefinementToMembers(x3, intersectUnionMembers(getTypes(x3.from), [y2], path));
        }
      } else if (x3 === booleanKeyword) {
        return [y2];
      }
      break;
    }
    case "Union":
      return intersectUnionMembers(getTypes(x3), y2.types, path);
    case "Suspend":
      return [new Suspend(() => extendAST(x3, y2.f(), path))];
    case "Refinement":
      return addRefinementToMembers(y2, intersectUnionMembers(getTypes(x3), getTypes(y2.from), path));
    case "TypeLiteral": {
      switch (x3._tag) {
        case "Union":
          return intersectUnionMembers(x3.types, [y2], path);
        case "Suspend":
          return [new Suspend(() => extendAST(x3.f(), y2, path))];
        case "Refinement":
          return addRefinementToMembers(x3, intersectUnionMembers(getTypes(x3.from), [y2], path));
        case "TypeLiteral":
          return [intersectTypeLiterals(x3, y2, path)];
        case "Transformation": {
          const transformation = x3.transformation;
          const from = intersectTypeLiterals(x3.from, y2, path);
          const to = intersectTypeLiterals(x3.to, typeAST(y2), path);
          switch (transformation._tag) {
            case "TypeLiteralTransformation":
              return [new Transformation(from, to, new TypeLiteralTransformation(transformation.propertySignatureTransformations))];
            case "ComposeTransformation":
              return [new Transformation(from, to, composeTransformation)];
            case "FinalTransformation":
              return [new Transformation(from, to, new FinalTransformation((fromA, options, ast, fromI) => map23(transformation.decode(fromA, options, ast, fromI), (partial3) => ({
                ...fromA,
                ...partial3
              })), (toI, options, ast, toA) => map23(transformation.encode(toI, options, ast, toA), (partial3) => ({
                ...toI,
                ...partial3
              }))))];
          }
        }
      }
      break;
    }
    case "Transformation": {
      if (isTransformation(x3)) {
        if (isTypeLiteralTransformation(y2.transformation) && isTypeLiteralTransformation(x3.transformation)) {
          return [new Transformation(intersectTypeLiterals(x3.from, y2.from, path), intersectTypeLiterals(x3.to, y2.to, path), new TypeLiteralTransformation(y2.transformation.propertySignatureTransformations.concat(x3.transformation.propertySignatureTransformations)))];
        }
      } else {
        return intersectUnionMembers([y2], [x3], path);
      }
      break;
    }
  }
  throw new Error(getSchemaExtendErrorMessage(x3, y2, path));
}));
var extend3 = /* @__PURE__ */ dual(2, (self2, that) => make69(extendAST(self2.ast, that.ast, [])));
var compose3 = /* @__PURE__ */ dual((args3) => isSchema(args3[1]), (from, to) => makeTransformationClass(from, to, compose(from.ast, to.ast)));
var suspend9 = (f) => make69(new Suspend(() => f().ast));
var RefineSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Refine");
function makeRefineClass(from, filter12, ast) {
  return class RefineClass extends make69(ast) {
    static annotations(annotations2) {
      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static [RefineSchemaId] = from;
    static from = from;
    static filter = filter12;
    static make = (a, options) => {
      return getDisableValidationMakeOption(options) ? a : validateSync(this)(a);
    };
  };
}
var fromFilterPredicateReturnTypeItem = (item, ast, input) => {
  if (isBoolean(item)) {
    return item ? none2() : some2(new Type2(ast, input));
  }
  if (isString(item)) {
    return some2(new Type2(ast, input, item));
  }
  if (item !== undefined) {
    if ("_tag" in item) {
      return some2(item);
    }
    const issue = new Type2(ast, input, item.message);
    return some2(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
  }
  return none2();
};
var toFilterParseIssue = (out2, ast, input) => {
  if (isSingle(out2)) {
    return fromFilterPredicateReturnTypeItem(out2, ast, input);
  }
  if (isNonEmptyReadonlyArray(out2)) {
    const issues = filterMap2(out2, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
    if (isNonEmptyReadonlyArray(issues)) {
      return some2(issues.length === 1 ? issues[0] : new Composite2(ast, input, issues));
    }
  }
  return none2();
};
function filter12(predicate, annotations2) {
  return (self2) => {
    function filter13(input, options, ast2) {
      return toFilterParseIssue(predicate(input, options, ast2), ast2, input);
    }
    const ast = new Refinement(self2.ast, filter13, toASTAnnotations(annotations2));
    return makeRefineClass(self2, filter13, ast);
  };
}
var filterEffect2 = /* @__PURE__ */ dual(2, (self2, f) => transformOrFail(self2, typeSchema(self2), {
  strict: true,
  decode: (i2, options, ast) => flatMap16(f(i2, options, ast), (filterReturnType) => match2(toFilterParseIssue(filterReturnType, ast, i2), {
    onNone: () => succeed15(i2),
    onSome: fail16
  })),
  encode: (a) => succeed15(a)
}));
function makeTransformationClass(from, to, ast) {
  return class TransformationClass extends make69(ast) {
    static annotations(annotations2) {
      return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static from = from;
    static to = to;
  };
}
var transformOrFail = /* @__PURE__ */ dual((args3) => isSchema(args3[0]) && isSchema(args3[1]), (from, to, options) => makeTransformationClass(from, to, new Transformation(from.ast, to.ast, new FinalTransformation(options.decode, options.encode))));
var transform2 = /* @__PURE__ */ dual((args3) => isSchema(args3[0]) && isSchema(args3[1]), (from, to, options) => transformOrFail(from, to, {
  strict: true,
  decode: (fromA, _options, _ast, toA) => succeed15(options.decode(fromA, toA)),
  encode: (toI, _options, _ast, toA) => succeed15(options.encode(toI, toA))
}));
function transformLiteral(from, to) {
  return transform2(Literal2(from), Literal2(to), {
    strict: true,
    decode: () => to,
    encode: () => from
  });
}
function transformLiterals(...pairs) {
  return Union2(...pairs.map(([from, to]) => transformLiteral(from, to)));
}
var attachPropertySignature = /* @__PURE__ */ dual((args3) => isSchema(args3[0]), (schema, key, value5, annotations2) => {
  const ast = extend3(typeSchema(schema), Struct({
    [key]: isSymbol(value5) ? UniqueSymbolFromSelf(value5) : Literal2(value5)
  })).ast;
  return make69(new Transformation(schema.ast, annotations2 ? mergeSchemaAnnotations(ast, annotations2) : ast, new TypeLiteralTransformation([new PropertySignatureTransformation(key, key, () => some2(value5), () => none2())])));
});
var annotations2 = /* @__PURE__ */ dual(2, (self2, annotations3) => self2.annotations(annotations3));
var rename2 = /* @__PURE__ */ dual(2, (self2, mapping) => make69(rename(self2.ast, mapping)));
var TrimmedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Trimmed");
var trimmed = (annotations3) => (self2) => self2.pipe(filter12((a) => a === a.trim(), {
  schemaId: TrimmedSchemaId,
  title: "trimmed",
  description: "a string with no leading or trailing whitespace",
  jsonSchema: {
    pattern: "^\\S[\\s\\S]*\\S$|^\\S$|^$"
  },
  ...annotations3
}));
var MaxLengthSchemaId2 = MaxLengthSchemaId;
var maxLength = (maxLength2, annotations3) => (self2) => self2.pipe(filter12((a) => a.length <= maxLength2, {
  schemaId: MaxLengthSchemaId2,
  title: `maxLength(${maxLength2})`,
  description: `a string at most ${maxLength2} character(s) long`,
  jsonSchema: {
    maxLength: maxLength2
  },
  ...annotations3
}));
var MinLengthSchemaId2 = MinLengthSchemaId;
var minLength = (minLength2, annotations3) => (self2) => self2.pipe(filter12((a) => a.length >= minLength2, {
  schemaId: MinLengthSchemaId2,
  title: `minLength(${minLength2})`,
  description: `a string at least ${minLength2} character(s) long`,
  jsonSchema: {
    minLength: minLength2
  },
  ...annotations3
}));
var LengthSchemaId2 = LengthSchemaId;
var length3 = (length4, annotations3) => (self2) => {
  const minLength2 = isObject(length4) ? Math.max(0, Math.floor(length4.min)) : Math.max(0, Math.floor(length4));
  const maxLength2 = isObject(length4) ? Math.max(minLength2, Math.floor(length4.max)) : minLength2;
  if (minLength2 !== maxLength2) {
    return self2.pipe(filter12((a) => a.length >= minLength2 && a.length <= maxLength2, {
      schemaId: LengthSchemaId2,
      title: `length({ min: ${minLength2}, max: ${maxLength2})`,
      description: `a string at least ${minLength2} character(s) and at most ${maxLength2} character(s) long`,
      jsonSchema: {
        minLength: minLength2,
        maxLength: maxLength2
      },
      ...annotations3
    }));
  }
  return self2.pipe(filter12((a) => a.length === minLength2, {
    schemaId: LengthSchemaId2,
    title: `length(${minLength2})`,
    description: minLength2 === 1 ? `a single character` : `a string ${minLength2} character(s) long`,
    jsonSchema: {
      minLength: minLength2,
      maxLength: minLength2
    },
    ...annotations3
  }));
};
var PatternSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Pattern");
var pattern = (regex, annotations3) => (self2) => {
  const source = regex.source;
  return self2.pipe(filter12((a) => {
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    schemaId: PatternSchemaId,
    [PatternSchemaId]: {
      regex
    },
    description: `a string matching the pattern ${source}`,
    jsonSchema: {
      pattern: source
    },
    ...annotations3
  }));
};
var StartsWithSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/StartsWith");
var startsWith = (startsWith2, annotations3) => (self2) => {
  const formatted = JSON.stringify(startsWith2);
  return self2.pipe(filter12((a) => a.startsWith(startsWith2), {
    schemaId: StartsWithSchemaId,
    [StartsWithSchemaId]: {
      startsWith: startsWith2
    },
    title: `startsWith(${formatted})`,
    description: `a string starting with ${formatted}`,
    jsonSchema: {
      pattern: `^${startsWith2}`
    },
    ...annotations3
  }));
};
var EndsWithSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/EndsWith");
var endsWith = (endsWith2, annotations3) => (self2) => {
  const formatted = JSON.stringify(endsWith2);
  return self2.pipe(filter12((a) => a.endsWith(endsWith2), {
    schemaId: EndsWithSchemaId,
    [EndsWithSchemaId]: {
      endsWith: endsWith2
    },
    title: `endsWith(${formatted})`,
    description: `a string ending with ${formatted}`,
    jsonSchema: {
      pattern: `^.*${endsWith2}$`
    },
    ...annotations3
  }));
};
var IncludesSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Includes");
var includes = (searchString, annotations3) => (self2) => {
  const formatted = JSON.stringify(searchString);
  return self2.pipe(filter12((a) => a.includes(searchString), {
    schemaId: IncludesSchemaId,
    [IncludesSchemaId]: {
      includes: searchString
    },
    title: `includes(${formatted})`,
    description: `a string including ${formatted}`,
    jsonSchema: {
      pattern: `.*${searchString}.*`
    },
    ...annotations3
  }));
};
var LowercasedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Lowercased");
var lowercased = (annotations3) => (self2) => self2.pipe(filter12((a) => a === a.toLowerCase(), {
  schemaId: LowercasedSchemaId,
  title: "lowercased",
  description: "a lowercase string",
  jsonSchema: {
    pattern: "^[^A-Z]*$"
  },
  ...annotations3
}));

class Lowercased extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ lowercased({
  identifier: "Lowercased"
}))) {
}
var UppercasedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Uppercased");
var uppercased = (annotations3) => (self2) => self2.pipe(filter12((a) => a === a.toUpperCase(), {
  schemaId: UppercasedSchemaId,
  title: "uppercased",
  description: "an uppercase string",
  jsonSchema: {
    pattern: "^[^a-z]*$"
  },
  ...annotations3
}));

class Uppercased extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ uppercased({
  identifier: "Uppercased"
}))) {
}
var CapitalizedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Capitalized");
var capitalized = (annotations3) => (self2) => self2.pipe(filter12((a) => a[0]?.toUpperCase() === a[0], {
  schemaId: CapitalizedSchemaId,
  title: "capitalized",
  description: "a capitalized string",
  jsonSchema: {
    pattern: "^[^a-z]?.*$"
  },
  ...annotations3
}));

class Capitalized extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ capitalized({
  identifier: "Capitalized"
}))) {
}
var UncapitalizedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Uncapitalized");
var uncapitalized = (annotations3) => (self2) => self2.pipe(filter12((a) => a[0]?.toLowerCase() === a[0], {
  schemaId: UncapitalizedSchemaId,
  title: "uncapitalized",
  description: "a uncapitalized string",
  jsonSchema: {
    pattern: "^[^A-Z]?.*$"
  },
  ...annotations3
}));

class Uncapitalized extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ uncapitalized({
  identifier: "Uncapitalized"
}))) {
}

class Char extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ length3(1, {
  identifier: "Char"
}))) {
}
var nonEmptyString3 = (annotations3) => minLength(1, {
  title: "nonEmptyString",
  description: "a non empty string",
  ...annotations3
});

class Lowercase extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be converted to lowercase"
}), Lowercased, {
  strict: true,
  decode: (i2) => i2.toLowerCase(),
  encode: identity
}).annotations({
  identifier: "Lowercase"
})) {
}

class Uppercase extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be converted to uppercase"
}), Uppercased, {
  strict: true,
  decode: (i2) => i2.toUpperCase(),
  encode: identity
}).annotations({
  identifier: "Uppercase"
})) {
}

class Capitalize extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be converted to a capitalized format"
}), Capitalized, {
  strict: true,
  decode: (i2) => capitalize(i2),
  encode: identity
}).annotations({
  identifier: "Capitalize"
})) {
}

class Uncapitalize extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be converted to an uncapitalized format"
}), Uncapitalized, {
  strict: true,
  decode: (i2) => uncapitalize(i2),
  encode: identity
}).annotations({
  identifier: "Uncapitalize"
})) {
}

class Trimmed extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ trimmed({
  identifier: "Trimmed"
}))) {
}

class NonEmptyTrimmedString extends (/* @__PURE__ */ Trimmed.pipe(/* @__PURE__ */ nonEmptyString3({
  identifier: "NonEmptyTrimmedString"
}))) {
}

class Trim extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be trimmed"
}), Trimmed, {
  strict: true,
  decode: (i2) => i2.trim(),
  encode: identity
}).annotations({
  identifier: "Trim"
})) {
}
var split = (separator) => transform2(String$.annotations({
  description: "a string that will be split"
}), Array$(String$), {
  strict: true,
  decode: (i2) => i2.split(separator),
  encode: (a) => a.join(separator)
});
var getErrorMessage2 = (e) => e instanceof Error ? e.message : String(e);
var getParseJsonTransformation = (options) => transformOrFail(String$.annotations({
  description: "a string to be decoded into JSON"
}), Unknown, {
  strict: true,
  decode: (i2, _2, ast) => _try({
    try: () => JSON.parse(i2, options?.reviver),
    catch: (e) => new Type2(ast, i2, getErrorMessage2(e))
  }),
  encode: (a, _2, ast) => _try({
    try: () => JSON.stringify(a, options?.replacer, options?.space),
    catch: (e) => new Type2(ast, a, getErrorMessage2(e))
  })
}).annotations({
  title: "parseJson",
  schemaId: ParseJsonSchemaId
});
var parseJson2 = (schemaOrOptions, o3) => isSchema(schemaOrOptions) ? compose3(parseJson2(o3), schemaOrOptions) : getParseJsonTransformation(schemaOrOptions);

class NonEmptyString extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ nonEmptyString3({
  identifier: "NonEmptyString"
}))) {
}
var UUIDSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/UUID");
var uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;

class UUID extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ pattern(uuidRegexp, {
  schemaId: UUIDSchemaId,
  identifier: "UUID",
  jsonSchema: {
    format: "uuid",
    pattern: uuidRegexp.source
  },
  description: "a Universally Unique Identifier",
  arbitrary: () => (fc) => fc.uuid()
}))) {
}
var ULIDSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ULID");
var ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;

class ULID extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ pattern(ulidRegexp, {
  schemaId: ULIDSchemaId,
  identifier: "ULID",
  description: "a Universally Unique Lexicographically Sortable Identifier",
  arbitrary: () => (fc) => fc.ulid()
}))) {
}

class URLFromSelf extends (/* @__PURE__ */ instanceOf2(URL, {
  identifier: "URLFromSelf",
  arbitrary: () => (fc) => fc.webUrl().map((s2) => new URL(s2)),
  pretty: () => (url2) => url2.toString()
})) {
}

class URL$ extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a URL"
}), URLFromSelf, {
  strict: true,
  decode: (i2, _2, ast) => _try({
    try: () => new URL(i2),
    catch: (e) => new Type2(ast, i2, `Unable to decode ${JSON.stringify(i2)} into a URL. ${getErrorMessage2(e)}`)
  }),
  encode: (a) => succeed15(a.toString())
}).annotations({
  identifier: "URL",
  pretty: () => (url2) => url2.toString()
})) {
}
var FiniteSchemaId2 = FiniteSchemaId;
var finite = (annotations3) => (self2) => self2.pipe(filter12(Number.isFinite, {
  schemaId: FiniteSchemaId2,
  title: "finite",
  description: "a finite number",
  jsonSchema: {
    type: "number"
  },
  ...annotations3
}));
var GreaterThanSchemaId2 = GreaterThanSchemaId;
var greaterThan6 = (exclusiveMinimum, annotations3) => (self2) => self2.pipe(filter12((a) => a > exclusiveMinimum, {
  schemaId: GreaterThanSchemaId2,
  title: `greaterThan(${exclusiveMinimum})`,
  description: exclusiveMinimum === 0 ? "a positive number" : `a number greater than ${exclusiveMinimum}`,
  jsonSchema: {
    exclusiveMinimum
  },
  ...annotations3
}));
var GreaterThanOrEqualToSchemaId2 = GreaterThanOrEqualToSchemaId;
var greaterThanOrEqualTo6 = (minimum, annotations3) => (self2) => self2.pipe(filter12((a) => a >= minimum, {
  schemaId: GreaterThanOrEqualToSchemaId2,
  title: `greaterThanOrEqualTo(${minimum})`,
  description: minimum === 0 ? "a non-negative number" : `a number greater than or equal to ${minimum}`,
  jsonSchema: {
    minimum
  },
  ...annotations3
}));
var MultipleOfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MultipleOf");
var multipleOf = (divisor, annotations3) => (self2) => {
  const positiveDivisor = Math.abs(divisor);
  return self2.pipe(filter12((a) => remainder(a, divisor) === 0, {
    schemaId: MultipleOfSchemaId,
    title: `multipleOf(${positiveDivisor})`,
    description: `a number divisible by ${positiveDivisor}`,
    jsonSchema: {
      multipleOf: positiveDivisor
    },
    ...annotations3
  }));
};
var IntSchemaId2 = IntSchemaId;
var int = (annotations3) => (self2) => self2.pipe(filter12((a) => Number.isSafeInteger(a), {
  schemaId: IntSchemaId2,
  title: "int",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations3
}));
var LessThanSchemaId2 = LessThanSchemaId;
var lessThan9 = (exclusiveMaximum, annotations3) => (self2) => self2.pipe(filter12((a) => a < exclusiveMaximum, {
  schemaId: LessThanSchemaId2,
  title: `lessThan(${exclusiveMaximum})`,
  description: exclusiveMaximum === 0 ? "a negative number" : `a number less than ${exclusiveMaximum}`,
  jsonSchema: {
    exclusiveMaximum
  },
  ...annotations3
}));
var LessThanOrEqualToSchemaId2 = LessThanOrEqualToSchemaId;
var lessThanOrEqualTo5 = (maximum, annotations3) => (self2) => self2.pipe(filter12((a) => a <= maximum, {
  schemaId: LessThanOrEqualToSchemaId2,
  title: `lessThanOrEqualTo(${maximum})`,
  description: maximum === 0 ? "a non-positive number" : `a number less than or equal to ${maximum}`,
  jsonSchema: {
    maximum
  },
  ...annotations3
}));
var BetweenSchemaId2 = BetweenSchemaId;
var between6 = (minimum, maximum, annotations3) => (self2) => self2.pipe(filter12((a) => a >= minimum && a <= maximum, {
  schemaId: BetweenSchemaId2,
  title: `between(${minimum}, ${maximum})`,
  description: `a number between ${minimum} and ${maximum}`,
  jsonSchema: {
    minimum,
    maximum
  },
  ...annotations3
}));
var NonNaNSchemaId2 = NonNaNSchemaId;
var nonNaN = (annotations3) => (self2) => self2.pipe(filter12((a) => !Number.isNaN(a), {
  schemaId: NonNaNSchemaId2,
  title: "nonNaN",
  description: "a number excluding NaN",
  ...annotations3
}));
var positive = (annotations3) => greaterThan6(0, {
  title: "positive",
  ...annotations3
});
var negative = (annotations3) => lessThan9(0, {
  title: "negative",
  ...annotations3
});
var nonPositive = (annotations3) => lessThanOrEqualTo5(0, {
  title: "nonPositive",
  ...annotations3
});
var nonNegative = (annotations3) => greaterThanOrEqualTo6(0, {
  title: "nonNegative",
  ...annotations3
});
var clamp8 = (minimum, maximum) => (self2) => {
  return transform2(self2, typeSchema(self2).pipe(between6(minimum, maximum)), {
    strict: false,
    decode: (i2) => clamp3(i2, {
      minimum,
      maximum
    }),
    encode: identity
  });
};
function parseNumber2(self2) {
  return transformOrFail(self2, Number$, {
    strict: false,
    decode: (i2, _2, ast) => fromOption4(parse(i2), () => new Type2(ast, i2, `Unable to decode ${JSON.stringify(i2)} into a number`)),
    encode: (a) => succeed15(String(a))
  });
}

class NumberFromString extends (/* @__PURE__ */ parseNumber2(String$.annotations({
  description: "a string to be decoded into a number"
})).annotations({
  identifier: "NumberFromString"
})) {
}

class Finite extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ finite({
  identifier: "Finite"
}))) {
}

class Int extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ int({
  identifier: "Int"
}))) {
}

class NonNaN extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonNaN({
  identifier: "NonNaN"
}))) {
}

class Positive extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ positive({
  identifier: "Positive"
}))) {
}

class Negative extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ negative({
  identifier: "Negative"
}))) {
}

class NonPositive extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonPositive({
  identifier: "NonPositive"
}))) {
}

class NonNegative extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonNegative({
  identifier: "NonNegative"
}))) {
}
var JsonNumberSchemaId2 = JsonNumberSchemaId;

class JsonNumber extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ finite({
  schemaId: JsonNumberSchemaId2,
  identifier: "JsonNumber"
}))) {
}

class Not extends (/* @__PURE__ */ transform2(/* @__PURE__ */ Boolean$.annotations({
  description: "a boolean that will be negated"
}), Boolean$, {
  strict: true,
  decode: (i2) => not2(i2),
  encode: (a) => not2(a)
})) {
}
var encodeSymbol = (sym, ast) => {
  const key = Symbol.keyFor(sym);
  return key === undefined ? fail16(new Type2(ast, sym, `Unable to encode a unique symbol ${String(sym)} into a string`)) : succeed15(key);
};
var decodeSymbol = (s2) => succeed15(Symbol.for(s2));

class Symbol$ extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a globally shared symbol"
}), SymbolFromSelf, {
  strict: false,
  decode: (i2) => decodeSymbol(i2),
  encode: (a, _2, ast) => encodeSymbol(a, ast)
}).annotations({
  identifier: "Symbol"
})) {
}
var GreaterThanBigIntSchemaId = GreaterThanBigintSchemaId;
var greaterThanBigInt = (min4, annotations3) => (self2) => self2.pipe(filter12((a) => a > min4, {
  schemaId: GreaterThanBigIntSchemaId,
  [GreaterThanBigIntSchemaId]: {
    min: min4
  },
  title: `greaterThanBigInt(${min4})`,
  description: min4 === 0n ? "a positive bigint" : `a bigint greater than ${min4}n`,
  ...annotations3
}));
var GreaterThanOrEqualToBigIntSchemaId2 = GreaterThanOrEqualToBigIntSchemaId;
var greaterThanOrEqualToBigInt = (min4, annotations3) => (self2) => self2.pipe(filter12((a) => a >= min4, {
  schemaId: GreaterThanOrEqualToBigIntSchemaId2,
  [GreaterThanOrEqualToBigIntSchemaId2]: {
    min: min4
  },
  title: `greaterThanOrEqualToBigInt(${min4})`,
  description: min4 === 0n ? "a non-negative bigint" : `a bigint greater than or equal to ${min4}n`,
  ...annotations3
}));
var LessThanBigIntSchemaId2 = LessThanBigIntSchemaId;
var lessThanBigInt = (max6, annotations3) => (self2) => self2.pipe(filter12((a) => a < max6, {
  schemaId: LessThanBigIntSchemaId2,
  [LessThanBigIntSchemaId2]: {
    max: max6
  },
  title: `lessThanBigInt(${max6})`,
  description: max6 === 0n ? "a negative bigint" : `a bigint less than ${max6}n`,
  ...annotations3
}));
var LessThanOrEqualToBigIntSchemaId2 = LessThanOrEqualToBigIntSchemaId;
var lessThanOrEqualToBigInt = (max6, annotations3) => (self2) => self2.pipe(filter12((a) => a <= max6, {
  schemaId: LessThanOrEqualToBigIntSchemaId2,
  [LessThanOrEqualToBigIntSchemaId2]: {
    max: max6
  },
  title: `lessThanOrEqualToBigInt(${max6})`,
  description: max6 === 0n ? "a non-positive bigint" : `a bigint less than or equal to ${max6}n`,
  ...annotations3
}));
var BetweenBigIntSchemaId = BetweenBigintSchemaId;
var betweenBigInt = (min4, max6, annotations3) => (self2) => self2.pipe(filter12((a) => a >= min4 && a <= max6, {
  schemaId: BetweenBigIntSchemaId,
  [BetweenBigIntSchemaId]: {
    min: min4,
    max: max6
  },
  title: `betweenBigInt(${min4}, ${max6})`,
  description: `a bigint between ${min4}n and ${max6}n`,
  ...annotations3
}));
var positiveBigInt = (annotations3) => greaterThanBigInt(0n, {
  title: "positiveBigInt",
  ...annotations3
});
var negativeBigInt = (annotations3) => lessThanBigInt(0n, {
  title: "negativeBigInt",
  ...annotations3
});
var nonNegativeBigInt = (annotations3) => greaterThanOrEqualToBigInt(0n, {
  title: "nonNegativeBigInt",
  ...annotations3
});
var nonPositiveBigInt = (annotations3) => lessThanOrEqualToBigInt(0n, {
  title: "nonPositiveBigInt",
  ...annotations3
});
var clampBigInt = (minimum, maximum) => (self2) => transform2(self2, self2.pipe(typeSchema, betweenBigInt(minimum, maximum)), {
  strict: false,
  decode: (i2) => clamp5(i2, {
    minimum,
    maximum
  }),
  encode: identity
});

class BigInt$ extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a bigint"
}), BigIntFromSelf, {
  strict: true,
  decode: (i2, _2, ast) => fromOption4(fromString2(i2), () => new Type2(ast, i2, `Unable to decode ${JSON.stringify(i2)} into a bigint`)),
  encode: (a) => succeed15(String(a))
}).annotations({
  identifier: "BigInt"
})) {
}
var PositiveBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ positiveBigInt({
  identifier: "PositiveBigintFromSelf"
}));
var PositiveBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ positiveBigInt({
  identifier: "PositiveBigint"
}));
var NegativeBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ negativeBigInt({
  identifier: "NegativeBigintFromSelf"
}));
var NegativeBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ negativeBigInt({
  identifier: "NegativeBigint"
}));
var NonPositiveBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ nonPositiveBigInt({
  identifier: "NonPositiveBigintFromSelf"
}));
var NonPositiveBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ nonPositiveBigInt({
  identifier: "NonPositiveBigint"
}));
var NonNegativeBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ nonNegativeBigInt({
  identifier: "NonNegativeBigintFromSelf"
}));
var NonNegativeBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ nonNegativeBigInt({
  identifier: "NonNegativeBigint"
}));

class BigIntFromNumber extends (/* @__PURE__ */ transformOrFail(Number$.annotations({
  description: "a number to be decoded into a bigint"
}), BigIntFromSelf.pipe(betweenBigInt(BigInt(Number.MIN_SAFE_INTEGER), BigInt(Number.MAX_SAFE_INTEGER))), {
  strict: true,
  decode: (i2, _2, ast) => fromOption4(fromNumber(i2), () => new Type2(ast, i2, `Unable to decode ${i2} into a bigint`)),
  encode: (a, _2, ast) => fromOption4(toNumber(a), () => new Type2(ast, a, `Unable to encode ${a}n into a number`))
}).annotations({
  identifier: "BigIntFromNumber"
})) {
}
var redactedArbitrary = (value5) => (fc) => value5(fc).map(make67);
var toComposite = (eff, onSuccess, ast, actual) => mapBoth6(eff, {
  onFailure: (e) => new Composite2(ast, actual, e),
  onSuccess
});
var redactedParse = (decodeUnknown4) => (u3, options, ast) => isRedacted2(u3) ? toComposite(decodeUnknown4(value4(u3), options), make67, ast, u3) : fail16(new Type2(ast, u3));
var RedactedFromSelf = (value5) => declare([value5], {
  decode: (value6) => redactedParse(decodeUnknown2(value6)),
  encode: (value6) => redactedParse(encodeUnknown(value6))
}, {
  description: "Redacted(<redacted>)",
  pretty: () => () => "Redacted(<redacted>)",
  arbitrary: redactedArbitrary,
  equivalence: getEquivalence7
});
function Redacted(value5) {
  return transform2(value5, RedactedFromSelf(typeSchema(asSchema(value5))), {
    strict: true,
    decode: (i2) => make67(i2),
    encode: (a) => value4(a)
  });
}

class DurationFromSelf extends (/* @__PURE__ */ declare(isDuration, {
  identifier: "DurationFromSelf",
  pretty: () => String,
  arbitrary: () => (fc) => fc.oneof(fc.constant(infinity), fc.bigInt({
    min: 0n
  }).map((_2) => nanos(_2)), fc.maxSafeNat().map((_2) => millis(_2))),
  equivalence: () => Equivalence2
})) {
}

class DurationFromNanos extends (/* @__PURE__ */ transformOrFail(NonNegativeBigIntFromSelf.annotations({
  description: "a bigint to be decoded into a Duration"
}), DurationFromSelf.pipe(filter12((duration3) => isFinite(duration3), {
  description: "a finite duration"
})), {
  strict: true,
  decode: (i2) => succeed15(nanos(i2)),
  encode: (a, _2, ast) => match2(toNanos(a), {
    onNone: () => fail16(new Type2(ast, a, `Unable to encode ${a} into a bigint`)),
    onSome: (nanos2) => succeed15(nanos2)
  })
}).annotations({
  identifier: "DurationFromNanos"
})) {
}
var NonNegativeInt = /* @__PURE__ */ NonNegative.pipe(int()).annotations({
  identifier: "NonNegativeInt"
});

class DurationFromMillis extends (/* @__PURE__ */ transform2(NonNegative.annotations({
  description: "a non-negative number to be decoded into a Duration"
}), DurationFromSelf, {
  strict: true,
  decode: (i2) => millis(i2),
  encode: (a) => toMillis(a)
}).annotations({
  identifier: "DurationFromMillis"
})) {
}
var DurationValueMillis = /* @__PURE__ */ TaggedStruct("Millis", {
  millis: NonNegativeInt
});
var DurationValueNanos = /* @__PURE__ */ TaggedStruct("Nanos", {
  nanos: BigInt$
});
var DurationValueInfinity = /* @__PURE__ */ TaggedStruct("Infinity", {});
var durationValueInfinity = /* @__PURE__ */ DurationValueInfinity.make({});
var DurationValue = /* @__PURE__ */ Union2(DurationValueMillis, DurationValueNanos, DurationValueInfinity).annotations({
  identifier: "DurationValue",
  description: "an JSON-compatible tagged union to be decoded into a Duration"
});
var FiniteHRTime = /* @__PURE__ */ Tuple(element(NonNegativeInt).annotations({
  title: "seconds"
}), element(NonNegativeInt).annotations({
  title: "nanos"
})).annotations({
  identifier: "FiniteHRTime"
});
var InfiniteHRTime = /* @__PURE__ */ Tuple(Literal2(-1), Literal2(0)).annotations({
  identifier: "InfiniteHRTime"
});
var HRTime = /* @__PURE__ */ Union2(FiniteHRTime, InfiniteHRTime).annotations({
  identifier: "HRTime",
  description: "a tuple of seconds and nanos to be decoded into a Duration"
});
var isDurationValue = (u3) => typeof u3 === "object";

class Duration extends (/* @__PURE__ */ transform2(Union2(DurationValue, HRTime), DurationFromSelf, {
  strict: true,
  decode: (i2) => {
    if (isDurationValue(i2)) {
      switch (i2._tag) {
        case "Millis":
          return millis(i2.millis);
        case "Nanos":
          return nanos(i2.nanos);
        case "Infinity":
          return infinity;
      }
    }
    const [seconds2, nanos2] = i2;
    return seconds2 === -1 ? infinity : nanos(BigInt(seconds2) * BigInt(1e9) + BigInt(nanos2));
  },
  encode: (a) => {
    switch (a.value._tag) {
      case "Millis":
        return DurationValueMillis.make({
          millis: a.value.millis
        });
      case "Nanos":
        return DurationValueNanos.make({
          nanos: a.value.nanos
        });
      case "Infinity":
        return durationValueInfinity;
    }
  }
}).annotations({
  identifier: "Duration"
})) {
}
var clampDuration = (minimum, maximum) => (self2) => transform2(self2, self2.pipe(typeSchema, betweenDuration(minimum, maximum)), {
  strict: false,
  decode: (i2) => clamp6(i2, {
    minimum,
    maximum
  }),
  encode: identity
});
var LessThanDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanDuration");
var lessThanDuration = (max6, annotations3) => (self2) => self2.pipe(filter12((a) => lessThan3(a, max6), {
  schemaId: LessThanDurationSchemaId,
  [LessThanDurationSchemaId]: {
    max: max6
  },
  title: `lessThanDuration(${max6})`,
  description: `a Duration less than ${decode(max6)}`,
  ...annotations3
}));
var LessThanOrEqualToDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/LessThanOrEqualToDuration");
var lessThanOrEqualToDuration = (max6, annotations3) => (self2) => self2.pipe(filter12((a) => lessThanOrEqualTo3(a, max6), {
  schemaId: LessThanDurationSchemaId,
  [LessThanDurationSchemaId]: {
    max: max6
  },
  title: `lessThanOrEqualToDuration(${max6})`,
  description: `a Duration less than or equal to ${decode(max6)}`,
  ...annotations3
}));
var GreaterThanDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanDuration");
var greaterThanDuration = (min4, annotations3) => (self2) => self2.pipe(filter12((a) => greaterThan3(a, min4), {
  schemaId: GreaterThanDurationSchemaId,
  [GreaterThanDurationSchemaId]: {
    min: min4
  },
  title: `greaterThanDuration(${min4})`,
  description: `a Duration greater than ${decode(min4)}`,
  ...annotations3
}));
var GreaterThanOrEqualToDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/GreaterThanOrEqualToDuration");
var greaterThanOrEqualToDuration = (min4, annotations3) => (self2) => self2.pipe(filter12((a) => greaterThanOrEqualTo3(a, min4), {
  schemaId: GreaterThanOrEqualToDurationSchemaId,
  [GreaterThanOrEqualToDurationSchemaId]: {
    min: min4
  },
  title: `greaterThanOrEqualToDuration(${min4})`,
  description: `a Duration greater than or equal to ${decode(min4)}`,
  ...annotations3
}));
var BetweenDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenDuration");
var betweenDuration = (minimum, maximum, annotations3) => (self2) => self2.pipe(filter12((a) => between4(a, {
  minimum,
  maximum
}), {
  schemaId: BetweenDurationSchemaId,
  [BetweenDurationSchemaId]: {
    maximum,
    minimum
  },
  title: `betweenDuration(${minimum}, ${maximum})`,
  description: `a Duration between ${decode(minimum)} and ${decode(maximum)}`,
  ...annotations3
}));

class Uint8ArrayFromSelf extends (/* @__PURE__ */ declare(isUint8Array, {
  identifier: "Uint8ArrayFromSelf",
  pretty: () => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
  arbitrary: () => (fc) => fc.uint8Array(),
  equivalence: () => getEquivalence3(equals)
})) {
}

class Uint8 extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ between6(0, 255, {
  identifier: "Uint8",
  description: "a 8-bit unsigned integer"
}))) {
}

class Uint8Array$ extends (/* @__PURE__ */ transform2(Array$(Uint8).annotations({
  description: "an array of 8-bit unsigned integers to be decoded into a Uint8Array"
}), Uint8ArrayFromSelf, {
  strict: true,
  decode: (i2) => Uint8Array.from(i2),
  encode: (a) => Array.from(a)
}).annotations({
  identifier: "Uint8Array"
})) {
}
var makeUint8ArrayTransformation = (id2, decode6, encode5) => transformOrFail(String$.annotations({
  description: "a string to be decoded into a Uint8Array"
}), Uint8ArrayFromSelf, {
  strict: true,
  decode: (i2, _2, ast) => mapLeft(decode6(i2), (decodeException) => new Type2(ast, i2, decodeException.message)),
  encode: (a) => succeed15(encode5(a))
}).annotations({
  identifier: id2
});
var Uint8ArrayFromBase64 = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromBase64", decodeBase64, encodeBase64);
var Uint8ArrayFromBase64Url = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromBase64Url", decodeBase64Url, encodeBase64Url);
var Uint8ArrayFromHex = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromHex", decodeHex, encodeHex);
var makeEncodingTransformation = (id2, decode6, encode5) => transformOrFail(String$.annotations({
  description: `A string that is interpreted as being ${id2}-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: (i2, _2, ast) => mapLeft(decode6(i2), (decodeException) => new Type2(ast, i2, decodeException.message)),
  encode: (a) => succeed15(encode5(a))
}).annotations({
  identifier: `StringFrom${id2}`
});
var StringFromBase64 = /* @__PURE__ */ makeEncodingTransformation("Base64", decodeBase64String, encodeBase64);
var StringFromBase64Url = /* @__PURE__ */ makeEncodingTransformation("Base64Url", decodeBase64UrlString, encodeBase64Url);
var StringFromHex = /* @__PURE__ */ makeEncodingTransformation("Hex", decodeHexString, encodeHex);
var StringFromUriComponent = /* @__PURE__ */ transformOrFail(String$.annotations({
  description: `A string that is interpreted as being UriComponent-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: (i2, _2, ast) => mapLeft(decodeUriComponent(i2), (decodeException) => new Type2(ast, i2, decodeException.message)),
  encode: (a, _2, ast) => mapLeft(encodeUriComponent(a), (encodeException) => new Type2(ast, a, encodeException.message))
}).annotations({
  identifier: `StringFromUriComponent`
});
var MinItemsSchemaId2 = MinItemsSchemaId;
var minItems = (n, annotations3) => (self2) => {
  const minItems2 = Math.floor(n);
  if (minItems2 < 1) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self2.pipe(filter12((a) => a.length >= minItems2, {
    schemaId: MinItemsSchemaId2,
    title: `minItems(${minItems2})`,
    description: `an array of at least ${minItems2} item(s)`,
    jsonSchema: {
      minItems: minItems2
    },
    [StableFilterAnnotationId]: true,
    ...annotations3
  }));
};
var MaxItemsSchemaId2 = MaxItemsSchemaId;
var maxItems = (n, annotations3) => (self2) => {
  const maxItems2 = Math.floor(n);
  if (maxItems2 < 1) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self2.pipe(filter12((a) => a.length <= maxItems2, {
    schemaId: MaxItemsSchemaId2,
    title: `maxItems(${maxItems2})`,
    description: `an array of at most ${maxItems2} item(s)`,
    jsonSchema: {
      maxItems: maxItems2
    },
    [StableFilterAnnotationId]: true,
    ...annotations3
  }));
};
var ItemsCountSchemaId2 = ItemsCountSchemaId;
var itemsCount = (n, annotations3) => (self2) => {
  const itemsCount2 = Math.floor(n);
  if (itemsCount2 < 0) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 0, actual ${n}`));
  }
  return self2.pipe(filter12((a) => a.length === itemsCount2, {
    schemaId: ItemsCountSchemaId2,
    title: `itemsCount(${itemsCount2})`,
    description: `an array of exactly ${itemsCount2} item(s)`,
    jsonSchema: {
      minItems: itemsCount2,
      maxItems: itemsCount2
    },
    [StableFilterAnnotationId]: true,
    ...annotations3
  }));
};
var getNumberIndexedAccess2 = (self2) => make69(getNumberIndexedAccess(self2.ast));
function head8(self2) {
  return transform2(self2, OptionFromSelf(getNumberIndexedAccess2(typeSchema(self2))), {
    strict: false,
    decode: (i2) => head(i2),
    encode: (a) => match2(a, {
      onNone: () => [],
      onSome: of
    })
  });
}
function headNonEmpty3(self2) {
  return transform2(self2, getNumberIndexedAccess2(typeSchema(self2)), {
    strict: false,
    decode: (i2) => headNonEmpty(i2),
    encode: (a) => of(a)
  });
}
var headOrElse = /* @__PURE__ */ dual((args3) => isSchema(args3[0]), (self2, fallback) => transformOrFail(self2, getNumberIndexedAccess2(typeSchema(self2)), {
  strict: true,
  decode: (i2, _2, ast) => i2.length > 0 ? succeed15(i2[0]) : fallback ? succeed15(fallback()) : fail16(new Type2(ast, i2, "Unable to retrieve the first element of an empty array")),
  encode: (a) => succeed15(of(a))
}));
var ValidDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ValidDate");
var validDate = (annotations3) => (self2) => self2.pipe(filter12((a) => !Number.isNaN(a.getTime()), {
  schemaId: ValidDateSchemaId,
  [ValidDateSchemaId]: {
    noInvalidDate: true
  },
  title: "validDate",
  description: "a valid Date",
  ...annotations3
}));
var LessThanDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanDate");
var lessThanDate = (max6, annotations3) => (self2) => self2.pipe(filter12((a) => a < max6, {
  schemaId: LessThanDateSchemaId,
  [LessThanDateSchemaId]: {
    max: max6
  },
  title: `lessThanDate(${formatDate(max6)})`,
  description: `a date before ${formatDate(max6)}`,
  ...annotations3
}));
var LessThanOrEqualToDateSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/LessThanOrEqualToDate");
var lessThanOrEqualToDate = (max6, annotations3) => (self2) => self2.pipe(filter12((a) => a <= max6, {
  schemaId: LessThanDateSchemaId,
  [LessThanDateSchemaId]: {
    max: max6
  },
  title: `lessThanOrEqualToDate(${formatDate(max6)})`,
  description: `a date before or equal to ${formatDate(max6)}`,
  ...annotations3
}));
var GreaterThanDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanDate");
var greaterThanDate = (min4, annotations3) => (self2) => self2.pipe(filter12((a) => a > min4, {
  schemaId: GreaterThanDateSchemaId,
  [GreaterThanDateSchemaId]: {
    min: min4
  },
  title: `greaterThanDate(${formatDate(min4)})`,
  description: `a date after ${formatDate(min4)}`,
  ...annotations3
}));
var GreaterThanOrEqualToDateSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/GreaterThanOrEqualToDate");
var greaterThanOrEqualToDate = (min4, annotations3) => (self2) => self2.pipe(filter12((a) => a >= min4, {
  schemaId: GreaterThanOrEqualToDateSchemaId,
  [GreaterThanOrEqualToDateSchemaId]: {
    min: min4
  },
  title: `greaterThanOrEqualToDate(${formatDate(min4)})`,
  description: `a date after or equal to ${formatDate(min4)}`,
  ...annotations3
}));
var BetweenDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenDate");
var betweenDate = (min4, max6, annotations3) => (self2) => self2.pipe(filter12((a) => a <= max6 && a >= min4, {
  schemaId: BetweenDateSchemaId,
  [BetweenDateSchemaId]: {
    max: max6,
    min: min4
  },
  title: `betweenDate(${formatDate(min4)}, ${formatDate(max6)})`,
  description: `a date between ${formatDate(min4)} and ${formatDate(max6)}`,
  ...annotations3
}));
var DateFromSelfSchemaId2 = DateFromSelfSchemaId;

class DateFromSelf extends (/* @__PURE__ */ declare(isDate, {
  identifier: "DateFromSelf",
  schemaId: DateFromSelfSchemaId2,
  [DateFromSelfSchemaId2]: {
    noInvalidDate: false
  },
  description: "a potentially invalid Date instance",
  pretty: () => (date3) => `new Date(${JSON.stringify(date3)})`,
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Date2
})) {
}

class ValidDateFromSelf extends (/* @__PURE__ */ DateFromSelf.pipe(/* @__PURE__ */ validDate({
  identifier: "ValidDateFromSelf",
  description: "a valid Date instance"
}))) {
}

class DateFromString extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: (i2) => new Date(i2),
  encode: (a) => formatDate(a)
}).annotations({
  identifier: "DateFromString"
})) {
}

class Date$ extends (/* @__PURE__ */ DateFromString.pipe(/* @__PURE__ */ validDate({
  identifier: "Date"
}))) {
}
class DateFromNumber extends (/* @__PURE__ */ transform2(Number$.annotations({
  description: "a number to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: (i2) => new Date(i2),
  encode: (a) => a.getTime()
}).annotations({
  identifier: "DateFromNumber"
})) {
}

class DateTimeUtcFromSelf extends (/* @__PURE__ */ declare((u3) => isDateTime2(u3) && isUtc2(u3), {
  identifier: "DateTimeUtcFromSelf",
  description: "a DateTime.Utc instance",
  pretty: () => (dateTime) => dateTime.toString(),
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: true
  }).map((date3) => unsafeFromDate2(date3)),
  equivalence: () => Equivalence5
})) {
}
var decodeDateTimeUtc = (input, ast) => _try({
  try: () => unsafeMake10(input),
  catch: () => new Type2(ast, input, `Unable to decode ${formatUnknown(input)} into a DateTime.Utc`)
});

class DateTimeUtcFromNumber extends (/* @__PURE__ */ transformOrFail(Number$.annotations({
  description: "a number to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i2, _2, ast) => decodeDateTimeUtc(i2, ast),
  encode: (a) => succeed15(toEpochMillis2(a))
}).annotations({
  identifier: "DateTimeUtcFromNumber"
})) {
}

class DateTimeUtcFromDate extends (/* @__PURE__ */ transformOrFail(DateFromSelf.annotations({
  description: "a Date to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i2, _2, ast) => decodeDateTimeUtc(i2, ast),
  encode: (a) => succeed15(toDateUtc2(a))
}).annotations({
  identifier: "DateTimeUtcFromDate"
})) {
}

class DateTimeUtc extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i2, _2, ast) => decodeDateTimeUtc(i2, ast),
  encode: (a) => succeed15(formatIso2(a))
}).annotations({
  identifier: "DateTimeUtc"
})) {
}
var timeZoneOffsetArbitrary = () => (fc) => fc.integer({
  min: -12 * 60 * 60 * 1000,
  max: 14 * 60 * 60 * 1000
}).map(zoneMakeOffset2);

class TimeZoneOffsetFromSelf extends (/* @__PURE__ */ declare(isTimeZoneOffset2, {
  identifier: "TimeZoneOffsetFromSelf",
  description: "a TimeZone.Offset instance",
  pretty: () => (zone) => zone.toString(),
  arbitrary: timeZoneOffsetArbitrary
})) {
}

class TimeZoneOffset extends (/* @__PURE__ */ transform2(Number$.annotations({
  description: "a number to be decoded into a TimeZone.Offset"
}), TimeZoneOffsetFromSelf, {
  strict: true,
  decode: (i2) => zoneMakeOffset2(i2),
  encode: (a) => a.offset
}).annotations({
  identifier: "TimeZoneOffset"
})) {
}
var timeZoneNamedArbitrary = () => (fc) => fc.constantFrom(...Intl.supportedValuesOf("timeZone")).map(zoneUnsafeMakeNamed2);

class TimeZoneNamedFromSelf extends (/* @__PURE__ */ declare(isTimeZoneNamed2, {
  identifier: "TimeZoneNamedFromSelf",
  description: "a TimeZone.Named instance",
  pretty: () => (zone) => zone.toString(),
  arbitrary: timeZoneNamedArbitrary
})) {
}

class TimeZoneNamed extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a TimeZone.Named"
}), TimeZoneNamedFromSelf, {
  strict: true,
  decode: (i2, _2, ast) => _try({
    try: () => zoneUnsafeMakeNamed2(i2),
    catch: () => new Type2(ast, i2, `Unable to decode ${JSON.stringify(i2)} into a TimeZone.Named`)
  }),
  encode: (a) => succeed15(a.id)
}).annotations({
  identifier: "TimeZoneNamed"
})) {
}

class TimeZoneFromSelf extends (/* @__PURE__ */ Union2(TimeZoneOffsetFromSelf, TimeZoneNamedFromSelf)) {
}

class TimeZone extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a TimeZone"
}), TimeZoneFromSelf, {
  strict: true,
  decode: (i2, _2, ast) => match2(zoneFromString2(i2), {
    onNone: () => fail16(new Type2(ast, i2, `Unable to decode ${JSON.stringify(i2)} into a TimeZone`)),
    onSome: succeed15
  }),
  encode: (a) => succeed15(zoneToString2(a))
}).annotations({
  identifier: "TimeZone"
})) {
}
var timeZoneArbitrary = (fc) => fc.oneof(timeZoneOffsetArbitrary()(fc), timeZoneNamedArbitrary()(fc));

class DateTimeZonedFromSelf extends (/* @__PURE__ */ declare((u3) => isDateTime2(u3) && isZoned2(u3), {
  identifier: "DateTimeZonedFromSelf",
  description: "a DateTime.Zoned instance",
  pretty: () => (dateTime) => dateTime.toString(),
  arbitrary: () => (fc) => fc.tuple(fc.integer({
    min: -31536000000000,
    max: 31536000000000
  }), timeZoneArbitrary(fc)).map(([millis2, timeZone]) => unsafeMakeZoned2(millis2, {
    timeZone
  })),
  equivalence: () => Equivalence5
})) {
}

class DateTimeZoned extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a DateTime.Zoned"
}), DateTimeZonedFromSelf, {
  strict: true,
  decode: (i2, _2, ast) => match2(makeZonedFromString2(i2), {
    onNone: () => fail16(new Type2(ast, i2, `Unable to decode ${JSON.stringify(i2)} into a DateTime.Zoned`)),
    onSome: succeed15
  }),
  encode: (a) => succeed15(formatIsoZoned2(a))
}).annotations({
  identifier: "DateTimeZoned"
})) {
}
var OptionNoneEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("None")
}).annotations({
  description: "NoneEncoded"
});
var optionSomeEncoded = (value5) => Struct({
  _tag: Literal2("Some"),
  value: value5
}).annotations({
  description: `SomeEncoded<${format6(value5)}>`
});
var optionEncoded = (value5) => Union2(OptionNoneEncoded, optionSomeEncoded(value5)).annotations({
  description: `OptionEncoded<${format6(value5)}>`
});
var optionDecode = (input) => input._tag === "None" ? none2() : some2(input.value);
var optionArbitrary = (value5, ctx) => (fc) => fc.oneof(ctx, fc.record({
  _tag: fc.constant("None")
}), fc.record({
  _tag: fc.constant("Some"),
  value: value5(fc)
})).map(optionDecode);
var optionPretty = (value5) => match2({
  onNone: () => "none()",
  onSome: (a) => `some(${value5(a)})`
});
var optionParse = (decodeUnknown4) => (u3, options, ast) => isOption2(u3) ? isNone2(u3) ? succeed15(none2()) : toComposite(decodeUnknown4(u3.value, options), some2, ast, u3) : fail16(new Type2(ast, u3));
var OptionFromSelf = (value5) => {
  return declare([value5], {
    decode: (value6) => optionParse(decodeUnknown2(value6)),
    encode: (value6) => optionParse(encodeUnknown(value6))
  }, {
    description: `Option<${format6(value5)}>`,
    pretty: optionPretty,
    arbitrary: optionArbitrary,
    equivalence: getEquivalence2
  });
};
var makeNoneEncoded = {
  _tag: "None"
};
var makeSomeEncoded = (value5) => ({
  _tag: "Some",
  value: value5
});
function Option(value5) {
  const value_ = asSchema(value5);
  const out2 = transform2(optionEncoded(value_), OptionFromSelf(typeSchema(value_)), {
    strict: true,
    decode: (i2) => optionDecode(i2),
    encode: (a) => match2(a, {
      onNone: () => makeNoneEncoded,
      onSome: makeSomeEncoded
    })
  });
  return out2;
}
function OptionFromNullOr(value5) {
  return transform2(NullOr(value5), OptionFromSelf(typeSchema(asSchema(value5))), {
    strict: true,
    decode: (i2) => fromNullable(i2),
    encode: (a) => getOrNull(a)
  });
}
function OptionFromNullishOr(value5, onNoneEncoding) {
  return transform2(NullishOr(value5), OptionFromSelf(typeSchema(asSchema(value5))), {
    strict: true,
    decode: (i2) => fromNullable(i2),
    encode: onNoneEncoding === null ? (a) => getOrNull(a) : (a) => getOrUndefined(a)
  });
}
function OptionFromUndefinedOr(value5) {
  return transform2(UndefinedOr(value5), OptionFromSelf(typeSchema(asSchema(value5))), {
    strict: true,
    decode: (i2) => fromNullable(i2),
    encode: (a) => getOrUndefined(a)
  });
}

class OptionFromNonEmptyTrimmedString extends (/* @__PURE__ */ transform2(String$, /* @__PURE__ */ OptionFromSelf(NonEmptyTrimmedString), {
  strict: true,
  decode: (i2) => filter(some2(i2.trim()), isNonEmpty6),
  encode: (a) => getOrElse(a, () => "")
})) {
}
var rightEncoded = (right3) => Struct({
  _tag: Literal2("Right"),
  right: right3
}).annotations({
  description: `RightEncoded<${format6(right3)}>`
});
var leftEncoded = (left3) => Struct({
  _tag: Literal2("Left"),
  left: left3
}).annotations({
  description: `LeftEncoded<${format6(left3)}>`
});
var eitherEncoded = (right3, left3) => Union2(rightEncoded(right3), leftEncoded(left3)).annotations({
  description: `EitherEncoded<${format6(left3)}, ${format6(right3)}>`
});
var eitherDecode = (input) => input._tag === "Left" ? left2(input.left) : right2(input.right);
var eitherArbitrary = (right3, left3) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Left"),
  left: left3(fc)
}), fc.record({
  _tag: fc.constant("Right"),
  right: right3(fc)
})).map(eitherDecode);
var eitherPretty = (right3, left3) => match({
  onLeft: (e) => `left(${left3(e)})`,
  onRight: (a) => `right(${right3(a)})`
});
var eitherParse = (parseRight, decodeUnknownLeft) => (u3, options, ast) => isEither2(u3) ? match(u3, {
  onLeft: (left3) => toComposite(decodeUnknownLeft(left3, options), left2, ast, u3),
  onRight: (right3) => toComposite(parseRight(right3, options), right2, ast, u3)
}) : fail16(new Type2(ast, u3));
var EitherFromSelf = ({
  left: left3,
  right: right3
}) => {
  return declare([right3, left3], {
    decode: (right4, left4) => eitherParse(decodeUnknown2(right4), decodeUnknown2(left4)),
    encode: (right4, left4) => eitherParse(encodeUnknown(right4), encodeUnknown(left4))
  }, {
    description: `Either<${format6(right3)}, ${format6(left3)}>`,
    pretty: eitherPretty,
    arbitrary: eitherArbitrary,
    equivalence: (right4, left4) => getEquivalence({
      left: left4,
      right: right4
    })
  });
};
var makeLeftEncoded = (left3) => ({
  _tag: "Left",
  left: left3
});
var makeRightEncoded = (right3) => ({
  _tag: "Right",
  right: right3
});
var Either2 = ({
  left: left3,
  right: right3
}) => {
  const right_ = asSchema(right3);
  const left_ = asSchema(left3);
  const out2 = transform2(eitherEncoded(right_, left_), EitherFromSelf({
    left: typeSchema(left_),
    right: typeSchema(right_)
  }), {
    strict: true,
    decode: (i2) => eitherDecode(i2),
    encode: (a) => match(a, {
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
  return out2;
};
var EitherFromUnion = ({
  left: left3,
  right: right3
}) => {
  const right_ = asSchema(right3);
  const left_ = asSchema(left3);
  const toright = typeSchema(right_);
  const toleft = typeSchema(left_);
  const fromRight = transform2(right_, rightEncoded(toright), {
    strict: true,
    decode: (i2) => makeRightEncoded(i2),
    encode: (a) => a.right
  });
  const fromLeft = transform2(left_, leftEncoded(toleft), {
    strict: true,
    decode: (i2) => makeLeftEncoded(i2),
    encode: (a) => a.left
  });
  const out2 = transform2(Union2(fromRight, fromLeft), EitherFromSelf({
    left: toleft,
    right: toright
  }), {
    strict: true,
    decode: (i2) => i2._tag === "Left" ? left2(i2.left) : right2(i2.right),
    encode: (a) => match(a, {
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
  return out2;
};
var mapArbitrary = (key, value5, ctx) => {
  return (fc) => {
    const items = fc.array(fc.tuple(key(fc), value5(fc)));
    return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as7) => new Map(as7));
  };
};
var readonlyMapPretty = (key, value5) => (map26) => `new Map([${Array.from(map26.entries()).map(([k2, v2]) => `[${key(k2)}, ${value5(v2)}]`).join(", ")}])`;
var readonlyMapEquivalence = (key, value5) => {
  const arrayEquivalence = getEquivalence3(make(([ka, va], [kb, vb]) => key(ka, kb) && value5(va, vb)));
  return make((a, b3) => arrayEquivalence(Array.from(a.entries()), Array.from(b3.entries())));
};
var readonlyMapParse = (decodeUnknown4) => (u3, options, ast) => isMap(u3) ? toComposite(decodeUnknown4(Array.from(u3.entries()), options), (as7) => new Map(as7), ast, u3) : fail16(new Type2(ast, u3));
var mapFromSelf_ = (key, value5, description) => declare([key, value5], {
  decode: (Key2, Value2) => readonlyMapParse(decodeUnknown2(Array$(Tuple(Key2, Value2)))),
  encode: (Key2, Value2) => readonlyMapParse(encodeUnknown(Array$(Tuple(Key2, Value2))))
}, {
  description,
  pretty: readonlyMapPretty,
  arbitrary: mapArbitrary,
  equivalence: readonlyMapEquivalence
});
var ReadonlyMapFromSelf = ({
  key,
  value: value5
}) => mapFromSelf_(key, value5, `ReadonlyMap<${format6(key)}, ${format6(value5)}>`);
var MapFromSelf = ({
  key,
  value: value5
}) => mapFromSelf_(key, value5, `Map<${format6(key)}, ${format6(value5)}>`);
function ReadonlyMap({
  key,
  value: value5
}) {
  return transform2(Array$(Tuple(key, value5)), ReadonlyMapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value5))
  }), {
    strict: true,
    decode: (i2) => new Map(i2),
    encode: (a) => Array.from(a.entries())
  });
}
function map26({
  key,
  value: value5
}) {
  return transform2(Array$(Tuple(key, value5)), MapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value5))
  }), {
    strict: true,
    decode: (i2) => new Map(i2),
    encode: (a) => Array.from(a.entries())
  });
}
var ReadonlyMapFromRecord = ({
  key,
  value: value5
}) => transform2(Record({
  key: encodedBoundSchema(key),
  value: value5
}).annotations({
  description: "a record to be decoded into a ReadonlyMap"
}), ReadonlyMapFromSelf({
  key,
  value: typeSchema(value5)
}), {
  strict: true,
  decode: (i2) => new Map(Object.entries(i2)),
  encode: (a) => Object.fromEntries(a)
});
var MapFromRecord = ({
  key,
  value: value5
}) => transform2(Record({
  key: encodedBoundSchema(key),
  value: value5
}).annotations({
  description: "a record to be decoded into a Map"
}), MapFromSelf({
  key,
  value: typeSchema(value5)
}), {
  strict: true,
  decode: (i2) => new Map(Object.entries(i2)),
  encode: (a) => Object.fromEntries(a)
});
var setArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as7) => new Set(as7));
};
var readonlySetPretty = (item) => (set10) => `new Set([${Array.from(set10.values()).map((a) => item(a)).join(", ")}])`;
var readonlySetEquivalence = (item) => {
  const arrayEquivalence = getEquivalence3(item);
  return make((a, b3) => arrayEquivalence(Array.from(a.values()), Array.from(b3.values())));
};
var readonlySetParse = (decodeUnknown4) => (u3, options, ast) => isSet(u3) ? toComposite(decodeUnknown4(Array.from(u3.values()), options), (as7) => new Set(as7), ast, u3) : fail16(new Type2(ast, u3));
var setFromSelf_ = (value5, description) => declare([value5], {
  decode: (item) => readonlySetParse(decodeUnknown2(Array$(item))),
  encode: (item) => readonlySetParse(encodeUnknown(Array$(item)))
}, {
  description,
  pretty: readonlySetPretty,
  arbitrary: setArbitrary,
  equivalence: readonlySetEquivalence
});
var ReadonlySetFromSelf = (value5) => setFromSelf_(value5, `ReadonlySet<${format6(value5)}>`);
var SetFromSelf = (value5) => setFromSelf_(value5, `Set<${format6(value5)}>`);
function ReadonlySet(value5) {
  return transform2(Array$(value5), ReadonlySetFromSelf(typeSchema(asSchema(value5))), {
    strict: true,
    decode: (i2) => new Set(i2),
    encode: (a) => Array.from(a)
  });
}
function set10(value5) {
  return transform2(Array$(value5), SetFromSelf(typeSchema(asSchema(value5))), {
    strict: true,
    decode: (i2) => new Set(i2),
    encode: (a) => Array.from(a)
  });
}
var bigDecimalPretty = () => (val) => `BigDecimal(${format2(normalize(val))})`;
var bigDecimalArbitrary = () => (fc) => fc.tuple(fc.bigInt(), fc.integer({
  min: 0,
  max: 18
})).map(([value5, scale2]) => make4(value5, scale2));

class BigDecimalFromSelf extends (/* @__PURE__ */ declare(isBigDecimal, {
  identifier: "BigDecimalFromSelf",
  pretty: bigDecimalPretty,
  arbitrary: bigDecimalArbitrary,
  equivalence: () => Equivalence
})) {
}

class BigDecimal extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a BigDecimal"
}), BigDecimalFromSelf, {
  strict: true,
  decode: (i2, _2, ast) => fromString(i2).pipe(match2({
    onNone: () => fail16(new Type2(ast, i2, `Unable to decode ${JSON.stringify(i2)} into a BigDecimal`)),
    onSome: (val) => succeed15(normalize(val))
  })),
  encode: (a) => succeed15(format2(normalize(a)))
}).annotations({
  identifier: "BigDecimal"
})) {
}

class BigDecimalFromNumber extends (/* @__PURE__ */ transform2(Number$.annotations({
  description: "a number to be decoded into a BigDecimal"
}), BigDecimalFromSelf, {
  strict: true,
  decode: (i2) => unsafeFromNumber(i2),
  encode: (a) => unsafeToNumber(a)
}).annotations({
  identifier: "BigDecimalFromNumber"
})) {
}
var GreaterThanBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanBigDecimal");
var greaterThanBigDecimal = (min4, annotations3) => (self2) => {
  const formatted = format2(min4);
  return self2.pipe(filter12((a) => greaterThan2(a, min4), {
    schemaId: GreaterThanBigDecimalSchemaId,
    [GreaterThanBigDecimalSchemaId]: {
      min: min4
    },
    title: `greaterThanBigDecimal(${formatted})`,
    description: `a BigDecimal greater than ${formatted}`,
    ...annotations3
  }));
};
var GreaterThanOrEqualToBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/GreaterThanOrEqualToBigDecimal");
var greaterThanOrEqualToBigDecimal = (min4, annotations3) => (self2) => {
  const formatted = format2(min4);
  return self2.pipe(filter12((a) => greaterThanOrEqualTo2(a, min4), {
    schemaId: GreaterThanOrEqualToBigDecimalSchemaId,
    [GreaterThanOrEqualToBigDecimalSchemaId]: {
      min: min4
    },
    title: `greaterThanOrEqualToBigDecimal(${formatted})`,
    description: `a BigDecimal greater than or equal to ${formatted}`,
    ...annotations3
  }));
};
var LessThanBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanBigDecimal");
var lessThanBigDecimal = (max6, annotations3) => (self2) => {
  const formatted = format2(max6);
  return self2.pipe(filter12((a) => lessThan2(a, max6), {
    schemaId: LessThanBigDecimalSchemaId,
    [LessThanBigDecimalSchemaId]: {
      max: max6
    },
    title: `lessThanBigDecimal(${formatted})`,
    description: `a BigDecimal less than ${formatted}`,
    ...annotations3
  }));
};
var LessThanOrEqualToBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/LessThanOrEqualToBigDecimal");
var lessThanOrEqualToBigDecimal = (max6, annotations3) => (self2) => {
  const formatted = format2(max6);
  return self2.pipe(filter12((a) => lessThanOrEqualTo2(a, max6), {
    schemaId: LessThanOrEqualToBigDecimalSchemaId,
    [LessThanOrEqualToBigDecimalSchemaId]: {
      max: max6
    },
    title: `lessThanOrEqualToBigDecimal(${formatted})`,
    description: `a BigDecimal less than or equal to ${formatted}`,
    ...annotations3
  }));
};
var PositiveBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/PositiveBigDecimal");
var positiveBigDecimal = (annotations3) => (self2) => self2.pipe(filter12((a) => isPositive(a), {
  schemaId: PositiveBigDecimalSchemaId,
  title: "positiveBigDecimal",
  description: `a positive BigDecimal`,
  ...annotations3
}));
var PositiveBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ positiveBigDecimal({
  identifier: "PositiveBigDecimalFromSelf"
}));
var NonNegativeBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/NonNegativeBigDecimal");
var nonNegativeBigDecimal = (annotations3) => (self2) => self2.pipe(filter12((a) => a.value >= 0n, {
  schemaId: NonNegativeBigDecimalSchemaId,
  title: "nonNegativeBigDecimal",
  description: `a non-negative BigDecimal`,
  ...annotations3
}));
var NonNegativeBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ nonNegativeBigDecimal({
  identifier: "NonNegativeBigDecimalFromSelf"
}));
var NegativeBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/NegativeBigDecimal");
var negativeBigDecimal = (annotations3) => (self2) => self2.pipe(filter12((a) => isNegative(a), {
  schemaId: NegativeBigDecimalSchemaId,
  title: "negativeBigDecimal",
  description: `a negative BigDecimal`,
  ...annotations3
}));
var NegativeBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ negativeBigDecimal({
  identifier: "NegativeBigDecimalFromSelf"
}));
var NonPositiveBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/NonPositiveBigDecimal");
var nonPositiveBigDecimal = (annotations3) => (self2) => self2.pipe(filter12((a) => a.value <= 0n, {
  schemaId: NonPositiveBigDecimalSchemaId,
  title: "nonPositiveBigDecimal",
  description: `a non-positive BigDecimal`,
  ...annotations3
}));
var NonPositiveBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ nonPositiveBigDecimal({
  identifier: "NonPositiveBigDecimalFromSelf"
}));
var BetweenBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenBigDecimal");
var betweenBigDecimal = (minimum, maximum, annotations3) => (self2) => {
  const formattedMinimum = format2(minimum);
  const formattedMaximum = format2(maximum);
  return self2.pipe(filter12((a) => between3(a, {
    minimum,
    maximum
  }), {
    schemaId: BetweenBigDecimalSchemaId,
    [BetweenBigDecimalSchemaId]: {
      maximum,
      minimum
    },
    title: `betweenBigDecimal(${formattedMinimum}, ${formattedMaximum})`,
    description: `a BigDecimal between ${formattedMinimum} and ${formattedMaximum}`,
    ...annotations3
  }));
};
var clampBigDecimal = (minimum, maximum) => (self2) => transform2(self2, self2.pipe(typeSchema, betweenBigDecimal(minimum, maximum)), {
  strict: false,
  decode: (i2) => clamp4(i2, {
    minimum,
    maximum
  }),
  encode: identity
});
var chunkArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable2);
};
var chunkPretty = (item) => (c) => `Chunk(${toReadonlyArray(c).map(item).join(", ")})`;
var chunkParse = (decodeUnknown4) => (u3, options, ast) => isChunk(u3) ? isEmpty(u3) ? succeed15(empty5()) : toComposite(decodeUnknown4(toReadonlyArray(u3), options), fromIterable2, ast, u3) : fail16(new Type2(ast, u3));
var ChunkFromSelf = (value5) => {
  return declare([value5], {
    decode: (item) => chunkParse(decodeUnknown2(Array$(item))),
    encode: (item) => chunkParse(encodeUnknown(Array$(item)))
  }, {
    description: `Chunk<${format6(value5)}>`,
    pretty: chunkPretty,
    arbitrary: chunkArbitrary,
    equivalence: getEquivalence4
  });
};
function Chunk(value5) {
  return transform2(Array$(value5), ChunkFromSelf(typeSchema(asSchema(value5))), {
    strict: true,
    decode: (i2) => i2.length === 0 ? empty5() : fromIterable2(i2),
    encode: (a) => toReadonlyArray(a)
  });
}
var nonEmptyChunkArbitrary = (item) => (fc) => array4(item(fc), {
  minLength: 1
}).map((as7) => unsafeFromNonEmptyArray(as7));
var nonEmptyChunkPretty = (item) => (c) => `NonEmptyChunk(${toReadonlyArray(c).map(item).join(", ")})`;
var nonEmptyChunkParse = (decodeUnknown4) => (u3, options, ast) => isChunk(u3) && isNonEmpty2(u3) ? toComposite(decodeUnknown4(toReadonlyArray(u3), options), unsafeFromNonEmptyArray, ast, u3) : fail16(new Type2(ast, u3));
var NonEmptyChunkFromSelf = (value5) => {
  return declare([value5], {
    decode: (item) => nonEmptyChunkParse(decodeUnknown2(NonEmptyArray(item))),
    encode: (item) => nonEmptyChunkParse(encodeUnknown(NonEmptyArray(item)))
  }, {
    description: `NonEmptyChunk<${format6(value5)}>`,
    pretty: nonEmptyChunkPretty,
    arbitrary: nonEmptyChunkArbitrary,
    equivalence: getEquivalence4
  });
};
function NonEmptyChunk(value5) {
  return transform2(NonEmptyArray(value5), NonEmptyChunkFromSelf(typeSchema(asSchema(value5))), {
    strict: true,
    decode: (i2) => unsafeFromNonEmptyArray(i2),
    encode: (a) => toReadonlyArray(a)
  });
}
var decodeData = (a) => Array.isArray(a) ? array5(a) : struct2(a);
var dataArbitrary = (item) => (fc) => item(fc).map(decodeData);
var dataPretty = (item) => (d2) => `Data(${item(d2)})`;
var dataParse = (decodeUnknown4) => (u3, options, ast) => isEqual(u3) ? toComposite(decodeUnknown4(u3, options), decodeData, ast, u3) : fail16(new Type2(ast, u3));
var DataFromSelf = (value5) => {
  return declare([value5], {
    decode: (item) => dataParse(decodeUnknown2(item)),
    encode: (item) => dataParse(encodeUnknown(item))
  }, {
    description: `Data<${format6(value5)}>`,
    pretty: dataPretty,
    arbitrary: dataArbitrary
  });
};
var Data = (value5) => {
  return transform2(value5, DataFromSelf(typeSchema(value5)), {
    strict: false,
    decode: (i2) => decodeData(i2),
    encode: (a) => Array.isArray(a) ? Array.from(a) : Object.assign({}, a)
  });
};
var isField = (u3) => isSchema(u3) || isPropertySignature(u3);
var isFields = (fields) => ownKeys(fields).every((key) => isField(fields[key]));
var getFields = (hasFields) => ("fields" in hasFields) ? hasFields.fields : getFields(hasFields[RefineSchemaId]);
var getSchemaFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr));
var getFieldsFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr);
var Class5 = (identifier2) => (fieldsOr, annotations3) => makeClass({
  kind: "Class",
  identifier: identifier2,
  schema: getSchemaFromFieldsOr(fieldsOr),
  fields: getFieldsFromFieldsOr(fieldsOr),
  Base: Class3,
  annotations: annotations3
});
var getClassTag = (tag3) => withConstructorDefault(propertySignature(Literal2(tag3)), () => tag3);
var TaggedClass2 = (identifier2) => (tag3, fieldsOr, annotations3) => {
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag3)
  };
  const taggedFields = extendFields(newFields, fields);
  return class TaggedClass3 extends makeClass({
    kind: "TaggedClass",
    identifier: identifier2 ?? tag3,
    schema: extend3(schema, Struct(newFields)),
    fields: taggedFields,
    Base: Class3,
    annotations: annotations3
  }) {
    static _tag = tag3;
  };
};
var TaggedError2 = (identifier2) => (tag3, fieldsOr, annotations3) => {

  class Base3 extends Error3 {
  }
  Base3.prototype.name = tag3;
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag3)
  };
  const taggedFields = extendFields(newFields, fields);
  const hasMessageField = "message" in taggedFields;

  class TaggedErrorClass extends makeClass({
    kind: "TaggedError",
    identifier: identifier2 ?? tag3,
    schema: extend3(schema, Struct(newFields)),
    fields: taggedFields,
    Base: Base3,
    annotations: annotations3,
    disableToString: true
  }) {
    static _tag = tag3;
  }
  if (!hasMessageField) {
    Object.defineProperty(TaggedErrorClass.prototype, "message", {
      get() {
        return `{ ${ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} }`;
      },
      enumerable: false,
      configurable: true
    });
  }
  return TaggedErrorClass;
};
var extendFields = (a, b3) => {
  const out2 = {
    ...a
  };
  for (const key of ownKeys(b3)) {
    if (key in a) {
      throw new Error(getASTDuplicatePropertySignatureErrorMessage(key));
    }
    out2[key] = b3[key];
  }
  return out2;
};
function getDisableValidationMakeOption(options) {
  return isBoolean(options) ? options : options?.disableValidation ?? false;
}
var astCache = /* @__PURE__ */ globalValue("effect/Schema/astCache", () => new WeakMap);
var getClassAnnotations = (annotations3) => {
  if (annotations3 === undefined) {
    return [];
  } else if (Array.isArray(annotations3)) {
    return annotations3;
  } else {
    return [annotations3];
  }
};
var makeClass = ({
  Base: Base3,
  annotations: annotations3,
  disableToString,
  fields,
  identifier: identifier2,
  kind,
  schema
}) => {
  const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier2}`);
  const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations3);
  const typeSchema_ = typeSchema(schema);
  const declarationSurrogate = typeSchema_.annotations({
    identifier: identifier2,
    ...typeAnnotations
  });
  const typeSide = typeSchema_.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Type side)`,
    ...typeAnnotations
  });
  const constructorSchema = schema.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Constructor)`,
    ...typeAnnotations
  });
  const encodedSide = schema.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Encoded side)`,
    ...encodedAnnotations
  });
  const transformationSurrogate = schema.annotations({
    [JSONIdentifierAnnotationId]: identifier2,
    ...encodedAnnotations,
    ...typeAnnotations,
    ...transformationAnnotations
  });
  const fallbackInstanceOf = (u3) => hasProperty(u3, classSymbol) && is2(typeSide)(u3);
  const klass = class extends Base3 {
    constructor(props = {}, options = false) {
      props = {
        ...props
      };
      if (kind !== "Class") {
        delete props["_tag"];
      }
      props = lazilyMergeDefaults(fields, props);
      if (!getDisableValidationMakeOption(options)) {
        props = validateSync(constructorSchema)(props);
      }
      super(props, true);
    }
    static [TypeId30] = variance9;
    static get ast() {
      let out2 = astCache.get(this);
      if (out2) {
        return out2;
      }
      const declaration = declare([schema], {
        decode: () => (input, _2, ast) => input instanceof this || fallbackInstanceOf(input) ? succeed15(input) : fail16(new Type2(ast, input)),
        encode: () => (input, options) => input instanceof this ? succeed15(input) : map23(encodeUnknown(typeSide)(input, options), (props) => new this(props, true))
      }, {
        identifier: identifier2,
        pretty: (pretty4) => (self2) => `${identifier2}(${pretty4(self2)})`,
        arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),
        equivalence: identity,
        [SurrogateAnnotationId]: declarationSurrogate.ast,
        ...typeAnnotations
      });
      out2 = transform2(encodedSide, declaration, {
        strict: true,
        decode: (i2) => new this(i2, true),
        encode: identity
      }).annotations({
        [SurrogateAnnotationId]: transformationSurrogate.ast,
        ...transformationAnnotations
      }).ast;
      astCache.set(this, out2);
      return out2;
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static annotations(annotations4) {
      return make69(this.ast).annotations(annotations4);
    }
    static toString() {
      return `(${String(encodedSide)} <-> ${identifier2})`;
    }
    static make(...args3) {
      return new this(...args3);
    }
    static fields = {
      ...fields
    };
    static identifier = identifier2;
    static extend(identifier3) {
      return (newFieldsOr, annotations4) => {
        const newFields = getFieldsFromFieldsOr(newFieldsOr);
        const newSchema = getSchemaFromFieldsOr(newFieldsOr);
        const extendedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: extend3(schema, newSchema),
          fields: extendedFields,
          Base: this,
          annotations: annotations4
        });
      };
    }
    static transformOrFail(identifier3) {
      return (newFieldsOr, options, annotations4) => {
        const transformedFields = extendFields(fields, newFieldsOr);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(schema, typeSchema(Struct(transformedFields)), options),
          fields: transformedFields,
          Base: this,
          annotations: annotations4
        });
      };
    }
    static transformOrFailFrom(identifier3) {
      return (newFields, options, annotations4) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(encodedSchema(schema), Struct(transformedFields), options),
          fields: transformedFields,
          Base: this,
          annotations: annotations4
        });
      };
    }
    get [classSymbol]() {
      return classSymbol;
    }
  };
  if (disableToString !== true) {
    Object.defineProperty(klass.prototype, "toString", {
      value() {
        return `${identifier2}({ ${ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} })`;
      },
      configurable: true,
      writable: true
    });
  }
  return klass;
};
var FiberIdNoneEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("None")
}).annotations({
  identifier: "FiberIdNoneEncoded"
});
var FiberIdRuntimeEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("Runtime"),
  id: Int,
  startTimeMillis: Int
}).annotations({
  identifier: "FiberIdRuntimeEncoded"
});
var FiberIdCompositeEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("Composite"),
  left: suspend9(() => FiberIdEncoded),
  right: suspend9(() => FiberIdEncoded)
}).annotations({
  identifier: "FiberIdCompositeEncoded"
});
var FiberIdEncoded = /* @__PURE__ */ Union2(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
  identifier: "FiberIdEncoded"
});
var fiberIdArbitrary = (fc) => fc.letrec((tie) => ({
  None: fc.record({
    _tag: fc.constant("None")
  }),
  Runtime: fc.record({
    _tag: fc.constant("Runtime"),
    id: fc.integer(),
    startTimeMillis: fc.integer()
  }),
  Composite: fc.record({
    _tag: fc.constant("Composite"),
    left: tie("FiberId"),
    right: tie("FiberId")
  }),
  FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
})).FiberId.map(fiberIdDecode);
var fiberIdPretty = (fiberId4) => {
  switch (fiberId4._tag) {
    case "None":
      return "FiberId.none";
    case "Runtime":
      return `FiberId.runtime(${fiberId4.id}, ${fiberId4.startTimeMillis})`;
    case "Composite":
      return `FiberId.composite(${fiberIdPretty(fiberId4.right)}, ${fiberIdPretty(fiberId4.left)})`;
  }
};

class FiberIdFromSelf extends (/* @__PURE__ */ declare(isFiberId2, {
  identifier: "FiberIdFromSelf",
  pretty: () => fiberIdPretty,
  arbitrary: () => fiberIdArbitrary
})) {
}
var fiberIdDecode = (input) => {
  switch (input._tag) {
    case "None":
      return none4;
    case "Runtime":
      return runtime2(input.id, input.startTimeMillis);
    case "Composite":
      return composite2(fiberIdDecode(input.left), fiberIdDecode(input.right));
  }
};
var fiberIdEncode = (input) => {
  switch (input._tag) {
    case "None":
      return {
        _tag: "None"
      };
    case "Runtime":
      return {
        _tag: "Runtime",
        id: input.id,
        startTimeMillis: input.startTimeMillis
      };
    case "Composite":
      return {
        _tag: "Composite",
        left: fiberIdEncode(input.left),
        right: fiberIdEncode(input.right)
      };
  }
};

class FiberId extends (/* @__PURE__ */ transform2(FiberIdEncoded, FiberIdFromSelf, {
  strict: true,
  decode: (i2) => fiberIdDecode(i2),
  encode: (a) => fiberIdEncode(a)
}).annotations({
  identifier: "FiberId"
})) {
}
var causeDieEncoded = (defect) => Struct({
  _tag: Literal2("Die"),
  defect
});
var CauseEmptyEncoded = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal2("Empty")
});
var causeFailEncoded = (error2) => Struct({
  _tag: Literal2("Fail"),
  error: error2
});
var CauseInterruptEncoded = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal2("Interrupt"),
  fiberId: FiberIdEncoded
});
var causeEncodedId = 0;
var causeEncoded = (error2, defect) => {
  const error_ = asSchema(error2);
  const defect_ = asSchema(defect);
  const suspended3 = suspend9(() => out2);
  const out2 = Union2(CauseEmptyEncoded, causeFailEncoded(error_), causeDieEncoded(defect_), CauseInterruptEncoded, Struct({
    _tag: Literal2("Sequential"),
    left: suspended3,
    right: suspended3
  }), Struct({
    _tag: Literal2("Parallel"),
    left: suspended3,
    right: suspended3
  })).annotations({
    title: `CauseEncoded<${format6(error2)}>`,
    [JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`
  });
  return out2;
};
var causeArbitrary = (error2, defect) => (fc) => fc.letrec((tie) => ({
  Empty: fc.record({
    _tag: fc.constant("Empty")
  }),
  Fail: fc.record({
    _tag: fc.constant("Fail"),
    error: error2(fc)
  }),
  Die: fc.record({
    _tag: fc.constant("Die"),
    defect: defect(fc)
  }),
  Interrupt: fc.record({
    _tag: fc.constant("Interrupt"),
    fiberId: fiberIdArbitrary(fc)
  }),
  Sequential: fc.record({
    _tag: fc.constant("Sequential"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Parallel: fc.record({
    _tag: fc.constant("Parallel"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
})).Cause.map(causeDecode);
var causePretty = (error2) => (cause3) => {
  const f = (cause4) => {
    switch (cause4._tag) {
      case "Empty":
        return "Cause.empty";
      case "Fail":
        return `Cause.fail(${error2(cause4.error)})`;
      case "Die":
        return `Cause.die(${pretty2(cause4)})`;
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty(cause4.fiberId)})`;
      case "Sequential":
        return `Cause.sequential(${f(cause4.left)}, ${f(cause4.right)})`;
      case "Parallel":
        return `Cause.parallel(${f(cause4.left)}, ${f(cause4.right)})`;
    }
  };
  return f(cause3);
};
var causeParse = (decodeUnknown4) => (u3, options, ast) => isCause2(u3) ? toComposite(decodeUnknown4(causeEncode(u3), options), causeDecode, ast, u3) : fail16(new Type2(ast, u3));
var CauseFromSelf = ({
  defect,
  error: error2
}) => {
  return declare([error2, defect], {
    decode: (error3, defect2) => causeParse(decodeUnknown2(causeEncoded(error3, defect2))),
    encode: (error3, defect2) => causeParse(encodeUnknown(causeEncoded(error3, defect2)))
  }, {
    title: `Cause<${error2.ast}>`,
    pretty: causePretty,
    arbitrary: causeArbitrary
  });
};
function causeDecode(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return empty30;
    case "Fail":
      return fail4(cause3.error);
    case "Die":
      return die4(cause3.defect);
    case "Interrupt":
      return interrupt5(fiberIdDecode(cause3.fiberId));
    case "Sequential":
      return sequential4(causeDecode(cause3.left), causeDecode(cause3.right));
    case "Parallel":
      return parallel4(causeDecode(cause3.left), causeDecode(cause3.right));
  }
}
function causeEncode(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause3.error
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause3.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause3.fiberId
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause3.left),
        right: causeEncode(cause3.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause3.left),
        right: causeEncode(cause3.right)
      };
  }
}
var Cause = ({
  defect,
  error: error2
}) => {
  const error_ = asSchema(error2);
  const defect_ = asSchema(defect);
  const out2 = transform2(causeEncoded(error_, defect_), CauseFromSelf({
    error: typeSchema(error_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: (i2) => causeDecode(i2),
    encode: (a) => causeEncode(a)
  });
  return out2;
};

class Defect extends (/* @__PURE__ */ transform2(Unknown, Unknown, {
  strict: true,
  decode: (i2) => {
    if (isObject(i2) && "message" in i2 && typeof i2.message === "string") {
      const err2 = new Error(i2.message, {
        cause: i2
      });
      if ("name" in i2 && typeof i2.name === "string") {
        err2.name = i2.name;
      }
      err2.stack = "stack" in i2 && typeof i2.stack === "string" ? i2.stack : "";
      return err2;
    }
    return String(i2);
  },
  encode: (a) => {
    if (a instanceof Error) {
      return {
        name: a.name,
        message: a.message
      };
    }
    return prettyErrorMessage(a);
  }
}).annotations({
  identifier: "Defect"
})) {
}
var exitFailureEncoded = (error2, defect) => Struct({
  _tag: Literal2("Failure"),
  cause: causeEncoded(error2, defect)
});
var exitSuccessEncoded = (value5) => Struct({
  _tag: Literal2("Success"),
  value: value5
});
var exitEncoded = (value5, error2, defect) => {
  return Union2(exitFailureEncoded(error2, defect), exitSuccessEncoded(value5)).annotations({
    title: `ExitEncoded<${format6(value5)}, ${format6(error2)}, ${format6(defect)}>`
  });
};
var exitDecode = (input) => {
  switch (input._tag) {
    case "Failure":
      return failCause2(causeDecode(input.cause));
    case "Success":
      return succeed2(input.value);
  }
};
var exitArbitrary = (value5, error2, defect) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Failure"),
  cause: causeArbitrary(error2, defect)(fc)
}), fc.record({
  _tag: fc.constant("Success"),
  value: value5(fc)
})).map(exitDecode);
var exitPretty = (value5, error2) => (exit3) => exit3._tag === "Failure" ? `Exit.failCause(${causePretty(error2)(exit3.cause)})` : `Exit.succeed(${value5(exit3.value)})`;
var exitParse = (decodeUnknownValue, decodeUnknownCause) => (u3, options, ast) => isExit(u3) ? match6(u3, {
  onFailure: (cause3) => toComposite(decodeUnknownCause(cause3, options), failCause2, ast, u3),
  onSuccess: (value5) => toComposite(decodeUnknownValue(value5, options), succeed2, ast, u3)
}) : fail16(new Type2(ast, u3));
var ExitFromSelf = ({
  defect,
  failure,
  success
}) => declare([success, failure, defect], {
  decode: (success2, failure2, defect2) => exitParse(decodeUnknown2(success2), decodeUnknown2(CauseFromSelf({
    error: failure2,
    defect: defect2
  }))),
  encode: (success2, failure2, defect2) => exitParse(encodeUnknown(success2), encodeUnknown(CauseFromSelf({
    error: failure2,
    defect: defect2
  })))
}, {
  title: `Exit<${success.ast}, ${failure.ast}>`,
  pretty: exitPretty,
  arbitrary: exitArbitrary
});
var Exit = ({
  defect,
  failure,
  success
}) => {
  const success_ = asSchema(success);
  const failure_ = asSchema(failure);
  const defect_ = asSchema(defect);
  const out2 = transform2(exitEncoded(success_, failure_, defect_), ExitFromSelf({
    failure: typeSchema(failure_),
    success: typeSchema(success_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: (i2) => exitDecode(i2),
    encode: (a) => a._tag === "Failure" ? {
      _tag: "Failure",
      cause: a.cause
    } : {
      _tag: "Success",
      value: a.value
    }
  });
  return out2;
};
var hashSetArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable5);
};
var hashSetPretty = (item) => (set11) => `HashSet(${Array.from(set11).map((a) => item(a)).join(", ")})`;
var hashSetEquivalence = (item) => {
  const arrayEquivalence = getEquivalence3(item);
  return make((a, b3) => arrayEquivalence(Array.from(a), Array.from(b3)));
};
var hashSetParse = (decodeUnknown4) => (u3, options, ast) => isHashSet2(u3) ? toComposite(decodeUnknown4(Array.from(u3), options), fromIterable5, ast, u3) : fail16(new Type2(ast, u3));
var HashSetFromSelf = (value5) => {
  return declare([value5], {
    decode: (item) => hashSetParse(decodeUnknown2(Array$(item))),
    encode: (item) => hashSetParse(encodeUnknown(Array$(item)))
  }, {
    description: `HashSet<${format6(value5)}>`,
    pretty: hashSetPretty,
    arbitrary: hashSetArbitrary,
    equivalence: hashSetEquivalence
  });
};
function HashSet(value5) {
  return transform2(Array$(value5), HashSetFromSelf(typeSchema(asSchema(value5))), {
    strict: true,
    decode: (i2) => fromIterable5(i2),
    encode: (a) => Array.from(a)
  });
}
var hashMapArbitrary = (key, value5, ctx) => (fc) => {
  const items = fc.array(fc.tuple(key(fc), value5(fc)));
  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable6);
};
var hashMapPretty = (key, value5) => (map27) => `HashMap([${Array.from(map27).map(([k2, v2]) => `[${key(k2)}, ${value5(v2)}]`).join(", ")}])`;
var hashMapEquivalence = (key, value5) => {
  const arrayEquivalence = getEquivalence3(make(([ka, va], [kb, vb]) => key(ka, kb) && value5(va, vb)));
  return make((a, b3) => arrayEquivalence(Array.from(a), Array.from(b3)));
};
var hashMapParse = (decodeUnknown4) => (u3, options, ast) => isHashMap2(u3) ? toComposite(decodeUnknown4(Array.from(u3), options), fromIterable6, ast, u3) : fail16(new Type2(ast, u3));
var HashMapFromSelf = ({
  key,
  value: value5
}) => {
  return declare([key, value5], {
    decode: (key2, value6) => hashMapParse(decodeUnknown2(Array$(Tuple(key2, value6)))),
    encode: (key2, value6) => hashMapParse(encodeUnknown(Array$(Tuple(key2, value6))))
  }, {
    description: `HashMap<${format6(key)}, ${format6(value5)}>`,
    pretty: hashMapPretty,
    arbitrary: hashMapArbitrary,
    equivalence: hashMapEquivalence
  });
};
var HashMap = ({
  key,
  value: value5
}) => {
  return transform2(Array$(Tuple(key, value5)), HashMapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value5))
  }), {
    strict: true,
    decode: (i2) => fromIterable6(i2),
    encode: (a) => Array.from(a)
  });
};
var listArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable7);
};
var listPretty = (item) => (set11) => `List(${Array.from(set11).map((a) => item(a)).join(", ")})`;
var listEquivalence = (item) => {
  const arrayEquivalence = getEquivalence3(item);
  return make((a, b3) => arrayEquivalence(Array.from(a), Array.from(b3)));
};
var listParse = (decodeUnknown4) => (u3, options, ast) => isList(u3) ? toComposite(decodeUnknown4(Array.from(u3), options), fromIterable7, ast, u3) : fail16(new Type2(ast, u3));
var ListFromSelf = (value5) => {
  return declare([value5], {
    decode: (item) => listParse(decodeUnknown2(Array$(item))),
    encode: (item) => listParse(encodeUnknown(Array$(item)))
  }, {
    description: `List<${format6(value5)}>`,
    pretty: listPretty,
    arbitrary: listArbitrary,
    equivalence: listEquivalence
  });
};
function List(value5) {
  return transform2(Array$(value5), ListFromSelf(typeSchema(asSchema(value5))), {
    strict: true,
    decode: (i2) => fromIterable7(i2),
    encode: (a) => Array.from(a)
  });
}
var sortedSetArbitrary = (item, ord, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== undefined ? fc.oneof(ctx, fc.constant([]), items) : items).map((as7) => fromIterable11(as7, ord));
};
var sortedSetPretty = (item) => (set11) => `new SortedSet([${Array.from(values3(set11)).map((a) => item(a)).join(", ")}])`;
var sortedSetParse = (decodeUnknown4, ord) => (u3, options, ast) => isSortedSet(u3) ? toComposite(decodeUnknown4(Array.from(values3(u3)), options), (as7) => fromIterable11(as7, ord), ast, u3) : fail16(new Type2(ast, u3));
var SortedSetFromSelf = (value5, ordA, ordI) => {
  return declare([value5], {
    decode: (item) => sortedSetParse(decodeUnknown2(Array$(item)), ordA),
    encode: (item) => sortedSetParse(encodeUnknown(Array$(item)), ordI)
  }, {
    description: `SortedSet<${format6(value5)}>`,
    pretty: sortedSetPretty,
    arbitrary: (arb, ctx) => sortedSetArbitrary(arb, ordA, ctx),
    equivalence: () => getEquivalence6()
  });
};
function SortedSet(value5, ordA) {
  const to = typeSchema(asSchema(value5));
  return transform2(Array$(value5), SortedSetFromSelf(to, ordA, ordA), {
    strict: true,
    decode: (i2) => fromIterable11(i2, ordA),
    encode: (a) => Array.from(values3(a))
  });
}

class BooleanFromUnknown extends (/* @__PURE__ */ transform2(Unknown, Boolean$, {
  strict: true,
  decode: (i2) => isTruthy(i2),
  encode: identity
}).annotations({
  identifier: "BooleanFromUnknown"
})) {
}

class BooleanFromString extends (/* @__PURE__ */ transform2(Literal2("true", "false").annotations({
  description: "a string to be decoded into a boolean"
}), Boolean$, {
  strict: true,
  decode: (i2) => i2 === "true",
  encode: (a) => a ? "true" : "false"
}).annotations({
  identifier: "BooleanFromString"
})) {
}
var Config = (name2, schema) => {
  const decodeUnknownEither3 = decodeUnknownEither(schema);
  return string5(name2).pipe(mapOrFail2((s2) => decodeUnknownEither3(s2).pipe(mapLeft((error2) => InvalidData2([], TreeFormatter.formatIssueSync(error2))))));
};
var symbolSerializable = /* @__PURE__ */ Symbol.for("effect/Schema/Serializable/symbol");
var asSerializable = (serializable) => serializable;
var serializableSchema = (self2) => self2[symbolSerializable];
var serialize = (self2) => encodeUnknown2(self2[symbolSerializable])(self2);
var deserialize = /* @__PURE__ */ dual(2, (self2, value5) => decodeUnknown3(self2[symbolSerializable])(value5));
var symbolWithResult = /* @__PURE__ */ Symbol.for("effect/Schema/Serializable/symbolResult");
var asWithResult = (withExit) => withExit;
var failureSchema = (self2) => self2[symbolWithResult].failure;
var successSchema = (self2) => self2[symbolWithResult].success;
var exitSchemaCache = /* @__PURE__ */ globalValue("effect/Schema/Serializable/exitSchemaCache", () => new WeakMap);
var exitSchema = (self2) => {
  const proto16 = Object.getPrototypeOf(self2);
  if (!(symbolWithResult in proto16)) {
    return Exit({
      failure: failureSchema(self2),
      success: successSchema(self2),
      defect: Defect
    });
  }
  let schema = exitSchemaCache.get(proto16);
  if (schema === undefined) {
    schema = Exit({
      failure: failureSchema(self2),
      success: successSchema(self2),
      defect: Defect
    });
    exitSchemaCache.set(proto16, schema);
  }
  return schema;
};
var serializeFailure = /* @__PURE__ */ dual(2, (self2, value5) => encode4(self2[symbolWithResult].failure)(value5));
var deserializeFailure = /* @__PURE__ */ dual(2, (self2, value5) => decodeUnknown3(self2[symbolWithResult].failure)(value5));
var serializeSuccess = /* @__PURE__ */ dual(2, (self2, value5) => encode4(self2[symbolWithResult].success)(value5));
var deserializeSuccess = /* @__PURE__ */ dual(2, (self2, value5) => decodeUnknown3(self2[symbolWithResult].success)(value5));
var serializeExit = /* @__PURE__ */ dual(2, (self2, value5) => encode4(exitSchema(self2))(value5));
var deserializeExit = /* @__PURE__ */ dual(2, (self2, value5) => decodeUnknown3(exitSchema(self2))(value5));
var asSerializableWithResult = (procedure) => procedure;
var TaggedRequest = (identifier2) => (tag3, options, annotations3) => {
  const taggedFields = extendFields({
    _tag: getClassTag(tag3)
  }, options.payload);
  return class TaggedRequestClass extends makeClass({
    kind: "TaggedRequest",
    identifier: identifier2 ?? tag3,
    schema: Struct(taggedFields),
    fields: taggedFields,
    Base: Class4,
    annotations: annotations3
  }) {
    static _tag = tag3;
    static success = options.success;
    static failure = options.failure;
    get [symbolSerializable]() {
      return this.constructor;
    }
    get [symbolWithResult]() {
      return {
        failure: options.failure,
        success: options.success
      };
    }
  };
};
var equivalence2 = (schema) => go2(schema.ast, []);
var getEquivalenceAnnotation = /* @__PURE__ */ getAnnotation(EquivalenceAnnotationId);
var go2 = (ast, path) => {
  const hook = getEquivalenceAnnotation(ast);
  if (isSome2(hook)) {
    switch (ast._tag) {
      case "Declaration":
        return hook.value(...ast.typeParameters.map((tp) => go2(tp, path)));
      case "Refinement":
        return hook.value(go2(ast.from, path));
      default:
        return hook.value();
    }
  }
  switch (ast._tag) {
    case "NeverKeyword":
      throw new Error(getEquivalenceUnsupportedErrorMessage(ast, path));
    case "Transformation":
      return go2(ast.to, path);
    case "Declaration":
    case "Literal":
    case "StringKeyword":
    case "TemplateLiteral":
    case "UniqueSymbol":
    case "SymbolKeyword":
    case "UnknownKeyword":
    case "AnyKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "Enums":
    case "ObjectKeyword":
      return equals;
    case "Refinement":
      return go2(ast.from, path);
    case "Suspend": {
      const get24 = memoizeThunk(() => go2(ast.f(), path));
      return (a, b3) => get24()(a, b3);
    }
    case "TupleType": {
      const elements = ast.elements.map((element2, i2) => go2(element2.type, path.concat(i2)));
      const rest = ast.rest.map((annotatedAST) => go2(annotatedAST.type, path));
      return make((a, b3) => {
        const len = a.length;
        if (len !== b3.length) {
          return false;
        }
        let i2 = 0;
        for (;i2 < Math.min(len, ast.elements.length); i2++) {
          if (!elements[i2](a[i2], b3[i2])) {
            return false;
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head9, ...tail] = rest;
          for (;i2 < len - tail.length; i2++) {
            if (!head9(a[i2], b3[i2])) {
              return false;
            }
          }
          for (let j4 = 0;j4 < tail.length; j4++) {
            i2 += j4;
            if (!tail[j4](a[i2], b3[i2])) {
              return false;
            }
          }
        }
        return true;
      });
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return equals;
      }
      const propertySignatures = ast.propertySignatures.map((ps) => go2(ps.type, path.concat(ps.name)));
      const indexSignatures = ast.indexSignatures.map((is4) => go2(is4.type, path));
      return make((a, b3) => {
        const aStringKeys = Object.keys(a);
        const aSymbolKeys = Object.getOwnPropertySymbols(a);
        for (let i2 = 0;i2 < propertySignatures.length; i2++) {
          const ps = ast.propertySignatures[i2];
          const name2 = ps.name;
          const aHas = Object.prototype.hasOwnProperty.call(a, name2);
          const bHas = Object.prototype.hasOwnProperty.call(b3, name2);
          if (ps.isOptional) {
            if (aHas !== bHas) {
              return false;
            }
          }
          if (aHas && bHas && !propertySignatures[i2](a[name2], b3[name2])) {
            return false;
          }
        }
        let bSymbolKeys;
        let bStringKeys;
        for (let i2 = 0;i2 < indexSignatures.length; i2++) {
          const is4 = ast.indexSignatures[i2];
          const encodedParameter = getEncodedParameter(is4.parameter);
          const isSymbol2 = isSymbolKeyword(encodedParameter);
          if (isSymbol2) {
            bSymbolKeys = bSymbolKeys || Object.getOwnPropertySymbols(b3);
            if (aSymbolKeys.length !== bSymbolKeys.length) {
              return false;
            }
          } else {
            bStringKeys = bStringKeys || Object.keys(b3);
            if (aStringKeys.length !== bStringKeys.length) {
              return false;
            }
          }
          const aKeys = isSymbol2 ? aSymbolKeys : aStringKeys;
          for (let j4 = 0;j4 < aKeys.length; j4++) {
            const key = aKeys[j4];
            if (!Object.prototype.hasOwnProperty.call(b3, key) || !indexSignatures[i2](a[key], b3[key])) {
              return false;
            }
          }
        }
        return true;
      });
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, true);
      const ownKeys2 = ownKeys(searchTree.keys);
      const len = ownKeys2.length;
      return make((a, b3) => {
        let candidates = [];
        if (len > 0 && isRecordOrArray(a)) {
          for (let i2 = 0;i2 < len; i2++) {
            const name2 = ownKeys2[i2];
            const buckets = searchTree.keys[name2].buckets;
            if (Object.prototype.hasOwnProperty.call(a, name2)) {
              const literal2 = String(a[name2]);
              if (Object.prototype.hasOwnProperty.call(buckets, literal2)) {
                candidates = candidates.concat(buckets[literal2]);
              }
            }
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        const tuples = candidates.map((ast2) => [go2(ast2, path), is2({
          ast: ast2
        })]);
        for (let i2 = 0;i2 < tuples.length; i2++) {
          const [equivalence3, is4] = tuples[i2];
          if (is4(a) && is4(b3)) {
            if (equivalence3(a, b3)) {
              return true;
            }
          }
        }
        return false;
      });
    }
  }
};
var SymbolStruct = /* @__PURE__ */ TaggedStruct("symbol", {
  key: String$
}).annotations({
  description: "an object to be decoded into a globally shared symbol"
});
var SymbolFromStruct = /* @__PURE__ */ transformOrFail(SymbolStruct, SymbolFromSelf, {
  strict: true,
  decode: (i2) => decodeSymbol(i2.key),
  encode: (a, _2, ast) => map23(encodeSymbol(a, ast), (key) => SymbolStruct.make({
    key
  }))
});

class PropertyKey$ extends (/* @__PURE__ */ Union2(String$, Number$, SymbolFromStruct).annotations({
  identifier: "PropertyKey"
})) {
}
class ArrayFormatterIssue extends (/* @__PURE__ */ Struct({
  _tag: propertySignature(Literal2("Pointer", "Unexpected", "Missing", "Composite", "Refinement", "Transformation", "Type", "Forbidden")).annotations({
    description: "The tag identifying the type of parse issue"
  }),
  path: propertySignature(Array$(PropertyKey$)).annotations({
    description: "The path to the property where the issue occurred"
  }),
  message: propertySignature(String$).annotations({
    description: "A descriptive message explaining the issue"
  })
}).annotations({
  identifier: "ArrayFormatterIssue",
  description: "Represents an issue returned by the ArrayFormatter formatter"
})) {
}
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/SortedMap.js
var TypeId31 = /* @__PURE__ */ Symbol.for("effect/SortedMap");
var SortedMapProto = {
  [TypeId31]: {
    _K: (_2) => _2,
    _V: (_2) => _2
  },
  [symbol]() {
    return pipe(hash(this.tree), combine(hash("effect/SortedMap")), cached(this));
  },
  [symbol2](that) {
    return isSortedMap(that) && equals(this.tree, that.tree);
  },
  [Symbol.iterator]() {
    return this.tree[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isSortedMap = (u3) => hasProperty(u3, TypeId31);
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/Subscribable.js
var TypeId32 = /* @__PURE__ */ Symbol.for("effect/Subscribable");
var Proto7 = {
  [TypeId13]: TypeId13,
  [TypeId32]: TypeId32,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/TestClock.js
var warning = "Warning: A test is using time, but is not advancing " + "the test clock, which may result in the test hanging. Use TestClock.adjust to " + "manually advance the time.";
var suspendedWarning = "Warning: A test is advancing the test clock, " + "but a fiber is not suspending, which may result in the test hanging. Use " + "TestAspect.diagnose to identity the fiber that is not suspending.";
// ../../node_modules/.pnpm/effect@3.16.8/node_modules/effect/dist/esm/internal/trie.js
var TrieSymbolKey = "effect/Trie";
var TrieTypeId = /* @__PURE__ */ Symbol.for(TrieSymbolKey);
var trieVariance = {
  _Value: (_2) => _2
};
var TrieProto = {
  [TrieTypeId]: trieVariance,
  [Symbol.iterator]() {
    return new TrieIterator(this, (k2, v2) => [k2, v2], () => true);
  },
  [symbol]() {
    let hash2 = hash(TrieSymbolKey);
    for (const item of this) {
      hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash2);
  },
  [symbol2](that) {
    if (isTrie(that)) {
      const entries2 = Array.from(that);
      return Array.from(this).every((itemSelf, i2) => {
        const itemThat = entries2[i2];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Trie",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
class TrieIterator {
  trie;
  f;
  filter;
  stack = [];
  constructor(trie, f, filter15) {
    this.trie = trie;
    this.f = f;
    this.filter = filter15;
    const root = trie._root !== undefined ? trie._root : undefined;
    if (root !== undefined) {
      this.stack.push([root, "", false]);
    }
  }
  next() {
    while (this.stack.length > 0) {
      const [node, keyString, isAdded] = this.stack.pop();
      if (isAdded) {
        const value6 = node.value;
        if (value6 !== undefined) {
          const key = keyString + node.key;
          if (this.filter(key, value6)) {
            return {
              done: false,
              value: this.f(key, value6)
            };
          }
        }
      } else {
        this.addToStack(node, keyString);
      }
    }
    return {
      done: true,
      value: undefined
    };
  }
  addToStack(node, keyString) {
    if (node.right !== undefined) {
      this.stack.push([node.right, keyString, false]);
    }
    if (node.mid !== undefined) {
      this.stack.push([node.mid, keyString + node.key, false]);
    }
    this.stack.push([node, keyString, true]);
    if (node.left !== undefined) {
      this.stack.push([node.left, keyString, false]);
    }
  }
  [Symbol.iterator]() {
    return new TrieIterator(this.trie, this.f, this.filter);
  }
}
var isTrie = (u3) => hasProperty(u3, TrieTypeId);
// ../../packages/psionic/src/persistence/services.ts
class PGliteError extends exports_Schema.TaggedError()("PGliteError", {
  message: exports_Schema.String,
  cause: exports_Schema.Unknown
}) {
}

class PGliteService extends exports_Context.Tag("PGliteService")() {
}
var PGliteServiceLive = (config2 = {}) => exports_Layer.effect(PGliteService, exports_Effect.gen(function* () {
  const databaseName = config2.databaseName || "openagents-chat";
  const client = yield* exports_Effect.tryPromise({
    try: async () => {
      const extensions = { live: j3 };
      if (config2.enableSync) {
        extensions.electricSync = me3;
      }
      const pg = new qe2(`idb://${databaseName}`, {
        extensions
      });
      await pg.exec(`
          -- Conversations table
          CREATE TABLE IF NOT EXISTS conversations (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            user_id TEXT NOT NULL DEFAULT 'local',
            title TEXT,
            model TEXT,
            last_message_at TIMESTAMP,
            created_at TIMESTAMP DEFAULT NOW(),
            archived BOOLEAN DEFAULT FALSE,
            metadata JSONB DEFAULT '{}'::jsonb
          );

          -- Messages table
          CREATE TABLE IF NOT EXISTS messages (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
            role TEXT NOT NULL CHECK (role IN ('user', 'assistant', 'system', 'tool')),
            content TEXT NOT NULL,
            model TEXT,
            created_at TIMESTAMP DEFAULT NOW(),
            metadata JSONB DEFAULT '{}'::jsonb
          );

          -- Indexes
          CREATE INDEX IF NOT EXISTS idx_user_created ON conversations(user_id, created_at);
          CREATE INDEX IF NOT EXISTS idx_archived ON conversations(archived);
          CREATE INDEX IF NOT EXISTS idx_conversation_created ON messages(conversation_id, created_at);
          CREATE INDEX IF NOT EXISTS idx_role ON messages(role);
          
          -- Full text search index
          CREATE INDEX IF NOT EXISTS idx_messages_content_fts
          ON messages USING gin(to_tsvector('english', content));
        `);
      return pg;
    },
    catch: (error2) => new PGliteError({
      message: "Failed to initialize PGlite",
      cause: error2
    })
  });
  const db = drizzle(client);
  const query = (fn3) => exports_Effect.tryPromise({
    try: () => fn3(db),
    catch: (error2) => new PGliteError({
      message: "Query failed",
      cause: error2
    })
  });
  return { client, db, query };
}));

class ConversationRepository extends exports_Context.Tag("ConversationRepository")() {
}
var ConversationRepositoryLive = exports_Layer.effect(ConversationRepository, exports_Effect.gen(function* () {
  const pgService = yield* PGliteService;
  return {
    create: (conversation) => pgService.query(async (db) => {
      const [created] = await db.insert(conversations).values(conversation).returning();
      return created;
    }),
    get: (id2) => pgService.query(async (db) => {
      const [conversation] = await db.select().from(conversations).where(eq(conversations.id, id2));
      return conversation;
    }),
    list: (userId = "local", includeArchived = false) => pgService.query(async (db) => {
      const conditions = [eq(conversations.userId, userId)];
      if (!includeArchived) {
        conditions.push(eq(conversations.archived, false));
      }
      return await db.select().from(conversations).where(conditions.length === 1 ? conditions[0] : and(...conditions)).orderBy(desc(conversations.lastMessageAt), desc(conversations.createdAt));
    }),
    update: (id2, updates) => pgService.query(async (db) => {
      const [updated] = await db.update(conversations).set(updates).where(eq(conversations.id, id2)).returning();
      return updated;
    }),
    delete: (id2) => pgService.query(async (db) => {
      const result = await db.delete(conversations).where(eq(conversations.id, id2)).returning();
      return result.length > 0;
    }),
    archive: (id2) => pgService.query(async (db) => {
      const [archived] = await db.update(conversations).set({ archived: true }).where(eq(conversations.id, id2)).returning();
      return !!archived;
    }),
    generateTitle: (conversationId) => pgService.query(async (db) => {
      const [firstMessage] = await db.select().from(messages).where(and(eq(messages.conversationId, conversationId), eq(messages.role, "user"))).orderBy(messages.createdAt).limit(1);
      if (!firstMessage) {
        return "New Conversation";
      }
      const title = firstMessage.content.slice(0, 50) + (firstMessage.content.length > 50 ? "..." : "");
      await db.update(conversations).set({ title }).where(eq(conversations.id, conversationId));
      return title;
    })
  };
}));

class MessageRepository extends exports_Context.Tag("MessageRepository")() {
}
var MessageRepositoryLive = exports_Layer.effect(MessageRepository, exports_Effect.gen(function* () {
  const pgService = yield* PGliteService;
  return {
    send: (message) => pgService.query(async (db) => {
      const [inserted] = await db.insert(messages).values(message).returning();
      await db.update(conversations).set({ lastMessageAt: new Date }).where(eq(conversations.id, message.conversationId));
      return inserted;
    }),
    getConversation: (conversationId, limit = 100) => pgService.query(async (db) => {
      return await db.select().from(messages).where(eq(messages.conversationId, conversationId)).orderBy(desc(messages.createdAt)).limit(limit);
    }),
    search: (query, userId = "local") => pgService.query(async () => {
      const result = await pgService.client.query(`
            SELECT m.* FROM messages m
            JOIN conversations c ON m.conversation_id = c.id
            WHERE c.user_id = $1
            AND to_tsvector('english', m.content) @@ plainto_tsquery('english', $2)
            ORDER BY m.created_at DESC
            LIMIT 50
          `, [userId, query]);
      return result.rows;
    }),
    delete: (id2) => pgService.query(async (db) => {
      const result = await db.delete(messages).where(eq(messages.id, id2)).returning();
      return result.length > 0;
    }),
    watchConversation: (conversationId, callback) => exports_Effect.sync(() => {
      const intervalId = setInterval(async () => {
        try {
          const result = await pgService.client.query(`SELECT * FROM messages
                 WHERE conversation_id = $1
                 ORDER BY created_at ASC`, [conversationId]);
          callback(result.rows);
        } catch (error2) {
          console.error("Error polling messages:", error2);
        }
      }, 2000);
      pgService.client.query(`SELECT * FROM messages
             WHERE conversation_id = $1
             ORDER BY created_at ASC`, [conversationId]).then((result) => callback(result.rows)).catch((error2) => console.error("Error fetching initial messages:", error2));
      return () => clearInterval(intervalId);
    })
  };
}));
// ../../packages/psionic/src/persistence/browser-pglite.ts
var pgInstance = null;
var dbInstance = null;
var initPromise = null;
async function initializePGlite(databaseName = "openagents-chat") {
  if (pgInstance && dbInstance) {
    return { pg: pgInstance, db: dbInstance };
  }
  if (initPromise) {
    await initPromise;
    return { pg: pgInstance, db: dbInstance };
  }
  initPromise = (async () => {
    try {
      pgInstance = new qe2(`idb://${databaseName}`);
      await pgInstance.waitReady;
      dbInstance = drizzle(pgInstance);
      await pgInstance.exec(`
        CREATE TABLE IF NOT EXISTS conversations (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          user_id TEXT NOT NULL DEFAULT 'local',
          title TEXT,
          model TEXT,
          last_message_at TIMESTAMP,
          created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
          archived BOOLEAN DEFAULT FALSE,
          metadata JSONB DEFAULT '{}'::jsonb
        );

        CREATE TABLE IF NOT EXISTS messages (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
          role TEXT NOT NULL CHECK (role IN ('user', 'assistant', 'system', 'tool')),
          content TEXT NOT NULL,
          model TEXT,
          created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
          metadata JSONB DEFAULT '{}'::jsonb
        );

        CREATE INDEX IF NOT EXISTS idx_conversations_user_id ON conversations(user_id);
        CREATE INDEX IF NOT EXISTS idx_conversations_created_at ON conversations(created_at DESC);
        CREATE INDEX IF NOT EXISTS idx_messages_conversation_id ON messages(conversation_id);
        CREATE INDEX IF NOT EXISTS idx_messages_created_at ON messages(created_at);
      `);
    } catch (error2) {
      console.error("Failed to initialize PGlite:", error2);
      throw error2;
    }
  })();
  await initPromise;
  return { pg: pgInstance, db: dbInstance };
}

// ../../packages/psionic/src/persistence/client-services.ts
class BrowserPersistenceError extends exports_Schema.TaggedError()("BrowserPersistenceError", {
  message: exports_Schema.String,
  cause: exports_Schema.Unknown
}) {
}

class BrowserPGliteService extends exports_Context.Tag("BrowserPGliteService")() {
}

class BrowserConversationRepository extends exports_Context.Tag("BrowserConversationRepository")() {
}

class BrowserMessageRepository extends exports_Context.Tag("BrowserMessageRepository")() {
}
var BrowserPGliteServiceLive = (databaseName = "openagents-chat") => exports_Layer.effect(BrowserPGliteService, exports_Effect.gen(function* () {
  const { db, pg } = yield* exports_Effect.tryPromise({
    try: () => initializePGlite(databaseName),
    catch: (error2) => new BrowserPersistenceError({
      message: "Failed to initialize PGlite",
      cause: error2
    })
  });
  return { db, pg };
}));
var BrowserConversationRepositoryLive = exports_Layer.effect(BrowserConversationRepository, exports_Effect.gen(function* () {
  const { db } = yield* BrowserPGliteService;
  return {
    create: (conversation) => exports_Effect.tryPromise({
      try: async () => {
        const [result] = await db.insert(conversations).values(conversation).returning();
        return result;
      },
      catch: (error2) => new BrowserPersistenceError({
        message: "Failed to create conversation",
        cause: error2
      })
    }),
    get: (id2) => exports_Effect.tryPromise({
      try: async () => {
        const [result] = await db.select().from(conversations).where(eq(conversations.id, id2));
        return result;
      },
      catch: (error2) => new BrowserPersistenceError({
        message: `Failed to get conversation ${id2}`,
        cause: error2
      })
    }),
    list: (userId = "local", includeArchived = false) => exports_Effect.tryPromise({
      try: async () => {
        const conditions = [eq(conversations.userId, userId)];
        if (!includeArchived) {
          conditions.push(eq(conversations.archived, false));
        }
        return db.select().from(conversations).where(conditions.length === 1 ? conditions[0] : and(...conditions)).orderBy(desc(conversations.lastMessageAt), desc(conversations.createdAt));
      },
      catch: (error2) => new BrowserPersistenceError({
        message: "Failed to list conversations",
        cause: error2
      })
    }),
    update: (id2, updates) => exports_Effect.tryPromise({
      try: async () => {
        const [result] = await db.update(conversations).set(updates).where(eq(conversations.id, id2)).returning();
        return result;
      },
      catch: (error2) => new BrowserPersistenceError({
        message: `Failed to update conversation ${id2}`,
        cause: error2
      })
    }),
    delete: (id2) => exports_Effect.tryPromise({
      try: async () => {
        const result = await db.delete(conversations).where(eq(conversations.id, id2)).returning();
        return result.length > 0;
      },
      catch: (error2) => new BrowserPersistenceError({
        message: `Failed to delete conversation ${id2}`,
        cause: error2
      })
    }),
    archive: (id2) => exports_Effect.tryPromise({
      try: async () => {
        const [result] = await db.update(conversations).set({ archived: true }).where(eq(conversations.id, id2)).returning();
        return !!result;
      },
      catch: (error2) => new BrowserPersistenceError({
        message: `Failed to archive conversation ${id2}`,
        cause: error2
      })
    }),
    generateTitle: (conversationId) => exports_Effect.gen(function* () {
      const conversation = yield* exports_Effect.tryPromise({
        try: () => db.select().from(conversations).where(eq(conversations.id, conversationId)).then((r2) => r2[0]),
        catch: (error2) => new BrowserPersistenceError({
          message: "Failed to get conversation for title generation",
          cause: error2
        })
      });
      if (!conversation || conversation.title) {
        return false;
      }
      const firstMessage = yield* exports_Effect.tryPromise({
        try: () => db.select().from(messages).where(eq(messages.conversationId, conversationId)).orderBy(messages.createdAt).limit(1).then((r2) => r2[0]),
        catch: (error2) => new BrowserPersistenceError({
          message: "Failed to get first message",
          cause: error2
        })
      });
      if (firstMessage && firstMessage.role === "user") {
        const title = firstMessage.content.slice(0, 50) + (firstMessage.content.length > 50 ? "..." : "");
        yield* exports_Effect.tryPromise({
          try: () => db.update(conversations).set({ title }).where(eq(conversations.id, conversationId)),
          catch: (error2) => new BrowserPersistenceError({
            message: "Failed to update title",
            cause: error2
          })
        });
        return true;
      }
      return false;
    })
  };
}));
var BrowserMessageRepositoryLive = exports_Layer.effect(BrowserMessageRepository, exports_Effect.gen(function* () {
  const { db, pg } = yield* BrowserPGliteService;
  return {
    send: (message) => exports_Effect.tryPromise({
      try: async () => {
        return await db.transaction(async (tx) => {
          const [newMessage] = await tx.insert(messages).values(message).returning();
          await tx.update(conversations).set({ lastMessageAt: new Date }).where(eq(conversations.id, message.conversationId));
          return newMessage;
        });
      },
      catch: (error2) => new BrowserPersistenceError({
        message: "Failed to send message",
        cause: error2
      })
    }),
    getConversation: (conversationId, limit) => exports_Effect.tryPromise({
      try: async () => {
        const baseQuery = db.select().from(messages).where(eq(messages.conversationId, conversationId)).orderBy(desc(messages.createdAt));
        const results = limit ? await baseQuery.limit(limit) : await baseQuery;
        return results.reverse();
      },
      catch: (error2) => new BrowserPersistenceError({
        message: `Failed to get messages for conversation ${conversationId}`,
        cause: error2
      })
    }),
    delete: (id2) => exports_Effect.tryPromise({
      try: async () => {
        const result = await db.delete(messages).where(eq(messages.id, id2)).returning();
        return result.length > 0;
      },
      catch: (error2) => new BrowserPersistenceError({
        message: `Failed to delete message ${id2}`,
        cause: error2
      })
    }),
    search: (query, userId = "local") => exports_Effect.tryPromise({
      try: async () => {
        const result = await pg.query(`
            SELECT m.* FROM messages m
            JOIN conversations c ON m.conversation_id = c.id
            WHERE c.user_id = $1
            AND m.content ILIKE $2
            ORDER BY m.created_at DESC
            LIMIT 50
          `, [userId, `%${query}%`]);
        return result.rows;
      },
      catch: (error2) => new BrowserPersistenceError({
        message: "Failed to search messages",
        cause: error2
      })
    }),
    watchConversation: (conversationId, callback) => exports_Effect.sync(() => {
      let lastCount = 0;
      const checkInterval = setInterval(async () => {
        try {
          const messageList = await db.select().from(messages).where(eq(messages.conversationId, conversationId)).orderBy(messages.createdAt);
          if (messageList.length !== lastCount) {
            lastCount = messageList.length;
            callback(messageList);
          }
        } catch (error2) {
          console.error("Watch error:", error2);
        }
      }, 1000);
      return () => clearInterval(checkInterval);
    })
  };
}));
var BrowserPersistenceLive = (databaseName) => BrowserConversationRepositoryLive.pipe(exports_Layer.provide(BrowserMessageRepositoryLive), exports_Layer.provide(BrowserPGliteServiceLive(databaseName)));

// ../../packages/psionic/src/persistence/browser-effect-client.ts
class BrowserEffectChatClient {
  managedRuntime;
  runtime;
  listeners = new Map;
  unsubscribers = new Map;
  constructor(databaseName) {
    const layer = BrowserPersistenceLive(databaseName);
    this.managedRuntime = exports_ManagedRuntime.make(layer);
    this.runtime = this.managedRuntime.runtime;
  }
  async createConversation(conversation = {}) {
    const newConversation = {
      userId: conversation.userId || "local",
      title: conversation.title || null,
      model: conversation.model || null,
      metadata: conversation.metadata || {},
      archived: false,
      ...conversation
    };
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* BrowserConversationRepository;
      return yield* repo.create(newConversation);
    }));
  }
  async getConversation(id2) {
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* BrowserConversationRepository;
      return yield* repo.get(id2);
    }));
  }
  async listConversations(userId = "local", includeArchived = false) {
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* BrowserConversationRepository;
      return yield* repo.list(userId, includeArchived);
    }));
  }
  async updateConversation(id2, updates) {
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* BrowserConversationRepository;
      return yield* repo.update(id2, updates);
    }));
  }
  async deleteConversation(id2) {
    this.unsubscribeFromConversation(id2);
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* BrowserConversationRepository;
      return yield* repo.delete(id2);
    }));
  }
  async archiveConversation(id2) {
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* BrowserConversationRepository;
      return yield* repo.archive(id2);
    }));
  }
  async sendMessage(message) {
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* BrowserMessageRepository;
      const sent = yield* repo.send(message);
      if (message.role === "user") {
        const conversationRepo = yield* BrowserConversationRepository;
        const conversation = yield* conversationRepo.get(message.conversationId);
        if (conversation && !conversation.title) {
          yield* conversationRepo.generateTitle(message.conversationId);
        }
      }
      return sent;
    }));
  }
  async getMessages(conversationId, limit) {
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* BrowserMessageRepository;
      return yield* repo.getConversation(conversationId, limit);
    }));
  }
  async searchMessages(query, userId = "local") {
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* BrowserMessageRepository;
      return yield* repo.search(query, userId);
    }));
  }
  async deleteMessage(id2) {
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* BrowserMessageRepository;
      return yield* repo.delete(id2);
    }));
  }
  subscribeToConversation(conversationId, callback) {
    if (!this.listeners.has(conversationId)) {
      this.listeners.set(conversationId, new Set);
    }
    this.listeners.get(conversationId).add(callback);
    if (!this.unsubscribers.has(conversationId)) {
      const self2 = this;
      const setupWatch = exports_Effect.gen(function* () {
        const repo = yield* BrowserMessageRepository;
        const unsubscribe = yield* repo.watchConversation(conversationId, (messages2) => {
          const listeners = self2.listeners.get(conversationId);
          if (listeners) {
            listeners.forEach((cb) => cb(messages2));
          }
        });
        self2.unsubscribers.set(conversationId, unsubscribe);
      });
      exports_Runtime.runPromise(this.runtime)(setupWatch).catch(console.error);
    }
    return () => {
      const listeners = this.listeners.get(conversationId);
      if (listeners) {
        listeners.delete(callback);
        if (listeners.size === 0) {
          this.unsubscribeFromConversation(conversationId);
        }
      }
    };
  }
  unsubscribeFromConversation(conversationId) {
    const unsubscribe = this.unsubscribers.get(conversationId);
    if (unsubscribe) {
      unsubscribe();
      this.unsubscribers.delete(conversationId);
    }
    this.listeners.delete(conversationId);
  }
  async startConversation(initialMessage, model, metadata2) {
    const conversation = await this.createConversation({
      model,
      metadata: metadata2
    });
    const message = await this.sendMessage({
      conversationId: conversation.id,
      role: "user",
      content: initialMessage,
      metadata: {}
    });
    return { conversation, message };
  }
}
// ../../packages/psionic/src/persistence/client.ts
class ChatClient {
  managedRuntime;
  runtime;
  listeners = new Map;
  unsubscribers = new Map;
  constructor(config2) {
    const layer = exports_Layer.provide(exports_Layer.mergeAll(ConversationRepositoryLive, MessageRepositoryLive), PGliteServiceLive(config2));
    this.managedRuntime = exports_ManagedRuntime.make(layer);
    this.runtime = this.managedRuntime.runtime;
  }
  async createConversation(conversation = {}) {
    const newConversation = {
      userId: conversation.userId || "local",
      title: conversation.title,
      model: conversation.model,
      metadata: conversation.metadata || {},
      ...conversation
    };
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* ConversationRepository;
      return yield* repo.create(newConversation);
    }));
  }
  async getConversation(id2) {
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* ConversationRepository;
      return yield* repo.get(id2);
    }));
  }
  async listConversations(userId = "local", includeArchived = false) {
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* ConversationRepository;
      return yield* repo.list(userId, includeArchived);
    }));
  }
  async updateConversation(id2, updates) {
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* ConversationRepository;
      return yield* repo.update(id2, updates);
    }));
  }
  async deleteConversation(id2) {
    this.unsubscribeFromConversation(id2);
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* ConversationRepository;
      return yield* repo.delete(id2);
    }));
  }
  async archiveConversation(id2) {
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* ConversationRepository;
      return yield* repo.archive(id2);
    }));
  }
  async sendMessage(message) {
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* MessageRepository;
      const sent = yield* repo.send(message);
      if (message.role === "user") {
        const conversationRepo = yield* ConversationRepository;
        const conversation = yield* conversationRepo.get(message.conversationId);
        if (conversation && !conversation.title) {
          yield* conversationRepo.generateTitle(message.conversationId);
        }
      }
      return sent;
    }));
  }
  async getMessages(conversationId, limit) {
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* MessageRepository;
      const messages2 = yield* repo.getConversation(conversationId, limit);
      return messages2.reverse();
    }));
  }
  async searchMessages(query, userId = "local") {
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* MessageRepository;
      return yield* repo.search(query, userId);
    }));
  }
  async deleteMessage(id2) {
    return exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
      const repo = yield* MessageRepository;
      return yield* repo.delete(id2);
    }));
  }
  subscribeToConversation(conversationId, callback) {
    if (!this.listeners.has(conversationId)) {
      this.listeners.set(conversationId, new Set);
    }
    this.listeners.get(conversationId).add(callback);
    if (!this.unsubscribers.has(conversationId)) {
      const self2 = this;
      exports_Runtime.runPromise(this.runtime)(exports_Effect.gen(function* () {
        const repo = yield* MessageRepository;
        const unsubscribe = yield* repo.watchConversation(conversationId, (messages2) => {
          const listeners = self2.listeners.get(conversationId);
          if (listeners) {
            const orderedMessages = [...messages2].sort((a, b3) => new Date(a.createdAt).getTime() - new Date(b3.createdAt).getTime());
            listeners.forEach((cb) => cb(orderedMessages));
          }
        });
        self2.unsubscribers.set(conversationId, unsubscribe);
      }));
    }
    return () => {
      const listeners = this.listeners.get(conversationId);
      if (listeners) {
        listeners.delete(callback);
        if (listeners.size === 0) {
          this.unsubscribeFromConversation(conversationId);
        }
      }
    };
  }
  unsubscribeFromConversation(conversationId) {
    const unsubscribe = this.unsubscribers.get(conversationId);
    if (unsubscribe) {
      unsubscribe();
      this.unsubscribers.delete(conversationId);
    }
    this.listeners.delete(conversationId);
  }
  async startConversation(initialMessage, model, metadata2) {
    const conversation = await this.createConversation({
      model,
      metadata: metadata2
    });
    const message = await this.sendMessage({
      conversationId: conversation.id,
      role: "user",
      content: initialMessage,
      metadata: {}
    });
    return { conversation, message };
  }
}
export {
  BrowserEffectChatClient as ChatClient
};
