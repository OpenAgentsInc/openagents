# Document Transformations in ProseMirror

## Why Transforms Matter

Transforms are central to ProseMirror's design. Instead of directly mutating documents, ProseMirror uses a system that:
- Creates a trail of updates
- Enables undo history tracking
- Supports collaborative editing
- Allows plugins to inspect and react to changes

## Steps

Steps are the fundamental units of document updates. They describe specific changes to a document.

```javascript
// Example of applying a step
console.log(myDoc.toString()) // → p("hello")
let step = new ReplaceStep(3, 5, Slice.empty)
let result = step.apply(myDoc)
console.log(result.doc.toString()) // → p("heo")
```

Key characteristics of steps:
- Represent atomic document modifications
- Can be applied to create new documents
- May fail if the modification is invalid
- Typically generated by helper functions

### Common Step Types

- `ReplaceStep`: Replace a document slice with another slice
- `ReplaceAroundStep`: Replace around a range (for structural changes)
- `AddMarkStep`: Add a mark to inline content
- `RemoveMarkStep`: Remove a mark from inline content

## Transforms

Transforms collect multiple steps and provide convenient methods for document modification:

```javascript
let tr = new Transform(myDoc)
tr.delete(5, 7)   // Delete between position 5 and 7
tr.split(5)       // Split the parent node at position 5
console.log(tr.doc.toString())  // Modified document
console.log(tr.steps.length)    // Number of steps
```

Transform methods typically return the transform itself, enabling method chaining.

### Common Transform Methods

```javascript
// Text manipulation
tr.insertText("hello", pos)
tr.replaceWith(from, to, content)
tr.delete(from, to)

// Structure manipulation
tr.split(pos, depth, typesAfter)
tr.join(pos, depth)
tr.lift(range, target)
tr.wrap(range, wrappers)
tr.setBlockType(from, to, type, attrs)

// Mark manipulation
tr.addMark(from, to, mark)
tr.removeMark(from, to, mark)
```

## Mapping

When document changes occur, positions in the document may become invalid or shift. Mapping helps track these positional changes:

```javascript
let step = new ReplaceStep(4, 6, Slice.empty) // Delete 4-5
let map = step.getMap()
console.log(map.map(8)) // → 6
console.log(map.map(2)) // → 2 (unchanged before change)
```

### Mapping Options

```javascript
// Map with different bias for insertions
map.map(pos, -1)  // Bias to left side of insertion
map.map(pos, 1)   // Bias to right side of insertion

// Map ranges
let mapped = map.mapResult(pos)
mapped.pos        // New position
mapped.deleted    // Whether position was deleted
```

Transforms automatically accumulate mappings, allowing complex position tracking across multiple steps.

```javascript
let tr = new Transform(doc)
tr.delete(2, 4)
tr.insertText("hello", 2)

// Map old position through all changes
let newPos = tr.mapping.map(10)
```

## Rebasing

Rebasing is the process of transforming steps to apply to a modified document. This is crucial for collaborative editing.

```javascript
// Two users start with same document
let doc = schema.node("doc", null, [
  schema.node("paragraph", null, [schema.text("hello")])
])

// User A makes changes
let stepsA = [
  new ReplaceStep(2, 2, schema.text("A").slice(0))
]

// User B makes changes to same document
let stepsB = [
  new ReplaceStep(6, 6, schema.text("B").slice(0))
]

// Apply A's changes
let docA = stepsA.reduce((d, step) => step.apply(d).doc, doc)

// Rebase B's changes on top of A's
let mappedB = stepsB.map(step => {
  let mapped = step.map(new Mapping(stepsA.map(s => s.getMap())))
  return mapped
})
```

## Position Mapping Example

```javascript
// Complex mapping example
let tr = new Transform(doc)
tr.delete(10, 15)  // Delete 5 characters
tr.insertText("new text", 8)  // Insert before deleted region

// Original position 20 is now at:
let newPos = tr.mapping.map(20)  // Accounts for both changes
```

## Transform Helpers

ProseMirror provides many helper functions for common transformations:

```javascript
import {replaceStep} from "prosemirror-transform"

// Create a step to replace content
let step = replaceStep(doc, from, to, slice)

// Check if a split is possible
import {canSplit} from "prosemirror-transform"
if (canSplit(doc, pos)) {
  tr.split(pos)
}
```

## Best Practices

1. **Never modify documents directly** - Always use transforms
2. **Store steps for history** - Steps can be inverted for undo
3. **Use mapping for position tracking** - Essential for collaborative editing
4. **Check step validity** - Steps can fail on incompatible documents
5. **Compose transforms** - Chain operations for efficiency

## Step Inversion

Steps can be inverted to support undo functionality:

```javascript
let step = new ReplaceStep(2, 4, Slice.empty)
let inverted = step.invert(doc)
// Applying inverted step undoes the original
```