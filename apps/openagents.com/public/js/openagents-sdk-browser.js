var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value3) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value3 }) : obj[key] = value3;
var __commonJS = (cb, mod3) => function __require() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __export = (target, all11) => {
  for (var name in all11)
    __defProp(target, name, { get: all11[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));
var __publicField = (obj, key, value3) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value3);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value3) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value3);
var __privateSet = (obj, member, value3, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value3) : member.set(obj, value3), value3);

// ../../node_modules/.pnpm/ws@8.18.0/node_modules/ws/browser.js
var require_browser = __commonJS({
  "../../node_modules/.pnpm/ws@8.18.0/node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// ../../node_modules/.pnpm/bech32@2.0.0/node_modules/bech32/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/.pnpm/bech32@2.0.0/node_modules/bech32/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bech32m = exports.bech32 = void 0;
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (let z = 0; z < ALPHABET.length; z++) {
      const x = ALPHABET.charAt(z);
      ALPHABET_MAP[x] = z;
    }
    function polymodStep(pre2) {
      const b = pre2 >> 25;
      return (pre2 & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      let chk = 1;
      for (let i = 0; i < prefix.length; ++i) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c >> 5;
      }
      chk = polymodStep(chk);
      for (let i = 0; i < prefix.length; ++i) {
        const v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ v & 31;
      }
      return chk;
    }
    function convert(data, inBits, outBits, pad3) {
      let value3 = 0;
      let bits = 0;
      const maxV = (1 << outBits) - 1;
      const result = [];
      for (let i = 0; i < data.length; ++i) {
        value3 = value3 << inBits | data[i];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value3 >> bits & maxV);
        }
      }
      if (pad3) {
        if (bits > 0) {
          result.push(value3 << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value3 << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWords(bytes3) {
      return convert(bytes3, 8, 5, true);
    }
    function fromWordsUnsafe(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function getLibraryFromEncoding(encoding) {
      let ENCODING_CONST;
      if (encoding === "bech32") {
        ENCODING_CONST = 1;
      } else {
        ENCODING_CONST = 734539939;
      }
      function encode6(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
          throw new TypeError("Exceeds length limit");
        prefix = prefix.toLowerCase();
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          throw new Error(chk);
        let result = prefix + "1";
        for (let i = 0; i < words.length; ++i) {
          const x = words[i];
          if (x >> 5 !== 0)
            throw new Error("Non 5-bit word");
          chk = polymodStep(chk) ^ x;
          result += ALPHABET.charAt(x);
        }
        for (let i = 0; i < 6; ++i) {
          chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i = 0; i < 6; ++i) {
          const v = chk >> (5 - i) * 5 & 31;
          result += ALPHABET.charAt(v);
        }
        return result;
      }
      function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
          return str + " too short";
        if (str.length > LIMIT)
          return "Exceeds length limit";
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
          return "Mixed-case string " + str;
        str = lowered;
        const split8 = str.lastIndexOf("1");
        if (split8 === -1)
          return "No separator character for " + str;
        if (split8 === 0)
          return "Missing prefix for " + str;
        const prefix = str.slice(0, split8);
        const wordChars2 = str.slice(split8 + 1);
        if (wordChars2.length < 6)
          return "Data too short";
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          return chk;
        const words = [];
        for (let i = 0; i < wordChars2.length; ++i) {
          const c = wordChars2.charAt(i);
          const v = ALPHABET_MAP[c];
          if (v === void 0)
            return "Unknown character " + c;
          chk = polymodStep(chk) ^ v;
          if (i + 6 >= wordChars2.length)
            continue;
          words.push(v);
        }
        if (chk !== ENCODING_CONST)
          return "Invalid checksum for " + str;
        return { prefix, words };
      }
      function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
      }
      function decode7(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
        throw new Error(res);
      }
      return {
        decodeUnsafe,
        decode: decode7,
        encode: encode6,
        toWords,
        fromWordsUnsafe,
        fromWords
      };
    }
    exports.bech32 = getLibraryFromEncoding("bech32");
    exports.bech32m = getLibraryFromEncoding("bech32m");
  }
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Context.js
var Context_exports = {};
__export(Context_exports, {
  GenericTag: () => GenericTag,
  Reference: () => Reference2,
  Tag: () => Tag2,
  add: () => add2,
  empty: () => empty2,
  get: () => get2,
  getOption: () => getOption2,
  getOrElse: () => getOrElse2,
  isContext: () => isContext2,
  isReference: () => isReference2,
  isTag: () => isTag2,
  make: () => make2,
  merge: () => merge2,
  mergeAll: () => mergeAll2,
  omit: () => omit2,
  pick: () => pick2,
  unsafeGet: () => unsafeGet2,
  unsafeMake: () => unsafeMake
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Function.js
var isFunction = (input) => typeof input === "function";
var dual = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self) => body(self, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self) {
          return body(self, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self) {
          return body(self, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self) {
          return body(self, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self) {
          return body(self, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args2 = arguments;
        return function(self) {
          return body(self, ...args2);
        };
      };
  }
};
var identity = (a) => a;
var unsafeCoerce = identity;
var constant = (value3) => () => value3;
var constTrue = /* @__PURE__ */ constant(true);
var constFalse = /* @__PURE__ */ constant(false);
var constNull = /* @__PURE__ */ constant(null);
var constUndefined = /* @__PURE__ */ constant(void 0);
var constVoid = constUndefined;
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.16.3";
var getCurrentVersion = () => moduleVersion;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId = `effect/GlobalValue/globalStoreId/${/* @__PURE__ */ getCurrentVersion()}`;
var globalStore;
var globalValue = (id3, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ?? (globalThis[globalStoreId] = /* @__PURE__ */ new Map());
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id3)) {
    globalStore.set(id3, compute());
  }
  return globalStore.get(id3);
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Predicate.js
var isTruthy = (input) => !!input;
var isSet = (input) => input instanceof Set;
var isMap = (input) => input instanceof Map;
var isString = (input) => typeof input === "string";
var isNumber = (input) => typeof input === "number";
var isBoolean = (input) => typeof input === "boolean";
var isBigInt = (input) => typeof input === "bigint";
var isSymbol = (input) => typeof input === "symbol";
var isFunction2 = isFunction;
var isUndefined = (input) => input === void 0;
var isNotUndefined = (input) => input !== void 0;
var isNotNull = (input) => input !== null;
var isNever = (_) => false;
var isRecordOrArray = (input) => typeof input === "object" && input !== null;
var isObject = (input) => isRecordOrArray(input) || isFunction2(input);
var hasProperty = /* @__PURE__ */ dual(2, (self, property2) => isObject(self) && property2 in self);
var isTagged = /* @__PURE__ */ dual(2, (self, tag3) => hasProperty(self, "_tag") && self["_tag"] === tag3);
var isNullable = (input) => input === null || input === void 0;
var isNotNullable = (input) => input !== null && input !== void 0;
var isUint8Array = (input) => input instanceof Uint8Array;
var isDate = (input) => input instanceof Date;
var isIterable = (input) => hasProperty(input, Symbol.iterator);
var isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);
var isPromiseLike = (input) => hasProperty(input, "then") && isFunction2(input.then);

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Utils.js
var GenKindTypeId = /* @__PURE__ */ Symbol.for("effect/Gen/GenKind");
var isGenKind = (u) => isObject(u) && GenKindTypeId in u;
var _a;
var GenKindImpl = class {
  constructor(value3) {
    __publicField(this, "value");
    /**
     * @since 2.0.0
     */
    __publicField(this, _a, GenKindTypeId);
    this.value = value3;
  }
  /**
   * @since 2.0.0
   */
  get _F() {
    return identity;
  }
  /**
   * @since 2.0.0
   */
  get _R() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _O() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _E() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  [(_a = GenKindTypeId, Symbol.iterator)]() {
    return new SingleShotGen(this);
  }
};
var SingleShotGen = class _SingleShotGen {
  constructor(self) {
    __publicField(this, "self");
    __publicField(this, "called", false);
    this.self = self;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
   * @since 2.0.0
   */
  throw(e) {
    throw e;
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var adapter = () => function() {
  let x = arguments[0];
  for (let i = 1; i < arguments.length; i++) {
    x = arguments[i](x);
  }
  return new GenKindImpl(x);
};
var defaultIncHi = 335903614;
var defaultIncLo = 4150755663;
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var BIT_53 = 9007199254740992;
var BIT_27 = 134217728;
var PCGRandom = class {
  constructor(seedHi, seedLo, incHi, incLo) {
    __publicField(this, "_state");
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  /**
   * Returns a copy of the internal state of this random number generator as a
   * JavaScript Array.
   *
   * @category getters
   * @since 2.0.0
   */
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  /**
   * Restore state previously retrieved using `getState()`.
   *
   * @since 2.0.0
   */
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  /**
   * Get a uniformly distributed 32 bit integer between [0, max).
   *
   * @category getter
   * @since 2.0.0
   */
  integer(max7) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max7;
  }
  /**
   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
   * 53 bits of precision (every bit of the mantissa is randomized).
   *
   * @category getters
   * @since 2.0.0
   */
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  /** @internal */
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
};
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
var YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");
var _value;
var YieldWrap = class {
  constructor(value3) {
    /**
     * @since 3.0.6
     */
    __privateAdd(this, _value);
    __privateSet(this, _value, value3);
  }
  /**
   * @since 3.0.6
   */
  [YieldWrapTypeId]() {
    return __privateGet(this, _value);
  }
};
_value = new WeakMap();
function yieldWrapGet(self) {
  if (typeof self === "object" && self !== null && YieldWrapTypeId in self) {
    return self[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
var structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: void 0
}));
var standard = {
  effect_internal_function: (body) => {
    return body();
  }
};
var forced = {
  effect_internal_function: (body) => {
    try {
      return body();
    } finally {
    }
  }
};
var isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
var genConstructor = function* () {
}.constructor;
var isGeneratorFunction = (u) => isObject(u) && u.constructor === genConstructor;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Hash.js
var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
var symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
var hash = (self) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self) {
    case "number":
      return number(self);
    case "bigint":
      return string(self.toString(10));
    case "boolean":
      return string(String(self));
    case "symbol":
      return string(String(self));
    case "string":
      return string(self);
    case "undefined":
      return string("undefined");
    case "function":
    case "object": {
      if (self === null) {
        return string("null");
      } else if (self instanceof Date) {
        return hash(self.toISOString());
      } else if (self instanceof URL) {
        return hash(self.href);
      } else if (isHash(self)) {
        return self[symbol]();
      } else {
        return random(self);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
var random = (self) => {
  if (!randomHashCache.has(self)) {
    randomHashCache.set(self, number(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self);
};
var combine = (b) => (self) => self * 53 ^ b;
var optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
var isHash = (u) => hasProperty(u, symbol);
var number = (n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h = n | 0;
  if (h !== n) {
    h ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h ^= n /= 4294967295;
  }
  return optimize(h);
};
var string = (str) => {
  let h = 5381, i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h);
};
var structureKeys = (o, keys6) => {
  let h = 12289;
  for (let i = 0; i < keys6.length; i++) {
    h ^= pipe(string(keys6[i]), combine(hash(o[keys6[i]])));
  }
  return optimize(h);
};
var structure = (o) => structureKeys(o, Object.keys(o));
var array = (arr) => {
  let h = 6151;
  for (let i = 0; i < arr.length; i++) {
    h = pipe(h, combine(hash(arr[i])));
  }
  return optimize(h);
};
var cached = function() {
  if (arguments.length === 1) {
    const self2 = arguments[0];
    return function(hash5) {
      Object.defineProperty(self2, symbol, {
        value() {
          return hash5;
        },
        enumerable: false
      });
      return hash5;
    };
  }
  const self = arguments[0];
  const hash4 = arguments[1];
  Object.defineProperty(self, symbol, {
    value() {
      return hash4;
    },
    enumerable: false
  });
  return hash4;
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Equal.js
var symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self) => compareBoth(self, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self, that) {
  if (self === that) {
    return true;
  }
  const selfType = typeof self;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self !== null && that !== null) {
      if (isEqual(self) && isEqual(that)) {
        if (hash(self) === hash(that) && self[symbol2](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
        }
      } else if (self instanceof Date && that instanceof Date) {
        return self.toISOString() === that.toISOString();
      } else if (self instanceof URL && that instanceof URL) {
        return self.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self) && Array.isArray(that)) {
        return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
        const keysSelf = Object.keys(self);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!(key in that && compareBoth(self[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
}
var isEqual = (u) => hasProperty(u, symbol2);
var equivalence = () => equals;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Inspectable.js
var NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var toJSON = (x) => {
  try {
    if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
};
var format = (x) => JSON.stringify(x, null, 2);
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var Class = class {
  /**
   * @since 2.0.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  /**
   * @since 2.0.0
   */
  toString() {
    return format(this.toJSON());
  }
};
var toStringUnknown = (u, whitespace = 2) => {
  if (typeof u === "string") {
    return u;
  }
  try {
    return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
  } catch {
    return String(u);
  }
};
var stringifyCircular = (obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value3) => typeof value3 === "object" && value3 !== null ? cache.includes(value3) ? void 0 : cache.push(value3) && (redactableState.fiberRefs !== void 0 && isRedactable(value3) ? value3[symbolRedactable](redactableState.fiberRefs) : value3) : value3, whitespace);
  cache = void 0;
  return retVal;
};
var symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
var isRedactable = (u) => typeof u === "object" && u !== null && symbolRedactable in u;
var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: void 0
}));
var withRedactableContext = (context9, f) => {
  const prev = redactableState.fiberRefs;
  redactableState.fiberRefs = context9;
  try {
    return f();
  } finally {
    redactableState.fiberRefs = prev;
  }
};
var redact = (u) => {
  if (isRedactable(u) && redactableState.fiberRefs !== void 0) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Pipeable.js
var pipeArguments = (self, args2) => {
  switch (args2.length) {
    case 0:
      return self;
    case 1:
      return args2[0](self);
    case 2:
      return args2[1](args2[0](self));
    case 3:
      return args2[2](args2[1](args2[0](self)));
    case 4:
      return args2[3](args2[2](args2[1](args2[0](self))));
    case 5:
      return args2[4](args2[3](args2[2](args2[1](args2[0](self)))));
    case 6:
      return args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self))))));
    case 7:
      return args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self)))))));
    case 8:
      return args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self))))))));
    case 9:
      return args2[8](args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self)))))))));
    default: {
      let ret = self;
      for (let i = 0, len = args2.length; i < len; i++) {
        ret = args2[i](ret);
      }
      return ret;
    }
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_ASYNC = "Async";
var OP_COMMIT = "Commit";
var OP_FAILURE = "Failure";
var OP_ON_FAILURE = "OnFailure";
var OP_ON_SUCCESS = "OnSuccess";
var OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
var OP_SUCCESS = "Success";
var OP_SYNC = "Sync";
var OP_TAG = "Tag";
var OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
var OP_WHILE = "While";
var OP_ITERATOR = "Iterator";
var OP_WITH_RUNTIME = "WithRuntime";
var OP_YIELD = "Yield";
var OP_REVERT_FLAGS = "RevertFlags";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
var StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
var SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
var ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
var effectVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _,
  _V: /* @__PURE__ */ getCurrentVersion()
};
var sinkVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _L: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var channelVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol2](that) {
    return this === that;
  },
  [symbol]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol]() {
    return cached(this, structure(this));
  },
  [symbol2](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};
var Base = /* @__PURE__ */ function() {
  function Base3() {
  }
  Base3.prototype = CommitPrototype;
  return Base3;
}();

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/option.js
var TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol2](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol]() {
    return cached(this, combine(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = /* @__PURE__ */ hash("None");
var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol2](that) {
    return isOption(that) && isNone(that);
  },
  [symbol]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = (input) => hasProperty(input, TypeId);
var isNone = (fa) => fa._tag === "None";
var isSome = (fa) => fa._tag === "Some";
var none = /* @__PURE__ */ Object.create(NoneProto);
var some = (value3) => {
  const a = Object.create(SomeProto);
  a.value = value3;
  return a;
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/context.js
var TagTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
var ReferenceTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
var STMSymbolKey = "effect/STM";
var STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
var TagProto = {
  ...EffectPrototype,
  _op: "Tag",
  [STMTypeId]: effectVariance,
  [TagTypeId]: {
    _Service: (_) => _,
    _Identifier: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self) {
    return self;
  },
  context(self) {
    return make(this, self);
  }
};
var ReferenceProto = {
  ...TagProto,
  [ReferenceTypeId]: ReferenceTypeId
};
var makeGenericTag = (key) => {
  const limit2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit2;
  const tag3 = Object.create(TagProto);
  Object.defineProperty(tag3, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag3.key = key;
  return tag3;
};
var Tag = (id3) => () => {
  const limit2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit2;
  function TagClass() {
  }
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id3;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return TagClass;
};
var Reference = () => (id3, options) => {
  const limit2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit2;
  function ReferenceClass() {
  }
  Object.setPrototypeOf(ReferenceClass, ReferenceProto);
  ReferenceClass.key = id3;
  ReferenceClass.defaultValue = options.defaultValue;
  Object.defineProperty(ReferenceClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return ReferenceClass;
};
var TypeId2 = /* @__PURE__ */ Symbol.for("effect/Context");
var ContextProto = {
  [TypeId2]: {
    _Services: (_) => _
  },
  [symbol2](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol]() {
    return cached(this, number(this.unsafeMap.size));
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var makeContext = (unsafeMap) => {
  const context9 = Object.create(ContextProto);
  context9.unsafeMap = unsafeMap;
  return context9;
};
var serviceNotFoundError = (tag3) => {
  const error2 = new Error(`Service not found${tag3.key ? `: ${String(tag3.key)}` : ""}`);
  if (tag3.stack) {
    const lines3 = tag3.stack.split("\n");
    if (lines3.length > 2) {
      const afterAt = lines3[2].match(/at (.*)/);
      if (afterAt) {
        error2.message = error2.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error2.stack) {
    const lines3 = error2.stack.split("\n");
    lines3.splice(1, 3);
    error2.stack = lines3.join("\n");
  }
  return error2;
};
var isContext = (u) => hasProperty(u, TypeId2);
var isTag = (u) => hasProperty(u, TagTypeId);
var isReference = (u) => hasProperty(u, ReferenceTypeId);
var _empty = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map());
var empty = () => _empty;
var make = (tag3, service3) => makeContext(/* @__PURE__ */ new Map([[tag3.key, service3]]));
var add = /* @__PURE__ */ dual(3, (self, tag3, service3) => {
  const map31 = new Map(self.unsafeMap);
  map31.set(tag3.key, service3);
  return makeContext(map31);
});
var defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => /* @__PURE__ */ new Map());
var getDefaultValue = (tag3) => {
  if (defaultValueCache.has(tag3.key)) {
    return defaultValueCache.get(tag3.key);
  }
  const value3 = tag3.defaultValue();
  defaultValueCache.set(tag3.key, value3);
  return value3;
};
var unsafeGetReference = (self, tag3) => {
  return self.unsafeMap.has(tag3.key) ? self.unsafeMap.get(tag3.key) : getDefaultValue(tag3);
};
var unsafeGet = /* @__PURE__ */ dual(2, (self, tag3) => {
  if (!self.unsafeMap.has(tag3.key)) {
    if (ReferenceTypeId in tag3) return getDefaultValue(tag3);
    throw serviceNotFoundError(tag3);
  }
  return self.unsafeMap.get(tag3.key);
});
var get = unsafeGet;
var getOrElse = /* @__PURE__ */ dual(3, (self, tag3, orElse15) => {
  if (!self.unsafeMap.has(tag3.key)) {
    return isReference(tag3) ? getDefaultValue(tag3) : orElse15();
  }
  return self.unsafeMap.get(tag3.key);
});
var getOption = /* @__PURE__ */ dual(2, (self, tag3) => {
  if (!self.unsafeMap.has(tag3.key)) {
    return isReference(tag3) ? some(getDefaultValue(tag3)) : none;
  }
  return some(self.unsafeMap.get(tag3.key));
});
var merge = /* @__PURE__ */ dual(2, (self, that) => {
  const map31 = new Map(self.unsafeMap);
  for (const [tag3, s] of that.unsafeMap) {
    map31.set(tag3, s);
  }
  return makeContext(map31);
});
var mergeAll = (...ctxs) => {
  const map31 = /* @__PURE__ */ new Map();
  for (const ctx of ctxs) {
    for (const [tag3, s] of ctx.unsafeMap) {
      map31.set(tag3, s);
    }
  }
  return makeContext(map31);
};
var pick = (...tags) => (self) => {
  const tagSet = new Set(tags.map((_) => _.key));
  const newEnv = /* @__PURE__ */ new Map();
  for (const [tag3, s] of self.unsafeMap.entries()) {
    if (tagSet.has(tag3)) {
      newEnv.set(tag3, s);
    }
  }
  return makeContext(newEnv);
};
var omit = (...tags) => (self) => {
  const newEnv = new Map(self.unsafeMap);
  for (const tag3 of tags) {
    newEnv.delete(tag3.key);
  }
  return makeContext(newEnv);
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Context.js
var GenericTag = makeGenericTag;
var unsafeMake = makeContext;
var isContext2 = isContext;
var isTag2 = isTag;
var isReference2 = isReference;
var empty2 = empty;
var make2 = make;
var add2 = add;
var get2 = get;
var getOrElse2 = getOrElse;
var unsafeGet2 = unsafeGet;
var getOption2 = getOption;
var merge2 = merge;
var mergeAll2 = mergeAll;
var pick2 = pick;
var omit2 = omit;
var Tag2 = Tag;
var Reference2 = Reference;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Effect.js
var Effect_exports = {};
__export(Effect_exports, {
  Do: () => Do3,
  EffectTypeId: () => EffectTypeId3,
  Service: () => Service,
  Tag: () => Tag3,
  acquireRelease: () => acquireRelease2,
  acquireReleaseInterruptible: () => acquireReleaseInterruptible2,
  acquireUseRelease: () => acquireUseRelease2,
  addFinalizer: () => addFinalizer3,
  all: () => all7,
  allSuccesses: () => allSuccesses2,
  allWith: () => allWith2,
  allowInterrupt: () => allowInterrupt2,
  andThen: () => andThen6,
  annotateCurrentSpan: () => annotateCurrentSpan2,
  annotateLogs: () => annotateLogs3,
  annotateLogsScoped: () => annotateLogsScoped2,
  annotateSpans: () => annotateSpans3,
  ap: () => ap2,
  as: () => as6,
  asSome: () => asSome2,
  asSomeError: () => asSomeError2,
  asVoid: () => asVoid4,
  async: () => async2,
  asyncEffect: () => asyncEffect2,
  awaitAllChildren: () => awaitAllChildren2,
  bind: () => bind4,
  bindAll: () => bindAll2,
  bindTo: () => bindTo4,
  blocked: () => blocked2,
  cacheRequestResult: () => cacheRequestResult,
  cached: () => cached3,
  cachedFunction: () => cachedFunction2,
  cachedInvalidateWithTTL: () => cachedInvalidateWithTTL2,
  cachedWithTTL: () => cachedWithTTL,
  catch: () => _catch2,
  catchAll: () => catchAll3,
  catchAllCause: () => catchAllCause3,
  catchAllDefect: () => catchAllDefect2,
  catchIf: () => catchIf2,
  catchSome: () => catchSome2,
  catchSomeCause: () => catchSomeCause2,
  catchSomeDefect: () => catchSomeDefect2,
  catchTag: () => catchTag2,
  catchTags: () => catchTags2,
  cause: () => cause2,
  checkInterruptible: () => checkInterruptible2,
  clock: () => clock2,
  clockWith: () => clockWith4,
  configProviderWith: () => configProviderWith2,
  console: () => console3,
  consoleWith: () => consoleWith2,
  context: () => context3,
  contextWith: () => contextWith2,
  contextWithEffect: () => contextWithEffect2,
  currentParentSpan: () => currentParentSpan2,
  currentSpan: () => currentSpan2,
  custom: () => custom2,
  daemonChildren: () => daemonChildren2,
  delay: () => delay2,
  descriptor: () => descriptor2,
  descriptorWith: () => descriptorWith2,
  die: () => die6,
  dieMessage: () => dieMessage2,
  dieSync: () => dieSync3,
  diffFiberRefs: () => diffFiberRefs2,
  disconnect: () => disconnect2,
  dropUntil: () => dropUntil2,
  dropWhile: () => dropWhile3,
  either: () => either4,
  ensuring: () => ensuring3,
  ensuringChild: () => ensuringChild2,
  ensuringChildren: () => ensuringChildren2,
  eventually: () => eventually2,
  every: () => every9,
  exists: () => exists3,
  exit: () => exit3,
  fail: () => fail10,
  failCause: () => failCause9,
  failCauseSync: () => failCauseSync3,
  failSync: () => failSync3,
  fiberId: () => fiberId2,
  fiberIdWith: () => fiberIdWith2,
  filter: () => filter9,
  filterEffectOrElse: () => filterEffectOrElse2,
  filterEffectOrFail: () => filterEffectOrFail2,
  filterMap: () => filterMap8,
  filterOrDie: () => filterOrDie2,
  filterOrDieMessage: () => filterOrDieMessage2,
  filterOrElse: () => filterOrElse2,
  filterOrFail: () => filterOrFail2,
  finalizersMask: () => finalizersMask2,
  findFirst: () => findFirst8,
  firstSuccessOf: () => firstSuccessOf2,
  flatMap: () => flatMap12,
  flatten: () => flatten9,
  flip: () => flip2,
  flipWith: () => flipWith2,
  fn: () => fn,
  fnUntraced: () => fnUntraced2,
  forEach: () => forEach10,
  forever: () => forever3,
  fork: () => fork3,
  forkAll: () => forkAll2,
  forkDaemon: () => forkDaemon2,
  forkIn: () => forkIn2,
  forkScoped: () => forkScoped2,
  forkWithErrorHandler: () => forkWithErrorHandler2,
  fromFiber: () => fromFiber2,
  fromFiberEffect: () => fromFiberEffect2,
  fromNullable: () => fromNullable3,
  functionWithSpan: () => functionWithSpan2,
  gen: () => gen3,
  getFiberRefs: () => getFiberRefs,
  getRuntimeFlags: () => getRuntimeFlags,
  head: () => head4,
  if: () => if_2,
  ignore: () => ignore2,
  ignoreLogged: () => ignoreLogged2,
  inheritFiberRefs: () => inheritFiberRefs2,
  interrupt: () => interrupt7,
  interruptWith: () => interruptWith2,
  interruptible: () => interruptible4,
  interruptibleMask: () => interruptibleMask2,
  intoDeferred: () => intoDeferred2,
  isEffect: () => isEffect2,
  isFailure: () => isFailure4,
  isSuccess: () => isSuccess3,
  iterate: () => iterate2,
  labelMetrics: () => labelMetrics2,
  labelMetricsScoped: () => labelMetricsScoped2,
  let: () => let_4,
  liftPredicate: () => liftPredicate3,
  linkSpanCurrent: () => linkSpanCurrent2,
  linkSpans: () => linkSpans2,
  locally: () => locally,
  locallyScoped: () => locallyScoped,
  locallyScopedWith: () => locallyScopedWith,
  locallyWith: () => locallyWith,
  log: () => log2,
  logAnnotations: () => logAnnotations2,
  logDebug: () => logDebug2,
  logError: () => logError2,
  logFatal: () => logFatal2,
  logInfo: () => logInfo2,
  logTrace: () => logTrace2,
  logWarning: () => logWarning2,
  logWithLevel: () => logWithLevel2,
  loop: () => loop2,
  makeLatch: () => makeLatch2,
  makeSemaphore: () => makeSemaphore2,
  makeSpan: () => makeSpan2,
  makeSpanScoped: () => makeSpanScoped2,
  map: () => map18,
  mapAccum: () => mapAccum4,
  mapBoth: () => mapBoth5,
  mapError: () => mapError3,
  mapErrorCause: () => mapErrorCause2,
  mapInputContext: () => mapInputContext3,
  match: () => match14,
  matchCause: () => matchCause4,
  matchCauseEffect: () => matchCauseEffect3,
  matchEffect: () => matchEffect2,
  merge: () => merge7,
  mergeAll: () => mergeAll5,
  metricLabels: () => metricLabels2,
  negate: () => negate2,
  never: () => never4,
  none: () => none9,
  onError: () => onError2,
  onExit: () => onExit3,
  onInterrupt: () => onInterrupt2,
  once: () => once3,
  option: () => option2,
  optionFromOptional: () => optionFromOptional2,
  orDie: () => orDie3,
  orDieWith: () => orDieWith2,
  orElse: () => orElse6,
  orElseFail: () => orElseFail2,
  orElseSucceed: () => orElseSucceed2,
  parallelErrors: () => parallelErrors2,
  parallelFinalizers: () => parallelFinalizers2,
  partition: () => partition5,
  patchFiberRefs: () => patchFiberRefs2,
  patchRuntimeFlags: () => patchRuntimeFlags,
  promise: () => promise2,
  provide: () => provide2,
  provideService: () => provideService3,
  provideServiceEffect: () => provideServiceEffect2,
  race: () => race2,
  raceAll: () => raceAll2,
  raceFirst: () => raceFirst2,
  raceWith: () => raceWith2,
  random: () => random3,
  randomWith: () => randomWith2,
  reduce: () => reduce12,
  reduceEffect: () => reduceEffect3,
  reduceRight: () => reduceRight4,
  reduceWhile: () => reduceWhile2,
  repeat: () => repeat,
  repeatN: () => repeatN2,
  repeatOrElse: () => repeatOrElse,
  replicate: () => replicate2,
  replicateEffect: () => replicateEffect2,
  request: () => request,
  retry: () => retry2,
  retryOrElse: () => retryOrElse,
  runCallback: () => runCallback,
  runFork: () => runFork2,
  runPromise: () => runPromise,
  runPromiseExit: () => runPromiseExit,
  runRequestBlock: () => runRequestBlock2,
  runSync: () => runSync,
  runSyncExit: () => runSyncExit,
  runtime: () => runtime4,
  sandbox: () => sandbox2,
  schedule: () => schedule,
  scheduleForked: () => scheduleForked2,
  scheduleFrom: () => scheduleFrom,
  scope: () => scope3,
  scopeWith: () => scopeWith2,
  scoped: () => scoped3,
  scopedWith: () => scopedWith2,
  sequentialFinalizers: () => sequentialFinalizers2,
  serviceConstants: () => serviceConstants2,
  serviceFunction: () => serviceFunction2,
  serviceFunctionEffect: () => serviceFunctionEffect2,
  serviceFunctions: () => serviceFunctions2,
  serviceMembers: () => serviceMembers2,
  serviceOption: () => serviceOption2,
  serviceOptional: () => serviceOptional2,
  setFiberRefs: () => setFiberRefs2,
  sleep: () => sleep4,
  spanAnnotations: () => spanAnnotations2,
  spanLinks: () => spanLinks2,
  step: () => step3,
  succeed: () => succeed10,
  succeedNone: () => succeedNone2,
  succeedSome: () => succeedSome2,
  summarized: () => summarized2,
  supervised: () => supervised2,
  suspend: () => suspend4,
  sync: () => sync5,
  tagMetrics: () => tagMetrics2,
  tagMetricsScoped: () => tagMetricsScoped2,
  takeUntil: () => takeUntil2,
  takeWhile: () => takeWhile3,
  tap: () => tap4,
  tapBoth: () => tapBoth2,
  tapDefect: () => tapDefect2,
  tapError: () => tapError3,
  tapErrorCause: () => tapErrorCause3,
  tapErrorTag: () => tapErrorTag2,
  timed: () => timed2,
  timedWith: () => timedWith2,
  timeout: () => timeout2,
  timeoutFail: () => timeoutFail2,
  timeoutFailCause: () => timeoutFailCause2,
  timeoutOption: () => timeoutOption2,
  timeoutTo: () => timeoutTo2,
  tracer: () => tracer2,
  tracerWith: () => tracerWith4,
  transplant: () => transplant2,
  transposeMapOption: () => transposeMapOption,
  transposeOption: () => transposeOption,
  try: () => try_3,
  tryMap: () => tryMap2,
  tryMapPromise: () => tryMapPromise2,
  tryPromise: () => tryPromise2,
  uninterruptible: () => uninterruptible2,
  uninterruptibleMask: () => uninterruptibleMask3,
  unless: () => unless2,
  unlessEffect: () => unlessEffect2,
  unsafeMakeLatch: () => unsafeMakeLatch2,
  unsafeMakeSemaphore: () => unsafeMakeSemaphore2,
  unsandbox: () => unsandbox2,
  updateFiberRefs: () => updateFiberRefs2,
  updateService: () => updateService2,
  useSpan: () => useSpan2,
  using: () => using2,
  validate: () => validate2,
  validateAll: () => validateAll2,
  validateFirst: () => validateFirst2,
  validateWith: () => validateWith2,
  void: () => _void,
  when: () => when2,
  whenEffect: () => whenEffect2,
  whenFiberRef: () => whenFiberRef2,
  whenLogLevel: () => whenLogLevel2,
  whenRef: () => whenRef2,
  whileLoop: () => whileLoop3,
  withClock: () => withClock2,
  withClockScoped: () => withClockScoped2,
  withConcurrency: () => withConcurrency2,
  withConfigProvider: () => withConfigProvider2,
  withConfigProviderScoped: () => withConfigProviderScoped2,
  withConsole: () => withConsole2,
  withConsoleScoped: () => withConsoleScoped2,
  withEarlyRelease: () => withEarlyRelease2,
  withExecutionPlan: () => withExecutionPlan2,
  withFiberRuntime: () => withFiberRuntime2,
  withLogSpan: () => withLogSpan2,
  withMaxOpsBeforeYield: () => withMaxOpsBeforeYield2,
  withMetric: () => withMetric2,
  withParentSpan: () => withParentSpan3,
  withRandom: () => withRandom2,
  withRandomScoped: () => withRandomScoped2,
  withRequestBatching: () => withRequestBatching2,
  withRequestCache: () => withRequestCache2,
  withRequestCaching: () => withRequestCaching2,
  withRuntimeFlagsPatch: () => withRuntimeFlagsPatch,
  withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped,
  withScheduler: () => withScheduler2,
  withSchedulingPriority: () => withSchedulingPriority2,
  withSpan: () => withSpan3,
  withSpanScoped: () => withSpanScoped2,
  withTracer: () => withTracer2,
  withTracerEnabled: () => withTracerEnabled2,
  withTracerScoped: () => withTracerScoped2,
  withTracerTiming: () => withTracerTiming2,
  withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel2,
  yieldNow: () => yieldNow4,
  zip: () => zip7,
  zipLeft: () => zipLeft5,
  zipRight: () => zipRight6,
  zipWith: () => zipWith9
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Equivalence.js
var make3 = (isEquivalent) => (self, that) => self === that || isEquivalent(self, that);
var isStrictEquivalent = (x, y) => x === y;
var strict = () => isStrictEquivalent;
var number2 = /* @__PURE__ */ strict();
var mapInput = /* @__PURE__ */ dual(2, (self, f) => make3((x, y) => self(f(x), f(y))));
var Date2 = /* @__PURE__ */ mapInput(number2, (date3) => date3.getTime());
var array2 = (item) => make3((self, that) => {
  if (self.length !== that.length) {
    return false;
  }
  for (let i = 0; i < self.length; i++) {
    const isEq = item(self[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/doNotation.js
var let_ = (map31) => dual(3, (self, name, f) => map31(self, (a) => Object.assign({}, a, {
  [name]: f(a)
})));
var bindTo = (map31) => dual(2, (self, name) => map31(self, (a) => ({
  [name]: a
})));
var bind = (map31, flatMap21) => dual(3, (self, name, f) => flatMap21(self, (a) => map31(f(a), (b) => Object.assign({}, a, {
  [name]: b
}))));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/either.js
var TypeId3 = /* @__PURE__ */ Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId3]: {
    _R: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol2](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol2](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = (input) => hasProperty(input, TypeId3);
var isLeft = (ma) => ma._tag === "Left";
var isRight = (ma) => ma._tag === "Right";
var left = (left3) => {
  const a = Object.create(LeftProto);
  a.left = left3;
  return a;
};
var right = (right3) => {
  const a = Object.create(RightProto);
  a.right = right3;
  return a;
};
var getLeft = (self) => isRight(self) ? none : some(self.left);
var getRight = (self) => isLeft(self) ? none : some(self.right);
var fromOption = /* @__PURE__ */ dual(2, (self, onNone) => isNone(self) ? left(onNone()) : right(self.value));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Either.js
var right2 = right;
var left2 = left;
var fromOption2 = fromOption;
var try_ = (evaluate3) => {
  if (isFunction2(evaluate3)) {
    try {
      return right2(evaluate3());
    } catch (e) {
      return left2(e);
    }
  } else {
    try {
      return right2(evaluate3.try());
    } catch (e) {
      return left2(evaluate3.catch(e));
    }
  }
};
var isEither2 = isEither;
var isLeft2 = isLeft;
var isRight2 = isRight;
var getEquivalence = ({
  left: left3,
  right: right3
}) => make3((x, y) => isLeft2(x) ? isLeft2(y) && left3(x.left, y.left) : isRight2(y) && right3(x.right, y.right));
var mapBoth = /* @__PURE__ */ dual(2, (self, {
  onLeft,
  onRight
}) => isLeft2(self) ? left2(onLeft(self.left)) : right2(onRight(self.right)));
var mapLeft = /* @__PURE__ */ dual(2, (self, f) => isLeft2(self) ? left2(f(self.left)) : right2(self.right));
var map = /* @__PURE__ */ dual(2, (self, f) => isRight2(self) ? right2(f(self.right)) : left2(self.left));
var match = /* @__PURE__ */ dual(2, (self, {
  onLeft,
  onRight
}) => isLeft2(self) ? onLeft(self.left) : onRight(self.right));
var merge3 = /* @__PURE__ */ match({
  onLeft: identity,
  onRight: identity
});
var getOrThrowWith = /* @__PURE__ */ dual(2, (self, onLeft) => {
  if (isRight2(self)) {
    return self.right;
  }
  throw onLeft(self.left);
});
var getOrThrow = /* @__PURE__ */ getOrThrowWith(() => new Error("getOrThrow called on a Left"));
var all = (input) => {
  if (Symbol.iterator in input) {
    const out2 = [];
    for (const e of input) {
      if (isLeft2(e)) {
        return e;
      }
      out2.push(e.right);
    }
    return right2(out2);
  }
  const out = {};
  for (const key of Object.keys(input)) {
    const e = input[key];
    if (isLeft2(e)) {
      return e;
    }
    out[key] = e.right;
  }
  return right2(out);
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray = (self) => self.length > 0;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Option.js
var Option_exports = {};
__export(Option_exports, {
  Do: () => Do,
  TypeId: () => TypeId4,
  all: () => all3,
  andThen: () => andThen,
  ap: () => ap,
  as: () => as,
  asVoid: () => asVoid,
  bind: () => bind2,
  bindTo: () => bindTo2,
  composeK: () => composeK,
  contains: () => contains,
  containsWith: () => containsWith,
  exists: () => exists,
  filter: () => filter,
  filterMap: () => filterMap,
  firstSomeOf: () => firstSomeOf,
  flatMap: () => flatMap,
  flatMapNullable: () => flatMapNullable,
  flatten: () => flatten,
  fromIterable: () => fromIterable,
  fromNullable: () => fromNullable,
  gen: () => gen,
  getEquivalence: () => getEquivalence2,
  getLeft: () => getLeft2,
  getOrElse: () => getOrElse3,
  getOrNull: () => getOrNull,
  getOrThrow: () => getOrThrow2,
  getOrThrowWith: () => getOrThrowWith2,
  getOrUndefined: () => getOrUndefined,
  getOrder: () => getOrder,
  getRight: () => getRight2,
  isNone: () => isNone2,
  isOption: () => isOption2,
  isSome: () => isSome2,
  let: () => let_2,
  lift2: () => lift2,
  liftNullable: () => liftNullable,
  liftPredicate: () => liftPredicate,
  liftThrowable: () => liftThrowable,
  map: () => map2,
  match: () => match2,
  mergeWith: () => mergeWith,
  none: () => none2,
  orElse: () => orElse,
  orElseEither: () => orElseEither,
  orElseSome: () => orElseSome,
  partitionMap: () => partitionMap,
  product: () => product,
  productMany: () => productMany,
  reduceCompact: () => reduceCompact,
  some: () => some2,
  tap: () => tap,
  toArray: () => toArray,
  toRefinement: () => toRefinement,
  void: () => void_,
  zipLeft: () => zipLeft,
  zipRight: () => zipRight,
  zipWith: () => zipWith
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Order.js
var make4 = (compare3) => (self, that) => self === that ? 0 : compare3(self, that);
var number3 = /* @__PURE__ */ make4((self, that) => self < that ? -1 : 1);
var bigint = /* @__PURE__ */ make4((self, that) => self < that ? -1 : 1);
var mapInput2 = /* @__PURE__ */ dual(2, (self, f) => make4((b1, b2) => self(f(b1), f(b2))));
var all2 = (collection) => {
  return make4((x, y) => {
    const len = Math.min(x.length, y.length);
    let collectionLength = 0;
    for (const O of collection) {
      if (collectionLength >= len) {
        break;
      }
      const o = O(x[collectionLength], y[collectionLength]);
      if (o !== 0) {
        return o;
      }
      collectionLength++;
    }
    return 0;
  });
};
var tuple = (...elements) => all2(elements);
var lessThan = (O) => dual(2, (self, that) => O(self, that) === -1);
var greaterThan = (O) => dual(2, (self, that) => O(self, that) === 1);
var lessThanOrEqualTo = (O) => dual(2, (self, that) => O(self, that) !== 1);
var greaterThanOrEqualTo = (O) => dual(2, (self, that) => O(self, that) !== -1);
var min = (O) => dual(2, (self, that) => self === that || O(self, that) < 1 ? self : that);
var max = (O) => dual(2, (self, that) => self === that || O(self, that) > -1 ? self : that);
var clamp = (O) => dual(2, (self, options) => min(O)(options.maximum, max(O)(options.minimum, self)));
var between = (O) => dual(2, (self, options) => !lessThan(O)(self, options.minimum) && !greaterThan(O)(self, options.maximum));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Option.js
var TypeId4 = /* @__PURE__ */ Symbol.for("effect/Option");
var none2 = () => none;
var some2 = some;
var isOption2 = isOption;
var isNone2 = isNone;
var isSome2 = isSome;
var match2 = /* @__PURE__ */ dual(2, (self, {
  onNone,
  onSome
}) => isNone2(self) ? onNone() : onSome(self.value));
var toRefinement = (f) => (a) => isSome2(f(a));
var fromIterable = (collection) => {
  for (const a of collection) {
    return some2(a);
  }
  return none2();
};
var getRight2 = getRight;
var getLeft2 = getLeft;
var getOrElse3 = /* @__PURE__ */ dual(2, (self, onNone) => isNone2(self) ? onNone() : self.value);
var orElse = /* @__PURE__ */ dual(2, (self, that) => isNone2(self) ? that() : self);
var orElseSome = /* @__PURE__ */ dual(2, (self, onNone) => isNone2(self) ? some2(onNone()) : self);
var orElseEither = /* @__PURE__ */ dual(2, (self, that) => isNone2(self) ? map2(that(), right) : map2(self, left));
var firstSomeOf = (collection) => {
  let out = none2();
  for (out of collection) {
    if (isSome2(out)) {
      return out;
    }
  }
  return out;
};
var fromNullable = (nullableValue) => nullableValue == null ? none2() : some2(nullableValue);
var liftNullable = (f) => (...a) => fromNullable(f(...a));
var getOrNull = /* @__PURE__ */ getOrElse3(constNull);
var getOrUndefined = /* @__PURE__ */ getOrElse3(constUndefined);
var liftThrowable = (f) => (...a) => {
  try {
    return some2(f(...a));
  } catch {
    return none2();
  }
};
var getOrThrowWith2 = /* @__PURE__ */ dual(2, (self, onNone) => {
  if (isSome2(self)) {
    return self.value;
  }
  throw onNone();
});
var getOrThrow2 = /* @__PURE__ */ getOrThrowWith2(() => new Error("getOrThrow called on a None"));
var map2 = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : some2(f(self.value)));
var as = /* @__PURE__ */ dual(2, (self, b) => map2(self, () => b));
var asVoid = /* @__PURE__ */ as(void 0);
var void_ = /* @__PURE__ */ some2(void 0);
var flatMap = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : f(self.value));
var andThen = /* @__PURE__ */ dual(2, (self, f) => flatMap(self, (a) => {
  const b = isFunction(f) ? f(a) : f;
  return isOption2(b) ? b : some2(b);
}));
var flatMapNullable = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : fromNullable(f(self.value)));
var flatten = /* @__PURE__ */ flatMap(identity);
var zipRight = /* @__PURE__ */ dual(2, (self, that) => flatMap(self, () => that));
var zipLeft = /* @__PURE__ */ dual(2, (self, that) => tap(self, () => that));
var composeK = /* @__PURE__ */ dual(2, (afb, bfc) => (a) => flatMap(afb(a), bfc));
var tap = /* @__PURE__ */ dual(2, (self, f) => flatMap(self, (a) => map2(f(a), () => a)));
var product = (self, that) => isSome2(self) && isSome2(that) ? some2([self.value, that.value]) : none2();
var productMany = (self, collection) => {
  if (isNone2(self)) {
    return none2();
  }
  const out = [self.value];
  for (const o of collection) {
    if (isNone2(o)) {
      return none2();
    }
    out.push(o.value);
  }
  return some2(out);
};
var all3 = (input) => {
  if (Symbol.iterator in input) {
    const out2 = [];
    for (const o of input) {
      if (isNone2(o)) {
        return none2();
      }
      out2.push(o.value);
    }
    return some2(out2);
  }
  const out = {};
  for (const key of Object.keys(input)) {
    const o = input[key];
    if (isNone2(o)) {
      return none2();
    }
    out[key] = o.value;
  }
  return some2(out);
};
var zipWith = /* @__PURE__ */ dual(3, (self, that, f) => map2(product(self, that), ([a, b]) => f(a, b)));
var ap = /* @__PURE__ */ dual(2, (self, that) => zipWith(self, that, (f, a) => f(a)));
var reduceCompact = /* @__PURE__ */ dual(3, (self, b, f) => {
  let out = b;
  for (const oa of self) {
    if (isSome2(oa)) {
      out = f(out, oa.value);
    }
  }
  return out;
});
var toArray = (self) => isNone2(self) ? [] : [self.value];
var partitionMap = /* @__PURE__ */ dual(2, (self, f) => {
  if (isNone2(self)) {
    return [none2(), none2()];
  }
  const e = f(self.value);
  return isLeft(e) ? [some2(e.left), none2()] : [none2(), some2(e.right)];
});
var filterMap = flatMap;
var filter = /* @__PURE__ */ dual(2, (self, predicate) => filterMap(self, (b) => predicate(b) ? some(b) : none));
var getEquivalence2 = (isEquivalent) => make3((x, y) => isNone2(x) ? isNone2(y) : isNone2(y) ? false : isEquivalent(x.value, y.value));
var getOrder = (O) => make4((self, that) => isSome2(self) ? isSome2(that) ? O(self.value, that.value) : 1 : -1);
var lift2 = (f) => dual(2, (self, that) => zipWith(self, that, f));
var liftPredicate = /* @__PURE__ */ dual(2, (b, predicate) => predicate(b) ? some2(b) : none2());
var containsWith = (isEquivalent) => dual(2, (self, a) => isNone2(self) ? false : isEquivalent(self.value, a));
var _equivalence = /* @__PURE__ */ equivalence();
var contains = /* @__PURE__ */ containsWith(_equivalence);
var exists = /* @__PURE__ */ dual(2, (self, refinement) => isNone2(self) ? false : refinement(self.value));
var bindTo2 = /* @__PURE__ */ bindTo(map2);
var let_2 = /* @__PURE__ */ let_(map2);
var bind2 = /* @__PURE__ */ bind(map2, flatMap);
var Do = /* @__PURE__ */ some2({});
var adapter2 = /* @__PURE__ */ adapter();
var gen = (...args2) => {
  const f = args2.length === 1 ? args2[0] : args2[1].bind(args2[0]);
  const iterator = f(adapter2);
  let state = iterator.next();
  while (!state.done) {
    const current2 = isGenKind(state.value) ? state.value.value : yieldWrapGet(state.value);
    if (isNone2(current2)) {
      return current2;
    }
    state = iterator.next(current2.value);
  }
  return some2(state.value);
};
var mergeWith = (f) => (o1, o2) => {
  if (isNone2(o1)) {
    return o2;
  } else if (isNone2(o2)) {
    return o1;
  }
  return some2(f(o1.value, o2.value));
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Tuple.js
var make5 = (...elements) => elements;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Iterable.js
var findFirst = /* @__PURE__ */ dual(2, (self, f) => {
  let i = 0;
  for (const a of self) {
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some2(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
    i++;
  }
  return none2();
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Record.js
var empty3 = () => ({});
var fromEntries = Object.fromEntries;
var has = /* @__PURE__ */ dual(2, (self, key) => Object.prototype.hasOwnProperty.call(self, key));
var filterMap2 = /* @__PURE__ */ dual(2, (self, f) => {
  const out = empty3();
  for (const key of keys(self)) {
    const o = f(self[key], key);
    if (isSome2(o)) {
      out[key] = o.value;
    }
  }
  return out;
});
var getSomes = /* @__PURE__ */ filterMap2(identity);
var keys = (self) => Object.keys(self);

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Array.js
var allocate = (n) => new Array(n);
var makeBy = /* @__PURE__ */ dual(2, (n, f) => {
  const max7 = Math.max(1, Math.floor(n));
  const out = new Array(max7);
  for (let i = 0; i < max7; i++) {
    out[i] = f(i);
  }
  return out;
});
var fromIterable2 = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
var ensure = (self) => Array.isArray(self) ? self : [self];
var match3 = /* @__PURE__ */ dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(self) : onEmpty());
var matchLeft = /* @__PURE__ */ dual(2, (self, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty());
var prepend = /* @__PURE__ */ dual(2, (self, head8) => [head8, ...self]);
var append = /* @__PURE__ */ dual(2, (self, last5) => [...self, last5]);
var appendAll = /* @__PURE__ */ dual(2, (self, that) => fromIterable2(self).concat(fromIterable2(that)));
var isArray = Array.isArray;
var isEmptyArray = (self) => self.length === 0;
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyArray2 = isNonEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var isOutOfBounds = (i, as13) => i < 0 || i >= as13.length;
var clamp2 = (i, as13) => Math.floor(Math.min(Math.max(0, i), as13.length));
var get3 = /* @__PURE__ */ dual(2, (self, index) => {
  const i = Math.floor(index);
  return isOutOfBounds(i, self) ? none2() : some2(self[i]);
});
var unsafeGet3 = /* @__PURE__ */ dual(2, (self, index) => {
  const i = Math.floor(index);
  if (isOutOfBounds(i, self)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self[i];
});
var head = /* @__PURE__ */ get3(0);
var headNonEmpty = /* @__PURE__ */ unsafeGet3(0);
var last = (self) => isNonEmptyReadonlyArray(self) ? some2(lastNonEmpty(self)) : none2();
var lastNonEmpty = (self) => self[self.length - 1];
var tailNonEmpty = (self) => self.slice(1);
var initNonEmpty = (self) => self.slice(0, -1);
var spanIndex = (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
};
var span = /* @__PURE__ */ dual(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));
var drop = /* @__PURE__ */ dual(2, (self, n) => {
  const input = fromIterable2(self);
  return input.slice(clamp2(n, input), input.length);
});
var findFirstIndex = /* @__PURE__ */ dual(2, (self, predicate) => {
  let i = 0;
  for (const a of self) {
    if (predicate(a, i)) {
      return some2(i);
    }
    i++;
  }
  return none2();
});
var findLastIndex = /* @__PURE__ */ dual(2, (self, predicate) => {
  const input = fromIterable2(self);
  for (let i = input.length - 1; i >= 0; i--) {
    if (predicate(input[i], i)) {
      return some2(i);
    }
  }
  return none2();
});
var findFirst2 = findFirst;
var findLast = /* @__PURE__ */ dual(2, (self, f) => {
  const input = fromIterable2(self);
  for (let i = input.length - 1; i >= 0; i--) {
    const a = input[i];
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some2(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
  }
  return none2();
});
var modify = /* @__PURE__ */ dual(3, (self, i, f) => {
  const out = Array.from(self);
  if (isOutOfBounds(i, out)) {
    return out;
  }
  const b = f(out[i]);
  out[i] = b;
  return out;
});
var remove = /* @__PURE__ */ dual(2, (self, i) => {
  const out = Array.from(self);
  if (isOutOfBounds(i, out)) {
    return out;
  }
  out.splice(i, 1);
  return out;
});
var reverse = (self) => Array.from(self).reverse();
var sort = /* @__PURE__ */ dual(2, (self, O) => {
  const out = Array.from(self);
  out.sort(O);
  return out;
});
var zip = /* @__PURE__ */ dual(2, (self, that) => zipWith2(self, that, make5));
var zipWith2 = /* @__PURE__ */ dual(3, (self, that, f) => {
  const as13 = fromIterable2(self);
  const bs = fromIterable2(that);
  if (isNonEmptyReadonlyArray(as13) && isNonEmptyReadonlyArray(bs)) {
    const out = [f(headNonEmpty(as13), headNonEmpty(bs))];
    const len = Math.min(as13.length, bs.length);
    for (let i = 1; i < len; i++) {
      out[i] = f(as13[i], bs[i]);
    }
    return out;
  }
  return [];
});
var unzip = (self) => {
  const input = fromIterable2(self);
  if (isNonEmptyReadonlyArray(input)) {
    const fa = [input[0][0]];
    const fb = [input[0][1]];
    for (let i = 1; i < input.length; i++) {
      fa[i] = input[i][0];
      fb[i] = input[i][1];
    }
    return [fa, fb];
  }
  return [[], []];
};
var modifyNonEmptyLast = /* @__PURE__ */ dual(2, (self, f) => append(initNonEmpty(self), f(lastNonEmpty(self))));
var containsWith2 = (isEquivalent) => dual(2, (self, a) => {
  for (const i of self) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
var _equivalence2 = /* @__PURE__ */ equivalence();
var contains2 = /* @__PURE__ */ containsWith2(_equivalence2);
var splitAt = /* @__PURE__ */ dual(2, (self, n) => {
  const input = Array.from(self);
  const _n = Math.floor(n);
  if (isNonEmptyReadonlyArray(input)) {
    if (_n >= 1) {
      return splitNonEmptyAt(input, _n);
    }
    return [[], input];
  }
  return [input, []];
});
var splitNonEmptyAt = /* @__PURE__ */ dual(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [copy(self), []] : [prepend(self.slice(1, _n), headNonEmpty(self)), self.slice(_n)];
});
var copy = (self) => self.slice();
var unionWith = /* @__PURE__ */ dual(3, (self, that, isEquivalent) => {
  const a = fromIterable2(self);
  const b = fromIterable2(that);
  if (isNonEmptyReadonlyArray(a)) {
    if (isNonEmptyReadonlyArray(b)) {
      const dedupe3 = dedupeWith(isEquivalent);
      return dedupe3(appendAll(a, b));
    }
    return a;
  }
  return b;
});
var union = /* @__PURE__ */ dual(2, (self, that) => unionWith(self, that, _equivalence2));
var intersectionWith = (isEquivalent) => {
  const has10 = containsWith2(isEquivalent);
  return dual(2, (self, that) => fromIterable2(self).filter((a) => has10(that, a)));
};
var intersection = /* @__PURE__ */ intersectionWith(_equivalence2);
var differenceWith = (isEquivalent) => {
  const has10 = containsWith2(isEquivalent);
  return dual(2, (self, that) => fromIterable2(self).filter((a) => !has10(that, a)));
};
var difference = /* @__PURE__ */ differenceWith(_equivalence2);
var empty4 = () => [];
var of = (a) => [a];
var map3 = /* @__PURE__ */ dual(2, (self, f) => self.map(f));
var flatMap2 = /* @__PURE__ */ dual(2, (self, f) => {
  if (isEmptyReadonlyArray(self)) {
    return [];
  }
  const out = [];
  for (let i = 0; i < self.length; i++) {
    const inner = f(self[i], i);
    for (let j = 0; j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
var flatten2 = /* @__PURE__ */ flatMap2(identity);
var filterMap3 = /* @__PURE__ */ dual(2, (self, f) => {
  const as13 = fromIterable2(self);
  const out = [];
  for (let i = 0; i < as13.length; i++) {
    const o = f(as13[i], i);
    if (isSome2(o)) {
      out.push(o.value);
    }
  }
  return out;
});
var filterMapWhile = /* @__PURE__ */ dual(2, (self, f) => {
  let i = 0;
  const out = [];
  for (const a of self) {
    const b = f(a, i);
    if (isSome2(b)) {
      out.push(b.value);
    } else {
      break;
    }
    i++;
  }
  return out;
});
var partitionMap2 = /* @__PURE__ */ dual(2, (self, f) => {
  const left3 = [];
  const right3 = [];
  const as13 = fromIterable2(self);
  for (let i = 0; i < as13.length; i++) {
    const e = f(as13[i], i);
    if (isLeft2(e)) {
      left3.push(e.left);
    } else {
      right3.push(e.right);
    }
  }
  return [left3, right3];
});
var getSomes2 = /* @__PURE__ */ filterMap3(identity);
var filter2 = /* @__PURE__ */ dual(2, (self, predicate) => {
  const as13 = fromIterable2(self);
  const out = [];
  for (let i = 0; i < as13.length; i++) {
    if (predicate(as13[i], i)) {
      out.push(as13[i]);
    }
  }
  return out;
});
var partition = /* @__PURE__ */ dual(2, (self, predicate) => {
  const left3 = [];
  const right3 = [];
  const as13 = fromIterable2(self);
  for (let i = 0; i < as13.length; i++) {
    if (predicate(as13[i], i)) {
      right3.push(as13[i]);
    } else {
      left3.push(as13[i]);
    }
  }
  return [left3, right3];
});
var separate = /* @__PURE__ */ partitionMap2(identity);
var reduce = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable2(self).reduce((b2, a, i) => f(b2, a, i), b));
var reduceRight = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable2(self).reduceRight((b2, a, i) => f(b2, a, i), b));
var every = /* @__PURE__ */ dual(2, (self, refinement) => self.every(refinement));
var unfold = (b, f) => {
  const out = [];
  let next4 = b;
  let o;
  while (isSome2(o = f(next4))) {
    const [a, b2] = o.value;
    out.push(a);
    next4 = b2;
  }
  return out;
};
var getEquivalence3 = array2;
var dedupeWith = /* @__PURE__ */ dual(2, (self, isEquivalent) => {
  const input = fromIterable2(self);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every((a) => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe = (self) => dedupeWith(self, equivalence());
var dedupeAdjacentWith = /* @__PURE__ */ dual(2, (self, isEquivalent) => {
  const out = [];
  let lastA = none2();
  for (const a of self) {
    if (isNone2(lastA) || !isEquivalent(a, lastA.value)) {
      out.push(a);
      lastA = some2(a);
    }
  }
  return out;
});
var dedupeAdjacent = /* @__PURE__ */ dedupeAdjacentWith(/* @__PURE__ */ equivalence());
var join = /* @__PURE__ */ dual(2, (self, sep) => fromIterable2(self).join(sep));
var mapAccum = /* @__PURE__ */ dual(3, (self, s, f) => {
  let i = 0;
  let s1 = s;
  const out = [];
  for (const a of self) {
    const r = f(s1, a, i);
    s1 = r[0];
    out.push(r[1]);
    i++;
  }
  return [s1, out];
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Chunk.js
var Chunk_exports = {};
__export(Chunk_exports, {
  append: () => append2,
  appendAll: () => appendAll2,
  chunksOf: () => chunksOf,
  compact: () => compact,
  contains: () => contains3,
  containsWith: () => containsWith3,
  dedupe: () => dedupe2,
  dedupeAdjacent: () => dedupeAdjacent2,
  difference: () => difference2,
  differenceWith: () => differenceWith2,
  drop: () => drop2,
  dropRight: () => dropRight,
  dropWhile: () => dropWhile,
  empty: () => empty5,
  every: () => every2,
  filter: () => filter3,
  filterMap: () => filterMap4,
  filterMapWhile: () => filterMapWhile2,
  findFirst: () => findFirst3,
  findFirstIndex: () => findFirstIndex2,
  findLast: () => findLast2,
  findLastIndex: () => findLastIndex2,
  flatMap: () => flatMap3,
  flatten: () => flatten3,
  forEach: () => forEach,
  fromIterable: () => fromIterable3,
  get: () => get4,
  getEquivalence: () => getEquivalence4,
  head: () => head2,
  headNonEmpty: () => headNonEmpty2,
  intersection: () => intersection2,
  isChunk: () => isChunk,
  isEmpty: () => isEmpty,
  isNonEmpty: () => isNonEmpty,
  join: () => join2,
  last: () => last2,
  lastNonEmpty: () => lastNonEmpty2,
  make: () => make6,
  makeBy: () => makeBy2,
  map: () => map4,
  mapAccum: () => mapAccum2,
  modify: () => modify2,
  modifyOption: () => modifyOption,
  of: () => of2,
  partition: () => partition2,
  partitionMap: () => partitionMap3,
  prepend: () => prepend2,
  prependAll: () => prependAll,
  range: () => range,
  reduce: () => reduce2,
  reduceRight: () => reduceRight2,
  remove: () => remove2,
  removeOption: () => removeOption,
  replace: () => replace,
  replaceOption: () => replaceOption,
  reverse: () => reverse2,
  separate: () => separate2,
  size: () => size,
  some: () => some3,
  sort: () => sort2,
  sortWith: () => sortWith,
  split: () => split,
  splitAt: () => splitAt2,
  splitNonEmptyAt: () => splitNonEmptyAt2,
  splitWhere: () => splitWhere,
  tail: () => tail,
  tailNonEmpty: () => tailNonEmpty2,
  take: () => take,
  takeRight: () => takeRight,
  takeWhile: () => takeWhile,
  toArray: () => toArray2,
  toReadonlyArray: () => toReadonlyArray,
  union: () => union2,
  unsafeFromArray: () => unsafeFromArray,
  unsafeFromNonEmptyArray: () => unsafeFromNonEmptyArray,
  unsafeGet: () => unsafeGet4,
  unsafeHead: () => unsafeHead,
  unsafeLast: () => unsafeLast,
  unzip: () => unzip2,
  zip: () => zip2,
  zipWith: () => zipWith3
});
var TypeId5 = /* @__PURE__ */ Symbol.for("effect/Chunk");
function copy2(src, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
var emptyArray = [];
var getEquivalence4 = (isEquivalent) => make3((self, that) => self.length === that.length && toReadonlyArray(self).every((value3, i) => isEquivalent(value3, unsafeGet4(that, i))));
var _equivalence3 = /* @__PURE__ */ getEquivalence4(equals);
var ChunkProto = {
  [TypeId5]: {
    _A: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isChunk(that) && _equivalence3(this, that);
  },
  [symbol]() {
    return cached(this, array(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeChunk = (backing) => {
  const chunk4 = Object.create(ChunkProto);
  chunk4.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk4.length = 0;
      chunk4.depth = 0;
      chunk4.left = chunk4;
      chunk4.right = chunk4;
      break;
    }
    case "IConcat": {
      chunk4.length = backing.left.length + backing.right.length;
      chunk4.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk4.left = backing.left;
      chunk4.right = backing.right;
      break;
    }
    case "IArray": {
      chunk4.length = backing.array.length;
      chunk4.depth = 0;
      chunk4.left = _empty2;
      chunk4.right = _empty2;
      break;
    }
    case "ISingleton": {
      chunk4.length = 1;
      chunk4.depth = 0;
      chunk4.left = _empty2;
      chunk4.right = _empty2;
      break;
    }
    case "ISlice": {
      chunk4.length = backing.length;
      chunk4.depth = backing.chunk.depth + 1;
      chunk4.left = _empty2;
      chunk4.right = _empty2;
      break;
    }
  }
  return chunk4;
};
var isChunk = (u) => hasProperty(u, TypeId5);
var _empty2 = /* @__PURE__ */ makeChunk({
  _tag: "IEmpty"
});
var empty5 = () => _empty2;
var make6 = (...as13) => unsafeFromNonEmptyArray(as13);
var of2 = (a) => makeChunk({
  _tag: "ISingleton",
  a
});
var fromIterable3 = (self) => isChunk(self) ? self : unsafeFromArray(fromIterable2(self));
var copyToArray = (self, array6, initial) => {
  switch (self.backing._tag) {
    case "IArray": {
      copy2(self.backing.array, 0, array6, initial, self.length);
      break;
    }
    case "IConcat": {
      copyToArray(self.left, array6, initial);
      copyToArray(self.right, array6, initial + self.left.length);
      break;
    }
    case "ISingleton": {
      array6[initial] = self.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j = initial;
      while (i < self.length) {
        array6[j] = unsafeGet4(self, i);
        i += 1;
        j += 1;
      }
      break;
    }
  }
};
var toArray_ = (self) => toReadonlyArray(self).slice();
var toArray2 = toArray_;
var toReadonlyArray_ = (self) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self.backing.array;
    }
    default: {
      const arr = new Array(self.length);
      copyToArray(self, arr, 0);
      self.backing = {
        _tag: "IArray",
        array: arr
      };
      self.left = _empty2;
      self.right = _empty2;
      self.depth = 0;
      return arr;
    }
  }
};
var toReadonlyArray = toReadonlyArray_;
var reverseChunk = (self) => {
  switch (self.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse(self.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse2(self.backing.right),
        right: reverse2(self.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse(toReadonlyArray(self)));
  }
};
var reverse2 = reverseChunk;
var get4 = /* @__PURE__ */ dual(2, (self, index) => index < 0 || index >= self.length ? none2() : some2(unsafeGet4(self, index)));
var unsafeFromArray = (self) => self.length === 0 ? empty5() : self.length === 1 ? of2(self[0]) : makeChunk({
  _tag: "IArray",
  array: self
});
var unsafeFromNonEmptyArray = (self) => unsafeFromArray(self);
var unsafeGet4 = /* @__PURE__ */ dual(2, (self, index) => {
  switch (self.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.a;
    }
    case "IArray": {
      if (index >= self.length || index < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self.backing.array[index];
    }
    case "IConcat": {
      return index < self.left.length ? unsafeGet4(self.left, index) : unsafeGet4(self.right, index - self.left.length);
    }
    case "ISlice": {
      return unsafeGet4(self.backing.chunk, index + self.backing.offset);
    }
  }
});
var append2 = /* @__PURE__ */ dual(2, (self, a) => appendAll2(self, of2(a)));
var prepend2 = /* @__PURE__ */ dual(2, (self, elem) => appendAll2(of2(elem), self));
var take = /* @__PURE__ */ dual(2, (self, n) => {
  if (n <= 0) {
    return _empty2;
  } else if (n >= self.length) {
    return self;
  } else {
    switch (self.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self.backing.chunk,
          length: n,
          offset: self.backing.offset
        });
      }
      case "IConcat": {
        if (n > self.left.length) {
          return makeChunk({
            _tag: "IConcat",
            left: self.left,
            right: take(self.right, n - self.left.length)
          });
        }
        return take(self.left, n);
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self,
          offset: 0,
          length: n
        });
      }
    }
  }
});
var drop2 = /* @__PURE__ */ dual(2, (self, n) => {
  if (n <= 0) {
    return self;
  } else if (n >= self.length) {
    return _empty2;
  } else {
    switch (self.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self.backing.chunk,
          offset: self.backing.offset + n,
          length: self.backing.length - n
        });
      }
      case "IConcat": {
        if (n > self.left.length) {
          return drop2(self.right, n - self.left.length);
        }
        return makeChunk({
          _tag: "IConcat",
          left: drop2(self.left, n),
          right: self.right
        });
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self,
          offset: n,
          length: self.length - n
        });
      }
    }
  }
});
var dropRight = /* @__PURE__ */ dual(2, (self, n) => take(self, Math.max(0, self.length - n)));
var dropWhile = /* @__PURE__ */ dual(2, (self, predicate) => {
  const arr = toReadonlyArray(self);
  const len = arr.length;
  let i = 0;
  while (i < len && predicate(arr[i])) {
    i++;
  }
  return drop2(self, i);
});
var prependAll = /* @__PURE__ */ dual(2, (self, that) => appendAll2(that, self));
var appendAll2 = /* @__PURE__ */ dual(2, (self, that) => {
  if (self.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self;
  }
  const diff8 = that.depth - self.depth;
  if (Math.abs(diff8) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self,
      right: that
    });
  } else if (diff8 < -1) {
    if (self.left.depth >= self.right.depth) {
      const nr = appendAll2(self.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self.left,
        right: nr
      });
    } else {
      const nrr = appendAll2(self.right.right, that);
      if (nrr.depth === self.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: self.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll2(self, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll2(self, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var filterMap4 = /* @__PURE__ */ dual(2, (self, f) => unsafeFromArray(filterMap3(self, f)));
var filter3 = /* @__PURE__ */ dual(2, (self, predicate) => unsafeFromArray(filter2(self, predicate)));
var filterMapWhile2 = /* @__PURE__ */ dual(2, (self, f) => unsafeFromArray(filterMapWhile(self, f)));
var compact = (self) => filterMap4(self, identity);
var flatMap3 = /* @__PURE__ */ dual(2, (self, f) => {
  if (self.backing._tag === "ISingleton") {
    return f(self.backing.a, 0);
  }
  let out = _empty2;
  let i = 0;
  for (const k of self) {
    out = appendAll2(out, f(k, i++));
  }
  return out;
});
var forEach = /* @__PURE__ */ dual(2, (self, f) => toReadonlyArray(self).forEach(f));
var flatten3 = /* @__PURE__ */ flatMap3(identity);
var chunksOf = /* @__PURE__ */ dual(2, (self, n) => {
  const gr = [];
  let current2 = [];
  toReadonlyArray(self).forEach((a) => {
    current2.push(a);
    if (current2.length >= n) {
      gr.push(unsafeFromArray(current2));
      current2 = [];
    }
  });
  if (current2.length > 0) {
    gr.push(unsafeFromArray(current2));
  }
  return unsafeFromArray(gr);
});
var intersection2 = /* @__PURE__ */ dual(2, (self, that) => unsafeFromArray(intersection(toReadonlyArray(self), toReadonlyArray(that))));
var isEmpty = (self) => self.length === 0;
var isNonEmpty = (self) => self.length > 0;
var head2 = /* @__PURE__ */ get4(0);
var unsafeHead = (self) => unsafeGet4(self, 0);
var headNonEmpty2 = unsafeHead;
var last2 = (self) => get4(self, self.length - 1);
var unsafeLast = (self) => unsafeGet4(self, self.length - 1);
var lastNonEmpty2 = unsafeLast;
var map4 = /* @__PURE__ */ dual(2, (self, f) => self.backing._tag === "ISingleton" ? of2(f(self.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self), map3((a, i) => f(a, i)))));
var mapAccum2 = /* @__PURE__ */ dual(3, (self, s, f) => {
  const [s1, as13] = mapAccum(self, s, f);
  return [s1, unsafeFromArray(as13)];
});
var partition2 = /* @__PURE__ */ dual(2, (self, predicate) => pipe(partition(toReadonlyArray(self), predicate), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));
var partitionMap3 = /* @__PURE__ */ dual(2, (self, f) => pipe(partitionMap2(toReadonlyArray(self), f), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));
var separate2 = (self) => pipe(separate(toReadonlyArray(self)), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]);
var size = (self) => self.length;
var sort2 = /* @__PURE__ */ dual(2, (self, O) => unsafeFromArray(sort(toReadonlyArray(self), O)));
var sortWith = /* @__PURE__ */ dual(3, (self, f, order) => sort2(self, mapInput2(order, f)));
var splitAt2 = /* @__PURE__ */ dual(2, (self, n) => [take(self, n), drop2(self, n)]);
var splitNonEmptyAt2 = /* @__PURE__ */ dual(2, (self, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self.length ? [self, empty5()] : [take(self, _n), drop2(self, _n)];
});
var split = /* @__PURE__ */ dual(2, (self, n) => chunksOf(self, Math.ceil(self.length / Math.floor(n))));
var splitWhere = /* @__PURE__ */ dual(2, (self, predicate) => {
  let i = 0;
  for (const a of toReadonlyArray(self)) {
    if (predicate(a)) {
      break;
    } else {
      i++;
    }
  }
  return splitAt2(self, i);
});
var tail = (self) => self.length > 0 ? some2(drop2(self, 1)) : none2();
var tailNonEmpty2 = (self) => drop2(self, 1);
var takeRight = /* @__PURE__ */ dual(2, (self, n) => drop2(self, self.length - n));
var takeWhile = /* @__PURE__ */ dual(2, (self, predicate) => {
  const out = [];
  for (const a of toReadonlyArray(self)) {
    if (predicate(a)) {
      out.push(a);
    } else {
      break;
    }
  }
  return unsafeFromArray(out);
});
var union2 = /* @__PURE__ */ dual(2, (self, that) => unsafeFromArray(union(toReadonlyArray(self), toReadonlyArray(that))));
var dedupe2 = (self) => unsafeFromArray(dedupe(toReadonlyArray(self)));
var dedupeAdjacent2 = (self) => unsafeFromArray(dedupeAdjacent(self));
var unzip2 = (self) => {
  const [left3, right3] = unzip(self);
  return [unsafeFromArray(left3), unsafeFromArray(right3)];
};
var zipWith3 = /* @__PURE__ */ dual(3, (self, that, f) => unsafeFromArray(zipWith2(self, that, f)));
var zip2 = /* @__PURE__ */ dual(2, (self, that) => zipWith3(self, that, (a, b) => [a, b]));
var remove2 = /* @__PURE__ */ dual(2, (self, i) => {
  if (i < 0 || i >= self.length) return self;
  return unsafeFromArray(remove(toReadonlyArray(self), i));
});
var removeOption = /* @__PURE__ */ dual(2, (self, i) => {
  if (i < 0 || i >= self.length) return none2();
  return some2(unsafeFromArray(remove(toReadonlyArray(self), i)));
});
var modifyOption = /* @__PURE__ */ dual(3, (self, i, f) => {
  if (i < 0 || i >= self.length) return none2();
  return some2(unsafeFromArray(modify(toReadonlyArray(self), i, f)));
});
var modify2 = /* @__PURE__ */ dual(3, (self, i, f) => getOrElse3(modifyOption(self, i, f), () => self));
var replace = /* @__PURE__ */ dual(3, (self, i, b) => modify2(self, i, () => b));
var replaceOption = /* @__PURE__ */ dual(3, (self, i, b) => modifyOption(self, i, () => b));
var makeBy2 = /* @__PURE__ */ dual(2, (n, f) => fromIterable3(makeBy(n, f)));
var range = (start5, end6) => start5 <= end6 ? makeBy2(end6 - start5 + 1, (i) => start5 + i) : of2(start5);
var contains3 = contains2;
var containsWith3 = containsWith2;
var findFirst3 = findFirst2;
var findFirstIndex2 = findFirstIndex;
var findLast2 = findLast;
var findLastIndex2 = findLastIndex;
var every2 = /* @__PURE__ */ dual(2, (self, refinement) => fromIterable2(self).every(refinement));
var some3 = /* @__PURE__ */ dual(2, (self, predicate) => fromIterable2(self).some(predicate));
var join2 = join;
var reduce2 = reduce;
var reduceRight2 = reduceRight;
var differenceWith2 = (isEquivalent) => {
  return dual(2, (self, that) => unsafeFromArray(differenceWith(isEquivalent)(that, self)));
};
var difference2 = /* @__PURE__ */ dual(2, (self, that) => unsafeFromArray(difference(that, self)));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE = 5;
var BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
var MASK = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function hashFragment(shift2, h) {
  return h >>> shift2 & MASK;
}
function toBitmap(x) {
  return 1 << x;
}
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stack.js
var make7 = (value3, previous2) => ({
  value: value3,
  previous: previous2
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate(mutate5, at, v, arr) {
  let out = arr;
  if (!mutate5) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0; i < len; ++i) out[i] = arr[i];
  }
  out[at] = v;
  return out;
}
function arraySpliceOut(mutate5, at, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate5) {
    i = g = at;
  } else {
    out = new Array(newLen);
    while (i < at) out[g++] = arr[i++];
  }
  ;
  ++i;
  while (i <= newLen) out[g++] = arr[i++];
  if (mutate5) {
    out.length = newLen;
  }
  return out;
}
function arraySpliceIn(mutate5, at, v, arr) {
  const len = arr.length;
  if (mutate5) {
    let i2 = len;
    while (i2 >= at) arr[i2--] = arr[i2];
    arr[at] = v;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at) out[g++] = arr[i++];
  out[at] = v;
  while (i < len) out[++g] = arr[i++];
  return out;
}

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/hashMap/node.js
var EmptyNode = class _EmptyNode {
  constructor() {
    __publicField(this, "_tag", "EmptyNode");
  }
  modify(edit, _shift, f, hash4, key, size17) {
    const v = f(none2());
    if (isNone2(v)) return new _EmptyNode();
    ++size17.value;
    return new LeafNode(edit, hash4, key, v);
  }
};
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
var LeafNode = class _LeafNode {
  constructor(edit, hash4, key, value3) {
    __publicField(this, "edit");
    __publicField(this, "hash");
    __publicField(this, "key");
    __publicField(this, "value");
    __publicField(this, "_tag", "LeafNode");
    this.edit = edit;
    this.hash = hash4;
    this.key = key;
    this.value = value3;
  }
  modify(edit, shift2, f, hash4, key, size17) {
    if (equals(key, this.key)) {
      const v2 = f(this.value);
      if (v2 === this.value) return this;
      else if (isNone2(v2)) {
        ;
        --size17.value;
        return new EmptyNode();
      }
      if (canEditNode(this, edit)) {
        this.value = v2;
        return this;
      }
      return new _LeafNode(edit, hash4, key, v2);
    }
    const v = f(none2());
    if (isNone2(v)) return this;
    ++size17.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash4, new _LeafNode(edit, hash4, key, v));
  }
};
var CollisionNode = class _CollisionNode {
  constructor(edit, hash4, children3) {
    __publicField(this, "edit");
    __publicField(this, "hash");
    __publicField(this, "children");
    __publicField(this, "_tag", "CollisionNode");
    this.edit = edit;
    this.hash = hash4;
    this.children = children3;
  }
  modify(edit, shift2, f, hash4, key, size17) {
    if (hash4 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size17);
      if (list === this.children) return this;
      return list.length > 1 ? new _CollisionNode(edit, this.hash, list) : list[0];
    }
    const v = f(none2());
    if (isNone2(v)) return this;
    ++size17.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash4, new LeafNode(edit, hash4, key, v));
  }
  updateCollisionList(mutate5, edit, hash4, list, f, key, size17) {
    const len = list.length;
    for (let i = 0; i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals(key, child.key)) {
        const value3 = child.value;
        const newValue2 = f(value3);
        if (newValue2 === value3) return list;
        if (isNone2(newValue2)) {
          ;
          --size17.value;
          return arraySpliceOut(mutate5, i, list);
        }
        return arrayUpdate(mutate5, i, new LeafNode(edit, hash4, key, newValue2), list);
      }
    }
    const newValue = f(none2());
    if (isNone2(newValue)) return list;
    ++size17.value;
    return arrayUpdate(mutate5, len, new LeafNode(edit, hash4, key, newValue), list);
  }
};
var IndexedNode = class _IndexedNode {
  constructor(edit, mask, children3) {
    __publicField(this, "edit");
    __publicField(this, "mask");
    __publicField(this, "children");
    __publicField(this, "_tag", "IndexedNode");
    this.edit = edit;
    this.mask = mask;
    this.children = children3;
  }
  modify(edit, shift2, f, hash4, key, size17) {
    const mask = this.mask;
    const children3 = this.children;
    const frag = hashFragment(shift2, hash4);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists6 = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists6) {
      const _newChild = new EmptyNode().modify(edit, shift2 + SIZE, f, hash4, key, size17);
      if (!_newChild) return this;
      return children3.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children3) : new _IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children3));
    }
    const current2 = children3[indx];
    const child = current2.modify(edit, shift2 + SIZE, f, hash4, key, size17);
    if (current2 === child) return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap) return new EmptyNode();
      if (children3.length <= 2 && isLeafNode(children3[indx ^ 1])) {
        return children3[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children3);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children3);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new _IndexedNode(edit, bitmap, newChildren);
  }
};
var ArrayNode = class _ArrayNode {
  constructor(edit, size17, children3) {
    __publicField(this, "edit");
    __publicField(this, "size");
    __publicField(this, "children");
    __publicField(this, "_tag", "ArrayNode");
    this.edit = edit;
    this.size = size17;
    this.children = children3;
  }
  modify(edit, shift2, f, hash4, key, size17) {
    let count4 = this.size;
    const children3 = this.children;
    const frag = hashFragment(shift2, hash4);
    const child = children3[frag];
    const newChild = (child || new EmptyNode()).modify(edit, shift2 + SIZE, f, hash4, key, size17);
    if (child === newChild) return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ;
      ++count4;
      newChildren = arrayUpdate(canEdit, frag, newChild, children3);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      ;
      --count4;
      if (count4 <= MIN_ARRAY_NODE) {
        return pack(edit, count4, frag, children3);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children3);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children3);
    }
    if (canEdit) {
      this.size = count4;
      this.children = newChildren;
      return this;
    }
    return new _ArrayNode(edit, count4, newChildren);
  }
};
function pack(edit, count4, removed, elements) {
  const children3 = new Array(count4 - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children3[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children3);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count4 = 0;
  for (let i = 0; bit; ++i) {
    if (bit & 1) arr[i] = subNodes[count4++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count4 + 1, arr);
}
function mergeLeavesInner(edit, shift2, h1, n1, h2, n2) {
  if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift2, h1);
  const subH2 = hashFragment(shift2, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children3 = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children3);
  }
}
function mergeLeaves(edit, shift2, h1, n1, h2, n2) {
  let stack = void 0;
  let currentShift = shift2;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = make7(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap";
var HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
var HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v) => [k, v]);
  },
  [symbol]() {
    let hash4 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash4 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash4);
  },
  [symbol2](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone2(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl = (editable, edit, root, size17) => {
  const map31 = Object.create(HashMapProto);
  map31._editable = editable;
  map31._edit = edit;
  map31._root = root;
  map31._size = size17;
  return map31;
};
var HashMapIterator = class _HashMapIterator {
  constructor(map31, f) {
    __publicField(this, "map");
    __publicField(this, "f");
    __publicField(this, "v");
    this.map = map31;
    this.f = f;
    this.v = visitLazy(this.map._root, this.f, void 0);
  }
  next() {
    if (isNone2(this.v)) {
      return {
        done: true,
        value: void 0
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new _HashMapIterator(this.map, this.f);
  }
};
var applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2();
var visitLazy = (node, f, cont = void 0) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome2(node.value)) {
        return some2({
          value: f(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children3 = node.children;
      return visitLazyChildren(children3.length, children3, 0, f, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
};
var visitLazyChildren = (len, children3, i, f, cont) => {
  while (i < len) {
    const child = children3[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f, [len, children3, i, f, cont]);
    }
  }
  return applyCont(cont);
};
var _empty3 = /* @__PURE__ */ makeImpl(false, 0, /* @__PURE__ */ new EmptyNode(), 0);
var empty6 = () => _empty3;
var make8 = (...entries3) => fromIterable4(entries3);
var fromIterable4 = (entries3) => {
  const map31 = beginMutation(empty6());
  for (const entry of entries3) {
    set(map31, entry[0], entry[1]);
  }
  return endMutation(map31);
};
var isHashMap = (u) => hasProperty(u, HashMapTypeId);
var isEmpty2 = (self) => self && isEmptyNode(self._root);
var get5 = /* @__PURE__ */ dual(2, (self, key) => getHash(self, key, hash(key)));
var getHash = /* @__PURE__ */ dual(3, (self, key, hash4) => {
  let node = self._root;
  let shift2 = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none2();
      }
      case "CollisionNode": {
        if (hash4 === node.hash) {
          const children3 = node.children;
          for (let i = 0, len = children3.length; i < len; ++i) {
            const child = children3[i];
            if ("key" in child && equals(key, child.key)) {
              return child.value;
            }
          }
        }
        return none2();
      }
      case "IndexedNode": {
        const frag = hashFragment(shift2, hash4);
        const bit = toBitmap(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap(node.mask, bit)];
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift2, hash4)];
        if (node) {
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      default:
        return none2();
    }
  }
});
var unsafeGet5 = /* @__PURE__ */ dual(2, (self, key) => {
  const element3 = getHash(self, key, hash(key));
  if (isNone2(element3)) {
    throw new Error("Expected map to contain key");
  }
  return element3.value;
});
var has2 = /* @__PURE__ */ dual(2, (self, key) => isSome2(getHash(self, key, hash(key))));
var hasHash = /* @__PURE__ */ dual(3, (self, key, hash4) => isSome2(getHash(self, key, hash4)));
var hasBy = /* @__PURE__ */ dual(2, (self, predicate) => isSome2(findFirst4(self, predicate)));
var set = /* @__PURE__ */ dual(3, (self, key, value3) => modifyAt(self, key, () => some2(value3)));
var setTree = /* @__PURE__ */ dual(3, (self, newRoot, newSize) => {
  if (self._editable) {
    ;
    self._root = newRoot;
    self._size = newSize;
    return self;
  }
  return newRoot === self._root ? self : makeImpl(self._editable, self._edit, newRoot, newSize);
});
var keys2 = (self) => new HashMapIterator(self, (key) => key);
var values = (self) => new HashMapIterator(self, (_, value3) => value3);
var entries = (self) => new HashMapIterator(self, (key, value3) => [key, value3]);
var size2 = (self) => self._size;
var beginMutation = (self) => makeImpl(true, self._edit + 1, self._root, self._size);
var endMutation = (self) => {
  ;
  self._editable = false;
  return self;
};
var mutate = /* @__PURE__ */ dual(2, (self, f) => {
  const transient = beginMutation(self);
  f(transient);
  return endMutation(transient);
});
var modifyAt = /* @__PURE__ */ dual(3, (self, key, f) => modifyHash(self, key, hash(key), f));
var modifyHash = /* @__PURE__ */ dual(4, (self, key, hash4, f) => {
  const size17 = {
    value: self._size
  };
  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash4, key, size17);
  return pipe(self, setTree(newRoot, size17.value));
});
var modify3 = /* @__PURE__ */ dual(3, (self, key, f) => modifyAt(self, key, map2(f)));
var union3 = /* @__PURE__ */ dual(2, (self, that) => {
  const result = beginMutation(self);
  forEach2(that, (v, k) => set(result, k, v));
  return endMutation(result);
});
var remove3 = /* @__PURE__ */ dual(2, (self, key) => modifyAt(self, key, none2));
var removeMany = /* @__PURE__ */ dual(2, (self, keys6) => mutate(self, (map31) => {
  for (const key of keys6) {
    remove3(key)(map31);
  }
}));
var map5 = /* @__PURE__ */ dual(2, (self, f) => reduce3(self, empty6(), (map31, value3, key) => set(map31, key, f(value3, key))));
var flatMap4 = /* @__PURE__ */ dual(2, (self, f) => reduce3(self, empty6(), (zero3, value3, key) => mutate(zero3, (map31) => forEach2(f(value3, key), (value4, key2) => set(map31, key2, value4)))));
var forEach2 = /* @__PURE__ */ dual(2, (self, f) => reduce3(self, void 0, (_, value3, key) => f(value3, key)));
var reduce3 = /* @__PURE__ */ dual(3, (self, zero3, f) => {
  const root = self._root;
  if (root._tag === "LeafNode") {
    return isSome2(root.value) ? f(zero3, root.value.value, root.key) : zero3;
  }
  if (root._tag === "EmptyNode") {
    return zero3;
  }
  const toVisit = [root.children];
  let children3;
  while (children3 = toVisit.pop()) {
    for (let i = 0, len = children3.length; i < len; ) {
      const child = children3[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome2(child.value)) {
            zero3 = f(zero3, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero3;
});
var filter4 = /* @__PURE__ */ dual(2, (self, f) => mutate(empty6(), (map31) => {
  for (const [k, a] of self) {
    if (f(a, k)) {
      set(map31, k, a);
    }
  }
}));
var compact2 = (self) => filterMap5(self, identity);
var filterMap5 = /* @__PURE__ */ dual(2, (self, f) => mutate(empty6(), (map31) => {
  for (const [k, a] of self) {
    const option5 = f(a, k);
    if (isSome2(option5)) {
      set(map31, k, option5.value);
    }
  }
}));
var findFirst4 = /* @__PURE__ */ dual(2, (self, predicate) => {
  for (const ka of self) {
    if (predicate(ka[1], ka[0])) {
      return some2(ka);
    }
  }
  return none2();
});
var some4 = /* @__PURE__ */ dual(2, (self, predicate) => {
  for (const ka of self) {
    if (predicate(ka[1], ka[0])) {
      return true;
    }
  }
  return false;
});
var every3 = /* @__PURE__ */ dual(2, (self, predicate) => !some4(self, (a, k) => !predicate(a, k)));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet";
var HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
var HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys2(this._keyMap);
  },
  [symbol]() {
    return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol2](that) {
    if (isHashSet(that)) {
      return size2(this._keyMap) === size2(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = (keyMap) => {
  const set10 = Object.create(HashSetProto);
  set10._keyMap = keyMap;
  return set10;
};
var isHashSet = (u) => hasProperty(u, HashSetTypeId);
var _empty4 = /* @__PURE__ */ makeImpl2(/* @__PURE__ */ empty6());
var empty7 = () => _empty4;
var fromIterable5 = (elements) => {
  const set10 = beginMutation2(empty7());
  for (const value3 of elements) {
    add3(set10, value3);
  }
  return endMutation2(set10);
};
var make9 = (...elements) => {
  const set10 = beginMutation2(empty7());
  for (const value3 of elements) {
    add3(set10, value3);
  }
  return endMutation2(set10);
};
var has3 = /* @__PURE__ */ dual(2, (self, value3) => has2(self._keyMap, value3));
var some5 = /* @__PURE__ */ dual(2, (self, f) => {
  let found = false;
  for (const value3 of self) {
    found = f(value3);
    if (found) {
      break;
    }
  }
  return found;
});
var every4 = /* @__PURE__ */ dual(2, (self, refinement) => !some5(self, (a) => !refinement(a)));
var size3 = (self) => size2(self._keyMap);
var beginMutation2 = (self) => makeImpl2(beginMutation(self._keyMap));
var endMutation2 = (self) => {
  ;
  self._keyMap._editable = false;
  return self;
};
var mutate2 = /* @__PURE__ */ dual(2, (self, f) => {
  const transient = beginMutation2(self);
  f(transient);
  return endMutation2(transient);
});
var add3 = /* @__PURE__ */ dual(2, (self, value3) => self._keyMap._editable ? (set(value3, true)(self._keyMap), self) : makeImpl2(set(value3, true)(self._keyMap)));
var remove4 = /* @__PURE__ */ dual(2, (self, value3) => self._keyMap._editable ? (remove3(value3)(self._keyMap), self) : makeImpl2(remove3(value3)(self._keyMap)));
var difference3 = /* @__PURE__ */ dual(2, (self, that) => mutate2(self, (set10) => {
  for (const value3 of that) {
    remove4(set10, value3);
  }
}));
var union4 = /* @__PURE__ */ dual(2, (self, that) => mutate2(empty7(), (set10) => {
  forEach3(self, (value3) => add3(set10, value3));
  for (const value3 of that) {
    add3(set10, value3);
  }
}));
var forEach3 = /* @__PURE__ */ dual(2, (self, f) => forEach2(self._keyMap, (_, k) => f(k)));
var reduce4 = /* @__PURE__ */ dual(3, (self, zero3, f) => reduce3(self._keyMap, zero3, (z, _, a) => f(z, a)));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/HashSet.js
var isHashSet2 = isHashSet;
var empty8 = empty7;
var fromIterable6 = fromIterable5;
var make10 = make9;
var has4 = has3;
var every5 = every4;
var size4 = size3;
var add4 = add3;
var remove5 = remove4;
var difference4 = difference3;
var union5 = union4;
var forEach4 = forEach3;
var reduce5 = reduce4;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE = "Die";
var OP_EMPTY = "Empty";
var OP_FAIL = "Fail";
var OP_INTERRUPT = "Interrupt";
var OP_PARALLEL = "Parallel";
var OP_SEQUENTIAL = "Sequential";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause";
var CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
var variance = {
  /* c8 ignore next */
  _E: (_) => _
};
var proto = {
  [CauseTypeId]: variance,
  [symbol]() {
    return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
  },
  [symbol2](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var empty9 = /* @__PURE__ */ (() => {
  const o = /* @__PURE__ */ Object.create(proto);
  o._tag = OP_EMPTY;
  return o;
})();
var fail = (error2) => {
  const o = Object.create(proto);
  o._tag = OP_FAIL;
  o.error = error2;
  return o;
};
var die = (defect) => {
  const o = Object.create(proto);
  o._tag = OP_DIE;
  o.defect = defect;
  return o;
};
var interrupt = (fiberId3) => {
  const o = Object.create(proto);
  o._tag = OP_INTERRUPT;
  o.fiberId = fiberId3;
  return o;
};
var parallel = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_PARALLEL;
  o.left = left3;
  o.right = right3;
  return o;
};
var sequential = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_SEQUENTIAL;
  o.left = left3;
  o.right = right3;
  return o;
};
var isCause = (u) => hasProperty(u, CauseTypeId);
var isEmptyType = (self) => self._tag === OP_EMPTY;
var isFailType = (self) => self._tag === OP_FAIL;
var isDieType = (self) => self._tag === OP_DIE;
var isEmpty3 = (self) => {
  if (self._tag === OP_EMPTY) {
    return true;
  }
  return reduce6(self, true, (acc, cause3) => {
    switch (cause3._tag) {
      case OP_EMPTY: {
        return some2(acc);
      }
      case OP_DIE:
      case OP_FAIL:
      case OP_INTERRUPT: {
        return some2(false);
      }
      default: {
        return none2();
      }
    }
  });
};
var isInterrupted = (self) => isSome2(interruptOption(self));
var isInterruptedOnly = (self) => reduceWithContext(void 0, IsInterruptedOnlyCauseReducer)(self);
var failures = (self) => reverse2(reduce6(self, empty5(), (list, cause3) => cause3._tag === OP_FAIL ? some2(pipe(list, prepend2(cause3.error))) : none2()));
var defects = (self) => reverse2(reduce6(self, empty5(), (list, cause3) => cause3._tag === OP_DIE ? some2(pipe(list, prepend2(cause3.defect))) : none2()));
var interruptors = (self) => reduce6(self, empty8(), (set10, cause3) => cause3._tag === OP_INTERRUPT ? some2(pipe(set10, add4(cause3.fiberId))) : none2());
var failureOption = (self) => find(self, (cause3) => cause3._tag === OP_FAIL ? some2(cause3.error) : none2());
var failureOrCause = (self) => {
  const option5 = failureOption(self);
  switch (option5._tag) {
    case "None": {
      return right2(self);
    }
    case "Some": {
      return left2(option5.value);
    }
  }
};
var flipCauseOption = (self) => match4(self, {
  onEmpty: some2(empty9),
  onFail: map2(fail),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: (fiberId3) => some2(interrupt(fiberId3)),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var interruptOption = (self) => find(self, (cause3) => cause3._tag === OP_INTERRUPT ? some2(cause3.fiberId) : none2());
var keepDefects = (self) => match4(self, {
  onEmpty: none2(),
  onFail: () => none2(),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var keepDefectsAndElectFailures = (self) => match4(self, {
  onEmpty: none2(),
  onFail: (failure) => some2(die(failure)),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var stripFailures = (self) => match4(self, {
  onEmpty: empty9,
  onFail: () => empty9,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var electFailures = (self) => match4(self, {
  onEmpty: empty9,
  onFail: die,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var map8 = /* @__PURE__ */ dual(2, (self, f) => flatMap7(self, (e) => fail(f(e))));
var flatMap7 = /* @__PURE__ */ dual(2, (self, f) => match4(self, {
  onEmpty: empty9,
  onFail: (error2) => f(error2),
  onDie: (defect) => die(defect),
  onInterrupt: (fiberId3) => interrupt(fiberId3),
  onSequential: (left3, right3) => sequential(left3, right3),
  onParallel: (left3, right3) => parallel(left3, right3)
}));
var flatten4 = (self) => flatMap7(self, identity);
var causeEquals = (left3, right3) => {
  let leftStack = of2(left3);
  let rightStack = of2(right3);
  while (isNonEmpty(leftStack) && isNonEmpty(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce6([empty8(), empty5()], ([parallel5, sequential5], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return some2([pipe(parallel5, union5(par2)), pipe(sequential5, appendAll2(seq2))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce6([empty8(), empty5()], ([parallel5, sequential5], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return some2([pipe(parallel5, union5(par2)), pipe(sequential5, appendAll2(seq2))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
};
var flattenCause = (cause3) => {
  return flattenCauseLoop(of2(cause3), empty5());
};
var flattenCauseLoop = (causes, flattened) => {
  while (1) {
    const [parallel5, sequential5] = pipe(causes, reduce([empty8(), empty5()], ([parallel6, sequential6], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return [pipe(parallel6, union5(par2)), pipe(sequential6, appendAll2(seq2))];
    }));
    const updated = size4(parallel5) > 0 ? pipe(flattened, prepend2(parallel5)) : flattened;
    if (isEmpty(sequential5)) {
      return reverse2(updated);
    }
    causes = sequential5;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
var find = /* @__PURE__ */ dual(2, (self, pf) => {
  const stack = [self];
  while (stack.length > 0) {
    const item = stack.pop();
    const option5 = pf(item);
    switch (option5._tag) {
      case "None": {
        switch (item._tag) {
          case OP_SEQUENTIAL:
          case OP_PARALLEL: {
            stack.push(item.right);
            stack.push(item.left);
            break;
          }
        }
        break;
      }
      case "Some": {
        return option5;
      }
    }
  }
  return none2();
});
var evaluateCause = (self) => {
  let cause3 = self;
  const stack = [];
  let _parallel = empty8();
  let _sequential = empty5();
  while (cause3 !== void 0) {
    switch (cause3._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add4(_parallel, make6(cause3._tag, cause3.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add4(_parallel, make6(cause3._tag, cause3.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add4(_parallel, make6(cause3._tag, cause3.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause3.left._tag) {
          case OP_EMPTY: {
            cause3 = cause3.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause3 = sequential(cause3.left.left, sequential(cause3.left.right, cause3.right));
            break;
          }
          case OP_PARALLEL: {
            cause3 = parallel(sequential(cause3.left.left, cause3.right), sequential(cause3.left.right, cause3.right));
            break;
          }
          default: {
            _sequential = prepend2(_sequential, cause3.right);
            cause3 = cause3.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
var IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: (_, left3, right3) => left3 && right3,
  parallelCase: (_, left3, right3) => left3 && right3
};
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
var match4 = /* @__PURE__ */ dual(2, (self, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt: onInterrupt3,
  onParallel,
  onSequential
}) => {
  return reduceWithContext(self, void 0, {
    emptyCase: () => onEmpty,
    failCase: (_, error2) => onFail(error2),
    dieCase: (_, defect) => onDie(defect),
    interruptCase: (_, fiberId3) => onInterrupt3(fiberId3),
    sequentialCase: (_, left3, right3) => onSequential(left3, right3),
    parallelCase: (_, left3, right3) => onParallel(left3, right3)
  });
});
var reduce6 = /* @__PURE__ */ dual(3, (self, zero3, pf) => {
  let accumulator = zero3;
  let cause3 = self;
  const causes = [];
  while (cause3 !== void 0) {
    const option5 = pf(accumulator, cause3);
    accumulator = isSome2(option5) ? option5.value : accumulator;
    switch (cause3._tag) {
      case OP_SEQUENTIAL: {
        causes.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
      case OP_PARALLEL: {
        causes.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
      default: {
        cause3 = void 0;
        break;
      }
    }
    if (cause3 === void 0 && causes.length > 0) {
      cause3 = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext = /* @__PURE__ */ dual(3, (self, context9, reducer) => {
  const input = [self];
  const output3 = [];
  while (input.length > 0) {
    const cause3 = input.pop();
    switch (cause3._tag) {
      case OP_EMPTY: {
        output3.push(right2(reducer.emptyCase(context9)));
        break;
      }
      case OP_FAIL: {
        output3.push(right2(reducer.failCase(context9, cause3.error)));
        break;
      }
      case OP_DIE: {
        output3.push(right2(reducer.dieCase(context9, cause3.defect)));
        break;
      }
      case OP_INTERRUPT: {
        output3.push(right2(reducer.interruptCase(context9, cause3.fiberId)));
        break;
      }
      case OP_SEQUENTIAL: {
        input.push(cause3.right);
        input.push(cause3.left);
        output3.push(left2({
          _tag: OP_SEQUENTIAL_CASE
        }));
        break;
      }
      case OP_PARALLEL: {
        input.push(cause3.right);
        input.push(cause3.left);
        output3.push(left2({
          _tag: OP_PARALLEL_CASE
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output3.length > 0) {
    const either8 = output3.pop();
    switch (either8._tag) {
      case "Left": {
        switch (either8.left._tag) {
          case OP_SEQUENTIAL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value3 = reducer.sequentialCase(context9, left3, right3);
            accumulator.push(value3);
            break;
          }
          case OP_PARALLEL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value3 = reducer.parallelCase(context9, left3, right3);
            accumulator.push(value3);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either8.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var pretty = (cause3, options) => {
  if (isInterruptedOnly(cause3)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause3).map(function(e) {
    if (options?.renderErrorCause !== true || e.cause === void 0) {
      return e.stack;
    }
    return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
  }).join("\n");
};
var renderErrorCause = (cause3, prefix) => {
  const lines3 = cause3.stack.split("\n");
  let stack = `${prefix}[cause]: ${lines3[0]}`;
  for (let i = 1, len = lines3.length; i < len; i++) {
    stack += `
${prefix}${lines3[i]}`;
  }
  if (cause3.cause) {
    stack += ` {
${renderErrorCause(cause3.cause, `${prefix}  `)}
${prefix}}`;
  }
  return stack;
};
var PrettyError = class _PrettyError extends globalThis.Error {
  constructor(originalError) {
    const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
      cause: new _PrettyError(originalError.cause)
    } : void 0);
    __publicField(this, "span");
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError instanceof Error ? originalError.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol in originalError) {
        this.span = originalError[spanSymbol];
      }
      Object.keys(originalError).forEach((key) => {
        if (!(key in this)) {
          this[key] = originalError[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
  }
};
var prettyErrorMessage = (u) => {
  if (typeof u === "string") {
    return u;
  }
  if (typeof u === "object" && u !== null && u instanceof Error) {
    return u.message;
  }
  try {
    if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {
  }
  return stringifyCircular(u);
};
var locationRegex = /\((.*)\)/g;
var spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => /* @__PURE__ */ new WeakMap());
var prettyErrorStack = (message, stack, span4) => {
  const out = [message];
  const lines3 = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
  for (let i = 1; i < lines3.length; i++) {
    if (lines3[i].includes(" at new BaseEffectError") || lines3[i].includes(" at new YieldableError")) {
      i++;
      continue;
    }
    if (lines3[i].includes("Generator.next")) {
      break;
    }
    if (lines3[i].includes("effect_internal_function")) {
      break;
    }
    out.push(lines3[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span4) {
    let current2 = span4;
    let i = 0;
    while (current2 && current2._tag === "Span" && i < 10) {
      const stackFn = spanToTrace.get(current2);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex);
          let match21 = false;
          for (const [, location] of locationMatchAll) {
            match21 = true;
            out.push(`    at ${current2.name} (${location})`);
          }
          if (!match21) {
            out.push(`    at ${current2.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out.push(`    at ${current2.name}`);
        }
      } else {
        out.push(`    at ${current2.name}`);
      }
      current2 = getOrUndefined(current2.parent);
      i++;
    }
  }
  return out.join("\n");
};
var spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
var prettyErrors = (cause3) => reduceWithContext(cause3, void 0, {
  emptyCase: () => [],
  dieCase: (_, unknownError) => {
    return [new PrettyError(unknownError)];
  },
  failCase: (_, error2) => {
    return [new PrettyError(error2)];
  },
  interruptCase: () => [],
  parallelCase: (_, l, r) => [...l, ...r],
  sequentialCase: (_, l, r) => [...l, ...r]
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Duration.js
var Duration_exports = {};
__export(Duration_exports, {
  Equivalence: () => Equivalence,
  Order: () => Order,
  between: () => between2,
  clamp: () => clamp3,
  days: () => days,
  decode: () => decode,
  decodeUnknown: () => decodeUnknown,
  divide: () => divide,
  equals: () => equals2,
  format: () => format2,
  formatIso: () => formatIso,
  fromIso: () => fromIso,
  greaterThan: () => greaterThan2,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo2,
  hours: () => hours,
  infinity: () => infinity,
  isDuration: () => isDuration,
  isFinite: () => isFinite,
  isZero: () => isZero,
  lessThan: () => lessThan2,
  lessThanOrEqualTo: () => lessThanOrEqualTo2,
  match: () => match5,
  matchWith: () => matchWith,
  max: () => max2,
  micros: () => micros,
  millis: () => millis,
  min: () => min2,
  minutes: () => minutes,
  nanos: () => nanos,
  parts: () => parts,
  seconds: () => seconds,
  subtract: () => subtract,
  sum: () => sum,
  times: () => times,
  toDays: () => toDays,
  toHours: () => toHours,
  toHrTime: () => toHrTime,
  toMillis: () => toMillis,
  toMinutes: () => toMinutes,
  toNanos: () => toNanos,
  toSeconds: () => toSeconds,
  toWeeks: () => toWeeks,
  unsafeDivide: () => unsafeDivide,
  unsafeFormatIso: () => unsafeFormatIso,
  unsafeToNanos: () => unsafeToNanos,
  weeks: () => weeks,
  zero: () => zero
});
var TypeId6 = /* @__PURE__ */ Symbol.for("effect/Duration");
var bigint0 = /* @__PURE__ */ BigInt(0);
var bigint24 = /* @__PURE__ */ BigInt(24);
var bigint60 = /* @__PURE__ */ BigInt(60);
var bigint1e3 = /* @__PURE__ */ BigInt(1e3);
var bigint1e6 = /* @__PURE__ */ BigInt(1e6);
var bigint1e9 = /* @__PURE__ */ BigInt(1e9);
var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
var decode = (input) => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return millis(input);
  } else if (isBigInt(input)) {
    return nanos(input);
  } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
      return zero;
    }
    if (input[0] === Infinity || input[1] === Infinity) {
      return infinity;
    }
    return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
  } else if (isString(input)) {
    const match21 = DURATION_REGEX.exec(input);
    if (match21) {
      const [_, valueStr, unit] = match21;
      const value3 = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value3);
        case "second":
        case "seconds":
          return seconds(value3);
        case "minute":
        case "minutes":
          return minutes(value3);
        case "hour":
        case "hours":
          return hours(value3);
        case "day":
        case "days":
          return days(value3);
        case "week":
        case "weeks":
          return weeks(value3);
      }
    }
  }
  throw new Error("Invalid DurationInput");
};
var decodeUnknown = /* @__PURE__ */ liftThrowable(decode);
var zeroValue = {
  _tag: "Millis",
  millis: 0
};
var infinityValue = {
  _tag: "Infinity"
};
var DurationProto = {
  [TypeId6]: TypeId6,
  [symbol]() {
    return cached(this, structure(this.value));
  },
  [symbol2](that) {
    return isDuration(that) && equals2(this, that);
  },
  toString() {
    return `Duration(${format2(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make11 = (input) => {
  const duration4 = Object.create(DurationProto);
  if (isNumber(input)) {
    if (isNaN(input) || input <= 0) {
      duration4.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration4.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration4.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1e6))
      };
    } else {
      duration4.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint0) {
    duration4.value = zeroValue;
  } else {
    duration4.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration4;
};
var isDuration = (u) => hasProperty(u, TypeId6);
var isFinite = (self) => self.value._tag !== "Infinity";
var isZero = (self) => {
  switch (self.value._tag) {
    case "Millis": {
      return self.value.millis === 0;
    }
    case "Nanos": {
      return self.value.nanos === bigint0;
    }
    case "Infinity": {
      return false;
    }
  }
};
var zero = /* @__PURE__ */ make11(0);
var infinity = /* @__PURE__ */ make11(Infinity);
var nanos = (nanos2) => make11(nanos2);
var micros = (micros2) => make11(micros2 * bigint1e3);
var millis = (millis2) => make11(millis2);
var seconds = (seconds2) => make11(seconds2 * 1e3);
var minutes = (minutes2) => make11(minutes2 * 6e4);
var hours = (hours2) => make11(hours2 * 36e5);
var days = (days2) => make11(days2 * 864e5);
var weeks = (weeks2) => make11(weeks2 * 6048e5);
var toMillis = (self) => match5(self, {
  onMillis: (millis2) => millis2,
  onNanos: (nanos2) => Number(nanos2) / 1e6
});
var toSeconds = (self) => match5(self, {
  onMillis: (millis2) => millis2 / 1e3,
  onNanos: (nanos2) => Number(nanos2) / 1e9
});
var toMinutes = (self) => match5(self, {
  onMillis: (millis2) => millis2 / 6e4,
  onNanos: (nanos2) => Number(nanos2) / 6e10
});
var toHours = (self) => match5(self, {
  onMillis: (millis2) => millis2 / 36e5,
  onNanos: (nanos2) => Number(nanos2) / 36e11
});
var toDays = (self) => match5(self, {
  onMillis: (millis2) => millis2 / 864e5,
  onNanos: (nanos2) => Number(nanos2) / 864e11
});
var toWeeks = (self) => match5(self, {
  onMillis: (millis2) => millis2 / 6048e5,
  onNanos: (nanos2) => Number(nanos2) / 6048e11
});
var toNanos = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return none2();
    case "Nanos":
      return some2(_self.value.nanos);
    case "Millis":
      return some2(BigInt(Math.round(_self.value.millis * 1e6)));
  }
};
var unsafeToNanos = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1e6));
  }
};
var toHrTime = (self) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1e3), Math.round(_self.value.millis % 1e3 * 1e6)];
  }
};
var match5 = /* @__PURE__ */ dual(2, (self, options) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Nanos":
      return options.onNanos(_self.value.nanos);
    case "Infinity":
      return options.onMillis(Infinity);
    case "Millis":
      return options.onMillis(_self.value.millis);
  }
});
var matchWith = /* @__PURE__ */ dual(3, (self, that, options) => {
  const _self = decode(self);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
var Order = /* @__PURE__ */ make4((self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 < that2 ? -1 : self2 > that2 ? 1 : 0,
  onNanos: (self2, that2) => self2 < that2 ? -1 : self2 > that2 ? 1 : 0
}));
var between2 = /* @__PURE__ */ between(/* @__PURE__ */ mapInput2(Order, decode));
var Equivalence = (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 === that2,
  onNanos: (self2, that2) => self2 === that2
});
var _min = /* @__PURE__ */ min(Order);
var min2 = /* @__PURE__ */ dual(2, (self, that) => _min(decode(self), decode(that)));
var _max = /* @__PURE__ */ max(Order);
var max2 = /* @__PURE__ */ dual(2, (self, that) => _max(decode(self), decode(that)));
var _clamp = /* @__PURE__ */ clamp(Order);
var clamp3 = /* @__PURE__ */ dual(2, (self, options) => _clamp(decode(self), {
  minimum: decode(options.minimum),
  maximum: decode(options.maximum)
}));
var divide = /* @__PURE__ */ dual(2, (self, by) => match5(self, {
  onMillis: (millis2) => {
    if (by === 0 || isNaN(by) || !Number.isFinite(by)) {
      return none2();
    }
    return some2(make11(millis2 / by));
  },
  onNanos: (nanos2) => {
    if (isNaN(by) || by <= 0 || !Number.isFinite(by)) {
      return none2();
    }
    try {
      return some2(make11(nanos2 / BigInt(by)));
    } catch {
      return none2();
    }
  }
}));
var unsafeDivide = /* @__PURE__ */ dual(2, (self, by) => match5(self, {
  onMillis: (millis2) => make11(millis2 / by),
  onNanos: (nanos2) => {
    if (isNaN(by) || by < 0 || Object.is(by, -0)) {
      return zero;
    } else if (Object.is(by, 0) || !Number.isFinite(by)) {
      return infinity;
    }
    return make11(nanos2 / BigInt(by));
  }
}));
var times = /* @__PURE__ */ dual(2, (self, times2) => match5(self, {
  onMillis: (millis2) => make11(millis2 * times2),
  onNanos: (nanos2) => make11(nanos2 * BigInt(times2))
}));
var subtract = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => make11(self2 - that2),
  onNanos: (self2, that2) => make11(self2 - that2)
}));
var sum = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => make11(self2 + that2),
  onNanos: (self2, that2) => make11(self2 + that2)
}));
var lessThan2 = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 < that2,
  onNanos: (self2, that2) => self2 < that2
}));
var lessThanOrEqualTo2 = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 <= that2,
  onNanos: (self2, that2) => self2 <= that2
}));
var greaterThan2 = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 > that2,
  onNanos: (self2, that2) => self2 > that2
}));
var greaterThanOrEqualTo2 = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
  onMillis: (self2, that2) => self2 >= that2,
  onNanos: (self2, that2) => self2 >= that2
}));
var equals2 = /* @__PURE__ */ dual(2, (self, that) => Equivalence(decode(self), decode(that)));
var parts = (self) => {
  const duration4 = decode(self);
  if (duration4.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos2 = unsafeToNanos(duration4);
  const ms = nanos2 / bigint1e6;
  const sec = ms / bigint1e3;
  const min5 = sec / bigint60;
  const hr = min5 / bigint60;
  const days2 = hr / bigint24;
  return {
    days: Number(days2),
    hours: Number(hr % bigint24),
    minutes: Number(min5 % bigint60),
    seconds: Number(sec % bigint60),
    millis: Number(ms % bigint1e3),
    nanos: Number(nanos2 % bigint1e6)
  };
};
var format2 = (self) => {
  const duration4 = decode(self);
  if (duration4.value._tag === "Infinity") {
    return "Infinity";
  }
  if (isZero(duration4)) {
    return "0";
  }
  const fragments = parts(duration4);
  const pieces = [];
  if (fragments.days !== 0) {
    pieces.push(`${fragments.days}d`);
  }
  if (fragments.hours !== 0) {
    pieces.push(`${fragments.hours}h`);
  }
  if (fragments.minutes !== 0) {
    pieces.push(`${fragments.minutes}m`);
  }
  if (fragments.seconds !== 0) {
    pieces.push(`${fragments.seconds}s`);
  }
  if (fragments.millis !== 0) {
    pieces.push(`${fragments.millis}ms`);
  }
  if (fragments.nanos !== 0) {
    pieces.push(`${fragments.nanos}ns`);
  }
  return pieces.join(" ");
};
var unsafeFormatIso = (self) => {
  const duration4 = decode(self);
  if (!isFinite(duration4)) {
    throw new RangeError("Cannot format infinite duration");
  }
  const fragments = [];
  const {
    days: days2,
    hours: hours2,
    millis: millis2,
    minutes: minutes2,
    nanos: nanos2,
    seconds: seconds2
  } = parts(duration4);
  let rest = days2;
  if (rest >= 365) {
    const years = Math.floor(rest / 365);
    rest %= 365;
    fragments.push(`${years}Y`);
  }
  if (rest >= 30) {
    const months = Math.floor(rest / 30);
    rest %= 30;
    fragments.push(`${months}M`);
  }
  if (rest >= 7) {
    const weeks2 = Math.floor(rest / 7);
    rest %= 7;
    fragments.push(`${weeks2}W`);
  }
  if (rest > 0) {
    fragments.push(`${rest}D`);
  }
  if (hours2 !== 0 || minutes2 !== 0 || seconds2 !== 0 || millis2 !== 0 || nanos2 !== 0) {
    fragments.push("T");
    if (hours2 !== 0) {
      fragments.push(`${hours2}H`);
    }
    if (minutes2 !== 0) {
      fragments.push(`${minutes2}M`);
    }
    if (seconds2 !== 0 || millis2 !== 0 || nanos2 !== 0) {
      const total = BigInt(seconds2) * bigint1e9 + BigInt(millis2) * bigint1e6 + BigInt(nanos2);
      const str = (Number(total) / 1e9).toFixed(9).replace(/\.?0+$/, "");
      fragments.push(`${str}S`);
    }
  }
  return `P${fragments.join("") || "T0S"}`;
};
var formatIso = (self) => {
  const duration4 = decode(self);
  return isFinite(duration4) ? some2(unsafeFormatIso(duration4)) : none2();
};
var fromIso = (iso) => {
  const result = DURATION_ISO_REGEX.exec(iso);
  if (result == null) {
    return none2();
  }
  const [years, months, weeks2, days2, hours2, mins, secs] = result.slice(1, 8).map((_) => _ ? Number(_) : 0);
  const value3 = years * 365 * 24 * 60 * 60 + months * 30 * 24 * 60 * 60 + weeks2 * 7 * 24 * 60 * 60 + days2 * 24 * 60 * 60 + hours2 * 60 * 60 + mins * 60 + secs;
  return some2(seconds(value3));
};
var DURATION_ISO_REGEX = /^P(?!$)(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?(?:T(?!$)(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/MutableRef.js
var TypeId7 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
var MutableRefProto = {
  [TypeId7]: TypeId7,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON(this.current)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make12 = (value3) => {
  const ref = Object.create(MutableRefProto);
  ref.current = value3;
  return ref;
};
var compareAndSet = /* @__PURE__ */ dual(3, (self, oldValue, newValue) => {
  if (equals(oldValue, self.current)) {
    self.current = newValue;
    return true;
  }
  return false;
});
var get6 = (self) => self.current;
var set2 = /* @__PURE__ */ dual(2, (self, value3) => {
  self.current = value3;
  return self;
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey = "effect/FiberId";
var FiberIdTypeId = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
var OP_NONE = "None";
var OP_RUNTIME = "Runtime";
var OP_COMPOSITE = "Composite";
var emptyHash = /* @__PURE__ */ string(`${FiberIdSymbolKey}-${OP_NONE}`);
var _a2;
var None = class {
  constructor() {
    __publicField(this, _a2, FiberIdTypeId);
    __publicField(this, "_tag", OP_NONE);
    __publicField(this, "id", -1);
    __publicField(this, "startTimeMillis", -1);
  }
  [(_a2 = FiberIdTypeId, symbol)]() {
    return emptyHash;
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_NONE;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var _a3;
var Runtime = class {
  constructor(id3, startTimeMillis) {
    __publicField(this, "id");
    __publicField(this, "startTimeMillis");
    __publicField(this, _a3, FiberIdTypeId);
    __publicField(this, "_tag", OP_RUNTIME);
    this.id = id3;
    this.startTimeMillis = startTimeMillis;
  }
  [(_a3 = FiberIdTypeId, symbol)]() {
    return cached(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var _a4;
var Composite = class {
  constructor(left3, right3) {
    __publicField(this, "left");
    __publicField(this, "right");
    __publicField(this, _a4, FiberIdTypeId);
    __publicField(this, "_tag", OP_COMPOSITE);
    __publicField(this, "_hash");
    this.left = left3;
    this.right = right3;
  }
  [(_a4 = FiberIdTypeId, symbol)]() {
    return pipe(string(`${FiberIdSymbolKey}-${this._tag}`), combine(hash(this.left)), combine(hash(this.right)), cached(this));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON(this.left),
      right: toJSON(this.right)
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var none3 = /* @__PURE__ */ new None();
var runtime = (id3, startTimeMillis) => {
  return new Runtime(id3, startTimeMillis);
};
var composite = (left3, right3) => {
  return new Composite(left3, right3);
};
var isFiberId = (self) => hasProperty(self, FiberIdTypeId);
var isNone3 = (self) => {
  return self._tag === OP_NONE || pipe(toSet(self), every5((id3) => isNone3(id3)));
};
var combine2 = /* @__PURE__ */ dual(2, (self, that) => {
  if (self._tag === OP_NONE) {
    return that;
  }
  if (that._tag === OP_NONE) {
    return self;
  }
  return new Composite(self, that);
});
var combineAll = (fiberIds) => {
  return pipe(fiberIds, reduce5(none3, (a, b) => combine2(b)(a)));
};
var getOrElse4 = /* @__PURE__ */ dual(2, (self, that) => isNone3(self) ? that : self);
var ids = (self) => {
  switch (self._tag) {
    case OP_NONE: {
      return empty8();
    }
    case OP_RUNTIME: {
      return make10(self.id);
    }
    case OP_COMPOSITE: {
      return pipe(ids(self.left), union5(ids(self.right)));
    }
  }
};
var _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make12(0));
var threadName = (self) => {
  const identifiers = Array.from(ids(self)).map((n) => `#${n}`).join(",");
  return identifiers;
};
var toSet = (self) => {
  switch (self._tag) {
    case OP_NONE: {
      return empty8();
    }
    case OP_RUNTIME: {
      return make10(self);
    }
    case OP_COMPOSITE: {
      return pipe(toSet(self.left), union5(toSet(self.right)));
    }
  }
};
var unsafeMake2 = () => {
  const id3 = get6(_fiberCounter);
  pipe(_fiberCounter, set2(id3 + 1));
  return new Runtime(id3, Date.now());
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/FiberId.js
var none4 = none3;
var runtime2 = runtime;
var composite2 = composite;
var isFiberId2 = isFiberId;
var combine3 = combine2;
var combineAll2 = combineAll;
var getOrElse5 = getOrElse4;
var ids2 = ids;
var threadName2 = threadName;
var unsafeMake3 = unsafeMake2;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/HashMap.js
var HashMap_exports = {};
__export(HashMap_exports, {
  beginMutation: () => beginMutation3,
  compact: () => compact3,
  empty: () => empty10,
  endMutation: () => endMutation3,
  entries: () => entries2,
  every: () => every6,
  filter: () => filter6,
  filterMap: () => filterMap6,
  findFirst: () => findFirst5,
  flatMap: () => flatMap8,
  forEach: () => forEach5,
  fromIterable: () => fromIterable7,
  get: () => get7,
  getHash: () => getHash2,
  has: () => has5,
  hasBy: () => hasBy2,
  hasHash: () => hasHash2,
  isEmpty: () => isEmpty4,
  isHashMap: () => isHashMap2,
  keySet: () => keySet2,
  keys: () => keys3,
  make: () => make14,
  map: () => map9,
  modify: () => modify4,
  modifyAt: () => modifyAt2,
  modifyHash: () => modifyHash2,
  mutate: () => mutate3,
  reduce: () => reduce7,
  remove: () => remove6,
  removeMany: () => removeMany2,
  set: () => set3,
  size: () => size5,
  some: () => some6,
  toEntries: () => toEntries,
  toValues: () => toValues,
  union: () => union6,
  unsafeGet: () => unsafeGet6,
  values: () => values3
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/hashMap/keySet.js
function keySet(self) {
  return makeImpl2(self);
}

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/HashMap.js
var isHashMap2 = isHashMap;
var empty10 = empty6;
var make14 = make8;
var fromIterable7 = fromIterable4;
var isEmpty4 = isEmpty2;
var get7 = get5;
var getHash2 = getHash;
var unsafeGet6 = unsafeGet5;
var has5 = has2;
var hasHash2 = hasHash;
var hasBy2 = hasBy;
var set3 = set;
var keys3 = keys2;
var keySet2 = keySet;
var values3 = values;
var toValues = (self) => Array.from(values3(self));
var entries2 = entries;
var toEntries = (self) => Array.from(entries2(self));
var size5 = size2;
var beginMutation3 = beginMutation;
var endMutation3 = endMutation;
var mutate3 = mutate;
var modifyAt2 = modifyAt;
var modifyHash2 = modifyHash;
var modify4 = modify3;
var union6 = union3;
var remove6 = remove3;
var removeMany2 = removeMany;
var map9 = map5;
var flatMap8 = flatMap4;
var forEach5 = forEach2;
var reduce7 = reduce3;
var filter6 = filter4;
var compact3 = compact2;
var filterMap6 = filterMap5;
var findFirst5 = findFirst4;
var some6 = some4;
var every6 = every3;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/List.js
var TypeId8 = /* @__PURE__ */ Symbol.for("effect/List");
var toArray3 = (self) => fromIterable2(self);
var getEquivalence5 = (isEquivalent) => mapInput(getEquivalence3(isEquivalent), toArray3);
var _equivalence4 = /* @__PURE__ */ getEquivalence5(equals);
var ConsProto = {
  [TypeId8]: TypeId8,
  _tag: "Cons",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: toArray3(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag && _equivalence4(this, that);
  },
  [symbol]() {
    return cached(this, array(toArray3(this)));
  },
  [Symbol.iterator]() {
    let done12 = false;
    let self = this;
    return {
      next() {
        if (done12) {
          return this.return();
        }
        if (self._tag === "Nil") {
          done12 = true;
          return this.return();
        }
        const value3 = self.head;
        self = self.tail;
        return {
          done: done12,
          value: value3
        };
      },
      return(value3) {
        if (!done12) {
          done12 = true;
        }
        return {
          done: true,
          value: value3
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeCons = (head8, tail2) => {
  const cons2 = Object.create(ConsProto);
  cons2.head = head8;
  cons2.tail = tail2;
  return cons2;
};
var NilHash = /* @__PURE__ */ string("Nil");
var NilProto = {
  [TypeId8]: TypeId8,
  _tag: "Nil",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol]() {
    return NilHash;
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: void 0
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _Nil = /* @__PURE__ */ Object.create(NilProto);
var isList = (u) => hasProperty(u, TypeId8);
var isNil = (self) => self._tag === "Nil";
var isCons = (self) => self._tag === "Cons";
var nil = () => _Nil;
var cons = (head8, tail2) => makeCons(head8, tail2);
var empty11 = nil;
var of3 = (value3) => makeCons(value3, _Nil);
var fromIterable8 = (prefix) => {
  const iterator = prefix[Symbol.iterator]();
  let next4;
  if ((next4 = iterator.next()) && !next4.done) {
    const result = makeCons(next4.value, _Nil);
    let curr = result;
    while ((next4 = iterator.next()) && !next4.done) {
      const temp = makeCons(next4.value, _Nil);
      curr.tail = temp;
      curr = temp;
    }
    return result;
  } else {
    return _Nil;
  }
};
var appendAll3 = /* @__PURE__ */ dual(2, (self, that) => prependAll2(that, self));
var prepend3 = /* @__PURE__ */ dual(2, (self, element3) => cons(element3, self));
var prependAll2 = /* @__PURE__ */ dual(2, (self, prefix) => {
  if (isNil(self)) {
    return prefix;
  } else if (isNil(prefix)) {
    return self;
  } else {
    const result = makeCons(prefix.head, self);
    let curr = result;
    let that = prefix.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
var reduce8 = /* @__PURE__ */ dual(3, (self, zero3, f) => {
  let acc = zero3;
  let these = self;
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reverse3 = (self) => {
  let result = empty11();
  let these = self;
  while (!isNil(these)) {
    result = prepend3(result, these.head);
    these = these.tail;
  }
  return result;
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/data.js
var ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
  [symbol]() {
    return cached(this, array(this));
  },
  [symbol2](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v, i) => equals(v, that[i]));
    } else {
      return false;
    }
  }
});
var Structural = /* @__PURE__ */ function() {
  function Structural3(args2) {
    if (args2) {
      Object.assign(this, args2);
    }
  }
  Structural3.prototype = StructuralPrototype;
  return Structural3;
}();
var struct = (as13) => Object.assign(Object.create(StructuralPrototype), as13);

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/differ/contextPatch.js
var ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
function variance2(a) {
  return a;
}
var PatchProto = {
  ...Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: variance2,
    _Patch: variance2
  }
};
var EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "Empty"
});
var _empty5 = /* @__PURE__ */ Object.create(EmptyProto);
var empty12 = () => _empty5;
var AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "AndThen"
});
var makeAndThen = (first2, second) => {
  const o = Object.create(AndThenProto);
  o.first = first2;
  o.second = second;
  return o;
};
var AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "AddService"
});
var makeAddService = (key, service3) => {
  const o = Object.create(AddServiceProto);
  o.key = key;
  o.service = service3;
  return o;
};
var RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "RemoveService"
});
var makeRemoveService = (key) => {
  const o = Object.create(RemoveServiceProto);
  o.key = key;
  return o;
};
var UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "UpdateService"
});
var makeUpdateService = (key, update5) => {
  const o = Object.create(UpdateServiceProto);
  o.key = key;
  o.update = update5;
  return o;
};
var diff = (oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch9 = empty12();
  for (const [tag3, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag3)) {
      const old = missingServices.get(tag3);
      missingServices.delete(tag3);
      if (!equals(old, newService)) {
        patch9 = combine4(makeUpdateService(tag3, () => newService))(patch9);
      }
    } else {
      missingServices.delete(tag3);
      patch9 = combine4(makeAddService(tag3, newService))(patch9);
    }
  }
  for (const [tag3] of missingServices.entries()) {
    patch9 = combine4(makeRemoveService(tag3))(patch9);
  }
  return patch9;
};
var combine4 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen(self, that));
var patch = /* @__PURE__ */ dual(2, (self, context9) => {
  if (self._tag === "Empty") {
    return context9;
  }
  let wasServiceUpdated = false;
  let patches = of2(self);
  const updatedContext = new Map(context9.unsafeMap);
  while (isNonEmpty(patches)) {
    const head8 = headNonEmpty2(patches);
    const tail2 = tailNonEmpty2(patches);
    switch (head8._tag) {
      case "Empty": {
        patches = tail2;
        break;
      }
      case "AddService": {
        updatedContext.set(head8.key, head8.service);
        patches = tail2;
        break;
      }
      case "AndThen": {
        patches = prepend2(prepend2(tail2, head8.second), head8.first);
        break;
      }
      case "RemoveService": {
        updatedContext.delete(head8.key);
        patches = tail2;
        break;
      }
      case "UpdateService": {
        updatedContext.set(head8.key, head8.update(updatedContext.get(head8.key)));
        wasServiceUpdated = true;
        patches = tail2;
        break;
      }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext(updatedContext);
  }
  const map31 = /* @__PURE__ */ new Map();
  for (const [tag3] of context9.unsafeMap) {
    if (updatedContext.has(tag3)) {
      map31.set(tag3, updatedContext.get(tag3));
      updatedContext.delete(tag3);
    }
  }
  for (const [tag3, s] of updatedContext) {
    map31.set(tag3, s);
  }
  return makeContext(map31);
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
var HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
function variance3(a) {
  return a;
}
var PatchProto2 = {
  ...Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: variance3,
    _Key: variance3,
    _Patch: variance3
  }
};
var EmptyProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Empty"
});
var _empty6 = /* @__PURE__ */ Object.create(EmptyProto2);
var empty13 = () => _empty6;
var AndThenProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "AndThen"
});
var makeAndThen2 = (first2, second) => {
  const o = Object.create(AndThenProto2);
  o.first = first2;
  o.second = second;
  return o;
};
var AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Add"
});
var makeAdd = (value3) => {
  const o = Object.create(AddProto);
  o.value = value3;
  return o;
};
var RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Remove"
});
var makeRemove = (value3) => {
  const o = Object.create(RemoveProto);
  o.value = value3;
  return o;
};
var diff2 = (oldValue, newValue) => {
  const [removed, patch9] = reduce5([oldValue, empty13()], ([set10, patch10], value3) => {
    if (has4(value3)(set10)) {
      return [remove5(value3)(set10), patch10];
    }
    return [set10, combine5(makeAdd(value3))(patch10)];
  })(newValue);
  return reduce5(patch9, (patch10, value3) => combine5(makeRemove(value3))(patch10))(removed);
};
var combine5 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen2(self, that));
var patch2 = /* @__PURE__ */ dual(2, (self, oldValue) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let set10 = oldValue;
  let patches = of2(self);
  while (isNonEmpty(patches)) {
    const head8 = headNonEmpty2(patches);
    const tail2 = tailNonEmpty2(patches);
    switch (head8._tag) {
      case "Empty": {
        patches = tail2;
        break;
      }
      case "AndThen": {
        patches = prepend2(head8.first)(prepend2(head8.second)(tail2));
        break;
      }
      case "Add": {
        set10 = add4(head8.value)(set10);
        patches = tail2;
        break;
      }
      case "Remove": {
        set10 = remove5(head8.value)(set10);
        patches = tail2;
      }
    }
  }
  return set10;
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
var ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
function variance4(a) {
  return a;
}
var PatchProto3 = {
  ...Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: variance4,
    _Patch: variance4
  }
};
var EmptyProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Empty"
});
var _empty7 = /* @__PURE__ */ Object.create(EmptyProto3);
var empty14 = () => _empty7;
var AndThenProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "AndThen"
});
var makeAndThen3 = (first2, second) => {
  const o = Object.create(AndThenProto3);
  o.first = first2;
  o.second = second;
  return o;
};
var AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Append"
});
var makeAppend = (values5) => {
  const o = Object.create(AppendProto);
  o.values = values5;
  return o;
};
var SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Slice"
});
var makeSlice = (from, until) => {
  const o = Object.create(SliceProto);
  o.from = from;
  o.until = until;
  return o;
};
var UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Update"
});
var makeUpdate = (index, patch9) => {
  const o = Object.create(UpdateProto);
  o.index = index;
  o.patch = patch9;
  return o;
};
var diff3 = (options) => {
  let i = 0;
  let patch9 = empty14();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = options.oldValue[i];
    const newElement = options.newValue[i];
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options.differ.empty)) {
      patch9 = combine6(patch9, makeUpdate(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch9 = combine6(patch9, makeSlice(0, i));
  }
  if (i < options.newValue.length) {
    patch9 = combine6(patch9, makeAppend(drop(i)(options.newValue)));
  }
  return patch9;
};
var combine6 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen3(self, that));
var patch3 = /* @__PURE__ */ dual(3, (self, oldValue, differ3) => {
  if (self._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray2 = oldValue.slice();
  let patches = of(self);
  while (isNonEmptyArray2(patches)) {
    const head8 = headNonEmpty(patches);
    const tail2 = tailNonEmpty(patches);
    switch (head8._tag) {
      case "Empty": {
        patches = tail2;
        break;
      }
      case "AndThen": {
        tail2.unshift(head8.first, head8.second);
        patches = tail2;
        break;
      }
      case "Append": {
        for (const value3 of head8.values) {
          readonlyArray2.push(value3);
        }
        patches = tail2;
        break;
      }
      case "Slice": {
        readonlyArray2 = readonlyArray2.slice(head8.from, head8.until);
        patches = tail2;
        break;
      }
      case "Update": {
        readonlyArray2[head8.index] = differ3.patch(head8.patch, readonlyArray2[head8.index]);
        patches = tail2;
        break;
      }
    }
  }
  return readonlyArray2;
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
var DifferProto = {
  [DifferTypeId]: {
    _P: identity,
    _V: identity
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make15 = (params) => {
  const differ3 = Object.create(DifferProto);
  differ3.empty = params.empty;
  differ3.diff = params.diff;
  differ3.combine = params.combine;
  differ3.patch = params.patch;
  return differ3;
};
var environment = () => make15({
  empty: empty12(),
  combine: (first2, second) => combine4(second)(first2),
  diff: (oldValue, newValue) => diff(oldValue, newValue),
  patch: (patch9, oldValue) => patch(oldValue)(patch9)
});
var hashSet = () => make15({
  empty: empty13(),
  combine: (first2, second) => combine5(second)(first2),
  diff: (oldValue, newValue) => diff2(oldValue, newValue),
  patch: (patch9, oldValue) => patch2(oldValue)(patch9)
});
var readonlyArray = (differ3) => make15({
  empty: empty14(),
  combine: (first2, second) => combine6(first2, second),
  diff: (oldValue, newValue) => diff3({
    oldValue,
    newValue,
    differ: differ3
  }),
  patch: (patch9, oldValue) => patch3(patch9, oldValue, differ3)
});
var update = () => updateWith((_, a) => a);
var updateWith = (f) => make15({
  empty: identity,
  combine: (first2, second) => {
    if (first2 === identity) {
      return second;
    }
    if (second === identity) {
      return first2;
    }
    return (a) => second(first2(a));
  },
  diff: (oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return identity;
    }
    return constant(newValue);
  },
  patch: (patch9, oldValue) => f(oldValue, patch9(oldValue))
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
var BIT_MASK = 255;
var BIT_SHIFT = 8;
var active = (patch9) => patch9 & BIT_MASK;
var enabled = (patch9) => patch9 >> BIT_SHIFT & BIT_MASK;
var make16 = (active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT);
var empty15 = /* @__PURE__ */ make16(0, 0);
var enable = (flag) => make16(flag, flag);
var disable = (flag) => make16(flag, 0);
var exclude = /* @__PURE__ */ dual(2, (self, flag) => make16(active(self) & ~flag, enabled(self)));
var andThen2 = /* @__PURE__ */ dual(2, (self, that) => self | that);
var invert = (n) => ~n >>> 0 & BIT_MASK;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/runtimeFlags.js
var None2 = 0;
var Interruption = 1 << 0;
var OpSupervision = 1 << 1;
var RuntimeMetrics = 1 << 2;
var WindDown = 1 << 4;
var CooperativeYielding = 1 << 5;
var cooperativeYielding = (self) => isEnabled(self, CooperativeYielding);
var enable2 = /* @__PURE__ */ dual(2, (self, flag) => self | flag);
var interruptible = (self) => interruption(self) && !windDown(self);
var interruption = (self) => isEnabled(self, Interruption);
var isEnabled = /* @__PURE__ */ dual(2, (self, flag) => (self & flag) !== 0);
var make17 = (...flags) => flags.reduce((a, b) => a | b, 0);
var none5 = /* @__PURE__ */ make17(None2);
var runtimeMetrics = (self) => isEnabled(self, RuntimeMetrics);
var windDown = (self) => isEnabled(self, WindDown);
var diff4 = /* @__PURE__ */ dual(2, (self, that) => make16(self ^ that, that));
var patch4 = /* @__PURE__ */ dual(2, (self, patch9) => self & (invert(active(patch9)) | enabled(patch9)) | active(patch9) & enabled(patch9));
var differ = /* @__PURE__ */ make15({
  empty: empty15,
  diff: (oldValue, newValue) => diff4(oldValue, newValue),
  combine: (first2, second) => andThen2(second)(first2),
  patch: (_patch, oldValue) => patch4(oldValue, _patch)
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var empty16 = empty15;
var enable3 = enable;
var disable2 = disable;
var exclude2 = exclude;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/blockedRequests.js
var empty17 = {
  _tag: "Empty"
};
var par = (self, that) => ({
  _tag: "Par",
  left: self,
  right: that
});
var seq = (self, that) => ({
  _tag: "Seq",
  left: self,
  right: that
});
var single = (dataSource, blockedRequest) => ({
  _tag: "Single",
  dataSource,
  blockedRequest
});
var flatten5 = (self) => {
  let current2 = of3(self);
  let updated = empty11();
  while (1) {
    const [parallel5, sequential5] = reduce8(current2, [parallelCollectionEmpty(), empty11()], ([parallel6, sequential6], blockedRequest) => {
      const [par2, seq2] = step(blockedRequest);
      return [parallelCollectionCombine(parallel6, par2), appendAll3(sequential6, seq2)];
    });
    updated = merge4(updated, parallel5);
    if (isNil(sequential5)) {
      return reverse3(updated);
    }
    current2 = sequential5;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var step = (requests) => {
  let current2 = requests;
  let parallel5 = parallelCollectionEmpty();
  let stack = empty11();
  let sequential5 = empty11();
  while (1) {
    switch (current2._tag) {
      case "Empty": {
        if (isNil(stack)) {
          return [parallel5, sequential5];
        }
        current2 = stack.head;
        stack = stack.tail;
        break;
      }
      case "Par": {
        stack = cons(current2.right, stack);
        current2 = current2.left;
        break;
      }
      case "Seq": {
        const left3 = current2.left;
        const right3 = current2.right;
        switch (left3._tag) {
          case "Empty": {
            current2 = right3;
            break;
          }
          case "Par": {
            const l = left3.left;
            const r = left3.right;
            current2 = par(seq(l, right3), seq(r, right3));
            break;
          }
          case "Seq": {
            const l = left3.left;
            const r = left3.right;
            current2 = seq(l, seq(r, right3));
            break;
          }
          case "Single": {
            current2 = left3;
            sequential5 = cons(right3, sequential5);
            break;
          }
        }
        break;
      }
      case "Single": {
        parallel5 = parallelCollectionAdd(parallel5, current2);
        if (isNil(stack)) {
          return [parallel5, sequential5];
        }
        current2 = stack.head;
        stack = stack.tail;
        break;
      }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var merge4 = (sequential5, parallel5) => {
  if (isNil(sequential5)) {
    return of3(parallelCollectionToSequentialCollection(parallel5));
  }
  if (parallelCollectionIsEmpty(parallel5)) {
    return sequential5;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential5.head);
  const parKeys = parallelCollectionKeys(parallel5);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential5.head, parallelCollectionToSequentialCollection(parallel5)), sequential5.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel5), sequential5);
};
var EntryTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/Entry");
var _a5;
_a5 = EntryTypeId;
var EntryImpl = class {
  constructor(request2, result, listeners, ownerId, state) {
    __publicField(this, "request");
    __publicField(this, "result");
    __publicField(this, "listeners");
    __publicField(this, "ownerId");
    __publicField(this, "state");
    __publicField(this, _a5, blockedRequestVariance);
    this.request = request2;
    this.result = result;
    this.listeners = listeners;
    this.ownerId = ownerId;
    this.state = state;
  }
};
var blockedRequestVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var makeEntry = (options) => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state);
var RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
var parallelVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var _a6;
_a6 = RequestBlockParallelTypeId;
var ParallelImpl = class {
  constructor(map31) {
    __publicField(this, "map");
    __publicField(this, _a6, parallelVariance);
    this.map = map31;
  }
};
var parallelCollectionEmpty = () => new ParallelImpl(empty10());
var parallelCollectionAdd = (self, blockedRequest) => new ParallelImpl(modifyAt2(self.map, blockedRequest.dataSource, (_) => orElseSome(map2(_, append2(blockedRequest.blockedRequest)), () => of2(blockedRequest.blockedRequest))));
var parallelCollectionCombine = (self, that) => new ParallelImpl(reduce7(self.map, that.map, (map31, value3, key) => set3(map31, key, match2(get7(map31, key), {
  onNone: () => value3,
  onSome: (other) => appendAll2(value3, other)
}))));
var parallelCollectionIsEmpty = (self) => isEmpty4(self.map);
var parallelCollectionKeys = (self) => Array.from(keys3(self.map));
var parallelCollectionToSequentialCollection = (self) => sequentialCollectionMake(map9(self.map, (x) => of2(x)));
var SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
var sequentialVariance = {
  /* c8 ignore next */
  _R: (_) => _
};
var _a7;
_a7 = SequentialCollectionTypeId;
var SequentialImpl = class {
  constructor(map31) {
    __publicField(this, "map");
    __publicField(this, _a7, sequentialVariance);
    this.map = map31;
  }
};
var sequentialCollectionMake = (map31) => new SequentialImpl(map31);
var sequentialCollectionCombine = (self, that) => new SequentialImpl(reduce7(that.map, self.map, (map31, value3, key) => set3(map31, key, match2(get7(map31, key), {
  onNone: () => empty5(),
  onSome: (a) => appendAll2(a, value3)
}))));
var sequentialCollectionKeys = (self) => Array.from(keys3(self.map));
var sequentialCollectionToChunk = (self) => Array.from(self.map);

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/opCodes/deferred.js
var OP_STATE_PENDING = "Pending";
var OP_STATE_DONE = "Done";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey = "effect/Deferred";
var DeferredTypeId = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
var deferredVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var pending = (joiners) => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
};
var done = (effect4) => {
  return {
    _tag: OP_STATE_DONE,
    effect: effect4
  };
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/singleShotGen.js
var SingleShotGen2 = class _SingleShotGen {
  constructor(self) {
    __publicField(this, "self");
    __publicField(this, "called", false);
    this.self = self;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/core.js
var blocked = (blockedRequests, _continue3) => {
  const effect4 = new EffectPrimitive("Blocked");
  effect4.effect_instruction_i0 = blockedRequests;
  effect4.effect_instruction_i1 = _continue3;
  return effect4;
};
var runRequestBlock = (blockedRequests) => {
  const effect4 = new EffectPrimitive("RunBlocked");
  effect4.effect_instruction_i0 = blockedRequests;
  return effect4;
};
var EffectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Effect");
var RevertFlags = class {
  constructor(patch9, op) {
    __publicField(this, "patch");
    __publicField(this, "op");
    __publicField(this, "_op", OP_REVERT_FLAGS);
    this.patch = patch9;
    this.op = op;
  }
};
var _a8;
var EffectPrimitive = class {
  constructor(_op) {
    __publicField(this, "_op");
    __publicField(this, "effect_instruction_i0");
    __publicField(this, "effect_instruction_i1");
    __publicField(this, "effect_instruction_i2");
    __publicField(this, "trace");
    __publicField(this, _a8, effectVariance);
    this._op = _op;
  }
  [(_a8 = EffectTypeId2, symbol2)](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var _a9;
var EffectPrimitiveFailure = class {
  constructor(_op) {
    __publicField(this, "_op");
    __publicField(this, "effect_instruction_i0");
    __publicField(this, "effect_instruction_i1");
    __publicField(this, "effect_instruction_i2");
    __publicField(this, "trace");
    __publicField(this, _a9, effectVariance);
    this._op = _op;
    this._tag = _op;
  }
  [(_a9 = EffectTypeId2, symbol2)](that) {
    return exitIsExit(that) && that._op === "Failure" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(
      // @ts-expect-error
      string(this._tag),
      // @ts-expect-error
      combine(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var _a10;
var EffectPrimitiveSuccess = class {
  constructor(_op) {
    __publicField(this, "_op");
    __publicField(this, "effect_instruction_i0");
    __publicField(this, "effect_instruction_i1");
    __publicField(this, "effect_instruction_i2");
    __publicField(this, "trace");
    __publicField(this, _a10, effectVariance);
    this._op = _op;
    this._tag = _op;
  }
  [(_a10 = EffectTypeId2, symbol2)](that) {
    return exitIsExit(that) && that._op === "Success" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(
      // @ts-expect-error
      string(this._tag),
      // @ts-expect-error
      combine(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var isEffect = (u) => hasProperty(u, EffectTypeId2);
var withFiberRuntime = (withRuntime) => {
  const effect4 = new EffectPrimitive(OP_WITH_RUNTIME);
  effect4.effect_instruction_i0 = withRuntime;
  return effect4;
};
var acquireUseRelease = /* @__PURE__ */ dual(3, (acquire, use, release) => uninterruptibleMask((restore) => flatMap9(acquire, (a) => flatMap9(exit(suspend(() => restore(use(a)))), (exit4) => {
  return suspend(() => release(a, exit4)).pipe(matchCauseEffect({
    onFailure: (cause3) => {
      switch (exit4._tag) {
        case OP_FAILURE:
          return failCause(sequential(exit4.effect_instruction_i0, cause3));
        case OP_SUCCESS:
          return failCause(cause3);
      }
    },
    onSuccess: () => exit4
  }));
}))));
var as2 = /* @__PURE__ */ dual(2, (self, value3) => flatMap9(self, () => succeed(value3)));
var asVoid2 = (self) => as2(self, void 0);
var custom = function() {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.commit = arguments[1];
      break;
    }
    case 3: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.commit = arguments[2];
      break;
    }
    case 4: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.effect_instruction_i2 = arguments[2];
      wrapper.commit = arguments[3];
      break;
    }
    default: {
      throw new Error(getBugErrorMessage("you're not supposed to end up here"));
    }
  }
  return wrapper;
};
var unsafeAsync = (register, blockingOn = none4) => {
  const effect4 = new EffectPrimitive(OP_ASYNC);
  let cancelerRef = void 0;
  effect4.effect_instruction_i0 = (resume2) => {
    cancelerRef = register(resume2);
  };
  effect4.effect_instruction_i1 = blockingOn;
  return onInterrupt(effect4, (_) => isEffect(cancelerRef) ? cancelerRef : void_2);
};
var asyncInterrupt = (register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn));
var async_ = (resume2, blockingOn = none4) => {
  return custom(resume2, function() {
    let backingResume = void 0;
    let pendingEffect = void 0;
    function proxyResume(effect5) {
      if (backingResume) {
        backingResume(effect5);
      } else if (pendingEffect === void 0) {
        pendingEffect = effect5;
      }
    }
    const effect4 = new EffectPrimitive(OP_ASYNC);
    effect4.effect_instruction_i0 = (resume3) => {
      backingResume = resume3;
      if (pendingEffect) {
        resume3(pendingEffect);
      }
    };
    effect4.effect_instruction_i1 = blockingOn;
    let cancelerRef = void 0;
    let controllerRef = void 0;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController();
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
    } else {
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
    }
    return cancelerRef || controllerRef ? onInterrupt(effect4, (_) => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_2;
    }) : effect4;
  });
};
var catchAllCause = /* @__PURE__ */ dual(2, (self, f) => {
  const effect4 = new EffectPrimitive(OP_ON_FAILURE);
  effect4.effect_instruction_i0 = self;
  effect4.effect_instruction_i1 = f;
  return effect4;
});
var catchAll = /* @__PURE__ */ dual(2, (self, f) => matchEffect(self, {
  onFailure: f,
  onSuccess: succeed
}));
var catchIf = /* @__PURE__ */ dual(3, (self, predicate, f) => catchAllCause(self, (cause3) => {
  const either8 = failureOrCause(cause3);
  switch (either8._tag) {
    case "Left":
      return predicate(either8.left) ? f(either8.left) : failCause(cause3);
    case "Right":
      return failCause(either8.right);
  }
}));
var catchSome = /* @__PURE__ */ dual(2, (self, pf) => catchAllCause(self, (cause3) => {
  const either8 = failureOrCause(cause3);
  switch (either8._tag) {
    case "Left":
      return pipe(pf(either8.left), getOrElse3(() => failCause(cause3)));
    case "Right":
      return failCause(either8.right);
  }
}));
var checkInterruptible = (f) => withFiberRuntime((_, status3) => f(interruption(status3.runtimeFlags)));
var originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
var capture = (obj, span4) => {
  if (isSome2(span4)) {
    return new Proxy(obj, {
      has(target, p) {
        return p === spanSymbol || p === originalSymbol || p in target;
      },
      get(target, p) {
        if (p === spanSymbol) {
          return span4.value;
        }
        if (p === originalSymbol) {
          return obj;
        }
        return target[p];
      }
    });
  }
  return obj;
};
var die2 = (defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect));
var dieMessage = (message) => failCauseSync(() => die(new RuntimeException(message)));
var dieSync = (evaluate3) => flatMap9(sync(evaluate3), die2);
var either2 = (self) => matchEffect(self, {
  onFailure: (e) => succeed(left2(e)),
  onSuccess: (a) => succeed(right2(a))
});
var exit = (self) => matchCause(self, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
});
var fail2 = (error2) => isObject(error2) && !(spanSymbol in error2) ? withFiberRuntime((fiber) => failCause(fail(capture(error2, currentSpanFromFiber(fiber))))) : failCause(fail(error2));
var failSync = (evaluate3) => flatMap9(sync(evaluate3), fail2);
var failCause = (cause3) => {
  const effect4 = new EffectPrimitiveFailure(OP_FAILURE);
  effect4.effect_instruction_i0 = cause3;
  return effect4;
};
var failCauseSync = (evaluate3) => flatMap9(sync(evaluate3), failCause);
var fiberId = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.id()));
var fiberIdWith = (f) => withFiberRuntime((state) => f(state.id()));
var flatMap9 = /* @__PURE__ */ dual(2, (self, f) => {
  const effect4 = new EffectPrimitive(OP_ON_SUCCESS);
  effect4.effect_instruction_i0 = self;
  effect4.effect_instruction_i1 = f;
  return effect4;
});
var andThen3 = /* @__PURE__ */ dual(2, (self, f) => flatMap9(self, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return b;
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume2) => {
      b.then((a2) => resume2(succeed(a2)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
    });
  }
  return succeed(b);
}));
var step2 = (self) => {
  const effect4 = new EffectPrimitive("OnStep");
  effect4.effect_instruction_i0 = self;
  return effect4;
};
var flatten6 = (self) => flatMap9(self, identity);
var flip = (self) => matchEffect(self, {
  onFailure: succeed,
  onSuccess: fail2
});
var matchCause = /* @__PURE__ */ dual(2, (self, options) => matchCauseEffect(self, {
  onFailure: (cause3) => succeed(options.onFailure(cause3)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var matchCauseEffect = /* @__PURE__ */ dual(2, (self, options) => {
  const effect4 = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
  effect4.effect_instruction_i0 = self;
  effect4.effect_instruction_i1 = options.onFailure;
  effect4.effect_instruction_i2 = options.onSuccess;
  return effect4;
});
var matchEffect = /* @__PURE__ */ dual(2, (self, options) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const defects2 = defects(cause3);
    if (defects2.length > 0) {
      return failCause(electFailures(cause3));
    }
    const failures2 = failures(cause3);
    if (failures2.length > 0) {
      return options.onFailure(unsafeHead(failures2));
    }
    return failCause(cause3);
  },
  onSuccess: options.onSuccess
}));
var forEachSequential = /* @__PURE__ */ dual(2, (self, f) => suspend(() => {
  const arr = fromIterable2(self);
  const ret = allocate(arr.length);
  let i = 0;
  return as2(whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: (b) => {
      ret[i++] = b;
    }
  }), ret);
}));
var forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self, f) => suspend(() => {
  const arr = fromIterable2(self);
  let i = 0;
  return whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: () => {
      i++;
    }
  });
}));
var if_ = /* @__PURE__ */ dual((args2) => typeof args2[0] === "boolean" || isEffect(args2[0]), (self, options) => isEffect(self) ? flatMap9(self, (b) => b ? options.onTrue() : options.onFalse()) : self ? options.onTrue() : options.onFalse());
var interrupt2 = /* @__PURE__ */ flatMap9(fiberId, (fiberId3) => interruptWith(fiberId3));
var interruptWith = (fiberId3) => failCause(interrupt(fiberId3));
var interruptible2 = (self) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = enable3(Interruption);
  effect4.effect_instruction_i1 = () => self;
  return effect4;
};
var interruptibleMask = (f) => custom(f, function() {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = enable3(Interruption);
  effect4.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect4;
});
var intoDeferred = /* @__PURE__ */ dual(2, (self, deferred) => uninterruptibleMask((restore) => flatMap9(exit(restore(self)), (exit4) => deferredDone(deferred, exit4))));
var map10 = /* @__PURE__ */ dual(2, (self, f) => flatMap9(self, (a) => sync(() => f(a))));
var mapBoth2 = /* @__PURE__ */ dual(2, (self, options) => matchEffect(self, {
  onFailure: (e) => failSync(() => options.onFailure(e)),
  onSuccess: (a) => sync(() => options.onSuccess(a))
}));
var mapError = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const either8 = failureOrCause(cause3);
    switch (either8._tag) {
      case "Left": {
        return failSync(() => f(either8.left));
      }
      case "Right": {
        return failCause(either8.right);
      }
    }
  },
  onSuccess: succeed
}));
var onError = /* @__PURE__ */ dual(2, (self, cleanup) => onExit(self, (exit4) => exitIsSuccess(exit4) ? void_2 : cleanup(exit4.effect_instruction_i0)));
var onExit = /* @__PURE__ */ dual(2, (self, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
  onFailure: (cause1) => {
    const result = exitFailCause(cause1);
    return matchCauseEffect(cleanup(result), {
      onFailure: (cause22) => exitFailCause(sequential(cause1, cause22)),
      onSuccess: () => result
    });
  },
  onSuccess: (success) => {
    const result = exitSucceed(success);
    return zipRight2(cleanup(result), result);
  }
})));
var onInterrupt = /* @__PURE__ */ dual(2, (self, cleanup) => onExit(self, exitMatch({
  onFailure: (cause3) => isInterruptedOnly(cause3) ? asVoid2(cleanup(interruptors(cause3))) : void_2,
  onSuccess: () => void_2
})));
var orElse2 = /* @__PURE__ */ dual(2, (self, that) => attemptOrElse(self, that, succeed));
var orDie = (self) => orDieWith(self, identity);
var orDieWith = /* @__PURE__ */ dual(2, (self, f) => matchEffect(self, {
  onFailure: (e) => die2(f(e)),
  onSuccess: succeed
}));
var partitionMap4 = partitionMap2;
var runtimeFlags = /* @__PURE__ */ withFiberRuntime((_, status3) => succeed(status3.runtimeFlags));
var succeed = (value3) => {
  const effect4 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect4.effect_instruction_i0 = value3;
  return effect4;
};
var suspend = (evaluate3) => {
  const effect4 = new EffectPrimitive(OP_COMMIT);
  effect4.commit = evaluate3;
  return effect4;
};
var sync = (thunk) => {
  const effect4 = new EffectPrimitive(OP_SYNC);
  effect4.effect_instruction_i0 = thunk;
  return effect4;
};
var tap2 = /* @__PURE__ */ dual((args2) => args2.length === 3 || args2.length === 2 && !(isObject(args2[1]) && "onlyEffect" in args2[1]), (self, f) => flatMap9(self, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return as2(b, a);
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume2) => {
      b.then((_) => resume2(succeed(a)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
    });
  }
  return succeed(a);
}));
var transplant = (f) => withFiberRuntime((state) => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride);
  const scope5 = pipe(scopeOverride, getOrElse3(() => state.scope()));
  return f(fiberRefLocally(currentForkScopeOverride, some2(scope5)));
});
var attemptOrElse = /* @__PURE__ */ dual(3, (self, that, onSuccess) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const defects2 = defects(cause3);
    if (defects2.length > 0) {
      return failCause(getOrThrow2(keepDefectsAndElectFailures(cause3)));
    }
    return that();
  },
  onSuccess
}));
var uninterruptible = (self) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = disable2(Interruption);
  effect4.effect_instruction_i1 = () => self;
  return effect4;
};
var uninterruptibleMask = (f) => custom(f, function() {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = disable2(Interruption);
  effect4.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect4;
});
var void_2 = /* @__PURE__ */ succeed(void 0);
var updateRuntimeFlags = (patch9) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = patch9;
  effect4.effect_instruction_i1 = void 0;
  return effect4;
};
var whenEffect = /* @__PURE__ */ dual(2, (self, condition) => flatMap9(condition, (b) => {
  if (b) {
    return pipe(self, map10(some2));
  }
  return succeed(none2());
}));
var whileLoop = (options) => {
  const effect4 = new EffectPrimitive(OP_WHILE);
  effect4.effect_instruction_i0 = options.while;
  effect4.effect_instruction_i1 = options.body;
  effect4.effect_instruction_i2 = options.step;
  return effect4;
};
var fromIterator = (iterator) => suspend(() => {
  const effect4 = new EffectPrimitive(OP_ITERATOR);
  effect4.effect_instruction_i0 = iterator();
  return effect4;
});
var gen2 = function() {
  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
  return fromIterator(() => f(pipe));
};
var fnUntraced = (body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args2) {
  return fromIterator(() => body.apply(this, args2));
} : function(...args2) {
  let effect4 = fromIterator(() => body.apply(this, args2));
  for (const x of pipeables) {
    effect4 = x(effect4, ...args2);
  }
  return effect4;
}, "length", {
  value: body.length,
  configurable: true
});
var withConcurrency = /* @__PURE__ */ dual(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency));
var withRequestBatching = /* @__PURE__ */ dual(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching));
var withRuntimeFlags = /* @__PURE__ */ dual(2, (self, update5) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = update5;
  effect4.effect_instruction_i1 = () => self;
  return effect4;
});
var withTracerEnabled = /* @__PURE__ */ dual(2, (effect4, enabled2) => fiberRefLocally(effect4, currentTracerEnabled, enabled2));
var withTracerTiming = /* @__PURE__ */ dual(2, (effect4, enabled2) => fiberRefLocally(effect4, currentTracerTimingEnabled, enabled2));
var yieldNow = (options) => {
  const effect4 = new EffectPrimitive(OP_YIELD);
  return typeof options?.priority !== "undefined" ? withSchedulingPriority(effect4, options.priority) : effect4;
};
var zip3 = /* @__PURE__ */ dual(2, (self, that) => flatMap9(self, (a) => map10(that, (b) => [a, b])));
var zipLeft2 = /* @__PURE__ */ dual(2, (self, that) => flatMap9(self, (a) => as2(that, a)));
var zipRight2 = /* @__PURE__ */ dual(2, (self, that) => flatMap9(self, () => that));
var zipWith4 = /* @__PURE__ */ dual(3, (self, that, f) => flatMap9(self, (a) => map10(that, (b) => f(a, b))));
var never = /* @__PURE__ */ asyncInterrupt(() => {
  const interval = setInterval(() => {
  }, 2 ** 31 - 1);
  return sync(() => clearInterval(interval));
});
var interruptFiber = (self) => flatMap9(fiberId, (fiberId3) => pipe(self, interruptAsFiber(fiberId3)));
var interruptAsFiber = /* @__PURE__ */ dual(2, (self, fiberId3) => flatMap9(self.interruptAsFork(fiberId3), () => self.await));
var logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 5e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 4e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 3e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 2e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 1e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var FiberRefSymbolKey = "effect/FiberRef";
var FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
var fiberRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var fiberRefGet = (self) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self)));
var fiberRefGetWith = /* @__PURE__ */ dual(2, (self, f) => flatMap9(fiberRefGet(self), f));
var fiberRefSet = /* @__PURE__ */ dual(2, (self, value3) => fiberRefModify(self, () => [void 0, value3]));
var fiberRefModify = /* @__PURE__ */ dual(2, (self, f) => withFiberRuntime((state) => {
  const [b, a] = f(state.getFiberRef(self));
  state.setFiberRef(self, a);
  return succeed(b);
}));
var RequestResolverSymbolKey = "effect/RequestResolver";
var RequestResolverTypeId = /* @__PURE__ */ Symbol.for(RequestResolverSymbolKey);
var requestResolverVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var _a11;
var RequestResolverImpl = class _RequestResolverImpl {
  constructor(runAll, target) {
    __publicField(this, "runAll");
    __publicField(this, "target");
    __publicField(this, _a11, requestResolverVariance);
    this.runAll = runAll;
    this.target = target;
  }
  [(_a11 = RequestResolverTypeId, symbol)]() {
    return cached(this, this.target ? hash(this.target) : random(this));
  }
  [symbol2](that) {
    return this.target ? isRequestResolver(that) && equals(this.target, that.target) : this === that;
  }
  identified(...ids3) {
    return new _RequestResolverImpl(this.runAll, fromIterable3(ids3));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isRequestResolver = (u) => hasProperty(u, RequestResolverTypeId);
var fiberRefLocally = /* @__PURE__ */ dual(3, (use, self, value3) => acquireUseRelease(zipLeft2(fiberRefGet(self), fiberRefSet(self, value3)), () => use, (oldValue) => fiberRefSet(self, oldValue)));
var fiberRefLocallyWith = /* @__PURE__ */ dual(3, (use, self, f) => fiberRefGetWith(self, (a) => fiberRefLocally(use, self, f(a))));
var fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
  differ: update(),
  fork: options?.fork ?? identity,
  join: options?.join
});
var fiberRefUnsafeMakeHashSet = (initial) => {
  const differ3 = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
};
var fiberRefUnsafeMakeReadonlyArray = (initial) => {
  const differ3 = readonlyArray(update());
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
};
var fiberRefUnsafeMakeContext = (initial) => {
  const differ3 = environment();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
};
var fiberRefUnsafeMakePatch = (initial, options) => {
  const _fiberRef = {
    ...CommitPrototype,
    [FiberRefTypeId]: fiberRefVariance,
    initial,
    commit() {
      return fiberRefGet(this);
    },
    diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
    combine: (first2, second) => options.differ.combine(first2, second),
    patch: (patch9) => (oldValue) => options.differ.patch(patch9, oldValue),
    fork: options.fork,
    join: options.join ?? ((_, n) => n)
  };
  return _fiberRef;
};
var fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ,
  fork: differ.empty
});
var currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty2()));
var currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
var currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
var currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty10()));
var currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
var currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty11()));
var withSchedulingPriority = /* @__PURE__ */ dual(2, (self, scheduler2) => fiberRefLocally(self, currentSchedulingPriority, scheduler2));
var withMaxOpsBeforeYield = /* @__PURE__ */ dual(2, (self, scheduler2) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler2));
var currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
var currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
var currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelDebug)));
var withUnhandledErrorLogLevel = /* @__PURE__ */ dual(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level));
var currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty4()));
var metricLabels = /* @__PURE__ */ fiberRefGet(currentMetricLabels);
var currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
  fork: () => none2(),
  join: (parent, _) => parent
}));
var currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty9, {
  fork: () => empty9,
  join: (parent, _) => parent
}));
var currentTracerEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
var currentTracerTimingEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
var currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty10()));
var currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty5()));
var ScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Scope");
var CloseableScopeTypeId = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
var scopeAddFinalizer = (self, finalizer3) => self.addFinalizer(() => asVoid2(finalizer3));
var scopeAddFinalizerExit = (self, finalizer3) => self.addFinalizer(finalizer3);
var scopeClose = (self, exit4) => self.close(exit4);
var scopeFork = (self, strategy) => self.fork(strategy);
var causeSquash = (self) => {
  return causeSquashWith(identity)(self);
};
var causeSquashWith = /* @__PURE__ */ dual(2, (self, f) => {
  const option5 = pipe(self, failureOption, map2(f));
  switch (option5._tag) {
    case "None": {
      return pipe(defects(self), head2, match2({
        onNone: () => {
          const interrupts = fromIterable2(interruptors(self)).flatMap((fiberId3) => fromIterable2(ids2(fiberId3)).map((id3) => `#${id3}`));
          return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : void 0);
        },
        onSome: identity
      }));
    }
    case "Some": {
      return option5.value;
    }
  }
});
var YieldableError = /* @__PURE__ */ function() {
  class YieldableError2 extends globalThis.Error {
    commit() {
      return fail2(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message) obj.message = this.message;
      if (this.cause) obj.cause = this.cause;
      return obj;
    }
    [NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}
${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty(fail(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  Object.assign(YieldableError2.prototype, StructuralCommitPrototype);
  return YieldableError2;
}();
var makeException = (proto14, tag3) => {
  class Base3 extends YieldableError {
    constructor() {
      super(...arguments);
      __publicField(this, "_tag", tag3);
    }
  }
  Object.assign(Base3.prototype, proto14);
  Base3.prototype.name = tag3;
  return Base3;
};
var RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException = /* @__PURE__ */ makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
var isRuntimeException = (u) => hasProperty(u, RuntimeExceptionTypeId);
var InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException = /* @__PURE__ */ makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
var isInterruptedException = (u) => hasProperty(u, InterruptedExceptionTypeId);
var IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
var IllegalArgumentException = /* @__PURE__ */ makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
var NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException = /* @__PURE__ */ makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
var isNoSuchElementException = (u) => hasProperty(u, NoSuchElementExceptionTypeId);
var InvalidPubSubCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
var InvalidPubSubCapacityException = /* @__PURE__ */ makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
var ExceededCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
var ExceededCapacityException = /* @__PURE__ */ makeException({
  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}, "ExceededCapacityException");
var TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException = /* @__PURE__ */ makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
var timeoutExceptionFromDuration = (duration4) => new TimeoutException(`Operation timed out after '${format2(duration4)}'`);
var UnknownExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
var UnknownException = /* @__PURE__ */ function() {
  class UnknownException2 extends YieldableError {
    constructor(cause3, message) {
      super(message ?? "An unknown error occurred", {
        cause: cause3
      });
      __publicField(this, "_tag", "UnknownException");
      __publicField(this, "error");
      this.error = cause3;
    }
  }
  Object.assign(UnknownException2.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException2;
}();
var exitIsExit = (u) => isEffect(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure");
var exitIsFailure = (self) => self._tag === "Failure";
var exitIsSuccess = (self) => self._tag === "Success";
var exitAs = /* @__PURE__ */ dual(2, (self, value3) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return exitFailCause(self.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return exitSucceed(value3);
    }
  }
});
var exitAsVoid = (self) => exitAs(self, void 0);
var exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel : sequential);
var exitDie = (defect) => exitFailCause(die(defect));
var exitFail = (error2) => exitFailCause(fail(error2));
var exitFailCause = (cause3) => {
  const effect4 = new EffectPrimitiveFailure(OP_FAILURE);
  effect4.effect_instruction_i0 = cause3;
  return effect4;
};
var exitFlatMap = /* @__PURE__ */ dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return exitFailCause(self.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return f(self.effect_instruction_i0);
    }
  }
});
var exitFlatten = (self) => pipe(self, exitFlatMap(identity));
var exitForEachEffect = /* @__PURE__ */ dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE: {
      return succeed(exitFailCause(self.effect_instruction_i0));
    }
    case OP_SUCCESS: {
      return exit(f(self.effect_instruction_i0));
    }
  }
});
var exitInterrupt = (fiberId3) => exitFailCause(interrupt(fiberId3));
var exitMap = /* @__PURE__ */ dual(2, (self, f) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(self.effect_instruction_i0);
    case OP_SUCCESS:
      return exitSucceed(f(self.effect_instruction_i0));
  }
});
var exitMapBoth = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self.effect_instruction_i0, map8(onFailure)));
    case OP_SUCCESS:
      return exitSucceed(onSuccess(self.effect_instruction_i0));
  }
});
var exitMatch = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitMatchEffect = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE:
      return onFailure(self.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self.effect_instruction_i0);
  }
});
var exitSucceed = (value3) => {
  const effect4 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect4.effect_instruction_i0 = value3;
  return effect4;
};
var exitVoid = /* @__PURE__ */ exitSucceed(void 0);
var exitZip = /* @__PURE__ */ dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: sequential
}));
var exitZipRight = /* @__PURE__ */ dual(2, (self, that) => exitZipWith(self, that, {
  onSuccess: (_, a2) => a2,
  onFailure: sequential
}));
var exitZipWith = /* @__PURE__ */ dual(3, (self, that, {
  onFailure,
  onSuccess
}) => {
  switch (self._tag) {
    case OP_FAILURE: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitFailCause(self.effect_instruction_i0);
        case OP_FAILURE: {
          return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
        }
      }
    }
    case OP_SUCCESS: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
        case OP_FAILURE:
          return exitFailCause(that.effect_instruction_i0);
      }
    }
  }
});
var exitCollectAllInternal = (exits, combineCauses) => {
  const list = fromIterable3(exits);
  if (!isNonEmpty(list)) {
    return none2();
  }
  return pipe(tailNonEmpty2(list), reduce(pipe(headNonEmpty2(list), exitMap(of2)), (accumulator, current2) => pipe(accumulator, exitZipWith(current2, {
    onSuccess: (list2, value3) => pipe(list2, prepend2(value3)),
    onFailure: combineCauses
  }))), exitMap(reverse2), exitMap((chunk4) => toReadonlyArray(chunk4)), some2);
};
var deferredUnsafeMake = (fiberId3) => {
  const _deferred = {
    ...CommitPrototype,
    [DeferredTypeId]: deferredVariance,
    state: make12(pending([])),
    commit() {
      return deferredAwait(this);
    },
    blockingOn: fiberId3
  };
  return _deferred;
};
var deferredMake = () => flatMap9(fiberId, (id3) => deferredMakeAs(id3));
var deferredMakeAs = (fiberId3) => sync(() => deferredUnsafeMake(fiberId3));
var deferredAwait = (self) => asyncInterrupt((resume2) => {
  const state = get6(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return resume2(state.effect);
    }
    case OP_STATE_PENDING: {
      state.joiners.push(resume2);
      return deferredInterruptJoiner(self, resume2);
    }
  }
}, self.blockingOn);
var deferredComplete = /* @__PURE__ */ dual(2, (self, effect4) => intoDeferred(effect4, self));
var deferredCompleteWith = /* @__PURE__ */ dual(2, (self, effect4) => sync(() => {
  const state = get6(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return false;
    }
    case OP_STATE_PENDING: {
      set2(self.state, done(effect4));
      for (let i = 0, len = state.joiners.length; i < len; i++) {
        state.joiners[i](effect4);
      }
      return true;
    }
  }
}));
var deferredDone = /* @__PURE__ */ dual(2, (self, exit4) => deferredCompleteWith(self, exit4));
var deferredFail = /* @__PURE__ */ dual(2, (self, error2) => deferredCompleteWith(self, fail2(error2)));
var deferredFailCause = /* @__PURE__ */ dual(2, (self, cause3) => deferredCompleteWith(self, failCause(cause3)));
var deferredInterrupt = (self) => flatMap9(fiberId, (fiberId3) => deferredCompleteWith(self, interruptWith(fiberId3)));
var deferredInterruptWith = /* @__PURE__ */ dual(2, (self, fiberId3) => deferredCompleteWith(self, interruptWith(fiberId3)));
var deferredIsDone = (self) => sync(() => get6(self.state)._tag === OP_STATE_DONE);
var deferredPoll = (self) => sync(() => {
  const state = get6(self.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return some2(state.effect);
    }
    case OP_STATE_PENDING: {
      return none2();
    }
  }
});
var deferredSucceed = /* @__PURE__ */ dual(2, (self, value3) => deferredCompleteWith(self, succeed(value3)));
var deferredUnsafeDone = (self, effect4) => {
  const state = get6(self.state);
  if (state._tag === OP_STATE_PENDING) {
    set2(self.state, done(effect4));
    for (let i = 0, len = state.joiners.length; i < len; i++) {
      state.joiners[i](effect4);
    }
  }
};
var deferredInterruptJoiner = (self, joiner) => sync(() => {
  const state = get6(self.state);
  if (state._tag === OP_STATE_PENDING) {
    const index = state.joiners.indexOf(joiner);
    if (index >= 0) {
      state.joiners.splice(index, 1);
    }
  }
});
var constContext = /* @__PURE__ */ withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
var context = () => constContext;
var contextWithEffect = (f) => flatMap9(context(), f);
var provideContext = /* @__PURE__ */ dual(2, (self, context9) => fiberRefLocally(currentContext, context9)(self));
var provideSomeContext = /* @__PURE__ */ dual(2, (self, context9) => fiberRefLocallyWith(currentContext, (parent) => merge2(parent, context9))(self));
var mapInputContext = /* @__PURE__ */ dual(2, (self, f) => contextWithEffect((context9) => provideContext(self, f(context9))));
var filterEffectOrElse = /* @__PURE__ */ dual(2, (self, options) => flatMap9(self, (a) => flatMap9(options.predicate(a), (pass) => pass ? succeed(a) : options.orElse(a))));
var filterEffectOrFail = /* @__PURE__ */ dual(2, (self, options) => filterEffectOrElse(self, {
  predicate: options.predicate,
  orElse: (a) => fail2(options.orFailWith(a))
}));
var currentSpanFromFiber = (fiber) => {
  const span4 = fiber.currentSpan;
  return span4 !== void 0 && span4._tag === "Span" ? some2(span4) : none2();
};
var NoopSpanProto = {
  _tag: "Span",
  spanId: "noop",
  traceId: "noop",
  sampled: false,
  status: {
    _tag: "Ended",
    startTime: /* @__PURE__ */ BigInt(0),
    endTime: /* @__PURE__ */ BigInt(0),
    exit: exitVoid
  },
  attributes: /* @__PURE__ */ new Map(),
  links: [],
  kind: "internal",
  attribute() {
  },
  event() {
  },
  end() {
  },
  addLinks() {
  }
};
var noopSpan = (options) => Object.assign(Object.create(NoopSpanProto), options);

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/clock.js
var ClockSymbolKey = "effect/Clock";
var ClockTypeId = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
var clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
var MAX_TIMER_MILLIS = 2 ** 31 - 1;
var globalClockScheduler = {
  unsafeSchedule(task, duration4) {
    const millis2 = toMillis(duration4);
    if (millis2 > MAX_TIMER_MILLIS) {
      return constFalse;
    }
    let completed = false;
    const handle = setTimeout(() => {
      completed = true;
      task();
    }, millis2);
    return () => {
      clearTimeout(handle);
      return !completed;
    };
  }
};
var performanceNowNanos = /* @__PURE__ */ function() {
  const bigint1e62 = /* @__PURE__ */ BigInt(1e6);
  if (typeof performance === "undefined") {
    return () => BigInt(Date.now()) * bigint1e62;
  }
  let origin;
  return () => {
    if (origin === void 0) {
      origin = BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
    }
    return origin + BigInt(Math.round(performance.now() * 1e6));
  };
}();
var processOrPerformanceNow = /* @__PURE__ */ function() {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : void 0;
  if (!processHrtime) {
    return performanceNowNanos;
  }
  const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
  return () => origin + processHrtime.bigint();
}();
var _a12;
_a12 = ClockTypeId;
var ClockImpl = class {
  constructor() {
    __publicField(this, _a12, ClockTypeId);
    __publicField(this, "currentTimeMillis", /* @__PURE__ */ sync(() => this.unsafeCurrentTimeMillis()));
    __publicField(this, "currentTimeNanos", /* @__PURE__ */ sync(() => this.unsafeCurrentTimeNanos()));
  }
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow();
  }
  scheduler() {
    return succeed(globalClockScheduler);
  }
  sleep(duration4) {
    return async_((resume2) => {
      const canceler = globalClockScheduler.unsafeSchedule(() => resume2(void_2), duration4);
      return asVoid2(sync(canceler));
    });
  }
};
var make18 = () => new ClockImpl();

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Number.js
var Order2 = number3;
var clamp4 = /* @__PURE__ */ clamp(Order2);
var remainder = /* @__PURE__ */ dual(2, (dividend, divisor) => {
  const selfDecCount = (dividend.toString().split(".")[1] || "").length;
  const divisorDecCount = (divisor.toString().split(".")[1] || "").length;
  const decCount = selfDecCount > divisorDecCount ? selfDecCount : divisorDecCount;
  const selfInt = parseInt(dividend.toFixed(decCount).replace(".", ""));
  const divisorInt = parseInt(divisor.toFixed(decCount).replace(".", ""));
  return selfInt % divisorInt / Math.pow(10, decCount);
});
var nextPow2 = (n) => {
  const nextPow = Math.ceil(Math.log(n) / Math.log(2));
  return Math.max(Math.pow(2, nextPow), 2);
};
var parse = (s) => {
  if (s === "NaN") {
    return some(NaN);
  }
  if (s === "Infinity") {
    return some(Infinity);
  }
  if (s === "-Infinity") {
    return some(-Infinity);
  }
  if (s.trim() === "") {
    return none;
  }
  const n = Number(s);
  return Number.isNaN(n) ? none : some(n);
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/RegExp.js
var escape = (string7) => string7.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/opCodes/configError.js
var OP_AND = "And";
var OP_OR = "Or";
var OP_INVALID_DATA = "InvalidData";
var OP_MISSING_DATA = "MissingData";
var OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
var OP_UNSUPPORTED = "Unsupported";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey = "effect/ConfigError";
var ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
var proto2 = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
var And = (self, that) => {
  const error2 = Object.create(proto2);
  error2._op = OP_AND;
  error2.left = self;
  error2.right = that;
  Object.defineProperty(error2, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  Object.defineProperty(error2, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error2;
};
var Or = (self, that) => {
  const error2 = Object.create(proto2);
  error2._op = OP_OR;
  error2.left = self;
  error2.right = that;
  Object.defineProperty(error2, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  Object.defineProperty(error2, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error2;
};
var InvalidData = (path, message, options = {
  pathDelim: "."
}) => {
  const error2 = Object.create(proto2);
  error2._op = OP_INVALID_DATA;
  error2.path = path;
  error2.message = message;
  Object.defineProperty(error2, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Invalid data at ${path2}: "${this.message}")`;
    }
  });
  return error2;
};
var MissingData = (path, message, options = {
  pathDelim: "."
}) => {
  const error2 = Object.create(proto2);
  error2._op = OP_MISSING_DATA;
  error2.path = path;
  error2.message = message;
  Object.defineProperty(error2, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Missing data at ${path2}: "${this.message}")`;
    }
  });
  return error2;
};
var SourceUnavailable = (path, message, cause3, options = {
  pathDelim: "."
}) => {
  const error2 = Object.create(proto2);
  error2._op = OP_SOURCE_UNAVAILABLE;
  error2.path = path;
  error2.message = message;
  error2.cause = cause3;
  Object.defineProperty(error2, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Source unavailable at ${path2}: "${this.message}")`;
    }
  });
  return error2;
};
var Unsupported = (path, message, options = {
  pathDelim: "."
}) => {
  const error2 = Object.create(proto2);
  error2._op = OP_UNSUPPORTED;
  error2.path = path;
  error2.message = message;
  Object.defineProperty(error2, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Unsupported operation at ${path2}: "${this.message}")`;
    }
  });
  return error2;
};
var prefixed = /* @__PURE__ */ dual(2, (self, prefix) => {
  switch (self._op) {
    case OP_AND: {
      return And(prefixed(self.left, prefix), prefixed(self.right, prefix));
    }
    case OP_OR: {
      return Or(prefixed(self.left, prefix), prefixed(self.right, prefix));
    }
    case OP_INVALID_DATA: {
      return InvalidData([...prefix, ...self.path], self.message);
    }
    case OP_MISSING_DATA: {
      return MissingData([...prefix, ...self.path], self.message);
    }
    case OP_SOURCE_UNAVAILABLE: {
      return SourceUnavailable([...prefix, ...self.path], self.message, self.cause);
    }
    case OP_UNSUPPORTED: {
      return Unsupported([...prefix, ...self.path], self.message);
    }
  }
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
var empty18 = {
  _tag: "Empty"
};
var patch5 = /* @__PURE__ */ dual(2, (path, patch9) => {
  let input = of3(patch9);
  let output3 = path;
  while (isCons(input)) {
    const patch10 = input.head;
    switch (patch10._tag) {
      case "Empty": {
        input = input.tail;
        break;
      }
      case "AndThen": {
        input = cons(patch10.first, cons(patch10.second, input.tail));
        break;
      }
      case "MapName": {
        output3 = map3(output3, patch10.f);
        input = input.tail;
        break;
      }
      case "Nested": {
        output3 = prepend(output3, patch10.name);
        input = input.tail;
        break;
      }
      case "Unnested": {
        const containsName = pipe(head(output3), contains(patch10.name));
        if (containsName) {
          output3 = tailNonEmpty(output3);
          input = input.tail;
        } else {
          return left2(MissingData(output3, `Expected ${patch10.name} to be in path in ConfigProvider#unnested`));
        }
        break;
      }
    }
  }
  return right2(output3);
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/opCodes/config.js
var OP_CONSTANT = "Constant";
var OP_FAIL2 = "Fail";
var OP_FALLBACK = "Fallback";
var OP_DESCRIBED = "Described";
var OP_LAZY = "Lazy";
var OP_MAP_OR_FAIL = "MapOrFail";
var OP_NESTED = "Nested";
var OP_PRIMITIVE = "Primitive";
var OP_SEQUENCE = "Sequence";
var OP_HASHMAP = "HashMap";
var OP_ZIP_WITH = "ZipWith";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/configProvider.js
var concat = (l, r) => [...l, ...r];
var ConfigProviderSymbolKey = "effect/ConfigProvider";
var ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
var configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
var FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
var FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
var make20 = (options) => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var makeFlat = (options) => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options.patch,
  load: (path, config2, split8 = true) => options.load(path, config2, split8),
  enumerateChildren: options.enumerateChildren
});
var fromFlat = (flat) => make20({
  load: (config2) => flatMap9(fromFlatLoop(flat, empty4(), config2, false), (chunk4) => match2(head(chunk4), {
    onNone: () => fail2(MissingData(empty4(), `Expected a single value having structure: ${config2}`)),
    onSome: succeed
  })),
  flattened: flat
});
var fromEnv = (options) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options);
  const makePathString = (path) => pipe(path, join(pathDelim));
  const unmakePathString = (pathString) => pathString.split(pathDelim);
  const getEnv = () => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {};
  const load = (path, primitive2, split8 = true) => {
    const pathString = makePathString(path);
    const current2 = getEnv();
    const valueOpt = pathString in current2 ? some2(current2[pathString]) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap9((value3) => parsePrimitive(value3, path, primitive2, seqDelim, split8)));
  };
  const enumerateChildren = (path) => sync(() => {
    const current2 = getEnv();
    const keys6 = Object.keys(current2);
    const keyPaths = keys6.map((value3) => unmakePathString(value3.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0; i < path.length; i++) {
        const pathComponent = pipe(path, unsafeGet3(i));
        const currentElement = keyPath[i];
        if (currentElement === void 0 || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
    return fromIterable6(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty18
  }));
};
var extend = (leftDef, rightDef, left3, right3) => {
  const leftPad = unfold(left3.length, (index) => index >= right3.length ? none2() : some2([leftDef(index), index + 1]));
  const rightPad = unfold(right3.length, (index) => index >= left3.length ? none2() : some2([rightDef(index), index + 1]));
  const leftExtension = concat(left3, leftPad);
  const rightExtension = concat(right3, rightPad);
  return [leftExtension, rightExtension];
};
var appendConfigPath = (path, config2) => {
  let op = config2;
  if (op._tag === "Nested") {
    const out = path.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path;
};
var fromFlatLoop = (flat, prefix, config2, split8) => {
  const op = config2;
  switch (op._tag) {
    case OP_CONSTANT: {
      return succeed(of(op.value));
    }
    case OP_DESCRIBED: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config, split8));
    }
    case OP_FAIL2: {
      return fail2(MissingData(prefix, op.message));
    }
    case OP_FALLBACK: {
      return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split8)), catchAll((error1) => {
        if (op.condition(error1)) {
          return pipe(fromFlatLoop(flat, prefix, op.second, split8), catchAll((error2) => fail2(Or(error1, error2))));
        }
        return fail2(error1);
      }));
    }
    case OP_LAZY: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config(), split8));
    }
    case OP_MAP_OR_FAIL: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split8), flatMap9(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
    }
    case OP_NESTED: {
      return suspend(() => fromFlatLoop(flat, concat(prefix, of(op.name)), op.config, split8));
    }
    case OP_PRIMITIVE: {
      return pipe(patch5(prefix, flat.patch), flatMap9((prefix2) => pipe(flat.load(prefix2, op, split8), flatMap9((values5) => {
        if (values5.length === 0) {
          const name = pipe(last(prefix2), getOrElse3(() => "<n/a>"));
          return fail2(MissingData([], `Expected ${op.description} with name ${name}`));
        }
        return succeed(values5);
      }))));
    }
    case OP_SEQUENCE: {
      return pipe(patch5(prefix, flat.patch), flatMap9((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap9(indicesFrom), flatMap9((indices) => {
        if (indices.length === 0) {
          return suspend(() => map10(fromFlatLoop(flat, prefix, op.config, true), of));
        }
        return pipe(forEachSequential(indices, (index) => fromFlatLoop(flat, append(prefix, `[${index}]`), op.config, true)), map10((chunkChunk) => {
          const flattened = flatten2(chunkChunk);
          if (flattened.length === 0) {
            return of(empty4());
          }
          return of(flattened);
        }));
      }))));
    }
    case OP_HASHMAP: {
      return suspend(() => pipe(patch5(prefix, flat.patch), flatMap9((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap9((keys6) => {
        return pipe(keys6, forEachSequential((key) => fromFlatLoop(flat, concat(prefix2, of(key)), op.valueConfig, split8)), map10((matrix) => {
          if (matrix.length === 0) {
            return of(empty10());
          }
          return pipe(transpose(matrix), map3((values5) => fromIterable7(zip(fromIterable2(keys6), values5))));
        }));
      })))));
    }
    case OP_ZIP_WITH: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split8), either2, flatMap9((left3) => pipe(fromFlatLoop(flat, prefix, op.right, split8), either2, flatMap9((right3) => {
        if (isLeft2(left3) && isLeft2(right3)) {
          return fail2(And(left3.left, right3.left));
        }
        if (isLeft2(left3) && isRight2(right3)) {
          return fail2(left3.left);
        }
        if (isRight2(left3) && isLeft2(right3)) {
          return fail2(right3.left);
        }
        if (isRight2(left3) && isRight2(right3)) {
          const path = pipe(prefix, join("."));
          const fail21 = fromFlatLoopFail(prefix, path);
          const [lefts, rights] = extend(fail21, fail21, pipe(left3.right, map3(right2)), pipe(right3.right, map3(right2)));
          return pipe(lefts, zip(rights), forEachSequential(([left4, right4]) => pipe(zip3(left4, right4), map10(([left5, right5]) => op.zip(left5, right5)))));
        }
        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
      })))));
    }
  }
};
var fromFlatLoopFail = (prefix, path) => (index) => left2(MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`));
var splitPathString = (text, delim) => {
  const split8 = text.split(new RegExp(`\\s*${escape(delim)}\\s*`));
  return split8;
};
var parsePrimitive = (text, path, primitive2, delimiter, split8) => {
  if (!split8) {
    return pipe(primitive2.parse(text), mapBoth2({
      onFailure: prefixed(path),
      onSuccess: of
    }));
  }
  return pipe(splitPathString(text, delimiter), forEachSequential((char2) => primitive2.parse(char2.trim())), mapError(prefixed(path)));
};
var transpose = (array6) => {
  return Object.keys(array6[0]).map((column) => array6.map((row) => row[column]));
};
var indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth2({
  onFailure: () => empty4(),
  onSuccess: sort(Order2)
}), either2, map10(merge3));
var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
var parseQuotedIndex = (str) => {
  const match21 = str.match(QUOTED_INDEX_REGEX);
  if (match21 !== null) {
    const matchedIndex = match21[2];
    return pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some2(matchedIndex) : none2(), flatMap(parseInteger));
  }
  return none2();
};
var parseInteger = (str) => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none2() : some2(parsedIndex);
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/defaultServices/console.js
var TypeId9 = /* @__PURE__ */ Symbol.for("effect/Console");
var consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
var defaultConsole = {
  [TypeId9]: TypeId9,
  assert(condition, ...args2) {
    return sync(() => {
      console.assert(condition, ...args2);
    });
  },
  clear: /* @__PURE__ */ sync(() => {
    console.clear();
  }),
  count(label) {
    return sync(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync(() => {
      console.countReset(label);
    });
  },
  debug(...args2) {
    return sync(() => {
      console.debug(...args2);
    });
  },
  dir(item, options) {
    return sync(() => {
      console.dir(item, options);
    });
  },
  dirxml(...args2) {
    return sync(() => {
      console.dirxml(...args2);
    });
  },
  error(...args2) {
    return sync(() => {
      console.error(...args2);
    });
  },
  group(options) {
    return options?.collapsed ? sync(() => console.groupCollapsed(options?.label)) : sync(() => console.group(options?.label));
  },
  groupEnd: /* @__PURE__ */ sync(() => {
    console.groupEnd();
  }),
  info(...args2) {
    return sync(() => {
      console.info(...args2);
    });
  },
  log(...args2) {
    return sync(() => {
      console.log(...args2);
    });
  },
  table(tabularData, properties) {
    return sync(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync(() => console.time(label));
  },
  timeEnd(label) {
    return sync(() => console.timeEnd(label));
  },
  timeLog(label, ...args2) {
    return sync(() => {
      console.timeLog(label, ...args2);
    });
  },
  trace(...args2) {
    return sync(() => {
      console.trace(...args2);
    });
  },
  warn(...args2) {
    return sync(() => {
      console.warn(...args2);
    });
  },
  unsafe: console
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/random.js
var RandomSymbolKey = "effect/Random";
var RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
var randomTag = /* @__PURE__ */ GenericTag("effect/Random");
var _a13;
_a13 = RandomTypeId;
var RandomImpl = class {
  constructor(seed) {
    __publicField(this, "seed");
    __publicField(this, _a13, RandomTypeId);
    __publicField(this, "PRNG");
    this.seed = seed;
    this.PRNG = new PCGRandom(seed);
  }
  get next() {
    return sync(() => this.PRNG.number());
  }
  get nextBoolean() {
    return map10(this.next, (n) => n > 0.5);
  }
  get nextInt() {
    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min5, max7) {
    return map10(this.next, (n) => (max7 - min5) * n + min5);
  }
  nextIntBetween(min5, max7) {
    return sync(() => this.PRNG.integer(max7 - min5) + min5);
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
};
var shuffleWith = (elements, nextIntBounded) => {
  return suspend(() => pipe(sync(() => Array.from(elements)), flatMap9((buffer3) => {
    const numbers = [];
    for (let i = buffer3.length; i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map10((k) => swap(buffer3, n - 1, k)))), as2(fromIterable3(buffer3)));
  })));
};
var swap = (buffer3, index1, index2) => {
  const tmp = buffer3[index1];
  buffer3[index1] = buffer3[index2];
  buffer3[index2] = tmp;
  return buffer3;
};
var make21 = (seed) => new RandomImpl(hash(seed));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/tracer.js
var TracerTypeId = /* @__PURE__ */ Symbol.for("effect/Tracer");
var make22 = (options) => ({
  [TracerTypeId]: TracerTypeId,
  ...options
});
var tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
var spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
var randomHexString = /* @__PURE__ */ function() {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function(length5) {
    let result = "";
    for (let i = 0; i < length5; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
}();
var NativeSpan = class {
  constructor(name, parent, context9, links, startTime, kind) {
    __publicField(this, "name");
    __publicField(this, "parent");
    __publicField(this, "context");
    __publicField(this, "startTime");
    __publicField(this, "kind");
    __publicField(this, "_tag", "Span");
    __publicField(this, "spanId");
    __publicField(this, "traceId", "native");
    __publicField(this, "sampled", true);
    __publicField(this, "status");
    __publicField(this, "attributes");
    __publicField(this, "events", []);
    __publicField(this, "links");
    this.name = name;
    this.parent = parent;
    this.context = context9;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = /* @__PURE__ */ new Map();
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
    this.links = Array.from(links);
  }
  end(endTime, exit4) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit4,
      startTime: this.status.startTime
    };
  }
  attribute(key, value3) {
    this.attributes.set(key, value3);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
  addLinks(links) {
    this.links.push(...links);
  }
};
var nativeTracer = /* @__PURE__ */ make22({
  span: (name, parent, context9, links, startTime, kind) => new NativeSpan(name, parent, context9, links, startTime, kind),
  context: (f) => f()
});
var addSpanStackTrace = (options) => {
  if (options?.captureStackTrace === false) {
    return options;
  } else if (options?.captureStackTrace !== void 0 && typeof options.captureStackTrace !== "boolean") {
    return options;
  }
  const limit2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 3;
  const traceError = new Error();
  Error.stackTraceLimit = limit2;
  let cache = false;
  return {
    ...options,
    captureStackTrace: () => {
      if (cache !== false) {
        return cache;
      }
      if (traceError.stack !== void 0) {
        const stack = traceError.stack.split("\n");
        if (stack[3] !== void 0) {
          cache = stack[3].trim();
          return cache;
        }
      }
    }
  };
};
var DisablePropagation = /* @__PURE__ */ Reference2()("effect/Tracer/DisablePropagation", {
  defaultValue: constFalse
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty2(), /* @__PURE__ */ add2(clockTag, /* @__PURE__ */ make18()), /* @__PURE__ */ add2(consoleTag, defaultConsole), /* @__PURE__ */ add2(randomTag, /* @__PURE__ */ make21(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add2(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add2(tracerTag, nativeTracer));
var currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
var sleep = (duration4) => {
  const decodedDuration = decode(duration4);
  return clockWith((clock3) => clock3.sleep(decodedDuration));
};
var defaultServicesWith = (f) => withFiberRuntime((fiber) => f(fiber.currentDefaultServices));
var clockWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key)));
var currentTimeMillis = /* @__PURE__ */ clockWith((clock3) => clock3.currentTimeMillis);
var currentTimeNanos = /* @__PURE__ */ clockWith((clock3) => clock3.currentTimeNanos);
var withClock = /* @__PURE__ */ dual(2, (effect4, c) => fiberRefLocallyWith(currentServices, add2(clockTag, c))(effect4));
var withConfigProvider = /* @__PURE__ */ dual(2, (self, provider) => fiberRefLocallyWith(currentServices, add2(configProviderTag, provider))(self));
var configProviderWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(configProviderTag.key)));
var config = (config2) => configProviderWith((_) => _.load(config2));
var randomWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(randomTag.key)));
var withRandom = /* @__PURE__ */ dual(2, (effect4, value3) => fiberRefLocallyWith(currentServices, add2(randomTag, value3))(effect4));
var next = /* @__PURE__ */ randomWith((random4) => random4.next);
var tracerWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(tracerTag.key)));
var withTracer = /* @__PURE__ */ dual(2, (effect4, value3) => fiberRefLocallyWith(currentServices, add2(tracerTag, value3))(effect4));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Boolean.js
var not = (self) => !self;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Deferred.js
var make23 = deferredMake;
var _await = deferredAwait;
var done2 = deferredDone;
var fail3 = deferredFail;
var failCause2 = deferredFailCause;
var interrupt3 = deferredInterrupt;
var isDone = deferredIsDone;
var poll = deferredPoll;
var succeed2 = deferredSucceed;
var unsafeMake4 = deferredUnsafeMake;
var unsafeDone = deferredUnsafeDone;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Effectable.js
var EffectPrototype2 = EffectPrototype;
var CommitPrototype2 = CommitPrototype;
var Base2 = Base;
var Class2 = class extends Base2 {
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/executionStrategy.js
var OP_SEQUENTIAL2 = "Sequential";
var OP_PARALLEL2 = "Parallel";
var OP_PARALLEL_N = "ParallelN";
var sequential2 = {
  _tag: OP_SEQUENTIAL2
};
var parallel2 = {
  _tag: OP_PARALLEL2
};
var parallelN = (parallelism) => ({
  _tag: OP_PARALLEL_N,
  parallelism
});
var isSequential = (self) => self._tag === OP_SEQUENTIAL2;
var isParallel = (self) => self._tag === OP_PARALLEL2;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential3 = sequential2;
var parallel3 = parallel2;
var parallelN2 = parallelN;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/fiberRefs.js
function unsafeMake5(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
function empty19() {
  return unsafeMake5(/* @__PURE__ */ new Map());
}
var FiberRefsSym = /* @__PURE__ */ Symbol.for("effect/FiberRefs");
var _a14;
_a14 = FiberRefsSym;
var FiberRefsImpl = class {
  constructor(locals) {
    __publicField(this, "locals");
    __publicField(this, _a14, FiberRefsSym);
    this.locals = locals;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = void 0;
  while (ret === void 0) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty(parentStack)[0];
      const parentAncestors = tailNonEmpty(parentStack);
      const childFiberId = headNonEmpty(childStack)[0];
      const childRefValue = headNonEmpty(childStack)[1];
      const childAncestors = tailNonEmpty(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
};
var joinAs = /* @__PURE__ */ dual(3, (self, fiberId3, that) => {
  const parentFiberRefs = new Map(self.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][symbol2](fiberId3)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId3, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch9 = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch9)(oldValue));
        if (!equals(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[symbol2](fiberId3)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId3, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
var forkAs = /* @__PURE__ */ dual(2, (self, childId) => {
  const map31 = /* @__PURE__ */ new Map();
  unsafeForkAs(self, map31, childId);
  return new FiberRefsImpl(map31);
});
var unsafeForkAs = (self, map31, fiberId3) => {
  self.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals(oldValue, newValue)) {
      map31.set(fiberRef, stack);
    } else {
      map31.set(fiberRef, [[fiberId3, newValue], ...stack]);
    }
  });
};
var fiberRefs = (self) => fromIterable6(self.locals.keys());
var setAll = (self) => forEachSequentialDiscard(fiberRefs(self), (fiberRef) => fiberRefSet(fiberRef, getOrDefault(self, fiberRef)));
var delete_ = /* @__PURE__ */ dual(2, (self, fiberRef) => {
  const locals = new Map(self.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl(locals);
});
var get8 = /* @__PURE__ */ dual(2, (self, fiberRef) => {
  if (!self.locals.has(fiberRef)) {
    return none2();
  }
  return some2(headNonEmpty(self.locals.get(fiberRef))[1]);
});
var getOrDefault = /* @__PURE__ */ dual(2, (self, fiberRef) => pipe(get8(self, fiberRef), getOrElse3(() => fiberRef.initial)));
var updateAs = /* @__PURE__ */ dual(2, (self, {
  fiberId: fiberId3,
  fiberRef,
  value: value3
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(/* @__PURE__ */ new Map([[fiberRef, [[fiberId3, value3]]]]));
  }
  const locals = new Map(self.locals);
  unsafeUpdateAs(locals, fiberId3, fiberRef, value3);
  return new FiberRefsImpl(locals);
});
var unsafeUpdateAs = (locals, fiberId3, fiberRef, value3) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty(oldStack);
    if (currentId[symbol2](fiberId3)) {
      if (equals(currentValue, value3)) {
        return;
      } else {
        newStack = [[fiberId3, value3], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId3, value3], ...oldStack];
    }
  } else {
    newStack = [[fiberId3, value3]];
  }
  locals.set(fiberRef, newStack);
};
var updateManyAs = /* @__PURE__ */ dual(2, (self, {
  entries: entries3,
  forkAs: forkAs2
}) => {
  if (self.locals.size === 0) {
    return new FiberRefsImpl(new Map(entries3));
  }
  const locals = new Map(self.locals);
  if (forkAs2 !== void 0) {
    unsafeForkAs(self, locals, forkAs2);
  }
  entries3.forEach(([fiberRef, values5]) => {
    if (values5.length === 1) {
      unsafeUpdateAs(locals, values5[0][0], fiberRef, values5[0][1]);
    } else {
      values5.forEach(([fiberId3, value3]) => {
        unsafeUpdateAs(locals, fiberId3, fiberRef, value3);
      });
    }
  });
  return new FiberRefsImpl(locals);
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/FiberRefs.js
var get9 = get8;
var getOrDefault2 = getOrDefault;
var joinAs2 = joinAs;
var setAll2 = setAll;
var updateManyAs2 = updateManyAs;
var empty20 = empty19;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/fiberRefs/patch.js
var OP_EMPTY2 = "Empty";
var OP_ADD = "Add";
var OP_REMOVE = "Remove";
var OP_UPDATE = "Update";
var OP_AND_THEN = "AndThen";
var empty21 = {
  _tag: OP_EMPTY2
};
var diff5 = (oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch9 = empty21;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue2 = headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== void 0) {
      const oldValue2 = headNonEmpty(old)[1];
      if (!equals(oldValue2, newValue2)) {
        patch9 = combine7({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue2, newValue2)
        })(patch9);
      }
    } else {
      patch9 = combine7({
        _tag: OP_ADD,
        fiberRef,
        value: newValue2
      })(patch9);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch9 = combine7({
      _tag: OP_REMOVE,
      fiberRef
    })(patch9);
  }
  return patch9;
};
var combine7 = /* @__PURE__ */ dual(2, (self, that) => ({
  _tag: OP_AND_THEN,
  first: self,
  second: that
}));
var patch6 = /* @__PURE__ */ dual(3, (self, fiberId3, oldValue) => {
  let fiberRefs3 = oldValue;
  let patches = of(self);
  while (isNonEmptyReadonlyArray(patches)) {
    const head8 = headNonEmpty(patches);
    const tail2 = tailNonEmpty(patches);
    switch (head8._tag) {
      case OP_EMPTY2: {
        patches = tail2;
        break;
      }
      case OP_ADD: {
        fiberRefs3 = updateAs(fiberRefs3, {
          fiberId: fiberId3,
          fiberRef: head8.fiberRef,
          value: head8.value
        });
        patches = tail2;
        break;
      }
      case OP_REMOVE: {
        fiberRefs3 = delete_(fiberRefs3, head8.fiberRef);
        patches = tail2;
        break;
      }
      case OP_UPDATE: {
        const value3 = getOrDefault(fiberRefs3, head8.fiberRef);
        fiberRefs3 = updateAs(fiberRefs3, {
          fiberId: fiberId3,
          fiberRef: head8.fiberRef,
          value: head8.fiberRef.patch(head8.patch)(value3)
        });
        patches = tail2;
        break;
      }
      case OP_AND_THEN: {
        patches = prepend(head8.first)(prepend(head8.second)(tail2));
        break;
      }
    }
  }
  return fiberRefs3;
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/FiberRefsPatch.js
var diff6 = diff5;
var patch7 = patch6;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/fiberStatus.js
var FiberStatusSymbolKey = "effect/FiberStatus";
var FiberStatusTypeId = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
var OP_DONE = "Done";
var OP_RUNNING = "Running";
var OP_SUSPENDED = "Suspended";
var DoneHash = /* @__PURE__ */ string(`${FiberStatusSymbolKey}-${OP_DONE}`);
var _a15;
var Done = class {
  constructor() {
    __publicField(this, _a15, FiberStatusTypeId);
    __publicField(this, "_tag", OP_DONE);
  }
  [(_a15 = FiberStatusTypeId, symbol)]() {
    return DoneHash;
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
};
var _a16;
var Running = class {
  constructor(runtimeFlags2) {
    __publicField(this, "runtimeFlags");
    __publicField(this, _a16, FiberStatusTypeId);
    __publicField(this, "_tag", OP_RUNNING);
    this.runtimeFlags = runtimeFlags2;
  }
  [(_a16 = FiberStatusTypeId, symbol)]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
};
var _a17;
var Suspended = class {
  constructor(runtimeFlags2, blockingOn) {
    __publicField(this, "runtimeFlags");
    __publicField(this, "blockingOn");
    __publicField(this, _a17, FiberStatusTypeId);
    __publicField(this, "_tag", OP_SUSPENDED);
    this.runtimeFlags = runtimeFlags2;
    this.blockingOn = blockingOn;
  }
  [(_a17 = FiberStatusTypeId, symbol)]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), combine(hash(this.blockingOn)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
  }
};
var done3 = /* @__PURE__ */ new Done();
var running = (runtimeFlags2) => new Running(runtimeFlags2);
var suspended = (runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn);
var isFiberStatus = (u) => hasProperty(u, FiberStatusTypeId);
var isDone2 = (self) => self._tag === OP_DONE;
var isRunning = (self) => self._tag === OP_RUNNING;
var isSuspended = (self) => self._tag === OP_SUSPENDED;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/FiberStatus.js
var done4 = done3;
var running2 = running;
var suspended2 = suspended;
var isDone3 = isDone2;
var isRunning2 = isRunning;
var isSuspended2 = isSuspended;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/LogLevel.js
var All = logLevelAll;
var Fatal = logLevelFatal;
var Error2 = logLevelError;
var Warning = logLevelWarning;
var Info = logLevelInfo;
var Debug = logLevelDebug;
var Trace = logLevelTrace;
var None3 = logLevelNone;
var Order3 = /* @__PURE__ */ pipe(Order2, /* @__PURE__ */ mapInput2((level) => level.ordinal));
var greaterThan3 = /* @__PURE__ */ greaterThan(Order3);
var fromLiteral = (literal2) => {
  switch (literal2) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return Error2;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return None3;
    case "Warning":
      return Warning;
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Micro.js
var TypeId10 = /* @__PURE__ */ Symbol.for("effect/Micro");
var MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
var MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
var microCauseVariance = {
  _E: identity
};
var _a18;
var MicroCauseImpl = class extends globalThis.Error {
  constructor(_tag, originalError, traces) {
    const causeName = `MicroCause.${_tag}`;
    let name;
    let message;
    let stack;
    if (originalError instanceof globalThis.Error) {
      name = `(${causeName}) ${originalError.name}`;
      message = originalError.message;
      const messageLines = message.split("\n").length;
      stack = originalError.stack ? `(${causeName}) ${originalError.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
    } else {
      name = causeName;
      message = toStringUnknown(originalError, 0);
      stack = `${name}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `
    ${traces.join("\n    ")}`;
    }
    super(message);
    __publicField(this, "_tag");
    __publicField(this, "traces");
    __publicField(this, _a18);
    this._tag = _tag;
    this.traces = traces;
    this[MicroCauseTypeId] = microCauseVariance;
    this.name = name;
    this.stack = stack;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [(_a18 = MicroCauseTypeId, NodeInspectSymbol)]() {
    return this.stack;
  }
};
var Die = class extends MicroCauseImpl {
  constructor(defect, traces = []) {
    super("Die", defect, traces);
    __publicField(this, "defect");
    this.defect = defect;
  }
};
var causeDie = (defect, traces = []) => new Die(defect, traces);
var Interrupt = class extends MicroCauseImpl {
  constructor(traces = []) {
    super("Interrupt", "interrupted", traces);
  }
};
var causeInterrupt = (traces = []) => new Interrupt(traces);
var causeIsInterrupt = (self) => self._tag === "Interrupt";
var MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
var fiberVariance = {
  _A: identity,
  _E: identity
};
var _a19;
_a19 = MicroFiberTypeId;
var MicroFiberImpl = class {
  constructor(context9, interruptible5 = true) {
    __publicField(this, "context");
    __publicField(this, "interruptible");
    __publicField(this, _a19);
    __publicField(this, "_stack", []);
    __publicField(this, "_observers", []);
    __publicField(this, "_exit");
    __publicField(this, "_children");
    __publicField(this, "currentOpCount", 0);
    __publicField(this, "_interrupted", false);
    // cancel the yielded operation, or for the yielded exit value
    __publicField(this, "_yielded");
    this.context = context9;
    this.interruptible = interruptible5;
    this[MicroFiberTypeId] = fiberVariance;
  }
  getRef(ref) {
    return unsafeGetReference(this.context, ref);
  }
  addObserver(cb) {
    if (this._exit) {
      cb(this._exit);
      return constVoid;
    }
    this._observers.push(cb);
    return () => {
      const index = this._observers.indexOf(cb);
      if (index >= 0) {
        this._observers.splice(index, 1);
      }
    };
  }
  unsafeInterrupt() {
    if (this._exit) {
      return;
    }
    this._interrupted = true;
    if (this.interruptible) {
      this.evaluate(exitInterrupt2);
    }
  }
  unsafePoll() {
    return this._exit;
  }
  evaluate(effect4) {
    if (this._exit) {
      return;
    } else if (this._yielded !== void 0) {
      const yielded = this._yielded;
      this._yielded = void 0;
      yielded();
    }
    const exit4 = this.runLoop(effect4);
    if (exit4 === Yield) {
      return;
    }
    const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
    if (interruptChildren !== void 0) {
      return this.evaluate(flatMap10(interruptChildren, () => exit4));
    }
    this._exit = exit4;
    for (let i = 0; i < this._observers.length; i++) {
      this._observers[i](exit4);
    }
    this._observers.length = 0;
  }
  runLoop(effect4) {
    let yielding = false;
    let current2 = effect4;
    this.currentOpCount = 0;
    try {
      while (true) {
        this.currentOpCount++;
        if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
          yielding = true;
          const prev = current2;
          current2 = flatMap10(yieldNow2, () => prev);
        }
        current2 = current2[evaluate](this);
        if (current2 === Yield) {
          const yielded = this._yielded;
          if (MicroExitTypeId in yielded) {
            this._yielded = void 0;
            return yielded;
          }
          return Yield;
        }
      }
    } catch (error2) {
      if (!hasProperty(current2, evaluate)) {
        return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current2)}`);
      }
      return exitDie2(error2);
    }
  }
  getCont(symbol4) {
    while (true) {
      const op = this._stack.pop();
      if (!op) return void 0;
      const cont = op[ensureCont] && op[ensureCont](this);
      if (cont) return {
        [symbol4]: cont
      };
      if (op[symbol4]) return op;
    }
  }
  yieldWith(value3) {
    this._yielded = value3;
    return Yield;
  }
  children() {
    return this._children ?? (this._children = /* @__PURE__ */ new Set());
  }
};
var fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({
  interruptChildren: void 0
}));
var fiberInterruptAll = (fibers) => suspend2(() => {
  for (const fiber of fibers) fiber.unsafeInterrupt();
  const iter = fibers[Symbol.iterator]();
  const wait = suspend2(() => {
    let result = iter.next();
    while (!result.done) {
      if (result.value.unsafePoll()) {
        result = iter.next();
        continue;
      }
      const fiber = result.value;
      return async((resume2) => {
        fiber.addObserver((_) => {
          resume2(wait);
        });
      });
    }
    return exitVoid2;
  });
  return wait;
});
var identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
var args = /* @__PURE__ */ Symbol.for("effect/Micro/args");
var evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
var successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
var failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
var ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
var Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
var microVariance = {
  _A: identity,
  _E: identity,
  _R: identity
};
var MicroProto = {
  ...EffectPrototype2,
  _op: "Micro",
  [TypeId10]: microVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  toJSON() {
    return {
      _id: "Micro",
      op: this[identifier],
      ...args in this ? {
        args: this[args]
      } : void 0
    };
  },
  toString() {
    return format(this);
  },
  [NodeInspectSymbol]() {
    return format(this);
  }
};
function defaultEvaluate(_fiber) {
  return exitDie2(`Micro.evaluate: Not implemented`);
}
var makePrimitiveProto = (options) => ({
  ...MicroProto,
  [identifier]: options.op,
  [evaluate]: options.eval ?? defaultEvaluate,
  [successCont]: options.contA,
  [failureCont]: options.contE,
  [ensureCont]: options.ensure
});
var makePrimitive = (options) => {
  const Proto4 = makePrimitiveProto(options);
  return function() {
    const self = Object.create(Proto4);
    self[args] = options.single === false ? arguments : arguments[0];
    return self;
  };
};
var makeExit = (options) => {
  const Proto4 = {
    ...makePrimitiveProto(options),
    [MicroExitTypeId]: MicroExitTypeId,
    _tag: options.op,
    get [options.prop]() {
      return this[args];
    },
    toJSON() {
      return {
        _id: "MicroExit",
        _tag: options.op,
        [options.prop]: this[args]
      };
    },
    [symbol2](that) {
      return isMicroExit(that) && that._tag === options.op && equals(this[args], that[args]);
    },
    [symbol]() {
      return cached(this, combine(string(options.op))(hash(this[args])));
    }
  };
  return function(value3) {
    const self = Object.create(Proto4);
    self[args] = value3;
    self[successCont] = void 0;
    self[failureCont] = void 0;
    self[ensureCont] = void 0;
    return self;
  };
};
var succeed3 = /* @__PURE__ */ makeExit({
  op: "Success",
  prop: "value",
  eval(fiber) {
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var failCause3 = /* @__PURE__ */ makeExit({
  op: "Failure",
  prop: "cause",
  eval(fiber) {
    let cont = fiber.getCont(failureCont);
    while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
      cont = fiber.getCont(failureCont);
    }
    return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var sync2 = /* @__PURE__ */ makePrimitive({
  op: "Sync",
  eval(fiber) {
    const value3 = this[args]();
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](value3, fiber) : fiber.yieldWith(exitSucceed2(value3));
  }
});
var suspend2 = /* @__PURE__ */ makePrimitive({
  op: "Suspend",
  eval(_fiber) {
    return this[args]();
  }
});
var yieldNowWith = /* @__PURE__ */ makePrimitive({
  op: "Yield",
  eval(fiber) {
    let resumed = false;
    fiber.getRef(CurrentScheduler).scheduleTask(() => {
      if (resumed) return;
      fiber.evaluate(exitVoid2);
    }, this[args] ?? 0);
    return fiber.yieldWith(() => {
      resumed = true;
    });
  }
});
var yieldNow2 = /* @__PURE__ */ yieldNowWith(0);
var void_3 = /* @__PURE__ */ succeed3(void 0);
var withMicroFiber = /* @__PURE__ */ makePrimitive({
  op: "WithMicroFiber",
  eval(fiber) {
    return this[args](fiber);
  }
});
var asyncOptions = /* @__PURE__ */ makePrimitive({
  op: "Async",
  single: false,
  eval(fiber) {
    const register = this[args][0];
    let resumed = false;
    let yielded = false;
    const controller = this[args][1] ? new AbortController() : void 0;
    const onCancel = register((effect4) => {
      if (resumed) return;
      resumed = true;
      if (yielded) {
        fiber.evaluate(effect4);
      } else {
        yielded = effect4;
      }
    }, controller?.signal);
    if (yielded !== false) return yielded;
    yielded = true;
    fiber._yielded = () => {
      resumed = true;
    };
    if (controller === void 0 && onCancel === void 0) {
      return Yield;
    }
    fiber._stack.push(asyncFinalizer(() => {
      resumed = true;
      controller?.abort();
      return onCancel ?? exitVoid2;
    }));
    return Yield;
  }
});
var asyncFinalizer = /* @__PURE__ */ makePrimitive({
  op: "AsyncFinalizer",
  ensure(fiber) {
    if (fiber.interruptible) {
      fiber.interruptible = false;
      fiber._stack.push(setInterruptible(true));
    }
  },
  contE(cause3, _fiber) {
    return causeIsInterrupt(cause3) ? flatMap10(this[args](), () => failCause3(cause3)) : failCause3(cause3);
  }
});
var async = (register) => asyncOptions(register, register.length >= 2);
var as3 = /* @__PURE__ */ dual(2, (self, value3) => map11(self, (_) => value3));
var exit2 = (self) => matchCause2(self, {
  onFailure: exitFailCause2,
  onSuccess: exitSucceed2
});
var flatMap10 = /* @__PURE__ */ dual(2, (self, f) => {
  const onSuccess = Object.create(OnSuccessProto);
  onSuccess[args] = self;
  onSuccess[successCont] = f;
  return onSuccess;
});
var OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccess",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var map11 = /* @__PURE__ */ dual(2, (self, f) => flatMap10(self, (a) => succeed3(f(a))));
var isMicroExit = (u) => hasProperty(u, MicroExitTypeId);
var exitSucceed2 = succeed3;
var exitFailCause2 = failCause3;
var exitInterrupt2 = /* @__PURE__ */ exitFailCause2(/* @__PURE__ */ causeInterrupt());
var exitDie2 = (defect) => exitFailCause2(causeDie(defect));
var exitVoid2 = /* @__PURE__ */ exitSucceed2(void 0);
var exitVoidAll = (exits) => {
  for (const exit4 of exits) {
    if (exit4._tag === "Failure") {
      return exit4;
    }
  }
  return exitVoid2;
};
var setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);
var MicroSchedulerDefault = class {
  constructor() {
    __publicField(this, "tasks", []);
    __publicField(this, "running", false);
    /**
     * @since 3.5.9
     */
    __publicField(this, "afterScheduled", () => {
      this.running = false;
      this.runTasks();
    });
  }
  /**
   * @since 3.5.9
   */
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate(this.afterScheduled);
    }
  }
  /**
   * @since 3.5.9
   */
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i = 0, len = tasks.length; i < len; i++) {
      tasks[i]();
    }
  }
  /**
   * @since 3.5.9
   */
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
  }
  /**
   * @since 3.5.9
   */
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
};
var updateContext = /* @__PURE__ */ dual(2, (self, f) => withMicroFiber((fiber) => {
  const prev = fiber.context;
  fiber.context = f(prev);
  return onExit2(self, () => {
    fiber.context = prev;
    return void_3;
  });
}));
var provideContext2 = /* @__PURE__ */ dual(2, (self, provided) => updateContext(self, merge2(provided)));
var MaxOpsBeforeYield = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
  defaultValue: () => 2048
})) {
};
var CurrentConcurrency = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentConcurrency", {
  defaultValue: () => "unbounded"
})) {
};
var CurrentScheduler = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentScheduler", {
  defaultValue: () => new MicroSchedulerDefault()
})) {
};
var matchCauseEffect2 = /* @__PURE__ */ dual(2, (self, options) => {
  const primitive2 = Object.create(OnSuccessAndFailureProto);
  primitive2[args] = self;
  primitive2[successCont] = options.onSuccess;
  primitive2[failureCont] = options.onFailure;
  return primitive2;
});
var OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccessAndFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var matchCause2 = /* @__PURE__ */ dual(2, (self, options) => matchCauseEffect2(self, {
  onFailure: (cause3) => sync2(() => options.onFailure(cause3)),
  onSuccess: (value3) => sync2(() => options.onSuccess(value3))
}));
var MicroScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroScope");
var _a20;
_a20 = MicroScopeTypeId;
var _MicroScopeImpl = class _MicroScopeImpl {
  constructor() {
    __publicField(this, _a20);
    __publicField(this, "state", {
      _tag: "Open",
      finalizers: /* @__PURE__ */ new Set()
    });
    this[MicroScopeTypeId] = MicroScopeTypeId;
  }
  unsafeAddFinalizer(finalizer3) {
    if (this.state._tag === "Open") {
      this.state.finalizers.add(finalizer3);
    }
  }
  addFinalizer(finalizer3) {
    return suspend2(() => {
      if (this.state._tag === "Open") {
        this.state.finalizers.add(finalizer3);
        return void_3;
      }
      return finalizer3(this.state.exit);
    });
  }
  unsafeRemoveFinalizer(finalizer3) {
    if (this.state._tag === "Open") {
      this.state.finalizers.delete(finalizer3);
    }
  }
  close(microExit) {
    return suspend2(() => {
      if (this.state._tag === "Open") {
        const finalizers = Array.from(this.state.finalizers).reverse();
        this.state = {
          _tag: "Closed",
          exit: microExit
        };
        return flatMap10(forEach6(finalizers, (finalizer3) => exit2(finalizer3(microExit))), exitVoidAll);
      }
      return void_3;
    });
  }
  get fork() {
    return sync2(() => {
      const newScope = new _MicroScopeImpl();
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      function fin(exit4) {
        return newScope.close(exit4);
      }
      this.state.finalizers.add(fin);
      newScope.unsafeAddFinalizer((_) => sync2(() => this.unsafeRemoveFinalizer(fin)));
      return newScope;
    });
  }
};
var MicroScopeImpl = _MicroScopeImpl;
var onExit2 = /* @__PURE__ */ dual(2, (self, f) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self), {
  onFailure: (cause3) => flatMap10(f(exitFailCause2(cause3)), () => failCause3(cause3)),
  onSuccess: (a) => flatMap10(f(exitSucceed2(a)), () => succeed3(a))
})));
var setInterruptible = /* @__PURE__ */ makePrimitive({
  op: "SetInterruptible",
  ensure(fiber) {
    fiber.interruptible = this[args];
    if (fiber._interrupted && fiber.interruptible) {
      return () => exitInterrupt2;
    }
  }
});
var interruptible3 = (self) => withMicroFiber((fiber) => {
  if (fiber.interruptible) return self;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible(false));
  if (fiber._interrupted) return exitInterrupt2;
  return self;
});
var uninterruptibleMask2 = (f) => withMicroFiber((fiber) => {
  if (!fiber.interruptible) return f(identity);
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return f(interruptible3);
});
var whileLoop2 = /* @__PURE__ */ makePrimitive({
  op: "While",
  contA(value3, fiber) {
    this[args].step(value3);
    if (this[args].while()) {
      fiber._stack.push(this);
      return this[args].body();
    }
    return exitVoid2;
  },
  eval(fiber) {
    if (this[args].while()) {
      fiber._stack.push(this);
      return this[args].body();
    }
    return exitVoid2;
  }
});
var forEach6 = (iterable, f, options) => withMicroFiber((parent) => {
  const concurrencyOption = options?.concurrency === "inherit" ? parent.getRef(CurrentConcurrency) : options?.concurrency ?? 1;
  const concurrency = concurrencyOption === "unbounded" ? Number.POSITIVE_INFINITY : Math.max(1, concurrencyOption);
  const items = fromIterable2(iterable);
  let length5 = items.length;
  if (length5 === 0) {
    return options?.discard ? void_3 : succeed3([]);
  }
  const out = options?.discard ? void 0 : new Array(length5);
  let index = 0;
  if (concurrency === 1) {
    return as3(whileLoop2({
      while: () => index < items.length,
      body: () => f(items[index], index),
      step: out ? (b) => out[index++] = b : (_) => index++
    }), out);
  }
  return async((resume2) => {
    const fibers = /* @__PURE__ */ new Set();
    let result = void 0;
    let inProgress = 0;
    let doneCount = 0;
    let pumping = false;
    let interrupted4 = false;
    function pump() {
      pumping = true;
      while (inProgress < concurrency && index < length5) {
        const currentIndex = index;
        const item = items[currentIndex];
        index++;
        inProgress++;
        try {
          const child = unsafeFork(parent, f(item, currentIndex), true, true);
          fibers.add(child);
          child.addObserver((exit4) => {
            fibers.delete(child);
            if (interrupted4) {
              return;
            } else if (exit4._tag === "Failure") {
              if (result === void 0) {
                result = exit4;
                length5 = index;
                fibers.forEach((fiber) => fiber.unsafeInterrupt());
              }
            } else if (out !== void 0) {
              out[currentIndex] = exit4.value;
            }
            doneCount++;
            inProgress--;
            if (doneCount === length5) {
              resume2(result ?? succeed3(out));
            } else if (!pumping && inProgress < concurrency) {
              pump();
            }
          });
        } catch (err) {
          result = exitDie2(err);
          length5 = index;
          fibers.forEach((fiber) => fiber.unsafeInterrupt());
        }
      }
      pumping = false;
    }
    pump();
    return suspend2(() => {
      interrupted4 = true;
      index = length5;
      return fiberInterruptAll(fibers);
    });
  });
});
var unsafeFork = (parent, effect4, immediate = false, daemon = false) => {
  const child = new MicroFiberImpl(parent.context, parent.interruptible);
  if (!daemon) {
    parent.children().add(child);
    child.addObserver(() => parent.children().delete(child));
  }
  if (immediate) {
    child.evaluate(effect4);
  } else {
    parent.getRef(CurrentScheduler).scheduleTask(() => child.evaluate(effect4), 0);
  }
  return child;
};
var runFork = (effect4, options) => {
  const fiber = new MicroFiberImpl(CurrentScheduler.context(options?.scheduler ?? new MicroSchedulerDefault()));
  fiber.evaluate(effect4);
  if (options?.signal) {
    if (options.signal.aborted) {
      fiber.unsafeInterrupt();
    } else {
      const abort = () => fiber.unsafeInterrupt();
      options.signal.addEventListener("abort", abort, {
        once: true
      });
      fiber.addObserver(() => options.signal.removeEventListener("abort", abort));
    }
  }
  return fiber;
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Ref.js
var Ref_exports = {};
__export(Ref_exports, {
  RefTypeId: () => RefTypeId2,
  get: () => get11,
  getAndSet: () => getAndSet2,
  getAndUpdate: () => getAndUpdate2,
  getAndUpdateSome: () => getAndUpdateSome2,
  make: () => make25,
  modify: () => modify6,
  modifySome: () => modifySome2,
  set: () => set5,
  setAndGet: () => setAndGet2,
  unsafeMake: () => unsafeMake7,
  update: () => update3,
  updateAndGet: () => updateAndGet2,
  updateSome: () => updateSome2,
  updateSomeAndGet: () => updateSomeAndGet2
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Readable.js
var TypeId11 = /* @__PURE__ */ Symbol.for("effect/Readable");
var Proto = {
  [TypeId11]: TypeId11,
  pipe() {
    return pipeArguments(this, arguments);
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/ref.js
var RefTypeId = /* @__PURE__ */ Symbol.for("effect/Ref");
var refVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a21, _b, _c;
var RefImpl = class extends (_c = Class2, _b = RefTypeId, _a21 = TypeId11, _c) {
  constructor(ref) {
    super();
    __publicField(this, "ref");
    __publicField(this, _b, refVariance);
    __publicField(this, _a21, TypeId11);
    __publicField(this, "get");
    this.ref = ref;
    this.get = sync(() => get6(this.ref));
  }
  commit() {
    return this.get;
  }
  modify(f) {
    return sync(() => {
      const current2 = get6(this.ref);
      const [b, a] = f(current2);
      if (current2 !== a) {
        set2(a)(this.ref);
      }
      return b;
    });
  }
};
var unsafeMake6 = (value3) => new RefImpl(make12(value3));
var make24 = (value3) => sync(() => unsafeMake6(value3));
var get10 = (self) => self.get;
var set4 = /* @__PURE__ */ dual(2, (self, value3) => self.modify(() => [void 0, value3]));
var getAndSet = /* @__PURE__ */ dual(2, (self, value3) => self.modify((a) => [a, value3]));
var getAndUpdate = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => [a, f(a)]));
var getAndUpdateSome = /* @__PURE__ */ dual(2, (self, pf) => self.modify((value3) => {
  const option5 = pf(value3);
  switch (option5._tag) {
    case "None": {
      return [value3, value3];
    }
    case "Some": {
      return [value3, option5.value];
    }
  }
}));
var setAndGet = /* @__PURE__ */ dual(2, (self, value3) => self.modify(() => [value3, value3]));
var modify5 = /* @__PURE__ */ dual(2, (self, f) => self.modify(f));
var modifySome = /* @__PURE__ */ dual(3, (self, fallback, pf) => self.modify((value3) => {
  const option5 = pf(value3);
  switch (option5._tag) {
    case "None": {
      return [fallback, value3];
    }
    case "Some": {
      return option5.value;
    }
  }
}));
var update2 = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => [void 0, f(a)]));
var updateAndGet = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => {
  const result = f(a);
  return [result, result];
}));
var updateSome = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => [void 0, match2(f(a), {
  onNone: () => a,
  onSome: (b) => b
})]));
var updateSomeAndGet = /* @__PURE__ */ dual(2, (self, pf) => self.modify((value3) => {
  const option5 = pf(value3);
  switch (option5._tag) {
    case "None": {
      return [value3, value3];
    }
    case "Some": {
      return [option5.value, option5.value];
    }
  }
}));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Ref.js
var RefTypeId2 = RefTypeId;
var make25 = make24;
var get11 = get10;
var getAndSet2 = getAndSet;
var getAndUpdate2 = getAndUpdate;
var getAndUpdateSome2 = getAndUpdateSome;
var modify6 = modify5;
var modifySome2 = modifySome;
var set5 = set4;
var setAndGet2 = setAndGet;
var update3 = update2;
var updateAndGet2 = updateAndGet;
var updateSome2 = updateSome;
var updateSomeAndGet2 = updateSomeAndGet;
var unsafeMake7 = unsafeMake6;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Scheduler.js
var PriorityBuckets = class {
  constructor() {
    /**
     * @since 2.0.0
     */
    __publicField(this, "buckets", []);
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    const length5 = this.buckets.length;
    let bucket = void 0;
    let index = 0;
    for (; index < length5; index++) {
      if (this.buckets[index][0] <= priority) {
        bucket = this.buckets[index];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index === length5) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index, 0, [priority, [task]]);
    }
  }
};
var MixedScheduler = class {
  constructor(maxNextTickBeforeTimer) {
    __publicField(this, "maxNextTickBeforeTimer");
    /**
     * @since 2.0.0
     */
    __publicField(this, "running", false);
    /**
     * @since 2.0.0
     */
    __publicField(this, "tasks", /* @__PURE__ */ new PriorityBuckets());
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  /**
   * @since 2.0.0
   */
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  /**
   * @since 2.0.0
   */
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
};
var defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
var SyncScheduler = class {
  constructor() {
    /**
     * @since 2.0.0
     */
    __publicField(this, "tasks", /* @__PURE__ */ new PriorityBuckets());
    /**
     * @since 2.0.0
     */
    __publicField(this, "deferred", false);
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0; i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
};
var currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
var withScheduler = /* @__PURE__ */ dual(2, (self, scheduler2) => fiberRefLocally(self, currentScheduler, scheduler2));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/completedRequestMap.js
var currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(/* @__PURE__ */ new Map()));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/concurrency.js
var match7 = (concurrency, sequential5, unbounded8, bounded8) => {
  switch (concurrency) {
    case void 0:
      return sequential5();
    case "unbounded":
      return unbounded8();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded8() : concurrency2 > 1 ? bounded8(concurrency2) : sequential5());
    default:
      return concurrency > 1 ? bounded8(concurrency) : sequential5();
  }
};
var matchSimple = (concurrency, sequential5, concurrent) => {
  switch (concurrency) {
    case void 0:
      return sequential5();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential5());
    default:
      return concurrency > 1 ? concurrent() : sequential5();
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Clock.js
var sleep2 = sleep;
var currentTimeMillis2 = currentTimeMillis;
var currentTimeNanos2 = currentTimeNanos;
var clockWith2 = clockWith;
var Clock = clockTag;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/logSpan.js
var make26 = (label, startTime) => ({
  label,
  startTime
});
var formatLabel = (key) => key.replace(/[\s="]/g, "_");
var render = (now2) => (self) => {
  const label = formatLabel(self.label);
  return `${label}=${now2 - self.startTime}ms`;
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/LogSpan.js
var make27 = make26;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Tracer.js
var tracerWith2 = tracerWith;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/metric/label.js
var MetricLabelSymbolKey = "effect/MetricLabel";
var MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);
var _a22;
var MetricLabelImpl = class {
  constructor(key, value3) {
    __publicField(this, "key");
    __publicField(this, "value");
    __publicField(this, _a22, MetricLabelTypeId);
    __publicField(this, "_hash");
    this.key = key;
    this.value = value3;
    this._hash = string(MetricLabelSymbolKey + this.key + this.value);
  }
  [(_a22 = MetricLabelTypeId, symbol)]() {
    return this._hash;
  }
  [symbol2](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make28 = (key, value3) => {
  return new MetricLabelImpl(key, value3);
};
var isMetricLabel = (u) => hasProperty(u, MetricLabelTypeId);

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations5) => Object.entries(args2[1]).reduce((acc, [key, value3]) => set3(acc, key, value3), annotations5));
});
var asSome = (self) => map10(self, some2);
var asSomeError = (self) => mapError(self, some2);
var try_2 = (arg) => {
  let evaluate3;
  let onFailure = void 0;
  if (typeof arg === "function") {
    evaluate3 = arg;
  } else {
    evaluate3 = arg.try;
    onFailure = arg.catch;
  }
  return suspend(() => {
    try {
      return succeed(internalCall(evaluate3));
    } catch (error2) {
      return fail2(onFailure ? internalCall(() => onFailure(error2)) : new UnknownException(error2, "An unknown error occurred in Effect.try"));
    }
  });
};
var _catch = /* @__PURE__ */ dual(3, (self, tag3, options) => catchAll(self, (e) => {
  if (hasProperty(e, tag3) && e[tag3] === options.failure) {
    return options.onFailure(e);
  }
  return fail2(e);
}));
var catchAllDefect = /* @__PURE__ */ dual(2, (self, f) => catchAllCause(self, (cause3) => {
  const option5 = find(cause3, (_) => isDieType(_) ? some2(_) : none2());
  switch (option5._tag) {
    case "None": {
      return failCause(cause3);
    }
    case "Some": {
      return f(option5.value.defect);
    }
  }
}));
var catchSomeCause = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const option5 = f(cause3);
    switch (option5._tag) {
      case "None": {
        return failCause(cause3);
      }
      case "Some": {
        return option5.value;
      }
    }
  },
  onSuccess: succeed
}));
var catchSomeDefect = /* @__PURE__ */ dual(2, (self, pf) => catchAllCause(self, (cause3) => {
  const option5 = find(cause3, (_) => isDieType(_) ? some2(_) : none2());
  switch (option5._tag) {
    case "None": {
      return failCause(cause3);
    }
    case "Some": {
      const optionEffect = pf(option5.value.defect);
      return optionEffect._tag === "Some" ? optionEffect.value : failCause(cause3);
    }
  }
}));
var catchTag = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self, ...args2) => {
  const f = args2[args2.length - 1];
  let predicate;
  if (args2.length === 2) {
    predicate = isTagged(args2[0]);
  } else {
    predicate = (e) => {
      const tag3 = hasProperty(e, "_tag") ? e["_tag"] : void 0;
      if (!tag3) return false;
      for (let i = 0; i < args2.length - 1; i++) {
        if (args2[i] === tag3) return true;
      }
      return false;
    };
  }
  return catchIf(self, predicate, f);
});
var catchTags = /* @__PURE__ */ dual(2, (self, cases) => {
  let keys6;
  return catchIf(self, (e) => {
    keys6 ?? (keys6 = Object.keys(cases));
    return hasProperty(e, "_tag") && isString(e["_tag"]) && keys6.includes(e["_tag"]);
  }, (e) => cases[e["_tag"]](e));
});
var cause = (self) => matchCause(self, {
  onFailure: identity,
  onSuccess: () => empty9
});
var clockWith3 = clockWith2;
var clock = /* @__PURE__ */ clockWith3(succeed);
var delay = /* @__PURE__ */ dual(2, (self, duration4) => zipRight2(sleep2(duration4), self));
var descriptorWith = (f) => withFiberRuntime((state, status3) => f({
  id: state.id(),
  status: status3,
  interruptors: interruptors(state.getFiberRef(currentInterruptedCause))
}));
var allowInterrupt = /* @__PURE__ */ descriptorWith((descriptor3) => size4(descriptor3.interruptors) > 0 ? interrupt2 : void_2);
var descriptor = /* @__PURE__ */ descriptorWith(succeed);
var diffFiberRefs = (self) => summarized(self, fiberRefs2, diff5);
var diffFiberRefsAndRuntimeFlags = (self) => summarized(self, zip3(fiberRefs2, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff5(refs, refsNew), diff4(flags, flagsNew)]);
var Do2 = /* @__PURE__ */ succeed({});
var bind3 = /* @__PURE__ */ bind(map10, flatMap9);
var bindTo3 = /* @__PURE__ */ bindTo(map10);
var let_3 = /* @__PURE__ */ let_(map10);
var dropUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next4;
  let dropping7 = succeed(false);
  let i = 0;
  while ((next4 = iterator.next()) && !next4.done) {
    const a = next4.value;
    const index = i++;
    dropping7 = flatMap9(dropping7, (bool2) => {
      if (bool2) {
        builder.push(a);
        return succeed(true);
      }
      return predicate(a, index);
    });
  }
  return map10(dropping7, () => builder);
}));
var dropWhile2 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next4;
  let dropping7 = succeed(true);
  let i = 0;
  while ((next4 = iterator.next()) && !next4.done) {
    const a = next4.value;
    const index = i++;
    dropping7 = flatMap9(dropping7, (d) => map10(d ? predicate(a, index) : succeed(false), (b) => {
      if (!b) {
        builder.push(a);
      }
      return b;
    }));
  }
  return map10(dropping7, () => builder);
}));
var contextWith = (f) => map10(context(), f);
var eventually = (self) => orElse2(self, () => flatMap9(yieldNow(), () => eventually(self)));
var filterMap7 = /* @__PURE__ */ dual(2, (elements, pf) => map10(forEachSequential(elements, identity), filterMap3(pf)));
var filterOrDie = /* @__PURE__ */ dual(3, (self, predicate, orDieWith6) => filterOrElse(self, predicate, (a) => dieSync(() => orDieWith6(a))));
var filterOrDieMessage = /* @__PURE__ */ dual(3, (self, predicate, message) => filterOrElse(self, predicate, () => dieMessage(message)));
var filterOrElse = /* @__PURE__ */ dual(3, (self, predicate, orElse15) => flatMap9(self, (a) => predicate(a) ? succeed(a) : orElse15(a)));
var liftPredicate2 = /* @__PURE__ */ dual(3, (self, predicate, orFailWith) => suspend(() => predicate(self) ? succeed(self) : fail2(orFailWith(self))));
var filterOrFail = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self, predicate, orFailWith) => filterOrElse(self, predicate, (a) => orFailWith === void 0 ? fail2(new NoSuchElementException()) : failSync(() => orFailWith(a))));
var findFirst6 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const next4 = iterator.next();
  if (!next4.done) {
    return findLoop(iterator, 0, predicate, next4.value);
  }
  return succeed(none2());
}));
var findLoop = (iterator, index, f, value3) => flatMap9(f(value3, index), (result) => {
  if (result) {
    return succeed(some2(value3));
  }
  const next4 = iterator.next();
  if (!next4.done) {
    return findLoop(iterator, index + 1, f, next4.value);
  }
  return succeed(none2());
});
var firstSuccessOf = (effects) => suspend(() => {
  const list = fromIterable3(effects);
  if (!isNonEmpty(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  return pipe(tailNonEmpty2(list), reduce(headNonEmpty2(list), (left3, right3) => orElse2(left3, () => right3)));
});
var flipWith = /* @__PURE__ */ dual(2, (self, f) => flip(f(flip(self))));
var match8 = /* @__PURE__ */ dual(2, (self, options) => matchEffect(self, {
  onFailure: (e) => succeed(options.onFailure(e)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var every7 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));
var forAllLoop = (iterator, index, f) => {
  const next4 = iterator.next();
  return next4.done ? succeed(true) : flatMap9(f(next4.value, index), (b) => b ? forAllLoop(iterator, index + 1, f) : succeed(b));
};
var forever = (self) => {
  const loop3 = flatMap9(flatMap9(self, () => yieldNow()), () => loop3);
  return loop3;
};
var fiberRefs2 = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.getFiberRefs()));
var head3 = (self) => flatMap9(self, (as13) => {
  const iterator = as13[Symbol.iterator]();
  const next4 = iterator.next();
  if (next4.done) {
    return fail2(new NoSuchElementException());
  }
  return succeed(next4.value);
});
var ignore = (self) => match8(self, {
  onFailure: constVoid,
  onSuccess: constVoid
});
var ignoreLogged = (self) => matchCauseEffect(self, {
  onFailure: (cause3) => logDebug(cause3, "An error was silently ignored because it is not anticipated to be useful"),
  onSuccess: () => void_2
});
var inheritFiberRefs = (childFiberRefs) => updateFiberRefs((parentFiberId, parentFiberRefs) => joinAs2(parentFiberRefs, parentFiberId, childFiberRefs));
var isFailure = (self) => match8(self, {
  onFailure: constTrue,
  onSuccess: constFalse
});
var isSuccess = (self) => match8(self, {
  onFailure: constFalse,
  onSuccess: constTrue
});
var iterate = (initial, options) => suspend(() => {
  if (options.while(initial)) {
    return flatMap9(options.body(initial), (z2) => iterate(z2, options));
  }
  return succeed(initial);
});
var logWithLevel = (level) => (...message) => {
  const levelOption = fromNullable(level);
  let cause3 = void 0;
  for (let i = 0, len = message.length; i < len; i++) {
    const msg = message[i];
    if (isCause(msg)) {
      if (cause3 !== void 0) {
        cause3 = sequential(cause3, msg);
      } else {
        cause3 = msg;
      }
      message = [...message.slice(0, i), ...message.slice(i + 1)];
      i--;
    }
  }
  if (cause3 === void 0) {
    cause3 = empty9;
  }
  return withFiberRuntime((fiberState) => {
    fiberState.log(message, cause3, levelOption);
    return void_2;
  });
};
var log = /* @__PURE__ */ logWithLevel();
var logTrace = /* @__PURE__ */ logWithLevel(Trace);
var logDebug = /* @__PURE__ */ logWithLevel(Debug);
var logInfo = /* @__PURE__ */ logWithLevel(Info);
var logWarning = /* @__PURE__ */ logWithLevel(Warning);
var logError = /* @__PURE__ */ logWithLevel(Error2);
var logFatal = /* @__PURE__ */ logWithLevel(Fatal);
var withLogSpan = /* @__PURE__ */ dual(2, (effect4, label) => flatMap9(currentTimeMillis2, (now2) => fiberRefLocallyWith(effect4, currentLogSpan, prepend3(make27(label, now2)))));
var logAnnotations = /* @__PURE__ */ fiberRefGet(currentLogAnnotations);
var loop = (initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : map10(loopInternal(initial, options.while, options.step, options.body), fromIterable2);
var loopInternal = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap9(body(initial), (a) => map10(loopInternal(inc(initial), cont, inc, body), prepend3(a))) : sync(() => empty11()));
var loopDiscard = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap9(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : void_2);
var mapAccum3 = /* @__PURE__ */ dual(3, (elements, initial, f) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let result = succeed(initial);
  let next4;
  let i = 0;
  while (!(next4 = iterator.next()).done) {
    const index = i++;
    const value3 = next4.value;
    result = flatMap9(result, (state) => map10(f(state, value3, index), ([z, b]) => {
      builder.push(b);
      return z;
    }));
  }
  return map10(result, (z) => [z, builder]);
}));
var mapErrorCause = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (c) => failCauseSync(() => f(c)),
  onSuccess: succeed
}));
var memoize = (self) => pipe(deferredMake(), flatMap9((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self), intoDeferred(deferred), once, map10((complete3) => zipRight2(complete3, pipe(deferredAwait(deferred), flatMap9(([patch9, a]) => as2(zip3(patchFiberRefs(patch9[0]), updateRuntimeFlags(patch9[1])), a))))))));
var merge5 = (self) => matchEffect(self, {
  onFailure: (e) => succeed(e),
  onSuccess: succeed
});
var negate = (self) => map10(self, (b) => !b);
var none6 = (self) => flatMap9(self, (option5) => {
  switch (option5._tag) {
    case "None":
      return void_2;
    case "Some":
      return fail2(new NoSuchElementException());
  }
});
var once = (self) => map10(make25(true), (ref) => asVoid2(whenEffect(self, getAndSet2(ref, false))));
var option = (self) => matchEffect(self, {
  onFailure: () => succeed(none2()),
  onSuccess: (a) => succeed(some2(a))
});
var orElseFail = /* @__PURE__ */ dual(2, (self, evaluate3) => orElse2(self, () => failSync(evaluate3)));
var orElseSucceed = /* @__PURE__ */ dual(2, (self, evaluate3) => orElse2(self, () => sync(evaluate3)));
var parallelErrors = (self) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const errors2 = fromIterable2(failures(cause3));
    return errors2.length === 0 ? failCause(cause3) : fail2(errors2);
  },
  onSuccess: succeed
});
var patchFiberRefs = (patch9) => updateFiberRefs((fiberId3, fiberRefs3) => pipe(patch9, patch6(fiberId3, fiberRefs3)));
var promise = (evaluate3) => evaluate3.length >= 1 ? async_((resolve, signal) => {
  try {
    evaluate3(signal).then((a) => resolve(exitSucceed(a)), (e) => resolve(exitDie(e)));
  } catch (e) {
    resolve(exitDie(e));
  }
}) : async_((resolve) => {
  try {
    ;
    evaluate3().then((a) => resolve(exitSucceed(a)), (e) => resolve(exitDie(e)));
  } catch (e) {
    resolve(exitDie(e));
  }
});
var provideService = /* @__PURE__ */ dual(3, (self, tag3, service3) => contextWithEffect((env3) => provideContext(self, add2(env3, tag3, service3))));
var provideServiceEffect = /* @__PURE__ */ dual(3, (self, tag3, effect4) => contextWithEffect((env3) => flatMap9(effect4, (service3) => provideContext(self, pipe(env3, add2(tag3, service3))))));
var random2 = /* @__PURE__ */ randomWith(succeed);
var reduce9 = /* @__PURE__ */ dual(3, (elements, zero3, f) => fromIterable2(elements).reduce((acc, el, i) => flatMap9(acc, (a) => f(a, el, i)), succeed(zero3)));
var reduceRight3 = /* @__PURE__ */ dual(3, (elements, zero3, f) => fromIterable2(elements).reduceRight((acc, el, i) => flatMap9(acc, (a) => f(el, a, i)), succeed(zero3)));
var reduceWhile = /* @__PURE__ */ dual(3, (elements, zero3, options) => flatMap9(sync(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop(iterator, 0, zero3, options.while, options.body)));
var reduceWhileLoop = (iterator, index, state, predicate, f) => {
  const next4 = iterator.next();
  if (!next4.done && predicate(state)) {
    return flatMap9(f(state, next4.value, index), (nextState) => reduceWhileLoop(iterator, index + 1, nextState, predicate, f));
  }
  return succeed(state);
};
var repeatN = /* @__PURE__ */ dual(2, (self, n) => suspend(() => repeatNLoop(self, n)));
var repeatNLoop = (self, n) => flatMap9(self, (a) => n <= 0 ? succeed(a) : zipRight2(yieldNow(), repeatNLoop(self, n - 1)));
var sandbox = (self) => matchCauseEffect(self, {
  onFailure: fail2,
  onSuccess: succeed
});
var setFiberRefs = (fiberRefs3) => suspend(() => setAll2(fiberRefs3));
var sleep3 = sleep2;
var succeedNone = /* @__PURE__ */ succeed(/* @__PURE__ */ none2());
var succeedSome = (value3) => succeed(some2(value3));
var summarized = /* @__PURE__ */ dual(3, (self, summary5, f) => flatMap9(summary5, (start5) => flatMap9(self, (value3) => map10(summary5, (end6) => [f(start5, end6), value3]))));
var tagMetrics = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [make28(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => make28(k, v)));
});
var labelMetrics = /* @__PURE__ */ dual(2, (self, labels) => fiberRefLocallyWith(self, currentMetricLabels, (old) => union(old, labels)));
var takeUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next4;
  let effect4 = succeed(false);
  let i = 0;
  while ((next4 = iterator.next()) && !next4.done) {
    const a = next4.value;
    const index = i++;
    effect4 = flatMap9(effect4, (bool2) => {
      if (bool2) {
        return succeed(true);
      }
      builder.push(a);
      return predicate(a, index);
    });
  }
  return map10(effect4, () => builder);
}));
var takeWhile2 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next4;
  let taking = succeed(true);
  let i = 0;
  while ((next4 = iterator.next()) && !next4.done) {
    const a = next4.value;
    const index = i++;
    taking = flatMap9(taking, (taking2) => pipe(taking2 ? predicate(a, index) : succeed(false), map10((bool2) => {
      if (bool2) {
        builder.push(a);
      }
      return bool2;
    })));
  }
  return map10(taking, () => builder);
}));
var tapBoth = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const either8 = failureOrCause(cause3);
    switch (either8._tag) {
      case "Left": {
        return zipRight2(onFailure(either8.left), failCause(cause3));
      }
      case "Right": {
        return failCause(cause3);
      }
    }
  },
  onSuccess: (a) => as2(onSuccess(a), a)
}));
var tapDefect = /* @__PURE__ */ dual(2, (self, f) => catchAllCause(self, (cause3) => match2(keepDefects(cause3), {
  onNone: () => failCause(cause3),
  onSome: (a) => zipRight2(f(a), failCause(cause3))
})));
var tapError = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (cause3) => {
    const either8 = failureOrCause(cause3);
    switch (either8._tag) {
      case "Left":
        return zipRight2(f(either8.left), failCause(cause3));
      case "Right":
        return failCause(cause3);
    }
  },
  onSuccess: succeed
}));
var tapErrorTag = /* @__PURE__ */ dual(3, (self, k, f) => tapError(self, (e) => {
  if (isTagged(e, k)) {
    return f(e);
  }
  return void_2;
}));
var tapErrorCause = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
  onFailure: (cause3) => zipRight2(f(cause3), failCause(cause3)),
  onSuccess: succeed
}));
var timed = (self) => timedWith(self, currentTimeNanos2);
var timedWith = /* @__PURE__ */ dual(2, (self, nanos2) => summarized(self, nanos2, (start5, end6) => nanos(end6 - start5)));
var tracerWith3 = tracerWith2;
var tracer = /* @__PURE__ */ tracerWith3(succeed);
var tryPromise = (arg) => {
  let evaluate3;
  let catcher = void 0;
  if (typeof arg === "function") {
    evaluate3 = arg;
  } else {
    evaluate3 = arg.try;
    catcher = arg.catch;
  }
  const fail21 = (e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
  if (evaluate3.length >= 1) {
    return async_((resolve, signal) => {
      try {
        evaluate3(signal).then((a) => resolve(exitSucceed(a)), (e) => resolve(fail21(e)));
      } catch (e) {
        resolve(fail21(e));
      }
    });
  }
  return async_((resolve) => {
    try {
      evaluate3().then((a) => resolve(exitSucceed(a)), (e) => resolve(fail21(e)));
    } catch (e) {
      resolve(fail21(e));
    }
  });
};
var tryMap = /* @__PURE__ */ dual(2, (self, options) => flatMap9(self, (a) => try_2({
  try: () => options.try(a),
  catch: options.catch
})));
var tryMapPromise = /* @__PURE__ */ dual(2, (self, options) => flatMap9(self, (a) => tryPromise({
  try: options.try.length >= 1 ? (signal) => options.try(a, signal) : () => options.try(a),
  catch: options.catch
})));
var unless = /* @__PURE__ */ dual(2, (self, condition) => suspend(() => condition() ? succeedNone : asSome(self)));
var unlessEffect = /* @__PURE__ */ dual(2, (self, condition) => flatMap9(condition, (b) => b ? succeedNone : asSome(self)));
var unsandbox = (self) => mapErrorCause(self, flatten4);
var updateFiberRefs = (f) => withFiberRuntime((state) => {
  state.setFiberRefs(f(state.id(), state.getFiberRefs()));
  return void_2;
});
var updateService = /* @__PURE__ */ dual(3, (self, tag3, f) => mapInputContext(self, (context9) => add2(context9, tag3, f(unsafeGet2(context9, tag3)))));
var when = /* @__PURE__ */ dual(2, (self, condition) => suspend(() => condition() ? map10(self, some2) : succeed(none2())));
var whenFiberRef = /* @__PURE__ */ dual(3, (self, fiberRef, predicate) => flatMap9(fiberRefGet(fiberRef), (s) => predicate(s) ? map10(self, (a) => [s, some2(a)]) : succeed([s, none2()])));
var whenRef = /* @__PURE__ */ dual(3, (self, ref, predicate) => flatMap9(get11(ref), (s) => predicate(s) ? map10(self, (a) => [s, some2(a)]) : succeed([s, none2()])));
var withMetric = /* @__PURE__ */ dual(2, (self, metric) => metric(self));
var serviceFunctionEffect = (getService, f) => (...args2) => flatMap9(getService, (a) => f(a)(...args2));
var serviceFunction = (getService, f) => (...args2) => map10(getService, (a) => f(a)(...args2));
var serviceFunctions = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return (...args2) => flatMap9(getService, (s) => s[prop](...args2));
  }
});
var serviceConstants = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return flatMap9(getService, (s) => isEffect(s[prop]) ? s[prop] : succeed(s[prop]));
  }
});
var serviceMembers = (getService) => ({
  functions: serviceFunctions(getService),
  constants: serviceConstants(getService)
});
var serviceOption = (tag3) => map10(context(), getOption2(tag3));
var serviceOptional = (tag3) => flatMap9(context(), getOption2(tag3));
var annotateCurrentSpan = function() {
  const args2 = arguments;
  return ignore(flatMap9(currentSpan, (span4) => sync(() => {
    if (typeof args2[0] === "string") {
      span4.attribute(args2[0], args2[1]);
    } else {
      for (const key in args2[0]) {
        span4.attribute(key, args2[0][key]);
      }
    }
  })));
};
var linkSpanCurrent = function() {
  const args2 = arguments;
  const links = Array.isArray(args2[0]) ? args2[0] : [{
    _tag: "SpanLink",
    span: args2[0],
    attributes: args2[1] ?? {}
  }];
  return ignore(flatMap9(currentSpan, (span4) => sync(() => span4.addLinks(links))));
};
var annotateSpans = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations5) => Object.entries(args2[1]).reduce((acc, [key, value3]) => set3(acc, key, value3), annotations5));
});
var currentParentSpan = /* @__PURE__ */ serviceOptional(spanTag);
var currentSpan = /* @__PURE__ */ flatMap9(/* @__PURE__ */ context(), (context9) => {
  const span4 = context9.unsafeMap.get(spanTag.key);
  return span4 !== void 0 && span4._tag === "Span" ? succeed(span4) : fail2(new NoSuchElementException());
});
var linkSpans = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self, span4, attributes) => fiberRefLocallyWith(self, currentTracerSpanLinks, append2({
  _tag: "SpanLink",
  span: span4,
  attributes: attributes ?? {}
})));
var bigint02 = /* @__PURE__ */ BigInt(0);
var filterDisablePropagation = /* @__PURE__ */ flatMap((span4) => get2(span4.context, DisablePropagation) ? span4._tag === "Span" ? filterDisablePropagation(span4.parent) : none2() : some2(span4));
var unsafeMakeSpan = (fiber, name, options) => {
  const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options.context && get2(options.context, DisablePropagation);
  const context9 = fiber.getFiberRef(currentContext);
  const parent = options.parent ? some2(options.parent) : options.root ? none2() : filterDisablePropagation(getOption2(context9, spanTag));
  let span4;
  if (disablePropagation) {
    span4 = noopSpan({
      name,
      parent,
      context: add2(options.context ?? empty2(), DisablePropagation, true)
    });
  } else {
    const services = fiber.getFiberRef(currentServices);
    const tracer3 = get2(services, tracerTag);
    const clock3 = get2(services, Clock);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const fiberRefs3 = fiber.getFiberRefs();
    const annotationsFromEnv = get9(fiberRefs3, currentTracerSpanAnnotations);
    const linksFromEnv = get9(fiberRefs3, currentTracerSpanLinks);
    const links = linksFromEnv._tag === "Some" ? options.links !== void 0 ? [...toReadonlyArray(linksFromEnv.value), ...options.links ?? []] : toReadonlyArray(linksFromEnv.value) : options.links ?? empty4();
    span4 = tracer3.span(name, parent, options.context ?? empty2(), links, timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint02, options.kind ?? "internal");
    if (annotationsFromEnv._tag === "Some") {
      forEach5(annotationsFromEnv.value, (value3, key) => span4.attribute(key, value3));
    }
    if (options.attributes !== void 0) {
      Object.entries(options.attributes).forEach(([k, v]) => span4.attribute(k, v));
    }
  }
  if (typeof options.captureStackTrace === "function") {
    spanToTrace.set(span4, options.captureStackTrace);
  }
  return span4;
};
var makeSpan = (name, options) => {
  options = addSpanStackTrace(options);
  return withFiberRuntime((fiber) => succeed(unsafeMakeSpan(fiber, name, options)));
};
var spanAnnotations = /* @__PURE__ */ fiberRefGet(currentTracerSpanAnnotations);
var spanLinks = /* @__PURE__ */ fiberRefGet(currentTracerSpanLinks);
var endSpan = (span4, exit4, clock3, timingEnabled) => sync(() => {
  if (span4.status._tag === "Ended") {
    return;
  }
  if (exitIsFailure(exit4) && spanToTrace.has(span4)) {
    span4.attribute("code.stacktrace", spanToTrace.get(span4)());
  }
  span4.end(timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint02, exit4);
});
var useSpan = (name, ...args2) => {
  const options = addSpanStackTrace(args2.length === 1 ? void 0 : args2[0]);
  const evaluate3 = args2[args2.length - 1];
  return withFiberRuntime((fiber) => {
    const span4 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock3 = get2(fiber.getFiberRef(currentServices), clockTag);
    return onExit(evaluate3(span4), (exit4) => endSpan(span4, exit4, clock3, timingEnabled));
  });
};
var withParentSpan = /* @__PURE__ */ dual(2, (self, span4) => provideService(self, spanTag, span4));
var withSpan = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return useSpan(name, options, (span4) => withParentSpan(self, span4));
  }
  return (self) => useSpan(name, options, (span4) => withParentSpan(self, span4));
};
var functionWithSpan = (options) => function() {
  let captureStackTrace = options.captureStackTrace ?? false;
  if (options.captureStackTrace !== false) {
    const limit2 = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error2 = new Error();
    Error.stackTraceLimit = limit2;
    let cache = false;
    captureStackTrace = () => {
      if (cache !== false) {
        return cache;
      }
      if (error2.stack) {
        const stack = error2.stack.trim().split("\n");
        cache = stack.slice(2).join("\n").trim();
        return cache;
      }
    };
  }
  return suspend(() => {
    const opts = typeof options.options === "function" ? options.options.apply(null, arguments) : options.options;
    return withSpan(suspend(() => internalCall(() => options.body.apply(this, arguments))), opts.name, {
      ...opts,
      captureStackTrace
    });
  });
};
var fromNullable2 = (value3) => value3 == null ? fail2(new NoSuchElementException()) : succeed(value3);
var optionFromOptional = (self) => catchAll(map10(self, some2), (error2) => isNoSuchElementException(error2) ? succeedNone : fail2(error2));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Exit.js
var isExit = exitIsExit;
var isFailure2 = exitIsFailure;
var isSuccess2 = exitIsSuccess;
var all4 = exitCollectAll;
var die3 = exitDie;
var fail4 = exitFail;
var failCause4 = exitFailCause;
var flatten7 = exitFlatten;
var forEachEffect = exitForEachEffect;
var interrupt4 = exitInterrupt;
var map12 = exitMap;
var mapBoth3 = exitMapBoth;
var match9 = exitMatch;
var succeed4 = exitSucceed;
var void_4 = exitVoid;
var zip4 = exitZip;
var zipRight3 = exitZipRight;
var zipWith5 = exitZipWith;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/fiberMessage.js
var OP_INTERRUPT_SIGNAL = "InterruptSignal";
var OP_STATEFUL = "Stateful";
var OP_RESUME = "Resume";
var OP_YIELD_NOW = "YieldNow";
var interruptSignal = (cause3) => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause: cause3
});
var stateful = (onFiber) => ({
  _tag: OP_STATEFUL,
  onFiber
});
var resume = (effect4) => ({
  _tag: OP_RESUME,
  effect: effect4
});
var yieldNow3 = () => ({
  _tag: OP_YIELD_NOW
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey = "effect/FiberScope";
var FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);
var _a23;
_a23 = FiberScopeTypeId;
var Global = class {
  constructor() {
    __publicField(this, _a23, FiberScopeTypeId);
    __publicField(this, "fiberId", none4);
    __publicField(this, "roots", /* @__PURE__ */ new Set());
  }
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
};
var _a24;
_a24 = FiberScopeTypeId;
var Local = class {
  constructor(fiberId3, parent) {
    __publicField(this, "fiberId");
    __publicField(this, "parent");
    __publicField(this, _a24, FiberScopeTypeId);
    this.fiberId = fiberId3;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful((parentFiber) => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
};
var unsafeMake8 = (fiber) => {
  return new Local(fiber.id(), fiber);
};
var globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global());

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey = "effect/Fiber";
var FiberTypeId = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
var fiberVariance2 = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var fiberProto = {
  [FiberTypeId]: fiberVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var RuntimeFiberSymbolKey = "effect/Fiber";
var RuntimeFiberTypeId = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
var Order4 = /* @__PURE__ */ pipe(/* @__PURE__ */ tuple(Order2, Order2), /* @__PURE__ */ mapInput2((fiber) => [fiber.id().startTimeMillis, fiber.id().id]));
var isFiber = (u) => hasProperty(u, FiberTypeId);
var isRuntimeFiber = (self) => RuntimeFiberTypeId in self;
var _await2 = (self) => self.await;
var children = (self) => self.children;
var done5 = (exit4) => {
  const _fiber = {
    ...CommitPrototype,
    commit() {
      return join3(this);
    },
    ...fiberProto,
    id: () => none4,
    await: succeed(exit4),
    children: succeed([]),
    inheritAll: void_2,
    poll: succeed(some2(exit4)),
    interruptAsFork: () => void_2
  };
  return _fiber;
};
var dump = (self) => map10(self.status, (status3) => ({
  id: self.id(),
  status: status3
}));
var dumpAll = (fibers) => forEachSequential(fibers, dump);
var fail5 = (error2) => done5(fail4(error2));
var failCause5 = (cause3) => done5(failCause4(cause3));
var fromEffect = (effect4) => map10(exit(effect4), done5);
var id = (self) => self.id();
var inheritAll = (self) => self.inheritAll;
var interrupted = (fiberId3) => done5(interrupt4(fiberId3));
var interruptAll = (fibers) => flatMap9(fiberId, (fiberId3) => pipe(fibers, interruptAllAs(fiberId3)));
var interruptAllAs = /* @__PURE__ */ dual(2, (fibers, fiberId3) => pipe(forEachSequentialDiscard(fibers, interruptAsFork(fiberId3)), zipRight2(pipe(fibers, forEachSequentialDiscard(_await2)))));
var interruptAsFork = /* @__PURE__ */ dual(2, (self, fiberId3) => self.interruptAsFork(fiberId3));
var join3 = (self) => zipLeft2(flatten6(self.await), self.inheritAll);
var map13 = /* @__PURE__ */ dual(2, (self, f) => mapEffect(self, (a) => sync(() => f(a))));
var mapEffect = /* @__PURE__ */ dual(2, (self, f) => {
  const _fiber = {
    ...CommitPrototype,
    commit() {
      return join3(this);
    },
    ...fiberProto,
    id: () => self.id(),
    await: flatMap9(self.await, forEachEffect(f)),
    children: self.children,
    inheritAll: self.inheritAll,
    poll: flatMap9(self.poll, (result) => {
      switch (result._tag) {
        case "None":
          return succeed(none2());
        case "Some":
          return pipe(forEachEffect(result.value, f), map10(some2));
      }
    }),
    interruptAsFork: (id3) => self.interruptAsFork(id3)
  };
  return _fiber;
});
var mapFiber = /* @__PURE__ */ dual(2, (self, f) => map10(self.await, match9({
  onFailure: (cause3) => failCause5(cause3),
  onSuccess: (a) => f(a)
})));
var match10 = /* @__PURE__ */ dual(2, (self, {
  onFiber,
  onRuntimeFiber
}) => {
  if (isRuntimeFiber(self)) {
    return onRuntimeFiber(self);
  }
  return onFiber(self);
});
var _never = {
  ...CommitPrototype,
  commit() {
    return join3(this);
  },
  ...fiberProto,
  id: () => none4,
  await: never,
  children: /* @__PURE__ */ succeed([]),
  inheritAll: never,
  poll: /* @__PURE__ */ succeed(/* @__PURE__ */ none2()),
  interruptAsFork: () => never
};
var never2 = _never;
var orElse3 = /* @__PURE__ */ dual(2, (self, that) => ({
  ...CommitPrototype,
  commit() {
    return join3(this);
  },
  ...fiberProto,
  id: () => getOrElse5(self.id(), that.id()),
  await: zipWith4(self.await, that.await, (exit1, exit22) => isSuccess2(exit1) ? exit1 : exit22),
  children: self.children,
  inheritAll: zipRight2(that.inheritAll, self.inheritAll),
  poll: zipWith4(self.poll, that.poll, (option1, option22) => {
    switch (option1._tag) {
      case "None": {
        return none2();
      }
      case "Some": {
        return isSuccess2(option1.value) ? option1 : option22;
      }
    }
  }),
  interruptAsFork: (id3) => pipe(interruptAsFiber(self, id3), zipRight2(pipe(that, interruptAsFiber(id3))), asVoid2)
}));
var orElseEither2 = /* @__PURE__ */ dual(2, (self, that) => orElse3(map13(self, left2), map13(that, right2)));
var poll2 = (self) => self.poll;
var parseMs = (milliseconds) => {
  const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;
  return {
    days: roundTowardsZero(milliseconds / 864e5),
    hours: roundTowardsZero(milliseconds / 36e5) % 24,
    minutes: roundTowardsZero(milliseconds / 6e4) % 60,
    seconds: roundTowardsZero(milliseconds / 1e3) % 60,
    milliseconds: roundTowardsZero(milliseconds) % 1e3,
    microseconds: roundTowardsZero(milliseconds * 1e3) % 1e3,
    nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1e3
  };
};
var renderStatus = (status3) => {
  if (isDone3(status3)) {
    return "Done";
  }
  if (isRunning2(status3)) {
    return "Running";
  }
  const isInterruptible = interruptible(status3.runtimeFlags) ? "interruptible" : "uninterruptible";
  return `Suspended(${isInterruptible})`;
};
var pretty2 = (self) => flatMap9(currentTimeMillis2, (now2) => map10(dump(self), (dump3) => {
  const time = now2 - dump3.id.startTimeMillis;
  const {
    days: days2,
    hours: hours2,
    milliseconds,
    minutes: minutes2,
    seconds: seconds2
  } = parseMs(time);
  const lifeMsg = (days2 === 0 ? "" : `${days2}d`) + (days2 === 0 && hours2 === 0 ? "" : `${hours2}h`) + (days2 === 0 && hours2 === 0 && minutes2 === 0 ? "" : `${minutes2}m`) + (days2 === 0 && hours2 === 0 && minutes2 === 0 && seconds2 === 0 ? "" : `${seconds2}s`) + `${milliseconds}ms`;
  const waitMsg = isSuspended2(dump3.status) ? (() => {
    const ids3 = ids2(dump3.status.blockingOn);
    return size4(ids3) > 0 ? `waiting on ` + Array.from(ids3).map((id3) => `${id3}`).join(", ") : "";
  })() : "";
  const statusMsg = renderStatus(dump3.status);
  return `[Fiber](#${dump3.id.id}) (${lifeMsg}) ${waitMsg}
   Status: ${statusMsg}`;
}));
var unsafeRoots = () => Array.from(globalScope.roots);
var roots = /* @__PURE__ */ sync(unsafeRoots);
var status = (self) => self.status;
var succeed5 = (value3) => done5(succeed4(value3));
var void_5 = /* @__PURE__ */ succeed5(void 0);
var currentFiberURI = "effect/FiberCurrent";
var getCurrentFiber = () => fromNullable(globalThis[currentFiberURI]);

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/logger.js
var LoggerSymbolKey = "effect/Logger";
var LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
var loggerVariance = {
  /* c8 ignore next */
  _Message: (_) => _,
  /* c8 ignore next */
  _Output: (_) => _
};
var makeLogger = (log3) => ({
  [LoggerTypeId]: loggerVariance,
  log: log3,
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var none7 = {
  [LoggerTypeId]: loggerVariance,
  log: constVoid,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var textOnly = /^[^\s"=]*$/;
var format3 = (quoteValue, whitespace) => ({
  annotations: annotations5,
  cause: cause3,
  date: date3,
  fiberId: fiberId3,
  logLevel: logLevel2,
  message,
  spans
}) => {
  const formatValue = (value3) => value3.match(textOnly) ? value3 : quoteValue(value3);
  const format8 = (label, value3) => `${formatLabel(label)}=${formatValue(value3)}`;
  const append4 = (label, value3) => " " + format8(label, value3);
  let out = format8("timestamp", date3.toISOString());
  out += append4("level", logLevel2.label);
  out += append4("fiber", threadName(fiberId3));
  const messages = ensure(message);
  for (let i = 0; i < messages.length; i++) {
    out += append4("message", toStringUnknown(messages[i], whitespace));
  }
  if (!isEmptyType(cause3)) {
    out += append4("cause", pretty(cause3, {
      renderErrorCause: true
    }));
  }
  for (const span4 of spans) {
    out += " " + render(date3.getTime())(span4);
  }
  for (const [label, value3] of annotations5) {
    out += append4(label, toStringUnknown(value3, whitespace));
  }
  return out;
};
var escapeDoubleQuotes = (s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
var stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format3(escapeDoubleQuotes));
var colors = {
  bold: "1",
  red: "31",
  green: "32",
  yellow: "33",
  blue: "34",
  cyan: "36",
  white: "37",
  gray: "90",
  black: "30",
  bgBrightRed: "101"
};
var logLevelColors = {
  None: [],
  All: [],
  Trace: [colors.gray],
  Debug: [colors.blue],
  Info: [colors.green],
  Warning: [colors.yellow],
  Error: [colors.red],
  Fatal: [colors.bgBrightRed, colors.black]
};
var hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
var processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
var hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/metric/boundaries.js
var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
var MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);
var _a25;
var MetricBoundariesImpl = class {
  constructor(values5) {
    __publicField(this, "values");
    __publicField(this, _a25, MetricBoundariesTypeId);
    __publicField(this, "_hash");
    this.values = values5;
    this._hash = pipe(string(MetricBoundariesSymbolKey), combine(array(this.values)));
  }
  [(_a25 = MetricBoundariesTypeId, symbol)]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricBoundaries(u) && equals(this.values, u.values);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricBoundaries = (u) => hasProperty(u, MetricBoundariesTypeId);
var fromIterable9 = (iterable) => {
  const values5 = pipe(iterable, appendAll(of2(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values5);
};
var exponential = (options) => pipe(makeBy(options.count - 1, (i) => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromIterable9);

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/metric/keyType.js
var MetricKeyTypeSymbolKey = "effect/MetricKeyType";
var MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
var CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
var FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
var FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
var GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
var GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
var HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
var SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
var SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
var metricKeyTypeVariance = {
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var _a26, _b2;
var CounterKeyType = class {
  constructor(incremental, bigint2) {
    __publicField(this, "incremental");
    __publicField(this, "bigint");
    __publicField(this, _b2, metricKeyTypeVariance);
    __publicField(this, _a26, CounterKeyTypeTypeId);
    __publicField(this, "_hash");
    this.incremental = incremental;
    this.bigint = bigint2;
    this._hash = string(CounterKeyTypeSymbolKey);
  }
  [(_b2 = MetricKeyTypeTypeId, _a26 = CounterKeyTypeTypeId, symbol)]() {
    return this._hash;
  }
  [symbol2](that) {
    return isCounterKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var FrequencyKeyTypeHash = /* @__PURE__ */ string(FrequencyKeyTypeSymbolKey);
var _a27, _b3;
var FrequencyKeyType = class {
  constructor(preregisteredWords) {
    __publicField(this, "preregisteredWords");
    __publicField(this, _b3, metricKeyTypeVariance);
    __publicField(this, _a27, FrequencyKeyTypeTypeId);
    this.preregisteredWords = preregisteredWords;
  }
  [(_b3 = MetricKeyTypeTypeId, _a27 = FrequencyKeyTypeTypeId, symbol)]() {
    return FrequencyKeyTypeHash;
  }
  [symbol2](that) {
    return isFrequencyKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var GaugeKeyTypeHash = /* @__PURE__ */ string(GaugeKeyTypeSymbolKey);
var _a28, _b4;
var GaugeKeyType = class {
  constructor(bigint2) {
    __publicField(this, "bigint");
    __publicField(this, _b4, metricKeyTypeVariance);
    __publicField(this, _a28, GaugeKeyTypeTypeId);
    this.bigint = bigint2;
  }
  [(_b4 = MetricKeyTypeTypeId, _a28 = GaugeKeyTypeTypeId, symbol)]() {
    return GaugeKeyTypeHash;
  }
  [symbol2](that) {
    return isGaugeKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _a29, _b5;
var HistogramKeyType = class {
  constructor(boundaries) {
    __publicField(this, "boundaries");
    __publicField(this, _b5, metricKeyTypeVariance);
    __publicField(this, _a29, HistogramKeyTypeTypeId);
    __publicField(this, "_hash");
    this.boundaries = boundaries;
    this._hash = pipe(string(HistogramKeyTypeSymbolKey), combine(hash(this.boundaries)));
  }
  [(_b5 = MetricKeyTypeTypeId, _a29 = HistogramKeyTypeTypeId, symbol)]() {
    return this._hash;
  }
  [symbol2](that) {
    return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _a30, _b6;
var SummaryKeyType = class {
  constructor(maxAge, maxSize, error2, quantiles) {
    __publicField(this, "maxAge");
    __publicField(this, "maxSize");
    __publicField(this, "error");
    __publicField(this, "quantiles");
    __publicField(this, _b6, metricKeyTypeVariance);
    __publicField(this, _a30, SummaryKeyTypeTypeId);
    __publicField(this, "_hash");
    this.maxAge = maxAge;
    this.maxSize = maxSize;
    this.error = error2;
    this.quantiles = quantiles;
    this._hash = pipe(string(SummaryKeyTypeSymbolKey), combine(hash(this.maxAge)), combine(hash(this.maxSize)), combine(hash(this.error)), combine(array(this.quantiles)));
  }
  [(_b6 = MetricKeyTypeTypeId, _a30 = SummaryKeyTypeTypeId, symbol)]() {
    return this._hash;
  }
  [symbol2](that) {
    return isSummaryKey(that) && equals(this.maxAge, that.maxAge) && this.maxSize === that.maxSize && this.error === that.error && equals(this.quantiles, that.quantiles);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter = (options) => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);
var histogram = (boundaries) => {
  return new HistogramKeyType(boundaries);
};
var isCounterKey = (u) => hasProperty(u, CounterKeyTypeTypeId);
var isFrequencyKey = (u) => hasProperty(u, FrequencyKeyTypeTypeId);
var isGaugeKey = (u) => hasProperty(u, GaugeKeyTypeTypeId);
var isHistogramKey = (u) => hasProperty(u, HistogramKeyTypeTypeId);
var isSummaryKey = (u) => hasProperty(u, SummaryKeyTypeTypeId);

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey = "effect/MetricKey";
var MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
var metricKeyVariance = {
  /* c8 ignore next */
  _Type: (_) => _
};
var arrayEquivilence = /* @__PURE__ */ getEquivalence3(equals);
var _a31;
var MetricKeyImpl = class {
  constructor(name, keyType, description, tags = []) {
    __publicField(this, "name");
    __publicField(this, "keyType");
    __publicField(this, "description");
    __publicField(this, "tags");
    __publicField(this, _a31, metricKeyVariance);
    __publicField(this, "_hash");
    this.name = name;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags;
    this._hash = pipe(string(this.name + this.description), combine(hash(this.keyType)), combine(array(this.tags)));
  }
  [(_a31 = MetricKeyTypeId, symbol)]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricKey = (u) => hasProperty(u, MetricKeyTypeId);
var counter2 = (name, options) => new MetricKeyImpl(name, counter(options), fromNullable(options?.description));
var histogram2 = (name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable(description));
var taggedWithLabels = /* @__PURE__ */ dual(2, (self, extraTags) => extraTags.length === 0 ? self : new MetricKeyImpl(self.name, self.keyType, self.description, union(self.tags, extraTags)));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/MutableHashMap.js
var TypeId12 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
var MutableHashMapProto = {
  [TypeId12]: TypeId12,
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MutableHashMapIterator = class _MutableHashMapIterator {
  constructor(self) {
    __publicField(this, "self");
    __publicField(this, "referentialIterator");
    __publicField(this, "bucketIterator");
    this.self = self;
    this.referentialIterator = self.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== void 0) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new _MutableHashMapIterator(this.self);
  }
};
var BucketIterator = class {
  constructor(backing) {
    __publicField(this, "backing");
    __publicField(this, "currentBucket");
    this.backing = backing;
  }
  next() {
    if (this.currentBucket === void 0) {
      const result2 = this.backing.next();
      if (result2.done) {
        return result2;
      }
      this.currentBucket = result2.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = void 0;
      return this.next();
    }
    return result;
  }
};
var empty22 = () => {
  const self = Object.create(MutableHashMapProto);
  self.referential = /* @__PURE__ */ new Map();
  self.buckets = /* @__PURE__ */ new Map();
  self.bucketsSize = 0;
  return self;
};
var get12 = /* @__PURE__ */ dual(2, (self, key) => {
  if (isEqual(key) === false) {
    return self.referential.has(key) ? some2(self.referential.get(key)) : none2();
  }
  const hash4 = key[symbol]();
  const bucket = self.buckets.get(hash4);
  if (bucket === void 0) {
    return none2();
  }
  return getFromBucket(self, bucket, key);
});
var getFromBucket = (self, bucket, key, remove10 = false) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      const value3 = bucket[i][1];
      if (remove10) {
        bucket.splice(i, 1);
        self.bucketsSize--;
      }
      return some2(value3);
    }
  }
  return none2();
};
var has6 = /* @__PURE__ */ dual(2, (self, key) => isSome2(get12(self, key)));
var set6 = /* @__PURE__ */ dual(3, (self, key, value3) => {
  if (isEqual(key) === false) {
    self.referential.set(key, value3);
    return self;
  }
  const hash4 = key[symbol]();
  const bucket = self.buckets.get(hash4);
  if (bucket === void 0) {
    self.buckets.set(hash4, [[key, value3]]);
    self.bucketsSize++;
    return self;
  }
  removeFromBucket(self, bucket, key);
  bucket.push([key, value3]);
  self.bucketsSize++;
  return self;
});
var removeFromBucket = (self, bucket, key) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      bucket.splice(i, 1);
      self.bucketsSize--;
      return;
    }
  }
};
var remove7 = /* @__PURE__ */ dual(2, (self, key) => {
  if (isEqual(key) === false) {
    self.referential.delete(key);
    return self;
  }
  const hash4 = key[symbol]();
  const bucket = self.buckets.get(hash4);
  if (bucket === void 0) {
    return self;
  }
  removeFromBucket(self, bucket, key);
  if (bucket.length === 0) {
    self.buckets.delete(hash4);
  }
  return self;
});
var size6 = (self) => {
  return self.referential.size + self.bucketsSize;
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/metric/state.js
var MetricStateSymbolKey = "effect/MetricState";
var MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
var CounterStateSymbolKey = "effect/MetricState/Counter";
var CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
var FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
var GaugeStateSymbolKey = "effect/MetricState/Gauge";
var GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
var HistogramStateSymbolKey = "effect/MetricState/Histogram";
var HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
var SummaryStateSymbolKey = "effect/MetricState/Summary";
var SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
var metricStateVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a32, _b7;
var CounterState = class {
  constructor(count4) {
    __publicField(this, "count");
    __publicField(this, _b7, metricStateVariance);
    __publicField(this, _a32, CounterStateTypeId);
    this.count = count4;
  }
  [(_b7 = MetricStateTypeId, _a32 = CounterStateTypeId, symbol)]() {
    return pipe(hash(CounterStateSymbolKey), combine(hash(this.count)), cached(this));
  }
  [symbol2](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var arrayEquals = /* @__PURE__ */ getEquivalence3(equals);
var _a33, _b8;
var FrequencyState = class {
  constructor(occurrences) {
    __publicField(this, "occurrences");
    __publicField(this, _b8, metricStateVariance);
    __publicField(this, _a33, FrequencyStateTypeId);
    __publicField(this, "_hash");
    this.occurrences = occurrences;
  }
  [(_b8 = MetricStateTypeId, _a33 = FrequencyStateTypeId, symbol)]() {
    return pipe(string(FrequencyStateSymbolKey), combine(array(fromIterable2(this.occurrences.entries()))), cached(this));
  }
  [symbol2](that) {
    return isFrequencyState(that) && arrayEquals(fromIterable2(this.occurrences.entries()), fromIterable2(that.occurrences.entries()));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _a34, _b9;
var GaugeState = class {
  constructor(value3) {
    __publicField(this, "value");
    __publicField(this, _b9, metricStateVariance);
    __publicField(this, _a34, GaugeStateTypeId);
    this.value = value3;
  }
  [(_b9 = MetricStateTypeId, _a34 = GaugeStateTypeId, symbol)]() {
    return pipe(hash(GaugeStateSymbolKey), combine(hash(this.value)), cached(this));
  }
  [symbol2](u) {
    return isGaugeState(u) && this.value === u.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _a35, _b10;
var HistogramState = class {
  constructor(buckets, count4, min5, max7, sum3) {
    __publicField(this, "buckets");
    __publicField(this, "count");
    __publicField(this, "min");
    __publicField(this, "max");
    __publicField(this, "sum");
    __publicField(this, _b10, metricStateVariance);
    __publicField(this, _a35, HistogramStateTypeId);
    this.buckets = buckets;
    this.count = count4;
    this.min = min5;
    this.max = max7;
    this.sum = sum3;
  }
  [(_b10 = MetricStateTypeId, _a35 = HistogramStateTypeId, symbol)]() {
    return pipe(hash(HistogramStateSymbolKey), combine(hash(this.buckets)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _a36, _b11;
var SummaryState = class {
  constructor(error2, quantiles, count4, min5, max7, sum3) {
    __publicField(this, "error");
    __publicField(this, "quantiles");
    __publicField(this, "count");
    __publicField(this, "min");
    __publicField(this, "max");
    __publicField(this, "sum");
    __publicField(this, _b11, metricStateVariance);
    __publicField(this, _a36, SummaryStateTypeId);
    this.error = error2;
    this.quantiles = quantiles;
    this.count = count4;
    this.min = min5;
    this.max = max7;
    this.sum = sum3;
  }
  [(_b11 = MetricStateTypeId, _a36 = SummaryStateTypeId, symbol)]() {
    return pipe(hash(SummaryStateSymbolKey), combine(hash(this.error)), combine(hash(this.quantiles)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter3 = (count4) => new CounterState(count4);
var frequency2 = (occurrences) => {
  return new FrequencyState(occurrences);
};
var gauge2 = (count4) => new GaugeState(count4);
var histogram3 = (options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
var summary2 = (options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
var isCounterState = (u) => hasProperty(u, CounterStateTypeId);
var isFrequencyState = (u) => hasProperty(u, FrequencyStateTypeId);
var isGaugeState = (u) => hasProperty(u, GaugeStateTypeId);
var isHistogramState = (u) => hasProperty(u, HistogramStateTypeId);
var isSummaryState = (u) => hasProperty(u, SummaryStateTypeId);

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey = "effect/MetricHook";
var MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
var metricHookVariance = {
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var make29 = (options) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var bigint03 = /* @__PURE__ */ BigInt(0);
var counter4 = (key) => {
  let sum3 = key.keyType.bigint ? bigint03 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value3) => value3 >= bigint03 : (value3) => value3 >= 0 : (_value2) => true;
  const update5 = (value3) => {
    if (canUpdate(value3)) {
      sum3 = sum3 + value3;
    }
  };
  return make29({
    get: () => counter3(sum3),
    update: update5,
    modify: update5
  });
};
var frequency3 = (key) => {
  const values5 = /* @__PURE__ */ new Map();
  for (const word of key.keyType.preregisteredWords) {
    values5.set(word, 0);
  }
  const update5 = (word) => {
    const slotCount = values5.get(word) ?? 0;
    values5.set(word, slotCount + 1);
  };
  return make29({
    get: () => frequency2(values5),
    update: update5,
    modify: update5
  });
};
var gauge3 = (_key, startAt) => {
  let value3 = startAt;
  return make29({
    get: () => gauge2(value3),
    update: (v) => {
      value3 = v;
    },
    modify: (v) => {
      value3 = value3 + v;
    }
  });
};
var histogram4 = (key) => {
  const bounds = key.keyType.boundaries.values;
  const size17 = bounds.length;
  const values5 = new Uint32Array(size17 + 1);
  const boundaries = new Float32Array(size17);
  let count4 = 0;
  let sum3 = 0;
  let min5 = Number.MAX_VALUE;
  let max7 = Number.MIN_VALUE;
  pipe(bounds, sort(Order2), map3((n, i) => {
    boundaries[i] = n;
  }));
  const update5 = (value3) => {
    let from = 0;
    let to = size17;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value3 <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      if (to === from + 1) {
        if (value3 <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values5[from] = values5[from] + 1;
    count4 = count4 + 1;
    sum3 = sum3 + value3;
    if (value3 < min5) {
      min5 = value3;
    }
    if (value3 > max7) {
      max7 = value3;
    }
  };
  const getBuckets = () => {
    const builder = allocate(size17);
    let cumulated = 0;
    for (let i = 0; i < size17; i++) {
      const boundary = boundaries[i];
      const value3 = values5[i];
      cumulated = cumulated + value3;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  };
  return make29({
    get: () => histogram3({
      buckets: getBuckets(),
      count: count4,
      min: min5,
      max: max7,
      sum: sum3
    }),
    update: update5,
    modify: update5
  });
};
var summary3 = (key) => {
  const {
    error: error2,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe(quantiles, sort(Order2));
  const values5 = allocate(maxSize);
  let head8 = 0;
  let count4 = 0;
  let sum3 = 0;
  let min5 = 0;
  let max7 = 0;
  const snapshot = (now2) => {
    const builder = [];
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values5[i];
      if (item != null) {
        const [t, v] = item;
        const age = millis(now2 - t);
        if (greaterThanOrEqualTo2(age, zero) && lessThanOrEqualTo2(age, maxAge)) {
          builder.push(v);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles(error2, sortedQuantiles, sort(builder, Order2));
  };
  const observe = (value3, timestamp) => {
    if (maxSize > 0) {
      head8 = head8 + 1;
      const target = head8 % maxSize;
      values5[target] = [timestamp, value3];
    }
    min5 = count4 === 0 ? value3 : Math.min(min5, value3);
    max7 = count4 === 0 ? value3 : Math.max(max7, value3);
    count4 = count4 + 1;
    sum3 = sum3 + value3;
  };
  return make29({
    get: () => summary2({
      error: error2,
      quantiles: snapshot(Date.now()),
      count: count4,
      min: min5,
      max: max7,
      sum: sum3
    }),
    update: ([value3, timestamp]) => observe(value3, timestamp),
    modify: ([value3, timestamp]) => observe(value3, timestamp)
  });
};
var calculateQuantiles = (error2, sortedQuantiles, sortedSamples) => {
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return empty4();
  }
  const head8 = sortedQuantiles[0];
  const tail2 = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error2, sampleCount, none2(), 0, head8, sortedSamples);
  const resolved = of(resolvedHead);
  tail2.forEach((quantile) => {
    resolved.push(resolveQuantile(error2, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map3(resolved, (rq) => [rq.quantile, rq.value]);
};
var resolveQuantile = (error2, sampleCount, current2, consumed, quantile, rest) => {
  let error_1 = error2;
  let sampleCount_1 = sampleCount;
  let current_1 = current2;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error2;
  let sampleCount_2 = sampleCount;
  let current_2 = current2;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  while (1) {
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: none2(),
        consumed: consumed_1,
        rest: []
      };
    }
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some2(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    const headValue = headNonEmpty(rest_1);
    const sameHead = span(rest_1, (n) => n === headValue);
    const desired = quantile_1 * sampleCount_1;
    const allowedError = error_1 / 2 * desired;
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    if (candConsumed > desired + allowedError) {
      const valueToReturn = isNone2(current_1) ? some2(headValue) : current_1;
      return {
        quantile: quantile_1,
        value: valueToReturn,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    switch (current_1._tag) {
      case "None": {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      case "Some": {
        const prevError = Math.abs(desired - current_1.value);
        if (candError < prevError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        return {
          quantile: quantile_1,
          value: some2(current_1.value),
          consumed: consumed_1,
          rest: rest_1
        };
      }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/metric/pair.js
var MetricPairSymbolKey = "effect/MetricPair";
var MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
var metricPairVariance = {
  /* c8 ignore next */
  _Type: (_) => _
};
var unsafeMake9 = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey = "effect/MetricRegistry";
var MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);
var _a37;
_a37 = MetricRegistryTypeId;
var MetricRegistryImpl = class {
  constructor() {
    __publicField(this, _a37, MetricRegistryTypeId);
    __publicField(this, "map", /* @__PURE__ */ empty22());
  }
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(unsafeMake9(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = pipe(this.map, get12(key), getOrUndefined);
    if (hook == null) {
      if (isCounterKey(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value3 = pipe(this.map, get12(key), getOrUndefined);
    if (value3 == null) {
      const counter6 = counter4(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set6(key, counter6));
      }
      value3 = counter6;
    }
    return value3;
  }
  getFrequency(key) {
    let value3 = pipe(this.map, get12(key), getOrUndefined);
    if (value3 == null) {
      const frequency5 = frequency3(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set6(key, frequency5));
      }
      value3 = frequency5;
    }
    return value3;
  }
  getGauge(key) {
    let value3 = pipe(this.map, get12(key), getOrUndefined);
    if (value3 == null) {
      const gauge5 = gauge3(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set6(key, gauge5));
      }
      value3 = gauge5;
    }
    return value3;
  }
  getHistogram(key) {
    let value3 = pipe(this.map, get12(key), getOrUndefined);
    if (value3 == null) {
      const histogram6 = histogram4(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set6(key, histogram6));
      }
      value3 = histogram6;
    }
    return value3;
  }
  getSummary(key) {
    let value3 = pipe(this.map, get12(key), getOrUndefined);
    if (value3 == null) {
      const summary5 = summary3(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set6(key, summary5));
      }
      value3 = summary5;
    }
    return value3;
  }
};
var make30 = () => {
  return new MetricRegistryImpl();
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey = "effect/Metric";
var MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
var metricVariance = {
  /* c8 ignore next */
  _Type: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _Out: (_) => _
};
var globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make30());
var make31 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign((effect4) => tap2(effect4, (a) => update4(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  return metric;
};
var counter5 = (name, options) => fromMetricKey(counter2(name, options));
var fromMetricKey = (key) => {
  let untaggedHook;
  const hookCache = /* @__PURE__ */ new WeakMap();
  const hook = (extraTags) => {
    if (extraTags.length === 0) {
      if (untaggedHook !== void 0) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook2 = hookCache.get(extraTags);
    if (hook2 !== void 0) {
      return hook2;
    }
    hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook2);
    return hook2;
  };
  return make31(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
};
var histogram5 = (name, boundaries, description) => fromMetricKey(histogram2(name, boundaries, description));
var tagged = /* @__PURE__ */ dual(3, (self, key, value3) => taggedWithLabels2(self, [make28(key, value3)]));
var taggedWithLabels2 = /* @__PURE__ */ dual(2, (self, extraTags) => {
  return make31(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, union(extraTags, extraTags1)), (extraTags1) => self.unsafeValue(union(extraTags, extraTags1)), (input, extraTags1) => self.unsafeModify(input, union(extraTags, extraTags1)));
});
var update4 = /* @__PURE__ */ dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, (tags) => sync(() => self.unsafeUpdate(input, tags))));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/request.js
var RequestSymbolKey = "effect/Request";
var RequestTypeId = /* @__PURE__ */ Symbol.for(RequestSymbolKey);
var requestVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var RequestPrototype = {
  ...StructuralPrototype,
  [RequestTypeId]: requestVariance
};
var isRequest = (u) => hasProperty(u, RequestTypeId);
var Class3 = /* @__PURE__ */ function() {
  function Class8(args2) {
    if (args2) {
      Object.assign(this, args2);
    }
  }
  Class8.prototype = RequestPrototype;
  return Class8;
}();
var complete = /* @__PURE__ */ dual(2, (self, result) => fiberRefGetWith(currentRequestMap, (map31) => sync(() => {
  if (map31.has(self)) {
    const entry = map31.get(self);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone(entry.result, result);
    }
  }
})));
var Listeners = class {
  constructor() {
    __publicField(this, "count", 0);
    __publicField(this, "observers", /* @__PURE__ */ new Set());
    __publicField(this, "interrupted", false);
  }
  addObserver(f) {
    this.observers.add(f);
  }
  removeObserver(f) {
    this.observers.delete(f);
  }
  increment() {
    this.count++;
    this.observers.forEach((f) => f(this.count));
  }
  decrement() {
    this.count--;
    this.observers.forEach((f) => f(this.count));
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/redBlackTree/iterator.js
var Direction = {
  Forward: 0,
  Backward: 1 << 0
};
var RedBlackTreeIterator = class _RedBlackTreeIterator {
  constructor(self, stack, direction) {
    __publicField(this, "self");
    __publicField(this, "stack");
    __publicField(this, "direction");
    __publicField(this, "count", 0);
    this.self = self;
    this.stack = stack;
    this.direction = direction;
  }
  /**
   * Clones the iterator
   */
  clone() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
  }
  /**
   * Reverse the traversal direction
   */
  reversed() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction.Forward ? Direction.Backward : Direction.Forward);
  }
  /**
   * Iterator next
   */
  next() {
    const entry = this.entry;
    this.count++;
    if (this.direction === Direction.Forward) {
      this.moveNext();
    } else {
      this.movePrev();
    }
    switch (entry._tag) {
      case "None": {
        return {
          done: true,
          value: this.count
        };
      }
      case "Some": {
        return {
          done: false,
          value: entry.value
        };
      }
    }
  }
  /**
   * Returns the key
   */
  get key() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].key);
    }
    return none2();
  }
  /**
   * Returns the value
   */
  get value() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].value);
    }
    return none2();
  }
  /**
   * Returns the key
   */
  get entry() {
    return map2(last(this.stack), (node) => [node.key, node.value]);
  }
  /**
   * Returns the position of this iterator in the sorted list
   */
  get index() {
    let idx = 0;
    const stack = this.stack;
    if (stack.length === 0) {
      const r = this.self._root;
      if (r != null) {
        return r.count;
      }
      return 0;
    } else if (stack[stack.length - 1].left != null) {
      idx = stack[stack.length - 1].left.count;
    }
    for (let s = stack.length - 2; s >= 0; --s) {
      if (stack[s + 1] === stack[s].right) {
        ;
        ++idx;
        if (stack[s].left != null) {
          idx += stack[s].left.count;
        }
      }
    }
    return idx;
  }
  /**
   * Advances iterator to next element in list
   */
  moveNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n.right != null) {
      n = n.right;
      while (n != null) {
        stack.push(n);
        n = n.left;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].right === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a next element
   */
  get hasNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].right != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].left === stack[s]) {
        return true;
      }
    }
    return false;
  }
  /**
   * Advances iterator to previous element in list
   */
  movePrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n != null && n.left != null) {
      n = n.left;
      while (n != null) {
        stack.push(n);
        n = n.right;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].left === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a previous element
   */
  get hasPrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].left != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].right === stack[s]) {
        return true;
      }
    }
    return false;
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/redBlackTree/node.js
var Color = {
  Red: 0,
  Black: 1 << 0
};
var clone = ({
  color,
  count: count4,
  key,
  left: left3,
  right: right3,
  value: value3
}) => ({
  color,
  key,
  value: value3,
  left: left3,
  right: right3,
  count: count4
});
function swap2(n, v) {
  n.key = v.key;
  n.value = v.value;
  n.left = v.left;
  n.right = v.right;
  n.color = v.color;
  n.count = v.count;
}
var repaint = ({
  count: count4,
  key,
  left: left3,
  right: right3,
  value: value3
}, color) => ({
  color,
  key,
  value: value3,
  left: left3,
  right: right3,
  count: count4
});
var recount = (node) => {
  node.count = 1 + (node.left?.count ?? 0) + (node.right?.count ?? 0);
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/redBlackTree.js
var RedBlackTreeSymbolKey = "effect/RedBlackTree";
var RedBlackTreeTypeId = /* @__PURE__ */ Symbol.for(RedBlackTreeSymbolKey);
var redBlackTreeVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var RedBlackTreeProto = {
  [RedBlackTreeTypeId]: redBlackTreeVariance,
  [symbol]() {
    let hash4 = hash(RedBlackTreeSymbolKey);
    for (const item of this) {
      hash4 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash4);
  },
  [symbol2](that) {
    if (isRedBlackTree(that)) {
      if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) {
        return false;
      }
      const entries3 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries3[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  [Symbol.iterator]() {
    const stack = [];
    let n = this._root;
    while (n != null) {
      stack.push(n);
      n = n.left;
    }
    return new RedBlackTreeIterator(this, stack, Direction.Forward);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "RedBlackTree",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl3 = (ord, root) => {
  const tree = Object.create(RedBlackTreeProto);
  tree._ord = ord;
  tree._root = root;
  return tree;
};
var isRedBlackTree = (u) => hasProperty(u, RedBlackTreeTypeId);
var empty23 = (ord) => makeImpl3(ord, void 0);
var fromIterable10 = /* @__PURE__ */ dual(2, (entries3, ord) => {
  let tree = empty23(ord);
  for (const [key, value3] of entries3) {
    tree = insert(tree, key, value3);
  }
  return tree;
});
var findFirst7 = /* @__PURE__ */ dual(2, (self, key) => {
  const cmp = self._ord;
  let node = self._root;
  while (node !== void 0) {
    const d = cmp(key, node.key);
    if (equals(key, node.key)) {
      return some2(node.value);
    }
    if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  return none2();
});
var has7 = /* @__PURE__ */ dual(2, (self, key) => isSome2(findFirst7(self, key)));
var insert = /* @__PURE__ */ dual(3, (self, key, value3) => {
  const cmp = self._ord;
  let n = self._root;
  const n_stack = [];
  const d_stack = [];
  while (n != null) {
    const d = cmp(key, n.key);
    n_stack.push(n);
    d_stack.push(d);
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  n_stack.push({
    color: Color.Red,
    key,
    value: value3,
    left: void 0,
    right: void 0,
    count: 1
  });
  for (let s = n_stack.length - 2; s >= 0; --s) {
    const n2 = n_stack[s];
    if (d_stack[s] <= 0) {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n_stack[s + 1],
        right: n2.right,
        count: n2.count + 1
      };
    } else {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n2.left,
        right: n_stack[s + 1],
        count: n2.count + 1
      };
    }
  }
  for (let s = n_stack.length - 1; s > 1; --s) {
    const p = n_stack[s - 1];
    const n3 = n_stack[s];
    if (p.color === Color.Black || n3.color === Color.Black) {
      break;
    }
    const pp = n_stack[s - 2];
    if (pp.left === p) {
      if (p.left === n3) {
        const y = pp.right;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.left = p.right;
          p.color = Color.Black;
          p.right = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = p;
            } else {
              ppp.right = p;
            }
          }
          break;
        }
      } else {
        const y = pp.right;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p.right = n3.left;
          pp.color = Color.Red;
          pp.left = n3.right;
          n3.color = Color.Black;
          n3.left = p;
          n3.right = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = n3;
            } else {
              ppp.right = n3;
            }
          }
          break;
        }
      }
    } else {
      if (p.right === n3) {
        const y = pp.left;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.right = p.left;
          p.color = Color.Black;
          p.left = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = p;
            } else {
              ppp.left = p;
            }
          }
          break;
        }
      } else {
        const y = pp.left;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p.left = n3.right;
          pp.color = Color.Red;
          pp.right = n3.left;
          n3.color = Color.Black;
          n3.right = p;
          n3.left = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = n3;
            } else {
              ppp.left = n3;
            }
          }
          break;
        }
      }
    }
  }
  n_stack[0].color = Color.Black;
  return makeImpl3(self._ord, n_stack[0]);
});
var keysForward = (self) => keys4(self, Direction.Forward);
var keys4 = (self, direction) => {
  const begin = self[Symbol.iterator]();
  let count4 = 0;
  return {
    [Symbol.iterator]: () => keys4(self, direction),
    next: () => {
      count4++;
      const entry = begin.key;
      if (direction === Direction.Forward) {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      switch (entry._tag) {
        case "None": {
          return {
            done: true,
            value: count4
          };
        }
        case "Some": {
          return {
            done: false,
            value: entry.value
          };
        }
      }
    }
  };
};
var removeFirst = /* @__PURE__ */ dual(2, (self, key) => {
  if (!has7(self, key)) {
    return self;
  }
  const ord = self._ord;
  const cmp = ord;
  let node = self._root;
  const stack = [];
  while (node !== void 0) {
    const d = cmp(key, node.key);
    stack.push(node);
    if (equals(key, node.key)) {
      node = void 0;
    } else if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  if (stack.length === 0) {
    return self;
  }
  const cstack = new Array(stack.length);
  let n = stack[stack.length - 1];
  cstack[cstack.length - 1] = {
    color: n.color,
    key: n.key,
    value: n.value,
    left: n.left,
    right: n.right,
    count: n.count
  };
  for (let i = stack.length - 2; i >= 0; --i) {
    n = stack[i];
    if (n.left === stack[i + 1]) {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: cstack[i + 1],
        right: n.right,
        count: n.count
      };
    } else {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
  }
  n = cstack[cstack.length - 1];
  if (n.left !== void 0 && n.right !== void 0) {
    const split8 = cstack.length;
    n = n.left;
    while (n.right != null) {
      cstack.push(n);
      n = n.right;
    }
    const v = cstack[split8 - 1];
    cstack.push({
      color: n.color,
      key: v.key,
      value: v.value,
      left: n.left,
      right: n.right,
      count: n.count
    });
    cstack[split8 - 1].key = n.key;
    cstack[split8 - 1].value = n.value;
    for (let i = cstack.length - 2; i >= split8; --i) {
      n = cstack[i];
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
    cstack[split8 - 1].left = cstack[split8];
  }
  n = cstack[cstack.length - 1];
  if (n.color === Color.Red) {
    const p = cstack[cstack.length - 2];
    if (p.left === n) {
      p.left = void 0;
    } else if (p.right === n) {
      p.right = void 0;
    }
    cstack.pop();
    for (let i = 0; i < cstack.length; ++i) {
      cstack[i].count--;
    }
    return makeImpl3(ord, cstack[0]);
  } else {
    if (n.left !== void 0 || n.right !== void 0) {
      if (n.left !== void 0) {
        swap2(n, n.left);
      } else if (n.right !== void 0) {
        swap2(n, n.right);
      }
      n.color = Color.Black;
      for (let i = 0; i < cstack.length - 1; ++i) {
        cstack[i].count--;
      }
      return makeImpl3(ord, cstack[0]);
    } else if (cstack.length === 1) {
      return makeImpl3(ord, void 0);
    } else {
      for (let i = 0; i < cstack.length; ++i) {
        cstack[i].count--;
      }
      const parent = cstack[cstack.length - 2];
      fixDoubleBlack(cstack);
      if (parent.left === n) {
        parent.left = void 0;
      } else {
        parent.right = void 0;
      }
    }
  }
  return makeImpl3(ord, cstack[0]);
});
var fixDoubleBlack = (stack) => {
  let n, p, s, z;
  for (let i = stack.length - 1; i >= 0; --i) {
    n = stack[i];
    if (i === 0) {
      n.color = Color.Black;
      return;
    }
    p = stack[i - 1];
    if (p.left === n) {
      s = p.right;
      if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
        s = p.right = clone(s);
        z = s.right = clone(s.right);
        p.right = s.left;
        s.left = p;
        s.right = z;
        s.color = p.color;
        n.color = Color.Black;
        p.color = Color.Black;
        z.color = Color.Black;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
        s = p.right = clone(s);
        z = s.left = clone(s.left);
        p.right = z.left;
        s.left = z.right;
        z.left = p;
        z.right = s;
        z.color = p.color;
        p.color = Color.Black;
        s.color = Color.Black;
        n.color = Color.Black;
        recount(p);
        recount(s);
        recount(z);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = z;
          } else {
            pp.right = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s !== void 0 && s.color === Color.Black) {
        if (p.color === Color.Red) {
          p.color = Color.Black;
          p.right = repaint(s, Color.Red);
          return;
        } else {
          p.right = repaint(s, Color.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone(s);
        p.right = s.left;
        s.left = p;
        s.color = p.color;
        p.color = Color.Red;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    } else {
      s = p.left;
      if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
        s = p.left = clone(s);
        z = s.left = clone(s.left);
        p.left = s.right;
        s.right = p;
        s.left = z;
        s.color = p.color;
        n.color = Color.Black;
        p.color = Color.Black;
        z.color = Color.Black;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
        s = p.left = clone(s);
        z = s.right = clone(s.right);
        p.left = z.right;
        s.right = z.left;
        z.right = p;
        z.left = s;
        z.color = p.color;
        p.color = Color.Black;
        s.color = Color.Black;
        n.color = Color.Black;
        recount(p);
        recount(s);
        recount(z);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = z;
          } else {
            pp.left = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s !== void 0 && s.color === Color.Black) {
        if (p.color === Color.Red) {
          p.color = Color.Black;
          p.left = repaint(s, Color.Red);
          return;
        } else {
          p.left = repaint(s, Color.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone(s);
        p.left = s.right;
        s.right = p;
        s.color = p.color;
        p.color = Color.Red;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    }
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/RedBlackTree.js
var fromIterable11 = fromIterable10;
var has8 = has7;
var insert2 = insert;
var keys5 = keysForward;
var removeFirst2 = removeFirst;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/SortedSet.js
var TypeId13 = /* @__PURE__ */ Symbol.for("effect/SortedSet");
var SortedSetProto = {
  [TypeId13]: {
    _A: (_) => _
  },
  [symbol]() {
    return pipe(hash(this.keyTree), combine(hash(TypeId13)), cached(this));
  },
  [symbol2](that) {
    return isSortedSet(that) && equals(this.keyTree, that.keyTree);
  },
  [Symbol.iterator]() {
    return keys5(this.keyTree);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var fromTree = (keyTree) => {
  const a = Object.create(SortedSetProto);
  a.keyTree = keyTree;
  return a;
};
var isSortedSet = (u) => hasProperty(u, TypeId13);
var fromIterable12 = /* @__PURE__ */ dual(2, (iterable, ord) => fromTree(fromIterable11(Array.from(iterable).map((k) => [k, true]), ord)));
var add5 = /* @__PURE__ */ dual(2, (self, value3) => has8(self.keyTree, value3) ? self : fromTree(insert2(self.keyTree, value3, true)));
var every8 = /* @__PURE__ */ dual(2, (self, predicate) => {
  for (const value3 of self) {
    if (!predicate(value3)) {
      return false;
    }
  }
  return true;
});
var has9 = /* @__PURE__ */ dual(2, (self, value3) => has8(self.keyTree, value3));
var isSubset2 = /* @__PURE__ */ dual(2, (self, that) => every8(self, (a) => has9(that, a)));
var remove8 = /* @__PURE__ */ dual(2, (self, value3) => fromTree(removeFirst2(self.keyTree, value3)));
var values4 = (self) => keys5(self.keyTree);
var getEquivalence6 = () => (a, b) => isSubset2(a, b) && isSubset2(b, a);

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey = "effect/Supervisor";
var SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
var supervisorVariance = {
  /* c8 ignore next */
  _T: (_) => _
};
var _a38;
_a38 = SupervisorTypeId;
var _ProxySupervisor = class _ProxySupervisor {
  constructor(underlying, value0) {
    __publicField(this, "underlying");
    __publicField(this, "value0");
    __publicField(this, _a38, supervisorVariance);
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context9, effect4, parent, fiber) {
    this.underlying.onStart(context9, effect4, parent, fiber);
  }
  onEnd(value3, fiber) {
    this.underlying.onEnd(value3, fiber);
  }
  onEffect(fiber, effect4) {
    this.underlying.onEffect(fiber, effect4);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f) {
    return new _ProxySupervisor(this, pipe(this.value, map10(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
};
var ProxySupervisor = _ProxySupervisor;
var _a39;
_a39 = SupervisorTypeId;
var _Zip = class _Zip {
  constructor(left3, right3) {
    __publicField(this, "left");
    __publicField(this, "right");
    __publicField(this, "_tag", "Zip");
    __publicField(this, _a39, supervisorVariance);
    this.left = left3;
    this.right = right3;
  }
  get value() {
    return zip3(this.left.value, this.right.value);
  }
  onStart(context9, effect4, parent, fiber) {
    this.left.onStart(context9, effect4, parent, fiber);
    this.right.onStart(context9, effect4, parent, fiber);
  }
  onEnd(value3, fiber) {
    this.left.onEnd(value3, fiber);
    this.right.onEnd(value3, fiber);
  }
  onEffect(fiber, effect4) {
    this.left.onEffect(fiber, effect4);
    this.right.onEffect(fiber, effect4);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map10(f)));
  }
  zip(right3) {
    return new _Zip(this, right3);
  }
};
var Zip = _Zip;
var isZip = (self) => hasProperty(self, SupervisorTypeId) && isTagged(self, "Zip");
var _a40;
_a40 = SupervisorTypeId;
var Track = class {
  constructor() {
    __publicField(this, _a40, supervisorVariance);
    __publicField(this, "fibers", /* @__PURE__ */ new Set());
  }
  get value() {
    return sync(() => Array.from(this.fibers));
  }
  onStart(_context, _effect, _parent, fiber) {
    this.fibers.add(fiber);
  }
  onEnd(_value2, fiber) {
    this.fibers.delete(fiber);
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map10(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var _a41;
_a41 = SupervisorTypeId;
var Const = class {
  constructor(effect4) {
    __publicField(this, "effect");
    __publicField(this, _a41, supervisorVariance);
    this.effect = effect4;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {
  }
  onEnd(_value2, _fiber) {
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map10(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var _a42;
_a42 = SupervisorTypeId;
var FibersIn = class {
  constructor(ref) {
    __publicField(this, "ref");
    __publicField(this, _a42, supervisorVariance);
    this.ref = ref;
  }
  get value() {
    return sync(() => get6(this.ref));
  }
  onStart(_context, _effect, _parent, fiber) {
    pipe(this.ref, set2(pipe(get6(this.ref), add5(fiber))));
  }
  onEnd(_value2, fiber) {
    pipe(this.ref, set2(pipe(get6(this.ref), remove8(fiber))));
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map10(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var unsafeTrack = () => {
  return new Track();
};
var track = /* @__PURE__ */ sync(unsafeTrack);
var fromEffect2 = (effect4) => {
  return new Const(effect4);
};
var none8 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect2(void_2));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Differ.js
var make33 = make15;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY3 = "Empty";
var OP_ADD_SUPERVISOR = "AddSupervisor";
var OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
var OP_AND_THEN2 = "AndThen";
var empty25 = {
  _tag: OP_EMPTY3
};
var combine8 = (self, that) => {
  return {
    _tag: OP_AND_THEN2,
    first: self,
    second: that
  };
};
var patch8 = (self, supervisor) => {
  return patchLoop(supervisor, of2(self));
};
var patchLoop = (_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty(patches)) {
    const head8 = headNonEmpty2(patches);
    switch (head8._tag) {
      case OP_EMPTY3: {
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_ADD_SUPERVISOR: {
        supervisor = supervisor.zip(head8.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_REMOVE_SUPERVISOR: {
        supervisor = removeSupervisor(supervisor, head8.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_AND_THEN2: {
        patches = prepend2(head8.first)(prepend2(head8.second)(tailNonEmpty2(patches)));
        break;
      }
    }
  }
  return supervisor;
};
var removeSupervisor = (self, that) => {
  if (equals(self, that)) {
    return none8;
  } else {
    if (isZip(self)) {
      return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));
    } else {
      return self;
    }
  }
};
var toSet2 = (self) => {
  if (equals(self, none8)) {
    return empty8();
  } else {
    if (isZip(self)) {
      return pipe(toSet2(self.left), union5(toSet2(self.right)));
    } else {
      return make10(self);
    }
  }
};
var diff7 = (oldValue, newValue) => {
  if (equals(oldValue, newValue)) {
    return empty25;
  }
  const oldSupervisors = toSet2(oldValue);
  const newSupervisors = toSet2(newValue);
  const added = pipe(newSupervisors, difference4(oldSupervisors), reduce5(empty25, (patch9, supervisor) => combine8(patch9, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = pipe(oldSupervisors, difference4(newSupervisors), reduce5(empty25, (patch9, supervisor) => combine8(patch9, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine8(added, removed);
};
var differ2 = /* @__PURE__ */ make33({
  empty: empty25,
  patch: patch8,
  combine: combine8,
  diff: diff7
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted = /* @__PURE__ */ counter5("effect_fiber_started", {
  incremental: true
});
var fiberActive = /* @__PURE__ */ counter5("effect_fiber_active");
var fiberSuccesses = /* @__PURE__ */ counter5("effect_fiber_successes", {
  incremental: true
});
var fiberFailures = /* @__PURE__ */ counter5("effect_fiber_failures", {
  incremental: true
});
var fiberLifetimes = /* @__PURE__ */ tagged(/* @__PURE__ */ histogram5("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
var EvaluationSignalContinue = "Continue";
var EvaluationSignalDone = "Done";
var EvaluationSignalYieldNow = "Yield";
var runtimeFiberVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var absurd = (_) => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
var YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
var yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
var contOpSuccess = {
  [OP_ON_SUCCESS]: (_, cont, value3) => {
    return internalCall(() => cont.effect_instruction_i1(value3));
  },
  ["OnStep"]: (_, _cont, value3) => {
    return exitSucceed(exitSucceed(value3));
  },
  [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value3) => {
    return internalCall(() => cont.effect_instruction_i2(value3));
  },
  [OP_REVERT_FLAGS]: (self, cont, value3) => {
    self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch);
    if (interruptible(self.currentRuntimeFlags) && self.isInterrupted()) {
      return exitFailCause(self.getInterruptedCause());
    } else {
      return exitSucceed(value3);
    }
  },
  [OP_WHILE]: (self, cont, value3) => {
    internalCall(() => cont.effect_instruction_i2(value3));
    if (internalCall(() => cont.effect_instruction_i0())) {
      self.pushStack(cont);
      return internalCall(() => cont.effect_instruction_i1());
    } else {
      return void_2;
    }
  },
  [OP_ITERATOR]: (self, cont, value3) => {
    const state = internalCall(() => cont.effect_instruction_i0.next(value3));
    if (state.done) return exitSucceed(state.value);
    self.pushStack(cont);
    return yieldWrapGet(state.value);
  }
};
var drainQueueWhileRunningTable = {
  [OP_INTERRUPT_SIGNAL]: (self, runtimeFlags2, cur, message) => {
    self.processNewInterruptSignal(message.cause);
    return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
  },
  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL]: (self, runtimeFlags2, cur, message) => {
    message.onFiber(self, running2(runtimeFlags2));
    return cur;
  },
  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return flatMap9(yieldNow(), () => cur);
  }
};
var runBlockedRequests = (self) => forEachSequentialDiscard(flatten5(self), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential5]) => {
  const map31 = /* @__PURE__ */ new Map();
  const arr = [];
  for (const block of sequential5) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map31.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map31);
}, false, false));
var _version = /* @__PURE__ */ getCurrentVersion();
var _a43, _b12;
var FiberRuntime = class extends Class2 {
  constructor(fiberId3, fiberRefs0, runtimeFlags0) {
    super();
    __publicField(this, _b12, fiberVariance2);
    __publicField(this, _a43, runtimeFiberVariance);
    __publicField(this, "_fiberRefs");
    __publicField(this, "_fiberId");
    __publicField(this, "_queue", /* @__PURE__ */ new Array());
    __publicField(this, "_children", null);
    __publicField(this, "_observers", /* @__PURE__ */ new Array());
    __publicField(this, "_running", false);
    __publicField(this, "_stack", []);
    __publicField(this, "_asyncInterruptor", null);
    __publicField(this, "_asyncBlockingOn", null);
    __publicField(this, "_exitValue", null);
    __publicField(this, "_steps", []);
    __publicField(this, "_isYielding", false);
    __publicField(this, "currentRuntimeFlags");
    __publicField(this, "currentOpCount", 0);
    __publicField(this, "currentSupervisor");
    __publicField(this, "currentScheduler");
    __publicField(this, "currentTracer");
    __publicField(this, "currentSpan");
    __publicField(this, "currentContext");
    __publicField(this, "currentDefaultServices");
    __publicField(this, "run", () => {
      this.drainQueueOnCurrentThread();
    });
    this.currentRuntimeFlags = runtimeFlags0;
    this._fiberId = fiberId3;
    this._fiberRefs = fiberRefs0;
    if (runtimeMetrics(runtimeFlags0)) {
      const tags = this.getFiberRef(currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags);
      fiberActive.unsafeUpdate(1, tags);
    }
    this.refreshRefCache();
  }
  commit() {
    return join3(this);
  }
  /**
   * The identity of the fiber.
   */
  id() {
    return this._fiberId;
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background. This can be called to "kick off" execution of a fiber after
   * it has been created.
   */
  resume(effect4) {
    this.tell(resume(effect4));
  }
  /**
   * The status of the fiber.
   */
  get status() {
    return this.ask((_, status3) => status3);
  }
  /**
   * Gets the fiber runtime flags.
   */
  get runtimeFlags() {
    return this.ask((state, status3) => {
      if (isDone3(status3)) {
        return state.currentRuntimeFlags;
      }
      return status3.runtimeFlags;
    });
  }
  /**
   * Returns the current `FiberScope` for the fiber.
   */
  scope() {
    return unsafeMake8(this);
  }
  /**
   * Retrieves the immediate children of the fiber.
   */
  get children() {
    return this.ask((fiber) => Array.from(fiber.getChildren()));
  }
  /**
   * Gets the fiber's set of children.
   */
  getChildren() {
    if (this._children === null) {
      this._children = /* @__PURE__ */ new Set();
    }
    return this._children;
  }
  /**
   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
   * if the fiber has not been interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause);
  }
  /**
   * Retrieves the whole set of fiber refs.
   */
  fiberRefs() {
    return this.ask((fiber) => fiber.getFiberRefs());
  }
  /**
   * Returns an effect that will contain information computed from the fiber
   * state and status while running on the fiber.
   *
   * This allows the outside world to interact safely with mutable fiber state
   * without locks or immutable data.
   */
  ask(f) {
    return suspend(() => {
      const deferred = deferredUnsafeMake(this._fiberId);
      this.tell(stateful((fiber, status3) => {
        deferredUnsafeDone(deferred, sync(() => f(fiber, status3)));
      }));
      return deferredAwait(deferred);
    });
  }
  /**
   * Adds a message to be processed by the fiber on the fiber.
   */
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return async_((resume2) => {
      const cb = (exit4) => resume2(succeed(exit4));
      this.tell(stateful((fiber, _) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync(() => this.tell(stateful((fiber, _) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch9 = pipe(
        diff4(parentRuntimeFlags, updatedRuntimeFlags),
        // Do not inherit WindDown or Interruption!
        exclude2(Interruption),
        exclude2(WindDown)
      );
      return updateRuntimeFlags(patch9);
    });
  }
  /**
   * Tentatively observes the fiber, but returns immediately if it is not
   * already done.
   */
  get poll() {
    return sync(() => fromNullable(this._exitValue));
  }
  /**
   * Unsafely observes the fiber, but returns immediately if it is not
   * already done.
   */
  unsafePoll() {
    return this._exitValue;
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  interruptAsFork(fiberId3) {
    return sync(() => this.tell(interruptSignal(interrupt(fiberId3))));
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  unsafeInterruptAsFork(fiberId3) {
    this.tell(interruptSignal(interrupt(fiberId3)));
  }
  /**
   * Adds an observer to the list of observers.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  /**
   * Removes the specified observer from the list of observers that will be
   * notified when the fiber exits.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeObserver(observer) {
    this._observers = this._observers.filter((o) => o !== observer);
  }
  /**
   * Retrieves all fiber refs of the fiber.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
    return this._fiberRefs;
  }
  /**
   * Deletes the specified fiber ref.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_(this._fiberRefs, fiberRef);
  }
  /**
   * Retrieves the state of the fiber ref, or else its initial value.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  /**
   * Sets the fiber ref to the specified value.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRef(fiberRef, value3) {
    this._fiberRefs = updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value: value3
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(currentServices);
    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
    this.currentSupervisor = this.getFiberRef(currentSupervisor);
    this.currentScheduler = this.getFiberRef(currentScheduler);
    this.currentContext = this.getFiberRef(currentContext);
    this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
  }
  /**
   * Wholesale replaces all fiber refs of this fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRefs(fiberRefs3) {
    this._fiberRefs = fiberRefs3;
    this.refreshRefCache();
  }
  /**
   * Adds a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addChild(child) {
    this.getChildren().add(child);
  }
  /**
   * Removes a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeChild(child) {
    this.getChildren().delete(child);
  }
  /**
   * Transfers all children of this fiber that are currently running to the
   * specified fiber scope.
   *
   * **NOTE**: This method must be invoked by the fiber itself after it has
   * evaluated the effects but prior to exiting.
   */
  transferChildren(scope5) {
    const children3 = this._children;
    this._children = null;
    if (children3 !== null && children3.size > 0) {
      for (const child of children3) {
        if (child._exitValue === null) {
          scope5.add(this.currentRuntimeFlags, child);
        }
      }
    }
  }
  /**
   * On the current thread, executes all messages in the fiber's inbox. This
   * method may return before all work is done, in the event the fiber executes
   * an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
      }
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  /**
   * Schedules the execution of all messages in the fiber's inbox.
   *
   * This method will return immediately after the scheduling
   * operation is completed, but potentially before such messages have been
   * executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
  }
  /**
   * Drains the fiber's message queue while the fiber is actively running,
   * returning the next effect to execute, which may be the input effect if no
   * additional effect needs to be executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueWhileRunning(runtimeFlags2, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
    }
    return cur;
  }
  /**
   * Determines if the fiber is interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  isInterrupted() {
    return !isEmpty3(this.getFiberRef(currentInterruptedCause));
  }
  /**
   * Adds an interruptor to the set of interruptors that are interrupting this
   * fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addInterruptedCause(cause3) {
    const oldSC = this.getFiberRef(currentInterruptedCause);
    this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause3));
  }
  /**
   * Processes a new incoming interrupt signal.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  processNewInterruptSignal(cause3) {
    this.addInterruptedCause(cause3);
    this.sendInterruptSignalToAllChildren();
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal(interrupt(this.id())));
      told = true;
    }
    return told;
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it = this._children.values();
      this._children = null;
      let isDone7 = false;
      const body = () => {
        const next4 = it.next();
        if (!next4.done) {
          return asVoid2(next4.value.await);
        } else {
          return sync(() => {
            isDone7 = true;
          });
        }
      };
      return whileLoop({
        while: () => !isDone7,
        body,
        step: () => {
        }
      });
    }
    return null;
  }
  reportExitValue(exit4) {
    if (runtimeMetrics(this.currentRuntimeFlags)) {
      const tags = this.getFiberRef(currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
      fiberActive.unsafeUpdate(-1, tags);
      switch (exit4._tag) {
        case OP_SUCCESS: {
          fiberSuccesses.unsafeUpdate(1, tags);
          break;
        }
        case OP_FAILURE: {
          fiberFailures.unsafeUpdate(1, tags);
          break;
        }
      }
    }
    if (exit4._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel);
      if (!isInterruptedOnly(exit4.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit4.cause, level);
      }
    }
  }
  setExitValue(exit4) {
    this._exitValue = exit4;
    this.reportExitValue(exit4);
    for (let i = this._observers.length - 1; i >= 0; i--) {
      this._observers[i](exit4);
    }
    this._observers = [];
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause3, overrideLogLevel) {
    const logLevel2 = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
    const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
    if (greaterThan3(minimumLogLevel, logLevel2)) {
      return;
    }
    const spans = this.getFiberRef(currentLogSpan);
    const annotations5 = this.getFiberRef(currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (size4(loggers) > 0) {
      const clockService = get2(this.getFiberRef(currentServices), clockTag);
      const date3 = new Date(clockService.unsafeCurrentTimeMillis());
      withRedactableContext(contextMap, () => {
        for (const logger of loggers) {
          logger.log({
            fiberId: this.id(),
            logLevel: logLevel2,
            message,
            cause: cause3,
            context: contextMap,
            spans,
            annotations: annotations5,
            date: date3
          });
        }
      });
    }
  }
  /**
   * Evaluates a single message on the current thread, while the fiber is
   * suspended. This method should only be called while evaluation of the
   * fiber's effect is suspended due to an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW: {
        return EvaluationSignalYieldNow;
      }
      case OP_INTERRUPT_SIGNAL: {
        this.processNewInterruptSignal(message.cause);
        if (this._asyncInterruptor !== null) {
          this._asyncInterruptor(exitFailCause(message.cause));
          this._asyncInterruptor = null;
        }
        return EvaluationSignalContinue;
      }
      case OP_RESUME: {
        this._asyncInterruptor = null;
        this._asyncBlockingOn = null;
        this.evaluateEffect(message.effect);
        return EvaluationSignalContinue;
      }
      case OP_STATEFUL: {
        message.onFiber(this, this._exitValue !== null ? done4 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
        return EvaluationSignalContinue;
      }
      default: {
        return absurd(message);
      }
    }
  }
  /**
   * Evaluates an effect until completion, potentially asynchronously.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this);
    try {
      let effect4 = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
      while (effect4 !== null) {
        const eff = effect4;
        const exit4 = this.runLoop(eff);
        if (exit4 === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OP_YIELD) {
            if (cooperativeYielding(this.currentRuntimeFlags)) {
              this.tell(yieldNow3());
              this.tell(resume(exitVoid));
              effect4 = null;
            } else {
              effect4 = exitVoid;
            }
          } else if (op._op === OP_ASYNC) {
            effect4 = null;
          }
        } else {
          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
          const interruption2 = this.interruptAllChildren();
          if (interruption2 !== null) {
            effect4 = flatMap9(interruption2, () => exit4);
          } else {
            if (this._queue.length === 0) {
              this.setExitValue(exit4);
            } else {
              this.tell(resume(exit4));
            }
            effect4 = null;
          }
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this);
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on the current
   * thread. This can be called to "kick off" execution of a fiber after it has
   * been created, in hopes that the effect can be executed synchronously.
   *
   * This is not the normal way of starting a fiber, but it is useful when the
   * express goal of executing the fiber is to synchronously produce its exit.
   */
  start(effect4) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        this.evaluateEffect(effect4);
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume(effect4));
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background, and on the correct thread pool. This can be called to "kick
   * off" execution of a fiber after it has been created, in hopes that the
   * effect can be executed synchronously.
   */
  startFork(effect4) {
    this.tell(resume(effect4));
  }
  /**
   * Takes the current runtime flags, patches them to return the new runtime
   * flags, and then makes any changes necessary to fiber state based on the
   * specified patch.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  patchRuntimeFlags(oldRuntimeFlags, patch9) {
    const newRuntimeFlags = patch4(oldRuntimeFlags, patch9);
    globalThis[currentFiberURI] = this;
    this.currentRuntimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  /**
   * Initiates an asynchronous operation, by building a callback that will
   * resume execution, and then feeding that callback to the registration
   * function, handling error cases and repeated resumptions appropriately.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  initiateAsync(runtimeFlags2, asyncRegister) {
    let alreadyCalled = false;
    const callback = (effect4) => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume(effect4));
      }
    };
    if (interruptible(runtimeFlags2)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause(die(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this.currentRuntimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [(_b12 = FiberTypeId, _a43 = RuntimeFiberTypeId, OP_TAG)](op) {
    return sync(() => unsafeGet2(this.currentContext, op));
  }
  ["Left"](op) {
    return fail2(op.left);
  }
  ["None"](_) {
    return fail2(new NoSuchElementException());
  }
  ["Right"](op) {
    return exitSucceed(op.right);
  }
  ["Some"](op) {
    return exitSucceed(op.value);
  }
  ["Micro"](op) {
    return unsafeAsync((microResume) => {
      let resume2 = microResume;
      const fiber = runFork(provideContext2(op, this.currentContext));
      fiber.addObserver((exit4) => {
        if (exit4._tag === "Success") {
          return resume2(exitSucceed(exit4.value));
        }
        switch (exit4.cause._tag) {
          case "Interrupt": {
            return resume2(exitFailCause(interrupt(none4)));
          }
          case "Fail": {
            return resume2(fail2(exit4.cause.error));
          }
          case "Die": {
            return resume2(die2(exit4.cause.defect));
          }
        }
      });
      return unsafeAsync((abortResume) => {
        resume2 = (_) => {
          abortResume(void_2);
        };
        fiber.unsafeInterrupt();
      });
    });
  }
  [OP_SYNC](op) {
    const value3 = internalCall(() => op.effect_instruction_i0());
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, value3);
    } else {
      yieldedOpChannel.currentOp = exitSucceed(value3);
      return YieldedOp;
    }
  }
  [OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OP_FAILURE](op) {
    const cause3 = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== void 0) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE: {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return internalCall(() => cont.effect_instruction_i1(cause3));
          } else {
            return exitFailCause(stripFailures(cause3));
          }
        }
        case "OnStep": {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return exitSucceed(exitFailCause(cause3));
          } else {
            return exitFailCause(stripFailures(cause3));
          }
        }
        case OP_REVERT_FLAGS: {
          this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
          if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
            return exitFailCause(sequential(cause3, this.getInterruptedCause()));
          } else {
            return exitFailCause(cause3);
          }
        }
        default: {
          absurd(cont);
        }
      }
    } else {
      yieldedOpChannel.currentOp = exitFailCause(cause3);
      return YieldedOp;
    }
  }
  [OP_WITH_RUNTIME](op) {
    return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this.currentRuntimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this.currentRuntimeFlags = snap.flags;
      const patchRefs = diff6(snap.refs, refs);
      const patchFlags = diff4(snap.flags, flags);
      return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(patch7(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber.currentRuntimeFlags = patch4(patchFlags)(newFiber.currentRuntimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask((restore) => flatMap9(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this.currentRuntimeFlags;
    const newRuntimeFlags = patch4(oldRuntimeFlags, updateFlags);
    if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause(this.getInterruptedCause());
    } else {
      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        const revertFlags = diff4(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags(revertFlags, op));
        return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
      } else {
        return exitVoid;
      }
    }
  }
  [OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_YIELD](op) {
    this._isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_WHILE](op) {
    const check4 = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check4()) {
      this.pushStack(op);
      return body();
    } else {
      return exitVoid;
    }
  }
  [OP_ITERATOR](op) {
    return contOpSuccess[OP_ITERATOR](this, op, void 0);
  }
  [OP_COMMIT](op) {
    return internalCall(() => op.commit());
  }
  /**
   * The main run-loop for evaluating effects.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
        this.currentSupervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
      }
      if (!this._isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this.currentScheduler.shouldYield(this);
        if (shouldYield !== false) {
          this._isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = flatMap9(yieldNow({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        cur = this.currentTracer.context(() => {
          if (_version !== cur[EffectTypeId2]._V) {
            return dieMessage(`Cannot execute an Effect versioned ${cur[EffectTypeId2]._V} with a Runtime of version ${getCurrentVersion()}`);
          }
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OP_YIELD || op._op === OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
        }
      } catch (e) {
        if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
          cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
        } else if (isInterruptedException(e)) {
          cur = exitFailCause(sequential(die(e), interrupt(none4)));
        } else {
          cur = die2(e);
        }
      }
    }
  }
};
var currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
var loggerWithConsoleLog = (self) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get2(services, consoleTag).unsafe.log(self.log(opts));
});
var defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
var tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
  annotations: annotations5,
  cause: cause3,
  context: context9,
  fiberId: fiberId3,
  logLevel: logLevel2,
  message
}) => {
  const span4 = getOption2(getOrDefault(context9, currentContext), spanTag);
  if (span4._tag === "None" || span4.value._tag === "ExternalSpan") {
    return;
  }
  const clockService = unsafeGet2(getOrDefault(context9, currentServices), clockTag);
  const attributes = {};
  for (const [key, value3] of annotations5) {
    attributes[key] = value3;
  }
  attributes["effect.fiberId"] = threadName2(fiberId3);
  attributes["effect.logLevel"] = logLevel2.label;
  if (cause3 !== null && cause3._tag !== "Empty") {
    attributes["effect.cause"] = pretty(cause3, {
      renderErrorCause: true
    });
  }
  span4.value.event(toStringUnknown(Array.isArray(message) ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
var currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make10(defaultLogger, tracerLogger)));
var annotateLogsScoped = function() {
  if (typeof arguments[0] === "string") {
    return fiberRefLocallyScopedWith(currentLogAnnotations, set3(arguments[0], arguments[1]));
  }
  const entries3 = Object.entries(arguments[0]);
  return fiberRefLocallyScopedWith(currentLogAnnotations, mutate3((annotations5) => {
    for (let i = 0; i < entries3.length; i++) {
      const [key, value3] = entries3[i];
      set3(annotations5, key, value3);
    }
    return annotations5;
  }));
};
var whenLogLevel = /* @__PURE__ */ dual(2, (effect4, level) => {
  const requiredLogLevel = typeof level === "string" ? fromLiteral(level) : level;
  return withFiberRuntime((fiberState) => {
    const minimumLogLevel = fiberState.getFiberRef(currentMinimumLogLevel);
    if (greaterThan3(minimumLogLevel, requiredLogLevel)) {
      return succeed(none2());
    }
    return map10(effect4, some2);
  });
});
var acquireRelease = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => uninterruptible(tap2(acquire, (a) => addFinalizer((exit4) => release(a, exit4)))));
var acquireReleaseInterruptible = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => ensuring(acquire, addFinalizer((exit4) => release(exit4))));
var addFinalizer = (finalizer3) => withFiberRuntime((runtime5) => {
  const acquireRefs = runtime5.getFiberRefs();
  const acquireFlags = runtime5.currentRuntimeFlags;
  return flatMap9(scope, (scope5) => scopeAddFinalizerExit(scope5, (exit4) => withFiberRuntime((runtimeFinalizer) => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer.currentRuntimeFlags;
    const patchRefs = diff6(preRefs, acquireRefs);
    const patchFlags = diff4(preFlags, acquireFlags);
    const inverseRefs = diff6(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(patch7(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring(withRuntimeFlags(finalizer3(exit4), patchFlags), sync(() => {
      runtimeFinalizer.setFiberRefs(patch7(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
});
var daemonChildren = (self) => {
  const forkScope = fiberRefLocally(currentForkScopeOverride, some2(globalScope));
  return forkScope(self);
};
var _existsParFound = /* @__PURE__ */ Symbol.for("effect/Effect/existsPar/found");
var exists2 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => matchSimple(options?.concurrency, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => matchEffect(forEach9(elements, (a, i) => if_(predicate(a, i), {
  onTrue: () => fail2(_existsParFound),
  onFalse: () => void_2
}), options), {
  onFailure: (e) => e === _existsParFound ? succeed(true) : fail2(e),
  onSuccess: () => succeed(false)
})));
var existsLoop = (iterator, index, f) => {
  const next4 = iterator.next();
  if (next4.done) {
    return succeed(false);
  }
  return pipe(flatMap9(f(next4.value, index), (b) => b ? succeed(b) : existsLoop(iterator, index + 1, f)));
};
var filter7 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => {
  const predicate_ = options?.negate ? (a, i) => map10(predicate(a, i), not) : predicate;
  return matchSimple(options?.concurrency, () => suspend(() => fromIterable2(elements).reduceRight((effect4, a, i) => zipWith4(effect4, suspend(() => predicate_(a, i)), (list, b) => b ? [a, ...list] : list), sync(() => new Array()))), () => map10(forEach9(elements, (a, i) => map10(predicate_(a, i), (b) => b ? some2(a) : none2()), options), getSomes2));
});
var allResolveInput = (input) => {
  if (Array.isArray(input) || isIterable(input)) {
    return [input, none2()];
  }
  const keys6 = Object.keys(input);
  const size17 = keys6.length;
  return [keys6.map((k) => input[k]), some2((values5) => {
    const res = {};
    for (let i = 0; i < size17; i++) {
      ;
      res[keys6[i]] = values5[i];
    }
    return res;
  })];
};
var allValidate = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect4 of effects) {
    eitherEffects.push(either2(effect4));
  }
  return flatMap9(forEach9(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => {
    const none10 = none2();
    const size17 = eithers.length;
    const errors2 = new Array(size17);
    const successes = new Array(size17);
    let errored = false;
    for (let i = 0; i < size17; i++) {
      const either8 = eithers[i];
      if (either8._tag === "Left") {
        errors2[i] = some2(either8.left);
        errored = true;
      } else {
        successes[i] = either8.right;
        errors2[i] = none10;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? fail2(reconcile.value(errors2)) : fail2(errors2);
    } else if (options?.discard) {
      return void_2;
    }
    return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
  });
};
var allEither = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect4 of effects) {
    eitherEffects.push(either2(effect4));
  }
  if (options?.discard) {
    return forEach9(eitherEffects, identity, {
      concurrency: options?.concurrency,
      batching: options?.batching,
      discard: true,
      concurrentFinalizers: options?.concurrentFinalizers
    });
  }
  return map10(forEach9(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
};
var all5 = (arg, options) => {
  const [effects, reconcile] = allResolveInput(arg);
  if (options?.mode === "validate") {
    return allValidate(effects, reconcile, options);
  } else if (options?.mode === "either") {
    return allEither(effects, reconcile, options);
  }
  return options?.discard !== true && reconcile._tag === "Some" ? map10(forEach9(effects, identity, options), reconcile.value) : forEach9(effects, identity, options);
};
var allWith = (options) => (arg) => all5(arg, options);
var allSuccesses = (elements, options) => map10(all5(fromIterable2(elements).map(exit), options), filterMap3((exit4) => exitIsSuccess(exit4) ? some2(exit4.effect_instruction_i0) : none2()));
var replicate = /* @__PURE__ */ dual(2, (self, n) => Array.from({
  length: n
}, () => self));
var replicateEffect = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self, n, options) => all5(replicate(self, n), options));
var forEach9 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (self, f, options) => withFiberRuntime((r) => {
  const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
  if (options?.discard) {
    return match7(options.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
  }
  return match7(options?.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachParUnbounded(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachParN(self, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
}));
var forEachParUnbounded = (self, f, batching) => suspend(() => {
  const as13 = fromIterable2(self);
  const array6 = new Array(as13.length);
  const fn2 = (a, i) => flatMap9(f(a, i), (b) => sync(() => array6[i] = b));
  return zipRight2(forEachConcurrentDiscard(as13, fn2, batching, false), succeed(array6));
});
var forEachConcurrentDiscard = (self, f, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
  let todos = Array.from(self).reverse();
  let target = todos.length;
  if (target === 0) {
    return void_2;
  }
  let counter6 = 0;
  let interrupted4 = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers = /* @__PURE__ */ new Set();
  const results = new Array();
  const interruptAll3 = () => fibers.forEach((fiber) => {
    fiber.currentScheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  });
  const startOrder = new Array();
  const joinOrder = new Array();
  const residual = new Array();
  const collectExits = () => {
    const exits = results.filter(({
      exit: exit4
    }) => exit4._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
      exit: exit4
    }) => exit4);
    if (exits.length === 0) {
      exits.push(exitVoid);
    }
    return exits;
  };
  const runFiber = (eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
    parent.currentScheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  };
  const onInterruptSignal = () => {
    if (!processAll) {
      target -= todos.length;
      todos = [];
    }
    interrupted4 = true;
    interruptAll3();
  };
  const stepOrExit = batching ? step2 : exit;
  const processingFiber = runFiber(async_((resume2) => {
    const pushResult = (res, index) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index,
          exit: res
        });
        if (res._op === "Failure" && !interrupted4) {
          onInterruptSignal();
        }
      }
    };
    const next4 = () => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index = counter6++;
        const returnNextElement = () => {
          const a2 = todos.pop();
          index = counter6++;
          return flatMap9(yieldNow(), () => flatMap9(stepOrExit(restore(f(a2, index))), onRes));
        };
        const onRes = (res) => {
          if (todos.length > 0) {
            pushResult(res, index);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed(res);
        };
        const todo = flatMap9(stepOrExit(restore(f(a, index))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers.add(fiber);
        if (interrupted4) {
          fiber.currentScheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver((wrapped) => {
          let exit4;
          if (wrapped._op === "Failure") {
            exit4 = wrapped;
          } else {
            exit4 = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers.delete(fiber);
          pushResult(exit4, index);
          if (results.length === target) {
            resume2(succeed(getOrElse3(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid)));
          } else if (residual.length + results.length === target) {
            const exits = collectExits();
            const requests = residual.map((blocked3) => blocked3.effect_instruction_i0).reduce(par);
            resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse3(exitCollectAll(exits, {
              parallel: true
            }), () => exitVoid), ...residual.map((blocked3) => blocked3.effect_instruction_i1)], (i) => i, batching, true, n))));
          } else {
            next4();
          }
        });
      }
    };
    for (let i = 0; i < fibersCount; i++) {
      next4();
    }
  }));
  return asVoid2(onExit(flatten6(restore(join3(processingFiber))), exitMatch({
    onFailure: (cause3) => {
      onInterruptSignal();
      const target2 = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async_((cb) => {
        const exits = [];
        let count4 = 0;
        let index = 0;
        const check4 = (index2, hitNext) => (exit4) => {
          exits[index2] = exit4;
          count4++;
          if (count4 === target2) {
            cb(exitSucceed(exitFailCause(cause3)));
          }
          if (toPop.length > 0 && hitNext) {
            next4();
          }
        };
        const next4 = () => {
          runFiber(toPop.pop(), true).addObserver(check4(index, true));
          index++;
        };
        processingFiber.addObserver(check4(index, false));
        index++;
        for (let i = 0; i < concurrency; i++) {
          next4();
        }
      });
    },
    onSuccess: () => forEachSequential(joinOrder, (f2) => f2.inheritAll)
  })));
})));
var forEachParN = (self, n, f, batching) => suspend(() => {
  const as13 = fromIterable2(self);
  const array6 = new Array(as13.length);
  const fn2 = (a, i) => map10(f(a, i), (b) => array6[i] = b);
  return zipRight2(forEachConcurrentDiscard(as13, fn2, batching, false, n), succeed(array6));
});
var fork = (self) => withFiberRuntime((state, status3) => succeed(unsafeFork2(self, state, status3.runtimeFlags)));
var forkDaemon = (self) => forkWithScopeOverride(self, globalScope);
var forkWithErrorHandler = /* @__PURE__ */ dual(2, (self, handler) => fork(onError(self, (cause3) => {
  const either8 = failureOrCause(cause3);
  switch (either8._tag) {
    case "Left":
      return handler(either8.left);
    case "Right":
      return failCause(either8.right);
  }
})));
var unsafeFork2 = (effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect4, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect4);
  return childFiber;
};
var unsafeForkUnstarted = (effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect4, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
};
var unsafeMakeChildFiber = (effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake3();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault(childFiberRefs, currentContext);
  const supervisor = childFiber.currentSupervisor;
  supervisor.onStart(childContext, effect4, some2(parentFiber), childFiber);
  childFiber.addObserver((exit4) => supervisor.onEnd(exit4, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse3(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
};
var forkWithScopeOverride = (self, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork2(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
var mergeAll3 = /* @__PURE__ */ dual((args2) => isFunction2(args2[2]), (elements, zero3, f, options) => matchSimple(options?.concurrency, () => fromIterable2(elements).reduce((acc, a, i) => zipWith4(acc, a, (acc2, a2) => f(acc2, a2, i)), succeed(zero3)), () => flatMap9(make25(zero3), (acc) => flatMap9(forEach9(elements, (effect4, i) => flatMap9(effect4, (a) => update3(acc, (b) => f(b, a, i))), options), () => get11(acc)))));
var partition4 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => pipe(forEach9(elements, (a, i) => either2(f(a, i)), options), map10((chunk4) => partitionMap4(chunk4, identity))));
var validateAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => flatMap9(partition4(elements, f, {
  concurrency: options?.concurrency,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([es, bs]) => isNonEmptyArray2(es) ? fail2(es) : options?.discard ? void_2 : succeed(bs)));
var raceAll = (all11) => {
  const list = fromIterable3(all11);
  if (!isNonEmpty(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  const self = headNonEmpty2(list);
  const effects = tailNonEmpty2(list);
  const inheritAll3 = (res) => pipe(inheritAll(res[1]), as2(res[0]));
  return pipe(deferredMake(), flatMap9((done12) => pipe(make25(effects.length), flatMap9((fails) => uninterruptibleMask((restore) => pipe(fork(interruptible2(self)), flatMap9((head8) => pipe(effects, forEachSequential((effect4) => fork(interruptible2(effect4))), map10((fibers) => unsafeFromArray(fibers)), map10((tail2) => pipe(tail2, prepend2(head8))), tap2((fibers) => pipe(fibers, reduce(void_2, (effect4, fiber) => pipe(effect4, zipRight2(pipe(_await2(fiber), flatMap9(raceAllArbiter(fibers, fiber, done12, fails)), fork, asVoid2)))))), flatMap9((fibers) => pipe(restore(pipe(_await(done12), flatMap9(inheritAll3))), onInterrupt(() => pipe(fibers, reduce(void_2, (effect4, fiber) => pipe(effect4, zipLeft2(interruptFiber(fiber))))))))))))))));
};
var raceAllArbiter = (fibers, winner, deferred, fails) => (exit4) => exitMatchEffect(exit4, {
  onFailure: (cause3) => pipe(modify6(fails, (fails2) => [fails2 === 0 ? pipe(deferredFailCause(deferred, cause3), asVoid2) : void_2, fails2 - 1]), flatten6),
  onSuccess: (value3) => pipe(deferredSucceed(deferred, [value3, winner]), flatMap9((set10) => set10 ? pipe(fromIterable3(fibers), reduce(void_2, (effect4, fiber) => fiber === winner ? effect4 : pipe(effect4, zipLeft2(interruptFiber(fiber))))) : void_2))
});
var reduceEffect = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, zero3, f, options) => matchSimple(options?.concurrency, () => fromIterable2(elements).reduce((acc, a, i) => zipWith4(acc, a, (acc2, a2) => f(acc2, a2, i)), zero3), () => suspend(() => pipe(mergeAll3([zero3, ...elements], none2(), (acc, elem, i) => {
  switch (acc._tag) {
    case "None": {
      return some2(elem);
    }
    case "Some": {
      return some2(f(acc.value, elem, i));
    }
  }
}, options), map10((option5) => {
  switch (option5._tag) {
    case "None": {
      throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    case "Some": {
      return option5.value;
    }
  }
})))));
var parallelFinalizers = (self) => contextWithEffect((context9) => match2(getOption2(context9, scopeTag), {
  onNone: () => self,
  onSome: (scope5) => {
    switch (scope5.strategy._tag) {
      case "Parallel":
        return self;
      case "Sequential":
      case "ParallelN":
        return flatMap9(scopeFork(scope5, parallel3), (inner) => scopeExtend(self, inner));
    }
  }
}));
var parallelNFinalizers = (parallelism) => (self) => contextWithEffect((context9) => match2(getOption2(context9, scopeTag), {
  onNone: () => self,
  onSome: (scope5) => {
    if (scope5.strategy._tag === "ParallelN" && scope5.strategy.parallelism === parallelism) {
      return self;
    }
    return flatMap9(scopeFork(scope5, parallelN2(parallelism)), (inner) => scopeExtend(self, inner));
  }
}));
var finalizersMask = (strategy) => (self) => finalizersMaskInternal(strategy, true)(self);
var finalizersMaskInternal = (strategy, concurrentFinalizers) => (self) => contextWithEffect((context9) => match2(getOption2(context9, scopeTag), {
  onNone: () => self(identity),
  onSome: (scope5) => {
    if (concurrentFinalizers === true) {
      const patch9 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
      switch (scope5.strategy._tag) {
        case "Parallel":
          return patch9(self(parallelFinalizers));
        case "Sequential":
          return patch9(self(sequentialFinalizers));
        case "ParallelN":
          return patch9(self(parallelNFinalizers(scope5.strategy.parallelism)));
      }
    } else {
      return self(identity);
    }
  }
}));
var scopeWith = (f) => flatMap9(scopeTag, f);
var scopedWith = (f) => flatMap9(scopeMake(), (scope5) => onExit(f(scope5), (exit4) => scope5.close(exit4)));
var scopedEffect = (effect4) => flatMap9(scopeMake(), (scope5) => scopeUse(effect4, scope5));
var sequentialFinalizers = (self) => contextWithEffect((context9) => match2(getOption2(context9, scopeTag), {
  onNone: () => self,
  onSome: (scope5) => {
    switch (scope5.strategy._tag) {
      case "Sequential":
        return self;
      case "Parallel":
      case "ParallelN":
        return flatMap9(scopeFork(scope5, sequential3), (inner) => scopeExtend(self, inner));
    }
  }
}));
var tagMetricsScoped = (key, value3) => labelMetricsScoped([make28(key, value3)]);
var labelMetricsScoped = (labels) => fiberRefLocallyScopedWith(currentMetricLabels, (old) => union(old, labels));
var using = /* @__PURE__ */ dual(2, (self, use) => scopedWith((scope5) => flatMap9(scopeExtend(self, scope5), use)));
var validate = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, options) => validateWith(self, that, (a, b) => [a, b], options));
var validateWith = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, f, options) => flatten6(zipWithOptions(exit(self), exit(that), (ea, eb) => exitZipWith(ea, eb, {
  onSuccess: f,
  onFailure: (ca, cb) => options?.concurrent ? parallel(ca, cb) : sequential(ca, cb)
}), options)));
var validateFirst = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => flip(forEach9(elements, (a, i) => flip(f(a, i)), options)));
var withClockScoped = (c) => fiberRefLocallyScopedWith(currentServices, add2(clockTag, c));
var withRandomScoped = (value3) => fiberRefLocallyScopedWith(currentServices, add2(randomTag, value3));
var withConfigProviderScoped = (provider) => fiberRefLocallyScopedWith(currentServices, add2(configProviderTag, provider));
var withEarlyRelease = (self) => scopeWith((parent) => flatMap9(scopeFork(parent, sequential2), (child) => pipe(self, scopeExtend(child), map10((value3) => [fiberIdWith((fiberId3) => scopeClose(child, exitInterrupt(fiberId3))), value3]))));
var zipOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, options) => zipWithOptions(self, that, (a, b) => [a, b], options));
var zipLeftOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, options) => {
  if (options?.concurrent !== true && (options?.batching === void 0 || options.batching === false)) {
    return zipLeft2(self, that);
  }
  return zipWithOptions(self, that, (a, _) => a, options);
});
var zipRightOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, options) => {
  if (options?.concurrent !== true && (options?.batching === void 0 || options.batching === false)) {
    return zipRight2(self, that);
  }
  return zipWithOptions(self, that, (_, b) => b, options);
});
var zipWithOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, f, options) => map10(all5([self, that], {
  concurrency: options?.concurrent ? 2 : 1,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([a, a2]) => f(a, a2)));
var withRuntimeFlagsScoped = (update5) => {
  if (update5 === empty16) {
    return void_2;
  }
  return pipe(runtimeFlags, flatMap9((runtimeFlags2) => {
    const updatedRuntimeFlags = patch4(runtimeFlags2, update5);
    const revertRuntimeFlags = diff4(updatedRuntimeFlags, runtimeFlags2);
    return pipe(updateRuntimeFlags(update5), zipRight2(addFinalizer(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid2);
  }), uninterruptible);
};
var scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
var scope = scopeTag;
var scopeUnsafeAddFinalizer = (scope5, fin) => {
  if (scope5.state._tag === "Open") {
    scope5.state.finalizers.set({}, fin);
  }
};
var ScopeImplProto = {
  [ScopeTypeId]: ScopeTypeId,
  [CloseableScopeTypeId]: CloseableScopeTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  fork(strategy) {
    return sync(() => {
      const newScope = scopeUnsafeMake(strategy);
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      const key = {};
      const fin = (exit4) => newScope.close(exit4);
      this.state.finalizers.set(key, fin);
      scopeUnsafeAddFinalizer(newScope, (_) => sync(() => {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(key);
        }
      }));
      return newScope;
    });
  },
  close(exit4) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return void_2;
      }
      const finalizers = Array.from(this.state.finalizers.values()).reverse();
      this.state = {
        _tag: "Closed",
        exit: exit4
      };
      if (finalizers.length === 0) {
        return void_2;
      }
      return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit(fin(exit4))), flatMap9((results) => pipe(exitCollectAll(results), map2(exitAsVoid), getOrElse3(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit(fin(exit4)), false), flatMap9((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse3(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit(fin(exit4)), false), flatMap9((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse3(() => exitVoid))));
    });
  },
  addFinalizer(fin) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return fin(this.state.exit);
      }
      this.state.finalizers.set({}, fin);
      return void_2;
    });
  }
};
var scopeUnsafeMake = (strategy = sequential2) => {
  const scope5 = Object.create(ScopeImplProto);
  scope5.strategy = strategy;
  scope5.state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Map()
  };
  return scope5;
};
var scopeMake = (strategy = sequential2) => sync(() => scopeUnsafeMake(strategy));
var scopeExtend = /* @__PURE__ */ dual(2, (effect4, scope5) => mapInputContext(
  effect4,
  // @ts-expect-error
  merge2(make2(scopeTag, scope5))
));
var scopeUse = /* @__PURE__ */ dual(2, (effect4, scope5) => pipe(effect4, scopeExtend(scope5), onExit((exit4) => scope5.close(exit4))));
var fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ: differ2,
  fork: empty25
});
var fiberRefLocallyScoped = /* @__PURE__ */ dual(2, (self, value3) => asVoid2(acquireRelease(flatMap9(fiberRefGet(self), (oldValue) => as2(fiberRefSet(self, value3), oldValue)), (oldValue) => fiberRefSet(self, oldValue))));
var fiberRefLocallyScopedWith = /* @__PURE__ */ dual(2, (self, f) => fiberRefGetWith(self, (a) => fiberRefLocallyScoped(self, f(a))));
var currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none5);
var currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none8);
var fiberAwaitAll = (fibers) => forEach9(fibers, _await2);
var fiberAll = (fibers) => {
  const _fiberAll = {
    ...CommitPrototype2,
    commit() {
      return join3(this);
    },
    [FiberTypeId]: fiberVariance2,
    id: () => fromIterable2(fibers).reduce((id3, fiber) => combine3(id3, fiber.id()), none4),
    await: exit(forEachParUnbounded(fibers, (fiber) => flatten6(fiber.await), false)),
    children: map10(forEachParUnbounded(fibers, (fiber) => fiber.children, false), flatten2),
    inheritAll: forEachSequentialDiscard(fibers, (fiber) => fiber.inheritAll),
    poll: map10(forEachSequential(fibers, (fiber) => fiber.poll), reduceRight(some2(exitSucceed(new Array())), (optionB, optionA) => {
      switch (optionA._tag) {
        case "None": {
          return none2();
        }
        case "Some": {
          switch (optionB._tag) {
            case "None": {
              return none2();
            }
            case "Some": {
              return some2(exitZipWith(optionA.value, optionB.value, {
                onSuccess: (a, chunk4) => [a, ...chunk4],
                onFailure: parallel
              }));
            }
          }
        }
      }
    })),
    interruptAsFork: (fiberId3) => forEachSequentialDiscard(fibers, (fiber) => fiber.interruptAsFork(fiberId3))
  };
  return _fiberAll;
};
var fiberInterruptFork = (self) => asVoid2(forkDaemon(interruptFiber(self)));
var fiberJoinAll = (fibers) => join3(fiberAll(fibers));
var fiberScoped = (self) => acquireRelease(succeed(self), interruptFiber);
var raceWith = /* @__PURE__ */ dual(3, (self, other, options) => raceFibersWith(self, other, {
  onSelfWin: (winner, loser) => flatMap9(winner.await, (exit4) => {
    switch (exit4._tag) {
      case OP_SUCCESS: {
        return flatMap9(winner.inheritAll, () => options.onSelfDone(exit4, loser));
      }
      case OP_FAILURE: {
        return options.onSelfDone(exit4, loser);
      }
    }
  }),
  onOtherWin: (winner, loser) => flatMap9(winner.await, (exit4) => {
    switch (exit4._tag) {
      case OP_SUCCESS: {
        return flatMap9(winner.inheritAll, () => options.onOtherDone(exit4, loser));
      }
      case OP_FAILURE: {
        return options.onOtherDone(exit4, loser);
      }
    }
  })
}));
var disconnect = (self) => uninterruptibleMask((restore) => fiberIdWith((fiberId3) => flatMap9(forkDaemon(restore(self)), (fiber) => pipe(restore(join3(fiber)), onInterrupt(() => pipe(fiber, interruptAsFork(fiberId3)))))));
var race = /* @__PURE__ */ dual(2, (self, that) => fiberIdWith((parentFiberId) => raceWith(self, that, {
  onSelfDone: (exit4, right3) => exitMatchEffect(exit4, {
    onFailure: (cause3) => pipe(join3(right3), mapErrorCause((cause22) => parallel(cause3, cause22))),
    onSuccess: (value3) => pipe(right3, interruptAsFiber(parentFiberId), as2(value3))
  }),
  onOtherDone: (exit4, left3) => exitMatchEffect(exit4, {
    onFailure: (cause3) => pipe(join3(left3), mapErrorCause((cause22) => parallel(cause22, cause3))),
    onSuccess: (value3) => pipe(left3, interruptAsFiber(parentFiberId), as2(value3))
  })
})));
var raceFibersWith = /* @__PURE__ */ dual(3, (self, other, options) => withFiberRuntime((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = make12(true);
  const leftFiber = unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags, options.selfScope);
  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
  return async_((cb) => {
    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self);
    rightFiber.startFork(other);
  }, combine3(leftFiber.id(), rightFiber.id()));
}));
var completeRace = (winner, loser, cont, ab, cb) => {
  if (compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
};
var ensuring = /* @__PURE__ */ dual(2, (self, finalizer3) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
  onFailure: (cause1) => matchCauseEffect(finalizer3, {
    onFailure: (cause22) => failCause(sequential(cause1, cause22)),
    onSuccess: () => failCause(cause1)
  }),
  onSuccess: (a) => as2(finalizer3, a)
})));
var invokeWithInterrupt = (self, entries3, onInterrupt3) => fiberIdWith((id3) => flatMap9(flatMap9(forkDaemon(interruptible2(self)), (processing) => async_((cb) => {
  const counts = entries3.map((_) => _.listeners.count);
  const checkDone = () => {
    if (counts.every((count4) => count4 === 0)) {
      if (entries3.every((_) => {
        if (_.result.state.current._tag === "Pending") {
          return true;
        } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted(_.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach((f) => f());
        onInterrupt3?.();
        cb(interruptFiber(processing));
      }
    }
  };
  processing.addObserver((exit4) => {
    cleanup.forEach((f) => f());
    cb(exit4);
  });
  const cleanup = entries3.map((r, i) => {
    const observer = (count4) => {
      counts[i] = count4;
      checkDone();
    };
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach((f) => f());
  });
})), () => suspend(() => {
  const residual = entries3.flatMap((entry) => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, (entry) => complete(entry.request, exitInterrupt(id3)));
})));
var makeSpanScoped = (name, options) => {
  options = addSpanStackTrace(options);
  return uninterruptible(withFiberRuntime((fiber) => {
    const scope5 = unsafeGet2(fiber.getFiberRef(currentContext), scopeTag);
    const span4 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock_ = get2(fiber.getFiberRef(currentServices), clockTag);
    return as2(scopeAddFinalizerExit(scope5, (exit4) => endSpan(span4, exit4, clock_, timingEnabled)), span4);
  }));
};
var withTracerScoped = (value3) => fiberRefLocallyScopedWith(currentServices, add2(tracerTag, value3));
var withSpanScoped = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return flatMap9(makeSpanScoped(name, addSpanStackTrace(options)), (span4) => provideService(self, spanTag, span4));
  }
  return (self) => flatMap9(makeSpanScoped(name, addSpanStackTrace(options)), (span4) => provideService(self, spanTag, span4));
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Cause.js
var empty26 = empty9;
var fail6 = fail;
var die4 = die;
var interrupt5 = interrupt;
var parallel4 = parallel;
var sequential4 = sequential;
var isCause2 = isCause;
var isFailType2 = isFailType;
var isDieType2 = isDieType;
var isInterrupted2 = isInterrupted;
var isInterruptedOnly2 = isInterruptedOnly;
var interruptors2 = interruptors;
var failureOrCause2 = failureOrCause;
var flipCauseOption2 = flipCauseOption;
var map14 = map8;
var squash = causeSquash;
var IllegalArgumentException2 = IllegalArgumentException;
var NoSuchElementException2 = NoSuchElementException;
var RuntimeException2 = RuntimeException;
var isRuntimeException2 = isRuntimeException;
var pretty3 = pretty;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/schedule/interval.js
var IntervalSymbolKey = "effect/ScheduleInterval";
var IntervalTypeId = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
var empty27 = {
  [IntervalTypeId]: IntervalTypeId,
  startMillis: 0,
  endMillis: 0
};
var make34 = (startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty27;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
};
var lessThan3 = /* @__PURE__ */ dual(2, (self, that) => min3(self, that) === self);
var min3 = /* @__PURE__ */ dual(2, (self, that) => {
  if (self.endMillis <= that.startMillis) return self;
  if (that.endMillis <= self.startMillis) return that;
  if (self.startMillis < that.startMillis) return self;
  if (that.startMillis < self.startMillis) return that;
  if (self.endMillis <= that.endMillis) return self;
  return that;
});
var isEmpty6 = (self) => {
  return self.startMillis >= self.endMillis;
};
var intersect = /* @__PURE__ */ dual(2, (self, that) => {
  const start5 = Math.max(self.startMillis, that.startMillis);
  const end6 = Math.min(self.endMillis, that.endMillis);
  return make34(start5, end6);
});
var size10 = (self) => {
  return millis(self.endMillis - self.startMillis);
};
var after = (startMilliseconds) => {
  return make34(startMilliseconds, Number.POSITIVE_INFINITY);
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/ScheduleInterval.js
var make35 = make34;
var empty28 = empty27;
var lessThan4 = lessThan3;
var isEmpty7 = isEmpty6;
var intersect2 = intersect;
var size11 = size10;
var after2 = after;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey = "effect/ScheduleIntervals";
var IntervalsTypeId = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
var make36 = (intervals) => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
};
var union8 = /* @__PURE__ */ dual(2, (self, that) => {
  if (!isNonEmpty(that.intervals)) {
    return self;
  }
  if (!isNonEmpty(self.intervals)) {
    return that;
  }
  if (headNonEmpty2(self.intervals).startMillis < headNonEmpty2(that.intervals).startMillis) {
    return unionLoop(tailNonEmpty2(self.intervals), that.intervals, headNonEmpty2(self.intervals), empty5());
  }
  return unionLoop(self.intervals, tailNonEmpty2(that.intervals), headNonEmpty2(that.intervals), empty5());
});
var unionLoop = (_self, _that, _interval, _acc) => {
  let self = _self;
  let that = _that;
  let interval = _interval;
  let acc = _acc;
  while (isNonEmpty(self) || isNonEmpty(that)) {
    if (!isNonEmpty(self) && isNonEmpty(that)) {
      if (interval.endMillis < headNonEmpty2(that).startMillis) {
        acc = pipe(acc, prepend2(interval));
        interval = headNonEmpty2(that);
        that = tailNonEmpty2(that);
        self = empty5();
      } else {
        interval = make35(interval.startMillis, headNonEmpty2(that).endMillis);
        that = tailNonEmpty2(that);
        self = empty5();
      }
    } else if (isNonEmpty(self) && isEmpty(that)) {
      if (interval.endMillis < headNonEmpty2(self).startMillis) {
        acc = pipe(acc, prepend2(interval));
        interval = headNonEmpty2(self);
        that = empty5();
        self = tailNonEmpty2(self);
      } else {
        interval = make35(interval.startMillis, headNonEmpty2(self).endMillis);
        that = empty5();
        self = tailNonEmpty2(self);
      }
    } else if (isNonEmpty(self) && isNonEmpty(that)) {
      if (headNonEmpty2(self).startMillis < headNonEmpty2(that).startMillis) {
        if (interval.endMillis < headNonEmpty2(self).startMillis) {
          acc = pipe(acc, prepend2(interval));
          interval = headNonEmpty2(self);
          self = tailNonEmpty2(self);
        } else {
          interval = make35(interval.startMillis, headNonEmpty2(self).endMillis);
          self = tailNonEmpty2(self);
        }
      } else if (interval.endMillis < headNonEmpty2(that).startMillis) {
        acc = pipe(acc, prepend2(interval));
        interval = headNonEmpty2(that);
        that = tailNonEmpty2(that);
      } else {
        interval = make35(interval.startMillis, headNonEmpty2(that).endMillis);
        that = tailNonEmpty2(that);
      }
    } else {
      throw new Error(getBugErrorMessage("Intervals.unionLoop"));
    }
  }
  return make36(pipe(acc, prepend2(interval), reverse2));
};
var intersect3 = /* @__PURE__ */ dual(2, (self, that) => intersectLoop(self.intervals, that.intervals, empty5()));
var intersectLoop = (_left, _right, _acc) => {
  let left3 = _left;
  let right3 = _right;
  let acc = _acc;
  while (isNonEmpty(left3) && isNonEmpty(right3)) {
    const interval = pipe(headNonEmpty2(left3), intersect2(headNonEmpty2(right3)));
    const intervals = isEmpty7(interval) ? acc : pipe(acc, prepend2(interval));
    if (pipe(headNonEmpty2(left3), lessThan4(headNonEmpty2(right3)))) {
      left3 = tailNonEmpty2(left3);
    } else {
      right3 = tailNonEmpty2(right3);
    }
    acc = intervals;
  }
  return make36(reverse2(acc));
};
var start = (self) => {
  return pipe(self.intervals, head2, getOrElse3(() => empty28)).startMillis;
};
var end = (self) => {
  return pipe(self.intervals, head2, getOrElse3(() => empty28)).endMillis;
};
var lessThan5 = /* @__PURE__ */ dual(2, (self, that) => start(self) < start(that));
var isNonEmpty3 = (self) => {
  return isNonEmpty(self.intervals);
};
var max4 = /* @__PURE__ */ dual(2, (self, that) => lessThan5(self, that) ? that : self);

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/ScheduleIntervals.js
var make37 = make36;
var union9 = union8;
var intersect4 = intersect3;
var start2 = start;
var end2 = end;
var lessThan6 = lessThan5;
var isNonEmpty4 = isNonEmpty3;
var max5 = max4;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE = "Continue";
var OP_DONE2 = "Done";
var _continue = (intervals) => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
};
var continueWith = (interval) => {
  return {
    _tag: OP_CONTINUE,
    intervals: make37(of2(interval))
  };
};
var done6 = {
  _tag: OP_DONE2
};
var isContinue = (self) => {
  return self._tag === OP_CONTINUE;
};
var isDone4 = (self) => {
  return self._tag === OP_DONE2;
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/ScheduleDecision.js
var _continue2 = _continue;
var continueWith2 = continueWith;
var done7 = done6;
var isContinue2 = isContinue;
var isDone5 = isDone4;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Scope.js
var Scope = scopeTag;
var addFinalizer2 = scopeAddFinalizer;
var addFinalizerExit = scopeAddFinalizerExit;
var close = scopeClose;
var extend2 = scopeExtend;
var fork2 = scopeFork;
var make38 = scopeMake;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/effect/circular.js
var Semaphore = class {
  constructor(permits) {
    __publicField(this, "permits");
    __publicField(this, "waiters", /* @__PURE__ */ new Set());
    __publicField(this, "taken", 0);
    __publicField(this, "take", (n) => asyncInterrupt((resume2) => {
      if (this.free < n) {
        const observer = () => {
          if (this.free < n) {
            return;
          }
          this.waiters.delete(observer);
          this.taken += n;
          resume2(succeed(n));
        };
        this.waiters.add(observer);
        return sync(() => {
          this.waiters.delete(observer);
        });
      }
      this.taken += n;
      return resume2(succeed(n));
    }));
    __publicField(this, "updateTaken", (f) => withFiberRuntime((fiber) => {
      this.taken = f(this.taken);
      if (this.waiters.size > 0) {
        fiber.getFiberRef(currentScheduler).scheduleTask(() => {
          const iter = this.waiters.values();
          let item = iter.next();
          while (item.done === false && this.free > 0) {
            item.value();
            item = iter.next();
          }
        }, fiber.getFiberRef(currentSchedulingPriority));
      }
      return succeed(this.free);
    }));
    __publicField(this, "release", (n) => this.updateTaken((taken) => taken - n));
    __publicField(this, "releaseAll", /* @__PURE__ */ this.updateTaken((_) => 0));
    __publicField(this, "withPermits", (n) => (self) => uninterruptibleMask((restore) => flatMap9(restore(this.take(n)), (permits) => ensuring(restore(self), this.release(permits)))));
    __publicField(this, "withPermitsIfAvailable", (n) => (self) => uninterruptibleMask((restore) => suspend(() => {
      if (this.free < n) {
        return succeedNone;
      }
      this.taken += n;
      return ensuring(restore(asSome(self)), this.release(n));
    })));
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
};
var unsafeMakeSemaphore = (permits) => new Semaphore(permits);
var makeSemaphore = (permits) => sync(() => unsafeMakeSemaphore(permits));
var Latch = class extends Class2 {
  constructor(isOpen) {
    super();
    __publicField(this, "isOpen");
    __publicField(this, "waiters", []);
    __publicField(this, "scheduled", false);
    __publicField(this, "flushWaiters", () => {
      this.scheduled = false;
      const waiters = this.waiters;
      this.waiters = [];
      for (let i = 0; i < waiters.length; i++) {
        waiters[i](exitVoid);
      }
    });
    __publicField(this, "open", /* @__PURE__ */ withFiberRuntime((fiber) => {
      if (this.isOpen) {
        return void_2;
      }
      this.isOpen = true;
      return this.unsafeSchedule(fiber);
    }));
    __publicField(this, "release", /* @__PURE__ */ withFiberRuntime((fiber) => {
      if (this.isOpen) {
        return void_2;
      }
      return this.unsafeSchedule(fiber);
    }));
    __publicField(this, "await", /* @__PURE__ */ asyncInterrupt((resume2) => {
      if (this.isOpen) {
        return resume2(void_2);
      }
      this.waiters.push(resume2);
      return sync(() => {
        const index = this.waiters.indexOf(resume2);
        if (index !== -1) {
          this.waiters.splice(index, 1);
        }
      });
    }));
    __publicField(this, "close", /* @__PURE__ */ sync(() => {
      this.isOpen = false;
    }));
    __publicField(this, "whenOpen", (self) => {
      return zipRight2(this.await, self);
    });
    this.isOpen = isOpen;
  }
  commit() {
    return this.await;
  }
  unsafeSchedule(fiber) {
    if (this.scheduled || this.waiters.length === 0) {
      return void_2;
    }
    this.scheduled = true;
    fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
    return void_2;
  }
  unsafeOpen() {
    if (this.isOpen) return;
    this.isOpen = true;
    this.flushWaiters();
  }
  unsafeClose() {
    this.isOpen = false;
  }
};
var unsafeMakeLatch = (open) => new Latch(open ?? false);
var makeLatch = (open) => sync(() => unsafeMakeLatch(open));
var awaitAllChildren = (self) => ensuringChildren(self, fiberAwaitAll);
var cached2 = /* @__PURE__ */ dual(2, (self, timeToLive) => map10(cachedInvalidateWithTTL(self, timeToLive), (tuple4) => tuple4[0]));
var cachedInvalidateWithTTL = /* @__PURE__ */ dual(2, (self, timeToLive) => {
  const duration4 = decode(timeToLive);
  return flatMap9(context(), (env3) => map10(makeSynchronized(none2()), (cache) => [provideContext(getCachedValue(self, duration4, cache), env3), invalidateCache(cache)]));
});
var computeCachedValue = (self, timeToLive, start5) => {
  const timeToLiveMillis = toMillis(decode(timeToLive));
  return pipe(deferredMake(), tap2((deferred) => intoDeferred(self, deferred)), map10((deferred) => some2([start5 + timeToLiveMillis, deferred])));
};
var getCachedValue = (self, timeToLive, cache) => uninterruptibleMask((restore) => pipe(clockWith3((clock3) => clock3.currentTimeMillis), flatMap9((time) => updateSomeAndGetEffectSynchronized(cache, (option5) => {
  switch (option5._tag) {
    case "None": {
      return some2(computeCachedValue(self, timeToLive, time));
    }
    case "Some": {
      const [end6] = option5.value;
      return end6 - time <= 0 ? some2(computeCachedValue(self, timeToLive, time)) : none2();
    }
  }
})), flatMap9((option5) => isNone2(option5) ? dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option5.value[1])))));
var invalidateCache = (cache) => set4(cache, none2());
var ensuringChild = /* @__PURE__ */ dual(2, (self, f) => ensuringChildren(self, (children3) => f(fiberAll(children3))));
var ensuringChildren = /* @__PURE__ */ dual(2, (self, children3) => flatMap9(track, (supervisor) => pipe(supervised(self, supervisor), ensuring(flatMap9(supervisor.value, children3)))));
var forkAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (effects, options) => options?.discard ? forEachSequentialDiscard(effects, fork) : map10(forEachSequential(effects, fork), fiberAll));
var forkIn = /* @__PURE__ */ dual(2, (self, scope5) => withFiberRuntime((parent, parentStatus) => {
  const scopeImpl = scope5;
  const fiber = unsafeFork2(self, parent, parentStatus.runtimeFlags, globalScope);
  if (scopeImpl.state._tag === "Open") {
    const finalizer3 = () => fiberIdWith((fiberId3) => equals(fiberId3, fiber.id()) ? void_2 : asVoid2(interruptFiber(fiber)));
    const key = {};
    scopeImpl.state.finalizers.set(key, finalizer3);
    fiber.addObserver(() => {
      if (scopeImpl.state._tag === "Closed") return;
      scopeImpl.state.finalizers.delete(key);
    });
  } else {
    fiber.unsafeInterruptAsFork(parent.id());
  }
  return succeed(fiber);
}));
var forkScoped = (self) => scopeWith((scope5) => forkIn(self, scope5));
var fromFiber = (fiber) => join3(fiber);
var fromFiberEffect = (fiber) => suspend(() => flatMap9(fiber, join3));
var memoKeySymbol = /* @__PURE__ */ Symbol.for("effect/Effect/memoizeFunction.key");
var _a44;
var Key = class {
  constructor(a, eq) {
    __publicField(this, "a");
    __publicField(this, "eq");
    __publicField(this, _a44, memoKeySymbol);
    this.a = a;
    this.eq = eq;
  }
  [(_a44 = memoKeySymbol, symbol2)](that) {
    if (hasProperty(that, memoKeySymbol)) {
      if (this.eq) {
        return this.eq(this.a, that.a);
      } else {
        return equals(this.a, that.a);
      }
    }
    return false;
  }
  [symbol]() {
    return this.eq ? 0 : cached(this, hash(this.a));
  }
};
var cachedFunction = (f, eq) => {
  return pipe(sync(() => empty22()), flatMap9(makeSynchronized), map10((ref) => (a) => pipe(ref.modifyEffect((map31) => {
    const result = pipe(map31, get12(new Key(a, eq)));
    if (isNone2(result)) {
      return pipe(deferredMake(), tap2((deferred) => pipe(diffFiberRefs(f(a)), intoDeferred(deferred), fork)), map10((deferred) => [deferred, pipe(map31, set6(new Key(a, eq), deferred))]));
    }
    return succeed([result.value, map31]);
  }), flatMap9(deferredAwait), flatMap9(([patch9, b]) => pipe(patchFiberRefs(patch9), as2(b))))));
};
var raceFirst = /* @__PURE__ */ dual(2, (self, that) => pipe(exit(self), race(exit(that)), (effect4) => flatten6(effect4)));
var supervised = /* @__PURE__ */ dual(2, (self, supervisor) => {
  const supervise = fiberRefLocallyWith(currentSupervisor, (s) => s.zip(supervisor));
  return supervise(self);
});
var timeout = /* @__PURE__ */ dual(2, (self, duration4) => timeoutFail(self, {
  onTimeout: () => timeoutExceptionFromDuration(duration4),
  duration: duration4
}));
var timeoutFail = /* @__PURE__ */ dual(2, (self, {
  duration: duration4,
  onTimeout
}) => flatten6(timeoutTo(self, {
  onTimeout: () => failSync(onTimeout),
  onSuccess: succeed,
  duration: duration4
})));
var timeoutFailCause = /* @__PURE__ */ dual(2, (self, {
  duration: duration4,
  onTimeout
}) => flatten6(timeoutTo(self, {
  onTimeout: () => failCauseSync(onTimeout),
  onSuccess: succeed,
  duration: duration4
})));
var timeoutOption = /* @__PURE__ */ dual(2, (self, duration4) => timeoutTo(self, {
  duration: duration4,
  onSuccess: some2,
  onTimeout: none2
}));
var timeoutTo = /* @__PURE__ */ dual(2, (self, {
  duration: duration4,
  onSuccess,
  onTimeout
}) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self), interruptible2(sleep3(duration4)), {
  onSelfWin: (winner, loser) => flatMap9(winner.await, (exit4) => {
    if (exit4._tag === "Success") {
      return flatMap9(winner.inheritAll, () => as2(interruptAsFiber(loser, parentFiberId), onSuccess(exit4.value)));
    } else {
      return flatMap9(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit4.cause));
    }
  }),
  onOtherWin: (winner, loser) => flatMap9(winner.await, (exit4) => {
    if (exit4._tag === "Success") {
      return flatMap9(winner.inheritAll, () => as2(interruptAsFiber(loser, parentFiberId), onTimeout()));
    } else {
      return flatMap9(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit4.cause));
    }
  }),
  otherScope: globalScope
}))));
var SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
var SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
var synchronizedVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a45, _b13, _c2, _d;
var SynchronizedImpl = class extends (_d = Class2, _c2 = SynchronizedTypeId, _b13 = RefTypeId, _a45 = TypeId11, _d) {
  constructor(ref, withLock) {
    super();
    __publicField(this, "ref");
    __publicField(this, "withLock");
    __publicField(this, _c2, synchronizedVariance);
    __publicField(this, _b13, refVariance);
    __publicField(this, _a45, TypeId11);
    __publicField(this, "get");
    this.ref = ref;
    this.withLock = withLock;
    this.get = get10(this.ref);
  }
  commit() {
    return this.get;
  }
  modify(f) {
    return this.modifyEffect((a) => succeed(f(a)));
  }
  modifyEffect(f) {
    return this.withLock(pipe(flatMap9(get10(this.ref), f), flatMap9(([b, a]) => as2(set4(this.ref, a), b))));
  }
};
var makeSynchronized = (value3) => sync(() => unsafeMakeSynchronized(value3));
var unsafeMakeSynchronized = (value3) => {
  const ref = unsafeMake6(value3);
  const sem = unsafeMakeSemaphore(1);
  return new SynchronizedImpl(ref, sem.withPermits(1));
};
var updateSomeAndGetEffectSynchronized = /* @__PURE__ */ dual(2, (self, pf) => self.modifyEffect((value3) => {
  const result = pf(value3);
  switch (result._tag) {
    case "None": {
      return succeed([value3, value3]);
    }
    case "Some": {
      return map10(result.value, (a) => [a, a]);
    }
  }
}));
var zipFiber = /* @__PURE__ */ dual(2, (self, that) => zipWithFiber(self, that, (a, b) => [a, b]));
var zipLeftFiber = /* @__PURE__ */ dual(2, (self, that) => zipWithFiber(self, that, (a, _) => a));
var zipRightFiber = /* @__PURE__ */ dual(2, (self, that) => zipWithFiber(self, that, (_, b) => b));
var zipWithFiber = /* @__PURE__ */ dual(3, (self, that, f) => ({
  ...CommitPrototype2,
  commit() {
    return join3(this);
  },
  [FiberTypeId]: fiberVariance2,
  id: () => pipe(self.id(), getOrElse5(that.id())),
  await: pipe(self.await, flatten6, zipWithOptions(flatten6(that.await), f, {
    concurrent: true
  }), exit),
  children: self.children,
  inheritAll: zipRight2(that.inheritAll, self.inheritAll),
  poll: zipWith4(self.poll, that.poll, (optionA, optionB) => pipe(optionA, flatMap((exitA) => pipe(optionB, map2((exitB) => zipWith5(exitA, exitB, {
    onSuccess: f,
    onFailure: parallel
  })))))),
  interruptAsFork: (id3) => zipRight2(self.interruptAsFork(id3), that.interruptAsFork(id3)),
  pipe() {
    return pipeArguments(this, arguments);
  }
}));
var bindAll = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self, f, options) => flatMap9(self, (a) => all5(f(a), options).pipe(map10((record4) => Object.assign({}, a, record4)))));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/managedRuntime/circular.js
var TypeId14 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/opCodes/layer.js
var OP_EXTEND_SCOPE = "ExtendScope";
var OP_FOLD = "Fold";
var OP_FRESH = "Fresh";
var OP_FROM_EFFECT = "FromEffect";
var OP_SCOPED = "Scoped";
var OP_SUSPEND = "Suspend";
var OP_PROVIDE = "Provide";
var OP_PROVIDE_MERGE = "ProvideMerge";
var OP_ZIP_WITH2 = "ZipWith";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Fiber.js
var Fiber_exports = {};
__export(Fiber_exports, {
  FiberTypeId: () => FiberTypeId2,
  Order: () => Order5,
  RuntimeFiberTypeId: () => RuntimeFiberTypeId2,
  all: () => all6,
  await: () => _await3,
  awaitAll: () => awaitAll,
  children: () => children2,
  done: () => done8,
  dump: () => dump2,
  dumpAll: () => dumpAll2,
  fail: () => fail7,
  failCause: () => failCause6,
  fromEffect: () => fromEffect3,
  getCurrentFiber: () => getCurrentFiber2,
  id: () => id2,
  inheritAll: () => inheritAll2,
  interrupt: () => interrupt6,
  interruptAll: () => interruptAll2,
  interruptAllAs: () => interruptAllAs2,
  interruptAs: () => interruptAs,
  interruptAsFork: () => interruptAsFork2,
  interruptFork: () => interruptFork,
  interrupted: () => interrupted2,
  isFiber: () => isFiber2,
  isRuntimeFiber: () => isRuntimeFiber2,
  join: () => join4,
  joinAll: () => joinAll,
  map: () => map15,
  mapEffect: () => mapEffect2,
  mapFiber: () => mapFiber2,
  match: () => match11,
  never: () => never3,
  orElse: () => orElse4,
  orElseEither: () => orElseEither4,
  poll: () => poll3,
  pretty: () => pretty4,
  roots: () => roots2,
  scoped: () => scoped,
  status: () => status2,
  succeed: () => succeed6,
  unsafeRoots: () => unsafeRoots2,
  void: () => void_6,
  zip: () => zip6,
  zipLeft: () => zipLeft3,
  zipRight: () => zipRight4,
  zipWith: () => zipWith6
});
var FiberTypeId2 = FiberTypeId;
var RuntimeFiberTypeId2 = RuntimeFiberTypeId;
var Order5 = Order4;
var isFiber2 = isFiber;
var isRuntimeFiber2 = isRuntimeFiber;
var id2 = id;
var _await3 = _await2;
var awaitAll = fiberAwaitAll;
var children2 = children;
var all6 = fiberAll;
var done8 = done5;
var dump2 = dump;
var dumpAll2 = dumpAll;
var fail7 = fail5;
var failCause6 = failCause5;
var fromEffect3 = fromEffect;
var getCurrentFiber2 = getCurrentFiber;
var inheritAll2 = inheritAll;
var interrupt6 = interruptFiber;
var interrupted2 = interrupted;
var interruptAs = interruptAsFiber;
var interruptAsFork2 = interruptAsFork;
var interruptAll2 = interruptAll;
var interruptAllAs2 = interruptAllAs;
var interruptFork = fiberInterruptFork;
var join4 = join3;
var joinAll = fiberJoinAll;
var map15 = map13;
var mapEffect2 = mapEffect;
var mapFiber2 = mapFiber;
var match11 = match10;
var never3 = never2;
var orElse4 = orElse3;
var orElseEither4 = orElseEither2;
var poll3 = poll2;
var pretty4 = pretty2;
var roots2 = roots;
var unsafeRoots2 = unsafeRoots;
var scoped = fiberScoped;
var status2 = status;
var succeed6 = succeed5;
var void_6 = void_5;
var zip6 = zipFiber;
var zipLeft3 = zipLeftFiber;
var zipRight4 = zipRightFiber;
var zipWith6 = zipWithFiber;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/runtime.js
var makeDual = (f) => function() {
  if (arguments.length === 1) {
    const runtime5 = arguments[0];
    return (effect4, ...args2) => f(runtime5, effect4, ...args2);
  }
  return f.apply(this, arguments);
};
var unsafeFork3 = /* @__PURE__ */ makeDual((runtime5, self, options) => {
  const fiberId3 = unsafeMake3();
  const fiberRefUpdates = [[currentContext, [[fiberId3, runtime5.context]]]];
  if (options?.scheduler) {
    fiberRefUpdates.push([currentScheduler, [[fiberId3, options.scheduler]]]);
  }
  let fiberRefs3 = updateManyAs2(runtime5.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId3
  });
  if (options?.updateRefs) {
    fiberRefs3 = options.updateRefs(fiberRefs3, fiberId3);
  }
  const fiberRuntime = new FiberRuntime(fiberId3, fiberRefs3, runtime5.runtimeFlags);
  let effect4 = self;
  if (options?.scope) {
    effect4 = flatMap9(fork2(options.scope, sequential2), (closeableScope) => zipRight2(scopeAddFinalizer(closeableScope, fiberIdWith((id3) => equals(id3, fiberRuntime.id()) ? void_2 : interruptAsFiber(fiberRuntime, id3))), onExit(self, (exit4) => close(closeableScope, exit4))));
  }
  const supervisor = fiberRuntime.currentSupervisor;
  if (supervisor !== none8) {
    supervisor.onStart(runtime5.context, effect4, none2(), fiberRuntime);
    fiberRuntime.addObserver((exit4) => supervisor.onEnd(exit4, fiberRuntime));
  }
  globalScope.add(runtime5.runtimeFlags, fiberRuntime);
  if (options?.immediate === false) {
    fiberRuntime.resume(effect4);
  } else {
    fiberRuntime.start(effect4);
  }
  return fiberRuntime;
});
var unsafeRunCallback = /* @__PURE__ */ makeDual((runtime5, effect4, options = {}) => {
  const fiberRuntime = unsafeFork3(runtime5, effect4, options);
  if (options.onExit) {
    fiberRuntime.addObserver((exit4) => {
      options.onExit(exit4);
    });
  }
  return (id3, cancelOptions) => unsafeRunCallback(runtime5)(pipe(fiberRuntime, interruptAs(id3 ?? none4)), {
    ...cancelOptions,
    onExit: cancelOptions?.onExit ? (exit4) => cancelOptions.onExit(flatten7(exit4)) : void 0
  });
});
var unsafeRunSync = /* @__PURE__ */ makeDual((runtime5, effect4) => {
  const result = unsafeRunSyncExit(runtime5)(effect4);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  }
  return result.effect_instruction_i0;
});
var AsyncFiberExceptionImpl = class extends Error {
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    __publicField(this, "fiber");
    __publicField(this, "_tag", "AsyncFiberException");
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
};
var asyncFiberException = (fiber) => {
  const limit2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error2 = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit2;
  return error2;
};
var FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");
var _a46, _b14;
var FiberFailureImpl = class extends Error {
  constructor(cause3) {
    const head8 = prettyErrors(cause3)[0];
    super(head8?.message || "An error has occurred");
    __publicField(this, _b14);
    __publicField(this, _a46);
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause3;
    this.name = head8 ? `(FiberFailure) ${head8.name}` : "FiberFailure";
    if (head8?.stack) {
      this.stack = head8.stack;
    }
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
      renderErrorCause: true
    });
  }
  [(_b14 = FiberFailureId, _a46 = FiberFailureCauseId, NodeInspectSymbol)]() {
    return this.toString();
  }
};
var fiberFailure = (cause3) => {
  const limit2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error2 = new FiberFailureImpl(cause3);
  Error.stackTraceLimit = limit2;
  return error2;
};
var fastPath = (effect4) => {
  const op = effect4;
  switch (op._op) {
    case "Failure":
    case "Success": {
      return op;
    }
    case "Left": {
      return exitFail(op.left);
    }
    case "Right": {
      return exitSucceed(op.right);
    }
    case "Some": {
      return exitSucceed(op.value);
    }
    case "None": {
      return exitFail(NoSuchElementException());
    }
  }
};
var unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime5, effect4) => {
  const op = fastPath(effect4);
  if (op) {
    return op;
  }
  const scheduler2 = new SyncScheduler();
  const fiberRuntime = unsafeFork3(runtime5)(effect4, {
    scheduler: scheduler2
  });
  scheduler2.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
});
var unsafeRunPromise = /* @__PURE__ */ makeDual((runtime5, effect4, options) => unsafeRunPromiseExit(runtime5, effect4, options).then((result) => {
  switch (result._tag) {
    case OP_SUCCESS: {
      return result.effect_instruction_i0;
    }
    case OP_FAILURE: {
      throw fiberFailure(result.effect_instruction_i0);
    }
  }
}));
var unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime5, effect4, options) => new Promise((resolve) => {
  const op = fastPath(effect4);
  if (op) {
    resolve(op);
  }
  const fiber = unsafeFork3(runtime5)(effect4);
  fiber.addObserver((exit4) => {
    resolve(exit4);
  });
  if (options?.signal !== void 0) {
    if (options.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      }, {
        once: true
      });
    }
  }
}));
var RuntimeImpl = class {
  constructor(context9, runtimeFlags2, fiberRefs3) {
    __publicField(this, "context");
    __publicField(this, "runtimeFlags");
    __publicField(this, "fiberRefs");
    this.context = context9;
    this.runtimeFlags = runtimeFlags2;
    this.fiberRefs = fiberRefs3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make39 = (options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
var runtime3 = () => withFiberRuntime((state, status3) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status3.runtimeFlags, state.getFiberRefs())));
var defaultRuntimeFlags = /* @__PURE__ */ make17(Interruption, CooperativeYielding, RuntimeMetrics);
var defaultRuntime = /* @__PURE__ */ make39({
  context: /* @__PURE__ */ empty2(),
  runtimeFlags: defaultRuntimeFlags,
  fiberRefs: /* @__PURE__ */ empty20()
});
var unsafeRunEffect = /* @__PURE__ */ unsafeRunCallback(defaultRuntime);
var unsafeForkEffect = /* @__PURE__ */ unsafeFork3(defaultRuntime);
var unsafeRunPromiseEffect = /* @__PURE__ */ unsafeRunPromise(defaultRuntime);
var unsafeRunPromiseExitEffect = /* @__PURE__ */ unsafeRunPromiseExit(defaultRuntime);
var unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);
var unsafeRunSyncExitEffect = /* @__PURE__ */ unsafeRunSyncExit(defaultRuntime);
var asyncEffect = (register) => suspend(() => {
  let cleanup = void 0;
  return flatMap9(deferredMake(), (deferred) => flatMap9(runtime3(), (runtime5) => uninterruptibleMask((restore) => zipRight2(fork(restore(matchCauseEffect(register((cb) => unsafeRunCallback(runtime5)(intoDeferred(cb, deferred))), {
    onFailure: (cause3) => deferredFailCause(deferred, cause3),
    onSuccess: (cleanup_) => {
      cleanup = cleanup_;
      return void_2;
    }
  }))), restore(onInterrupt(deferredAwait(deferred), () => cleanup ?? void_2))))));
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/synchronizedRef.js
var modifyEffect = /* @__PURE__ */ dual(2, (self, f) => self.modifyEffect(f));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/layer.js
var LayerSymbolKey = "effect/Layer";
var LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
var layerVariance = {
  /* c8 ignore next */
  _RIn: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _ROut: (_) => _
};
var proto3 = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MemoMapTypeIdKey = "effect/Layer/MemoMap";
var MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
var CurrentMemoMap = /* @__PURE__ */ Reference2()("effect/Layer/CurrentMemoMap", {
  defaultValue: () => unsafeMakeMemoMap()
});
var isLayer = (u) => hasProperty(u, LayerTypeId);
var isFresh = (self) => {
  return self._op_layer === OP_FRESH;
};
var _a47;
_a47 = MemoMapTypeId;
var MemoMapImpl = class {
  constructor(ref) {
    __publicField(this, "ref");
    __publicField(this, _a47);
    this.ref = ref;
    this[MemoMapTypeId] = MemoMapTypeId;
  }
  /**
   * Checks the memo map to see if a layer exists. If it is, immediately
   * returns it. Otherwise, obtains the layer, stores it in the memo map,
   * and adds a finalizer to the `Scope`.
   */
  getOrElseMemoize(layer4, scope5) {
    return pipe(modifyEffect(this.ref, (map31) => {
      const inMap = map31.get(layer4);
      if (inMap !== void 0) {
        const [acquire, release] = inMap;
        const cached4 = pipe(acquire, flatMap9(([patch9, b]) => pipe(patchFiberRefs(patch9), as2(b))), onExit(exitMatch({
          onFailure: () => void_2,
          onSuccess: () => scopeAddFinalizerExit(scope5, release)
        })));
        return succeed([cached4, map31]);
      }
      return pipe(make24(0), flatMap9((observers) => pipe(deferredMake(), flatMap9((deferred) => pipe(make24(() => void_2), map10((finalizerRef) => {
        const resource = uninterruptibleMask((restore) => pipe(scopeMake(), flatMap9((innerScope) => pipe(restore(flatMap9(makeBuilder(layer4, innerScope, true), (f) => diffFiberRefs(f(this)))), exit, flatMap9((exit4) => {
          switch (exit4._tag) {
            case OP_FAILURE: {
              return pipe(deferredFailCause(deferred, exit4.effect_instruction_i0), zipRight2(scopeClose(innerScope, exit4)), zipRight2(failCause(exit4.effect_instruction_i0)));
            }
            case OP_SUCCESS: {
              return pipe(set4(finalizerRef, (exit5) => pipe(scopeClose(innerScope, exit5), whenEffect(modify5(observers, (n) => [n === 1, n - 1])), asVoid2)), zipRight2(update2(observers, (n) => n + 1)), zipRight2(scopeAddFinalizerExit(scope5, (exit5) => pipe(sync(() => map31.delete(layer4)), zipRight2(get10(finalizerRef)), flatMap9((finalizer3) => finalizer3(exit5))))), zipRight2(deferredSucceed(deferred, exit4.effect_instruction_i0)), as2(exit4.effect_instruction_i0[1]));
            }
          }
        })))));
        const memoized3 = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
          onFailure: () => void_2,
          onSuccess: () => update2(observers, (n) => n + 1)
        }))), (exit4) => pipe(get10(finalizerRef), flatMap9((finalizer3) => finalizer3(exit4)))];
        return [resource, isFresh(layer4) ? map31 : map31.set(layer4, memoized3)];
      }))))));
    }), flatten6);
  }
};
var makeMemoMap = /* @__PURE__ */ suspend(() => map10(makeSynchronized(/* @__PURE__ */ new Map()), (ref) => new MemoMapImpl(ref)));
var unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(/* @__PURE__ */ new Map()));
var build = (self) => scopeWith((scope5) => buildWithScope(self, scope5));
var buildWithScope = /* @__PURE__ */ dual(2, (self, scope5) => flatMap9(makeMemoMap, (memoMap) => buildWithMemoMap(self, memoMap, scope5)));
var buildWithMemoMap = /* @__PURE__ */ dual(3, (self, memoMap, scope5) => flatMap9(makeBuilder(self, scope5), (run6) => provideService(run6(memoMap), CurrentMemoMap, memoMap)));
var makeBuilder = (self, scope5, inMemoMap = false) => {
  const op = self;
  switch (op._op_layer) {
    case "Locally": {
      return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope5)));
    }
    case "ExtendScope": {
      return sync(() => (memoMap) => scopeWith((scope6) => memoMap.getOrElseMemoize(op.layer, scope6)));
    }
    case "Fold": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope5), matchCauseEffect({
        onFailure: (cause3) => memoMap.getOrElseMemoize(op.failureK(cause3), scope5),
        onSuccess: (value3) => memoMap.getOrElseMemoize(op.successK(value3), scope5)
      })));
    }
    case "Fresh": {
      return sync(() => (_) => pipe(op.layer, buildWithScope(scope5)));
    }
    case "FromEffect": {
      return inMemoMap ? sync(() => (_) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope5));
    }
    case "Provide": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), flatMap9((env3) => pipe(memoMap.getOrElseMemoize(op.second, scope5), provideContext(env3)))));
    }
    case "Scoped": {
      return inMemoMap ? sync(() => (_) => scopeExtend(op.effect, scope5)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope5));
    }
    case "Suspend": {
      return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope5));
    }
    case "ProvideMerge": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), zipWith4(memoMap.getOrElseMemoize(op.second, scope5), op.zipK)));
    }
    case "ZipWith": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), zipWithOptions(memoMap.getOrElseMemoize(op.second, scope5), op.zipK, {
        concurrent: true
      })));
    }
  }
};
var catchAll2 = /* @__PURE__ */ dual(2, (self, onFailure) => match12(self, {
  onFailure,
  onSuccess: succeedContext
}));
var catchAllCause2 = /* @__PURE__ */ dual(2, (self, onFailure) => matchCause3(self, {
  onFailure,
  onSuccess: succeedContext
}));
var die5 = (defect) => failCause7(die4(defect));
var dieSync2 = (evaluate3) => failCauseSync2(() => die4(evaluate3()));
var discard = (self) => map16(self, () => empty2());
var context2 = () => fromEffectContext(context());
var extendScope = (self) => {
  const extendScope3 = Object.create(proto3);
  extendScope3._op_layer = OP_EXTEND_SCOPE;
  extendScope3.layer = self;
  return extendScope3;
};
var fail8 = (error2) => failCause7(fail6(error2));
var failSync2 = (evaluate3) => failCauseSync2(() => fail6(evaluate3()));
var failCause7 = (cause3) => fromEffectContext(failCause(cause3));
var failCauseSync2 = (evaluate3) => fromEffectContext(failCauseSync(evaluate3));
var flatMap11 = /* @__PURE__ */ dual(2, (self, f) => match12(self, {
  onFailure: fail8,
  onSuccess: f
}));
var flatten8 = /* @__PURE__ */ dual(2, (self, tag3) => flatMap11(self, get2(tag3)));
var fresh = (self) => {
  const fresh3 = Object.create(proto3);
  fresh3._op_layer = OP_FRESH;
  fresh3.layer = self;
  return fresh3;
};
var fromEffect4 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag3 = tagFirst ? a : b;
  const effect4 = tagFirst ? b : a;
  return fromEffectContext(map10(effect4, (service3) => make2(tag3, service3)));
});
var fromEffectDiscard = (effect4) => fromEffectContext(map10(effect4, () => empty2()));
function fromEffectContext(effect4) {
  const fromEffect10 = Object.create(proto3);
  fromEffect10._op_layer = OP_FROM_EFFECT;
  fromEffect10.effect = effect4;
  return fromEffect10;
}
var fiberRefLocally2 = /* @__PURE__ */ dual(3, (self, ref, value3) => locallyEffect(self, fiberRefLocally(ref, value3)));
var locallyEffect = /* @__PURE__ */ dual(2, (self, f) => {
  const locally3 = Object.create(proto3);
  locally3._op_layer = "Locally";
  locally3.self = self;
  locally3.f = f;
  return locally3;
});
var fiberRefLocallyWith2 = /* @__PURE__ */ dual(3, (self, ref, value3) => locallyEffect(self, fiberRefLocallyWith(ref, value3)));
var fiberRefLocallyScoped2 = (self, value3) => scopedDiscard(fiberRefLocallyScoped(self, value3));
var fiberRefLocallyScopedWith2 = (self, value3) => scopedDiscard(fiberRefLocallyScopedWith(self, value3));
var fromFunction = (tagA, tagB, f) => fromEffectContext(map10(tagA, (a) => make2(tagB, f(a))));
var launch = (self) => scopedEffect(zipRight2(scopeWith((scope5) => pipe(self, buildWithScope(scope5))), never));
var map16 = /* @__PURE__ */ dual(2, (self, f) => flatMap11(self, (context9) => succeedContext(f(context9))));
var mapError2 = /* @__PURE__ */ dual(2, (self, f) => catchAll2(self, (error2) => failSync2(() => f(error2))));
var matchCause3 = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => {
  const fold2 = Object.create(proto3);
  fold2._op_layer = OP_FOLD;
  fold2.layer = self;
  fold2.failureK = onFailure;
  fold2.successK = onSuccess;
  return fold2;
});
var match12 = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => matchCause3(self, {
  onFailure: (cause3) => {
    const failureOrCause3 = failureOrCause2(cause3);
    switch (failureOrCause3._tag) {
      case "Left": {
        return onFailure(failureOrCause3.left);
      }
      case "Right": {
        return failCause7(failureOrCause3.right);
      }
    }
  },
  onSuccess
}));
var memoize2 = (self) => scopeWith((scope5) => map10(memoize(buildWithScope(self, scope5)), fromEffectContext));
var merge6 = /* @__PURE__ */ dual(2, (self, that) => zipWith7(self, that, (a, b) => merge2(a, b)));
var mergeAll4 = (...layers) => {
  let final = layers[0];
  for (let i = 1; i < layers.length; i++) {
    final = merge6(final, layers[i]);
  }
  return final;
};
var orDie2 = (self) => catchAll2(self, (defect) => die5(defect));
var orElse5 = /* @__PURE__ */ dual(2, (self, that) => catchAll2(self, that));
var passthrough = (self) => merge6(context2(), self);
var project = /* @__PURE__ */ dual(4, (self, tagA, tagB, f) => map16(self, (context9) => make2(tagB, f(unsafeGet2(context9, tagA)))));
var retry = /* @__PURE__ */ dual(2, (self, schedule4) => suspend3(() => {
  const stateTag = GenericTag("effect/Layer/retry/{ state: unknown }");
  return pipe(succeed7(stateTag, {
    state: schedule4.initial
  }), flatMap11((env3) => retryLoop(self, schedule4, stateTag, pipe(env3, get2(stateTag)).state)));
}));
var retryLoop = (self, schedule4, stateTag, state) => {
  return pipe(self, catchAll2((error2) => pipe(retryUpdate(schedule4, stateTag, error2, state), flatMap11((env3) => fresh(retryLoop(self, schedule4, stateTag, pipe(env3, get2(stateTag)).state))))));
};
var retryUpdate = (schedule4, stateTag, error2, state) => {
  return fromEffect4(stateTag, pipe(currentTimeMillis2, flatMap9((now2) => pipe(schedule4.step(now2, error2, state), flatMap9(([state2, _, decision]) => isDone5(decision) ? fail2(error2) : pipe(sleep2(millis(start2(decision.intervals) - now2)), as2({
    state: state2
  })))))));
};
var scoped2 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag3 = tagFirst ? a : b;
  const effect4 = tagFirst ? b : a;
  return scopedContext(map10(effect4, (service3) => make2(tag3, service3)));
});
var scopedDiscard = (effect4) => scopedContext(pipe(effect4, as2(empty2())));
var scopedContext = (effect4) => {
  const scoped8 = Object.create(proto3);
  scoped8._op_layer = OP_SCOPED;
  scoped8.effect = effect4;
  return scoped8;
};
var scope2 = /* @__PURE__ */ scopedContext(/* @__PURE__ */ map10(/* @__PURE__ */ acquireRelease(/* @__PURE__ */ scopeMake(), (scope5, exit4) => scope5.close(exit4)), (scope5) => make2(Scope, scope5)));
var service = (tag3) => fromEffect4(tag3, tag3);
var succeed7 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag3 = tagFirst ? a : b;
  const resource = tagFirst ? b : a;
  return fromEffectContext(succeed(make2(tag3, resource)));
});
var succeedContext = (context9) => {
  return fromEffectContext(succeed(context9));
};
var empty30 = /* @__PURE__ */ succeedContext(/* @__PURE__ */ empty2());
var suspend3 = (evaluate3) => {
  const suspend15 = Object.create(proto3);
  suspend15._op_layer = OP_SUSPEND;
  suspend15.evaluate = evaluate3;
  return suspend15;
};
var sync3 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag3 = tagFirst ? a : b;
  const evaluate3 = tagFirst ? b : a;
  return fromEffectContext(sync(() => make2(tag3, evaluate3())));
});
var syncContext = (evaluate3) => {
  return fromEffectContext(sync(evaluate3));
};
var tap3 = /* @__PURE__ */ dual(2, (self, f) => flatMap11(self, (context9) => fromEffectContext(as2(f(context9), context9))));
var tapError2 = /* @__PURE__ */ dual(2, (self, f) => catchAll2(self, (e) => fromEffectContext(flatMap9(f(e), () => fail2(e)))));
var tapErrorCause2 = /* @__PURE__ */ dual(2, (self, f) => catchAllCause2(self, (cause3) => fromEffectContext(flatMap9(f(cause3), () => failCause(cause3)))));
var toRuntime = (self) => pipe(scopeWith((scope5) => buildWithScope(self, scope5)), flatMap9((context9) => pipe(runtime3(), provideContext(context9))));
var toRuntimeWithMemoMap = /* @__PURE__ */ dual(2, (self, memoMap) => flatMap9(scopeWith((scope5) => buildWithMemoMap(self, memoMap, scope5)), (context9) => pipe(runtime3(), provideContext(context9))));
var provide = /* @__PURE__ */ dual(2, (self, that) => suspend3(() => {
  const provideTo = Object.create(proto3);
  provideTo._op_layer = OP_PROVIDE;
  provideTo.first = Object.create(proto3, {
    _op_layer: {
      value: OP_PROVIDE_MERGE,
      enumerable: true
    },
    first: {
      value: context2(),
      enumerable: true
    },
    second: {
      value: Array.isArray(that) ? mergeAll4(...that) : that
    },
    zipK: {
      value: (a, b) => pipe(a, merge2(b))
    }
  });
  provideTo.second = self;
  return provideTo;
}));
var provideMerge = /* @__PURE__ */ dual(2, (that, self) => {
  const zipWith17 = Object.create(proto3);
  zipWith17._op_layer = OP_PROVIDE_MERGE;
  zipWith17.first = self;
  zipWith17.second = provide(that, self);
  zipWith17.zipK = (a, b) => {
    return pipe(a, merge2(b));
  };
  return zipWith17;
});
var zipWith7 = /* @__PURE__ */ dual(3, (self, that, f) => suspend3(() => {
  const zipWith17 = Object.create(proto3);
  zipWith17._op_layer = OP_ZIP_WITH2;
  zipWith17.first = self;
  zipWith17.second = that;
  zipWith17.zipK = f;
  return zipWith17;
}));
var unwrapEffect = (self) => {
  const tag3 = GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
  return flatMap11(fromEffect4(tag3, self), (context9) => get2(context9, tag3));
};
var unwrapScoped = (self) => {
  const tag3 = GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
  return flatMap11(scoped2(tag3, self), (context9) => get2(context9, tag3));
};
var annotateLogs2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith2(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations5) => Object.entries(args2[1]).reduce((acc, [key, value3]) => set3(acc, key, value3), annotations5));
});
var annotateSpans2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith2(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations5) => Object.entries(args2[1]).reduce((acc, [key, value3]) => set3(acc, key, value3), annotations5));
});
var withSpan2 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return unwrapScoped(map10(options?.onEnd ? tap2(makeSpanScoped(name, options), (span4) => addFinalizer((exit4) => options.onEnd(span4, exit4))) : makeSpanScoped(name, options), (span4) => withParentSpan2(self, span4)));
  }
  return (self) => unwrapScoped(map10(options?.onEnd ? tap2(makeSpanScoped(name, options), (span4) => addFinalizer((exit4) => options.onEnd(span4, exit4))) : makeSpanScoped(name, options), (span4) => withParentSpan2(self, span4)));
};
var withParentSpan2 = /* @__PURE__ */ dual(2, (self, span4) => provide(self, succeedContext(make2(spanTag, span4))));
var provideSomeLayer = /* @__PURE__ */ dual(2, (self, layer4) => scopedWith((scope5) => flatMap9(buildWithScope(layer4, scope5), (context9) => provideSomeContext(self, context9))));
var provideSomeRuntime = /* @__PURE__ */ dual(2, (self, rt) => {
  const patchRefs = diff6(defaultRuntime.fiberRefs, rt.fiberRefs);
  const patchFlags = diff4(defaultRuntime.runtimeFlags, rt.runtimeFlags);
  return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
    const oldContext = fiber.getFiberRef(currentContext);
    const oldRefs = fiber.getFiberRefs();
    const newRefs = patch7(fiber.id(), oldRefs)(patchRefs);
    const oldFlags = fiber.currentRuntimeFlags;
    const newFlags = patch4(patchFlags)(oldFlags);
    const rollbackRefs = diff6(newRefs, oldRefs);
    const rollbackFlags = diff4(newFlags, oldFlags);
    fiber.setFiberRefs(newRefs);
    fiber.currentRuntimeFlags = newFlags;
    return ensuring(provideSomeContext(restore(self), merge2(oldContext, rt.context)), withFiberRuntime((fiber2) => {
      fiber2.setFiberRefs(patch7(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
      fiber2.currentRuntimeFlags = patch4(rollbackFlags)(fiber2.currentRuntimeFlags);
      return void_2;
    }));
  }));
});
var effect_provide = /* @__PURE__ */ dual(2, (self, source) => {
  if (Array.isArray(source)) {
    return provideSomeLayer(self, mergeAll4(...source));
  } else if (isLayer(source)) {
    return provideSomeLayer(self, source);
  } else if (isContext2(source)) {
    return provideSomeContext(self, source);
  } else if (TypeId14 in source) {
    return flatMap9(source.runtimeEffect, (rt) => provideSomeRuntime(self, rt));
  } else {
    return provideSomeRuntime(self, source);
  }
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/console.js
var console2 = /* @__PURE__ */ map10(/* @__PURE__ */ fiberRefGet(currentServices), /* @__PURE__ */ get2(consoleTag));
var consoleWith = (f) => fiberRefGetWith(currentServices, (services) => f(get2(services, consoleTag)));
var withConsole = /* @__PURE__ */ dual(2, (effect4, value3) => fiberRefLocallyWith(effect4, currentServices, add2(consoleTag, value3)));
var withConsoleScoped = (console4) => fiberRefLocallyScopedWith(currentServices, add2(consoleTag, console4));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Data.js
var Data_exports = {};
__export(Data_exports, {
  Class: () => Class4,
  Error: () => Error3,
  Structural: () => Structural2,
  TaggedClass: () => TaggedClass,
  TaggedError: () => TaggedError,
  array: () => array3,
  case: () => _case,
  struct: () => struct2,
  tagged: () => tagged2,
  taggedEnum: () => taggedEnum,
  tuple: () => tuple2,
  unsafeArray: () => unsafeArray,
  unsafeStruct: () => unsafeStruct
});
var struct2 = struct;
var unsafeStruct = (as13) => Object.setPrototypeOf(as13, StructuralPrototype);
var tuple2 = (...as13) => unsafeArray(as13);
var array3 = (as13) => unsafeArray(as13.slice(0));
var unsafeArray = (as13) => Object.setPrototypeOf(as13, ArrayProto);
var _case = () => (args2) => args2 === void 0 ? Object.create(StructuralPrototype) : struct2(args2);
var tagged2 = (tag3) => (args2) => {
  const value3 = args2 === void 0 ? Object.create(StructuralPrototype) : struct2(args2);
  value3._tag = tag3;
  return value3;
};
var Class4 = Structural;
var TaggedClass = (tag3) => {
  class Base3 extends Class4 {
    constructor() {
      super(...arguments);
      __publicField(this, "_tag", tag3);
    }
  }
  return Base3;
};
var Structural2 = Structural;
var taggedEnum = () => new Proxy({}, {
  get(_target, tag3, _receiver) {
    if (tag3 === "$is") {
      return isTagged;
    } else if (tag3 === "$match") {
      return taggedMatch;
    }
    return tagged2(tag3);
  }
});
function taggedMatch() {
  if (arguments.length === 1) {
    const cases2 = arguments[0];
    return function(value4) {
      return cases2[value4._tag](value4);
    };
  }
  const value3 = arguments[0];
  const cases = arguments[1];
  return cases[value3._tag](value3);
}
var Error3 = /* @__PURE__ */ function() {
  const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
  const O = {
    BaseEffectError: class extends YieldableError {
      constructor(args2) {
        super(args2?.message, args2?.cause ? {
          cause: args2.cause
        } : void 0);
        if (args2) {
          Object.assign(this, args2);
          Object.defineProperty(this, plainArgsSymbol, {
            value: args2,
            enumerable: false
          });
        }
      }
      toJSON() {
        return {
          ...this[plainArgsSymbol],
          ...this
        };
      }
    }
  };
  return O.BaseEffectError;
}();
var TaggedError = (tag3) => {
  const O = {
    BaseEffectError: class extends Error3 {
      constructor() {
        super(...arguments);
        __publicField(this, "_tag", tag3);
      }
    }
  };
  O.BaseEffectError.prototype.name = tag3;
  return O.BaseEffectError;
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/dateTime.js
var TypeId15 = /* @__PURE__ */ Symbol.for("effect/DateTime");
var TimeZoneTypeId = /* @__PURE__ */ Symbol.for("effect/DateTime/TimeZone");
var Proto2 = {
  [TypeId15]: TypeId15,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [NodeInspectSymbol]() {
    return this.toString();
  },
  toJSON() {
    return toDateUtc(this).toJSON();
  }
};
var ProtoUtc = {
  ...Proto2,
  _tag: "Utc",
  [symbol]() {
    return cached(this, number(this.epochMillis));
  },
  [symbol2](that) {
    return isDateTime(that) && that._tag === "Utc" && this.epochMillis === that.epochMillis;
  },
  toString() {
    return `DateTime.Utc(${toDateUtc(this).toJSON()})`;
  }
};
var ProtoZoned = {
  ...Proto2,
  _tag: "Zoned",
  [symbol]() {
    return pipe(number(this.epochMillis), combine(hash(this.zone)), cached(this));
  },
  [symbol2](that) {
    return isDateTime(that) && that._tag === "Zoned" && this.epochMillis === that.epochMillis && equals(this.zone, that.zone);
  },
  toString() {
    return `DateTime.Zoned(${formatIsoZoned(this)})`;
  }
};
var ProtoTimeZone = {
  [TimeZoneTypeId]: TimeZoneTypeId,
  [NodeInspectSymbol]() {
    return this.toString();
  }
};
var ProtoTimeZoneNamed = {
  ...ProtoTimeZone,
  _tag: "Named",
  [symbol]() {
    return cached(this, string(`Named:${this.id}`));
  },
  [symbol2](that) {
    return isTimeZone(that) && that._tag === "Named" && this.id === that.id;
  },
  toString() {
    return `TimeZone.Named(${this.id})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Named",
      id: this.id
    };
  }
};
var ProtoTimeZoneOffset = {
  ...ProtoTimeZone,
  _tag: "Offset",
  [symbol]() {
    return cached(this, string(`Offset:${this.offset}`));
  },
  [symbol2](that) {
    return isTimeZone(that) && that._tag === "Offset" && this.offset === that.offset;
  },
  toString() {
    return `TimeZone.Offset(${offsetToString(this.offset)})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Offset",
      offset: this.offset
    };
  }
};
var makeZonedProto = (epochMillis, zone, partsUtc) => {
  const self = Object.create(ProtoZoned);
  self.epochMillis = epochMillis;
  self.zone = zone;
  Object.defineProperty(self, "partsUtc", {
    value: partsUtc,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(self, "adjustedEpochMillis", {
    value: void 0,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(self, "partsAdjusted", {
    value: void 0,
    enumerable: false,
    writable: true
  });
  return self;
};
var isDateTime = (u) => hasProperty(u, TypeId15);
var isTimeZone = (u) => hasProperty(u, TimeZoneTypeId);
var isTimeZoneOffset = (u) => isTimeZone(u) && u._tag === "Offset";
var isTimeZoneNamed = (u) => isTimeZone(u) && u._tag === "Named";
var isUtc = (self) => self._tag === "Utc";
var isZoned = (self) => self._tag === "Zoned";
var Equivalence2 = /* @__PURE__ */ make3((a, b) => a.epochMillis === b.epochMillis);
var makeUtc = (epochMillis) => {
  const self = Object.create(ProtoUtc);
  self.epochMillis = epochMillis;
  Object.defineProperty(self, "partsUtc", {
    value: void 0,
    enumerable: false,
    writable: true
  });
  return self;
};
var unsafeFromDate = (date3) => {
  const epochMillis = date3.getTime();
  if (Number.isNaN(epochMillis)) {
    throw new IllegalArgumentException2("Invalid date");
  }
  return makeUtc(epochMillis);
};
var unsafeMake10 = (input) => {
  if (isDateTime(input)) {
    return input;
  } else if (input instanceof Date) {
    return unsafeFromDate(input);
  } else if (typeof input === "object") {
    const date3 = /* @__PURE__ */ new Date(0);
    setPartsDate(date3, input);
    return unsafeFromDate(date3);
  }
  return unsafeFromDate(new Date(input));
};
var minEpochMillis = -864e13 + 12 * 60 * 60 * 1e3;
var maxEpochMillis = 864e13 - 14 * 60 * 60 * 1e3;
var unsafeMakeZoned = (input, options) => {
  if (options?.timeZone === void 0 && isDateTime(input) && isZoned(input)) {
    return input;
  }
  const self = unsafeMake10(input);
  if (self.epochMillis < minEpochMillis || self.epochMillis > maxEpochMillis) {
    throw new IllegalArgumentException2(`Epoch millis out of range: ${self.epochMillis}`);
  }
  let zone;
  if (options?.timeZone === void 0) {
    const offset = new Date(self.epochMillis).getTimezoneOffset() * -60 * 1e3;
    zone = zoneMakeOffset(offset);
  } else if (isTimeZone(options?.timeZone)) {
    zone = options.timeZone;
  } else if (typeof options?.timeZone === "number") {
    zone = zoneMakeOffset(options.timeZone);
  } else {
    const parsedZone = zoneFromString(options.timeZone);
    if (isNone2(parsedZone)) {
      throw new IllegalArgumentException2(`Invalid time zone: ${options.timeZone}`);
    }
    zone = parsedZone.value;
  }
  if (options?.adjustForTimeZone !== true) {
    return makeZonedProto(self.epochMillis, zone, self.partsUtc);
  }
  return makeZonedFromAdjusted(self.epochMillis, zone);
};
var makeZoned = /* @__PURE__ */ liftThrowable(unsafeMakeZoned);
var zonedStringRegex = /^(.{17,35})\[(.+)\]$/;
var makeZonedFromString = (input) => {
  const match21 = zonedStringRegex.exec(input);
  if (match21 === null) {
    const offset = parseOffset(input);
    return offset !== null ? makeZoned(input, {
      timeZone: offset
    }) : none2();
  }
  const [, isoString, timeZone] = match21;
  return makeZoned(isoString, {
    timeZone
  });
};
var validZoneCache = /* @__PURE__ */ globalValue("effect/DateTime/validZoneCache", () => /* @__PURE__ */ new Map());
var formatOptions = {
  day: "numeric",
  month: "numeric",
  year: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric",
  timeZoneName: "longOffset",
  fractionalSecondDigits: 3,
  hourCycle: "h23"
};
var zoneMakeIntl = (format8) => {
  const zoneId = format8.resolvedOptions().timeZone;
  if (validZoneCache.has(zoneId)) {
    return validZoneCache.get(zoneId);
  }
  const zone = Object.create(ProtoTimeZoneNamed);
  zone.id = zoneId;
  zone.format = format8;
  validZoneCache.set(zoneId, zone);
  return zone;
};
var zoneUnsafeMakeNamed = (zoneId) => {
  if (validZoneCache.has(zoneId)) {
    return validZoneCache.get(zoneId);
  }
  try {
    return zoneMakeIntl(new Intl.DateTimeFormat("en-US", {
      ...formatOptions,
      timeZone: zoneId
    }));
  } catch {
    throw new IllegalArgumentException2(`Invalid time zone: ${zoneId}`);
  }
};
var zoneMakeOffset = (offset) => {
  const zone = Object.create(ProtoTimeZoneOffset);
  zone.offset = offset;
  return zone;
};
var zoneMakeNamed = /* @__PURE__ */ liftThrowable(zoneUnsafeMakeNamed);
var offsetZoneRegex = /^(?:GMT|[+-])/;
var zoneFromString = (zone) => {
  if (offsetZoneRegex.test(zone)) {
    const offset = parseOffset(zone);
    return offset === null ? none2() : some2(zoneMakeOffset(offset));
  }
  return zoneMakeNamed(zone);
};
var zoneToString = (self) => {
  if (self._tag === "Offset") {
    return offsetToString(self.offset);
  }
  return self.id;
};
var toDateUtc = (self) => new Date(self.epochMillis);
var toDate = (self) => {
  if (self._tag === "Utc") {
    return new Date(self.epochMillis);
  } else if (self.zone._tag === "Offset") {
    return new Date(self.epochMillis + self.zone.offset);
  } else if (self.adjustedEpochMillis !== void 0) {
    return new Date(self.adjustedEpochMillis);
  }
  const parts2 = self.zone.format.formatToParts(self.epochMillis).filter((_) => _.type !== "literal");
  const date3 = /* @__PURE__ */ new Date(0);
  date3.setUTCFullYear(Number(parts2[2].value), Number(parts2[0].value) - 1, Number(parts2[1].value));
  date3.setUTCHours(Number(parts2[3].value), Number(parts2[4].value), Number(parts2[5].value), Number(parts2[6].value));
  self.adjustedEpochMillis = date3.getTime();
  return date3;
};
var zonedOffset = (self) => {
  const date3 = toDate(self);
  return date3.getTime() - toEpochMillis(self);
};
var offsetToString = (offset) => {
  const abs2 = Math.abs(offset);
  let hours2 = Math.floor(abs2 / (60 * 60 * 1e3));
  let minutes2 = Math.round(abs2 % (60 * 60 * 1e3) / (60 * 1e3));
  if (minutes2 === 60) {
    hours2 += 1;
    minutes2 = 0;
  }
  return `${offset < 0 ? "-" : "+"}${String(hours2).padStart(2, "0")}:${String(minutes2).padStart(2, "0")}`;
};
var zonedOffsetIso = (self) => offsetToString(zonedOffset(self));
var toEpochMillis = (self) => self.epochMillis;
var dateToParts = (date3) => ({
  millis: date3.getUTCMilliseconds(),
  seconds: date3.getUTCSeconds(),
  minutes: date3.getUTCMinutes(),
  hours: date3.getUTCHours(),
  day: date3.getUTCDate(),
  weekDay: date3.getUTCDay(),
  month: date3.getUTCMonth() + 1,
  year: date3.getUTCFullYear()
});
var toParts = (self) => {
  if (self._tag === "Utc") {
    return toPartsUtc(self);
  } else if (self.partsAdjusted !== void 0) {
    return self.partsAdjusted;
  }
  self.partsAdjusted = withDate(self, dateToParts);
  return self.partsAdjusted;
};
var toPartsUtc = (self) => {
  if (self.partsUtc !== void 0) {
    return self.partsUtc;
  }
  self.partsUtc = withDateUtc(self, dateToParts);
  return self.partsUtc;
};
var setPartsDate = (date3, parts2) => {
  if (parts2.year !== void 0) {
    date3.setUTCFullYear(parts2.year);
  }
  if (parts2.month !== void 0) {
    date3.setUTCMonth(parts2.month - 1);
  }
  if (parts2.day !== void 0) {
    date3.setUTCDate(parts2.day);
  }
  if (parts2.weekDay !== void 0) {
    const diff8 = parts2.weekDay - date3.getUTCDay();
    date3.setUTCDate(date3.getUTCDate() + diff8);
  }
  if (parts2.hours !== void 0) {
    date3.setUTCHours(parts2.hours);
  }
  if (parts2.minutes !== void 0) {
    date3.setUTCMinutes(parts2.minutes);
  }
  if (parts2.seconds !== void 0) {
    date3.setUTCSeconds(parts2.seconds);
  }
  if (parts2.millis !== void 0) {
    date3.setUTCMilliseconds(parts2.millis);
  }
};
var makeZonedFromAdjusted = (adjustedMillis, zone) => {
  const offset = zone._tag === "Offset" ? zone.offset : calculateNamedOffset(adjustedMillis, zone);
  return makeZonedProto(adjustedMillis - offset, zone);
};
var offsetRegex = /([+-])(\d{2}):(\d{2})$/;
var parseOffset = (offset) => {
  const match21 = offsetRegex.exec(offset);
  if (match21 === null) {
    return null;
  }
  const [, sign2, hours2, minutes2] = match21;
  return (sign2 === "+" ? 1 : -1) * (Number(hours2) * 60 + Number(minutes2)) * 60 * 1e3;
};
var calculateNamedOffset = (adjustedMillis, zone) => {
  const offset = zone.format.formatToParts(adjustedMillis).find((_) => _.type === "timeZoneName")?.value ?? "";
  if (offset === "GMT") {
    return 0;
  }
  const result = parseOffset(offset);
  if (result === null) {
    return zonedOffset(makeZonedProto(adjustedMillis, zone));
  }
  return result;
};
var mutate4 = /* @__PURE__ */ dual(2, (self, f) => {
  if (self._tag === "Utc") {
    const date3 = toDateUtc(self);
    f(date3);
    return makeUtc(date3.getTime());
  }
  const adjustedDate = toDate(self);
  const newAdjustedDate = new Date(adjustedDate.getTime());
  f(newAdjustedDate);
  return makeZonedFromAdjusted(newAdjustedDate.getTime(), self.zone);
});
var withDate = /* @__PURE__ */ dual(2, (self, f) => f(toDate(self)));
var withDateUtc = /* @__PURE__ */ dual(2, (self, f) => f(toDateUtc(self)));
var formatIso2 = (self) => toDateUtc(self).toISOString();
var formatIsoOffset = (self) => {
  const date3 = toDate(self);
  return self._tag === "Utc" ? date3.toISOString() : `${date3.toISOString().slice(0, -1)}${zonedOffsetIso(self)}`;
};
var formatIsoZoned = (self) => self.zone._tag === "Offset" ? formatIsoOffset(self) : `${formatIsoOffset(self)}[${self.zone.id}]`;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/String.js
var toUpperCase = (self) => self.toUpperCase();
var toLowerCase = (self) => self.toLowerCase();
var capitalize = (self) => {
  if (self.length === 0) return self;
  return toUpperCase(self[0]) + self.slice(1);
};
var uncapitalize = (self) => {
  if (self.length === 0) return self;
  return toLowerCase(self[0]) + self.slice(1);
};
var isNonEmpty5 = (self) => self.length > 0;
var split2 = /* @__PURE__ */ dual(2, (self, separator) => {
  const out = self.split(separator);
  return isNonEmptyArray(out) ? out : [self];
});
var camelToSnake = (self) => self.replace(/([A-Z])/g, "_$1").toLowerCase();

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Cron.js
var TypeId16 = /* @__PURE__ */ Symbol.for("effect/Cron");
var CronProto = {
  [TypeId16]: TypeId16,
  [symbol2](that) {
    return isCron(that) && equals3(this, that);
  },
  [symbol]() {
    return pipe(hash(this.tz), combine(array(fromIterable2(this.seconds))), combine(array(fromIterable2(this.minutes))), combine(array(fromIterable2(this.hours))), combine(array(fromIterable2(this.days))), combine(array(fromIterable2(this.months))), combine(array(fromIterable2(this.weekdays))), cached(this));
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Cron",
      tz: this.tz,
      seconds: fromIterable2(this.seconds),
      minutes: fromIterable2(this.minutes),
      hours: fromIterable2(this.hours),
      days: fromIterable2(this.days),
      months: fromIterable2(this.months),
      weekdays: fromIterable2(this.weekdays)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isCron = (u) => hasProperty(u, TypeId16);
var make40 = (values5) => {
  const o = Object.create(CronProto);
  o.seconds = new Set(sort(values5.seconds ?? [0], Order2));
  o.minutes = new Set(sort(values5.minutes, Order2));
  o.hours = new Set(sort(values5.hours, Order2));
  o.days = new Set(sort(values5.days, Order2));
  o.months = new Set(sort(values5.months, Order2));
  o.weekdays = new Set(sort(values5.weekdays, Order2));
  o.tz = fromNullable(values5.tz);
  const seconds2 = Array.from(o.seconds);
  const minutes2 = Array.from(o.minutes);
  const hours2 = Array.from(o.hours);
  const days2 = Array.from(o.days);
  const months = Array.from(o.months);
  const weekdays = Array.from(o.weekdays);
  o.first = {
    second: seconds2[0] ?? 0,
    minute: minutes2[0] ?? 0,
    hour: hours2[0] ?? 0,
    day: days2[0] ?? 1,
    month: (months[0] ?? 1) - 1,
    weekday: weekdays[0] ?? 0
  };
  o.next = {
    second: nextLookupTable(seconds2, 60),
    minute: nextLookupTable(minutes2, 60),
    hour: nextLookupTable(hours2, 24),
    day: nextLookupTable(days2, 32),
    month: nextLookupTable(months, 13),
    weekday: nextLookupTable(weekdays, 7)
  };
  return o;
};
var nextLookupTable = (values5, size17) => {
  const result = new Array(size17).fill(void 0);
  if (values5.length === 0) {
    return result;
  }
  let current2 = void 0;
  let index = values5.length - 1;
  for (let i = size17 - 1; i >= 0; i--) {
    while (index >= 0 && values5[index] >= i) {
      current2 = values5[index--];
    }
    result[i] = current2;
  }
  return result;
};
var ParseErrorTypeId = /* @__PURE__ */ Symbol.for("effect/Cron/errors/ParseError");
var _a48, _b15;
var ParseError = class extends (_b15 = /* @__PURE__ */ TaggedError("CronParseError"), _a48 = ParseErrorTypeId, _b15) {
  constructor() {
    super(...arguments);
    /**
     * @since 2.0.0
     */
    __publicField(this, _a48, ParseErrorTypeId);
  }
};
var parse2 = (cron3, tz) => {
  const segments = cron3.split(" ").filter(isNonEmpty5);
  if (segments.length !== 5 && segments.length !== 6) {
    return left2(new ParseError({
      message: `Invalid number of segments in cron expression`,
      input: cron3
    }));
  }
  if (segments.length === 5) {
    segments.unshift("0");
  }
  const [seconds2, minutes2, hours2, days2, months, weekdays] = segments;
  const zone = tz === void 0 || isTimeZone(tz) ? right2(tz) : fromOption2(zoneFromString(tz), () => new ParseError({
    message: `Invalid time zone in cron expression`,
    input: tz
  }));
  return all({
    tz: zone,
    seconds: parseSegment(seconds2, secondOptions),
    minutes: parseSegment(minutes2, minuteOptions),
    hours: parseSegment(hours2, hourOptions),
    days: parseSegment(days2, dayOptions),
    months: parseSegment(months, monthOptions),
    weekdays: parseSegment(weekdays, weekdayOptions)
  }).pipe(map(make40));
};
var match13 = (cron3, date3) => {
  const parts2 = unsafeMakeZoned(date3, {
    timeZone: getOrUndefined(cron3.tz)
  }).pipe(toParts);
  if (cron3.seconds.size !== 0 && !cron3.seconds.has(parts2.seconds)) {
    return false;
  }
  if (cron3.minutes.size !== 0 && !cron3.minutes.has(parts2.minutes)) {
    return false;
  }
  if (cron3.hours.size !== 0 && !cron3.hours.has(parts2.hours)) {
    return false;
  }
  if (cron3.months.size !== 0 && !cron3.months.has(parts2.month)) {
    return false;
  }
  if (cron3.days.size === 0 && cron3.weekdays.size === 0) {
    return true;
  }
  if (cron3.weekdays.size === 0) {
    return cron3.days.has(parts2.day);
  }
  if (cron3.days.size === 0) {
    return cron3.weekdays.has(parts2.weekDay);
  }
  return cron3.days.has(parts2.day) || cron3.weekdays.has(parts2.weekDay);
};
var daysInMonth = (date3) => new Date(Date.UTC(date3.getUTCFullYear(), date3.getUTCMonth() + 1, 0)).getUTCDate();
var next2 = (cron3, startFrom) => {
  const tz = getOrUndefined(cron3.tz);
  const zoned = unsafeMakeZoned(startFrom ?? /* @__PURE__ */ new Date(), {
    timeZone: tz
  });
  const utc = tz !== void 0 && isTimeZoneNamed(tz) && tz.id === "UTC";
  const adjustDst = utc ? constVoid : (current2) => {
    const adjusted = unsafeMakeZoned(current2, {
      timeZone: zoned.zone,
      adjustForTimeZone: true
    }).pipe(toDate);
    const drift = current2.getTime() - adjusted.getTime();
    if (drift > 0) {
      current2.setTime(current2.getTime() + drift);
    }
  };
  const result = mutate4(zoned, (current2) => {
    current2.setUTCSeconds(current2.getUTCSeconds() + 1, 0);
    for (let i = 0; i < 1e4; i++) {
      if (cron3.seconds.size !== 0) {
        const currentSecond = current2.getUTCSeconds();
        const nextSecond2 = cron3.next.second[currentSecond];
        if (nextSecond2 === void 0) {
          current2.setUTCMinutes(current2.getUTCMinutes() + 1, cron3.first.second);
          adjustDst(current2);
          continue;
        }
        if (nextSecond2 > currentSecond) {
          current2.setUTCSeconds(nextSecond2);
          adjustDst(current2);
          continue;
        }
      }
      if (cron3.minutes.size !== 0) {
        const currentMinute = current2.getUTCMinutes();
        const nextMinute2 = cron3.next.minute[currentMinute];
        if (nextMinute2 === void 0) {
          current2.setUTCHours(current2.getUTCHours() + 1, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
        if (nextMinute2 > currentMinute) {
          current2.setUTCMinutes(nextMinute2, cron3.first.second);
          adjustDst(current2);
          continue;
        }
      }
      if (cron3.hours.size !== 0) {
        const currentHour = current2.getUTCHours();
        const nextHour2 = cron3.next.hour[currentHour];
        if (nextHour2 === void 0) {
          current2.setUTCDate(current2.getUTCDate() + 1);
          current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
        if (nextHour2 > currentHour) {
          current2.setUTCHours(nextHour2, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
      }
      if (cron3.weekdays.size !== 0 || cron3.days.size !== 0) {
        let a = Infinity;
        let b = Infinity;
        if (cron3.weekdays.size !== 0) {
          const currentWeekday = current2.getUTCDay();
          const nextWeekday = cron3.next.weekday[currentWeekday];
          a = nextWeekday === void 0 ? 7 - currentWeekday + cron3.first.weekday : nextWeekday - currentWeekday;
        }
        if (cron3.days.size !== 0 && a !== 0) {
          const currentDay = current2.getUTCDate();
          const nextDay2 = cron3.next.day[currentDay];
          b = nextDay2 === void 0 ? daysInMonth(current2) - currentDay + cron3.first.day : nextDay2 - currentDay;
        }
        const addDays = Math.min(a, b);
        if (addDays !== 0) {
          current2.setUTCDate(current2.getUTCDate() + addDays);
          current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
      }
      if (cron3.months.size !== 0) {
        const currentMonth = current2.getUTCMonth() + 1;
        const nextMonth = cron3.next.month[currentMonth];
        if (nextMonth === void 0) {
          current2.setUTCFullYear(current2.getUTCFullYear() + 1);
          current2.setUTCMonth(cron3.first.month, cron3.first.day);
          current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
        if (nextMonth > currentMonth) {
          current2.setUTCMonth(nextMonth - 1, cron3.first.day);
          current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
      }
      return;
    }
    throw new Error("Unable to find next cron date");
  });
  return toDateUtc(result);
};
var Equivalence3 = /* @__PURE__ */ make3((self, that) => restrictionsEquals(self.seconds, that.seconds) && restrictionsEquals(self.minutes, that.minutes) && restrictionsEquals(self.hours, that.hours) && restrictionsEquals(self.days, that.days) && restrictionsEquals(self.months, that.months) && restrictionsEquals(self.weekdays, that.weekdays));
var restrictionsArrayEquals = /* @__PURE__ */ array2(number2);
var restrictionsEquals = (self, that) => restrictionsArrayEquals(fromIterable2(self), fromIterable2(that));
var equals3 = /* @__PURE__ */ dual(2, (self, that) => Equivalence3(self, that));
var secondOptions = {
  min: 0,
  max: 59
};
var minuteOptions = {
  min: 0,
  max: 59
};
var hourOptions = {
  min: 0,
  max: 23
};
var dayOptions = {
  min: 1,
  max: 31
};
var monthOptions = {
  min: 1,
  max: 12,
  aliases: {
    jan: 1,
    feb: 2,
    mar: 3,
    apr: 4,
    may: 5,
    jun: 6,
    jul: 7,
    aug: 8,
    sep: 9,
    oct: 10,
    nov: 11,
    dec: 12
  }
};
var weekdayOptions = {
  min: 0,
  max: 6,
  aliases: {
    sun: 0,
    mon: 1,
    tue: 2,
    wed: 3,
    thu: 4,
    fri: 5,
    sat: 6
  }
};
var parseSegment = (input, options) => {
  const capacity7 = options.max - options.min + 1;
  const values5 = /* @__PURE__ */ new Set();
  const fields = input.split(",");
  for (const field of fields) {
    const [raw, step4] = splitStep(field);
    if (raw === "*" && step4 === void 0) {
      return right2(/* @__PURE__ */ new Set());
    }
    if (step4 !== void 0) {
      if (!Number.isInteger(step4)) {
        return left2(new ParseError({
          message: `Expected step value to be a positive integer`,
          input
        }));
      }
      if (step4 < 1) {
        return left2(new ParseError({
          message: `Expected step value to be greater than 0`,
          input
        }));
      }
      if (step4 > options.max) {
        return left2(new ParseError({
          message: `Expected step value to be less than ${options.max}`,
          input
        }));
      }
    }
    if (raw === "*") {
      for (let i = options.min; i <= options.max; i += step4 ?? 1) {
        values5.add(i);
      }
    } else {
      const [left3, right3] = splitRange(raw, options.aliases);
      if (!Number.isInteger(left3)) {
        return left2(new ParseError({
          message: `Expected a positive integer`,
          input
        }));
      }
      if (left3 < options.min || left3 > options.max) {
        return left2(new ParseError({
          message: `Expected a value between ${options.min} and ${options.max}`,
          input
        }));
      }
      if (right3 === void 0) {
        values5.add(left3);
      } else {
        if (!Number.isInteger(right3)) {
          return left2(new ParseError({
            message: `Expected a positive integer`,
            input
          }));
        }
        if (right3 < options.min || right3 > options.max) {
          return left2(new ParseError({
            message: `Expected a value between ${options.min} and ${options.max}`,
            input
          }));
        }
        if (left3 > right3) {
          return left2(new ParseError({
            message: `Invalid value range`,
            input
          }));
        }
        for (let i = left3; i <= right3; i += step4 ?? 1) {
          values5.add(i);
        }
      }
    }
    if (values5.size >= capacity7) {
      return right2(/* @__PURE__ */ new Set());
    }
  }
  return right2(values5);
};
var splitStep = (input) => {
  const seperator = input.indexOf("/");
  if (seperator !== -1) {
    return [input.slice(0, seperator), Number(input.slice(seperator + 1))];
  }
  return [input, void 0];
};
var splitRange = (input, aliases) => {
  const seperator = input.indexOf("-");
  if (seperator !== -1) {
    return [aliasOrValue(input.slice(0, seperator), aliases), aliasOrValue(input.slice(seperator + 1), aliases)];
  }
  return [aliasOrValue(input, aliases), void 0];
};
function aliasOrValue(field, aliases) {
  return aliases?.[field.toLocaleLowerCase()] ?? Number(field);
}

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Random.js
var next3 = next;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey = "effect/Schedule";
var ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
var isSchedule = (u) => hasProperty(u, ScheduleTypeId);
var ScheduleDriverSymbolKey = "effect/ScheduleDriver";
var ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
var defaultIterationMetadata = {
  start: 0,
  now: 0,
  input: void 0,
  elapsed: zero,
  elapsedSincePrevious: zero,
  recurrence: 0
};
var CurrentIterationMetadata = /* @__PURE__ */ Reference2()("effect/Schedule/CurrentIterationMetadata", {
  defaultValue: () => defaultIterationMetadata
});
var scheduleVariance = {
  /* c8 ignore next */
  _Out: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var scheduleDriverVariance = {
  /* c8 ignore next */
  _Out: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var _a49;
_a49 = ScheduleTypeId;
var ScheduleImpl = class {
  constructor(initial, step4) {
    __publicField(this, "initial");
    __publicField(this, "step");
    __publicField(this, _a49, scheduleVariance);
    this.initial = initial;
    this.step = step4;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var updateInfo = (iterationMetaRef, now2, input) => update2(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
  now: now2,
  input,
  recurrence: prev.recurrence + 1,
  elapsed: zero,
  elapsedSincePrevious: zero,
  start: now2
} : {
  now: now2,
  input,
  recurrence: prev.recurrence + 1,
  elapsed: millis(now2 - prev.start),
  elapsedSincePrevious: millis(now2 - prev.now),
  start: prev.start
});
var _a50;
_a50 = ScheduleDriverTypeId;
var ScheduleDriverImpl = class {
  constructor(schedule4, ref) {
    __publicField(this, "schedule");
    __publicField(this, "ref");
    __publicField(this, _a50, scheduleDriverVariance);
    __publicField(this, "iterationMeta", /* @__PURE__ */ unsafeMake6(defaultIterationMetadata));
    this.schedule = schedule4;
    this.ref = ref;
  }
  get state() {
    return map10(get10(this.ref), (tuple4) => tuple4[1]);
  }
  get last() {
    return flatMap9(get10(this.ref), ([element3, _]) => {
      switch (element3._tag) {
        case "None": {
          return failSync(() => new NoSuchElementException());
        }
        case "Some": {
          return succeed(element3.value);
        }
      }
    });
  }
  get reset() {
    return set4(this.ref, [none2(), this.schedule.initial]).pipe(zipLeft2(set4(this.iterationMeta, defaultIterationMetadata)));
  }
  next(input) {
    return pipe(map10(get10(this.ref), (tuple4) => tuple4[1]), flatMap9((state) => pipe(currentTimeMillis2, flatMap9((now2) => pipe(suspend(() => this.schedule.step(now2, input, state)), flatMap9(([state2, out, decision]) => {
      const setState = set4(this.ref, [some2(out), state2]);
      if (isDone5(decision)) {
        return setState.pipe(zipRight2(fail2(none2())));
      }
      const millis2 = start2(decision.intervals) - now2;
      if (millis2 <= 0) {
        return setState.pipe(zipRight2(updateInfo(this.iterationMeta, now2, input)), as2(out));
      }
      const duration4 = millis(millis2);
      return pipe(setState, zipRight2(updateInfo(this.iterationMeta, now2, input)), zipRight2(sleep3(duration4)), as2(out));
    }))))));
  }
};
var makeWithState = (initial, step4) => new ScheduleImpl(initial, step4);
var addDelay = /* @__PURE__ */ dual(2, (self, f) => addDelayEffect(self, (out) => sync(() => f(out))));
var addDelayEffect = /* @__PURE__ */ dual(2, (self, f) => modifyDelayEffect(self, (out, duration4) => map10(f(out), (delay3) => sum(duration4, decode(delay3)))));
var andThen5 = /* @__PURE__ */ dual(2, (self, that) => map17(andThenEither(self, that), merge3));
var andThenEither = /* @__PURE__ */ dual(2, (self, that) => makeWithState([self.initial, that.initial, true], (now2, input, state) => state[2] ? flatMap9(self.step(now2, input, state[0]), ([lState, out, decision]) => {
  if (isDone5(decision)) {
    return map10(that.step(now2, input, state[1]), ([rState, out2, decision2]) => [[lState, rState, false], right2(out2), decision2]);
  }
  return succeed([[lState, state[1], true], left2(out), decision]);
}) : map10(that.step(now2, input, state[1]), ([rState, out, decision]) => [[state[0], rState, false], right2(out), decision])));
var as5 = /* @__PURE__ */ dual(2, (self, out) => map17(self, () => out));
var asVoid3 = (self) => map17(self, constVoid);
var bothInOut = /* @__PURE__ */ dual(2, (self, that) => makeWithState([self.initial, that.initial], (now2, [in1, in2], state) => zipWith4(self.step(now2, in1, state[0]), that.step(now2, in2, state[1]), ([lState, out, lDecision], [rState, out2, rDecision]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    const interval = pipe(lDecision.intervals, union9(rDecision.intervals));
    return [[lState, rState], [out, out2], _continue2(interval)];
  }
  return [[lState, rState], [out, out2], done7];
})));
var check = /* @__PURE__ */ dual(2, (self, test) => checkEffect(self, (input, out) => sync(() => test(input, out))));
var checkEffect = /* @__PURE__ */ dual(2, (self, test) => makeWithState(self.initial, (now2, input, state) => flatMap9(self.step(now2, input, state), ([state2, out, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out, done7]);
  }
  return map10(test(input, out), (cont) => cont ? [state2, out, decision] : [state2, out, done7]);
})));
var collectAllInputs = () => collectAllOutputs(identity2());
var collectAllOutputs = (self) => reduce11(self, empty5(), (outs, out) => pipe(outs, append2(out)));
var collectUntil = (f) => collectAllOutputs(recurUntil(f));
var collectUntilEffect = (f) => collectAllOutputs(recurUntilEffect(f));
var collectWhile = (f) => collectAllOutputs(recurWhile(f));
var collectWhileEffect = (f) => collectAllOutputs(recurWhileEffect(f));
var compose = /* @__PURE__ */ dual(2, (self, that) => makeWithState([self.initial, that.initial], (now2, input, state) => flatMap9(self.step(now2, input, state[0]), ([lState, out, lDecision]) => map10(that.step(now2, out, state[1]), ([rState, out2, rDecision]) => isDone5(lDecision) ? [[lState, rState], out2, done7] : isDone5(rDecision) ? [[lState, rState], out2, done7] : [[lState, rState], out2, _continue2(pipe(lDecision.intervals, max5(rDecision.intervals)))]))));
var mapInput3 = /* @__PURE__ */ dual(2, (self, f) => mapInputEffect(self, (input2) => sync(() => f(input2))));
var mapInputContext2 = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now2, input, state) => mapInputContext(self.step(now2, input, state), f)));
var mapInputEffect = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now2, input2, state) => flatMap9(f(input2), (input) => self.step(now2, input, state))));
var cron = (expression, tz) => {
  const parsed = isCron(expression) ? right2(expression) : parse2(expression, tz);
  return makeWithState([true, [Number.MIN_SAFE_INTEGER, 0, 0]], (now2, _, [initial, previous2]) => {
    if (now2 < previous2[0]) {
      return succeed([[false, previous2], [previous2[1], previous2[2]], continueWith2(make35(previous2[1], previous2[2]))]);
    }
    if (isLeft2(parsed)) {
      return die2(parsed.left);
    }
    const cron3 = parsed.right;
    const date3 = new Date(now2);
    let next4;
    if (initial && match13(cron3, date3)) {
      next4 = now2;
    }
    next4 = next2(cron3, date3).getTime();
    const start5 = beginningOfSecond(next4);
    const end6 = endOfSecond(next4);
    return succeed([[false, [next4, start5, end6]], [start5, end6], continueWith2(make35(start5, end6))]);
  });
};
var dayOfMonth = (day) => {
  return makeWithState([Number.NEGATIVE_INFINITY, 0], (now2, _, state) => {
    if (!Number.isInteger(day) || day < 1 || 31 < day) {
      return dieSync(() => new IllegalArgumentException(`Invalid argument in: dayOfMonth(${day}). Must be in range 1...31`));
    }
    const n = state[1];
    const initial = n === 0;
    const day0 = nextDayOfMonth(now2, day, initial);
    const start5 = beginningOfDay(day0);
    const end6 = endOfDay(day0);
    const interval = make35(start5, end6);
    return succeed([[end6, n + 1], n, continueWith2(interval)]);
  });
};
var dayOfWeek = (day) => {
  return makeWithState([Number.MIN_SAFE_INTEGER, 0], (now2, _, state) => {
    if (!Number.isInteger(day) || day < 1 || 7 < day) {
      return dieSync(() => new IllegalArgumentException(`Invalid argument in: dayOfWeek(${day}). Must be in range 1 (Monday)...7 (Sunday)`));
    }
    const n = state[1];
    const initial = n === 0;
    const day0 = nextDay(now2, day, initial);
    const start5 = beginningOfDay(day0);
    const end6 = endOfDay(day0);
    const interval = make35(start5, end6);
    return succeed([[end6, n + 1], n, continueWith2(interval)]);
  });
};
var delayed = /* @__PURE__ */ dual(2, (self, f) => delayedEffect(self, (duration4) => sync(() => f(duration4))));
var delayedEffect = /* @__PURE__ */ dual(2, (self, f) => modifyDelayEffect(self, (_, delay3) => f(delay3)));
var delayedSchedule = (schedule4) => addDelay(schedule4, (x) => x);
var delays = (self) => makeWithState(self.initial, (now2, input, state) => pipe(self.step(now2, input, state), flatMap9(([state2, _, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, zero, decision]);
  }
  return succeed([state2, millis(start2(decision.intervals) - now2), decision]);
})));
var mapBoth4 = /* @__PURE__ */ dual(2, (self, {
  onInput,
  onOutput
}) => map17(mapInput3(self, onInput), onOutput));
var mapBothEffect = /* @__PURE__ */ dual(2, (self, {
  onInput,
  onOutput
}) => mapEffect3(mapInputEffect(self, onInput), onOutput));
var driver = (self) => pipe(make24([none2(), self.initial]), map10((ref) => new ScheduleDriverImpl(self, ref)));
var duration = (durationInput) => {
  const duration4 = decode(durationInput);
  const durationMillis = toMillis(duration4);
  return makeWithState(true, (now2, _, state) => succeed(state ? [false, duration4, continueWith2(after2(now2 + durationMillis))] : [false, zero, done7]));
};
var either3 = /* @__PURE__ */ dual(2, (self, that) => union10(self, that));
var eitherWith = /* @__PURE__ */ dual(3, (self, that, f) => unionWith2(self, that, f));
var ensuring2 = /* @__PURE__ */ dual(2, (self, finalizer3) => makeWithState(self.initial, (now2, input, state) => flatMap9(self.step(now2, input, state), ([state2, out, decision]) => isDone5(decision) ? as2(finalizer3, [state2, out, decision]) : succeed([state2, out, decision]))));
var exponential2 = (baseInput, factor = 2) => {
  const base = decode(baseInput);
  return delayedSchedule(map17(forever2, (i) => times(base, Math.pow(factor, i))));
};
var fibonacci = (oneInput) => {
  const one = decode(oneInput);
  return delayedSchedule(pipe(unfold2([one, one], ([a, b]) => [b, sum(a, b)]), map17((out) => out[0])));
};
var fixed = (intervalInput) => {
  const interval = decode(intervalInput);
  const intervalMillis = toMillis(interval);
  return makeWithState([none2(), 0], (now2, _, [option5, n]) => sync(() => {
    switch (option5._tag) {
      case "None": {
        return [[some2([now2, now2 + intervalMillis]), n + 1], n, continueWith2(after2(now2 + intervalMillis))];
      }
      case "Some": {
        const [startMillis, lastRun] = option5.value;
        const runningBehind = now2 > lastRun + intervalMillis;
        const boundary = equals(interval, zero) ? interval : millis(intervalMillis - (now2 - startMillis) % intervalMillis);
        const sleepTime = equals(boundary, zero) ? interval : boundary;
        const nextRun = runningBehind ? now2 : now2 + toMillis(sleepTime);
        return [[some2([startMillis, nextRun]), n + 1], n, continueWith2(after2(nextRun))];
      }
    }
  }));
};
var fromDelay = (delay3) => duration(delay3);
var fromDelays = (delay3, ...delays3) => makeWithState([[delay3, ...delays3].map((_) => decode(_)), true], (now2, _, [durations, cont]) => sync(() => {
  if (cont) {
    const x = durations[0];
    const interval = after2(now2 + toMillis(x));
    if (durations.length >= 2) {
      return [[durations.slice(1), true], x, continueWith2(interval)];
    }
    const y = durations.slice(1);
    return [[[x, ...y], false], x, continueWith2(interval)];
  }
  return [[durations, false], zero, done7];
}));
var fromFunction2 = (f) => map17(identity2(), f);
var hourOfDay = (hour) => makeWithState([Number.NEGATIVE_INFINITY, 0], (now2, _, state) => {
  if (!Number.isInteger(hour) || hour < 0 || 23 < hour) {
    return dieSync(() => new IllegalArgumentException(`Invalid argument in: hourOfDay(${hour}). Must be in range 0...23`));
  }
  const n = state[1];
  const initial = n === 0;
  const hour0 = nextHour(now2, hour, initial);
  const start5 = beginningOfHour(hour0);
  const end6 = endOfHour(hour0);
  const interval = make35(start5, end6);
  return succeed([[end6, n + 1], n, continueWith2(interval)]);
});
var identity2 = () => makeWithState(void 0, (now2, input, state) => succeed([state, input, continueWith2(after2(now2))]));
var intersect5 = /* @__PURE__ */ dual(2, (self, that) => intersectWith(self, that, intersect4));
var intersectWith = /* @__PURE__ */ dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now2, input, state) => pipe(zipWith4(self.step(now2, input, state[0]), that.step(now2, input, state[1]), (a, b) => [a, b]), flatMap9(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
  }
  return succeed([[lState, rState], [out, out2], done7]);
}))));
var intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
  const combined = f(lInterval, rInterval);
  if (isNonEmpty4(combined)) {
    return succeed([[lState, rState], [out, out2], _continue2(combined)]);
  }
  if (pipe(lInterval, lessThan6(rInterval))) {
    return flatMap9(self.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
      if (isDone5(decision)) {
        return succeed([[lState2, rState], [out3, out2], done7]);
      }
      return intersectWithLoop(self, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f);
    });
  }
  return flatMap9(that.step(end2(rInterval), input, rState), ([rState2, out22, decision]) => {
    if (isDone5(decision)) {
      return succeed([[lState, rState2], [out, out22], done7]);
    }
    return intersectWithLoop(self, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f);
  });
};
var jittered = (self) => jitteredWith(self, {
  min: 0.8,
  max: 1.2
});
var jitteredWith = /* @__PURE__ */ dual(2, (self, options) => {
  const {
    max: max7,
    min: min5
  } = Object.assign({
    min: 0.8,
    max: 1.2
  }, options);
  return delayedEffect(self, (duration4) => map10(next3, (random4) => {
    const d = toMillis(duration4);
    const jittered3 = d * min5 * (1 - random4) + d * max7 * random4;
    return millis(jittered3);
  }));
});
var linear = (baseInput) => {
  const base = decode(baseInput);
  return delayedSchedule(map17(forever2, (i) => times(base, i + 1)));
};
var map17 = /* @__PURE__ */ dual(2, (self, f) => mapEffect3(self, (out) => sync(() => f(out))));
var mapEffect3 = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now2, input, state) => flatMap9(self.step(now2, input, state), ([state2, out, decision]) => map10(f(out), (out2) => [state2, out2, decision]))));
var minuteOfHour = (minute) => makeWithState([Number.MIN_SAFE_INTEGER, 0], (now2, _, state) => {
  if (!Number.isInteger(minute) || minute < 0 || 59 < minute) {
    return dieSync(() => new IllegalArgumentException(`Invalid argument in: minuteOfHour(${minute}). Must be in range 0...59`));
  }
  const n = state[1];
  const initial = n === 0;
  const minute0 = nextMinute(now2, minute, initial);
  const start5 = beginningOfMinute(minute0);
  const end6 = endOfMinute(minute0);
  const interval = make35(start5, end6);
  return succeed([[end6, n + 1], n, continueWith2(interval)]);
});
var modifyDelay = /* @__PURE__ */ dual(2, (self, f) => modifyDelayEffect(self, (out, duration4) => sync(() => f(out, duration4))));
var modifyDelayEffect = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now2, input, state) => flatMap9(self.step(now2, input, state), ([state2, out, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out, decision]);
  }
  const intervals = decision.intervals;
  const delay3 = size11(make35(now2, start2(intervals)));
  return map10(f(out, delay3), (durationInput) => {
    const duration4 = decode(durationInput);
    const oldStart = start2(intervals);
    const newStart = now2 + toMillis(duration4);
    const delta = newStart - oldStart;
    const newEnd = Math.max(0, end2(intervals) + delta);
    const newInterval = make35(newStart, newEnd);
    return [state2, out, continueWith2(newInterval)];
  });
})));
var onDecision = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now2, input, state) => flatMap9(self.step(now2, input, state), ([state2, out, decision]) => as2(f(out, decision), [state2, out, decision]))));
var passthrough2 = (self) => makeWithState(self.initial, (now2, input, state) => pipe(self.step(now2, input, state), map10(([state2, _, decision]) => [state2, input, decision])));
var provideContext3 = /* @__PURE__ */ dual(2, (self, context9) => makeWithState(self.initial, (now2, input, state) => provideContext(self.step(now2, input, state), context9)));
var provideService2 = /* @__PURE__ */ dual(3, (self, tag3, service3) => makeWithState(self.initial, (now2, input, state) => contextWithEffect((env3) => provideContext(
  // @ts-expect-error
  self.step(now2, input, state),
  add2(env3, tag3, service3)
))));
var recurUntil = (f) => untilInput(identity2(), f);
var recurUntilEffect = (f) => untilInputEffect(identity2(), f);
var recurUntilOption = (pf) => untilOutput(map17(identity2(), pf), isSome2);
var recurUpTo = (durationInput) => {
  const duration4 = decode(durationInput);
  return whileOutput(elapsed, (elapsed3) => lessThan2(elapsed3, duration4));
};
var recurWhile = (f) => whileInput(identity2(), f);
var recurWhileEffect = (f) => whileInputEffect(identity2(), f);
var recurs = (n) => whileOutput(forever2, (out) => out < n);
var reduce11 = /* @__PURE__ */ dual(3, (self, zero3, f) => reduceEffect2(self, zero3, (z, out) => sync(() => f(z, out))));
var reduceEffect2 = /* @__PURE__ */ dual(3, (self, zero3, f) => makeWithState([self.initial, zero3], (now2, input, [s, z]) => flatMap9(self.step(now2, input, s), ([s2, out, decision]) => isDone5(decision) ? succeed([[s2, z], z, decision]) : map10(f(z, out), (z2) => [[s2, z2], z, decision]))));
var repetitions = (self) => reduce11(self, 0, (n, _) => n + 1);
var resetAfter = /* @__PURE__ */ dual(2, (self, durationInput) => {
  const duration4 = decode(durationInput);
  return pipe(self, intersect5(elapsed), resetWhen(([, time]) => greaterThanOrEqualTo2(time, duration4)), map17((out) => out[0]));
});
var resetWhen = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now2, input, state) => flatMap9(self.step(now2, input, state), ([state2, out, decision]) => f(out) ? self.step(now2, input, self.initial) : succeed([state2, out, decision]))));
var run = /* @__PURE__ */ dual(3, (self, now2, input) => pipe(runLoop(self, now2, fromIterable3(input), self.initial, empty5()), map10((list) => reverse2(list))));
var runLoop = (self, now2, inputs, state, acc) => {
  if (!isNonEmpty(inputs)) {
    return succeed(acc);
  }
  const input = headNonEmpty2(inputs);
  const nextInputs = tailNonEmpty2(inputs);
  return flatMap9(self.step(now2, input, state), ([state2, out, decision]) => {
    if (isDone5(decision)) {
      return sync(() => pipe(acc, prepend2(out)));
    }
    return runLoop(self, start2(decision.intervals), nextInputs, state2, prepend2(acc, out));
  });
};
var secondOfMinute = (second) => makeWithState([Number.NEGATIVE_INFINITY, 0], (now2, _, state) => {
  if (!Number.isInteger(second) || second < 0 || 59 < second) {
    return dieSync(() => new IllegalArgumentException(`Invalid argument in: secondOfMinute(${second}). Must be in range 0...59`));
  }
  const n = state[1];
  const initial = n === 0;
  const second0 = nextSecond(now2, second, initial);
  const start5 = beginningOfSecond(second0);
  const end6 = endOfSecond(second0);
  const interval = make35(start5, end6);
  return succeed([[end6, n + 1], n, continueWith2(interval)]);
});
var spaced = (duration4) => addDelay(forever2, () => duration4);
var succeed8 = (value3) => map17(forever2, () => value3);
var sync4 = (evaluate3) => map17(forever2, evaluate3);
var tapInput = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now2, input, state) => zipRight2(f(input), self.step(now2, input, state))));
var tapOutput = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now2, input, state) => tap2(self.step(now2, input, state), ([, out]) => f(out))));
var unfold2 = (initial, f) => makeWithState(initial, (now2, _, state) => sync(() => [f(state), state, continueWith2(after2(now2))]));
var union10 = /* @__PURE__ */ dual(2, (self, that) => unionWith2(self, that, union9));
var unionWith2 = /* @__PURE__ */ dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now2, input, state) => zipWith4(self.step(now2, input, state[0]), that.step(now2, input, state[1]), ([lState, l, lDecision], [rState, r, rDecision]) => {
  if (isDone5(lDecision) && isDone5(rDecision)) {
    return [[lState, rState], [l, r], done7];
  }
  if (isDone5(lDecision) && isContinue2(rDecision)) {
    return [[lState, rState], [l, r], _continue2(rDecision.intervals)];
  }
  if (isContinue2(lDecision) && isDone5(rDecision)) {
    return [[lState, rState], [l, r], _continue2(lDecision.intervals)];
  }
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    const combined = f(lDecision.intervals, rDecision.intervals);
    return [[lState, rState], [l, r], _continue2(combined)];
  }
  throw new Error("BUG: Schedule.unionWith - please report an issue at https://github.com/Effect-TS/effect/issues");
})));
var untilInput = /* @__PURE__ */ dual(2, (self, f) => check(self, (input, _) => !f(input)));
var untilInputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (input, _) => negate(f(input))));
var untilOutput = /* @__PURE__ */ dual(2, (self, f) => check(self, (_, out) => !f(out)));
var untilOutputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (_, out) => negate(f(out))));
var upTo = /* @__PURE__ */ dual(2, (self, duration4) => zipLeft4(self, recurUpTo(duration4)));
var whileInput = /* @__PURE__ */ dual(2, (self, f) => check(self, (input, _) => f(input)));
var whileInputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (input, _) => f(input)));
var whileOutput = /* @__PURE__ */ dual(2, (self, f) => check(self, (_, out) => f(out)));
var whileOutputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (_, out) => f(out)));
var windowed = (intervalInput) => {
  const interval = decode(intervalInput);
  const millis2 = toMillis(interval);
  return makeWithState([none2(), 0], (now2, _, [option5, n]) => {
    switch (option5._tag) {
      case "None": {
        return succeed([[some2(now2), n + 1], n, continueWith2(after2(now2 + millis2))]);
      }
      case "Some": {
        return succeed([[some2(option5.value), n + 1], n, continueWith2(after2(now2 + (millis2 - (now2 - option5.value) % millis2)))]);
      }
    }
  });
};
var zipLeft4 = /* @__PURE__ */ dual(2, (self, that) => map17(intersect5(self, that), (out) => out[0]));
var zipRight5 = /* @__PURE__ */ dual(2, (self, that) => map17(intersect5(self, that), (out) => out[1]));
var zipWith8 = /* @__PURE__ */ dual(3, (self, that, f) => map17(intersect5(self, that), ([out, out2]) => f(out, out2)));
var beginningOfSecond = (now2) => {
  const date3 = new Date(now2);
  return new Date(date3.getFullYear(), date3.getMonth(), date3.getDate(), date3.getHours(), date3.getMinutes(), date3.getSeconds(), 0).getTime();
};
var endOfSecond = (now2) => {
  const date3 = new Date(beginningOfSecond(now2));
  return date3.setSeconds(date3.getSeconds() + 1);
};
var nextSecond = (now2, second, initial) => {
  const date3 = new Date(now2);
  if (date3.getSeconds() === second && initial) {
    return now2;
  }
  if (date3.getSeconds() < second) {
    return date3.setSeconds(second);
  }
  const newDate = new Date(date3.setSeconds(second));
  return newDate.setTime(newDate.getTime() + 1e3 * 60);
};
var beginningOfMinute = (now2) => {
  const date3 = new Date(now2);
  return new Date(date3.getFullYear(), date3.getMonth(), date3.getDate(), date3.getHours(), date3.getMinutes(), 0, 0).getTime();
};
var endOfMinute = (now2) => {
  const date3 = new Date(beginningOfMinute(now2));
  return date3.setMinutes(date3.getMinutes() + 1);
};
var nextMinute = (now2, minute, initial) => {
  const date3 = new Date(now2);
  if (date3.getMinutes() === minute && initial) {
    return now2;
  }
  if (date3.getMinutes() < minute) {
    return date3.setMinutes(minute);
  }
  const newDate = new Date(date3.setMinutes(minute));
  return newDate.setTime(newDate.getTime() + 1e3 * 60 * 60);
};
var beginningOfHour = (now2) => {
  const date3 = new Date(now2);
  return new Date(date3.getFullYear(), date3.getMonth(), date3.getDate(), date3.getHours(), 0, 0, 0).getTime();
};
var endOfHour = (now2) => {
  const date3 = new Date(beginningOfHour(now2));
  return date3.setHours(date3.getHours() + 1);
};
var nextHour = (now2, hour, initial) => {
  const date3 = new Date(now2);
  if (date3.getHours() === hour && initial) {
    return now2;
  }
  if (date3.getHours() < hour) {
    return date3.setHours(hour);
  }
  const newDate = new Date(date3.setHours(hour));
  return newDate.setTime(newDate.getTime() + 1e3 * 60 * 60 * 24);
};
var beginningOfDay = (now2) => {
  const date3 = new Date(now2);
  return new Date(date3.getFullYear(), date3.getMonth(), date3.getDate(), 0, 0, 0, 0).getTime();
};
var endOfDay = (now2) => {
  const date3 = new Date(beginningOfDay(now2));
  return date3.setDate(date3.getDate() + 1);
};
var nextDay = (now2, dayOfWeek3, initial) => {
  const date3 = new Date(now2);
  if (date3.getDay() === dayOfWeek3 && initial) {
    return now2;
  }
  const nextDayOfWeek = (7 + dayOfWeek3 - date3.getDay()) % 7;
  return date3.setDate(date3.getDate() + (nextDayOfWeek === 0 ? 7 : nextDayOfWeek));
};
var nextDayOfMonth = (now2, day, initial) => {
  const date3 = new Date(now2);
  if (date3.getDate() === day && initial) {
    return now2;
  }
  if (date3.getDate() < day) {
    return date3.setDate(day);
  }
  return findNextMonth(now2, day, 1);
};
var findNextMonth = (now2, day, months) => {
  const d = new Date(now2);
  const tmp1 = new Date(d.setDate(day));
  const tmp2 = new Date(tmp1.setMonth(tmp1.getMonth() + months));
  if (tmp2.getDate() === day) {
    const d2 = new Date(now2);
    const tmp3 = new Date(d2.setDate(day));
    return tmp3.setMonth(tmp3.getMonth() + months);
  }
  return findNextMonth(now2, day, months + 1);
};
var ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");
var _a51;
_a51 = ScheduleDefectTypeId;
var ScheduleDefect = class {
  constructor(error2) {
    __publicField(this, "error");
    __publicField(this, _a51);
    this.error = error2;
    this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
  }
};
var isScheduleDefect = (u) => hasProperty(u, ScheduleDefectTypeId);
var scheduleDefectWrap = (self) => catchAll(self, (e) => die2(new ScheduleDefect(e)));
var scheduleDefectRefailCause = (cause3) => match2(find(cause3, (_) => isDieType(_) && isScheduleDefect(_.defect) ? some2(_.defect) : none2()), {
  onNone: () => cause3,
  onSome: (error2) => fail(error2.error)
});
var scheduleDefectRefail = (effect4) => catchAllCause(effect4, (cause3) => failCause(scheduleDefectRefailCause(cause3)));
var repeat_Effect = /* @__PURE__ */ dual(2, (self, schedule4) => repeatOrElse_Effect(self, schedule4, (e, _) => fail2(e)));
var repeat_combined = /* @__PURE__ */ dual(2, (self, options) => {
  if (isSchedule(options)) {
    return repeat_Effect(self, options);
  }
  const base = options.schedule ?? passthrough2(forever2);
  const withWhile = options.while ? whileInputEffect(base, (a) => {
    const applied = options.while(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (a) => {
    const applied = options.until(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options.times ? intersect5(withUntil, recurs(options.times)).pipe(map17((intersectionPair) => intersectionPair[0])) : withUntil;
  return scheduleDefectRefail(repeat_Effect(self, withTimes));
});
var repeatOrElse_Effect = /* @__PURE__ */ dual(3, (self, schedule4, orElse15) => flatMap9(driver(schedule4), (driver3) => matchEffect(self, {
  onFailure: (error2) => orElse15(error2, none2()),
  onSuccess: (value3) => repeatOrElseEffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get10(driver3.iterationMeta)), driver3, (error2, option5) => provideServiceEffect(orElse15(error2, option5), CurrentIterationMetadata, get10(driver3.iterationMeta)), value3)
})));
var repeatOrElseEffectLoop = (self, driver3, orElse15, value3) => matchEffect(driver3.next(value3), {
  onFailure: () => orDie(driver3.last),
  onSuccess: (b) => matchEffect(self, {
    onFailure: (error2) => orElse15(error2, some2(b)),
    onSuccess: (value4) => repeatOrElseEffectLoop(self, driver3, orElse15, value4)
  })
});
var retry_Effect = /* @__PURE__ */ dual(2, (self, policy) => retryOrElse_Effect(self, policy, (e, _) => fail2(e)));
var retry_combined = /* @__PURE__ */ dual(2, (self, options) => {
  if (isSchedule(options)) {
    return retry_Effect(self, options);
  }
  return scheduleDefectRefail(retry_Effect(self, fromRetryOptions(options)));
});
var fromRetryOptions = (options) => {
  const base = options.schedule ?? forever2;
  const withWhile = options.while ? whileInputEffect(base, (e) => {
    const applied = options.while(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (e) => {
    const applied = options.until(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  return options.times ? intersect5(withUntil, recurs(options.times)) : withUntil;
};
var retryOrElse_Effect = /* @__PURE__ */ dual(3, (self, policy, orElse15) => flatMap9(driver(policy), (driver3) => retryOrElse_EffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get10(driver3.iterationMeta)), driver3, (e, out) => provideServiceEffect(orElse15(e, out), CurrentIterationMetadata, get10(driver3.iterationMeta)))));
var retryOrElse_EffectLoop = (self, driver3, orElse15) => {
  return catchAll(self, (e) => matchEffect(driver3.next(e), {
    onFailure: () => pipe(driver3.last, orDie, flatMap9((out) => orElse15(e, out))),
    onSuccess: () => retryOrElse_EffectLoop(self, driver3, orElse15)
  }));
};
var schedule_Effect = /* @__PURE__ */ dual(2, (self, schedule4) => scheduleFrom_Effect(self, void 0, schedule4));
var scheduleFrom_Effect = /* @__PURE__ */ dual(3, (self, initial, schedule4) => flatMap9(driver(schedule4), (driver3) => scheduleFrom_EffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get10(driver3.iterationMeta)), initial, driver3)));
var scheduleFrom_EffectLoop = (self, initial, driver3) => matchEffect(driver3.next(initial), {
  onFailure: () => orDie(driver3.last),
  onSuccess: () => flatMap9(self, (a) => scheduleFrom_EffectLoop(self, a, driver3))
});
var count = /* @__PURE__ */ unfold2(0, (n) => n + 1);
var elapsed = /* @__PURE__ */ makeWithState(/* @__PURE__ */ none2(), (now2, _, state) => {
  switch (state._tag) {
    case "None": {
      return succeed([some2(now2), zero, continueWith2(after2(now2))]);
    }
    case "Some": {
      return succeed([some2(state.value), millis(now2 - state.value), continueWith2(after2(now2))]);
    }
  }
});
var forever2 = /* @__PURE__ */ unfold2(0, (n) => n + 1);
var once2 = /* @__PURE__ */ asVoid3(/* @__PURE__ */ recurs(1));
var stop = /* @__PURE__ */ asVoid3(/* @__PURE__ */ recurs(0));
var scheduleForked = /* @__PURE__ */ dual(2, (self, schedule4) => forkScoped(schedule_Effect(self, schedule4)));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/executionPlan.js
var withExecutionPlan = /* @__PURE__ */ dual(2, (effect4, plan) => suspend(() => {
  let i = 0;
  let result;
  return flatMap9(whileLoop({
    while: () => i < plan.steps.length && (result === void 0 || isLeft2(result)),
    body: () => {
      const step4 = plan.steps[i];
      let nextEffect = effect_provide(effect4, step4.provide);
      if (result) {
        let attempted = false;
        const wrapped = nextEffect;
        nextEffect = suspend(() => {
          if (attempted) return wrapped;
          attempted = true;
          return result;
        });
        nextEffect = scheduleDefectRefail(retry_Effect(nextEffect, scheduleFromStep(step4, false)));
      } else {
        const schedule4 = scheduleFromStep(step4, true);
        nextEffect = schedule4 ? scheduleDefectRefail(retry_Effect(nextEffect, schedule4)) : nextEffect;
      }
      return either2(nextEffect);
    },
    step: (either8) => {
      result = either8;
      i++;
    }
  }), () => result);
}));
var scheduleFromStep = (step4, first2) => {
  if (!first2) {
    return fromRetryOptions({
      schedule: step4.schedule ? step4.schedule : step4.attempts ? void 0 : once2,
      times: step4.attempts,
      while: step4.while
    });
  } else if (step4.attempts === 1 || !(step4.schedule || step4.attempts)) {
    return void 0;
  }
  return fromRetryOptions({
    schedule: step4.schedule,
    while: step4.while,
    times: step4.attempts ? step4.attempts - 1 : void 0
  });
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/MutableList.js
var TypeId17 = /* @__PURE__ */ Symbol.for("effect/MutableList");
var MutableListProto = {
  [TypeId17]: TypeId17,
  [Symbol.iterator]() {
    let done12 = false;
    let head8 = this.head;
    return {
      next() {
        if (done12) {
          return this.return();
        }
        if (head8 == null) {
          done12 = true;
          return this.return();
        }
        const value3 = head8.value;
        head8 = head8.next;
        return {
          done: done12,
          value: value3
        };
      },
      return(value3) {
        if (!done12) {
          done12 = true;
        }
        return {
          done: true,
          value: value3
        };
      }
    };
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeNode = (value3) => ({
  value: value3,
  removed: false,
  prev: void 0,
  next: void 0
});
var empty31 = () => {
  const list = Object.create(MutableListProto);
  list.head = void 0;
  list.tail = void 0;
  list._length = 0;
  return list;
};
var isEmpty8 = (self) => length(self) === 0;
var length = (self) => self._length;
var append3 = /* @__PURE__ */ dual(2, (self, value3) => {
  const node = makeNode(value3);
  if (self.head === void 0) {
    self.head = node;
  }
  if (self.tail === void 0) {
    self.tail = node;
  } else {
    self.tail.next = node;
    node.prev = self.tail;
    self.tail = node;
  }
  ;
  self._length += 1;
  return self;
});
var shift = (self) => {
  const head8 = self.head;
  if (head8 !== void 0) {
    remove9(self, head8);
    return head8.value;
  }
  return void 0;
};
var remove9 = (self, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== void 0 && node.next !== void 0) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== void 0) {
    self.tail = node.prev;
    node.prev.next = void 0;
  } else if (node.next !== void 0) {
    self.head = node.next;
    node.next.prev = void 0;
  } else {
    self.tail = void 0;
    self.head = void 0;
  }
  if (self._length > 0) {
    ;
    self._length -= 1;
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/MutableQueue.js
var TypeId18 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
var EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
var MutableQueueProto = {
  [TypeId18]: TypeId18,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make41 = (capacity7) => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = empty31();
  queue.capacity = capacity7;
  return queue;
};
var bounded = (capacity7) => make41(capacity7);
var unbounded = () => make41(void 0);
var length2 = (self) => length(self.queue);
var isEmpty9 = (self) => isEmpty8(self.queue);
var capacity = (self) => self.capacity === void 0 ? Infinity : self.capacity;
var offer = /* @__PURE__ */ dual(2, (self, value3) => {
  const queueLength = length(self.queue);
  if (self.capacity !== void 0 && queueLength === self.capacity) {
    return false;
  }
  append3(value3)(self.queue);
  return true;
});
var offerAll = /* @__PURE__ */ dual(2, (self, values5) => {
  const iterator = values5[Symbol.iterator]();
  let next4;
  let remainder2 = empty5();
  let offering = true;
  while (offering && (next4 = iterator.next()) && !next4.done) {
    offering = offer(next4.value)(self);
  }
  while (next4 != null && !next4.done) {
    remainder2 = prepend2(next4.value)(remainder2);
    next4 = iterator.next();
  }
  return reverse2(remainder2);
});
var poll4 = /* @__PURE__ */ dual(2, (self, def) => {
  if (isEmpty8(self.queue)) {
    return def;
  }
  return shift(self.queue);
});
var pollUpTo = /* @__PURE__ */ dual(2, (self, n) => {
  let result = empty5();
  let count4 = 0;
  while (count4 < n) {
    const element3 = poll4(EmptyMutableQueue)(self);
    if (element3 === EmptyMutableQueue) {
      break;
    }
    result = prepend2(element3)(result);
    count4 += 1;
  }
  return reverse2(result);
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/cache.js
var complete2 = (key, exit4, entryStats, timeToLiveMillis) => struct({
  _tag: "Complete",
  key,
  exit: exit4,
  entryStats,
  timeToLiveMillis
});
var pending2 = (key, deferred) => struct({
  _tag: "Pending",
  key,
  deferred
});
var refreshing = (deferred, complete3) => struct({
  _tag: "Refreshing",
  deferred,
  complete: complete3
});
var MapKeyTypeId = /* @__PURE__ */ Symbol.for("effect/Cache/MapKey");
var _a52;
var MapKeyImpl = class {
  constructor(current2) {
    __publicField(this, "current");
    __publicField(this, _a52, MapKeyTypeId);
    __publicField(this, "previous");
    __publicField(this, "next");
    this.current = current2;
  }
  [(_a52 = MapKeyTypeId, symbol)]() {
    return pipe(hash(this.current), combine(hash(this.previous)), combine(hash(this.next)), cached(this));
  }
  [symbol2](that) {
    if (this === that) {
      return true;
    }
    return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
  }
};
var makeMapKey = (current2) => new MapKeyImpl(current2);
var isMapKey = (u) => hasProperty(u, MapKeyTypeId);
var KeySetImpl = class {
  constructor() {
    __publicField(this, "head");
    __publicField(this, "tail");
  }
  add(key) {
    if (key !== this.tail) {
      if (this.tail === void 0) {
        this.head = key;
        this.tail = key;
      } else {
        const previous2 = key.previous;
        const next4 = key.next;
        if (next4 !== void 0) {
          key.next = void 0;
          if (previous2 !== void 0) {
            previous2.next = next4;
            next4.previous = previous2;
          } else {
            this.head = next4;
            this.head.previous = void 0;
          }
        }
        this.tail.next = key;
        key.previous = this.tail;
        this.tail = key;
      }
    }
  }
  remove() {
    const key = this.head;
    if (key !== void 0) {
      const next4 = key.next;
      if (next4 !== void 0) {
        key.next = void 0;
        this.head = next4;
        this.head.previous = void 0;
      } else {
        this.head = void 0;
        this.tail = void 0;
      }
    }
    return key;
  }
};
var makeKeySet = () => new KeySetImpl();
var makeCacheState = (map31, keys6, accesses, updating, hits, misses) => ({
  map: map31,
  keys: keys6,
  accesses,
  updating,
  hits,
  misses
});
var initialCacheState = () => makeCacheState(empty22(), makeKeySet(), unbounded(), make12(false), 0, 0);
var CacheSymbolKey = "effect/Cache";
var CacheTypeId = /* @__PURE__ */ Symbol.for(CacheSymbolKey);
var cacheVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Error: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var ConsumerCacheSymbolKey = "effect/ConsumerCache";
var ConsumerCacheTypeId = /* @__PURE__ */ Symbol.for(ConsumerCacheSymbolKey);
var consumerCacheVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Error: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var makeCacheStats = (options) => options;
var makeEntryStats = (loadedMillis) => ({
  loadedMillis
});
var _a53, _b16;
_b16 = CacheTypeId, _a53 = ConsumerCacheTypeId;
var CacheImpl = class {
  constructor(capacity7, context9, fiberId3, lookup, timeToLive) {
    __publicField(this, "capacity");
    __publicField(this, "context");
    __publicField(this, "fiberId");
    __publicField(this, "lookup");
    __publicField(this, "timeToLive");
    __publicField(this, _b16, cacheVariance);
    __publicField(this, _a53, consumerCacheVariance);
    __publicField(this, "cacheState");
    this.capacity = capacity7;
    this.context = context9;
    this.fiberId = fiberId3;
    this.lookup = lookup;
    this.timeToLive = timeToLive;
    this.cacheState = initialCacheState();
  }
  get(key) {
    return map10(this.getEither(key), merge3);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size6(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match2(get12(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value3) => this.resolveMapValue(value3)
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match2(get12(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value3) => this.resolveMapValue(value3, true)
    }));
  }
  contains(key) {
    return sync(() => has6(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const option5 = get12(this.cacheState.map, key);
      if (isSome2(option5)) {
        switch (option5.value._tag) {
          case "Complete": {
            const loaded = option5.value.entryStats.loadedMillis;
            return some2(makeEntryStats(loaded));
          }
          case "Pending": {
            return none2();
          }
          case "Refreshing": {
            const loaded = option5.value.complete.entryStats.loadedMillis;
            return some2(makeEntryStats(loaded));
          }
        }
      }
      return none2();
    });
  }
  getEither(key) {
    return suspend(() => {
      const k = key;
      let mapKey = void 0;
      let deferred = void 0;
      let value3 = getOrUndefined(get12(this.cacheState.map, k));
      if (value3 === void 0) {
        deferred = unsafeMake4(this.fiberId);
        mapKey = makeMapKey(k);
        if (has6(this.cacheState.map, k)) {
          value3 = getOrUndefined(get12(this.cacheState.map, k));
        } else {
          set6(this.cacheState.map, k, pending2(mapKey, deferred));
        }
      }
      if (value3 === void 0) {
        this.trackAccess(mapKey);
        this.trackMiss();
        return map10(this.lookupValueOf(key, deferred), right2);
      } else {
        return flatMap9(this.resolveMapValue(value3), match2({
          onNone: () => this.getEither(key),
          onSome: (value4) => succeed(left2(value4))
        }));
      }
    });
  }
  invalidate(key) {
    return sync(() => {
      remove7(this.cacheState.map, key);
    });
  }
  invalidateWhen(key, when5) {
    return sync(() => {
      const value3 = get12(this.cacheState.map, key);
      if (isSome2(value3) && value3.value._tag === "Complete") {
        if (value3.value.exit._tag === "Success") {
          if (when5(value3.value.exit.value)) {
            remove7(this.cacheState.map, key);
          }
        }
      }
    });
  }
  get invalidateAll() {
    return sync(() => {
      this.cacheState.map = empty22();
    });
  }
  refresh(key) {
    return clockWith3((clock3) => suspend(() => {
      const k = key;
      const deferred = unsafeMake4(this.fiberId);
      let value3 = getOrUndefined(get12(this.cacheState.map, k));
      if (value3 === void 0) {
        if (has6(this.cacheState.map, k)) {
          value3 = getOrUndefined(get12(this.cacheState.map, k));
        } else {
          set6(this.cacheState.map, k, pending2(makeMapKey(k), deferred));
        }
      }
      if (value3 === void 0) {
        return asVoid2(this.lookupValueOf(key, deferred));
      } else {
        switch (value3._tag) {
          case "Complete": {
            if (this.hasExpired(clock3, value3.timeToLiveMillis)) {
              const found = getOrUndefined(get12(this.cacheState.map, k));
              if (equals(found, value3)) {
                remove7(this.cacheState.map, k);
              }
              return asVoid2(this.get(key));
            }
            return pipe(this.lookupValueOf(key, deferred), when(() => {
              const current2 = getOrUndefined(get12(this.cacheState.map, k));
              if (equals(current2, value3)) {
                const mapValue = refreshing(deferred, value3);
                set6(this.cacheState.map, k, mapValue);
                return true;
              }
              return false;
            }), asVoid2);
          }
          case "Pending": {
            return _await(value3.deferred);
          }
          case "Refreshing": {
            return _await(value3.deferred);
          }
        }
      }
    }));
  }
  set(key, value3) {
    return clockWith3((clock3) => sync(() => {
      const now2 = clock3.unsafeCurrentTimeMillis();
      const k = key;
      const lookupResult = succeed4(value3);
      const mapValue = complete2(makeMapKey(k), lookupResult, makeEntryStats(now2), now2 + toMillis(decode(this.timeToLive(lookupResult))));
      set6(this.cacheState.map, k, mapValue);
    }));
  }
  get size() {
    return sync(() => {
      return size6(this.cacheState.map);
    });
  }
  get values() {
    return sync(() => {
      const values5 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values5.push(entry[1].exit.value);
        }
      }
      return values5;
    });
  }
  get entries() {
    return sync(() => {
      const values5 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values5.push([entry[0], entry[1].exit.value]);
        }
      }
      return values5;
    });
  }
  get keys() {
    return sync(() => {
      const keys6 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          keys6.push(entry[0]);
        }
      }
      return keys6;
    });
  }
  resolveMapValue(value3, ignorePending = false) {
    return clockWith3((clock3) => {
      switch (value3._tag) {
        case "Complete": {
          this.trackAccess(value3.key);
          if (this.hasExpired(clock3, value3.timeToLiveMillis)) {
            remove7(this.cacheState.map, value3.key.current);
            return succeed(none2());
          }
          this.trackHit();
          return map10(value3.exit, some2);
        }
        case "Pending": {
          this.trackAccess(value3.key);
          this.trackHit();
          if (ignorePending) {
            return succeed(none2());
          }
          return map10(_await(value3.deferred), some2);
        }
        case "Refreshing": {
          this.trackAccess(value3.complete.key);
          this.trackHit();
          if (this.hasExpired(clock3, value3.complete.timeToLiveMillis)) {
            if (ignorePending) {
              return succeed(none2());
            }
            return map10(_await(value3.deferred), some2);
          }
          return map10(value3.complete.exit, some2);
        }
      }
    });
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop3 = true;
      while (loop3) {
        const key2 = poll4(this.cacheState.accesses, EmptyMutableQueue);
        if (key2 === EmptyMutableQueue) {
          loop3 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size17 = size6(this.cacheState.map);
      loop3 = size17 > this.capacity;
      while (loop3) {
        const key2 = this.cacheState.keys.remove();
        if (key2 !== void 0) {
          if (has6(this.cacheState.map, key2.current)) {
            remove7(this.cacheState.map, key2.current);
            size17 = size17 - 1;
            loop3 = size17 > this.capacity;
          }
        } else {
          loop3 = false;
        }
      }
      set2(this.cacheState.updating, false);
    }
  }
  hasExpired(clock3, timeToLiveMillis) {
    return clock3.unsafeCurrentTimeMillis() > timeToLiveMillis;
  }
  lookupValueOf(input, deferred) {
    return clockWith3((clock3) => suspend(() => {
      const key = input;
      return pipe(this.lookup(input), provideContext(this.context), exit, flatMap9((exit4) => {
        const now2 = clock3.unsafeCurrentTimeMillis();
        const stats = makeEntryStats(now2);
        const value3 = complete2(makeMapKey(key), exit4, stats, now2 + toMillis(decode(this.timeToLive(exit4))));
        set6(this.cacheState.map, key, value3);
        return zipRight2(done2(deferred, exit4), exit4);
      }), onInterrupt(() => zipRight2(interrupt3(deferred), sync(() => {
        remove7(this.cacheState.map, key);
      }))));
    }));
  }
};
var make42 = (options) => {
  const timeToLive = decode(options.timeToLive);
  return makeWith({
    capacity: options.capacity,
    lookup: options.lookup,
    timeToLive: () => timeToLive
  });
};
var makeWith = (options) => map10(all5([context(), fiberId]), ([context9, fiberId3]) => new CacheImpl(options.capacity, context9, fiberId3, options.lookup, (exit4) => decode(options.timeToLive(exit4))));
var unsafeMakeWith = (capacity7, lookup, timeToLive) => new CacheImpl(capacity7, empty2(), none3, lookup, (exit4) => decode(timeToLive(exit4)));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/query.js
var currentCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map10(deferredMake(), (handle) => ({
  listeners: new Listeners(),
  handle
})), () => seconds(60))));
var currentCacheEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
var fromRequest = (request2, dataSource) => flatMap9(isEffect(dataSource) ? dataSource : succeed(dataSource), (ds) => fiberIdWith((id3) => {
  const proxy = new Proxy(request2, {});
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      const cached4 = fiberRefGetWith(currentCache, (cache) => flatMap9(cache.getEither(proxy), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            if (orNew.left.listeners.interrupted) {
              return flatMap9(cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached4);
            }
            orNew.left.listeners.increment();
            return uninterruptibleMask((restore) => flatMap9(exit(blocked(empty17, restore(deferredAwait(orNew.left.handle)))), (exit4) => {
              orNew.left.listeners.decrement();
              return exit4;
            }));
          }
          case "Right": {
            orNew.right.listeners.increment();
            return uninterruptibleMask((restore) => flatMap9(exit(blocked(single(ds, makeEntry({
              request: proxy,
              result: orNew.right.handle,
              listeners: orNew.right.listeners,
              ownerId: id3,
              state: {
                completed: false
              }
            })), restore(deferredAwait(orNew.right.handle)))), () => {
              orNew.right.listeners.decrement();
              return deferredAwait(orNew.right.handle);
            }));
          }
        }
      }));
      return cached4;
    }
    const listeners = new Listeners();
    listeners.increment();
    return flatMap9(deferredMake(), (ref) => ensuring(blocked(single(ds, makeEntry({
      request: proxy,
      result: ref,
      listeners,
      ownerId: id3,
      state: {
        completed: false
      }
    })), deferredAwait(ref)), sync(() => listeners.decrement())));
  });
}));
var cacheRequest = (request2, result) => {
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      return fiberRefGetWith(currentCache, (cache) => flatMap9(cache.getEither(request2), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            return void_2;
          }
          case "Right": {
            return deferredComplete(orNew.right.handle, result);
          }
        }
      }));
    }
    return void_2;
  });
};
var withRequestCaching = /* @__PURE__ */ dual(2, (self, strategy) => fiberRefLocally(self, currentCacheEnabled, strategy));
var withRequestCache = /* @__PURE__ */ dual(
  2,
  // @ts-expect-error
  (self, cache) => fiberRefLocally(self, currentCache, cache)
);

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Request.js
var isRequest2 = isRequest;
var Class5 = Class3;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Effect.js
var EffectTypeId3 = EffectTypeId2;
var isEffect2 = isEffect;
var cachedWithTTL = cached2;
var cachedInvalidateWithTTL2 = cachedInvalidateWithTTL;
var cached3 = memoize;
var cachedFunction2 = cachedFunction;
var once3 = once;
var all7 = all5;
var allWith2 = allWith;
var allSuccesses2 = allSuccesses;
var dropUntil2 = dropUntil;
var dropWhile3 = dropWhile2;
var takeUntil2 = takeUntil;
var takeWhile3 = takeWhile2;
var every9 = every7;
var exists3 = exists2;
var filter9 = filter7;
var filterMap8 = filterMap7;
var findFirst8 = findFirst6;
var forEach10 = forEach9;
var head4 = head3;
var mergeAll5 = mergeAll3;
var partition5 = partition4;
var reduce12 = reduce9;
var reduceWhile2 = reduceWhile;
var reduceRight4 = reduceRight3;
var reduceEffect3 = reduceEffect;
var replicate2 = replicate;
var replicateEffect2 = replicateEffect;
var validateAll2 = validateAll;
var validateFirst2 = validateFirst;
var async2 = async_;
var asyncEffect2 = asyncEffect;
var custom2 = custom;
var withFiberRuntime2 = withFiberRuntime;
var fail10 = fail2;
var failSync3 = failSync;
var failCause9 = failCause;
var failCauseSync3 = failCauseSync;
var die6 = die2;
var dieMessage2 = dieMessage;
var dieSync3 = dieSync;
var gen3 = gen2;
var never4 = never;
var none9 = none6;
var promise2 = promise;
var succeed10 = succeed;
var succeedNone2 = succeedNone;
var succeedSome2 = succeedSome;
var suspend4 = suspend;
var sync5 = sync;
var _void = void_2;
var yieldNow4 = yieldNow;
var _catch2 = _catch;
var catchAll3 = catchAll;
var catchAllCause3 = catchAllCause;
var catchAllDefect2 = catchAllDefect;
var catchIf2 = catchIf;
var catchSome2 = catchSome;
var catchSomeCause2 = catchSomeCause;
var catchSomeDefect2 = catchSomeDefect;
var catchTag2 = catchTag;
var catchTags2 = catchTags;
var cause2 = cause;
var eventually2 = eventually;
var ignore2 = ignore;
var ignoreLogged2 = ignoreLogged;
var parallelErrors2 = parallelErrors;
var sandbox2 = sandbox;
var retry2 = retry_combined;
var withExecutionPlan2 = withExecutionPlan;
var retryOrElse = retryOrElse_Effect;
var try_3 = try_2;
var tryMap2 = tryMap;
var tryMapPromise2 = tryMapPromise;
var tryPromise2 = tryPromise;
var unsandbox2 = unsandbox;
var allowInterrupt2 = allowInterrupt;
var checkInterruptible2 = checkInterruptible;
var disconnect2 = disconnect;
var interrupt7 = interrupt2;
var interruptWith2 = interruptWith;
var interruptible4 = interruptible2;
var interruptibleMask2 = interruptibleMask;
var onInterrupt2 = onInterrupt;
var uninterruptible2 = uninterruptible;
var uninterruptibleMask3 = uninterruptibleMask;
var liftPredicate3 = liftPredicate2;
var as6 = as2;
var asSome2 = asSome;
var asSomeError2 = asSomeError;
var asVoid4 = asVoid2;
var flip2 = flip;
var flipWith2 = flipWith;
var map18 = map10;
var mapAccum4 = mapAccum3;
var mapBoth5 = mapBoth2;
var mapError3 = mapError;
var mapErrorCause2 = mapErrorCause;
var merge7 = merge5;
var negate2 = negate;
var acquireRelease2 = acquireRelease;
var acquireReleaseInterruptible2 = acquireReleaseInterruptible;
var acquireUseRelease2 = acquireUseRelease;
var addFinalizer3 = addFinalizer;
var ensuring3 = ensuring;
var onError2 = onError;
var onExit3 = onExit;
var parallelFinalizers2 = parallelFinalizers;
var sequentialFinalizers2 = sequentialFinalizers;
var finalizersMask2 = finalizersMask;
var scope3 = scope;
var scopeWith2 = scopeWith;
var scopedWith2 = scopedWith;
var scoped3 = scopedEffect;
var using2 = using;
var withEarlyRelease2 = withEarlyRelease;
var awaitAllChildren2 = awaitAllChildren;
var daemonChildren2 = daemonChildren;
var descriptor2 = descriptor;
var descriptorWith2 = descriptorWith;
var diffFiberRefs2 = diffFiberRefs;
var ensuringChild2 = ensuringChild;
var ensuringChildren2 = ensuringChildren;
var fiberId2 = fiberId;
var fiberIdWith2 = fiberIdWith;
var fork3 = fork;
var forkDaemon2 = forkDaemon;
var forkAll2 = forkAll;
var forkIn2 = forkIn;
var forkScoped2 = forkScoped;
var forkWithErrorHandler2 = forkWithErrorHandler;
var fromFiber2 = fromFiber;
var fromFiberEffect2 = fromFiberEffect;
var supervised2 = supervised;
var transplant2 = transplant;
var withConcurrency2 = withConcurrency;
var withScheduler2 = withScheduler;
var withSchedulingPriority2 = withSchedulingPriority;
var withMaxOpsBeforeYield2 = withMaxOpsBeforeYield;
var clock2 = clock;
var clockWith4 = clockWith3;
var withClockScoped2 = withClockScoped;
var withClock2 = withClock;
var console3 = console2;
var consoleWith2 = consoleWith;
var withConsoleScoped2 = withConsoleScoped;
var withConsole2 = withConsole;
var delay2 = delay;
var sleep4 = sleep3;
var timed2 = timed;
var timedWith2 = timedWith;
var timeout2 = timeout;
var timeoutOption2 = timeoutOption;
var timeoutFail2 = timeoutFail;
var timeoutFailCause2 = timeoutFailCause;
var timeoutTo2 = timeoutTo;
var configProviderWith2 = configProviderWith;
var withConfigProvider2 = withConfigProvider;
var withConfigProviderScoped2 = withConfigProviderScoped;
var context3 = context;
var contextWith2 = contextWith;
var contextWithEffect2 = contextWithEffect;
var mapInputContext3 = mapInputContext;
var provide2 = effect_provide;
var provideService3 = provideService;
var provideServiceEffect2 = provideServiceEffect;
var serviceFunction2 = serviceFunction;
var serviceFunctionEffect2 = serviceFunctionEffect;
var serviceFunctions2 = serviceFunctions;
var serviceConstants2 = serviceConstants;
var serviceMembers2 = serviceMembers;
var serviceOption2 = serviceOption;
var serviceOptional2 = serviceOptional;
var updateService2 = updateService;
var Do3 = Do2;
var bind4 = bind3;
var bindAll2 = bindAll;
var bindTo4 = bindTo3;
var let_4 = let_3;
var option2 = option;
var either4 = either2;
var exit3 = exit;
var intoDeferred2 = intoDeferred;
var if_2 = if_;
var filterOrDie2 = filterOrDie;
var filterOrDieMessage2 = filterOrDieMessage;
var filterOrElse2 = filterOrElse;
var filterOrFail2 = filterOrFail;
var filterEffectOrElse2 = filterEffectOrElse;
var filterEffectOrFail2 = filterEffectOrFail;
var unless2 = unless;
var unlessEffect2 = unlessEffect;
var when2 = when;
var whenEffect2 = whenEffect;
var whenFiberRef2 = whenFiberRef;
var whenRef2 = whenRef;
var flatMap12 = flatMap9;
var andThen6 = andThen3;
var flatten9 = flatten6;
var race2 = race;
var raceAll2 = raceAll;
var raceFirst2 = raceFirst;
var raceWith2 = raceWith;
var summarized2 = summarized;
var tap4 = tap2;
var tapBoth2 = tapBoth;
var tapDefect2 = tapDefect;
var tapError3 = tapError;
var tapErrorTag2 = tapErrorTag;
var tapErrorCause3 = tapErrorCause;
var forever3 = forever;
var iterate2 = iterate;
var loop2 = loop;
var repeat = repeat_combined;
var repeatN2 = repeatN;
var repeatOrElse = repeatOrElse_Effect;
var schedule = schedule_Effect;
var scheduleForked2 = scheduleForked;
var scheduleFrom = scheduleFrom_Effect;
var whileLoop3 = whileLoop;
var getFiberRefs = fiberRefs2;
var inheritFiberRefs2 = inheritFiberRefs;
var locally = fiberRefLocally;
var locallyWith = fiberRefLocallyWith;
var locallyScoped = fiberRefLocallyScoped;
var locallyScopedWith = fiberRefLocallyScopedWith;
var patchFiberRefs2 = patchFiberRefs;
var setFiberRefs2 = setFiberRefs;
var updateFiberRefs2 = updateFiberRefs;
var isFailure4 = isFailure;
var isSuccess3 = isSuccess;
var match14 = match8;
var matchCause4 = matchCause;
var matchCauseEffect3 = matchCauseEffect;
var matchEffect2 = matchEffect;
var log2 = log;
var logWithLevel2 = (level, ...message) => logWithLevel(level)(...message);
var logTrace2 = logTrace;
var logDebug2 = logDebug;
var logInfo2 = logInfo;
var logWarning2 = logWarning;
var logError2 = logError;
var logFatal2 = logFatal;
var withLogSpan2 = withLogSpan;
var annotateLogs3 = annotateLogs;
var annotateLogsScoped2 = annotateLogsScoped;
var logAnnotations2 = logAnnotations;
var withUnhandledErrorLogLevel2 = withUnhandledErrorLogLevel;
var whenLogLevel2 = whenLogLevel;
var orDie3 = orDie;
var orDieWith2 = orDieWith;
var orElse6 = orElse2;
var orElseFail2 = orElseFail;
var orElseSucceed2 = orElseSucceed;
var firstSuccessOf2 = firstSuccessOf;
var random3 = random2;
var randomWith2 = randomWith;
var withRandom2 = withRandom;
var withRandomScoped2 = withRandomScoped;
var runtime4 = runtime3;
var getRuntimeFlags = runtimeFlags;
var patchRuntimeFlags = updateRuntimeFlags;
var withRuntimeFlagsPatch = withRuntimeFlags;
var withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
var tagMetrics2 = tagMetrics;
var labelMetrics2 = labelMetrics;
var tagMetricsScoped2 = tagMetricsScoped;
var labelMetricsScoped2 = labelMetricsScoped;
var metricLabels2 = metricLabels;
var withMetric2 = withMetric;
var unsafeMakeSemaphore2 = unsafeMakeSemaphore;
var makeSemaphore2 = makeSemaphore;
var unsafeMakeLatch2 = unsafeMakeLatch;
var makeLatch2 = makeLatch;
var runFork2 = unsafeForkEffect;
var runCallback = unsafeRunEffect;
var runPromise = unsafeRunPromiseEffect;
var runPromiseExit = unsafeRunPromiseExitEffect;
var runSync = unsafeRunSyncEffect;
var runSyncExit = unsafeRunSyncExitEffect;
var validate2 = validate;
var validateWith2 = validateWith;
var zip7 = zipOptions;
var zipLeft5 = zipLeftOptions;
var zipRight6 = zipRightOptions;
var zipWith9 = zipWithOptions;
var ap2 = /* @__PURE__ */ dual(2, (self, that) => zipWith9(self, that, (f, a) => f(a)));
var blocked2 = blocked;
var runRequestBlock2 = runRequestBlock;
var step3 = step2;
var request = /* @__PURE__ */ dual((args2) => isRequest2(args2[0]), fromRequest);
var cacheRequestResult = cacheRequest;
var withRequestBatching2 = withRequestBatching;
var withRequestCaching2 = withRequestCaching;
var withRequestCache2 = withRequestCache;
var tracer2 = tracer;
var tracerWith4 = tracerWith;
var withTracer2 = withTracer;
var withTracerScoped2 = withTracerScoped;
var withTracerEnabled2 = withTracerEnabled;
var withTracerTiming2 = withTracerTiming;
var annotateSpans3 = annotateSpans;
var annotateCurrentSpan2 = annotateCurrentSpan;
var currentSpan2 = currentSpan;
var currentParentSpan2 = currentParentSpan;
var spanAnnotations2 = spanAnnotations;
var spanLinks2 = spanLinks;
var linkSpans2 = linkSpans;
var linkSpanCurrent2 = linkSpanCurrent;
var makeSpan2 = makeSpan;
var makeSpanScoped2 = makeSpanScoped;
var useSpan2 = useSpan;
var withSpan3 = withSpan;
var functionWithSpan2 = functionWithSpan;
var withSpanScoped2 = withSpanScoped;
var withParentSpan3 = withParentSpan;
var fromNullable3 = fromNullable2;
var optionFromOptional2 = optionFromOptional;
var transposeOption = (self) => {
  return isNone(self) ? succeedNone2 : map18(self.value, some);
};
var transposeMapOption = /* @__PURE__ */ dual(2, (self, f) => isNone(self) ? succeedNone2 : map18(f(self.value), some));
var makeTagProxy = (TagClass) => {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(TagClass, {
    get(target, prop, receiver) {
      if (prop in target) {
        return Reflect.get(target, prop, receiver);
      }
      if (cache.has(prop)) {
        return cache.get(prop);
      }
      const fn2 = (...args2) => andThen3(target, (s) => {
        if (typeof s[prop] === "function") {
          cache.set(prop, (...args3) => andThen3(target, (s2) => s2[prop](...args3)));
          return s[prop](...args2);
        }
        cache.set(prop, andThen3(target, (s2) => s2[prop]));
        return s[prop];
      });
      const cn = andThen3(target, (s) => s[prop]);
      Object.assign(fn2, cn);
      Object.setPrototypeOf(fn2, Object.getPrototypeOf(cn));
      cache.set(prop, fn2);
      return fn2;
    }
  });
};
var Tag3 = (id3) => () => {
  const limit2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit2;
  function TagClass() {
  }
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id3;
  Object.defineProperty(TagClass, "use", {
    get() {
      return (body) => andThen3(this, body);
    }
  });
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return makeTagProxy(TagClass);
};
var Service = function() {
  return function() {
    const [id3, maker] = arguments;
    const proxy = "accessors" in maker ? maker["accessors"] : false;
    const limit2 = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error();
    Error.stackTraceLimit = limit2;
    let patchState = "unchecked";
    const TagClass = function(service3) {
      if (patchState === "unchecked") {
        const proto14 = Object.getPrototypeOf(service3);
        if (proto14 === Object.prototype || proto14 === null) {
          patchState = "plain";
        } else {
          const selfProto = Object.getPrototypeOf(this);
          Object.setPrototypeOf(selfProto, proto14);
          patchState = "patched";
        }
      }
      if (patchState === "plain") {
        Object.assign(this, service3);
      } else if (patchState === "patched") {
        Object.setPrototypeOf(service3, Object.getPrototypeOf(this));
        return service3;
      }
    };
    TagClass.prototype._tag = id3;
    Object.defineProperty(TagClass, "make", {
      get() {
        return (service3) => new this(service3);
      }
    });
    Object.defineProperty(TagClass, "use", {
      get() {
        return (body) => andThen3(this, body);
      }
    });
    TagClass.key = id3;
    Object.assign(TagClass, TagProto);
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
    const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
    let layerCache;
    let isFunction3 = false;
    if ("effect" in maker) {
      isFunction3 = typeof maker.effect === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return function() {
              return fromEffect4(TagClass, map18(maker.effect.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ?? (layerCache = fromEffect4(TagClass, map18(maker.effect, (_) => new this(_))));
        }
      });
    } else if ("scoped" in maker) {
      isFunction3 = typeof maker.scoped === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return function() {
              return scoped2(TagClass, map18(maker.scoped.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ?? (layerCache = scoped2(TagClass, map18(maker.scoped, (_) => new this(_))));
        }
      });
    } else if ("sync" in maker) {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ?? (layerCache = sync3(TagClass, () => new this(maker.sync())));
        }
      });
    } else {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ?? (layerCache = succeed7(TagClass, new this(maker.succeed)));
        }
      });
    }
    if (hasDeps) {
      let layerWithDepsCache;
      Object.defineProperty(TagClass, "Default", {
        get() {
          if (isFunction3) {
            return function() {
              return provide(this.DefaultWithoutDependencies.apply(null, arguments), maker.dependencies);
            };
          }
          return layerWithDepsCache ?? (layerWithDepsCache = provide(this.DefaultWithoutDependencies, maker.dependencies));
        }
      });
    }
    return proxy === true ? makeTagProxy(TagClass) : TagClass;
  };
};
var fn = function(nameOrBody, ...pipeables) {
  const limit2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const errorDef = new Error();
  Error.stackTraceLimit = limit2;
  if (typeof nameOrBody !== "string") {
    return defineLength(nameOrBody.length, function(...args2) {
      const limit3 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error();
      Error.stackTraceLimit = limit3;
      return fnApply({
        self: this,
        body: nameOrBody,
        args: args2,
        pipeables,
        spanName: "<anonymous>",
        spanOptions: {
          context: DisablePropagation.context(true)
        },
        errorDef,
        errorCall
      });
    });
  }
  const name = nameOrBody;
  const options = pipeables[0];
  return (body, ...pipeables2) => defineLength(body.length, {
    [name](...args2) {
      const limit3 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error();
      Error.stackTraceLimit = limit3;
      return fnApply({
        self: this,
        body,
        args: args2,
        pipeables: pipeables2,
        spanName: name,
        spanOptions: options,
        errorDef,
        errorCall
      });
    }
  }[name]);
};
function defineLength(length5, fn2) {
  return Object.defineProperty(fn2, "length", {
    value: length5,
    configurable: true
  });
}
function fnApply(options) {
  let effect4;
  let fnError = void 0;
  if (isGeneratorFunction(options.body)) {
    effect4 = fromIterator(() => options.body.apply(options.self, options.args));
  } else {
    try {
      effect4 = options.body.apply(options.self, options.args);
    } catch (error2) {
      fnError = error2;
      effect4 = die6(error2);
    }
  }
  if (options.pipeables.length > 0) {
    try {
      for (const x of options.pipeables) {
        effect4 = x(effect4, ...options.args);
      }
    } catch (error2) {
      effect4 = fnError ? failCause9(sequential(die(fnError), die(error2))) : die6(error2);
    }
  }
  let cache = false;
  const captureStackTrace = () => {
    if (cache !== false) {
      return cache;
    }
    if (options.errorCall.stack) {
      const stackDef = options.errorDef.stack.trim().split("\n");
      const stackCall = options.errorCall.stack.trim().split("\n");
      let endStackDef = stackDef.slice(2).join("\n").trim();
      if (!endStackDef.includes(`(`)) {
        endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
      }
      let endStackCall = stackCall.slice(2).join("\n").trim();
      if (!endStackCall.includes(`(`)) {
        endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
      }
      cache = `${endStackDef}
${endStackCall}`;
      return cache;
    }
  };
  const opts = options.spanOptions && "captureStackTrace" in options.spanOptions ? options.spanOptions : {
    captureStackTrace,
    ...options.spanOptions
  };
  return withSpan3(effect4, options.spanName, opts);
}
var fnUntraced2 = fnUntraced;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Layer.js
var Layer_exports = {};
__export(Layer_exports, {
  CurrentMemoMap: () => CurrentMemoMap2,
  LayerTypeId: () => LayerTypeId2,
  MemoMapTypeId: () => MemoMapTypeId2,
  annotateLogs: () => annotateLogs4,
  annotateSpans: () => annotateSpans4,
  build: () => build2,
  buildWithMemoMap: () => buildWithMemoMap2,
  buildWithScope: () => buildWithScope2,
  catchAll: () => catchAll4,
  catchAllCause: () => catchAllCause4,
  context: () => context4,
  die: () => die7,
  dieSync: () => dieSync4,
  discard: () => discard2,
  effect: () => effect,
  effectContext: () => effectContext,
  effectDiscard: () => effectDiscard,
  empty: () => empty32,
  extendScope: () => extendScope2,
  fail: () => fail11,
  failCause: () => failCause10,
  failCauseSync: () => failCauseSync4,
  failSync: () => failSync4,
  fiberRefLocallyScopedWith: () => fiberRefLocallyScopedWith3,
  flatMap: () => flatMap13,
  flatten: () => flatten10,
  fresh: () => fresh2,
  function: () => fromFunction3,
  isFresh: () => isFresh2,
  isLayer: () => isLayer2,
  launch: () => launch2,
  locally: () => locally2,
  locallyEffect: () => locallyEffect2,
  locallyScoped: () => locallyScoped2,
  locallyWith: () => locallyWith2,
  makeMemoMap: () => makeMemoMap2,
  map: () => map19,
  mapError: () => mapError4,
  match: () => match15,
  matchCause: () => matchCause5,
  memoize: () => memoize3,
  merge: () => merge8,
  mergeAll: () => mergeAll6,
  orDie: () => orDie4,
  orElse: () => orElse7,
  parentSpan: () => parentSpan2,
  passthrough: () => passthrough3,
  project: () => project2,
  provide: () => provide3,
  provideMerge: () => provideMerge2,
  retry: () => retry3,
  scope: () => scope4,
  scoped: () => scoped4,
  scopedContext: () => scopedContext2,
  scopedDiscard: () => scopedDiscard2,
  service: () => service2,
  setClock: () => setClock,
  setConfigProvider: () => setConfigProvider2,
  setRandom: () => setRandom,
  setRequestBatching: () => setRequestBatching,
  setRequestCache: () => setRequestCache,
  setRequestCaching: () => setRequestCaching,
  setScheduler: () => setScheduler,
  setTracer: () => setTracer2,
  setTracerEnabled: () => setTracerEnabled,
  setTracerTiming: () => setTracerTiming,
  setUnhandledErrorLogLevel: () => setUnhandledErrorLogLevel,
  span: () => span3,
  succeed: () => succeed11,
  succeedContext: () => succeedContext2,
  suspend: () => suspend5,
  sync: () => sync6,
  syncContext: () => syncContext2,
  tap: () => tap5,
  tapError: () => tapError4,
  tapErrorCause: () => tapErrorCause4,
  toRuntime: () => toRuntime2,
  toRuntimeWithMemoMap: () => toRuntimeWithMemoMap2,
  unwrapEffect: () => unwrapEffect2,
  unwrapScoped: () => unwrapScoped2,
  updateService: () => updateService3,
  withParentSpan: () => withParentSpan4,
  withSpan: () => withSpan4,
  zipWith: () => zipWith10
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/layer/circular.js
var setConfigProvider = (configProvider) => scopedDiscard(withConfigProviderScoped(configProvider));
var parentSpan = (span4) => succeedContext(make2(spanTag, span4));
var span2 = (name, options) => {
  options = addSpanStackTrace(options);
  return scoped2(spanTag, options?.onEnd ? tap2(makeSpanScoped(name, options), (span4) => addFinalizer((exit4) => options.onEnd(span4, exit4))) : makeSpanScoped(name, options));
};
var setTracer = (tracer3) => scopedDiscard(withTracerScoped(tracer3));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Layer.js
var LayerTypeId2 = LayerTypeId;
var MemoMapTypeId2 = MemoMapTypeId;
var CurrentMemoMap2 = CurrentMemoMap;
var isLayer2 = isLayer;
var isFresh2 = isFresh;
var annotateLogs4 = annotateLogs2;
var annotateSpans4 = annotateSpans2;
var build2 = build;
var buildWithScope2 = buildWithScope;
var catchAll4 = catchAll2;
var catchAllCause4 = catchAllCause2;
var context4 = context2;
var die7 = die5;
var dieSync4 = dieSync2;
var discard2 = discard;
var effect = fromEffect4;
var effectDiscard = fromEffectDiscard;
var effectContext = fromEffectContext;
var empty32 = empty30;
var extendScope2 = extendScope;
var fail11 = fail8;
var failSync4 = failSync2;
var failCause10 = failCause7;
var failCauseSync4 = failCauseSync2;
var flatMap13 = flatMap11;
var flatten10 = flatten8;
var fresh2 = fresh;
var fromFunction3 = fromFunction;
var launch2 = launch;
var map19 = map16;
var mapError4 = mapError2;
var match15 = match12;
var matchCause5 = matchCause3;
var memoize3 = memoize2;
var merge8 = merge6;
var mergeAll6 = mergeAll4;
var orDie4 = orDie2;
var orElse7 = orElse5;
var passthrough3 = passthrough;
var project2 = project;
var locallyEffect2 = locallyEffect;
var locally2 = fiberRefLocally2;
var locallyWith2 = fiberRefLocallyWith2;
var locallyScoped2 = fiberRefLocallyScoped2;
var fiberRefLocallyScopedWith3 = fiberRefLocallyScopedWith2;
var retry3 = retry;
var scope4 = scope2;
var scoped4 = scoped2;
var scopedDiscard2 = scopedDiscard;
var scopedContext2 = scopedContext;
var service2 = service;
var succeed11 = succeed7;
var succeedContext2 = succeedContext;
var suspend5 = suspend3;
var sync6 = sync3;
var syncContext2 = syncContext;
var tap5 = tap3;
var tapError4 = tapError2;
var tapErrorCause4 = tapErrorCause2;
var toRuntime2 = toRuntime;
var toRuntimeWithMemoMap2 = toRuntimeWithMemoMap;
var provide3 = provide;
var provideMerge2 = provideMerge;
var zipWith10 = zipWith7;
var unwrapEffect2 = unwrapEffect;
var unwrapScoped2 = unwrapScoped;
var setClock = (clock3) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(clockTag, clock3)));
var setConfigProvider2 = setConfigProvider;
var parentSpan2 = parentSpan;
var setRandom = (random4) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(randomTag, random4)));
var setRequestBatching = (requestBatching) => scopedDiscard2(fiberRefLocallyScoped(currentRequestBatching, requestBatching));
var setRequestCaching = (requestCaching) => scopedDiscard2(fiberRefLocallyScoped(currentCacheEnabled, requestCaching));
var setRequestCache = (cache) => scopedDiscard2(isEffect(cache) ? flatMap9(cache, (x) => fiberRefLocallyScoped(currentCache, x)) : fiberRefLocallyScoped(currentCache, cache));
var setScheduler = (scheduler2) => scopedDiscard2(fiberRefLocallyScoped(currentScheduler, scheduler2));
var span3 = span2;
var setTracer2 = setTracer;
var setTracerEnabled = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerEnabled, enabled2));
var setTracerTiming = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerTimingEnabled, enabled2));
var setUnhandledErrorLogLevel = (level) => scopedDiscard2(fiberRefLocallyScoped(currentUnhandledErrorLogLevel, level));
var withSpan4 = withSpan2;
var withParentSpan4 = withParentSpan2;
var makeMemoMap2 = makeMemoMap;
var buildWithMemoMap2 = buildWithMemoMap;
var updateService3 = /* @__PURE__ */ dual(3, (layer4, tag3, f) => provide3(layer4, map19(context4(), (c) => add2(c, tag3, f(unsafeGet2(c, tag3))))));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Stream.js
var Stream_exports = {};
__export(Stream_exports, {
  DefaultChunkSize: () => DefaultChunkSize2,
  Do: () => Do5,
  StreamTypeId: () => StreamTypeId3,
  accumulate: () => accumulate2,
  accumulateChunks: () => accumulateChunks2,
  acquireRelease: () => acquireRelease4,
  aggregate: () => aggregate2,
  aggregateWithin: () => aggregateWithin2,
  aggregateWithinEither: () => aggregateWithinEither2,
  as: () => as11,
  async: () => _async2,
  asyncEffect: () => asyncEffect4,
  asyncPush: () => asyncPush2,
  asyncScoped: () => asyncScoped2,
  bind: () => bind6,
  bindEffect: () => bindEffect2,
  bindTo: () => bindTo6,
  branchAfter: () => branchAfter2,
  broadcast: () => broadcast2,
  broadcastDynamic: () => broadcastDynamic2,
  broadcastedQueues: () => broadcastedQueues2,
  broadcastedQueuesDynamic: () => broadcastedQueuesDynamic2,
  buffer: () => buffer2,
  bufferChunks: () => bufferChunks2,
  catchAll: () => catchAll8,
  catchAllCause: () => catchAllCause7,
  catchSome: () => catchSome4,
  catchSomeCause: () => catchSomeCause4,
  catchTag: () => catchTag4,
  catchTags: () => catchTags4,
  changes: () => changes2,
  changesWith: () => changesWith2,
  changesWithEffect: () => changesWithEffect2,
  chunks: () => chunks2,
  chunksWith: () => chunksWith2,
  combine: () => combine10,
  combineChunks: () => combineChunks2,
  concat: () => concat3,
  concatAll: () => concatAll3,
  context: () => context6,
  contextWith: () => contextWith4,
  contextWithEffect: () => contextWithEffect4,
  contextWithStream: () => contextWithStream2,
  cross: () => cross2,
  crossLeft: () => crossLeft2,
  crossRight: () => crossRight2,
  crossWith: () => crossWith2,
  debounce: () => debounce2,
  decodeText: () => decodeText2,
  die: () => die11,
  dieMessage: () => dieMessage5,
  dieSync: () => dieSync7,
  distributedWith: () => distributedWith2,
  distributedWithDynamic: () => distributedWithDynamic2,
  drain: () => drain4,
  drainFork: () => drainFork2,
  drop: () => drop4,
  dropRight: () => dropRight3,
  dropUntil: () => dropUntil4,
  dropUntilEffect: () => dropUntilEffect2,
  dropWhile: () => dropWhile5,
  dropWhileEffect: () => dropWhileEffect2,
  either: () => either7,
  empty: () => empty34,
  encodeText: () => encodeText2,
  ensuring: () => ensuring8,
  ensuringWith: () => ensuringWith3,
  execute: () => execute2,
  fail: () => fail17,
  failCause: () => failCause15,
  failCauseSync: () => failCauseSync7,
  failSync: () => failSync8,
  filter: () => filter11,
  filterEffect: () => filterEffect2,
  filterMap: () => filterMap10,
  filterMapEffect: () => filterMapEffect2,
  filterMapWhile: () => filterMapWhile4,
  filterMapWhileEffect: () => filterMapWhileEffect2,
  finalizer: () => finalizer2,
  find: () => find3,
  findEffect: () => findEffect2,
  flatMap: () => flatMap18,
  flatten: () => flatten14,
  flattenChunks: () => flattenChunks2,
  flattenEffect: () => flattenEffect2,
  flattenExitOption: () => flattenExitOption2,
  flattenIterables: () => flattenIterables2,
  flattenTake: () => flattenTake2,
  forever: () => forever6,
  fromAsyncIterable: () => fromAsyncIterable2,
  fromChannel: () => fromChannel3,
  fromChunk: () => fromChunk2,
  fromChunkPubSub: () => fromChunkPubSub2,
  fromChunkQueue: () => fromChunkQueue2,
  fromChunks: () => fromChunks2,
  fromEffect: () => fromEffect9,
  fromEffectOption: () => fromEffectOption2,
  fromEventListener: () => fromEventListener2,
  fromIterable: () => fromIterable15,
  fromIterableEffect: () => fromIterableEffect2,
  fromIteratorSucceed: () => fromIteratorSucceed2,
  fromPubSub: () => fromPubSub2,
  fromPull: () => fromPull3,
  fromQueue: () => fromQueue3,
  fromReadableStream: () => fromReadableStream2,
  fromReadableStreamByob: () => fromReadableStreamByob2,
  fromSchedule: () => fromSchedule2,
  fromTPubSub: () => fromTPubSub2,
  fromTQueue: () => fromTQueue2,
  groupAdjacentBy: () => groupAdjacentBy2,
  groupBy: () => groupBy2,
  groupByKey: () => groupByKey2,
  grouped: () => grouped2,
  groupedWithin: () => groupedWithin2,
  haltAfter: () => haltAfter2,
  haltWhen: () => haltWhen2,
  haltWhenDeferred: () => haltWhenDeferred2,
  identity: () => identity4,
  interleave: () => interleave2,
  interleaveWith: () => interleaveWith2,
  interruptAfter: () => interruptAfter2,
  interruptWhen: () => interruptWhen3,
  interruptWhenDeferred: () => interruptWhenDeferred3,
  intersperse: () => intersperse2,
  intersperseAffixes: () => intersperseAffixes2,
  iterate: () => iterate4,
  let: () => let_6,
  make: () => make55,
  map: () => map25,
  mapAccum: () => mapAccum6,
  mapAccumEffect: () => mapAccumEffect2,
  mapBoth: () => mapBoth8,
  mapChunks: () => mapChunks2,
  mapChunksEffect: () => mapChunksEffect2,
  mapConcat: () => mapConcat2,
  mapConcatChunk: () => mapConcatChunk2,
  mapConcatChunkEffect: () => mapConcatChunkEffect2,
  mapConcatEffect: () => mapConcatEffect2,
  mapEffect: () => mapEffect6,
  mapError: () => mapError7,
  mapErrorCause: () => mapErrorCause5,
  mapInputContext: () => mapInputContext7,
  merge: () => merge10,
  mergeAll: () => mergeAll9,
  mergeEither: () => mergeEither2,
  mergeLeft: () => mergeLeft2,
  mergeRight: () => mergeRight2,
  mergeWith: () => mergeWith4,
  mergeWithTag: () => mergeWithTag2,
  mkString: () => mkString3,
  never: () => never6,
  onDone: () => onDone2,
  onEnd: () => onEnd2,
  onError: () => onError4,
  onStart: () => onStart2,
  orDie: () => orDie6,
  orDieWith: () => orDieWith5,
  orElse: () => orElse10,
  orElseEither: () => orElseEither6,
  orElseFail: () => orElseFail4,
  orElseIfEmpty: () => orElseIfEmpty2,
  orElseIfEmptyChunk: () => orElseIfEmptyChunk2,
  orElseIfEmptyStream: () => orElseIfEmptyStream2,
  orElseSucceed: () => orElseSucceed4,
  paginate: () => paginate2,
  paginateChunk: () => paginateChunk2,
  paginateChunkEffect: () => paginateChunkEffect2,
  paginateEffect: () => paginateEffect2,
  partition: () => partition7,
  partitionEither: () => partitionEither2,
  peel: () => peel2,
  pipeThrough: () => pipeThrough2,
  pipeThroughChannel: () => pipeThroughChannel2,
  pipeThroughChannelOrFail: () => pipeThroughChannelOrFail2,
  prepend: () => prepend5,
  provideContext: () => provideContext7,
  provideLayer: () => provideLayer2,
  provideService: () => provideService7,
  provideServiceEffect: () => provideServiceEffect4,
  provideServiceStream: () => provideServiceStream2,
  provideSomeLayer: () => provideSomeLayer3,
  race: () => race4,
  raceAll: () => raceAll4,
  range: () => range3,
  rechunk: () => rechunk2,
  refineOrDie: () => refineOrDie2,
  refineOrDieWith: () => refineOrDieWith2,
  repeat: () => repeat3,
  repeatEffect: () => repeatEffect2,
  repeatEffectChunk: () => repeatEffectChunk2,
  repeatEffectChunkOption: () => repeatEffectChunkOption2,
  repeatEffectOption: () => repeatEffectOption2,
  repeatEffectWithSchedule: () => repeatEffectWithSchedule2,
  repeatEither: () => repeatEither2,
  repeatElements: () => repeatElements2,
  repeatElementsWith: () => repeatElementsWith2,
  repeatValue: () => repeatValue2,
  repeatWith: () => repeatWith2,
  retry: () => retry7,
  run: () => run5,
  runCollect: () => runCollect2,
  runCount: () => runCount2,
  runDrain: () => runDrain3,
  runFold: () => runFold2,
  runFoldEffect: () => runFoldEffect2,
  runFoldScoped: () => runFoldScoped2,
  runFoldScopedEffect: () => runFoldScopedEffect2,
  runFoldWhile: () => runFoldWhile2,
  runFoldWhileEffect: () => runFoldWhileEffect2,
  runFoldWhileScoped: () => runFoldWhileScoped2,
  runFoldWhileScopedEffect: () => runFoldWhileScopedEffect2,
  runForEach: () => runForEach2,
  runForEachChunk: () => runForEachChunk2,
  runForEachChunkScoped: () => runForEachChunkScoped2,
  runForEachScoped: () => runForEachScoped2,
  runForEachWhile: () => runForEachWhile2,
  runForEachWhileScoped: () => runForEachWhileScoped2,
  runHead: () => runHead2,
  runIntoPubSub: () => runIntoPubSub2,
  runIntoPubSubScoped: () => runIntoPubSubScoped2,
  runIntoQueue: () => runIntoQueue2,
  runIntoQueueElementsScoped: () => runIntoQueueElementsScoped2,
  runIntoQueueScoped: () => runIntoQueueScoped2,
  runLast: () => runLast2,
  runScoped: () => runScoped3,
  runSum: () => runSum2,
  scan: () => scan2,
  scanEffect: () => scanEffect2,
  scanReduce: () => scanReduce2,
  scanReduceEffect: () => scanReduceEffect2,
  schedule: () => schedule3,
  scheduleWith: () => scheduleWith2,
  scoped: () => scoped7,
  scopedWith: () => scopedWith5,
  share: () => share2,
  sliding: () => sliding8,
  slidingSize: () => slidingSize2,
  some: () => some8,
  someOrElse: () => someOrElse2,
  someOrFail: () => someOrFail2,
  split: () => split4,
  splitLines: () => splitLines3,
  splitOnChunk: () => splitOnChunk2,
  succeed: () => succeed17,
  suspend: () => suspend11,
  sync: () => sync11,
  take: () => take8,
  takeRight: () => takeRight3,
  takeUntil: () => takeUntil4,
  takeUntilEffect: () => takeUntilEffect2,
  takeWhile: () => takeWhile5,
  tap: () => tap8,
  tapBoth: () => tapBoth4,
  tapError: () => tapError6,
  tapErrorCause: () => tapErrorCause6,
  tapSink: () => tapSink2,
  throttle: () => throttle2,
  throttleEffect: () => throttleEffect2,
  tick: () => tick2,
  timeout: () => timeout4,
  timeoutFail: () => timeoutFail4,
  timeoutFailCause: () => timeoutFailCause4,
  timeoutTo: () => timeoutTo4,
  toAsyncIterable: () => toAsyncIterable2,
  toAsyncIterableEffect: () => toAsyncIterableEffect2,
  toAsyncIterableRuntime: () => toAsyncIterableRuntime2,
  toChannel: () => toChannel3,
  toPubSub: () => toPubSub3,
  toPull: () => toPull3,
  toQueue: () => toQueue3,
  toQueueOfElements: () => toQueueOfElements2,
  toReadableStream: () => toReadableStream2,
  toReadableStreamEffect: () => toReadableStreamEffect2,
  toReadableStreamRuntime: () => toReadableStreamRuntime2,
  transduce: () => transduce2,
  unfold: () => unfold5,
  unfoldChunk: () => unfoldChunk2,
  unfoldChunkEffect: () => unfoldChunkEffect2,
  unfoldEffect: () => unfoldEffect2,
  unwrap: () => unwrap3,
  unwrapScoped: () => unwrapScoped5,
  unwrapScopedWith: () => unwrapScopedWith4,
  updateService: () => updateService5,
  void: () => void_10,
  when: () => when4,
  whenCase: () => whenCase2,
  whenCaseEffect: () => whenCaseEffect2,
  whenEffect: () => whenEffect4,
  withExecutionPlan: () => withExecutionPlan4,
  withSpan: () => withSpan7,
  zip: () => zip10,
  zipAll: () => zipAll2,
  zipAllLeft: () => zipAllLeft2,
  zipAllRight: () => zipAllRight2,
  zipAllSortedByKey: () => zipAllSortedByKey2,
  zipAllSortedByKeyLeft: () => zipAllSortedByKeyLeft2,
  zipAllSortedByKeyRight: () => zipAllSortedByKeyRight2,
  zipAllSortedByKeyWith: () => zipAllSortedByKeyWith2,
  zipAllWith: () => zipAllWith2,
  zipFlatten: () => zipFlatten2,
  zipLatest: () => zipLatest2,
  zipLatestAll: () => zipLatestAll2,
  zipLatestWith: () => zipLatestWith2,
  zipLeft: () => zipLeft9,
  zipRight: () => zipRight12,
  zipWith: () => zipWith15,
  zipWithChunks: () => zipWithChunks2,
  zipWithIndex: () => zipWithIndex2,
  zipWithNext: () => zipWithNext2,
  zipWithPrevious: () => zipWithPrevious2,
  zipWithPreviousAndNext: () => zipWithPreviousAndNext2
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Queue.js
var Queue_exports = {};
__export(Queue_exports, {
  BackingQueueTypeId: () => BackingQueueTypeId2,
  DequeueTypeId: () => DequeueTypeId2,
  EnqueueTypeId: () => EnqueueTypeId2,
  QueueStrategyTypeId: () => QueueStrategyTypeId2,
  awaitShutdown: () => awaitShutdown2,
  backPressureStrategy: () => backPressureStrategy2,
  bounded: () => bounded3,
  capacity: () => capacity3,
  dropping: () => dropping2,
  droppingStrategy: () => droppingStrategy2,
  isDequeue: () => isDequeue2,
  isEmpty: () => isEmpty11,
  isEnqueue: () => isEnqueue2,
  isFull: () => isFull2,
  isQueue: () => isQueue2,
  isShutdown: () => isShutdown2,
  make: () => make44,
  offer: () => offer3,
  offerAll: () => offerAll3,
  poll: () => poll6,
  shutdown: () => shutdown2,
  size: () => size13,
  sliding: () => sliding2,
  slidingStrategy: () => slidingStrategy2,
  take: () => take3,
  takeAll: () => takeAll2,
  takeBetween: () => takeBetween2,
  takeN: () => takeN2,
  takeUpTo: () => takeUpTo2,
  unbounded: () => unbounded3,
  unsafeOffer: () => unsafeOffer2
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/queue.js
var EnqueueSymbolKey = "effect/QueueEnqueue";
var EnqueueTypeId = /* @__PURE__ */ Symbol.for(EnqueueSymbolKey);
var DequeueSymbolKey = "effect/QueueDequeue";
var DequeueTypeId = /* @__PURE__ */ Symbol.for(DequeueSymbolKey);
var QueueStrategySymbolKey = "effect/QueueStrategy";
var QueueStrategyTypeId = /* @__PURE__ */ Symbol.for(QueueStrategySymbolKey);
var BackingQueueSymbolKey = "effect/BackingQueue";
var BackingQueueTypeId = /* @__PURE__ */ Symbol.for(BackingQueueSymbolKey);
var queueStrategyVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var backingQueueVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var enqueueVariance = {
  /* c8 ignore next */
  _In: (_) => _
};
var dequeueVariance = {
  /* c8 ignore next */
  _Out: (_) => _
};
var _a54, _b17, _c3;
var QueueImpl = class extends (_c3 = Class2, _b17 = EnqueueTypeId, _a54 = DequeueTypeId, _c3) {
  constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
    super();
    __publicField(this, "queue");
    __publicField(this, "takers");
    __publicField(this, "shutdownHook");
    __publicField(this, "shutdownFlag");
    __publicField(this, "strategy");
    __publicField(this, _b17, enqueueVariance);
    __publicField(this, _a54, dequeueVariance);
    this.queue = queue;
    this.takers = takers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
  capacity() {
    return this.queue.capacity();
  }
  get size() {
    return suspend(() => catchAll(this.unsafeSize(), () => interrupt2));
  }
  unsafeSize() {
    if (get6(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.queue.length() - length2(this.takers) + this.strategy.surplusSize());
  }
  get isEmpty() {
    return map10(this.size, (size17) => size17 <= 0);
  }
  get isFull() {
    return map10(this.size, (size17) => size17 >= this.capacity());
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set2(true));
      return pipe(forEachConcurrentDiscard(unsafePollAll(this.takers), (d) => deferredInterruptWith(d, state.id()), false, false), zipRight2(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
    }));
  }
  get isShutdown() {
    return sync(() => get6(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  isActive() {
    return !get6(this.shutdownFlag);
  }
  unsafeOffer(value3) {
    if (get6(this.shutdownFlag)) {
      return false;
    }
    let noRemaining;
    if (this.queue.length() === 0) {
      const taker = pipe(this.takers, poll4(EmptyMutableQueue));
      if (taker !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, value3);
        noRemaining = true;
      } else {
        noRemaining = false;
      }
    } else {
      noRemaining = false;
    }
    if (noRemaining) {
      return true;
    }
    const succeeded = this.queue.offer(value3);
    unsafeCompleteTakers(this.strategy, this.queue, this.takers);
    return succeeded;
  }
  offer(value3) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      let noRemaining;
      if (this.queue.length() === 0) {
        const taker = pipe(this.takers, poll4(EmptyMutableQueue));
        if (taker !== EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, value3);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return succeed(true);
      }
      const succeeded = this.queue.offer(value3);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded ? succeed(true) : this.strategy.handleSurplus([value3], this.queue, this.takers, this.shutdownFlag);
    });
  }
  offerAll(iterable) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const values5 = fromIterable2(iterable);
      const pTakers = this.queue.length() === 0 ? fromIterable2(unsafePollN(this.takers, values5.length)) : empty4;
      const [forTakers, remaining] = pipe(values5, splitAt(pTakers.length));
      for (let i = 0; i < pTakers.length; i++) {
        const taker = pTakers[i];
        const item = forTakers[i];
        unsafeCompleteDeferred(taker, item);
      }
      if (remaining.length === 0) {
        return succeed(true);
      }
      const surplus = this.queue.offerAll(remaining);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return isEmpty(surplus) ? succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
    });
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const item = this.queue.poll(EmptyMutableQueue);
      if (item !== EmptyMutableQueue) {
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return succeed(item);
      } else {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.takers, offer(deferred));
          unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => {
          return sync(() => unsafeRemove(this.takers, deferred));
        }));
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      return get6(this.shutdownFlag) ? interrupt2 : sync(() => {
        const values5 = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return fromIterable3(values5);
      });
    });
  }
  takeUpTo(max7) {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => {
      const values5 = this.queue.pollUpTo(max7);
      this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
      return fromIterable3(values5);
    }));
  }
  takeBetween(min5, max7) {
    return suspend(() => takeRemainderLoop(this, min5, max7, empty5()));
  }
};
var takeRemainderLoop = (self, min5, max7, acc) => {
  if (max7 < min5) {
    return succeed(acc);
  }
  return pipe(takeUpTo(self, max7), flatMap9((bs) => {
    const remaining = min5 - bs.length;
    if (remaining === 1) {
      return pipe(take2(self), map10((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(take2(self), flatMap9((b) => takeRemainderLoop(self, remaining - 1, max7 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
};
var isQueue = (u) => isEnqueue(u) && isDequeue(u);
var isEnqueue = (u) => hasProperty(u, EnqueueTypeId);
var isDequeue = (u) => hasProperty(u, DequeueTypeId);
var bounded2 = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap9((queue) => make43(backingQueueFromMutableQueue(queue), backPressureStrategy())));
var dropping = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap9((queue) => make43(backingQueueFromMutableQueue(queue), droppingStrategy())));
var sliding = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap9((queue) => make43(backingQueueFromMutableQueue(queue), slidingStrategy())));
var unbounded2 = () => pipe(sync(() => unbounded()), flatMap9((queue) => make43(backingQueueFromMutableQueue(queue), droppingStrategy())));
var unsafeMake11 = (queue, takers, shutdownHook, shutdownFlag, strategy) => {
  return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
};
var make43 = (queue, strategy) => pipe(deferredMake(), map10((deferred) => unsafeMake11(queue, unbounded(), deferred, make12(false), strategy)));
var _a55;
_a55 = BackingQueueTypeId;
var BackingQueueFromMutableQueue = class {
  constructor(mutable5) {
    __publicField(this, "mutable");
    __publicField(this, _a55, backingQueueVariance);
    this.mutable = mutable5;
  }
  poll(def) {
    return poll4(this.mutable, def);
  }
  pollUpTo(limit2) {
    return pollUpTo(this.mutable, limit2);
  }
  offerAll(elements) {
    return offerAll(this.mutable, elements);
  }
  offer(element3) {
    return offer(this.mutable, element3);
  }
  capacity() {
    return capacity(this.mutable);
  }
  length() {
    return length2(this.mutable);
  }
};
var backingQueueFromMutableQueue = (mutable5) => new BackingQueueFromMutableQueue(mutable5);
var capacity2 = (self) => self.capacity();
var size12 = (self) => self.size;
var isFull = (self) => self.isFull;
var isEmpty10 = (self) => self.isEmpty;
var isShutdown = (self) => self.isShutdown;
var awaitShutdown = (self) => self.awaitShutdown;
var shutdown = (self) => self.shutdown;
var offer2 = /* @__PURE__ */ dual(2, (self, value3) => self.offer(value3));
var unsafeOffer = /* @__PURE__ */ dual(2, (self, value3) => self.unsafeOffer(value3));
var offerAll2 = /* @__PURE__ */ dual(2, (self, iterable) => self.offerAll(iterable));
var poll5 = (self) => map10(self.takeUpTo(1), head2);
var take2 = (self) => self.take;
var takeAll = (self) => self.takeAll;
var takeUpTo = /* @__PURE__ */ dual(2, (self, max7) => self.takeUpTo(max7));
var takeBetween = /* @__PURE__ */ dual(3, (self, min5, max7) => self.takeBetween(min5, max7));
var takeN = /* @__PURE__ */ dual(2, (self, n) => self.takeBetween(n, n));
var backPressureStrategy = () => new BackPressureStrategy();
var droppingStrategy = () => new DroppingStrategy();
var slidingStrategy = () => new SlidingStrategy();
var _a56;
_a56 = QueueStrategyTypeId;
var BackPressureStrategy = class {
  constructor() {
    __publicField(this, _a56, queueStrategyVariance);
    __publicField(this, "putters", /* @__PURE__ */ unbounded());
  }
  surplusSize() {
    return length2(this.putters);
  }
  onCompleteTakersWithEmptyQueue(takers) {
    while (!isEmpty9(this.putters) && !isEmpty9(takers)) {
      const taker = poll4(takers, void 0);
      const putter = poll4(this.putters, void 0);
      if (putter[2]) {
        unsafeCompleteDeferred(putter[1], true);
      }
      unsafeCompleteDeferred(taker, putter[0]);
    }
  }
  get shutdown() {
    return pipe(fiberId, flatMap9((fiberId3) => pipe(sync(() => unsafePollAll(this.putters)), flatMap9((putters) => forEachConcurrentDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred, fiberId3), asVoid2) : void_2, false, false)))));
  }
  handleSurplus(iterable, queue, takers, isShutdown7) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(iterable, deferred);
        this.unsafeOnQueueEmptySpace(queue, takers);
        unsafeCompleteTakers(this, queue, takers);
        return get6(isShutdown7) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnQueueEmptySpace(queue, takers) {
    let keepPolling = true;
    while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {
      const putter = pipe(this.putters, poll4(EmptyMutableQueue));
      if (putter === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const offered = queue.offer(putter[0]);
        if (offered && putter[2]) {
          unsafeCompleteDeferred(putter[1], true);
        } else if (!offered) {
          unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), prepend2(putter)));
        }
        unsafeCompleteTakers(this, queue, takers);
      }
    }
  }
  unsafeOffer(iterable, deferred) {
    const stuff = fromIterable2(iterable);
    for (let i = 0; i < stuff.length; i++) {
      const value3 = stuff[i];
      if (i === stuff.length - 1) {
        pipe(this.putters, offer([value3, deferred, true]));
      } else {
        pipe(this.putters, offer([value3, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), filter3(([, _]) => _ !== deferred)));
  }
};
var _a57;
_a57 = QueueStrategyTypeId;
var DroppingStrategy = class {
  constructor() {
    __publicField(this, _a57, queueStrategyVariance);
  }
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_2;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(_iterable, _queue, _takers, _isShutdown) {
    return succeed(false);
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
};
var _a58;
_a58 = QueueStrategyTypeId;
var SlidingStrategy = class {
  constructor() {
    __publicField(this, _a58, queueStrategyVariance);
  }
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_2;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(iterable, queue, takers, _isShutdown) {
    return sync(() => {
      this.unsafeOffer(queue, iterable);
      unsafeCompleteTakers(this, queue, takers);
      return true;
    });
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
  unsafeOffer(queue, iterable) {
    const iterator = iterable[Symbol.iterator]();
    let next4;
    let offering = true;
    while (!(next4 = iterator.next()).done && offering) {
      if (queue.capacity() === 0) {
        return;
      }
      queue.poll(EmptyMutableQueue);
      offering = queue.offer(next4.value);
    }
  }
};
var unsafeCompleteDeferred = (deferred, a) => {
  return deferredUnsafeDone(deferred, succeed(a));
};
var unsafeOfferAll = (queue, as13) => {
  return pipe(queue, offerAll(as13));
};
var unsafePollAll = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollN = (queue, max7) => {
  return pipe(queue, pollUpTo(max7));
};
var unsafeRemove = (queue, a) => {
  unsafeOfferAll(queue, pipe(unsafePollAll(queue), filter3((b) => a !== b)));
};
var unsafeCompleteTakers = (strategy, queue, takers) => {
  let keepPolling = true;
  while (keepPolling && queue.length() !== 0) {
    const taker = pipe(takers, poll4(EmptyMutableQueue));
    if (taker !== EmptyMutableQueue) {
      const element3 = queue.poll(EmptyMutableQueue);
      if (element3 !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, element3);
        strategy.unsafeOnQueueEmptySpace(queue, takers);
      } else {
        unsafeOfferAll(takers, pipe(unsafePollAll(takers), prepend2(taker)));
      }
      keepPolling = true;
    } else {
      keepPolling = false;
    }
  }
  if (keepPolling && queue.length() === 0 && !isEmpty9(takers)) {
    strategy.onCompleteTakersWithEmptyQueue(takers);
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Queue.js
var EnqueueTypeId2 = EnqueueTypeId;
var DequeueTypeId2 = DequeueTypeId;
var QueueStrategyTypeId2 = QueueStrategyTypeId;
var BackingQueueTypeId2 = BackingQueueTypeId;
var isQueue2 = isQueue;
var isDequeue2 = isDequeue;
var isEnqueue2 = isEnqueue;
var backPressureStrategy2 = backPressureStrategy;
var droppingStrategy2 = droppingStrategy;
var slidingStrategy2 = slidingStrategy;
var make44 = make43;
var bounded3 = bounded2;
var dropping2 = dropping;
var sliding2 = sliding;
var unbounded3 = unbounded2;
var capacity3 = capacity2;
var size13 = size12;
var isEmpty11 = isEmpty10;
var isFull2 = isFull;
var isShutdown2 = isShutdown;
var awaitShutdown2 = awaitShutdown;
var shutdown2 = shutdown;
var offer3 = offer2;
var unsafeOffer2 = unsafeOffer;
var offerAll3 = offerAll2;
var poll6 = poll5;
var take3 = take2;
var takeAll2 = takeAll;
var takeUpTo2 = takeUpTo;
var takeBetween2 = takeBetween;
var takeN2 = takeN;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/FiberRef.js
var get13 = fiberRefGet;
var getWith = fiberRefGetWith;
var currentContext2 = currentContext;
var currentSchedulingPriority2 = currentSchedulingPriority;
var currentScheduler2 = currentScheduler;
var currentTracerTimingEnabled2 = currentTracerTimingEnabled;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/pubsub.js
var AbsentValue = /* @__PURE__ */ Symbol.for("effect/PubSub/AbsentValue");
var addSubscribers = (subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    subscribers.set(subscription, /* @__PURE__ */ new Set());
  }
  const set10 = subscribers.get(subscription);
  set10.add(pollers);
};
var removeSubscribers = (subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    return;
  }
  const set10 = subscribers.get(subscription);
  set10.delete(pollers);
  if (set10.size === 0) {
    subscribers.delete(subscription);
  }
};
var bounded4 = (capacity7) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity7);
  return makePubSub(pubsub, new BackPressureStrategy2());
});
var dropping3 = (capacity7) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity7);
  return makePubSub(pubsub, new DroppingStrategy2());
});
var sliding3 = (capacity7) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity7);
  return makePubSub(pubsub, new SlidingStrategy2());
});
var unbounded4 = (options) => suspend(() => {
  const pubsub = makeUnboundedPubSub(options);
  return makePubSub(pubsub, new DroppingStrategy2());
});
var shutdown3 = (self) => self.shutdown;
var subscribe = (self) => self.subscribe;
var makeBoundedPubSub = (capacity7) => {
  const options = typeof capacity7 === "number" ? {
    capacity: capacity7
  } : capacity7;
  ensureCapacity(options.capacity);
  const replayBuffer = options.replay && options.replay > 0 ? new ReplayBuffer(Math.ceil(options.replay)) : void 0;
  if (options.capacity === 1) {
    return new BoundedPubSubSingle(replayBuffer);
  } else if (nextPow2(options.capacity) === options.capacity) {
    return new BoundedPubSubPow2(options.capacity, replayBuffer);
  } else {
    return new BoundedPubSubArb(options.capacity, replayBuffer);
  }
};
var makeUnboundedPubSub = (options) => new UnboundedPubSub(options?.replay ? new ReplayBuffer(options.replay) : void 0);
var makeSubscription = (pubsub, subscribers, strategy) => map10(deferredMake(), (deferred) => unsafeMakeSubscription(pubsub, subscribers, pubsub.subscribe(), unbounded(), deferred, make12(false), strategy));
var unsafeMakeSubscription = (pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) => new SubscriptionImpl(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, pubsub.replayWindow());
var BoundedPubSubArb = class {
  constructor(capacity7, replayBuffer) {
    __publicField(this, "capacity");
    __publicField(this, "replayBuffer");
    __publicField(this, "array");
    __publicField(this, "publisherIndex", 0);
    __publicField(this, "subscribers");
    __publicField(this, "subscriberCount", 0);
    __publicField(this, "subscribersIndex", 0);
    this.capacity = capacity7;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity7
    });
    this.subscribers = Array.from({
      length: capacity7
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value3) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex % this.capacity;
      this.array[index] = value3;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value3);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty5();
    }
    const chunk4 = fromIterable3(elements);
    const n = chunk4.length;
    const size17 = this.publisherIndex - this.subscribersIndex;
    const available = this.capacity - size17;
    const forPubSub = Math.min(n, available);
    if (forPubSub === 0) {
      return chunk4;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const a = unsafeGet4(chunk4, iteratorIndex++);
      const index = this.publisherIndex % this.capacity;
      this.array[index] = a;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(a);
      }
    }
    return drop2(chunk4, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex % this.capacity;
      this.array[index] = AbsentValue;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubArbSubscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubArbSubscription = class {
  constructor(self, subscriberIndex, unsubscribed) {
    __publicField(this, "self");
    __publicField(this, "subscriberIndex");
    __publicField(this, "unsubscribed");
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex % this.self.capacity;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty5();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size17 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size17);
    if (toPoll <= 0) {
      return empty5();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex % this.self.capacity;
      const a = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(a);
      this.subscriberIndex += 1;
    }
    return fromIterable3(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex % this.self.capacity;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
};
var BoundedPubSubPow2 = class {
  constructor(capacity7, replayBuffer) {
    __publicField(this, "capacity");
    __publicField(this, "replayBuffer");
    __publicField(this, "array");
    __publicField(this, "mask");
    __publicField(this, "publisherIndex", 0);
    __publicField(this, "subscribers");
    __publicField(this, "subscriberCount", 0);
    __publicField(this, "subscribersIndex", 0);
    this.capacity = capacity7;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity7
    });
    this.mask = capacity7 - 1;
    this.subscribers = Array.from({
      length: capacity7
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value3) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex & this.mask;
      this.array[index] = value3;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value3);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty5();
    }
    const chunk4 = fromIterable3(elements);
    const n = chunk4.length;
    const size17 = this.publisherIndex - this.subscribersIndex;
    const available = this.capacity - size17;
    const forPubSub = Math.min(n, available);
    if (forPubSub === 0) {
      return chunk4;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const elem = unsafeGet4(chunk4, iteratorIndex++);
      const index = this.publisherIndex & this.mask;
      this.array[index] = elem;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(elem);
      }
    }
    return drop2(chunk4, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex & this.mask;
      this.array[index] = AbsentValue;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubPow2Subscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubPow2Subscription = class {
  constructor(self, subscriberIndex, unsubscribed) {
    __publicField(this, "self");
    __publicField(this, "subscriberIndex");
    __publicField(this, "unsubscribed");
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty5();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size17 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size17);
    if (toPoll <= 0) {
      return empty5();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(elem);
      this.subscriberIndex += 1;
    }
    return fromIterable3(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex & this.self.mask;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
};
var BoundedPubSubSingle = class {
  constructor(replayBuffer) {
    __publicField(this, "replayBuffer");
    __publicField(this, "publisherIndex", 0);
    __publicField(this, "subscriberCount", 0);
    __publicField(this, "subscribers", 0);
    __publicField(this, "value", AbsentValue);
    __publicField(this, "capacity", 1);
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  isEmpty() {
    return this.subscribers === 0;
  }
  isFull() {
    return !this.isEmpty();
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  publish(value3) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      this.value = value3;
      this.subscribers = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value3);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty5();
    }
    const chunk4 = fromIterable3(elements);
    if (isEmpty(chunk4)) {
      return chunk4;
    }
    if (this.publish(unsafeHead(chunk4))) {
      return drop2(chunk4, 1);
    } else {
      return chunk4;
    }
  }
  slide() {
    if (this.isFull()) {
      this.subscribers = 0;
      this.value = AbsentValue;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubSingleSubscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubSingleSubscription = class {
  constructor(self, subscriberIndex, unsubscribed) {
    __publicField(this, "self");
    __publicField(this, "subscriberIndex");
    __publicField(this, "unsubscribed");
    this.self = self;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.subscribers === 0 || this.subscriberIndex === this.self.publisherIndex;
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  poll(default_) {
    if (this.isEmpty()) {
      return default_;
    }
    const elem = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return elem;
  }
  pollUpTo(n) {
    if (this.isEmpty() || n < 1) {
      return empty5();
    }
    const a = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return of2(a);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      if (this.subscriberIndex !== this.self.publisherIndex) {
        this.self.subscribers -= 1;
        if (this.self.subscribers === 0) {
          this.self.value = AbsentValue;
        }
      }
    }
  }
};
var UnboundedPubSub = class {
  constructor(replayBuffer) {
    __publicField(this, "replayBuffer");
    __publicField(this, "publisherHead", {
      value: AbsentValue,
      subscribers: 0,
      next: null
    });
    __publicField(this, "publisherTail", this.publisherHead);
    __publicField(this, "publisherIndex", 0);
    __publicField(this, "subscribersIndex", 0);
    __publicField(this, "capacity", Number.MAX_SAFE_INTEGER);
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherHead === this.publisherTail;
  }
  isFull() {
    return false;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value3) {
    const subscribers = this.publisherTail.subscribers;
    if (subscribers !== 0) {
      this.publisherTail.next = {
        value: value3,
        subscribers,
        next: null
      };
      this.publisherTail = this.publisherTail.next;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value3);
    }
    return true;
  }
  publishAll(elements) {
    if (this.publisherTail.subscribers !== 0) {
      for (const a of elements) {
        this.publish(a);
      }
    } else if (this.replayBuffer) {
      this.replayBuffer.offerAll(elements);
    }
    return empty5();
  }
  slide() {
    if (this.publisherHead !== this.publisherTail) {
      this.publisherHead = this.publisherHead.next;
      this.publisherHead.value = AbsentValue;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.publisherTail.subscribers += 1;
    return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
  }
};
var UnboundedPubSubSubscription = class {
  constructor(self, subscriberHead, subscriberIndex, unsubscribed) {
    __publicField(this, "self");
    __publicField(this, "subscriberHead");
    __publicField(this, "subscriberIndex");
    __publicField(this, "unsubscribed");
    this.self = self;
    this.subscriberHead = subscriberHead;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    if (this.unsubscribed) {
      return true;
    }
    let empty37 = true;
    let loop3 = true;
    while (loop3) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop3 = false;
      } else {
        if (this.subscriberHead.next.value !== AbsentValue) {
          empty37 = false;
          loop3 = false;
        } else {
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
    }
    return empty37;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    let loop3 = true;
    let polled = default_;
    while (loop3) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop3 = false;
      } else {
        const elem = this.subscriberHead.next.value;
        if (elem !== AbsentValue) {
          polled = elem;
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          loop3 = false;
        }
        this.subscriberHead = this.subscriberHead.next;
        this.subscriberIndex += 1;
      }
    }
    return polled;
  }
  pollUpTo(n) {
    const builder = [];
    const default_ = AbsentValue;
    let i = 0;
    while (i !== n) {
      const a = this.poll(default_);
      if (a === default_) {
        i = n;
      } else {
        builder.push(a);
        i += 1;
      }
    }
    return fromIterable3(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.publisherTail.subscribers -= 1;
      while (this.subscriberHead !== this.self.publisherTail) {
        if (this.subscriberHead.next.value !== AbsentValue) {
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
        }
        this.subscriberHead = this.subscriberHead.next;
      }
    }
  }
};
var _a59, _b18;
var SubscriptionImpl = class extends (_b18 = Class2, _a59 = DequeueTypeId, _b18) {
  constructor(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, replayWindow) {
    super();
    __publicField(this, "pubsub");
    __publicField(this, "subscribers");
    __publicField(this, "subscription");
    __publicField(this, "pollers");
    __publicField(this, "shutdownHook");
    __publicField(this, "shutdownFlag");
    __publicField(this, "strategy");
    __publicField(this, "replayWindow");
    __publicField(this, _a59, dequeueVariance);
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.subscription = subscription;
    this.pollers = pollers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
    this.replayWindow = replayWindow;
  }
  commit() {
    return this.take;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  capacity() {
    return this.pubsub.capacity;
  }
  isActive() {
    return !get6(this.shutdownFlag);
  }
  get size() {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() + this.replayWindow.remaining));
  }
  unsafeSize() {
    if (get6(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.subscription.size() + this.replayWindow.remaining);
  }
  get isFull() {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() === this.capacity()));
  }
  get isEmpty() {
    return map10(this.size, (size17) => size17 === 0);
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      set2(this.shutdownFlag, true);
      return pipe(forEachParUnbounded(unsafePollAllQueue(this.pollers), (d) => deferredInterruptWith(d, state.id()), false), zipRight2(sync(() => {
        this.subscribers.delete(this.subscription);
        this.subscription.unsubscribe();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      })), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
    }));
  }
  get isShutdown() {
    return sync(() => get6(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.replayWindow.remaining > 0) {
        const message2 = this.replayWindow.take();
        return succeed(message2);
      }
      const message = isEmpty9(this.pollers) ? this.subscription.poll(EmptyMutableQueue) : EmptyMutableQueue;
      if (message === EmptyMutableQueue) {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.pollers, offer(deferred));
          pipe(this.subscribers, addSubscribers(this.subscription, this.pollers));
          this.strategy.unsafeCompletePollers(this.pubsub, this.subscribers, this.subscription, this.pollers);
          return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => sync(() => unsafeRemove2(this.pollers, deferred))));
      } else {
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        return succeed(message);
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const as13 = isEmpty9(this.pollers) ? unsafePollAllSubscription(this.subscription) : empty5();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      if (this.replayWindow.remaining > 0) {
        return succeed(appendAll2(this.replayWindow.takeAll(), as13));
      }
      return succeed(as13);
    });
  }
  takeUpTo(max7) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      let replay = void 0;
      if (this.replayWindow.remaining >= max7) {
        const as14 = this.replayWindow.takeN(max7);
        return succeed(as14);
      } else if (this.replayWindow.remaining > 0) {
        replay = this.replayWindow.takeAll();
        max7 = max7 - replay.length;
      }
      const as13 = isEmpty9(this.pollers) ? unsafePollN2(this.subscription, max7) : empty5();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      return replay ? succeed(appendAll2(replay, as13)) : succeed(as13);
    });
  }
  takeBetween(min5, max7) {
    return suspend(() => takeRemainderLoop2(this, min5, max7, empty5()));
  }
};
var takeRemainderLoop2 = (self, min5, max7, acc) => {
  if (max7 < min5) {
    return succeed(acc);
  }
  return pipe(self.takeUpTo(max7), flatMap9((bs) => {
    const remaining = min5 - bs.length;
    if (remaining === 1) {
      return pipe(self.take, map10((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(self.take, flatMap9((b) => takeRemainderLoop2(self, remaining - 1, max7 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
};
var _a60, _b19;
_b19 = EnqueueTypeId, _a60 = DequeueTypeId;
var PubSubImpl = class {
  constructor(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) {
    __publicField(this, "pubsub");
    __publicField(this, "subscribers");
    __publicField(this, "scope");
    __publicField(this, "shutdownHook");
    __publicField(this, "shutdownFlag");
    __publicField(this, "strategy");
    __publicField(this, _b19, enqueueVariance);
    __publicField(this, _a60, dequeueVariance);
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.scope = scope5;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  capacity() {
    return this.pubsub.capacity;
  }
  get size() {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => this.pubsub.size()));
  }
  unsafeSize() {
    if (get6(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.pubsub.size());
  }
  get isFull() {
    return map10(this.size, (size17) => size17 === this.capacity());
  }
  get isEmpty() {
    return map10(this.size, (size17) => size17 === 0);
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get isShutdown() {
    return sync(() => get6(this.shutdownFlag));
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set2(true));
      return pipe(this.scope.close(exitInterrupt(state.id())), zipRight2(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
    }));
  }
  publish(value3) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.pubsub.publish(value3)) {
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, of2(value3), this.shutdownFlag);
    });
  }
  isActive() {
    return !get6(this.shutdownFlag);
  }
  unsafeOffer(value3) {
    if (get6(this.shutdownFlag)) {
      return false;
    }
    if (this.pubsub.publish(value3)) {
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      return true;
    }
    return false;
  }
  publishAll(elements) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const surplus = unsafePublishAll(this.pubsub, elements);
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      if (isEmpty(surplus)) {
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, surplus, this.shutdownFlag);
    });
  }
  get subscribe() {
    const acquire = tap2(all5([this.scope.fork(sequential2), makeSubscription(this.pubsub, this.subscribers, this.strategy)]), (tuple4) => tuple4[0].addFinalizer(() => tuple4[1].shutdown));
    return map10(acquireRelease(acquire, (tuple4, exit4) => tuple4[0].close(exit4)), (tuple4) => tuple4[1]);
  }
  offer(value3) {
    return this.publish(value3);
  }
  offerAll(elements) {
    return this.publishAll(elements);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makePubSub = (pubsub, strategy) => flatMap9(scopeMake(), (scope5) => map10(deferredMake(), (deferred) => unsafeMakePubSub(pubsub, /* @__PURE__ */ new Map(), scope5, deferred, make12(false), strategy)));
var unsafeMakePubSub = (pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) => new PubSubImpl(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy);
var ensureCapacity = (capacity7) => {
  if (capacity7 <= 0) {
    throw new InvalidPubSubCapacityException(`Cannot construct PubSub with capacity of ${capacity7}`);
  }
};
var unsafeCompleteDeferred2 = (deferred, a) => {
  deferredUnsafeDone(deferred, succeed(a));
};
var unsafeOfferAll2 = (queue, as13) => {
  return pipe(queue, offerAll(as13));
};
var unsafePollAllQueue = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollAllSubscription = (subscription) => {
  return subscription.pollUpTo(Number.POSITIVE_INFINITY);
};
var unsafePollN2 = (subscription, max7) => {
  return subscription.pollUpTo(max7);
};
var unsafePublishAll = (pubsub, as13) => {
  return pubsub.publishAll(as13);
};
var unsafeRemove2 = (queue, value3) => {
  unsafeOfferAll2(queue, pipe(unsafePollAllQueue(queue), filter3((elem) => elem !== value3)));
};
var BackPressureStrategy2 = class {
  constructor() {
    __publicField(this, "publishers", /* @__PURE__ */ unbounded());
  }
  get shutdown() {
    return flatMap9(fiberId, (fiberId3) => flatMap9(sync(() => unsafePollAllQueue(this.publishers)), (publishers) => forEachConcurrentDiscard(publishers, ([_, deferred, last5]) => last5 ? pipe(deferredInterruptWith(deferred, fiberId3), asVoid2) : void_2, false, false)));
  }
  handleSurplus(pubsub, subscribers, elements, isShutdown7) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(elements, deferred);
        this.unsafeOnPubSubEmptySpace(pubsub, subscribers);
        this.unsafeCompleteSubscribers(pubsub, subscribers);
        return get6(isShutdown7) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnPubSubEmptySpace(pubsub, subscribers) {
    let keepPolling = true;
    while (keepPolling && !pubsub.isFull()) {
      const publisher = pipe(this.publishers, poll4(EmptyMutableQueue));
      if (publisher === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const published = pubsub.publish(publisher[0]);
        if (published && publisher[2]) {
          unsafeCompleteDeferred2(publisher[1], true);
        } else if (!published) {
          unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), prepend2(publisher)));
        }
        this.unsafeCompleteSubscribers(pubsub, subscribers);
      }
    }
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeOffer(elements, deferred) {
    const iterator = elements[Symbol.iterator]();
    let next4 = iterator.next();
    if (!next4.done) {
      while (1) {
        const value3 = next4.value;
        next4 = iterator.next();
        if (next4.done) {
          pipe(this.publishers, offer([value3, deferred, true]));
          break;
        }
        pipe(this.publishers, offer([value3, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), filter3(([_, a]) => a !== deferred)));
  }
};
var DroppingStrategy2 = class {
  get shutdown() {
    return void_2;
  }
  handleSurplus(_pubsub, _subscribers, _elements, _isShutdown) {
    return succeed(false);
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
};
var SlidingStrategy2 = class {
  get shutdown() {
    return void_2;
  }
  handleSurplus(pubsub, subscribers, elements, _isShutdown) {
    return sync(() => {
      this.unsafeSlidingPublish(pubsub, elements);
      this.unsafeCompleteSubscribers(pubsub, subscribers);
      return true;
    });
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeSlidingPublish(pubsub, elements) {
    const it = elements[Symbol.iterator]();
    let next4 = it.next();
    if (!next4.done && pubsub.capacity > 0) {
      let a = next4.value;
      let loop3 = true;
      while (loop3) {
        pubsub.slide();
        const pub = pubsub.publish(a);
        if (pub && (next4 = it.next()) && !next4.done) {
          a = next4.value;
        } else if (pub) {
          loop3 = false;
        }
      }
    }
  }
};
var unsafeStrategyCompletePollers = (strategy, pubsub, subscribers, subscription, pollers) => {
  let keepPolling = true;
  while (keepPolling && !subscription.isEmpty()) {
    const poller = pipe(pollers, poll4(EmptyMutableQueue));
    if (poller === EmptyMutableQueue) {
      pipe(subscribers, removeSubscribers(subscription, pollers));
      if (isEmpty9(pollers)) {
        keepPolling = false;
      } else {
        pipe(subscribers, addSubscribers(subscription, pollers));
      }
    } else {
      const pollResult = subscription.poll(EmptyMutableQueue);
      if (pollResult === EmptyMutableQueue) {
        unsafeOfferAll2(pollers, pipe(unsafePollAllQueue(pollers), prepend2(poller)));
      } else {
        unsafeCompleteDeferred2(poller, pollResult);
        strategy.unsafeOnPubSubEmptySpace(pubsub, subscribers);
      }
    }
  }
};
var unsafeStrategyCompleteSubscribers = (strategy, pubsub, subscribers) => {
  for (const [subscription, pollersSet] of subscribers) {
    for (const pollers of pollersSet) {
      strategy.unsafeCompletePollers(pubsub, subscribers, subscription, pollers);
    }
  }
};
var ReplayBuffer = class {
  constructor(capacity7) {
    __publicField(this, "capacity");
    __publicField(this, "head", {
      value: AbsentValue,
      next: null
    });
    __publicField(this, "tail", this.head);
    __publicField(this, "size", 0);
    __publicField(this, "index", 0);
    this.capacity = capacity7;
  }
  slide() {
    this.index++;
  }
  offer(a) {
    this.tail.value = a;
    this.tail.next = {
      value: AbsentValue,
      next: null
    };
    this.tail = this.tail.next;
    if (this.size === this.capacity) {
      this.head = this.head.next;
    } else {
      this.size += 1;
    }
  }
  offerAll(as13) {
    for (const a of as13) {
      this.offer(a);
    }
  }
};
var ReplayWindowImpl = class {
  constructor(buffer3) {
    __publicField(this, "buffer");
    __publicField(this, "head");
    __publicField(this, "index");
    __publicField(this, "remaining");
    this.buffer = buffer3;
    this.index = buffer3.index;
    this.remaining = buffer3.size;
    this.head = buffer3.head;
  }
  fastForward() {
    while (this.index < this.buffer.index) {
      this.head = this.head.next;
      this.index++;
    }
  }
  take() {
    if (this.remaining === 0) {
      return void 0;
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    this.remaining--;
    const value3 = this.head.value;
    this.head = this.head.next;
    return value3;
  }
  takeN(n) {
    if (this.remaining === 0) {
      return empty5();
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    const len = Math.min(n, this.remaining);
    const items = new Array(len);
    for (let i = 0; i < len; i++) {
      const value3 = this.head.value;
      this.head = this.head.next;
      items[i] = value3;
    }
    this.remaining -= len;
    return unsafeFromArray(items);
  }
  takeAll() {
    return this.takeN(this.remaining);
  }
};
var emptyReplayWindow = {
  remaining: 0,
  take: () => void 0,
  takeN: () => empty5(),
  takeAll: () => empty5()
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/PubSub.js
var bounded5 = bounded4;
var dropping4 = dropping3;
var sliding4 = sliding3;
var unbounded5 = unbounded4;
var shutdown4 = shutdown3;
var subscribe2 = subscribe;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/opCodes/channelChildExecutorDecision.js
var OP_CONTINUE2 = "Continue";
var OP_CLOSE = "Close";
var OP_YIELD2 = "Yield";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
var ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
var ChildExecutorDecisionTypeId = /* @__PURE__ */ Symbol.for(ChildExecutorDecisionSymbolKey);
var proto4 = {
  [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
};
var Continue = (_) => {
  const op = Object.create(proto4);
  op._tag = OP_CONTINUE2;
  return op;
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/opCodes/continuation.js
var OP_CONTINUATION_K = "ContinuationK";
var OP_CONTINUATION_FINALIZER = "ContinuationFinalizer";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/channel/continuation.js
var ContinuationTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelContinuation");
var continuationVariance = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _,
  /* c8 ignore next */
  _OutErr2: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone2: (_) => _
};
var _a61;
_a61 = ContinuationTypeId;
var ContinuationKImpl = class {
  constructor(onSuccess, onHalt) {
    __publicField(this, "onSuccess");
    __publicField(this, "onHalt");
    __publicField(this, "_tag", OP_CONTINUATION_K);
    __publicField(this, _a61, continuationVariance);
    this.onSuccess = onSuccess;
    this.onHalt = onHalt;
  }
  onExit(exit4) {
    return isFailure2(exit4) ? this.onHalt(exit4.cause) : this.onSuccess(exit4.value);
  }
};
var _a62;
_a62 = ContinuationTypeId;
var ContinuationFinalizerImpl = class {
  constructor(finalizer3) {
    __publicField(this, "finalizer");
    __publicField(this, "_tag", OP_CONTINUATION_FINALIZER);
    __publicField(this, _a62, continuationVariance);
    this.finalizer = finalizer3;
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullStrategy.js
var OP_PULL_AFTER_NEXT = "PullAfterNext";
var OP_PULL_AFTER_ALL_ENQUEUED = "PullAfterAllEnqueued";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
var UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
var UpstreamPullStrategyTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullStrategySymbolKey);
var upstreamPullStrategyVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto5 = {
  [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
};
var PullAfterNext = (emitSeparator) => {
  const op = Object.create(proto5);
  op._tag = OP_PULL_AFTER_NEXT;
  op.emitSeparator = emitSeparator;
  return op;
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/opCodes/channel.js
var OP_BRACKET_OUT = "BracketOut";
var OP_BRIDGE = "Bridge";
var OP_CONCAT_ALL = "ConcatAll";
var OP_EMIT = "Emit";
var OP_ENSURING = "Ensuring";
var OP_FAIL3 = "Fail";
var OP_FOLD2 = "Fold";
var OP_FROM_EFFECT2 = "FromEffect";
var OP_PIPE_TO = "PipeTo";
var OP_PROVIDE2 = "Provide";
var OP_READ = "Read";
var OP_SUCCEED = "Succeed";
var OP_SUCCEED_NOW = "SucceedNow";
var OP_SUSPEND2 = "Suspend";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/core-stream.js
var ChannelSymbolKey = "effect/Channel";
var ChannelTypeId2 = /* @__PURE__ */ Symbol.for(ChannelSymbolKey);
var channelVariance2 = {
  /* c8 ignore next */
  _Env: (_) => _,
  /* c8 ignore next */
  _InErr: (_) => _,
  /* c8 ignore next */
  _InElem: (_) => _,
  /* c8 ignore next */
  _InDone: (_) => _,
  /* c8 ignore next */
  _OutErr: (_) => _,
  /* c8 ignore next */
  _OutElem: (_) => _,
  /* c8 ignore next */
  _OutDone: (_) => _
};
var proto6 = {
  [ChannelTypeId2]: channelVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isChannel = (u) => hasProperty(u, ChannelTypeId2) || isEffect2(u);
var acquireReleaseOut = /* @__PURE__ */ dual(2, (self, release) => {
  const op = Object.create(proto6);
  op._tag = OP_BRACKET_OUT;
  op.acquire = () => self;
  op.finalizer = release;
  return op;
});
var catchAllCause5 = /* @__PURE__ */ dual(2, (self, f) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self;
  op.k = new ContinuationKImpl(succeed12, f);
  return op;
});
var collectElements = (self) => {
  return suspend6(() => {
    const builder = [];
    return flatMap14(pipeTo(self, collectElementsReader(builder)), (value3) => sync7(() => [fromIterable3(builder), value3]));
  });
};
var collectElementsReader = (builder) => readWith({
  onInput: (outElem) => flatMap14(sync7(() => {
    builder.push(outElem);
  }), () => collectElementsReader(builder)),
  onFailure: fail12,
  onDone: succeedNow
});
var concatAllWith = (channels, f, g) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = f;
  op.combineAll = g;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => channels;
  op.k = identity;
  return op;
};
var concatMapWith = /* @__PURE__ */ dual(4, (self, f, g, h) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = g;
  op.combineAll = h;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => self;
  op.k = f;
  return op;
});
var embedInput = /* @__PURE__ */ dual(2, (self, input) => {
  const op = Object.create(proto6);
  op._tag = OP_BRIDGE;
  op.input = input;
  op.channel = self;
  return op;
});
var ensuringWith = /* @__PURE__ */ dual(2, (self, finalizer3) => {
  const op = Object.create(proto6);
  op._tag = OP_ENSURING;
  op.channel = self;
  op.finalizer = finalizer3;
  return op;
});
var fail12 = (error2) => failCause11(fail6(error2));
var failCause11 = (cause3) => failCauseSync5(() => cause3);
var failCauseSync5 = (evaluate3) => {
  const op = Object.create(proto6);
  op._tag = OP_FAIL3;
  op.error = evaluate3;
  return op;
};
var flatMap14 = /* @__PURE__ */ dual(2, (self, f) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self;
  op.k = new ContinuationKImpl(f, failCause11);
  return op;
});
var foldCauseChannel = /* @__PURE__ */ dual(2, (self, options) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self;
  op.k = new ContinuationKImpl(options.onSuccess, options.onFailure);
  return op;
});
var fromEffect5 = (effect4) => {
  const op = Object.create(proto6);
  op._tag = OP_FROM_EFFECT2;
  op.effect = () => effect4;
  return op;
};
var pipeTo = /* @__PURE__ */ dual(2, (self, that) => {
  const op = Object.create(proto6);
  op._tag = OP_PIPE_TO;
  op.left = () => self;
  op.right = () => that;
  return op;
});
var provideContext4 = /* @__PURE__ */ dual(2, (self, env3) => {
  const op = Object.create(proto6);
  op._tag = OP_PROVIDE2;
  op.context = () => env3;
  op.inner = self;
  return op;
});
var readWith = (options) => readWithCause({
  onInput: options.onInput,
  onFailure: (cause3) => match(failureOrCause2(cause3), {
    onLeft: options.onFailure,
    onRight: failCause11
  }),
  onDone: options.onDone
});
var readWithCause = (options) => {
  const op = Object.create(proto6);
  op._tag = OP_READ;
  op.more = options.onInput;
  op.done = new ContinuationKImpl(options.onDone, options.onFailure);
  return op;
};
var succeed12 = (value3) => sync7(() => value3);
var succeedNow = (result) => {
  const op = Object.create(proto6);
  op._tag = OP_SUCCEED_NOW;
  op.terminal = result;
  return op;
};
var suspend6 = (evaluate3) => {
  const op = Object.create(proto6);
  op._tag = OP_SUSPEND2;
  op.channel = evaluate3;
  return op;
};
var sync7 = (evaluate3) => {
  const op = Object.create(proto6);
  op._tag = OP_SUCCEED;
  op.evaluate = evaluate3;
  return op;
};
var void_7 = /* @__PURE__ */ succeedNow(void 0);
var write = (out) => {
  const op = Object.create(proto6);
  op._tag = OP_EMIT;
  op.out = out;
  return op;
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/opCodes/channelState.js
var OP_DONE3 = "Done";
var OP_EMIT2 = "Emit";
var OP_FROM_EFFECT3 = "FromEffect";
var OP_READ2 = "Read";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/channel/channelState.js
var ChannelStateTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelState");
var channelStateVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var proto7 = {
  [ChannelStateTypeId]: channelStateVariance
};
var Done2 = () => {
  const op = Object.create(proto7);
  op._tag = OP_DONE3;
  return op;
};
var Emit = () => {
  const op = Object.create(proto7);
  op._tag = OP_EMIT2;
  return op;
};
var fromEffect6 = (effect4) => {
  const op = Object.create(proto7);
  op._tag = OP_FROM_EFFECT3;
  op.effect = effect4;
  return op;
};
var Read = (upstream, onEffect, onEmit, onDone3) => {
  const op = Object.create(proto7);
  op._tag = OP_READ2;
  op.upstream = upstream;
  op.onEffect = onEffect;
  op.onEmit = onEmit;
  op.onDone = onDone3;
  return op;
};
var isFromEffect = (self) => self._tag === OP_FROM_EFFECT3;
var effect2 = (self) => isFromEffect(self) ? self.effect : _void;
var effectOrUndefinedIgnored = (self) => isFromEffect(self) ? ignore2(self.effect) : void 0;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/channel/subexecutor.js
var OP_PULL_FROM_CHILD = "PullFromChild";
var OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
var OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
var OP_EMIT3 = "Emit";
var PullFromChild = class {
  constructor(childExecutor, parentSubexecutor, onEmit) {
    __publicField(this, "childExecutor");
    __publicField(this, "parentSubexecutor");
    __publicField(this, "onEmit");
    __publicField(this, "_tag", OP_PULL_FROM_CHILD);
    this.childExecutor = childExecutor;
    this.parentSubexecutor = parentSubexecutor;
    this.onEmit = onEmit;
  }
  close(exit4) {
    const fin1 = this.childExecutor.close(exit4);
    const fin2 = this.parentSubexecutor.close(exit4);
    if (fin1 !== void 0 && fin2 !== void 0) {
      return zipWith9(exit3(fin1), exit3(fin2), (exit1, exit22) => pipe(exit1, zipRight3(exit22)));
    } else if (fin1 !== void 0) {
      return fin1;
    } else if (fin2 !== void 0) {
      return fin2;
    } else {
      return void 0;
    }
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};
var PullFromUpstream = class _PullFromUpstream {
  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
    __publicField(this, "upstreamExecutor");
    __publicField(this, "createChild");
    __publicField(this, "lastDone");
    __publicField(this, "activeChildExecutors");
    __publicField(this, "combineChildResults");
    __publicField(this, "combineWithChildResult");
    __publicField(this, "onPull");
    __publicField(this, "onEmit");
    __publicField(this, "_tag", OP_PULL_FROM_UPSTREAM);
    this.upstreamExecutor = upstreamExecutor;
    this.createChild = createChild;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
    this.onEmit = onEmit;
  }
  close(exit4) {
    const fin1 = this.upstreamExecutor.close(exit4);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit4) : void 0), fin1];
    const result = fins.reduce((acc, next4) => {
      if (acc !== void 0 && next4 !== void 0) {
        return zipWith9(acc, exit3(next4), (exit1, exit22) => zipRight3(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next4 !== void 0) {
        return exit3(next4);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new _PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
  }
};
var DrainChildExecutors = class _DrainChildExecutors {
  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
    __publicField(this, "upstreamExecutor");
    __publicField(this, "lastDone");
    __publicField(this, "activeChildExecutors");
    __publicField(this, "upstreamDone");
    __publicField(this, "combineChildResults");
    __publicField(this, "combineWithChildResult");
    __publicField(this, "onPull");
    __publicField(this, "_tag", OP_DRAIN_CHILD_EXECUTORS);
    this.upstreamExecutor = upstreamExecutor;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.upstreamDone = upstreamDone;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
  }
  close(exit4) {
    const fin1 = this.upstreamExecutor.close(exit4);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit4) : void 0), fin1];
    const result = fins.reduce((acc, next4) => {
      if (acc !== void 0 && next4 !== void 0) {
        return zipWith9(acc, exit3(next4), (exit1, exit22) => zipRight3(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next4 !== void 0) {
        return exit3(next4);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new _DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
  }
};
var Emit2 = class {
  constructor(value3, next4) {
    __publicField(this, "value");
    __publicField(this, "next");
    __publicField(this, "_tag", OP_EMIT3);
    this.value = value3;
    this.next = next4;
  }
  close(exit4) {
    const result = this.next.close(exit4);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullRequest.js
var OP_PULLED = "Pulled";
var OP_NO_UPSTREAM = "NoUpstream";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
var UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
var UpstreamPullRequestTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullRequestSymbolKey);
var upstreamPullRequestVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto8 = {
  [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
};
var Pulled = (value3) => {
  const op = Object.create(proto8);
  op._tag = OP_PULLED;
  op.value = value3;
  return op;
};
var NoUpstream = (activeDownstreamCount) => {
  const op = Object.create(proto8);
  op._tag = OP_NO_UPSTREAM;
  op.activeDownstreamCount = activeDownstreamCount;
  return op;
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/channel/channelExecutor.js
var ChannelExecutor = class _ChannelExecutor {
  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
    __publicField(this, "_activeSubexecutor");
    __publicField(this, "_cancelled");
    __publicField(this, "_closeLastSubstream");
    __publicField(this, "_currentChannel");
    __publicField(this, "_done");
    __publicField(this, "_doneStack", []);
    __publicField(this, "_emitted");
    __publicField(this, "_executeCloseLastSubstream");
    __publicField(this, "_input");
    __publicField(this, "_inProgressFinalizer");
    __publicField(this, "_providedEnv");
    this._currentChannel = initialChannel;
    this._executeCloseLastSubstream = executeCloseLastSubstream;
    this._providedEnv = providedEnv;
  }
  run() {
    let result = void 0;
    while (result === void 0) {
      if (this._cancelled !== void 0) {
        result = this.processCancellation();
      } else if (this._activeSubexecutor !== void 0) {
        result = this.runSubexecutor();
      } else {
        try {
          if (this._currentChannel === void 0) {
            result = Done2();
          } else {
            if (isEffect2(this._currentChannel)) {
              this._currentChannel = fromEffect5(this._currentChannel);
            }
            switch (this._currentChannel._tag) {
              case OP_BRACKET_OUT: {
                result = this.runBracketOut(this._currentChannel);
                break;
              }
              case OP_BRIDGE: {
                const bridgeInput = this._currentChannel.input;
                this._currentChannel = this._currentChannel.channel;
                if (this._input !== void 0) {
                  const inputExecutor = this._input;
                  this._input = void 0;
                  const drainer = () => flatMap12(bridgeInput.awaitRead(), () => suspend4(() => {
                    const state = inputExecutor.run();
                    switch (state._tag) {
                      case OP_DONE3: {
                        return match9(inputExecutor.getDone(), {
                          onFailure: (cause3) => bridgeInput.error(cause3),
                          onSuccess: (value3) => bridgeInput.done(value3)
                        });
                      }
                      case OP_EMIT2: {
                        return flatMap12(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                      }
                      case OP_FROM_EFFECT3: {
                        return matchCauseEffect3(state.effect, {
                          onFailure: (cause3) => bridgeInput.error(cause3),
                          onSuccess: () => drainer()
                        });
                      }
                      case OP_READ2: {
                        return readUpstream(state, () => drainer(), (cause3) => bridgeInput.error(cause3));
                      }
                    }
                  }));
                  result = fromEffect6(flatMap12(forkDaemon2(interruptible4(drainer())), (fiber) => sync5(() => this.addFinalizer((exit4) => flatMap12(interrupt6(fiber), () => suspend4(() => {
                    const effect4 = this.restorePipe(exit4, inputExecutor);
                    return effect4 !== void 0 ? effect4 : _void;
                  }))))));
                }
                break;
              }
              case OP_CONCAT_ALL: {
                const executor = new _ChannelExecutor(this._currentChannel.value(), this._providedEnv, (effect4) => sync5(() => {
                  const prevLastClose = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
                  this._closeLastSubstream = pipe(prevLastClose, zipRight6(effect4));
                }));
                executor._input = this._input;
                const channel = this._currentChannel;
                this._activeSubexecutor = new PullFromUpstream(executor, (value3) => channel.k(value3), void 0, [], (x, y) => channel.combineInners(x, y), (x, y) => channel.combineAll(x, y), (request2) => channel.onPull(request2), (value3) => channel.onEmit(value3));
                this._closeLastSubstream = void 0;
                this._currentChannel = void 0;
                break;
              }
              case OP_EMIT: {
                this._emitted = this._currentChannel.out;
                this._currentChannel = this._activeSubexecutor !== void 0 ? void 0 : void_7;
                result = Emit();
                break;
              }
              case OP_ENSURING: {
                this.runEnsuring(this._currentChannel);
                break;
              }
              case OP_FAIL3: {
                result = this.doneHalt(this._currentChannel.error());
                break;
              }
              case OP_FOLD2: {
                this._doneStack.push(this._currentChannel.k);
                this._currentChannel = this._currentChannel.channel;
                break;
              }
              case OP_FROM_EFFECT2: {
                const effect4 = this._providedEnv === void 0 ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide2(this._providedEnv));
                result = fromEffect6(matchCauseEffect3(effect4, {
                  onFailure: (cause3) => {
                    const state = this.doneHalt(cause3);
                    return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                  },
                  onSuccess: (value3) => {
                    const state = this.doneSucceed(value3);
                    return state !== void 0 && isFromEffect(state) ? state.effect : _void;
                  }
                }));
                break;
              }
              case OP_PIPE_TO: {
                const previousInput = this._input;
                const leftExec = new _ChannelExecutor(this._currentChannel.left(), this._providedEnv, (effect4) => this._executeCloseLastSubstream(effect4));
                leftExec._input = previousInput;
                this._input = leftExec;
                this.addFinalizer((exit4) => {
                  const effect4 = this.restorePipe(exit4, previousInput);
                  return effect4 !== void 0 ? effect4 : _void;
                });
                this._currentChannel = this._currentChannel.right();
                break;
              }
              case OP_PROVIDE2: {
                const previousEnv = this._providedEnv;
                this._providedEnv = this._currentChannel.context();
                this._currentChannel = this._currentChannel.inner;
                this.addFinalizer(() => sync5(() => {
                  this._providedEnv = previousEnv;
                }));
                break;
              }
              case OP_READ: {
                const read = this._currentChannel;
                result = Read(this._input, identity, (emitted) => {
                  try {
                    this._currentChannel = read.more(emitted);
                  } catch (error2) {
                    this._currentChannel = read.done.onExit(die3(error2));
                  }
                  return void 0;
                }, (exit4) => {
                  const onExit4 = (exit5) => {
                    return read.done.onExit(exit5);
                  };
                  this._currentChannel = onExit4(exit4);
                  return void 0;
                });
                break;
              }
              case OP_SUCCEED: {
                result = this.doneSucceed(this._currentChannel.evaluate());
                break;
              }
              case OP_SUCCEED_NOW: {
                result = this.doneSucceed(this._currentChannel.terminal);
                break;
              }
              case OP_SUSPEND2: {
                this._currentChannel = this._currentChannel.channel();
                break;
              }
            }
          }
        } catch (error2) {
          this._currentChannel = failCause11(die4(error2));
        }
      }
    }
    return result;
  }
  getDone() {
    return this._done;
  }
  getEmit() {
    return this._emitted;
  }
  cancelWith(exit4) {
    this._cancelled = exit4;
  }
  clearInProgressFinalizer() {
    this._inProgressFinalizer = void 0;
  }
  storeInProgressFinalizer(finalizer3) {
    this._inProgressFinalizer = finalizer3;
  }
  popAllFinalizers(exit4) {
    const finalizers = [];
    let next4 = this._doneStack.pop();
    while (next4) {
      if (next4._tag === "ContinuationFinalizer") {
        finalizers.push(next4.finalizer);
      }
      next4 = this._doneStack.pop();
    }
    const effect4 = finalizers.length === 0 ? _void : runFinalizers(finalizers, exit4);
    this.storeInProgressFinalizer(effect4);
    return effect4;
  }
  popNextFinalizers() {
    const builder = [];
    while (this._doneStack.length !== 0) {
      const cont = this._doneStack[this._doneStack.length - 1];
      if (cont._tag === OP_CONTINUATION_K) {
        return builder;
      }
      builder.push(cont);
      this._doneStack.pop();
    }
    return builder;
  }
  restorePipe(exit4, prev) {
    const currInput = this._input;
    this._input = prev;
    if (currInput !== void 0) {
      const effect4 = currInput.close(exit4);
      return effect4;
    }
    return _void;
  }
  close(exit4) {
    let runInProgressFinalizers = void 0;
    const finalizer3 = this._inProgressFinalizer;
    if (finalizer3 !== void 0) {
      runInProgressFinalizers = pipe(finalizer3, ensuring3(sync5(() => this.clearInProgressFinalizer())));
    }
    let closeSelf = void 0;
    const selfFinalizers = this.popAllFinalizers(exit4);
    if (selfFinalizers !== void 0) {
      closeSelf = pipe(selfFinalizers, ensuring3(sync5(() => this.clearInProgressFinalizer())));
    }
    const closeSubexecutors = this._activeSubexecutor === void 0 ? void 0 : this._activeSubexecutor.close(exit4);
    if (closeSubexecutors === void 0 && runInProgressFinalizers === void 0 && closeSelf === void 0) {
      return void 0;
    }
    return pipe(
      exit3(ifNotNull(closeSubexecutors)),
      zip7(exit3(ifNotNull(runInProgressFinalizers))),
      zip7(exit3(ifNotNull(closeSelf))),
      map18(([[exit1, exit22], exit32]) => pipe(exit1, zipRight3(exit22), zipRight3(exit32))),
      uninterruptible2,
      // TODO: remove
      flatMap12((exit5) => suspend4(() => exit5))
    );
  }
  doneSucceed(value3) {
    if (this._doneStack.length === 0) {
      this._done = succeed4(value3);
      this._currentChannel = void 0;
      return Done2();
    }
    const head8 = this._doneStack[this._doneStack.length - 1];
    if (head8._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      this._currentChannel = head8.onSuccess(value3);
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = succeed4(value3);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), succeed4(value3));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect4 = pipe(finalizerEffect, ensuring3(sync5(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap12(() => sync5(() => this.doneSucceed(value3))));
    return fromEffect6(effect4);
  }
  doneHalt(cause3) {
    if (this._doneStack.length === 0) {
      this._done = failCause4(cause3);
      this._currentChannel = void 0;
      return Done2();
    }
    const head8 = this._doneStack[this._doneStack.length - 1];
    if (head8._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      try {
        this._currentChannel = head8.onHalt(cause3);
      } catch (error2) {
        this._currentChannel = failCause11(die4(error2));
      }
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = failCause4(cause3);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), failCause4(cause3));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect4 = pipe(finalizerEffect, ensuring3(sync5(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap12(() => sync5(() => this.doneHalt(cause3))));
    return fromEffect6(effect4);
  }
  processCancellation() {
    this._currentChannel = void 0;
    this._done = this._cancelled;
    this._cancelled = void 0;
    return Done2();
  }
  runBracketOut(bracketOut) {
    const effect4 = uninterruptible2(matchCauseEffect3(this.provide(bracketOut.acquire()), {
      onFailure: (cause3) => sync5(() => {
        this._currentChannel = failCause11(cause3);
      }),
      onSuccess: (out) => sync5(() => {
        this.addFinalizer((exit4) => this.provide(bracketOut.finalizer(out, exit4)));
        this._currentChannel = write(out);
      })
    }));
    return fromEffect6(effect4);
  }
  provide(effect4) {
    if (this._providedEnv === void 0) {
      return effect4;
    }
    return pipe(effect4, provide2(this._providedEnv));
  }
  runEnsuring(ensuring10) {
    this.addFinalizer(ensuring10.finalizer);
    this._currentChannel = ensuring10.channel;
  }
  addFinalizer(f) {
    this._doneStack.push(new ContinuationFinalizerImpl(f));
  }
  runSubexecutor() {
    const subexecutor = this._activeSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_CHILD: {
        return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
      }
      case OP_PULL_FROM_UPSTREAM: {
        return this.pullFromUpstream(subexecutor);
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        return this.drainChildExecutors(subexecutor);
      }
      case OP_EMIT3: {
        this._emitted = subexecutor.value;
        this._activeSubexecutor = subexecutor.next;
        return Emit();
      }
    }
  }
  replaceSubexecutor(nextSubExec) {
    this._currentChannel = void 0;
    this._activeSubexecutor = nextSubExec;
  }
  finishWithExit(exit4) {
    const state = match9(exit4, {
      onFailure: (cause3) => this.doneHalt(cause3),
      onSuccess: (value3) => this.doneSucceed(value3)
    });
    this._activeSubexecutor = void 0;
    return state === void 0 ? _void : effect2(state);
  }
  finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
    this.addFinalizer(() => pipe(closeFuncs, forEach10((closeFunc) => pipe(sync5(() => closeFunc(subexecutorDone)), flatMap12((closeEffect) => closeEffect !== void 0 ? closeEffect : _void)), {
      discard: true
    })));
    const state = pipe(subexecutorDone, match9({
      onFailure: (cause3) => this.doneHalt(cause3),
      onSuccess: (value3) => this.doneSucceed(value3)
    }));
    this._activeSubexecutor = void 0;
    return state;
  }
  applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
    switch (strategy._tag) {
      case OP_PULL_AFTER_NEXT: {
        const shouldPrepend = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldPrepend ? [void 0, ...queue] : queue];
      }
      case OP_PULL_AFTER_ALL_ENQUEUED: {
        const shouldEnqueue = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldEnqueue ? [...queue, void 0] : queue];
      }
    }
  }
  pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
    return Read(childExecutor, identity, (emitted) => {
      const childExecutorDecision = onEmitted(emitted);
      switch (childExecutorDecision._tag) {
        case OP_CONTINUE2: {
          break;
        }
        case OP_CLOSE: {
          this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
          break;
        }
        case OP_YIELD2: {
          const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      }
      this._activeSubexecutor = new Emit2(emitted, this._activeSubexecutor);
      return void 0;
    }, match9({
      onFailure: (cause3) => {
        const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3);
        return state === void 0 ? void 0 : effectOrUndefinedIgnored(state);
      },
      onSuccess: (doneValue) => {
        this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
        return void 0;
      }
    }));
  }
  finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
    const subexecutor = parentSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_UPSTREAM: {
        const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
        this._closeLastSubstream = childExecutor.close(succeed4(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        this._closeLastSubstream = childExecutor.close(succeed4(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      default: {
        break;
      }
    }
  }
  handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3) {
    return this.finishSubexecutorWithCloseEffect(failCause4(cause3), (exit4) => parentSubexecutor.close(exit4), (exit4) => childExecutor.close(exit4));
  }
  pullFromUpstream(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      return this.performPullFromUpstream(subexecutor);
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
    if (activeChild === void 0) {
      return this.performPullFromUpstream(parentSubexecutor);
    }
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
  performPullFromUpstream(subexecutor) {
    return Read(subexecutor.upstreamExecutor, (effect4) => {
      const closeLastSubstream = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
      this._closeLastSubstream = void 0;
      return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight6(effect4));
    }, (emitted) => {
      if (this._closeLastSubstream !== void 0) {
        const closeLastSubstream = this._closeLastSubstream;
        this._closeLastSubstream = void 0;
        return pipe(this._executeCloseLastSubstream(closeLastSubstream), map18(() => {
          const childExecutor2 = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
          childExecutor2._input = this._input;
          const [emitSeparator2, updatedChildExecutors2] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
          this._activeSubexecutor = new PullFromChild(childExecutor2, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors2, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
          if (isSome2(emitSeparator2)) {
            this._activeSubexecutor = new Emit2(emitSeparator2.value, this._activeSubexecutor);
          }
          return void 0;
        }));
      }
      const childExecutor = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
      childExecutor._input = this._input;
      const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
      this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
      if (isSome2(emitSeparator)) {
        this._activeSubexecutor = new Emit2(emitSeparator.value, this._activeSubexecutor);
      }
      return void 0;
    }, (exit4) => {
      if (subexecutor.activeChildExecutors.some((subexecutor2) => subexecutor2 !== void 0)) {
        const drain5 = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [void 0, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        if (this._closeLastSubstream !== void 0) {
          const closeLastSubstream2 = this._closeLastSubstream;
          this._closeLastSubstream = void 0;
          return pipe(this._executeCloseLastSubstream(closeLastSubstream2), map18(() => this.replaceSubexecutor(drain5)));
        }
        this.replaceSubexecutor(drain5);
        return void 0;
      }
      const closeLastSubstream = this._closeLastSubstream;
      const state = this.finishSubexecutorWithCloseEffect(pipe(exit4, map12((a) => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, (exit5) => subexecutor.upstreamExecutor.close(exit5));
      return state === void 0 ? void 0 : (
        // NOTE: assuming finalizers cannot fail
        effectOrUndefinedIgnored(state)
      );
    });
  }
  drainChildExecutors(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      const lastClose = this._closeLastSubstream;
      if (lastClose !== void 0) {
        this.addFinalizer(() => succeed10(lastClose));
      }
      return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, (exit4) => subexecutor.upstreamExecutor.close(exit4));
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const rest = subexecutor.activeChildExecutors.slice(1);
    if (activeChild === void 0) {
      const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n, curr) => curr !== void 0 ? n + 1 : n, 0))));
      this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
      if (isSome2(emitSeparator)) {
        this._emitted = emitSeparator.value;
        return Emit();
      }
      return void 0;
    }
    const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
};
var ifNotNull = (effect4) => effect4 !== void 0 ? effect4 : _void;
var runFinalizers = (finalizers, exit4) => {
  return pipe(forEach10(finalizers, (fin) => exit3(fin(exit4))), map18((exits) => pipe(all4(exits), getOrElse3(() => void_4))), flatMap12((exit5) => suspend4(() => exit5)));
};
var readUpstream = (r, onSuccess, onFailure) => {
  const readStack = [r];
  const read = () => {
    const current2 = readStack.pop();
    if (current2 === void 0 || current2.upstream === void 0) {
      return dieMessage2("Unexpected end of input for channel execution");
    }
    const state = current2.upstream.run();
    switch (state._tag) {
      case OP_EMIT2: {
        const emitEffect = current2.onEmit(current2.upstream.getEmit());
        if (readStack.length === 0) {
          if (emitEffect === void 0) {
            return suspend4(onSuccess);
          }
          return pipe(emitEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (emitEffect === void 0) {
          return suspend4(() => read());
        }
        return pipe(emitEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read()
        }));
      }
      case OP_DONE3: {
        const doneEffect = current2.onDone(current2.upstream.getDone());
        if (readStack.length === 0) {
          if (doneEffect === void 0) {
            return suspend4(onSuccess);
          }
          return pipe(doneEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (doneEffect === void 0) {
          return suspend4(() => read());
        }
        return pipe(doneEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read()
        }));
      }
      case OP_FROM_EFFECT3: {
        readStack.push(current2);
        return pipe(current2.onEffect(state.effect), catchAllCause3((cause3) => suspend4(() => {
          const doneEffect = current2.onDone(failCause4(cause3));
          return doneEffect === void 0 ? _void : doneEffect;
        })), matchCauseEffect3({
          onFailure,
          onSuccess: () => read()
        }));
      }
      case OP_READ2: {
        readStack.push(current2);
        readStack.push(state);
        return suspend4(() => read());
      }
    }
  };
  return read();
};
var runIn = /* @__PURE__ */ dual(2, (self, scope5) => {
  const run6 = (channelDeferred, scopeDeferred, scope6) => acquireUseRelease2(sync5(() => new ChannelExecutor(self, void 0, identity)), (exec) => suspend4(() => runScopedInterpret(exec.run(), exec).pipe(intoDeferred2(channelDeferred), zipRight6(_await(channelDeferred)), zipLeft5(_await(scopeDeferred)))), (exec, exit4) => {
    const finalize = exec.close(exit4);
    if (finalize === void 0) {
      return _void;
    }
    return tapErrorCause3(finalize, (cause3) => addFinalizer2(scope6, failCause9(cause3)));
  });
  return uninterruptibleMask3((restore) => all7([fork2(scope5, sequential3), make23(), make23()]).pipe(flatMap12(([child, channelDeferred, scopeDeferred]) => restore(run6(channelDeferred, scopeDeferred, child)).pipe(forkIn2(scope5), flatMap12((fiber) => scope5.addFinalizer((exit4) => {
    const interruptors3 = isFailure2(exit4) ? interruptors2(exit4.cause) : void 0;
    return isDone(channelDeferred).pipe(flatMap12((isDone7) => isDone7 ? succeed2(scopeDeferred, void 0).pipe(zipRight6(_await3(fiber)), zipRight6(inheritAll2(fiber))) : succeed2(scopeDeferred, void 0).pipe(zipRight6(interruptors3 && size4(interruptors3) > 0 ? interruptAs(fiber, combineAll2(interruptors3)) : interrupt6(fiber)), zipRight6(inheritAll2(fiber)))));
  }).pipe(zipRight6(restore(_await(channelDeferred)))))))));
});
var runScopedInterpret = (channelState, exec) => {
  const op = channelState;
  switch (op._tag) {
    case OP_FROM_EFFECT3: {
      return pipe(op.effect, flatMap12(() => runScopedInterpret(exec.run(), exec)));
    }
    case OP_EMIT2: {
      return runScopedInterpret(exec.run(), exec);
    }
    case OP_DONE3: {
      return suspend4(() => exec.getDone());
    }
    case OP_READ2: {
      return readUpstream(op, () => runScopedInterpret(exec.run(), exec), failCause9);
    }
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/opCodes/channelMergeDecision.js
var OP_DONE4 = "Done";
var OP_AWAIT = "Await";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/channel/mergeDecision.js
var MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
var MergeDecisionTypeId = /* @__PURE__ */ Symbol.for(MergeDecisionSymbolKey);
var proto9 = {
  [MergeDecisionTypeId]: {
    _R: (_) => _,
    _E0: (_) => _,
    _Z0: (_) => _,
    _E: (_) => _,
    _Z: (_) => _
  }
};
var Done3 = (effect4) => {
  const op = Object.create(proto9);
  op._tag = OP_DONE4;
  op.effect = effect4;
  return op;
};
var Await = (f) => {
  const op = Object.create(proto9);
  op._tag = OP_AWAIT;
  op.f = f;
  return op;
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/opCodes/channelMergeState.js
var OP_BOTH_RUNNING = "BothRunning";
var OP_LEFT_DONE = "LeftDone";
var OP_RIGHT_DONE = "RightDone";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/channel/mergeState.js
var MergeStateSymbolKey = "effect/ChannelMergeState";
var MergeStateTypeId = /* @__PURE__ */ Symbol.for(MergeStateSymbolKey);
var proto10 = {
  [MergeStateTypeId]: MergeStateTypeId
};
var BothRunning = (left3, right3) => {
  const op = Object.create(proto10);
  op._tag = OP_BOTH_RUNNING;
  op.left = left3;
  op.right = right3;
  return op;
};
var LeftDone = (f) => {
  const op = Object.create(proto10);
  op._tag = OP_LEFT_DONE;
  op.f = f;
  return op;
};
var RightDone = (f) => {
  const op = Object.create(proto10);
  op._tag = OP_RIGHT_DONE;
  op.f = f;
  return op;
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/opCodes/channelMergeStrategy.js
var OP_BACK_PRESSURE = "BackPressure";
var OP_BUFFER_SLIDING = "BufferSliding";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
var MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
var MergeStrategyTypeId = /* @__PURE__ */ Symbol.for(MergeStrategySymbolKey);
var proto11 = {
  [MergeStrategyTypeId]: MergeStrategyTypeId
};
var BackPressure = (_) => {
  const op = Object.create(proto11);
  op._tag = OP_BACK_PRESSURE;
  return op;
};
var BufferSliding = (_) => {
  const op = Object.create(proto11);
  op._tag = OP_BUFFER_SLIDING;
  return op;
};
var match16 = /* @__PURE__ */ dual(2, (self, {
  onBackPressure,
  onBufferSliding
}) => {
  switch (self._tag) {
    case OP_BACK_PRESSURE: {
      return onBackPressure();
    }
    case OP_BUFFER_SLIDING: {
      return onBufferSliding();
    }
  }
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/channel/singleProducerAsyncInput.js
var OP_STATE_EMPTY = "Empty";
var OP_STATE_EMIT = "Emit";
var OP_STATE_ERROR = "Error";
var OP_STATE_DONE2 = "Done";
var stateEmpty = (notifyProducer) => ({
  _tag: OP_STATE_EMPTY,
  notifyProducer
});
var stateEmit = (notifyConsumers) => ({
  _tag: OP_STATE_EMIT,
  notifyConsumers
});
var stateError = (cause3) => ({
  _tag: OP_STATE_ERROR,
  cause: cause3
});
var stateDone = (done12) => ({
  _tag: OP_STATE_DONE2,
  done: done12
});
var SingleProducerAsyncInputImpl = class {
  constructor(ref) {
    __publicField(this, "ref");
    this.ref = ref;
  }
  awaitRead() {
    return flatten9(modify6(this.ref, (state) => state._tag === OP_STATE_EMPTY ? [_await(state.notifyProducer), state] : [_void, state]));
  }
  get close() {
    return fiberIdWith2((fiberId3) => this.error(interrupt5(fiberId3)));
  }
  done(value3) {
    return flatten9(modify6(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach10(state.notifyConsumers, (deferred) => succeed2(deferred, left2(value3)), {
            discard: true
          }), stateDone(value3)];
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    }));
  }
  emit(element3) {
    return flatMap12(make23(), (deferred) => flatten9(modify6(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          const notifyConsumer = state.notifyConsumers[0];
          const notifyConsumers = state.notifyConsumers.slice(1);
          if (notifyConsumer !== void 0) {
            return [succeed2(notifyConsumer, right2(element3)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
          }
          throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues");
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    })));
  }
  error(cause3) {
    return flatten9(modify6(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach10(state.notifyConsumers, (deferred) => failCause2(deferred, cause3), {
            discard: true
          }), stateError(cause3)];
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    }));
  }
  get take() {
    return this.takeWith((cause3) => failCause4(map14(cause3, left2)), (elem) => succeed4(elem), (done12) => fail4(right2(done12)));
  }
  takeWith(onError5, onElement, onDone3) {
    return flatMap12(make23(), (deferred) => flatten9(modify6(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [zipRight6(succeed2(state.notifyProducer, void 0), matchCause4(_await(deferred), {
            onFailure: onError5,
            onSuccess: match({
              onLeft: onDone3,
              onRight: onElement
            })
          })), stateEmit([deferred])];
        }
        case OP_STATE_EMIT: {
          return [matchCause4(_await(deferred), {
            onFailure: onError5,
            onSuccess: match({
              onLeft: onDone3,
              onRight: onElement
            })
          }), stateEmit([...state.notifyConsumers, deferred])];
        }
        case OP_STATE_ERROR: {
          return [succeed10(onError5(state.cause)), state];
        }
        case OP_STATE_DONE2: {
          return [succeed10(onDone3(state.done)), state];
        }
      }
    })));
  }
};
var make45 = () => pipe(make23(), flatMap12((deferred) => make25(stateEmpty(deferred))), map18((ref) => new SingleProducerAsyncInputImpl(ref)));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/channel.js
var acquireUseRelease3 = (acquire, use, release) => flatMap14(fromEffect5(make25(() => _void)), (ref) => pipe(fromEffect5(uninterruptible2(tap4(acquire, (a) => set5(ref, (exit4) => release(a, exit4))))), flatMap14(use), ensuringWith((exit4) => flatMap12(get11(ref), (f) => f(exit4)))));
var as7 = /* @__PURE__ */ dual(2, (self, value3) => map20(self, () => value3));
var catchAll5 = /* @__PURE__ */ dual(2, (self, f) => catchAllCause5(self, (cause3) => match(failureOrCause2(cause3), {
  onLeft: f,
  onRight: failCause11
})));
var concatMap = /* @__PURE__ */ dual(2, (self, f) => concatMapWith(self, f, () => void 0, () => void 0));
var drain = (self) => {
  const drainer = readWithCause({
    onInput: () => drainer,
    onFailure: failCause11,
    onDone: succeed12
  });
  return pipeTo(self, drainer);
};
var ensuring4 = /* @__PURE__ */ dual(2, (self, finalizer3) => ensuringWith(self, () => finalizer3));
var flatten11 = (self) => flatMap14(self, identity);
var foldChannel = /* @__PURE__ */ dual(2, (self, options) => foldCauseChannel(self, {
  onFailure: (cause3) => {
    const either8 = failureOrCause2(cause3);
    switch (either8._tag) {
      case "Left": {
        return options.onFailure(either8.left);
      }
      case "Right": {
        return failCause11(either8.right);
      }
    }
  },
  onSuccess: options.onSuccess
}));
var fromInput = (input) => unwrap(input.takeWith(failCause11, (elem) => flatMap14(write(elem), () => fromInput(input)), succeed12));
var fromQueue = (queue) => suspend6(() => fromQueueInternal(queue));
var fromQueueInternal = (queue) => pipe(fromEffect5(take3(queue)), flatMap14(match({
  onLeft: match9({
    onFailure: failCause11,
    onSuccess: succeedNow
  }),
  onRight: (elem) => flatMap14(write(elem), () => fromQueueInternal(queue))
})));
var identityChannel = () => readWith({
  onInput: (input) => flatMap14(write(input), () => identityChannel()),
  onFailure: fail12,
  onDone: succeedNow
});
var interruptWhen = /* @__PURE__ */ dual(2, (self, effect4) => mergeWith2(self, {
  other: fromEffect5(effect4),
  onSelfDone: (selfDone) => Done3(suspend4(() => selfDone)),
  onOtherDone: (effectDone) => Done3(suspend4(() => effectDone))
}));
var interruptWhenDeferred = /* @__PURE__ */ dual(2, (self, deferred) => interruptWhen(self, _await(deferred)));
var map20 = /* @__PURE__ */ dual(2, (self, f) => flatMap14(self, (a) => sync7(() => f(a))));
var mapError5 = /* @__PURE__ */ dual(2, (self, f) => mapErrorCause3(self, map14(f)));
var mapErrorCause3 = /* @__PURE__ */ dual(2, (self, f) => catchAllCause5(self, (cause3) => failCause11(f(cause3))));
var mapOut = /* @__PURE__ */ dual(2, (self, f) => {
  const reader = readWith({
    onInput: (outElem) => flatMap14(write(f(outElem)), () => reader),
    onFailure: fail12,
    onDone: succeedNow
  });
  return pipeTo(self, reader);
});
var mapOutEffect = /* @__PURE__ */ dual(2, (self, f) => {
  const reader = readWithCause({
    onInput: (outElem) => pipe(fromEffect5(f(outElem)), flatMap14(write), flatMap14(() => reader)),
    onFailure: failCause11,
    onDone: succeedNow
  });
  return pipeTo(self, reader);
});
var mapOutEffectPar = /* @__PURE__ */ dual(3, (self, f, n) => unwrapScopedWith((scope5) => gen3(function* () {
  const input = yield* make45();
  const queueReader = fromInput(input);
  const queue = yield* bounded3(n);
  yield* addFinalizer2(scope5, shutdown2(queue));
  const errorSignal = yield* make23();
  const withPermits = n === Number.POSITIVE_INFINITY ? (_) => identity : (yield* makeSemaphore2(n)).withPermits;
  const pull = yield* queueReader.pipe(pipeTo(self), toPullIn(scope5));
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause3) => offer3(queue, failCause9(cause3)),
    onSuccess: match({
      onLeft: (outDone) => zipRight6(interruptible4(withPermits(n)(_void)), asVoid4(offer3(queue, succeed10(left2(outDone))))),
      onRight: (outElem) => gen3(function* () {
        const deferred = yield* make23();
        const latch = yield* make23();
        yield* offer3(queue, map18(_await(deferred), right2));
        yield* succeed2(latch, void 0).pipe(zipRight6(uninterruptibleMask3((restore) => exit3(restore(_await(errorSignal))).pipe(raceFirst2(exit3(restore(f(outElem)))), flatMap12(identity))).pipe(tapErrorCause3((cause3) => failCause2(errorSignal, cause3)), intoDeferred2(deferred))), withPermits(1), forkIn2(scope5));
        yield* _await(latch);
      })
    })
  }), forever3, interruptible4, forkIn2(scope5));
  const consumer = unwrap(matchCause4(flatten9(take3(queue)), {
    onFailure: failCause11,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap14(write(outElem), () => consumer)
    })
  }));
  return embedInput(consumer, input);
})));
var mergeAll7 = (options) => {
  return (channels) => mergeAllWith(options)(channels, constVoid);
};
var mergeAllWith = ({
  bufferSize = 16,
  concurrency,
  mergeStrategy = BackPressure()
}) => (channels, f) => unwrapScopedWith((scope5) => gen3(function* () {
  const concurrencyN = concurrency === "unbounded" ? Number.MAX_SAFE_INTEGER : concurrency;
  const input = yield* make45();
  const queueReader = fromInput(input);
  const queue = yield* bounded3(bufferSize);
  yield* addFinalizer2(scope5, shutdown2(queue));
  const cancelers = yield* unbounded3();
  yield* addFinalizer2(scope5, shutdown2(cancelers));
  const lastDone = yield* make25(none2());
  const errorSignal = yield* make23();
  const withPermits = (yield* makeSemaphore2(concurrencyN)).withPermits;
  const pull = yield* toPullIn(pipeTo(queueReader, channels), scope5);
  function evaluatePull(pull2) {
    return pull2.pipe(flatMap12(match({
      onLeft: (done12) => succeed10(some2(done12)),
      onRight: (outElem) => as6(offer3(queue, succeed10(right2(outElem))), none2())
    })), repeat({
      until: (_) => isSome2(_)
    }), flatMap12((outDone) => update3(lastDone, match2({
      onNone: () => some2(outDone.value),
      onSome: (lastDone2) => some2(f(lastDone2, outDone.value))
    }))), catchAllCause3((cause3) => isInterrupted2(cause3) ? failCause9(cause3) : offer3(queue, failCause9(cause3)).pipe(zipRight6(succeed2(errorSignal, void 0)), asVoid4)));
  }
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause3) => offer3(queue, failCause9(cause3)).pipe(zipRight6(succeed10(false))),
    onSuccess: match({
      onLeft: (outDone) => raceWith2(interruptible4(_await(errorSignal)), interruptible4(withPermits(concurrencyN)(_void)), {
        onSelfDone: (_, permitAcquisition) => as6(interrupt6(permitAcquisition), false),
        onOtherDone: (_, failureAwait) => zipRight6(interrupt6(failureAwait), get11(lastDone).pipe(flatMap12(match2({
          onNone: () => offer3(queue, succeed10(left2(outDone))),
          onSome: (lastDone2) => offer3(queue, succeed10(left2(f(lastDone2, outDone))))
        })), as6(false)))
      }),
      onRight: (channel) => match16(mergeStrategy, {
        onBackPressure: () => gen3(function* () {
          const latch = yield* make23();
          const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel), scope6).pipe(flatMap12((pull2) => race2(exit3(evaluatePull(pull2)), exit3(interruptible4(_await(errorSignal))))), flatMap12(identity)));
          yield* succeed2(latch, void 0).pipe(zipRight6(raceEffects), withPermits(1), forkIn2(scope5));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        }),
        onBufferSliding: () => gen3(function* () {
          const canceler = yield* make23();
          const latch = yield* make23();
          const size17 = yield* size13(cancelers);
          yield* take3(cancelers).pipe(flatMap12((canceler2) => succeed2(canceler2, void 0)), when2(() => size17 >= concurrencyN));
          yield* offer3(cancelers, canceler);
          const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel), scope6).pipe(flatMap12((pull2) => exit3(evaluatePull(pull2)).pipe(race2(exit3(interruptible4(_await(errorSignal)))), race2(exit3(interruptible4(_await(canceler)))))), flatMap12(identity)));
          yield* succeed2(latch, void 0).pipe(zipRight6(raceEffects), withPermits(1), forkIn2(scope5));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        })
      })
    })
  }), repeat({
    while: (_) => _
  }), forkIn2(scope5));
  const consumer = pipe(take3(queue), flatten9, matchCause4({
    onFailure: failCause11,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap14(write(outElem), () => consumer)
    })
  }), unwrap);
  return embedInput(consumer, input);
}));
var mergeMap = /* @__PURE__ */ dual(3, (self, f, options) => mergeAll7(options)(mapOut(self, f)));
var mergeWith2 = /* @__PURE__ */ dual(2, (self, options) => {
  function merge12(scope5) {
    return gen3(function* () {
      const input = yield* make45();
      const queueReader = fromInput(input);
      const pullL = yield* toPullIn(pipeTo(queueReader, self), scope5);
      const pullR = yield* toPullIn(pipeTo(queueReader, options.other), scope5);
      function handleSide(exit4, fiber, pull) {
        return (done12, both2, single2) => {
          function onDecision3(decision) {
            const op = decision;
            if (op._tag === OP_DONE4) {
              return succeed10(fromEffect5(zipRight6(interrupt6(fiber), op.effect)));
            }
            return map18(_await3(fiber), match9({
              onFailure: (cause3) => fromEffect5(op.f(failCause4(cause3))),
              onSuccess: match({
                onLeft: (done13) => fromEffect5(op.f(succeed4(done13))),
                onRight: (elem) => zipRight7(write(elem), go6(single2(op.f)))
              })
            }));
          }
          return match9(exit4, {
            onFailure: (cause3) => onDecision3(done12(failCause4(cause3))),
            onSuccess: match({
              onLeft: (z) => onDecision3(done12(succeed4(z))),
              onRight: (elem) => succeed10(flatMap14(write(elem), () => flatMap14(fromEffect5(forkIn2(interruptible4(pull), scope5)), (leftFiber) => go6(both2(leftFiber, fiber)))))
            })
          });
        };
      }
      function go6(state) {
        switch (state._tag) {
          case OP_BOTH_RUNNING: {
            const leftJoin = interruptible4(join4(state.left));
            const rightJoin = interruptible4(join4(state.right));
            return unwrap(raceWith2(leftJoin, rightJoin, {
              onSelfDone: (leftExit, rf) => zipRight6(interrupt6(rf), handleSide(leftExit, state.right, pullL)(options.onSelfDone, BothRunning, (f) => LeftDone(f))),
              onOtherDone: (rightExit, lf) => zipRight6(interrupt6(lf), handleSide(rightExit, state.left, pullR)(options.onOtherDone, (left3, right3) => BothRunning(right3, left3), (f) => RightDone(f)))
            }));
          }
          case OP_LEFT_DONE: {
            return unwrap(map18(exit3(pullR), match9({
              onFailure: (cause3) => fromEffect5(state.f(failCause4(cause3))),
              onSuccess: match({
                onLeft: (done12) => fromEffect5(state.f(succeed4(done12))),
                onRight: (elem) => flatMap14(write(elem), () => go6(LeftDone(state.f)))
              })
            })));
          }
          case OP_RIGHT_DONE: {
            return unwrap(map18(exit3(pullL), match9({
              onFailure: (cause3) => fromEffect5(state.f(failCause4(cause3))),
              onSuccess: match({
                onLeft: (done12) => fromEffect5(state.f(succeed4(done12))),
                onRight: (elem) => flatMap14(write(elem), () => go6(RightDone(state.f)))
              })
            })));
          }
        }
      }
      return fromEffect5(withFiberRuntime2((parent) => {
        const inherit = withFiberRuntime2((state) => {
          ;
          state.transferChildren(parent.scope());
          return _void;
        });
        const leftFiber = interruptible4(pullL).pipe(ensuring3(inherit), forkIn2(scope5));
        const rightFiber = interruptible4(pullR).pipe(ensuring3(inherit), forkIn2(scope5));
        return zipWith9(leftFiber, rightFiber, (left3, right3) => BothRunning(left3, right3));
      })).pipe(flatMap14(go6), embedInput(input));
    });
  }
  return unwrapScopedWith(merge12);
});
var orDieWith3 = /* @__PURE__ */ dual(2, (self, f) => catchAll5(self, (e) => failCauseSync5(() => die4(f(e)))));
var orElse8 = /* @__PURE__ */ dual(2, (self, that) => catchAll5(self, that));
var pipeToOrFail = /* @__PURE__ */ dual(2, (self, that) => suspend6(() => {
  let channelException = void 0;
  const reader = readWith({
    onInput: (outElem) => flatMap14(write(outElem), () => reader),
    onFailure: (outErr) => {
      channelException = ChannelException(outErr);
      return failCause11(die4(channelException));
    },
    onDone: succeedNow
  });
  const writer = readWithCause({
    onInput: (outElem) => pipe(write(outElem), flatMap14(() => writer)),
    onFailure: (cause3) => isDieType2(cause3) && isChannelException(cause3.defect) && equals(cause3.defect, channelException) ? fail12(cause3.defect.error) : failCause11(cause3),
    onDone: succeedNow
  });
  return pipeTo(pipeTo(pipeTo(self, reader), that), writer);
}));
var repeated = (self) => flatMap14(self, () => repeated(self));
var run2 = (self) => scopedWith2((scope5) => runIn(self, scope5));
var runDrain = (self) => run2(drain(self));
var runScoped = (self) => scopeWith2((scope5) => runIn(self, scope5));
var scoped5 = (effect4) => unwrap(uninterruptibleMask3((restore) => map18(make38(), (scope5) => acquireReleaseOut(tapErrorCause3(restore(extend2(effect4, scope5)), (cause3) => close(scope5, failCause4(cause3))), (_, exit4) => close(scope5, exit4)))));
var scopedWith3 = (f) => unwrapScoped3(map18(scope3, (scope5) => flatMap14(fromEffect5(f(scope5)), write)));
var splitLines = () => suspend6(() => {
  let stringBuilder = "";
  let midCRLF = false;
  const splitLinesChunk = (chunk4) => {
    const chunkBuilder = [];
    map4(chunk4, (str) => {
      if (str.length !== 0) {
        let from = 0;
        let indexOfCR = str.indexOf("\r");
        let indexOfLF = str.indexOf("\n");
        if (midCRLF) {
          if (indexOfLF === 0) {
            chunkBuilder.push(stringBuilder);
            stringBuilder = "";
            from = 1;
            indexOfLF = str.indexOf("\n", from);
          } else {
            stringBuilder = stringBuilder + "\r";
          }
          midCRLF = false;
        }
        while (indexOfCR !== -1 || indexOfLF !== -1) {
          if (indexOfCR === -1 || indexOfLF !== -1 && indexOfLF < indexOfCR) {
            if (stringBuilder.length === 0) {
              chunkBuilder.push(str.substring(from, indexOfLF));
            } else {
              chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF));
              stringBuilder = "";
            }
            from = indexOfLF + 1;
            indexOfLF = str.indexOf("\n", from);
          } else {
            if (str.length === indexOfCR + 1) {
              midCRLF = true;
              indexOfCR = -1;
            } else {
              if (indexOfLF === indexOfCR + 1) {
                if (stringBuilder.length === 0) {
                  chunkBuilder.push(str.substring(from, indexOfCR));
                } else {
                  stringBuilder = stringBuilder + str.substring(from, indexOfCR);
                  chunkBuilder.push(stringBuilder);
                  stringBuilder = "";
                }
                from = indexOfCR + 2;
                indexOfCR = str.indexOf("\r", from);
                indexOfLF = str.indexOf("\n", from);
              } else {
                indexOfCR = str.indexOf("\r", indexOfCR + 1);
              }
            }
          }
        }
        if (midCRLF) {
          stringBuilder = stringBuilder + str.substring(from, str.length - 1);
        } else {
          stringBuilder = stringBuilder + str.substring(from, str.length);
        }
      }
    });
    return unsafeFromArray(chunkBuilder);
  };
  const loop3 = readWithCause({
    onInput: (input) => {
      const out = splitLinesChunk(input);
      return isEmpty(out) ? loop3 : flatMap14(write(out), () => loop3);
    },
    onFailure: (cause3) => stringBuilder.length === 0 ? failCause11(cause3) : flatMap14(write(of2(stringBuilder)), () => failCause11(cause3)),
    onDone: (done12) => stringBuilder.length === 0 ? succeed12(done12) : flatMap14(write(of2(stringBuilder)), () => succeed12(done12))
  });
  return loop3;
});
var toPubSub = (pubsub) => toQueue(pubsub);
var toPull = (self) => flatMap12(scope3, (scope5) => toPullIn(self, scope5));
var toPullIn = /* @__PURE__ */ dual(2, (self, scope5) => zip7(sync5(() => new ChannelExecutor(self, void 0, identity)), runtime4()).pipe(tap4(([executor, runtime5]) => addFinalizerExit(scope5, (exit4) => {
  const finalizer3 = executor.close(exit4);
  return finalizer3 !== void 0 ? provide2(finalizer3, runtime5) : _void;
})), uninterruptible2, map18(([executor]) => suspend4(() => interpretToPull(executor.run(), executor)))));
var interpretToPull = (channelState, exec) => {
  const state = channelState;
  switch (state._tag) {
    case OP_DONE3: {
      return match9(exec.getDone(), {
        onFailure: failCause9,
        onSuccess: (done12) => succeed10(left2(done12))
      });
    }
    case OP_EMIT2: {
      return succeed10(right2(exec.getEmit()));
    }
    case OP_FROM_EFFECT3: {
      return pipe(state.effect, flatMap12(() => interpretToPull(exec.run(), exec)));
    }
    case OP_READ2: {
      return readUpstream(state, () => interpretToPull(exec.run(), exec), (cause3) => failCause9(cause3));
    }
  }
};
var toQueue = (queue) => suspend6(() => toQueueInternal(queue));
var toQueueInternal = (queue) => {
  return readWithCause({
    onInput: (elem) => flatMap14(fromEffect5(offer3(queue, right2(elem))), () => toQueueInternal(queue)),
    onFailure: (cause3) => fromEffect5(pipe(offer3(queue, left2(failCause4(cause3))))),
    onDone: (done12) => fromEffect5(pipe(offer3(queue, left2(succeed4(done12)))))
  });
};
var unwrap = (channel) => flatten11(fromEffect5(channel));
var unwrapScoped3 = (self) => concatAllWith(scoped5(self), (d, _) => d, (d, _) => d);
var unwrapScopedWith = (f) => concatAllWith(scopedWith3(f), (d, _) => d, (d, _) => d);
var withSpan5 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  const acquire = all7([makeSpan2(name, options), context3(), clock2, get13(currentTracerTimingEnabled2)]);
  if (dataFirst) {
    const self = arguments[0];
    return acquireUseRelease3(acquire, ([span4, context9]) => provideContext4(self, add2(context9, spanTag, span4)), ([span4, , clock3, timingEnabled], exit4) => endSpan(span4, exit4, clock3, timingEnabled));
  }
  return (self) => acquireUseRelease3(acquire, ([span4, context9]) => provideContext4(self, add2(context9, spanTag, span4)), ([span4, , clock3, timingEnabled], exit4) => endSpan(span4, exit4, clock3, timingEnabled));
};
var writeAll = (...outs) => writeChunk(fromIterable3(outs));
var writeChunk = (outs) => writeChunkWriter(0, outs.length, outs);
var writeChunkWriter = (idx, len, chunk4) => {
  return idx === len ? void_7 : pipe(write(pipe(chunk4, unsafeGet4(idx))), flatMap14(() => writeChunkWriter(idx + 1, len, chunk4)));
};
var zip8 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self, that, options) => options?.concurrent ? mergeWith2(self, {
  other: that,
  onSelfDone: (exit1) => Await((exit22) => suspend4(() => zip4(exit1, exit22))),
  onOtherDone: (exit22) => Await((exit1) => suspend4(() => zip4(exit1, exit22)))
}) : flatMap14(self, (a) => map20(that, (b) => [a, b])));
var zipLeft6 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self, that, options) => options?.concurrent ? map20(zip8(self, that, {
  concurrent: true
}), (tuple4) => tuple4[0]) : flatMap14(self, (z) => as7(that, z)));
var zipRight7 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self, that, options) => options?.concurrent ? map20(zip8(self, that, {
  concurrent: true
}), (tuple4) => tuple4[1]) : flatMap14(self, () => that));
var ChannelExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Channel/ChannelException");
var ChannelException = (error2) => ({
  _tag: "ChannelException",
  [ChannelExceptionTypeId]: ChannelExceptionTypeId,
  error: error2
});
var isChannelException = (u) => hasProperty(u, ChannelExceptionTypeId);

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/MergeDecision.js
var Done4 = Done3;
var Await2 = Await;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/rcRef.js
var TypeId19 = /* @__PURE__ */ Symbol.for("effect/RcRef");
var stateEmpty2 = {
  _tag: "Empty"
};
var stateClosed = {
  _tag: "Closed"
};
var variance5 = {
  _A: identity,
  _E: identity
};
var _a63, _b20, _c4;
var RcRefImpl = class extends (_c4 = Class2, _b20 = TypeId19, _a63 = TypeId11, _c4) {
  constructor(acquire, context9, scope5, idleTimeToLive) {
    super();
    __publicField(this, "acquire");
    __publicField(this, "context");
    __publicField(this, "scope");
    __publicField(this, "idleTimeToLive");
    __publicField(this, _b20, variance5);
    __publicField(this, _a63, TypeId11);
    __publicField(this, "state", stateEmpty2);
    __publicField(this, "semaphore", /* @__PURE__ */ unsafeMakeSemaphore(1));
    __publicField(this, "get");
    this.acquire = acquire;
    this.context = context9;
    this.scope = scope5;
    this.idleTimeToLive = idleTimeToLive;
    this.get = get14(this);
  }
  commit() {
    return this.get;
  }
};
var make46 = (options) => withFiberRuntime((fiber) => {
  const context9 = fiber.getFiberRef(currentContext);
  const scope5 = get2(context9, scopeTag);
  const ref = new RcRefImpl(options.acquire, context9, scope5, options.idleTimeToLive ? decode(options.idleTimeToLive) : void 0);
  return as2(scope5.addFinalizer(() => ref.semaphore.withPermits(1)(suspend(() => {
    const close2 = ref.state._tag === "Acquired" ? scopeClose(ref.state.scope, exitVoid) : void_2;
    ref.state = stateClosed;
    return close2;
  }))), ref);
});
var get14 = (self_) => {
  const self = self_;
  return uninterruptibleMask((restore) => suspend(() => {
    switch (self.state._tag) {
      case "Closed": {
        return interrupt2;
      }
      case "Acquired": {
        self.state.refCount++;
        return self.state.fiber ? as2(interruptFiber(self.state.fiber), self.state) : succeed(self.state);
      }
      case "Empty": {
        return scopeMake().pipe(bindTo3("scope"), bind3("value", ({
          scope: scope5
        }) => restore(fiberRefLocally(self.acquire, currentContext, add2(self.context, scopeTag, scope5)))), map10(({
          scope: scope5,
          value: value3
        }) => {
          const state = {
            _tag: "Acquired",
            value: value3,
            scope: scope5,
            fiber: void 0,
            refCount: 1
          };
          self.state = state;
          return state;
        }));
      }
    }
  })).pipe(self.semaphore.withPermits(1), bindTo3("state"), bind3("scope", () => scopeTag), tap2(({
    scope: scope5,
    state
  }) => scope5.addFinalizer(() => suspend(() => {
    state.refCount--;
    if (state.refCount > 0) {
      return void_2;
    }
    if (self.idleTimeToLive === void 0) {
      self.state = stateEmpty2;
      return scopeClose(state.scope, exitVoid);
    }
    return sleep3(self.idleTimeToLive).pipe(interruptible2, zipRight2(suspend(() => {
      if (self.state._tag === "Acquired" && self.state.refCount === 0) {
        self.state = stateEmpty2;
        return scopeClose(state.scope, exitVoid);
      }
      return void_2;
    })), ensuring(sync(() => {
      state.fiber = void 0;
    })), forkIn(self.scope), tap2((fiber) => {
      state.fiber = fiber;
    }), self.semaphore.withPermits(1));
  }))), map10(({
    state
  }) => state.value));
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/RcRef.js
var make47 = make46;
var get15 = get14;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Runtime.js
var runFork3 = unsafeFork3;
var runPromiseExit2 = unsafeRunPromiseExit;
var defaultRuntime2 = defaultRuntime;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Schedule.js
var Schedule_exports = {};
__export(Schedule_exports, {
  CurrentIterationMetadata: () => CurrentIterationMetadata2,
  ScheduleDriverTypeId: () => ScheduleDriverTypeId2,
  ScheduleTypeId: () => ScheduleTypeId2,
  addDelay: () => addDelay2,
  addDelayEffect: () => addDelayEffect2,
  andThen: () => andThen7,
  andThenEither: () => andThenEither2,
  as: () => as8,
  asVoid: () => asVoid5,
  bothInOut: () => bothInOut2,
  check: () => check2,
  checkEffect: () => checkEffect2,
  collectAllInputs: () => collectAllInputs2,
  collectAllOutputs: () => collectAllOutputs2,
  collectUntil: () => collectUntil2,
  collectUntilEffect: () => collectUntilEffect2,
  collectWhile: () => collectWhile2,
  collectWhileEffect: () => collectWhileEffect2,
  compose: () => compose2,
  count: () => count2,
  cron: () => cron2,
  dayOfMonth: () => dayOfMonth2,
  dayOfWeek: () => dayOfWeek2,
  delayed: () => delayed2,
  delayedEffect: () => delayedEffect2,
  delayedSchedule: () => delayedSchedule2,
  delays: () => delays2,
  driver: () => driver2,
  duration: () => duration2,
  either: () => either5,
  eitherWith: () => eitherWith2,
  elapsed: () => elapsed2,
  ensuring: () => ensuring5,
  exponential: () => exponential3,
  fibonacci: () => fibonacci2,
  fixed: () => fixed2,
  forever: () => forever4,
  fromDelay: () => fromDelay2,
  fromDelays: () => fromDelays2,
  fromFunction: () => fromFunction4,
  hourOfDay: () => hourOfDay2,
  identity: () => identity3,
  intersect: () => intersect6,
  intersectWith: () => intersectWith2,
  isSchedule: () => isSchedule2,
  jittered: () => jittered2,
  jitteredWith: () => jitteredWith2,
  linear: () => linear2,
  makeWithState: () => makeWithState2,
  map: () => map21,
  mapBoth: () => mapBoth6,
  mapBothEffect: () => mapBothEffect2,
  mapEffect: () => mapEffect4,
  mapInput: () => mapInput4,
  mapInputContext: () => mapInputContext4,
  mapInputEffect: () => mapInputEffect2,
  minuteOfHour: () => minuteOfHour2,
  modifyDelay: () => modifyDelay2,
  modifyDelayEffect: () => modifyDelayEffect2,
  onDecision: () => onDecision2,
  once: () => once4,
  passthrough: () => passthrough4,
  provideContext: () => provideContext5,
  provideService: () => provideService5,
  recurUntil: () => recurUntil2,
  recurUntilEffect: () => recurUntilEffect2,
  recurUntilOption: () => recurUntilOption2,
  recurUpTo: () => recurUpTo2,
  recurWhile: () => recurWhile2,
  recurWhileEffect: () => recurWhileEffect2,
  recurs: () => recurs2,
  reduce: () => reduce13,
  reduceEffect: () => reduceEffect4,
  repeatForever: () => repeatForever,
  repetitions: () => repetitions2,
  resetAfter: () => resetAfter2,
  resetWhen: () => resetWhen2,
  run: () => run3,
  secondOfMinute: () => secondOfMinute2,
  spaced: () => spaced2,
  stop: () => stop2,
  succeed: () => succeed13,
  sync: () => sync8,
  tapInput: () => tapInput2,
  tapOutput: () => tapOutput2,
  unfold: () => unfold3,
  union: () => union11,
  unionWith: () => unionWith3,
  untilInput: () => untilInput2,
  untilInputEffect: () => untilInputEffect2,
  untilOutput: () => untilOutput2,
  untilOutputEffect: () => untilOutputEffect2,
  upTo: () => upTo2,
  whileInput: () => whileInput2,
  whileInputEffect: () => whileInputEffect2,
  whileOutput: () => whileOutput2,
  whileOutputEffect: () => whileOutputEffect2,
  windowed: () => windowed2,
  zipLeft: () => zipLeft7,
  zipRight: () => zipRight8,
  zipWith: () => zipWith11
});
var ScheduleTypeId2 = ScheduleTypeId;
var ScheduleDriverTypeId2 = ScheduleDriverTypeId;
var makeWithState2 = makeWithState;
var isSchedule2 = isSchedule;
var addDelay2 = addDelay;
var addDelayEffect2 = addDelayEffect;
var andThen7 = andThen5;
var andThenEither2 = andThenEither;
var as8 = as5;
var asVoid5 = asVoid3;
var bothInOut2 = bothInOut;
var check2 = check;
var checkEffect2 = checkEffect;
var collectAllInputs2 = collectAllInputs;
var collectAllOutputs2 = collectAllOutputs;
var collectUntil2 = collectUntil;
var collectUntilEffect2 = collectUntilEffect;
var collectWhile2 = collectWhile;
var collectWhileEffect2 = collectWhileEffect;
var compose2 = compose;
var mapInput4 = mapInput3;
var mapInputEffect2 = mapInputEffect;
var mapInputContext4 = mapInputContext2;
var count2 = count;
var cron2 = cron;
var secondOfMinute2 = secondOfMinute;
var minuteOfHour2 = minuteOfHour;
var hourOfDay2 = hourOfDay;
var dayOfMonth2 = dayOfMonth;
var dayOfWeek2 = dayOfWeek;
var delayed2 = delayed;
var delayedEffect2 = delayedEffect;
var delayedSchedule2 = delayedSchedule;
var delays2 = delays;
var mapBoth6 = mapBoth4;
var mapBothEffect2 = mapBothEffect;
var driver2 = driver;
var duration2 = duration;
var either5 = either3;
var eitherWith2 = eitherWith;
var elapsed2 = elapsed;
var ensuring5 = ensuring2;
var exponential3 = exponential2;
var fibonacci2 = fibonacci;
var fixed2 = fixed;
var forever4 = forever2;
var fromDelay2 = fromDelay;
var fromDelays2 = fromDelays;
var fromFunction4 = fromFunction2;
var identity3 = identity2;
var passthrough4 = passthrough2;
var intersect6 = intersect5;
var intersectWith2 = intersectWith;
var jittered2 = jittered;
var jitteredWith2 = jitteredWith;
var linear2 = linear;
var map21 = map17;
var mapEffect4 = mapEffect3;
var modifyDelay2 = modifyDelay;
var modifyDelayEffect2 = modifyDelayEffect;
var onDecision2 = onDecision;
var once4 = once2;
var provideContext5 = provideContext3;
var provideService5 = provideService2;
var recurUntil2 = recurUntil;
var recurUntilEffect2 = recurUntilEffect;
var recurUntilOption2 = recurUntilOption;
var recurUpTo2 = recurUpTo;
var recurWhile2 = recurWhile;
var recurWhileEffect2 = recurWhileEffect;
var recurs2 = recurs;
var reduce13 = reduce11;
var reduceEffect4 = reduceEffect2;
var repeatForever = forever2;
var repetitions2 = repetitions;
var resetAfter2 = resetAfter;
var resetWhen2 = resetWhen;
var run3 = run;
var spaced2 = spaced;
var stop2 = stop;
var succeed13 = succeed8;
var sync8 = sync4;
var tapInput2 = tapInput;
var tapOutput2 = tapOutput;
var unfold3 = unfold2;
var union11 = union10;
var unionWith3 = unionWith2;
var untilInput2 = untilInput;
var untilInputEffect2 = untilInputEffect;
var untilOutput2 = untilOutput;
var untilOutputEffect2 = untilOutputEffect;
var upTo2 = upTo;
var whileInput2 = whileInput;
var whileInputEffect2 = whileInputEffect;
var whileOutput2 = whileOutput;
var whileOutputEffect2 = whileOutputEffect;
var windowed2 = windowed;
var zipLeft7 = zipLeft4;
var zipRight8 = zipRight5;
var zipWith11 = zipWith8;
var CurrentIterationMetadata2 = CurrentIterationMetadata;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/opCodes/streamHaltStrategy.js
var OP_LEFT = "Left";
var OP_RIGHT = "Right";
var OP_BOTH = "Both";
var OP_EITHER = "Either";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stream/haltStrategy.js
var Left = {
  _tag: OP_LEFT
};
var Right = {
  _tag: OP_RIGHT
};
var Both = {
  _tag: OP_BOTH
};
var Either = {
  _tag: OP_EITHER
};
var fromInput2 = (input) => {
  switch (input) {
    case "left":
      return Left;
    case "right":
      return Right;
    case "both":
      return Both;
    case "either":
      return Either;
    default:
      return input;
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/StreamHaltStrategy.js
var Both2 = Both;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/sink.js
var SinkTypeId2 = /* @__PURE__ */ Symbol.for("effect/Sink");
var sinkVariance2 = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _In: (_) => _,
  /* c8 ignore next */
  _L: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var _a64;
_a64 = SinkTypeId2;
var SinkImpl = class {
  constructor(channel) {
    __publicField(this, "channel");
    __publicField(this, _a64, sinkVariance2);
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isSink = (u) => hasProperty(u, SinkTypeId2);
var suspend7 = (evaluate3) => new SinkImpl(suspend6(() => toChannel(evaluate3())));
var collectAll = () => new SinkImpl(collectAllLoop(empty5()));
var collectAllLoop = (acc) => readWithCause({
  onInput: (chunk4) => collectAllLoop(pipe(acc, appendAll2(chunk4))),
  onFailure: failCause11,
  onDone: () => succeed12(acc)
});
var collectAllN = (n) => suspend7(() => fromChannel(collectAllNLoop(n, empty5())));
var collectAllNLoop = (n, acc) => readWithCause({
  onInput: (chunk4) => {
    const [collected, leftovers] = splitAt2(chunk4, n);
    if (collected.length < n) {
      return collectAllNLoop(n - collected.length, appendAll2(acc, collected));
    }
    if (isEmpty(leftovers)) {
      return succeed12(appendAll2(acc, collected));
    }
    return flatMap14(write(leftovers), () => succeed12(appendAll2(acc, collected)));
  },
  onFailure: failCause11,
  onDone: () => succeed12(acc)
});
var collectLeftover = (self) => new SinkImpl(pipe(collectElements(toChannel(self)), map20(([chunks3, z]) => [z, flatten3(chunks3)])));
var drain2 = /* @__PURE__ */ new SinkImpl(/* @__PURE__ */ drain(/* @__PURE__ */ identityChannel()));
var fail13 = (e) => new SinkImpl(fail12(e));
var fold = (s, contFn, f) => suspend7(() => new SinkImpl(foldReader(s, contFn, f)));
var foldReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => {
      const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f, 0, input.length);
      if (isNonEmpty(leftovers)) {
        return pipe(write(leftovers), as7(nextS));
      }
      return foldReader(nextS, contFn, f);
    },
    onFailure: fail12,
    onDone: () => succeedNow(s)
  });
};
var foldChunkSplit = (s, chunk4, contFn, f, index, length5) => {
  if (index === length5) {
    return [s, empty5()];
  }
  const s1 = f(s, pipe(chunk4, unsafeGet4(index)));
  if (contFn(s1)) {
    return foldChunkSplit(s1, chunk4, contFn, f, index + 1, length5);
  }
  return [s1, pipe(chunk4, drop2(index + 1))];
};
var foldSink = /* @__PURE__ */ dual(2, (self, options) => {
  const newChannel = pipe(toChannel(self), collectElements, foldChannel({
    onFailure: (error2) => toChannel(options.onFailure(error2)),
    onSuccess: ([leftovers, z]) => suspend6(() => {
      const leftoversRef = {
        ref: pipe(leftovers, filter3(isNonEmpty))
      };
      const refReader = pipe(
        sync7(() => {
          const ref = leftoversRef.ref;
          leftoversRef.ref = empty5();
          return ref;
        }),
        // This cast is safe because of the L1 >: L <: In1 bound. It follows that
        // L <: In1 and therefore Chunk[L] can be safely cast to Chunk[In1].
        flatMap14((chunk4) => writeChunk(chunk4))
      );
      const passthrough5 = identityChannel();
      const continuationSink = pipe(refReader, zipRight7(passthrough5), pipeTo(toChannel(options.onSuccess(z))));
      return flatMap14(collectElements(continuationSink), ([newLeftovers, z1]) => pipe(succeed12(leftoversRef.ref), flatMap14(writeChunk), zipRight7(writeChunk(newLeftovers)), as7(z1)));
    })
  }));
  return new SinkImpl(newChannel);
});
var foldChunks = (s, contFn, f) => suspend7(() => new SinkImpl(foldChunksReader(s, contFn, f)));
var foldChunksReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => foldChunksReader(f(s, input), contFn, f),
    onFailure: fail12,
    onDone: () => succeedNow(s)
  });
};
var foldEffect = (s, contFn, f) => suspend7(() => new SinkImpl(foldEffectReader(s, contFn, f)));
var foldEffectReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => pipe(fromEffect5(foldChunkSplitEffect(s, input, contFn, f)), flatMap14(([nextS, leftovers]) => pipe(leftovers, match2({
      onNone: () => foldEffectReader(nextS, contFn, f),
      onSome: (leftover2) => pipe(write(leftover2), as7(nextS))
    })))),
    onFailure: fail12,
    onDone: () => succeedNow(s)
  });
};
var foldChunkSplitEffect = (s, chunk4, contFn, f) => foldChunkSplitEffectInternal(s, chunk4, 0, chunk4.length, contFn, f);
var foldChunkSplitEffectInternal = (s, chunk4, index, length5, contFn, f) => {
  if (index === length5) {
    return succeed10([s, none2()]);
  }
  return pipe(f(s, pipe(chunk4, unsafeGet4(index))), flatMap12((s1) => contFn(s1) ? foldChunkSplitEffectInternal(s1, chunk4, index + 1, length5, contFn, f) : succeed10([s1, some2(pipe(chunk4, drop2(index + 1)))])));
};
var foldLeftChunks = (s, f) => foldChunks(s, constTrue, f);
var flatMap15 = /* @__PURE__ */ dual(2, (self, f) => foldSink(self, {
  onFailure: fail13,
  onSuccess: f
}));
var forEach11 = (f) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect5(forEach10(input, (v) => f(v), {
      discard: true
    })), flatMap14(() => process2)),
    onFailure: failCause11,
    onDone: () => void_7
  });
  return new SinkImpl(process2);
};
var forEachChunk = (f) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect5(f(input)), flatMap14(() => process2)),
    onFailure: failCause11,
    onDone: () => void_7
  });
  return new SinkImpl(process2);
};
var forEachWhile = (f) => {
  const process2 = readWithCause({
    onInput: (input) => forEachWhileReader(f, input, 0, input.length, process2),
    onFailure: failCause11,
    onDone: () => void_7
  });
  return new SinkImpl(process2);
};
var forEachWhileReader = (f, input, index, length5, cont) => {
  if (index === length5) {
    return cont;
  }
  return pipe(fromEffect5(f(pipe(input, unsafeGet4(index)))), flatMap14((bool2) => bool2 ? forEachWhileReader(f, input, index + 1, length5, cont) : write(pipe(input, drop2(index)))), catchAll5((error2) => pipe(write(pipe(input, drop2(index))), zipRight7(fail12(error2)))));
};
var fromChannel = (channel) => new SinkImpl(channel);
var fromEffect7 = (effect4) => new SinkImpl(fromEffect5(effect4));
var head5 = () => fold(none2(), isNone2, (option5, input) => match2(option5, {
  onNone: () => some2(input),
  onSome: () => option5
}));
var last4 = () => foldLeftChunks(none2(), (s, input) => orElse(last2(input), () => s));
var map22 = /* @__PURE__ */ dual(2, (self, f) => {
  return new SinkImpl(pipe(toChannel(self), map20(f)));
});
var raceWith3 = /* @__PURE__ */ dual(2, (self, options) => {
  function race6(scope5) {
    return gen3(function* () {
      const pubsub = yield* bounded5(options?.capacity ?? 16);
      const subscription1 = yield* extend2(subscribe2(pubsub), scope5);
      const subscription2 = yield* extend2(subscribe2(pubsub), scope5);
      const reader = toPubSub(pubsub);
      const writer = fromQueue(subscription1).pipe(pipeTo(toChannel(self)), zipLeft6(fromEffect5(shutdown2(subscription1))), mergeWith2({
        other: fromQueue(subscription2).pipe(pipeTo(toChannel(options.other)), zipLeft6(fromEffect5(shutdown2(subscription2)))),
        onSelfDone: options.onSelfDone,
        onOtherDone: options.onOtherDone
      }));
      const racedChannel = mergeWith2(reader, {
        other: writer,
        onSelfDone: () => Await(identity),
        onOtherDone: (exit4) => Done3(exit4)
      });
      return new SinkImpl(racedChannel);
    });
  }
  return unwrapScopedWith2(race6);
});
var sum2 = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk4) => acc + reduce2(chunk4, 0, (s, a) => s + a));
var toChannel = (self) => isEffect2(self) ? toChannel(fromEffect7(self)) : self.channel;
var unwrapScopedWith2 = (f) => new SinkImpl(unwrapScopedWith((scope5) => f(scope5).pipe(map18((sink) => toChannel(sink)))));
var zipRight9 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self, that, options) => zipWith12(self, that, (_, z2) => z2, options));
var zipWith12 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self, that, f, options) => options?.concurrent ? raceWith3(self, {
  other: that,
  onSelfDone: match9({
    onFailure: (cause3) => Done3(failCause9(cause3)),
    onSuccess: (leftZ) => Await(match9({
      onFailure: failCause9,
      onSuccess: (rightZ) => succeed10(f(leftZ, rightZ))
    }))
  }),
  onOtherDone: match9({
    onFailure: (cause3) => Done3(failCause9(cause3)),
    onSuccess: (rightZ) => Await(match9({
      onFailure: failCause9,
      onSuccess: (leftZ) => succeed10(f(leftZ, rightZ))
    }))
  })
}) : flatMap15(self, (z) => map22(that, (z2) => f(z, z2))));
var count3 = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk4) => acc + chunk4.length);
var mkString = /* @__PURE__ */ suspend7(() => {
  const strings = [];
  return pipe(foldLeftChunks(void 0, (_, elems) => map4(elems, (elem) => {
    strings.push(String(elem));
  })), map22(() => strings.join("")));
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stm/versioned.js
var Versioned = class {
  constructor(value3) {
    __publicField(this, "value");
    this.value = value3;
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stm/entry.js
var make48 = (ref, isNew) => ({
  ref,
  isNew,
  isChanged: false,
  expected: ref.versioned,
  newValue: ref.versioned.value
});
var unsafeGet7 = (self) => {
  return self.newValue;
};
var unsafeSet = (self, value3) => {
  self.isChanged = true;
  self.newValue = value3;
};
var commit = (self) => {
  self.ref.versioned = new Versioned(self.newValue);
};
var isInvalid = (self) => {
  return self.ref.versioned !== self.expected;
};
var isChanged = (self) => {
  return self.isChanged;
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stm/journal.js
var JournalAnalysisInvalid = "Invalid";
var JournalAnalysisReadWrite = "ReadWrite";
var JournalAnalysisReadOnly = "ReadOnly";
var commitJournal = (journal) => {
  for (const entry of journal) {
    commit(entry[1]);
  }
};
var analyzeJournal = (journal) => {
  let val = JournalAnalysisReadOnly;
  for (const [, entry] of journal) {
    val = isInvalid(entry) ? JournalAnalysisInvalid : isChanged(entry) ? JournalAnalysisReadWrite : val;
    if (val === JournalAnalysisInvalid) {
      return val;
    }
  }
  return val;
};
var collectTodos = (journal) => {
  const allTodos = /* @__PURE__ */ new Map();
  for (const [, entry] of journal) {
    for (const todo of entry.ref.todos) {
      allTodos.set(todo[0], todo[1]);
    }
    entry.ref.todos = /* @__PURE__ */ new Map();
  }
  return allTodos;
};
var execTodos = (todos) => {
  const todosSorted = Array.from(todos.entries()).sort((x, y) => x[0] - y[0]);
  for (const [_, todo] of todosSorted) {
    todo();
  }
};
var addTodo = (txnId, journal, todoEffect) => {
  let added = false;
  for (const [, entry] of journal) {
    if (!entry.ref.todos.has(txnId)) {
      entry.ref.todos.set(txnId, todoEffect);
      added = true;
    }
  }
  return added;
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stm/opCodes/stm.js
var OP_WITH_STM_RUNTIME = "WithSTMRuntime";
var OP_ON_FAILURE2 = "OnFailure";
var OP_ON_RETRY = "OnRetry";
var OP_ON_SUCCESS2 = "OnSuccess";
var OP_PROVIDE3 = "Provide";
var OP_SYNC2 = "Sync";
var OP_SUCCEED2 = "Succeed";
var OP_RETRY = "Retry";
var OP_FAIL4 = "Fail";
var OP_DIE2 = "Die";
var OP_INTERRUPT2 = "Interrupt";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stm/opCodes/tExit.js
var OP_FAIL5 = "Fail";
var OP_DIE3 = "Die";
var OP_INTERRUPT3 = "Interrupt";
var OP_SUCCEED3 = "Succeed";
var OP_RETRY2 = "Retry";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stm/opCodes/tryCommit.js
var OP_DONE5 = "Done";
var OP_SUSPEND3 = "Suspend";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stm/opCodes/stmState.js
var OP_DONE6 = "Done";
var OP_INTERRUPTED = "Interrupted";
var OP_RUNNING2 = "Running";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stm/stmState.js
var STMStateSymbolKey = "effect/STM/State";
var STMStateTypeId = /* @__PURE__ */ Symbol.for(STMStateSymbolKey);
var isSTMState = (u) => hasProperty(u, STMStateTypeId);
var isRunning3 = (self) => {
  return self._tag === OP_RUNNING2;
};
var isDone6 = (self) => {
  return self._tag === OP_DONE6;
};
var done9 = (exit4) => {
  return {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_DONE6,
    exit: exit4,
    [symbol]() {
      return pipe(hash(STMStateSymbolKey), combine(hash(OP_DONE6)), combine(hash(exit4)), cached(this));
    },
    [symbol2](that) {
      return isSTMState(that) && that._tag === OP_DONE6 && equals(exit4, that.exit);
    }
  };
};
var interruptedHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_INTERRUPTED)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("interrupted")));
var interrupted3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_INTERRUPTED,
  [symbol]() {
    return interruptedHash;
  },
  [symbol2](that) {
    return isSTMState(that) && that._tag === OP_INTERRUPTED;
  }
};
var runningHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RUNNING2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("running")));
var running3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_RUNNING2,
  [symbol]() {
    return runningHash;
  },
  [symbol2](that) {
    return isSTMState(that) && that._tag === OP_RUNNING2;
  }
};
var fromTExit = (tExit) => {
  switch (tExit._tag) {
    case OP_FAIL5: {
      return done9(fail4(tExit.error));
    }
    case OP_DIE3: {
      return done9(die3(tExit.defect));
    }
    case OP_INTERRUPT3: {
      return done9(interrupt4(tExit.fiberId));
    }
    case OP_SUCCEED3: {
      return done9(succeed4(tExit.value));
    }
    case OP_RETRY2: {
      throw new Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stm/tExit.js
var TExitSymbolKey = "effect/TExit";
var TExitTypeId = /* @__PURE__ */ Symbol.for(TExitSymbolKey);
var variance6 = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _E: (_) => _
};
var isExit2 = (u) => hasProperty(u, TExitTypeId);
var isSuccess4 = (self) => {
  return self._tag === OP_SUCCEED3;
};
var isRetry = (self) => {
  return self._tag === OP_RETRY2;
};
var fail14 = (error2) => ({
  [TExitTypeId]: variance6,
  _tag: OP_FAIL5,
  error: error2,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_FAIL5)), combine(hash(error2)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_FAIL5 && equals(error2, that.error);
  }
});
var die8 = (defect) => ({
  [TExitTypeId]: variance6,
  _tag: OP_DIE3,
  defect,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_DIE3)), combine(hash(defect)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_DIE3 && equals(defect, that.defect);
  }
});
var interrupt8 = (fiberId3) => ({
  [TExitTypeId]: variance6,
  _tag: OP_INTERRUPT3,
  fiberId: fiberId3,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_INTERRUPT3)), combine(hash(fiberId3)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_INTERRUPT3 && equals(fiberId3, that.fiberId);
  }
});
var succeed14 = (value3) => ({
  [TExitTypeId]: variance6,
  _tag: OP_SUCCEED3,
  value: value3,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_SUCCEED3)), combine(hash(value3)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_SUCCEED3 && equals(value3, that.value);
  }
});
var retryHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(TExitSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RETRY2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("retry")));
var retry4 = {
  [TExitTypeId]: variance6,
  _tag: OP_RETRY2,
  [symbol]() {
    return retryHash;
  },
  [symbol2](that) {
    return isExit2(that) && isRetry(that);
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stm/tryCommit.js
var done10 = (exit4) => {
  return {
    _tag: OP_DONE5,
    exit: exit4
  };
};
var suspend8 = (journal) => {
  return {
    _tag: OP_SUSPEND3,
    journal
  };
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stm/txnId.js
var txnCounter = {
  ref: 0
};
var make49 = () => {
  const newId = txnCounter.ref + 1;
  txnCounter.ref = newId;
  return newId;
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stm/core.js
var STMSymbolKey2 = "effect/STM";
var STMTypeId2 = /* @__PURE__ */ Symbol.for(STMSymbolKey2);
var stmVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var _a65, _b21, _c5, _d2;
var STMPrimitive = class {
  constructor(effect_instruction_i0) {
    __publicField(this, "effect_instruction_i0");
    __publicField(this, "_op", OP_COMMIT);
    __publicField(this, "effect_instruction_i1");
    __publicField(this, "effect_instruction_i2");
    __publicField(this, _d2);
    __publicField(this, _c5);
    __publicField(this, _b21);
    __publicField(this, _a65);
    this.effect_instruction_i0 = effect_instruction_i0;
    this[EffectTypeId3] = effectVariance;
    this[StreamTypeId] = stmVariance;
    this[SinkTypeId2] = stmVariance;
    this[ChannelTypeId2] = stmVariance;
  }
  get [(_d2 = EffectTypeId3, _c5 = StreamTypeId, _b21 = SinkTypeId2, _a65 = ChannelTypeId2, STMTypeId2)]() {
    return stmVariance;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
  commit() {
    return unsafeAtomically(this, constVoid, constVoid);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeAtomically = (self, onDone3, onInterrupt3) => withFiberRuntime((state) => {
  const fiberId3 = state.id();
  const env3 = state.getFiberRef(currentContext2);
  const scheduler2 = state.getFiberRef(currentScheduler2);
  const priority = state.getFiberRef(currentSchedulingPriority2);
  const commitResult = tryCommitSync(fiberId3, self, env3, scheduler2, priority);
  switch (commitResult._tag) {
    case OP_DONE5: {
      onDone3(commitResult.exit);
      return commitResult.exit;
    }
    case OP_SUSPEND3: {
      const txnId = make49();
      const state2 = {
        value: running3
      };
      const effect4 = async2((k) => tryCommitAsync(fiberId3, self, txnId, state2, env3, scheduler2, priority, k));
      return uninterruptibleMask3((restore) => pipe(restore(effect4), catchAllCause3((cause3) => {
        let currentState = state2.value;
        if (isRunning3(currentState)) {
          state2.value = interrupted3;
        }
        currentState = state2.value;
        if (isDone6(currentState)) {
          onDone3(currentState.exit);
          return currentState.exit;
        }
        onInterrupt3();
        return failCause9(cause3);
      })));
    }
  }
});
var tryCommit = (fiberId3, stm, state, env3, scheduler2, priority) => {
  const journal = /* @__PURE__ */ new Map();
  const tExit = new STMDriver(stm, journal, fiberId3, env3).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      state.value = fromTExit(tExit);
      return completeTodos(succeed4(tExit.value), journal, scheduler2, priority);
    }
    case OP_FAIL5: {
      state.value = fromTExit(tExit);
      const cause3 = fail6(tExit.error);
      return completeTodos(failCause4(cause3), journal, scheduler2, priority);
    }
    case OP_DIE3: {
      state.value = fromTExit(tExit);
      const cause3 = die4(tExit.defect);
      return completeTodos(failCause4(cause3), journal, scheduler2, priority);
    }
    case OP_INTERRUPT3: {
      state.value = fromTExit(tExit);
      const cause3 = interrupt5(fiberId3);
      return completeTodos(failCause4(cause3), journal, scheduler2, priority);
    }
    case OP_RETRY2: {
      return suspend8(journal);
    }
  }
};
var tryCommitSync = (fiberId3, stm, env3, scheduler2, priority) => {
  const journal = /* @__PURE__ */ new Map();
  const tExit = new STMDriver(stm, journal, fiberId3, env3).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite && isSuccess4(tExit)) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      return completeTodos(succeed4(tExit.value), journal, scheduler2, priority);
    }
    case OP_FAIL5: {
      const cause3 = fail6(tExit.error);
      return completeTodos(failCause4(cause3), journal, scheduler2, priority);
    }
    case OP_DIE3: {
      const cause3 = die4(tExit.defect);
      return completeTodos(failCause4(cause3), journal, scheduler2, priority);
    }
    case OP_INTERRUPT3: {
      const cause3 = interrupt5(fiberId3);
      return completeTodos(failCause4(cause3), journal, scheduler2, priority);
    }
    case OP_RETRY2: {
      return suspend8(journal);
    }
  }
};
var tryCommitAsync = (fiberId3, self, txnId, state, context9, scheduler2, priority, k) => {
  if (isRunning3(state.value)) {
    const result = tryCommit(fiberId3, self, state, context9, scheduler2, priority);
    switch (result._tag) {
      case OP_DONE5: {
        completeTryCommit(result.exit, k);
        break;
      }
      case OP_SUSPEND3: {
        addTodo(txnId, result.journal, () => tryCommitAsync(fiberId3, self, txnId, state, context9, scheduler2, priority, k));
        break;
      }
    }
  }
};
var completeTodos = (exit4, journal, scheduler2, priority) => {
  const todos = collectTodos(journal);
  if (todos.size > 0) {
    scheduler2.scheduleTask(() => execTodos(todos), priority);
  }
  return done10(exit4);
};
var completeTryCommit = (exit4, k) => {
  k(exit4);
};
var STMDriver = class {
  constructor(self, journal, fiberId3, r0) {
    __publicField(this, "self");
    __publicField(this, "journal");
    __publicField(this, "fiberId");
    __publicField(this, "contStack", []);
    __publicField(this, "env");
    this.self = self;
    this.journal = journal;
    this.fiberId = fiberId3;
    this.env = r0;
  }
  getEnv() {
    return this.env;
  }
  pushStack(cont) {
    this.contStack.push(cont);
  }
  popStack() {
    return this.contStack.pop();
  }
  nextSuccess() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_SUCCESS2) {
      current2 = this.popStack();
    }
    return current2;
  }
  nextFailure() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_FAILURE2) {
      current2 = this.popStack();
    }
    return current2;
  }
  nextRetry() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_RETRY) {
      current2 = this.popStack();
    }
    return current2;
  }
  run() {
    let curr = this.self;
    let exit4 = void 0;
    while (exit4 === void 0 && curr !== void 0) {
      try {
        const current2 = curr;
        if (current2) {
          switch (current2._op) {
            case "Tag": {
              curr = effect3((_, __, env3) => unsafeGet2(env3, current2));
              break;
            }
            case "Left": {
              curr = fail15(current2.left);
              break;
            }
            case "None": {
              curr = fail15(new NoSuchElementException2());
              break;
            }
            case "Right": {
              curr = succeed15(current2.right);
              break;
            }
            case "Some": {
              curr = succeed15(current2.value);
              break;
            }
            case "Commit": {
              switch (current2.effect_instruction_i0) {
                case OP_DIE2: {
                  exit4 = die8(internalCall(() => current2.effect_instruction_i1()));
                  break;
                }
                case OP_FAIL4: {
                  const cont = this.nextFailure();
                  if (cont === void 0) {
                    exit4 = fail14(internalCall(() => current2.effect_instruction_i1()));
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(internalCall(() => current2.effect_instruction_i1())));
                  }
                  break;
                }
                case OP_RETRY: {
                  const cont = this.nextRetry();
                  if (cont === void 0) {
                    exit4 = retry4;
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2());
                  }
                  break;
                }
                case OP_INTERRUPT2: {
                  exit4 = interrupt8(this.fiberId);
                  break;
                }
                case OP_WITH_STM_RUNTIME: {
                  curr = internalCall(() => current2.effect_instruction_i1(this));
                  break;
                }
                case OP_ON_SUCCESS2:
                case OP_ON_FAILURE2:
                case OP_ON_RETRY: {
                  this.pushStack(current2);
                  curr = current2.effect_instruction_i1;
                  break;
                }
                case OP_PROVIDE3: {
                  const env3 = this.env;
                  this.env = internalCall(() => current2.effect_instruction_i2(env3));
                  curr = pipe(current2.effect_instruction_i1, ensuring6(sync9(() => this.env = env3)));
                  break;
                }
                case OP_SUCCEED2: {
                  const value3 = current2.effect_instruction_i1;
                  const cont = this.nextSuccess();
                  if (cont === void 0) {
                    exit4 = succeed14(value3);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value3));
                  }
                  break;
                }
                case OP_SYNC2: {
                  const value3 = internalCall(() => current2.effect_instruction_i1());
                  const cont = this.nextSuccess();
                  if (cont === void 0) {
                    exit4 = succeed14(value3);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value3));
                  }
                  break;
                }
              }
              break;
            }
          }
        }
      } catch (e) {
        curr = die9(e);
      }
    }
    return exit4;
  }
};
var catchAll6 = /* @__PURE__ */ dual(2, (self, f) => {
  const stm = new STMPrimitive(OP_ON_FAILURE2);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = f;
  return stm;
});
var die9 = (defect) => dieSync5(() => defect);
var dieSync5 = (evaluate3) => {
  const stm = new STMPrimitive(OP_DIE2);
  stm.effect_instruction_i1 = evaluate3;
  return stm;
};
var effect3 = (f) => withSTMRuntime((_) => succeed15(f(_.journal, _.fiberId, _.getEnv())));
var ensuring6 = /* @__PURE__ */ dual(2, (self, finalizer3) => matchSTM(self, {
  onFailure: (e) => zipRight10(finalizer3, fail15(e)),
  onSuccess: (a) => zipRight10(finalizer3, succeed15(a))
}));
var fail15 = (error2) => failSync6(() => error2);
var failSync6 = (evaluate3) => {
  const stm = new STMPrimitive(OP_FAIL4);
  stm.effect_instruction_i1 = evaluate3;
  return stm;
};
var flatMap16 = /* @__PURE__ */ dual(2, (self, f) => {
  const stm = new STMPrimitive(OP_ON_SUCCESS2);
  stm.effect_instruction_i1 = self;
  stm.effect_instruction_i2 = f;
  return stm;
});
var matchSTM = /* @__PURE__ */ dual(2, (self, {
  onFailure,
  onSuccess
}) => pipe(self, map23(right2), catchAll6((e) => pipe(onFailure(e), map23(left2))), flatMap16((either8) => {
  switch (either8._tag) {
    case "Left": {
      return succeed15(either8.left);
    }
    case "Right": {
      return onSuccess(either8.right);
    }
  }
})));
var withSTMRuntime = (f) => {
  const stm = new STMPrimitive(OP_WITH_STM_RUNTIME);
  stm.effect_instruction_i1 = f;
  return stm;
};
var interruptAs2 = (fiberId3) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = fiberId3;
  return stm;
};
var map23 = /* @__PURE__ */ dual(2, (self, f) => pipe(self, flatMap16((a) => sync9(() => f(a)))));
var retry5 = /* @__PURE__ */ new STMPrimitive(OP_RETRY);
var succeed15 = (value3) => {
  const stm = new STMPrimitive(OP_SUCCEED2);
  stm.effect_instruction_i1 = value3;
  return stm;
};
var sync9 = (evaluate3) => {
  const stm = new STMPrimitive(OP_SYNC2);
  stm.effect_instruction_i1 = evaluate3;
  return stm;
};
var zipRight10 = /* @__PURE__ */ dual(2, (self, that) => pipe(self, flatMap16(() => that)));
var zipWith13 = /* @__PURE__ */ dual(3, (self, that, f) => pipe(self, flatMap16((a) => pipe(that, map23((b) => f(a, b))))));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stm/opCodes/strategy.js
var OP_BACKPRESSURE_STRATEGY = "BackPressure";
var OP_DROPPING_STRATEGY = "Dropping";
var OP_SLIDING_STRATEGY = "Sliding";

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stm/stm.js
var as9 = /* @__PURE__ */ dual(2, (self, value3) => pipe(self, map23(() => value3)));
var flatten12 = (self) => flatMap16(self, identity);
var forEach12 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (iterable, f, options) => {
  if (options?.discard) {
    return pipe(sync9(() => iterable[Symbol.iterator]()), flatMap16((iterator) => {
      const loop3 = suspend9(() => {
        const next4 = iterator.next();
        if (next4.done) {
          return void_8;
        }
        return pipe(f(next4.value), flatMap16(() => loop3));
      });
      return loop3;
    }));
  }
  return suspend9(() => fromIterable2(iterable).reduce((acc, curr) => zipWith13(acc, f(curr), (array6, elem) => {
    array6.push(elem);
    return array6;
  }), succeed15([])));
});
var all8 = (input, options) => {
  if (Symbol.iterator in input) {
    return forEach12(input, identity, options);
  } else if (options?.discard) {
    return forEach12(Object.values(input), identity, options);
  }
  return map23(forEach12(Object.entries(input), ([_, e]) => map23(e, (a) => [_, a])), (values5) => {
    const res = {};
    for (const [k, v] of values5) {
      ;
      res[k] = v;
    }
    return res;
  });
};
var suspend9 = (evaluate3) => flatten12(sync9(evaluate3));
var tap6 = /* @__PURE__ */ dual(2, (self, f) => flatMap16(self, (a) => as9(f(a), a)));
var void_8 = /* @__PURE__ */ succeed15(void 0);

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stm/tRef.js
var TRefSymbolKey = "effect/TRef";
var TRefTypeId = /* @__PURE__ */ Symbol.for(TRefSymbolKey);
var tRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var _a66;
_a66 = TRefTypeId;
var TRefImpl = class {
  constructor(value3) {
    __publicField(this, _a66, tRefVariance);
    /** @internal */
    __publicField(this, "todos");
    /** @internal */
    __publicField(this, "versioned");
    this.versioned = new Versioned(value3);
    this.todos = /* @__PURE__ */ new Map();
  }
  modify(f) {
    return effect3((journal) => {
      const entry = getOrMakeEntry(this, journal);
      const [retValue, newValue] = f(unsafeGet7(entry));
      unsafeSet(entry, newValue);
      return retValue;
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make50 = (value3) => effect3((journal) => {
  const ref = new TRefImpl(value3);
  journal.set(ref, make48(ref, true));
  return ref;
});
var get16 = (self) => self.modify((a) => [a, a]);
var set7 = /* @__PURE__ */ dual(2, (self, value3) => self.modify(() => [void 0, value3]));
var getOrMakeEntry = (self, journal) => {
  if (journal.has(self)) {
    return journal.get(self);
  }
  const entry = make48(self, false);
  journal.set(self, entry);
  return entry;
};
var unsafeGet8 = /* @__PURE__ */ dual(2, (self, journal) => unsafeGet7(getOrMakeEntry(self, journal)));
var unsafeSet2 = /* @__PURE__ */ dual(3, (self, value3, journal) => {
  const entry = getOrMakeEntry(self, journal);
  unsafeSet(entry, value3);
  return void 0;
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stm/tQueue.js
var TEnqueueSymbolKey = "effect/TQueue/TEnqueue";
var TEnqueueTypeId = /* @__PURE__ */ Symbol.for(TEnqueueSymbolKey);
var TDequeueSymbolKey = "effect/TQueue/TDequeue";
var TDequeueTypeId = /* @__PURE__ */ Symbol.for(TDequeueSymbolKey);
var tDequeueVariance = {
  /* c8 ignore next */
  _Out: (_) => _
};
var tEnqueueVariance = {
  /* c8 ignore next */
  _In: (_) => _
};
var _a67, _b22;
_b22 = TDequeueTypeId, _a67 = TEnqueueTypeId;
var TQueueImpl = class {
  constructor(ref, requestedCapacity, strategy) {
    __publicField(this, "ref");
    __publicField(this, "requestedCapacity");
    __publicField(this, "strategy");
    __publicField(this, _b22, tDequeueVariance);
    __publicField(this, _a67, tEnqueueVariance);
    __publicField(this, "size", /* @__PURE__ */ withSTMRuntime((runtime5) => {
      const queue = unsafeGet8(this.ref, runtime5.journal);
      if (queue === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      return succeed15(queue.length);
    }));
    __publicField(this, "isFull", /* @__PURE__ */ map23(this.size, (size17) => size17 === this.requestedCapacity));
    __publicField(this, "isEmpty", /* @__PURE__ */ map23(this.size, (size17) => size17 === 0));
    __publicField(this, "shutdown", /* @__PURE__ */ withSTMRuntime((runtime5) => {
      unsafeSet2(this.ref, void 0, runtime5.journal);
      return void_8;
    }));
    __publicField(this, "isShutdown", /* @__PURE__ */ effect3((journal) => {
      const queue = unsafeGet8(this.ref, journal);
      return queue === void 0;
    }));
    __publicField(this, "awaitShutdown", /* @__PURE__ */ flatMap16(this.isShutdown, (isShutdown7) => isShutdown7 ? void_8 : retry5));
    __publicField(this, "peek", /* @__PURE__ */ withSTMRuntime((runtime5) => {
      const queue = unsafeGet8(this.ref, runtime5.journal);
      if (queue === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      if (queue.length === 0) {
        return retry5;
      }
      return succeed15(queue[0]);
    }));
    __publicField(this, "peekOption", /* @__PURE__ */ withSTMRuntime((runtime5) => {
      const queue = unsafeGet8(this.ref, runtime5.journal);
      if (queue === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      return succeed15(fromNullable(queue[0]));
    }));
    __publicField(this, "take", /* @__PURE__ */ withSTMRuntime((runtime5) => {
      const queue = unsafeGet8(this.ref, runtime5.journal);
      if (queue === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      if (queue.length === 0) {
        return retry5;
      }
      const dequeued = queue.shift();
      unsafeSet2(this.ref, queue, runtime5.journal);
      return succeed15(dequeued);
    }));
    __publicField(this, "takeAll", /* @__PURE__ */ withSTMRuntime((runtime5) => {
      const queue = unsafeGet8(this.ref, runtime5.journal);
      if (queue === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      unsafeSet2(this.ref, [], runtime5.journal);
      return succeed15(queue);
    }));
    this.ref = ref;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
  }
  capacity() {
    return this.requestedCapacity;
  }
  offer(value3) {
    return withSTMRuntime((runtime5) => {
      const queue = pipe(this.ref, unsafeGet8(runtime5.journal));
      if (queue === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      if (queue.length < this.requestedCapacity) {
        queue.push(value3);
        unsafeSet2(this.ref, queue, runtime5.journal);
        return succeed15(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry5;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed15(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (queue.length === 0) {
            return succeed15(true);
          }
          queue.shift();
          queue.push(value3);
          unsafeSet2(this.ref, queue, runtime5.journal);
          return succeed15(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return withSTMRuntime((runtime5) => {
      const as13 = Array.from(iterable);
      const queue = unsafeGet8(this.ref, runtime5.journal);
      if (queue === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      if (queue.length + as13.length <= this.requestedCapacity) {
        unsafeSet2(this.ref, [...queue, ...as13], runtime5.journal);
        return succeed15(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry5;
        }
        case OP_DROPPING_STRATEGY: {
          const forQueue = as13.slice(0, this.requestedCapacity - queue.length);
          unsafeSet2(this.ref, [...queue, ...forQueue], runtime5.journal);
          return succeed15(false);
        }
        case OP_SLIDING_STRATEGY: {
          const forQueue = as13.slice(0, this.requestedCapacity - queue.length);
          const toDrop = queue.length + forQueue.length - this.requestedCapacity;
          const newQueue = queue.slice(toDrop);
          unsafeSet2(this.ref, [...newQueue, ...forQueue], runtime5.journal);
          return succeed15(true);
        }
      }
    });
  }
  takeUpTo(max7) {
    return withSTMRuntime((runtime5) => {
      const queue = unsafeGet8(this.ref, runtime5.journal);
      if (queue === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      const [toTake, remaining] = splitAt2(unsafeFromArray(queue), max7);
      unsafeSet2(this.ref, Array.from(remaining), runtime5.journal);
      return succeed15(Array.from(toTake));
    });
  }
};
var isShutdown4 = (self) => self.isShutdown;
var shutdown5 = (self) => self.shutdown;
var take4 = (self) => self.take;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stm/tPubSub.js
var TPubSubSymbolKey = "effect/TPubSub";
var TPubSubTypeId = /* @__PURE__ */ Symbol.for(TPubSubSymbolKey);
var AbsentValue2 = /* @__PURE__ */ Symbol.for("effect/TPubSub/AbsentValue");
var makeNode2 = (head8, subscribers, tail2) => ({
  head: head8,
  subscribers,
  tail: tail2
});
var _a68, _b23;
_b23 = TPubSubTypeId, _a68 = TEnqueueTypeId;
var TPubSubImpl = class {
  constructor(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers) {
    __publicField(this, "pubsubSize");
    __publicField(this, "publisherHead");
    __publicField(this, "publisherTail");
    __publicField(this, "requestedCapacity");
    __publicField(this, "strategy");
    __publicField(this, "subscriberCount");
    __publicField(this, "subscribers");
    __publicField(this, _b23, {
      _A: (_) => _
    });
    __publicField(this, _a68, tEnqueueVariance);
    __publicField(this, "isShutdown", /* @__PURE__ */ effect3((journal) => {
      const currentPublisherTail = unsafeGet8(this.publisherTail, journal);
      return currentPublisherTail === void 0;
    }));
    __publicField(this, "awaitShutdown", /* @__PURE__ */ flatMap16(this.isShutdown, (isShutdown7) => isShutdown7 ? void_8 : retry5));
    __publicField(this, "size", /* @__PURE__ */ withSTMRuntime((runtime5) => {
      const currentPublisherTail = unsafeGet8(this.publisherTail, runtime5.journal);
      if (currentPublisherTail === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      return succeed15(unsafeGet8(this.pubsubSize, runtime5.journal));
    }));
    __publicField(this, "isEmpty", /* @__PURE__ */ map23(this.size, (size17) => size17 === 0));
    __publicField(this, "isFull", /* @__PURE__ */ map23(this.size, (size17) => size17 === this.capacity()));
    __publicField(this, "shutdown", /* @__PURE__ */ effect3((journal) => {
      const currentPublisherTail = unsafeGet8(this.publisherTail, journal);
      if (currentPublisherTail !== void 0) {
        unsafeSet2(this.publisherTail, void 0, journal);
        const currentSubscribers = unsafeGet8(this.subscribers, journal);
        forEach4(currentSubscribers, (subscriber) => {
          unsafeSet2(subscriber, void 0, journal);
        });
        unsafeSet2(this.subscribers, empty8(), journal);
      }
    }));
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.publisherTail = publisherTail;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  capacity() {
    return this.requestedCapacity;
  }
  offer(value3) {
    return withSTMRuntime((runtime5) => {
      const currentPublisherTail = unsafeGet8(this.publisherTail, runtime5.journal);
      if (currentPublisherTail === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      const currentSubscriberCount = unsafeGet8(this.subscriberCount, runtime5.journal);
      if (currentSubscriberCount === 0) {
        return succeed15(true);
      }
      const currentPubSubSize = unsafeGet8(this.pubsubSize, runtime5.journal);
      if (currentPubSubSize < this.requestedCapacity) {
        const updatedPublisherTail = new TRefImpl(void 0);
        const updatedNode = makeNode2(value3, currentSubscriberCount, updatedPublisherTail);
        unsafeSet2(currentPublisherTail, updatedNode, runtime5.journal);
        unsafeSet2(this.publisherTail, updatedPublisherTail, runtime5.journal);
        unsafeSet2(this.pubsubSize, currentPubSubSize + 1, runtime5.journal);
        return succeed15(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry5;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed15(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (this.requestedCapacity > 0) {
            let currentPublisherHead = unsafeGet8(this.publisherHead, runtime5.journal);
            let loop3 = true;
            while (loop3) {
              const node = unsafeGet8(currentPublisherHead, runtime5.journal);
              if (node === void 0) {
                return retry5;
              }
              const head8 = node.head;
              const tail2 = node.tail;
              if (head8 !== AbsentValue2) {
                const updatedNode2 = makeNode2(AbsentValue2, node.subscribers, node.tail);
                unsafeSet2(currentPublisherHead, updatedNode2, runtime5.journal);
                unsafeSet2(this.publisherHead, tail2, runtime5.journal);
                loop3 = false;
              } else {
                currentPublisherHead = tail2;
              }
            }
          }
          const updatedPublisherTail = new TRefImpl(void 0);
          const updatedNode = makeNode2(value3, currentSubscriberCount, updatedPublisherTail);
          unsafeSet2(currentPublisherTail, updatedNode, runtime5.journal);
          unsafeSet2(this.publisherTail, updatedPublisherTail, runtime5.journal);
          return succeed15(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return map23(forEach12(iterable, (a) => this.offer(a)), every(identity));
  }
};
var _a69, _b24;
_b24 = TPubSubTypeId, _a69 = TDequeueTypeId;
var TPubSubSubscriptionImpl = class {
  constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
    __publicField(this, "pubsubSize");
    __publicField(this, "publisherHead");
    __publicField(this, "requestedCapacity");
    __publicField(this, "subscriberHead");
    __publicField(this, "subscriberCount");
    __publicField(this, "subscribers");
    __publicField(this, _b24, TPubSubTypeId);
    __publicField(this, _a69, tDequeueVariance);
    __publicField(this, "isShutdown", /* @__PURE__ */ effect3((journal) => {
      const currentSubscriberHead = unsafeGet8(this.subscriberHead, journal);
      return currentSubscriberHead === void 0;
    }));
    __publicField(this, "awaitShutdown", /* @__PURE__ */ flatMap16(this.isShutdown, (isShutdown7) => isShutdown7 ? void_8 : retry5));
    __publicField(this, "size", /* @__PURE__ */ withSTMRuntime((runtime5) => {
      let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      let loop3 = true;
      let size17 = 0;
      while (loop3) {
        const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
        if (node === void 0) {
          loop3 = false;
        } else {
          const head8 = node.head;
          const tail2 = node.tail;
          if (head8 !== AbsentValue2) {
            size17 = size17 + 1;
            if (size17 >= Number.MAX_SAFE_INTEGER) {
              loop3 = false;
            }
          }
          currentSubscriberHead = tail2;
        }
      }
      return succeed15(size17);
    }));
    __publicField(this, "isEmpty", /* @__PURE__ */ map23(this.size, (size17) => size17 === 0));
    __publicField(this, "isFull", /* @__PURE__ */ map23(this.size, (size17) => size17 === this.capacity()));
    __publicField(this, "peek", /* @__PURE__ */ withSTMRuntime((runtime5) => {
      let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      let value3 = AbsentValue2;
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
        if (node === void 0) {
          return retry5;
        }
        const head8 = node.head;
        const tail2 = node.tail;
        if (head8 !== AbsentValue2) {
          value3 = head8;
          loop3 = false;
        } else {
          currentSubscriberHead = tail2;
        }
      }
      return succeed15(value3);
    }));
    __publicField(this, "peekOption", /* @__PURE__ */ withSTMRuntime((runtime5) => {
      let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      let value3 = none2();
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
        if (node === void 0) {
          value3 = none2();
          loop3 = false;
        } else {
          const head8 = node.head;
          const tail2 = node.tail;
          if (head8 !== AbsentValue2) {
            value3 = some2(head8);
            loop3 = false;
          } else {
            currentSubscriberHead = tail2;
          }
        }
      }
      return succeed15(value3);
    }));
    __publicField(this, "shutdown", /* @__PURE__ */ effect3((journal) => {
      let currentSubscriberHead = unsafeGet8(this.subscriberHead, journal);
      if (currentSubscriberHead !== void 0) {
        unsafeSet2(this.subscriberHead, void 0, journal);
        let loop3 = true;
        while (loop3) {
          const node = unsafeGet8(currentSubscriberHead, journal);
          if (node === void 0) {
            loop3 = false;
          } else {
            const head8 = node.head;
            const tail2 = node.tail;
            if (head8 !== AbsentValue2) {
              const subscribers = node.subscribers;
              if (subscribers === 1) {
                const size17 = unsafeGet8(this.pubsubSize, journal);
                const updatedNode = makeNode2(AbsentValue2, 0, tail2);
                unsafeSet2(currentSubscriberHead, updatedNode, journal);
                unsafeSet2(this.publisherHead, tail2, journal);
                unsafeSet2(this.pubsubSize, size17 - 1, journal);
              } else {
                const updatedNode = makeNode2(head8, subscribers - 1, tail2);
                unsafeSet2(currentSubscriberHead, updatedNode, journal);
              }
            }
            currentSubscriberHead = tail2;
          }
        }
        const currentSubscriberCount = unsafeGet8(this.subscriberCount, journal);
        unsafeSet2(this.subscriberCount, currentSubscriberCount - 1, journal);
        unsafeSet2(this.subscribers, remove5(unsafeGet8(this.subscribers, journal), this.subscriberHead), journal);
      }
    }));
    __publicField(this, "take", /* @__PURE__ */ withSTMRuntime((runtime5) => {
      let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      let value3 = AbsentValue2;
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
        if (node === void 0) {
          return retry5;
        }
        const head8 = node.head;
        const tail2 = node.tail;
        if (head8 !== AbsentValue2) {
          const subscribers = node.subscribers;
          if (subscribers === 1) {
            const size17 = unsafeGet8(this.pubsubSize, runtime5.journal);
            const updatedNode = makeNode2(AbsentValue2, 0, tail2);
            unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
            unsafeSet2(this.publisherHead, tail2, runtime5.journal);
            unsafeSet2(this.pubsubSize, size17 - 1, runtime5.journal);
          } else {
            const updatedNode = makeNode2(head8, subscribers - 1, tail2);
            unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
          }
          unsafeSet2(this.subscriberHead, tail2, runtime5.journal);
          value3 = head8;
          loop3 = false;
        } else {
          currentSubscriberHead = tail2;
        }
      }
      return succeed15(value3);
    }));
    __publicField(this, "takeAll", /* @__PURE__ */ this.takeUpTo(Number.POSITIVE_INFINITY));
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.requestedCapacity = requestedCapacity;
    this.subscriberHead = subscriberHead;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  capacity() {
    return this.requestedCapacity;
  }
  takeUpTo(max7) {
    return withSTMRuntime((runtime5) => {
      let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime5.fiberId);
      }
      const builder = [];
      let n = 0;
      while (n !== max7) {
        const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
        if (node === void 0) {
          n = max7;
        } else {
          const head8 = node.head;
          const tail2 = node.tail;
          if (head8 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size17 = unsafeGet8(this.pubsubSize, runtime5.journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail2);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
              unsafeSet2(this.publisherHead, tail2, runtime5.journal);
              unsafeSet2(this.pubsubSize, size17 - 1, runtime5.journal);
            } else {
              const updatedNode = makeNode2(head8, subscribers - 1, tail2);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
            }
            builder.push(head8);
            n = n + 1;
          }
          currentSubscriberHead = tail2;
        }
      }
      unsafeSet2(this.subscriberHead, currentSubscriberHead, runtime5.journal);
      return succeed15(builder);
    });
  }
};
var makeSubscription2 = (pubsubSize, publisherHead, publisherTail, requestedCapacity, subscriberCount, subscribers) => pipe(get16(publisherTail), flatMap16((currentPublisherTail) => pipe(all8([make50(currentPublisherTail), get16(subscriberCount), get16(subscribers)]), tap6(([_, currentSubscriberCount]) => pipe(subscriberCount, set7(currentSubscriberCount + 1))), tap6(([subscriberHead, _, currentSubscribers]) => pipe(subscribers, set7(pipe(currentSubscribers, add4(subscriberHead))))), map23(([subscriberHead]) => new TPubSubSubscriptionImpl(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers)))));
var subscribe3 = (self) => makeSubscription2(self.pubsubSize, self.publisherHead, self.publisherTail, self.requestedCapacity, self.subscriberCount, self.subscribers);
var subscribeScoped = (self) => acquireRelease2(subscribe3(self), (dequeue) => shutdown5(dequeue));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/TPubSub.js
var subscribeScoped2 = subscribeScoped;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/TQueue.js
var isShutdown6 = isShutdown4;
var take5 = take4;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/ringBuffer.js
var RingBuffer = class {
  constructor(capacity7) {
    __publicField(this, "capacity");
    __publicField(this, "array");
    __publicField(this, "size", 0);
    __publicField(this, "current", 0);
    this.capacity = capacity7;
    this.array = Array.from({
      length: capacity7
    }, constUndefined);
  }
  head() {
    return fromNullable(this.array[this.current]);
  }
  lastOrNull() {
    if (this.size === 0) {
      return void 0;
    }
    const index = this.current === 0 ? this.array.length - 1 : this.current - 1;
    return this.array[index] ?? void 0;
  }
  put(value3) {
    this.array[this.current] = value3;
    this.increment();
  }
  dropLast() {
    if (this.size > 0) {
      this.decrement();
      this.array[this.current] = void 0;
    }
  }
  toChunk() {
    const begin = this.current - this.size;
    const newArray = begin < 0 ? [...this.array.slice(this.capacity + begin, this.capacity), ...this.array.slice(0, this.current)] : this.array.slice(begin, this.current);
    return fromIterable3(newArray);
  }
  increment() {
    if (this.size < this.capacity) {
      this.size += 1;
    }
    this.current = (this.current + 1) % this.capacity;
  }
  decrement() {
    this.size -= 1;
    if (this.current > 0) {
      this.current -= 1;
    } else {
      this.current = this.capacity - 1;
    }
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stream/debounceState.js
var OP_NOT_STARTED = "NotStarted";
var OP_PREVIOUS = "Previous";
var OP_CURRENT = "Current";
var notStarted = {
  _tag: OP_NOT_STARTED
};
var previous = (fiber) => ({
  _tag: OP_PREVIOUS,
  fiber
});
var current = (fiber) => ({
  _tag: OP_CURRENT,
  fiber
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stream/emit.js
var make51 = (emit2) => {
  const ops = {
    chunk(as13) {
      return this(succeed10(as13));
    },
    die(defect) {
      return this(die6(defect));
    },
    dieMessage(message) {
      return this(dieMessage2(message));
    },
    done(exit4) {
      return this(suspend4(() => mapBoth3(exit4, {
        onFailure: some2,
        onSuccess: of2
      })));
    },
    end() {
      return this(fail10(none2()));
    },
    fail(e) {
      return this(fail10(some2(e)));
    },
    fromEffect(effect4) {
      return this(mapBoth5(effect4, {
        onFailure: some2,
        onSuccess: of2
      }));
    },
    fromEffectChunk(effect4) {
      return this(pipe(effect4, mapError3(some2)));
    },
    halt(cause3) {
      return this(failCause9(pipe(cause3, map14(some2))));
    },
    single(value3) {
      return this(succeed10(of2(value3)));
    }
  };
  return Object.assign(emit2, ops);
};
var makePush = (queue, scheduler2) => {
  let finished = false;
  let buffer3 = [];
  let running4 = false;
  function array6(items) {
    if (finished) return false;
    if (items.length <= 5e4) {
      buffer3.push.apply(buffer3, items);
    } else {
      for (let i = 0; i < items.length; i++) {
        buffer3.push(items[0]);
      }
    }
    if (!running4) {
      running4 = true;
      scheduler2.scheduleTask(flush, 0);
    }
    return true;
  }
  function flush() {
    running4 = false;
    if (buffer3.length > 0) {
      queue.unsafeOffer(buffer3);
      buffer3 = [];
    }
  }
  function done12(exit4) {
    if (finished) return;
    finished = true;
    if (exit4._tag === "Success") {
      buffer3.push(exit4.value);
    }
    flush();
    queue.unsafeOffer(exit4._tag === "Success" ? void_4 : exit4);
  }
  return {
    single(value3) {
      if (finished) return false;
      buffer3.push(value3);
      if (!running4) {
        running4 = true;
        scheduler2.scheduleTask(flush, 0);
      }
      return true;
    },
    array: array6,
    chunk(chunk4) {
      return array6(toReadonlyArray(chunk4));
    },
    done: done12,
    end() {
      if (finished) return;
      finished = true;
      flush();
      queue.unsafeOffer(void_4);
    },
    halt(cause3) {
      return done12(failCause4(cause3));
    },
    fail(error2) {
      return done12(fail4(error2));
    },
    die(defect) {
      return done12(die3(defect));
    },
    dieMessage(message) {
      return done12(die3(new Error(message)));
    }
  };
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stream/handoff.js
var HandoffTypeId = /* @__PURE__ */ Symbol.for("effect/Stream/Handoff");
var OP_HANDOFF_STATE_EMPTY = "Empty";
var OP_HANDOFF_STATE_FULL = "Full";
var handoffStateEmpty = (notifyConsumer) => ({
  _tag: OP_HANDOFF_STATE_EMPTY,
  notifyConsumer
});
var handoffStateFull = (value3, notifyProducer) => ({
  _tag: OP_HANDOFF_STATE_FULL,
  value: value3,
  notifyProducer
});
var handoffStateMatch = (onEmpty, onFull) => {
  return (self) => {
    switch (self._tag) {
      case OP_HANDOFF_STATE_EMPTY: {
        return onEmpty(self.notifyConsumer);
      }
      case OP_HANDOFF_STATE_FULL: {
        return onFull(self.value, self.notifyProducer);
      }
    }
  };
};
var handoffVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var make52 = () => pipe(make23(), flatMap12((deferred) => make25(handoffStateEmpty(deferred))), map18((ref) => ({
  [HandoffTypeId]: handoffVariance,
  ref
})));
var offer5 = /* @__PURE__ */ dual(2, (self, value3) => {
  return flatMap12(make23(), (deferred) => flatten9(modify6(self.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [zipRight6(succeed2(notifyConsumer, void 0), _await(deferred)), handoffStateFull(value3, deferred)], (_, notifyProducer) => [flatMap12(_await(notifyProducer), () => pipe(self, offer5(value3))), state])))));
});
var take6 = (self) => flatMap12(make23(), (deferred) => flatten9(modify6(self.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [flatMap12(_await(notifyConsumer), () => take6(self)), state], (value3, notifyProducer) => [as6(succeed2(notifyProducer, void 0), value3), handoffStateEmpty(deferred)])))));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stream/handoffSignal.js
var OP_EMIT4 = "Emit";
var OP_HALT = "Halt";
var OP_END = "End";
var emit = (elements) => ({
  _tag: OP_EMIT4,
  elements
});
var halt = (cause3) => ({
  _tag: OP_HALT,
  cause: cause3
});
var end3 = (reason) => ({
  _tag: OP_END,
  reason
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/take.js
var TakeSymbolKey = "effect/Take";
var TakeTypeId = /* @__PURE__ */ Symbol.for(TakeSymbolKey);
var takeVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _E: (_) => _
};
var _a70;
_a70 = TakeTypeId;
var TakeImpl = class {
  constructor(exit4) {
    __publicField(this, "exit");
    __publicField(this, _a70, takeVariance);
    this.exit = exit4;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var chunk2 = (chunk4) => new TakeImpl(succeed4(chunk4));
var done11 = (self) => suspend4(() => self.exit);
var end4 = /* @__PURE__ */ new TakeImpl(/* @__PURE__ */ fail4(/* @__PURE__ */ none2()));
var failCause12 = (cause3) => new TakeImpl(failCause4(pipe(cause3, map14(some2))));
var fromPull = (pull) => matchCause4(pull, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: () => end4,
    onSome: failCause12
  }),
  onSuccess: chunk2
});
var match19 = /* @__PURE__ */ dual(2, (self, {
  onEnd: onEnd3,
  onFailure,
  onSuccess
}) => match9(self.exit, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: onEnd3,
    onSome: onFailure
  }),
  onSuccess
}));
var of5 = (value3) => new TakeImpl(succeed4(of2(value3)));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stream/pull.js
var end5 = () => fail10(none2());
var failCause13 = (cause3) => mapError3(failCause9(cause3), some2);

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stream/sinkEndReason.js
var OP_SCHEDULE_END = "ScheduleEnd";
var OP_UPSTREAM_END = "UpstreamEnd";
var ScheduleEnd = {
  _tag: OP_SCHEDULE_END
};
var UpstreamEnd = {
  _tag: OP_UPSTREAM_END
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stream/zipAllState.js
var OP_DRAIN_LEFT = "DrainLeft";
var OP_DRAIN_RIGHT = "DrainRight";
var OP_PULL_BOTH = "PullBoth";
var OP_PULL_LEFT = "PullLeft";
var OP_PULL_RIGHT = "PullRight";
var DrainLeft = {
  _tag: OP_DRAIN_LEFT
};
var DrainRight = {
  _tag: OP_DRAIN_RIGHT
};
var PullBoth = {
  _tag: OP_PULL_BOTH
};
var PullLeft = (rightChunk) => ({
  _tag: OP_PULL_LEFT,
  rightChunk
});
var PullRight = (leftChunk) => ({
  _tag: OP_PULL_RIGHT,
  leftChunk
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stream/zipChunksState.js
var OP_PULL_BOTH2 = "PullBoth";
var OP_PULL_LEFT2 = "PullLet";
var OP_PULL_RIGHT2 = "PullRight";
var PullBoth2 = {
  _tag: OP_PULL_BOTH2
};
var PullLeft2 = (rightChunk) => ({
  _tag: OP_PULL_LEFT2,
  rightChunk
});
var PullRight2 = (leftChunk) => ({
  _tag: OP_PULL_RIGHT2,
  leftChunk
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/stream.js
var StreamSymbolKey = "effect/Stream";
var StreamTypeId2 = /* @__PURE__ */ Symbol.for(StreamSymbolKey);
var streamVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _A: (_) => _
};
var _a71;
_a71 = StreamTypeId2;
var StreamImpl = class {
  constructor(channel) {
    __publicField(this, "channel");
    __publicField(this, _a71, streamVariance);
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isStream = (u) => hasProperty(u, StreamTypeId2) || isEffect2(u);
var DefaultChunkSize = 4096;
var accumulate = (self) => chunks(accumulateChunks(self));
var accumulateChunks = (self) => {
  const accumulator = (s) => readWith({
    onInput: (input) => {
      const next4 = appendAll2(s, input);
      return flatMap14(write(next4), () => accumulator(next4));
    },
    onFailure: fail12,
    onDone: () => void_7
  });
  return new StreamImpl(pipeTo(toChannel2(self), accumulator(empty5())));
};
var acquireRelease3 = (acquire, release) => scoped6(acquireRelease2(acquire, release));
var aggregate = /* @__PURE__ */ dual(2, (self, sink) => aggregateWithin(self, sink, forever4));
var aggregateWithin = /* @__PURE__ */ dual(3, (self, sink, schedule4) => filterMap9(aggregateWithinEither(self, sink, schedule4), (_) => match(_, {
  onLeft: none2,
  onRight: some2
})));
var aggregateWithinEither = /* @__PURE__ */ dual(3, (self, sink, schedule4) => {
  const layer4 = all7([make52(), make25(ScheduleEnd), make25(empty5()), driver2(schedule4), make25(false), make25(false)]);
  return fromEffect8(layer4).pipe(flatMap17(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {
    const handoffProducer = readWithCause({
      onInput: (input) => flatMap14(fromEffect5(pipe(handoff, offer5(emit(input)), when2(() => isNonEmpty(input)))), () => handoffProducer),
      onFailure: (cause3) => fromEffect5(offer5(handoff, halt(cause3))),
      onDone: () => fromEffect5(offer5(handoff, end3(UpstreamEnd)))
    });
    const handoffConsumer = pipe(getAndSet2(sinkLeftovers, empty5()), flatMap12((leftovers) => {
      if (isNonEmpty(leftovers)) {
        return pipe(set5(consumed, true), zipRight6(succeed10(pipe(write(leftovers), flatMap14(() => handoffConsumer)))));
      }
      return pipe(take6(handoff), map18((signal) => {
        switch (signal._tag) {
          case OP_EMIT4: {
            return pipe(fromEffect5(set5(consumed, true)), zipRight7(write(signal.elements)), zipRight7(fromEffect5(get11(endAfterEmit))), flatMap14((bool2) => bool2 ? void_7 : handoffConsumer));
          }
          case OP_HALT: {
            return failCause11(signal.cause);
          }
          case OP_END: {
            if (signal.reason._tag === OP_SCHEDULE_END) {
              return pipe(get11(consumed), map18((bool2) => bool2 ? fromEffect5(pipe(set5(sinkEndReason, ScheduleEnd), zipRight6(set5(endAfterEmit, true)))) : pipe(fromEffect5(pipe(set5(sinkEndReason, ScheduleEnd), zipRight6(set5(endAfterEmit, true)))), flatMap14(() => handoffConsumer))), unwrap);
            }
            return pipe(set5(sinkEndReason, signal.reason), zipRight6(set5(endAfterEmit, true)), fromEffect5);
          }
        }
      }));
    }), unwrap);
    const timeout5 = (lastB) => scheduleDriver.next(lastB);
    const scheduledAggregator = (sinkFiber, scheduleFiber, scope5) => {
      const forkSink = pipe(set5(consumed, false), zipRight6(set5(endAfterEmit, false)), zipRight6(pipe(handoffConsumer, pipeToOrFail(toChannel(sink)), collectElements, run2, forkIn2(scope5))));
      const handleSide = (leftovers, b, c) => pipe(set5(sinkLeftovers, flatten3(leftovers)), zipRight6(map18(get11(sinkEndReason), (reason) => {
        switch (reason._tag) {
          case OP_SCHEDULE_END: {
            return pipe(all7([get11(consumed), forkSink, pipe(timeout5(some2(b)), forkIn2(scope5))]), map18(([wasConsumed, sinkFiber2, scheduleFiber2]) => {
              const toWrite = pipe(c, match2({
                onNone: () => of2(right2(b)),
                onSome: (c2) => make6(right2(b), left2(c2))
              }));
              if (wasConsumed) {
                return pipe(write(toWrite), flatMap14(() => scheduledAggregator(sinkFiber2, scheduleFiber2, scope5)));
              }
              return scheduledAggregator(sinkFiber2, scheduleFiber2, scope5);
            }), unwrap);
          }
          case OP_UPSTREAM_END: {
            return pipe(get11(consumed), map18((wasConsumed) => wasConsumed ? write(of2(right2(b))) : void_7), unwrap);
          }
        }
      })), unwrap);
      return unwrap(raceWith2(join4(sinkFiber), join4(scheduleFiber), {
        onSelfDone: (sinkExit, _) => pipe(interrupt6(scheduleFiber), zipRight6(pipe(suspend4(() => sinkExit), map18(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
        onOtherDone: (scheduleExit, _) => matchCauseEffect3(suspend4(() => scheduleExit), {
          onFailure: (cause3) => match(failureOrCause2(cause3), {
            onLeft: () => pipe(handoff, offer5(end3(ScheduleEnd)), forkDaemon2, zipRight6(pipe(join4(sinkFiber), map18(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
            onRight: (cause4) => pipe(handoff, offer5(halt(cause4)), forkDaemon2, zipRight6(pipe(join4(sinkFiber), map18(([leftovers, b]) => handleSide(leftovers, b, none2())))))
          }),
          onSuccess: (c) => pipe(handoff, offer5(end3(ScheduleEnd)), forkDaemon2, zipRight6(pipe(join4(sinkFiber), map18(([leftovers, b]) => handleSide(leftovers, b, some2(c))))))
        })
      }));
    };
    return unwrapScopedWith3((scope5) => pipeTo(toChannel2(self), handoffProducer).pipe(run2, forkIn2(scope5), zipRight6(pipeToOrFail(handoffConsumer, toChannel(sink)).pipe(collectElements, run2, forkIn2(scope5), flatMap12((sinkFiber) => timeout5(none2()).pipe(forkIn2(scope5), map18((scheduleFiber) => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope5)))))))));
  }));
});
var as10 = /* @__PURE__ */ dual(2, (self, value3) => map24(self, () => value3));
var queueFromBufferOptions = (bufferSize) => {
  if (bufferSize === "unbounded") {
    return unbounded3();
  } else if (typeof bufferSize === "number" || bufferSize === void 0) {
    return bounded3(bufferSize ?? 16);
  }
  switch (bufferSize.strategy) {
    case "dropping":
      return dropping2(bufferSize.bufferSize ?? 16);
    case "sliding":
      return sliding2(bufferSize.bufferSize ?? 16);
    default:
      return bounded3(bufferSize.bufferSize ?? 16);
  }
};
var _async = (register, bufferSize) => acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown2(queue)).pipe(flatMap12((output3) => runtime4().pipe(flatMap12((runtime5) => sync5(() => {
  const runPromiseExit3 = runPromiseExit2(runtime5);
  const canceler = register(make51((resume2) => fromPull(resume2).pipe(flatMap12((take10) => offer3(output3, take10)), asVoid4, runPromiseExit3).then((exit4) => {
    if (isFailure2(exit4)) {
      if (!isInterrupted2(exit4.cause)) {
        throw squash(exit4.cause);
      }
    }
  })));
  return canceler;
})), map18((value3) => {
  const loop3 = take3(output3).pipe(flatMap12((take10) => done11(take10)), match14({
    onFailure: (maybeError) => fromEffect5(shutdown2(output3)).pipe(zipRight7(match2(maybeError, {
      onNone: () => void_7,
      onSome: (error2) => fail12(error2)
    }))),
    onSuccess: (chunk4) => write(chunk4).pipe(flatMap14(() => loop3))
  }), unwrap);
  return fromChannel2(loop3).pipe(ensuring7(value3 ?? _void));
}))), unwrapScoped4);
var asyncEffect3 = (register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown2(queue)), flatMap12((output3) => pipe(runtime4(), flatMap12((runtime5) => pipe(register(make51((k) => pipe(fromPull(k), flatMap12((take10) => offer3(output3, take10)), asVoid4, runPromiseExit2(runtime5)).then((exit4) => {
  if (isFailure2(exit4)) {
    if (!isInterrupted2(exit4.cause)) {
      throw squash(exit4.cause);
    }
  }
}))), map18(() => {
  const loop3 = pipe(take3(output3), flatMap12(done11), match14({
    onFailure: (maybeError) => pipe(fromEffect5(shutdown2(output3)), zipRight7(match2(maybeError, {
      onNone: () => void_7,
      onSome: fail12
    }))),
    onSuccess: (chunk4) => pipe(write(chunk4), flatMap14(() => loop3))
  }), unwrap);
  return loop3;
}))))), unwrapScoped3, fromChannel2);
var queueFromBufferOptionsPush = (options) => {
  if (options?.bufferSize === "unbounded" || options?.bufferSize === void 0 && options?.strategy === void 0) {
    return unbounded3();
  }
  switch (options?.strategy) {
    case "sliding":
      return sliding2(options.bufferSize ?? 16);
    default:
      return dropping2(options?.bufferSize ?? 16);
  }
};
var asyncPush = (register, options) => acquireRelease2(queueFromBufferOptionsPush(options), shutdown2).pipe(tap4((queue) => getWith(currentScheduler2, (scheduler2) => register(makePush(queue, scheduler2)))), map18((queue) => {
  const loop3 = flatMap14(take3(queue), (item) => isExit(item) ? isSuccess2(item) ? void_7 : failCause11(item.cause) : zipRight7(write(unsafeFromArray(item)), loop3));
  return loop3;
}), unwrapScoped3, fromChannel2);
var asyncScoped = (register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown2(queue)), flatMap12((output3) => pipe(runtime4(), flatMap12((runtime5) => pipe(register(make51((k) => pipe(fromPull(k), flatMap12((take10) => offer3(output3, take10)), asVoid4, runPromiseExit2(runtime5)).then((exit4) => {
  if (isFailure2(exit4)) {
    if (!isInterrupted2(exit4.cause)) {
      throw squash(exit4.cause);
    }
  }
}))), zipRight6(make25(false)), flatMap12((ref) => pipe(get11(ref), map18((isDone7) => isDone7 ? end5() : pipe(take3(output3), flatMap12(done11), onError2(() => pipe(set5(ref, true), zipRight6(shutdown2(output3)))))))))))), scoped6, flatMap17(repeatEffectChunkOption));
var branchAfter = /* @__PURE__ */ dual(3, (self, n, f) => suspend10(() => {
  const buffering = (acc) => readWith({
    onInput: (input) => {
      const nextSize = acc.length + input.length;
      if (nextSize >= n) {
        const [b1, b2] = pipe(input, splitAt2(n - acc.length));
        return running4(pipe(acc, appendAll2(b1)), b2);
      }
      return buffering(pipe(acc, appendAll2(input)));
    },
    onFailure: fail12,
    onDone: () => running4(acc, empty5())
  });
  const running4 = (prefix, leftover2) => pipeTo(zipRight7(write(leftover2), identityChannel()), toChannel2(f(prefix)));
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(buffering(empty5()))));
}));
var broadcast = /* @__PURE__ */ dual(3, (self, n, maximumLag) => pipe(self, broadcastedQueues(n, maximumLag), map18((tuple4) => tuple4.map((queue) => flattenTake(fromQueue2(queue, {
  shutdown: true
}))))));
var broadcastDynamic = /* @__PURE__ */ dual(2, (self, maximumLag) => map18(toPubSub2(self, maximumLag), (pubsub) => flattenTake(fromPubSub(pubsub))));
var share = /* @__PURE__ */ dual(2, (self, options) => map18(make47({
  acquire: broadcastDynamic(self, options),
  idleTimeToLive: options.idleTimeToLive
}), (rcRef) => unwrapScoped4(get15(rcRef))));
var broadcastedQueues = /* @__PURE__ */ dual(3, (self, n, maximumLag) => flatMap12(pubsubFromOptions(maximumLag), (pubsub) => pipe(all7(Array.from({
  length: n
}, () => subscribe2(pubsub))), tap4(() => forkScoped2(runIntoPubSubScoped(self, pubsub))))));
var broadcastedQueuesDynamic = /* @__PURE__ */ dual(2, (self, maximumLag) => map18(toPubSub2(self, maximumLag), subscribe2));
var buffer = /* @__PURE__ */ dual(2, (self, options) => {
  if (options.capacity === "unbounded") {
    return bufferUnbounded(self);
  } else if (options.strategy === "dropping") {
    return bufferDropping(self, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferSliding(self, options.capacity);
  }
  const queue = toQueueOfElements(self, options);
  return new StreamImpl(unwrapScoped3(map18(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take3(queue2)), flatMap14(match9({
      onFailure: (cause3) => pipe(flipCauseOption2(cause3), match2({
        onNone: () => void_7,
        onSome: failCause11
      })),
      onSuccess: (value3) => flatMap14(write(of2(value3)), () => process2)
    })));
    return process2;
  })));
});
var bufferChunks = /* @__PURE__ */ dual(2, (self, options) => {
  if (options.strategy === "dropping") {
    return bufferChunksDropping(self, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferChunksSliding(self, options.capacity);
  }
  const queue = toQueue2(self, options);
  return new StreamImpl(unwrapScoped3(map18(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take3(queue2)), flatMap14(match19({
      onEnd: () => void_7,
      onFailure: failCause11,
      onSuccess: (value3) => pipe(write(value3), flatMap14(() => process2))
    })));
    return process2;
  })));
});
var bufferChunksDropping = /* @__PURE__ */ dual(2, (self, capacity7) => {
  const queue = acquireRelease2(dropping2(capacity7), (queue2) => shutdown2(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self)));
});
var bufferChunksSliding = /* @__PURE__ */ dual(2, (self, capacity7) => {
  const queue = acquireRelease2(sliding2(capacity7), (queue2) => shutdown2(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self)));
});
var bufferDropping = /* @__PURE__ */ dual(2, (self, capacity7) => {
  const queue = acquireRelease2(dropping2(capacity7), (queue2) => shutdown2(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(rechunk(1)(self))));
});
var bufferSliding = /* @__PURE__ */ dual(2, (self, capacity7) => {
  const queue = acquireRelease2(sliding2(capacity7), (queue2) => shutdown2(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(pipe(self, rechunk(1)))));
});
var bufferUnbounded = (self) => {
  const queue = toQueue2(self, {
    strategy: "unbounded"
  });
  return new StreamImpl(unwrapScoped3(map18(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take3(queue2)), flatMap14(match19({
      onEnd: () => void_7,
      onFailure: failCause11,
      onSuccess: (value3) => flatMap14(write(value3), () => process2)
    })));
    return process2;
  })));
};
var bufferSignal = (scoped8, bufferChannel) => {
  const producer = (queue, ref) => {
    const terminate = (take10) => pipe(get11(ref), tap4(_await), zipRight6(make23()), flatMap12((deferred) => pipe(offer3(queue, [take10, deferred]), zipRight6(set5(ref, deferred)), zipRight6(_await(deferred)))), asVoid4, fromEffect5);
    return readWithCause({
      onInput: (input) => pipe(make23(), flatMap12((deferred) => pipe(offer3(queue, [chunk2(input), deferred]), flatMap12((added) => pipe(set5(ref, deferred), when2(() => added))))), asVoid4, fromEffect5, flatMap14(() => producer(queue, ref))),
      onFailure: (error2) => terminate(failCause12(error2)),
      onDone: () => terminate(end4)
    });
  };
  const consumer = (queue) => {
    const process2 = pipe(fromEffect5(take3(queue)), flatMap14(([take10, deferred]) => zipRight7(fromEffect5(succeed2(deferred, void 0)), match19(take10, {
      onEnd: () => void_7,
      onFailure: failCause11,
      onSuccess: (value3) => pipe(write(value3), flatMap14(() => process2))
    }))));
    return process2;
  };
  return unwrapScoped3(pipe(scoped8, flatMap12((queue) => pipe(make23(), tap4((start5) => succeed2(start5, void 0)), flatMap12((start5) => pipe(make25(start5), flatMap12((ref) => pipe(bufferChannel, pipeTo(producer(queue, ref)), runScoped, forkScoped2)), as6(consumer(queue))))))));
};
var catchAll7 = /* @__PURE__ */ dual(2, (self, f) => catchAllCause6(self, (cause3) => match(failureOrCause2(cause3), {
  onLeft: f,
  onRight: failCause14
})));
var catchAllCause6 = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), catchAllCause5((cause3) => toChannel2(f(cause3))))));
var catchSome3 = /* @__PURE__ */ dual(2, (self, pf) => pipe(self, catchAll7((error2) => pipe(pf(error2), getOrElse3(() => fail16(error2))))));
var catchSomeCause3 = /* @__PURE__ */ dual(2, (self, pf) => pipe(self, catchAllCause6((cause3) => pipe(pf(cause3), getOrElse3(() => failCause14(cause3))))));
var catchTag3 = /* @__PURE__ */ dual(3, (self, k, f) => catchAll7(self, (e) => {
  if ("_tag" in e && e["_tag"] === k) {
    return f(e);
  }
  return fail16(e);
}));
var catchTags3 = /* @__PURE__ */ dual(2, (self, cases) => catchAll7(self, (e) => {
  const keys6 = Object.keys(cases);
  if ("_tag" in e && keys6.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return fail16(e);
}));
var changes = (self) => pipe(self, changesWith((x, y) => equals(y)(x)));
var changesWith = /* @__PURE__ */ dual(2, (self, f) => {
  const writer = (last5) => readWithCause({
    onInput: (input) => {
      const [newLast, newChunk] = reduce2(input, [last5, empty5()], ([option5, outputs], output3) => {
        if (isSome2(option5) && f(option5.value, output3)) {
          return [some2(output3), outputs];
        }
        return [some2(output3), pipe(outputs, append2(output3))];
      });
      return flatMap14(write(newChunk), () => writer(newLast));
    },
    onFailure: failCause11,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer(none2()))));
});
var changesWithEffect = /* @__PURE__ */ dual(2, (self, f) => {
  const writer = (last5) => readWithCause({
    onInput: (input) => pipe(input, reduce12([last5, empty5()], ([option5, outputs], output3) => {
      if (isSome2(option5)) {
        return pipe(f(option5.value, output3), map18((bool2) => bool2 ? [some2(output3), outputs] : [some2(output3), pipe(outputs, append2(output3))]));
      }
      return succeed10([some2(output3), pipe(outputs, append2(output3))]);
    }), fromEffect5, flatMap14(([newLast, newChunk]) => pipe(write(newChunk), flatMap14(() => writer(newLast))))),
    onFailure: failCause11,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer(none2()))));
});
var chunks = (self) => pipe(self, mapChunks(of2));
var chunksWith = /* @__PURE__ */ dual(2, (self, f) => flattenChunks(f(chunks(self))));
var unsome = (effect4) => catchAll3(asSome2(effect4), (o) => o._tag === "None" ? succeedNone2 : fail10(o.value));
var combine9 = /* @__PURE__ */ dual(4, (self, that, s, f) => {
  function producer(handoff, latch) {
    return fromEffect5(take6(latch)).pipe(zipRight7(readWithCause({
      onInput: (input) => flatMap14(fromEffect5(offer5(handoff, succeed4(input))), () => producer(handoff, latch)),
      onFailure: (cause3) => fromEffect5(offer5(handoff, failCause4(pipe(cause3, map14(some2))))),
      onDone: () => flatMap14(fromEffect5(offer5(handoff, fail4(none2()))), () => producer(handoff, latch))
    })));
  }
  return new StreamImpl(unwrapScopedWith((scope5) => all7([make52(), make52(), make52(), make52()]).pipe(tap4(([left3, _, latchL]) => toChannel2(self).pipe(concatMap(writeChunk), pipeTo(producer(left3, latchL)), runIn(scope5), forkIn2(scope5))), tap4(([, right3, _, rightL]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3, rightL)), runIn(scope5), forkIn2(scope5))), map18(([left3, right3, latchL, latchR]) => {
    const pullLeft = offer5(latchL, void 0).pipe(zipRight6(take6(left3).pipe(flatMap12(identity))));
    const pullRight = offer5(latchR, void 0).pipe(zipRight6(take6(right3).pipe(flatMap12(identity))));
    return toChannel2(unfoldEffect(s, (s2) => flatMap12(f(s2, pullLeft, pullRight), unsome)));
  }))));
});
var combineChunks = /* @__PURE__ */ dual(4, (self, that, s, f) => {
  const producer = (handoff, latch) => zipRight7(fromEffect5(take6(latch)), readWithCause({
    onInput: (input) => flatMap14(fromEffect5(pipe(handoff, offer5(chunk2(input)))), () => producer(handoff, latch)),
    onFailure: (cause3) => fromEffect5(offer5(handoff, failCause12(cause3))),
    onDone: () => fromEffect5(offer5(handoff, end4))
  }));
  return new StreamImpl(unwrapScopedWith((scope5) => all7([make52(), make52(), make52(), make52()]).pipe(tap4(([left3, _, latchL]) => pipeTo(toChannel2(self), producer(left3, latchL)).pipe(runIn(scope5), forkIn2(scope5))), tap4(([_, right3, __, latchR]) => pipeTo(toChannel2(that), producer(right3, latchR)).pipe(runIn(scope5), forkIn2(scope5))), map18(([left3, right3, latchL, latchR]) => {
    const pullLeft = offer5(latchL, void 0).pipe(zipRight6(take6(left3).pipe(flatMap12(done11))));
    const pullRight = offer5(latchR, void 0).pipe(zipRight6(take6(right3).pipe(flatMap12(done11))));
    return toChannel2(unfoldChunkEffect(s, (s2) => flatMap12(f(s2, pullLeft, pullRight), unsome)));
  }))));
});
var concat2 = /* @__PURE__ */ dual(2, (self, that) => new StreamImpl(pipe(toChannel2(self), zipRight7(toChannel2(that)))));
var concatAll2 = (streams) => suspend10(() => pipe(streams, reduce2(empty33, (x, y) => concat2(y)(x))));
var cross = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, a2) => [a, a2])));
var crossLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, _) => a)));
var crossRight = /* @__PURE__ */ dual(2, (left3, right3) => flatMap17(left3, () => right3));
var crossWith = /* @__PURE__ */ dual(3, (left3, right3, f) => pipe(left3, flatMap17((a) => pipe(right3, map24((b) => f(a, b))))));
var debounce = /* @__PURE__ */ dual(2, (self, duration4) => unwrapScopedWith3((scope5) => gen3(function* () {
  const handoff = yield* make52();
  function enqueue(last5) {
    return sleep2(duration4).pipe(as6(last5), forkIn2(scope5), map18((fiber) => consumer(previous(fiber))));
  }
  const producer = readWithCause({
    onInput: (input) => match2(last2(input), {
      onNone: () => producer,
      onSome: (elem) => fromEffect5(offer5(handoff, emit(of2(elem)))).pipe(flatMap14(() => producer))
    }),
    onFailure: (cause3) => fromEffect5(offer5(handoff, halt(cause3))),
    onDone: () => fromEffect5(offer5(handoff, end3(UpstreamEnd)))
  });
  function consumer(state) {
    switch (state._tag) {
      case OP_NOT_STARTED: {
        return unwrap(take6(handoff).pipe(map18((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause11(signal.cause);
            }
            case OP_END: {
              return void_7;
            }
          }
        })));
      }
      case OP_PREVIOUS: {
        return unwrap(take6(handoff).pipe(forkIn2(scope5), flatMap12((handoffFiber) => raceWith2(join4(state.fiber), join4(handoffFiber), {
          onSelfDone: (leftExit, current2) => match9(leftExit, {
            onFailure: (cause3) => interrupt6(current2).pipe(as6(failCause11(cause3))),
            onSuccess: (chunk4) => interrupt6(current2).pipe(zipRight6(succeed10(write(chunk4).pipe(flatMap14(() => consumer(current(handoffFiber)))))))
          }),
          onOtherDone: (rightExit, previous2) => match9(rightExit, {
            onFailure: (cause3) => interrupt6(previous2).pipe(as6(failCause11(cause3))),
            onSuccess: (signal) => {
              switch (signal._tag) {
                case OP_EMIT4: {
                  return interrupt6(previous2).pipe(zipRight6(enqueue(signal.elements)));
                }
                case OP_HALT: {
                  return interrupt6(previous2).pipe(as6(failCause11(signal.cause)));
                }
                case OP_END: {
                  return join4(previous2).pipe(map18((chunk4) => write(chunk4).pipe(zipRight7(void_7))));
                }
              }
            }
          })
        }))));
      }
      case OP_CURRENT: {
        return unwrap(join4(state.fiber).pipe(map18((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause11(signal.cause);
            }
            case OP_END: {
              return void_7;
            }
          }
        })));
      }
    }
  }
  return scopedWith4((scope6) => pipeTo(toChannel2(self), producer).pipe(runIn(scope6), forkIn2(scope6))).pipe(crossRight(new StreamImpl(consumer(notStarted))));
})));
var die10 = (defect) => fromEffect8(die6(defect));
var dieSync6 = (evaluate3) => fromEffect8(dieSync3(evaluate3));
var dieMessage4 = (message) => fromEffect8(dieMessage2(message));
var distributedWith = /* @__PURE__ */ dual(2, (self, options) => pipe(make23(), flatMap12((deferred) => pipe(self, distributedWithDynamic({
  maximumLag: options.maximumLag,
  decide: (a) => flatMap12(_await(deferred), (f) => f(a))
}), flatMap12((next4) => pipe(all7(map4(range(0, options.size - 1), (id3) => map18(next4, ([key, queue]) => [[key, id3], queue]))), map18(unsafeFromArray), flatMap12((entries3) => {
  const [mappings, queues] = reduceRight2(entries3, [/* @__PURE__ */ new Map(), empty5()], ([mappings2, queues2], [mapping, queue]) => [mappings2.set(mapping[0], mapping[1]), pipe(queues2, prepend2(queue))]);
  return pipe(succeed2(deferred, (a) => map18(options.decide(a), (f) => (key) => pipe(f(mappings.get(key))))), as6(Array.from(queues)));
})))))));
var distributedWithDynamicId = {
  ref: 0
};
var newDistributedWithDynamicId = () => {
  const current2 = distributedWithDynamicId.ref;
  distributedWithDynamicId.ref = current2 + 1;
  return current2;
};
var distributedWithDynamic = /* @__PURE__ */ dual(2, (self, options) => distributedWithDynamicCallback(self, options.maximumLag, options.decide, () => _void));
var distributedWithDynamicCallback = /* @__PURE__ */ dual(4, (self, maximumLag, decide, done12) => pipe(acquireRelease2(make25(/* @__PURE__ */ new Map()), (ref, _) => pipe(get11(ref), flatMap12((queues) => pipe(queues.values(), forEach10(shutdown2))))), flatMap12((queuesRef) => gen3(function* () {
  const offer6 = (a) => pipe(decide(a), flatMap12((shouldProcess) => pipe(get11(queuesRef), flatMap12((queues) => pipe(queues.entries(), reduce12(empty5(), (acc, [id3, queue]) => {
    if (shouldProcess(id3)) {
      return pipe(offer3(queue, succeed4(a)), matchCauseEffect3({
        onFailure: (cause3) => (
          // Ignore all downstream queues that were shut
          // down and remove them later
          isInterrupted2(cause3) ? succeed10(pipe(acc, prepend2(id3))) : failCause9(cause3)
        ),
        onSuccess: () => succeed10(acc)
      }));
    }
    return succeed10(acc);
  }), flatMap12((ids3) => {
    if (isNonEmpty(ids3)) {
      return pipe(update3(queuesRef, (map31) => {
        for (const id3 of ids3) {
          map31.delete(id3);
        }
        return map31;
      }));
    }
    return _void;
  }))))), asVoid4);
  const queuesLock = yield* makeSemaphore2(1);
  const newQueue = yield* make25(pipe(bounded3(maximumLag), flatMap12((queue) => {
    const id3 = newDistributedWithDynamicId();
    return pipe(update3(queuesRef, (map31) => map31.set(id3, queue)), as6([id3, queue]));
  })));
  const finalize = (endTake) => (
    // Make sure that no queues are currently being added
    queuesLock.withPermits(1)(pipe(set5(newQueue, pipe(
      // All newly created queues should end immediately
      bounded3(1),
      tap4((queue) => offer3(queue, endTake)),
      flatMap12((queue) => {
        const id3 = newDistributedWithDynamicId();
        return pipe(update3(queuesRef, (map31) => map31.set(id3, queue)), as6(make5(id3, queue)));
      })
    )), zipRight6(pipe(get11(queuesRef), flatMap12((map31) => pipe(fromIterable3(map31.values()), forEach10((queue) => pipe(offer3(queue, endTake), catchSomeCause2((cause3) => isInterrupted2(cause3) ? some2(_void) : none2()))))))), zipRight6(done12(endTake)), asVoid4))
  );
  yield* pipe(self, runForEachScoped(offer6), matchCauseEffect3({
    onFailure: (cause3) => finalize(failCause4(pipe(cause3, map14(some2)))),
    onSuccess: () => finalize(fail4(none2()))
  }), forkScoped2);
  return queuesLock.withPermits(1)(flatten9(get11(newQueue)));
}))));
var drain3 = (self) => new StreamImpl(drain(toChannel2(self)));
var drainFork = /* @__PURE__ */ dual(2, (self, that) => fromEffect8(make23()).pipe(flatMap17((backgroundDied) => scopedWith4((scope5) => toChannel2(that).pipe(drain, runIn(scope5), catchAllCause3((cause3) => failCause2(backgroundDied, cause3)), forkIn2(scope5))).pipe(crossRight(interruptWhenDeferred2(self, backgroundDied))))));
var drop3 = /* @__PURE__ */ dual(2, (self, n) => {
  const loop3 = (r) => readWith({
    onInput: (input) => {
      const dropped = pipe(input, drop2(r));
      const leftover2 = Math.max(0, r - input.length);
      const more = isEmpty(input) || leftover2 > 0;
      if (more) {
        return loop3(leftover2);
      }
      return pipe(write(dropped), zipRight7(identityChannel()));
    },
    onFailure: fail12,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3(n))));
});
var dropRight2 = /* @__PURE__ */ dual(2, (self, n) => {
  if (n <= 0) {
    return identityStream();
  }
  return suspend10(() => {
    const queue = new RingBuffer(n);
    const reader = readWith({
      onInput: (input) => {
        const outputs = pipe(input, filterMap4((elem) => {
          const head8 = queue.head();
          queue.put(elem);
          return head8;
        }));
        return pipe(write(outputs), flatMap14(() => reader));
      },
      onFailure: fail12,
      onDone: () => void_7
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(reader)));
  });
});
var dropUntil3 = /* @__PURE__ */ dual(2, (self, predicate) => drop3(dropWhile4(self, (a) => !predicate(a)), 1));
var dropUntilEffect = /* @__PURE__ */ dual(2, (self, predicate) => {
  const loop3 = readWith({
    onInput: (input) => pipe(dropUntil2(input, predicate), map18(unsafeFromArray), map18((leftover2) => {
      const more = isEmpty(leftover2);
      if (more) {
        return suspend6(() => loop3);
      }
      return pipe(write(leftover2), zipRight7(identityChannel()));
    }), unwrap),
    onFailure: fail12,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3)));
});
var dropWhile4 = /* @__PURE__ */ dual(2, (self, predicate) => {
  const loop3 = readWith({
    onInput: (input) => {
      const output3 = dropWhile(input, predicate);
      if (isEmpty(output3)) {
        return suspend6(() => loop3);
      }
      return zipRight7(write(output3), identityChannel());
    },
    onFailure: fail12,
    onDone: succeedNow
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self), loop3));
});
var dropWhileEffect = /* @__PURE__ */ dual(2, (self, predicate) => {
  const loop3 = readWith({
    onInput: (input) => pipe(dropWhile3(input, predicate), map18(unsafeFromArray), map18((leftover2) => {
      const more = isEmpty(leftover2);
      if (more) {
        return suspend6(() => loop3);
      }
      return zipRight7(write(leftover2), identityChannel());
    }), unwrap),
    onFailure: fail12,
    onDone: () => void_7
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self), loop3));
});
var either6 = (self) => pipe(self, map24(right2), catchAll7((error2) => make53(left2(error2))));
var empty33 = /* @__PURE__ */ new StreamImpl(void_7);
var ensuring7 = /* @__PURE__ */ dual(2, (self, finalizer3) => new StreamImpl(pipe(toChannel2(self), ensuring4(finalizer3))));
var ensuringWith2 = /* @__PURE__ */ dual(2, (self, finalizer3) => new StreamImpl(ensuringWith(toChannel2(self), finalizer3)));
var context5 = () => fromEffect8(context3());
var contextWith3 = (f) => pipe(context5(), map24(f));
var contextWithEffect3 = (f) => pipe(context5(), mapEffectSequential(f));
var contextWithStream = (f) => pipe(context5(), flatMap17(f));
var execute = (effect4) => drain3(fromEffect8(effect4));
var fail16 = (error2) => fromEffectOption(fail10(some2(error2)));
var failSync7 = (evaluate3) => fromEffectOption(failSync3(() => some2(evaluate3())));
var failCause14 = (cause3) => fromEffect8(failCause9(cause3));
var failCauseSync6 = (evaluate3) => fromEffect8(failCauseSync3(evaluate3));
var filter10 = /* @__PURE__ */ dual(2, (self, predicate) => mapChunks(self, filter3(predicate)));
var filterEffect = /* @__PURE__ */ dual(2, (self, f) => {
  const loop3 = (iterator) => {
    const next4 = iterator.next();
    if (next4.done) {
      return readWithCause({
        onInput: (input) => loop3(input[Symbol.iterator]()),
        onFailure: failCause11,
        onDone: succeed12
      });
    } else {
      return pipe(f(next4.value), map18((bool2) => bool2 ? pipe(write(of2(next4.value)), flatMap14(() => loop3(iterator))) : loop3(iterator)), unwrap);
    }
  };
  return new StreamImpl(suspend6(() => pipe(toChannel2(self), pipeTo(loop3(empty5()[Symbol.iterator]())))));
});
var filterMap9 = /* @__PURE__ */ dual(2, (self, pf) => mapChunks(self, filterMap4(pf)));
var filterMapEffect = /* @__PURE__ */ dual(2, (self, pf) => suspend10(() => {
  const loop3 = (iterator) => {
    const next4 = iterator.next();
    if (next4.done) {
      return readWithCause({
        onInput: (input) => loop3(input[Symbol.iterator]()),
        onFailure: failCause11,
        onDone: succeed12
      });
    } else {
      return pipe(pf(next4.value), match2({
        onNone: () => sync5(() => loop3(iterator)),
        onSome: map18((a2) => flatMap14(write(of2(a2)), () => loop3(iterator)))
      }), unwrap);
    }
  };
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3(empty5()[Symbol.iterator]()))));
}));
var filterMapWhile3 = /* @__PURE__ */ dual(2, (self, pf) => {
  const loop3 = readWith({
    onInput: (input) => {
      const mapped = filterMapWhile2(input, pf);
      if (mapped.length === input.length) {
        return pipe(write(mapped), flatMap14(() => loop3));
      }
      return write(mapped);
    },
    onFailure: fail12,
    onDone: succeed12
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3)));
});
var filterMapWhileEffect = /* @__PURE__ */ dual(2, (self, pf) => suspend10(() => {
  const loop3 = (iterator) => {
    const next4 = iterator.next();
    if (next4.done) {
      return readWithCause({
        onInput: (input) => loop3(input[Symbol.iterator]()),
        onFailure: failCause11,
        onDone: succeed12
      });
    } else {
      return unwrap(match2(pf(next4.value), {
        onNone: () => succeed10(void_7),
        onSome: map18((a2) => flatMap14(write(of2(a2)), () => loop3(iterator)))
      }));
    }
  };
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3(empty5()[Symbol.iterator]()))));
}));
var finalizer = (finalizer3) => acquireRelease3(_void, () => finalizer3);
var find2 = /* @__PURE__ */ dual(2, (self, predicate) => {
  const loop3 = readWith({
    onInput: (input) => match2(findFirst3(input, predicate), {
      onNone: () => loop3,
      onSome: (n) => write(of2(n))
    }),
    onFailure: fail12,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3)));
});
var findEffect = /* @__PURE__ */ dual(2, (self, predicate) => {
  const loop3 = readWith({
    onInput: (input) => pipe(findFirst8(input, predicate), map18(match2({
      onNone: () => loop3,
      onSome: (n) => write(of2(n))
    })), unwrap),
    onFailure: fail12,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3)));
});
var flatMap17 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, f, options) => {
  const bufferSize = options?.bufferSize ?? 16;
  if (options?.switch) {
    return matchConcurrency(options?.concurrency, () => flatMapParSwitchBuffer(self, 1, bufferSize, f), (n) => flatMapParSwitchBuffer(self, n, bufferSize, f));
  }
  return matchConcurrency(options?.concurrency, () => new StreamImpl(concatMap(toChannel2(self), (as13) => pipe(as13, map4((a) => toChannel2(f(a))), reduce2(void_7, (left3, right3) => pipe(left3, zipRight7(right3)))))), (_) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), options))));
});
var matchConcurrency = (concurrency, sequential5, bounded8) => {
  switch (concurrency) {
    case void 0:
      return sequential5();
    case "unbounded":
      return bounded8(Number.MAX_SAFE_INTEGER);
    default:
      return concurrency > 1 ? bounded8(concurrency) : sequential5();
  }
};
var flatMapParSwitchBuffer = /* @__PURE__ */ dual(4, (self, n, bufferSize, f) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), {
  concurrency: n,
  mergeStrategy: BufferSliding(),
  bufferSize
}))));
var flatten13 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options) => flatMap17(self, identity, options));
var flattenChunks = (self) => {
  const flatten19 = readWithCause({
    onInput: (chunks3) => flatMap14(writeChunk(chunks3), () => flatten19),
    onFailure: failCause11,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(flatten19)));
};
var flattenEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options) => options?.unordered ? flatMap17(self, (a) => fromEffect8(a), {
  concurrency: options.concurrency
}) : matchConcurrency(options?.concurrency, () => mapEffectSequential(self, identity), (n) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mapOutEffectPar(identity, n), mapOut(of2)))));
var flattenExitOption = (self) => {
  const processChunk = (chunk4, cont) => {
    const [toEmit, rest] = pipe(chunk4, splitWhere((exit4) => !isSuccess2(exit4)));
    const next4 = pipe(head2(rest), match2({
      onNone: () => cont,
      onSome: match9({
        onFailure: (cause3) => match2(flipCauseOption2(cause3), {
          onNone: () => void_7,
          onSome: failCause11
        }),
        onSuccess: () => void_7
      })
    }));
    return pipe(write(pipe(toEmit, filterMap4((exit4) => isSuccess2(exit4) ? some2(exit4.value) : none2()))), flatMap14(() => next4));
  };
  const process2 = readWithCause({
    onInput: (chunk4) => processChunk(chunk4, process2),
    onFailure: (cause3) => failCause11(cause3),
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(process2)));
};
var flattenIterables = (self) => pipe(self, map24(fromIterable3), flattenChunks);
var flattenTake = (self) => flattenChunks(flattenExitOption(pipe(self, map24((take10) => take10.exit))));
var forever5 = (self) => new StreamImpl(repeated(toChannel2(self)));
var fromAsyncIterable = (iterable, onError5) => pipe(acquireRelease2(sync5(() => iterable[Symbol.asyncIterator]()), (iterator) => iterator.return ? promise2(async () => iterator.return()) : _void), map18((iterator) => repeatEffectOption(pipe(tryPromise2({
  try: async () => iterator.next(),
  catch: (reason) => some2(onError5(reason))
}), flatMap12((result) => result.done ? fail10(none2()) : succeed10(result.value))))), unwrapScoped4);
var fromChannel2 = (channel) => new StreamImpl(channel);
var toChannel2 = (stream4) => {
  if ("channel" in stream4) {
    return stream4.channel;
  } else if (isEffect2(stream4)) {
    return toChannel2(fromEffect8(stream4));
  } else {
    throw new TypeError(`Expected a Stream.`);
  }
};
var fromChunk = (chunk4) => new StreamImpl(isEmpty(chunk4) ? void_7 : write(chunk4));
var fromChunkPubSub = (pubsub, options) => {
  if (options?.scoped) {
    const effect4 = map18(subscribe2(pubsub), fromChunkQueue);
    return options.shutdown ? map18(effect4, ensuring7(shutdown4(pubsub))) : effect4;
  }
  const stream4 = flatMap17(scoped6(subscribe2(pubsub)), fromChunkQueue);
  return options?.shutdown ? ensuring7(stream4, shutdown4(pubsub)) : stream4;
};
var fromChunkQueue = (queue, options) => pipe(take3(queue), catchAllCause3((cause3) => pipe(isShutdown2(queue), flatMap12((isShutdown7) => isShutdown7 && isInterrupted2(cause3) ? end5() : failCause13(cause3)))), repeatEffectChunkOption, options?.shutdown ? ensuring7(shutdown2(queue)) : identity);
var fromChunks = (...chunks3) => pipe(fromIterable14(chunks3), flatMap17(fromChunk));
var fromEffect8 = (effect4) => pipe(effect4, mapError3(some2), fromEffectOption);
var fromEffectOption = (effect4) => new StreamImpl(unwrap(match14(effect4, {
  onFailure: match2({
    onNone: () => void_7,
    onSome: fail12
  }),
  onSuccess: (a) => write(of2(a))
})));
var fromPubSub = (pubsub, options) => {
  const maxChunkSize = options?.maxChunkSize ?? DefaultChunkSize;
  if (options?.scoped) {
    const effect4 = map18(subscribe2(pubsub), (queue) => fromQueue2(queue, {
      maxChunkSize,
      shutdown: true
    }));
    return options.shutdown ? map18(effect4, ensuring7(shutdown4(pubsub))) : effect4;
  }
  const stream4 = flatMap17(scoped6(subscribe2(pubsub)), (queue) => fromQueue2(queue, {
    maxChunkSize
  }));
  return options?.shutdown ? ensuring7(stream4, shutdown4(pubsub)) : stream4;
};
var fromTPubSub = (pubsub) => {
  return unwrapScoped4(map18(subscribeScoped2(pubsub), (queue) => fromTQueue(queue)));
};
var fromIterable14 = (iterable) => suspend10(() => isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]()));
var fromIterableEffect = (effect4) => pipe(effect4, map18(fromIterable14), unwrap2);
var fromIteratorSucceed = (iterator, maxChunkSize = DefaultChunkSize) => {
  return pipe(sync5(() => {
    let builder = [];
    const loop3 = (iterator2) => pipe(sync5(() => {
      let next4 = iterator2.next();
      if (maxChunkSize === 1) {
        if (next4.done) {
          return void_7;
        }
        return pipe(write(of2(next4.value)), flatMap14(() => loop3(iterator2)));
      }
      builder = [];
      let count4 = 0;
      while (next4.done === false) {
        builder.push(next4.value);
        count4 = count4 + 1;
        if (count4 >= maxChunkSize) {
          break;
        }
        next4 = iterator2.next();
      }
      if (count4 > 0) {
        return pipe(write(unsafeFromArray(builder)), flatMap14(() => loop3(iterator2)));
      }
      return void_7;
    }), unwrap);
    return new StreamImpl(loop3(iterator));
  }), unwrap2);
};
var fromPull2 = (effect4) => pipe(effect4, map18(repeatEffectChunkOption), unwrapScoped4);
var fromQueue2 = (queue, options) => pipe(takeBetween2(queue, 1, options?.maxChunkSize ?? DefaultChunkSize), catchAllCause3((cause3) => pipe(isShutdown2(queue), flatMap12((isShutdown7) => isShutdown7 && isInterrupted2(cause3) ? end5() : failCause13(cause3)))), repeatEffectChunkOption, options?.shutdown ? ensuring7(shutdown2(queue)) : identity);
var fromTQueue = (queue) => pipe(take5(queue), map18(of2), catchAllCause3((cause3) => pipe(isShutdown6(queue), flatMap12((isShutdown7) => isShutdown7 && isInterrupted2(cause3) ? end5() : failCause13(cause3)))), repeatEffectChunkOption);
var fromSchedule = (schedule4) => pipe(driver2(schedule4), map18((driver3) => repeatEffectOption(driver3.next(void 0))), unwrap2);
var fromReadableStream = (...args2) => {
  const evaluate3 = args2.length === 1 ? args2[0].evaluate : args2[0];
  const onError5 = args2.length === 1 ? args2[0].onError : args2[1];
  const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
  return unwrapScoped4(map18(acquireRelease2(sync5(() => evaluate3().getReader()), (reader) => releaseLockOnEnd ? sync5(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => repeatEffectOption(flatMap12(tryPromise2({
    try: () => reader.read(),
    catch: (reason) => some2(onError5(reason))
  }), ({
    done: done12,
    value: value3
  }) => done12 ? fail10(none2()) : succeed10(value3)))));
};
var fromReadableStreamByob = (...args2) => {
  const evaluate3 = args2.length === 1 ? args2[0].evaluate : args2[0];
  const onError5 = args2.length === 1 ? args2[0].onError : args2[1];
  const allocSize = (args2.length === 1 ? args2[0].bufferSize : args2[2]) ?? 4096;
  const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
  return unwrapScoped4(map18(acquireRelease2(sync5(() => evaluate3().getReader({
    mode: "byob"
  })), (reader) => releaseLockOnEnd ? sync5(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => catchAll7(forever5(readChunkStreamByobReader(reader, onError5, allocSize)), (error2) => error2 === EOF ? empty33 : fail16(error2))));
};
var EOF = /* @__PURE__ */ Symbol.for("effect/Stream/EOF");
var readChunkStreamByobReader = (reader, onError5, size17) => {
  const buffer3 = new ArrayBuffer(size17);
  return paginateEffect(0, (offset) => flatMap12(tryPromise2({
    try: () => reader.read(new Uint8Array(buffer3, offset, buffer3.byteLength - offset)),
    catch: (reason) => onError5(reason)
  }), ({
    done: done12,
    value: value3
  }) => {
    if (done12) {
      return fail10(EOF);
    }
    const newOffset = offset + value3.byteLength;
    return succeed10([value3, newOffset >= buffer3.byteLength ? none2() : some2(newOffset)]);
  }));
};
var groupAdjacentBy = /* @__PURE__ */ dual(2, (self, f) => {
  const groupAdjacentByChunk = (state, chunk4) => {
    if (isEmpty(chunk4)) {
      return [state, empty5()];
    }
    const builder = [];
    let from = 0;
    let until = 0;
    let key = void 0;
    let previousChunk = empty5();
    switch (state._tag) {
      case "Some": {
        const tuple4 = state.value;
        key = tuple4[0];
        let loop3 = true;
        while (loop3 && until < chunk4.length) {
          const input = unsafeGet4(chunk4, until);
          const updatedKey = f(input);
          if (!equals(key, updatedKey)) {
            const previousChunk2 = tuple4[1];
            const additionalChunk = unsafeFromArray(Array.from(chunk4).slice(from, until));
            const group = appendAll2(previousChunk2, additionalChunk);
            builder.push([key, group]);
            key = updatedKey;
            from = until;
            loop3 = false;
          }
          until = until + 1;
        }
        if (loop3) {
          previousChunk = tuple4[1];
        }
        break;
      }
      case "None": {
        key = f(unsafeGet4(chunk4, until));
        until = until + 1;
        break;
      }
    }
    while (until < chunk4.length) {
      const input = unsafeGet4(chunk4, until);
      const updatedKey = f(input);
      if (!equals(key, updatedKey)) {
        builder.push([key, unsafeFromArray(Array.from(chunk4).slice(from, until))]);
        key = updatedKey;
        from = until;
      }
      until = until + 1;
    }
    const nonEmptyChunk = appendAll2(previousChunk, unsafeFromArray(Array.from(chunk4).slice(from, until)));
    const output3 = unsafeFromArray(builder);
    return [some2([key, nonEmptyChunk]), output3];
  };
  const groupAdjacent = (state) => readWithCause({
    onInput: (input) => {
      const [updatedState, output3] = groupAdjacentByChunk(state, input);
      return isEmpty(output3) ? groupAdjacent(updatedState) : flatMap14(write(output3), () => groupAdjacent(updatedState));
    },
    onFailure: (cause3) => match2(state, {
      onNone: () => failCause11(cause3),
      onSome: (output3) => flatMap14(write(of2(output3)), () => failCause11(cause3))
    }),
    onDone: (done12) => match2(state, {
      onNone: () => succeedNow(done12),
      onSome: (output3) => flatMap14(write(of2(output3)), () => succeedNow(done12))
    })
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self), groupAdjacent(none2())));
});
var grouped = /* @__PURE__ */ dual(2, (self, chunkSize) => pipe(self, rechunk(chunkSize), chunks));
var groupedWithin = /* @__PURE__ */ dual(3, (self, chunkSize, duration4) => aggregateWithin(self, collectAllN(chunkSize), spaced2(duration4)));
var haltWhen = /* @__PURE__ */ dual(2, (self, effect4) => {
  const writer = (fiber) => pipe(poll3(fiber), map18(match2({
    onNone: () => readWith({
      onInput: (input) => flatMap14(write(input), () => writer(fiber)),
      onFailure: fail12,
      onDone: () => void_7
    }),
    onSome: match9({
      onFailure: failCause11,
      onSuccess: () => void_7
    })
  })), unwrap);
  return new StreamImpl(unwrapScopedWith((scope5) => effect4.pipe(forkIn2(scope5), map18((fiber) => toChannel2(self).pipe(pipeTo(writer(fiber)))))));
});
var haltAfter = /* @__PURE__ */ dual(2, (self, duration4) => pipe(self, haltWhen(sleep2(duration4))));
var haltWhenDeferred = /* @__PURE__ */ dual(2, (self, deferred) => {
  const writer = pipe(poll(deferred), map18(match2({
    onNone: () => readWith({
      onInput: (input) => pipe(write(input), flatMap14(() => writer)),
      onFailure: fail12,
      onDone: () => void_7
    }),
    onSome: (effect4) => unwrap(match14(effect4, {
      onFailure: fail12,
      onSuccess: () => void_7
    }))
  })), unwrap);
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer)));
});
var identityStream = () => new StreamImpl(identityChannel());
var interleave = /* @__PURE__ */ dual(2, (self, that) => pipe(self, interleaveWith(that, forever5(make53(true, false)))));
var interleaveWith = /* @__PURE__ */ dual(3, (self, that, decider) => {
  const producer = (handoff) => readWithCause({
    onInput: (value3) => flatMap14(fromEffect5(offer5(handoff, of5(value3))), () => producer(handoff)),
    onFailure: (cause3) => fromEffect5(offer5(handoff, failCause12(cause3))),
    onDone: () => fromEffect5(offer5(handoff, end4))
  });
  return new StreamImpl(unwrapScopedWith((scope5) => pipe(make52(), zip7(make52()), tap4(([left3]) => toChannel2(self).pipe(concatMap(writeChunk), pipeTo(producer(left3)), runIn(scope5), forkIn2(scope5))), tap4(([_, right3]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3)), runIn(scope5), forkIn2(scope5))), map18(([left3, right3]) => {
    const process2 = (leftDone, rightDone) => readWithCause({
      onInput: (bool2) => {
        if (bool2 && !leftDone) {
          return pipe(fromEffect5(take6(left3)), flatMap14(match19({
            onEnd: () => rightDone ? void_7 : process2(true, rightDone),
            onFailure: failCause11,
            onSuccess: (chunk4) => pipe(write(chunk4), flatMap14(() => process2(leftDone, rightDone)))
          })));
        }
        if (!bool2 && !rightDone) {
          return pipe(fromEffect5(take6(right3)), flatMap14(match19({
            onEnd: () => leftDone ? void_7 : process2(leftDone, true),
            onFailure: failCause11,
            onSuccess: (chunk4) => pipe(write(chunk4), flatMap14(() => process2(leftDone, rightDone)))
          })));
        }
        return process2(leftDone, rightDone);
      },
      onFailure: failCause11,
      onDone: () => void_7
    });
    return pipe(toChannel2(decider), concatMap(writeChunk), pipeTo(process2(false, false)));
  }))));
});
var intersperse = /* @__PURE__ */ dual(2, (self, element3) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(suspend6(() => {
  const writer = (isFirst) => readWithCause({
    onInput: (chunk4) => {
      const builder = [];
      let flagResult = isFirst;
      for (const output3 of chunk4) {
        if (flagResult) {
          flagResult = false;
          builder.push(output3);
        } else {
          builder.push(element3);
          builder.push(output3);
        }
      }
      return pipe(write(unsafeFromArray(builder)), flatMap14(() => writer(flagResult)));
    },
    onFailure: failCause11,
    onDone: () => void_7
  });
  return writer(true);
})))));
var intersperseAffixes = /* @__PURE__ */ dual(2, (self, {
  end: end6,
  middle,
  start: start5
}) => pipe(make53(start5), concat2(pipe(self, intersperse(middle))), concat2(make53(end6))));
var interruptAfter = /* @__PURE__ */ dual(2, (self, duration4) => pipe(self, interruptWhen2(sleep2(duration4))));
var interruptWhen2 = /* @__PURE__ */ dual(2, (self, effect4) => new StreamImpl(pipe(toChannel2(self), interruptWhen(effect4))));
var interruptWhenDeferred2 = /* @__PURE__ */ dual(2, (self, deferred) => new StreamImpl(pipe(toChannel2(self), interruptWhenDeferred(deferred))));
var iterate3 = (value3, next4) => unfold4(value3, (a) => some2([a, next4(a)]));
var make53 = (...as13) => fromIterable14(as13);
var map24 = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapOut(map4(f)))));
var mapAccum5 = /* @__PURE__ */ dual(3, (self, s, f) => {
  const accumulator = (s2) => readWith({
    onInput: (input) => {
      const [nextS, chunk4] = mapAccum2(input, s2, f);
      return flatMap14(write(chunk4), () => accumulator(nextS));
    },
    onFailure: fail12,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(accumulator(s))));
});
var mapAccumEffect = /* @__PURE__ */ dual(3, (self, s, f) => suspend10(() => {
  const accumulator = (s2) => readWith({
    onInput: (input) => pipe(suspend4(() => {
      const outputs = [];
      const emit2 = (output3) => sync5(() => {
        outputs.push(output3);
      });
      return pipe(input, reduce12(s2, (s3, a) => pipe(f(s3, a), flatMap12(([s4, a2]) => pipe(emit2(a2), as6(s4))))), match14({
        onFailure: (error2) => {
          if (outputs.length !== 0) {
            return zipRight7(write(unsafeFromArray(outputs)), fail12(error2));
          }
          return fail12(error2);
        },
        onSuccess: (s3) => flatMap14(write(unsafeFromArray(outputs)), () => accumulator(s3))
      }));
    }), unwrap),
    onFailure: fail12,
    onDone: () => void_7
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(accumulator(s))));
}));
var mapBoth7 = /* @__PURE__ */ dual(2, (self, options) => pipe(self, mapError6(options.onFailure), map24(options.onSuccess)));
var mapChunks = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapOut(f))));
var mapChunksEffect = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapOutEffect(f))));
var mapConcat = /* @__PURE__ */ dual(2, (self, f) => pipe(self, mapConcatChunk((a) => fromIterable3(f(a)))));
var mapConcatChunk = /* @__PURE__ */ dual(2, (self, f) => pipe(self, mapChunks(flatMap3(f))));
var mapConcatChunkEffect = /* @__PURE__ */ dual(2, (self, f) => pipe(self, mapEffectSequential(f), mapConcatChunk(identity)));
var mapConcatEffect = /* @__PURE__ */ dual(2, (self, f) => pipe(self, mapEffectSequential((a) => pipe(f(a), map18(fromIterable3))), mapConcatChunk(identity)));
var mapEffectSequential = /* @__PURE__ */ dual(2, (self, f) => {
  const loop3 = (iterator) => {
    const next4 = iterator.next();
    if (next4.done) {
      return readWithCause({
        onInput: (elem) => loop3(elem[Symbol.iterator]()),
        onFailure: failCause11,
        onDone: succeed12
      });
    } else {
      const value3 = next4.value;
      return unwrap(map18(f(value3), (a2) => flatMap14(write(of2(a2)), () => loop3(iterator))));
    }
  };
  return new StreamImpl(pipe(toChannel2(self), pipeTo(suspend6(() => loop3(empty5()[Symbol.iterator]())))));
});
var mapEffectPar = /* @__PURE__ */ dual(3, (self, n, f) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mapOutEffectPar(f, n), mapOut(of2))));
var mapError6 = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapError5(f))));
var mapErrorCause4 = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapErrorCause3(f))));
var merge9 = /* @__PURE__ */ dual((args2) => isStream(args2[1]), (self, that, options) => mergeWith3(self, that, {
  onSelf: identity,
  onOther: identity,
  haltStrategy: options?.haltStrategy
}));
var mergeAll8 = /* @__PURE__ */ dual((args2) => Symbol.iterator in args2[0], (streams, options) => flatten13(fromIterable14(streams), options));
var mergeWithTag = /* @__PURE__ */ dual(2, (streams, options) => {
  const keys6 = Object.keys(streams);
  const values5 = keys6.map((key) => streams[key].pipe(map24((value3) => ({
    _tag: key,
    value: value3
  }))));
  return mergeAll8(values5, options);
});
var mergeEither = /* @__PURE__ */ dual(2, (self, that) => mergeWith3(self, that, {
  onSelf: left2,
  onOther: right2
}));
var mergeLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, merge9(drain3(right3))));
var mergeRight = /* @__PURE__ */ dual(2, (left3, right3) => pipe(drain3(left3), merge9(right3)));
var mergeWith3 = /* @__PURE__ */ dual(3, (self, other, options) => {
  const strategy = options.haltStrategy ? fromInput2(options.haltStrategy) : Both2;
  const handler = (terminate) => (exit4) => terminate || !isSuccess2(exit4) ? (
    // TODO: remove
    Done4(suspend4(() => exit4))
  ) : Await2((exit5) => suspend4(() => exit5));
  return new StreamImpl(mergeWith2(toChannel2(map24(self, options.onSelf)), {
    other: toChannel2(map24(other, options.onOther)),
    onSelfDone: handler(strategy._tag === "Either" || strategy._tag === "Left"),
    onOtherDone: handler(strategy._tag === "Either" || strategy._tag === "Right")
  }));
});
var mkString2 = (self) => run4(self, mkString);
var never5 = /* @__PURE__ */ fromEffect8(never4);
var onEnd = /* @__PURE__ */ dual(2, (self, effect4) => concat2(self, drain3(fromEffect8(effect4))));
var onError3 = /* @__PURE__ */ dual(2, (self, cleanup) => pipe(self, catchAllCause6((cause3) => fromEffect8(pipe(cleanup(cause3), zipRight6(failCause9(cause3)))))));
var onDone = /* @__PURE__ */ dual(2, (self, cleanup) => new StreamImpl(pipe(toChannel2(self), ensuringWith((exit4) => isSuccess2(exit4) ? cleanup() : _void))));
var onStart = /* @__PURE__ */ dual(2, (self, effect4) => unwrap2(as6(effect4, self)));
var orDie5 = (self) => pipe(self, orDieWith4(identity));
var orDieWith4 = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), orDieWith3(f))));
var orElse9 = /* @__PURE__ */ dual(2, (self, that) => new StreamImpl(pipe(toChannel2(self), orElse8(() => toChannel2(that())))));
var orElseEither5 = /* @__PURE__ */ dual(2, (self, that) => pipe(self, map24(left2), orElse9(() => pipe(that(), map24(right2)))));
var orElseFail3 = /* @__PURE__ */ dual(2, (self, error2) => pipe(self, orElse9(() => failSync7(error2))));
var orElseIfEmpty = /* @__PURE__ */ dual(2, (self, element3) => pipe(self, orElseIfEmptyChunk(() => of2(element3()))));
var orElseIfEmptyChunk = /* @__PURE__ */ dual(2, (self, chunk4) => pipe(self, orElseIfEmptyStream(() => new StreamImpl(write(chunk4())))));
var orElseIfEmptyStream = /* @__PURE__ */ dual(2, (self, stream4) => {
  const writer = readWith({
    onInput: (input) => {
      if (isEmpty(input)) {
        return suspend6(() => writer);
      }
      return pipe(write(input), zipRight7(identityChannel()));
    },
    onFailure: fail12,
    onDone: () => suspend6(() => toChannel2(stream4()))
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(writer)));
});
var orElseSucceed3 = /* @__PURE__ */ dual(2, (self, value3) => pipe(self, orElse9(() => sync10(value3))));
var paginate = (s, f) => paginateChunk(s, (s2) => {
  const page = f(s2);
  return [of2(page[0]), page[1]];
});
var paginateChunk = (s, f) => {
  const loop3 = (s2) => {
    const page = f(s2);
    return match2(page[1], {
      onNone: () => zipRight7(write(page[0]), void_7),
      onSome: (s3) => flatMap14(write(page[0]), () => loop3(s3))
    });
  };
  return new StreamImpl(suspend6(() => loop3(s)));
};
var paginateChunkEffect = (s, f) => {
  const loop3 = (s2) => unwrap(map18(f(s2), ([chunk4, option5]) => match2(option5, {
    onNone: () => zipRight7(write(chunk4), void_7),
    onSome: (s3) => flatMap14(write(chunk4), () => loop3(s3))
  })));
  return new StreamImpl(suspend6(() => loop3(s)));
};
var paginateEffect = (s, f) => paginateChunkEffect(s, (s2) => pipe(f(s2), map18(([a, s3]) => [of2(a), s3])));
var peel = /* @__PURE__ */ dual(2, (self, sink) => {
  const OP_EMIT5 = "Emit";
  const OP_HALT2 = "Halt";
  const OP_END2 = "End";
  return pipe(make23(), flatMap12((deferred) => pipe(make52(), map18((handoff) => {
    const consumer = foldSink(collectLeftover(sink), {
      onFailure: (error2) => zipRight9(fromEffect7(fail3(deferred, error2)), fail13(error2)),
      onSuccess: ([z, leftovers]) => {
        const loop3 = readWithCause({
          onInput: (elements) => flatMap14(fromEffect5(offer5(handoff, {
            _tag: OP_EMIT5,
            elements
          })), () => loop3),
          onFailure: (cause3) => zipRight7(fromEffect5(offer5(handoff, {
            _tag: OP_HALT2,
            cause: cause3
          })), failCause11(cause3)),
          onDone: (_) => zipRight7(fromEffect5(offer5(handoff, {
            _tag: OP_END2
          })), void_7)
        });
        return fromChannel(pipe(fromEffect5(succeed2(deferred, z)), zipRight7(fromEffect5(pipe(handoff, offer5({
          _tag: OP_EMIT5,
          elements: leftovers
        })))), zipRight7(loop3)));
      }
    });
    const producer = pipe(take6(handoff), map18((signal) => {
      switch (signal._tag) {
        case OP_EMIT5: {
          return pipe(write(signal.elements), flatMap14(() => producer));
        }
        case OP_HALT2: {
          return failCause11(signal.cause);
        }
        case OP_END2: {
          return void_7;
        }
      }
    }), unwrap);
    return pipe(self, tapErrorCause5((cause3) => failCause2(deferred, cause3)), run4(consumer), forkScoped2, zipRight6(_await(deferred)), map18((z) => [z, new StreamImpl(producer)]));
  }))), flatten9);
});
var partition6 = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self, predicate, options) => partitionEither(self, (a) => succeed10(predicate(a) ? right2(a) : left2(a)), options));
var partitionEither = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self, predicate, options) => pipe(mapEffectSequential(self, predicate), distributedWith({
  size: 2,
  maximumLag: options?.bufferSize ?? 16,
  decide: match({
    onLeft: () => succeed10((n) => n === 0),
    onRight: () => succeed10((n) => n === 1)
  })
}), flatMap12(([queue1, queue2]) => succeed10([filterMap9(flattenExitOption(fromQueue2(queue1, {
  shutdown: true
})), (_) => match(_, {
  onLeft: some2,
  onRight: none2
})), filterMap9(flattenExitOption(fromQueue2(queue2, {
  shutdown: true
})), (_) => match(_, {
  onLeft: none2,
  onRight: some2
}))]))));
var pipeThrough = /* @__PURE__ */ dual(2, (self, sink) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(toChannel(sink)))));
var pipeThroughChannel = /* @__PURE__ */ dual(2, (self, channel) => new StreamImpl(pipeTo(toChannel2(self), channel)));
var pipeThroughChannelOrFail = /* @__PURE__ */ dual(2, (self, chan) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(chan))));
var prepend4 = /* @__PURE__ */ dual(2, (self, values5) => new StreamImpl(zipRight7(write(values5), toChannel2(self))));
var provideContext6 = /* @__PURE__ */ dual(2, (self, context9) => new StreamImpl(pipe(toChannel2(self), provideContext4(context9))));
var provideSomeContext2 = /* @__PURE__ */ dual(2, (self, context9) => mapInputContext6(self, merge2(context9)));
var provideLayer = /* @__PURE__ */ dual(2, (self, layer4) => new StreamImpl(unwrapScopedWith((scope5) => buildWithScope2(layer4, scope5).pipe(map18((env3) => pipe(toChannel2(self), provideContext4(env3)))))));
var provideService6 = /* @__PURE__ */ dual(3, (self, tag3, resource) => provideServiceEffect3(self, tag3, succeed10(resource)));
var provideServiceEffect3 = /* @__PURE__ */ dual(3, (self, tag3, effect4) => provideServiceStream(self, tag3, fromEffect8(effect4)));
var provideServiceStream = /* @__PURE__ */ dual(3, (self, tag3, stream4) => contextWithStream((env3) => flatMap17(stream4, (service3) => pipe(self, provideContext6(add2(env3, tag3, service3))))));
var mapInputContext6 = /* @__PURE__ */ dual(2, (self, f) => contextWithStream((env3) => pipe(self, provideContext6(f(env3)))));
var provideSomeLayer2 = /* @__PURE__ */ dual(2, (self, layer4) => (
  // @ts-expect-error
  pipe(self, provideLayer(pipe(context4(), merge8(layer4))))
));
var range2 = (min5, max7, chunkSize = DefaultChunkSize) => suspend10(() => {
  if (min5 > max7) {
    return empty33;
  }
  const go6 = (min6, max8, chunkSize2) => {
    const remaining = max8 - min6 + 1;
    if (remaining > chunkSize2) {
      return pipe(write(range(min6, min6 + chunkSize2 - 1)), flatMap14(() => go6(min6 + chunkSize2, max8, chunkSize2)));
    }
    return write(range(min6, min6 + remaining - 1));
  };
  return new StreamImpl(go6(min5, max7, chunkSize));
});
var race3 = /* @__PURE__ */ dual(2, (left3, right3) => raceAll3(left3, right3));
var raceAll3 = (...streams) => make23().pipe(map18((halt2) => {
  let winner = null;
  return mergeAll8(streams.map((stream4, index) => stream4.pipe(takeWhile4(() => {
    if (winner === null) {
      winner = index;
      unsafeDone(halt2, void_4);
      return true;
    }
    return winner === index;
  }), interruptWhen2(_await(halt2).pipe(flatMap12(() => winner === index ? never4 : _void))))), {
    concurrency: streams.length
  });
}), unwrap2);
var rechunk = /* @__PURE__ */ dual(2, (self, n) => suspend10(() => {
  const target = Math.max(n, 1);
  const process2 = rechunkProcess(new StreamRechunker(target), target);
  return new StreamImpl(pipe(toChannel2(self), pipeTo(process2)));
}));
var rechunkProcess = (rechunker, target) => readWithCause({
  onInput: (chunk4) => {
    if (chunk4.length === target && rechunker.isEmpty()) {
      return flatMap14(write(chunk4), () => rechunkProcess(rechunker, target));
    }
    if (chunk4.length > 0) {
      const chunks3 = [];
      let result = void 0;
      let index = 0;
      while (index < chunk4.length) {
        while (index < chunk4.length && result === void 0) {
          result = rechunker.write(pipe(chunk4, unsafeGet4(index)));
          index = index + 1;
        }
        if (result !== void 0) {
          chunks3.push(result);
          result = void 0;
        }
      }
      return flatMap14(writeAll(...chunks3), () => rechunkProcess(rechunker, target));
    }
    return suspend6(() => rechunkProcess(rechunker, target));
  },
  onFailure: (cause3) => zipRight7(rechunker.emitIfNotEmpty(), failCause11(cause3)),
  onDone: () => rechunker.emitIfNotEmpty()
});
var StreamRechunker = class {
  constructor(n) {
    __publicField(this, "n");
    __publicField(this, "builder", []);
    __publicField(this, "pos", 0);
    this.n = n;
  }
  isEmpty() {
    return this.pos === 0;
  }
  write(elem) {
    this.builder.push(elem);
    this.pos += 1;
    if (this.pos === this.n) {
      const result = unsafeFromArray(this.builder);
      this.builder = [];
      this.pos = 0;
      return result;
    }
    return void 0;
  }
  emitIfNotEmpty() {
    if (this.pos !== 0) {
      return write(unsafeFromArray(this.builder));
    }
    return void_7;
  }
};
var refineOrDie = /* @__PURE__ */ dual(2, (self, pf) => pipe(self, refineOrDieWith(pf, identity)));
var refineOrDieWith = /* @__PURE__ */ dual(3, (self, pf, f) => new StreamImpl(catchAll5(toChannel2(self), (error2) => match2(pf(error2), {
  onNone: () => failCause11(die4(f(error2))),
  onSome: fail12
}))));
var repeat2 = /* @__PURE__ */ dual(2, (self, schedule4) => filterMap9(repeatEither(self, schedule4), (_) => match(_, {
  onLeft: none2,
  onRight: some2
})));
var repeatEffect = (effect4) => repeatEffectOption(pipe(effect4, mapError3(some2)));
var repeatEffectChunk = (effect4) => repeatEffectChunkOption(pipe(effect4, mapError3(some2)));
var repeatEffectChunkOption = (effect4) => unfoldChunkEffect(effect4, (effect5) => pipe(map18(effect5, (chunk4) => some2([chunk4, effect5])), catchAll3(match2({
  onNone: () => succeed10(none2()),
  onSome: fail10
}))));
var repeatEffectOption = (effect4) => repeatEffectChunkOption(pipe(effect4, map18(of2)));
var repeatEither = /* @__PURE__ */ dual(2, (self, schedule4) => repeatWith(self, schedule4, {
  onElement: (a) => right2(a),
  onSchedule: left2
}));
var repeatElements = /* @__PURE__ */ dual(2, (self, schedule4) => filterMap9(repeatElementsWith(self, schedule4, {
  onElement: (a) => some2(a),
  onSchedule: none2
}), identity));
var repeatElementsWith = /* @__PURE__ */ dual(3, (self, schedule4, options) => {
  const driver3 = pipe(driver2(schedule4), map18((driver4) => {
    const feed3 = (input) => match2(head2(input), {
      onNone: () => loop3,
      onSome: (a) => zipRight7(write(of2(options.onElement(a))), step4(pipe(input, drop2(1)), a))
    });
    const step4 = (input, a) => {
      const advance = pipe(driver4.next(a), as6(pipe(write(of2(options.onElement(a))), flatMap14(() => step4(input, a)))));
      const reset = pipe(driver4.last, orDie3, flatMap12((b) => pipe(driver4.reset, map18(() => pipe(write(of2(options.onSchedule(b))), zipRight7(feed3(input)))))));
      return pipe(advance, orElse6(() => reset), unwrap);
    };
    const loop3 = readWith({
      onInput: feed3,
      onFailure: fail12,
      onDone: () => void_7
    });
    return loop3;
  }), unwrap);
  return new StreamImpl(pipe(toChannel2(self), pipeTo(driver3)));
});
var repeatValue = (value3) => new StreamImpl(repeated(write(of2(value3))));
var repeatWith = /* @__PURE__ */ dual(3, (self, schedule4, options) => {
  return pipe(driver2(schedule4), map18((driver3) => {
    const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get11(driver3.iterationMeta));
    const scheduleOutput = pipe(driver3.last, orDie3, map18(options.onSchedule));
    const process2 = pipe(self, provideLastIterationInfo, map24(options.onElement), toChannel2);
    const loop3 = unwrap(match14(driver3.next(void 0), {
      onFailure: () => void_7,
      onSuccess: () => pipe(process2, zipRight7(pipe(scheduleOutput, map18((c) => pipe(write(of2(c)), flatMap14(() => loop3))), unwrap)))
    }));
    return new StreamImpl(pipe(process2, zipRight7(loop3)));
  }), unwrap2);
});
var repeatWithSchedule = (value3, schedule4) => repeatEffectWithSchedule(succeed10(value3), schedule4);
var repeatEffectWithSchedule = (effect4, schedule4) => flatMap17(fromEffect8(zip7(effect4, driver2(schedule4))), ([a, driver3]) => {
  const provideLastIterationInfo = provideServiceEffect2(CurrentIterationMetadata2, get11(driver3.iterationMeta));
  return concat2(succeed16(a), unfoldEffect(a, (s) => matchEffect2(driver3.next(s), {
    onFailure: succeed10,
    onSuccess: () => map18(provideLastIterationInfo(effect4), (nextA) => some2([nextA, nextA]))
  })));
});
var retry6 = /* @__PURE__ */ dual(2, (self, policy) => driver2(policy).pipe(map18((driver3) => {
  const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get11(driver3.iterationMeta));
  const loop3 = toChannel2(provideLastIterationInfo(self)).pipe(mapOutEffect((out) => as6(driver3.reset, out)), catchAll5((error2) => driver3.next(error2).pipe(match14({
    onFailure: () => fail12(error2),
    onSuccess: () => loop3
  }), unwrap)));
  return loop3;
}), unwrap, fromChannel2));
var withExecutionPlan3 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, policy, options) => suspend10(() => {
  const preventFallbackOnPartialStream = options?.preventFallbackOnPartialStream ?? false;
  let i = 0;
  let lastError = none2();
  const loop3 = suspend10(() => {
    const step4 = policy.steps[i++];
    if (!step4) {
      return fail16(getOrThrow2(lastError));
    }
    let nextStream = isContext2(step4.provide) ? provideSomeContext2(self, step4.provide) : provideSomeLayer2(self, step4.provide);
    let receivedElements = false;
    if (isSome2(lastError)) {
      const error2 = lastError.value;
      let attempted = false;
      const wrapped = nextStream;
      nextStream = suspend10(() => {
        if (attempted) return wrapped;
        attempted = true;
        return fail16(error2);
      });
      nextStream = scheduleDefectRefail2(retry6(nextStream, scheduleFromStep(step4, false)));
    } else {
      const schedule4 = scheduleFromStep(step4, true);
      nextStream = schedule4 ? scheduleDefectRefail2(retry6(nextStream, schedule4)) : nextStream;
    }
    return catchAll7(preventFallbackOnPartialStream ? mapChunks(nextStream, (chunk4) => {
      receivedElements = true;
      return chunk4;
    }) : nextStream, (error2) => {
      if (preventFallbackOnPartialStream && receivedElements) {
        return fail16(error2);
      }
      lastError = some2(error2);
      return loop3;
    });
  });
  return loop3;
}));
var scheduleDefectRefail2 = (self) => catchAllCause6(self, (cause3) => failCause14(scheduleDefectRefailCause(cause3)));
var run4 = /* @__PURE__ */ dual(2, (self, sink) => toChannel2(self).pipe(pipeToOrFail(toChannel(sink)), runDrain));
var runCollect = (self) => run4(self, collectAll());
var runCount = (self) => run4(self, count3);
var runDrain2 = (self) => run4(self, drain2);
var runFold = /* @__PURE__ */ dual(3, (self, s, f) => runFoldWhile(self, s, constTrue, f));
var runFoldEffect = /* @__PURE__ */ dual(3, (self, s, f) => runFoldWhileEffect(self, s, constTrue, f));
var runFoldScoped = /* @__PURE__ */ dual(3, (self, s, f) => pipe(self, runFoldWhileScoped(s, constTrue, f)));
var runFoldScopedEffect = /* @__PURE__ */ dual(3, (self, s, f) => pipe(self, runFoldWhileScopedEffect(s, constTrue, f)));
var runFoldWhile = /* @__PURE__ */ dual(4, (self, s, cont, f) => run4(self, fold(s, cont, f)));
var runFoldWhileEffect = /* @__PURE__ */ dual(4, (self, s, cont, f) => run4(self, foldEffect(s, cont, f)));
var runFoldWhileScoped = /* @__PURE__ */ dual(4, (self, s, cont, f) => pipe(self, runScoped2(fold(s, cont, f))));
var runFoldWhileScopedEffect = /* @__PURE__ */ dual(4, (self, s, cont, f) => pipe(self, runScoped2(foldEffect(s, cont, f))));
var runForEach = /* @__PURE__ */ dual(2, (self, f) => run4(self, forEach11(f)));
var runForEachChunk = /* @__PURE__ */ dual(2, (self, f) => run4(self, forEachChunk(f)));
var runForEachChunkScoped = /* @__PURE__ */ dual(2, (self, f) => pipe(self, runScoped2(forEachChunk(f))));
var runForEachScoped = /* @__PURE__ */ dual(2, (self, f) => pipe(self, runScoped2(forEach11(f))));
var runForEachWhile = /* @__PURE__ */ dual(2, (self, f) => run4(self, forEachWhile(f)));
var runForEachWhileScoped = /* @__PURE__ */ dual(2, (self, f) => pipe(self, runScoped2(forEachWhile(f))));
var runHead = (self) => run4(self, head5());
var runIntoPubSub = /* @__PURE__ */ dual(2, (self, pubsub) => pipe(self, runIntoQueue(pubsub)));
var runIntoPubSubScoped = /* @__PURE__ */ dual(2, (self, pubsub) => pipe(self, runIntoQueueScoped(pubsub)));
var runIntoQueue = /* @__PURE__ */ dual(2, (self, queue) => pipe(self, runIntoQueueScoped(queue), scoped3));
var runIntoQueueElementsScoped = /* @__PURE__ */ dual(2, (self, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap14(fromEffect5(offerAll3(queue, map4(input, succeed4))), () => writer),
    onFailure: (cause3) => fromEffect5(offer3(queue, failCause4(map14(cause3, some2)))),
    onDone: () => fromEffect5(offer3(queue, fail4(none2())))
  });
  return pipe(pipeTo(toChannel2(self), writer), drain, runScoped, asVoid4);
});
var runIntoQueueScoped = /* @__PURE__ */ dual(2, (self, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap14(write(chunk2(input)), () => writer),
    onFailure: (cause3) => write(failCause12(cause3)),
    onDone: () => write(end4)
  });
  return pipe(pipeTo(toChannel2(self), writer), mapOutEffect((take10) => offer3(queue, take10)), drain, runScoped, asVoid4);
});
var runLast = (self) => run4(self, last4());
var runScoped2 = /* @__PURE__ */ dual(2, (self, sink) => pipe(toChannel2(self), pipeToOrFail(toChannel(sink)), drain, runScoped));
var runSum = (self) => run4(self, sum2);
var scan = /* @__PURE__ */ dual(3, (self, s, f) => pipe(self, scanEffect(s, (s2, a) => succeed10(f(s2, a)))));
var scanReduce = /* @__PURE__ */ dual(2, (self, f) => pipe(self, scanReduceEffect((a2, a) => succeed10(f(a2, a)))));
var scanReduceEffect = /* @__PURE__ */ dual(2, (self, f) => pipe(self, mapAccumEffect(none2(), (option5, a) => {
  switch (option5._tag) {
    case "None": {
      return succeed10([some2(a), a]);
    }
    case "Some": {
      return pipe(f(option5.value, a), map18((b) => [some2(b), b]));
    }
  }
})));
var schedule2 = /* @__PURE__ */ dual(2, (self, schedule4) => filterMap9(scheduleWith(self, schedule4, {
  onElement: some2,
  onSchedule: none2
}), identity));
var scheduleWith = /* @__PURE__ */ dual(3, (self, schedule4, options) => {
  const loop3 = (driver3, iterator) => {
    const next4 = iterator.next();
    if (next4.done) {
      return readWithCause({
        onInput: (chunk4) => loop3(driver3, chunk4[Symbol.iterator]()),
        onFailure: failCause11,
        onDone: succeedNow
      });
    }
    return unwrap(matchEffect2(driver3.next(next4.value), {
      onFailure: () => pipe(driver3.last, orDie3, map18((b) => pipe(write(make6(options.onElement(next4.value), options.onSchedule(b))), flatMap14(() => loop3(driver3, iterator)))), zipLeft5(driver3.reset)),
      onSuccess: () => succeed10(pipe(write(of2(options.onElement(next4.value))), flatMap14(() => loop3(driver3, iterator))))
    }));
  };
  return new StreamImpl(pipe(fromEffect5(driver2(schedule4)), flatMap14((driver3) => pipe(toChannel2(self), pipeTo(loop3(driver3, empty5()[Symbol.iterator]()))))));
});
var scanEffect = /* @__PURE__ */ dual(3, (self, s, f) => new StreamImpl(pipe(write(of2(s)), flatMap14(() => toChannel2(pipe(self, mapAccumEffect(s, (s2, a) => pipe(f(s2, a), map18((s3) => [s3, s3])))))))));
var scoped6 = (effect4) => new StreamImpl(ensuring4(scoped5(pipe(effect4, map18(of2))), _void));
var scopedWith4 = (f) => new StreamImpl(scopedWith3((scope5) => f(scope5).pipe(map18(of2))));
var some7 = (self) => pipe(self, mapError6(some2), someOrFail(() => none2()));
var someOrElse = /* @__PURE__ */ dual(2, (self, fallback) => pipe(self, map24(getOrElse3(fallback))));
var someOrFail = /* @__PURE__ */ dual(2, (self, error2) => mapEffectSequential(self, match2({
  onNone: () => failSync3(error2),
  onSome: succeed10
})));
var sliding7 = /* @__PURE__ */ dual(2, (self, chunkSize) => slidingSize(self, chunkSize, 1));
var slidingSize = /* @__PURE__ */ dual(3, (self, chunkSize, stepSize) => {
  if (chunkSize <= 0 || stepSize <= 0) {
    return die10(new IllegalArgumentException2("Invalid bounds - `chunkSize` and `stepSize` must be greater than zero"));
  }
  return new StreamImpl(suspend6(() => {
    const queue = new RingBuffer(chunkSize);
    const emitOnStreamEnd = (queueSize, channelEnd) => {
      if (queueSize < chunkSize) {
        const items = queue.toChunk();
        const result2 = isEmpty(items) ? empty5() : of2(items);
        return pipe(write(result2), flatMap14(() => channelEnd));
      }
      const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;
      if (lastEmitIndex === queueSize) {
        return channelEnd;
      }
      const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);
      const lastItems = pipe(queue.toChunk(), takeRight(leftovers));
      const result = isEmpty(lastItems) ? empty5() : of2(lastItems);
      return pipe(write(result), flatMap14(() => channelEnd));
    };
    const reader = (queueSize) => readWithCause({
      onInput: (input) => flatMap14(write(filterMap4(input, (element3, index) => {
        queue.put(element3);
        const currentIndex = queueSize + index + 1;
        if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {
          return none2();
        }
        return some2(queue.toChunk());
      })), () => reader(queueSize + input.length)),
      onFailure: (cause3) => emitOnStreamEnd(queueSize, failCause11(cause3)),
      onDone: () => emitOnStreamEnd(queueSize, void_7)
    });
    return pipe(toChannel2(self), pipeTo(reader(0)));
  }));
});
var split3 = /* @__PURE__ */ dual(2, (self, predicate) => {
  const split8 = (leftovers, input) => {
    const [chunk4, remaining] = pipe(leftovers, appendAll2(input), splitWhere(predicate));
    if (isEmpty(chunk4) || isEmpty(remaining)) {
      return loop3(pipe(chunk4, appendAll2(pipe(remaining, drop2(1)))));
    }
    return pipe(write(of2(chunk4)), flatMap14(() => split8(empty5(), pipe(remaining, drop2(1)))));
  };
  const loop3 = (leftovers) => readWith({
    onInput: (input) => split8(leftovers, input),
    onFailure: fail12,
    onDone: () => {
      if (isEmpty(leftovers)) {
        return void_7;
      }
      if (isNone2(pipe(leftovers, findFirst3(predicate)))) {
        return zipRight7(write(of2(leftovers)), void_7);
      }
      return zipRight7(split8(empty5(), leftovers), void_7);
    }
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3(empty5()))));
});
var splitOnChunk = /* @__PURE__ */ dual(2, (self, delimiter) => {
  const next4 = (leftover2, delimiterIndex) => readWithCause({
    onInput: (inputChunk) => {
      let buffer3;
      const [carry, delimiterCursor] = pipe(inputChunk, reduce2([pipe(leftover2, getOrElse3(() => empty5())), delimiterIndex], ([carry2, delimiterCursor2], a) => {
        const concatenated = pipe(carry2, append2(a));
        if (delimiterCursor2 < delimiter.length && equals(a, pipe(delimiter, unsafeGet4(delimiterCursor2)))) {
          if (delimiterCursor2 + 1 === delimiter.length) {
            if (buffer3 === void 0) {
              buffer3 = [];
            }
            buffer3.push(pipe(concatenated, take(concatenated.length - delimiter.length)));
            return [empty5(), 0];
          }
          return [concatenated, delimiterCursor2 + 1];
        }
        return [concatenated, equals(a, pipe(delimiter, unsafeGet4(0))) ? 1 : 0];
      }));
      const output3 = buffer3 === void 0 ? empty5() : unsafeFromArray(buffer3);
      return flatMap14(write(output3), () => next4(isNonEmpty(carry) ? some2(carry) : none2(), delimiterCursor));
    },
    onFailure: (cause3) => match2(leftover2, {
      onNone: () => failCause11(cause3),
      onSome: (chunk4) => zipRight7(write(of2(chunk4)), failCause11(cause3))
    }),
    onDone: (done12) => match2(leftover2, {
      onNone: () => succeed12(done12),
      onSome: (chunk4) => zipRight7(write(of2(chunk4)), succeed12(done12))
    })
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(next4(none2(), 0))));
});
var splitLines2 = (self) => pipeThroughChannel(self, splitLines());
var succeed16 = (value3) => fromChunk(of2(value3));
var sync10 = (evaluate3) => suspend10(() => fromChunk(of2(evaluate3())));
var suspend10 = (stream4) => new StreamImpl(suspend6(() => toChannel2(stream4())));
var take7 = /* @__PURE__ */ dual(2, (self, n) => {
  if (!Number.isInteger(n)) {
    return die10(new IllegalArgumentException2(`${n} must be an integer`));
  }
  const loop3 = (n2) => readWith({
    onInput: (input) => {
      const taken = pipe(input, take(Math.min(n2, Number.POSITIVE_INFINITY)));
      const leftover2 = Math.max(0, n2 - taken.length);
      const more = leftover2 > 0;
      if (more) {
        return pipe(write(taken), flatMap14(() => loop3(leftover2)));
      }
      return write(taken);
    },
    onFailure: fail12,
    onDone: succeed12
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(0 < n ? loop3(n) : void_7)));
});
var takeRight2 = /* @__PURE__ */ dual(2, (self, n) => {
  if (n <= 0) {
    return empty33;
  }
  return new StreamImpl(pipe(succeed10(new RingBuffer(n)), map18((queue) => {
    const reader = readWith({
      onInput: (input) => {
        for (const element3 of input) {
          queue.put(element3);
        }
        return reader;
      },
      onFailure: fail12,
      onDone: () => pipe(write(queue.toChunk()), zipRight7(void_7))
    });
    return pipe(toChannel2(self), pipeTo(reader));
  }), unwrap));
});
var takeUntil3 = /* @__PURE__ */ dual(2, (self, predicate) => {
  const loop3 = readWith({
    onInput: (input) => {
      const taken = pipe(input, takeWhile((a) => !predicate(a)));
      const last5 = pipe(input, drop2(taken.length), take(1));
      if (isEmpty(last5)) {
        return pipe(write(taken), flatMap14(() => loop3));
      }
      return write(pipe(taken, appendAll2(last5)));
    },
    onFailure: fail12,
    onDone: succeed12
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3)));
});
var takeUntilEffect = /* @__PURE__ */ dual(2, (self, predicate) => {
  const loop3 = (iterator) => {
    const next4 = iterator.next();
    if (next4.done) {
      return readWithCause({
        onInput: (elem) => loop3(elem[Symbol.iterator]()),
        onFailure: failCause11,
        onDone: succeed12
      });
    }
    return pipe(predicate(next4.value), map18((bool2) => bool2 ? write(of2(next4.value)) : pipe(write(of2(next4.value)), flatMap14(() => loop3(iterator)))), unwrap);
  };
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3(empty5()[Symbol.iterator]()))));
});
var takeWhile4 = /* @__PURE__ */ dual(2, (self, predicate) => {
  const loop3 = readWith({
    onInput: (input) => {
      const taken = pipe(input, takeWhile(predicate));
      const more = taken.length === input.length;
      if (more) {
        return pipe(write(taken), flatMap14(() => loop3));
      }
      return write(taken);
    },
    onFailure: fail12,
    onDone: succeed12
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3)));
});
var tap7 = /* @__PURE__ */ dual(2, (self, f) => mapEffectSequential(self, (a) => as6(f(a), a)));
var tapBoth3 = /* @__PURE__ */ dual(2, (self, options) => pipe(self, tapError5(options.onFailure), tap7(options.onSuccess)));
var tapError5 = /* @__PURE__ */ dual(2, (self, f) => catchAll7(self, (error2) => fromEffect8(zipRight6(f(error2), fail10(error2)))));
var tapErrorCause5 = /* @__PURE__ */ dual(2, (self, f) => {
  const loop3 = readWithCause({
    onInput: (chunk4) => flatMap14(write(chunk4), () => loop3),
    onFailure: (cause3) => fromEffect5(zipRight6(f(cause3), failCause9(cause3))),
    onDone: succeedNow
  });
  return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3)));
});
var tapSink = /* @__PURE__ */ dual(2, (self, sink) => pipe(fromEffect8(all7([bounded3(1), make23()])), flatMap17(([queue, deferred]) => {
  const right3 = flattenTake(fromQueue2(queue, {
    maxChunkSize: 1
  }));
  const loop3 = readWithCause({
    onInput: (chunk4) => pipe(fromEffect5(offer3(queue, chunk2(chunk4))), foldCauseChannel({
      onFailure: () => flatMap14(write(chunk4), () => identityChannel()),
      onSuccess: () => flatMap14(write(chunk4), () => loop3)
    })),
    onFailure: (cause3) => pipe(fromEffect5(offer3(queue, failCause12(cause3))), foldCauseChannel({
      onFailure: () => failCause11(cause3),
      onSuccess: () => failCause11(cause3)
    })),
    onDone: () => pipe(fromEffect5(offer3(queue, end4)), foldCauseChannel({
      onFailure: () => void_7,
      onSuccess: () => void_7
    }))
  });
  return pipe(new StreamImpl(pipe(pipeTo(toChannel2(self), loop3), ensuring4(zipRight6(forkDaemon2(offer3(queue, end4)), _await(deferred))))), merge9(execute(pipe(run4(right3, sink), ensuring3(zipRight6(shutdown2(queue), succeed2(deferred, void 0)))))));
})));
var throttle = /* @__PURE__ */ dual(2, (self, options) => throttleEffect(self, {
  ...options,
  cost: (chunk4) => succeed10(options.cost(chunk4))
}));
var throttleEffect = /* @__PURE__ */ dual(2, (self, options) => {
  if (options.strategy === "enforce") {
    return throttleEnforceEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);
  }
  return throttleShapeEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);
});
var throttleEnforceEffect = (self, cost, units, duration4, burst) => {
  const loop3 = (tokens, timestampMillis) => readWithCause({
    onInput: (input) => pipe(cost(input), zip7(currentTimeMillis2), map18(([weight, currentTimeMillis3]) => {
      const elapsed3 = currentTimeMillis3 - timestampMillis;
      const cycles = elapsed3 / toMillis(duration4);
      const sum3 = tokens + cycles * units;
      const max7 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available = sum3 < 0 ? max7 : Math.min(sum3, max7);
      if (weight <= available) {
        return pipe(write(input), flatMap14(() => loop3(available - weight, currentTimeMillis3)));
      }
      return loop3(tokens, timestampMillis);
    }), unwrap),
    onFailure: failCause11,
    onDone: () => void_7
  });
  const throttled = pipe(currentTimeMillis2, map18((currentTimeMillis3) => loop3(units, currentTimeMillis3)), unwrap);
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(throttled)));
};
var throttleShapeEffect = (self, costFn, units, duration4, burst) => {
  const loop3 = (tokens, timestampMillis) => readWithCause({
    onInput: (input) => pipe(costFn(input), zip7(currentTimeMillis2), map18(([weight, currentTimeMillis3]) => {
      const elapsed3 = currentTimeMillis3 - timestampMillis;
      const cycles = elapsed3 / toMillis(duration4);
      const sum3 = tokens + cycles * units;
      const max7 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available = sum3 < 0 ? max7 : Math.min(sum3, max7);
      const remaining = available - weight;
      const waitCycles = remaining >= 0 ? 0 : -remaining / units;
      const delay3 = millis(Math.max(0, waitCycles * toMillis(duration4)));
      if (greaterThan2(delay3, zero)) {
        return pipe(fromEffect5(sleep2(delay3)), zipRight7(write(input)), flatMap14(() => loop3(remaining, currentTimeMillis3)));
      }
      return flatMap14(write(input), () => loop3(remaining, currentTimeMillis3));
    }), unwrap),
    onFailure: failCause11,
    onDone: () => void_7
  });
  const throttled = pipe(currentTimeMillis2, map18((currentTimeMillis3) => loop3(units, currentTimeMillis3)), unwrap);
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(throttled)));
};
var tick = (interval) => repeatWithSchedule(void 0, spaced2(interval));
var timeout3 = /* @__PURE__ */ dual(2, (self, duration4) => pipe(toPull2(self), map18(timeoutFail2({
  onTimeout: () => none2(),
  duration: duration4
})), fromPull2));
var timeoutFail3 = /* @__PURE__ */ dual(3, (self, error2, duration4) => pipe(self, timeoutTo3(duration4, failSync7(error2))));
var timeoutFailCause3 = /* @__PURE__ */ dual(3, (self, cause3, duration4) => pipe(toPull2(self), map18(timeoutFailCause2({
  onTimeout: () => map14(cause3(), some2),
  duration: duration4
})), fromPull2));
var timeoutTo3 = /* @__PURE__ */ dual(3, (self, duration4, that) => {
  const StreamTimeout = new RuntimeException2("Stream Timeout");
  return pipe(self, timeoutFailCause3(() => die4(StreamTimeout), duration4), catchSomeCause3((cause3) => isDieType2(cause3) && isRuntimeException2(cause3.defect) && cause3.defect.message !== void 0 && cause3.defect.message === "Stream Timeout" ? some2(that) : none2()));
});
var pubsubFromOptions = (options) => {
  if (typeof options === "number") {
    return bounded5(options);
  } else if (options.capacity === "unbounded") {
    return unbounded5({
      replay: options.replay
    });
  }
  switch (options.strategy) {
    case "dropping":
      return dropping4(options);
    case "sliding":
      return sliding4(options);
    default:
      return bounded5(options);
  }
};
var toPubSub2 = /* @__PURE__ */ dual(2, (self, capacity7) => pipe(acquireRelease2(pubsubFromOptions(capacity7), (pubsub) => shutdown4(pubsub)), tap4((pubsub) => pipe(self, runIntoPubSubScoped(pubsub), forkScoped2))));
var toPull2 = (self) => map18(toPull(toChannel2(self)), (pull) => pipe(pull, mapError3(some2), flatMap12(match({
  onLeft: () => fail10(none2()),
  onRight: succeed10
}))));
var toQueue2 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options) => tap4(acquireRelease2(options?.strategy === "unbounded" ? unbounded3() : options?.strategy === "dropping" ? dropping2(options.capacity ?? 2) : options?.strategy === "sliding" ? sliding2(options.capacity ?? 2) : bounded3(options?.capacity ?? 2), (queue) => shutdown2(queue)), (queue) => forkScoped2(runIntoQueueScoped(self, queue))));
var toQueueOfElements = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options) => tap4(acquireRelease2(bounded3(options?.capacity ?? 2), (queue) => shutdown2(queue)), (queue) => forkScoped2(runIntoQueueElementsScoped(self, queue))));
var toReadableStream = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options) => toReadableStreamRuntime(self, defaultRuntime2, options));
var toReadableStreamEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options) => map18(runtime4(), (runtime5) => toReadableStreamRuntime(self, runtime5, options)));
var toReadableStreamRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, runtime5, options) => {
  const runFork4 = runFork3(runtime5);
  let currentResolve = void 0;
  let fiber = void 0;
  const latch = unsafeMakeLatch2(false);
  return new ReadableStream({
    start(controller) {
      fiber = runFork4(runForEachChunk(self, (chunk4) => latch.whenOpen(sync5(() => {
        latch.unsafeClose();
        for (const item of chunk4) {
          controller.enqueue(item);
        }
        currentResolve();
        currentResolve = void 0;
      }))));
      fiber.addObserver((exit4) => {
        if (exit4._tag === "Failure") {
          controller.error(squash(exit4.cause));
        } else {
          controller.close();
        }
      });
    },
    pull() {
      return new Promise((resolve) => {
        currentResolve = resolve;
        runSync(latch.open);
      });
    },
    cancel() {
      if (!fiber) return;
      return runPromise(asVoid4(interrupt6(fiber)));
    }
  }, options?.strategy);
});
var transduce = /* @__PURE__ */ dual(2, (self, sink) => {
  const newChannel = suspend6(() => {
    const leftovers = {
      ref: empty5()
    };
    const upstreamDone = {
      ref: false
    };
    const buffer3 = suspend6(() => {
      const leftover2 = leftovers.ref;
      if (isEmpty(leftover2)) {
        return readWith({
          onInput: (input) => pipe(write(input), flatMap14(() => buffer3)),
          onFailure: fail12,
          onDone: succeedNow
        });
      }
      leftovers.ref = empty5();
      return pipe(writeChunk(leftover2), flatMap14(() => buffer3));
    });
    const concatAndGet = (chunk4) => {
      const leftover2 = leftovers.ref;
      const concatenated = appendAll2(leftover2, filter3(chunk4, (chunk5) => chunk5.length !== 0));
      leftovers.ref = concatenated;
      return concatenated;
    };
    const upstreamMarker = readWith({
      onInput: (input) => flatMap14(write(input), () => upstreamMarker),
      onFailure: fail12,
      onDone: (done12) => zipRight7(sync7(() => {
        upstreamDone.ref = true;
      }), succeedNow(done12))
    });
    const transducer = pipe(sink, toChannel, collectElements, flatMap14(([leftover2, z]) => pipe(succeed12([upstreamDone.ref, concatAndGet(leftover2)]), flatMap14(([done12, newLeftovers]) => {
      const nextChannel = done12 && isEmpty(newLeftovers) ? void_7 : transducer;
      return pipe(write(of2(z)), flatMap14(() => nextChannel));
    }))));
    return pipe(toChannel2(self), pipeTo(upstreamMarker), pipeTo(buffer3), pipeToOrFail(transducer));
  });
  return new StreamImpl(newChannel);
});
var toAsyncIterableRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, runtime5) => {
  const runFork4 = runFork3(runtime5);
  return {
    [Symbol.asyncIterator]() {
      let currentResolve = void 0;
      let currentReject = void 0;
      let fiber = void 0;
      const latch = unsafeMakeLatch2(false);
      return {
        next() {
          if (!fiber) {
            fiber = runFork4(runForEach(self, (value3) => latch.whenOpen(sync5(() => {
              latch.unsafeClose();
              currentResolve({
                done: false,
                value: value3
              });
              currentResolve = currentReject = void 0;
            }))));
            fiber.addObserver((exit4) => {
              fiber = runFork2(latch.whenOpen(sync5(() => {
                if (exit4._tag === "Failure") {
                  currentReject(squash(exit4.cause));
                } else {
                  currentResolve({
                    done: true,
                    value: void 0
                  });
                }
                currentResolve = currentReject = void 0;
              })));
            });
          }
          return new Promise((resolve, reject) => {
            currentResolve = resolve;
            currentReject = reject;
            latch.unsafeOpen();
          });
        },
        return() {
          if (!fiber) return Promise.resolve({
            done: true,
            value: void 0
          });
          return runPromise(as6(interrupt6(fiber), {
            done: true,
            value: void 0
          }));
        }
      };
    }
  };
});
var toAsyncIterable = (self) => toAsyncIterableRuntime(self, defaultRuntime2);
var toAsyncIterableEffect = (self) => map18(runtime4(), (runtime5) => toAsyncIterableRuntime(self, runtime5));
var unfold4 = (s, f) => unfoldChunk(s, (s2) => pipe(f(s2), map2(([a, s3]) => [of2(a), s3])));
var unfoldChunk = (s, f) => {
  const loop3 = (s2) => match2(f(s2), {
    onNone: () => void_7,
    onSome: ([chunk4, s3]) => flatMap14(write(chunk4), () => loop3(s3))
  });
  return new StreamImpl(suspend6(() => loop3(s)));
};
var unfoldChunkEffect = (s, f) => suspend10(() => {
  const loop3 = (s2) => unwrap(map18(f(s2), match2({
    onNone: () => void_7,
    onSome: ([chunk4, s3]) => flatMap14(write(chunk4), () => loop3(s3))
  })));
  return new StreamImpl(loop3(s));
});
var unfoldEffect = (s, f) => unfoldChunkEffect(s, (s2) => pipe(f(s2), map18(map2(([a, s3]) => [of2(a), s3]))));
var void_9 = /* @__PURE__ */ succeed16(void 0);
var unwrap2 = (effect4) => flatten13(fromEffect8(effect4));
var unwrapScoped4 = (effect4) => flatten13(scoped6(effect4));
var unwrapScopedWith3 = (f) => flatten13(scopedWith4((scope5) => f(scope5)));
var updateService4 = /* @__PURE__ */ dual(3, (self, tag3, f) => pipe(self, mapInputContext6((context9) => pipe(context9, add2(tag3, f(pipe(context9, unsafeGet2(tag3))))))));
var when3 = /* @__PURE__ */ dual(2, (self, test) => pipe(self, whenEffect3(sync5(test))));
var whenCase = (evaluate3, pf) => whenCaseEffect(pf)(sync5(evaluate3));
var whenCaseEffect = /* @__PURE__ */ dual(2, (self, pf) => pipe(fromEffect8(self), flatMap17((a) => pipe(pf(a), getOrElse3(() => empty33)))));
var whenEffect3 = /* @__PURE__ */ dual(2, (self, effect4) => pipe(fromEffect8(effect4), flatMap17((bool2) => bool2 ? self : empty33)));
var withSpan6 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self = arguments[0];
    return new StreamImpl(withSpan5(toChannel2(self), name, options));
  }
  return (self) => new StreamImpl(withSpan5(toChannel2(self), name, options));
};
var zip9 = /* @__PURE__ */ dual(2, (self, that) => pipe(self, zipWith14(that, (a, a2) => [a, a2])));
var zipFlatten = /* @__PURE__ */ dual(2, (self, that) => pipe(self, zipWith14(that, (a, a2) => [...a, a2])));
var zipAll = /* @__PURE__ */ dual(2, (self, options) => zipAllWith(self, {
  other: options.other,
  onSelf: (a) => [a, options.defaultOther],
  onOther: (a2) => [options.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2]
}));
var zipAllLeft = /* @__PURE__ */ dual(3, (self, other, defaultSelf) => zipAllWith(self, {
  other,
  onSelf: identity,
  onOther: () => defaultSelf,
  onBoth: (a) => a
}));
var zipAllRight = /* @__PURE__ */ dual(3, (self, other, defaultRight) => zipAllWith(self, {
  other,
  onSelf: () => defaultRight,
  onOther: identity,
  onBoth: (_, a2) => a2
}));
var zipAllSortedByKey = /* @__PURE__ */ dual(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: (a) => [a, options.defaultOther],
  onOther: (a2) => [options.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2],
  order: options.order
}));
var zipAllSortedByKeyLeft = /* @__PURE__ */ dual(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: identity,
  onOther: () => options.defaultSelf,
  onBoth: (a) => a,
  order: options.order
}));
var zipAllSortedByKeyRight = /* @__PURE__ */ dual(2, (self, options) => zipAllSortedByKeyWith(self, {
  other: options.other,
  onSelf: () => options.defaultOther,
  onOther: identity,
  onBoth: (_, a2) => a2,
  order: options.order
}));
var zipAllSortedByKeyWith = /* @__PURE__ */ dual(2, (self, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_DRAIN_LEFT: {
        return pipe(pullLeft, match14({
          onFailure: fail4,
          onSuccess: (leftChunk) => succeed4([map4(leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])
        }));
      }
      case OP_DRAIN_RIGHT: {
        return pipe(pullRight, match14({
          onFailure: fail4,
          onSuccess: (rightChunk) => succeed4([map4(rightChunk, ([k, a2]) => [k, options.onOther(a2)]), DrainRight])
        }));
      }
      case OP_PULL_BOTH: {
        return pipe(unsome(pullLeft), zip7(unsome(pullRight), {
          concurrent: true
        }), matchEffect2({
          onFailure: (error2) => succeed10(fail4(some2(error2))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed10(succeed4(merge12(leftOption.value, rightOption.value)));
            }
            if (isSome2(leftOption) && isNone2(rightOption)) {
              if (isEmpty(leftOption.value)) {
                return pull(DrainLeft, pullLeft, pullRight);
              }
              return succeed10(succeed4([pipe(leftOption.value, map4(([k, a]) => [k, options.onSelf(a)])), DrainLeft]));
            }
            if (isNone2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(rightOption.value)) {
                return pull(DrainRight, pullLeft, pullRight);
              }
              return succeed10(succeed4([pipe(rightOption.value, map4(([k, a2]) => [k, options.onOther(a2)])), DrainRight]));
            }
            return succeed10(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect2(pullLeft, {
          onFailure: match2({
            onNone: () => succeed10(succeed4([pipe(state.rightChunk, map4(([k, a2]) => [k, options.onOther(a2)])), DrainRight])),
            onSome: (error2) => succeed10(fail4(some2(error2)))
          }),
          onSuccess: (leftChunk) => isEmpty(leftChunk) ? pull(PullLeft(state.rightChunk), pullLeft, pullRight) : succeed10(succeed4(merge12(leftChunk, state.rightChunk)))
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect2(pullRight, {
          onFailure: match2({
            onNone: () => succeed10(succeed4([map4(state.leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])),
            onSome: (error2) => succeed10(fail4(some2(error2)))
          }),
          onSuccess: (rightChunk) => isEmpty(rightChunk) ? pull(PullRight(state.leftChunk), pullLeft, pullRight) : succeed10(succeed4(merge12(state.leftChunk, rightChunk)))
        });
      }
    }
  };
  const merge12 = (leftChunk, rightChunk) => {
    const hasNext = (chunk4, index) => index < chunk4.length - 1;
    const builder = [];
    let state = void 0;
    let leftIndex = 0;
    let rightIndex = 0;
    let leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
    let rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
    let k1 = leftTuple[0];
    let a = leftTuple[1];
    let k2 = rightTuple[0];
    let a2 = rightTuple[1];
    let loop3 = true;
    while (loop3) {
      const compare3 = options.order(k1, k2);
      if (compare3 === 0) {
        builder.push([k1, options.onBoth(a, a2)]);
        if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {
          leftIndex = leftIndex + 1;
          rightIndex = rightIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
          rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else if (hasNext(leftChunk, leftIndex)) {
          state = PullRight(pipe(leftChunk, drop2(leftIndex + 1)));
          loop3 = false;
        } else if (hasNext(rightChunk, rightIndex)) {
          state = PullLeft(pipe(rightChunk, drop2(rightIndex + 1)));
          loop3 = false;
        } else {
          state = PullBoth;
          loop3 = false;
        }
      } else if (compare3 < 0) {
        builder.push([k1, options.onSelf(a)]);
        if (hasNext(leftChunk, leftIndex)) {
          leftIndex = leftIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
        } else {
          const rightBuilder = [];
          rightBuilder.push(rightTuple);
          while (hasNext(rightChunk, rightIndex)) {
            rightIndex = rightIndex + 1;
            rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
            rightBuilder.push(rightTuple);
          }
          state = PullLeft(unsafeFromArray(rightBuilder));
          loop3 = false;
        }
      } else {
        builder.push([k2, options.onOther(a2)]);
        if (hasNext(rightChunk, rightIndex)) {
          rightIndex = rightIndex + 1;
          rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else {
          const leftBuilder = [];
          leftBuilder.push(leftTuple);
          while (hasNext(leftChunk, leftIndex)) {
            leftIndex = leftIndex + 1;
            leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
            leftBuilder.push(leftTuple);
          }
          state = PullRight(unsafeFromArray(leftBuilder));
          loop3 = false;
        }
      }
    }
    return [unsafeFromArray(builder), state];
  };
  return combineChunks(self, options.other, PullBoth, pull);
});
var zipAllWith = /* @__PURE__ */ dual(2, (self, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_DRAIN_LEFT: {
        return matchEffect2(pullLeft, {
          onFailure: (error2) => succeed10(fail4(error2)),
          onSuccess: (leftChunk) => succeed10(succeed4([map4(leftChunk, options.onSelf), DrainLeft]))
        });
      }
      case OP_DRAIN_RIGHT: {
        return matchEffect2(pullRight, {
          onFailure: (error2) => succeed10(fail4(error2)),
          onSuccess: (rightChunk) => succeed10(succeed4([map4(rightChunk, options.onOther), DrainRight]))
        });
      }
      case OP_PULL_BOTH: {
        return pipe(unsome(pullLeft), zip7(unsome(pullRight), {
          concurrent: true
        }), matchEffect2({
          onFailure: (error2) => succeed10(fail4(some2(error2))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed10(succeed4(zip13(leftOption.value, rightOption.value, options.onBoth)));
            }
            if (isSome2(leftOption) && isNone2(rightOption)) {
              return succeed10(succeed4([map4(leftOption.value, options.onSelf), DrainLeft]));
            }
            if (isNone2(leftOption) && isSome2(rightOption)) {
              return succeed10(succeed4([map4(rightOption.value, options.onOther), DrainRight]));
            }
            return succeed10(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect2(pullLeft, {
          onFailure: match2({
            onNone: () => succeed10(succeed4([map4(state.rightChunk, options.onOther), DrainRight])),
            onSome: (error2) => succeed10(fail4(some2(error2)))
          }),
          onSuccess: (leftChunk) => {
            if (isEmpty(leftChunk)) {
              return pull(PullLeft(state.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.rightChunk)) {
              return pull(PullRight(leftChunk), pullLeft, pullRight);
            }
            return succeed10(succeed4(zip13(leftChunk, state.rightChunk, options.onBoth)));
          }
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect2(pullRight, {
          onFailure: match2({
            onNone: () => succeed10(succeed4([map4(state.leftChunk, options.onSelf), DrainLeft])),
            onSome: (error2) => succeed10(fail4(some2(error2)))
          }),
          onSuccess: (rightChunk) => {
            if (isEmpty(rightChunk)) {
              return pull(PullRight(state.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.leftChunk)) {
              return pull(PullLeft(rightChunk), pullLeft, pullRight);
            }
            return succeed10(succeed4(zip13(state.leftChunk, rightChunk, options.onBoth)));
          }
        });
      }
    }
  };
  const zip13 = (leftChunk, rightChunk, f) => {
    const [output3, either8] = zipChunks(leftChunk, rightChunk, f);
    switch (either8._tag) {
      case "Left": {
        if (isEmpty(either8.left)) {
          return [output3, PullBoth];
        }
        return [output3, PullRight(either8.left)];
      }
      case "Right": {
        if (isEmpty(either8.right)) {
          return [output3, PullBoth];
        }
        return [output3, PullLeft(either8.right)];
      }
    }
  };
  return combineChunks(self, options.other, PullBoth, pull);
});
var zipLatest = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipLatestWith(right3, (a, a2) => [a, a2])));
var zipLatestAll = (...streams) => {
  if (streams.length === 0) {
    return empty33;
  } else if (streams.length === 1) {
    return map24(streams[0], (x) => [x]);
  }
  const [head8, ...tail2] = streams;
  return zipLatestWith(head8, zipLatestAll(...tail2), (first2, second) => [first2, ...second]);
};
var zipLatestWith = /* @__PURE__ */ dual(3, (left3, right3, f) => {
  const pullNonEmpty = (pull) => pipe(pull, flatMap12((chunk4) => isEmpty(chunk4) ? pullNonEmpty(pull) : succeed10(chunk4)));
  return pipe(toPull2(left3), map18(pullNonEmpty), zip7(pipe(toPull2(right3), map18(pullNonEmpty))), flatMap12(([left4, right4]) => pipe(fromEffectOption(raceWith2(left4, right4, {
    onSelfDone: (leftDone, rightFiber) => pipe(suspend4(() => leftDone), zipWith9(join4(rightFiber), (l, r) => [l, r, true])),
    onOtherDone: (rightDone, leftFiber) => pipe(suspend4(() => rightDone), zipWith9(join4(leftFiber), (l, r) => [r, l, false]))
  })), flatMap17(([l, r, leftFirst]) => pipe(fromEffect8(make25([unsafeLast(l), unsafeLast(r)])), flatMap17((latest) => pipe(fromChunk(leftFirst ? pipe(r, map4((a2) => f(unsafeLast(l), a2))) : pipe(l, map4((a) => f(a, unsafeLast(r))))), concat2(pipe(repeatEffectOption(left4), mergeEither(repeatEffectOption(right4)), mapEffectSequential(match({
    onLeft: (leftChunk) => pipe(modify6(latest, ([_, rightLatest]) => [pipe(leftChunk, map4((a) => f(a, rightLatest))), [unsafeLast(leftChunk), rightLatest]])),
    onRight: (rightChunk) => pipe(modify6(latest, ([leftLatest, _]) => [pipe(rightChunk, map4((a2) => f(leftLatest, a2))), [leftLatest, unsafeLast(rightChunk)]]))
  })), flatMap17(fromChunk))))))), toPull2)), fromPull2);
});
var zipLeft8 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
  if (left4.length > right4.length) {
    return [pipe(left4, take(right4.length)), left2(pipe(left4, take(right4.length)))];
  }
  return [left4, right2(pipe(right4, drop2(left4.length)))];
})));
var zipRight11 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
  if (left4.length > right4.length) {
    return [right4, left2(pipe(left4, take(right4.length)))];
  }
  return [pipe(right4, take(left4.length)), right2(pipe(right4, drop2(left4.length)))];
})));
var zipWith14 = /* @__PURE__ */ dual(3, (left3, right3, f) => pipe(left3, zipWithChunks(right3, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f))));
var zipWithChunks = /* @__PURE__ */ dual(3, (self, that, f) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_PULL_BOTH2: {
        return pipe(unsome(pullLeft), zip7(unsome(pullRight), {
          concurrent: true
        }), matchEffect2({
          onFailure: (error2) => succeed10(fail4(some2(error2))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth2, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft2(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight2(leftOption.value), pullLeft, pullRight);
              }
              return succeed10(succeed4(zip13(leftOption.value, rightOption.value)));
            }
            return succeed10(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT2: {
        return matchEffect2(pullLeft, {
          onFailure: (error2) => succeed10(fail4(error2)),
          onSuccess: (leftChunk) => {
            if (isEmpty(leftChunk)) {
              return pull(PullLeft2(state.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.rightChunk)) {
              return pull(PullRight2(leftChunk), pullLeft, pullRight);
            }
            return succeed10(succeed4(zip13(leftChunk, state.rightChunk)));
          }
        });
      }
      case OP_PULL_RIGHT2: {
        return matchEffect2(pullRight, {
          onFailure: (error2) => succeed10(fail4(error2)),
          onSuccess: (rightChunk) => {
            if (isEmpty(rightChunk)) {
              return pull(PullRight2(state.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.leftChunk)) {
              return pull(PullLeft2(rightChunk), pullLeft, pullRight);
            }
            return succeed10(succeed4(zip13(state.leftChunk, rightChunk)));
          }
        });
      }
    }
  };
  const zip13 = (leftChunk, rightChunk) => {
    const [output3, either8] = f(leftChunk, rightChunk);
    switch (either8._tag) {
      case "Left": {
        if (isEmpty(either8.left)) {
          return [output3, PullBoth2];
        }
        return [output3, PullRight2(either8.left)];
      }
      case "Right": {
        if (isEmpty(either8.right)) {
          return [output3, PullBoth2];
        }
        return [output3, PullLeft2(either8.right)];
      }
    }
  };
  return pipe(self, combineChunks(that, PullBoth2, pull));
});
var zipWithIndex = (self) => pipe(self, mapAccum5(0, (index, a) => [index + 1, [a, index]]));
var zipWithNext = (self) => {
  const process2 = (last5) => readWithCause({
    onInput: (input) => {
      const [newLast, chunk4] = mapAccum2(input, last5, (prev, curr) => [some2(curr), pipe(prev, map2((a) => [a, curr]))]);
      const output3 = filterMap4(chunk4, (option5) => isSome2(option5) ? some2([option5.value[0], some2(option5.value[1])]) : none2());
      return flatMap14(write(output3), () => process2(newLast));
    },
    onFailure: failCause11,
    onDone: () => match2(last5, {
      onNone: () => void_7,
      onSome: (value3) => zipRight7(write(of2([value3, none2()])), void_7)
    })
  });
  return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(process2(none2()))));
};
var zipWithPrevious = (self) => pipe(self, mapAccum5(none2(), (prev, curr) => [some2(curr), [prev, curr]]));
var zipWithPreviousAndNext = (self) => pipe(zipWithNext(zipWithPrevious(self)), map24(([[prev, curr], next4]) => [prev, curr, pipe(next4, map2((tuple4) => tuple4[1]))]));
var zipChunks = (left3, right3, f) => {
  if (left3.length > right3.length) {
    return [pipe(left3, take(right3.length), zipWith3(right3, f)), left2(pipe(left3, drop2(right3.length)))];
  }
  return [pipe(left3, zipWith3(pipe(right3, take(left3.length)), f)), right2(pipe(right3, drop2(left3.length)))];
};
var Do4 = /* @__PURE__ */ succeed16({});
var bind5 = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self, tag3, f, options) => flatMap17(self, (k) => map24(f(k), (a) => ({
  ...k,
  [tag3]: a
})), options));
var bindTo5 = /* @__PURE__ */ bindTo(map24);
var let_5 = /* @__PURE__ */ let_(map24);
var decodeText = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, encoding = "utf-8") => suspend10(() => {
  const decoder2 = new TextDecoder(encoding);
  return map24(self, (s) => decoder2.decode(s));
}));
var encodeText = (self) => suspend10(() => {
  const encoder2 = new TextEncoder();
  return map24(self, (s) => encoder2.encode(s));
});
var fromEventListener = (target, type, options) => asyncPush((emit2) => acquireRelease2(sync5(() => target.addEventListener(type, emit2.single, options)), () => sync5(() => target.removeEventListener(type, emit2.single, options))), {
  bufferSize: typeof options === "object" ? options.bufferSize : void 0
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/groupBy.js
var GroupBySymbolKey = "effect/GroupBy";
var GroupByTypeId = /* @__PURE__ */ Symbol.for(GroupBySymbolKey);
var groupByVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _K: (_) => _,
  /* c8 ignore next */
  _V: (_) => _
};
var isGroupBy = (u) => hasProperty(u, GroupByTypeId);
var evaluate2 = /* @__PURE__ */ dual((args2) => isGroupBy(args2[0]), (self, f, options) => flatMap17(self.grouped, ([key, queue]) => f(key, flattenTake(fromQueue2(queue, {
  shutdown: true
}))), {
  concurrency: "unbounded",
  bufferSize: options?.bufferSize ?? 16
}));
var make54 = (grouped3) => ({
  [GroupByTypeId]: groupByVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  grouped: grouped3
});
var groupBy = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, f, options) => make54(unwrapScoped4(gen3(function* () {
  const decider = yield* make23();
  const output3 = yield* acquireRelease2(bounded3(options?.bufferSize ?? 16), (queue) => shutdown2(queue));
  const ref = yield* make25(/* @__PURE__ */ new Map());
  const add8 = yield* pipe(mapEffectSequential(self, f), distributedWithDynamicCallback(options?.bufferSize ?? 16, ([key, value3]) => flatMap12(_await(decider), (f2) => f2(key, value3)), (exit4) => offer3(output3, exit4)));
  yield* succeed2(decider, (key, _) => pipe(get11(ref), map18((map31) => fromNullable(map31.get(key))), flatMap12(match2({
    onNone: () => flatMap12(add8, ([index, queue]) => zipRight6(update3(ref, (map31) => map31.set(key, index)), pipe(offer3(output3, succeed4([key, mapDequeue(queue, (exit4) => new TakeImpl(pipe(exit4, map12((tuple4) => of2(tuple4[1])))))])), as6((n) => n === index)))),
    onSome: (index) => succeed10((n) => n === index)
  }))));
  return flattenExitOption(fromQueue2(output3, {
    shutdown: true
  }));
}))));
var mapEffectOptions = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self, f, options) => {
  if (options?.key) {
    return evaluate2(groupByKey(self, options.key, {
      bufferSize: options.bufferSize
    }), (_, s) => mapEffectSequential(s, f));
  }
  return matchConcurrency(options?.concurrency, () => mapEffectSequential(self, f), (n) => options?.unordered ? flatMap17(self, (a) => fromEffect8(f(a)), {
    concurrency: n
  }) : mapEffectPar(self, n, f));
});
var bindEffect = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self, tag3, f, options) => mapEffectOptions(self, (k) => map18(f(k), (a) => ({
  ...k,
  [tag3]: a
})), options));
var mapDequeue = (dequeue, f) => new MapDequeue(dequeue, f);
var _a72, _b25;
var MapDequeue = class extends (_b25 = Class2, _a72 = DequeueTypeId2, _b25) {
  constructor(dequeue, f) {
    super();
    __publicField(this, "dequeue");
    __publicField(this, "f");
    __publicField(this, _a72, {
      _Out: (_) => _
    });
    this.dequeue = dequeue;
    this.f = f;
  }
  capacity() {
    return capacity3(this.dequeue);
  }
  get size() {
    return size13(this.dequeue);
  }
  unsafeSize() {
    return this.dequeue.unsafeSize();
  }
  get awaitShutdown() {
    return awaitShutdown2(this.dequeue);
  }
  isActive() {
    return this.dequeue.isActive();
  }
  get isShutdown() {
    return isShutdown2(this.dequeue);
  }
  get shutdown() {
    return shutdown2(this.dequeue);
  }
  get isFull() {
    return isFull2(this.dequeue);
  }
  get isEmpty() {
    return isEmpty11(this.dequeue);
  }
  get take() {
    return pipe(take3(this.dequeue), map18((a) => this.f(a)));
  }
  get takeAll() {
    return pipe(takeAll2(this.dequeue), map18(map4((a) => this.f(a))));
  }
  takeUpTo(max7) {
    return pipe(takeUpTo2(this.dequeue, max7), map18(map4((a) => this.f(a))));
  }
  takeBetween(min5, max7) {
    return pipe(takeBetween2(this.dequeue, min5, max7), map18(map4((a) => this.f(a))));
  }
  takeN(n) {
    return pipe(takeN2(this.dequeue, n), map18(map4((a) => this.f(a))));
  }
  poll() {
    return pipe(poll6(this.dequeue), map18(map2((a) => this.f(a))));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
};
var groupByKey = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self, f, options) => {
  const loop3 = (map31, outerQueue) => readWithCause({
    onInput: (input) => flatMap14(fromEffect5(forEach10(groupByIterable(input, f), ([key, values5]) => {
      const innerQueue = map31.get(key);
      if (innerQueue === void 0) {
        return pipe(bounded3(options?.bufferSize ?? 16), flatMap12((innerQueue2) => pipe(sync5(() => {
          map31.set(key, innerQueue2);
        }), zipRight6(offer3(outerQueue, of5([key, innerQueue2]))), zipRight6(pipe(offer3(innerQueue2, chunk2(values5)), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2()))))));
      }
      return catchSomeCause2(offer3(innerQueue, chunk2(values5)), (cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2());
    }, {
      discard: true
    })), () => loop3(map31, outerQueue)),
    onFailure: (cause3) => fromEffect5(offer3(outerQueue, failCause12(cause3))),
    onDone: () => pipe(fromEffect5(pipe(forEach10(map31.entries(), ([_, innerQueue]) => pipe(offer3(innerQueue, end4), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2())), {
      discard: true
    }), zipRight6(offer3(outerQueue, end4)))))
  });
  return make54(unwrapScopedWith3((scope5) => gen3(function* () {
    const map31 = /* @__PURE__ */ new Map();
    const queue = yield* unbounded3();
    yield* addFinalizer2(scope5, shutdown2(queue));
    return yield* toChannel2(self).pipe(pipeTo(loop3(map31, queue)), drain, runIn(scope5), forkIn2(scope5), as6(flattenTake(fromQueue2(queue, {
      shutdown: true
    }))));
  })));
});
var groupByIterable = /* @__PURE__ */ dual(2, (iterable, f) => {
  const builder = [];
  const iterator = iterable[Symbol.iterator]();
  const map31 = /* @__PURE__ */ new Map();
  let next4;
  while ((next4 = iterator.next()) && !next4.done) {
    const value3 = next4.value;
    const key = f(value3);
    if (map31.has(key)) {
      const innerBuilder = map31.get(key);
      innerBuilder.push(value3);
    } else {
      const innerBuilder = [value3];
      builder.push([key, innerBuilder]);
      map31.set(key, innerBuilder);
    }
  }
  return unsafeFromArray(builder.map((tuple4) => [tuple4[0], unsafeFromArray(tuple4[1])]));
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Stream.js
var StreamTypeId3 = StreamTypeId2;
var DefaultChunkSize2 = DefaultChunkSize;
var accumulate2 = accumulate;
var accumulateChunks2 = accumulateChunks;
var acquireRelease4 = acquireRelease3;
var aggregate2 = aggregate;
var aggregateWithin2 = aggregateWithin;
var aggregateWithinEither2 = aggregateWithinEither;
var as11 = as10;
var _async2 = _async;
var asyncEffect4 = asyncEffect3;
var asyncPush2 = asyncPush;
var asyncScoped2 = asyncScoped;
var branchAfter2 = branchAfter;
var broadcast2 = broadcast;
var share2 = share;
var broadcastDynamic2 = broadcastDynamic;
var broadcastedQueues2 = broadcastedQueues;
var broadcastedQueuesDynamic2 = broadcastedQueuesDynamic;
var buffer2 = buffer;
var bufferChunks2 = bufferChunks;
var catchAll8 = catchAll7;
var catchAllCause7 = catchAllCause6;
var catchSome4 = catchSome3;
var catchTag4 = catchTag3;
var catchTags4 = catchTags3;
var catchSomeCause4 = catchSomeCause3;
var changes2 = changes;
var changesWith2 = changesWith;
var changesWithEffect2 = changesWithEffect;
var chunks2 = chunks;
var chunksWith2 = chunksWith;
var combine10 = combine9;
var combineChunks2 = combineChunks;
var concat3 = concat2;
var concatAll3 = concatAll2;
var cross2 = cross;
var crossLeft2 = crossLeft;
var crossRight2 = crossRight;
var crossWith2 = crossWith;
var debounce2 = debounce;
var die11 = die10;
var dieSync7 = dieSync6;
var dieMessage5 = dieMessage4;
var distributedWith2 = distributedWith;
var distributedWithDynamic2 = distributedWithDynamic;
var drain4 = drain3;
var drainFork2 = drainFork;
var drop4 = drop3;
var dropRight3 = dropRight2;
var dropUntil4 = dropUntil3;
var dropUntilEffect2 = dropUntilEffect;
var dropWhile5 = dropWhile4;
var dropWhileEffect2 = dropWhileEffect;
var either7 = either6;
var empty34 = empty33;
var ensuring8 = ensuring7;
var ensuringWith3 = ensuringWith2;
var context6 = context5;
var contextWith4 = contextWith3;
var contextWithEffect4 = contextWithEffect3;
var contextWithStream2 = contextWithStream;
var execute2 = execute;
var fail17 = fail16;
var failSync8 = failSync7;
var failCause15 = failCause14;
var failCauseSync7 = failCauseSync6;
var filter11 = filter10;
var filterEffect2 = filterEffect;
var filterMap10 = filterMap9;
var filterMapEffect2 = filterMapEffect;
var filterMapWhile4 = filterMapWhile3;
var filterMapWhileEffect2 = filterMapWhileEffect;
var finalizer2 = finalizer;
var find3 = find2;
var findEffect2 = findEffect;
var flatMap18 = flatMap17;
var flatten14 = flatten13;
var flattenChunks2 = flattenChunks;
var flattenEffect2 = flattenEffect;
var flattenExitOption2 = flattenExitOption;
var flattenIterables2 = flattenIterables;
var flattenTake2 = flattenTake;
var forever6 = forever5;
var fromAsyncIterable2 = fromAsyncIterable;
var fromChannel3 = fromChannel2;
var toChannel3 = toChannel2;
var fromChunk2 = fromChunk;
var fromChunkPubSub2 = fromChunkPubSub;
var fromChunkQueue2 = fromChunkQueue;
var fromChunks2 = fromChunks;
var fromEffect9 = fromEffect8;
var fromEffectOption2 = fromEffectOption;
var fromPubSub2 = fromPubSub;
var fromTPubSub2 = fromTPubSub;
var fromIterable15 = fromIterable14;
var fromIterableEffect2 = fromIterableEffect;
var fromIteratorSucceed2 = fromIteratorSucceed;
var fromPull3 = fromPull2;
var fromQueue3 = fromQueue2;
var fromTQueue2 = fromTQueue;
var fromReadableStream2 = fromReadableStream;
var fromReadableStreamByob2 = fromReadableStreamByob;
var fromSchedule2 = fromSchedule;
var groupAdjacentBy2 = groupAdjacentBy;
var groupBy2 = groupBy;
var groupByKey2 = groupByKey;
var grouped2 = grouped;
var groupedWithin2 = groupedWithin;
var haltAfter2 = haltAfter;
var haltWhen2 = haltWhen;
var haltWhenDeferred2 = haltWhenDeferred;
var identity4 = identityStream;
var interleave2 = interleave;
var interleaveWith2 = interleaveWith;
var intersperse2 = intersperse;
var intersperseAffixes2 = intersperseAffixes;
var interruptAfter2 = interruptAfter;
var interruptWhen3 = interruptWhen2;
var interruptWhenDeferred3 = interruptWhenDeferred2;
var iterate4 = iterate3;
var make55 = make53;
var map25 = map24;
var mapAccum6 = mapAccum5;
var mapAccumEffect2 = mapAccumEffect;
var mapBoth8 = mapBoth7;
var mapChunks2 = mapChunks;
var mapChunksEffect2 = mapChunksEffect;
var mapConcat2 = mapConcat;
var mapConcatChunk2 = mapConcatChunk;
var mapConcatChunkEffect2 = mapConcatChunkEffect;
var mapConcatEffect2 = mapConcatEffect;
var mapEffect6 = mapEffectOptions;
var mapError7 = mapError6;
var mapErrorCause5 = mapErrorCause4;
var merge10 = merge9;
var mergeAll9 = mergeAll8;
var mergeWithTag2 = mergeWithTag;
var mergeWith4 = mergeWith3;
var mergeEither2 = mergeEither;
var mergeLeft2 = mergeLeft;
var mergeRight2 = mergeRight;
var mkString3 = mkString2;
var never6 = never5;
var onEnd2 = onEnd;
var onError4 = onError3;
var onDone2 = onDone;
var onStart2 = onStart;
var orDie6 = orDie5;
var orDieWith5 = orDieWith4;
var orElse10 = orElse9;
var orElseEither6 = orElseEither5;
var orElseFail4 = orElseFail3;
var orElseIfEmpty2 = orElseIfEmpty;
var orElseIfEmptyChunk2 = orElseIfEmptyChunk;
var orElseIfEmptyStream2 = orElseIfEmptyStream;
var orElseSucceed4 = orElseSucceed3;
var paginate2 = paginate;
var paginateChunk2 = paginateChunk;
var paginateChunkEffect2 = paginateChunkEffect;
var paginateEffect2 = paginateEffect;
var partition7 = partition6;
var partitionEither2 = partitionEither;
var peel2 = peel;
var pipeThrough2 = pipeThrough;
var pipeThroughChannel2 = pipeThroughChannel;
var pipeThroughChannelOrFail2 = pipeThroughChannelOrFail;
var prepend5 = prepend4;
var provideContext7 = provideContext6;
var provideLayer2 = provideLayer;
var provideService7 = provideService6;
var provideServiceEffect4 = provideServiceEffect3;
var provideServiceStream2 = provideServiceStream;
var mapInputContext7 = mapInputContext6;
var provideSomeLayer3 = provideSomeLayer2;
var race4 = race3;
var raceAll4 = raceAll3;
var range3 = range2;
var rechunk2 = rechunk;
var refineOrDie2 = refineOrDie;
var refineOrDieWith2 = refineOrDieWith;
var repeat3 = repeat2;
var repeatEffect2 = repeatEffect;
var repeatEffectChunk2 = repeatEffectChunk;
var repeatEffectChunkOption2 = repeatEffectChunkOption;
var repeatEffectOption2 = repeatEffectOption;
var repeatEffectWithSchedule2 = repeatEffectWithSchedule;
var repeatEither2 = repeatEither;
var repeatElements2 = repeatElements;
var repeatElementsWith2 = repeatElementsWith;
var repeatValue2 = repeatValue;
var repeatWith2 = repeatWith;
var retry7 = retry6;
var withExecutionPlan4 = withExecutionPlan3;
var run5 = run4;
var runCollect2 = runCollect;
var runCount2 = runCount;
var runDrain3 = runDrain2;
var runFold2 = runFold;
var runFoldEffect2 = runFoldEffect;
var runFoldScoped2 = runFoldScoped;
var runFoldScopedEffect2 = runFoldScopedEffect;
var runFoldWhile2 = runFoldWhile;
var runFoldWhileEffect2 = runFoldWhileEffect;
var runFoldWhileScoped2 = runFoldWhileScoped;
var runFoldWhileScopedEffect2 = runFoldWhileScopedEffect;
var runForEach2 = runForEach;
var runForEachChunk2 = runForEachChunk;
var runForEachChunkScoped2 = runForEachChunkScoped;
var runForEachScoped2 = runForEachScoped;
var runForEachWhile2 = runForEachWhile;
var runForEachWhileScoped2 = runForEachWhileScoped;
var runHead2 = runHead;
var runIntoPubSub2 = runIntoPubSub;
var runIntoPubSubScoped2 = runIntoPubSubScoped;
var runIntoQueue2 = runIntoQueue;
var runIntoQueueElementsScoped2 = runIntoQueueElementsScoped;
var runIntoQueueScoped2 = runIntoQueueScoped;
var runLast2 = runLast;
var runScoped3 = runScoped2;
var runSum2 = runSum;
var scan2 = scan;
var scanEffect2 = scanEffect;
var scanReduce2 = scanReduce;
var scanReduceEffect2 = scanReduceEffect;
var schedule3 = schedule2;
var scheduleWith2 = scheduleWith;
var scoped7 = scoped6;
var scopedWith5 = scopedWith4;
var sliding8 = sliding7;
var slidingSize2 = slidingSize;
var some8 = some7;
var someOrElse2 = someOrElse;
var someOrFail2 = someOrFail;
var split4 = split3;
var splitOnChunk2 = splitOnChunk;
var splitLines3 = splitLines2;
var succeed17 = succeed16;
var sync11 = sync10;
var suspend11 = suspend10;
var take8 = take7;
var takeRight3 = takeRight2;
var takeUntil4 = takeUntil3;
var takeUntilEffect2 = takeUntilEffect;
var takeWhile5 = takeWhile4;
var tap8 = tap7;
var tapBoth4 = tapBoth3;
var tapError6 = tapError5;
var tapErrorCause6 = tapErrorCause5;
var tapSink2 = tapSink;
var throttle2 = throttle;
var throttleEffect2 = throttleEffect;
var tick2 = tick;
var timeout4 = timeout3;
var timeoutFail4 = timeoutFail3;
var timeoutFailCause4 = timeoutFailCause3;
var timeoutTo4 = timeoutTo3;
var toPubSub3 = toPubSub2;
var toPull3 = toPull2;
var toQueue3 = toQueue2;
var toQueueOfElements2 = toQueueOfElements;
var toReadableStream2 = toReadableStream;
var toReadableStreamEffect2 = toReadableStreamEffect;
var toReadableStreamRuntime2 = toReadableStreamRuntime;
var toAsyncIterableRuntime2 = toAsyncIterableRuntime;
var toAsyncIterableEffect2 = toAsyncIterableEffect;
var toAsyncIterable2 = toAsyncIterable;
var transduce2 = transduce;
var unfold5 = unfold4;
var unfoldChunk2 = unfoldChunk;
var unfoldChunkEffect2 = unfoldChunkEffect;
var unfoldEffect2 = unfoldEffect;
var void_10 = void_9;
var unwrap3 = unwrap2;
var unwrapScoped5 = unwrapScoped4;
var unwrapScopedWith4 = unwrapScopedWith3;
var updateService5 = updateService4;
var when4 = when3;
var whenCase2 = whenCase;
var whenCaseEffect2 = whenCaseEffect;
var whenEffect4 = whenEffect3;
var withSpan7 = withSpan6;
var zip10 = zip9;
var zipFlatten2 = zipFlatten;
var zipAll2 = zipAll;
var zipAllLeft2 = zipAllLeft;
var zipAllRight2 = zipAllRight;
var zipAllSortedByKey2 = zipAllSortedByKey;
var zipAllSortedByKeyLeft2 = zipAllSortedByKeyLeft;
var zipAllSortedByKeyRight2 = zipAllSortedByKeyRight;
var zipAllSortedByKeyWith2 = zipAllSortedByKeyWith;
var zipAllWith2 = zipAllWith;
var zipLatest2 = zipLatest;
var zipLatestAll2 = zipLatestAll;
var zipLatestWith2 = zipLatestWith;
var zipLeft9 = zipLeft8;
var zipRight12 = zipRight11;
var zipWith15 = zipWith14;
var zipWithChunks2 = zipWithChunks;
var zipWithNext2 = zipWithNext;
var zipWithPrevious2 = zipWithPrevious;
var zipWithPreviousAndNext2 = zipWithPreviousAndNext;
var zipWithIndex2 = zipWithIndex;
var Do5 = Do4;
var bind6 = bind5;
var bindEffect2 = bindEffect;
var bindTo6 = bindTo5;
var let_6 = let_5;
var decodeText2 = decodeText;
var encodeText2 = encodeText;
var fromEventListener2 = fromEventListener;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Schema.js
var Schema_exports = {};
__export(Schema_exports, {
  Any: () => Any,
  Array: () => Array$,
  ArrayEnsure: () => ArrayEnsure,
  ArrayFormatterIssue: () => ArrayFormatterIssue,
  BetweenBigDecimalSchemaId: () => BetweenBigDecimalSchemaId,
  BetweenBigIntSchemaId: () => BetweenBigIntSchemaId,
  BetweenDateSchemaId: () => BetweenDateSchemaId,
  BetweenDurationSchemaId: () => BetweenDurationSchemaId,
  BetweenSchemaId: () => BetweenSchemaId2,
  BigDecimal: () => BigDecimal,
  BigDecimalFromNumber: () => BigDecimalFromNumber,
  BigDecimalFromSelf: () => BigDecimalFromSelf,
  BigInt: () => BigInt$,
  BigIntFromNumber: () => BigIntFromNumber,
  BigIntFromSelf: () => BigIntFromSelf,
  Boolean: () => Boolean$,
  BooleanFromString: () => BooleanFromString,
  BooleanFromUnknown: () => BooleanFromUnknown,
  BrandSchemaId: () => BrandSchemaId,
  Capitalize: () => Capitalize,
  Capitalized: () => Capitalized,
  CapitalizedSchemaId: () => CapitalizedSchemaId,
  Cause: () => Cause,
  CauseFromSelf: () => CauseFromSelf,
  Char: () => Char,
  Chunk: () => Chunk,
  ChunkFromSelf: () => ChunkFromSelf,
  Class: () => Class6,
  Config: () => Config,
  Data: () => Data,
  DataFromSelf: () => DataFromSelf,
  Date: () => Date$,
  DateFromNumber: () => DateFromNumber,
  DateFromSelf: () => DateFromSelf,
  DateFromSelfSchemaId: () => DateFromSelfSchemaId2,
  DateFromString: () => DateFromString,
  DateTimeUtc: () => DateTimeUtc,
  DateTimeUtcFromDate: () => DateTimeUtcFromDate,
  DateTimeUtcFromNumber: () => DateTimeUtcFromNumber,
  DateTimeUtcFromSelf: () => DateTimeUtcFromSelf,
  DateTimeZoned: () => DateTimeZoned,
  DateTimeZonedFromSelf: () => DateTimeZonedFromSelf,
  Defect: () => Defect,
  Duration: () => Duration,
  DurationFromMillis: () => DurationFromMillis,
  DurationFromNanos: () => DurationFromNanos,
  DurationFromSelf: () => DurationFromSelf,
  Either: () => Either2,
  EitherFromSelf: () => EitherFromSelf,
  EitherFromUnion: () => EitherFromUnion,
  EndsWithSchemaId: () => EndsWithSchemaId,
  Enums: () => Enums2,
  Exit: () => Exit,
  ExitFromSelf: () => ExitFromSelf,
  FiberId: () => FiberId,
  FiberIdFromSelf: () => FiberIdFromSelf,
  Finite: () => Finite,
  FiniteSchemaId: () => FiniteSchemaId2,
  FromPropertySignature: () => FromPropertySignature,
  GreaterThanBigDecimalSchemaId: () => GreaterThanBigDecimalSchemaId,
  GreaterThanBigIntSchemaId: () => GreaterThanBigIntSchemaId,
  GreaterThanDateSchemaId: () => GreaterThanDateSchemaId,
  GreaterThanDurationSchemaId: () => GreaterThanDurationSchemaId,
  GreaterThanOrEqualToBigDecimalSchemaId: () => GreaterThanOrEqualToBigDecimalSchemaId,
  GreaterThanOrEqualToBigIntSchemaId: () => GreaterThanOrEqualToBigIntSchemaId2,
  GreaterThanOrEqualToDateSchemaId: () => GreaterThanOrEqualToDateSchemaId,
  GreaterThanOrEqualToDurationSchemaId: () => GreaterThanOrEqualToDurationSchemaId,
  GreaterThanOrEqualToSchemaId: () => GreaterThanOrEqualToSchemaId2,
  GreaterThanSchemaId: () => GreaterThanSchemaId2,
  HashMap: () => HashMap,
  HashMapFromSelf: () => HashMapFromSelf,
  HashSet: () => HashSet,
  HashSetFromSelf: () => HashSetFromSelf,
  IncludesSchemaId: () => IncludesSchemaId,
  InstanceOfSchemaId: () => InstanceOfSchemaId,
  Int: () => Int,
  IntSchemaId: () => IntSchemaId2,
  ItemsCountSchemaId: () => ItemsCountSchemaId2,
  JsonNumber: () => JsonNumber,
  JsonNumberSchemaId: () => JsonNumberSchemaId2,
  LengthSchemaId: () => LengthSchemaId2,
  LessThanBigDecimalSchemaId: () => LessThanBigDecimalSchemaId,
  LessThanBigIntSchemaId: () => LessThanBigIntSchemaId2,
  LessThanDateSchemaId: () => LessThanDateSchemaId,
  LessThanDurationSchemaId: () => LessThanDurationSchemaId,
  LessThanOrEqualToBigDecimalSchemaId: () => LessThanOrEqualToBigDecimalSchemaId,
  LessThanOrEqualToBigIntSchemaId: () => LessThanOrEqualToBigIntSchemaId2,
  LessThanOrEqualToDateSchemaId: () => LessThanOrEqualToDateSchemaId,
  LessThanOrEqualToDurationSchemaId: () => LessThanOrEqualToDurationSchemaId,
  LessThanOrEqualToSchemaId: () => LessThanOrEqualToSchemaId2,
  LessThanSchemaId: () => LessThanSchemaId2,
  List: () => List,
  ListFromSelf: () => ListFromSelf,
  Literal: () => Literal2,
  Lowercase: () => Lowercase,
  Lowercased: () => Lowercased,
  LowercasedSchemaId: () => LowercasedSchemaId,
  Map: () => map28,
  MapFromRecord: () => MapFromRecord,
  MapFromSelf: () => MapFromSelf,
  MaxItemsSchemaId: () => MaxItemsSchemaId2,
  MaxLengthSchemaId: () => MaxLengthSchemaId2,
  MinItemsSchemaId: () => MinItemsSchemaId2,
  MinLengthSchemaId: () => MinLengthSchemaId2,
  MultipleOfSchemaId: () => MultipleOfSchemaId,
  Negative: () => Negative,
  NegativeBigDecimalFromSelf: () => NegativeBigDecimalFromSelf,
  NegativeBigDecimalSchemaId: () => NegativeBigDecimalSchemaId,
  NegativeBigInt: () => NegativeBigInt,
  NegativeBigIntFromSelf: () => NegativeBigIntFromSelf,
  Never: () => Never,
  NonEmptyArray: () => NonEmptyArray,
  NonEmptyArrayEnsure: () => NonEmptyArrayEnsure,
  NonEmptyChunk: () => NonEmptyChunk,
  NonEmptyChunkFromSelf: () => NonEmptyChunkFromSelf,
  NonEmptyString: () => NonEmptyString,
  NonEmptyTrimmedString: () => NonEmptyTrimmedString,
  NonNaN: () => NonNaN,
  NonNaNSchemaId: () => NonNaNSchemaId2,
  NonNegative: () => NonNegative,
  NonNegativeBigDecimalFromSelf: () => NonNegativeBigDecimalFromSelf,
  NonNegativeBigDecimalSchemaId: () => NonNegativeBigDecimalSchemaId,
  NonNegativeBigInt: () => NonNegativeBigInt,
  NonNegativeBigIntFromSelf: () => NonNegativeBigIntFromSelf,
  NonNegativeInt: () => NonNegativeInt,
  NonPositive: () => NonPositive,
  NonPositiveBigDecimalFromSelf: () => NonPositiveBigDecimalFromSelf,
  NonPositiveBigDecimalSchemaId: () => NonPositiveBigDecimalSchemaId,
  NonPositiveBigInt: () => NonPositiveBigInt,
  NonPositiveBigIntFromSelf: () => NonPositiveBigIntFromSelf,
  Not: () => Not,
  Null: () => Null,
  NullOr: () => NullOr,
  NullishOr: () => NullishOr,
  Number: () => Number$,
  NumberFromString: () => NumberFromString,
  Object: () => Object$,
  Option: () => Option,
  OptionFromNonEmptyTrimmedString: () => OptionFromNonEmptyTrimmedString,
  OptionFromNullOr: () => OptionFromNullOr,
  OptionFromNullishOr: () => OptionFromNullishOr,
  OptionFromSelf: () => OptionFromSelf,
  OptionFromUndefinedOr: () => OptionFromUndefinedOr,
  PatternSchemaId: () => PatternSchemaId,
  Positive: () => Positive,
  PositiveBigDecimalFromSelf: () => PositiveBigDecimalFromSelf,
  PositiveBigDecimalSchemaId: () => PositiveBigDecimalSchemaId,
  PositiveBigInt: () => PositiveBigInt,
  PositiveBigIntFromSelf: () => PositiveBigIntFromSelf,
  PropertyKey: () => PropertyKey$,
  PropertySignatureDeclaration: () => PropertySignatureDeclaration,
  PropertySignatureTransformation: () => PropertySignatureTransformation2,
  PropertySignatureTypeId: () => PropertySignatureTypeId,
  ReadonlyMap: () => ReadonlyMap,
  ReadonlyMapFromRecord: () => ReadonlyMapFromRecord,
  ReadonlyMapFromSelf: () => ReadonlyMapFromSelf,
  ReadonlySet: () => ReadonlySet,
  ReadonlySetFromSelf: () => ReadonlySetFromSelf,
  Record: () => Record,
  Redacted: () => Redacted,
  RedactedFromSelf: () => RedactedFromSelf,
  RefineSchemaId: () => RefineSchemaId,
  Set: () => set8,
  SetFromSelf: () => SetFromSelf,
  SortedSet: () => SortedSet,
  SortedSetFromSelf: () => SortedSetFromSelf,
  StartsWithSchemaId: () => StartsWithSchemaId,
  String: () => String$,
  StringFromBase64: () => StringFromBase64,
  StringFromBase64Url: () => StringFromBase64Url,
  StringFromHex: () => StringFromHex,
  StringFromUriComponent: () => StringFromUriComponent,
  Struct: () => Struct,
  Symbol: () => Symbol$,
  SymbolFromSelf: () => SymbolFromSelf,
  TaggedClass: () => TaggedClass3,
  TaggedError: () => TaggedError2,
  TaggedRequest: () => TaggedRequest,
  TaggedStruct: () => TaggedStruct,
  TemplateLiteral: () => TemplateLiteral2,
  TemplateLiteralParser: () => TemplateLiteralParser,
  TimeZone: () => TimeZone,
  TimeZoneFromSelf: () => TimeZoneFromSelf,
  TimeZoneNamed: () => TimeZoneNamed,
  TimeZoneNamedFromSelf: () => TimeZoneNamedFromSelf,
  TimeZoneOffset: () => TimeZoneOffset,
  TimeZoneOffsetFromSelf: () => TimeZoneOffsetFromSelf,
  ToPropertySignature: () => ToPropertySignature,
  Trim: () => Trim,
  Trimmed: () => Trimmed,
  TrimmedSchemaId: () => TrimmedSchemaId,
  Tuple: () => Tuple,
  TypeId: () => TypeId21,
  ULID: () => ULID,
  ULIDSchemaId: () => ULIDSchemaId,
  URL: () => URL$,
  URLFromSelf: () => URLFromSelf,
  UUID: () => UUID,
  UUIDSchemaId: () => UUIDSchemaId,
  Uint8: () => Uint8,
  Uint8Array: () => Uint8Array$,
  Uint8ArrayFromBase64: () => Uint8ArrayFromBase64,
  Uint8ArrayFromBase64Url: () => Uint8ArrayFromBase64Url,
  Uint8ArrayFromHex: () => Uint8ArrayFromHex,
  Uint8ArrayFromSelf: () => Uint8ArrayFromSelf,
  Uncapitalize: () => Uncapitalize,
  Uncapitalized: () => Uncapitalized,
  UncapitalizedSchemaId: () => UncapitalizedSchemaId,
  Undefined: () => Undefined,
  UndefinedOr: () => UndefinedOr,
  Union: () => Union2,
  UniqueSymbolFromSelf: () => UniqueSymbolFromSelf,
  Unknown: () => Unknown,
  Uppercase: () => Uppercase,
  Uppercased: () => Uppercased,
  UppercasedSchemaId: () => UppercasedSchemaId,
  ValidDateFromSelf: () => ValidDateFromSelf,
  ValidDateSchemaId: () => ValidDateSchemaId,
  Void: () => Void,
  annotations: () => annotations2,
  asSchema: () => asSchema,
  asSerializable: () => asSerializable,
  asSerializableWithResult: () => asSerializableWithResult,
  asWithResult: () => asWithResult,
  asserts: () => asserts,
  attachPropertySignature: () => attachPropertySignature,
  between: () => between5,
  betweenBigDecimal: () => betweenBigDecimal,
  betweenBigInt: () => betweenBigInt,
  betweenDate: () => betweenDate,
  betweenDuration: () => betweenDuration,
  brand: () => brand,
  capitalized: () => capitalized,
  clamp: () => clamp8,
  clampBigDecimal: () => clampBigDecimal,
  clampBigInt: () => clampBigInt,
  clampDuration: () => clampDuration,
  compose: () => compose4,
  declare: () => declare,
  decode: () => decode5,
  decodeEither: () => decodeEither,
  decodeOption: () => decodeOption,
  decodePromise: () => decodePromise,
  decodeSync: () => decodeSync,
  decodeUnknown: () => decodeUnknown3,
  decodeUnknownEither: () => decodeUnknownEither2,
  decodeUnknownOption: () => decodeUnknownOption,
  decodeUnknownPromise: () => decodeUnknownPromise,
  decodeUnknownSync: () => decodeUnknownSync,
  deserialize: () => deserialize,
  deserializeExit: () => deserializeExit,
  deserializeFailure: () => deserializeFailure,
  deserializeSuccess: () => deserializeSuccess,
  element: () => element,
  encode: () => encode4,
  encodeEither: () => encodeEither,
  encodeOption: () => encodeOption,
  encodePromise: () => encodePromise,
  encodeSync: () => encodeSync,
  encodeUnknown: () => encodeUnknown2,
  encodeUnknownEither: () => encodeUnknownEither2,
  encodeUnknownOption: () => encodeUnknownOption,
  encodeUnknownPromise: () => encodeUnknownPromise,
  encodeUnknownSync: () => encodeUnknownSync,
  encodedBoundSchema: () => encodedBoundSchema,
  encodedSchema: () => encodedSchema,
  endsWith: () => endsWith,
  equivalence: () => equivalence2,
  exitSchema: () => exitSchema,
  extend: () => extend3,
  failureSchema: () => failureSchema,
  filter: () => filter12,
  filterEffect: () => filterEffect3,
  finite: () => finite,
  format: () => format6,
  fromBrand: () => fromBrand,
  fromKey: () => fromKey,
  getClassTag: () => getClassTag,
  getNumberIndexedAccess: () => getNumberIndexedAccess2,
  greaterThan: () => greaterThan6,
  greaterThanBigDecimal: () => greaterThanBigDecimal,
  greaterThanBigInt: () => greaterThanBigInt,
  greaterThanDate: () => greaterThanDate,
  greaterThanDuration: () => greaterThanDuration,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo5,
  greaterThanOrEqualToBigDecimal: () => greaterThanOrEqualToBigDecimal,
  greaterThanOrEqualToBigInt: () => greaterThanOrEqualToBigInt,
  greaterThanOrEqualToDate: () => greaterThanOrEqualToDate,
  greaterThanOrEqualToDuration: () => greaterThanOrEqualToDuration,
  head: () => head6,
  headNonEmpty: () => headNonEmpty3,
  headOrElse: () => headOrElse,
  includes: () => includes,
  instanceOf: () => instanceOf,
  int: () => int,
  is: () => is,
  isPropertySignature: () => isPropertySignature,
  isSchema: () => isSchema,
  itemsCount: () => itemsCount,
  keyof: () => keyof2,
  length: () => length3,
  lessThan: () => lessThan9,
  lessThanBigDecimal: () => lessThanBigDecimal,
  lessThanBigInt: () => lessThanBigInt,
  lessThanDate: () => lessThanDate,
  lessThanDuration: () => lessThanDuration,
  lessThanOrEqualTo: () => lessThanOrEqualTo5,
  lessThanOrEqualToBigDecimal: () => lessThanOrEqualToBigDecimal,
  lessThanOrEqualToBigInt: () => lessThanOrEqualToBigInt,
  lessThanOrEqualToDate: () => lessThanOrEqualToDate,
  lessThanOrEqualToDuration: () => lessThanOrEqualToDuration,
  lowercased: () => lowercased,
  make: () => make60,
  makePropertySignature: () => makePropertySignature,
  maxItems: () => maxItems,
  maxLength: () => maxLength,
  minItems: () => minItems,
  minLength: () => minLength,
  multipleOf: () => multipleOf,
  mutable: () => mutable2,
  negative: () => negative,
  negativeBigDecimal: () => negativeBigDecimal,
  negativeBigInt: () => negativeBigInt,
  nonEmptyString: () => nonEmptyString2,
  nonNaN: () => nonNaN,
  nonNegative: () => nonNegative,
  nonNegativeBigDecimal: () => nonNegativeBigDecimal,
  nonNegativeBigInt: () => nonNegativeBigInt,
  nonPositive: () => nonPositive,
  nonPositiveBigDecimal: () => nonPositiveBigDecimal,
  nonPositiveBigInt: () => nonPositiveBigInt,
  omit: () => omit5,
  optional: () => optional,
  optionalElement: () => optionalElement,
  optionalToOptional: () => optionalToOptional,
  optionalToRequired: () => optionalToRequired,
  optionalWith: () => optionalWith,
  parseJson: () => parseJson,
  parseNumber: () => parseNumber,
  partial: () => partial2,
  partialWith: () => partialWith,
  pattern: () => pattern,
  pick: () => pick5,
  pickLiteral: () => pickLiteral,
  pluck: () => pluck,
  positive: () => positive,
  positiveBigDecimal: () => positiveBigDecimal,
  positiveBigInt: () => positiveBigInt,
  propertySignature: () => propertySignature,
  rename: () => rename2,
  required: () => required2,
  requiredToOptional: () => requiredToOptional,
  serializableSchema: () => serializableSchema,
  serialize: () => serialize,
  serializeExit: () => serializeExit,
  serializeFailure: () => serializeFailure,
  serializeSuccess: () => serializeSuccess,
  split: () => split5,
  standardSchemaV1: () => standardSchemaV1,
  startsWith: () => startsWith,
  successSchema: () => successSchema,
  suspend: () => suspend13,
  symbolSerializable: () => symbolSerializable,
  symbolWithResult: () => symbolWithResult,
  tag: () => tag,
  transform: () => transform2,
  transformLiteral: () => transformLiteral,
  transformLiterals: () => transformLiterals,
  transformOrFail: () => transformOrFail,
  trimmed: () => trimmed,
  typeSchema: () => typeSchema,
  uncapitalized: () => uncapitalized,
  uppercased: () => uppercased,
  validDate: () => validDate,
  validate: () => validate5,
  validateEither: () => validateEither2,
  validateOption: () => validateOption,
  validatePromise: () => validatePromise,
  validateSync: () => validateSync,
  withConstructorDefault: () => withConstructorDefault,
  withDecodingDefault: () => withDecodingDefault,
  withDefaults: () => withDefaults
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/BigDecimal.js
var FINITE_INT_REGEX = /^[+-]?\d+$/;
var TypeId20 = /* @__PURE__ */ Symbol.for("effect/BigDecimal");
var BigDecimalProto = {
  [TypeId20]: TypeId20,
  [symbol]() {
    const normalized = normalize(this);
    return pipe(hash(normalized.value), combine(number(normalized.scale)), cached(this));
  },
  [symbol2](that) {
    return isBigDecimal(that) && equals4(this, that);
  },
  toString() {
    return `BigDecimal(${format4(this)})`;
  },
  toJSON() {
    return {
      _id: "BigDecimal",
      value: String(this.value),
      scale: this.scale
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isBigDecimal = (u) => hasProperty(u, TypeId20);
var make56 = (value3, scale2) => {
  const o = Object.create(BigDecimalProto);
  o.value = value3;
  o.scale = scale2;
  return o;
};
var unsafeMakeNormalized = (value3, scale2) => {
  if (value3 !== bigint04 && value3 % bigint10 === bigint04) {
    throw new RangeError("Value must be normalized");
  }
  const o = make56(value3, scale2);
  o.normalized = o;
  return o;
};
var bigint04 = /* @__PURE__ */ BigInt(0);
var bigint10 = /* @__PURE__ */ BigInt(10);
var zero2 = /* @__PURE__ */ unsafeMakeNormalized(bigint04, 0);
var normalize = (self) => {
  if (self.normalized === void 0) {
    if (self.value === bigint04) {
      self.normalized = zero2;
    } else {
      const digits = `${self.value}`;
      let trail = 0;
      for (let i = digits.length - 1; i >= 0; i--) {
        if (digits[i] === "0") {
          trail++;
        } else {
          break;
        }
      }
      if (trail === 0) {
        self.normalized = self;
      }
      const value3 = BigInt(digits.substring(0, digits.length - trail));
      const scale2 = self.scale - trail;
      self.normalized = unsafeMakeNormalized(value3, scale2);
    }
  }
  return self.normalized;
};
var scale = /* @__PURE__ */ dual(2, (self, scale2) => {
  if (scale2 > self.scale) {
    return make56(self.value * bigint10 ** BigInt(scale2 - self.scale), scale2);
  }
  if (scale2 < self.scale) {
    return make56(self.value / bigint10 ** BigInt(self.scale - scale2), scale2);
  }
  return self;
});
var Order6 = /* @__PURE__ */ make4((self, that) => {
  const scmp = number3(sign(self), sign(that));
  if (scmp !== 0) {
    return scmp;
  }
  if (self.scale > that.scale) {
    return bigint(self.value, scale(that, self.scale).value);
  }
  if (self.scale < that.scale) {
    return bigint(scale(self, that.scale).value, that.value);
  }
  return bigint(self.value, that.value);
});
var lessThan7 = /* @__PURE__ */ lessThan(Order6);
var lessThanOrEqualTo3 = /* @__PURE__ */ lessThanOrEqualTo(Order6);
var greaterThan4 = /* @__PURE__ */ greaterThan(Order6);
var greaterThanOrEqualTo3 = /* @__PURE__ */ greaterThanOrEqualTo(Order6);
var between3 = /* @__PURE__ */ between(Order6);
var clamp5 = /* @__PURE__ */ clamp(Order6);
var sign = (n) => n.value === bigint04 ? 0 : n.value < bigint04 ? -1 : 1;
var abs = (n) => n.value < bigint04 ? make56(-n.value, n.scale) : n;
var Equivalence4 = /* @__PURE__ */ make3((self, that) => {
  if (self.scale > that.scale) {
    return scale(that, self.scale).value === self.value;
  }
  if (self.scale < that.scale) {
    return scale(self, that.scale).value === that.value;
  }
  return self.value === that.value;
});
var equals4 = /* @__PURE__ */ dual(2, (self, that) => Equivalence4(self, that));
var unsafeFromNumber = (n) => getOrThrowWith2(safeFromNumber(n), () => new RangeError(`Number must be finite, got ${n}`));
var fromNumber = unsafeFromNumber;
var safeFromNumber = (n) => {
  if (!Number.isFinite(n)) {
    return none2();
  }
  const string7 = `${n}`;
  if (string7.includes("e")) {
    return fromString(string7);
  }
  const [lead, trail = ""] = string7.split(".");
  return some2(make56(BigInt(`${lead}${trail}`), trail.length));
};
var fromString = (s) => {
  if (s === "") {
    return some2(zero2);
  }
  let base;
  let exp;
  const seperator = s.search(/[eE]/);
  if (seperator !== -1) {
    const trail = s.slice(seperator + 1);
    base = s.slice(0, seperator);
    exp = Number(trail);
    if (base === "" || !Number.isSafeInteger(exp) || !FINITE_INT_REGEX.test(trail)) {
      return none2();
    }
  } else {
    base = s;
    exp = 0;
  }
  let digits;
  let offset;
  const dot = base.search(/\./);
  if (dot !== -1) {
    const lead = base.slice(0, dot);
    const trail = base.slice(dot + 1);
    digits = `${lead}${trail}`;
    offset = trail.length;
  } else {
    digits = base;
    offset = 0;
  }
  if (!FINITE_INT_REGEX.test(digits)) {
    return none2();
  }
  const scale2 = offset - exp;
  if (!Number.isSafeInteger(scale2)) {
    return none2();
  }
  return some2(make56(BigInt(digits), scale2));
};
var format4 = (n) => {
  const normalized = normalize(n);
  if (Math.abs(normalized.scale) >= 16) {
    return toExponential(normalized);
  }
  const negative3 = normalized.value < bigint04;
  const absolute = negative3 ? `${normalized.value}`.substring(1) : `${normalized.value}`;
  let before2;
  let after3;
  if (normalized.scale >= absolute.length) {
    before2 = "0";
    after3 = "0".repeat(normalized.scale - absolute.length) + absolute;
  } else {
    const location = absolute.length - normalized.scale;
    if (location > absolute.length) {
      const zeros = location - absolute.length;
      before2 = `${absolute}${"0".repeat(zeros)}`;
      after3 = "";
    } else {
      after3 = absolute.slice(location);
      before2 = absolute.slice(0, location);
    }
  }
  const complete3 = after3 === "" ? before2 : `${before2}.${after3}`;
  return negative3 ? `-${complete3}` : complete3;
};
var toExponential = (n) => {
  if (isZero2(n)) {
    return "0e+0";
  }
  const normalized = normalize(n);
  const digits = `${abs(normalized).value}`;
  const head8 = digits.slice(0, 1);
  const tail2 = digits.slice(1);
  let output3 = `${isNegative(normalized) ? "-" : ""}${head8}`;
  if (tail2 !== "") {
    output3 += `.${tail2}`;
  }
  const exp = tail2.length - normalized.scale;
  return `${output3}e${exp >= 0 ? "+" : ""}${exp}`;
};
var unsafeToNumber = (n) => Number(format4(n));
var isZero2 = (n) => n.value === bigint04;
var isNegative = (n) => n.value < bigint04;
var isPositive = (n) => n.value > bigint04;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/BigInt.js
var Order7 = bigint;
var clamp6 = /* @__PURE__ */ clamp(Order7);
var toNumber = (b) => {
  if (b > BigInt(Number.MAX_SAFE_INTEGER) || b < BigInt(Number.MIN_SAFE_INTEGER)) {
    return none2();
  }
  return some2(Number(b));
};
var fromString2 = (s) => {
  try {
    return s.trim() === "" ? none2() : some2(BigInt(s));
  } catch {
    return none2();
  }
};
var fromNumber2 = (n) => {
  if (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER) {
    return none2();
  }
  try {
    return some2(BigInt(n));
  } catch {
    return none2();
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/ConfigError.js
var InvalidData2 = InvalidData;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/redacted.js
var RedactedSymbolKey = "effect/Redacted";
var redactedRegistry = /* @__PURE__ */ globalValue("effect/Redacted/redactedRegistry", () => /* @__PURE__ */ new WeakMap());
var RedactedTypeId = /* @__PURE__ */ Symbol.for(RedactedSymbolKey);
var proto12 = {
  [RedactedTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return "<redacted>";
  },
  toJSON() {
    return "<redacted>";
  },
  [NodeInspectSymbol]() {
    return "<redacted>";
  },
  [symbol]() {
    return pipe(hash(RedactedSymbolKey), combine(hash(redactedRegistry.get(this))), cached(this));
  },
  [symbol2](that) {
    return isRedacted(that) && equals(redactedRegistry.get(this), redactedRegistry.get(that));
  }
};
var isRedacted = (u) => hasProperty(u, RedactedTypeId);
var make57 = (value3) => {
  const redacted2 = Object.create(proto12);
  redactedRegistry.set(redacted2, value3);
  return redacted2;
};
var value = (self) => {
  if (redactedRegistry.has(self)) {
    return redactedRegistry.get(self);
  } else {
    throw new Error("Unable to get redacted value");
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/config.js
var ConfigSymbolKey = "effect/Config";
var ConfigTypeId = /* @__PURE__ */ Symbol.for(ConfigSymbolKey);
var configVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto13 = {
  ...CommitPrototype,
  [ConfigTypeId]: configVariance,
  commit() {
    return config(this);
  }
};
var mapOrFail = /* @__PURE__ */ dual(2, (self, f) => {
  const mapOrFail3 = Object.create(proto13);
  mapOrFail3._tag = OP_MAP_OR_FAIL;
  mapOrFail3.original = self;
  mapOrFail3.mapOrFail = f;
  return mapOrFail3;
});
var nested2 = /* @__PURE__ */ dual(2, (self, name) => {
  const nested3 = Object.create(proto13);
  nested3._tag = OP_NESTED;
  nested3.name = name;
  nested3.config = self;
  return nested3;
});
var primitive = (description, parse3) => {
  const primitive2 = Object.create(proto13);
  primitive2._tag = OP_PRIMITIVE;
  primitive2.description = description;
  primitive2.parse = parse3;
  return primitive2;
};
var string2 = (name) => {
  const config2 = primitive("a text property", right2);
  return name === void 0 ? config2 : nested2(config2, name);
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Config.js
var mapOrFail2 = mapOrFail;
var string3 = string2;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/DateTime.js
var isDateTime2 = isDateTime;
var isTimeZoneOffset2 = isTimeZoneOffset;
var isTimeZoneNamed2 = isTimeZoneNamed;
var isUtc2 = isUtc;
var isZoned2 = isZoned;
var Equivalence5 = Equivalence2;
var unsafeFromDate2 = unsafeFromDate;
var unsafeMake12 = unsafeMake10;
var unsafeMakeZoned2 = unsafeMakeZoned;
var makeZonedFromString2 = makeZonedFromString;
var zoneUnsafeMakeNamed2 = zoneUnsafeMakeNamed;
var zoneMakeOffset2 = zoneMakeOffset;
var zoneFromString2 = zoneFromString;
var zoneToString2 = zoneToString;
var toDateUtc2 = toDateUtc;
var toEpochMillis2 = toEpochMillis;
var formatIso3 = formatIso2;
var formatIsoZoned2 = formatIsoZoned;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/encoding/common.js
var DecodeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Encoding/errors/Decode");
var DecodeException = (input, message) => {
  const out = {
    _tag: "DecodeException",
    [DecodeExceptionTypeId]: DecodeExceptionTypeId,
    input
  };
  if (isString(message)) {
    out.message = message;
  }
  return out;
};
var EncodeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Encoding/errors/Encode");
var EncodeException = (input, message) => {
  const out = {
    _tag: "EncodeException",
    [EncodeExceptionTypeId]: EncodeExceptionTypeId,
    input
  };
  if (isString(message)) {
    out.message = message;
  }
  return out;
};
var encoder = /* @__PURE__ */ new TextEncoder();
var decoder = /* @__PURE__ */ new TextDecoder();

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/encoding/base64.js
var encode = (bytes3) => {
  const length5 = bytes3.length;
  let result = "";
  let i;
  for (i = 2; i < length5; i += 3) {
    result += base64abc[bytes3[i - 2] >> 2];
    result += base64abc[(bytes3[i - 2] & 3) << 4 | bytes3[i - 1] >> 4];
    result += base64abc[(bytes3[i - 1] & 15) << 2 | bytes3[i] >> 6];
    result += base64abc[bytes3[i] & 63];
  }
  if (i === length5 + 1) {
    result += base64abc[bytes3[i - 2] >> 2];
    result += base64abc[(bytes3[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === length5) {
    result += base64abc[bytes3[i - 2] >> 2];
    result += base64abc[(bytes3[i - 2] & 3) << 4 | bytes3[i - 1] >> 4];
    result += base64abc[(bytes3[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
};
var decode2 = (str) => {
  const stripped = stripCrlf(str);
  const length5 = stripped.length;
  if (length5 % 4 !== 0) {
    return left2(DecodeException(stripped, `Length must be a multiple of 4, but is ${length5}`));
  }
  const index = stripped.indexOf("=");
  if (index !== -1 && (index < length5 - 2 || index === length5 - 2 && stripped[length5 - 1] !== "=")) {
    return left2(DecodeException(stripped, "Found a '=' character, but it is not at the end"));
  }
  try {
    const missingOctets = stripped.endsWith("==") ? 2 : stripped.endsWith("=") ? 1 : 0;
    const result = new Uint8Array(3 * (length5 / 4) - missingOctets);
    for (let i = 0, j = 0; i < length5; i += 4, j += 3) {
      const buffer3 = getBase64Code(stripped.charCodeAt(i)) << 18 | getBase64Code(stripped.charCodeAt(i + 1)) << 12 | getBase64Code(stripped.charCodeAt(i + 2)) << 6 | getBase64Code(stripped.charCodeAt(i + 3));
      result[j] = buffer3 >> 16;
      result[j + 1] = buffer3 >> 8 & 255;
      result[j + 2] = buffer3 & 255;
    }
    return right2(result);
  } catch (e) {
    return left2(DecodeException(stripped, e instanceof Error ? e.message : "Invalid input"));
  }
};
var stripCrlf = (str) => str.replace(/[\n\r]/g, "");
function getBase64Code(charCode) {
  if (charCode >= base64codes.length) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  const code = base64codes[charCode];
  if (code === 255) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  return code;
}
var base64abc = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];
var base64codes = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/encoding/base64Url.js
var encode2 = (data) => encode(data).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
var decode3 = (str) => {
  const stripped = stripCrlf(str);
  const length5 = stripped.length;
  if (length5 % 4 === 1) {
    return left2(DecodeException(stripped, `Length should be a multiple of 4, but is ${length5}`));
  }
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(stripped)) {
    return left2(DecodeException(stripped, "Invalid input"));
  }
  let sanitized = length5 % 4 === 2 ? `${stripped}==` : length5 % 4 === 3 ? `${stripped}=` : stripped;
  sanitized = sanitized.replace(/-/g, "+").replace(/_/g, "/");
  return decode2(sanitized);
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/encoding/hex.js
var encode3 = (bytes3) => {
  let result = "";
  for (let i = 0; i < bytes3.length; ++i) {
    result += bytesToHex[bytes3[i]];
  }
  return result;
};
var decode4 = (str) => {
  const bytes3 = new TextEncoder().encode(str);
  if (bytes3.length % 2 !== 0) {
    return left2(DecodeException(str, `Length must be a multiple of 2, but is ${bytes3.length}`));
  }
  try {
    const length5 = bytes3.length / 2;
    const result = new Uint8Array(length5);
    for (let i = 0; i < length5; i++) {
      const a = fromHexChar(bytes3[i * 2]);
      const b = fromHexChar(bytes3[i * 2 + 1]);
      result[i] = a << 4 | b;
    }
    return right2(result);
  } catch (e) {
    return left2(DecodeException(str, e instanceof Error ? e.message : "Invalid input"));
  }
};
var bytesToHex = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var fromHexChar = (byte) => {
  if (48 <= byte && byte <= 57) {
    return byte - 48;
  }
  if (97 <= byte && byte <= 102) {
    return byte - 97 + 10;
  }
  if (65 <= byte && byte <= 70) {
    return byte - 65 + 10;
  }
  throw new TypeError("Invalid input");
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Encoding.js
var encodeBase64 = (input) => typeof input === "string" ? encode(encoder.encode(input)) : encode(input);
var decodeBase64 = (str) => decode2(str);
var decodeBase64String = (str) => map(decodeBase64(str), (_) => decoder.decode(_));
var encodeBase64Url = (input) => typeof input === "string" ? encode2(encoder.encode(input)) : encode2(input);
var decodeBase64Url = (str) => decode3(str);
var decodeBase64UrlString = (str) => map(decodeBase64Url(str), (_) => decoder.decode(_));
var encodeHex = (input) => typeof input === "string" ? encode3(encoder.encode(input)) : encode3(input);
var decodeHex = (str) => decode4(str);
var decodeHexString = (str) => map(decodeHex(str), (_) => decoder.decode(_));
var encodeUriComponent = (str) => try_({
  try: () => encodeURIComponent(str),
  catch: (e) => EncodeException2(str, e instanceof Error ? e.message : "Invalid input")
});
var decodeUriComponent = (str) => try_({
  try: () => decodeURIComponent(str),
  catch: (e) => DecodeException2(str, e instanceof Error ? e.message : "Invalid input")
});
var DecodeException2 = DecodeException;
var EncodeException2 = EncodeException;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/precondition/PreconditionFailure.js
var PreconditionFailure = class _PreconditionFailure extends Error {
  constructor(interruptExecution = false) {
    super();
    this.interruptExecution = interruptExecution;
    this.footprint = _PreconditionFailure.SharedFootPrint;
  }
  static isFailure(err) {
    return err != null && err.footprint === _PreconditionFailure.SharedFootPrint;
  }
};
PreconditionFailure.SharedFootPrint = Symbol.for("fast-check/PreconditionFailure");

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/StreamHelpers.js
var Nil = class {
  [Symbol.iterator]() {
    return this;
  }
  next(value3) {
    return { value: value3, done: true };
  }
};
Nil.nil = new Nil();
function nilHelper() {
  return Nil.nil;
}
function* mapHelper(g, f) {
  for (const v of g) {
    yield f(v);
  }
}
function* flatMapHelper(g, f) {
  for (const v of g) {
    yield* f(v);
  }
}
function* filterHelper(g, f) {
  for (const v of g) {
    if (f(v)) {
      yield v;
    }
  }
}
function* takeNHelper(g, n) {
  for (let i = 0; i < n; ++i) {
    const cur = g.next();
    if (cur.done) {
      break;
    }
    yield cur.value;
  }
}
function* takeWhileHelper(g, f) {
  let cur = g.next();
  while (!cur.done && f(cur.value)) {
    yield cur.value;
    cur = g.next();
  }
}
function* joinHelper(g, others) {
  for (let cur = g.next(); !cur.done; cur = g.next()) {
    yield cur.value;
  }
  for (const s of others) {
    for (let cur = s.next(); !cur.done; cur = s.next()) {
      yield cur.value;
    }
  }
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/Stream.js
var safeSymbolIterator = Symbol.iterator;
var Stream = class _Stream {
  static nil() {
    return new _Stream(nilHelper());
  }
  static of(...elements) {
    return new _Stream(elements[safeSymbolIterator]());
  }
  constructor(g) {
    this.g = g;
  }
  next() {
    return this.g.next();
  }
  [Symbol.iterator]() {
    return this.g;
  }
  map(f) {
    return new _Stream(mapHelper(this.g, f));
  }
  flatMap(f) {
    return new _Stream(flatMapHelper(this.g, f));
  }
  dropWhile(f) {
    let foundEligible = false;
    function* helper(v) {
      if (foundEligible || !f(v)) {
        foundEligible = true;
        yield v;
      }
    }
    return this.flatMap(helper);
  }
  drop(n) {
    if (n <= 0) {
      return this;
    }
    let idx = 0;
    function helper() {
      return idx++ < n;
    }
    return this.dropWhile(helper);
  }
  takeWhile(f) {
    return new _Stream(takeWhileHelper(this.g, f));
  }
  take(n) {
    return new _Stream(takeNHelper(this.g, n));
  }
  filter(f) {
    return new _Stream(filterHelper(this.g, f));
  }
  every(f) {
    for (const v of this.g) {
      if (!f(v)) {
        return false;
      }
    }
    return true;
  }
  has(f) {
    for (const v of this.g) {
      if (f(v)) {
        return [true, v];
      }
    }
    return [false, null];
  }
  join(...others) {
    return new _Stream(joinHelper(this.g, others));
  }
  getNthOrLast(nth) {
    let remaining = nth;
    let last5 = null;
    for (const v of this.g) {
      if (remaining-- === 0)
        return v;
      last5 = v;
    }
    return last5;
  }
};
function stream(g) {
  return new Stream(g);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/symbols.js
var cloneMethod = Symbol.for("fast-check/cloneMethod");
function hasCloneMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && cloneMethod in instance && typeof instance[cloneMethod] === "function";
}
function cloneIfNeeded(instance) {
  return hasCloneMethod(instance) ? instance[cloneMethod]() : instance;
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/arbitrary/definition/Value.js
var safeObjectDefineProperty = Object.defineProperty;
var Value = class {
  constructor(value_, context9, customGetValue = void 0) {
    this.value_ = value_;
    this.context = context9;
    this.hasToBeCloned = customGetValue !== void 0 || hasCloneMethod(value_);
    this.readOnce = false;
    if (this.hasToBeCloned) {
      safeObjectDefineProperty(this, "value", { get: customGetValue !== void 0 ? customGetValue : this.getValue });
    } else {
      this.value = value_;
    }
  }
  getValue() {
    if (this.hasToBeCloned) {
      if (!this.readOnce) {
        this.readOnce = true;
        return this.value_;
      }
      return this.value_[cloneMethod]();
    }
    return this.value_;
  }
};

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/arbitrary/definition/Arbitrary.js
var safeObjectAssign = Object.assign;
var Arbitrary = class {
  filter(refinement) {
    return new FilterArbitrary(this, refinement);
  }
  map(mapper, unmapper) {
    return new MapArbitrary(this, mapper, unmapper);
  }
  chain(chainer) {
    return new ChainArbitrary(this, chainer);
  }
  noShrink() {
    return new NoShrinkArbitrary(this);
  }
  noBias() {
    return new NoBiasArbitrary(this);
  }
};
var ChainArbitrary = class extends Arbitrary {
  constructor(arb, chainer) {
    super();
    this.arb = arb;
    this.chainer = chainer;
  }
  generate(mrng, biasFactor) {
    const clonedMrng = mrng.clone();
    const src = this.arb.generate(mrng, biasFactor);
    return this.valueChainer(src, mrng, clonedMrng, biasFactor);
  }
  canShrinkWithoutContext(value3) {
    return false;
  }
  shrink(value3, context9) {
    if (this.isSafeContext(context9)) {
      return (!context9.stoppedForOriginal ? this.arb.shrink(context9.originalValue, context9.originalContext).map((v) => this.valueChainer(v, context9.clonedMrng.clone(), context9.clonedMrng, context9.originalBias)) : Stream.nil()).join(context9.chainedArbitrary.shrink(value3, context9.chainedContext).map((dst) => {
        const newContext = safeObjectAssign(safeObjectAssign({}, context9), {
          chainedContext: dst.context,
          stoppedForOriginal: true
        });
        return new Value(dst.value_, newContext);
      }));
    }
    return Stream.nil();
  }
  valueChainer(v, generateMrng, clonedMrng, biasFactor) {
    const chainedArbitrary = this.chainer(v.value_);
    const dst = chainedArbitrary.generate(generateMrng, biasFactor);
    const context9 = {
      originalBias: biasFactor,
      originalValue: v.value_,
      originalContext: v.context,
      stoppedForOriginal: false,
      chainedArbitrary,
      chainedContext: dst.context,
      clonedMrng
    };
    return new Value(dst.value_, context9);
  }
  isSafeContext(context9) {
    return context9 != null && typeof context9 === "object" && "originalBias" in context9 && "originalValue" in context9 && "originalContext" in context9 && "stoppedForOriginal" in context9 && "chainedArbitrary" in context9 && "chainedContext" in context9 && "clonedMrng" in context9;
  }
};
var MapArbitrary = class extends Arbitrary {
  constructor(arb, mapper, unmapper) {
    super();
    this.arb = arb;
    this.mapper = mapper;
    this.unmapper = unmapper;
    this.bindValueMapper = (v) => this.valueMapper(v);
  }
  generate(mrng, biasFactor) {
    const g = this.arb.generate(mrng, biasFactor);
    return this.valueMapper(g);
  }
  canShrinkWithoutContext(value3) {
    if (this.unmapper !== void 0) {
      try {
        const unmapped = this.unmapper(value3);
        return this.arb.canShrinkWithoutContext(unmapped);
      } catch (_err) {
        return false;
      }
    }
    return false;
  }
  shrink(value3, context9) {
    if (this.isSafeContext(context9)) {
      return this.arb.shrink(context9.originalValue, context9.originalContext).map(this.bindValueMapper);
    }
    if (this.unmapper !== void 0) {
      const unmapped = this.unmapper(value3);
      return this.arb.shrink(unmapped, void 0).map(this.bindValueMapper);
    }
    return Stream.nil();
  }
  mapperWithCloneIfNeeded(v) {
    const sourceValue = v.value;
    const mappedValue = this.mapper(sourceValue);
    if (v.hasToBeCloned && (typeof mappedValue === "object" && mappedValue !== null || typeof mappedValue === "function") && Object.isExtensible(mappedValue) && !hasCloneMethod(mappedValue)) {
      Object.defineProperty(mappedValue, cloneMethod, { get: () => () => this.mapperWithCloneIfNeeded(v)[0] });
    }
    return [mappedValue, sourceValue];
  }
  valueMapper(v) {
    const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v);
    const context9 = { originalValue: sourceValue, originalContext: v.context };
    return new Value(mappedValue, context9);
  }
  isSafeContext(context9) {
    return context9 != null && typeof context9 === "object" && "originalValue" in context9 && "originalContext" in context9;
  }
};
var FilterArbitrary = class extends Arbitrary {
  constructor(arb, refinement) {
    super();
    this.arb = arb;
    this.refinement = refinement;
    this.bindRefinementOnValue = (v) => this.refinementOnValue(v);
  }
  generate(mrng, biasFactor) {
    while (true) {
      const g = this.arb.generate(mrng, biasFactor);
      if (this.refinementOnValue(g)) {
        return g;
      }
    }
  }
  canShrinkWithoutContext(value3) {
    return this.arb.canShrinkWithoutContext(value3) && this.refinement(value3);
  }
  shrink(value3, context9) {
    return this.arb.shrink(value3, context9).filter(this.bindRefinementOnValue);
  }
  refinementOnValue(v) {
    return this.refinement(v.value);
  }
};
var NoShrinkArbitrary = class extends Arbitrary {
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, biasFactor) {
    return this.arb.generate(mrng, biasFactor);
  }
  canShrinkWithoutContext(value3) {
    return this.arb.canShrinkWithoutContext(value3);
  }
  shrink(_value2, _context) {
    return Stream.nil();
  }
  noShrink() {
    return this;
  }
};
var NoBiasArbitrary = class extends Arbitrary {
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, _biasFactor) {
    return this.arb.generate(mrng, void 0);
  }
  canShrinkWithoutContext(value3) {
    return this.arb.canShrinkWithoutContext(value3);
  }
  shrink(value3, context9) {
    return this.arb.shrink(value3, context9);
  }
  noBias() {
    return this;
  }
};

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/apply.js
var untouchedApply = Function.prototype.apply;
var ApplySymbol = Symbol("apply");
function safeExtractApply(f) {
  try {
    return f.apply;
  } catch (err) {
    return void 0;
  }
}
function safeApplyHacky(f, instance, args2) {
  const ff = f;
  ff[ApplySymbol] = untouchedApply;
  const out = ff[ApplySymbol](instance, args2);
  delete ff[ApplySymbol];
  return out;
}
function safeApply(f, instance, args2) {
  if (safeExtractApply(f) === untouchedApply) {
    return f.apply(instance, args2);
  }
  return safeApplyHacky(f, instance, args2);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/globals.js
var SArray = typeof Array !== "undefined" ? Array : void 0;
var SError = typeof Error !== "undefined" ? Error : void 0;
var SString = typeof String !== "undefined" ? String : void 0;
var SencodeURIComponent = typeof encodeURIComponent !== "undefined" ? encodeURIComponent : void 0;
var SSymbol = Symbol;
var untouchedForEach = Array.prototype.forEach;
var untouchedIndexOf = Array.prototype.indexOf;
var untouchedJoin = Array.prototype.join;
var untouchedMap = Array.prototype.map;
var untouchedFilter = Array.prototype.filter;
var untouchedPush = Array.prototype.push;
var untouchedPop = Array.prototype.pop;
var untouchedSplice = Array.prototype.splice;
var untouchedSlice = Array.prototype.slice;
var untouchedSort = Array.prototype.sort;
var untouchedEvery = Array.prototype.every;
function extractIndexOf(instance) {
  try {
    return instance.indexOf;
  } catch (err) {
    return void 0;
  }
}
function extractJoin(instance) {
  try {
    return instance.join;
  } catch (err) {
    return void 0;
  }
}
function extractMap(instance) {
  try {
    return instance.map;
  } catch (err) {
    return void 0;
  }
}
function extractFilter(instance) {
  try {
    return instance.filter;
  } catch (err) {
    return void 0;
  }
}
function extractPush(instance) {
  try {
    return instance.push;
  } catch (err) {
    return void 0;
  }
}
function extractSlice(instance) {
  try {
    return instance.slice;
  } catch (err) {
    return void 0;
  }
}
function safeIndexOf(instance, ...args2) {
  if (extractIndexOf(instance) === untouchedIndexOf) {
    return instance.indexOf(...args2);
  }
  return safeApply(untouchedIndexOf, instance, args2);
}
function safeJoin(instance, ...args2) {
  if (extractJoin(instance) === untouchedJoin) {
    return instance.join(...args2);
  }
  return safeApply(untouchedJoin, instance, args2);
}
function safeMap(instance, fn2) {
  if (extractMap(instance) === untouchedMap) {
    return instance.map(fn2);
  }
  return safeApply(untouchedMap, instance, [fn2]);
}
function safeFilter(instance, predicate) {
  if (extractFilter(instance) === untouchedFilter) {
    return instance.filter(predicate);
  }
  return safeApply(untouchedFilter, instance, [predicate]);
}
function safePush(instance, ...args2) {
  if (extractPush(instance) === untouchedPush) {
    return instance.push(...args2);
  }
  return safeApply(untouchedPush, instance, args2);
}
function safeSlice(instance, ...args2) {
  if (extractSlice(instance) === untouchedSlice) {
    return instance.slice(...args2);
  }
  return safeApply(untouchedSlice, instance, args2);
}
var untouchedGetTime = Date.prototype.getTime;
var untouchedToISOString = Date.prototype.toISOString;
function extractGetTime(instance) {
  try {
    return instance.getTime;
  } catch (err) {
    return void 0;
  }
}
function extractToISOString(instance) {
  try {
    return instance.toISOString;
  } catch (err) {
    return void 0;
  }
}
function safeGetTime(instance) {
  if (extractGetTime(instance) === untouchedGetTime) {
    return instance.getTime();
  }
  return safeApply(untouchedGetTime, instance, []);
}
function safeToISOString(instance) {
  if (extractToISOString(instance) === untouchedToISOString) {
    return instance.toISOString();
  }
  return safeApply(untouchedToISOString, instance, []);
}
var untouchedAdd = Set.prototype.add;
var untouchedHas = Set.prototype.has;
var untouchedSet = WeakMap.prototype.set;
var untouchedGet = WeakMap.prototype.get;
var untouchedMapSet = Map.prototype.set;
var untouchedMapGet = Map.prototype.get;
function extractMapSet(instance) {
  try {
    return instance.set;
  } catch (err) {
    return void 0;
  }
}
function extractMapGet(instance) {
  try {
    return instance.get;
  } catch (err) {
    return void 0;
  }
}
function safeMapSet(instance, key, value3) {
  if (extractMapSet(instance) === untouchedMapSet) {
    return instance.set(key, value3);
  }
  return safeApply(untouchedMapSet, instance, [key, value3]);
}
function safeMapGet(instance, key) {
  if (extractMapGet(instance) === untouchedMapGet) {
    return instance.get(key);
  }
  return safeApply(untouchedMapGet, instance, [key]);
}
var untouchedSplit = String.prototype.split;
var untouchedStartsWith = String.prototype.startsWith;
var untouchedEndsWith = String.prototype.endsWith;
var untouchedSubstring = String.prototype.substring;
var untouchedToLowerCase = String.prototype.toLowerCase;
var untouchedToUpperCase = String.prototype.toUpperCase;
var untouchedPadStart = String.prototype.padStart;
var untouchedCharCodeAt = String.prototype.charCodeAt;
var untouchedNormalize = String.prototype.normalize;
var untouchedReplace = String.prototype.replace;
function extractSplit(instance) {
  try {
    return instance.split;
  } catch (err) {
    return void 0;
  }
}
function extractCharCodeAt(instance) {
  try {
    return instance.charCodeAt;
  } catch (err) {
    return void 0;
  }
}
function safeSplit(instance, ...args2) {
  if (extractSplit(instance) === untouchedSplit) {
    return instance.split(...args2);
  }
  return safeApply(untouchedSplit, instance, args2);
}
function safeCharCodeAt(instance, index) {
  if (extractCharCodeAt(instance) === untouchedCharCodeAt) {
    return instance.charCodeAt(index);
  }
  return safeApply(untouchedCharCodeAt, instance, [index]);
}
var untouchedNumberToString = Number.prototype.toString;
function extractNumberToString(instance) {
  try {
    return instance.toString;
  } catch (err) {
    return void 0;
  }
}
function safeNumberToString(instance, ...args2) {
  if (extractNumberToString(instance) === untouchedNumberToString) {
    return instance.toString(...args2);
  }
  return safeApply(untouchedNumberToString, instance, args2);
}
var untouchedToString = Object.prototype.toString;
function safeToString(instance) {
  return safeApply(untouchedToString, instance, []);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/LazyIterableIterator.js
var LazyIterableIterator = class {
  constructor(producer) {
    this.producer = producer;
  }
  [Symbol.iterator]() {
    if (this.it === void 0) {
      this.it = this.producer();
    }
    return this.it;
  }
  next() {
    if (this.it === void 0) {
      this.it = this.producer();
    }
    return this.it.next();
  }
};
function makeLazy(producer) {
  return new LazyIterableIterator(producer);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/TupleArbitrary.js
var safeArrayIsArray = Array.isArray;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/IRawProperty.js
var safeMathLog = Math.log;
function runIdToFrequency(runId) {
  return 2 + ~~(safeMathLog(runId + 1) * 0.4342944819032518);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/configuration/GlobalParameters.js
var globalParameters = {};
function readConfigureGlobal() {
  return globalParameters;
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/NoUndefinedAsContext.js
var UndefinedContextPlaceholder = Symbol("UndefinedContextPlaceholder");
function noUndefinedAsContext(value3) {
  if (value3.context !== void 0) {
    return value3;
  }
  if (value3.hasToBeCloned) {
    return new Value(value3.value_, UndefinedContextPlaceholder, () => value3.value);
  }
  return new Value(value3.value_, UndefinedContextPlaceholder);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/AsyncProperty.generic.js
var AsyncProperty = class _AsyncProperty {
  constructor(arb, predicate) {
    this.arb = arb;
    this.predicate = predicate;
    const { asyncBeforeEach, asyncAfterEach, beforeEach, afterEach } = readConfigureGlobal() || {};
    if (asyncBeforeEach !== void 0 && beforeEach !== void 0) {
      throw SError(`Global "asyncBeforeEach" and "beforeEach" parameters can't be set at the same time when running async properties`);
    }
    if (asyncAfterEach !== void 0 && afterEach !== void 0) {
      throw SError(`Global "asyncAfterEach" and "afterEach" parameters can't be set at the same time when running async properties`);
    }
    this.beforeEachHook = asyncBeforeEach || beforeEach || _AsyncProperty.dummyHook;
    this.afterEachHook = asyncAfterEach || afterEach || _AsyncProperty.dummyHook;
  }
  isAsync() {
    return true;
  }
  generate(mrng, runId) {
    const value3 = this.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : void 0);
    return noUndefinedAsContext(value3);
  }
  shrink(value3) {
    if (value3.context === void 0 && !this.arb.canShrinkWithoutContext(value3.value_)) {
      return Stream.nil();
    }
    const safeContext = value3.context !== UndefinedContextPlaceholder ? value3.context : void 0;
    return this.arb.shrink(value3.value_, safeContext).map(noUndefinedAsContext);
  }
  async runBeforeEach() {
    await this.beforeEachHook();
  }
  async runAfterEach() {
    await this.afterEachHook();
  }
  async run(v, dontRunHook) {
    if (!dontRunHook) {
      await this.beforeEachHook();
    }
    try {
      const output3 = await this.predicate(v);
      return output3 == null || output3 === true ? null : {
        error: new SError("Property failed by returning false"),
        errorMessage: "Error: Property failed by returning false"
      };
    } catch (err) {
      if (PreconditionFailure.isFailure(err))
        return err;
      if (err instanceof SError && err.stack) {
        return { error: err, errorMessage: err.stack };
      }
      return { error: err, errorMessage: SString(err) };
    } finally {
      if (!dontRunHook) {
        await this.afterEachHook();
      }
    }
  }
  beforeEach(hookFunction) {
    const previousBeforeEachHook = this.beforeEachHook;
    this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
    return this;
  }
  afterEach(hookFunction) {
    const previousAfterEachHook = this.afterEachHook;
    this.afterEachHook = () => hookFunction(previousAfterEachHook);
    return this;
  }
};
AsyncProperty.dummyHook = () => {
};

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/Property.generic.js
var Property = class _Property {
  constructor(arb, predicate) {
    this.arb = arb;
    this.predicate = predicate;
    const { beforeEach = _Property.dummyHook, afterEach = _Property.dummyHook, asyncBeforeEach, asyncAfterEach } = readConfigureGlobal() || {};
    if (asyncBeforeEach !== void 0) {
      throw SError(`"asyncBeforeEach" can't be set when running synchronous properties`);
    }
    if (asyncAfterEach !== void 0) {
      throw SError(`"asyncAfterEach" can't be set when running synchronous properties`);
    }
    this.beforeEachHook = beforeEach;
    this.afterEachHook = afterEach;
  }
  isAsync() {
    return false;
  }
  generate(mrng, runId) {
    const value3 = this.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : void 0);
    return noUndefinedAsContext(value3);
  }
  shrink(value3) {
    if (value3.context === void 0 && !this.arb.canShrinkWithoutContext(value3.value_)) {
      return Stream.nil();
    }
    const safeContext = value3.context !== UndefinedContextPlaceholder ? value3.context : void 0;
    return this.arb.shrink(value3.value_, safeContext).map(noUndefinedAsContext);
  }
  runBeforeEach() {
    this.beforeEachHook();
  }
  runAfterEach() {
    this.afterEachHook();
  }
  run(v, dontRunHook) {
    if (!dontRunHook) {
      this.beforeEachHook();
    }
    try {
      const output3 = this.predicate(v);
      return output3 == null || output3 === true ? null : {
        error: new SError("Property failed by returning false"),
        errorMessage: "Error: Property failed by returning false"
      };
    } catch (err) {
      if (PreconditionFailure.isFailure(err))
        return err;
      if (err instanceof SError && err.stack) {
        return { error: err, errorMessage: err.stack };
      }
      return { error: err, errorMessage: SString(err) };
    } finally {
      if (!dontRunHook) {
        this.afterEachHook();
      }
    }
  }
  beforeEach(hookFunction) {
    const previousBeforeEachHook = this.beforeEachHook;
    this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
    return this;
  }
  afterEach(hookFunction) {
    const previousAfterEachHook = this.afterEachHook;
    this.afterEachHook = () => hookFunction(previousAfterEachHook);
    return this;
  }
};
Property.dummyHook = () => {
};

// ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/pure-rand-default.js
var pure_rand_default_exports = {};
__export(pure_rand_default_exports, {
  __commitHash: () => __commitHash,
  __type: () => __type,
  __version: () => __version,
  congruential32: () => congruential32,
  generateN: () => generateN,
  mersenne: () => MersenneTwister_default,
  skipN: () => skipN,
  uniformArrayIntDistribution: () => uniformArrayIntDistribution,
  uniformBigIntDistribution: () => uniformBigIntDistribution,
  uniformIntDistribution: () => uniformIntDistribution,
  unsafeGenerateN: () => unsafeGenerateN,
  unsafeSkipN: () => unsafeSkipN,
  unsafeUniformArrayIntDistribution: () => unsafeUniformArrayIntDistribution,
  unsafeUniformBigIntDistribution: () => unsafeUniformBigIntDistribution,
  unsafeUniformIntDistribution: () => unsafeUniformIntDistribution,
  xoroshiro128plus: () => xoroshiro128plus,
  xorshift128plus: () => xorshift128plus
});

// ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/RandomGenerator.js
function unsafeGenerateN(rng, num2) {
  var out = [];
  for (var idx = 0; idx != num2; ++idx) {
    out.push(rng.unsafeNext());
  }
  return out;
}
function generateN(rng, num2) {
  var nextRng = rng.clone();
  var out = unsafeGenerateN(nextRng, num2);
  return [out, nextRng];
}
function unsafeSkipN(rng, num2) {
  for (var idx = 0; idx != num2; ++idx) {
    rng.unsafeNext();
  }
}
function skipN(rng, num2) {
  var nextRng = rng.clone();
  unsafeSkipN(nextRng, num2);
  return nextRng;
}

// ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/LinearCongruential.js
var MULTIPLIER = 214013;
var INCREMENT = 2531011;
var MASK2 = 4294967295;
var MASK_2 = (1 << 31) - 1;
var computeNextSeed = function(seed) {
  return seed * MULTIPLIER + INCREMENT & MASK2;
};
var computeValueFromNextSeed = function(nextseed) {
  return (nextseed & MASK_2) >> 16;
};
var LinearCongruential32 = function() {
  function LinearCongruential322(seed) {
    this.seed = seed;
  }
  LinearCongruential322.prototype.clone = function() {
    return new LinearCongruential322(this.seed);
  };
  LinearCongruential322.prototype.next = function() {
    var nextRng = new LinearCongruential322(this.seed);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  LinearCongruential322.prototype.unsafeNext = function() {
    var s1 = computeNextSeed(this.seed);
    var v1 = computeValueFromNextSeed(s1);
    var s2 = computeNextSeed(s1);
    var v2 = computeValueFromNextSeed(s2);
    this.seed = computeNextSeed(s2);
    var v3 = computeValueFromNextSeed(this.seed);
    var vnext = v3 + (v2 + (v1 << 15) << 15);
    return vnext | 0;
  };
  LinearCongruential322.prototype.getState = function() {
    return [this.seed];
  };
  return LinearCongruential322;
}();
function fromState(state) {
  var valid = state.length === 1;
  if (!valid) {
    throw new Error("The state must have been produced by a congruential32 RandomGenerator");
  }
  return new LinearCongruential32(state[0]);
}
var congruential32 = Object.assign(function(seed) {
  return new LinearCongruential32(seed);
}, { fromState });

// ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/MersenneTwister.js
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack2) {
  if (pack2 || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var MersenneTwister = function() {
  function MersenneTwister2(states, index) {
    this.states = states;
    this.index = index;
  }
  MersenneTwister2.twist = function(prev) {
    var mt = prev.slice();
    for (var idx = 0; idx !== MersenneTwister2.N - MersenneTwister2.M; ++idx) {
      var y_1 = (mt[idx] & MersenneTwister2.MASK_UPPER) + (mt[idx + 1] & MersenneTwister2.MASK_LOWER);
      mt[idx] = mt[idx + MersenneTwister2.M] ^ y_1 >>> 1 ^ -(y_1 & 1) & MersenneTwister2.A;
    }
    for (var idx = MersenneTwister2.N - MersenneTwister2.M; idx !== MersenneTwister2.N - 1; ++idx) {
      var y_2 = (mt[idx] & MersenneTwister2.MASK_UPPER) + (mt[idx + 1] & MersenneTwister2.MASK_LOWER);
      mt[idx] = mt[idx + MersenneTwister2.M - MersenneTwister2.N] ^ y_2 >>> 1 ^ -(y_2 & 1) & MersenneTwister2.A;
    }
    var y = (mt[MersenneTwister2.N - 1] & MersenneTwister2.MASK_UPPER) + (mt[0] & MersenneTwister2.MASK_LOWER);
    mt[MersenneTwister2.N - 1] = mt[MersenneTwister2.M - 1] ^ y >>> 1 ^ -(y & 1) & MersenneTwister2.A;
    return mt;
  };
  MersenneTwister2.seeded = function(seed) {
    var out = Array(MersenneTwister2.N);
    out[0] = seed;
    for (var idx = 1; idx !== MersenneTwister2.N; ++idx) {
      var xored = out[idx - 1] ^ out[idx - 1] >>> 30;
      out[idx] = Math.imul(MersenneTwister2.F, xored) + idx | 0;
    }
    return out;
  };
  MersenneTwister2.from = function(seed) {
    return new MersenneTwister2(MersenneTwister2.twist(MersenneTwister2.seeded(seed)), 0);
  };
  MersenneTwister2.prototype.clone = function() {
    return new MersenneTwister2(this.states, this.index);
  };
  MersenneTwister2.prototype.next = function() {
    var nextRng = new MersenneTwister2(this.states, this.index);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  MersenneTwister2.prototype.unsafeNext = function() {
    var y = this.states[this.index];
    y ^= this.states[this.index] >>> MersenneTwister2.U;
    y ^= y << MersenneTwister2.S & MersenneTwister2.B;
    y ^= y << MersenneTwister2.T & MersenneTwister2.C;
    y ^= y >>> MersenneTwister2.L;
    if (++this.index >= MersenneTwister2.N) {
      this.states = MersenneTwister2.twist(this.states);
      this.index = 0;
    }
    return y;
  };
  MersenneTwister2.prototype.getState = function() {
    return __spreadArray([this.index], __read(this.states), false);
  };
  MersenneTwister2.fromState = function(state) {
    var valid = state.length === MersenneTwister2.N + 1 && state[0] >= 0 && state[0] < MersenneTwister2.N;
    if (!valid) {
      throw new Error("The state must have been produced by a mersenne RandomGenerator");
    }
    return new MersenneTwister2(state.slice(1), state[0]);
  };
  MersenneTwister2.N = 624;
  MersenneTwister2.M = 397;
  MersenneTwister2.R = 31;
  MersenneTwister2.A = 2567483615;
  MersenneTwister2.F = 1812433253;
  MersenneTwister2.U = 11;
  MersenneTwister2.S = 7;
  MersenneTwister2.B = 2636928640;
  MersenneTwister2.T = 15;
  MersenneTwister2.C = 4022730752;
  MersenneTwister2.L = 18;
  MersenneTwister2.MASK_LOWER = Math.pow(2, MersenneTwister2.R) - 1;
  MersenneTwister2.MASK_UPPER = Math.pow(2, MersenneTwister2.R);
  return MersenneTwister2;
}();
function fromState2(state) {
  return MersenneTwister.fromState(state);
}
var MersenneTwister_default = Object.assign(function(seed) {
  return MersenneTwister.from(seed);
}, { fromState: fromState2 });

// ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/XorShift.js
var XorShift128Plus = function() {
  function XorShift128Plus2(s01, s00, s11, s10) {
    this.s01 = s01;
    this.s00 = s00;
    this.s11 = s11;
    this.s10 = s10;
  }
  XorShift128Plus2.prototype.clone = function() {
    return new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
  };
  XorShift128Plus2.prototype.next = function() {
    var nextRng = new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  XorShift128Plus2.prototype.unsafeNext = function() {
    var a0 = this.s00 ^ this.s00 << 23;
    var a1 = this.s01 ^ (this.s01 << 23 | this.s00 >>> 9);
    var b0 = a0 ^ this.s10 ^ (a0 >>> 18 | a1 << 14) ^ (this.s10 >>> 5 | this.s11 << 27);
    var b1 = a1 ^ this.s11 ^ a1 >>> 18 ^ this.s11 >>> 5;
    var out = this.s00 + this.s10 | 0;
    this.s01 = this.s11;
    this.s00 = this.s10;
    this.s11 = b1;
    this.s10 = b0;
    return out;
  };
  XorShift128Plus2.prototype.jump = function() {
    var nextRng = new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
    nextRng.unsafeJump();
    return nextRng;
  };
  XorShift128Plus2.prototype.unsafeJump = function() {
    var ns01 = 0;
    var ns00 = 0;
    var ns11 = 0;
    var ns10 = 0;
    var jump = [1667051007, 2321340297, 1548169110, 304075285];
    for (var i = 0; i !== 4; ++i) {
      for (var mask = 1; mask; mask <<= 1) {
        if (jump[i] & mask) {
          ns01 ^= this.s01;
          ns00 ^= this.s00;
          ns11 ^= this.s11;
          ns10 ^= this.s10;
        }
        this.unsafeNext();
      }
    }
    this.s01 = ns01;
    this.s00 = ns00;
    this.s11 = ns11;
    this.s10 = ns10;
  };
  XorShift128Plus2.prototype.getState = function() {
    return [this.s01, this.s00, this.s11, this.s10];
  };
  return XorShift128Plus2;
}();
function fromState3(state) {
  var valid = state.length === 4;
  if (!valid) {
    throw new Error("The state must have been produced by a xorshift128plus RandomGenerator");
  }
  return new XorShift128Plus(state[0], state[1], state[2], state[3]);
}
var xorshift128plus = Object.assign(function(seed) {
  return new XorShift128Plus(-1, ~seed, seed | 0, 0);
}, { fromState: fromState3 });

// ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/XoroShiro.js
var XoroShiro128Plus = function() {
  function XoroShiro128Plus2(s01, s00, s11, s10) {
    this.s01 = s01;
    this.s00 = s00;
    this.s11 = s11;
    this.s10 = s10;
  }
  XoroShiro128Plus2.prototype.clone = function() {
    return new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
  };
  XoroShiro128Plus2.prototype.next = function() {
    var nextRng = new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  XoroShiro128Plus2.prototype.unsafeNext = function() {
    var out = this.s00 + this.s10 | 0;
    var a0 = this.s10 ^ this.s00;
    var a1 = this.s11 ^ this.s01;
    var s00 = this.s00;
    var s01 = this.s01;
    this.s00 = s00 << 24 ^ s01 >>> 8 ^ a0 ^ a0 << 16;
    this.s01 = s01 << 24 ^ s00 >>> 8 ^ a1 ^ (a1 << 16 | a0 >>> 16);
    this.s10 = a1 << 5 ^ a0 >>> 27;
    this.s11 = a0 << 5 ^ a1 >>> 27;
    return out;
  };
  XoroShiro128Plus2.prototype.jump = function() {
    var nextRng = new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
    nextRng.unsafeJump();
    return nextRng;
  };
  XoroShiro128Plus2.prototype.unsafeJump = function() {
    var ns01 = 0;
    var ns00 = 0;
    var ns11 = 0;
    var ns10 = 0;
    var jump = [3639956645, 3750757012, 1261568508, 386426335];
    for (var i = 0; i !== 4; ++i) {
      for (var mask = 1; mask; mask <<= 1) {
        if (jump[i] & mask) {
          ns01 ^= this.s01;
          ns00 ^= this.s00;
          ns11 ^= this.s11;
          ns10 ^= this.s10;
        }
        this.unsafeNext();
      }
    }
    this.s01 = ns01;
    this.s00 = ns00;
    this.s11 = ns11;
    this.s10 = ns10;
  };
  XoroShiro128Plus2.prototype.getState = function() {
    return [this.s01, this.s00, this.s11, this.s10];
  };
  return XoroShiro128Plus2;
}();
function fromState4(state) {
  var valid = state.length === 4;
  if (!valid) {
    throw new Error("The state must have been produced by a xoroshiro128plus RandomGenerator");
  }
  return new XoroShiro128Plus(state[0], state[1], state[2], state[3]);
}
var xoroshiro128plus = Object.assign(function(seed) {
  return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);
}, { fromState: fromState4 });

// ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/internals/ArrayInt.js
function addArrayIntToNew(arrayIntA, arrayIntB) {
  if (arrayIntA.sign !== arrayIntB.sign) {
    return substractArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
  }
  var data = [];
  var reminder = 0;
  var dataA = arrayIntA.data;
  var dataB = arrayIntB.data;
  for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    var current2 = vA + vB + reminder;
    data.push(current2 >>> 0);
    reminder = ~~(current2 / 4294967296);
  }
  if (reminder !== 0) {
    data.push(reminder);
  }
  return { sign: arrayIntA.sign, data: data.reverse() };
}
function addOneToPositiveArrayInt(arrayInt) {
  arrayInt.sign = 1;
  var data = arrayInt.data;
  for (var index = data.length - 1; index >= 0; --index) {
    if (data[index] === 4294967295) {
      data[index] = 0;
    } else {
      data[index] += 1;
      return arrayInt;
    }
  }
  data.unshift(1);
  return arrayInt;
}
function isStrictlySmaller(dataA, dataB) {
  var maxLength3 = Math.max(dataA.length, dataB.length);
  for (var index = 0; index < maxLength3; ++index) {
    var indexA = index + dataA.length - maxLength3;
    var indexB = index + dataB.length - maxLength3;
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    if (vA < vB)
      return true;
    if (vA > vB)
      return false;
  }
  return false;
}
function substractArrayIntToNew(arrayIntA, arrayIntB) {
  if (arrayIntA.sign !== arrayIntB.sign) {
    return addArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
  }
  var dataA = arrayIntA.data;
  var dataB = arrayIntB.data;
  if (isStrictlySmaller(dataA, dataB)) {
    var out = substractArrayIntToNew(arrayIntB, arrayIntA);
    out.sign = -out.sign;
    return out;
  }
  var data = [];
  var reminder = 0;
  for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    var current2 = vA - vB - reminder;
    data.push(current2 >>> 0);
    reminder = current2 < 0 ? 1 : 0;
  }
  return { sign: arrayIntA.sign, data: data.reverse() };
}
function trimArrayIntInplace(arrayInt) {
  var data = arrayInt.data;
  var firstNonZero = 0;
  for (; firstNonZero !== data.length && data[firstNonZero] === 0; ++firstNonZero) {
  }
  if (firstNonZero === data.length) {
    arrayInt.sign = 1;
    arrayInt.data = [0];
    return arrayInt;
  }
  data.splice(0, firstNonZero);
  return arrayInt;
}
function fromNumberToArrayInt64(out, n) {
  if (n < 0) {
    var posN = -n;
    out.sign = -1;
    out.data[0] = ~~(posN / 4294967296);
    out.data[1] = posN >>> 0;
  } else {
    out.sign = 1;
    out.data[0] = ~~(n / 4294967296);
    out.data[1] = n >>> 0;
  }
  return out;
}
function substractArrayInt64(out, arrayIntA, arrayIntB) {
  var lowA = arrayIntA.data[1];
  var highA = arrayIntA.data[0];
  var signA = arrayIntA.sign;
  var lowB = arrayIntB.data[1];
  var highB = arrayIntB.data[0];
  var signB = arrayIntB.sign;
  out.sign = 1;
  if (signA === 1 && signB === -1) {
    var low_1 = lowA + lowB;
    var high = highA + highB + (low_1 > 4294967295 ? 1 : 0);
    out.data[0] = high >>> 0;
    out.data[1] = low_1 >>> 0;
    return out;
  }
  var lowFirst = lowA;
  var highFirst = highA;
  var lowSecond = lowB;
  var highSecond = highB;
  if (signA === -1) {
    lowFirst = lowB;
    highFirst = highB;
    lowSecond = lowA;
    highSecond = highA;
  }
  var reminderLow = 0;
  var low = lowFirst - lowSecond;
  if (low < 0) {
    reminderLow = 1;
    low = low >>> 0;
  }
  out.data[0] = highFirst - highSecond - reminderLow;
  out.data[1] = low;
  return out;
}

// ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformIntDistributionInternal.js
function unsafeUniformIntDistributionInternal(rangeSize, rng) {
  var MaxAllowed = rangeSize > 2 ? ~~(4294967296 / rangeSize) * rangeSize : 4294967296;
  var deltaV = rng.unsafeNext() + 2147483648;
  while (deltaV >= MaxAllowed) {
    deltaV = rng.unsafeNext() + 2147483648;
  }
  return deltaV % rangeSize;
}

// ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js
function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng) {
  var rangeLength = rangeSize.length;
  while (true) {
    for (var index = 0; index !== rangeLength; ++index) {
      var indexRangeSize = index === 0 ? rangeSize[0] + 1 : 4294967296;
      var g = unsafeUniformIntDistributionInternal(indexRangeSize, rng);
      out[index] = g;
    }
    for (var index = 0; index !== rangeLength; ++index) {
      var current2 = out[index];
      var currentInRange = rangeSize[index];
      if (current2 < currentInRange) {
        return out;
      } else if (current2 > currentInRange) {
        break;
      }
    }
  }
}

// ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformArrayIntDistribution.js
function unsafeUniformArrayIntDistribution(from, to, rng) {
  var rangeSize = trimArrayIntInplace(addOneToPositiveArrayInt(substractArrayIntToNew(to, from)));
  var emptyArrayIntData = rangeSize.data.slice(0);
  var g = unsafeUniformArrayIntDistributionInternal(emptyArrayIntData, rangeSize.data, rng);
  return trimArrayIntInplace(addArrayIntToNew({ sign: 1, data: g }, from));
}

// ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformArrayIntDistribution.js
function uniformArrayIntDistribution(from, to, rng) {
  if (rng != null) {
    var nextRng = rng.clone();
    return [unsafeUniformArrayIntDistribution(from, to, nextRng), nextRng];
  }
  return function(rng2) {
    var nextRng2 = rng2.clone();
    return [unsafeUniformArrayIntDistribution(from, to, nextRng2), nextRng2];
  };
}

// ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformBigIntDistribution.js
var SBigInt = typeof BigInt !== "undefined" ? BigInt : void 0;
function unsafeUniformBigIntDistribution(from, to, rng) {
  var diff8 = to - from + SBigInt(1);
  var MinRng = SBigInt(-2147483648);
  var NumValues = SBigInt(4294967296);
  var FinalNumValues = NumValues;
  var NumIterations = 1;
  while (FinalNumValues < diff8) {
    FinalNumValues *= NumValues;
    ++NumIterations;
  }
  var MaxAcceptedRandom = FinalNumValues - FinalNumValues % diff8;
  while (true) {
    var value3 = SBigInt(0);
    for (var num2 = 0; num2 !== NumIterations; ++num2) {
      var out = rng.unsafeNext();
      value3 = NumValues * value3 + (SBigInt(out) - MinRng);
    }
    if (value3 < MaxAcceptedRandom) {
      var inDiff = value3 % diff8;
      return inDiff + from;
    }
  }
}

// ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformBigIntDistribution.js
function uniformBigIntDistribution(from, to, rng) {
  if (rng != null) {
    var nextRng = rng.clone();
    return [unsafeUniformBigIntDistribution(from, to, nextRng), nextRng];
  }
  return function(rng2) {
    var nextRng2 = rng2.clone();
    return [unsafeUniformBigIntDistribution(from, to, nextRng2), nextRng2];
  };
}

// ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformIntDistribution.js
var safeNumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;
var sharedA = { sign: 1, data: [0, 0] };
var sharedB = { sign: 1, data: [0, 0] };
var sharedC = { sign: 1, data: [0, 0] };
var sharedData = [0, 0];
function uniformLargeIntInternal(from, to, rangeSize, rng) {
  var rangeSizeArrayIntValue = rangeSize <= safeNumberMaxSafeInteger ? fromNumberToArrayInt64(sharedC, rangeSize) : substractArrayInt64(sharedC, fromNumberToArrayInt64(sharedA, to), fromNumberToArrayInt64(sharedB, from));
  if (rangeSizeArrayIntValue.data[1] === 4294967295) {
    rangeSizeArrayIntValue.data[0] += 1;
    rangeSizeArrayIntValue.data[1] = 0;
  } else {
    rangeSizeArrayIntValue.data[1] += 1;
  }
  unsafeUniformArrayIntDistributionInternal(sharedData, rangeSizeArrayIntValue.data, rng);
  return sharedData[0] * 4294967296 + sharedData[1] + from;
}
function unsafeUniformIntDistribution(from, to, rng) {
  var rangeSize = to - from;
  if (rangeSize <= 4294967295) {
    var g = unsafeUniformIntDistributionInternal(rangeSize + 1, rng);
    return g + from;
  }
  return uniformLargeIntInternal(from, to, rangeSize, rng);
}

// ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformIntDistribution.js
function uniformIntDistribution(from, to, rng) {
  if (rng != null) {
    var nextRng = rng.clone();
    return [unsafeUniformIntDistribution(from, to, nextRng), nextRng];
  }
  return function(rng2) {
    var nextRng2 = rng2.clone();
    return [unsafeUniformIntDistribution(from, to, nextRng2), nextRng2];
  };
}

// ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/pure-rand-default.js
var __type = "module";
var __version = "6.1.0";
var __commitHash = "a413dd2b721516be2ef29adffb515c5ae67bfbad";

// ../../node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/pure-rand.js
var pure_rand_default = pure_rand_default_exports;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/configuration/VerbosityLevel.js
var VerbosityLevel;
(function(VerbosityLevel2) {
  VerbosityLevel2[VerbosityLevel2["None"] = 0] = "None";
  VerbosityLevel2[VerbosityLevel2["Verbose"] = 1] = "Verbose";
  VerbosityLevel2[VerbosityLevel2["VeryVerbose"] = 2] = "VeryVerbose";
})(VerbosityLevel || (VerbosityLevel = {}));

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/configuration/QualifiedParameters.js
var safeDateNow = Date.now;
var safeMathMin = Math.min;
var safeMathRandom = Math.random;
var QualifiedParameters = class _QualifiedParameters {
  constructor(op) {
    const p = op || {};
    this.seed = _QualifiedParameters.readSeed(p);
    this.randomType = _QualifiedParameters.readRandomType(p);
    this.numRuns = _QualifiedParameters.readNumRuns(p);
    this.verbose = _QualifiedParameters.readVerbose(p);
    this.maxSkipsPerRun = _QualifiedParameters.readOrDefault(p, "maxSkipsPerRun", 100);
    this.timeout = _QualifiedParameters.safeTimeout(_QualifiedParameters.readOrDefault(p, "timeout", null));
    this.skipAllAfterTimeLimit = _QualifiedParameters.safeTimeout(_QualifiedParameters.readOrDefault(p, "skipAllAfterTimeLimit", null));
    this.interruptAfterTimeLimit = _QualifiedParameters.safeTimeout(_QualifiedParameters.readOrDefault(p, "interruptAfterTimeLimit", null));
    this.markInterruptAsFailure = _QualifiedParameters.readBoolean(p, "markInterruptAsFailure");
    this.skipEqualValues = _QualifiedParameters.readBoolean(p, "skipEqualValues");
    this.ignoreEqualValues = _QualifiedParameters.readBoolean(p, "ignoreEqualValues");
    this.logger = _QualifiedParameters.readOrDefault(p, "logger", (v) => {
      console.log(v);
    });
    this.path = _QualifiedParameters.readOrDefault(p, "path", "");
    this.unbiased = _QualifiedParameters.readBoolean(p, "unbiased");
    this.examples = _QualifiedParameters.readOrDefault(p, "examples", []);
    this.endOnFailure = _QualifiedParameters.readBoolean(p, "endOnFailure");
    this.reporter = _QualifiedParameters.readOrDefault(p, "reporter", null);
    this.asyncReporter = _QualifiedParameters.readOrDefault(p, "asyncReporter", null);
    this.errorWithCause = _QualifiedParameters.readBoolean(p, "errorWithCause");
  }
  toParameters() {
    const orUndefined3 = (value3) => value3 !== null ? value3 : void 0;
    const parameters = {
      seed: this.seed,
      randomType: this.randomType,
      numRuns: this.numRuns,
      maxSkipsPerRun: this.maxSkipsPerRun,
      timeout: orUndefined3(this.timeout),
      skipAllAfterTimeLimit: orUndefined3(this.skipAllAfterTimeLimit),
      interruptAfterTimeLimit: orUndefined3(this.interruptAfterTimeLimit),
      markInterruptAsFailure: this.markInterruptAsFailure,
      skipEqualValues: this.skipEqualValues,
      ignoreEqualValues: this.ignoreEqualValues,
      path: this.path,
      logger: this.logger,
      unbiased: this.unbiased,
      verbose: this.verbose,
      examples: this.examples,
      endOnFailure: this.endOnFailure,
      reporter: orUndefined3(this.reporter),
      asyncReporter: orUndefined3(this.asyncReporter),
      errorWithCause: this.errorWithCause
    };
    return parameters;
  }
  static read(op) {
    return new _QualifiedParameters(op);
  }
};
QualifiedParameters.createQualifiedRandomGenerator = (random4) => {
  return (seed) => {
    const rng = random4(seed);
    if (rng.unsafeJump === void 0) {
      rng.unsafeJump = () => unsafeSkipN(rng, 42);
    }
    return rng;
  };
};
QualifiedParameters.readSeed = (p) => {
  if (p.seed == null)
    return safeDateNow() ^ safeMathRandom() * 4294967296;
  const seed32 = p.seed | 0;
  if (p.seed === seed32)
    return seed32;
  const gap = p.seed - seed32;
  return seed32 ^ gap * 4294967296;
};
QualifiedParameters.readRandomType = (p) => {
  if (p.randomType == null)
    return pure_rand_default.xorshift128plus;
  if (typeof p.randomType === "string") {
    switch (p.randomType) {
      case "mersenne":
        return QualifiedParameters.createQualifiedRandomGenerator(pure_rand_default.mersenne);
      case "congruential":
      case "congruential32":
        return QualifiedParameters.createQualifiedRandomGenerator(pure_rand_default.congruential32);
      case "xorshift128plus":
        return pure_rand_default.xorshift128plus;
      case "xoroshiro128plus":
        return pure_rand_default.xoroshiro128plus;
      default:
        throw new Error(`Invalid random specified: '${p.randomType}'`);
    }
  }
  const mrng = p.randomType(0);
  if ("min" in mrng && mrng.min !== -2147483648) {
    throw new Error(`Invalid random number generator: min must equal -0x80000000, got ${String(mrng.min)}`);
  }
  if ("max" in mrng && mrng.max !== 2147483647) {
    throw new Error(`Invalid random number generator: max must equal 0x7fffffff, got ${String(mrng.max)}`);
  }
  if ("unsafeJump" in mrng) {
    return p.randomType;
  }
  return QualifiedParameters.createQualifiedRandomGenerator(p.randomType);
};
QualifiedParameters.readNumRuns = (p) => {
  const defaultValue = 100;
  if (p.numRuns != null)
    return p.numRuns;
  if (p.num_runs != null)
    return p.num_runs;
  return defaultValue;
};
QualifiedParameters.readVerbose = (p) => {
  if (p.verbose == null)
    return VerbosityLevel.None;
  if (typeof p.verbose === "boolean") {
    return p.verbose === true ? VerbosityLevel.Verbose : VerbosityLevel.None;
  }
  if (p.verbose <= VerbosityLevel.None) {
    return VerbosityLevel.None;
  }
  if (p.verbose >= VerbosityLevel.VeryVerbose) {
    return VerbosityLevel.VeryVerbose;
  }
  return p.verbose | 0;
};
QualifiedParameters.readBoolean = (p, key) => p[key] === true;
QualifiedParameters.readOrDefault = (p, key, defaultValue) => {
  const value3 = p[key];
  return value3 != null ? value3 : defaultValue;
};
QualifiedParameters.safeTimeout = (value3) => {
  if (value3 === null) {
    return null;
  }
  return safeMathMin(value3, 2147483647);
};

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/stringify.js
var safeArrayFrom = Array.from;
var safeBufferIsBuffer = typeof Buffer !== "undefined" ? Buffer.isBuffer : void 0;
var safeJsonStringify = JSON.stringify;
var safeNumberIsNaN = Number.isNaN;
var safeObjectKeys = Object.keys;
var safeObjectGetOwnPropertySymbols = Object.getOwnPropertySymbols;
var safeObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var safeObjectGetPrototypeOf = Object.getPrototypeOf;
var safeNegativeInfinity = Number.NEGATIVE_INFINITY;
var safePositiveInfinity = Number.POSITIVE_INFINITY;
var toStringMethod = Symbol.for("fast-check/toStringMethod");
function hasToStringMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && toStringMethod in instance && typeof instance[toStringMethod] === "function";
}
var asyncToStringMethod = Symbol.for("fast-check/asyncToStringMethod");
function hasAsyncToStringMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && asyncToStringMethod in instance && typeof instance[asyncToStringMethod] === "function";
}
var findSymbolNameRegex = /^Symbol\((.*)\)$/;
function getSymbolDescription(s) {
  if (s.description !== void 0)
    return s.description;
  const m = findSymbolNameRegex.exec(SString(s));
  return m && m[1].length ? m[1] : null;
}
function stringifyNumber(numValue) {
  switch (numValue) {
    case 0:
      return 1 / numValue === safeNegativeInfinity ? "-0" : "0";
    case safeNegativeInfinity:
      return "Number.NEGATIVE_INFINITY";
    case safePositiveInfinity:
      return "Number.POSITIVE_INFINITY";
    default:
      return numValue === numValue ? SString(numValue) : "Number.NaN";
  }
}
function isSparseArray(arr) {
  let previousNumberedIndex = -1;
  for (const index in arr) {
    const numberedIndex = Number(index);
    if (numberedIndex !== previousNumberedIndex + 1)
      return true;
    previousNumberedIndex = numberedIndex;
  }
  return previousNumberedIndex + 1 !== arr.length;
}
function stringifyInternal(value3, previousValues, getAsyncContent) {
  const currentValues = [...previousValues, value3];
  if (typeof value3 === "object") {
    if (safeIndexOf(previousValues, value3) !== -1) {
      return "[cyclic]";
    }
  }
  if (hasAsyncToStringMethod(value3)) {
    const content = getAsyncContent(value3);
    if (content.state === "fulfilled") {
      return content.value;
    }
  }
  if (hasToStringMethod(value3)) {
    try {
      return value3[toStringMethod]();
    } catch (err) {
    }
  }
  switch (safeToString(value3)) {
    case "[object Array]": {
      const arr = value3;
      if (arr.length >= 50 && isSparseArray(arr)) {
        const assignments = [];
        for (const index in arr) {
          if (!safeNumberIsNaN(Number(index)))
            safePush(assignments, `${index}:${stringifyInternal(arr[index], currentValues, getAsyncContent)}`);
        }
        return assignments.length !== 0 ? `Object.assign(Array(${arr.length}),{${safeJoin(assignments, ",")}})` : `Array(${arr.length})`;
      }
      const stringifiedArray = safeJoin(safeMap(arr, (v) => stringifyInternal(v, currentValues, getAsyncContent)), ",");
      return arr.length === 0 || arr.length - 1 in arr ? `[${stringifiedArray}]` : `[${stringifiedArray},]`;
    }
    case "[object BigInt]":
      return `${value3}n`;
    case "[object Boolean]": {
      const unboxedToString = value3 == true ? "true" : "false";
      return typeof value3 === "boolean" ? unboxedToString : `new Boolean(${unboxedToString})`;
    }
    case "[object Date]": {
      const d = value3;
      return safeNumberIsNaN(safeGetTime(d)) ? `new Date(NaN)` : `new Date(${safeJsonStringify(safeToISOString(d))})`;
    }
    case "[object Map]":
      return `new Map(${stringifyInternal(Array.from(value3), currentValues, getAsyncContent)})`;
    case "[object Null]":
      return `null`;
    case "[object Number]":
      return typeof value3 === "number" ? stringifyNumber(value3) : `new Number(${stringifyNumber(Number(value3))})`;
    case "[object Object]": {
      try {
        const toStringAccessor = value3.toString;
        if (typeof toStringAccessor === "function" && toStringAccessor !== Object.prototype.toString) {
          return value3.toString();
        }
      } catch (err) {
        return "[object Object]";
      }
      const mapper = (k) => `${k === "__proto__" ? '["__proto__"]' : typeof k === "symbol" ? `[${stringifyInternal(k, currentValues, getAsyncContent)}]` : safeJsonStringify(k)}:${stringifyInternal(value3[k], currentValues, getAsyncContent)}`;
      const stringifiedProperties = [
        ...safeMap(safeObjectKeys(value3), mapper),
        ...safeMap(safeFilter(safeObjectGetOwnPropertySymbols(value3), (s) => {
          const descriptor3 = safeObjectGetOwnPropertyDescriptor(value3, s);
          return descriptor3 && descriptor3.enumerable;
        }), mapper)
      ];
      const rawRepr = "{" + safeJoin(stringifiedProperties, ",") + "}";
      if (safeObjectGetPrototypeOf(value3) === null) {
        return rawRepr === "{}" ? "Object.create(null)" : `Object.assign(Object.create(null),${rawRepr})`;
      }
      return rawRepr;
    }
    case "[object Set]":
      return `new Set(${stringifyInternal(Array.from(value3), currentValues, getAsyncContent)})`;
    case "[object String]":
      return typeof value3 === "string" ? safeJsonStringify(value3) : `new String(${safeJsonStringify(value3)})`;
    case "[object Symbol]": {
      const s = value3;
      if (SSymbol.keyFor(s) !== void 0) {
        return `Symbol.for(${safeJsonStringify(SSymbol.keyFor(s))})`;
      }
      const desc = getSymbolDescription(s);
      if (desc === null) {
        return "Symbol()";
      }
      const knownSymbol = desc.startsWith("Symbol.") && SSymbol[desc.substring(7)];
      return s === knownSymbol ? desc : `Symbol(${safeJsonStringify(desc)})`;
    }
    case "[object Promise]": {
      const promiseContent = getAsyncContent(value3);
      switch (promiseContent.state) {
        case "fulfilled":
          return `Promise.resolve(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
        case "rejected":
          return `Promise.reject(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
        case "pending":
          return `new Promise(() => {/*pending*/})`;
        case "unknown":
        default:
          return `new Promise(() => {/*unknown*/})`;
      }
    }
    case "[object Error]":
      if (value3 instanceof Error) {
        return `new Error(${stringifyInternal(value3.message, currentValues, getAsyncContent)})`;
      }
      break;
    case "[object Undefined]":
      return `undefined`;
    case "[object Int8Array]":
    case "[object Uint8Array]":
    case "[object Uint8ClampedArray]":
    case "[object Int16Array]":
    case "[object Uint16Array]":
    case "[object Int32Array]":
    case "[object Uint32Array]":
    case "[object Float32Array]":
    case "[object Float64Array]":
    case "[object BigInt64Array]":
    case "[object BigUint64Array]": {
      if (typeof safeBufferIsBuffer === "function" && safeBufferIsBuffer(value3)) {
        return `Buffer.from(${stringifyInternal(safeArrayFrom(value3.values()), currentValues, getAsyncContent)})`;
      }
      const valuePrototype = safeObjectGetPrototypeOf(value3);
      const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;
      if (typeof className === "string") {
        const typedArray = value3;
        const valuesFromTypedArr = typedArray.values();
        return `${className}.from(${stringifyInternal(safeArrayFrom(valuesFromTypedArr), currentValues, getAsyncContent)})`;
      }
      break;
    }
  }
  try {
    return value3.toString();
  } catch (_a102) {
    return safeToString(value3);
  }
}
function stringify(value3) {
  return stringifyInternal(value3, [], () => ({ state: "unknown", value: void 0 }));
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/DecorateProperty.js
var safeDateNow2 = Date.now;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/reporter/ExecutionStatus.js
var ExecutionStatus;
(function(ExecutionStatus2) {
  ExecutionStatus2[ExecutionStatus2["Success"] = 0] = "Success";
  ExecutionStatus2[ExecutionStatus2["Skipped"] = -1] = "Skipped";
  ExecutionStatus2[ExecutionStatus2["Failure"] = 1] = "Failure";
})(ExecutionStatus || (ExecutionStatus = {}));

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/reporter/RunExecution.js
var RunExecution = class _RunExecution {
  constructor(verbosity, interruptedAsFailure) {
    this.verbosity = verbosity;
    this.interruptedAsFailure = interruptedAsFailure;
    this.isSuccess = () => this.pathToFailure == null;
    this.firstFailure = () => this.pathToFailure ? +safeSplit(this.pathToFailure, ":")[0] : -1;
    this.numShrinks = () => this.pathToFailure ? safeSplit(this.pathToFailure, ":").length - 1 : 0;
    this.rootExecutionTrees = [];
    this.currentLevelExecutionTrees = this.rootExecutionTrees;
    this.failure = null;
    this.numSkips = 0;
    this.numSuccesses = 0;
    this.interrupted = false;
  }
  appendExecutionTree(status3, value3) {
    const currentTree = { status: status3, value: value3, children: [] };
    this.currentLevelExecutionTrees.push(currentTree);
    return currentTree;
  }
  fail(value3, id3, failure) {
    if (this.verbosity >= VerbosityLevel.Verbose) {
      const currentTree = this.appendExecutionTree(ExecutionStatus.Failure, value3);
      this.currentLevelExecutionTrees = currentTree.children;
    }
    if (this.pathToFailure == null)
      this.pathToFailure = `${id3}`;
    else
      this.pathToFailure += `:${id3}`;
    this.value = value3;
    this.failure = failure;
  }
  skip(value3) {
    if (this.verbosity >= VerbosityLevel.VeryVerbose) {
      this.appendExecutionTree(ExecutionStatus.Skipped, value3);
    }
    if (this.pathToFailure == null) {
      ++this.numSkips;
    }
  }
  success(value3) {
    if (this.verbosity >= VerbosityLevel.VeryVerbose) {
      this.appendExecutionTree(ExecutionStatus.Success, value3);
    }
    if (this.pathToFailure == null) {
      ++this.numSuccesses;
    }
  }
  interrupt() {
    this.interrupted = true;
  }
  extractFailures() {
    if (this.isSuccess()) {
      return [];
    }
    const failures2 = [];
    let cursor = this.rootExecutionTrees;
    while (cursor.length > 0 && cursor[cursor.length - 1].status === ExecutionStatus.Failure) {
      const failureTree = cursor[cursor.length - 1];
      failures2.push(failureTree.value);
      cursor = failureTree.children;
    }
    return failures2;
  }
  toRunDetails(seed, basePath, maxSkips, qParams) {
    if (!this.isSuccess()) {
      return {
        failed: true,
        interrupted: this.interrupted,
        numRuns: this.firstFailure() + 1 - this.numSkips,
        numSkips: this.numSkips,
        numShrinks: this.numShrinks(),
        seed,
        counterexample: this.value,
        counterexamplePath: _RunExecution.mergePaths(basePath, this.pathToFailure),
        error: this.failure.errorMessage,
        errorInstance: this.failure.error,
        failures: this.extractFailures(),
        executionSummary: this.rootExecutionTrees,
        verbose: this.verbosity,
        runConfiguration: qParams.toParameters()
      };
    }
    const considerInterruptedAsFailure = this.interruptedAsFailure || this.numSuccesses === 0;
    const failed = this.numSkips > maxSkips || this.interrupted && considerInterruptedAsFailure;
    const out = {
      failed,
      interrupted: this.interrupted,
      numRuns: this.numSuccesses,
      numSkips: this.numSkips,
      numShrinks: 0,
      seed,
      counterexample: null,
      counterexamplePath: null,
      error: null,
      errorInstance: null,
      failures: [],
      executionSummary: this.rootExecutionTrees,
      verbose: this.verbosity,
      runConfiguration: qParams.toParameters()
    };
    return out;
  }
};
RunExecution.mergePaths = (offsetPath, path) => {
  if (offsetPath.length === 0)
    return path;
  const offsetItems = offsetPath.split(":");
  const remainingItems = path.split(":");
  const middle = +offsetItems[offsetItems.length - 1] + +remainingItems[0];
  return [...offsetItems.slice(0, offsetItems.length - 1), `${middle}`, ...remainingItems.slice(1)].join(":");
};

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/random/generator/Random.js
var Random = class _Random {
  constructor(sourceRng) {
    this.internalRng = sourceRng.clone();
  }
  clone() {
    return new _Random(this.internalRng);
  }
  next(bits) {
    return unsafeUniformIntDistribution(0, (1 << bits) - 1, this.internalRng);
  }
  nextBoolean() {
    return unsafeUniformIntDistribution(0, 1, this.internalRng) == 1;
  }
  nextInt(min5, max7) {
    return unsafeUniformIntDistribution(min5 == null ? _Random.MIN_INT : min5, max7 == null ? _Random.MAX_INT : max7, this.internalRng);
  }
  nextBigInt(min5, max7) {
    return unsafeUniformBigIntDistribution(min5, max7, this.internalRng);
  }
  nextArrayInt(min5, max7) {
    return unsafeUniformArrayIntDistribution(min5, max7, this.internalRng);
  }
  nextDouble() {
    const a = this.next(26);
    const b = this.next(27);
    return (a * _Random.DBL_FACTOR + b) * _Random.DBL_DIVISOR;
  }
  getState() {
    if ("getState" in this.internalRng && typeof this.internalRng.getState === "function") {
      return this.internalRng.getState();
    }
    return void 0;
  }
};
Random.MIN_INT = 2147483648 | 0;
Random.MAX_INT = 2147483647 | 0;
Random.DBL_FACTOR = Math.pow(2, 27);
Random.DBL_DIVISOR = Math.pow(2, -53);

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/StableArbitraryGeneratorCache.js
var safeArrayIsArray2 = Array.isArray;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BiasNumericRange.js
var safeMathFloor = Math.floor;
var safeMathLog2 = Math.log;
function integerLogLike(v) {
  return safeMathFloor(safeMathLog2(v) / safeMathLog2(2));
}
function biasNumericRange(min5, max7, logLike) {
  if (min5 === max7) {
    return [{ min: min5, max: max7 }];
  }
  if (min5 < 0 && max7 > 0) {
    const logMin = logLike(-min5);
    const logMax = logLike(max7);
    return [
      { min: -logMin, max: logMax },
      { min: max7 - logMax, max: max7 },
      { min: min5, max: min5 + logMin }
    ];
  }
  const logGap = logLike(max7 - min5);
  const arbCloseToMin = { min: min5, max: min5 + logGap };
  const arbCloseToMax = { min: max7 - logGap, max: max7 };
  return min5 < 0 ? [arbCloseToMax, arbCloseToMin] : [arbCloseToMin, arbCloseToMax];
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkInteger.js
var safeMathCeil = Math.ceil;
var safeMathFloor2 = Math.floor;
function halvePosInteger(n) {
  return safeMathFloor2(n / 2);
}
function halveNegInteger(n) {
  return safeMathCeil(n / 2);
}
function shrinkInteger(current2, target, tryTargetAsap) {
  const realGap = current2 - target;
  function* shrinkDecr() {
    let previous2 = tryTargetAsap ? void 0 : target;
    const gap = tryTargetAsap ? realGap : halvePosInteger(realGap);
    for (let toremove = gap; toremove > 0; toremove = halvePosInteger(toremove)) {
      const next4 = toremove === realGap ? target : current2 - toremove;
      yield new Value(next4, previous2);
      previous2 = next4;
    }
  }
  function* shrinkIncr() {
    let previous2 = tryTargetAsap ? void 0 : target;
    const gap = tryTargetAsap ? realGap : halveNegInteger(realGap);
    for (let toremove = gap; toremove < 0; toremove = halveNegInteger(toremove)) {
      const next4 = toremove === realGap ? target : current2 - toremove;
      yield new Value(next4, previous2);
      previous2 = next4;
    }
  }
  return realGap > 0 ? stream(shrinkDecr()) : stream(shrinkIncr());
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/IntegerArbitrary.js
var safeMathSign = Math.sign;
var safeNumberIsInteger = Number.isInteger;
var safeObjectIs = Object.is;
var IntegerArbitrary = class _IntegerArbitrary extends Arbitrary {
  constructor(min5, max7) {
    super();
    this.min = min5;
    this.max = max7;
  }
  generate(mrng, biasFactor) {
    const range4 = this.computeGenerateRange(mrng, biasFactor);
    return new Value(mrng.nextInt(range4.min, range4.max), void 0);
  }
  canShrinkWithoutContext(value3) {
    return typeof value3 === "number" && safeNumberIsInteger(value3) && !safeObjectIs(value3, -0) && this.min <= value3 && value3 <= this.max;
  }
  shrink(current2, context9) {
    if (!_IntegerArbitrary.isValidContext(current2, context9)) {
      const target = this.defaultTarget();
      return shrinkInteger(current2, target, true);
    }
    if (this.isLastChanceTry(current2, context9)) {
      return Stream.of(new Value(context9, void 0));
    }
    return shrinkInteger(current2, context9, false);
  }
  defaultTarget() {
    if (this.min <= 0 && this.max >= 0) {
      return 0;
    }
    return this.min < 0 ? this.max : this.min;
  }
  computeGenerateRange(mrng, biasFactor) {
    if (biasFactor === void 0 || mrng.nextInt(1, biasFactor) !== 1) {
      return { min: this.min, max: this.max };
    }
    const ranges = biasNumericRange(this.min, this.max, integerLogLike);
    if (ranges.length === 1) {
      return ranges[0];
    }
    const id3 = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
    return id3 < 0 ? ranges[0] : ranges[id3 + 1];
  }
  isLastChanceTry(current2, context9) {
    if (current2 > 0)
      return current2 === context9 + 1 && current2 > this.min;
    if (current2 < 0)
      return current2 === context9 - 1 && current2 < this.max;
    return false;
  }
  static isValidContext(current2, context9) {
    if (context9 === void 0) {
      return false;
    }
    if (typeof context9 !== "number") {
      throw new Error(`Invalid context type passed to IntegerArbitrary (#1)`);
    }
    if (context9 !== 0 && safeMathSign(current2) !== safeMathSign(context9)) {
      throw new Error(`Invalid context value passed to IntegerArbitrary (#2)`);
    }
    return true;
  }
};

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/integer.js
var safeNumberIsInteger2 = Number.isInteger;
function buildCompleteIntegerConstraints(constraints) {
  const min5 = constraints.min !== void 0 ? constraints.min : -2147483648;
  const max7 = constraints.max !== void 0 ? constraints.max : 2147483647;
  return { min: min5, max: max7 };
}
function integer2(constraints = {}) {
  const fullConstraints = buildCompleteIntegerConstraints(constraints);
  if (fullConstraints.min > fullConstraints.max) {
    throw new Error("fc.integer maximum value should be equal or greater than the minimum one");
  }
  if (!safeNumberIsInteger2(fullConstraints.min)) {
    throw new Error("fc.integer minimum value should be an integer");
  }
  if (!safeNumberIsInteger2(fullConstraints.max)) {
    throw new Error("fc.integer maximum value should be an integer");
  }
  return new IntegerArbitrary(fullConstraints.min, fullConstraints.max);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DepthContext.js
var depthContextCache = /* @__PURE__ */ new Map();
function getDepthContextFor(contextMeta) {
  if (contextMeta === void 0) {
    return { depth: 0 };
  }
  if (typeof contextMeta !== "string") {
    return contextMeta;
  }
  const cachedContext = safeMapGet(depthContextCache, contextMeta);
  if (cachedContext !== void 0) {
    return cachedContext;
  }
  const context9 = { depth: 0 };
  safeMapSet(depthContextCache, contextMeta, context9);
  return context9;
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/NoopSlicedGenerator.js
var NoopSlicedGenerator = class {
  constructor(arb, mrng, biasFactor) {
    this.arb = arb;
    this.mrng = mrng;
    this.biasFactor = biasFactor;
  }
  attemptExact() {
    return;
  }
  next() {
    return this.arb.generate(this.mrng, this.biasFactor);
  }
};

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SlicedBasedGenerator.js
var safeMathMin2 = Math.min;
var safeMathMax = Math.max;
var SlicedBasedGenerator = class {
  constructor(arb, mrng, slices, biasFactor) {
    this.arb = arb;
    this.mrng = mrng;
    this.slices = slices;
    this.biasFactor = biasFactor;
    this.activeSliceIndex = 0;
    this.nextIndexInSlice = 0;
    this.lastIndexInSlice = -1;
  }
  attemptExact(targetLength) {
    if (targetLength !== 0 && this.mrng.nextInt(1, this.biasFactor) === 1) {
      const eligibleIndices = [];
      for (let index = 0; index !== this.slices.length; ++index) {
        const slice = this.slices[index];
        if (slice.length === targetLength) {
          safePush(eligibleIndices, index);
        }
      }
      if (eligibleIndices.length === 0) {
        return;
      }
      this.activeSliceIndex = eligibleIndices[this.mrng.nextInt(0, eligibleIndices.length - 1)];
      this.nextIndexInSlice = 0;
      this.lastIndexInSlice = targetLength - 1;
    }
  }
  next() {
    if (this.nextIndexInSlice <= this.lastIndexInSlice) {
      return new Value(this.slices[this.activeSliceIndex][this.nextIndexInSlice++], void 0);
    }
    if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
      return this.arb.generate(this.mrng, this.biasFactor);
    }
    this.activeSliceIndex = this.mrng.nextInt(0, this.slices.length - 1);
    const slice = this.slices[this.activeSliceIndex];
    if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
      this.nextIndexInSlice = 1;
      this.lastIndexInSlice = slice.length - 1;
      return new Value(slice[0], void 0);
    }
    const rangeBoundaryA = this.mrng.nextInt(0, slice.length - 1);
    const rangeBoundaryB = this.mrng.nextInt(0, slice.length - 1);
    this.nextIndexInSlice = safeMathMin2(rangeBoundaryA, rangeBoundaryB);
    this.lastIndexInSlice = safeMathMax(rangeBoundaryA, rangeBoundaryB);
    return new Value(slice[this.nextIndexInSlice++], void 0);
  }
};

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSlicedGenerator.js
function buildSlicedGenerator(arb, mrng, slices, biasFactor) {
  if (biasFactor === void 0 || slices.length === 0 || mrng.nextInt(1, biasFactor) !== 1) {
    return new NoopSlicedGenerator(arb, mrng, biasFactor);
  }
  return new SlicedBasedGenerator(arb, mrng, slices, biasFactor);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayArbitrary.js
var safeMathFloor3 = Math.floor;
var safeMathLog3 = Math.log;
var safeMathMax2 = Math.max;
var safeArrayIsArray3 = Array.isArray;
function biasedMaxLength(minLength3, maxLength3) {
  if (minLength3 === maxLength3) {
    return minLength3;
  }
  return minLength3 + safeMathFloor3(safeMathLog3(maxLength3 - minLength3) / safeMathLog3(2));
}
var ArrayArbitrary = class _ArrayArbitrary extends Arbitrary {
  constructor(arb, minLength3, maxGeneratedLength, maxLength3, depthIdentifier, setBuilder, customSlices) {
    super();
    this.arb = arb;
    this.minLength = minLength3;
    this.maxGeneratedLength = maxGeneratedLength;
    this.maxLength = maxLength3;
    this.setBuilder = setBuilder;
    this.customSlices = customSlices;
    this.lengthArb = integer2({ min: minLength3, max: maxGeneratedLength });
    this.depthContext = getDepthContextFor(depthIdentifier);
  }
  preFilter(tab) {
    if (this.setBuilder === void 0) {
      return tab;
    }
    const s = this.setBuilder();
    for (let index = 0; index !== tab.length; ++index) {
      s.tryAdd(tab[index]);
    }
    return s.getData();
  }
  static makeItCloneable(vs, shrinkables) {
    vs[cloneMethod] = () => {
      const cloned = [];
      for (let idx = 0; idx !== shrinkables.length; ++idx) {
        safePush(cloned, shrinkables[idx].value);
      }
      this.makeItCloneable(cloned, shrinkables);
      return cloned;
    };
    return vs;
  }
  generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
    let numSkippedInRow = 0;
    const s = setBuilder();
    const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
    while (s.size() < N && numSkippedInRow < this.maxGeneratedLength) {
      const current2 = slicedGenerator.next();
      if (s.tryAdd(current2)) {
        numSkippedInRow = 0;
      } else {
        numSkippedInRow += 1;
      }
    }
    return s.getData();
  }
  safeGenerateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
    const depthImpact = safeMathMax2(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
    this.depthContext.depth += depthImpact;
    try {
      return this.generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems);
    } finally {
      this.depthContext.depth -= depthImpact;
    }
  }
  generateNItems(N, mrng, biasFactorItems) {
    const items = [];
    const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
    slicedGenerator.attemptExact(N);
    for (let index = 0; index !== N; ++index) {
      const current2 = slicedGenerator.next();
      safePush(items, current2);
    }
    return items;
  }
  safeGenerateNItems(N, mrng, biasFactorItems) {
    const depthImpact = safeMathMax2(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
    this.depthContext.depth += depthImpact;
    try {
      return this.generateNItems(N, mrng, biasFactorItems);
    } finally {
      this.depthContext.depth -= depthImpact;
    }
  }
  wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext, startIndex) {
    const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;
    let cloneable = false;
    const vs = [];
    const itemsContexts = [];
    for (let idx = 0; idx !== items.length; ++idx) {
      const s = items[idx];
      cloneable = cloneable || s.hasToBeCloned;
      safePush(vs, s.value);
      safePush(itemsContexts, s.context);
    }
    if (cloneable) {
      _ArrayArbitrary.makeItCloneable(vs, items);
    }
    const context9 = {
      shrunkOnce,
      lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== void 0 ? itemsRawLengthContext : void 0,
      itemsContexts,
      startIndex
    };
    return new Value(vs, context9);
  }
  generate(mrng, biasFactor) {
    const biasMeta = this.applyBias(mrng, biasFactor);
    const targetSize = biasMeta.size;
    const items = this.setBuilder !== void 0 ? this.safeGenerateNItemsNoDuplicates(this.setBuilder, targetSize, mrng, biasMeta.biasFactorItems) : this.safeGenerateNItems(targetSize, mrng, biasMeta.biasFactorItems);
    return this.wrapper(items, false, void 0, 0);
  }
  applyBias(mrng, biasFactor) {
    if (biasFactor === void 0) {
      return { size: this.lengthArb.generate(mrng, void 0).value };
    }
    if (this.minLength === this.maxGeneratedLength) {
      return { size: this.lengthArb.generate(mrng, void 0).value, biasFactorItems: biasFactor };
    }
    if (mrng.nextInt(1, biasFactor) !== 1) {
      return { size: this.lengthArb.generate(mrng, void 0).value };
    }
    if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxGeneratedLength) {
      return { size: this.lengthArb.generate(mrng, void 0).value, biasFactorItems: biasFactor };
    }
    const maxBiasedLength = biasedMaxLength(this.minLength, this.maxGeneratedLength);
    const targetSizeValue = integer2({ min: this.minLength, max: maxBiasedLength }).generate(mrng, void 0);
    return { size: targetSizeValue.value, biasFactorItems: biasFactor };
  }
  canShrinkWithoutContext(value3) {
    if (!safeArrayIsArray3(value3) || this.minLength > value3.length || value3.length > this.maxLength) {
      return false;
    }
    for (let index = 0; index !== value3.length; ++index) {
      if (!(index in value3)) {
        return false;
      }
      if (!this.arb.canShrinkWithoutContext(value3[index])) {
        return false;
      }
    }
    const filtered = this.preFilter(safeMap(value3, (item) => new Value(item, void 0)));
    return filtered.length === value3.length;
  }
  shrinkItemByItem(value3, safeContext, endIndex) {
    const shrinks = [];
    for (let index = safeContext.startIndex; index < endIndex; ++index) {
      safePush(shrinks, makeLazy(() => this.arb.shrink(value3[index], safeContext.itemsContexts[index]).map((v) => {
        const beforeCurrent = safeMap(safeSlice(value3, 0, index), (v2, i) => new Value(cloneIfNeeded(v2), safeContext.itemsContexts[i]));
        const afterCurrent = safeMap(safeSlice(value3, index + 1), (v2, i) => new Value(cloneIfNeeded(v2), safeContext.itemsContexts[i + index + 1]));
        return [
          [...beforeCurrent, v, ...afterCurrent],
          void 0,
          index
        ];
      })));
    }
    return Stream.nil().join(...shrinks);
  }
  shrinkImpl(value3, context9) {
    if (value3.length === 0) {
      return Stream.nil();
    }
    const safeContext = context9 !== void 0 ? context9 : { shrunkOnce: false, lengthContext: void 0, itemsContexts: [], startIndex: 0 };
    return this.lengthArb.shrink(value3.length, safeContext.lengthContext).drop(safeContext.shrunkOnce && safeContext.lengthContext === void 0 && value3.length > this.minLength + 1 ? 1 : 0).map((lengthValue) => {
      const sliceStart = value3.length - lengthValue.value;
      return [
        safeMap(safeSlice(value3, sliceStart), (v, index) => new Value(cloneIfNeeded(v), safeContext.itemsContexts[index + sliceStart])),
        lengthValue.context,
        0
      ];
    }).join(makeLazy(() => value3.length > this.minLength ? this.shrinkItemByItem(value3, safeContext, 1) : this.shrinkItemByItem(value3, safeContext, value3.length))).join(value3.length > this.minLength ? makeLazy(() => {
      const subContext = {
        shrunkOnce: false,
        lengthContext: void 0,
        itemsContexts: safeSlice(safeContext.itemsContexts, 1),
        startIndex: 0
      };
      return this.shrinkImpl(safeSlice(value3, 1), subContext).filter((v) => this.minLength <= v[0].length + 1).map((v) => {
        return [[new Value(cloneIfNeeded(value3[0]), safeContext.itemsContexts[0]), ...v[0]], void 0, 0];
      });
    }) : Stream.nil());
  }
  shrink(value3, context9) {
    return this.shrinkImpl(value3, context9).map((contextualValue) => this.wrapper(contextualValue[0], true, contextualValue[1], contextualValue[2]));
  }
};

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/MaxLengthFromMinLength.js
var safeMathFloor4 = Math.floor;
var safeMathMin3 = Math.min;
var MaxLengthUpperBound = 2147483647;
var orderedSize = ["xsmall", "small", "medium", "large", "xlarge"];
var orderedRelativeSize = ["-4", "-3", "-2", "-1", "=", "+1", "+2", "+3", "+4"];
var DefaultSize = "small";
function maxLengthFromMinLength(minLength3, size17) {
  switch (size17) {
    case "xsmall":
      return safeMathFloor4(1.1 * minLength3) + 1;
    case "small":
      return 2 * minLength3 + 10;
    case "medium":
      return 11 * minLength3 + 100;
    case "large":
      return 101 * minLength3 + 1e3;
    case "xlarge":
      return 1001 * minLength3 + 1e4;
    default:
      throw new Error(`Unable to compute lengths based on received size: ${size17}`);
  }
}
function relativeSizeToSize(size17, defaultSize) {
  const sizeInRelative = safeIndexOf(orderedRelativeSize, size17);
  if (sizeInRelative === -1) {
    return size17;
  }
  const defaultSizeInSize = safeIndexOf(orderedSize, defaultSize);
  if (defaultSizeInSize === -1) {
    throw new Error(`Unable to offset size based on the unknown defaulted one: ${defaultSize}`);
  }
  const resultingSizeInSize = defaultSizeInSize + sizeInRelative - 4;
  return resultingSizeInSize < 0 ? orderedSize[0] : resultingSizeInSize >= orderedSize.length ? orderedSize[orderedSize.length - 1] : orderedSize[resultingSizeInSize];
}
function maxGeneratedLengthFromSizeForArbitrary(size17, minLength3, maxLength3, specifiedMaxLength) {
  const { baseSize: defaultSize = DefaultSize, defaultSizeToMaxWhenMaxSpecified } = readConfigureGlobal() || {};
  const definedSize = size17 !== void 0 ? size17 : specifiedMaxLength && defaultSizeToMaxWhenMaxSpecified ? "max" : defaultSize;
  if (definedSize === "max") {
    return maxLength3;
  }
  const finalSize = relativeSizeToSize(definedSize, defaultSize);
  return safeMathMin3(maxLengthFromMinLength(minLength3, finalSize), maxLength3);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/array.js
function array5(arb, constraints = {}) {
  const size17 = constraints.size;
  const minLength3 = constraints.minLength || 0;
  const maxLengthOrUnset = constraints.maxLength;
  const depthIdentifier = constraints.depthIdentifier;
  const maxLength3 = maxLengthOrUnset !== void 0 ? maxLengthOrUnset : MaxLengthUpperBound;
  const specifiedMaxLength = maxLengthOrUnset !== void 0;
  const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size17, minLength3, maxLength3, specifiedMaxLength);
  const customSlices = constraints.experimentalCustomSlices || [];
  return new ArrayArbitrary(arb, minLength3, maxGeneratedLength, maxLength3, depthIdentifier, void 0, customSlices);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToCharString.js
var indexToCharStringMapper = String.fromCodePoint;
function indexToCharStringUnmapper(c) {
  if (typeof c !== "string") {
    throw new Error("Cannot unmap non-string");
  }
  if (c.length === 0 || c.length > 2) {
    throw new Error("Cannot unmap string with more or less than one character");
  }
  const c1 = safeCharCodeAt(c, 0);
  if (c.length === 1) {
    return c1;
  }
  const c2 = safeCharCodeAt(c, 1);
  if (c1 < 55296 || c1 > 56319 || c2 < 56320 || c2 > 57343) {
    throw new Error("Cannot unmap invalid surrogate pairs");
  }
  return c.codePointAt(0);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterArbitraryBuilder.js
function buildCharacterArbitrary(min5, max7, mapToCode, unmapFromCode) {
  return integer2({ min: min5, max: max7 }).map((n) => indexToCharStringMapper(mapToCode(n)), (c) => unmapFromCode(indexToCharStringUnmapper(c)));
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToPrintableIndex.js
function indexToPrintableIndexMapper(v) {
  if (v < 95)
    return v + 32;
  if (v <= 126)
    return v - 95;
  return v;
}
function indexToPrintableIndexUnmapper(v) {
  if (v >= 32 && v <= 126)
    return v - 32;
  if (v >= 0 && v <= 31)
    return v + 95;
  return v;
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/char.js
function identity5(v) {
  return v;
}
function char() {
  return buildCharacterArbitrary(32, 126, identity5, identity5);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/fullUnicode.js
var gapSize = 57343 + 1 - 55296;
function unicodeMapper(v) {
  if (v < 55296)
    return indexToPrintableIndexMapper(v);
  return v + gapSize;
}
function unicodeUnmapper(v) {
  if (v < 55296)
    return indexToPrintableIndexUnmapper(v);
  if (v <= 57343)
    return -1;
  return v - gapSize;
}
function fullUnicode() {
  return buildCharacterArbitrary(0, 1114111 - gapSize, unicodeMapper, unicodeUnmapper);
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/unicode.js
var gapSize2 = 57343 + 1 - 55296;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/context.js
var ContextImplem = class _ContextImplem {
  constructor() {
    this.receivedLogs = [];
  }
  log(data) {
    this.receivedLogs.push(data);
  }
  size() {
    return this.receivedLogs.length;
  }
  toString() {
    return JSON.stringify({ logs: this.receivedLogs });
  }
  [cloneMethod]() {
    return new _ContextImplem();
  }
};

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/TimeToDate.js
var safeNaN = Number.NaN;
var safeNumberIsNaN2 = Number.isNaN;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/date.js
var safeNumberIsNaN3 = Number.isNaN;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/CloneArbitrary.js
var safeIsArray = Array.isArray;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/StrictlyEqualSet.js
var safeNumberIsNaN4 = Number.isNaN;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/FrequencyArbitrary.js
var safePositiveInfinity2 = Number.POSITIVE_INFINITY;
var safeMaxSafeInteger = Number.MAX_SAFE_INTEGER;
var safeNumberIsInteger3 = Number.isInteger;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/nat.js
var safeNumberIsInteger4 = Number.isInteger;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterRangeArbitraryBuilder.js
var safeStringFromCharCode = String.fromCharCode;
function percentCharArbMapper(c) {
  const encoded = SencodeURIComponent(c);
  return c !== encoded ? encoded : `%${safeNumberToString(safeCharCodeAt(c, 0), 16)}`;
}
function percentCharArbUnmapper(value3) {
  if (typeof value3 !== "string") {
    throw new Error("Unsupported");
  }
  const decoded = decodeURIComponent(value3);
  return decoded;
}
var percentCharArb = fullUnicode().map(percentCharArbMapper, percentCharArbUnmapper);

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/GraphemeRangesHelpers.js
var safeStringFromCodePoint = String.fromCodePoint;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/AdapterArbitrary.js
var AdaptedValue = Symbol("adapted-value");

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleHelpers.js
var safeNegativeInfinity2 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity3 = Number.POSITIVE_INFINITY;
var safeEpsilon = Number.EPSILON;
var f64 = new Float64Array(1);
var u32 = new Uint32Array(f64.buffer, f64.byteOffset);

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatingOnlyHelpers.js
var safeNumberIsInteger5 = Number.isInteger;
var safeNegativeInfinity3 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity4 = Number.POSITIVE_INFINITY;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleOnlyHelpers.js
var safeNegativeInfinity4 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity5 = Number.POSITIVE_INFINITY;
var safeMaxValue = Number.MAX_VALUE;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/double.js
var safeNumberIsInteger6 = Number.isInteger;
var safeNumberIsNaN5 = Number.isNaN;
var safeNegativeInfinity5 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity6 = Number.POSITIVE_INFINITY;
var safeMaxValue2 = Number.MAX_VALUE;
var safeNaN2 = Number.NaN;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatHelpers.js
var safeNegativeInfinity6 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity7 = Number.POSITIVE_INFINITY;
var MIN_VALUE_32 = 2 ** -126 * 2 ** -23;
var MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);
var EPSILON_32 = 2 ** -23;
var f32 = new Float32Array(1);
var u322 = new Uint32Array(f32.buffer, f32.byteOffset);

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatOnlyHelpers.js
var safeNegativeInfinity7 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity8 = Number.POSITIVE_INFINITY;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/float.js
var safeNumberIsInteger7 = Number.isInteger;
var safeNumberIsNaN6 = Number.isNaN;
var safeNegativeInfinity8 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity9 = Number.POSITIVE_INFINITY;
var safeNaN3 = Number.NaN;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TextEscaper.js
function escapeForTemplateString(originalText) {
  return originalText.replace(/([$`\\])/g, "\\$1").replace(/\r/g, "\\r");
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/maxSafeInteger.js
var safeMinSafeInteger = Number.MIN_SAFE_INTEGER;
var safeMaxSafeInteger2 = Number.MAX_SAFE_INTEGER;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/maxSafeNat.js
var safeMaxSafeInteger3 = Number.MAX_SAFE_INTEGER;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/NatToStringifiedNat.js
var safeNumberParseInt = Number.parseInt;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/sparseArray.js
var safeArrayIsArray4 = SArray.isArray;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/PartialRecordArbitraryBuilder.js
var noKeyValue = Symbol("no-key");

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/SubarrayArbitrary.js
var safeArrayIsArray5 = Array.isArray;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/UintToBase32String.js
var encodeSymbolLookupTable = {
  10: "A",
  11: "B",
  12: "C",
  13: "D",
  14: "E",
  15: "F",
  16: "G",
  17: "H",
  18: "J",
  19: "K",
  20: "M",
  21: "N",
  22: "P",
  23: "Q",
  24: "R",
  25: "S",
  26: "T",
  27: "V",
  28: "W",
  29: "X",
  30: "Y",
  31: "Z"
};
function encodeSymbol(symbol4) {
  return symbol4 < 10 ? SString(symbol4) : encodeSymbolLookupTable[symbol4];
}
function pad(value3, paddingLength) {
  let extraPadding = "";
  while (value3.length + extraPadding.length < paddingLength) {
    extraPadding += "0";
  }
  return extraPadding + value3;
}
function smallUintToBase32StringMapper(num2) {
  let base32Str = "";
  for (let remaining = num2; remaining !== 0; ) {
    const next4 = remaining >> 5;
    const current2 = remaining - (next4 << 5);
    base32Str = encodeSymbol(current2) + base32Str;
    remaining = next4;
  }
  return base32Str;
}
function uintToBase32StringMapper(num2, paddingLength) {
  const head8 = ~~(num2 / 1073741824);
  const tail2 = num2 & 1073741823;
  return pad(smallUintToBase32StringMapper(head8), paddingLength - 6) + pad(smallUintToBase32StringMapper(tail2), 6);
}
function paddedUintToBase32StringMapper(paddingLength) {
  return function padded(num2) {
    return uintToBase32StringMapper(num2, paddingLength);
  };
}

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/ulid.js
var padded10Mapper = paddedUintToBase32StringMapper(10);
var padded8Mapper = paddedUintToBase32StringMapper(8);

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/model/commands/CommandsIterable.js
var CommandsIterable = class _CommandsIterable {
  constructor(commands2, metadataForReplay) {
    this.commands = commands2;
    this.metadataForReplay = metadataForReplay;
  }
  [Symbol.iterator]() {
    return this.commands[Symbol.iterator]();
  }
  [cloneMethod]() {
    return new _CommandsIterable(this.commands.map((c) => c.clone()), this.metadataForReplay);
  }
  toString() {
    const serializedCommands = this.commands.filter((c) => c.hasRan).map((c) => c.toString()).join(",");
    const metadata = this.metadataForReplay();
    return metadata.length !== 0 ? `${serializedCommands} /*${metadata}*/` : serializedCommands;
  }
};

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SchedulerImplem.js
var defaultSchedulerAct = (f) => f();
var SchedulerImplem = class _SchedulerImplem {
  constructor(act, taskSelector) {
    this.act = act;
    this.taskSelector = taskSelector;
    this.lastTaskId = 0;
    this.sourceTaskSelector = taskSelector.clone();
    this.scheduledTasks = [];
    this.triggeredTasks = [];
    this.scheduledWatchers = [];
  }
  static buildLog(reportItem) {
    return `[task\${${reportItem.taskId}}] ${reportItem.label.length !== 0 ? `${reportItem.schedulingType}::${reportItem.label}` : reportItem.schedulingType} ${reportItem.status}${reportItem.outputValue !== void 0 ? ` with value ${escapeForTemplateString(reportItem.outputValue)}` : ""}`;
  }
  log(schedulingType, taskId, label, metadata, status3, data) {
    this.triggeredTasks.push({
      status: status3,
      schedulingType,
      taskId,
      label,
      metadata,
      outputValue: data !== void 0 ? stringify(data) : void 0
    });
  }
  scheduleInternal(schedulingType, label, task, metadata, customAct, thenTaskToBeAwaited) {
    let trigger = null;
    const taskId = ++this.lastTaskId;
    const scheduledPromise = new Promise((resolve, reject) => {
      trigger = () => {
        (thenTaskToBeAwaited ? task.then(() => thenTaskToBeAwaited()) : task).then((data) => {
          this.log(schedulingType, taskId, label, metadata, "resolved", data);
          return resolve(data);
        }, (err) => {
          this.log(schedulingType, taskId, label, metadata, "rejected", err);
          return reject(err);
        });
      };
    });
    this.scheduledTasks.push({
      original: task,
      scheduled: scheduledPromise,
      trigger,
      schedulingType,
      taskId,
      label,
      metadata,
      customAct
    });
    if (this.scheduledWatchers.length !== 0) {
      this.scheduledWatchers[0]();
    }
    return scheduledPromise;
  }
  schedule(task, label, metadata, customAct) {
    return this.scheduleInternal("promise", label || "", task, metadata, customAct || defaultSchedulerAct);
  }
  scheduleFunction(asyncFunction, customAct) {
    return (...args2) => this.scheduleInternal("function", `${asyncFunction.name}(${args2.map(stringify).join(",")})`, asyncFunction(...args2), void 0, customAct || defaultSchedulerAct);
  }
  scheduleSequence(sequenceBuilders, customAct) {
    const status3 = { done: false, faulty: false };
    const dummyResolvedPromise = { then: (f) => f() };
    let resolveSequenceTask = () => {
    };
    const sequenceTask = new Promise((resolve) => resolveSequenceTask = resolve);
    sequenceBuilders.reduce((previouslyScheduled, item) => {
      const [builder, label, metadata] = typeof item === "function" ? [item, item.name, void 0] : [item.builder, item.label, item.metadata];
      return previouslyScheduled.then(() => {
        const scheduled = this.scheduleInternal("sequence", label, dummyResolvedPromise, metadata, customAct || defaultSchedulerAct, () => builder());
        scheduled.catch(() => {
          status3.faulty = true;
          resolveSequenceTask();
        });
        return scheduled;
      });
    }, dummyResolvedPromise).then(() => {
      status3.done = true;
      resolveSequenceTask();
    }, () => {
    });
    return Object.assign(status3, {
      task: Promise.resolve(sequenceTask).then(() => {
        return { done: status3.done, faulty: status3.faulty };
      })
    });
  }
  count() {
    return this.scheduledTasks.length;
  }
  internalWaitOne() {
    if (this.scheduledTasks.length === 0) {
      throw new Error("No task scheduled");
    }
    const taskIndex = this.taskSelector.nextTaskIndex(this.scheduledTasks);
    const [scheduledTask] = this.scheduledTasks.splice(taskIndex, 1);
    return scheduledTask.customAct(async () => {
      scheduledTask.trigger();
      try {
        await scheduledTask.scheduled;
      } catch (_err) {
      }
    });
  }
  async waitOne(customAct) {
    const waitAct = customAct || defaultSchedulerAct;
    await this.act(() => waitAct(async () => await this.internalWaitOne()));
  }
  async waitAll(customAct) {
    while (this.scheduledTasks.length > 0) {
      await this.waitOne(customAct);
    }
  }
  async waitFor(unscheduledTask, customAct) {
    let taskResolved = false;
    let awaiterPromise = null;
    const awaiter = async () => {
      while (!taskResolved && this.scheduledTasks.length > 0) {
        await this.waitOne(customAct);
      }
      awaiterPromise = null;
    };
    const handleNotified = () => {
      if (awaiterPromise !== null) {
        return;
      }
      awaiterPromise = Promise.resolve().then(awaiter);
    };
    const clearAndReplaceWatcher = () => {
      const handleNotifiedIndex = this.scheduledWatchers.indexOf(handleNotified);
      if (handleNotifiedIndex !== -1) {
        this.scheduledWatchers.splice(handleNotifiedIndex, 1);
      }
      if (handleNotifiedIndex === 0 && this.scheduledWatchers.length !== 0) {
        this.scheduledWatchers[0]();
      }
    };
    const rewrappedTask = unscheduledTask.then((ret) => {
      taskResolved = true;
      if (awaiterPromise === null) {
        clearAndReplaceWatcher();
        return ret;
      }
      return awaiterPromise.then(() => {
        clearAndReplaceWatcher();
        return ret;
      });
    }, (err) => {
      taskResolved = true;
      if (awaiterPromise === null) {
        clearAndReplaceWatcher();
        throw err;
      }
      return awaiterPromise.then(() => {
        clearAndReplaceWatcher();
        throw err;
      });
    });
    if (this.scheduledTasks.length > 0 && this.scheduledWatchers.length === 0) {
      handleNotified();
    }
    this.scheduledWatchers.push(handleNotified);
    return rewrappedTask;
  }
  report() {
    return [
      ...this.triggeredTasks,
      ...this.scheduledTasks.map((t) => ({
        status: "pending",
        schedulingType: t.schedulingType,
        taskId: t.taskId,
        label: t.label,
        metadata: t.metadata
      }))
    ];
  }
  toString() {
    return "schedulerFor()`\n" + this.report().map(_SchedulerImplem.buildLog).map((log3) => `-> ${log3}`).join("\n") + "`";
  }
  [cloneMethod]() {
    return new _SchedulerImplem(this.act, this.sourceTaskSelector);
  }
};

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ReadRegex.js
var TokenizerBlockMode;
(function(TokenizerBlockMode2) {
  TokenizerBlockMode2[TokenizerBlockMode2["Full"] = 0] = "Full";
  TokenizerBlockMode2[TokenizerBlockMode2["Character"] = 1] = "Character";
})(TokenizerBlockMode || (TokenizerBlockMode = {}));

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TokenizeRegex.js
var safeStringFromCodePoint2 = String.fromCodePoint;

// ../../node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/stringMatching.js
var safeStringFromCodePoint3 = String.fromCodePoint;
var wordChars = [..."abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"];
var digitChars = [..."0123456789"];
var spaceChars = [..." 	\r\n\v\f"];
var newLineChars = [..."\r\n"];
var terminatorChars = [...""];
var newLineAndTerminatorChars = [...newLineChars, ...terminatorChars];
var defaultChar = char();

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/schema/util.js
var getKeysForIndexSignature = (input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature(input, parameter.from);
  }
};
var ownKeys = (o) => Object.keys(o).concat(Object.getOwnPropertySymbols(o));
var memoizeThunk = (f) => {
  let done12 = false;
  let a;
  return () => {
    if (done12) {
      return a;
    }
    a = f();
    done12 = true;
    return a;
  };
};
var formatDate = (date3) => {
  try {
    return date3.toISOString();
  } catch {
    return String(date3);
  }
};
var formatUnknown = (u, checkCircular = true) => {
  if (Array.isArray(u)) {
    return `[${u.map((i) => formatUnknown(i, checkCircular)).join(",")}]`;
  }
  if (isDate(u)) {
    return formatDate(u);
  }
  if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString) {
    return u["toString"]();
  }
  if (isString(u)) {
    return JSON.stringify(u);
  }
  if (isNumber(u) || u == null || isBoolean(u) || isSymbol(u)) {
    return String(u);
  }
  if (isBigInt(u)) {
    return String(u) + "n";
  }
  if (isIterable(u)) {
    return `${u.constructor.name}(${formatUnknown(Array.from(u), checkCircular)})`;
  }
  try {
    if (checkCircular) {
      JSON.stringify(u);
    }
    const pojo = `{${ownKeys(u).map((k) => `${isString(k) ? JSON.stringify(k) : String(k)}:${formatUnknown(u[k], false)}`).join(",")}}`;
    const name = u.constructor.name;
    return u.constructor !== Object.prototype.constructor ? `${name}(${pojo})` : pojo;
  } catch {
    return "<circular structure>";
  }
};
var formatPropertyKey = (name) => typeof name === "string" ? JSON.stringify(name) : String(name);
var isNonEmpty6 = (x) => Array.isArray(x);
var isSingle = (x) => !Array.isArray(x);
var formatPathKey = (key) => `[${formatPropertyKey(key)}]`;
var formatPath = (path) => isNonEmpty6(path) ? path.map(formatPathKey).join("") : formatPathKey(path);

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/schema/errors.js
var getErrorMessage = (reason, details, path, ast) => {
  let out = reason;
  if (path && isNonEmptyReadonlyArray(path)) {
    out += `
at path: ${formatPath(path)}`;
  }
  if (details !== void 0) {
    out += `
details: ${details}`;
  }
  if (ast) {
    out += `
schema (${ast._tag}): ${ast}`;
  }
  return out;
};
var getInvalidArgumentErrorMessage = (details) => getErrorMessage("Invalid Argument", details);
var getUnsupportedSchemaErrorMessage = (details, path, ast) => getErrorMessage("Unsupported schema", details, path, ast);
var getMissingAnnotationErrorMessage = (details, path, ast) => getErrorMessage("Missing annotation", details, path, ast);
var getEquivalenceUnsupportedErrorMessage = (ast, path) => getUnsupportedSchemaErrorMessage("Cannot build an Equivalence", path, ast);
var getJSONSchemaMissingAnnotationErrorMessage = (path, ast) => getMissingAnnotationErrorMessage(`Generating a JSON Schema for this schema requires a "jsonSchema" annotation`, path, ast);
var getJSONSchemaMissingIdentifierAnnotationErrorMessage = (path, ast) => getMissingAnnotationErrorMessage(`Generating a JSON Schema for this schema requires an "identifier" annotation`, path, ast);
var getJSONSchemaUnsupportedPostRestElementsErrorMessage = (path) => getErrorMessage("Generating a JSON Schema for post-rest elements is not currently supported. You're welcome to contribute by submitting a Pull Request", void 0, path);
var getJSONSchemaUnsupportedKeyErrorMessage = (key, path) => getErrorMessage("Unsupported key", `Cannot encode ${formatPropertyKey(key)} key to JSON Schema`, path);
var getSchemaExtendErrorMessage = (x, y, path) => getErrorMessage("Unsupported schema or overlapping types", `cannot extend ${x} with ${y}`, path);
var getSchemaUnsupportedLiteralSpanErrorMessage = (ast) => getErrorMessage("Unsupported template literal span", void 0, void 0, ast);
var getASTUnsupportedSchemaErrorMessage = (ast) => getUnsupportedSchemaErrorMessage(void 0, void 0, ast);
var getASTUnsupportedKeySchemaErrorMessage = (ast) => getErrorMessage("Unsupported key schema", void 0, void 0, ast);
var getASTUnsupportedLiteralErrorMessage = (literal2) => getErrorMessage("Unsupported literal", `literal value: ${formatUnknown(literal2)}`);
var getASTDuplicateIndexSignatureErrorMessage = (type) => getErrorMessage("Duplicate index signature", `${type} index signature`);
var getASTIndexSignatureParameterErrorMessage = /* @__PURE__ */ getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
var getASTRequiredElementFollowinAnOptionalElementErrorMessage = /* @__PURE__ */ getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
var getASTDuplicatePropertySignatureTransformationErrorMessage = (key) => getErrorMessage("Duplicate property signature transformation", `Duplicate key ${formatUnknown(key)}`);
var getASTUnsupportedRenameSchemaErrorMessage = (ast) => getUnsupportedSchemaErrorMessage(void 0, void 0, ast);
var getASTDuplicatePropertySignatureErrorMessage = (key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`);

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/internal/schema/schemaId.js
var DateFromSelfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/DateFromSelf");
var GreaterThanSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThan");
var GreaterThanOrEqualToSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanOrEqualTo");
var LessThanSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThan");
var LessThanOrEqualToSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanOrEqualTo");
var IntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Int");
var NonNaNSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/NonNaN");
var FiniteSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Finite");
var JsonNumberSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/JsonNumber");
var BetweenSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Between");
var GreaterThanBigintSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanBigint");
var GreaterThanOrEqualToBigIntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanOrEqualToBigint");
var LessThanBigIntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanBigint");
var LessThanOrEqualToBigIntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanOrEqualToBigint");
var BetweenBigintSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenBigint");
var MinLengthSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MinLength");
var MaxLengthSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MaxLength");
var LengthSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Length");
var MinItemsSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MinItems");
var MaxItemsSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MaxItems");
var ItemsCountSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ItemsCount");

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/SchemaAST.js
var BrandAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Brand");
var SchemaIdAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/SchemaId");
var MessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Message");
var MissingMessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/MissingMessage");
var IdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Identifier");
var TitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Title");
var AutoTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/AutoTitle");
var DescriptionAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Description");
var ExamplesAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Examples");
var DefaultAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Default");
var JSONSchemaAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONSchema");
var ArbitraryAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Arbitrary");
var PrettyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Pretty");
var EquivalenceAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Equivalence");
var DocumentationAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Documentation");
var ConcurrencyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Concurrency");
var BatchingAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Batching");
var ParseIssueTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseIssueTitle");
var ParseOptionsAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseOptions");
var DecodingFallbackAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/DecodingFallback");
var SurrogateAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Surrogate");
var StableFilterAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/StableFilter");
var getAnnotation = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some2(annotated.annotations[key]) : none2());
var getBrandAnnotation = /* @__PURE__ */ getAnnotation(BrandAnnotationId);
var getMessageAnnotation = /* @__PURE__ */ getAnnotation(MessageAnnotationId);
var getMissingMessageAnnotation = /* @__PURE__ */ getAnnotation(MissingMessageAnnotationId);
var getTitleAnnotation = /* @__PURE__ */ getAnnotation(TitleAnnotationId);
var getAutoTitleAnnotation = /* @__PURE__ */ getAnnotation(AutoTitleAnnotationId);
var getIdentifierAnnotation = /* @__PURE__ */ getAnnotation(IdentifierAnnotationId);
var getDescriptionAnnotation = /* @__PURE__ */ getAnnotation(DescriptionAnnotationId);
var getExamplesAnnotation = /* @__PURE__ */ getAnnotation(ExamplesAnnotationId);
var getDefaultAnnotation = /* @__PURE__ */ getAnnotation(DefaultAnnotationId);
var getJSONSchemaAnnotation = /* @__PURE__ */ getAnnotation(JSONSchemaAnnotationId);
var getConcurrencyAnnotation = /* @__PURE__ */ getAnnotation(ConcurrencyAnnotationId);
var getBatchingAnnotation = /* @__PURE__ */ getAnnotation(BatchingAnnotationId);
var getParseIssueTitleAnnotation = /* @__PURE__ */ getAnnotation(ParseIssueTitleAnnotationId);
var getParseOptionsAnnotation = /* @__PURE__ */ getAnnotation(ParseOptionsAnnotationId);
var getDecodingFallbackAnnotation = /* @__PURE__ */ getAnnotation(DecodingFallbackAnnotationId);
var getSurrogateAnnotation = /* @__PURE__ */ getAnnotation(SurrogateAnnotationId);
var getStableFilterAnnotation = /* @__PURE__ */ getAnnotation(StableFilterAnnotationId);
var hasStableFilter = (annotated) => exists(getStableFilterAnnotation(annotated), (b) => b === true);
var JSONIdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONIdentifier");
var getJSONIdentifierAnnotation = /* @__PURE__ */ getAnnotation(JSONIdentifierAnnotationId);
var getJSONIdentifier = (annotated) => orElse(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
var ParseJsonSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/ParseJson");
var Declaration = class {
  constructor(typeParameters, decodeUnknown6, encodeUnknown5, annotations5 = {}) {
    __publicField(this, "typeParameters");
    __publicField(this, "decodeUnknown");
    __publicField(this, "encodeUnknown");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Declaration");
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown6;
    this.encodeUnknown = encodeUnknown5;
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse3(getExpected(this), () => "<declaration schema>");
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var createASTGuard = (tag3) => (ast) => ast._tag === tag3;
var isDeclaration = /* @__PURE__ */ createASTGuard("Declaration");
var Literal = class {
  constructor(literal2, annotations5 = {}) {
    __publicField(this, "literal");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Literal");
    this.literal = literal2;
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse3(getExpected(this), () => formatUnknown(this.literal));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isLiteral = /* @__PURE__ */ createASTGuard("Literal");
var $null = /* @__PURE__ */ new Literal(null);
var UniqueSymbol = class {
  constructor(symbol4, annotations5 = {}) {
    __publicField(this, "symbol");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "UniqueSymbol");
    this.symbol = symbol4;
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse3(getExpected(this), () => formatUnknown(this.symbol));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isUniqueSymbol = /* @__PURE__ */ createASTGuard("UniqueSymbol");
var UndefinedKeyword = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "UndefinedKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var undefinedKeyword = /* @__PURE__ */ new UndefinedKeyword({
  [TitleAnnotationId]: "undefined"
});
var VoidKeyword = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "VoidKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var voidKeyword = /* @__PURE__ */ new VoidKeyword({
  [TitleAnnotationId]: "void"
});
var NeverKeyword = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "NeverKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var neverKeyword = /* @__PURE__ */ new NeverKeyword({
  [TitleAnnotationId]: "never"
});
var isNeverKeyword = /* @__PURE__ */ createASTGuard("NeverKeyword");
var UnknownKeyword = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "UnknownKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var unknownKeyword = /* @__PURE__ */ new UnknownKeyword({
  [TitleAnnotationId]: "unknown"
});
var AnyKeyword = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "AnyKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var anyKeyword = /* @__PURE__ */ new AnyKeyword({
  [TitleAnnotationId]: "any"
});
var StringKeyword = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "StringKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var stringKeyword = /* @__PURE__ */ new StringKeyword({
  [TitleAnnotationId]: "string",
  [DescriptionAnnotationId]: "a string"
});
var isStringKeyword = /* @__PURE__ */ createASTGuard("StringKeyword");
var NumberKeyword = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "NumberKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var numberKeyword = /* @__PURE__ */ new NumberKeyword({
  [TitleAnnotationId]: "number",
  [DescriptionAnnotationId]: "a number"
});
var isNumberKeyword = /* @__PURE__ */ createASTGuard("NumberKeyword");
var BooleanKeyword = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "BooleanKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var booleanKeyword = /* @__PURE__ */ new BooleanKeyword({
  [TitleAnnotationId]: "boolean",
  [DescriptionAnnotationId]: "a boolean"
});
var isBooleanKeyword = /* @__PURE__ */ createASTGuard("BooleanKeyword");
var BigIntKeyword = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "BigIntKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var bigIntKeyword = /* @__PURE__ */ new BigIntKeyword({
  [TitleAnnotationId]: "bigint",
  [DescriptionAnnotationId]: "a bigint"
});
var SymbolKeyword = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "SymbolKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var symbolKeyword = /* @__PURE__ */ new SymbolKeyword({
  [TitleAnnotationId]: "symbol",
  [DescriptionAnnotationId]: "a symbol"
});
var isSymbolKeyword = /* @__PURE__ */ createASTGuard("SymbolKeyword");
var ObjectKeyword = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "ObjectKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var objectKeyword = /* @__PURE__ */ new ObjectKeyword({
  [TitleAnnotationId]: "object",
  [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
});
var Enums = class {
  constructor(enums, annotations5 = {}) {
    __publicField(this, "enums");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Enums");
    this.enums = enums;
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse3(getExpected(this), () => `<enum ${this.enums.length} value(s): ${this.enums.map(([_, value3]) => JSON.stringify(value3)).join(" | ")}>`);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      enums: this.enums,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isEnums = /* @__PURE__ */ createASTGuard("Enums");
var isTemplateLiteralSpanType = (ast) => {
  switch (ast._tag) {
    case "Literal":
    case "NumberKeyword":
    case "StringKeyword":
    case "TemplateLiteral":
      return true;
    case "Union":
      return ast.types.every(isTemplateLiteralSpanType);
  }
  return false;
};
var templateLiteralSpanUnionTypeToString = (type) => {
  switch (type._tag) {
    case "Literal":
      return JSON.stringify(String(type.literal));
    case "StringKeyword":
      return "string";
    case "NumberKeyword":
      return "number";
    case "TemplateLiteral":
      return String(type);
    case "Union":
      return type.types.map(templateLiteralSpanUnionTypeToString).join(" | ");
  }
};
var templateLiteralSpanTypeToString = (type) => {
  switch (type._tag) {
    case "Literal":
      return String(type.literal);
    case "StringKeyword":
      return "${string}";
    case "NumberKeyword":
      return "${number}";
    case "TemplateLiteral":
      return "${" + String(type) + "}";
    case "Union":
      return "${" + type.types.map(templateLiteralSpanUnionTypeToString).join(" | ") + "}";
  }
};
var TemplateLiteralSpan = class {
  constructor(type, literal2) {
    __publicField(this, "literal");
    /**
     * @since 3.10.0
     */
    __publicField(this, "type");
    this.literal = literal2;
    if (isTemplateLiteralSpanType(type)) {
      this.type = type;
    } else {
      throw new Error(getSchemaUnsupportedLiteralSpanErrorMessage(type));
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return templateLiteralSpanTypeToString(this.type) + this.literal;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      literal: this.literal
    };
  }
};
var TemplateLiteral = class {
  constructor(head8, spans, annotations5 = {}) {
    __publicField(this, "head");
    __publicField(this, "spans");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "TemplateLiteral");
    this.head = head8;
    this.spans = spans;
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse3(getExpected(this), () => formatTemplateLiteral(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      head: this.head,
      spans: this.spans.map((span4) => span4.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatTemplateLiteral = (ast) => "`" + ast.head + ast.spans.map(String).join("") + "`";
var isTemplateLiteral = /* @__PURE__ */ createASTGuard("TemplateLiteral");
var Type = class {
  constructor(type, annotations5 = {}) {
    __publicField(this, "type");
    __publicField(this, "annotations");
    this.type = type;
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return String(this.type);
  }
};
var OptionalType = class extends Type {
  constructor(type, isOptional, annotations5 = {}) {
    super(type, annotations5);
    __publicField(this, "isOptional");
    this.isOptional = isOptional;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
};
var getRestASTs = (rest) => rest.map((annotatedAST) => annotatedAST.type);
var TupleType = class {
  constructor(elements, rest, isReadonly, annotations5 = {}) {
    __publicField(this, "elements");
    __publicField(this, "rest");
    __publicField(this, "isReadonly");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "TupleType");
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations5;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse3(getExpected(this), () => formatTuple(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map((e) => e.toJSON()),
      rest: this.rest.map((ast) => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatTuple = (ast) => {
  const formattedElements = ast.elements.map(String).join(", ");
  return matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head8, tail2) => {
      const formattedHead = String(head8);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail2.length > 0) {
        const formattedTail = tail2.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
};
var PropertySignature = class extends OptionalType {
  constructor(name, type, isOptional, isReadonly, annotations5) {
    super(type, isOptional, annotations5);
    __publicField(this, "name");
    __publicField(this, "isReadonly");
    this.name = name;
    this.isReadonly = isReadonly;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter(ast.from);
  }
  return false;
};
var IndexSignature = class {
  constructor(parameter, type, isReadonly) {
    __publicField(this, "type");
    __publicField(this, "isReadonly");
    /**
     * @since 3.10.0
     */
    __publicField(this, "parameter");
    this.type = type;
    this.isReadonly = isReadonly;
    if (isParameter(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(getASTIndexSignatureParameterErrorMessage);
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
};
var TypeLiteral = class {
  constructor(propertySignatures, indexSignatures, annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "TypeLiteral");
    /**
     * @since 3.10.0
     */
    __publicField(this, "propertySignatures");
    /**
     * @since 3.10.0
     */
    __publicField(this, "indexSignatures");
    this.annotations = annotations5;
    const keys6 = {};
    for (let i = 0; i < propertySignatures.length; i++) {
      const name = propertySignatures[i].name;
      if (Object.prototype.hasOwnProperty.call(keys6, name)) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
      }
      keys6[name] = null;
    }
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i = 0; i < indexSignatures.length; i++) {
      const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
      if (isStringKeyword(encodedParameter)) {
        if (parameters.string) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword(encodedParameter)) {
        if (parameters.symbol) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = propertySignatures;
    this.indexSignatures = indexSignatures;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse3(getExpected(this), () => formatTypeLiteral(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatIndexSignatures = (iss) => iss.map(String).join("; ");
var formatTypeLiteral = (ast) => {
  if (ast.propertySignatures.length > 0) {
    const pss = ast.propertySignatures.map(String).join("; ");
    if (ast.indexSignatures.length > 0) {
      return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return `{ ${pss} }`;
    }
  } else {
    if (ast.indexSignatures.length > 0) {
      return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return "{}";
    }
  }
};
var isTypeLiteral = /* @__PURE__ */ createASTGuard("TypeLiteral");
var sortCandidates = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput2(Order2, (ast) => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
var literalMap = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
var flatten15 = (candidates) => flatMap2(candidates, (ast) => isUnion(ast) ? flatten15(ast.types) : [ast]);
var unify = (candidates) => {
  const cs = sortCandidates(candidates);
  const out = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword];
      case "UnknownKeyword":
        return [unknownKeyword];
      // uniques
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword": {
        if (!uniques[ast._tag]) {
          uniques[ast._tag] = ast;
          out.push(ast);
        }
        break;
      }
      case "Literal": {
        const type = typeof ast.literal;
        switch (type) {
          case "string":
          case "number":
          case "bigint":
          case "boolean": {
            const _tag = literalMap[type];
            if (!uniques[_tag] && !literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
          // null
          case "object": {
            if (!literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
        }
        break;
      }
      case "UniqueSymbol": {
        if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
          literals.push(ast.symbol);
          out.push(ast);
        }
        break;
      }
      case "TupleType": {
        if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          if (!uniques["{}"]) {
            uniques["{}"] = ast;
            out.push(ast);
          }
        } else if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      default:
        out.push(ast);
    }
  }
  return out;
};
var _Union = class _Union {
  constructor(types, annotations5 = {}) {
    __publicField(this, "types");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Union");
    this.types = types;
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse3(getExpected(this), () => this.types.map(String).join(" | "));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
__publicField(_Union, "make", (types, annotations5) => {
  return isMembers(types) ? new _Union(types, annotations5) : types.length === 1 ? types[0] : neverKeyword;
});
/** @internal */
__publicField(_Union, "unify", (candidates, annotations5) => {
  return _Union.make(unify(flatten15(candidates)), annotations5);
});
var Union = _Union;
var mapMembers = (members, f) => members.map(f);
var isMembers = (as13) => as13.length > 1;
var isUnion = /* @__PURE__ */ createASTGuard("Union");
var toJSONMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => /* @__PURE__ */ new WeakMap());
var Suspend = class {
  constructor(f, annotations5 = {}) {
    __publicField(this, "f");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Suspend");
    this.f = f;
    this.annotations = annotations5;
    this.f = memoizeThunk(f);
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getExpected(this).pipe(orElse(() => flatMap(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse3(() => "<suspended schema>"));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    const ast = this.f();
    let out = toJSONMemoMap.get(ast);
    if (out) {
      return out;
    }
    toJSONMemoMap.set(ast, {
      _tag: this._tag
    });
    out = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
    toJSONMemoMap.set(ast, out);
    return out;
  }
};
var Refinement = class {
  constructor(from, filter14, annotations5 = {}) {
    __publicField(this, "from");
    __publicField(this, "filter");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Refinement");
    this.from = from;
    this.filter = filter14;
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getIdentifierAnnotation(this).pipe(getOrElse3(() => match2(getOrElseExpected(this), {
      onNone: () => `{ ${this.from} | filter }`,
      onSome: (expected) => isRefinement(this.from) ? String(this.from) + " & " + expected : expected
    })));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isRefinement = /* @__PURE__ */ createASTGuard("Refinement");
var defaultParseOption = {};
var Transformation = class {
  constructor(from, to, transformation, annotations5 = {}) {
    __publicField(this, "from");
    __publicField(this, "to");
    __publicField(this, "transformation");
    __publicField(this, "annotations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Transformation");
    this.from = from;
    this.to = to;
    this.transformation = transformation;
    this.annotations = annotations5;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse3(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isTransformation = /* @__PURE__ */ createASTGuard("Transformation");
var FinalTransformation = class {
  constructor(decode7, encode6) {
    __publicField(this, "decode");
    __publicField(this, "encode");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "FinalTransformation");
    this.decode = decode7;
    this.encode = encode6;
  }
};
var createTransformationGuard = (tag3) => (ast) => ast._tag === tag3;
var ComposeTransformation = class {
  constructor() {
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "ComposeTransformation");
  }
};
var composeTransformation = /* @__PURE__ */ new ComposeTransformation();
var PropertySignatureTransformation = class {
  constructor(from, to, decode7, encode6) {
    __publicField(this, "from");
    __publicField(this, "to");
    __publicField(this, "decode");
    __publicField(this, "encode");
    this.from = from;
    this.to = to;
    this.decode = decode7;
    this.encode = encode6;
  }
};
var isRenamingPropertySignatureTransformation = (t) => t.decode === identity && t.encode === identity;
var TypeLiteralTransformation = class {
  constructor(propertySignatureTransformations) {
    __publicField(this, "propertySignatureTransformations");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "TypeLiteralTransformation");
    this.propertySignatureTransformations = propertySignatureTransformations;
    const fromKeys = {};
    const toKeys = {};
    for (const pst of propertySignatureTransformations) {
      const from = pst.from;
      if (fromKeys[from]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(from));
      }
      fromKeys[from] = true;
      const to = pst.to;
      if (toKeys[to]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(to));
      }
      toKeys[to] = true;
    }
  }
};
var isTypeLiteralTransformation = /* @__PURE__ */ createTransformationGuard("TypeLiteralTransformation");
var annotations = (ast, overrides) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  const value3 = {
    ...ast.annotations,
    ...overrides
  };
  const surrogate = getSurrogateAnnotation(ast);
  if (isSome2(surrogate)) {
    value3[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
  }
  d.annotations.value = value3;
  return Object.create(Object.getPrototypeOf(ast), d);
};
var keyof = (ast) => Union.unify(_keyof(ast));
var STRING_KEYWORD_PATTERN = "[\\s\\S]*";
var NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
var getTemplateLiteralSpanTypePattern = (type, capture2) => {
  switch (type._tag) {
    case "Literal":
      return escape(String(type.literal));
    case "StringKeyword":
      return STRING_KEYWORD_PATTERN;
    case "NumberKeyword":
      return NUMBER_KEYWORD_PATTERN;
    case "TemplateLiteral":
      return getTemplateLiteralPattern(type, capture2, false);
    case "Union":
      return type.types.map((type2) => getTemplateLiteralSpanTypePattern(type2, capture2)).join("|");
  }
};
var handleTemplateLiteralSpanTypeParens = (type, s, capture2, top) => {
  if (isUnion(type)) {
    if (capture2 && !top) {
      return `(?:${s})`;
    }
  } else if (!capture2 || !top) {
    return s;
  }
  return `(${s})`;
};
var getTemplateLiteralPattern = (ast, capture2, top) => {
  let pattern3 = ``;
  if (ast.head !== "") {
    const head8 = escape(ast.head);
    pattern3 += capture2 && top ? `(${head8})` : head8;
  }
  for (const span4 of ast.spans) {
    const spanPattern = getTemplateLiteralSpanTypePattern(span4.type, capture2);
    pattern3 += handleTemplateLiteralSpanTypeParens(span4.type, spanPattern, capture2, top);
    if (span4.literal !== "") {
      const literal2 = escape(span4.literal);
      pattern3 += capture2 && top ? `(${literal2})` : literal2;
    }
  }
  return pattern3;
};
var getTemplateLiteralRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`);
var getTemplateLiteralCapturingRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast, true, true)}$`);
var getPropertySignatures = (ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertySignatures(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.propertySignatures.slice();
    case "Suspend":
      return getPropertySignatures(ast.f());
    case "Refinement":
      return getPropertySignatures(ast.from);
  }
  return getPropertyKeys(ast).map((name) => getPropertyKeyIndexedAccess(ast, name));
};
var getIndexSignatures = (ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getIndexSignatures(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.indexSignatures.slice();
    case "Suspend":
      return getIndexSignatures(ast.f());
    case "Refinement":
      return getIndexSignatures(ast.from);
  }
  return [];
};
var getNumberIndexedAccess = (ast) => {
  switch (ast._tag) {
    case "TupleType": {
      let hasOptional = false;
      let out = [];
      for (const e of ast.elements) {
        if (e.isOptional) {
          hasOptional = true;
        }
        out.push(e.type);
      }
      if (hasOptional) {
        out.push(undefinedKeyword);
      }
      out = out.concat(getRestASTs(ast.rest));
      return Union.make(out);
    }
    case "Refinement":
      return getNumberIndexedAccess(ast.from);
    case "Union":
      return Union.make(ast.types.map(getNumberIndexedAccess));
    case "Suspend":
      return getNumberIndexedAccess(ast.f());
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var getTypeLiteralPropertySignature = (ast, name) => {
  const ops = findFirst2(ast.propertySignatures, (ps) => ps.name === name);
  if (isSome2(ops)) {
    return ops.value;
  }
  if (isString(name)) {
    let out = void 0;
    for (const is4 of ast.indexSignatures) {
      const encodedParameter = getEncodedParameter(is4.parameter);
      switch (encodedParameter._tag) {
        case "TemplateLiteral": {
          const regex = getTemplateLiteralRegExp(encodedParameter);
          if (regex.test(name)) {
            return new PropertySignature(name, is4.type, false, true);
          }
          break;
        }
        case "StringKeyword": {
          if (out === void 0) {
            out = new PropertySignature(name, is4.type, false, true);
          }
        }
      }
    }
    if (out) {
      return out;
    }
  } else if (isSymbol(name)) {
    for (const is4 of ast.indexSignatures) {
      const encodedParameter = getEncodedParameter(is4.parameter);
      if (isSymbolKeyword(encodedParameter)) {
        return new PropertySignature(name, is4.type, false, true);
      }
    }
  }
};
var getPropertyKeyIndexedAccess = (ast, name) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertyKeyIndexedAccess(annotation.value, name);
  }
  switch (ast._tag) {
    case "TypeLiteral": {
      const ps = getTypeLiteralPropertySignature(ast, name);
      if (ps) {
        return ps;
      }
      break;
    }
    case "Union":
      return new PropertySignature(name, Union.make(ast.types.map((ast2) => getPropertyKeyIndexedAccess(ast2, name).type)), false, true);
    case "Suspend":
      return getPropertyKeyIndexedAccess(ast.f(), name);
    case "Refinement":
      return getPropertyKeyIndexedAccess(ast.from, name);
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var getPropertyKeys = (ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertyKeys(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.propertySignatures.map((ps) => ps.name);
    case "Union":
      return ast.types.slice(1).reduce((out, ast2) => intersection(out, getPropertyKeys(ast2)), getPropertyKeys(ast.types[0]));
    case "Suspend":
      return getPropertyKeys(ast.f());
    case "Refinement":
      return getPropertyKeys(ast.from);
    case "Transformation":
      return getPropertyKeys(ast.to);
  }
  return [];
};
var record2 = (key, value3) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go6 = (key2) => {
    switch (key2._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(new IndexSignature(key2, value3, true));
        break;
      case "Literal":
        if (isString(key2.literal) || isNumber(key2.literal)) {
          propertySignatures.push(new PropertySignature(key2.literal, value3, false, true));
        } else {
          throw new Error(getASTUnsupportedLiteralErrorMessage(key2.literal));
        }
        break;
      case "Enums": {
        for (const [_, name] of key2.enums) {
          propertySignatures.push(new PropertySignature(name, value3, false, true));
        }
        break;
      }
      case "UniqueSymbol":
        propertySignatures.push(new PropertySignature(key2.symbol, value3, false, true));
        break;
      case "Union":
        key2.types.forEach(go6);
        break;
      default:
        throw new Error(getASTUnsupportedKeySchemaErrorMessage(key2));
    }
  };
  go6(key);
  return {
    propertySignatures,
    indexSignatures
  };
};
var pick3 = (ast, keys6) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return pick3(annotation.value, keys6);
  }
  switch (ast._tag) {
    case "TypeLiteral": {
      const pss = [];
      const names = {};
      for (const ps of ast.propertySignatures) {
        names[ps.name] = null;
        if (keys6.includes(ps.name)) {
          pss.push(ps);
        }
      }
      for (const key of keys6) {
        if (!(key in names)) {
          const ps = getTypeLiteralPropertySignature(ast, key);
          if (ps) {
            pss.push(ps);
          }
        }
      }
      return new TypeLiteral(pss, []);
    }
    case "Union":
      return new TypeLiteral(keys6.map((name) => getPropertyKeyIndexedAccess(ast, name)), []);
    case "Suspend":
      return pick3(ast.f(), keys6);
    case "Refinement":
      return pick3(ast.from, keys6);
    case "Transformation": {
      switch (ast.transformation._tag) {
        case "ComposeTransformation":
          return new Transformation(pick3(ast.from, keys6), pick3(ast.to, keys6), composeTransformation);
        case "TypeLiteralTransformation": {
          const ts = [];
          const fromKeys = [];
          for (const k of keys6) {
            const t = ast.transformation.propertySignatureTransformations.find((t2) => t2.to === k);
            if (t) {
              ts.push(t);
              fromKeys.push(t.from);
            } else {
              fromKeys.push(k);
            }
          }
          return isNonEmptyReadonlyArray(ts) ? new Transformation(pick3(ast.from, fromKeys), pick3(ast.to, keys6), new TypeLiteralTransformation(ts)) : pick3(ast.from, fromKeys);
        }
      }
    }
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var omit3 = (ast, keys6) => {
  let indexSignatures = getIndexSignatures(ast);
  if (indexSignatures.length > 0) {
    if (indexSignatures.some((is4) => isStringKeyword(getEncodedParameter(is4.parameter)))) {
      indexSignatures = indexSignatures.filter((is4) => !isTemplateLiteral(getEncodedParameter(is4.parameter)));
    }
    return new TypeLiteral([], indexSignatures);
  }
  return pick3(ast, getPropertyKeys(ast).filter((name) => !keys6.includes(name)));
};
var orUndefined = (ast) => Union.make([ast, undefinedKeyword]);
var partial = (ast, options) => {
  const exact = options?.exact === true;
  switch (ast._tag) {
    case "TupleType":
      return new TupleType(ast.elements.map((e) => new OptionalType(exact ? e.type : orUndefined(e.type), true)), match3(ast.rest, {
        onEmpty: () => ast.rest,
        onNonEmpty: (rest) => [new Type(Union.make([...getRestASTs(rest), undefinedKeyword]))]
      }), ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral(ast.propertySignatures.map((ps) => new PropertySignature(ps.name, exact ? ps.type : orUndefined(ps.type), true, ps.isReadonly, ps.annotations)), ast.indexSignatures.map((is4) => new IndexSignature(is4.parameter, orUndefined(is4.type), is4.isReadonly)));
    case "Union":
      return Union.make(ast.types.map((member) => partial(member, options)));
    case "Suspend":
      return new Suspend(() => partial(ast.f(), options));
    case "Declaration":
    case "Refinement":
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    case "Transformation": {
      if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
        return new Transformation(partial(ast.from, options), partial(ast.to, options), ast.transformation);
      }
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    }
  }
  return ast;
};
var required = (ast) => {
  switch (ast._tag) {
    case "TupleType":
      return new TupleType(ast.elements.map((e) => new OptionalType(e.type, false)), ast.rest, ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral(ast.propertySignatures.map((f) => new PropertySignature(f.name, f.type, false, f.isReadonly, f.annotations)), ast.indexSignatures);
    case "Union":
      return Union.make(ast.types.map((member) => required(member)));
    case "Suspend":
      return new Suspend(() => required(ast.f()));
    case "Declaration":
    case "Refinement":
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    case "Transformation": {
      if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
        return new Transformation(required(ast.from), required(ast.to), ast.transformation);
      }
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    }
  }
  return ast;
};
var mutable = (ast) => {
  switch (ast._tag) {
    case "TupleType":
      return ast.isReadonly === false ? ast : new TupleType(ast.elements, ast.rest, false, ast.annotations);
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => ps.isReadonly === false ? ps : new PropertySignature(ps.name, ps.type, ps.isOptional, false, ps.annotations));
      const indexSignatures = changeMap(ast.indexSignatures, (is4) => is4.isReadonly === false ? is4 : new IndexSignature(is4.parameter, is4.type, false));
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap(ast.types, mutable);
      return types === ast.types ? ast : Union.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => mutable(ast.f()), ast.annotations);
    case "Refinement": {
      const from = mutable(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const from = mutable(ast.from);
      const to = mutable(ast.to);
      return from === ast.from && to === ast.to ? ast : new Transformation(from, to, ast.transformation, ast.annotations);
    }
  }
  return ast;
};
var pickAnnotations = (annotationIds) => (annotated) => {
  let out = void 0;
  for (const id3 of annotationIds) {
    if (Object.prototype.hasOwnProperty.call(annotated.annotations, id3)) {
      if (out === void 0) {
        out = {};
      }
      out[id3] = annotated.annotations[id3];
    }
  }
  return out;
};
var omitAnnotations = (annotationIds) => (annotated) => {
  const out = {
    ...annotated.annotations
  };
  for (const id3 of annotationIds) {
    delete out[id3];
  }
  return out;
};
var preserveTransformationAnnotations = /* @__PURE__ */ pickAnnotations([ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId]);
var typeAST = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, typeAST);
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type = typeAST(e.type);
        return type === e.type ? e : new OptionalType(type, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, typeAST);
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type) => new Type(type)), ast.isReadonly, ast.annotations);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (p) => {
        const type = typeAST(p.type);
        return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is4) => {
        const type = typeAST(is4.type);
        return type === is4.type ? is4 : new IndexSignature(is4.parameter, type, is4.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap(ast.types, typeAST);
      return types === ast.types ? ast : Union.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => typeAST(ast.f()), ast.annotations);
    case "Refinement": {
      const from = typeAST(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const preserve = preserveTransformationAnnotations(ast);
      return typeAST(preserve !== void 0 ? annotations(ast.to, preserve) : ast.to);
    }
  }
  return ast;
};
var createJSONIdentifierAnnotation = (annotated) => match2(getJSONIdentifier(annotated), {
  onNone: () => void 0,
  onSome: (identifier2) => ({
    [JSONIdentifierAnnotationId]: identifier2
  })
});
function changeMap(as13, f) {
  let changed = false;
  const out = allocate(as13.length);
  for (let i = 0; i < as13.length; i++) {
    const a = as13[i];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as13;
}
var getTransformationFrom = (ast) => {
  switch (ast._tag) {
    case "Transformation":
      return ast.from;
    case "Refinement":
      return getTransformationFrom(ast.from);
    case "Suspend":
      return getTransformationFrom(ast.f());
  }
};
var encodedAST_ = (ast, isBound) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, (ast2) => encodedAST_(ast2, isBound));
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type = encodedAST_(e.type, isBound);
        return type === e.type ? e : new OptionalType(type, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, (ast2) => encodedAST_(ast2, isBound));
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast2) => new Type(ast2)), ast.isReadonly, createJSONIdentifierAnnotation(ast));
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
        const type = encodedAST_(ps.type, isBound);
        return type === ps.type ? ps : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is4) => {
        const type = encodedAST_(is4.type, isBound);
        return type === is4.type ? is4 : new IndexSignature(is4.parameter, type, is4.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, createJSONIdentifierAnnotation(ast));
    }
    case "Union": {
      const types = changeMap(ast.types, (ast2) => encodedAST_(ast2, isBound));
      return types === ast.types ? ast : Union.make(types, createJSONIdentifierAnnotation(ast));
    }
    case "Suspend":
      return new Suspend(() => encodedAST_(ast.f(), isBound), createJSONIdentifierAnnotation(ast));
    case "Refinement": {
      const from = encodedAST_(ast.from, isBound);
      if (isBound) {
        if (from === ast.from) {
          return ast;
        }
        if (getTransformationFrom(ast.from) === void 0 && hasStableFilter(ast)) {
          return new Refinement(from, ast.filter, ast.annotations);
        }
      }
      const identifier2 = createJSONIdentifierAnnotation(ast);
      return identifier2 ? annotations(from, identifier2) : from;
    }
    case "Transformation": {
      const identifier2 = createJSONIdentifierAnnotation(ast);
      return encodedAST_(identifier2 ? annotations(ast.from, identifier2) : ast.from, isBound);
    }
  }
  return ast;
};
var encodedAST = (ast) => encodedAST_(ast, false);
var encodedBoundAST = (ast) => encodedAST_(ast, true);
var toJSONAnnotations = (annotations5) => {
  const out = {};
  for (const k of Object.getOwnPropertySymbols(annotations5)) {
    out[String(k)] = annotations5[k];
  }
  return out;
};
var getEncodedParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getEncodedParameter(ast.from);
  }
};
var equals5 = (self, that) => {
  switch (self._tag) {
    case "Literal":
      return isLiteral(that) && that.literal === self.literal;
    case "UniqueSymbol":
      return isUniqueSymbol(that) && that.symbol === self.symbol;
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "NeverKeyword":
    case "UnknownKeyword":
    case "AnyKeyword":
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
    case "ObjectKeyword":
      return that._tag === self._tag;
    case "TemplateLiteral":
      return isTemplateLiteral(that) && that.head === self.head && equalsTemplateLiteralSpan(that.spans, self.spans);
    case "Enums":
      return isEnums(that) && equalsEnums(that.enums, self.enums);
    case "Union":
      return isUnion(that) && equalsUnion(self.types, that.types);
    case "Refinement":
    case "TupleType":
    case "TypeLiteral":
    case "Suspend":
    case "Transformation":
    case "Declaration":
      return self === that;
  }
};
var equalsTemplateLiteralSpan = /* @__PURE__ */ getEquivalence3((self, that) => {
  return self.literal === that.literal && equals5(self.type, that.type);
});
var equalsEnums = /* @__PURE__ */ getEquivalence3((self, that) => that[0] === self[0] && that[1] === self[1]);
var equalsUnion = /* @__PURE__ */ getEquivalence3(equals5);
var intersection4 = /* @__PURE__ */ intersectionWith(equals5);
var _keyof = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return _keyof(annotation.value);
      }
      break;
    }
    case "TypeLiteral":
      return ast.propertySignatures.map((p) => isSymbol(p.name) ? new UniqueSymbol(p.name) : new Literal(p.name)).concat(ast.indexSignatures.map((is4) => getEncodedParameter(is4.parameter)));
    case "Suspend":
      return _keyof(ast.f());
    case "Union":
      return ast.types.slice(1).reduce((out, ast2) => intersection4(out, _keyof(ast2)), _keyof(ast.types[0]));
    case "Transformation":
      return _keyof(ast.to);
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
};
var compose3 = (ab, cd) => new Transformation(ab, cd, composeTransformation);
var rename = (ast, mapping) => {
  switch (ast._tag) {
    case "TypeLiteral": {
      const propertySignatureTransformations = [];
      for (const key of ownKeys(mapping)) {
        const name = mapping[key];
        if (name !== void 0) {
          propertySignatureTransformations.push(new PropertySignatureTransformation(key, name, identity, identity));
        }
      }
      if (propertySignatureTransformations.length === 0) {
        return ast;
      }
      return new Transformation(ast, new TypeLiteral(ast.propertySignatures.map((ps) => {
        const name = mapping[ps.name];
        return new PropertySignature(name === void 0 ? ps.name : name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations);
      }), ast.indexSignatures), new TypeLiteralTransformation(propertySignatureTransformations));
    }
    case "Union":
      return Union.make(ast.types.map((ast2) => rename(ast2, mapping)));
    case "Suspend":
      return new Suspend(() => rename(ast.f(), mapping));
    case "Transformation":
      return compose3(ast, rename(typeAST(ast), mapping));
  }
  throw new Error(getASTUnsupportedRenameSchemaErrorMessage(ast));
};
var formatKeyword = (ast) => getOrElse3(getExpected(ast), () => ast._tag);
function getBrands(ast) {
  return match2(getBrandAnnotation(ast), {
    onNone: () => "",
    onSome: (brands) => brands.map((brand3) => ` & Brand<${formatUnknown(brand3)}>`).join("")
  });
}
var getOrElseExpected = (ast) => getTitleAnnotation(ast).pipe(orElse(() => getDescriptionAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), map2((s) => s + getBrands(ast)));
var getExpected = (ast) => orElse(getIdentifierAnnotation(ast), () => getOrElseExpected(ast));
var pruneUndefined = (ast, self, onTransformation) => {
  switch (ast._tag) {
    case "UndefinedKeyword":
      return neverKeyword;
    case "Union": {
      const types = [];
      let hasUndefined = false;
      for (const type of ast.types) {
        const pruned = self(type);
        if (pruned) {
          hasUndefined = true;
          if (!isNeverKeyword(pruned)) {
            types.push(pruned);
          }
        } else {
          types.push(type);
        }
      }
      if (hasUndefined) {
        return Union.make(types);
      }
      break;
    }
    case "Suspend":
      return self(ast.f());
    case "Transformation":
      return onTransformation(ast);
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/ParseResult.js
var Pointer = class {
  constructor(path, actual, issue) {
    __publicField(this, "path");
    __publicField(this, "actual");
    __publicField(this, "issue");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Pointer");
    this.path = path;
    this.actual = actual;
    this.issue = issue;
  }
};
var Unexpected = class {
  constructor(actual, message) {
    __publicField(this, "actual");
    __publicField(this, "message");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Unexpected");
    this.actual = actual;
    this.message = message;
  }
};
var Missing = class {
  constructor(ast, message) {
    __publicField(this, "ast");
    __publicField(this, "message");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Missing");
    /**
     * @since 3.10.0
     */
    __publicField(this, "actual");
    this.ast = ast;
    this.message = message;
  }
};
var Composite2 = class {
  constructor(ast, actual, issues, output3) {
    __publicField(this, "ast");
    __publicField(this, "actual");
    __publicField(this, "issues");
    __publicField(this, "output");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Composite");
    this.ast = ast;
    this.actual = actual;
    this.issues = issues;
    this.output = output3;
  }
};
var Refinement2 = class {
  constructor(ast, actual, kind, issue) {
    __publicField(this, "ast");
    __publicField(this, "actual");
    __publicField(this, "kind");
    __publicField(this, "issue");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Refinement");
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
};
var Transformation2 = class {
  constructor(ast, actual, kind, issue) {
    __publicField(this, "ast");
    __publicField(this, "actual");
    __publicField(this, "kind");
    __publicField(this, "issue");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Transformation");
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
};
var Type2 = class {
  constructor(ast, actual, message) {
    __publicField(this, "ast");
    __publicField(this, "actual");
    __publicField(this, "message");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Type");
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
};
var Forbidden = class {
  constructor(ast, actual, message) {
    __publicField(this, "ast");
    __publicField(this, "actual");
    __publicField(this, "message");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "Forbidden");
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
};
var ParseErrorTypeId2 = /* @__PURE__ */ Symbol.for("effect/Schema/ParseErrorTypeId");
var _a73;
var ParseError2 = class extends (/* @__PURE__ */ TaggedError("ParseError")) {
  constructor() {
    super(...arguments);
    /**
     * @since 3.10.0
     */
    __publicField(this, _a73, ParseErrorTypeId2);
  }
  get message() {
    return this.toString();
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return TreeFormatter.formatIssueSync(this.issue);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  /**
   * @since 3.10.0
   */
  [(_a73 = ParseErrorTypeId2, NodeInspectSymbol)]() {
    return this.toJSON();
  }
};
var parseError = (issue) => new ParseError2({
  issue
});
var succeed19 = right2;
var fail19 = left2;
var _try = try_;
var fromOption3 = fromOption2;
var isEither4 = isEither2;
var flatMap19 = /* @__PURE__ */ dual(2, (self, f) => {
  return isEither4(self) ? match(self, {
    onLeft: left2,
    onRight: f
  }) : flatMap12(self, f);
});
var map27 = /* @__PURE__ */ dual(2, (self, f) => {
  return isEither4(self) ? map(self, f) : map18(self, f);
});
var mapError8 = /* @__PURE__ */ dual(2, (self, f) => {
  return isEither4(self) ? mapLeft(self, f) : mapError3(self, f);
});
var mapBoth9 = /* @__PURE__ */ dual(2, (self, options) => {
  return isEither4(self) ? mapBoth(self, {
    onLeft: options.onFailure,
    onRight: options.onSuccess
  }) : mapBoth5(self, options);
});
var orElse12 = /* @__PURE__ */ dual(2, (self, f) => {
  return isEither4(self) ? match(self, {
    onLeft: f,
    onRight: right2
  }) : catchAll3(self, f);
});
var mergeInternalOptions = (options, overrideOptions) => {
  if (overrideOptions === void 0 || isNumber(overrideOptions)) {
    return options;
  }
  if (options === void 0) {
    return overrideOptions;
  }
  return {
    ...options,
    ...overrideOptions
  };
};
var getEither = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (u, overrideOptions) => parser(u, mergeInternalOptions(options, overrideOptions));
};
var getSync = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError);
};
var getOption3 = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => getRight2(parser(input, overrideOptions));
};
var getEffect = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (input, overrideOptions) => parser(input, {
    ...mergeInternalOptions(options, overrideOptions),
    isEffectAllowed: true
  });
};
var decodeUnknownSync = (schema, options) => getSync(schema.ast, true, options);
var decodeUnknownOption = (schema, options) => getOption3(schema.ast, true, options);
var decodeUnknownEither = (schema, options) => getEither(schema.ast, true, options);
var decodeUnknown2 = (schema, options) => getEffect(schema.ast, true, options);
var encodeUnknownSync = (schema, options) => getSync(schema.ast, false, options);
var encodeUnknownOption = (schema, options) => getOption3(schema.ast, false, options);
var encodeUnknownEither = (schema, options) => getEither(schema.ast, false, options);
var encodeUnknown = (schema, options) => getEffect(schema.ast, false, options);
var decodeSync = decodeUnknownSync;
var decodeOption = decodeUnknownOption;
var validateSync = (schema, options) => getSync(typeAST(schema.ast), true, options);
var validateOption = (schema, options) => getOption3(typeAST(schema.ast), true, options);
var validateEither = (schema, options) => getEither(typeAST(schema.ast), true, options);
var validate4 = (schema, options) => getEffect(typeAST(schema.ast), true, options);
var is = (schema, options) => {
  const parser = goMemo(typeAST(schema.ast), true);
  return (u, overrideOptions) => isRight2(parser(u, {
    exact: true,
    ...mergeInternalOptions(options, overrideOptions)
  }));
};
var asserts = (schema, options) => {
  const parser = goMemo(typeAST(schema.ast), true);
  return (u, overrideOptions) => {
    const result = parser(u, {
      exact: true,
      ...mergeInternalOptions(options, overrideOptions)
    });
    if (isLeft2(result)) {
      throw parseError(result.left);
    }
  };
};
var encodeSync = encodeUnknownSync;
var encodeOption = encodeUnknownOption;
var decodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/decodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var encodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/encodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var goMemo = (ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
  const memo2 = memoMap.get(ast);
  if (memo2) {
    return memo2;
  }
  const raw = go(ast, isDecoding);
  const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
  const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i, options) => raw(i, mergeInternalOptions(options, parseOptionsAnnotation.value)) : raw;
  const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
  const parser = isDecoding && isSome2(decodingFallbackAnnotation) ? (i, options) => handleForbidden(orElse12(parserWithOptions(i, options), decodingFallbackAnnotation.value), ast, i, options) : parserWithOptions;
  memoMap.set(ast, parser);
  return parser;
};
var getConcurrency = (ast) => getOrUndefined(getConcurrencyAnnotation(ast));
var getBatching = (ast) => getOrUndefined(getBatchingAnnotation(ast));
var go = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement": {
      if (isDecoding) {
        const from = goMemo(ast.from, true);
        return (i, options) => {
          options = options ?? defaultParseOption;
          const allErrors = options?.errors === "all";
          const result = flatMap19(orElse12(from(i, options), (ef) => {
            const issue = new Refinement2(ast, i, "From", ef);
            if (allErrors && hasStableFilter(ast) && isComposite2(ef)) {
              return match2(ast.filter(i, options, ast), {
                onNone: () => left2(issue),
                onSome: (ep) => left2(new Composite2(ast, i, [issue, new Refinement2(ast, i, "Predicate", ep)]))
              });
            }
            return left2(issue);
          }), (a) => match2(ast.filter(a, options, ast), {
            onNone: () => right2(a),
            onSome: (ep) => left2(new Refinement2(ast, i, "Predicate", ep))
          }));
          return handleForbidden(result, ast, i, options);
        };
      } else {
        const from = goMemo(typeAST(ast), true);
        const to = goMemo(dropRightRefinement(ast.from), false);
        return (i, options) => handleForbidden(flatMap19(from(i, options), (a) => to(a, options)), ast, i, options);
      }
    }
    case "Transformation": {
      const transform4 = getFinalTransformation(ast.transformation, isDecoding);
      const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
      const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
      return (i, options) => handleForbidden(flatMap19(mapError8(from(i, options), (e) => new Transformation2(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap19(mapError8(transform4(a, options ?? defaultParseOption, ast, i), (e) => new Transformation2(ast, i, "Transformation", e)), (i2) => mapError8(to(i2, options), (e) => new Transformation2(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options);
    }
    case "Declaration": {
      const parse3 = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
      return (i, options) => handleForbidden(parse3(i, options ?? defaultParseOption, ast), ast, i, options);
    }
    case "Literal":
      return fromRefinement(ast, (u) => u === ast.literal);
    case "UniqueSymbol":
      return fromRefinement(ast, (u) => u === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement(ast, isUndefined);
    case "NeverKeyword":
      return fromRefinement(ast, isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
    case "VoidKeyword":
      return right2;
    case "StringKeyword":
      return fromRefinement(ast, isString);
    case "NumberKeyword":
      return fromRefinement(ast, isNumber);
    case "BooleanKeyword":
      return fromRefinement(ast, isBoolean);
    case "BigIntKeyword":
      return fromRefinement(ast, isBigInt);
    case "SymbolKeyword":
      return fromRefinement(ast, isSymbol);
    case "ObjectKeyword":
      return fromRefinement(ast, isObject);
    case "Enums":
      return fromRefinement(ast, (u) => ast.enums.some(([_, value3]) => value3 === u));
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp(ast);
      return fromRefinement(ast, (u) => isString(u) && regex.test(u));
    }
    case "TupleType": {
      const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
      const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
      let requiredTypes = ast.elements.filter((e) => !e.isOptional);
      if (ast.rest.length > 0) {
        requiredTypes = requiredTypes.concat(ast.rest.slice(1));
      }
      const requiredLen = requiredTypes.length;
      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options) => {
        if (!isArray(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const output3 = [];
        const len = input.length;
        for (let i2 = len; i2 <= requiredLen - 1; i2++) {
          const e = new Pointer(i2, input, new Missing(requiredTypes[i2 - len]));
          if (allErrors) {
            es.push([stepKey++, e]);
            continue;
          } else {
            return left2(new Composite2(ast, input, e, output3));
          }
        }
        if (ast.rest.length === 0) {
          for (let i2 = ast.elements.length; i2 <= len - 1; i2++) {
            const e = new Pointer(i2, input, new Unexpected(input[i2], `is unexpected, expected: ${expectedIndexes}`));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite2(ast, input, e, output3));
            }
          }
        }
        let i = 0;
        let queue = void 0;
        for (; i < elements.length; i++) {
          if (len < i + 1) {
            if (ast.elements[i].isOptional) {
              continue;
            }
          } else {
            const parser = elements[i];
            const te = parser(input[i], options);
            if (isEither4(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output3)));
                }
              }
              output3.push([stepKey++, te.right]);
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output4
              }) => flatMap12(either4(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output4)));
                  }
                }
                output4.push([nk, t.right]);
                return _void;
              }));
            }
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head8, ...tail2] = rest;
          for (; i < len - tail2.length; i++) {
            const te = head8(input[i], options);
            if (isEither4(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output3)));
                }
              } else {
                output3.push([stepKey++, te.right]);
              }
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output4
              }) => flatMap12(either4(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output4)));
                  }
                } else {
                  output4.push([nk, t.right]);
                  return _void;
                }
              }));
            }
          }
          for (let j = 0; j < tail2.length; j++) {
            i += j;
            if (len < i + 1) {
              continue;
            } else {
              const te = tail2[j](input[i], options);
              if (isEither4(te)) {
                if (isLeft2(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output3)));
                  }
                }
                output3.push([stepKey++, te.right]);
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output4
                }) => flatMap12(either4(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output4)));
                    }
                  }
                  output4.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output4
        }) => isNonEmptyArray2(es2) ? left2(new Composite2(ast, input, sortByIndex(es2), sortByIndex(output4))) : right2(sortByIndex(output4));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy(es),
              output: copy(output3)
            };
            return flatMap12(forEach10(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          output: output3,
          es
        });
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return fromRefinement(ast, isNotNullable);
      }
      const propertySignatures = [];
      const expectedKeysMap = {};
      const expectedKeys = [];
      for (const ps of ast.propertySignatures) {
        propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
        expectedKeysMap[ps.name] = null;
        expectedKeys.push(ps.name);
      }
      const indexSignatures = ast.indexSignatures.map((is4) => [goMemo(is4.parameter, isDecoding), goMemo(is4.type, isDecoding), is4.parameter]);
      const expectedAST = Union.make(ast.indexSignatures.map((is4) => is4.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal(key))));
      const expected = goMemo(expectedAST, isDecoding);
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options) => {
        if (!isRecord(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const onExcessPropertyError = options?.onExcessProperty === "error";
        const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
        const output3 = {};
        let inputKeys;
        if (onExcessPropertyError || onExcessPropertyPreserve) {
          inputKeys = ownKeys(input);
          for (const key of inputKeys) {
            const te = expected(key, options);
            if (isEither4(te) && isLeft2(te)) {
              if (onExcessPropertyError) {
                const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output3));
                }
              } else {
                output3[key] = input[key];
              }
            }
          }
        }
        let queue = void 0;
        const isExact = options?.exact === true;
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = propertySignatures[i][1];
          const name = ps.name;
          const hasKey = Object.prototype.hasOwnProperty.call(input, name);
          if (!hasKey) {
            if (ps.isOptional) {
              continue;
            } else if (isExact) {
              const e = new Pointer(name, input, new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output3));
              }
            }
          }
          const parser = propertySignatures[i][0];
          const te = parser(input[name], options);
          if (isEither4(te)) {
            if (isLeft2(te)) {
              const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output3));
              }
            }
            output3[name] = te.right;
          } else {
            const nk = stepKey++;
            const index = name;
            if (!queue) {
              queue = [];
            }
            queue.push(({
              es: es2,
              output: output4
            }) => flatMap12(either4(te), (t) => {
              if (isLeft2(t)) {
                const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps));
                if (allErrors) {
                  es2.push([nk, e]);
                  return _void;
                } else {
                  return left2(new Composite2(ast, input, e, output4));
                }
              }
              output4[index] = t.right;
              return _void;
            }));
          }
        }
        for (let i = 0; i < indexSignatures.length; i++) {
          const indexSignature = indexSignatures[i];
          const parameter = indexSignature[0];
          const type = indexSignature[1];
          const keys6 = getKeysForIndexSignature(input, indexSignature[2]);
          for (const key of keys6) {
            const keu = parameter(key, options);
            if (isEither4(keu) && isRight2(keu)) {
              const vpr = type(input[key], options);
              if (isEither4(vpr)) {
                if (isLeft2(vpr)) {
                  const e = new Pointer(key, input, vpr.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, output3));
                  }
                } else {
                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                    output3[key] = vpr.right;
                  }
                }
              } else {
                const nk = stepKey++;
                const index = key;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output4
                }) => flatMap12(either4(vpr), (tv) => {
                  if (isLeft2(tv)) {
                    const e = new Pointer(index, input, tv.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, output4));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output4[key] = tv.right;
                    }
                    return _void;
                  }
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output4
        }) => {
          if (isNonEmptyArray2(es2)) {
            return left2(new Composite2(ast, input, sortByIndex(es2), output4));
          }
          if (options?.propertyOrder === "original") {
            const keys6 = inputKeys || ownKeys(input);
            for (const name of expectedKeys) {
              if (keys6.indexOf(name) === -1) {
                keys6.push(name);
              }
            }
            const out = {};
            for (const key of keys6) {
              if (Object.prototype.hasOwnProperty.call(output4, key)) {
                out[key] = output4[key];
              }
            }
            return right2(out);
          }
          return right2(output4);
        };
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy(es),
              output: Object.assign({}, output3)
            };
            return flatMap12(forEach10(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          es,
          output: output3
        });
      };
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, isDecoding);
      const ownKeys3 = ownKeys(searchTree.keys);
      const ownKeysLen = ownKeys3.length;
      const astTypesLen = ast.types.length;
      const map31 = /* @__PURE__ */ new Map();
      for (let i = 0; i < astTypesLen; i++) {
        map31.set(ast.types[i], goMemo(ast.types[i], isDecoding));
      }
      const concurrency = getConcurrency(ast) ?? 1;
      const batching = getBatching(ast);
      return (input, options) => {
        const es = [];
        let stepKey = 0;
        let candidates = [];
        if (ownKeysLen > 0) {
          if (isRecordOrArray(input)) {
            for (let i = 0; i < ownKeysLen; i++) {
              const name = ownKeys3[i];
              const buckets = searchTree.keys[name].buckets;
              if (Object.prototype.hasOwnProperty.call(input, name)) {
                const literal2 = String(input[name]);
                if (Object.prototype.hasOwnProperty.call(buckets, literal2)) {
                  candidates = candidates.concat(buckets[literal2]);
                } else {
                  const {
                    candidates: candidates2,
                    literals
                  } = searchTree.keys[name];
                  const literalsUnion = Union.make(literals);
                  const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([new PropertySignature(name, literalsUnion, false, true)], []) : Union.make(candidates2);
                  es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Type2(literalsUnion, input[name])))]);
                }
              } else {
                const {
                  candidates: candidates2,
                  literals
                } = searchTree.keys[name];
                const fakePropertySignature = new PropertySignature(name, Union.make(literals), false, true);
                const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates2);
                es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
              }
            }
          } else {
            const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
            es.push([stepKey++, new Type2(errorAst, input)]);
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        let queue = void 0;
        for (let i = 0; i < candidates.length; i++) {
          const candidate = candidates[i];
          const pr = map31.get(candidate)(input, options);
          if (isEither4(pr) && (!queue || queue.length === 0)) {
            if (isRight2(pr)) {
              return pr;
            } else {
              es.push([stepKey++, pr.left]);
            }
          } else {
            const nk = stepKey++;
            if (!queue) {
              queue = [];
            }
            queue.push((state) => suspend4(() => {
              if ("finalResult" in state) {
                return _void;
              } else {
                return flatMap12(either4(pr), (t) => {
                  if (isRight2(t)) {
                    state.finalResult = t;
                  } else {
                    state.es.push([nk, t.left]);
                  }
                  return _void;
                });
              }
            }));
          }
        }
        const computeResult = (es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite2(ast, input, sortByIndex(es2))) : (
          // this should never happen
          left2(new Type2(ast, input))
        );
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy(es)
            };
            return flatMap12(forEach10(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => {
              if ("finalResult" in state) {
                return state.finalResult;
              }
              return computeResult(state.es);
            });
          });
        }
        return computeResult(es);
      };
    }
    case "Suspend": {
      const get17 = memoizeThunk(() => goMemo(annotations(ast.f(), ast.annotations), isDecoding));
      return (a, options) => get17()(a, options);
    }
  }
};
var fromRefinement = (ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type2(ast, u));
var getLiterals = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return getLiterals(annotation.value, isDecoding);
      }
      break;
    }
    case "TypeLiteral": {
      const out = [];
      for (let i = 0; i < ast.propertySignatures.length; i++) {
        const propertySignature3 = ast.propertySignatures[i];
        const type = isDecoding ? encodedAST(propertySignature3.type) : typeAST(propertySignature3.type);
        if (isLiteral(type) && !propertySignature3.isOptional) {
          out.push([propertySignature3.name, type]);
        }
      }
      return out;
    }
    case "TupleType": {
      const out = [];
      for (let i = 0; i < ast.elements.length; i++) {
        const element3 = ast.elements[i];
        const type = isDecoding ? encodedAST(element3.type) : typeAST(element3.type);
        if (isLiteral(type) && !element3.isOptional) {
          out.push([i, type]);
        }
      }
      return out;
    }
    case "Refinement":
      return getLiterals(ast.from, isDecoding);
    case "Suspend":
      return getLiterals(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
};
var getSearchTree = (members, isDecoding) => {
  const keys6 = {};
  const otherwise = [];
  const candidates = [];
  for (let i = 0; i < members.length; i++) {
    const member = members[i];
    const tags = getLiterals(member, isDecoding);
    if (tags.length > 0) {
      candidates.push(member);
      for (let j = 0; j < tags.length; j++) {
        const [key, literal2] = tags[j];
        const hash4 = String(literal2.literal);
        keys6[key] = keys6[key] || {
          buckets: {},
          literals: [],
          candidates: []
        };
        const buckets = keys6[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash4)) {
          if (j < tags.length - 1) {
            continue;
          }
          buckets[hash4].push(member);
          keys6[key].literals.push(literal2);
          keys6[key].candidates.push(member);
        } else {
          buckets[hash4] = [member];
          keys6[key].literals.push(literal2);
          keys6[key].candidates.push(member);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys: keys6,
    otherwise,
    candidates
  };
};
var dropRightRefinement = (ast) => isRefinement(ast) ? dropRightRefinement(ast.from) : ast;
var handleForbidden = (effect4, ast, actual, options) => {
  if (options?.isEffectAllowed === true) {
    return effect4;
  }
  if (isEither4(effect4)) {
    return effect4;
  }
  const scheduler2 = new SyncScheduler();
  const fiber = runFork2(effect4, {
    scheduler: scheduler2
  });
  scheduler2.flush();
  const exit4 = fiber.unsafePoll();
  if (exit4) {
    if (isSuccess2(exit4)) {
      return right2(exit4.value);
    }
    const cause3 = exit4.cause;
    if (isFailType2(cause3)) {
      return left2(cause3.error);
    }
    return left2(new Forbidden(ast, actual, pretty3(cause3)));
  }
  return left2(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
};
var compare = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0;
function sortByIndex(es) {
  return es.sort(compare).map((t) => t[1]);
}
var getFinalTransformation = (transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return right2;
    case "TypeLiteralTransformation":
      return (input) => {
        let out = right2(input);
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation2 = isDecoding ? pst.decode : pst.encode;
          const f = (input2) => {
            const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some2(input2[from]) : none2());
            delete input2[from];
            if (isSome2(o)) {
              input2[to] = o.value;
            }
            return input2;
          };
          out = map27(out, f);
        }
        return out;
      };
  }
};
var makeTree = (value3, forest = []) => ({
  value: value3,
  forest
});
var TreeFormatter = {
  formatIssue: (issue) => map27(formatTree(issue), drawTree),
  formatIssueSync: (issue) => {
    const e = TreeFormatter.formatIssue(issue);
    return isEither4(e) ? getOrThrow(e) : runSync(e);
  },
  formatError: (error2) => TreeFormatter.formatIssue(error2.issue),
  formatErrorSync: (error2) => TreeFormatter.formatIssueSync(error2.issue)
};
var drawTree = (tree) => tree.value + draw("\n", tree.forest);
var draw = (indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0; i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "\u2514" : "\u251C") + "\u2500 " + tree.value;
    r += draw(indentation + (len > 1 && !isLast ? "\u2502  " : "   "), tree.forest);
  }
  return r;
};
var formatTransformationKind = (kind) => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
};
var formatRefinementKind = (kind) => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
};
var getAnnotated = (issue) => "ast" in issue ? some2(issue.ast) : none2();
var Either_void = /* @__PURE__ */ right2(void 0);
var getCurrentMessage = (issue) => getAnnotated(issue).pipe(flatMap(getMessageAnnotation), match2({
  onNone: () => Either_void,
  onSome: (messageAnnotation) => {
    const union12 = messageAnnotation(issue);
    if (isString(union12)) {
      return right2({
        message: union12,
        override: false
      });
    }
    if (isEffect2(union12)) {
      return map18(union12, (message) => ({
        message,
        override: false
      }));
    }
    if (isString(union12.message)) {
      return right2({
        message: union12.message,
        override: union12.override
      });
    }
    return map18(union12.message, (message) => ({
      message,
      override: union12.override
    }));
  }
}));
var createParseIssueGuard = (tag3) => (issue) => issue._tag === tag3;
var isComposite2 = /* @__PURE__ */ createParseIssueGuard("Composite");
var isRefinement2 = /* @__PURE__ */ createParseIssueGuard("Refinement");
var isTransformation2 = /* @__PURE__ */ createParseIssueGuard("Transformation");
var getMessage = (issue) => flatMap19(getCurrentMessage(issue), (currentMessage) => {
  if (currentMessage !== void 0) {
    const useInnerMessage = !currentMessage.override && (isComposite2(issue) || isRefinement2(issue) && issue.kind === "From" || isTransformation2(issue) && issue.kind !== "Transformation");
    return useInnerMessage ? isTransformation2(issue) || isRefinement2(issue) ? getMessage(issue.issue) : Either_void : right2(currentMessage.message);
  }
  return Either_void;
});
var getParseIssueTitleAnnotation2 = (issue) => getAnnotated(issue).pipe(flatMap(getParseIssueTitleAnnotation), flatMapNullable((annotation) => annotation(issue)), getOrUndefined);
function getRefinementExpected(ast) {
  return getDescriptionAnnotation(ast).pipe(orElse(() => getTitleAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), orElse(() => getIdentifierAnnotation(ast)), getOrElse3(() => `{ ${ast.from} | filter }`));
}
function getDefaultTypeMessage(issue) {
  if (issue.message !== void 0) {
    return issue.message;
  }
  const expected = isRefinement(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast);
  return `Expected ${expected}, actual ${formatUnknown(issue.actual)}`;
}
var formatTypeMessage = (issue) => map27(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation2(issue) ?? getDefaultTypeMessage(issue));
var getParseIssueTitle = (issue) => getParseIssueTitleAnnotation2(issue) ?? String(issue.ast);
var formatForbiddenMessage = (issue) => issue.message ?? "is forbidden";
var formatUnexpectedMessage = (issue) => issue.message ?? "is unexpected";
var formatMissingMessage = (issue) => {
  const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
  if (isSome2(missingMessageAnnotation)) {
    const annotation = missingMessageAnnotation.value();
    return isString(annotation) ? right2(annotation) : annotation;
  }
  return right2(issue.message ?? "is missing");
};
var formatTree = (issue) => {
  switch (issue._tag) {
    case "Type":
      return map27(formatTypeMessage(issue), makeTree);
    case "Forbidden":
      return right2(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
    case "Unexpected":
      return right2(makeTree(formatUnexpectedMessage(issue)));
    case "Missing":
      return map27(formatMissingMessage(issue), makeTree);
    case "Transformation":
      return flatMap19(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        return map27(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
      });
    case "Refinement":
      return flatMap19(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        return map27(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
      });
    case "Pointer":
      return map27(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
    case "Composite":
      return flatMap19(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        const parseIssueTitle = getParseIssueTitle(issue);
        return isNonEmpty6(issue.issues) ? map27(forEach10(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map27(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
      });
  }
};
var makeArrayFormatterIssue = (_tag, path, message) => ({
  _tag,
  path,
  message
});
var ArrayFormatter = {
  formatIssue: (issue) => getArrayFormatterIssues(issue, void 0, []),
  formatIssueSync: (issue) => {
    const e = ArrayFormatter.formatIssue(issue);
    return isEither4(e) ? getOrThrow(e) : runSync(e);
  },
  formatError: (error2) => ArrayFormatter.formatIssue(error2.issue),
  formatErrorSync: (error2) => ArrayFormatter.formatIssueSync(error2.issue)
};
var getArrayFormatterIssues = (issue, parentTag, path) => {
  const _tag = issue._tag;
  switch (_tag) {
    case "Type":
      return map27(formatTypeMessage(issue), (message) => [makeArrayFormatterIssue(parentTag ?? _tag, path, message)]);
    case "Forbidden":
      return right2([makeArrayFormatterIssue(_tag, path, formatForbiddenMessage(issue))]);
    case "Unexpected":
      return right2([makeArrayFormatterIssue(_tag, path, formatUnexpectedMessage(issue))]);
    case "Missing":
      return map27(formatMissingMessage(issue), (message) => [makeArrayFormatterIssue(_tag, path, message)]);
    case "Pointer":
      return getArrayFormatterIssues(issue.issue, void 0, path.concat(issue.path));
    case "Composite":
      return flatMap19(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2([makeArrayFormatterIssue(_tag, path, message)]);
        }
        return isNonEmpty6(issue.issues) ? map27(forEach10(issue.issues, (issue2) => getArrayFormatterIssues(issue2, void 0, path)), flatten2) : getArrayFormatterIssues(issue.issues, void 0, path);
      });
    case "Refinement":
      return flatMap19(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2([makeArrayFormatterIssue(_tag, path, message)]);
        }
        return getArrayFormatterIssues(issue.issue, issue.kind === "Predicate" ? _tag : void 0, path);
      });
    case "Transformation":
      return flatMap19(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2([makeArrayFormatterIssue(_tag, path, message)]);
        }
        return getArrayFormatterIssues(issue.issue, issue.kind === "Transformation" ? _tag : void 0, path);
      });
  }
};

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Redacted.js
var isRedacted2 = isRedacted;
var make59 = make57;
var value2 = value;
var getEquivalence7 = (isEquivalent) => make3((x, y) => isEquivalent(value2(x), value2(y)));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Struct.js
var pick4 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys6) => {
  const out = {};
  for (const k of keys6) {
    if (k in s) {
      out[k] = s[k];
    }
  }
  return out;
});
var omit4 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys6) => {
  const out = {
    ...s
  };
  for (const k of keys6) {
    delete out[k];
  }
  return out;
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Schema.js
var TypeId21 = /* @__PURE__ */ Symbol.for("effect/Schema");
function make60(ast) {
  var _a102, _b51, _c6;
  return _b51 = TypeId21, _a102 = TypeId21, _c6 = class {
    constructor() {
      __publicField(this, _b51, variance7);
    }
    static annotations(annotations5) {
      return make60(mergeSchemaAnnotations(this.ast, annotations5));
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static toString() {
      return String(ast);
    }
  }, __publicField(_c6, "ast", ast), __publicField(_c6, "Type"), __publicField(_c6, "Encoded"), __publicField(_c6, "Context"), __publicField(_c6, _a102, variance7), _c6;
}
var variance7 = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _I: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var makeStandardResult = (exit4) => isSuccess2(exit4) ? exit4.value : makeStandardFailureResult(pretty3(exit4.cause));
var makeStandardFailureResult = (message) => ({
  issues: [{
    message
  }]
});
var makeStandardFailureFromParseIssue = (issue) => map18(ArrayFormatter.formatIssue(issue), (issues) => ({
  issues: issues.map((issue2) => ({
    path: issue2.path,
    message: issue2.message
  }))
}));
var standardSchemaV1 = (schema, overrideOptions) => {
  var _a102;
  const decodeUnknown6 = decodeUnknown2(schema, {
    errors: "all"
  });
  return _a102 = class extends make60(schema.ast) {
  }, __publicField(_a102, "~standard", {
    version: 1,
    vendor: "effect",
    validate(value3) {
      const scheduler2 = new SyncScheduler();
      const fiber = runFork2(matchEffect2(decodeUnknown6(value3, overrideOptions), {
        onFailure: makeStandardFailureFromParseIssue,
        onSuccess: (value4) => succeed10({
          value: value4
        })
      }), {
        scheduler: scheduler2
      });
      scheduler2.flush();
      const exit4 = fiber.unsafePoll();
      if (exit4) {
        return makeStandardResult(exit4);
      }
      return new Promise((resolve) => {
        fiber.addObserver((exit5) => {
          resolve(makeStandardResult(exit5));
        });
      });
    }
  }), _a102;
};
var builtInAnnotations = {
  schemaId: SchemaIdAnnotationId,
  message: MessageAnnotationId,
  missingMessage: MissingMessageAnnotationId,
  identifier: IdentifierAnnotationId,
  title: TitleAnnotationId,
  description: DescriptionAnnotationId,
  examples: ExamplesAnnotationId,
  default: DefaultAnnotationId,
  documentation: DocumentationAnnotationId,
  jsonSchema: JSONSchemaAnnotationId,
  arbitrary: ArbitraryAnnotationId,
  pretty: PrettyAnnotationId,
  equivalence: EquivalenceAnnotationId,
  concurrency: ConcurrencyAnnotationId,
  batching: BatchingAnnotationId,
  parseIssueTitle: ParseIssueTitleAnnotationId,
  parseOptions: ParseOptionsAnnotationId,
  decodingFallback: DecodingFallbackAnnotationId
};
var toASTAnnotations = (annotations5) => {
  if (!annotations5) {
    return {};
  }
  const out = {
    ...annotations5
  };
  for (const key in builtInAnnotations) {
    if (key in annotations5) {
      const id3 = builtInAnnotations[key];
      out[id3] = annotations5[key];
      delete out[key];
    }
  }
  return out;
};
var mergeSchemaAnnotations = (ast, annotations5) => annotations(ast, toASTAnnotations(annotations5));
function asSchema(schema) {
  return schema;
}
var format6 = (schema) => String(schema.ast);
var encodedSchema = (schema) => make60(encodedAST(schema.ast));
var encodedBoundSchema = (schema) => make60(encodedBoundAST(schema.ast));
var typeSchema = (schema) => make60(typeAST(schema.ast));
var encodeUnknown2 = (schema, options) => {
  const encodeUnknown5 = encodeUnknown(schema, options);
  return (u, overrideOptions) => mapError8(encodeUnknown5(u, overrideOptions), parseError);
};
var encodeUnknownEither2 = (schema, options) => {
  const encodeUnknownEither5 = encodeUnknownEither(schema, options);
  return (u, overrideOptions) => mapLeft(encodeUnknownEither5(u, overrideOptions), parseError);
};
var encodeUnknownPromise = (schema, options) => {
  const parser = encodeUnknown2(schema, options);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
};
var encode4 = encodeUnknown2;
var encodeEither = encodeUnknownEither2;
var encodePromise = encodeUnknownPromise;
var decodeUnknown3 = (schema, options) => {
  const decodeUnknown6 = decodeUnknown2(schema, options);
  return (u, overrideOptions) => mapError8(decodeUnknown6(u, overrideOptions), parseError);
};
var decodeUnknownEither2 = (schema, options) => {
  const decodeUnknownEither5 = decodeUnknownEither(schema, options);
  return (u, overrideOptions) => mapLeft(decodeUnknownEither5(u, overrideOptions), parseError);
};
var decodeUnknownPromise = (schema, options) => {
  const parser = decodeUnknown3(schema, options);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
};
var decode5 = decodeUnknown3;
var decodeEither = decodeUnknownEither2;
var decodePromise = decodeUnknownPromise;
var validate5 = (schema, options) => {
  const validate8 = validate4(schema, options);
  return (u, overrideOptions) => mapError8(validate8(u, overrideOptions), parseError);
};
var validateEither2 = (schema, options) => {
  const validateEither5 = validateEither(schema, options);
  return (u, overrideOptions) => mapLeft(validateEither5(u, overrideOptions), parseError);
};
var validatePromise = (schema, options) => {
  const parser = validate5(schema, options);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
};
var isSchema = (u) => hasProperty(u, TypeId21) && isObject(u[TypeId21]);
function getDefaultLiteralAST(literals) {
  return isMembers(literals) ? Union.make(mapMembers(literals, (literal2) => new Literal(literal2))) : new Literal(literals[0]);
}
function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
  var _a102;
  return _a102 = class extends make60(ast) {
    static annotations(annotations5) {
      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations5));
    }
  }, __publicField(_a102, "literals", [...literals]), _a102;
}
function Literal2(...literals) {
  return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
}
var pickLiteral = (...literals) => (_schema) => Literal2(...literals);
var UniqueSymbolFromSelf = (symbol4) => make60(new UniqueSymbol(symbol4));
var getDefaultEnumsAST = (enums) => new Enums(Object.keys(enums).filter((key) => typeof enums[enums[key]] !== "number").map((key) => [key, enums[key]]));
var makeEnumsClass = (enums, ast = getDefaultEnumsAST(enums)) => {
  var _a102;
  return _a102 = class extends make60(ast) {
    static annotations(annotations5) {
      return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations5));
    }
  }, __publicField(_a102, "enums", {
    ...enums
  }), _a102;
};
var Enums2 = (enums) => makeEnumsClass(enums);
var TemplateLiteral2 = (...[head8, ...tail2]) => {
  const spans = [];
  let h = "";
  let ts = tail2;
  if (isSchema(head8)) {
    if (isLiteral(head8.ast)) {
      h = String(head8.ast.literal);
    } else {
      ts = [head8, ...ts];
    }
  } else {
    h = String(head8);
  }
  for (let i = 0; i < ts.length; i++) {
    const item = ts[i];
    if (isSchema(item)) {
      if (i < ts.length - 1) {
        const next4 = ts[i + 1];
        if (isSchema(next4)) {
          if (isLiteral(next4.ast)) {
            spans.push(new TemplateLiteralSpan(item.ast, String(next4.ast.literal)));
            i++;
            continue;
          }
        } else {
          spans.push(new TemplateLiteralSpan(item.ast, String(next4)));
          i++;
          continue;
        }
      }
      spans.push(new TemplateLiteralSpan(item.ast, ""));
    } else {
      spans.push(new TemplateLiteralSpan(new Literal(item), ""));
    }
  }
  if (isNonEmptyArray2(spans)) {
    return make60(new TemplateLiteral(h, spans));
  } else {
    return make60(new TemplateLiteral("", [new TemplateLiteralSpan(new Literal(h), "")]));
  }
};
function getTemplateLiteralParserCoercedElement(encoded, schema) {
  const ast = encoded.ast;
  switch (ast._tag) {
    case "Literal": {
      const literal2 = ast.literal;
      if (!isString(literal2)) {
        const s = String(literal2);
        return transform2(Literal2(s), schema, {
          strict: true,
          decode: () => literal2,
          encode: () => s
        });
      }
      break;
    }
    case "NumberKeyword":
      return compose4(NumberFromString, schema);
    case "Union": {
      const members = [];
      let hasCoercions = false;
      for (const member of ast.types) {
        const schema2 = make60(member);
        const encoded2 = encodedSchema(schema2);
        const coerced = getTemplateLiteralParserCoercedElement(encoded2, schema2);
        if (coerced) {
          hasCoercions = true;
        }
        members.push(coerced ?? schema2);
      }
      return hasCoercions ? compose4(Union2(...members), schema) : schema;
    }
  }
}
var TemplateLiteralParser = (...params) => {
  var _a102;
  const encodedSchemas = [];
  const elements = [];
  const schemas = [];
  let coerced = false;
  for (let i = 0; i < params.length; i++) {
    const param = params[i];
    const schema = isSchema(param) ? param : Literal2(param);
    schemas.push(schema);
    const encoded = encodedSchema(schema);
    encodedSchemas.push(encoded);
    const element3 = getTemplateLiteralParserCoercedElement(encoded, schema);
    if (element3) {
      elements.push(element3);
      coerced = true;
    } else {
      elements.push(schema);
    }
  }
  const from = TemplateLiteral2(...encodedSchemas);
  const re = getTemplateLiteralCapturingRegExp(from.ast);
  let to = Tuple(...elements);
  if (coerced) {
    to = to.annotations({
      [AutoTitleAnnotationId]: format6(Tuple(...schemas))
    });
  }
  return _a102 = class extends transformOrFail(from, to, {
    strict: false,
    decode: (i, _, ast) => {
      const match21 = re.exec(i);
      return match21 ? succeed19(match21.slice(1, params.length + 1)) : fail19(new Type2(ast, i, `${re.source}: no match for ${JSON.stringify(i)}`));
    },
    encode: (tuple4) => succeed19(tuple4.join(""))
  }) {
  }, __publicField(_a102, "params", params.slice()), _a102;
};
var declareConstructor = (typeParameters, options, annotations5) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options.decode(...typeParameters2.map(make60)), (...typeParameters2) => options.encode(...typeParameters2.map(make60)), toASTAnnotations(annotations5)));
var declarePrimitive = (is4, annotations5) => {
  const decodeUnknown6 = () => (input, _, ast) => is4(input) ? succeed19(input) : fail19(new Type2(ast, input));
  const encodeUnknown5 = decodeUnknown6;
  return makeDeclareClass([], new Declaration([], decodeUnknown6, encodeUnknown5, toASTAnnotations(annotations5)));
};
function makeDeclareClass(typeParameters, ast) {
  var _a102;
  return _a102 = class extends make60(ast) {
    static annotations(annotations5) {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations5));
    }
  }, __publicField(_a102, "typeParameters", [...typeParameters]), _a102;
}
var declare = function() {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options = arguments[1];
    const annotations6 = arguments[2];
    return declareConstructor(typeParameters, options, annotations6);
  }
  const is4 = arguments[0];
  const annotations5 = arguments[1];
  return declarePrimitive(is4, annotations5);
};
var BrandSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Brand");
var fromBrand = (constructor, annotations5) => (self) => {
  const out = makeBrandClass(self, new Refinement(self.ast, function predicate(a, _, ast) {
    const either8 = constructor.either(a);
    return isLeft2(either8) ? some2(new Type2(ast, a, either8.left.map((v) => v.message).join(", "))) : none2();
  }, toASTAnnotations({
    schemaId: BrandSchemaId,
    [BrandSchemaId]: {
      constructor
    },
    ...annotations5
  })));
  return out;
};
var InstanceOfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/InstanceOf");
var instanceOf = (constructor, annotations5) => declare((u) => u instanceof constructor, {
  title: constructor.name,
  description: `an instance of ${constructor.name}`,
  pretty: () => String,
  schemaId: InstanceOfSchemaId,
  [InstanceOfSchemaId]: {
    constructor
  },
  ...annotations5
});
var Undefined = class extends (/* @__PURE__ */ make60(undefinedKeyword)) {
};
var Void = class extends (/* @__PURE__ */ make60(voidKeyword)) {
};
var Null = class extends (/* @__PURE__ */ make60($null)) {
};
var Never = class extends (/* @__PURE__ */ make60(neverKeyword)) {
};
var Unknown = class extends (/* @__PURE__ */ make60(unknownKeyword)) {
};
var Any = class extends (/* @__PURE__ */ make60(anyKeyword)) {
};
var BigIntFromSelf = class extends (/* @__PURE__ */ make60(bigIntKeyword)) {
};
var SymbolFromSelf = class extends (/* @__PURE__ */ make60(symbolKeyword)) {
};
var String$ = class extends (/* @__PURE__ */ make60(stringKeyword)) {
};
var Number$ = class extends (/* @__PURE__ */ make60(numberKeyword)) {
};
var Boolean$ = class extends (/* @__PURE__ */ make60(booleanKeyword)) {
};
var Object$ = class extends (/* @__PURE__ */ make60(objectKeyword)) {
};
var getDefaultUnionAST = (members) => Union.make(members.map((m) => m.ast));
function makeUnionClass(members, ast = getDefaultUnionAST(members)) {
  var _a102;
  return _a102 = class extends make60(ast) {
    static annotations(annotations5) {
      return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations5));
    }
  }, __publicField(_a102, "members", [...members]), _a102;
}
function Union2(...members) {
  return isMembers(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never;
}
var NullOr = (self) => Union2(self, Null);
var UndefinedOr = (self) => Union2(self, Undefined);
var NullishOr = (self) => Union2(self, Null, Undefined);
var keyof2 = (self) => make60(keyof(self.ast));
var element = (self) => new ElementImpl(new OptionalType(self.ast, false), self);
var optionalElement = (self) => new ElementImpl(new OptionalType(self.ast, true), self);
var _a74;
_a74 = TypeId21;
var _ElementImpl = class _ElementImpl {
  constructor(ast, from) {
    __publicField(this, "ast");
    __publicField(this, "from");
    __publicField(this, _a74);
    __publicField(this, "_Token");
    this.ast = ast;
    this.from = from;
  }
  annotations(annotations5) {
    return new _ElementImpl(new OptionalType(this.ast.type, this.ast.isOptional, {
      ...this.ast.annotations,
      ...toASTAnnotations(annotations5)
    }), this.from);
  }
  toString() {
    return `${this.ast.type}${this.ast.isOptional ? "?" : ""}`;
  }
};
var ElementImpl = _ElementImpl;
var getDefaultTupleTypeAST = (elements, rest) => new TupleType(elements.map((el) => isSchema(el) ? new OptionalType(el.ast, false) : el.ast), rest.map((el) => isSchema(el) ? new Type(el.ast) : el.ast), true);
function makeTupleTypeClass(elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) {
  var _a102;
  return _a102 = class extends make60(ast) {
    static annotations(annotations5) {
      return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations5));
    }
  }, __publicField(_a102, "elements", [...elements]), __publicField(_a102, "rest", [...rest]), _a102;
}
function Tuple(...args2) {
  return Array.isArray(args2[0]) ? makeTupleTypeClass(args2[0], args2.slice(1)) : makeTupleTypeClass(args2, []);
}
function makeArrayClass(value3, ast) {
  var _a102;
  return _a102 = class extends makeTupleTypeClass([], [value3], ast) {
    static annotations(annotations5) {
      return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations5));
    }
  }, __publicField(_a102, "value", value3), _a102;
}
var Array$ = (value3) => makeArrayClass(value3);
function makeNonEmptyArrayClass(value3, ast) {
  var _a102;
  return _a102 = class extends makeTupleTypeClass([value3], [value3], ast) {
    static annotations(annotations5) {
      return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations5));
    }
  }, __publicField(_a102, "value", value3), _a102;
}
var NonEmptyArray = (value3) => makeNonEmptyArrayClass(value3);
function ArrayEnsure(value3) {
  return transform2(Union2(value3, Array$(value3)), Array$(typeSchema(asSchema(value3))), {
    strict: true,
    decode: (i) => ensure(i),
    encode: (a) => a.length === 1 ? a[0] : a
  });
}
function NonEmptyArrayEnsure(value3) {
  return transform2(Union2(value3, NonEmptyArray(value3)), NonEmptyArray(typeSchema(asSchema(value3))), {
    strict: true,
    decode: (i) => isNonEmptyReadonlyArray(i) ? i : of(i),
    encode: (a) => a.length === 1 ? a[0] : a
  });
}
var formatPropertySignatureToken = (isOptional) => isOptional ? '"?:"' : '":"';
var PropertySignatureDeclaration = class extends OptionalType {
  constructor(type, isOptional, isReadonly, annotations5, defaultValue) {
    super(type, isOptional, annotations5);
    __publicField(this, "isReadonly");
    __publicField(this, "defaultValue");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "PropertySignatureDeclaration");
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    const token = formatPropertySignatureToken(this.isOptional);
    const type = String(this.type);
    return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`;
  }
};
var FromPropertySignature = class extends OptionalType {
  constructor(type, isOptional, isReadonly, annotations5, fromKey3) {
    super(type, isOptional, annotations5);
    __publicField(this, "isReadonly");
    __publicField(this, "fromKey");
    this.isReadonly = isReadonly;
    this.fromKey = fromKey3;
  }
};
var ToPropertySignature = class extends OptionalType {
  constructor(type, isOptional, isReadonly, annotations5, defaultValue) {
    super(type, isOptional, annotations5);
    __publicField(this, "isReadonly");
    __publicField(this, "defaultValue");
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
};
var formatPropertyKey2 = (p) => {
  if (p === void 0) {
    return "never";
  }
  if (isString(p)) {
    return JSON.stringify(p);
  }
  return String(p);
};
var PropertySignatureTransformation2 = class {
  constructor(from, to, decode7, encode6) {
    __publicField(this, "from");
    __publicField(this, "to");
    __publicField(this, "decode");
    __publicField(this, "encode");
    /**
     * @since 3.10.0
     */
    __publicField(this, "_tag", "PropertySignatureTransformation");
    this.from = from;
    this.to = to;
    this.decode = decode7;
    this.encode = encode6;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey2(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
  }
};
var mergeSignatureAnnotations = (ast, annotations5) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
        ...ast.annotations,
        ...annotations5
      }, ast.defaultValue);
    }
    case "PropertySignatureTransformation": {
      return new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
        ...ast.to.annotations,
        ...annotations5
      }, ast.to.defaultValue), ast.decode, ast.encode);
    }
  }
};
var PropertySignatureTypeId = /* @__PURE__ */ Symbol.for("effect/PropertySignature");
var isPropertySignature = (u) => hasProperty(u, PropertySignatureTypeId);
var _a75, _b26;
_b26 = TypeId21, _a75 = PropertySignatureTypeId;
var _PropertySignatureImpl = class _PropertySignatureImpl {
  constructor(ast) {
    __publicField(this, "ast");
    __publicField(this, _b26);
    __publicField(this, _a75, null);
    __publicField(this, "_TypeToken");
    __publicField(this, "_Key");
    __publicField(this, "_EncodedToken");
    __publicField(this, "_HasDefault");
    this.ast = ast;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  annotations(annotations5) {
    return new _PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations5)));
  }
  toString() {
    return String(this.ast);
  }
};
var PropertySignatureImpl = _PropertySignatureImpl;
var makePropertySignature = (ast) => new PropertySignatureImpl(ast);
var PropertySignatureWithFromImpl = class _PropertySignatureWithFromImpl extends PropertySignatureImpl {
  constructor(ast, from) {
    super(ast);
    __publicField(this, "from");
    this.from = from;
  }
  annotations(annotations5) {
    return new _PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations5)), this.from);
  }
};
var propertySignature = (self) => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self.ast, false, true, {}, void 0), self);
var withConstructorDefault = /* @__PURE__ */ dual(2, (self, defaultValue) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
  }
});
var applyDefaultValue = (o, defaultValue) => match2(o, {
  onNone: () => some2(defaultValue()),
  onSome: (value3) => some2(value3 === void 0 ? defaultValue() : value3)
});
var pruneUndefined2 = (ast) => pruneUndefined(ast, pruneUndefined2, (ast2) => {
  const pruned = pruneUndefined2(ast2.to);
  if (pruned) {
    return new Transformation(ast2.from, pruned, ast2.transformation);
  }
});
var withDecodingDefault = /* @__PURE__ */ dual(2, (self, defaultValue) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      const to = typeAST(ast.type);
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations), new ToPropertySignature(pruneUndefined2(to) ?? to, false, true, {}, ast.defaultValue), (o) => applyDefaultValue(o, defaultValue), identity));
    }
    case "PropertySignatureTransformation": {
      const to = ast.to.type;
      return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(pruneUndefined2(to) ?? to, false, ast.to.isReadonly, ast.to.annotations, ast.to.defaultValue), (o) => applyDefaultValue(ast.decode(o), defaultValue), ast.encode));
    }
  }
});
var withDefaults = /* @__PURE__ */ dual(2, (self, defaults) => self.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)));
var fromKey = /* @__PURE__ */ dual(2, (self, key) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, key), new ToPropertySignature(typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue), identity, identity));
    }
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations, key), ast.to, ast.decode, ast.encode));
  }
});
var optionalToRequired = (from, to, options) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from.ast, true, true, {}, void 0), new ToPropertySignature(to.ast, false, true, {}, void 0), (o) => some2(options.decode(o)), flatMap(options.encode)));
var requiredToOptional = (from, to, options) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from.ast, false, true, {}, void 0), new ToPropertySignature(to.ast, true, true, {}, void 0), flatMap(options.decode), (o) => some2(options.encode(o))));
var optionalToOptional = (from, to, options) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from.ast, true, true, {}, void 0), new ToPropertySignature(to.ast, true, true, {}, void 0), options.decode, options.encode));
var optionalPropertySignatureAST = (self, options) => {
  const isExact = options?.exact;
  const defaultValue = options?.default;
  const isNullable2 = options?.nullable;
  const asOption = options?.as == "Option";
  const asOptionEncode = options?.onNoneEncoding ? orElse(options.onNoneEncoding) : identity;
  if (isExact) {
    if (defaultValue) {
      if (isNullable2) {
        return withConstructorDefault(optionalToRequired(NullOr(self), typeSchema(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a === null ? defaultValue() : a
          }),
          encode: some2
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(self, typeSchema(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: identity
          }),
          encode: some2
        }), defaultValue).ast;
      }
    } else if (asOption) {
      if (isNullable2) {
        return optionalToRequired(NullOr(self), OptionFromSelf(typeSchema(self)), {
          decode: filter(isNotNull),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(self, OptionFromSelf(typeSchema(self)), {
          decode: identity,
          encode: identity
        }).ast;
      }
    } else {
      if (isNullable2) {
        return optionalToOptional(NullOr(self), typeSchema(self), {
          decode: filter(isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(self.ast, true, true, {}, void 0);
      }
    }
  } else {
    if (defaultValue) {
      if (isNullable2) {
        return withConstructorDefault(optionalToRequired(NullishOr(self), typeSchema(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a == null ? defaultValue() : a
          }),
          encode: some2
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(UndefinedOr(self), typeSchema(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a === void 0 ? defaultValue() : a
          }),
          encode: some2
        }), defaultValue).ast;
      }
    } else if (asOption) {
      if (isNullable2) {
        return optionalToRequired(NullishOr(self), OptionFromSelf(typeSchema(self)), {
          decode: filter((a) => a != null),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(UndefinedOr(self), OptionFromSelf(typeSchema(self)), {
          decode: filter(isNotUndefined),
          encode: asOptionEncode
        }).ast;
      }
    } else {
      if (isNullable2) {
        return optionalToOptional(NullishOr(self), UndefinedOr(typeSchema(self)), {
          decode: filter(isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(UndefinedOr(self).ast, true, true, {}, void 0);
      }
    }
  }
};
var optional = (self) => {
  const ast = self.ast === undefinedKeyword || self.ast === neverKeyword ? undefinedKeyword : UndefinedOr(self).ast;
  return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, void 0), self);
};
var optionalWith = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (self, options) => {
  return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(self, options), self);
});
var preserveMissingMessageAnnotation = /* @__PURE__ */ pickAnnotations([MissingMessageAnnotationId]);
var getDefaultTypeLiteralAST = (fields, records) => {
  const ownKeys3 = ownKeys(fields);
  const pss = [];
  if (ownKeys3.length > 0) {
    const from = [];
    const to = [];
    const transformations = [];
    for (let i = 0; i < ownKeys3.length; i++) {
      const key = ownKeys3[i];
      const field = fields[key];
      if (isPropertySignature(field)) {
        const ast = field.ast;
        switch (ast._tag) {
          case "PropertySignatureDeclaration": {
            const type = ast.type;
            const isOptional = ast.isOptional;
            const toAnnotations = ast.annotations;
            from.push(new PropertySignature(key, type, isOptional, true, preserveMissingMessageAnnotation(ast)));
            to.push(new PropertySignature(key, typeAST(type), isOptional, true, toAnnotations));
            pss.push(new PropertySignature(key, type, isOptional, true, toAnnotations));
            break;
          }
          case "PropertySignatureTransformation": {
            const fromKey3 = ast.from.fromKey ?? key;
            from.push(new PropertySignature(fromKey3, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
            to.push(new PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
            transformations.push(new PropertySignatureTransformation(fromKey3, key, ast.decode, ast.encode));
            break;
          }
        }
      } else {
        from.push(new PropertySignature(key, field.ast, false, true));
        to.push(new PropertySignature(key, typeAST(field.ast), false, true));
        pss.push(new PropertySignature(key, field.ast, false, true));
      }
    }
    if (isNonEmptyReadonlyArray(transformations)) {
      const issFrom = [];
      const issTo = [];
      for (const r of records) {
        const {
          indexSignatures,
          propertySignatures
        } = record2(r.key.ast, r.value.ast);
        propertySignatures.forEach((ps) => {
          from.push(ps);
          to.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
        });
        indexSignatures.forEach((is4) => {
          issFrom.push(is4);
          issTo.push(new IndexSignature(is4.parameter, typeAST(is4.type), is4.isReadonly));
        });
      }
      return new Transformation(new TypeLiteral(from, issFrom, {
        [AutoTitleAnnotationId]: "Struct (Encoded side)"
      }), new TypeLiteral(to, issTo, {
        [AutoTitleAnnotationId]: "Struct (Type side)"
      }), new TypeLiteralTransformation(transformations));
    }
  }
  const iss = [];
  for (const r of records) {
    const {
      indexSignatures,
      propertySignatures
    } = record2(r.key.ast, r.value.ast);
    propertySignatures.forEach((ps) => pss.push(ps));
    indexSignatures.forEach((is4) => iss.push(is4));
  }
  return new TypeLiteral(pss, iss);
};
var lazilyMergeDefaults = (fields, out) => {
  const ownKeys3 = ownKeys(fields);
  for (const key of ownKeys3) {
    const field = fields[key];
    if (out[key] === void 0 && isPropertySignature(field)) {
      const ast = field.ast;
      const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
      if (defaultValue !== void 0) {
        out[key] = defaultValue();
      }
    }
  }
  return out;
};
function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
  var _a102;
  return _a102 = class extends make60(ast) {
    static annotations(annotations5) {
      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations5));
    }
    static pick(...keys6) {
      return Struct(pick4(fields, ...keys6));
    }
    static omit(...keys6) {
      return Struct(omit4(fields, ...keys6));
    }
  }, __publicField(_a102, "fields", {
    ...fields
  }), __publicField(_a102, "records", [...records]), __publicField(_a102, "make", (props, options) => {
    const propsWithDefaults = lazilyMergeDefaults(fields, {
      ...props
    });
    return getDisableValidationMakeOption(options) ? propsWithDefaults : validateSync(_a102)(propsWithDefaults);
  }), _a102;
}
function Struct(fields, ...records) {
  return makeTypeLiteralClass(fields, records);
}
var tag = (tag3) => Literal2(tag3).pipe(propertySignature, withConstructorDefault(() => tag3));
var TaggedStruct = (value3, fields) => Struct({
  _tag: tag(value3),
  ...fields
});
function makeRecordClass(key, value3, ast) {
  var _a102;
  return _a102 = class extends makeTypeLiteralClass({}, [{
    key,
    value: value3
  }], ast) {
    static annotations(annotations5) {
      return makeRecordClass(key, value3, mergeSchemaAnnotations(this.ast, annotations5));
    }
  }, __publicField(_a102, "key", key), __publicField(_a102, "value", value3), _a102;
}
var Record = (options) => makeRecordClass(options.key, options.value);
var pick5 = (...keys6) => (self) => make60(pick3(self.ast, keys6));
var omit5 = (...keys6) => (self) => make60(omit3(self.ast, keys6));
var pluck = /* @__PURE__ */ dual(2, (schema, key) => {
  const ps = getPropertyKeyIndexedAccess(typeAST(schema.ast), key);
  const value3 = make60(ps.isOptional ? orUndefined(ps.type) : ps.type);
  const out = transform2(schema.pipe(pick5(key)), value3, {
    strict: true,
    decode: (i) => i[key],
    encode: (a) => ps.isOptional && a === void 0 ? {} : {
      [key]: a
    }
  });
  return out;
});
function makeBrandClass(from, ast) {
  var _a102;
  return _a102 = class extends make60(ast) {
    static annotations(annotations5) {
      return makeBrandClass(this.from, mergeSchemaAnnotations(this.ast, annotations5));
    }
  }, __publicField(_a102, "make", (a, options) => {
    return getDisableValidationMakeOption(options) ? a : validateSync(_a102)(a);
  }), __publicField(_a102, "from", from), _a102;
}
var brand = (brand3, annotations5) => (self) => {
  const annotation = match2(getBrandAnnotation(self.ast), {
    onNone: () => [brand3],
    onSome: (brands) => [...brands, brand3]
  });
  const ast = annotations(self.ast, toASTAnnotations({
    [BrandAnnotationId]: annotation,
    ...annotations5
  }));
  return makeBrandClass(self, ast);
};
var partial2 = (self) => make60(partial(self.ast));
var partialWith = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (self, options) => make60(partial(self.ast, options)));
var required2 = (self) => make60(required(self.ast));
var mutable2 = (schema) => make60(mutable(schema.ast));
var intersectTypeLiterals = (x, y, path) => {
  if (isTypeLiteral(x) && isTypeLiteral(y)) {
    const propertySignatures = [...x.propertySignatures];
    for (const ps of y.propertySignatures) {
      const name = ps.name;
      const i = propertySignatures.findIndex((ps2) => ps2.name === name);
      if (i === -1) {
        propertySignatures.push(ps);
      } else {
        const {
          isOptional,
          type
        } = propertySignatures[i];
        propertySignatures[i] = new PropertySignature(name, extendAST(type, ps.type, path.concat(name)), isOptional, true);
      }
    }
    return new TypeLiteral(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
  }
  throw new Error(getSchemaExtendErrorMessage(x, y, path));
};
var preserveRefinementAnnotations = /* @__PURE__ */ omitAnnotations([IdentifierAnnotationId]);
var addRefinementToMembers = (refinement, asts) => asts.map((ast) => new Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)));
var extendAST = (x, y, path) => Union.make(intersectUnionMembers([x], [y], path));
var getTypes = (ast) => isUnion(ast) ? ast.types : [ast];
var intersectUnionMembers = (xs, ys, path) => flatMap2(xs, (x) => flatMap2(ys, (y) => {
  switch (y._tag) {
    case "Literal": {
      if (isString(y.literal) && isStringKeyword(x) || isNumber(y.literal) && isNumberKeyword(x) || isBoolean(y.literal) && isBooleanKeyword(x)) {
        return [y];
      }
      break;
    }
    case "StringKeyword": {
      if (y === stringKeyword) {
        if (isStringKeyword(x) || isLiteral(x) && isString(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        }
      } else if (x === stringKeyword) {
        return [y];
      }
      break;
    }
    case "NumberKeyword": {
      if (y === numberKeyword) {
        if (isNumberKeyword(x) || isLiteral(x) && isNumber(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        }
      } else if (x === numberKeyword) {
        return [y];
      }
      break;
    }
    case "BooleanKeyword": {
      if (y === booleanKeyword) {
        if (isBooleanKeyword(x) || isLiteral(x) && isBoolean(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        }
      } else if (x === booleanKeyword) {
        return [y];
      }
      break;
    }
    case "Union":
      return intersectUnionMembers(getTypes(x), y.types, path);
    case "Suspend":
      return [new Suspend(() => extendAST(x, y.f(), path))];
    case "Refinement":
      return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path));
    case "TypeLiteral": {
      switch (x._tag) {
        case "Union":
          return intersectUnionMembers(x.types, [y], path);
        case "Suspend":
          return [new Suspend(() => extendAST(x.f(), y, path))];
        case "Refinement":
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        case "TypeLiteral":
          return [intersectTypeLiterals(x, y, path)];
        case "Transformation": {
          const transformation = x.transformation;
          const from = intersectTypeLiterals(x.from, y, path);
          const to = intersectTypeLiterals(x.to, typeAST(y), path);
          switch (transformation._tag) {
            case "TypeLiteralTransformation":
              return [new Transformation(from, to, new TypeLiteralTransformation(transformation.propertySignatureTransformations))];
            case "ComposeTransformation":
              return [new Transformation(from, to, composeTransformation)];
            case "FinalTransformation":
              return [new Transformation(from, to, new FinalTransformation((fromA, options, ast, fromI) => map27(transformation.decode(fromA, options, ast, fromI), (partial5) => ({
                ...fromA,
                ...partial5
              })), (toI, options, ast, toA) => map27(transformation.encode(toI, options, ast, toA), (partial5) => ({
                ...toI,
                ...partial5
              }))))];
          }
        }
      }
      break;
    }
    case "Transformation": {
      if (isTransformation(x)) {
        if (isTypeLiteralTransformation(y.transformation) && isTypeLiteralTransformation(x.transformation)) {
          return [new Transformation(intersectTypeLiterals(x.from, y.from, path), intersectTypeLiterals(x.to, y.to, path), new TypeLiteralTransformation(y.transformation.propertySignatureTransformations.concat(x.transformation.propertySignatureTransformations)))];
        }
      } else {
        return intersectUnionMembers([y], [x], path);
      }
      break;
    }
  }
  throw new Error(getSchemaExtendErrorMessage(x, y, path));
}));
var extend3 = /* @__PURE__ */ dual(2, (self, that) => make60(extendAST(self.ast, that.ast, [])));
var compose4 = /* @__PURE__ */ dual((args2) => isSchema(args2[1]), (from, to) => makeTransformationClass(from, to, compose3(from.ast, to.ast)));
var suspend13 = (f) => make60(new Suspend(() => f().ast));
var RefineSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Refine");
function makeRefineClass(from, filter14, ast) {
  var _a102, _b51, _c6;
  return _c6 = class extends (_b51 = make60(ast), _a102 = RefineSchemaId, _b51) {
    static annotations(annotations5) {
      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations5));
    }
  }, __publicField(_c6, _a102, from), __publicField(_c6, "from", from), __publicField(_c6, "filter", filter14), __publicField(_c6, "make", (a, options) => {
    return getDisableValidationMakeOption(options) ? a : validateSync(_c6)(a);
  }), _c6;
}
var fromFilterPredicateReturnTypeItem = (item, ast, input) => {
  if (isBoolean(item)) {
    return item ? none2() : some2(new Type2(ast, input));
  }
  if (isString(item)) {
    return some2(new Type2(ast, input, item));
  }
  if (item !== void 0) {
    if ("_tag" in item) {
      return some2(item);
    }
    const issue = new Type2(ast, input, item.message);
    return some2(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
  }
  return none2();
};
var toFilterParseIssue = (out, ast, input) => {
  if (isSingle(out)) {
    return fromFilterPredicateReturnTypeItem(out, ast, input);
  }
  if (isNonEmptyReadonlyArray(out)) {
    const issues = filterMap3(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
    if (isNonEmptyReadonlyArray(issues)) {
      return some2(issues.length === 1 ? issues[0] : new Composite2(ast, input, issues));
    }
  }
  return none2();
};
function filter12(predicate, annotations5) {
  return (self) => {
    function filter14(input, options, ast2) {
      return toFilterParseIssue(predicate(input, options, ast2), ast2, input);
    }
    const ast = new Refinement(self.ast, filter14, toASTAnnotations(annotations5));
    return makeRefineClass(self, filter14, ast);
  };
}
var filterEffect3 = /* @__PURE__ */ dual(2, (self, f) => transformOrFail(self, typeSchema(self), {
  strict: true,
  decode: (i, options, ast) => flatMap19(f(i, options, ast), (filterReturnType) => match2(toFilterParseIssue(filterReturnType, ast, i), {
    onNone: () => succeed19(i),
    onSome: fail19
  })),
  encode: (a) => succeed19(a)
}));
function makeTransformationClass(from, to, ast) {
  var _a102;
  return _a102 = class extends make60(ast) {
    static annotations(annotations5) {
      return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations5));
    }
  }, __publicField(_a102, "from", from), __publicField(_a102, "to", to), _a102;
}
var transformOrFail = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options) => makeTransformationClass(from, to, new Transformation(from.ast, to.ast, new FinalTransformation(options.decode, options.encode))));
var transform2 = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options) => transformOrFail(from, to, {
  strict: true,
  decode: (fromA, _options, _ast, toA) => succeed19(options.decode(fromA, toA)),
  encode: (toI, _options, _ast, toA) => succeed19(options.encode(toI, toA))
}));
function transformLiteral(from, to) {
  return transform2(Literal2(from), Literal2(to), {
    strict: true,
    decode: () => to,
    encode: () => from
  });
}
function transformLiterals(...pairs) {
  return Union2(...pairs.map(([from, to]) => transformLiteral(from, to)));
}
var attachPropertySignature = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (schema, key, value3, annotations5) => {
  const ast = extend3(typeSchema(schema), Struct({
    [key]: isSymbol(value3) ? UniqueSymbolFromSelf(value3) : Literal2(value3)
  })).ast;
  return make60(new Transformation(schema.ast, annotations5 ? mergeSchemaAnnotations(ast, annotations5) : ast, new TypeLiteralTransformation([new PropertySignatureTransformation(key, key, () => some2(value3), () => none2())])));
});
var annotations2 = /* @__PURE__ */ dual(2, (self, annotations5) => self.annotations(annotations5));
var rename2 = /* @__PURE__ */ dual(2, (self, mapping) => make60(rename(self.ast, mapping)));
var TrimmedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Trimmed");
var trimmed = (annotations5) => (self) => self.pipe(filter12((a) => a === a.trim(), {
  schemaId: TrimmedSchemaId,
  title: "trimmed",
  description: "a string with no leading or trailing whitespace",
  jsonSchema: {
    pattern: "^\\S[\\s\\S]*\\S$|^\\S$|^$"
  },
  ...annotations5
}));
var MaxLengthSchemaId2 = MaxLengthSchemaId;
var maxLength = (maxLength3, annotations5) => (self) => self.pipe(filter12((a) => a.length <= maxLength3, {
  schemaId: MaxLengthSchemaId2,
  title: `maxLength(${maxLength3})`,
  description: `a string at most ${maxLength3} character(s) long`,
  jsonSchema: {
    maxLength: maxLength3
  },
  ...annotations5
}));
var MinLengthSchemaId2 = MinLengthSchemaId;
var minLength = (minLength3, annotations5) => (self) => self.pipe(filter12((a) => a.length >= minLength3, {
  schemaId: MinLengthSchemaId2,
  title: `minLength(${minLength3})`,
  description: `a string at least ${minLength3} character(s) long`,
  jsonSchema: {
    minLength: minLength3
  },
  ...annotations5
}));
var LengthSchemaId2 = LengthSchemaId;
var length3 = (length5, annotations5) => (self) => {
  const minLength3 = isObject(length5) ? Math.max(0, Math.floor(length5.min)) : Math.max(0, Math.floor(length5));
  const maxLength3 = isObject(length5) ? Math.max(minLength3, Math.floor(length5.max)) : minLength3;
  if (minLength3 !== maxLength3) {
    return self.pipe(filter12((a) => a.length >= minLength3 && a.length <= maxLength3, {
      schemaId: LengthSchemaId2,
      title: `length({ min: ${minLength3}, max: ${maxLength3})`,
      description: `a string at least ${minLength3} character(s) and at most ${maxLength3} character(s) long`,
      jsonSchema: {
        minLength: minLength3,
        maxLength: maxLength3
      },
      ...annotations5
    }));
  }
  return self.pipe(filter12((a) => a.length === minLength3, {
    schemaId: LengthSchemaId2,
    title: `length(${minLength3})`,
    description: minLength3 === 1 ? `a single character` : `a string ${minLength3} character(s) long`,
    jsonSchema: {
      minLength: minLength3,
      maxLength: minLength3
    },
    ...annotations5
  }));
};
var PatternSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Pattern");
var pattern = (regex, annotations5) => (self) => {
  const source = regex.source;
  return self.pipe(filter12((a) => {
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    schemaId: PatternSchemaId,
    [PatternSchemaId]: {
      regex
    },
    // title: `pattern(/${source}/)`, // avoiding this because it can be very long
    description: `a string matching the pattern ${source}`,
    jsonSchema: {
      pattern: source
    },
    ...annotations5
  }));
};
var StartsWithSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/StartsWith");
var startsWith = (startsWith3, annotations5) => (self) => {
  const formatted = JSON.stringify(startsWith3);
  return self.pipe(filter12((a) => a.startsWith(startsWith3), {
    schemaId: StartsWithSchemaId,
    [StartsWithSchemaId]: {
      startsWith: startsWith3
    },
    title: `startsWith(${formatted})`,
    description: `a string starting with ${formatted}`,
    jsonSchema: {
      pattern: `^${startsWith3}`
    },
    ...annotations5
  }));
};
var EndsWithSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/EndsWith");
var endsWith = (endsWith3, annotations5) => (self) => {
  const formatted = JSON.stringify(endsWith3);
  return self.pipe(filter12((a) => a.endsWith(endsWith3), {
    schemaId: EndsWithSchemaId,
    [EndsWithSchemaId]: {
      endsWith: endsWith3
    },
    title: `endsWith(${formatted})`,
    description: `a string ending with ${formatted}`,
    jsonSchema: {
      pattern: `^.*${endsWith3}$`
    },
    ...annotations5
  }));
};
var IncludesSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Includes");
var includes = (searchString, annotations5) => (self) => {
  const formatted = JSON.stringify(searchString);
  return self.pipe(filter12((a) => a.includes(searchString), {
    schemaId: IncludesSchemaId,
    [IncludesSchemaId]: {
      includes: searchString
    },
    title: `includes(${formatted})`,
    description: `a string including ${formatted}`,
    jsonSchema: {
      pattern: `.*${searchString}.*`
    },
    ...annotations5
  }));
};
var LowercasedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Lowercased");
var lowercased = (annotations5) => (self) => self.pipe(filter12((a) => a === a.toLowerCase(), {
  schemaId: LowercasedSchemaId,
  title: "lowercased",
  description: "a lowercase string",
  jsonSchema: {
    pattern: "^[^A-Z]*$"
  },
  ...annotations5
}));
var Lowercased = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ lowercased({
  identifier: "Lowercased"
}))) {
};
var UppercasedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Uppercased");
var uppercased = (annotations5) => (self) => self.pipe(filter12((a) => a === a.toUpperCase(), {
  schemaId: UppercasedSchemaId,
  title: "uppercased",
  description: "an uppercase string",
  jsonSchema: {
    pattern: "^[^a-z]*$"
  },
  ...annotations5
}));
var Uppercased = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ uppercased({
  identifier: "Uppercased"
}))) {
};
var CapitalizedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Capitalized");
var capitalized = (annotations5) => (self) => self.pipe(filter12((a) => a[0]?.toUpperCase() === a[0], {
  schemaId: CapitalizedSchemaId,
  title: "capitalized",
  description: "a capitalized string",
  jsonSchema: {
    pattern: "^[^a-z]?.*$"
  },
  ...annotations5
}));
var Capitalized = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ capitalized({
  identifier: "Capitalized"
}))) {
};
var UncapitalizedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Uncapitalized");
var uncapitalized = (annotations5) => (self) => self.pipe(filter12((a) => a[0]?.toLowerCase() === a[0], {
  schemaId: UncapitalizedSchemaId,
  title: "uncapitalized",
  description: "a uncapitalized string",
  jsonSchema: {
    pattern: "^[^A-Z]?.*$"
  },
  ...annotations5
}));
var Uncapitalized = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ uncapitalized({
  identifier: "Uncapitalized"
}))) {
};
var Char = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ length3(1, {
  identifier: "Char"
}))) {
};
var nonEmptyString2 = (annotations5) => minLength(1, {
  title: "nonEmptyString",
  description: "a non empty string",
  ...annotations5
});
var Lowercase = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be converted to lowercase"
}), Lowercased, {
  strict: true,
  decode: (i) => i.toLowerCase(),
  encode: identity
}).annotations({
  identifier: "Lowercase"
})) {
};
var Uppercase = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be converted to uppercase"
}), Uppercased, {
  strict: true,
  decode: (i) => i.toUpperCase(),
  encode: identity
}).annotations({
  identifier: "Uppercase"
})) {
};
var Capitalize = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be converted to a capitalized format"
}), Capitalized, {
  strict: true,
  decode: (i) => capitalize(i),
  encode: identity
}).annotations({
  identifier: "Capitalize"
})) {
};
var Uncapitalize = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be converted to an uncapitalized format"
}), Uncapitalized, {
  strict: true,
  decode: (i) => uncapitalize(i),
  encode: identity
}).annotations({
  identifier: "Uncapitalize"
})) {
};
var Trimmed = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ trimmed({
  identifier: "Trimmed"
}))) {
};
var NonEmptyTrimmedString = class extends (/* @__PURE__ */ Trimmed.pipe(/* @__PURE__ */ nonEmptyString2({
  identifier: "NonEmptyTrimmedString"
}))) {
};
var Trim = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be trimmed"
}), Trimmed, {
  strict: true,
  decode: (i) => i.trim(),
  encode: identity
}).annotations({
  identifier: "Trim"
})) {
};
var split5 = (separator) => transform2(String$.annotations({
  description: "a string that will be split"
}), Array$(String$), {
  strict: true,
  decode: (i) => i.split(separator),
  encode: (a) => a.join(separator)
});
var getErrorMessage2 = (e) => e instanceof Error ? e.message : String(e);
var getParseJsonTransformation = (options) => transformOrFail(String$.annotations({
  description: "a string to be decoded into JSON"
}), Unknown, {
  strict: true,
  decode: (i, _, ast) => _try({
    try: () => JSON.parse(i, options?.reviver),
    catch: (e) => new Type2(ast, i, getErrorMessage2(e))
  }),
  encode: (a, _, ast) => _try({
    try: () => JSON.stringify(a, options?.replacer, options?.space),
    catch: (e) => new Type2(ast, a, getErrorMessage2(e))
  })
}).annotations({
  title: "parseJson",
  schemaId: ParseJsonSchemaId
});
var parseJson = (schemaOrOptions, o) => isSchema(schemaOrOptions) ? compose4(parseJson(o), schemaOrOptions) : getParseJsonTransformation(schemaOrOptions);
var NonEmptyString = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ nonEmptyString2({
  identifier: "NonEmptyString"
}))) {
};
var UUIDSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/UUID");
var uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
var UUID = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ pattern(uuidRegexp, {
  schemaId: UUIDSchemaId,
  identifier: "UUID",
  jsonSchema: {
    format: "uuid",
    pattern: uuidRegexp.source
  },
  description: "a Universally Unique Identifier",
  arbitrary: () => (fc) => fc.uuid()
}))) {
};
var ULIDSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ULID");
var ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;
var ULID = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ pattern(ulidRegexp, {
  schemaId: ULIDSchemaId,
  identifier: "ULID",
  description: "a Universally Unique Lexicographically Sortable Identifier",
  arbitrary: () => (fc) => fc.ulid()
}))) {
};
var URLFromSelf = class extends (/* @__PURE__ */ instanceOf(URL, {
  identifier: "URLFromSelf",
  arbitrary: () => (fc) => fc.webUrl().map((s) => new URL(s)),
  pretty: () => (url2) => url2.toString()
})) {
};
var URL$ = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a URL"
}), URLFromSelf, {
  strict: true,
  decode: (i, _, ast) => _try({
    try: () => new URL(i),
    catch: (e) => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a URL. ${getErrorMessage2(e)}`)
  }),
  encode: (a) => succeed19(a.toString())
}).annotations({
  identifier: "URL",
  pretty: () => (url2) => url2.toString()
})) {
};
var FiniteSchemaId2 = FiniteSchemaId;
var finite = (annotations5) => (self) => self.pipe(filter12(Number.isFinite, {
  schemaId: FiniteSchemaId2,
  title: "finite",
  description: "a finite number",
  jsonSchema: {
    "type": "number"
  },
  ...annotations5
}));
var GreaterThanSchemaId2 = GreaterThanSchemaId;
var greaterThan6 = (exclusiveMinimum, annotations5) => (self) => self.pipe(filter12((a) => a > exclusiveMinimum, {
  schemaId: GreaterThanSchemaId2,
  title: `greaterThan(${exclusiveMinimum})`,
  description: exclusiveMinimum === 0 ? "a positive number" : `a number greater than ${exclusiveMinimum}`,
  jsonSchema: {
    exclusiveMinimum
  },
  ...annotations5
}));
var GreaterThanOrEqualToSchemaId2 = GreaterThanOrEqualToSchemaId;
var greaterThanOrEqualTo5 = (minimum, annotations5) => (self) => self.pipe(filter12((a) => a >= minimum, {
  schemaId: GreaterThanOrEqualToSchemaId2,
  title: `greaterThanOrEqualTo(${minimum})`,
  description: minimum === 0 ? "a non-negative number" : `a number greater than or equal to ${minimum}`,
  jsonSchema: {
    minimum
  },
  ...annotations5
}));
var MultipleOfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MultipleOf");
var multipleOf = (divisor, annotations5) => (self) => {
  const positiveDivisor = Math.abs(divisor);
  return self.pipe(filter12((a) => remainder(a, divisor) === 0, {
    schemaId: MultipleOfSchemaId,
    title: `multipleOf(${positiveDivisor})`,
    description: `a number divisible by ${positiveDivisor}`,
    jsonSchema: {
      multipleOf: positiveDivisor
    },
    ...annotations5
  }));
};
var IntSchemaId2 = IntSchemaId;
var int = (annotations5) => (self) => self.pipe(filter12((a) => Number.isSafeInteger(a), {
  schemaId: IntSchemaId2,
  title: "int",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations5
}));
var LessThanSchemaId2 = LessThanSchemaId;
var lessThan9 = (exclusiveMaximum, annotations5) => (self) => self.pipe(filter12((a) => a < exclusiveMaximum, {
  schemaId: LessThanSchemaId2,
  title: `lessThan(${exclusiveMaximum})`,
  description: exclusiveMaximum === 0 ? "a negative number" : `a number less than ${exclusiveMaximum}`,
  jsonSchema: {
    exclusiveMaximum
  },
  ...annotations5
}));
var LessThanOrEqualToSchemaId2 = LessThanOrEqualToSchemaId;
var lessThanOrEqualTo5 = (maximum, annotations5) => (self) => self.pipe(filter12((a) => a <= maximum, {
  schemaId: LessThanOrEqualToSchemaId2,
  title: `lessThanOrEqualTo(${maximum})`,
  description: maximum === 0 ? "a non-positive number" : `a number less than or equal to ${maximum}`,
  jsonSchema: {
    maximum
  },
  ...annotations5
}));
var BetweenSchemaId2 = BetweenSchemaId;
var between5 = (minimum, maximum, annotations5) => (self) => self.pipe(filter12((a) => a >= minimum && a <= maximum, {
  schemaId: BetweenSchemaId2,
  title: `between(${minimum}, ${maximum})`,
  description: `a number between ${minimum} and ${maximum}`,
  jsonSchema: {
    minimum,
    maximum
  },
  ...annotations5
}));
var NonNaNSchemaId2 = NonNaNSchemaId;
var nonNaN = (annotations5) => (self) => self.pipe(filter12((a) => !Number.isNaN(a), {
  schemaId: NonNaNSchemaId2,
  title: "nonNaN",
  description: "a number excluding NaN",
  ...annotations5
}));
var positive = (annotations5) => greaterThan6(0, {
  title: "positive",
  ...annotations5
});
var negative = (annotations5) => lessThan9(0, {
  title: "negative",
  ...annotations5
});
var nonPositive = (annotations5) => lessThanOrEqualTo5(0, {
  title: "nonPositive",
  ...annotations5
});
var nonNegative = (annotations5) => greaterThanOrEqualTo5(0, {
  title: "nonNegative",
  ...annotations5
});
var clamp8 = (minimum, maximum) => (self) => {
  return transform2(self, typeSchema(self).pipe(between5(minimum, maximum)), {
    strict: false,
    decode: (i) => clamp4(i, {
      minimum,
      maximum
    }),
    encode: identity
  });
};
function parseNumber(self) {
  return transformOrFail(self, Number$, {
    strict: false,
    decode: (i, _, ast) => fromOption3(parse(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a number`)),
    encode: (a) => succeed19(String(a))
  });
}
var NumberFromString = class extends (/* @__PURE__ */ parseNumber(String$.annotations({
  description: "a string to be decoded into a number"
})).annotations({
  identifier: "NumberFromString"
})) {
};
var Finite = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ finite({
  identifier: "Finite"
}))) {
};
var Int = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ int({
  identifier: "Int"
}))) {
};
var NonNaN = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonNaN({
  identifier: "NonNaN"
}))) {
};
var Positive = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ positive({
  identifier: "Positive"
}))) {
};
var Negative = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ negative({
  identifier: "Negative"
}))) {
};
var NonPositive = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonPositive({
  identifier: "NonPositive"
}))) {
};
var NonNegative = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonNegative({
  identifier: "NonNegative"
}))) {
};
var JsonNumberSchemaId2 = JsonNumberSchemaId;
var JsonNumber = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ finite({
  schemaId: JsonNumberSchemaId2,
  identifier: "JsonNumber"
}))) {
};
var Not = class extends (/* @__PURE__ */ transform2(/* @__PURE__ */ Boolean$.annotations({
  description: "a boolean that will be negated"
}), Boolean$, {
  strict: true,
  decode: (i) => not(i),
  encode: (a) => not(a)
})) {
};
var encodeSymbol2 = (sym, ast) => {
  const key = Symbol.keyFor(sym);
  return key === void 0 ? fail19(new Type2(ast, sym, `Unable to encode a unique symbol ${String(sym)} into a string`)) : succeed19(key);
};
var decodeSymbol = (s) => succeed19(Symbol.for(s));
var Symbol$ = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a globally shared symbol"
}), SymbolFromSelf, {
  strict: false,
  decode: (i) => decodeSymbol(i),
  encode: (a, _, ast) => encodeSymbol2(a, ast)
}).annotations({
  identifier: "Symbol"
})) {
};
var GreaterThanBigIntSchemaId = GreaterThanBigintSchemaId;
var greaterThanBigInt = (min5, annotations5) => (self) => self.pipe(filter12((a) => a > min5, {
  schemaId: GreaterThanBigIntSchemaId,
  [GreaterThanBigIntSchemaId]: {
    min: min5
  },
  title: `greaterThanBigInt(${min5})`,
  description: min5 === 0n ? "a positive bigint" : `a bigint greater than ${min5}n`,
  ...annotations5
}));
var GreaterThanOrEqualToBigIntSchemaId2 = GreaterThanOrEqualToBigIntSchemaId;
var greaterThanOrEqualToBigInt = (min5, annotations5) => (self) => self.pipe(filter12((a) => a >= min5, {
  schemaId: GreaterThanOrEqualToBigIntSchemaId2,
  [GreaterThanOrEqualToBigIntSchemaId2]: {
    min: min5
  },
  title: `greaterThanOrEqualToBigInt(${min5})`,
  description: min5 === 0n ? "a non-negative bigint" : `a bigint greater than or equal to ${min5}n`,
  ...annotations5
}));
var LessThanBigIntSchemaId2 = LessThanBigIntSchemaId;
var lessThanBigInt = (max7, annotations5) => (self) => self.pipe(filter12((a) => a < max7, {
  schemaId: LessThanBigIntSchemaId2,
  [LessThanBigIntSchemaId2]: {
    max: max7
  },
  title: `lessThanBigInt(${max7})`,
  description: max7 === 0n ? "a negative bigint" : `a bigint less than ${max7}n`,
  ...annotations5
}));
var LessThanOrEqualToBigIntSchemaId2 = LessThanOrEqualToBigIntSchemaId;
var lessThanOrEqualToBigInt = (max7, annotations5) => (self) => self.pipe(filter12((a) => a <= max7, {
  schemaId: LessThanOrEqualToBigIntSchemaId2,
  [LessThanOrEqualToBigIntSchemaId2]: {
    max: max7
  },
  title: `lessThanOrEqualToBigInt(${max7})`,
  description: max7 === 0n ? "a non-positive bigint" : `a bigint less than or equal to ${max7}n`,
  ...annotations5
}));
var BetweenBigIntSchemaId = BetweenBigintSchemaId;
var betweenBigInt = (min5, max7, annotations5) => (self) => self.pipe(filter12((a) => a >= min5 && a <= max7, {
  schemaId: BetweenBigIntSchemaId,
  [BetweenBigIntSchemaId]: {
    min: min5,
    max: max7
  },
  title: `betweenBigInt(${min5}, ${max7})`,
  description: `a bigint between ${min5}n and ${max7}n`,
  ...annotations5
}));
var positiveBigInt = (annotations5) => greaterThanBigInt(0n, {
  title: "positiveBigInt",
  ...annotations5
});
var negativeBigInt = (annotations5) => lessThanBigInt(0n, {
  title: "negativeBigInt",
  ...annotations5
});
var nonNegativeBigInt = (annotations5) => greaterThanOrEqualToBigInt(0n, {
  title: "nonNegativeBigInt",
  ...annotations5
});
var nonPositiveBigInt = (annotations5) => lessThanOrEqualToBigInt(0n, {
  title: "nonPositiveBigInt",
  ...annotations5
});
var clampBigInt = (minimum, maximum) => (self) => transform2(self, self.pipe(typeSchema, betweenBigInt(minimum, maximum)), {
  strict: false,
  decode: (i) => clamp6(i, {
    minimum,
    maximum
  }),
  encode: identity
});
var BigInt$ = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a bigint"
}), BigIntFromSelf, {
  strict: true,
  decode: (i, _, ast) => fromOption3(fromString2(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a bigint`)),
  encode: (a) => succeed19(String(a))
}).annotations({
  identifier: "BigInt"
})) {
};
var PositiveBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ positiveBigInt({
  identifier: "PositiveBigintFromSelf"
}));
var PositiveBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ positiveBigInt({
  identifier: "PositiveBigint"
}));
var NegativeBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ negativeBigInt({
  identifier: "NegativeBigintFromSelf"
}));
var NegativeBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ negativeBigInt({
  identifier: "NegativeBigint"
}));
var NonPositiveBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ nonPositiveBigInt({
  identifier: "NonPositiveBigintFromSelf"
}));
var NonPositiveBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ nonPositiveBigInt({
  identifier: "NonPositiveBigint"
}));
var NonNegativeBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ nonNegativeBigInt({
  identifier: "NonNegativeBigintFromSelf"
}));
var NonNegativeBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ nonNegativeBigInt({
  identifier: "NonNegativeBigint"
}));
var BigIntFromNumber = class extends (/* @__PURE__ */ transformOrFail(Number$.annotations({
  description: "a number to be decoded into a bigint"
}), BigIntFromSelf.pipe(betweenBigInt(BigInt(Number.MIN_SAFE_INTEGER), BigInt(Number.MAX_SAFE_INTEGER))), {
  strict: true,
  decode: (i, _, ast) => fromOption3(fromNumber2(i), () => new Type2(ast, i, `Unable to decode ${i} into a bigint`)),
  encode: (a, _, ast) => fromOption3(toNumber(a), () => new Type2(ast, a, `Unable to encode ${a}n into a number`))
}).annotations({
  identifier: "BigIntFromNumber"
})) {
};
var redactedArbitrary = (value3) => (fc) => value3(fc).map(make59);
var toComposite = (eff, onSuccess, ast, actual) => mapBoth9(eff, {
  onFailure: (e) => new Composite2(ast, actual, e),
  onSuccess
});
var redactedParse = (decodeUnknown6) => (u, options, ast) => isRedacted2(u) ? toComposite(decodeUnknown6(value2(u), options), make59, ast, u) : fail19(new Type2(ast, u));
var RedactedFromSelf = (value3) => declare([value3], {
  decode: (value4) => redactedParse(decodeUnknown2(value4)),
  encode: (value4) => redactedParse(encodeUnknown(value4))
}, {
  description: "Redacted(<redacted>)",
  pretty: () => () => "Redacted(<redacted>)",
  arbitrary: redactedArbitrary,
  equivalence: getEquivalence7
});
function Redacted(value3) {
  return transform2(value3, RedactedFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: (i) => make59(i),
    encode: (a) => value2(a)
  });
}
var DurationFromSelf = class extends (/* @__PURE__ */ declare(isDuration, {
  identifier: "DurationFromSelf",
  pretty: () => String,
  arbitrary: () => (fc) => fc.oneof(fc.constant(infinity), fc.bigInt({
    min: 0n
  }).map((_) => nanos(_)), fc.maxSafeNat().map((_) => millis(_))),
  equivalence: () => Equivalence
})) {
};
var DurationFromNanos = class extends (/* @__PURE__ */ transformOrFail(NonNegativeBigIntFromSelf.annotations({
  description: "a bigint to be decoded into a Duration"
}), DurationFromSelf.pipe(filter12((duration4) => isFinite(duration4), {
  description: "a finite duration"
})), {
  strict: true,
  decode: (i) => succeed19(nanos(i)),
  encode: (a, _, ast) => match2(toNanos(a), {
    onNone: () => fail19(new Type2(ast, a, `Unable to encode ${a} into a bigint`)),
    onSome: (nanos2) => succeed19(nanos2)
  })
}).annotations({
  identifier: "DurationFromNanos"
})) {
};
var NonNegativeInt = /* @__PURE__ */ NonNegative.pipe(int()).annotations({
  identifier: "NonNegativeInt"
});
var DurationFromMillis = class extends (/* @__PURE__ */ transform2(NonNegative.annotations({
  description: "a non-negative number to be decoded into a Duration"
}), DurationFromSelf, {
  strict: true,
  decode: (i) => millis(i),
  encode: (a) => toMillis(a)
}).annotations({
  identifier: "DurationFromMillis"
})) {
};
var DurationValueMillis = /* @__PURE__ */ TaggedStruct("Millis", {
  millis: NonNegativeInt
});
var DurationValueNanos = /* @__PURE__ */ TaggedStruct("Nanos", {
  nanos: BigInt$
});
var DurationValueInfinity = /* @__PURE__ */ TaggedStruct("Infinity", {});
var durationValueInfinity = /* @__PURE__ */ DurationValueInfinity.make({});
var DurationValue = /* @__PURE__ */ Union2(DurationValueMillis, DurationValueNanos, DurationValueInfinity).annotations({
  identifier: "DurationValue",
  description: "an JSON-compatible tagged union to be decoded into a Duration"
});
var FiniteHRTime = /* @__PURE__ */ Tuple(element(NonNegativeInt).annotations({
  title: "seconds"
}), element(NonNegativeInt).annotations({
  title: "nanos"
})).annotations({
  identifier: "FiniteHRTime"
});
var InfiniteHRTime = /* @__PURE__ */ Tuple(Literal2(-1), Literal2(0)).annotations({
  identifier: "InfiniteHRTime"
});
var HRTime = /* @__PURE__ */ Union2(FiniteHRTime, InfiniteHRTime).annotations({
  identifier: "HRTime",
  description: "a tuple of seconds and nanos to be decoded into a Duration"
});
var isDurationValue = (u) => typeof u === "object";
var Duration = class extends (/* @__PURE__ */ transform2(Union2(DurationValue, HRTime), DurationFromSelf, {
  strict: true,
  decode: (i) => {
    if (isDurationValue(i)) {
      switch (i._tag) {
        case "Millis":
          return millis(i.millis);
        case "Nanos":
          return nanos(i.nanos);
        case "Infinity":
          return infinity;
      }
    }
    const [seconds2, nanos2] = i;
    return seconds2 === -1 ? infinity : nanos(BigInt(seconds2) * BigInt(1e9) + BigInt(nanos2));
  },
  encode: (a) => {
    switch (a.value._tag) {
      case "Millis":
        return DurationValueMillis.make({
          millis: a.value.millis
        });
      case "Nanos":
        return DurationValueNanos.make({
          nanos: a.value.nanos
        });
      case "Infinity":
        return durationValueInfinity;
    }
  }
}).annotations({
  identifier: "Duration"
})) {
};
var clampDuration = (minimum, maximum) => (self) => transform2(self, self.pipe(typeSchema, betweenDuration(minimum, maximum)), {
  strict: false,
  decode: (i) => clamp3(i, {
    minimum,
    maximum
  }),
  encode: identity
});
var LessThanDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanDuration");
var lessThanDuration = (max7, annotations5) => (self) => self.pipe(filter12((a) => lessThan2(a, max7), {
  schemaId: LessThanDurationSchemaId,
  [LessThanDurationSchemaId]: {
    max: max7
  },
  title: `lessThanDuration(${max7})`,
  description: `a Duration less than ${decode(max7)}`,
  ...annotations5
}));
var LessThanOrEqualToDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/LessThanOrEqualToDuration");
var lessThanOrEqualToDuration = (max7, annotations5) => (self) => self.pipe(filter12((a) => lessThanOrEqualTo2(a, max7), {
  schemaId: LessThanDurationSchemaId,
  [LessThanDurationSchemaId]: {
    max: max7
  },
  title: `lessThanOrEqualToDuration(${max7})`,
  description: `a Duration less than or equal to ${decode(max7)}`,
  ...annotations5
}));
var GreaterThanDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanDuration");
var greaterThanDuration = (min5, annotations5) => (self) => self.pipe(filter12((a) => greaterThan2(a, min5), {
  schemaId: GreaterThanDurationSchemaId,
  [GreaterThanDurationSchemaId]: {
    min: min5
  },
  title: `greaterThanDuration(${min5})`,
  description: `a Duration greater than ${decode(min5)}`,
  ...annotations5
}));
var GreaterThanOrEqualToDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/GreaterThanOrEqualToDuration");
var greaterThanOrEqualToDuration = (min5, annotations5) => (self) => self.pipe(filter12((a) => greaterThanOrEqualTo2(a, min5), {
  schemaId: GreaterThanOrEqualToDurationSchemaId,
  [GreaterThanOrEqualToDurationSchemaId]: {
    min: min5
  },
  title: `greaterThanOrEqualToDuration(${min5})`,
  description: `a Duration greater than or equal to ${decode(min5)}`,
  ...annotations5
}));
var BetweenDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenDuration");
var betweenDuration = (minimum, maximum, annotations5) => (self) => self.pipe(filter12((a) => between2(a, {
  minimum,
  maximum
}), {
  schemaId: BetweenDurationSchemaId,
  [BetweenDurationSchemaId]: {
    maximum,
    minimum
  },
  title: `betweenDuration(${minimum}, ${maximum})`,
  description: `a Duration between ${decode(minimum)} and ${decode(maximum)}`,
  ...annotations5
}));
var Uint8ArrayFromSelf = class extends (/* @__PURE__ */ declare(isUint8Array, {
  identifier: "Uint8ArrayFromSelf",
  pretty: () => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
  arbitrary: () => (fc) => fc.uint8Array(),
  equivalence: () => getEquivalence3(equals)
})) {
};
var Uint8 = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ between5(0, 255, {
  identifier: "Uint8",
  description: "a 8-bit unsigned integer"
}))) {
};
var Uint8Array$ = class extends (/* @__PURE__ */ transform2(Array$(Uint8).annotations({
  description: "an array of 8-bit unsigned integers to be decoded into a Uint8Array"
}), Uint8ArrayFromSelf, {
  strict: true,
  decode: (i) => Uint8Array.from(i),
  encode: (a) => Array.from(a)
}).annotations({
  identifier: "Uint8Array"
})) {
};
var makeUint8ArrayTransformation = (id3, decode7, encode6) => transformOrFail(String$.annotations({
  description: "a string to be decoded into a Uint8Array"
}), Uint8ArrayFromSelf, {
  strict: true,
  decode: (i, _, ast) => mapLeft(decode7(i), (decodeException) => new Type2(ast, i, decodeException.message)),
  encode: (a) => succeed19(encode6(a))
}).annotations({
  identifier: id3
});
var Uint8ArrayFromBase64 = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromBase64", decodeBase64, encodeBase64);
var Uint8ArrayFromBase64Url = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromBase64Url", decodeBase64Url, encodeBase64Url);
var Uint8ArrayFromHex = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromHex", decodeHex, encodeHex);
var makeEncodingTransformation = (id3, decode7, encode6) => transformOrFail(String$.annotations({
  description: `A string that is interpreted as being ${id3}-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: (i, _, ast) => mapLeft(decode7(i), (decodeException) => new Type2(ast, i, decodeException.message)),
  encode: (a) => succeed19(encode6(a))
}).annotations({
  identifier: `StringFrom${id3}`
});
var StringFromBase64 = /* @__PURE__ */ makeEncodingTransformation("Base64", decodeBase64String, encodeBase64);
var StringFromBase64Url = /* @__PURE__ */ makeEncodingTransformation("Base64Url", decodeBase64UrlString, encodeBase64Url);
var StringFromHex = /* @__PURE__ */ makeEncodingTransformation("Hex", decodeHexString, encodeHex);
var StringFromUriComponent = /* @__PURE__ */ transformOrFail(String$.annotations({
  description: `A string that is interpreted as being UriComponent-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: (i, _, ast) => mapLeft(decodeUriComponent(i), (decodeException) => new Type2(ast, i, decodeException.message)),
  encode: (a, _, ast) => mapLeft(encodeUriComponent(a), (encodeException) => new Type2(ast, a, encodeException.message))
}).annotations({
  identifier: `StringFromUriComponent`
});
var MinItemsSchemaId2 = MinItemsSchemaId;
var minItems = (n, annotations5) => (self) => {
  const minItems3 = Math.floor(n);
  if (minItems3 < 1) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self.pipe(filter12((a) => a.length >= minItems3, {
    schemaId: MinItemsSchemaId2,
    title: `minItems(${minItems3})`,
    description: `an array of at least ${minItems3} item(s)`,
    jsonSchema: {
      minItems: minItems3
    },
    [StableFilterAnnotationId]: true,
    ...annotations5
  }));
};
var MaxItemsSchemaId2 = MaxItemsSchemaId;
var maxItems = (n, annotations5) => (self) => {
  const maxItems3 = Math.floor(n);
  if (maxItems3 < 1) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self.pipe(filter12((a) => a.length <= maxItems3, {
    schemaId: MaxItemsSchemaId2,
    title: `maxItems(${maxItems3})`,
    description: `an array of at most ${maxItems3} item(s)`,
    jsonSchema: {
      maxItems: maxItems3
    },
    [StableFilterAnnotationId]: true,
    ...annotations5
  }));
};
var ItemsCountSchemaId2 = ItemsCountSchemaId;
var itemsCount = (n, annotations5) => (self) => {
  const itemsCount3 = Math.floor(n);
  if (itemsCount3 < 0) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 0, actual ${n}`));
  }
  return self.pipe(filter12((a) => a.length === itemsCount3, {
    schemaId: ItemsCountSchemaId2,
    title: `itemsCount(${itemsCount3})`,
    description: `an array of exactly ${itemsCount3} item(s)`,
    jsonSchema: {
      minItems: itemsCount3,
      maxItems: itemsCount3
    },
    [StableFilterAnnotationId]: true,
    ...annotations5
  }));
};
var getNumberIndexedAccess2 = (self) => make60(getNumberIndexedAccess(self.ast));
function head6(self) {
  return transform2(self, OptionFromSelf(getNumberIndexedAccess2(typeSchema(self))), {
    strict: false,
    decode: (i) => head(i),
    encode: (a) => match2(a, {
      onNone: () => [],
      onSome: of
    })
  });
}
function headNonEmpty3(self) {
  return transform2(self, getNumberIndexedAccess2(typeSchema(self)), {
    strict: false,
    decode: (i) => headNonEmpty(i),
    encode: (a) => of(a)
  });
}
var headOrElse = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (self, fallback) => transformOrFail(self, getNumberIndexedAccess2(typeSchema(self)), {
  strict: true,
  decode: (i, _, ast) => i.length > 0 ? succeed19(i[0]) : fallback ? succeed19(fallback()) : fail19(new Type2(ast, i, "Unable to retrieve the first element of an empty array")),
  encode: (a) => succeed19(of(a))
}));
var ValidDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ValidDate");
var validDate = (annotations5) => (self) => self.pipe(filter12((a) => !Number.isNaN(a.getTime()), {
  schemaId: ValidDateSchemaId,
  [ValidDateSchemaId]: {
    noInvalidDate: true
  },
  title: "validDate",
  description: "a valid Date",
  ...annotations5
}));
var LessThanDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanDate");
var lessThanDate = (max7, annotations5) => (self) => self.pipe(filter12((a) => a < max7, {
  schemaId: LessThanDateSchemaId,
  [LessThanDateSchemaId]: {
    max: max7
  },
  title: `lessThanDate(${formatDate(max7)})`,
  description: `a date before ${formatDate(max7)}`,
  ...annotations5
}));
var LessThanOrEqualToDateSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/LessThanOrEqualToDate");
var lessThanOrEqualToDate = (max7, annotations5) => (self) => self.pipe(filter12((a) => a <= max7, {
  schemaId: LessThanDateSchemaId,
  [LessThanDateSchemaId]: {
    max: max7
  },
  title: `lessThanOrEqualToDate(${formatDate(max7)})`,
  description: `a date before or equal to ${formatDate(max7)}`,
  ...annotations5
}));
var GreaterThanDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanDate");
var greaterThanDate = (min5, annotations5) => (self) => self.pipe(filter12((a) => a > min5, {
  schemaId: GreaterThanDateSchemaId,
  [GreaterThanDateSchemaId]: {
    min: min5
  },
  title: `greaterThanDate(${formatDate(min5)})`,
  description: `a date after ${formatDate(min5)}`,
  ...annotations5
}));
var GreaterThanOrEqualToDateSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/GreaterThanOrEqualToDate");
var greaterThanOrEqualToDate = (min5, annotations5) => (self) => self.pipe(filter12((a) => a >= min5, {
  schemaId: GreaterThanOrEqualToDateSchemaId,
  [GreaterThanOrEqualToDateSchemaId]: {
    min: min5
  },
  title: `greaterThanOrEqualToDate(${formatDate(min5)})`,
  description: `a date after or equal to ${formatDate(min5)}`,
  ...annotations5
}));
var BetweenDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenDate");
var betweenDate = (min5, max7, annotations5) => (self) => self.pipe(filter12((a) => a <= max7 && a >= min5, {
  schemaId: BetweenDateSchemaId,
  [BetweenDateSchemaId]: {
    max: max7,
    min: min5
  },
  title: `betweenDate(${formatDate(min5)}, ${formatDate(max7)})`,
  description: `a date between ${formatDate(min5)} and ${formatDate(max7)}`,
  ...annotations5
}));
var DateFromSelfSchemaId2 = DateFromSelfSchemaId;
var DateFromSelf = class extends (/* @__PURE__ */ declare(isDate, {
  identifier: "DateFromSelf",
  schemaId: DateFromSelfSchemaId2,
  [DateFromSelfSchemaId2]: {
    noInvalidDate: false
  },
  description: "a potentially invalid Date instance",
  pretty: () => (date3) => `new Date(${JSON.stringify(date3)})`,
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Date2
})) {
};
var ValidDateFromSelf = class extends (/* @__PURE__ */ DateFromSelf.pipe(/* @__PURE__ */ validDate({
  identifier: "ValidDateFromSelf",
  description: "a valid Date instance"
}))) {
};
var DateFromString = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: (i) => new Date(i),
  encode: (a) => formatDate(a)
}).annotations({
  identifier: "DateFromString"
})) {
};
var Date$ = class extends (/* @__PURE__ */ DateFromString.pipe(/* @__PURE__ */ validDate({
  identifier: "Date"
}))) {
};
var DateFromNumber = class extends (/* @__PURE__ */ transform2(Number$.annotations({
  description: "a number to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: (i) => new Date(i),
  encode: (a) => a.getTime()
}).annotations({
  identifier: "DateFromNumber"
})) {
};
var DateTimeUtcFromSelf = class extends (/* @__PURE__ */ declare((u) => isDateTime2(u) && isUtc2(u), {
  identifier: "DateTimeUtcFromSelf",
  description: "a DateTime.Utc instance",
  pretty: () => (dateTime) => dateTime.toString(),
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: true
  }).map((date3) => unsafeFromDate2(date3)),
  equivalence: () => Equivalence5
})) {
};
var decodeDateTimeUtc = (input, ast) => _try({
  try: () => unsafeMake12(input),
  catch: () => new Type2(ast, input, `Unable to decode ${formatUnknown(input)} into a DateTime.Utc`)
});
var DateTimeUtcFromNumber = class extends (/* @__PURE__ */ transformOrFail(Number$.annotations({
  description: "a number to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
  encode: (a) => succeed19(toEpochMillis2(a))
}).annotations({
  identifier: "DateTimeUtcFromNumber"
})) {
};
var DateTimeUtcFromDate = class extends (/* @__PURE__ */ transformOrFail(DateFromSelf.annotations({
  description: "a Date to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
  encode: (a) => succeed19(toDateUtc2(a))
}).annotations({
  identifier: "DateTimeUtcFromDate"
})) {
};
var DateTimeUtc = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: (i, _, ast) => decodeDateTimeUtc(i, ast),
  encode: (a) => succeed19(formatIso3(a))
}).annotations({
  identifier: "DateTimeUtc"
})) {
};
var timeZoneOffsetArbitrary = () => (fc) => fc.integer({
  min: -12 * 60 * 60 * 1e3,
  max: 14 * 60 * 60 * 1e3
}).map(zoneMakeOffset2);
var TimeZoneOffsetFromSelf = class extends (/* @__PURE__ */ declare(isTimeZoneOffset2, {
  identifier: "TimeZoneOffsetFromSelf",
  description: "a TimeZone.Offset instance",
  pretty: () => (zone) => zone.toString(),
  arbitrary: timeZoneOffsetArbitrary
})) {
};
var TimeZoneOffset = class extends (/* @__PURE__ */ transform2(Number$.annotations({
  description: "a number to be decoded into a TimeZone.Offset"
}), TimeZoneOffsetFromSelf, {
  strict: true,
  decode: (i) => zoneMakeOffset2(i),
  encode: (a) => a.offset
}).annotations({
  identifier: "TimeZoneOffset"
})) {
};
var timeZoneNamedArbitrary = () => (fc) => fc.constantFrom(...Intl.supportedValuesOf("timeZone")).map(zoneUnsafeMakeNamed2);
var TimeZoneNamedFromSelf = class extends (/* @__PURE__ */ declare(isTimeZoneNamed2, {
  identifier: "TimeZoneNamedFromSelf",
  description: "a TimeZone.Named instance",
  pretty: () => (zone) => zone.toString(),
  arbitrary: timeZoneNamedArbitrary
})) {
};
var TimeZoneNamed = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a TimeZone.Named"
}), TimeZoneNamedFromSelf, {
  strict: true,
  decode: (i, _, ast) => _try({
    try: () => zoneUnsafeMakeNamed2(i),
    catch: () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone.Named`)
  }),
  encode: (a) => succeed19(a.id)
}).annotations({
  identifier: "TimeZoneNamed"
})) {
};
var TimeZoneFromSelf = class extends (/* @__PURE__ */ Union2(TimeZoneOffsetFromSelf, TimeZoneNamedFromSelf)) {
};
var TimeZone = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a TimeZone"
}), TimeZoneFromSelf, {
  strict: true,
  decode: (i, _, ast) => match2(zoneFromString2(i), {
    onNone: () => fail19(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone`)),
    onSome: succeed19
  }),
  encode: (a) => succeed19(zoneToString2(a))
}).annotations({
  identifier: "TimeZone"
})) {
};
var timeZoneArbitrary = (fc) => fc.oneof(timeZoneOffsetArbitrary()(fc), timeZoneNamedArbitrary()(fc));
var DateTimeZonedFromSelf = class extends (/* @__PURE__ */ declare((u) => isDateTime2(u) && isZoned2(u), {
  identifier: "DateTimeZonedFromSelf",
  description: "a DateTime.Zoned instance",
  pretty: () => (dateTime) => dateTime.toString(),
  arbitrary: () => (fc) => fc.tuple(fc.integer({
    // time zone db supports +/- 1000 years or so
    min: -31536e9,
    max: 31536e9
  }), timeZoneArbitrary(fc)).map(([millis2, timeZone]) => unsafeMakeZoned2(millis2, {
    timeZone
  })),
  equivalence: () => Equivalence5
})) {
};
var DateTimeZoned = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a DateTime.Zoned"
}), DateTimeZonedFromSelf, {
  strict: true,
  decode: (i, _, ast) => match2(makeZonedFromString2(i), {
    onNone: () => fail19(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a DateTime.Zoned`)),
    onSome: succeed19
  }),
  encode: (a) => succeed19(formatIsoZoned2(a))
}).annotations({
  identifier: "DateTimeZoned"
})) {
};
var OptionNoneEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("None")
}).annotations({
  description: "NoneEncoded"
});
var optionSomeEncoded = (value3) => Struct({
  _tag: Literal2("Some"),
  value: value3
}).annotations({
  description: `SomeEncoded<${format6(value3)}>`
});
var optionEncoded = (value3) => Union2(OptionNoneEncoded, optionSomeEncoded(value3)).annotations({
  description: `OptionEncoded<${format6(value3)}>`
});
var optionDecode = (input) => input._tag === "None" ? none2() : some2(input.value);
var optionArbitrary = (value3, ctx) => (fc) => fc.oneof(ctx, fc.record({
  _tag: fc.constant("None")
}), fc.record({
  _tag: fc.constant("Some"),
  value: value3(fc)
})).map(optionDecode);
var optionPretty = (value3) => match2({
  onNone: () => "none()",
  onSome: (a) => `some(${value3(a)})`
});
var optionParse = (decodeUnknown6) => (u, options, ast) => isOption2(u) ? isNone2(u) ? succeed19(none2()) : toComposite(decodeUnknown6(u.value, options), some2, ast, u) : fail19(new Type2(ast, u));
var OptionFromSelf = (value3) => {
  return declare([value3], {
    decode: (value4) => optionParse(decodeUnknown2(value4)),
    encode: (value4) => optionParse(encodeUnknown(value4))
  }, {
    description: `Option<${format6(value3)}>`,
    pretty: optionPretty,
    arbitrary: optionArbitrary,
    equivalence: getEquivalence2
  });
};
var makeNoneEncoded = {
  _tag: "None"
};
var makeSomeEncoded = (value3) => ({
  _tag: "Some",
  value: value3
});
function Option(value3) {
  const value_ = asSchema(value3);
  const out = transform2(optionEncoded(value_), OptionFromSelf(typeSchema(value_)), {
    strict: true,
    decode: (i) => optionDecode(i),
    encode: (a) => match2(a, {
      onNone: () => makeNoneEncoded,
      onSome: makeSomeEncoded
    })
  });
  return out;
}
function OptionFromNullOr(value3) {
  return transform2(NullOr(value3), OptionFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: (i) => fromNullable(i),
    encode: (a) => getOrNull(a)
  });
}
function OptionFromNullishOr(value3, onNoneEncoding) {
  return transform2(NullishOr(value3), OptionFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: (i) => fromNullable(i),
    encode: onNoneEncoding === null ? (a) => getOrNull(a) : (a) => getOrUndefined(a)
  });
}
function OptionFromUndefinedOr(value3) {
  return transform2(UndefinedOr(value3), OptionFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: (i) => fromNullable(i),
    encode: (a) => getOrUndefined(a)
  });
}
var OptionFromNonEmptyTrimmedString = class extends (/* @__PURE__ */ transform2(String$, /* @__PURE__ */ OptionFromSelf(NonEmptyTrimmedString), {
  strict: true,
  decode: (i) => filter(some2(i.trim()), isNonEmpty5),
  encode: (a) => getOrElse3(a, () => "")
})) {
};
var rightEncoded = (right3) => Struct({
  _tag: Literal2("Right"),
  right: right3
}).annotations({
  description: `RightEncoded<${format6(right3)}>`
});
var leftEncoded = (left3) => Struct({
  _tag: Literal2("Left"),
  left: left3
}).annotations({
  description: `LeftEncoded<${format6(left3)}>`
});
var eitherEncoded = (right3, left3) => Union2(rightEncoded(right3), leftEncoded(left3)).annotations({
  description: `EitherEncoded<${format6(left3)}, ${format6(right3)}>`
});
var eitherDecode = (input) => input._tag === "Left" ? left2(input.left) : right2(input.right);
var eitherArbitrary = (right3, left3) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Left"),
  left: left3(fc)
}), fc.record({
  _tag: fc.constant("Right"),
  right: right3(fc)
})).map(eitherDecode);
var eitherPretty = (right3, left3) => match({
  onLeft: (e) => `left(${left3(e)})`,
  onRight: (a) => `right(${right3(a)})`
});
var eitherParse = (parseRight, decodeUnknownLeft) => (u, options, ast) => isEither2(u) ? match(u, {
  onLeft: (left3) => toComposite(decodeUnknownLeft(left3, options), left2, ast, u),
  onRight: (right3) => toComposite(parseRight(right3, options), right2, ast, u)
}) : fail19(new Type2(ast, u));
var EitherFromSelf = ({
  left: left3,
  right: right3
}) => {
  return declare([right3, left3], {
    decode: (right4, left4) => eitherParse(decodeUnknown2(right4), decodeUnknown2(left4)),
    encode: (right4, left4) => eitherParse(encodeUnknown(right4), encodeUnknown(left4))
  }, {
    description: `Either<${format6(right3)}, ${format6(left3)}>`,
    pretty: eitherPretty,
    arbitrary: eitherArbitrary,
    equivalence: (right4, left4) => getEquivalence({
      left: left4,
      right: right4
    })
  });
};
var makeLeftEncoded = (left3) => ({
  _tag: "Left",
  left: left3
});
var makeRightEncoded = (right3) => ({
  _tag: "Right",
  right: right3
});
var Either2 = ({
  left: left3,
  right: right3
}) => {
  const right_ = asSchema(right3);
  const left_ = asSchema(left3);
  const out = transform2(eitherEncoded(right_, left_), EitherFromSelf({
    left: typeSchema(left_),
    right: typeSchema(right_)
  }), {
    strict: true,
    decode: (i) => eitherDecode(i),
    encode: (a) => match(a, {
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
  return out;
};
var EitherFromUnion = ({
  left: left3,
  right: right3
}) => {
  const right_ = asSchema(right3);
  const left_ = asSchema(left3);
  const toright = typeSchema(right_);
  const toleft = typeSchema(left_);
  const fromRight = transform2(right_, rightEncoded(toright), {
    strict: true,
    decode: (i) => makeRightEncoded(i),
    encode: (a) => a.right
  });
  const fromLeft = transform2(left_, leftEncoded(toleft), {
    strict: true,
    decode: (i) => makeLeftEncoded(i),
    encode: (a) => a.left
  });
  const out = transform2(Union2(fromRight, fromLeft), EitherFromSelf({
    left: toleft,
    right: toright
  }), {
    strict: true,
    decode: (i) => i._tag === "Left" ? left2(i.left) : right2(i.right),
    encode: (a) => match(a, {
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
  return out;
};
var mapArbitrary = (key, value3, ctx) => {
  return (fc) => {
    const items = fc.array(fc.tuple(key(fc), value3(fc)));
    return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as13) => new Map(as13));
  };
};
var readonlyMapPretty = (key, value3) => (map31) => `new Map([${Array.from(map31.entries()).map(([k, v]) => `[${key(k)}, ${value3(v)}]`).join(", ")}])`;
var readonlyMapEquivalence = (key, value3) => {
  const arrayEquivalence = getEquivalence3(make3(([ka, va], [kb, vb]) => key(ka, kb) && value3(va, vb)));
  return make3((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())));
};
var readonlyMapParse = (decodeUnknown6) => (u, options, ast) => isMap(u) ? toComposite(decodeUnknown6(Array.from(u.entries()), options), (as13) => new Map(as13), ast, u) : fail19(new Type2(ast, u));
var mapFromSelf_ = (key, value3, description) => declare([key, value3], {
  decode: (Key2, Value2) => readonlyMapParse(decodeUnknown2(Array$(Tuple(Key2, Value2)))),
  encode: (Key2, Value2) => readonlyMapParse(encodeUnknown(Array$(Tuple(Key2, Value2))))
}, {
  description,
  pretty: readonlyMapPretty,
  arbitrary: mapArbitrary,
  equivalence: readonlyMapEquivalence
});
var ReadonlyMapFromSelf = ({
  key,
  value: value3
}) => mapFromSelf_(key, value3, `ReadonlyMap<${format6(key)}, ${format6(value3)}>`);
var MapFromSelf = ({
  key,
  value: value3
}) => mapFromSelf_(key, value3, `Map<${format6(key)}, ${format6(value3)}>`);
function ReadonlyMap({
  key,
  value: value3
}) {
  return transform2(Array$(Tuple(key, value3)), ReadonlyMapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value3))
  }), {
    strict: true,
    decode: (i) => new Map(i),
    encode: (a) => Array.from(a.entries())
  });
}
function map28({
  key,
  value: value3
}) {
  return transform2(Array$(Tuple(key, value3)), MapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value3))
  }), {
    strict: true,
    decode: (i) => new Map(i),
    encode: (a) => Array.from(a.entries())
  });
}
var ReadonlyMapFromRecord = ({
  key,
  value: value3
}) => transform2(Record({
  key: encodedBoundSchema(key),
  value: value3
}).annotations({
  description: "a record to be decoded into a ReadonlyMap"
}), ReadonlyMapFromSelf({
  key,
  value: typeSchema(value3)
}), {
  strict: true,
  decode: (i) => new Map(Object.entries(i)),
  encode: (a) => Object.fromEntries(a)
});
var MapFromRecord = ({
  key,
  value: value3
}) => transform2(Record({
  key: encodedBoundSchema(key),
  value: value3
}).annotations({
  description: "a record to be decoded into a Map"
}), MapFromSelf({
  key,
  value: typeSchema(value3)
}), {
  strict: true,
  decode: (i) => new Map(Object.entries(i)),
  encode: (a) => Object.fromEntries(a)
});
var setArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as13) => new Set(as13));
};
var readonlySetPretty = (item) => (set10) => `new Set([${Array.from(set10.values()).map((a) => item(a)).join(", ")}])`;
var readonlySetEquivalence = (item) => {
  const arrayEquivalence = getEquivalence3(item);
  return make3((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())));
};
var readonlySetParse = (decodeUnknown6) => (u, options, ast) => isSet(u) ? toComposite(decodeUnknown6(Array.from(u.values()), options), (as13) => new Set(as13), ast, u) : fail19(new Type2(ast, u));
var setFromSelf_ = (value3, description) => declare([value3], {
  decode: (item) => readonlySetParse(decodeUnknown2(Array$(item))),
  encode: (item) => readonlySetParse(encodeUnknown(Array$(item)))
}, {
  description,
  pretty: readonlySetPretty,
  arbitrary: setArbitrary,
  equivalence: readonlySetEquivalence
});
var ReadonlySetFromSelf = (value3) => setFromSelf_(value3, `ReadonlySet<${format6(value3)}>`);
var SetFromSelf = (value3) => setFromSelf_(value3, `Set<${format6(value3)}>`);
function ReadonlySet(value3) {
  return transform2(Array$(value3), ReadonlySetFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: (i) => new Set(i),
    encode: (a) => Array.from(a)
  });
}
function set8(value3) {
  return transform2(Array$(value3), SetFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: (i) => new Set(i),
    encode: (a) => Array.from(a)
  });
}
var bigDecimalPretty = () => (val) => `BigDecimal(${format4(normalize(val))})`;
var bigDecimalArbitrary = () => (fc) => fc.tuple(fc.bigInt(), fc.integer({
  min: 0,
  max: 18
})).map(([value3, scale2]) => make56(value3, scale2));
var BigDecimalFromSelf = class extends (/* @__PURE__ */ declare(isBigDecimal, {
  identifier: "BigDecimalFromSelf",
  pretty: bigDecimalPretty,
  arbitrary: bigDecimalArbitrary,
  equivalence: () => Equivalence4
})) {
};
var BigDecimal = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a BigDecimal"
}), BigDecimalFromSelf, {
  strict: true,
  decode: (i, _, ast) => fromString(i).pipe(match2({
    onNone: () => fail19(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a BigDecimal`)),
    onSome: (val) => succeed19(normalize(val))
  })),
  encode: (a) => succeed19(format4(normalize(a)))
}).annotations({
  identifier: "BigDecimal"
})) {
};
var BigDecimalFromNumber = class extends (/* @__PURE__ */ transform2(Number$.annotations({
  description: "a number to be decoded into a BigDecimal"
}), BigDecimalFromSelf, {
  strict: true,
  decode: (i) => unsafeFromNumber(i),
  encode: (a) => unsafeToNumber(a)
}).annotations({
  identifier: "BigDecimalFromNumber"
})) {
};
var GreaterThanBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanBigDecimal");
var greaterThanBigDecimal = (min5, annotations5) => (self) => {
  const formatted = format4(min5);
  return self.pipe(filter12((a) => greaterThan4(a, min5), {
    schemaId: GreaterThanBigDecimalSchemaId,
    [GreaterThanBigDecimalSchemaId]: {
      min: min5
    },
    title: `greaterThanBigDecimal(${formatted})`,
    description: `a BigDecimal greater than ${formatted}`,
    ...annotations5
  }));
};
var GreaterThanOrEqualToBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/GreaterThanOrEqualToBigDecimal");
var greaterThanOrEqualToBigDecimal = (min5, annotations5) => (self) => {
  const formatted = format4(min5);
  return self.pipe(filter12((a) => greaterThanOrEqualTo3(a, min5), {
    schemaId: GreaterThanOrEqualToBigDecimalSchemaId,
    [GreaterThanOrEqualToBigDecimalSchemaId]: {
      min: min5
    },
    title: `greaterThanOrEqualToBigDecimal(${formatted})`,
    description: `a BigDecimal greater than or equal to ${formatted}`,
    ...annotations5
  }));
};
var LessThanBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanBigDecimal");
var lessThanBigDecimal = (max7, annotations5) => (self) => {
  const formatted = format4(max7);
  return self.pipe(filter12((a) => lessThan7(a, max7), {
    schemaId: LessThanBigDecimalSchemaId,
    [LessThanBigDecimalSchemaId]: {
      max: max7
    },
    title: `lessThanBigDecimal(${formatted})`,
    description: `a BigDecimal less than ${formatted}`,
    ...annotations5
  }));
};
var LessThanOrEqualToBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/LessThanOrEqualToBigDecimal");
var lessThanOrEqualToBigDecimal = (max7, annotations5) => (self) => {
  const formatted = format4(max7);
  return self.pipe(filter12((a) => lessThanOrEqualTo3(a, max7), {
    schemaId: LessThanOrEqualToBigDecimalSchemaId,
    [LessThanOrEqualToBigDecimalSchemaId]: {
      max: max7
    },
    title: `lessThanOrEqualToBigDecimal(${formatted})`,
    description: `a BigDecimal less than or equal to ${formatted}`,
    ...annotations5
  }));
};
var PositiveBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/PositiveBigDecimal");
var positiveBigDecimal = (annotations5) => (self) => self.pipe(filter12((a) => isPositive(a), {
  schemaId: PositiveBigDecimalSchemaId,
  title: "positiveBigDecimal",
  description: `a positive BigDecimal`,
  ...annotations5
}));
var PositiveBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ positiveBigDecimal({
  identifier: "PositiveBigDecimalFromSelf"
}));
var NonNegativeBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/NonNegativeBigDecimal");
var nonNegativeBigDecimal = (annotations5) => (self) => self.pipe(filter12((a) => a.value >= 0n, {
  schemaId: NonNegativeBigDecimalSchemaId,
  title: "nonNegativeBigDecimal",
  description: `a non-negative BigDecimal`,
  ...annotations5
}));
var NonNegativeBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ nonNegativeBigDecimal({
  identifier: "NonNegativeBigDecimalFromSelf"
}));
var NegativeBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/NegativeBigDecimal");
var negativeBigDecimal = (annotations5) => (self) => self.pipe(filter12((a) => isNegative(a), {
  schemaId: NegativeBigDecimalSchemaId,
  title: "negativeBigDecimal",
  description: `a negative BigDecimal`,
  ...annotations5
}));
var NegativeBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ negativeBigDecimal({
  identifier: "NegativeBigDecimalFromSelf"
}));
var NonPositiveBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/NonPositiveBigDecimal");
var nonPositiveBigDecimal = (annotations5) => (self) => self.pipe(filter12((a) => a.value <= 0n, {
  schemaId: NonPositiveBigDecimalSchemaId,
  title: "nonPositiveBigDecimal",
  description: `a non-positive BigDecimal`,
  ...annotations5
}));
var NonPositiveBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ nonPositiveBigDecimal({
  identifier: "NonPositiveBigDecimalFromSelf"
}));
var BetweenBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenBigDecimal");
var betweenBigDecimal = (minimum, maximum, annotations5) => (self) => {
  const formattedMinimum = format4(minimum);
  const formattedMaximum = format4(maximum);
  return self.pipe(filter12((a) => between3(a, {
    minimum,
    maximum
  }), {
    schemaId: BetweenBigDecimalSchemaId,
    [BetweenBigDecimalSchemaId]: {
      maximum,
      minimum
    },
    title: `betweenBigDecimal(${formattedMinimum}, ${formattedMaximum})`,
    description: `a BigDecimal between ${formattedMinimum} and ${formattedMaximum}`,
    ...annotations5
  }));
};
var clampBigDecimal = (minimum, maximum) => (self) => transform2(self, self.pipe(typeSchema, betweenBigDecimal(minimum, maximum)), {
  strict: false,
  decode: (i) => clamp5(i, {
    minimum,
    maximum
  }),
  encode: identity
});
var chunkArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable3);
};
var chunkPretty = (item) => (c) => `Chunk(${toReadonlyArray(c).map(item).join(", ")})`;
var chunkParse = (decodeUnknown6) => (u, options, ast) => isChunk(u) ? isEmpty(u) ? succeed19(empty5()) : toComposite(decodeUnknown6(toReadonlyArray(u), options), fromIterable3, ast, u) : fail19(new Type2(ast, u));
var ChunkFromSelf = (value3) => {
  return declare([value3], {
    decode: (item) => chunkParse(decodeUnknown2(Array$(item))),
    encode: (item) => chunkParse(encodeUnknown(Array$(item)))
  }, {
    description: `Chunk<${format6(value3)}>`,
    pretty: chunkPretty,
    arbitrary: chunkArbitrary,
    equivalence: getEquivalence4
  });
};
function Chunk(value3) {
  return transform2(Array$(value3), ChunkFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: (i) => i.length === 0 ? empty5() : fromIterable3(i),
    encode: (a) => toReadonlyArray(a)
  });
}
var nonEmptyChunkArbitrary = (item) => (fc) => array5(item(fc), {
  minLength: 1
}).map((as13) => unsafeFromNonEmptyArray(as13));
var nonEmptyChunkPretty = (item) => (c) => `NonEmptyChunk(${toReadonlyArray(c).map(item).join(", ")})`;
var nonEmptyChunkParse = (decodeUnknown6) => (u, options, ast) => isChunk(u) && isNonEmpty(u) ? toComposite(decodeUnknown6(toReadonlyArray(u), options), unsafeFromNonEmptyArray, ast, u) : fail19(new Type2(ast, u));
var NonEmptyChunkFromSelf = (value3) => {
  return declare([value3], {
    decode: (item) => nonEmptyChunkParse(decodeUnknown2(NonEmptyArray(item))),
    encode: (item) => nonEmptyChunkParse(encodeUnknown(NonEmptyArray(item)))
  }, {
    description: `NonEmptyChunk<${format6(value3)}>`,
    pretty: nonEmptyChunkPretty,
    arbitrary: nonEmptyChunkArbitrary,
    equivalence: getEquivalence4
  });
};
function NonEmptyChunk(value3) {
  return transform2(NonEmptyArray(value3), NonEmptyChunkFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: (i) => unsafeFromNonEmptyArray(i),
    encode: (a) => toReadonlyArray(a)
  });
}
var decodeData = (a) => Array.isArray(a) ? array3(a) : struct2(a);
var dataArbitrary = (item) => (fc) => item(fc).map(decodeData);
var dataPretty = (item) => (d) => `Data(${item(d)})`;
var dataParse = (decodeUnknown6) => (u, options, ast) => isEqual(u) ? toComposite(decodeUnknown6(u, options), decodeData, ast, u) : fail19(new Type2(ast, u));
var DataFromSelf = (value3) => {
  return declare([value3], {
    decode: (item) => dataParse(decodeUnknown2(item)),
    encode: (item) => dataParse(encodeUnknown(item))
  }, {
    description: `Data<${format6(value3)}>`,
    pretty: dataPretty,
    arbitrary: dataArbitrary
  });
};
var Data = (value3) => {
  return transform2(value3, DataFromSelf(typeSchema(value3)), {
    strict: false,
    decode: (i) => decodeData(i),
    encode: (a) => Array.isArray(a) ? Array.from(a) : Object.assign({}, a)
  });
};
var isField = (u) => isSchema(u) || isPropertySignature(u);
var isFields = (fields) => ownKeys(fields).every((key) => isField(fields[key]));
var getFields = (hasFields) => "fields" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId]);
var getSchemaFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr));
var getFieldsFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr);
var Class6 = (identifier2) => (fieldsOr, annotations5) => makeClass({
  kind: "Class",
  identifier: identifier2,
  schema: getSchemaFromFieldsOr(fieldsOr),
  fields: getFieldsFromFieldsOr(fieldsOr),
  Base: Class4,
  annotations: annotations5
});
var getClassTag = (tag3) => withConstructorDefault(propertySignature(Literal2(tag3)), () => tag3);
var TaggedClass3 = (identifier2) => (tag3, fieldsOr, annotations5) => {
  var _a102;
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag3)
  };
  const taggedFields = extendFields(newFields, fields);
  return _a102 = class extends makeClass({
    kind: "TaggedClass",
    identifier: identifier2 ?? tag3,
    schema: extend3(schema, Struct(newFields)),
    fields: taggedFields,
    Base: Class4,
    annotations: annotations5
  }) {
  }, __publicField(_a102, "_tag", tag3), _a102;
};
var TaggedError2 = (identifier2) => (tag3, fieldsOr, annotations5) => {
  class Base3 extends Error3 {
  }
  ;
  Base3.prototype.name = tag3;
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag3)
  };
  const taggedFields = extendFields(newFields, fields);
  const hasMessageField = "message" in taggedFields;
  class TaggedErrorClass extends makeClass({
    kind: "TaggedError",
    identifier: identifier2 ?? tag3,
    schema: extend3(schema, Struct(newFields)),
    fields: taggedFields,
    Base: Base3,
    annotations: annotations5,
    disableToString: true
  }) {
  }
  __publicField(TaggedErrorClass, "_tag", tag3);
  if (!hasMessageField) {
    Object.defineProperty(TaggedErrorClass.prototype, "message", {
      get() {
        return `{ ${ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} }`;
      },
      enumerable: false,
      // mirrors the built-in Error.prototype.message, whose descriptor is also non-enumerable
      configurable: true
    });
  }
  return TaggedErrorClass;
};
var extendFields = (a, b) => {
  const out = {
    ...a
  };
  for (const key of ownKeys(b)) {
    if (key in a) {
      throw new Error(getASTDuplicatePropertySignatureErrorMessage(key));
    }
    out[key] = b[key];
  }
  return out;
};
function getDisableValidationMakeOption(options) {
  return isBoolean(options) ? options : options?.disableValidation ?? false;
}
var astCache = /* @__PURE__ */ globalValue("effect/Schema/astCache", () => /* @__PURE__ */ new WeakMap());
var getClassAnnotations = (annotations5) => {
  if (annotations5 === void 0) {
    return [];
  } else if (Array.isArray(annotations5)) {
    return annotations5;
  } else {
    return [annotations5];
  }
};
var makeClass = ({
  Base: Base3,
  annotations: annotations5,
  disableToString,
  fields,
  identifier: identifier2,
  kind,
  schema
}) => {
  var _a102, _b51;
  const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier2}`);
  const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations5);
  const typeSchema_ = typeSchema(schema);
  const declarationSurrogate = typeSchema_.annotations({
    identifier: identifier2,
    ...typeAnnotations
  });
  const typeSide = typeSchema_.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Type side)`,
    ...typeAnnotations
  });
  const constructorSchema = schema.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Constructor)`,
    ...typeAnnotations
  });
  const encodedSide = schema.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Encoded side)`,
    ...encodedAnnotations
  });
  const transformationSurrogate = schema.annotations({
    [JSONIdentifierAnnotationId]: identifier2,
    ...encodedAnnotations,
    ...typeAnnotations,
    ...transformationAnnotations
  });
  const fallbackInstanceOf = (u) => hasProperty(u, classSymbol) && is(typeSide)(u);
  const klass = (_b51 = class extends Base3 {
    constructor(props = {}, options = false) {
      props = {
        ...props
      };
      if (kind !== "Class") {
        delete props["_tag"];
      }
      props = lazilyMergeDefaults(fields, props);
      if (!getDisableValidationMakeOption(options)) {
        props = validateSync(constructorSchema)(props);
      }
      super(props, true);
    }
    static get ast() {
      let out = astCache.get(this);
      if (out) {
        return out;
      }
      const declaration = declare([schema], {
        decode: () => (input, _, ast) => input instanceof this || fallbackInstanceOf(input) ? succeed19(input) : fail19(new Type2(ast, input)),
        encode: () => (input, options) => input instanceof this ? succeed19(input) : map27(encodeUnknown(typeSide)(input, options), (props) => new this(props, true))
      }, {
        identifier: identifier2,
        pretty: (pretty5) => (self) => `${identifier2}(${pretty5(self)})`,
        // @ts-expect-error
        arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),
        equivalence: identity,
        [SurrogateAnnotationId]: declarationSurrogate.ast,
        ...typeAnnotations
      });
      out = transform2(encodedSide, declaration, {
        strict: true,
        decode: (i) => new this(i, true),
        encode: identity
      }).annotations({
        [SurrogateAnnotationId]: transformationSurrogate.ast,
        ...transformationAnnotations
      }).ast;
      astCache.set(this, out);
      return out;
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static annotations(annotations6) {
      return make60(this.ast).annotations(annotations6);
    }
    static toString() {
      return `(${String(encodedSide)} <-> ${identifier2})`;
    }
    // ----------------
    // Class interface
    // ----------------
    static make(...args2) {
      return new this(...args2);
    }
    static extend(identifier3) {
      return (newFieldsOr, annotations6) => {
        const newFields = getFieldsFromFieldsOr(newFieldsOr);
        const newSchema = getSchemaFromFieldsOr(newFieldsOr);
        const extendedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: extend3(schema, newSchema),
          fields: extendedFields,
          Base: this,
          annotations: annotations6
        });
      };
    }
    static transformOrFail(identifier3) {
      return (newFieldsOr, options, annotations6) => {
        const transformedFields = extendFields(fields, newFieldsOr);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(schema, typeSchema(Struct(transformedFields)), options),
          fields: transformedFields,
          Base: this,
          annotations: annotations6
        });
      };
    }
    static transformOrFailFrom(identifier3) {
      return (newFields, options, annotations6) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(encodedSchema(schema), Struct(transformedFields), options),
          fields: transformedFields,
          Base: this,
          annotations: annotations6
        });
      };
    }
    // ----------------
    // other
    // ----------------
    get [(_a102 = TypeId21, classSymbol)]() {
      return classSymbol;
    }
  }, // ----------------
  // Schema interface
  // ----------------
  __publicField(_b51, _a102, variance7), __publicField(_b51, "fields", {
    ...fields
  }), __publicField(_b51, "identifier", identifier2), _b51);
  if (disableToString !== true) {
    Object.defineProperty(klass.prototype, "toString", {
      value() {
        return `${identifier2}({ ${ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} })`;
      },
      configurable: true,
      writable: true
    });
  }
  return klass;
};
var FiberIdNoneEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("None")
}).annotations({
  identifier: "FiberIdNoneEncoded"
});
var FiberIdRuntimeEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("Runtime"),
  id: Int,
  startTimeMillis: Int
}).annotations({
  identifier: "FiberIdRuntimeEncoded"
});
var FiberIdCompositeEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("Composite"),
  left: suspend13(() => FiberIdEncoded),
  right: suspend13(() => FiberIdEncoded)
}).annotations({
  identifier: "FiberIdCompositeEncoded"
});
var FiberIdEncoded = /* @__PURE__ */ Union2(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
  identifier: "FiberIdEncoded"
});
var fiberIdArbitrary = (fc) => fc.letrec((tie) => ({
  None: fc.record({
    _tag: fc.constant("None")
  }),
  Runtime: fc.record({
    _tag: fc.constant("Runtime"),
    id: fc.integer(),
    startTimeMillis: fc.integer()
  }),
  Composite: fc.record({
    _tag: fc.constant("Composite"),
    left: tie("FiberId"),
    right: tie("FiberId")
  }),
  FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
})).FiberId.map(fiberIdDecode);
var fiberIdPretty = (fiberId3) => {
  switch (fiberId3._tag) {
    case "None":
      return "FiberId.none";
    case "Runtime":
      return `FiberId.runtime(${fiberId3.id}, ${fiberId3.startTimeMillis})`;
    case "Composite":
      return `FiberId.composite(${fiberIdPretty(fiberId3.right)}, ${fiberIdPretty(fiberId3.left)})`;
  }
};
var FiberIdFromSelf = class extends (/* @__PURE__ */ declare(isFiberId2, {
  identifier: "FiberIdFromSelf",
  pretty: () => fiberIdPretty,
  arbitrary: () => fiberIdArbitrary
})) {
};
var fiberIdDecode = (input) => {
  switch (input._tag) {
    case "None":
      return none4;
    case "Runtime":
      return runtime2(input.id, input.startTimeMillis);
    case "Composite":
      return composite2(fiberIdDecode(input.left), fiberIdDecode(input.right));
  }
};
var fiberIdEncode = (input) => {
  switch (input._tag) {
    case "None":
      return {
        _tag: "None"
      };
    case "Runtime":
      return {
        _tag: "Runtime",
        id: input.id,
        startTimeMillis: input.startTimeMillis
      };
    case "Composite":
      return {
        _tag: "Composite",
        left: fiberIdEncode(input.left),
        right: fiberIdEncode(input.right)
      };
  }
};
var FiberId = class extends (/* @__PURE__ */ transform2(FiberIdEncoded, FiberIdFromSelf, {
  strict: true,
  decode: (i) => fiberIdDecode(i),
  encode: (a) => fiberIdEncode(a)
}).annotations({
  identifier: "FiberId"
})) {
};
var causeDieEncoded = (defect) => Struct({
  _tag: Literal2("Die"),
  defect
});
var CauseEmptyEncoded = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal2("Empty")
});
var causeFailEncoded = (error2) => Struct({
  _tag: Literal2("Fail"),
  error: error2
});
var CauseInterruptEncoded = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal2("Interrupt"),
  fiberId: FiberIdEncoded
});
var causeEncodedId = 0;
var causeEncoded = (error2, defect) => {
  const error_ = asSchema(error2);
  const defect_ = asSchema(defect);
  const suspended3 = suspend13(() => out);
  const out = Union2(CauseEmptyEncoded, causeFailEncoded(error_), causeDieEncoded(defect_), CauseInterruptEncoded, Struct({
    _tag: Literal2("Sequential"),
    left: suspended3,
    right: suspended3
  }), Struct({
    _tag: Literal2("Parallel"),
    left: suspended3,
    right: suspended3
  })).annotations({
    title: `CauseEncoded<${format6(error2)}>`,
    [JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`
  });
  return out;
};
var causeArbitrary = (error2, defect) => (fc) => fc.letrec((tie) => ({
  Empty: fc.record({
    _tag: fc.constant("Empty")
  }),
  Fail: fc.record({
    _tag: fc.constant("Fail"),
    error: error2(fc)
  }),
  Die: fc.record({
    _tag: fc.constant("Die"),
    defect: defect(fc)
  }),
  Interrupt: fc.record({
    _tag: fc.constant("Interrupt"),
    fiberId: fiberIdArbitrary(fc)
  }),
  Sequential: fc.record({
    _tag: fc.constant("Sequential"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Parallel: fc.record({
    _tag: fc.constant("Parallel"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
})).Cause.map(causeDecode);
var causePretty = (error2) => (cause3) => {
  const f = (cause4) => {
    switch (cause4._tag) {
      case "Empty":
        return "Cause.empty";
      case "Fail":
        return `Cause.fail(${error2(cause4.error)})`;
      case "Die":
        return `Cause.die(${pretty3(cause4)})`;
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty(cause4.fiberId)})`;
      case "Sequential":
        return `Cause.sequential(${f(cause4.left)}, ${f(cause4.right)})`;
      case "Parallel":
        return `Cause.parallel(${f(cause4.left)}, ${f(cause4.right)})`;
    }
  };
  return f(cause3);
};
var causeParse = (decodeUnknown6) => (u, options, ast) => isCause2(u) ? toComposite(decodeUnknown6(causeEncode(u), options), causeDecode, ast, u) : fail19(new Type2(ast, u));
var CauseFromSelf = ({
  defect,
  error: error2
}) => {
  return declare([error2, defect], {
    decode: (error3, defect2) => causeParse(decodeUnknown2(causeEncoded(error3, defect2))),
    encode: (error3, defect2) => causeParse(encodeUnknown(causeEncoded(error3, defect2)))
  }, {
    title: `Cause<${error2.ast}>`,
    pretty: causePretty,
    arbitrary: causeArbitrary
  });
};
function causeDecode(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return empty26;
    case "Fail":
      return fail6(cause3.error);
    case "Die":
      return die4(cause3.defect);
    case "Interrupt":
      return interrupt5(fiberIdDecode(cause3.fiberId));
    case "Sequential":
      return sequential4(causeDecode(cause3.left), causeDecode(cause3.right));
    case "Parallel":
      return parallel4(causeDecode(cause3.left), causeDecode(cause3.right));
  }
}
function causeEncode(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause3.error
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause3.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause3.fiberId
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause3.left),
        right: causeEncode(cause3.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause3.left),
        right: causeEncode(cause3.right)
      };
  }
}
var Cause = ({
  defect,
  error: error2
}) => {
  const error_ = asSchema(error2);
  const defect_ = asSchema(defect);
  const out = transform2(causeEncoded(error_, defect_), CauseFromSelf({
    error: typeSchema(error_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: (i) => causeDecode(i),
    encode: (a) => causeEncode(a)
  });
  return out;
};
var Defect = class extends (/* @__PURE__ */ transform2(Unknown, Unknown, {
  strict: true,
  decode: (i) => {
    if (isObject(i) && "message" in i && typeof i.message === "string") {
      const err = new Error(i.message, {
        cause: i
      });
      if ("name" in i && typeof i.name === "string") {
        err.name = i.name;
      }
      err.stack = "stack" in i && typeof i.stack === "string" ? i.stack : "";
      return err;
    }
    return String(i);
  },
  encode: (a) => {
    if (a instanceof Error) {
      return {
        name: a.name,
        message: a.message
        // no stack because of security reasons
      };
    }
    return prettyErrorMessage(a);
  }
}).annotations({
  identifier: "Defect"
})) {
};
var exitFailureEncoded = (error2, defect) => Struct({
  _tag: Literal2("Failure"),
  cause: causeEncoded(error2, defect)
});
var exitSuccessEncoded = (value3) => Struct({
  _tag: Literal2("Success"),
  value: value3
});
var exitEncoded = (value3, error2, defect) => {
  return Union2(exitFailureEncoded(error2, defect), exitSuccessEncoded(value3)).annotations({
    title: `ExitEncoded<${format6(value3)}, ${format6(error2)}, ${format6(defect)}>`
  });
};
var exitDecode = (input) => {
  switch (input._tag) {
    case "Failure":
      return failCause4(causeDecode(input.cause));
    case "Success":
      return succeed4(input.value);
  }
};
var exitArbitrary = (value3, error2, defect) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Failure"),
  cause: causeArbitrary(error2, defect)(fc)
}), fc.record({
  _tag: fc.constant("Success"),
  value: value3(fc)
})).map(exitDecode);
var exitPretty = (value3, error2) => (exit4) => exit4._tag === "Failure" ? `Exit.failCause(${causePretty(error2)(exit4.cause)})` : `Exit.succeed(${value3(exit4.value)})`;
var exitParse = (decodeUnknownValue, decodeUnknownCause) => (u, options, ast) => isExit(u) ? match9(u, {
  onFailure: (cause3) => toComposite(decodeUnknownCause(cause3, options), failCause4, ast, u),
  onSuccess: (value3) => toComposite(decodeUnknownValue(value3, options), succeed4, ast, u)
}) : fail19(new Type2(ast, u));
var ExitFromSelf = ({
  defect,
  failure,
  success
}) => declare([success, failure, defect], {
  decode: (success2, failure2, defect2) => exitParse(decodeUnknown2(success2), decodeUnknown2(CauseFromSelf({
    error: failure2,
    defect: defect2
  }))),
  encode: (success2, failure2, defect2) => exitParse(encodeUnknown(success2), encodeUnknown(CauseFromSelf({
    error: failure2,
    defect: defect2
  })))
}, {
  title: `Exit<${success.ast}, ${failure.ast}>`,
  pretty: exitPretty,
  arbitrary: exitArbitrary
});
var Exit = ({
  defect,
  failure,
  success
}) => {
  const success_ = asSchema(success);
  const failure_ = asSchema(failure);
  const defect_ = asSchema(defect);
  const out = transform2(exitEncoded(success_, failure_, defect_), ExitFromSelf({
    failure: typeSchema(failure_),
    success: typeSchema(success_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: (i) => exitDecode(i),
    encode: (a) => a._tag === "Failure" ? {
      _tag: "Failure",
      cause: a.cause
    } : {
      _tag: "Success",
      value: a.value
    }
  });
  return out;
};
var hashSetArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable6);
};
var hashSetPretty = (item) => (set10) => `HashSet(${Array.from(set10).map((a) => item(a)).join(", ")})`;
var hashSetEquivalence = (item) => {
  const arrayEquivalence = getEquivalence3(item);
  return make3((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
var hashSetParse = (decodeUnknown6) => (u, options, ast) => isHashSet2(u) ? toComposite(decodeUnknown6(Array.from(u), options), fromIterable6, ast, u) : fail19(new Type2(ast, u));
var HashSetFromSelf = (value3) => {
  return declare([value3], {
    decode: (item) => hashSetParse(decodeUnknown2(Array$(item))),
    encode: (item) => hashSetParse(encodeUnknown(Array$(item)))
  }, {
    description: `HashSet<${format6(value3)}>`,
    pretty: hashSetPretty,
    arbitrary: hashSetArbitrary,
    equivalence: hashSetEquivalence
  });
};
function HashSet(value3) {
  return transform2(Array$(value3), HashSetFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: (i) => fromIterable6(i),
    encode: (a) => Array.from(a)
  });
}
var hashMapArbitrary = (key, value3, ctx) => (fc) => {
  const items = fc.array(fc.tuple(key(fc), value3(fc)));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable7);
};
var hashMapPretty = (key, value3) => (map31) => `HashMap([${Array.from(map31).map(([k, v]) => `[${key(k)}, ${value3(v)}]`).join(", ")}])`;
var hashMapEquivalence = (key, value3) => {
  const arrayEquivalence = getEquivalence3(make3(([ka, va], [kb, vb]) => key(ka, kb) && value3(va, vb)));
  return make3((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
var hashMapParse = (decodeUnknown6) => (u, options, ast) => isHashMap2(u) ? toComposite(decodeUnknown6(Array.from(u), options), fromIterable7, ast, u) : fail19(new Type2(ast, u));
var HashMapFromSelf = ({
  key,
  value: value3
}) => {
  return declare([key, value3], {
    decode: (key2, value4) => hashMapParse(decodeUnknown2(Array$(Tuple(key2, value4)))),
    encode: (key2, value4) => hashMapParse(encodeUnknown(Array$(Tuple(key2, value4))))
  }, {
    description: `HashMap<${format6(key)}, ${format6(value3)}>`,
    pretty: hashMapPretty,
    arbitrary: hashMapArbitrary,
    equivalence: hashMapEquivalence
  });
};
var HashMap = ({
  key,
  value: value3
}) => {
  return transform2(Array$(Tuple(key, value3)), HashMapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value3))
  }), {
    strict: true,
    decode: (i) => fromIterable7(i),
    encode: (a) => Array.from(a)
  });
};
var listArbitrary = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable8);
};
var listPretty = (item) => (set10) => `List(${Array.from(set10).map((a) => item(a)).join(", ")})`;
var listEquivalence = (item) => {
  const arrayEquivalence = getEquivalence3(item);
  return make3((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
var listParse = (decodeUnknown6) => (u, options, ast) => isList(u) ? toComposite(decodeUnknown6(Array.from(u), options), fromIterable8, ast, u) : fail19(new Type2(ast, u));
var ListFromSelf = (value3) => {
  return declare([value3], {
    decode: (item) => listParse(decodeUnknown2(Array$(item))),
    encode: (item) => listParse(encodeUnknown(Array$(item)))
  }, {
    description: `List<${format6(value3)}>`,
    pretty: listPretty,
    arbitrary: listArbitrary,
    equivalence: listEquivalence
  });
};
function List(value3) {
  return transform2(Array$(value3), ListFromSelf(typeSchema(asSchema(value3))), {
    strict: true,
    decode: (i) => fromIterable8(i),
    encode: (a) => Array.from(a)
  });
}
var sortedSetArbitrary = (item, ord, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as13) => fromIterable12(as13, ord));
};
var sortedSetPretty = (item) => (set10) => `new SortedSet([${Array.from(values4(set10)).map((a) => item(a)).join(", ")}])`;
var sortedSetParse = (decodeUnknown6, ord) => (u, options, ast) => isSortedSet(u) ? toComposite(decodeUnknown6(Array.from(values4(u)), options), (as13) => fromIterable12(as13, ord), ast, u) : fail19(new Type2(ast, u));
var SortedSetFromSelf = (value3, ordA, ordI) => {
  return declare([value3], {
    decode: (item) => sortedSetParse(decodeUnknown2(Array$(item)), ordA),
    encode: (item) => sortedSetParse(encodeUnknown(Array$(item)), ordI)
  }, {
    description: `SortedSet<${format6(value3)}>`,
    pretty: sortedSetPretty,
    arbitrary: (arb, ctx) => sortedSetArbitrary(arb, ordA, ctx),
    equivalence: () => getEquivalence6()
  });
};
function SortedSet(value3, ordA) {
  const to = typeSchema(asSchema(value3));
  return transform2(Array$(value3), SortedSetFromSelf(to, ordA, ordA), {
    strict: true,
    decode: (i) => fromIterable12(i, ordA),
    encode: (a) => Array.from(values4(a))
  });
}
var BooleanFromUnknown = class extends (/* @__PURE__ */ transform2(Unknown, Boolean$, {
  strict: true,
  decode: (i) => isTruthy(i),
  encode: identity
}).annotations({
  identifier: "BooleanFromUnknown"
})) {
};
var BooleanFromString = class extends (/* @__PURE__ */ transform2(Literal2("true", "false").annotations({
  description: "a string to be decoded into a boolean"
}), Boolean$, {
  strict: true,
  decode: (i) => i === "true",
  encode: (a) => a ? "true" : "false"
}).annotations({
  identifier: "BooleanFromString"
})) {
};
var Config = (name, schema) => {
  const decodeUnknownEither5 = decodeUnknownEither(schema);
  return string3(name).pipe(mapOrFail2((s) => decodeUnknownEither5(s).pipe(mapLeft((error2) => InvalidData2([], TreeFormatter.formatIssueSync(error2))))));
};
var symbolSerializable = /* @__PURE__ */ Symbol.for("effect/Schema/Serializable/symbol");
var asSerializable = (serializable) => serializable;
var serializableSchema = (self) => self[symbolSerializable];
var serialize = (self) => encodeUnknown2(self[symbolSerializable])(self);
var deserialize = /* @__PURE__ */ dual(2, (self, value3) => decodeUnknown3(self[symbolSerializable])(value3));
var symbolWithResult = /* @__PURE__ */ Symbol.for("effect/Schema/Serializable/symbolResult");
var asWithResult = (withExit) => withExit;
var failureSchema = (self) => self[symbolWithResult].failure;
var successSchema = (self) => self[symbolWithResult].success;
var exitSchemaCache = /* @__PURE__ */ globalValue("effect/Schema/Serializable/exitSchemaCache", () => /* @__PURE__ */ new WeakMap());
var exitSchema = (self) => {
  const proto14 = Object.getPrototypeOf(self);
  if (!(symbolWithResult in proto14)) {
    return Exit({
      failure: failureSchema(self),
      success: successSchema(self),
      defect: Defect
    });
  }
  let schema = exitSchemaCache.get(proto14);
  if (schema === void 0) {
    schema = Exit({
      failure: failureSchema(self),
      success: successSchema(self),
      defect: Defect
    });
    exitSchemaCache.set(proto14, schema);
  }
  return schema;
};
var serializeFailure = /* @__PURE__ */ dual(2, (self, value3) => encode4(self[symbolWithResult].failure)(value3));
var deserializeFailure = /* @__PURE__ */ dual(2, (self, value3) => decodeUnknown3(self[symbolWithResult].failure)(value3));
var serializeSuccess = /* @__PURE__ */ dual(2, (self, value3) => encode4(self[symbolWithResult].success)(value3));
var deserializeSuccess = /* @__PURE__ */ dual(2, (self, value3) => decodeUnknown3(self[symbolWithResult].success)(value3));
var serializeExit = /* @__PURE__ */ dual(2, (self, value3) => encode4(exitSchema(self))(value3));
var deserializeExit = /* @__PURE__ */ dual(2, (self, value3) => decodeUnknown3(exitSchema(self))(value3));
var asSerializableWithResult = (procedure) => procedure;
var TaggedRequest = (identifier2) => (tag3, options, annotations5) => {
  var _a102;
  const taggedFields = extendFields({
    _tag: getClassTag(tag3)
  }, options.payload);
  return _a102 = class extends makeClass({
    kind: "TaggedRequest",
    identifier: identifier2 ?? tag3,
    schema: Struct(taggedFields),
    fields: taggedFields,
    Base: Class5,
    annotations: annotations5
  }) {
    get [symbolSerializable]() {
      return this.constructor;
    }
    get [symbolWithResult]() {
      return {
        failure: options.failure,
        success: options.success
      };
    }
  }, __publicField(_a102, "_tag", tag3), __publicField(_a102, "success", options.success), __publicField(_a102, "failure", options.failure), _a102;
};
var equivalence2 = (schema) => go2(schema.ast, []);
var getEquivalenceAnnotation = /* @__PURE__ */ getAnnotation(EquivalenceAnnotationId);
var go2 = (ast, path) => {
  const hook = getEquivalenceAnnotation(ast);
  if (isSome2(hook)) {
    switch (ast._tag) {
      case "Declaration":
        return hook.value(...ast.typeParameters.map((tp) => go2(tp, path)));
      case "Refinement":
        return hook.value(go2(ast.from, path));
      default:
        return hook.value();
    }
  }
  switch (ast._tag) {
    case "NeverKeyword":
      throw new Error(getEquivalenceUnsupportedErrorMessage(ast, path));
    case "Transformation":
      return go2(ast.to, path);
    case "Declaration":
    case "Literal":
    case "StringKeyword":
    case "TemplateLiteral":
    case "UniqueSymbol":
    case "SymbolKeyword":
    case "UnknownKeyword":
    case "AnyKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "Enums":
    case "ObjectKeyword":
      return equals;
    case "Refinement":
      return go2(ast.from, path);
    case "Suspend": {
      const get17 = memoizeThunk(() => go2(ast.f(), path));
      return (a, b) => get17()(a, b);
    }
    case "TupleType": {
      const elements = ast.elements.map((element3, i) => go2(element3.type, path.concat(i)));
      const rest = ast.rest.map((annotatedAST) => go2(annotatedAST.type, path));
      return make3((a, b) => {
        const len = a.length;
        if (len !== b.length) {
          return false;
        }
        let i = 0;
        for (; i < Math.min(len, ast.elements.length); i++) {
          if (!elements[i](a[i], b[i])) {
            return false;
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head8, ...tail2] = rest;
          for (; i < len - tail2.length; i++) {
            if (!head8(a[i], b[i])) {
              return false;
            }
          }
          for (let j = 0; j < tail2.length; j++) {
            i += j;
            if (!tail2[j](a[i], b[i])) {
              return false;
            }
          }
        }
        return true;
      });
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return equals;
      }
      const propertySignatures = ast.propertySignatures.map((ps) => go2(ps.type, path.concat(ps.name)));
      const indexSignatures = ast.indexSignatures.map((is4) => go2(is4.type, path));
      return make3((a, b) => {
        const aStringKeys = Object.keys(a);
        const aSymbolKeys = Object.getOwnPropertySymbols(a);
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = ast.propertySignatures[i];
          const name = ps.name;
          const aHas = Object.prototype.hasOwnProperty.call(a, name);
          const bHas = Object.prototype.hasOwnProperty.call(b, name);
          if (ps.isOptional) {
            if (aHas !== bHas) {
              return false;
            }
          }
          if (aHas && bHas && !propertySignatures[i](a[name], b[name])) {
            return false;
          }
        }
        let bSymbolKeys;
        let bStringKeys;
        for (let i = 0; i < indexSignatures.length; i++) {
          const is4 = ast.indexSignatures[i];
          const encodedParameter = getEncodedParameter(is4.parameter);
          const isSymbol2 = isSymbolKeyword(encodedParameter);
          if (isSymbol2) {
            bSymbolKeys = bSymbolKeys || Object.getOwnPropertySymbols(b);
            if (aSymbolKeys.length !== bSymbolKeys.length) {
              return false;
            }
          } else {
            bStringKeys = bStringKeys || Object.keys(b);
            if (aStringKeys.length !== bStringKeys.length) {
              return false;
            }
          }
          const aKeys = isSymbol2 ? aSymbolKeys : aStringKeys;
          for (let j = 0; j < aKeys.length; j++) {
            const key = aKeys[j];
            if (!Object.prototype.hasOwnProperty.call(b, key) || !indexSignatures[i](a[key], b[key])) {
              return false;
            }
          }
        }
        return true;
      });
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, true);
      const ownKeys3 = ownKeys(searchTree.keys);
      const len = ownKeys3.length;
      return make3((a, b) => {
        let candidates = [];
        if (len > 0 && isRecordOrArray(a)) {
          for (let i = 0; i < len; i++) {
            const name = ownKeys3[i];
            const buckets = searchTree.keys[name].buckets;
            if (Object.prototype.hasOwnProperty.call(a, name)) {
              const literal2 = String(a[name]);
              if (Object.prototype.hasOwnProperty.call(buckets, literal2)) {
                candidates = candidates.concat(buckets[literal2]);
              }
            }
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        const tuples = candidates.map((ast2) => [go2(ast2, path), is({
          ast: ast2
        })]);
        for (let i = 0; i < tuples.length; i++) {
          const [equivalence3, is4] = tuples[i];
          if (is4(a) && is4(b)) {
            if (equivalence3(a, b)) {
              return true;
            }
          }
        }
        return false;
      });
    }
  }
};
var SymbolStruct = /* @__PURE__ */ TaggedStruct("symbol", {
  key: String$
}).annotations({
  description: "an object to be decoded into a globally shared symbol"
});
var SymbolFromStruct = /* @__PURE__ */ transformOrFail(SymbolStruct, SymbolFromSelf, {
  strict: true,
  decode: (i) => decodeSymbol(i.key),
  encode: (a, _, ast) => map27(encodeSymbol2(a, ast), (key) => SymbolStruct.make({
    key
  }))
});
var PropertyKey$ = class extends (/* @__PURE__ */ Union2(String$, Number$, SymbolFromStruct).annotations({
  identifier: "PropertyKey"
})) {
};
var ArrayFormatterIssue = class extends (/* @__PURE__ */ Struct({
  _tag: propertySignature(Literal2("Pointer", "Unexpected", "Missing", "Composite", "Refinement", "Transformation", "Type", "Forbidden")).annotations({
    description: "The tag identifying the type of parse issue"
  }),
  path: propertySignature(Array$(PropertyKey$)).annotations({
    description: "The path to the property where the issue occurred"
  }),
  message: propertySignature(String$).annotations({
    description: "A descriptive message explaining the issue"
  })
}).annotations({
  identifier: "ArrayFormatterIssue",
  description: "Represents an issue returned by the ArrayFormatter formatter"
})) {
};

// ../../packages/ai/src/core/AiError.ts
var TypeId22 = Symbol.for("@effect/ai/AiError");
var _a76, _b27;
var AiError = class extends (_b27 = TaggedError2("@effect/ai/AiError")("AiError", {
  module: String$,
  method: String$,
  description: String$,
  cause: optional(Defect)
}), _a76 = TypeId22, _b27) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a76, TypeId22);
  }
  /**
   * @since 1.0.0
   */
  static is(u) {
    return hasProperty(u, TypeId22);
  }
  /**
   * @since 1.0.0
   */
  get message() {
    return `${this.module}.${this.method}: ${this.description}`;
  }
};

// ../../packages/ai/src/core/AiLanguageModel.ts
var AiLanguageModel_exports = {};
__export(AiLanguageModel_exports, {
  AiLanguageModel: () => AiLanguageModel,
  generateObject: () => generateObject,
  generateText: () => generateText,
  make: () => make62,
  streamText: () => streamText
});

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/JSONSchema.js
var fromAST = (ast, options) => {
  const definitionPath = options.definitionPath ?? "#/$defs/";
  const getRef = (id3) => definitionPath + id3;
  const target = options.target ?? "jsonSchema7";
  const handleIdentifier = options.topLevelReferenceStrategy !== "skip";
  const additionalPropertiesStrategy = options.additionalPropertiesStrategy ?? "strict";
  return go3(ast, options.definitions, handleIdentifier, [], {
    getRef,
    target,
    additionalPropertiesStrategy
  });
};
var constNever = {
  "$id": "/schemas/never",
  "not": {}
};
var constAny = {
  "$id": "/schemas/any"
};
var constUnknown = {
  "$id": "/schemas/unknown"
};
var constVoid2 = {
  "$id": "/schemas/void"
};
var constAnyObject = {
  "$id": "/schemas/object",
  "anyOf": [{
    "type": "object"
  }, {
    "type": "array"
  }]
};
var constEmpty = {
  "$id": "/schemas/%7B%7D",
  "anyOf": [{
    "type": "object"
  }, {
    "type": "array"
  }]
};
var getJsonSchemaAnnotations = (ast, annotated) => {
  annotated ?? (annotated = ast);
  const out = getSomes({
    description: getDescriptionAnnotation(annotated),
    title: getTitleAnnotation(annotated),
    default: getDefaultAnnotation(annotated)
  });
  const oexamples = getExamplesAnnotation(annotated);
  if (isSome2(oexamples) && oexamples.value.length > 0) {
    const getOption5 = getOption3(ast, false);
    const examples = filterMap3(oexamples.value, (e) => getOption5(e));
    if (examples.length > 0) {
      out.examples = examples;
    }
  }
  return out;
};
var removeDefaultJsonSchemaAnnotations = (jsonSchemaAnnotations, ast) => {
  if (jsonSchemaAnnotations["title"] === ast.annotations[TitleAnnotationId]) {
    delete jsonSchemaAnnotations["title"];
  }
  if (jsonSchemaAnnotations["description"] === ast.annotations[DescriptionAnnotationId]) {
    delete jsonSchemaAnnotations["description"];
  }
  return jsonSchemaAnnotations;
};
var getASTJsonSchemaAnnotations = (ast) => {
  const jsonSchemaAnnotations = getJsonSchemaAnnotations(ast);
  switch (ast._tag) {
    case "StringKeyword":
      return removeDefaultJsonSchemaAnnotations(jsonSchemaAnnotations, stringKeyword);
    case "NumberKeyword":
      return removeDefaultJsonSchemaAnnotations(jsonSchemaAnnotations, numberKeyword);
    case "BooleanKeyword":
      return removeDefaultJsonSchemaAnnotations(jsonSchemaAnnotations, booleanKeyword);
    default:
      return jsonSchemaAnnotations;
  }
};
var pruneUndefined3 = (ast) => {
  if (isNone2(getJSONSchemaAnnotation(ast))) {
    return pruneUndefined(ast, pruneUndefined3, (ast2) => pruneUndefined3(ast2.from));
  }
};
var isParseJsonTransformation = (ast) => ast.annotations[SchemaIdAnnotationId] === ParseJsonSchemaId;
var isOverrideAnnotation = (jsonSchema) => {
  return "type" in jsonSchema || "oneOf" in jsonSchema || "anyOf" in jsonSchema || "const" in jsonSchema || "enum" in jsonSchema || "$ref" in jsonSchema;
};
var isMergeableEnum = (jsonSchema) => {
  const len = Object.keys(jsonSchema).length;
  return "enum" in jsonSchema && (len === 1 || "type" in jsonSchema && len === 2);
};
var addEnumType = (jsonSchema) => {
  if ("enum" in jsonSchema && !("type" in jsonSchema)) {
    const type = jsonSchema.enum.every(isString) ? "string" : jsonSchema.enum.every(isNumber) ? "number" : jsonSchema.enum.every(isBoolean) ? "boolean" : void 0;
    if (type !== void 0) {
      return {
        type,
        ...jsonSchema
      };
    }
  }
  return jsonSchema;
};
var mergeRefinements = (from, jsonSchema, annotations5) => {
  const out = {
    ...from,
    ...annotations5,
    ...jsonSchema
  };
  out.allOf ?? (out.allOf = []);
  const handle = (name, filter14) => {
    if (name in jsonSchema && name in from) {
      out.allOf.unshift({
        [name]: from[name]
      });
      out.allOf = out.allOf.filter(filter14);
    }
  };
  handle("minLength", (i) => i.minLength > jsonSchema.minLength);
  handle("maxLength", (i) => i.maxLength < jsonSchema.maxLength);
  handle("pattern", (i) => i.pattern !== jsonSchema.pattern);
  handle("minItems", (i) => i.minItems > jsonSchema.minItems);
  handle("maxItems", (i) => i.maxItems < jsonSchema.maxItems);
  handle("minimum", (i) => i.minimum > jsonSchema.minimum);
  handle("maximum", (i) => i.maximum < jsonSchema.maximum);
  handle("exclusiveMinimum", (i) => i.exclusiveMinimum > jsonSchema.exclusiveMinimum);
  handle("exclusiveMaximum", (i) => i.exclusiveMaximum < jsonSchema.exclusiveMaximum);
  handle("multipleOf", (i) => i.multipleOf !== jsonSchema.multipleOf);
  if (out.allOf.length === 0) {
    delete out.allOf;
  }
  return out;
};
function isContentSchemaSupported(options) {
  switch (options.target) {
    case "jsonSchema7":
      return false;
    case "jsonSchema2019-09":
    case "openApi3.1":
      return true;
  }
}
function isNullTypeKeywordSupported(options) {
  switch (options.target) {
    case "jsonSchema7":
    case "jsonSchema2019-09":
      return true;
    case "openApi3.1":
      return false;
  }
}
function isNullableKeywordSupported(options) {
  switch (options.target) {
    case "jsonSchema7":
    case "jsonSchema2019-09":
      return false;
    case "openApi3.1":
      return true;
  }
}
function getAdditionalProperties(options) {
  switch (options.additionalPropertiesStrategy) {
    case "allow":
      return true;
    case "strict":
      return false;
  }
}
var isNeverJSONSchema = (jsonSchema) => "$id" in jsonSchema && jsonSchema.$id === "/schemas/never";
var isAnyJSONSchema = (jsonSchema) => "$id" in jsonSchema && jsonSchema.$id === "/schemas/any";
var isUnknownJSONSchema = (jsonSchema) => "$id" in jsonSchema && jsonSchema.$id === "/schemas/unknown";
var isVoidJSONSchema = (jsonSchema) => "$id" in jsonSchema && jsonSchema.$id === "/schemas/void";
var shrink = (members) => {
  let i = members.findIndex(isAnyJSONSchema);
  if (i !== -1) {
    members = [members[i]];
  }
  i = members.findIndex(isUnknownJSONSchema);
  if (i !== -1) {
    members = [members[i]];
  }
  i = members.findIndex(isVoidJSONSchema);
  if (i !== -1) {
    members = [members[i]];
  }
  return members;
};
var go3 = (ast, $defs, handleIdentifier, path, options) => {
  if (handleIdentifier) {
    const identifier2 = getJSONIdentifier(ast);
    if (isSome2(identifier2)) {
      const id3 = identifier2.value;
      const escapedId = id3.replace(/~/ig, "~0").replace(/\//ig, "~1");
      const out = {
        $ref: options.getRef(escapedId)
      };
      if (!has($defs, id3)) {
        $defs[id3] = out;
        $defs[id3] = go3(ast, $defs, false, path, options);
      }
      return out;
    }
  }
  const hook = getJSONSchemaAnnotation(ast);
  if (isSome2(hook)) {
    const handler = hook.value;
    if (isRefinement(ast)) {
      const t = getTransformationFrom(ast);
      if (t === void 0) {
        return mergeRefinements(go3(ast.from, $defs, handleIdentifier, path, options), handler, getJsonSchemaAnnotations(ast));
      } else if (!isOverrideAnnotation(handler)) {
        return go3(t, $defs, handleIdentifier, path, options);
      }
    }
    if (isDeclaration(ast)) {
      return {
        ...handler,
        ...getJsonSchemaAnnotations(ast)
      };
    }
    return handler;
  }
  const surrogate = getSurrogateAnnotation(ast);
  if (isSome2(surrogate)) {
    return go3(surrogate.value, $defs, handleIdentifier, path, options);
  }
  switch (ast._tag) {
    case "Declaration":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "Literal": {
      const literal2 = ast.literal;
      if (literal2 === null) {
        if (isNullTypeKeywordSupported(options)) {
          return {
            type: "null",
            ...getJsonSchemaAnnotations(ast)
          };
        } else {
          return {
            // @ts-expect-error
            enum: [null],
            ...getJsonSchemaAnnotations(ast)
          };
        }
      } else if (isString(literal2)) {
        return {
          type: "string",
          enum: [literal2],
          ...getJsonSchemaAnnotations(ast)
        };
      } else if (isNumber(literal2)) {
        return {
          type: "number",
          enum: [literal2],
          ...getJsonSchemaAnnotations(ast)
        };
      } else if (isBoolean(literal2)) {
        return {
          type: "boolean",
          enum: [literal2],
          ...getJsonSchemaAnnotations(ast)
        };
      }
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    }
    case "UniqueSymbol":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "UndefinedKeyword":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "VoidKeyword":
      return {
        ...constVoid2,
        ...getJsonSchemaAnnotations(ast)
      };
    case "NeverKeyword":
      return {
        ...constNever,
        ...getJsonSchemaAnnotations(ast)
      };
    case "UnknownKeyword":
      return {
        ...constUnknown,
        ...getJsonSchemaAnnotations(ast)
      };
    case "AnyKeyword":
      return {
        ...constAny,
        ...getJsonSchemaAnnotations(ast)
      };
    case "ObjectKeyword":
      return {
        ...constAnyObject,
        ...getJsonSchemaAnnotations(ast)
      };
    case "StringKeyword":
      return {
        type: "string",
        ...getASTJsonSchemaAnnotations(ast)
      };
    case "NumberKeyword":
      return {
        type: "number",
        ...getASTJsonSchemaAnnotations(ast)
      };
    case "BooleanKeyword":
      return {
        type: "boolean",
        ...getASTJsonSchemaAnnotations(ast)
      };
    case "BigIntKeyword":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "SymbolKeyword":
      throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
    case "TupleType": {
      const elements = ast.elements.map((e, i) => ({
        ...go3(e.type, $defs, true, path.concat(i), options),
        ...getJsonSchemaAnnotations(e.type, e)
      }));
      const rest = ast.rest.map((annotatedAST) => ({
        ...go3(annotatedAST.type, $defs, true, path, options),
        ...getJsonSchemaAnnotations(annotatedAST.type, annotatedAST)
      }));
      const output3 = {
        type: "array"
      };
      const len = ast.elements.length;
      if (len > 0) {
        output3.minItems = len - ast.elements.filter((element3) => element3.isOptional).length;
        output3.items = elements;
      }
      const restLength = rest.length;
      if (restLength > 0) {
        const head8 = rest[0];
        const isHomogeneous = restLength === 1 && ast.elements.every((e) => e.type === ast.rest[0].type);
        if (isHomogeneous) {
          output3.items = head8;
        } else {
          output3.additionalItems = head8;
        }
        if (restLength > 1) {
          throw new Error(getJSONSchemaUnsupportedPostRestElementsErrorMessage(path));
        }
      } else {
        if (len > 0) {
          output3.additionalItems = false;
        } else {
          output3.maxItems = 0;
        }
      }
      return {
        ...output3,
        ...getJsonSchemaAnnotations(ast)
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return {
          ...constEmpty,
          ...getJsonSchemaAnnotations(ast)
        };
      }
      const output3 = {
        type: "object",
        required: [],
        properties: {},
        additionalProperties: getAdditionalProperties(options)
      };
      let patternProperties = void 0;
      let propertyNames = void 0;
      for (const is4 of ast.indexSignatures) {
        const pruned = pruneUndefined3(is4.type) ?? is4.type;
        const parameter = is4.parameter;
        switch (parameter._tag) {
          case "StringKeyword": {
            output3.additionalProperties = go3(pruned, $defs, true, path, options);
            break;
          }
          case "TemplateLiteral": {
            patternProperties = go3(pruned, $defs, true, path, options);
            propertyNames = {
              type: "string",
              pattern: getTemplateLiteralRegExp(parameter).source
            };
            break;
          }
          case "Refinement": {
            patternProperties = go3(pruned, $defs, true, path, options);
            propertyNames = go3(parameter, $defs, true, path, options);
            break;
          }
          case "SymbolKeyword": {
            const indexSignaturePath = path.concat("[symbol]");
            output3.additionalProperties = go3(pruned, $defs, true, indexSignaturePath, options);
            propertyNames = go3(parameter, $defs, true, indexSignaturePath, options);
            break;
          }
        }
      }
      for (let i = 0; i < ast.propertySignatures.length; i++) {
        const ps = ast.propertySignatures[i];
        const name = ps.name;
        if (isString(name)) {
          const pruned = pruneUndefined3(ps.type);
          const type = pruned ?? ps.type;
          output3.properties[name] = {
            ...go3(type, $defs, true, path.concat(ps.name), options),
            ...getJsonSchemaAnnotations(type, ps)
          };
          if (!ps.isOptional && pruned === void 0) {
            output3.required.push(name);
          }
        } else {
          throw new Error(getJSONSchemaUnsupportedKeyErrorMessage(name, path));
        }
      }
      if (patternProperties !== void 0) {
        delete output3.additionalProperties;
        output3.patternProperties = {
          "": patternProperties
        };
      }
      if (propertyNames !== void 0) {
        output3.propertyNames = propertyNames;
      }
      return {
        ...output3,
        ...getJsonSchemaAnnotations(ast)
      };
    }
    case "Union": {
      const members = [];
      for (const type of ast.types) {
        const jsonSchema = go3(type, $defs, true, path, options);
        if (!isNeverJSONSchema(jsonSchema)) {
          const last5 = members[members.length - 1];
          if (isMergeableEnum(jsonSchema) && last5 !== void 0 && isMergeableEnum(last5)) {
            members[members.length - 1] = {
              enum: last5.enum.concat(jsonSchema.enum)
            };
          } else {
            members.push(jsonSchema);
          }
        }
      }
      const anyOf = shrink(members);
      const finalize = (anyOf2) => {
        switch (anyOf2.length) {
          case 0:
            return {
              ...constNever,
              ...getJsonSchemaAnnotations(ast)
            };
          case 1: {
            return {
              ...addEnumType(anyOf2[0]),
              ...getJsonSchemaAnnotations(ast)
            };
          }
          default:
            return {
              anyOf: anyOf2.map(addEnumType),
              ...getJsonSchemaAnnotations(ast)
            };
        }
      };
      if (isNullableKeywordSupported(options)) {
        let nullable = false;
        const nonNullables = [];
        for (const s of anyOf) {
          if ("nullable" in s) {
            nullable = true;
            const nn = {
              ...s
            };
            delete nn.nullable;
            nonNullables.push(nn);
          } else if (isMergeableEnum(s)) {
            const nnes = s.enum.filter((e) => e !== null);
            if (nnes.length < s.enum.length) {
              nullable = true;
              if (nnes.length === 0) {
                continue;
              }
              const nn = {
                ...s
              };
              nn.enum = nnes;
              nonNullables.push(nn);
            }
          } else {
            nonNullables.push(s);
          }
        }
        if (nullable) {
          const out = finalize(nonNullables);
          if (!isAnyJSONSchema(out) && !isUnknownJSONSchema(out)) {
            out.nullable = nullable;
          }
          return out;
        }
      }
      return finalize(anyOf);
    }
    case "Enums": {
      const anyOf = ast.enums.map((e) => addEnumType({
        title: e[0],
        enum: [e[1]]
      }));
      return anyOf.length >= 1 ? {
        $comment: "/schemas/enums",
        anyOf,
        ...getJsonSchemaAnnotations(ast)
      } : {
        ...constNever,
        ...getJsonSchemaAnnotations(ast)
      };
    }
    case "Refinement": {
      if (getTransformationFrom(ast) === void 0) {
        throw new Error(getJSONSchemaMissingAnnotationErrorMessage(path, ast));
      }
      return go3(ast.from, $defs, handleIdentifier, path, options);
    }
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp(ast);
      return {
        type: "string",
        title: String(ast),
        description: "a template literal",
        pattern: regex.source,
        ...getJsonSchemaAnnotations(ast)
      };
    }
    case "Suspend": {
      const identifier2 = orElse(getJSONIdentifier(ast), () => getJSONIdentifier(ast.f()));
      if (isNone2(identifier2)) {
        throw new Error(getJSONSchemaMissingIdentifierAnnotationErrorMessage(path, ast));
      }
      return go3(ast.f(), $defs, handleIdentifier, path, options);
    }
    case "Transformation": {
      if (isParseJsonTransformation(ast.from)) {
        const out = {
          "type": "string",
          "contentMediaType": "application/json"
        };
        if (isContentSchemaSupported(options)) {
          out["contentSchema"] = go3(ast.to, $defs, handleIdentifier, path, options);
        }
        return out;
      }
      let next4 = ast.from;
      if (isTypeLiteralTransformation(ast.transformation)) {
        const identifier2 = getIdentifierAnnotation(ast);
        if (isSome2(identifier2) && isNone2(getIdentifierAnnotation(next4))) {
          next4 = annotations(next4, {
            [IdentifierAnnotationId]: identifier2.value
          });
        }
        const title = getTitleAnnotation(ast);
        if (isSome2(title) && isNone2(getTitleAnnotation(next4))) {
          next4 = annotations(next4, {
            [TitleAnnotationId]: title.value
          });
        }
        const description = getDescriptionAnnotation(ast);
        if (isSome2(description) && isNone2(getDescriptionAnnotation(next4))) {
          next4 = annotations(next4, {
            [DescriptionAnnotationId]: description.value
          });
        }
      }
      return go3(next4, $defs, handleIdentifier, path, options);
    }
  }
};

// ../../packages/ai/src/core/AiInput.ts
var AiInput_exports = {};
__export(AiInput_exports, {
  AiInput: () => AiInput,
  AssistantMessage: () => AssistantMessage,
  AssistantMessagePart: () => AssistantMessagePart,
  FilePart: () => FilePart,
  FileUrlPart: () => FileUrlPart,
  FromJson: () => FromJson2,
  ImagePart: () => ImagePart,
  ImageUrlPart: () => ImageUrlPart,
  Message: () => Message,
  MessageTypeId: () => MessageTypeId,
  PartTypeId: () => PartTypeId2,
  ReasoningPart: () => ReasoningPart2,
  RedactedReasoningPart: () => RedactedReasoningPart2,
  TextPart: () => TextPart2,
  ToolCallId: () => ToolCallId3,
  ToolCallPart: () => ToolCallPart2,
  ToolCallResultPart: () => ToolCallResultPart,
  ToolMessage: () => ToolMessage,
  ToolMessagePart: () => ToolMessagePart,
  TypeId: () => TypeId24,
  UserMessage: () => UserMessage,
  UserMessagePart: () => UserMessagePart,
  concat: () => concat4,
  empty: () => empty36,
  is: () => is2,
  isMessage: () => isMessage,
  isPart: () => isPart,
  make: () => make61
});

// ../../packages/ai/src/core/internal/common.ts
var ToolCallId = String$.pipe(
  brand("@effect/ai/ToolCallId")
);
var ProviderMetadata = Record({
  key: String$,
  value: Record({ key: String$, value: Unknown })
}).annotations({ identifier: "@effect/ai/ProviderMetadata" });

// ../../packages/ai/src/core/AiResponse.ts
var constDisableValidation = { disableValidation: true };
var TypeId23 = Symbol.for("@effect/ai/AiResponse");
var _a77, _b28;
var AiResponse = class extends (_b28 = Class6(
  "@effect/ai/AiResponse"
)({
  /**
   * The parts of the response.
   */
  parts: Array$(suspend13(() => Part))
}), _a77 = TypeId23, _b28) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a77, TypeId23);
  }
  /**
   * Returns the generated text content of the response.
   */
  get text() {
    let text = "";
    let found = false;
    for (const part of this.parts) {
      if (part._tag === "TextPart") {
        text += found ? "\n\n" + part.text : part.text;
        found = true;
      }
    }
    return text;
  }
  /**
   * Returns the finish reason for the response, or `"unknown"` if the finish
   * reason is not known.
   */
  get finishReason() {
    const finishPart = this.parts.find((part) => part._tag === "FinishPart");
    return finishPart?.reason ?? "unknown";
  }
  /**
   * Attempts to retrieve provider-specific response metadata.
   */
  getProviderMetadata(tag3) {
    const finishPart = this.parts.find((part) => part._tag === "FinishPart");
    return fromNullable(finishPart?.providerMetadata[tag3.key]);
  }
};
var FromJson = parseJson(AiResponse);
var StructuredResponseTypeId = Symbol.for("@effect/ai/AiResponse/StructuredResponse");
var _a78, _b29;
var WithStructuredOutput = class extends (_b29 = AiResponse, _a78 = StructuredResponseTypeId, _b29) {
  constructor(props, options) {
    super({ parts: props.parts }, options);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a78, StructuredResponseTypeId);
    /**
     * The identifier of the tool which generated the structured output.
     */
    __publicField(this, "id");
    /**
     * The name of the tool which generated the structured output.
     */
    __publicField(this, "name");
    /**
     * The structured output generated by the model.
     */
    __publicField(this, "value");
    this.id = props.id;
    this.name = props.name;
    this.value = props.value;
  }
};
var WithToolCallResultsTypeId = Symbol.for("@effect/ai/AiResponse/WithToolCallResults");
var _a79, _b30;
var WithToolCallResults = class extends (_b30 = AiResponse, _a79 = WithToolCallResultsTypeId, _b30) {
  constructor(props, options) {
    super({ parts: props.parts }, options);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a79, WithToolCallResultsTypeId);
    /**
     * The tool call results, represented as a mapping between the tool call
     * identifier and the result of the tool call handler.
     */
    __publicField(this, "results");
    /**
     * The encoded tool call results, suitable for incorporation into subsequent
     * requests to the large language model.
     */
    __publicField(this, "encodedResults");
    this.results = props.results;
    this.encodedResults = props.encodedResults;
  }
};
var PartTypeId = Symbol.for("@effect/ai/AiResponse/Part");
var ContentSourceAnnotation = class extends TaggedClass3(
  "@effect/ai/AiResponse/Annotation/ContentSourceAnnotation"
)("ContentSourceAnnotation", {
  /**
   * The identifier for the content source.
   */
  id: String$,
  /**
   * The index of the content source in the list of sources provided in the
   * model request parameters.
   */
  index: Int,
  /**
   * The provider-specific type of the file annotation.
   *
   * For example, when using Anthropic the type may be `char_location`,
   * `page_location`, or `content_block_location`.
   */
  type: String$,
  /**
   * The content used from the content source in the message generated by the
   * model.
   */
  referencedContent: String$,
  /**
   * The index of the first character of the content referenced by the content
   * source in the message generated by the model.
   */
  startIndex: Int,
  /**
   * The index of the last character of the content referenced by the content
   * source in the message generated by the model.
   */
  endIndex: Int
}) {
};
var FileAnnotation = class extends TaggedClass3(
  "@effect/ai/AiResponse/Annotation/FileAnnotation"
)("FileAnnotation", {
  /**
   * The identifier for the file.
   */
  id: String$,
  /**
   * The provider-specific type of the file annotation.
   *
   * For example, when using OpenAi the type may be `file_citation` or
   * `file_path`.
   */
  type: String$,
  /**
   * The index of the file in the list of files provided in the model request
   * parameters.
   */
  index: Int
}) {
};
var UrlAnnotation = class extends TaggedClass3(
  "@effect/ai/AiResponse/Annotation/UrlAnnotation"
)("UrlAnnotation", {
  /**
   * The URL of the web resource.
   */
  url: String$,
  /**
   * The title of the web resource.
   */
  title: String$,
  /**
   * The index of the first character of the content referenced by the web
   * resource in the message generated by the model.
   */
  startIndex: Int,
  /**
   * The index of the last character of the content referenced by the web
   * resource in the message generated by the model.
   */
  endIndex: Int
}) {
};
var Annotation = Union2(
  ContentSourceAnnotation,
  FileAnnotation,
  UrlAnnotation
);
var _a80, _b31;
var TextPart = class extends (_b31 = TaggedClass3(
  "@effect/ai/AiResponse/TextPart"
)("TextPart", {
  /**
   * The text content generated by the model.
   */
  text: String$,
  /**
   * The annotations used to support the text generated by the model.
   */
  annotations: optionalWith(Array$(Annotation), {
    default: () => []
  })
}), _a80 = PartTypeId, _b31) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a80, PartTypeId);
  }
};
var _a81, _b32;
var ReasoningPart = class extends (_b32 = TaggedClass3(
  "@effect/ai/AiResponse/ReasoningPart"
)("ReasoningPart", {
  /**
   * The reasoning content that the model used to return the output.
   */
  reasoningText: String$,
  /**
   * An optional signature which verifies that the reasoning text was generated
   * by the model.
   */
  signature: optional(String$)
}), _a81 = PartTypeId, _b32) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a81, PartTypeId);
  }
};
var _a82, _b33;
var RedactedReasoningPart = class extends (_b33 = TaggedClass3(
  "@effect/ai/AiResponse/RedactedReasoningPart"
)("RedactedReasoningPart", {
  /**
   * The content in the reasoning that was encrypted by the model provider for
   * safety reasons.
   */
  redactedText: String$
}), _a82 = PartTypeId, _b33) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a82, PartTypeId);
  }
};
var ToolCallId2 = ToolCallId;
var _a83, _b34;
var ToolCallPart = class _ToolCallPart extends (_b34 = TaggedClass3(
  "@effect/ai/AiResponse/ToolCallPart"
)("ToolCallPart", {
  /**
   * The identifier generated by a model when requesting a tool call.
   */
  id: ToolCallId2,
  /**
   * The name of the tool to call.
   */
  name: String$,
  /**
   * The arguments to call the tool with as a JSON-serializable object that
   * matches the tool call input schema.
   */
  params: Unknown
}), _a83 = PartTypeId, _b34) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a83, PartTypeId);
  }
  /**
   * Converts a raw tool call into a `ToolCallPart` by parsing tool call
   * parameters as a JSON string. If your tool call parameters are already
   * parsed, use `ToolCallPart.fromUnknown`.
   *
   * @since 1.0.0
   */
  static fromJson({ id: id3, name, params }) {
    return try_3({
      try() {
        return new _ToolCallPart({
          id: ToolCallId2.make(id3, constDisableValidation),
          name,
          params: JSON.parse(params)
        }, constDisableValidation);
      },
      catch: (cause3) => new AiError({
        module: "AiResponse",
        method: "ToolCall.fromJson",
        description: `Failed to parse parameters from JSON:
${params}`,
        cause: cause3
      })
    });
  }
  /**
   * Converts a raw tool call into a `ToolCallPart` assuming that the tool call
   * parameters have already been parsed. If your tool call parameters have not
   * already been parsed, use `ToolCallPart.fromJson`.
   *
   * @since 1.0.0
   */
  static fromUnknown({ id: id3, name, params }) {
    return new _ToolCallPart({
      id: ToolCallId2.make(id3, constDisableValidation),
      name,
      params
    }, constDisableValidation);
  }
};
var _a84, _b35;
var MetadataPart = class extends (_b35 = TaggedClass3(
  "@effect/ai/AiResponse/MetadataPart"
)("MetadataPart", {
  /**
   * The unique identifier for the response. Each chunk of the response should
   * have the same identifier.
   */
  id: optional(String$),
  /**
   * The model that was used to generate the response.
   */
  model: String$,
  /**
   * The Unix timestamp of when the model began generated the response.
   */
  timestamp: optional(DateFromNumber)
}), _a84 = PartTypeId, _b35) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a84, PartTypeId);
  }
};
var FinishReason = Literal2(
  "stop",
  "length",
  "content-filter",
  "tool-calls",
  "error",
  "other",
  "unknown"
);
var Usage = class extends Class6(
  "@effect/ai/AiResponse/Usage"
)({
  /**
   * The number of tokens sent in the request to the model.
   */
  inputTokens: Number$,
  /**
   * The number of tokens that the model generated for the request.
   */
  outputTokens: Number$,
  /**
   * The total of number of input tokens and output tokens generated by the
   * model.
   */
  totalTokens: Number$,
  /**
   * The number of reasoning tokens that the model used to generate the output
   * for the request.
   */
  reasoningTokens: Number$,
  /**
   * The number of input tokens read from the prompt cache for the request.
   */
  cacheReadInputTokens: Number$,
  /**
   * The number of input tokens written to the prompt cache for the request.
   */
  cacheWriteInputTokens: Number$
}) {
};
var _a85, _b36;
var FinishPart = class extends (_b36 = TaggedClass3(
  "@effect/ai/AiResponse/FinishPart"
)("FinishPart", {
  /**
   * The usage information for the response.
   */
  usage: Usage,
  /**
   * The reason the model finished generating a response.
   */
  reason: FinishReason,
  /**
   * Provider-specific metadata associated with the response.
   */
  providerMetadata: optionalWith(
    Record({
      key: String$,
      value: Record({ key: String$, value: Unknown })
    }),
    { default: () => ({}) }
  )
}), _a85 = PartTypeId, _b36) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a85, PartTypeId);
  }
};
var Part = Union2(
  TextPart,
  ReasoningPart,
  RedactedReasoningPart,
  ToolCallPart,
  MetadataPart,
  FinishPart
);
var isStructured = (u) => hasProperty(u, StructuredResponseTypeId);
var hasToolCallResults = (u) => hasProperty(u, WithToolCallResultsTypeId);
var empty35 = new AiResponse(
  { parts: [] },
  constDisableValidation
);
var merge11 = dual(2, (self, other) => {
  const newParts = mergeParts(self, other);
  if (hasToolCallResults(self) && hasToolCallResults(other)) {
    return new WithToolCallResults({
      results: new Map([...self.results, ...other.results]),
      encodedResults: new Map([...self.encodedResults, ...other.encodedResults]),
      parts: newParts
    }, constDisableValidation);
  } else if (hasToolCallResults(self)) {
    return new WithToolCallResults({
      results: self.results,
      encodedResults: self.encodedResults,
      parts: newParts
    }, constDisableValidation);
  } else if (hasToolCallResults(other)) {
    return new WithToolCallResults({
      results: other.results,
      encodedResults: other.encodedResults,
      parts: newParts
    }, constDisableValidation);
  } else if (isStructured(self) && isStructured(other)) {
    return new WithStructuredOutput({
      id: self.id,
      name: self.name,
      value: other.value,
      parts: newParts
    }, constDisableValidation);
  } else if (isStructured(self)) {
    return new WithStructuredOutput({
      id: self.id,
      name: self.name,
      value: self.value,
      parts: newParts
    }, constDisableValidation);
  } else if (isStructured(other)) {
    return new WithStructuredOutput({
      id: other.id,
      name: other.name,
      value: other.value,
      parts: newParts
    }, constDisableValidation);
  }
  return new AiResponse({ parts: newParts }, constDisableValidation);
});
var mergeParts = (self, other) => {
  if (other.parts.length === 0) {
    return self.parts;
  }
  if (self.parts.length === 0) {
    return other.parts;
  }
  const lastPart = self.parts[self.parts.length - 1];
  const newParts = [];
  let text = lastPart._tag === "TextPart" ? lastPart.text : "";
  for (const part of other.parts) {
    if (part._tag === "TextPart") {
      text += part.text;
    }
  }
  if (text.length > 0) {
    newParts.push(new TextPart({ text }, constDisableValidation));
  }
  return newParts.length === 0 ? self.parts : [...self.parts.slice(0, self.parts.length - 1), ...newParts];
};
var withToolCallsJson = dual(2, (self, toolCalls) => forEach10(toolCalls, (toolCall) => ToolCallPart.fromJson(toolCall)).pipe(
  map18(
    (parts2) => new AiResponse({
      parts: [...self.parts, ...parts2]
    }, constDisableValidation)
  )
));

// ../../packages/ai/src/core/AiInput.ts
var TypeId24 = Symbol.for("@effect/ai/AiInput");
var _a86, _b37;
var AiInput = class extends (_b37 = Class6(
  "@effect/ai/AiInput"
)({
  messages: Array$(suspend13(() => Message))
}), _a86 = TypeId24, _b37) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a86, TypeId24);
  }
};
var FromJson2 = parseJson(AiInput);
var MessageTypeId = Symbol.for("@effect/ai/AiInput/Message");
var _a87, _b38;
var UserMessage = class extends (_b38 = TaggedClass3(
  "@effect/ai/AiInput/Message/UserMessage"
)("UserMessage", {
  parts: Array$(suspend13(() => UserMessagePart)),
  userName: optional(String$)
}), _a87 = MessageTypeId, _b38) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a87, MessageTypeId);
  }
};
var _a88, _b39;
var AssistantMessage = class extends (_b39 = TaggedClass3(
  "@effect/ai/AiInput/Message/AssistantMessage"
)("AssistantMessage", {
  parts: Array$(suspend13(() => AssistantMessagePart))
}), _a88 = MessageTypeId, _b39) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a88, MessageTypeId);
  }
};
var _a89, _b40;
var ToolMessage = class extends (_b40 = TaggedClass3(
  "@effect/ai/AiInput/Message/ToolMessage"
)("ToolMessage", {
  parts: Array$(suspend13(() => ToolMessagePart))
}), _a89 = MessageTypeId, _b40) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a89, MessageTypeId);
  }
};
var Message = Union2(
  UserMessage,
  AssistantMessage,
  ToolMessage
);
var PartTypeId2 = Symbol.for("@effect/ai/AiInput/Message/Part");
var _a90, _b41;
var TextPart2 = class extends (_b41 = TaggedClass3(
  "@effect/ai/AiInput/TextPart"
)("TextPart", {
  /**
   * The text content.
   */
  text: String$
}), _a90 = PartTypeId2, _b41) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a90, PartTypeId2);
  }
};
var _a91, _b42;
var ImagePart = class extends (_b42 = TaggedClass3(
  "@effect/ai/AiInput/ImagePart"
)("ImagePart", {
  /**
   * The binary image data.
   */
  data: Uint8ArrayFromBase64,
  /**
   * The optional MIME type for the image.
   */
  mediaType: optional(String$)
}), _a91 = PartTypeId2, _b42) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a91, PartTypeId2);
  }
};
var _a92, _b43;
var ImageUrlPart = class extends (_b43 = TaggedClass3(
  "@effect/ai/AiInput/ImageUrlPart"
)("ImageUrlPart", {
  /**
   * The URL that points to the image.
   */
  url: URL$
}), _a92 = PartTypeId2, _b43) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a92, PartTypeId2);
  }
};
var _a93, _b44;
var FilePart = class extends (_b44 = TaggedClass3(
  "@effect/ai/AiInput/FilePart"
)("FilePart", {
  /**
   * The binary file data.
   */
  data: Uint8ArrayFromBase64,
  /**
   * The optional name of the file.
   */
  name: optional(String$),
  /**
   * The optional MIME type for the image.
   */
  mediaType: optional(String$)
}), _a93 = PartTypeId2, _b44) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a93, PartTypeId2);
  }
};
var _a94, _b45;
var FileUrlPart = class extends (_b45 = TaggedClass3(
  "@effect/ai/AiInput/FileUrlPart"
)("FileUrlPart", {
  /**
   * The URL that points to the file.
   */
  url: URL$
}), _a94 = PartTypeId2, _b45) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a94, PartTypeId2);
  }
};
var _a95, _b46;
var ReasoningPart2 = class extends (_b46 = TaggedClass3(
  "@effect/ai/AiInput/ReasoningPart"
)("ReasoningPart", {
  /**
   * The reasoning text that the model used to return the output.
   */
  reasoningText: String$,
  /**
   * An optional signature which verifies that the reasoning text was generated
   * by the model.
   */
  signature: optional(String$)
}), _a95 = PartTypeId2, _b46) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a95, PartTypeId2);
  }
};
var _a96, _b47;
var RedactedReasoningPart2 = class extends (_b47 = TaggedClass3(
  "@effect/ai/AiInput/RedactedReasoningPart"
)("RedactedReasoningPart", {
  /**
   * The content in the reasoning that was encrypted by the model provider for
   * safety reasons.
   */
  redactedText: String$
}), _a96 = PartTypeId2, _b47) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a96, PartTypeId2);
  }
};
var ToolCallId3 = ToolCallId;
var _a97, _b48;
var ToolCallPart2 = class extends (_b48 = TaggedClass3(
  "@effect/ai/AiInput/ToolCallPart"
)("ToolCallPart", {
  /**
   * The identifier generated by a model when requesting a tool call.
   */
  id: ToolCallId3,
  /**
   * The name of the tool to call.
   */
  name: String$,
  /**
   * The arguments to call the tool with as a JSON-serializable object that
   * matches the tool call input schema.
   */
  params: Unknown
}), _a97 = PartTypeId2, _b48) {
  constructor(props, options) {
    super(props, options);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a97, PartTypeId2);
  }
};
var _a98, _b49;
var ToolCallResultPart = class extends (_b49 = TaggedClass3(
  "@effect/ai/AiInput/ToolCallResultPart"
)("ToolCallResultPart", {
  /**
   * The identifier generated by a model when requesting a tool call.
   */
  id: ToolCallId3,
  /**
   * The result of the tool call as a JSON-serializable object.
   */
  result: Unknown
}), _a98 = PartTypeId2, _b49) {
  constructor() {
    super(...arguments);
    /**
     * @since 1.0.0
     */
    __publicField(this, _a98, PartTypeId2);
  }
};
var UserMessagePart = Union2(
  TextPart2,
  ImagePart,
  ImageUrlPart,
  FilePart,
  FileUrlPart
);
var AssistantMessagePart = Union2(
  TextPart2,
  ReasoningPart2,
  RedactedReasoningPart2,
  ToolCallPart2
);
var ToolMessagePart = ToolCallResultPart;
var is2 = (u) => hasProperty(u, TypeId24);
var isMessage = (u) => hasProperty(u, MessageTypeId);
var isPart = (u) => hasProperty(u, PartTypeId2);
var empty36 = new AiInput({ messages: [] });
var make61 = (input) => {
  if (isString(input)) {
    const textPart = new TextPart2({ text: input });
    const message = new UserMessage({ parts: [textPart] });
    return new AiInput({ messages: [message] });
  }
  if (isMessage(input)) {
    return new AiInput({ messages: [input] });
  }
  if (isIterable(input)) {
    return new AiInput({ messages: Array.from(input) });
  }
  if (is2(input)) {
    return input;
  }
  if (isStructured(input)) {
    const assistantMessages = fromResponse(input).messages;
    const toolPart = new ToolCallResultPart({
      id: input.id,
      result: input.value
    });
    const toolMessage = new ToolMessage({ parts: [toolPart] });
    return new AiInput({ messages: [...assistantMessages, toolMessage] });
  }
  if (hasToolCallResults(input)) {
    const assistantMessages = fromResponse(input).messages;
    const toolParts = [];
    for (const [id3, result] of input.encodedResults) {
      toolParts.push(new ToolCallResultPart({ id: id3, result }));
    }
    const toolMessage = new ToolMessage({ parts: toolParts });
    return new AiInput({ messages: [...assistantMessages, toolMessage] });
  }
  return fromResponse(input);
};
var EXCLUDED_RESPONSE_PARTS = [
  "MetadataPart",
  "ReasoningPart",
  "RedactedReasoningPart",
  "FinishPart"
];
var validResponseParts = (part) => !EXCLUDED_RESPONSE_PARTS.includes(part._tag);
var fromResponse = (response) => {
  if (response.parts.length === 0) {
    return empty36;
  }
  const parts2 = response.parts.filter(validResponseParts).map(
    (part) => part._tag === "TextPart" ? new TextPart2({ text: part.text }) : new ToolCallPart2({
      id: part.id,
      name: part.name,
      params: part.params
    })
  );
  const message = new AssistantMessage({ parts: parts2 });
  return new AiInput({ messages: [message] });
};
var concat4 = dual(2, (self, other) => AiInput.make({
  messages: [...self.messages, ...other.messages]
}));

// ../../packages/ai/src/core/AiTelemetry.ts
var addSpanAttributes = (keyPrefix, transformKey) => (span4, attributes) => {
  for (const [key, value3] of Object.entries(attributes)) {
    if (isNotNullable(value3)) {
      span4.attribute(`${keyPrefix}.${transformKey(key)}`, value3);
    }
  }
};
var addSpanBaseAttributes = addSpanAttributes("gen_ai", camelToSnake);
var addSpanOperationAttributes = addSpanAttributes("gen_ai.operation", camelToSnake);
var addSpanRequestAttributes = addSpanAttributes("gen_ai.request", camelToSnake);
var addSpanResponseAttributes = addSpanAttributes("gen_ai.response", camelToSnake);
var addSpanTokenAttributes = addSpanAttributes("gen_ai.token", camelToSnake);
var addSpanUsageAttributes = addSpanAttributes("gen_ai.usage", camelToSnake);
var addGenAIAnnotations = dual(2, (span4, options) => {
  addSpanBaseAttributes(span4, { system: options.system });
  if (isNotNullable(options.operation)) addSpanOperationAttributes(span4, options.operation);
  if (isNotNullable(options.request)) addSpanRequestAttributes(span4, options.request);
  if (isNotNullable(options.response)) addSpanResponseAttributes(span4, options.response);
  if (isNotNullable(options.token)) addSpanTokenAttributes(span4, options.token);
  if (isNotNullable(options.usage)) addSpanUsageAttributes(span4, options.usage);
});
var CurrentSpanTransformer = class extends Tag2("@effect/ai/AiTelemetry/CurrentSpanTransformer")() {
};

// ../../packages/ai/src/core/AiLanguageModel.ts
var constDisableValidation2 = { disableValidation: true };
var AiLanguageModel = class extends Tag2("@effect/ai/AiLanguageModel")() {
};
var constEmptyMap = /* @__PURE__ */ new Map();
var make62 = fnUntraced2(function* (opts) {
  const parentSpanTransformer = yield* serviceOption2(CurrentSpanTransformer);
  const getSpanTransformer = serviceOption2(CurrentSpanTransformer).pipe(
    map18(orElse(() => parentSpanTransformer))
  );
  const generateText2 = ({ concurrency, toolChoice = "auto", toolkit, ...options }) => useSpan2(
    "AiLanguageModel.generateText",
    { captureStackTrace: false, attributes: { concurrency, toolChoice } },
    fnUntraced2(function* (span4) {
      const prompt = make61(options.prompt);
      const system = fromNullable(options.system);
      const spanTransformer = yield* getSpanTransformer;
      const modelOptions = { prompt, system, tools: [], toolChoice: "none", span: span4 };
      if (isUndefined(toolkit)) {
        const response2 = yield* opts.generateText(modelOptions);
        if (isSome2(spanTransformer)) {
          spanTransformer.value({ ...modelOptions, response: response2 });
        }
        return response2;
      }
      modelOptions.toolChoice = toolChoice;
      const actualToolkit = isEffect2(toolkit) ? yield* toolkit : toolkit;
      for (const tool of actualToolkit.tools) {
        modelOptions.tools.push(convertTool(tool));
      }
      const response = yield* opts.generateText(modelOptions);
      if (isSome2(spanTransformer)) {
        spanTransformer.value({ ...modelOptions, response });
      }
      return yield* resolveParts({ response, toolkit: actualToolkit, concurrency, method: "generateText" });
    }, (effect4, span4) => withParentSpan3(effect4, span4))
  );
  const streamText2 = fnUntraced2(
    function* ({ concurrency, toolChoice = "auto", toolkit, ...options }) {
      const span4 = yield* makeSpanScoped2("AiLanguageModel.streamText", {
        captureStackTrace: false,
        attributes: { concurrency, toolChoice }
      });
      const prompt = make61(options.prompt);
      const system = fromNullable(options.system);
      const modelOptions = { prompt, system, tools: [], toolChoice: "none", span: span4 };
      if (isUndefined(toolkit)) {
        return [opts.streamText(modelOptions), modelOptions];
      }
      modelOptions.toolChoice = toolChoice;
      const actualToolkit = isEffect2(toolkit) ? yield* toolkit : toolkit;
      for (const tool of actualToolkit.tools) {
        modelOptions.tools.push(convertTool(tool));
      }
      return [
        opts.streamText(modelOptions).pipe(
          mapEffect6(
            (response) => resolveParts({ response, toolkit: actualToolkit, concurrency, method: "streamText" }),
            { concurrency: "unbounded" }
          )
        ),
        modelOptions
      ];
    },
    flatMap12(fnUntraced2(function* ([stream4, options]) {
      const spanTransformer = yield* getSpanTransformer;
      if (isNone2(spanTransformer)) {
        return stream4;
      }
      let finalResponse = empty35;
      return stream4.pipe(
        map25((response) => {
          finalResponse = merge11(finalResponse, response);
          return response;
        }),
        ensuring8(sync5(() => {
          spanTransformer.value({ ...options, response: finalResponse });
        }))
      );
    })),
    unwrapScoped5
  );
  const generateObject2 = (options) => {
    const toolCallId = options.toolCallId ? options.toolCallId : "_tag" in options.schema ? options.schema._tag : "identifier" in options.schema ? options.schema.identifier : "generateObject";
    return useSpan2(
      "AiLanguageModel.generateObject",
      {
        captureStackTrace: false,
        attributes: { toolCallId }
      },
      fnUntraced2(function* (span4) {
        const prompt = make61(options.prompt);
        const system = fromNullable(options.system);
        const spanTransformer = yield* getSpanTransformer;
        const decode7 = decodeUnknown3(options.schema);
        const tool = convertStructured(toolCallId, options.schema);
        const toolChoice = { tool: tool.name };
        const modelOptions = { prompt, system, tools: [tool], toolChoice, span: span4 };
        const response = yield* opts.generateText(modelOptions);
        if (isSome2(spanTransformer)) {
          spanTransformer.value({ ...modelOptions, response });
        }
        const toolCallPart = response.parts.find(
          (part) => part._tag === "ToolCallPart" && part.name === toolCallId
        );
        if (isUndefined(toolCallPart)) {
          return yield* new AiError({
            module: "AiLanguageModel",
            method: "generateObject",
            description: `Tool call '${toolCallId}' not found in model response`
          });
        }
        return yield* matchEffect2(decode7(toolCallPart.params), {
          onFailure: (cause3) => new AiError({
            module: "AiLanguageModel",
            method: "generateObject",
            description: `Failed to decode tool call '${toolCallId}' parameters`,
            cause: cause3
          }),
          onSuccess: (output3) => succeed10(
            new WithStructuredOutput({
              parts: response.parts,
              id: toolCallPart.id,
              name: toolCallPart.name,
              value: output3
            }, constDisableValidation2)
          )
        });
      }, (effect4, span4) => withParentSpan3(effect4, span4))
    );
  };
  return AiLanguageModel.of({ generateText: generateText2, streamText: streamText2, generateObject: generateObject2 });
});
var convertTool = (tool) => ({
  name: tool.name,
  description: tool.description ?? getDescription(tool.parametersSchema.ast),
  parameters: makeJsonSchema(tool.parametersSchema.ast),
  structured: false
});
var convertStructured = (name, schema) => ({
  name,
  description: getDescription(schema.ast),
  parameters: makeJsonSchema(schema.ast),
  structured: true
});
var makeJsonSchema = (ast) => {
  const props = getPropertySignatures(ast);
  if (props.length === 0) {
    return {
      type: "object",
      properties: {},
      required: [],
      additionalProperties: false
    };
  }
  const $defs = {};
  const schema = fromAST(ast, {
    definitions: $defs,
    topLevelReferenceStrategy: "skip"
  });
  if (Object.keys($defs).length === 0) return schema;
  schema.$defs = $defs;
  return schema;
};
var getDescription = (ast) => {
  const annotations5 = ast._tag === "Transformation" ? {
    ...ast.to.annotations,
    ...ast.annotations
  } : ast.annotations;
  return DescriptionAnnotationId in annotations5 ? annotations5[DescriptionAnnotationId] : "";
};
var resolveParts = fnUntraced2(function* (options) {
  const toolNames = [];
  const toolParts = options.response.parts.filter(
    (part) => {
      if (part._tag === "ToolCallPart") {
        toolNames.push(part.name);
        return true;
      }
      return false;
    }
  );
  if (toolParts.length === 0) {
    return new WithToolCallResults({
      parts: options.response.parts,
      results: constEmptyMap,
      encodedResults: constEmptyMap
    }, constDisableValidation2);
  }
  yield* annotateCurrentSpan2("toolCalls", toolNames);
  const results = /* @__PURE__ */ new Map();
  const encodedResults = /* @__PURE__ */ new Map();
  const resolve = forEach10(toolParts, (part) => {
    const id3 = part.id;
    const name = part.name;
    const params = part.params;
    const toolCall = options.toolkit.handle(name, params);
    return map18(toolCall, ({ encodedResult, result }) => {
      results.set(id3, result);
      encodedResults.set(id3, encodedResult);
    });
  }, { concurrency: options.concurrency, discard: true });
  yield* resolve;
  return new WithToolCallResults({
    parts: options.response.parts,
    results,
    encodedResults
  }, constDisableValidation2);
});
var generateText = serviceFunctionEffect2(AiLanguageModel, (_) => _.generateText);
var generateObject = serviceFunctionEffect2(AiLanguageModel, (_) => _.generateObject);
var streamText = (options) => unwrap3(AiLanguageModel.pipe(map18((_) => _.streamText(options))));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Brand.js
var Brand_exports = {};
__export(Brand_exports, {
  BrandTypeId: () => BrandTypeId,
  RefinedConstructorsTypeId: () => RefinedConstructorsTypeId,
  all: () => all10,
  error: () => error,
  errors: () => errors,
  nominal: () => nominal,
  refined: () => refined,
  unbranded: () => unbranded
});
var BrandTypeId = /* @__PURE__ */ Symbol.for("effect/Brand");
var RefinedConstructorsTypeId = /* @__PURE__ */ Symbol.for("effect/Brand/Refined");
var error = (message, meta) => [{
  message,
  meta
}];
var errors = (...errors2) => flatten2(errors2);
function refined(...args2) {
  const either8 = args2.length === 2 ? (unbranded2) => args2[0](unbranded2) ? right2(unbranded2) : left2(args2[1](unbranded2)) : (unbranded2) => {
    return match2(args2[0](unbranded2), {
      onNone: () => right2(unbranded2),
      onSome: left2
    });
  };
  return Object.assign((unbranded2) => getOrThrowWith(either8(unbranded2), identity), {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args3) => getRight2(either8(args3)),
    either: either8,
    is: (args3) => isRight2(either8(args3))
  });
}
var nominal = () => {
  return Object.assign((args2) => args2, {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args2) => some2(args2),
    either: (args2) => right2(args2),
    is: (_args) => true
  });
};
var all10 = (...brands) => {
  const either8 = (args2) => {
    let result = right2(args2);
    for (const brand3 of brands) {
      const nextResult = brand3.either(args2);
      if (isLeft2(result) && isLeft2(nextResult)) {
        result = left2([...result.left, ...nextResult.left]);
      } else {
        result = isLeft2(result) ? result : nextResult;
      }
    }
    return result;
  };
  return Object.assign((args2) => match(either8(args2), {
    onLeft: (e) => {
      throw e;
    },
    onRight: identity
  }), {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: (args2) => getRight2(either8(args2)),
    either: either8,
    is: (args2) => isRight2(either8(args2))
  });
};
var unbranded = unsafeCoerce;

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Sink.js
var foldLeftChunks2 = foldLeftChunks;

// ../../packages/ai/src/providers/cloudflare/CloudflareConfig.ts
var _CloudflareConfig = class _CloudflareConfig extends Tag2("@openagentsinc/ai-cloudflare/CloudflareConfig")() {
};
/**
 * @since 1.0.0
 */
__publicField(_CloudflareConfig, "getOrUndefined", map18(
  context3(),
  (context9) => context9.unsafeMap.get(_CloudflareConfig.key)
));
var CloudflareConfig = _CloudflareConfig;
var withAccountId = dual(
  2,
  (self, accountId) => flatMap12(
    CloudflareConfig.getOrUndefined,
    (config2) => provideService3(self, CloudflareConfig, { ...config2, accountId })
  )
);
var withOpenAIEndpoints = dual(
  2,
  (self, useOpenAIEndpoints) => flatMap12(
    CloudflareConfig.getOrUndefined,
    (config2) => provideService3(self, CloudflareConfig, { ...config2, useOpenAIEndpoints })
  )
);

// ../../packages/ai/src/providers/cloudflare/CloudflareClient.ts
var CloudflareClient = class extends Tag2("@openagentsinc/ai-cloudflare/CloudflareClient")() {
};

// ../../packages/ai/src/providers/cloudflare/internal/utilities.ts
var convertToCloudflareMessages = (messages) => {
  const result = [];
  for (const message of messages) {
    switch (message._tag) {
      case "UserMessage": {
        const textContent = message.parts.filter((part) => part._tag === "TextPart").map((part) => part.text).join("");
        result.push({
          role: "user",
          content: textContent || ""
        });
        break;
      }
      case "AssistantMessage": {
        const textContent = message.parts.filter((part) => part._tag === "TextPart").map((part) => part.text).join("");
        if (textContent) {
          result.push({
            role: "assistant",
            content: textContent
          });
        }
        break;
      }
      case "ToolMessage": {
        const textContent = message.parts.filter((part) => part._tag === "TextPart").map((part) => part.text).join("");
        if (textContent) {
          result.push({
            role: "assistant",
            content: textContent
          });
        }
        break;
      }
    }
  }
  return result;
};

// ../../packages/ai/src/providers/cloudflare/CloudflareLanguageModel.ts
var CloudflareLanguageModel = class extends Tag2("@openagentsinc/ai-cloudflare/CloudflareLanguageModel")() {
};
var makeLanguageModel = (options) => gen3(function* () {
  const client = yield* CloudflareClient;
  const streamText2 = (input) => {
    const messages = convertToCloudflareMessages(input.prompt.messages);
    return client.stream({
      model: options.model,
      messages,
      temperature: options.temperature,
      max_tokens: options.maxTokens,
      top_p: options.topP,
      frequency_penalty: options.frequencyPenalty,
      presence_penalty: options.presencePenalty,
      stop: options.stop,
      stream: true
    }).pipe(
      catchAll8(
        (error2) => fail17(
          new AiError({
            module: "CloudflareLanguageModel",
            method: "streamText",
            description: `Cloudflare API Error: ${error2.message}`
          })
        )
      )
    );
  };
  const generateText2 = (input) => {
    const messages = convertToCloudflareMessages(input.prompt.messages);
    return client.complete({
      model: options.model,
      messages,
      temperature: options.temperature,
      max_tokens: options.maxTokens,
      top_p: options.topP,
      frequency_penalty: options.frequencyPenalty,
      presence_penalty: options.presencePenalty,
      stop: options.stop,
      stream: false
    }).pipe(
      catchAll3(
        (error2) => fail10(
          new AiError({
            module: "CloudflareLanguageModel",
            method: "generateText",
            description: `Cloudflare API Error: ${error2.message}`
          })
        )
      )
    );
  };
  return yield* make62({
    generateText: generateText2,
    streamText: streamText2
  });
});
var layer = (options) => effect(CloudflareLanguageModel, makeLanguageModel(options));

// ../../node_modules/.pnpm/effect@3.16.3/node_modules/effect/dist/esm/Cache.js
var Cache_exports = {};
__export(Cache_exports, {
  CacheTypeId: () => CacheTypeId2,
  ConsumerCacheTypeId: () => ConsumerCacheTypeId2,
  make: () => make63,
  makeCacheStats: () => makeCacheStats2,
  makeEntryStats: () => makeEntryStats2,
  makeWith: () => makeWith2
});
var CacheTypeId2 = CacheTypeId;
var ConsumerCacheTypeId2 = ConsumerCacheTypeId;
var make63 = make42;
var makeWith2 = makeWith;
var makeCacheStats2 = makeCacheStats;
var makeEntryStats2 = makeEntryStats;

// ../../packages/nostr/src/services/EventService.ts
var EventService_exports = {};
__export(EventService_exports, {
  EventService: () => EventService,
  EventServiceLive: () => EventServiceLive
});

// ../../packages/nostr/src/core/Errors.ts
var InvalidEventId = class extends Schema_exports.TaggedError()("InvalidEventId", {
  id: Schema_exports.String,
  reason: Schema_exports.String
}) {
};
var InvalidSignature = class extends Schema_exports.TaggedError()("InvalidSignature", {
  eventId: Schema_exports.String,
  publicKey: Schema_exports.String,
  reason: Schema_exports.optional(Schema_exports.String)
}) {
};
var InvalidEventFormat = class extends Schema_exports.TaggedError()("InvalidEventFormat", {
  field: Schema_exports.String,
  value: Schema_exports.Unknown,
  reason: Schema_exports.String
}) {
};
var EventValidationError = class extends Schema_exports.TaggedError()("EventValidationError", {
  eventId: Schema_exports.optional(Schema_exports.String),
  errors: Schema_exports.Array(Schema_exports.String)
}) {
};
var CryptoError = class extends Schema_exports.TaggedError()("CryptoError", {
  operation: Schema_exports.Literal("sign", "verify", "hash", "generateKey"),
  reason: Schema_exports.String
}) {
};
var InvalidPrivateKey = class extends Schema_exports.TaggedError()("InvalidPrivateKey", {
  reason: Schema_exports.String
}) {
};
var InvalidPublicKey = class extends Schema_exports.TaggedError()("InvalidPublicKey", {
  publicKey: Schema_exports.String,
  reason: Schema_exports.String
}) {
};
var ConnectionError = class extends Schema_exports.TaggedError()("ConnectionError", {
  url: Schema_exports.String,
  reason: Schema_exports.String,
  code: Schema_exports.optional(Schema_exports.Union(Schema_exports.Number, Schema_exports.String))
}) {
};
var ConnectionClosed = class extends Schema_exports.TaggedError()("ConnectionClosed", {
  url: Schema_exports.String,
  reason: Schema_exports.optional(Schema_exports.String)
}) {
};
var MessageSendError = class extends Schema_exports.TaggedError()("MessageSendError", {
  url: Schema_exports.String,
  message: Schema_exports.String,
  reason: Schema_exports.String
}) {
};
var SubscriptionError = class extends Schema_exports.TaggedError()("SubscriptionError", {
  subscriptionId: Schema_exports.String,
  reason: Schema_exports.String
}) {
};
var SubscriptionClosed = class extends Schema_exports.TaggedError()("SubscriptionClosed", {
  subscriptionId: Schema_exports.String,
  reason: Schema_exports.String
}) {
};
var RelayError = class extends Schema_exports.TaggedError()("RelayError", {
  url: Schema_exports.String,
  code: Schema_exports.Literal("duplicate", "pow", "blocked", "rate-limited", "invalid", "restricted", "error"),
  message: Schema_exports.String
}) {
};
var RelayNotice = class extends Schema_exports.TaggedError()("RelayNotice", {
  url: Schema_exports.String,
  message: Schema_exports.String
}) {
};
var TimeoutError = class extends Schema_exports.TaggedError()("TimeoutError", {
  operation: Schema_exports.String,
  timeoutMs: Schema_exports.Number
}) {
};
var Nip06Error = class extends Schema_exports.TaggedError()("Nip06Error", {
  operation: Schema_exports.Literal("generateMnemonic", "validateMnemonic", "deriveKey", "encodeKey", "decodeKey"),
  reason: Schema_exports.String
}) {
};
var InvalidMnemonic = class extends Schema_exports.TaggedError()("InvalidMnemonic", {
  mnemonic: Schema_exports.String,
  reason: Schema_exports.String
}) {
};
var KeyDerivationError = class extends Schema_exports.TaggedError()("KeyDerivationError", {
  path: Schema_exports.String,
  reason: Schema_exports.String
}) {
};

// ../../packages/nostr/src/core/Schema.ts
var EventId = pipe(
  Schema_exports.String,
  Schema_exports.pattern(/^[0-9a-f]{64}$/),
  Schema_exports.brand("EventId"),
  Schema_exports.annotations({
    title: "EventId",
    description: "32-bytes lowercase hex-encoded sha256"
  })
);
var PublicKey = pipe(
  Schema_exports.String,
  Schema_exports.pattern(/^[0-9a-f]{64}$/),
  Schema_exports.brand("PublicKey"),
  Schema_exports.annotations({
    title: "PublicKey",
    description: "32-bytes lowercase hex-encoded public key"
  })
);
var PrivateKey = pipe(
  Schema_exports.String,
  Schema_exports.pattern(/^[0-9a-f]{64}$/),
  Schema_exports.brand("PrivateKey"),
  Schema_exports.annotations({
    title: "PrivateKey",
    description: "32-bytes lowercase hex-encoded private key"
  })
);
var Signature = pipe(
  Schema_exports.String,
  Schema_exports.pattern(/^[0-9a-f]{128}$/),
  Schema_exports.brand("Signature"),
  Schema_exports.annotations({
    title: "Signature",
    description: "64-bytes lowercase hex-encoded schnorr signature"
  })
);
var UnixTimestamp = pipe(
  Schema_exports.Number,
  Schema_exports.int(),
  Schema_exports.positive(),
  Schema_exports.annotations({
    title: "UnixTimestamp",
    description: "Unix timestamp in seconds"
  })
);
var EventKind = pipe(
  Schema_exports.Number,
  Schema_exports.int(),
  Schema_exports.between(0, 65535),
  Schema_exports.annotations({
    title: "EventKind",
    description: "Event kind (0-65535)"
  })
);
var Tag4 = pipe(
  Schema_exports.Array(Schema_exports.String),
  Schema_exports.minItems(1),
  Schema_exports.annotations({
    title: "Tag",
    description: "Event tag - array of strings with tag name as first element"
  })
);
var NostrEvent = class extends Schema_exports.Class("NostrEvent")({
  id: EventId,
  pubkey: PublicKey,
  created_at: UnixTimestamp,
  kind: EventKind,
  tags: Schema_exports.Array(Tag4),
  content: Schema_exports.String,
  sig: Signature
}, {
  title: "NostrEvent",
  description: "Nostr event as defined in NIP-01"
}) {
};
var UnsignedEvent = class extends Schema_exports.Class("UnsignedEvent")({
  pubkey: PublicKey,
  created_at: UnixTimestamp,
  kind: EventKind,
  tags: Schema_exports.Array(Tag4),
  content: Schema_exports.String
}, {
  title: "UnsignedEvent",
  description: "Nostr event before ID calculation and signing"
}) {
};
var EventParams = class extends Schema_exports.Class("EventParams")({
  kind: EventKind,
  tags: Schema_exports.Array(Tag4),
  content: Schema_exports.String
}, {
  title: "EventParams",
  description: "Parameters for creating a new event"
}) {
};
var Filter = class extends Schema_exports.Class("Filter")({
  ids: Schema_exports.optional(Schema_exports.Array(EventId)),
  authors: Schema_exports.optional(Schema_exports.Array(PublicKey)),
  kinds: Schema_exports.optional(Schema_exports.Array(EventKind)),
  since: Schema_exports.optional(UnixTimestamp),
  until: Schema_exports.optional(UnixTimestamp),
  limit: Schema_exports.optional(pipe(Schema_exports.Number, Schema_exports.int(), Schema_exports.positive())),
  // Tag filters - single letter tags
  "#e": Schema_exports.optional(Schema_exports.Array(EventId)),
  "#p": Schema_exports.optional(Schema_exports.Array(PublicKey)),
  "#a": Schema_exports.optional(Schema_exports.Array(Schema_exports.String)),
  "#d": Schema_exports.optional(Schema_exports.Array(Schema_exports.String))
}, {
  title: "Filter",
  description: "Filter for querying events as defined in NIP-01"
}) {
};
var SubscriptionId = pipe(
  Schema_exports.String,
  Schema_exports.minLength(1),
  Schema_exports.maxLength(64),
  Schema_exports.brand("SubscriptionId"),
  Schema_exports.annotations({
    title: "SubscriptionId",
    description: "Arbitrary, non-empty string of max length 64 chars"
  })
);
var EventMessage = Schema_exports.Tuple(
  Schema_exports.Literal("EVENT"),
  NostrEvent
);
var ReqMessage = Schema_exports.Array(Schema_exports.Unknown).pipe(
  Schema_exports.filter((arr) => {
    if (arr.length < 2) return false;
    if (arr[0] !== "REQ") return false;
    return true;
  })
);
var CloseMessage = Schema_exports.Tuple(
  Schema_exports.Literal("CLOSE"),
  SubscriptionId
);
var ClientMessage = Schema_exports.Union(
  EventMessage,
  ReqMessage,
  CloseMessage
);
var RelayEventMessage = Schema_exports.Tuple(
  Schema_exports.Literal("EVENT"),
  SubscriptionId,
  NostrEvent
);
var OkMessage = Schema_exports.Tuple(
  Schema_exports.Literal("OK"),
  EventId,
  Schema_exports.Boolean,
  Schema_exports.String
);
var EoseMessage = Schema_exports.Tuple(
  Schema_exports.Literal("EOSE"),
  SubscriptionId
);
var ClosedMessage = Schema_exports.Tuple(
  Schema_exports.Literal("CLOSED"),
  SubscriptionId,
  Schema_exports.String
);
var NoticeMessage = Schema_exports.Tuple(
  Schema_exports.Literal("NOTICE"),
  Schema_exports.String
);
var RelayMessage = Schema_exports.Union(
  RelayEventMessage,
  OkMessage,
  EoseMessage,
  ClosedMessage,
  NoticeMessage
);
var OkPrefix = Schema_exports.Literal(
  "duplicate",
  "pow",
  "blocked",
  "rate-limited",
  "invalid",
  "restricted",
  "error"
);
var Mnemonic = pipe(
  Schema_exports.String,
  Schema_exports.filter((str) => {
    const words = str.trim().split(/\s+/);
    return [12, 15, 18, 21, 24].includes(words.length);
  }),
  Schema_exports.brand("Mnemonic"),
  Schema_exports.annotations({
    title: "Mnemonic",
    description: "BIP39 mnemonic phrase (12, 15, 18, 21, or 24 words)"
  })
);
var Nsec = pipe(
  Schema_exports.String,
  Schema_exports.pattern(/^nsec1[ac-hj-np-z02-9]{58}$/),
  Schema_exports.brand("Nsec"),
  Schema_exports.annotations({
    title: "Nsec",
    description: "Bech32-encoded private key (nsec1...)"
  })
);
var Npub = pipe(
  Schema_exports.String,
  Schema_exports.pattern(/^npub1[ac-hj-np-z02-9]{58}$/),
  Schema_exports.brand("Npub"),
  Schema_exports.annotations({
    title: "Npub",
    description: "Bech32-encoded public key (npub1...)"
  })
);
var DerivationPath = pipe(
  Schema_exports.String,
  Schema_exports.pattern(/^m\/44'\/1237'\/\d+'\/0\/0$/),
  Schema_exports.brand("DerivationPath"),
  Schema_exports.annotations({
    title: "DerivationPath",
    description: "BIP32 derivation path for Nostr keys (m/44'/1237'/account'/0/0)"
  })
);
var KeyDerivationResult = class extends Schema_exports.Class("KeyDerivationResult")({
  privateKey: PrivateKey,
  publicKey: PublicKey,
  nsec: Nsec,
  npub: Npub
}, {
  title: "KeyDerivationResult",
  description: "Complete key derivation result from NIP-06"
}) {
};

// ../../packages/nostr/src/services/CryptoService.ts
var CryptoService_exports = {};
__export(CryptoService_exports, {
  CryptoService: () => CryptoService,
  CryptoServiceLive: () => CryptoServiceLive
});

// ../../node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/_assert.js
function anumber(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber(h.outputLen);
  anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min5 = instance.outputLen;
  if (out.length < min5) {
    throw new Error("digestInto() expects output buffer of length at least " + min5);
  }
}

// ../../node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/crypto.js
var crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// ../../node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/utils.js
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift2) {
  return word << 32 - shift2 | word >>> shift2;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("utf8ToBytes expected string, got " + typeof str);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum3 = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes(a);
    sum3 += a.length;
  }
  const res = new Uint8Array(sum3);
  for (let i = 0, pad3 = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad3);
    pad3 += a.length;
  }
  return res;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto && typeof crypto.getRandomValues === "function") {
    return crypto.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto && typeof crypto.randomBytes === "function") {
    return crypto.randomBytes(bytesLength);
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// ../../node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value3, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value3, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value3 >> _32n2 & _u32_max);
  const wl = Number(value3 & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
}
function Chi(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists(this);
    const { view, buffer: buffer3, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take10 = Math.min(blockLen - this.pos, len - pos);
      if (take10 === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer3.set(data.subarray(pos, pos + take10), this.pos);
      this.pos += take10;
      pos += take10;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    this.finished = true;
    const { buffer: buffer3, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer3[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer3[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE3);
  }
  digest() {
    const { buffer: buffer3, outputLen } = this;
    this.digestInto(buffer3);
    const res = buffer3.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer3, length: length5, finished, destroyed, pos } = this;
    to.length = length5;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length5 % blockLen)
      to.buffer.set(buffer3);
    return to;
  }
};

// ../../node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

// ../../node_modules/.pnpm/@noble+hashes@1.7.1/node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash4, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash(hash4);
    const key = toBytes(_key);
    this.iHash = hash4.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad3 = new Uint8Array(blockLen);
    pad3.set(key.length > blockLen ? hash4.create().update(key).digest() : key);
    for (let i = 0; i < pad3.length; i++)
      pad3[i] ^= 54;
    this.iHash.update(pad3);
    this.oHash = hash4.create();
    for (let i = 0; i < pad3.length; i++)
      pad3[i] ^= 54 ^ 92;
    this.oHash.update(pad3);
    pad3.fill(0);
  }
  update(buf) {
    aexists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists(this);
    abytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash4, key, message) => new HMAC(hash4, key).update(message).digest();
hmac.create = (hash4, key) => new HMAC(hash4, key);

// ../../node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  aInRange: () => aInRange,
  abool: () => abool,
  abytes: () => abytes2,
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex2,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes,
  hexToNumber: () => hexToNumber,
  inRange: () => inRange,
  isBytes: () => isBytes2,
  memoized: () => memoized,
  notImplemented: () => notImplemented,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes2,
  validateObject: () => validateObject
});
var _0n = /* @__PURE__ */ BigInt(0);
var _1n = /* @__PURE__ */ BigInt(1);
var _2n = /* @__PURE__ */ BigInt(2);
function isBytes2(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes2(item) {
  if (!isBytes2(item))
    throw new Error("Uint8Array expected");
}
function abool(title, value3) {
  if (typeof value3 !== "boolean")
    throw new Error(title + " boolean expected, got " + value3);
}
var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex2(bytes3) {
  abytes2(bytes3);
  let hex = "";
  for (let i = 0; i < bytes3.length; i++) {
    hex += hexes[bytes3[i]];
  }
  return hex;
}
function numberToHexUnpadded(num2) {
  const hex = num2.toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n : BigInt("0x" + hex);
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array6 = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char2 = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char2 + '" at index ' + hi);
    }
    array6[ai] = n1 * 16 + n2;
  }
  return array6;
}
function bytesToNumberBE(bytes3) {
  return hexToNumber(bytesToHex2(bytes3));
}
function bytesToNumberLE(bytes3) {
  abytes2(bytes3);
  return hexToNumber(bytesToHex2(Uint8Array.from(bytes3).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
    }
  } else if (isBytes2(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
function concatBytes2(...arrays) {
  let sum3 = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes2(a);
    sum3 += a.length;
  }
  const res = new Uint8Array(sum3);
  for (let i = 0, pad3 = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad3);
    pad3 += a.length;
  }
  return res;
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff8 = 0;
  for (let i = 0; i < a.length; i++)
    diff8 |= a[i] ^ b[i];
  return diff8 === 0;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
function inRange(n, min5, max7) {
  return isPosBig(n) && isPosBig(min5) && isPosBig(max7) && min5 <= n && n < max7;
}
function aInRange(title, n, min5, max7) {
  if (!inRange(n, min5, max7))
    throw new Error("expected valid " + title + ": " + min5 + " <= n < " + max7 + ", got " + n);
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n;
}
function bitSet(n, pos, value3) {
  return n | (value3 ? _1n : _0n) << BigInt(pos);
}
var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen5 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen5())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes2(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object2) => object2.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object2, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error("invalid validator function");
    const val = object2[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object2)) {
      throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object2;
}
var notImplemented = () => {
  throw new Error("not implemented");
};
function memoized(fn2) {
  const map31 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args2) => {
    const val = map31.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn2(arg, ...args2);
    map31.set(arg, computed);
    return computed;
  };
}

// ../../node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = /* @__PURE__ */ BigInt(2);
var _3n = /* @__PURE__ */ BigInt(3);
var _4n = /* @__PURE__ */ BigInt(4);
var _5n = /* @__PURE__ */ BigInt(5);
var _8n = /* @__PURE__ */ BigInt(8);
var _9n = /* @__PURE__ */ BigInt(9);
var _16n = /* @__PURE__ */ BigInt(16);
function mod(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow(num2, power, modulo) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (modulo <= _0n2)
    throw new Error("invalid modulus");
  if (modulo === _1n2)
    return _0n2;
  let res = _1n2;
  while (power > _0n2) {
    if (power & _1n2)
      res = res * num2 % modulo;
    num2 = num2 * num2 % modulo;
    power >>= _1n2;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert2(number7, modulo) {
  if (number7 === _0n2)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n2)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod(number7, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd3 = b;
  if (gcd3 !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n2) / _2n2;
  let Q, S, Z;
  for (Q = P - _1n2, S = 0; Q % _2n2 === _0n2; Q /= _2n2, S++)
    ;
  for (Z = _2n2; Z < P && pow(Z, legendreC, P) !== P - _1n2; Z++) {
    if (Z > 1e3)
      throw new Error("Cannot find square root: likely non-prime P");
  }
  if (S === 1) {
    const p1div4 = (P + _1n2) / _4n;
    return function tonelliFast(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n2) / _2n2;
  return function tonelliSlow(Fp, n) {
    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
    let x = Fp.pow(n, Q1div2);
    let b = Fp.pow(n, Q);
    while (!Fp.eql(b, Fp.ONE)) {
      if (Fp.eql(b, Fp.ZERO))
        return Fp.ZERO;
      let m = 1;
      for (let t2 = Fp.sqr(b); m < r; m++) {
        if (Fp.eql(t2, Fp.ONE))
          break;
        t2 = Fp.sqr(t2);
      }
      const ge = Fp.pow(g, _1n2 << BigInt(r - m - 1));
      g = Fp.sqr(ge);
      x = Fp.mul(x, ge);
      b = Fp.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n2) / _4n;
    return function sqrt3mod42(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod82(Fp, n) {
      const n2 = Fp.mul(n, _2n2);
      const v = Fp.pow(n2, c1);
      const nv = Fp.mul(n, v);
      const i = Fp.mul(Fp.mul(nv, _2n2), v);
      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map31, val) => {
    map31[val] = "function";
    return map31;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f, num2, power) {
  if (power < _0n2)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n2)
    return f.ONE;
  if (power === _1n2)
    return num2;
  let p = f.ONE;
  let d = num2;
  while (power > _0n2) {
    if (power & _1n2)
      p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num2, i) => {
    if (f.is0(num2))
      return acc;
    tmp[i] = acc;
    return f.mul(acc, num2);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num2, i) => {
    if (f.is0(num2))
      return acc;
    tmp[i] = f.mul(acc, tmp[i]);
    return f.mul(acc, num2);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen3, isLE3 = false, redef = {}) {
  if (ORDER <= _0n2)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen3);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f = Object.freeze({
    ORDER,
    isLE: isLE3,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    create: (num2) => mod(num2, ORDER),
    isValid: (num2) => {
      if (typeof num2 !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num2);
      return _0n2 <= num2 && num2 < ORDER;
    },
    is0: (num2) => num2 === _0n2,
    isOdd: (num2) => (num2 & _1n2) === _1n2,
    neg: (num2) => mod(-num2, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num2) => mod(num2 * num2, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num2, power) => FpPow(f, num2, power),
    div: (lhs, rhs) => mod(lhs * invert2(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num2) => num2 * num2,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num2) => invert2(num2, ORDER),
    sqrt: redef.sqrt || ((n) => {
      if (!sqrtP)
        sqrtP = FpSqrt(ORDER);
      return sqrtP(f, n);
    }),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num2) => isLE3 ? numberToBytesLE(num2, BYTES) : numberToBytesBE(num2, BYTES),
    fromBytes: (bytes3) => {
      if (bytes3.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes3.length);
      return isLE3 ? bytesToNumberLE(bytes3) : bytesToNumberBE(bytes3);
    }
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length5 = getFieldBytesLength(fieldOrder);
  return length5 + Math.ceil(length5 / 2);
}
function mapHashToField(key, fieldOrder, isLE3 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num2 = isLE3 ? bytesToNumberLE(key) : bytesToNumberBE(key);
  const reduced = mod(num2, fieldOrder - _1n2) + _1n2;
  return isLE3 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// ../../node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function validateW(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts(W, bits) {
  validateW(W, bits);
  const windows = Math.ceil(bits / W) + 1;
  const windowSize = 2 ** (W - 1);
  return { windows, windowSize };
}
function validateMSMPoints(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i);
  });
}
function validateMSMScalars(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i);
  });
}
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function getW(P) {
  return pointWindowSizes.get(P) || 1;
}
function wNAF(c, bits) {
  return {
    constTimeNegate,
    hasPrecomputes(elm) {
      return getW(elm) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(elm, n, p = c.ZERO) {
      let d = elm;
      while (n > _0n3) {
        if (n & _1n3)
          p = p.add(d);
        d = d.double();
        n >>= _1n3;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = calcWOpts(W, bits);
      const points = [];
      let p = elm;
      let base = p;
      for (let window = 0; window < windows; window++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = calcWOpts(W, bits);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window = 0; window < windows; window++) {
        const offset = window * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n3;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
      const { windows, windowSize } = calcWOpts(W, bits);
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window = 0; window < windows; window++) {
        const offset = window * windowSize;
        if (n === _0n3)
          break;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n3;
        }
        if (wbits === 0)
          continue;
        let curr = precomputes[offset + Math.abs(wbits) - 1];
        if (wbits < 0)
          curr = curr.negate();
        acc = acc.add(curr);
      }
      return acc;
    },
    getPrecomputes(W, P, transform4) {
      let comp = pointPrecomputes.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1)
          pointPrecomputes.set(P, transform4(comp));
      }
      return comp;
    },
    wNAFCached(P, n, transform4) {
      const W = getW(P);
      return this.wNAF(W, this.getPrecomputes(W, P, transform4), n);
    },
    wNAFCachedUnsafe(P, n, transform4, prev) {
      const W = getW(P);
      if (W === 1)
        return this.unsafeLadder(P, n, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform4), n, prev);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P, W) {
      validateW(W, bits);
      pointWindowSizes.set(P, W);
      pointPrecomputes.delete(P);
    }
  };
}
function pippenger(c, fieldN, points, scalars) {
  validateMSMPoints(points, c);
  validateMSMScalars(scalars, fieldN);
  if (points.length !== scalars.length)
    throw new Error("arrays of points and scalars must have equal length");
  const zero3 = c.ZERO;
  const wbits = bitLen(BigInt(points.length));
  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1;
  const MASK3 = (1 << windowSize) - 1;
  const buckets = new Array(MASK3 + 1).fill(zero3);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum3 = zero3;
  for (let i = lastBits; i >= 0; i -= windowSize) {
    buckets.fill(zero3);
    for (let j = 0; j < scalars.length; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i) & BigInt(MASK3));
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero3;
    for (let j = buckets.length - 1, sumI = zero3; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum3 = sum3.add(resI);
    if (i !== 0)
      for (let j = 0; j < windowSize; j++)
        sum3 = sum3.double();
  }
  return sum3;
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// ../../node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validateSigVerOpts(opts) {
  if (opts.lowS !== void 0)
    abool("lowS", opts.lowS);
  if (opts.prehash !== void 0)
    abool("prehash", opts.prehash);
}
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp, a } = opts;
  if (endo) {
    if (!Fp.eql(a, Fp.ZERO)) {
      throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DERErr = class extends Error {
  constructor(m = "") {
    super(m);
  }
};
var DER = {
  // asn.1 DER encoding utils
  Err: DERErr,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag3, data) => {
      const { Err: E } = DER;
      if (tag3 < 0 || tag3 > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded(dataLen);
      if (len.length / 2 & 128)
        throw new E("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : "";
      const t = numberToHexUnpadded(tag3);
      return t + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag3, data) {
      const { Err: E } = DER;
      let pos = 0;
      if (tag3 < 0 || tag3 > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag3)
        throw new E("tlv.decode: wrong tlv");
      const first2 = data[pos++];
      const isLong = !!(first2 & 128);
      let length5 = 0;
      if (!isLong)
        length5 = first2;
      else {
        const lenLen = first2 & 127;
        if (!lenLen)
          throw new E("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E("tlv.decode(long): zero leftmost byte");
        for (const b of lengthBytes)
          length5 = length5 << 8 | b;
        pos += lenLen;
        if (length5 < 128)
          throw new E("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length5);
      if (v.length !== length5)
        throw new E("tlv.decode: wrong value length");
      return { v, l: data.subarray(pos + length5) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num2) {
      const { Err: E } = DER;
      if (num2 < _0n4)
        throw new E("integer: negative integers are not allowed");
      let hex = numberToHexUnpadded(num2);
      if (Number.parseInt(hex[0], 16) & 8)
        hex = "00" + hex;
      if (hex.length & 1)
        throw new E("unexpected DER parsing assertion: unpadded hex");
      return hex;
    },
    decode(data) {
      const { Err: E } = DER;
      if (data[0] & 128)
        throw new E("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E("invalid signature integer: unnecessary leading zero");
      return b2n(data);
    }
  },
  toSig(hex) {
    const { Err: E, _int: int3, _tlv: tlv } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    abytes2(data);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    return { r: int3.decode(rBytes), s: int3.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int3 } = DER;
    const rs = tlv.encode(2, int3.encode(sig.r));
    const ss = tlv.encode(2, int3.encode(sig.s));
    const seq2 = rs + ss;
    return tlv.encode(48, seq2);
  }
};
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n3 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp } = CURVE;
  const Fn = Field(CURVE.n, CURVE.nBitLength);
  const toBytes5 = CURVE.toBytes || ((_c6, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes3) => {
    const tail2 = bytes3.subarray(1);
    const x = Fp.fromBytes(tail2.subarray(0, Fp.BYTES));
    const y = Fp.fromBytes(tail2.subarray(Fp.BYTES, 2 * Fp.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp.sqr(x);
    const x3 = Fp.mul(x2, x);
    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
  }
  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num2) {
    return inRange(num2, _1n4, CURVE.n);
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes2(key))
        key = bytesToHex2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("invalid private key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num2;
    try {
      num2 = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error2) {
      throw new Error("invalid private key, expected hex or " + nByteLength + " bytes, got " + typeof key);
    }
    if (wrapPrivateKey)
      num2 = mod(num2, N);
    aInRange("private key", num2, _1n4, N);
    return num2;
  }
  function assertPrjPoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized((p, iz) => {
    const { px: x, py: y, pz: z } = p;
    if (Fp.eql(z, Fp.ONE))
      return { x, y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp.ONE : Fp.inv(z);
    const ax = Fp.mul(x, iz);
    const ay = Fp.mul(y, iz);
    const zz = Fp.mul(z, iz);
    if (is0)
      return { x: Fp.ZERO, y: Fp.ZERO };
    if (!Fp.eql(zz, Fp.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p) => {
    if (p.is0()) {
      if (CURVE.allowInfinityPoint && !Fp.is0(p.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p.toAffine();
    if (!Fp.isValid(x) || !Fp.isValid(y))
      throw new Error("bad point: x or y not FE");
    const left3 = Fp.sqr(y);
    const right3 = weierstrassEquation(x);
    if (!Fp.eql(left3, right3))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class Point3 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp.isValid(pz))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point3)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp.eql(i, Fp.ZERO);
      if (is0(x) && is0(y))
        return Point3.ZERO;
      return new Point3(x, y, Fp.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point3.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex) {
      const P = Point3.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // Multiscalar Multiplication
    static msm(points, scalars) {
      return pippenger(Point3, Fn, points, scalars);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp.isOdd)
        return !Fp.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point3(this.px, Fp.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      let t0 = Fp.mul(X1, X1);
      let t1 = Fp.mul(Y1, Y1);
      let t2 = Fp.mul(Z1, Z1);
      let t3 = Fp.mul(X1, Y1);
      t3 = Fp.add(t3, t3);
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a, Z3);
      Y3 = Fp.mul(b3, t2);
      Y3 = Fp.add(X3, Y3);
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t3, X3);
      Z3 = Fp.mul(b3, Z3);
      t2 = Fp.mul(a, t2);
      t3 = Fp.sub(t0, t2);
      t3 = Fp.mul(a, t3);
      t3 = Fp.add(t3, Z3);
      Z3 = Fp.add(t0, t0);
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t2);
      t0 = Fp.mul(t0, t3);
      Y3 = Fp.add(Y3, t0);
      t2 = Fp.mul(Y1, Z1);
      t2 = Fp.add(t2, t2);
      t0 = Fp.mul(t2, t3);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t2, t1);
      Z3 = Fp.add(Z3, Z3);
      Z3 = Fp.add(Z3, Z3);
      return new Point3(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      const a = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n2);
      let t0 = Fp.mul(X1, X2);
      let t1 = Fp.mul(Y1, Y2);
      let t2 = Fp.mul(Z1, Z2);
      let t3 = Fp.add(X1, Y1);
      let t4 = Fp.add(X2, Y2);
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t1);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X1, Z1);
      let t5 = Fp.add(X2, Z2);
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t2);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2);
      t5 = Fp.mul(t5, X3);
      X3 = Fp.add(t1, t2);
      t5 = Fp.sub(t5, X3);
      Z3 = Fp.mul(a, t4);
      X3 = Fp.mul(b3, t2);
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t2 = Fp.mul(a, t2);
      t4 = Fp.mul(b3, t4);
      t1 = Fp.add(t1, t2);
      t2 = Fp.sub(t0, t2);
      t2 = Fp.mul(a, t2);
      t4 = Fp.add(t4, t2);
      t0 = Fp.mul(t1, t4);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t5, t4);
      X3 = Fp.mul(t3, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t3, t1);
      Z3 = Fp.mul(t5, Z3);
      Z3 = Fp.add(Z3, t0);
      return new Point3(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, n, Point3.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo, n: N } = CURVE;
      aInRange("scalar", sc, _0n4, N);
      const I = Point3.ZERO;
      if (sc === _0n4)
        return I;
      if (this.is0() || sc === _1n4)
        return this;
      if (!endo || wnaf.hasPrecomputes(this))
        return wnaf.wNAFCachedUnsafe(this, sc, Point3.normalizeZ);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n4 || k2 > _0n4) {
        if (k1 & _1n4)
          k1p = k1p.add(d);
        if (k2 & _1n4)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n4;
        k2 >>= _1n4;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point3(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo, n: N } = CURVE;
      aInRange("scalar", scalar, _1n4, N);
      let point, fake;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point3(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(scalar);
        point = p;
        fake = f;
      }
      return Point3.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point3.BASE;
      const mul3 = (P, a2) => a2 === _0n4 || a2 === _1n4 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum3 = mul3(this, a).add(mul3(Q, b));
      return sum3.is0() ? void 0 : sum3;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point3, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point3, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes5(Point3, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool("isCompressed", isCompressed);
      return bytesToHex2(this.toRawBytes(isCompressed));
    }
  }
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp.ONE);
  Point3.ZERO = new Point3(Fp.ZERO, Fp.ONE, Fp.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point3, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point3,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp.BYTES + 1;
  const uncompressedLen = 2 * Fp.BYTES + 1;
  function modN2(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert2(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point3, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c6, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp.toBytes(a.x);
      const cat = concatBytes2;
      abool("isCompressed", isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
      }
    },
    fromBytes(bytes3) {
      const len = bytes3.length;
      const head8 = bytes3[0];
      const tail2 = bytes3.subarray(1);
      if (len === compressedLen && (head8 === 2 || head8 === 3)) {
        const x = bytesToNumberBE(tail2);
        if (!inRange(x, _1n4, Fp.ORDER))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y;
        try {
          y = Fp.sqrt(y2);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y & _1n4) === _1n4;
        const isHeadOdd = (head8 & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head8 === 4) {
        const x = Fp.fromBytes(tail2.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail2.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      } else {
        const cl = compressedLen;
        const ul = uncompressedLen;
        throw new Error("invalid Point, expected length of " + cl + ", or uncompressed " + ul + ", got " + len);
      }
    }
  });
  const numToNByteStr = (num2) => bytesToHex2(numberToBytesBE(num2, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number7) {
    const HALF = CURVE_ORDER >> _1n4;
    return number7 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN2(-s) : s;
  }
  const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
  class Signature2 {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature2(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature2(r, s);
    }
    assertValidity() {
      aInRange("r", this.r, _1n4, CURVE_ORDER);
      aInRange("s", this.s, _1n4, CURVE_ORDER);
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point3.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN2(-h * ir);
      const u2 = modN2(s * ir);
      const Q = Point3.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, modN2(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error2) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length5 = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length5), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point3.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point3.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes2(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point3)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point3.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes3) {
    if (bytes3.length > 8192)
      throw new Error("input is too large");
    const num2 = bytesToNumberBE(bytes3);
    const delta = bytes3.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num2 >> BigInt(delta) : num2;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes3) {
    return modN2(bits2int(bytes3));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num2) {
    aInRange("num < 2^" + CURVE.nBitLength, num2, _0n4, ORDER_MASK);
    return numberToBytesBE(num2, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash4, randomBytes: randomBytes4 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash4(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e = ent === true ? randomBytes4(Fp.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point3.BASE.multiply(k).toAffine();
      const r = modN2(q.x);
      if (r === _0n4)
        return;
      const s = modN2(ik * modN2(m + r * d));
      if (s === _0n4)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature2(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign2(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point3.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    const { lowS, prehash, format: format8 } = opts;
    validateSigVerOpts(opts);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    if (format8 !== void 0 && format8 !== "compact" && format8 !== "der")
      throw new Error("format must be compact or der");
    const isHex = typeof sg === "string" || isBytes2(sg);
    const isObj = !isHex && !format8 && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig = void 0;
    let P;
    try {
      if (isObj)
        _sig = new Signature2(sg.r, sg.s);
      if (isHex) {
        try {
          if (format8 !== "compact")
            _sig = Signature2.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
        }
        if (!_sig && format8 !== "der")
          _sig = Signature2.fromCompact(sg);
      }
      P = Point3.fromHex(publicKey);
    } catch (error2) {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is4 = invN(s);
    const u1 = modN2(h * is4);
    const u2 = modN2(r * is4);
    const R = Point3.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN2(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign: sign2,
    verify,
    ProjectivePoint: Point3,
    Signature: Signature2,
    utils: utils2
  };
}

// ../../node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash3(hash4) {
  return {
    hash: hash4,
    hmac: (key, ...msgs) => hmac(hash4, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash4) => weierstrass({ ...curveDef, ...getHash3(hash4) });
  return { ...create(defHash), create };
}

// ../../node_modules/.pnpm/@noble+curves@1.8.1/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var divNearest = (a, b) => (a + b / _2n4) / b;
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n5 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n5, P) * b3 % P;
  const b9 = pow2(b6, _3n5, P) * b3 % P;
  const b11 = pow2(b9, _2n4, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n5, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n4, P);
  if (!Fpk1.eql(Fpk1.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk1 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  Fp: Fpk1,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  endo: {
    // Endomorphism, see above
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256);
var _0n5 = BigInt(0);
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag3, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag3];
  if (tagP === void 0) {
    const tagH = sha256(Uint8Array.from(tag3, (c) => c.charCodeAt(0)));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag3] = tagP;
  }
  return sha256(concatBytes2(tagP, ...messages));
}
var pointToBytes = (point) => point.toRawBytes(true).slice(1);
var numTo32b = (n) => numberToBytesBE(n, 32);
var modP = (x) => mod(x, secp256k1P);
var modN = (x) => mod(x, secp256k1N);
var Point = secp256k1.ProjectivePoint;
var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p = Point.fromPrivateKey(d_);
  const scalar = p.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  aInRange("x", x, _1n5, secp256k1P);
  const xx = modP(x * x);
  const c = modP(xx * x + BigInt(7));
  let y = sqrtMod(c);
  if (y % _2n4 !== _0n5)
    y = modP(-y);
  const p = new Point(x, y, _1n5);
  p.assertValidity();
  return p;
}
var num = bytesToNumberBE;
function challenge(...args2) {
  return modN(num(taggedHash("BIP0340/challenge", ...args2)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = numTo32b(d ^ num(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const k_ = modN(num(rand));
  if (k_ === _0n5)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(num(pub));
    const r = num(sig.subarray(0, 32));
    if (!inRange(r, _1n5, secp256k1P))
      return false;
    const s = num(sig.subarray(32, 64));
    if (!inRange(s, _1n5, secp256k1N))
      return false;
    const e = challenge(numTo32b(r), pointToBytes(P), m);
    const R = GmulAdd(P, s, modN(-e));
    if (!R || !R.hasEvenY() || R.toAffine().x !== r)
      return false;
    return true;
  } catch (error2) {
    return false;
  }
}
var schnorr = /* @__PURE__ */ (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))();

// ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/_assert.js
function number5(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function isBytes3(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes(b, ...lengths) {
  if (!isBytes3(b))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash3(hash4) {
  if (typeof hash4 !== "function" || typeof hash4.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number5(hash4.outputLen);
  number5(hash4.blockLen);
}
function exists4(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min5 = instance.outputLen;
  if (out.length < min5) {
    throw new Error(`digestInto() expects output buffer of length at least ${min5}`);
  }
}

// ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/utils.js
function isBytes4(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr2 = (word, shift2) => word << 32 - shift2 | word >>> shift2;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes2 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex3(bytes3) {
  if (!isBytes4(bytes3))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < bytes3.length; i++) {
    hex += hexes2[bytes3[i]];
  }
  return hex;
}
var asciis2 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase162(char2) {
  if (char2 >= asciis2._0 && char2 <= asciis2._9)
    return char2 - asciis2._0;
  if (char2 >= asciis2._A && char2 <= asciis2._F)
    return char2 - (asciis2._A - 10);
  if (char2 >= asciis2._a && char2 <= asciis2._f)
    return char2 - (asciis2._a - 10);
  return;
}
function hexToBytes2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array6 = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase162(hex.charCodeAt(hi));
    const n2 = asciiToBase162(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char2 = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char2 + '" at index ' + hi);
    }
    array6[ai] = n1 * 16 + n2;
  }
  return array6;
}
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes3(data);
  if (!isBytes4(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes3(...arrays) {
  let sum3 = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    if (!isBytes4(a))
      throw new Error("Uint8Array expected");
    sum3 += a.length;
  }
  const res = new Uint8Array(sum3);
  for (let i = 0, pad3 = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad3);
    pad3 += a.length;
  }
  return res;
}
var Hash2 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function wrapConstructor2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes2(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint642(view, byteOffset, value3, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value3, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value3 >> _32n2 & _u32_max);
  const wl = Number(value3 & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
}
var SHA2 = class extends Hash2 {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView2(this.buffer);
  }
  update(data) {
    exists4(this);
    const { view, buffer: buffer3, blockLen } = this;
    data = toBytes2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take10 = Math.min(blockLen - this.pos, len - pos);
      if (take10 === blockLen) {
        const dataView = createView2(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer3.set(data.subarray(pos, pos + take10), this.pos);
      this.pos += take10;
      pos += take10;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists4(this);
    output(out, this);
    this.finished = true;
    const { buffer: buffer3, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer3[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer3[i] = 0;
    setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE3);
  }
  digest() {
    const { buffer: buffer3, outputLen } = this;
    this.digestInto(buffer3);
    const res = buffer3.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer3, length: length5, finished, destroyed, pos } = this;
    to.length = length5;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length5 % blockLen)
      to.buffer.set(buffer3);
    return to;
  }
};

// ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/sha256.js
var Chi2 = (a, b, c) => a & b ^ ~a & c;
var Maj2 = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K2 = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W2 = /* @__PURE__ */ new Uint32Array(64);
var SHA2562 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W2[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W2[i - 15];
      const W2 = SHA256_W2[i - 2];
      const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
      SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
      const T1 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
      const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
      const T2 = sigma0 + Maj2(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha2562 = /* @__PURE__ */ wrapConstructor2(() => new SHA2562());

// ../../packages/nostr/src/services/CryptoService.ts
var CryptoService = class extends Context_exports.Tag("nostr/CryptoService")() {
};
var CryptoServiceLive = Layer_exports.effect(
  CryptoService,
  Effect_exports.sync(() => {
    const generatePrivateKey = () => Effect_exports.try({
      try: () => bytesToHex3(randomBytes2(32)),
      catch: (error2) => new CryptoError({
        operation: "generateKey",
        reason: String(error2)
      })
    });
    const getPublicKey = (privateKey) => Effect_exports.gen(function* () {
      if (!/^[0-9a-f]{64}$/.test(privateKey)) {
        return yield* new InvalidPrivateKey({
          reason: "Private key must be 64 hex characters"
        });
      }
      return yield* Effect_exports.try({
        try: () => {
          const publicKey = schnorr.getPublicKey(privateKey);
          return bytesToHex3(publicKey);
        },
        catch: (error2) => new CryptoError({
          operation: "generateKey",
          reason: String(error2)
        })
      });
    });
    const sign2 = (message, privateKey) => Effect_exports.gen(function* () {
      if (!/^[0-9a-f]{64}$/.test(privateKey)) {
        return yield* new InvalidPrivateKey({
          reason: "Private key must be 64 hex characters"
        });
      }
      return yield* Effect_exports.try({
        try: () => {
          const messageHash = sha2562(message);
          const signature = schnorr.sign(messageHash, privateKey);
          return bytesToHex3(signature);
        },
        catch: (error2) => new CryptoError({
          operation: "sign",
          reason: String(error2)
        })
      });
    });
    const verify = (signature, message, publicKey) => Effect_exports.try({
      try: () => {
        const messageHash = sha2562(message);
        const signatureBytes = hexToBytes2(signature);
        const publicKeyBytes = hexToBytes2(publicKey);
        return schnorr.verify(signatureBytes, messageHash, publicKeyBytes);
      },
      catch: (error2) => new CryptoError({
        operation: "verify",
        reason: String(error2)
      })
    });
    const hash4 = (message) => Effect_exports.try({
      try: () => bytesToHex3(sha2562(message)),
      catch: (error2) => new CryptoError({
        operation: "hash",
        reason: String(error2)
      })
    });
    return {
      generatePrivateKey,
      getPublicKey,
      sign: sign2,
      verify,
      hash: hash4
    };
  })
);

// ../../packages/nostr/src/services/EventService.ts
var EventService = class extends Context_exports.Tag("nostr/EventService")() {
};
var serializeEvent = (event) => {
  const serialized = JSON.stringify([
    0,
    event.pubkey,
    event.created_at,
    event.kind,
    event.tags,
    event.content
  ]);
  return serialized;
};
var EventServiceLive = Layer_exports.effect(
  EventService,
  Effect_exports.gen(function* () {
    const crypto4 = yield* CryptoService;
    const serialize2 = (event) => serializeEvent(event);
    const calculateId = (event) => Effect_exports.gen(function* () {
      const serialized = serialize2(event);
      const id3 = yield* crypto4.hash(serialized);
      return id3;
    }).pipe(
      Effect_exports.catchAll(
        (error2) => Effect_exports.fail(
          new InvalidEventId({
            id: "unknown",
            reason: `Failed to calculate event ID: ${error2}`
          })
        )
      )
    );
    const sign2 = (event, privateKey) => crypto4.sign(event.id, privateKey).pipe(
      Effect_exports.catchAll(
        (error2) => Effect_exports.fail(
          new InvalidSignature({
            eventId: event.id,
            publicKey: event.pubkey,
            reason: String(error2)
          })
        )
      )
    );
    const create = (params, privateKey) => Effect_exports.gen(function* () {
      const publicKey = yield* crypto4.getPublicKey(privateKey).pipe(
        Effect_exports.catchAll(
          () => Effect_exports.fail(
            new EventValidationError({
              errors: ["Invalid private key"]
            })
          )
        )
      );
      const unsignedEvent = {
        pubkey: publicKey,
        created_at: Math.floor(Date.now() / 1e3),
        kind: params.kind,
        tags: params.tags,
        content: params.content
      };
      const id3 = yield* calculateId(unsignedEvent);
      const sig = yield* sign2({ ...unsignedEvent, id: id3 }, privateKey);
      const event = {
        ...unsignedEvent,
        id: id3,
        sig
      };
      return yield* Schema_exports.decodeUnknown(NostrEvent)(event);
    });
    const verify = (event) => Effect_exports.gen(function* () {
      const unsignedEvent = {
        pubkey: event.pubkey,
        created_at: event.created_at,
        kind: event.kind,
        tags: event.tags,
        content: event.content
      };
      const calculatedId = yield* calculateId(unsignedEvent);
      if (calculatedId !== event.id) {
        return yield* Effect_exports.fail(
          new InvalidEventId({
            id: event.id,
            reason: `Calculated ID ${calculatedId} does not match event ID ${event.id}`
          })
        );
      }
      const isValid2 = yield* crypto4.verify(event.sig, event.id, event.pubkey).pipe(
        Effect_exports.catchAll(() => Effect_exports.succeed(false))
      );
      if (!isValid2) {
        return yield* Effect_exports.fail(
          new InvalidSignature({
            eventId: event.id,
            publicKey: event.pubkey,
            reason: "Signature verification failed"
          })
        );
      }
      return event;
    });
    return {
      create,
      verify,
      calculateId,
      sign: sign2,
      serialize: serialize2
    };
  })
);

// ../../packages/nostr/src/services/RelayService.ts
var RelayService_exports = {};
__export(RelayService_exports, {
  RelayService: () => RelayService,
  RelayServiceLive: () => RelayServiceLive
});

// ../../packages/nostr/src/services/WebSocketService.ts
var WebSocketService_exports = {};
__export(WebSocketService_exports, {
  WebSocketService: () => WebSocketService,
  WebSocketServiceLive: () => WebSocketServiceLive
});
var import_ws = __toESM(require_browser(), 1);
var WebSocketService = class extends Context_exports.Tag("nostr/WebSocketService")() {
};
var WebSocketServiceLive = Layer_exports.succeed(
  WebSocketService,
  {
    connect: (url2) => Effect_exports.gen(function* () {
      const ws = new import_ws.WebSocket(url2);
      const messageQueue = yield* Queue_exports.unbounded();
      const errorRef = yield* Ref_exports.make(Option_exports.none());
      const setupHandlers = Effect_exports.sync(() => {
        ws.on("error", (error2) => {
          const connError = new ConnectionError({
            url: url2,
            reason: error2.message,
            code: error2.code
          });
          Ref_exports.set(errorRef, Option_exports.some(connError)).pipe(Effect_exports.runSync);
          Queue_exports.shutdown(messageQueue).pipe(Effect_exports.runSync);
        });
        ws.on("close", (code, reason) => {
          const connError = new ConnectionError({
            url: url2,
            reason: reason?.toString() || "Connection closed"
          });
          Ref_exports.set(errorRef, Option_exports.some(connError)).pipe(Effect_exports.runSync);
          Queue_exports.shutdown(messageQueue).pipe(Effect_exports.runSync);
        });
        ws.on("message", (data) => {
          const message = data.toString();
          Queue_exports.offer(messageQueue, message).pipe(Effect_exports.runSync);
        });
      });
      const waitForOpen = Effect_exports.async((resume2) => {
        if (ws.readyState === import_ws.WebSocket.OPEN) {
          resume2(Effect_exports.succeed(void 0));
        } else {
          ws.once("open", () => resume2(Effect_exports.succeed(void 0)));
          ws.once("error", (error2) => resume2(Effect_exports.fail(
            new ConnectionError({
              url: url2,
              reason: error2.message,
              code: error2.code
            })
          )));
        }
      });
      yield* setupHandlers;
      yield* waitForOpen.pipe(
        Effect_exports.timeoutFail({
          duration: "30 seconds",
          onTimeout: () => new ConnectionError({
            url: url2,
            reason: "Connection timeout"
          })
        })
      );
      yield* Effect_exports.addFinalizer(
        () => Effect_exports.sync(() => {
          if (ws.readyState === import_ws.WebSocket.OPEN || ws.readyState === import_ws.WebSocket.CONNECTING) {
            ws.close();
          }
        })
      );
      const connection = {
        url: url2,
        ws,
        readyState: () => ws.readyState,
        send: (message) => Effect_exports.gen(function* () {
          if (ws.readyState !== import_ws.WebSocket.OPEN) {
            return yield* Effect_exports.fail(
              new MessageSendError({
                url: url2,
                message,
                reason: "WebSocket is not open"
              })
            );
          }
          return yield* Effect_exports.async((resume2) => {
            ws.send(message, (error2) => {
              if (error2) {
                resume2(Effect_exports.fail(
                  new MessageSendError({
                    url: url2,
                    message,
                    reason: error2.message
                  })
                ));
              } else {
                resume2(Effect_exports.succeed(void 0));
              }
            });
          });
        }),
        close: (code, reason) => Effect_exports.sync(() => {
          ws.close(code, reason);
        }),
        messages: Stream_exports.fromQueue(messageQueue).pipe(
          Stream_exports.flatMap(
            (message) => Ref_exports.get(errorRef).pipe(
              Effect_exports.flatMap(Option_exports.match({
                onNone: () => Effect_exports.succeed(message),
                onSome: (error2) => Effect_exports.fail(error2)
              })),
              Stream_exports.fromEffect
            )
          )
        )
      };
      return connection;
    }),
    isOpen: (connection) => connection.readyState() === import_ws.WebSocket.OPEN
  }
);

// ../../packages/nostr/src/services/RelayService.ts
var RelayService = class extends Context_exports.Tag("nostr/RelayService")() {
};
var RelayServiceLive = Layer_exports.effect(
  RelayService,
  Effect_exports.gen(function* () {
    const wsService = yield* WebSocketService;
    const connect = (url2) => Effect_exports.gen(function* () {
      const ws = yield* wsService.connect(url2);
      const subscriptions = yield* Ref_exports.make(HashMap_exports.empty());
      const pendingOk = yield* Ref_exports.make(HashMap_exports.empty());
      const processMessages = Stream_exports.runForEach(ws.messages, (data) => Effect_exports.gen(function* () {
        const message = yield* Schema_exports.decodeUnknown(RelayMessage)(JSON.parse(data)).pipe(
          Effect_exports.catchAll(() => Effect_exports.succeed(null))
        );
        if (!message) return;
        switch (message[0]) {
          case "EVENT": {
            const [, subId, event] = message;
            const subs = yield* Ref_exports.get(subscriptions);
            const sub = HashMap_exports.get(subs, subId);
            if (Option_exports.isSome(sub)) {
              yield* Queue_exports.offer(sub.value.queue, event);
            }
            break;
          }
          case "OK": {
            const [, eventId, success] = message;
            const pending3 = yield* Ref_exports.get(pendingOk);
            const callback = HashMap_exports.get(pending3, eventId);
            if (Option_exports.isSome(callback)) {
              callback.value(success);
              yield* Ref_exports.update(pendingOk, HashMap_exports.remove(eventId));
            }
            break;
          }
          case "EOSE": {
            const [, subId] = message;
            yield* Ref_exports.update(
              subscriptions,
              HashMap_exports.modify(
                subId,
                (state) => ({ ...state, eoseReceived: true })
              )
            );
            break;
          }
          case "CLOSED": {
            const [, subId] = message;
            const subs = yield* Ref_exports.get(subscriptions);
            const sub = HashMap_exports.get(subs, subId);
            if (Option_exports.isSome(sub)) {
              yield* Queue_exports.shutdown(sub.value.queue);
              yield* Ref_exports.update(subscriptions, HashMap_exports.remove(subId));
            }
            break;
          }
          case "NOTICE": {
            console.log(`[${url2}] NOTICE:`, message[1]);
            break;
          }
        }
      })).pipe(
        Effect_exports.forkScoped,
        Effect_exports.interruptible
      );
      yield* processMessages;
      const subscribe4 = (id3, filters) => Effect_exports.gen(function* () {
        const subs = yield* Ref_exports.get(subscriptions);
        if (HashMap_exports.has(subs, id3)) {
          return yield* Effect_exports.fail(
            new SubscriptionError({
              subscriptionId: id3,
              reason: "Subscription ID already exists"
            })
          );
        }
        const queue = yield* Queue_exports.unbounded();
        const subState = {
          queue,
          filters,
          eoseReceived: false
        };
        yield* Ref_exports.update(subscriptions, HashMap_exports.set(id3, subState));
        const reqMessage = ["REQ", id3, ...filters];
        yield* ws.send(JSON.stringify(reqMessage));
        yield* Effect_exports.addFinalizer(
          () => Effect_exports.gen(function* () {
            yield* ws.send(JSON.stringify(["CLOSE", id3])).pipe(
              Effect_exports.catchAll(() => Effect_exports.succeed(void 0))
            );
            yield* Queue_exports.shutdown(queue);
            yield* Ref_exports.update(subscriptions, HashMap_exports.remove(id3));
          })
        );
        const subscription = {
          id: id3,
          filters,
          events: Stream_exports.fromQueue(queue).pipe(
            Stream_exports.catchAll(
              (error2) => Stream_exports.fail(
                new SubscriptionError({
                  subscriptionId: id3,
                  reason: String(error2)
                })
              )
            )
          )
        };
        return subscription;
      });
      const publish3 = (event) => Effect_exports.gen(function* () {
        const eventMessage = ["EVENT", event];
        yield* ws.send(JSON.stringify(eventMessage));
        const result = yield* Effect_exports.async((resume2) => {
          Ref_exports.update(
            pendingOk,
            HashMap_exports.set(
              event.id,
              (success) => resume2(Effect_exports.succeed(success))
            )
          ).pipe(Effect_exports.runSync);
        }).pipe(
          Effect_exports.timeoutFail({
            duration: "10 seconds",
            onTimeout: () => new TimeoutError({
              operation: "publish",
              timeoutMs: 1e4
            })
          }),
          Effect_exports.catchAll(() => Effect_exports.succeed(false))
        );
        return result;
      });
      const close2 = (subscriptionId) => Effect_exports.gen(function* () {
        const closeMessage = ["CLOSE", subscriptionId];
        yield* ws.send(JSON.stringify(closeMessage));
        yield* Ref_exports.update(subscriptions, HashMap_exports.remove(subscriptionId));
      });
      const disconnect3 = () => ws.close();
      const connection = {
        url: url2,
        subscribe: subscribe4,
        publish: publish3,
        close: close2,
        disconnect: disconnect3
      };
      return connection;
    });
    return { connect };
  })
);

// ../../packages/nostr/src/agent-profile/AgentProfileService.ts
var AGENT_PROFILE_KIND = 31337;
var AgentProfileContent = Schema_exports.Struct({
  description: Schema_exports.String,
  avatar: Schema_exports.optional(Schema_exports.String),
  capabilities: Schema_exports.Array(Schema_exports.Struct({
    id: Schema_exports.String,
    name: Schema_exports.String,
    description: Schema_exports.String,
    pricing: Schema_exports.Struct({
      base: Schema_exports.Number,
      per_unit: Schema_exports.optional(Schema_exports.String),
      unit_limit: Schema_exports.optional(Schema_exports.Number)
    }),
    nip90_kinds: Schema_exports.optional(Schema_exports.Array(Schema_exports.Number))
  })),
  pricing_models: Schema_exports.optional(Schema_exports.Struct({
    subscription_monthly: Schema_exports.optional(Schema_exports.Number),
    per_request: Schema_exports.optional(Schema_exports.Number)
  })),
  constraints: Schema_exports.optional(Schema_exports.Struct({
    max_monthly_requests: Schema_exports.optional(Schema_exports.Number),
    max_concurrent_jobs: Schema_exports.optional(Schema_exports.Number),
    supported_languages: Schema_exports.optional(Schema_exports.Array(Schema_exports.String))
  })),
  metrics: Schema_exports.optional(Schema_exports.Struct({
    total_earned: Schema_exports.optional(Schema_exports.Number),
    total_spent: Schema_exports.optional(Schema_exports.Number),
    requests_completed: Schema_exports.optional(Schema_exports.Number),
    average_rating: Schema_exports.optional(Schema_exports.Number),
    uptime_percentage: Schema_exports.optional(Schema_exports.Number)
  }))
});
var AgentProfile = Schema_exports.Struct({
  pubkey: Schema_exports.String,
  agent_id: Schema_exports.String,
  name: Schema_exports.String,
  status: Schema_exports.Literal("active", "hibernating", "offline"),
  balance: Schema_exports.Number,
  metabolic_rate: Schema_exports.Number,
  capabilities: Schema_exports.Array(Schema_exports.String),
  content: AgentProfileContent,
  last_activity: Schema_exports.String,
  profile_event_id: Schema_exports.optional(Schema_exports.String),
  created_at: Schema_exports.String,
  updated_at: Schema_exports.String
});
var CreateAgentProfileParams = Schema_exports.Struct({
  agent_id: Schema_exports.String,
  name: Schema_exports.String,
  content: AgentProfileContent,
  status: Schema_exports.optional(Schema_exports.Literal("active", "hibernating", "offline")),
  balance: Schema_exports.optional(Schema_exports.Number),
  metabolic_rate: Schema_exports.optional(Schema_exports.Number)
});
var AgentProfileFilters = Schema_exports.Struct({
  pubkeys: Schema_exports.optional(Schema_exports.Array(Schema_exports.String)),
  agent_ids: Schema_exports.optional(Schema_exports.Array(Schema_exports.String)),
  status: Schema_exports.optional(Schema_exports.Array(Schema_exports.Literal("active", "hibernating", "offline"))),
  capabilities: Schema_exports.optional(Schema_exports.Array(Schema_exports.String)),
  min_balance: Schema_exports.optional(Schema_exports.Number),
  limit: Schema_exports.optional(Schema_exports.Number),
  since: Schema_exports.optional(Schema_exports.Number)
});
var AgentProfileError = class extends Schema_exports.TaggedError()("AgentProfileError", {
  reason: Schema_exports.Literal("validation_failed", "event_creation_failed", "relay_error", "not_found"),
  message: Schema_exports.String,
  details: Schema_exports.optional(Schema_exports.Unknown)
}) {
};
var AgentProfileService = class extends Context_exports.Tag("nostr/AgentProfileService")() {
};
var AgentProfileServiceLive = Layer_exports.effect(
  AgentProfileService,
  Effect_exports.gen(function* () {
    const eventService = yield* EventService;
    const relayService = yield* RelayService;
    const createProfile = (pubkey, privateKey, params) => Effect_exports.gen(function* () {
      const tags = [
        ["d", params.agent_id],
        ["name", params.name]
      ];
      if (params.status) {
        tags.push(["status", params.status]);
      }
      if (params.balance !== void 0) {
        tags.push(["balance", params.balance.toString()]);
      }
      if (params.metabolic_rate !== void 0) {
        tags.push(["metabolic_rate", params.metabolic_rate.toString()]);
      }
      const event = yield* eventService.create(
        {
          kind: AGENT_PROFILE_KIND,
          tags,
          content: JSON.stringify(params.content)
        },
        privateKey
      );
      return event;
    }).pipe(
      Effect_exports.catchAll(
        (error2) => Effect_exports.fail(
          new AgentProfileError({
            reason: "event_creation_failed",
            message: String(error2),
            details: error2
          })
        )
      )
    );
    const updateProfile = (pubkey, privateKey, updates) => Effect_exports.gen(function* () {
      const tags = [];
      if (updates.agent_id) {
        tags.push(["d", updates.agent_id]);
      }
      if (updates.name) {
        tags.push(["name", updates.name]);
      }
      if (updates.status) {
        tags.push(["status", updates.status]);
      }
      if (updates.balance !== void 0) {
        tags.push(["balance", updates.balance.toString()]);
      }
      if (updates.metabolic_rate !== void 0) {
        tags.push(["metabolic_rate", updates.metabolic_rate.toString()]);
      }
      const event = yield* eventService.create(
        {
          kind: AGENT_PROFILE_KIND,
          tags,
          content: JSON.stringify(updates.content || {})
        },
        privateKey
      );
      return event;
    }).pipe(
      Effect_exports.catchAll(
        (error2) => Effect_exports.fail(
          new AgentProfileError({
            reason: "event_creation_failed",
            message: String(error2),
            details: error2
          })
        )
      )
    );
    const getProfile = (_pubkey) => Effect_exports.gen(function* () {
      yield* Effect_exports.succeed(void 0);
      return null;
    });
    const listProfiles = (_filters) => Effect_exports.gen(function* () {
      yield* Effect_exports.succeed(void 0);
      return [];
    });
    const publishProfile = (event, relays) => Effect_exports.gen(function* () {
      if (!relays || relays.length === 0) {
        return;
      }
      for (const relay of relays) {
        yield* Effect_exports.scoped(
          Effect_exports.gen(function* () {
            const connection = yield* relayService.connect(relay);
            yield* connection.publish(event);
          })
        ).pipe(
          Effect_exports.catchAll((error2) => {
            console.error(`Failed to publish to relay ${relay}:`, error2);
            return Effect_exports.succeed(void 0);
          })
        );
      }
    }).pipe(
      Effect_exports.catchAll(
        (error2) => Effect_exports.fail(
          new AgentProfileError({
            reason: "relay_error",
            message: String(error2),
            details: error2
          })
        )
      )
    );
    const subscribeToProfiles = (_filters, _onProfile) => Effect_exports.gen(function* () {
      yield* Effect_exports.succeed(void 0);
      return () => {
      };
    });
    return {
      createProfile,
      updateProfile,
      getProfile,
      listProfiles,
      publishProfile,
      subscribeToProfiles
    };
  })
);

// ../../node_modules/.pnpm/@scure+base@1.2.4/node_modules/@scure/base/lib/esm/index.js
function isBytes5(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function isArrayOf(isString2, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString2) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber2(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function chain(...args2) {
  const id3 = (a) => a;
  const wrap = (a, b) => (c) => a(b(c));
  const encode6 = args2.map((x) => x.encode).reduceRight(wrap, id3);
  const decode7 = args2.map((x) => x.decode).reduce(wrap, id3);
  return { encode: encode6, decode: decode7 };
}
// @__NO_SIDE_EFFECTS__
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l, i) => [l, i]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i) => {
        if (!Number.isSafeInteger(i) || i < 0 || i >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
        return lettersA[i];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i = indexes.get(letter);
        if (i === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function join5(separator = "") {
  astr("join", separator);
  return {
    encode: (from) => {
      astrArr("join.decode", from);
      return from.join(separator);
    },
    decode: (to) => {
      astr("join.decode", to);
      return to.split(separator);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function padding(bits, chr = "=") {
  anumber2(bits);
  astr("padding", chr);
  return {
    encode(data) {
      astrArr("padding.encode", data);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end6 = input.length;
      if (end6 * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end6 > 0 && input[end6 - 1] === chr; end6--) {
        const last5 = end6 - 1;
        const byte = last5 * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end6);
    }
  };
}
var gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
var radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));
var powers = /* @__PURE__ */ (() => {
  let res = [];
  for (let i = 0; i < 40; i++)
    res.push(2 ** i);
  return res;
})();
function convertRadix2(data, from, to, padding3) {
  aArr(data);
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (/* @__PURE__ */ radix2carry(from, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${/* @__PURE__ */ radix2carry(from, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const max7 = powers[from];
  const mask = powers[to] - 1;
  const res = [];
  for (const n of data) {
    anumber2(n);
    if (n >= max7)
      throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
    carry = carry << from | n;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    const pow3 = powers[pos];
    if (pow3 === void 0)
      throw new Error("invalid carry");
    carry &= pow3 - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding3 && pos >= from)
    throw new Error("Excess padding");
  if (!padding3 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding3 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
// @__NO_SIDE_EFFECTS__
function radix2(bits, revPadding = false) {
  anumber2(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ radix2carry(8, bits) > 32 || /* @__PURE__ */ radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes3) => {
      if (!isBytes5(bytes3))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes3), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn2) {
  afn(fn2);
  return function(...args2) {
    try {
      return fn2.apply(null, args2);
    } catch (e) {
    }
  };
}
var base642 = /* @__PURE__ */ chain(/* @__PURE__ */ radix2(6), /* @__PURE__ */ alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), /* @__PURE__ */ padding(6), /* @__PURE__ */ join5(""));
var BECH_ALPHABET = /* @__PURE__ */ chain(/* @__PURE__ */ alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), /* @__PURE__ */ join5(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre2) {
  const b = pre2 >> 25;
  let chk = (pre2 & 33554431) << 5;
  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
    if ((b >> i & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i = 0; i < len; i++) {
    const c = prefix.charCodeAt(i);
    if (c < 33 || c > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i = 0; i < len; i++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 31;
  for (let v of words)
    chk = bech32Polymod(chk) ^ v;
  for (let i = 0; i < 6; i++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
// @__NO_SIDE_EFFECTS__
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = /* @__PURE__ */ radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode6(prefix, words, limit2 = 90) {
    astr("bech32.encode prefix", prefix);
    if (isBytes5(words))
      words = Array.from(words);
    anumArr("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit2 !== false && actualLength > limit2)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit2}`);
    const lowered = prefix.toLowerCase();
    const sum3 = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum3}`;
  }
  function decode7(str, limit2 = 90) {
    astr("bech32.decode input", str);
    const slen = str.length;
    if (slen < 8 || limit2 !== false && slen > limit2)
      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit2})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum3 = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum3))
      throw new Error(`Invalid checksum in ${str}: expected "${sum3}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode7);
  function decodeToBytes(str) {
    const { prefix, words } = decode7(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  function encodeFromBytes(prefix, bytes3) {
    return encode6(prefix, toWords(bytes3));
  }
  return {
    encode: encode6,
    decode: decode7,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
var bech32 = /* @__PURE__ */ genBech32("bech32");

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/crypto.js
var crypto3 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js
function isBytes6(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function anumber3(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function abytes3(b, ...lengths) {
  if (!isBytes6(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function ahash2(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  anumber3(h.outputLen);
  anumber3(h.blockLen);
}
function aexists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput2(out, instance) {
  abytes3(out);
  const min5 = instance.outputLen;
  if (out.length < min5) {
    throw new Error("digestInto() expects output buffer of length at least " + min5);
  }
}
function clean(...arrays) {
  for (let i = 0; i < arrays.length; i++) {
    arrays[i].fill(0);
  }
}
function createView3(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr3(word, shift2) {
  return word << 32 - shift2 | word >>> shift2;
}
function rotl(word, shift2) {
  return word << shift2 | word >>> 32 - shift2 >>> 0;
}
var hasHexBuiltin = /* @__PURE__ */ (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes3 = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
function bytesToHex4(bytes3) {
  abytes3(bytes3);
  if (hasHexBuiltin)
    return bytes3.toHex();
  let hex = "";
  for (let i = 0; i < bytes3.length; i++) {
    hex += hexes3[bytes3[i]];
  }
  return hex;
}
var asciis3 = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase163(ch) {
  if (ch >= asciis3._0 && ch <= asciis3._9)
    return ch - asciis3._0;
  if (ch >= asciis3.A && ch <= asciis3.F)
    return ch - (asciis3.A - 10);
  if (ch >= asciis3.a && ch <= asciis3.f)
    return ch - (asciis3.a - 10);
  return;
}
function hexToBytes3(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array6 = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase163(hex.charCodeAt(hi));
    const n2 = asciiToBase163(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char2 = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char2 + '" at index ' + hi);
    }
    array6[ai] = n1 * 16 + n2;
  }
  return array6;
}
function utf8ToBytes4(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes3(data) {
  if (typeof data === "string")
    data = utf8ToBytes4(data);
  abytes3(data);
  return data;
}
function kdfInputToBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes4(data);
  abytes3(data);
  return data;
}
function concatBytes4(...arrays) {
  let sum3 = 0;
  for (let i = 0; i < arrays.length; i++) {
    const a = arrays[i];
    abytes3(a);
    sum3 += a.length;
  }
  const res = new Uint8Array(sum3);
  for (let i = 0, pad3 = 0; i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad3);
    pad3 += a.length;
  }
  return res;
}
function checkOpts(defaults, opts) {
  if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
    throw new Error("options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
var Hash3 = class {
};
function createHasher(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes3(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes3(bytesLength = 32) {
  if (crypto3 && typeof crypto3.getRandomValues === "function") {
    return crypto3.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto3 && typeof crypto3.randomBytes === "function") {
    return Uint8Array.from(crypto3.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// ../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/esm/utils.js
var _0n6 = /* @__PURE__ */ BigInt(0);
var _1n6 = /* @__PURE__ */ BigInt(1);
function abool2(title, value3) {
  if (typeof value3 !== "boolean")
    throw new Error(title + " boolean expected, got " + value3);
}
function numberToHexUnpadded2(num2) {
  const hex = num2.toString(16);
  return hex.length & 1 ? "0" + hex : hex;
}
function hexToNumber2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return hex === "" ? _0n6 : BigInt("0x" + hex);
}
function bytesToNumberBE2(bytes3) {
  return hexToNumber2(bytesToHex4(bytes3));
}
function bytesToNumberLE2(bytes3) {
  abytes3(bytes3);
  return hexToNumber2(bytesToHex4(Uint8Array.from(bytes3).reverse()));
}
function numberToBytesBE2(n, len) {
  return hexToBytes3(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE2(n, len) {
  return numberToBytesBE2(n, len).reverse();
}
function ensureBytes2(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes3(hex);
    } catch (e) {
      throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
    }
  } else if (isBytes6(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(title + " must be hex string or Uint8Array");
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(title + " of length " + expectedLength + " expected, got " + len);
  return res;
}
var isPosBig2 = (n) => typeof n === "bigint" && _0n6 <= n;
function inRange2(n, min5, max7) {
  return isPosBig2(n) && isPosBig2(min5) && isPosBig2(max7) && min5 <= n && n < max7;
}
function aInRange2(title, n, min5, max7) {
  if (!inRange2(n, min5, max7))
    throw new Error("expected valid " + title + ": " + min5 + " <= n < " + max7 + ", got " + n);
}
function bitLen2(n) {
  let len;
  for (len = 0; n > _0n6; n >>= _1n6, len += 1)
    ;
  return len;
}
var bitMask2 = (n) => (_1n6 << BigInt(n)) - _1n6;
function createHmacDrbg2(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  const u8n2 = (len) => new Uint8Array(len);
  const u8of = (byte) => Uint8Array.of(byte);
  let v = u8n2(hashLen);
  let k = u8n2(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n2(0)) => {
    k = h(u8of(0), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8of(1), seed);
    v = h();
  };
  const gen5 = () => {
    if (i++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes4(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen5())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function _validateObject(object2, fields, optFields = {}) {
  if (!object2 || typeof object2 !== "object")
    throw new Error("expected valid options object");
  function checkField(fieldName, expectedType, isOpt) {
    const val = object2[fieldName];
    if (isOpt && val === void 0)
      return;
    const current2 = typeof val;
    if (current2 !== expectedType || val === null)
      throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current2}`);
  }
  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
function memoized2(fn2) {
  const map31 = /* @__PURE__ */ new WeakMap();
  return (arg, ...args2) => {
    const val = map31.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn2(arg, ...args2);
    map31.set(arg, computed);
    return computed;
  };
}

// ../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/esm/abstract/modular.js
var _0n7 = BigInt(0);
var _1n7 = BigInt(1);
var _2n5 = /* @__PURE__ */ BigInt(2);
var _3n3 = /* @__PURE__ */ BigInt(3);
var _4n3 = /* @__PURE__ */ BigInt(4);
var _5n2 = /* @__PURE__ */ BigInt(5);
var _8n2 = /* @__PURE__ */ BigInt(8);
function mod2(a, b) {
  const result = a % b;
  return result >= _0n7 ? result : b + result;
}
function pow22(x, power, modulo) {
  let res = x;
  while (power-- > _0n7) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert3(number7, modulo) {
  if (number7 === _0n7)
    throw new Error("invert: expected non-zero number");
  if (modulo <= _0n7)
    throw new Error("invert: expected positive modulus, got " + modulo);
  let a = mod2(number7, modulo);
  let b = modulo;
  let x = _0n7, y = _1n7, u = _1n7, v = _0n7;
  while (a !== _0n7) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd3 = b;
  if (gcd3 !== _1n7)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function sqrt3mod4(Fp, n) {
  const p1div4 = (Fp.ORDER + _1n7) / _4n3;
  const root = Fp.pow(n, p1div4);
  if (!Fp.eql(Fp.sqr(root), n))
    throw new Error("Cannot find square root");
  return root;
}
function sqrt5mod8(Fp, n) {
  const p5div8 = (Fp.ORDER - _5n2) / _8n2;
  const n2 = Fp.mul(n, _2n5);
  const v = Fp.pow(n2, p5div8);
  const nv = Fp.mul(n, v);
  const i = Fp.mul(Fp.mul(nv, _2n5), v);
  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
  if (!Fp.eql(Fp.sqr(root), n))
    throw new Error("Cannot find square root");
  return root;
}
function tonelliShanks2(P) {
  if (P < BigInt(3))
    throw new Error("sqrt is not defined for small field");
  let Q = P - _1n7;
  let S = 0;
  while (Q % _2n5 === _0n7) {
    Q /= _2n5;
    S++;
  }
  let Z = _2n5;
  const _Fp = Field2(P);
  while (FpLegendre(_Fp, Z) === 1) {
    if (Z++ > 1e3)
      throw new Error("Cannot find square root: probably non-prime P");
  }
  if (S === 1)
    return sqrt3mod4;
  let cc = _Fp.pow(Z, Q);
  const Q1div2 = (Q + _1n7) / _2n5;
  return function tonelliSlow(Fp, n) {
    if (Fp.is0(n))
      return n;
    if (FpLegendre(Fp, n) !== 1)
      throw new Error("Cannot find square root");
    let M = S;
    let c = Fp.mul(Fp.ONE, cc);
    let t = Fp.pow(n, Q);
    let R = Fp.pow(n, Q1div2);
    while (!Fp.eql(t, Fp.ONE)) {
      if (Fp.is0(t))
        return Fp.ZERO;
      let i = 1;
      let t_tmp = Fp.sqr(t);
      while (!Fp.eql(t_tmp, Fp.ONE)) {
        i++;
        t_tmp = Fp.sqr(t_tmp);
        if (i === M)
          throw new Error("Cannot find square root");
      }
      const exponent = _1n7 << BigInt(M - i - 1);
      const b = Fp.pow(c, exponent);
      M = i;
      c = Fp.sqr(b);
      t = Fp.mul(t, c);
      R = Fp.mul(R, b);
    }
    return R;
  };
}
function FpSqrt2(P) {
  if (P % _4n3 === _3n3)
    return sqrt3mod4;
  if (P % _8n2 === _5n2)
    return sqrt5mod8;
  return tonelliShanks2(P);
}
var FIELD_FIELDS2 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField2(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "number",
    BITS: "number"
  };
  const opts = FIELD_FIELDS2.reduce((map31, val) => {
    map31[val] = "function";
    return map31;
  }, initial);
  _validateObject(field, opts);
  return field;
}
function FpPow2(Fp, num2, power) {
  if (power < _0n7)
    throw new Error("invalid exponent, negatives unsupported");
  if (power === _0n7)
    return Fp.ONE;
  if (power === _1n7)
    return num2;
  let p = Fp.ONE;
  let d = num2;
  while (power > _0n7) {
    if (power & _1n7)
      p = Fp.mul(p, d);
    d = Fp.sqr(d);
    power >>= _1n7;
  }
  return p;
}
function FpInvertBatch2(Fp, nums, passZero = false) {
  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
  const multipliedAcc = nums.reduce((acc, num2, i) => {
    if (Fp.is0(num2))
      return acc;
    inverted[i] = acc;
    return Fp.mul(acc, num2);
  }, Fp.ONE);
  const invertedAcc = Fp.inv(multipliedAcc);
  nums.reduceRight((acc, num2, i) => {
    if (Fp.is0(num2))
      return acc;
    inverted[i] = Fp.mul(acc, inverted[i]);
    return Fp.mul(acc, num2);
  }, invertedAcc);
  return inverted;
}
function FpLegendre(Fp, n) {
  const p1mod2 = (Fp.ORDER - _1n7) / _2n5;
  const powered = Fp.pow(n, p1mod2);
  const yes = Fp.eql(powered, Fp.ONE);
  const zero3 = Fp.eql(powered, Fp.ZERO);
  const no = Fp.eql(powered, Fp.neg(Fp.ONE));
  if (!yes && !zero3 && !no)
    throw new Error("invalid Legendre symbol result");
  return yes ? 1 : zero3 ? 0 : -1;
}
function nLength2(n, nBitLength) {
  if (nBitLength !== void 0)
    anumber3(nBitLength);
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field2(ORDER, bitLenOrOpts, isLE3 = false, opts = {}) {
  if (ORDER <= _0n7)
    throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
  let _nbitLength = void 0;
  let _sqrt = void 0;
  if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
    if (opts.sqrt || isLE3)
      throw new Error("cannot specify opts in two arguments");
    const _opts = bitLenOrOpts;
    if (_opts.BITS)
      _nbitLength = _opts.BITS;
    if (_opts.sqrt)
      _sqrt = _opts.sqrt;
    if (typeof _opts.isLE === "boolean")
      isLE3 = _opts.isLE;
  } else {
    if (typeof bitLenOrOpts === "number")
      _nbitLength = bitLenOrOpts;
    if (opts.sqrt)
      _sqrt = opts.sqrt;
  }
  const { nBitLength: BITS, nByteLength: BYTES } = nLength2(ORDER, _nbitLength);
  if (BYTES > 2048)
    throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let sqrtP;
  const f = Object.freeze({
    ORDER,
    isLE: isLE3,
    BITS,
    BYTES,
    MASK: bitMask2(BITS),
    ZERO: _0n7,
    ONE: _1n7,
    create: (num2) => mod2(num2, ORDER),
    isValid: (num2) => {
      if (typeof num2 !== "bigint")
        throw new Error("invalid field element: expected bigint, got " + typeof num2);
      return _0n7 <= num2 && num2 < ORDER;
    },
    is0: (num2) => num2 === _0n7,
    // is valid and invertible
    isValidNot0: (num2) => !f.is0(num2) && f.isValid(num2),
    isOdd: (num2) => (num2 & _1n7) === _1n7,
    neg: (num2) => mod2(-num2, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num2) => mod2(num2 * num2, ORDER),
    add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
    pow: (num2, power) => FpPow2(f, num2, power),
    div: (lhs, rhs) => mod2(lhs * invert3(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num2) => num2 * num2,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num2) => invert3(num2, ORDER),
    sqrt: _sqrt || ((n) => {
      if (!sqrtP)
        sqrtP = FpSqrt2(ORDER);
      return sqrtP(f, n);
    }),
    toBytes: (num2) => isLE3 ? numberToBytesLE2(num2, BYTES) : numberToBytesBE2(num2, BYTES),
    fromBytes: (bytes3) => {
      if (bytes3.length !== BYTES)
        throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes3.length);
      return isLE3 ? bytesToNumberLE2(bytes3) : bytesToNumberBE2(bytes3);
    },
    // TODO: we don't need it here, move out to separate fn
    invertBatch: (lst) => FpInvertBatch2(f, lst),
    // We can't move this out because Fp6, Fp12 implement it
    // and it's unclear what to return in there.
    cmov: (a, b, c) => c ? b : a
  });
  return Object.freeze(f);
}
function getFieldBytesLength2(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength2(fieldOrder) {
  const length5 = getFieldBytesLength2(fieldOrder);
  return length5 + Math.ceil(length5 / 2);
}
function mapHashToField2(key, fieldOrder, isLE3 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength2(fieldOrder);
  const minLen = getMinHashLength2(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
  const num2 = isLE3 ? bytesToNumberLE2(key) : bytesToNumberBE2(key);
  const reduced = mod2(num2, fieldOrder - _1n7) + _1n7;
  return isLE3 ? numberToBytesLE2(reduced, fieldLen) : numberToBytesBE2(reduced, fieldLen);
}

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_md.js
function setBigUint643(view, byteOffset, value3, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value3, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value3 >> _32n2 & _u32_max);
  const wl = Number(value3 & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
}
function Chi3(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj3(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD2 = class extends Hash3 {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView3(this.buffer);
  }
  update(data) {
    aexists2(this);
    data = toBytes3(data);
    abytes3(data);
    const { view, buffer: buffer3, blockLen } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take10 = Math.min(blockLen - this.pos, len - pos);
      if (take10 === blockLen) {
        const dataView = createView3(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer3.set(data.subarray(pos, pos + take10), this.pos);
      this.pos += take10;
      pos += take10;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists2(this);
    aoutput2(out, this);
    this.finished = true;
    const { buffer: buffer3, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer3[pos++] = 128;
    clean(this.buffer.subarray(pos));
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer3[i] = 0;
    setBigUint643(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView3(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE3);
  }
  digest() {
    const { buffer: buffer3, outputLen } = this;
    this.digestInto(buffer3);
    const res = buffer3.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer3, length: length5, finished, destroyed, pos } = this;
    to.destroyed = destroyed;
    to.finished = finished;
    to.length = length5;
    to.pos = pos;
    if (length5 % blockLen)
      to.buffer.set(buffer3);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
};
var SHA256_IV2 = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA512_IV = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  4089235720,
  3144134277,
  2227873595,
  1013904242,
  4271175723,
  2773480762,
  1595750129,
  1359893119,
  2917565137,
  2600822924,
  725511199,
  528734635,
  4215389547,
  1541459225,
  327033209
]);

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
var _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split6(lst, le = false) {
  const len = lst.length;
  let Ah = new Uint32Array(len);
  let Al = new Uint32Array(len);
  for (let i = 0; i < len; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var shrSH = (h, _l, s) => h >>> s;
var shrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
function add7(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha2.js
var SHA256_K3 = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_W3 = /* @__PURE__ */ new Uint32Array(64);
var SHA2563 = class extends HashMD2 {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV2[0] | 0;
    this.B = SHA256_IV2[1] | 0;
    this.C = SHA256_IV2[2] | 0;
    this.D = SHA256_IV2[3] | 0;
    this.E = SHA256_IV2[4] | 0;
    this.F = SHA256_IV2[5] | 0;
    this.G = SHA256_IV2[6] | 0;
    this.H = SHA256_IV2[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      SHA256_W3[i] = view.getUint32(offset, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W3[i - 15];
      const W2 = SHA256_W3[i - 2];
      const s0 = rotr3(W15, 7) ^ rotr3(W15, 18) ^ W15 >>> 3;
      const s1 = rotr3(W2, 17) ^ rotr3(W2, 19) ^ W2 >>> 10;
      SHA256_W3[i] = s1 + SHA256_W3[i - 7] + s0 + SHA256_W3[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr3(E, 6) ^ rotr3(E, 11) ^ rotr3(E, 25);
      const T1 = H + sigma1 + Chi3(E, F, G) + SHA256_K3[i] + SHA256_W3[i] | 0;
      const sigma0 = rotr3(A, 2) ^ rotr3(A, 13) ^ rotr3(A, 22);
      const T2 = sigma0 + Maj3(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    clean(SHA256_W3);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    clean(this.buffer);
  }
};
var K512 = /* @__PURE__ */ (() => split6([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))))();
var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
var SHA512 = class extends HashMD2 {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = SHA512_IV[0] | 0;
    this.Al = SHA512_IV[1] | 0;
    this.Bh = SHA512_IV[2] | 0;
    this.Bl = SHA512_IV[3] | 0;
    this.Ch = SHA512_IV[4] | 0;
    this.Cl = SHA512_IV[5] | 0;
    this.Dh = SHA512_IV[6] | 0;
    this.Dl = SHA512_IV[7] | 0;
    this.Eh = SHA512_IV[8] | 0;
    this.El = SHA512_IV[9] | 0;
    this.Fh = SHA512_IV[10] | 0;
    this.Fl = SHA512_IV[11] | 0;
    this.Gh = SHA512_IV[12] | 0;
    this.Gl = SHA512_IV[13] | 0;
    this.Hh = SHA512_IV[14] | 0;
    this.Hl = SHA512_IV[15] | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
      const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
      const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
      const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
      const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
      const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = add7(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All2 = add3L(T1l, sigma0l, MAJl);
      Ah = add3H(All2, T1h, sigma0h, MAJh);
      Al = All2 | 0;
    }
    ({ h: Ah, l: Al } = add7(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = add7(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = add7(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = add7(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = add7(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = add7(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = add7(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = add7(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    clean(SHA512_W_H, SHA512_W_L);
  }
  destroy() {
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var sha2563 = /* @__PURE__ */ createHasher(() => new SHA2563());
var sha512 = /* @__PURE__ */ createHasher(() => new SHA512());

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/hmac.js
var HMAC2 = class extends Hash3 {
  constructor(hash4, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash2(hash4);
    const key = toBytes3(_key);
    this.iHash = hash4.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad3 = new Uint8Array(blockLen);
    pad3.set(key.length > blockLen ? hash4.create().update(key).digest() : key);
    for (let i = 0; i < pad3.length; i++)
      pad3[i] ^= 54;
    this.iHash.update(pad3);
    this.oHash = hash4.create();
    for (let i = 0; i < pad3.length; i++)
      pad3[i] ^= 54 ^ 92;
    this.oHash.update(pad3);
    clean(pad3);
  }
  update(buf) {
    aexists2(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists2(this);
    abytes3(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  clone() {
    return this._cloneInto();
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac2 = (hash4, key, message) => new HMAC2(hash4, key).update(message).digest();
hmac2.create = (hash4, key) => new HMAC2(hash4, key);

// ../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/esm/abstract/curve.js
var _0n8 = BigInt(0);
var _1n8 = BigInt(1);
function negateCt(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function normalizeZ(c, property2, points) {
  const getz = property2 === "pz" ? (p) => p.pz : (p) => p.ez;
  const toInv = FpInvertBatch2(c.Fp, points.map(getz));
  const affined = points.map((p, i) => p.toAffine(toInv[i]));
  return affined.map(c.fromAffine);
}
function validateW2(W, bits) {
  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
    throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W);
}
function calcWOpts2(W, scalarBits) {
  validateW2(W, scalarBits);
  const windows = Math.ceil(scalarBits / W) + 1;
  const windowSize = 2 ** (W - 1);
  const maxNumber = 2 ** W;
  const mask = bitMask2(W);
  const shiftBy = BigInt(W);
  return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n, window, wOpts) {
  const { windowSize, mask, maxNumber, shiftBy } = wOpts;
  let wbits = Number(n & mask);
  let nextN = n >> shiftBy;
  if (wbits > windowSize) {
    wbits -= maxNumber;
    nextN += _1n8;
  }
  const offsetStart = window * windowSize;
  const offset = offsetStart + Math.abs(wbits) - 1;
  const isZero3 = wbits === 0;
  const isNeg = wbits < 0;
  const isNegF = window % 2 !== 0;
  const offsetF = offsetStart;
  return { nextN, offset, isZero: isZero3, isNeg, isNegF, offsetF };
}
function validateMSMPoints2(points, c) {
  if (!Array.isArray(points))
    throw new Error("array expected");
  points.forEach((p, i) => {
    if (!(p instanceof c))
      throw new Error("invalid point at index " + i);
  });
}
function validateMSMScalars2(scalars, field) {
  if (!Array.isArray(scalars))
    throw new Error("array of scalars expected");
  scalars.forEach((s, i) => {
    if (!field.isValid(s))
      throw new Error("invalid scalar at index " + i);
  });
}
var pointPrecomputes2 = /* @__PURE__ */ new WeakMap();
var pointWindowSizes2 = /* @__PURE__ */ new WeakMap();
function getW2(P) {
  return pointWindowSizes2.get(P) || 1;
}
function assert0(n) {
  if (n !== _0n8)
    throw new Error("invalid wNAF");
}
function wNAF2(c, bits) {
  return {
    constTimeNegate: negateCt,
    hasPrecomputes(elm) {
      return getW2(elm) !== 1;
    },
    // non-const time multiplication ladder
    unsafeLadder(elm, n, p = c.ZERO) {
      let d = elm;
      while (n > _0n8) {
        if (n & _1n8)
          p = p.add(d);
        d = d.double();
        n >>= _1n8;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param elm Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = calcWOpts2(W, bits);
      const points = [];
      let p = elm;
      let base = p;
      for (let window = 0; window < windows; window++) {
        base = p;
        points.push(base);
        for (let i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      let p = c.ZERO;
      let f = c.BASE;
      const wo = calcWOpts2(W, bits);
      for (let window = 0; window < wo.windows; window++) {
        const { nextN, offset, isZero: isZero3, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);
        n = nextN;
        if (isZero3) {
          f = f.add(negateCt(isNegF, precomputes[offsetF]));
        } else {
          p = p.add(negateCt(isNeg, precomputes[offset]));
        }
      }
      assert0(n);
      return { p, f };
    },
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {
      const wo = calcWOpts2(W, bits);
      for (let window = 0; window < wo.windows; window++) {
        if (n === _0n8)
          break;
        const { nextN, offset, isZero: isZero3, isNeg } = calcOffsets(n, window, wo);
        n = nextN;
        if (isZero3) {
          continue;
        } else {
          const item = precomputes[offset];
          acc = acc.add(isNeg ? item.negate() : item);
        }
      }
      assert0(n);
      return acc;
    },
    getPrecomputes(W, P, transform4) {
      let comp = pointPrecomputes2.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          if (typeof transform4 === "function")
            comp = transform4(comp);
          pointPrecomputes2.set(P, comp);
        }
      }
      return comp;
    },
    wNAFCached(P, n, transform4) {
      const W = getW2(P);
      return this.wNAF(W, this.getPrecomputes(W, P, transform4), n);
    },
    wNAFCachedUnsafe(P, n, transform4, prev) {
      const W = getW2(P);
      if (W === 1)
        return this.unsafeLadder(P, n, prev);
      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform4), n, prev);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P, W) {
      validateW2(W, bits);
      pointWindowSizes2.set(P, W);
      pointPrecomputes2.delete(P);
    }
  };
}
function mulEndoUnsafe(c, point, k1, k2) {
  let acc = point;
  let p1 = c.ZERO;
  let p2 = c.ZERO;
  while (k1 > _0n8 || k2 > _0n8) {
    if (k1 & _1n8)
      p1 = p1.add(acc);
    if (k2 & _1n8)
      p2 = p2.add(acc);
    acc = acc.double();
    k1 >>= _1n8;
    k2 >>= _1n8;
  }
  return { p1, p2 };
}
function pippenger2(c, fieldN, points, scalars) {
  validateMSMPoints2(points, c);
  validateMSMScalars2(scalars, fieldN);
  const plength = points.length;
  const slength = scalars.length;
  if (plength !== slength)
    throw new Error("arrays of points and scalars must have equal length");
  const zero3 = c.ZERO;
  const wbits = bitLen2(BigInt(plength));
  let windowSize = 1;
  if (wbits > 12)
    windowSize = wbits - 3;
  else if (wbits > 4)
    windowSize = wbits - 2;
  else if (wbits > 0)
    windowSize = 2;
  const MASK3 = bitMask2(windowSize);
  const buckets = new Array(Number(MASK3) + 1).fill(zero3);
  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
  let sum3 = zero3;
  for (let i = lastBits; i >= 0; i -= windowSize) {
    buckets.fill(zero3);
    for (let j = 0; j < slength; j++) {
      const scalar = scalars[j];
      const wbits2 = Number(scalar >> BigInt(i) & MASK3);
      buckets[wbits2] = buckets[wbits2].add(points[j]);
    }
    let resI = zero3;
    for (let j = buckets.length - 1, sumI = zero3; j > 0; j--) {
      sumI = sumI.add(buckets[j]);
      resI = resI.add(sumI);
    }
    sum3 = sum3.add(resI);
    if (i !== 0)
      for (let j = 0; j < windowSize; j++)
        sum3 = sum3.double();
  }
  return sum3;
}
function createField(order, field) {
  if (field) {
    if (field.ORDER !== order)
      throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
    validateField2(field);
    return field;
  } else {
    return Field2(order);
  }
}
function _createCurveFields(type, CURVE, curveOpts = {}) {
  if (!CURVE || typeof CURVE !== "object")
    throw new Error(`expected valid ${type} CURVE object`);
  for (const p of ["p", "n", "h"]) {
    const val = CURVE[p];
    if (!(typeof val === "bigint" && val > _0n8))
      throw new Error(`CURVE.${p} must be positive bigint`);
  }
  const Fp = createField(CURVE.p, curveOpts.Fp);
  const Fn = createField(CURVE.n, curveOpts.Fn);
  const _b51 = type === "weierstrass" ? "b" : "d";
  const params = ["Gx", "Gy", "a", _b51];
  for (const p of params) {
    if (!Fp.isValid(CURVE[p]))
      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
  }
  return { Fp, Fn };
}

// ../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validateSigVerOpts2(opts) {
  if (opts.lowS !== void 0)
    abool2("lowS", opts.lowS);
  if (opts.prehash !== void 0)
    abool2("prehash", opts.prehash);
}
var DERErr2 = class extends Error {
  constructor(m = "") {
    super(m);
  }
};
var DER2 = {
  // asn.1 DER encoding utils
  Err: DERErr2,
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (tag3, data) => {
      const { Err: E } = DER2;
      if (tag3 < 0 || tag3 > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length & 1)
        throw new E("tlv.encode: unpadded data");
      const dataLen = data.length / 2;
      const len = numberToHexUnpadded2(dataLen);
      if (len.length / 2 & 128)
        throw new E("tlv.encode: long form length too big");
      const lenLen = dataLen > 127 ? numberToHexUnpadded2(len.length / 2 | 128) : "";
      const t = numberToHexUnpadded2(tag3);
      return t + lenLen + len + data;
    },
    // v - value, l - left bytes (unparsed)
    decode(tag3, data) {
      const { Err: E } = DER2;
      let pos = 0;
      if (tag3 < 0 || tag3 > 256)
        throw new E("tlv.encode: wrong tag");
      if (data.length < 2 || data[pos++] !== tag3)
        throw new E("tlv.decode: wrong tlv");
      const first2 = data[pos++];
      const isLong = !!(first2 & 128);
      let length5 = 0;
      if (!isLong)
        length5 = first2;
      else {
        const lenLen = first2 & 127;
        if (!lenLen)
          throw new E("tlv.decode(long): indefinite length not supported");
        if (lenLen > 4)
          throw new E("tlv.decode(long): byte length is too big");
        const lengthBytes = data.subarray(pos, pos + lenLen);
        if (lengthBytes.length !== lenLen)
          throw new E("tlv.decode: length bytes not complete");
        if (lengthBytes[0] === 0)
          throw new E("tlv.decode(long): zero leftmost byte");
        for (const b of lengthBytes)
          length5 = length5 << 8 | b;
        pos += lenLen;
        if (length5 < 128)
          throw new E("tlv.decode(long): not minimal encoding");
      }
      const v = data.subarray(pos, pos + length5);
      if (v.length !== length5)
        throw new E("tlv.decode: wrong value length");
      return { v, l: data.subarray(pos + length5) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(num2) {
      const { Err: E } = DER2;
      if (num2 < _0n9)
        throw new E("integer: negative integers are not allowed");
      let hex = numberToHexUnpadded2(num2);
      if (Number.parseInt(hex[0], 16) & 8)
        hex = "00" + hex;
      if (hex.length & 1)
        throw new E("unexpected DER parsing assertion: unpadded hex");
      return hex;
    },
    decode(data) {
      const { Err: E } = DER2;
      if (data[0] & 128)
        throw new E("invalid signature integer: negative");
      if (data[0] === 0 && !(data[1] & 128))
        throw new E("invalid signature integer: unnecessary leading zero");
      return bytesToNumberBE2(data);
    }
  },
  toSig(hex) {
    const { Err: E, _int: int3, _tlv: tlv } = DER2;
    const data = ensureBytes2("signature", hex);
    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);
    if (seqLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
    const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
    if (sLeftBytes.length)
      throw new E("invalid signature: left bytes after parsing");
    return { r: int3.decode(rBytes), s: int3.decode(sBytes) };
  },
  hexFromSig(sig) {
    const { _tlv: tlv, _int: int3 } = DER2;
    const rs = tlv.encode(2, int3.encode(sig.r));
    const ss = tlv.encode(2, int3.encode(sig.s));
    const seq2 = rs + ss;
    return tlv.encode(48, seq2);
  }
};
var _0n9 = BigInt(0);
var _1n9 = BigInt(1);
var _2n6 = BigInt(2);
var _3n4 = BigInt(3);
var _4n4 = BigInt(4);
function _legacyHelperEquat(Fp, a, b) {
  function weierstrassEquation(x) {
    const x2 = Fp.sqr(x);
    const x3 = Fp.mul(x2, x);
    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
  }
  return weierstrassEquation;
}
function _legacyHelperNormPriv(Fn, allowedPrivateKeyLengths, wrapPrivateKey) {
  const { BYTES: expected } = Fn;
  function normPrivateKeyToScalar(key) {
    let num2;
    if (typeof key === "bigint") {
      num2 = key;
    } else {
      let bytes3 = ensureBytes2("private key", key);
      if (allowedPrivateKeyLengths) {
        if (!allowedPrivateKeyLengths.includes(bytes3.length * 2))
          throw new Error("invalid private key");
        const padded = new Uint8Array(expected);
        padded.set(bytes3, padded.length - bytes3.length);
        bytes3 = padded;
      }
      try {
        num2 = Fn.fromBytes(bytes3);
      } catch (error2) {
        throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
      }
    }
    if (wrapPrivateKey)
      num2 = Fn.create(num2);
    if (!Fn.isValidNot0(num2))
      throw new Error("invalid private key: out of range [1..N-1]");
    return num2;
  }
  return normPrivateKeyToScalar;
}
function weierstrassN(CURVE, curveOpts = {}) {
  const { Fp, Fn } = _createCurveFields("weierstrass", CURVE, curveOpts);
  const { h: cofactor, n: CURVE_ORDER } = CURVE;
  _validateObject(curveOpts, {}, {
    allowInfinityPoint: "boolean",
    clearCofactor: "function",
    isTorsionFree: "function",
    fromBytes: "function",
    toBytes: "function",
    endo: "object",
    wrapPrivateKey: "boolean"
  });
  const { endo } = curveOpts;
  if (endo) {
    if (!Fp.is0(CURVE.a) || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
    }
  }
  function assertCompressionIsSupported() {
    if (!Fp.isOdd)
      throw new Error("compression is not supported: Field does not have .isOdd()");
  }
  function pointToBytes2(_c6, point, isCompressed) {
    const { x, y } = point.toAffine();
    const bx = Fp.toBytes(x);
    abool2("isCompressed", isCompressed);
    if (isCompressed) {
      assertCompressionIsSupported();
      const hasEvenY = !Fp.isOdd(y);
      return concatBytes4(pprefix(hasEvenY), bx);
    } else {
      return concatBytes4(Uint8Array.of(4), bx, Fp.toBytes(y));
    }
  }
  function pointFromBytes(bytes3) {
    abytes3(bytes3);
    const L = Fp.BYTES;
    const LC = L + 1;
    const LU = 2 * L + 1;
    const length5 = bytes3.length;
    const head8 = bytes3[0];
    const tail2 = bytes3.subarray(1);
    if (length5 === LC && (head8 === 2 || head8 === 3)) {
      const x = Fp.fromBytes(tail2);
      if (!Fp.isValid(x))
        throw new Error("bad point: is not on curve, wrong x");
      const y2 = weierstrassEquation(x);
      let y;
      try {
        y = Fp.sqrt(y2);
      } catch (sqrtError) {
        const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
        throw new Error("bad point: is not on curve, sqrt error" + err);
      }
      assertCompressionIsSupported();
      const isYOdd = Fp.isOdd(y);
      const isHeadOdd = (head8 & 1) === 1;
      if (isHeadOdd !== isYOdd)
        y = Fp.neg(y);
      return { x, y };
    } else if (length5 === LU && head8 === 4) {
      const x = Fp.fromBytes(tail2.subarray(L * 0, L * 1));
      const y = Fp.fromBytes(tail2.subarray(L * 1, L * 2));
      if (!isValidXY(x, y))
        throw new Error("bad point: is not on curve");
      return { x, y };
    } else {
      throw new Error(`bad point: got length ${length5}, expected compressed=${LC} or uncompressed=${LU}`);
    }
  }
  const toBytes5 = curveOpts.toBytes || pointToBytes2;
  const fromBytes = curveOpts.fromBytes || pointFromBytes;
  const weierstrassEquation = _legacyHelperEquat(Fp, CURVE.a, CURVE.b);
  function isValidXY(x, y) {
    const left3 = Fp.sqr(y);
    const right3 = weierstrassEquation(x);
    return Fp.eql(left3, right3);
  }
  if (!isValidXY(CURVE.Gx, CURVE.Gy))
    throw new Error("bad curve params: generator point");
  const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n4), _4n4);
  const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
  if (Fp.is0(Fp.add(_4a3, _27b2)))
    throw new Error("bad curve params: a or b");
  function acoord(title, n, banZero = false) {
    if (!Fp.isValid(n) || banZero && Fp.is0(n))
      throw new Error(`bad point coordinate ${title}`);
    return n;
  }
  function aprjpoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized2((p, iz) => {
    const { px: x, py: y, pz: z } = p;
    if (Fp.eql(z, Fp.ONE))
      return { x, y };
    const is0 = p.is0();
    if (iz == null)
      iz = is0 ? Fp.ONE : Fp.inv(z);
    const ax = Fp.mul(x, iz);
    const ay = Fp.mul(y, iz);
    const zz = Fp.mul(z, iz);
    if (is0)
      return { x: Fp.ZERO, y: Fp.ZERO };
    if (!Fp.eql(zz, Fp.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized2((p) => {
    if (p.is0()) {
      if (curveOpts.allowInfinityPoint && !Fp.is0(p.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x, y } = p.toAffine();
    if (!Fp.isValid(x) || !Fp.isValid(y))
      throw new Error("bad point: x or y not field elements");
    if (!isValidXY(x, y))
      throw new Error("bad point: equation left != right");
    if (!p.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
    k2p = new Point3(Fp.mul(k2p.px, endoBeta), k2p.py, k2p.pz);
    k1p = negateCt(k1neg, k1p);
    k2p = negateCt(k2neg, k2p);
    return k1p.add(k2p);
  }
  class Point3 {
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    constructor(px, py, pz) {
      this.px = acoord("x", px);
      this.py = acoord("y", py, true);
      this.pz = acoord("z", pz);
      Object.freeze(this);
    }
    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point3)
        throw new Error("projective point not allowed");
      if (Fp.is0(x) && Fp.is0(y))
        return Point3.ZERO;
      return new Point3(x, y, Fp.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      return normalizeZ(Point3, "pz", points);
    }
    static fromBytes(bytes3) {
      abytes3(bytes3);
      return Point3.fromHex(bytes3);
    }
    /** Converts hash string or Uint8Array to Point. */
    static fromHex(hex) {
      const P = Point3.fromAffine(fromBytes(ensureBytes2("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    /** Multiplies generator point by privateKey. */
    static fromPrivateKey(privateKey) {
      const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
      return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    /** Multiscalar Multiplication */
    static msm(points, scalars) {
      return pippenger2(Point3, Fn, points, scalars);
    }
    /**
     *
     * @param windowSize
     * @param isLazy true will defer table computation until the first multiplication
     * @returns
     */
    precompute(windowSize = 8, isLazy = true) {
      wnaf.setWindowSize(this, windowSize);
      if (!isLazy)
        this.multiply(_3n4);
      return this;
    }
    /** "Private method", don't use it directly */
    _setWindowSize(windowSize) {
      this.precompute(windowSize);
    }
    // TODO: return `this`
    /** A point on curve is valid if it conforms to equation. */
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (!Fp.isOdd)
        throw new Error("Field doesn't support isOdd");
      return !Fp.isOdd(y);
    }
    /** Compare one point to another. */
    equals(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
    negate() {
      return new Point3(this.px, Fp.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp.mul(b, _3n4);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      let t0 = Fp.mul(X1, X1);
      let t1 = Fp.mul(Y1, Y1);
      let t2 = Fp.mul(Z1, Z1);
      let t3 = Fp.mul(X1, Y1);
      t3 = Fp.add(t3, t3);
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a, Z3);
      Y3 = Fp.mul(b3, t2);
      Y3 = Fp.add(X3, Y3);
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t3, X3);
      Z3 = Fp.mul(b3, Z3);
      t2 = Fp.mul(a, t2);
      t3 = Fp.sub(t0, t2);
      t3 = Fp.mul(a, t3);
      t3 = Fp.add(t3, Z3);
      Z3 = Fp.add(t0, t0);
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t2);
      t0 = Fp.mul(t0, t3);
      Y3 = Fp.add(Y3, t0);
      t2 = Fp.mul(Y1, Z1);
      t2 = Fp.add(t2, t2);
      t0 = Fp.mul(t2, t3);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t2, t1);
      Z3 = Fp.add(Z3, Z3);
      Z3 = Fp.add(Z3, Z3);
      return new Point3(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      aprjpoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
      const a = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n4);
      let t0 = Fp.mul(X1, X2);
      let t1 = Fp.mul(Y1, Y2);
      let t2 = Fp.mul(Z1, Z2);
      let t3 = Fp.add(X1, Y1);
      let t4 = Fp.add(X2, Y2);
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t1);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X1, Z1);
      let t5 = Fp.add(X2, Z2);
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t2);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2);
      t5 = Fp.mul(t5, X3);
      X3 = Fp.add(t1, t2);
      t5 = Fp.sub(t5, X3);
      Z3 = Fp.mul(a, t4);
      X3 = Fp.mul(b3, t2);
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t2 = Fp.mul(a, t2);
      t4 = Fp.mul(b3, t4);
      t1 = Fp.add(t1, t2);
      t2 = Fp.sub(t0, t2);
      t2 = Fp.mul(a, t2);
      t4 = Fp.add(t4, t2);
      t0 = Fp.mul(t1, t4);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t5, t4);
      X3 = Fp.mul(t3, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t3, t1);
      Z3 = Fp.mul(t5, Z3);
      Z3 = Fp.add(Z3, t0);
      return new Point3(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo: endo2 } = curveOpts;
      if (!Fn.isValidNot0(scalar))
        throw new Error("invalid scalar: out of range");
      let point, fake;
      const mul3 = (n) => wnaf.wNAFCached(this, n, Point3.normalizeZ);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(scalar);
        const { p: k1p, f: k1f } = mul3(k1);
        const { p: k2p, f: k2f } = mul3(k2);
        fake = k1f.add(k2f);
        point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
      } else {
        const { p, f } = mul3(scalar);
        point = p;
        fake = f;
      }
      return Point3.normalizeZ([point, fake])[0];
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      const { endo: endo2 } = curveOpts;
      const p = this;
      if (!Fn.isValid(sc))
        throw new Error("invalid scalar: out of range");
      if (sc === _0n9 || p.is0())
        return Point3.ZERO;
      if (sc === _1n9)
        return p;
      if (wnaf.hasPrecomputes(this))
        return this.multiply(sc);
      if (endo2) {
        const { k1neg, k1, k2neg, k2 } = endo2.splitScalar(sc);
        const { p1, p2 } = mulEndoUnsafe(Point3, p, k1, k2);
        return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);
      } else {
        return wnaf.wNAFCachedUnsafe(p, sc);
      }
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const sum3 = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
      return sum3.is0() ? void 0 : sum3;
    }
    /**
     * Converts Projective point to affine (x, y) coordinates.
     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
     */
    toAffine(invertedZ) {
      return toAffineMemo(this, invertedZ);
    }
    /**
     * Checks whether Point is free of torsion elements (is in prime subgroup).
     * Always torsion-free for cofactor=1 curves.
     */
    isTorsionFree() {
      const { isTorsionFree } = curveOpts;
      if (cofactor === _1n9)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point3, this);
      return wnaf.wNAFCachedUnsafe(this, CURVE_ORDER).is0();
    }
    clearCofactor() {
      const { clearCofactor } = curveOpts;
      if (cofactor === _1n9)
        return this;
      if (clearCofactor)
        return clearCofactor(Point3, this);
      return this.multiplyUnsafe(cofactor);
    }
    toBytes(isCompressed = true) {
      abool2("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes5(Point3, this, isCompressed);
    }
    /** @deprecated use `toBytes` */
    toRawBytes(isCompressed = true) {
      return this.toBytes(isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex4(this.toBytes(isCompressed));
    }
    toString() {
      return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
    }
  }
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp.ONE);
  Point3.ZERO = new Point3(Fp.ZERO, Fp.ONE, Fp.ZERO);
  Point3.Fp = Fp;
  Point3.Fn = Fn;
  const bits = Fn.BITS;
  const wnaf = wNAF2(Point3, curveOpts.endo ? Math.ceil(bits / 2) : bits);
  return Point3;
}
function pprefix(hasEvenY) {
  return Uint8Array.of(hasEvenY ? 2 : 3);
}
function ecdsa(Point3, ecdsaOpts, curveOpts = {}) {
  _validateObject(ecdsaOpts, { hash: "function" }, {
    hmac: "function",
    lowS: "boolean",
    randomBytes: "function",
    bits2int: "function",
    bits2int_modN: "function"
  });
  const randomBytes_ = ecdsaOpts.randomBytes || randomBytes3;
  const hmac_ = ecdsaOpts.hmac || ((key, ...msgs) => hmac2(ecdsaOpts.hash, key, concatBytes4(...msgs)));
  const { Fp, Fn } = Point3;
  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
  function isBiggerThanHalfOrder(number7) {
    const HALF = CURVE_ORDER >> _1n9;
    return number7 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? Fn.neg(s) : s;
  }
  function aValidRS(title, num2) {
    if (!Fn.isValidNot0(num2))
      throw new Error(`invalid signature ${title}: out of range 1..CURVE.n`);
  }
  class Signature2 {
    constructor(r, s, recovery) {
      aValidRS("r", r);
      aValidRS("s", s);
      this.r = r;
      this.s = s;
      if (recovery != null)
        this.recovery = recovery;
      Object.freeze(this);
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex) {
      const L = Fn.BYTES;
      const b = ensureBytes2("compactSignature", hex, L * 2);
      return new Signature2(Fn.fromBytes(b.subarray(0, L)), Fn.fromBytes(b.subarray(L, L * 2)));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex) {
      const { r, s } = DER2.toSig(ensureBytes2("DER", hex));
      return new Signature2(r, s);
    }
    /**
     * @todo remove
     * @deprecated
     */
    assertValidity() {
    }
    addRecoveryBit(recovery) {
      return new Signature2(this.r, this.s, recovery);
    }
    // ProjPointType<bigint>
    recoverPublicKey(msgHash) {
      const FIELD_ORDER = Fp.ORDER;
      const { r, s, recovery: rec } = this;
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const hasCofactor = CURVE_ORDER * _2n6 < FIELD_ORDER;
      if (hasCofactor && rec > 1)
        throw new Error("recovery id is ambiguous for h>1 curve");
      const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
      if (!Fp.isValid(radj))
        throw new Error("recovery id 2 or 3 invalid");
      const x = Fp.toBytes(radj);
      const R = Point3.fromHex(concatBytes4(pprefix((rec & 1) === 0), x));
      const ir = Fn.inv(radj);
      const h = bits2int_modN(ensureBytes2("msgHash", msgHash));
      const u1 = Fn.create(-h * ir);
      const u2 = Fn.create(s * ir);
      const Q = Point3.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
      if (Q.is0())
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature2(this.r, Fn.neg(this.s), this.recovery) : this;
    }
    toBytes(format8) {
      if (format8 === "compact")
        return concatBytes4(Fn.toBytes(this.r), Fn.toBytes(this.s));
      if (format8 === "der")
        return hexToBytes3(DER2.hexFromSig(this));
      throw new Error("invalid format");
    }
    // DER-encoded
    toDERRawBytes() {
      return this.toBytes("der");
    }
    toDERHex() {
      return bytesToHex4(this.toBytes("der"));
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return this.toBytes("compact");
    }
    toCompactHex() {
      return bytesToHex4(this.toBytes("compact"));
    }
  }
  const normPrivateKeyToScalar = _legacyHelperNormPriv(Fn, curveOpts.allowedPrivateKeyLengths, curveOpts.wrapPrivateKey);
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error2) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const n = CURVE_ORDER;
      return mapHashToField2(randomBytes_(getMinHashLength2(n)), n);
    },
    precompute(windowSize = 8, point = Point3.BASE) {
      return point.precompute(windowSize, false);
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point3.fromPrivateKey(privateKey).toBytes(isCompressed);
  }
  function isProbPub(item) {
    if (typeof item === "bigint")
      return false;
    if (item instanceof Point3)
      return true;
    const arr = ensureBytes2("key", item);
    const length5 = arr.length;
    const L = Fp.BYTES;
    const LC = L + 1;
    const LU = 2 * L + 1;
    if (curveOpts.allowedPrivateKeyLengths || Fn.BYTES === LC) {
      return void 0;
    } else {
      return length5 === LC || length5 === LU;
    }
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA) === true)
      throw new Error("first arg must be private key");
    if (isProbPub(publicB) === false)
      throw new Error("second arg must be public key");
    const b = Point3.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toBytes(isCompressed);
  }
  const bits2int = ecdsaOpts.bits2int || function(bytes3) {
    if (bytes3.length > 8192)
      throw new Error("input is too large");
    const num2 = bytesToNumberBE2(bytes3);
    const delta = bytes3.length * 8 - fnBits;
    return delta > 0 ? num2 >> BigInt(delta) : num2;
  };
  const bits2int_modN = ecdsaOpts.bits2int_modN || function(bytes3) {
    return Fn.create(bits2int(bytes3));
  };
  const ORDER_MASK = bitMask2(fnBits);
  function int2octets(num2) {
    aInRange2("num < 2^" + fnBits, num2, _0n9, ORDER_MASK);
    return Fn.toBytes(num2);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash4 } = ecdsaOpts;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes2("msgHash", msgHash);
    validateSigVerOpts2(opts);
    if (prehash)
      msgHash = ensureBytes2("prehashed msgHash", hash4(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e = ent === true ? randomBytes_(Fp.BYTES) : ent;
      seedArgs.push(ensureBytes2("extraEntropy", e));
    }
    const seed = concatBytes4(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!Fn.isValidNot0(k))
        return;
      const ik = Fn.inv(k);
      const q = Point3.BASE.multiply(k).toAffine();
      const r = Fn.create(q.x);
      if (r === _0n9)
        return;
      const s = Fn.create(ik * Fn.create(m + r * d));
      if (s === _0n9)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n9);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature2(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: ecdsaOpts.lowS, prehash: false };
  const defaultVerOpts = { lowS: ecdsaOpts.lowS, prehash: false };
  function sign2(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const drbg = createHmacDrbg2(ecdsaOpts.hash.outputLen, Fn.BYTES, hmac_);
    return drbg(seed, k2sig);
  }
  Point3.BASE.precompute(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes2("msgHash", msgHash);
    publicKey = ensureBytes2("publicKey", publicKey);
    validateSigVerOpts2(opts);
    const { lowS, prehash, format: format8 } = opts;
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    if (format8 !== void 0 && !["compact", "der", "js"].includes(format8))
      throw new Error('format must be "compact", "der" or "js"');
    const isHex = typeof sg === "string" || isBytes6(sg);
    const isObj = !isHex && !format8 && typeof sg === "object" && sg !== null && typeof sg.r === "bigint" && typeof sg.s === "bigint";
    if (!isHex && !isObj)
      throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let _sig = void 0;
    let P;
    try {
      if (isObj) {
        if (format8 === void 0 || format8 === "js") {
          _sig = new Signature2(sg.r, sg.s);
        } else {
          throw new Error("invalid format");
        }
      }
      if (isHex) {
        try {
          if (format8 !== "compact")
            _sig = Signature2.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER2.Err))
            throw derError;
        }
        if (!_sig && format8 !== "der")
          _sig = Signature2.fromCompact(sg);
      }
      P = Point3.fromHex(publicKey);
    } catch (error2) {
      return false;
    }
    if (!_sig)
      return false;
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = ecdsaOpts.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is4 = Fn.inv(s);
    const u1 = Fn.create(h * is4);
    const u2 = Fn.create(r * is4);
    const R = Point3.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));
    if (R.is0())
      return false;
    const v = Fn.create(R.x);
    return v === r;
  }
  return Object.freeze({
    getPublicKey,
    getSharedSecret,
    sign: sign2,
    verify,
    utils: utils2,
    Point: Point3,
    Signature: Signature2
  });
}
function _weierstrass_legacy_opts_to_new(c) {
  const CURVE = {
    a: c.a,
    b: c.b,
    p: c.Fp.ORDER,
    n: c.n,
    h: c.h,
    Gx: c.Gx,
    Gy: c.Gy
  };
  const Fp = c.Fp;
  const Fn = Field2(CURVE.n, c.nBitLength);
  const curveOpts = {
    Fp,
    Fn,
    allowedPrivateKeyLengths: c.allowedPrivateKeyLengths,
    allowInfinityPoint: c.allowInfinityPoint,
    endo: c.endo,
    wrapPrivateKey: c.wrapPrivateKey,
    isTorsionFree: c.isTorsionFree,
    clearCofactor: c.clearCofactor,
    fromBytes: c.fromBytes,
    toBytes: c.toBytes
  };
  return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c) {
  const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
  const ecdsaOpts = {
    hash: c.hash,
    hmac: c.hmac,
    randomBytes: c.randomBytes,
    lowS: c.lowS,
    bits2int: c.bits2int,
    bits2int_modN: c.bits2int_modN
  };
  return { CURVE, curveOpts, ecdsaOpts };
}
function _ecdsa_new_output_to_legacy(c, ecdsa2) {
  return Object.assign({}, ecdsa2, {
    ProjectivePoint: ecdsa2.Point,
    CURVE: c
  });
}
function weierstrass2(c) {
  const { CURVE, curveOpts, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
  const Point3 = weierstrassN(CURVE, curveOpts);
  const signs = ecdsa(Point3, ecdsaOpts, curveOpts);
  return _ecdsa_new_output_to_legacy(c, signs);
}

// ../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/esm/_shortw_utils.js
function createCurve2(curveDef, defHash) {
  const create = (hash4) => weierstrass2({ ...curveDef, hash: hash4 });
  return { ...create(defHash), create };
}

// ../../node_modules/.pnpm/@noble+curves@1.9.2/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1_CURVE = {
  p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: BigInt(1),
  a: BigInt(0),
  b: BigInt(7),
  Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
  Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
};
var _0n10 = BigInt(0);
var _1n10 = BigInt(1);
var _2n7 = BigInt(2);
var divNearest2 = (a, b) => (a + b / _2n7) / b;
function sqrtMod2(y) {
  const P = secp256k1_CURVE.p;
  const _3n5 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow22(b3, _3n5, P) * b3 % P;
  const b9 = pow22(b6, _3n5, P) * b3 % P;
  const b11 = pow22(b9, _2n7, P) * b2 % P;
  const b22 = pow22(b11, _11n, P) * b11 % P;
  const b44 = pow22(b22, _22n, P) * b22 % P;
  const b88 = pow22(b44, _44n, P) * b44 % P;
  const b176 = pow22(b88, _88n, P) * b88 % P;
  const b220 = pow22(b176, _44n, P) * b44 % P;
  const b223 = pow22(b220, _3n5, P) * b3 % P;
  const t1 = pow22(b223, _23n, P) * b22 % P;
  const t2 = pow22(t1, _6n, P) * b2 % P;
  const root = pow22(t2, _2n7, P);
  if (!Fpk12.eql(Fpk12.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fpk12 = Field2(secp256k1_CURVE.p, void 0, void 0, { sqrt: sqrtMod2 });
var secp256k12 = createCurve2({
  ...secp256k1_CURVE,
  Fp: Fpk12,
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  endo: {
    // Endomorphism, see above
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1_CURVE.n;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n10 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest2(b2 * k, n);
      const c2 = divNearest2(-b1 * k, n);
      let k1 = mod2(k - c1 * a1 - c2 * a2, n);
      let k2 = mod2(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha2563);

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/legacy.js
var Rho160 = /* @__PURE__ */ Uint8Array.from([
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8
]);
var Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
var Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();
var idxLR = /* @__PURE__ */ (() => {
  const L = [Id160];
  const R = [Pi160];
  const res = [L, R];
  for (let i = 0; i < 4; i++)
    for (let j of res)
      j.push(j[i].map((k) => Rho160[k]));
  return res;
})();
var idxL = /* @__PURE__ */ (() => idxLR[0])();
var idxR = /* @__PURE__ */ (() => idxLR[1])();
var shifts160 = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => Uint8Array.from(i));
var shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
var shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
var Kl160 = /* @__PURE__ */ Uint32Array.from([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr160 = /* @__PURE__ */ Uint32Array.from([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function ripemd_f(group, x, y, z) {
  if (group === 0)
    return x ^ y ^ z;
  if (group === 1)
    return x & y | ~x & z;
  if (group === 2)
    return (x | ~y) ^ z;
  if (group === 3)
    return x & z | y & ~z;
  return x ^ (y | ~z);
}
var BUF_160 = /* @__PURE__ */ new Uint32Array(16);
var RIPEMD160 = class extends HashMD2 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0; i < 16; i++, offset += 4)
      BUF_160[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl160[group], hbr = Kr160[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL160[group], sr = shiftsR160[group];
      for (let i = 0; i < 16; i++) {
        const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0; i < 16; i++) {
        const tr = rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    clean(BUF_160);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = /* @__PURE__ */ createHasher(() => new RIPEMD160());

// ../../node_modules/.pnpm/@scure+base@1.2.6/node_modules/@scure/base/lib/esm/index.js
function isBytes7(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function isArrayOf2(isString2, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString2) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn2(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr2(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber4(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`invalid integer: ${n}`);
}
function aArr2(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr2(label, input) {
  if (!isArrayOf2(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr2(label, input) {
  if (!isArrayOf2(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
// @__NO_SIDE_EFFECTS__
function chain2(...args2) {
  const id3 = (a) => a;
  const wrap = (a, b) => (c) => a(b(c));
  const encode6 = args2.map((x) => x.encode).reduceRight(wrap, id3);
  const decode7 = args2.map((x) => x.decode).reduce(wrap, id3);
  return { encode: encode6, decode: decode7 };
}
// @__NO_SIDE_EFFECTS__
function alphabet2(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr2("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l, i) => [l, i]));
  return {
    encode: (digits) => {
      aArr2(digits);
      return digits.map((i) => {
        if (!Number.isSafeInteger(i) || i < 0 || i >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
        return lettersA[i];
      });
    },
    decode: (input) => {
      aArr2(input);
      return input.map((letter) => {
        astr2("alphabet.decode", letter);
        const i = indexes.get(letter);
        if (i === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i;
      });
    }
  };
}
// @__NO_SIDE_EFFECTS__
function join6(separator = "") {
  astr2("join", separator);
  return {
    encode: (from) => {
      astrArr2("join.decode", from);
      return from.join(separator);
    },
    decode: (to) => {
      astr2("join.decode", to);
      return to.split(separator);
    }
  };
}
// @__NO_SIDE_EFFECTS__
function padding2(bits, chr = "=") {
  anumber4(bits);
  astr2("padding", chr);
  return {
    encode(data) {
      astrArr2("padding.encode", data);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr2("padding.decode", input);
      let end6 = input.length;
      if (end6 * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end6 > 0 && input[end6 - 1] === chr; end6--) {
        const last5 = end6 - 1;
        const byte = last5 * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end6);
    }
  };
}
function convertRadix(data, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
  aArr2(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d) => {
    anumber4(d);
    if (d < 0 || d >= from)
      throw new Error(`invalid integer: ${d}`);
    return d;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done12 = true;
    for (let i = pos; i < dlen; i++) {
      const digit = digits[i];
      const fromCarry = from * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to;
      carry = digitBase % to;
      const rounded = Math.floor(div);
      digits[i] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done12)
        continue;
      else if (!rounded)
        pos = i;
      else
        done12 = false;
    }
    res.push(carry);
    if (done12)
      break;
  }
  for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
    res.push(0);
  return res.reverse();
}
var gcd2 = (a, b) => b === 0 ? a : gcd2(b, a % b);
var radix2carry2 = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd2(from, to));
var powers2 = /* @__PURE__ */ (() => {
  let res = [];
  for (let i = 0; i < 40; i++)
    res.push(2 ** i);
  return res;
})();
function convertRadix22(data, from, to, padding3) {
  aArr2(data);
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (/* @__PURE__ */ radix2carry2(from, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${/* @__PURE__ */ radix2carry2(from, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const max7 = powers2[from];
  const mask = powers2[to] - 1;
  const res = [];
  for (const n of data) {
    anumber4(n);
    if (n >= max7)
      throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
    carry = carry << from | n;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    const pow3 = powers2[pos];
    if (pow3 === void 0)
      throw new Error("invalid carry");
    carry &= pow3 - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding3 && pos >= from)
    throw new Error("Excess padding");
  if (!padding3 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding3 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
// @__NO_SIDE_EFFECTS__
function radix(num2) {
  anumber4(num2);
  const _256 = 2 ** 8;
  return {
    encode: (bytes3) => {
      if (!isBytes7(bytes3))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes3), _256, num2);
    },
    decode: (digits) => {
      anumArr2("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num2, _256));
    }
  };
}
// @__NO_SIDE_EFFECTS__
function radix22(bits, revPadding = false) {
  anumber4(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (/* @__PURE__ */ radix2carry2(8, bits) > 32 || /* @__PURE__ */ radix2carry2(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes3) => {
      if (!isBytes7(bytes3))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix22(Array.from(bytes3), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr2("radix2.decode", digits);
      return Uint8Array.from(convertRadix22(digits, bits, 8, revPadding));
    }
  };
}
function checksum(len, fn2) {
  anumber4(len);
  afn2(fn2);
  return {
    encode(data) {
      if (!isBytes7(data))
        throw new Error("checksum.encode: input should be Uint8Array");
      const sum3 = fn2(data).slice(0, len);
      const res = new Uint8Array(data.length + len);
      res.set(data);
      res.set(sum3, data.length);
      return res;
    },
    decode(data) {
      if (!isBytes7(data))
        throw new Error("checksum.decode: input should be Uint8Array");
      const payload = data.slice(0, -len);
      const oldChecksum = data.slice(-len);
      const newChecksum = fn2(payload).slice(0, len);
      for (let i = 0; i < len; i++)
        if (newChecksum[i] !== oldChecksum[i])
          throw new Error("Invalid checksum");
      return payload;
    }
  };
}
var utils = {
  alphabet: alphabet2,
  chain: chain2,
  checksum,
  convertRadix,
  convertRadix2: convertRadix22,
  radix,
  radix2: radix22,
  join: join6,
  padding: padding2
};
var genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => /* @__PURE__ */ chain2(/* @__PURE__ */ radix(58), /* @__PURE__ */ alphabet2(abc), /* @__PURE__ */ join6(""));
var base58 = /* @__PURE__ */ genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var createBase58check = (sha2564) => /* @__PURE__ */ chain2(checksum(4, (data) => sha2564(sha2564(data))), base58);

// ../../node_modules/.pnpm/@scure+bip32@1.7.0/node_modules/@scure/bip32/lib/esm/index.js
var Point2 = secp256k12.ProjectivePoint;
var base58check = createBase58check(sha2563);
function bytesToNumber(bytes3) {
  abytes3(bytes3);
  const h = bytes3.length === 0 ? "0" : bytesToHex4(bytes3);
  return BigInt("0x" + h);
}
function numberToBytes(num2) {
  if (typeof num2 !== "bigint")
    throw new Error("bigint expected");
  return hexToBytes3(num2.toString(16).padStart(64, "0"));
}
var MASTER_SECRET = utf8ToBytes4("Bitcoin seed");
var BITCOIN_VERSIONS = { private: 76066276, public: 76067358 };
var HARDENED_OFFSET = 2147483648;
var hash160 = (data) => ripemd160(sha2563(data));
var fromU32 = (data) => createView3(data).getUint32(0, false);
var toU32 = (n) => {
  if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {
    throw new Error("invalid number, should be from 0 to 2**32-1, got " + n);
  }
  const buf = new Uint8Array(4);
  createView3(buf).setUint32(0, n, false);
  return buf;
};
var HDKey = class _HDKey {
  get fingerprint() {
    if (!this.pubHash) {
      throw new Error("No publicKey set!");
    }
    return fromU32(this.pubHash);
  }
  get identifier() {
    return this.pubHash;
  }
  get pubKeyHash() {
    return this.pubHash;
  }
  get privateKey() {
    return this.privKeyBytes || null;
  }
  get publicKey() {
    return this.pubKey || null;
  }
  get privateExtendedKey() {
    const priv = this.privateKey;
    if (!priv) {
      throw new Error("No private key");
    }
    return base58check.encode(this.serialize(this.versions.private, concatBytes4(new Uint8Array([0]), priv)));
  }
  get publicExtendedKey() {
    if (!this.pubKey) {
      throw new Error("No public key");
    }
    return base58check.encode(this.serialize(this.versions.public, this.pubKey));
  }
  static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
    abytes3(seed);
    if (8 * seed.length < 128 || 8 * seed.length > 512) {
      throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got " + seed.length);
    }
    const I = hmac2(sha512, MASTER_SECRET, seed);
    return new _HDKey({
      versions,
      chainCode: I.slice(32),
      privateKey: I.slice(0, 32)
    });
  }
  static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
    const keyBuffer = base58check.decode(base58key);
    const keyView = createView3(keyBuffer);
    const version = keyView.getUint32(0, false);
    const opt = {
      versions,
      depth: keyBuffer[4],
      parentFingerprint: keyView.getUint32(5, false),
      index: keyView.getUint32(9, false),
      chainCode: keyBuffer.slice(13, 45)
    };
    const key = keyBuffer.slice(45);
    const isPriv = key[0] === 0;
    if (version !== versions[isPriv ? "private" : "public"]) {
      throw new Error("Version mismatch");
    }
    if (isPriv) {
      return new _HDKey({ ...opt, privateKey: key.slice(1) });
    } else {
      return new _HDKey({ ...opt, publicKey: key });
    }
  }
  static fromJSON(json2) {
    return _HDKey.fromExtendedKey(json2.xpriv);
  }
  constructor(opt) {
    this.depth = 0;
    this.index = 0;
    this.chainCode = null;
    this.parentFingerprint = 0;
    if (!opt || typeof opt !== "object") {
      throw new Error("HDKey.constructor must not be called directly");
    }
    this.versions = opt.versions || BITCOIN_VERSIONS;
    this.depth = opt.depth || 0;
    this.chainCode = opt.chainCode || null;
    this.index = opt.index || 0;
    this.parentFingerprint = opt.parentFingerprint || 0;
    if (!this.depth) {
      if (this.parentFingerprint || this.index) {
        throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
      }
    }
    if (opt.publicKey && opt.privateKey) {
      throw new Error("HDKey: publicKey and privateKey at same time.");
    }
    if (opt.privateKey) {
      if (!secp256k12.utils.isValidPrivateKey(opt.privateKey)) {
        throw new Error("Invalid private key");
      }
      this.privKey = typeof opt.privateKey === "bigint" ? opt.privateKey : bytesToNumber(opt.privateKey);
      this.privKeyBytes = numberToBytes(this.privKey);
      this.pubKey = secp256k12.getPublicKey(opt.privateKey, true);
    } else if (opt.publicKey) {
      this.pubKey = Point2.fromHex(opt.publicKey).toRawBytes(true);
    } else {
      throw new Error("HDKey: no public or private key provided");
    }
    this.pubHash = hash160(this.pubKey);
  }
  derive(path) {
    if (!/^[mM]'?/.test(path)) {
      throw new Error('Path must start with "m" or "M"');
    }
    if (/^[mM]'?$/.test(path)) {
      return this;
    }
    const parts2 = path.replace(/^[mM]'?\//, "").split("/");
    let child = this;
    for (const c of parts2) {
      const m = /^(\d+)('?)$/.exec(c);
      const m1 = m && m[1];
      if (!m || m.length !== 3 || typeof m1 !== "string")
        throw new Error("invalid child index: " + c);
      let idx = +m1;
      if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {
        throw new Error("Invalid index");
      }
      if (m[2] === "'") {
        idx += HARDENED_OFFSET;
      }
      child = child.deriveChild(idx);
    }
    return child;
  }
  deriveChild(index) {
    if (!this.pubKey || !this.chainCode) {
      throw new Error("No publicKey or chainCode set");
    }
    let data = toU32(index);
    if (index >= HARDENED_OFFSET) {
      const priv = this.privateKey;
      if (!priv) {
        throw new Error("Could not derive hardened child key");
      }
      data = concatBytes4(new Uint8Array([0]), priv, data);
    } else {
      data = concatBytes4(this.pubKey, data);
    }
    const I = hmac2(sha512, this.chainCode, data);
    const childTweak = bytesToNumber(I.slice(0, 32));
    const chainCode = I.slice(32);
    if (!secp256k12.utils.isValidPrivateKey(childTweak)) {
      throw new Error("Tweak bigger than curve order");
    }
    const opt = {
      versions: this.versions,
      chainCode,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint,
      index
    };
    try {
      if (this.privateKey) {
        const added = mod2(this.privKey + childTweak, secp256k12.CURVE.n);
        if (!secp256k12.utils.isValidPrivateKey(added)) {
          throw new Error("The tweak was out of range or the resulted private key is invalid");
        }
        opt.privateKey = added;
      } else {
        const added = Point2.fromHex(this.pubKey).add(Point2.fromPrivateKey(childTweak));
        if (added.equals(Point2.ZERO)) {
          throw new Error("The tweak was equal to negative P, which made the result key invalid");
        }
        opt.publicKey = added.toRawBytes(true);
      }
      return new _HDKey(opt);
    } catch (err) {
      return this.deriveChild(index + 1);
    }
  }
  sign(hash4) {
    if (!this.privateKey) {
      throw new Error("No privateKey set!");
    }
    abytes3(hash4, 32);
    return secp256k12.sign(hash4, this.privKey).toCompactRawBytes();
  }
  verify(hash4, signature) {
    abytes3(hash4, 32);
    abytes3(signature, 64);
    if (!this.publicKey) {
      throw new Error("No publicKey set!");
    }
    let sig;
    try {
      sig = secp256k12.Signature.fromCompact(signature);
    } catch (error2) {
      return false;
    }
    return secp256k12.verify(sig, hash4, this.publicKey);
  }
  wipePrivateData() {
    this.privKey = void 0;
    if (this.privKeyBytes) {
      this.privKeyBytes.fill(0);
      this.privKeyBytes = void 0;
    }
    return this;
  }
  toJSON() {
    return {
      xpriv: this.privateExtendedKey,
      xpub: this.publicExtendedKey
    };
  }
  serialize(version, key) {
    if (!this.chainCode) {
      throw new Error("No chainCode set");
    }
    abytes3(key, 33);
    return concatBytes4(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
  }
};

// ../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash4, _password, _salt, _opts) {
  ahash2(hash4);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  anumber3(c);
  anumber3(dkLen);
  anumber3(asyncTick);
  if (c < 1)
    throw new Error("iterations (c) should be >= 1");
  const password = kdfInputToBytes(_password);
  const salt = kdfInputToBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac2.create(hash4, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  clean(u);
  return DK;
}
function pbkdf2(hash4, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash4, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView3(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1; ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0; i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

// ../../node_modules/.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/esm/index.js
var isJapanese = (wordlist2) => wordlist2[0] === "\u3042\u3044\u3053\u304F\u3057\u3093";
function nfkd(str) {
  if (typeof str !== "string")
    throw new TypeError("invalid mnemonic type: " + typeof str);
  return str.normalize("NFKD");
}
function normalize2(str) {
  const norm = nfkd(str);
  const words = norm.split(" ");
  if (![12, 15, 18, 21, 24].includes(words.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: norm, words };
}
function aentropy(ent) {
  abytes3(ent, 16, 20, 24, 28, 32);
}
var calcChecksum = (entropy) => {
  const bitsLeft = 8 - entropy.length / 4;
  return new Uint8Array([sha2563(entropy)[0] >> bitsLeft << bitsLeft]);
};
function getCoder(wordlist2) {
  if (!Array.isArray(wordlist2) || wordlist2.length !== 2048 || typeof wordlist2[0] !== "string")
    throw new Error("Wordlist: expected array of 2048 strings");
  wordlist2.forEach((i) => {
    if (typeof i !== "string")
      throw new Error("wordlist: non-string element: " + i);
  });
  return utils.chain(utils.checksum(1, calcChecksum), utils.radix2(11, true), utils.alphabet(wordlist2));
}
function mnemonicToEntropy(mnemonic, wordlist2) {
  const { words } = normalize2(mnemonic);
  const entropy = getCoder(wordlist2).decode(words);
  aentropy(entropy);
  return entropy;
}
function entropyToMnemonic(entropy, wordlist2) {
  aentropy(entropy);
  const words = getCoder(wordlist2).encode(entropy);
  return words.join(isJapanese(wordlist2) ? "\u3000" : " ");
}
function validateMnemonic(mnemonic, wordlist2) {
  try {
    mnemonicToEntropy(mnemonic, wordlist2);
  } catch (e) {
    return false;
  }
  return true;
}
var psalt = (passphrase) => nfkd("mnemonic" + passphrase);
function mnemonicToSeedSync(mnemonic, passphrase = "") {
  return pbkdf2(sha512, normalize2(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
}

// ../../node_modules/.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/esm/wordlists/english.js
var wordlist = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split("\n");

// ../../packages/nostr/src/nip06/Nip06Service.ts
var Nip06Service = class extends Context_exports.Tag("nostr/Nip06Service")() {
};
var Nip06ServiceLive = Layer_exports.effect(
  Nip06Service,
  Effect_exports.gen(function* () {
    const crypto4 = yield* CryptoService;
    const generateMnemonic = (wordCount = 12) => Effect_exports.try({
      try: () => {
        const entropyBytesMap = {
          12: 16,
          // 128 bits
          15: 20,
          // 160 bits
          18: 24,
          // 192 bits
          21: 28,
          // 224 bits
          24: 32
          // 256 bits
        };
        const entropyBytes = entropyBytesMap[wordCount];
        if (!entropyBytes) {
          throw new Error(`Invalid word count: ${wordCount}`);
        }
        const entropy = randomBytes2(entropyBytes);
        const mnemonic = entropyToMnemonic(entropy, wordlist);
        return mnemonic;
      },
      catch: (error2) => new Nip06Error({
        operation: "generateMnemonic",
        reason: `Failed to generate mnemonic: ${String(error2)}`
      })
    });
    const validateMnemonic2 = (mnemonic) => Effect_exports.try({
      try: () => validateMnemonic(mnemonic, wordlist),
      catch: (error2) => new Nip06Error({
        operation: "validateMnemonic",
        reason: `Failed to validate mnemonic: ${String(error2)}`
      })
    });
    const getDerivationPath = (account = 0) => Effect_exports.try({
      try: () => `m/44'/1237'/${account}'/0/0`,
      catch: (error2) => new Nip06Error({
        operation: "deriveKey",
        reason: `Failed to create derivation path: ${String(error2)}`
      })
    });
    const derivePrivateKey = (mnemonic, account = 0) => Effect_exports.gen(function* () {
      const isValid2 = yield* validateMnemonic2(mnemonic);
      if (!isValid2) {
        return yield* new InvalidMnemonic({
          mnemonic,
          reason: "Invalid BIP39 mnemonic phrase"
        });
      }
      const path = yield* getDerivationPath(account);
      return yield* Effect_exports.try({
        try: () => {
          const seed = mnemonicToSeedSync(mnemonic);
          const masterKey = HDKey.fromMasterSeed(seed);
          const derived = masterKey.derive(path);
          if (!derived.privateKey) {
            throw new Error("Failed to derive private key");
          }
          return bytesToHex3(derived.privateKey);
        },
        catch: (error2) => new KeyDerivationError({
          path,
          reason: `Key derivation failed: ${String(error2)}`
        })
      });
    });
    const derivePublicKey = (privateKey) => crypto4.getPublicKey(privateKey).pipe(
      Effect_exports.mapError(
        (error2) => new Nip06Error({
          operation: "deriveKey",
          reason: `Failed to derive public key: ${String(error2)}`
        })
      )
    );
    const encodeNsec = (privateKey) => Effect_exports.try({
      try: () => {
        const bytes3 = hexToBytes2(privateKey);
        const words = bech32.toWords(bytes3);
        const encoded = bech32.encode("nsec", words);
        return encoded;
      },
      catch: (error2) => new Nip06Error({
        operation: "encodeKey",
        reason: `Failed to encode nsec: ${String(error2)}`
      })
    });
    const encodeNpub = (publicKey) => Effect_exports.try({
      try: () => {
        const bytes3 = hexToBytes2(publicKey);
        const words = bech32.toWords(bytes3);
        const encoded = bech32.encode("npub", words);
        return encoded;
      },
      catch: (error2) => new Nip06Error({
        operation: "encodeKey",
        reason: `Failed to encode npub: ${String(error2)}`
      })
    });
    const decodeNsec = (nsec) => Effect_exports.try({
      try: () => {
        const nsecStr = nsec;
        const { prefix, words } = bech32.decode(nsecStr, 90);
        if (prefix !== "nsec") {
          throw new Error(`Invalid prefix: expected 'nsec', got '${prefix}'`);
        }
        const bytes3 = bech32.fromWords(words);
        return bytesToHex3(new Uint8Array(bytes3));
      },
      catch: (error2) => new Nip06Error({
        operation: "decodeKey",
        reason: `Failed to decode nsec: ${String(error2)}`
      })
    });
    const decodeNpub = (npub) => Effect_exports.try({
      try: () => {
        const npubStr = npub;
        const { prefix, words } = bech32.decode(npubStr, 90);
        if (prefix !== "npub") {
          throw new Error(`Invalid prefix: expected 'npub', got '${prefix}'`);
        }
        const bytes3 = bech32.fromWords(words);
        return bytesToHex3(new Uint8Array(bytes3));
      },
      catch: (error2) => new Nip06Error({
        operation: "decodeKey",
        reason: `Failed to decode npub: ${String(error2)}`
      })
    });
    const deriveAllKeys = (mnemonic, account = 0) => Effect_exports.gen(function* () {
      const privateKey = yield* derivePrivateKey(mnemonic, account);
      const publicKey = yield* derivePublicKey(privateKey);
      const nsec = yield* encodeNsec(privateKey);
      const npub = yield* encodeNpub(publicKey);
      return new KeyDerivationResult({
        privateKey,
        publicKey,
        nsec,
        npub
      });
    });
    return {
      generateMnemonic,
      validateMnemonic: validateMnemonic2,
      derivePrivateKey,
      derivePublicKey,
      encodeNsec,
      encodeNpub,
      decodeNsec,
      decodeNpub,
      deriveAllKeys,
      getDerivationPath
    };
  })
);

// ../../packages/nostr/src/nip28/Nip28Service.ts
var Nip28InvalidInputError = class extends Data_exports.TaggedError(
  "Nip28InvalidInputError"
) {
};
var Nip28PublishError = class extends Data_exports.TaggedError("Nip28PublishError") {
};
var Nip28FetchError = class extends Data_exports.TaggedError("Nip28FetchError") {
};
var Nip28ChannelNotFoundError = class extends Data_exports.TaggedError("Nip28ChannelNotFoundError") {
};
var ChannelMetadataContentSchema = Schema_exports.Struct({
  name: Schema_exports.String,
  // NIP-28 implies name is required for kind 40 content
  about: Schema_exports.optional(Schema_exports.String),
  picture: Schema_exports.optional(Schema_exports.String),
  relays: Schema_exports.optional(Schema_exports.Array(Schema_exports.String))
  // NIP-28 mentions this for kind 40 content too
});
var ChannelMessageContentSchema = Schema_exports.String;
var ModerationReasonContentSchema = Schema_exports.Struct({
  reason: Schema_exports.String
});
var Nip28Service = class extends Context_exports.Tag("nostr/Nip28Service")() {
};
var Nip28ServiceLive = Layer_exports.effect(
  Nip28Service,
  Effect_exports.gen(function* () {
    const eventService = yield* EventService;
    const relayService = yield* RelayService;
    const createChannel = (params) => Effect_exports.scoped(Effect_exports.gen(function* () {
      if (!params.name.trim()) {
        return yield* Effect_exports.fail(new Nip28InvalidInputError({ message: "Channel name cannot be empty" }));
      }
      const content = JSON.stringify({
        name: params.name,
        about: params.about,
        picture: params.picture,
        relays: params.relays
      });
      const eventParams = {
        kind: 40,
        tags: [],
        content
      };
      const event = yield* eventService.create(eventParams, params.privateKey).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28PublishError({
              message: "Failed to create channel event",
              cause: error2
            })
          )
        )
      );
      const relayUrl = params.relays?.[0] || "ws://localhost:3003/relay";
      const connection = yield* relayService.connect(relayUrl).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28PublishError({
              message: "Failed to connect to relay",
              cause: error2
            })
          )
        )
      );
      const published = yield* connection.publish(event).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28PublishError({
              message: "Failed to publish channel event",
              cause: error2
            })
          )
        )
      );
      if (!published) {
        return yield* Effect_exports.fail(new Nip28PublishError({ message: "Channel event rejected by relay" }));
      }
      return event;
    }));
    const getChannelMetadata = (channelId) => Effect_exports.scoped(Effect_exports.gen(function* () {
      const connection = yield* relayService.connect("ws://localhost:3003/relay").pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28FetchError({
              message: "Failed to connect to relay",
              cause: error2
            })
          )
        )
      );
      const filter14 = {
        ids: [channelId],
        kinds: [40],
        limit: 1
      };
      const subscription = yield* connection.subscribe("channel-metadata", [filter14]).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28FetchError({
              message: "Failed to subscribe to channel metadata",
              cause: error2
            })
          )
        )
      );
      const events = yield* Stream_exports.runCollect(subscription.events).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28FetchError({
              message: "Failed to collect channel events",
              cause: error2
            })
          )
        )
      );
      if (Chunk_exports.isEmpty(events)) {
        return yield* Effect_exports.fail(new Nip28ChannelNotFoundError({ channelId }));
      }
      const event = Chunk_exports.unsafeHead(events);
      const content = JSON.parse(event.content);
      return {
        name: content.name,
        about: content.about,
        picture: content.picture,
        creatorPubkey: event.pubkey,
        channelId: event.id,
        relays: content.relays
      };
    }));
    const setChannelMetadata = (params) => Effect_exports.scoped(Effect_exports.gen(function* () {
      const content = JSON.stringify({
        name: params.name,
        about: params.about,
        picture: params.picture
      });
      const eventParams = {
        kind: 41,
        tags: [["e", params.channelId]],
        content
      };
      const event = yield* eventService.create(eventParams, params.privateKey).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28PublishError({
              message: "Failed to create channel metadata event",
              cause: error2
            })
          )
        )
      );
      const connection = yield* relayService.connect("ws://localhost:3003/relay").pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28PublishError({
              message: "Failed to connect to relay",
              cause: error2
            })
          )
        )
      );
      const published = yield* connection.publish(event).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28PublishError({
              message: "Failed to publish metadata update",
              cause: error2
            })
          )
        )
      );
      if (!published) {
        return yield* Effect_exports.fail(new Nip28PublishError({ message: "Metadata update rejected by relay" }));
      }
      return event;
    }));
    const sendChannelMessage = (params) => Effect_exports.scoped(Effect_exports.gen(function* () {
      if (!params.content.trim()) {
        return yield* Effect_exports.fail(new Nip28InvalidInputError({ message: "Message content cannot be empty" }));
      }
      const tags = [
        ["e", params.channelId, params.relayHint || "", "root"]
      ];
      if (params.replyToEventId) {
        tags.push(["e", params.replyToEventId, "", "reply"]);
      }
      if (params.replyToPubkey) {
        tags.push(["p", params.replyToPubkey]);
      }
      const eventParams = {
        kind: 42,
        tags,
        content: params.content
      };
      const event = yield* eventService.create(eventParams, params.privateKey).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28PublishError({
              message: "Failed to create message event",
              cause: error2
            })
          )
        )
      );
      const connection = yield* relayService.connect("ws://localhost:3003/relay").pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28PublishError({
              message: "Failed to connect to relay",
              cause: error2
            })
          )
        )
      );
      const published = yield* connection.publish(event).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28PublishError({
              message: "Failed to publish message",
              cause: error2
            })
          )
        )
      );
      if (!published) {
        return yield* Effect_exports.fail(new Nip28PublishError({ message: "Message rejected by relay" }));
      }
      return event;
    }));
    const getChannelMessages = (channelId, filterOptions) => Effect_exports.scoped(Effect_exports.gen(function* () {
      const connection = yield* relayService.connect("ws://localhost:3003/relay").pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28FetchError({
              message: "Failed to connect to relay",
              cause: error2
            })
          )
        )
      );
      const filter14 = {
        kinds: [42],
        "#e": [channelId],
        ...filterOptions
      };
      const subscription = yield* connection.subscribe("channel-messages", [filter14]).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28FetchError({
              message: "Failed to subscribe to channel messages",
              cause: error2
            })
          )
        )
      );
      const events = yield* Stream_exports.runCollect(subscription.events).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28FetchError({
              message: "Failed to collect channel messages",
              cause: error2
            })
          )
        )
      );
      return Chunk_exports.toReadonlyArray(events).map((event) => ({
        ...event,
        channelId,
        replyToEventId: event.tags.find((tag3) => tag3[0] === "e" && tag3[3] === "reply")?.[1],
        replyToPubkey: event.tags.find((tag3) => tag3[0] === "p")?.[1]
      }));
    }));
    const subscribeToChannelMessages = (channelId) => Stream_exports.unwrapScoped(
      Effect_exports.gen(function* () {
        const connection = yield* relayService.connect("ws://localhost:3003/relay").pipe(
          Effect_exports.catchAll(
            (error2) => Effect_exports.fail(
              new Nip28FetchError({
                message: "Failed to connect to relay",
                cause: error2
              })
            )
          )
        );
        const filter14 = {
          kinds: [42],
          "#e": [channelId]
        };
        const subscription = yield* connection.subscribe("channel-messages-live", [filter14]).pipe(
          Effect_exports.catchAll(
            (error2) => Effect_exports.fail(
              new Nip28FetchError({
                message: "Failed to subscribe to channel messages",
                cause: error2
              })
            )
          )
        );
        return Stream_exports.map(subscription.events, (event) => ({
          ...event,
          channelId,
          replyToEventId: event.tags.find((tag3) => tag3[0] === "e" && tag3[3] === "reply")?.[1],
          replyToPubkey: event.tags.find((tag3) => tag3[0] === "p")?.[1]
        })).pipe(
          Stream_exports.catchAll(
            (error2) => Stream_exports.fail(
              new Nip28FetchError({
                message: "Stream error in channel messages",
                cause: error2
              })
            )
          )
        );
      })
    );
    const hideMessage = (params) => Effect_exports.scoped(Effect_exports.gen(function* () {
      const content = params.reason || "User chose to hide this message";
      const eventParams = {
        kind: 43,
        tags: [["e", params.messageEventId]],
        content
      };
      const event = yield* eventService.create(eventParams, params.privateKey).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28PublishError({
              message: "Failed to create hide message event",
              cause: error2
            })
          )
        )
      );
      const connection = yield* relayService.connect("ws://localhost:3003/relay").pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28PublishError({
              message: "Failed to connect to relay",
              cause: error2
            })
          )
        )
      );
      const published = yield* connection.publish(event).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28PublishError({
              message: "Failed to publish hide message event",
              cause: error2
            })
          )
        )
      );
      if (!published) {
        return yield* Effect_exports.fail(new Nip28PublishError({ message: "Hide message event rejected by relay" }));
      }
      return event;
    }));
    const muteUser = (params) => Effect_exports.scoped(Effect_exports.gen(function* () {
      const content = params.reason || "User chose to mute this pubkey";
      const eventParams = {
        kind: 44,
        tags: [["p", params.userPubkey]],
        content
      };
      const event = yield* eventService.create(eventParams, params.privateKey).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28PublishError({
              message: "Failed to create mute user event",
              cause: error2
            })
          )
        )
      );
      const connection = yield* relayService.connect("ws://localhost:3003/relay").pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28PublishError({
              message: "Failed to connect to relay",
              cause: error2
            })
          )
        )
      );
      const published = yield* connection.publish(event).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip28PublishError({
              message: "Failed to publish mute user event",
              cause: error2
            })
          )
        )
      );
      if (!published) {
        return yield* Effect_exports.fail(new Nip28PublishError({ message: "Mute user event rejected by relay" }));
      }
      return event;
    }));
    return {
      createChannel,
      getChannelMetadata,
      setChannelMetadata,
      sendChannelMessage,
      getChannelMessages,
      subscribeToChannelMessages,
      hideMessage,
      muteUser
    };
  })
);

// ../../packages/nostr/src/nip90/Nip90Service.ts
var Nip90Service_exports = {};
__export(Nip90Service_exports, {
  JobFeedbackSchema: () => JobFeedbackSchema,
  JobInputType: () => JobInputType,
  JobRequestSchema: () => JobRequestSchema,
  JobResultSchema: () => JobResultSchema,
  JobStatus: () => JobStatus,
  NIP90_FEEDBACK_KIND: () => NIP90_FEEDBACK_KIND,
  NIP90_JOB_REQUEST_KINDS: () => NIP90_JOB_REQUEST_KINDS,
  NIP90_JOB_RESULT_KINDS: () => NIP90_JOB_RESULT_KINDS,
  Nip90FetchError: () => Nip90FetchError,
  Nip90InvalidInputError: () => Nip90InvalidInputError,
  Nip90JobNotFoundError: () => Nip90JobNotFoundError,
  Nip90PaymentError: () => Nip90PaymentError,
  Nip90PublishError: () => Nip90PublishError,
  Nip90Service: () => Nip90Service,
  Nip90ServiceLive: () => Nip90ServiceLive,
  Nip90ServiceNotFoundError: () => Nip90ServiceNotFoundError,
  ServiceCapabilitySchema: () => ServiceCapabilitySchema,
  ServiceOfferingSchema: () => ServiceOfferingSchema
});
var NIP90_JOB_REQUEST_KINDS = {
  TEXT_GENERATION: 5e3,
  CODE_GENERATION: 5001,
  IMAGE_GENERATION: 5100,
  AUDIO_GENERATION: 5200,
  VIDEO_GENERATION: 5300,
  CODE_REVIEW: 5201,
  TEXT_ANALYSIS: 5002,
  DATA_ANALYSIS: 5003,
  TRANSLATION: 5004,
  SUMMARIZATION: 5005
};
var NIP90_JOB_RESULT_KINDS = {
  TEXT_GENERATION: 6e3,
  CODE_GENERATION: 6001,
  IMAGE_GENERATION: 6100,
  AUDIO_GENERATION: 6200,
  VIDEO_GENERATION: 6300,
  CODE_REVIEW: 6201,
  TEXT_ANALYSIS: 6002,
  DATA_ANALYSIS: 6003,
  TRANSLATION: 6004,
  SUMMARIZATION: 6005
};
var NIP90_FEEDBACK_KIND = 7e3;
var Nip90InvalidInputError = class extends Data_exports.TaggedError(
  "Nip90InvalidInputError"
) {
};
var Nip90PublishError = class extends Data_exports.TaggedError("Nip90PublishError") {
};
var Nip90FetchError = class extends Data_exports.TaggedError("Nip90FetchError") {
};
var Nip90JobNotFoundError = class extends Data_exports.TaggedError("Nip90JobNotFoundError") {
};
var Nip90ServiceNotFoundError = class extends Data_exports.TaggedError("Nip90ServiceNotFoundError") {
};
var Nip90PaymentError = class extends Data_exports.TaggedError("Nip90PaymentError") {
};
var JobStatus = Schema_exports.Literal(
  "payment-required",
  "processing",
  "error",
  "success",
  "partial"
);
var JobInputType = Schema_exports.Literal("url", "event", "job", "text");
var ServiceCapabilitySchema = Schema_exports.Struct({
  id: Schema_exports.String,
  name: Schema_exports.String,
  description: Schema_exports.String,
  inputTypes: Schema_exports.Array(JobInputType),
  outputType: Schema_exports.String,
  pricing: Schema_exports.Struct({
    basePrice: Schema_exports.Number,
    // sats
    perUnit: Schema_exports.optional(Schema_exports.String),
    // e.g., "token", "word", "file"
    unitLimit: Schema_exports.optional(Schema_exports.Number)
  }),
  parameters: Schema_exports.optional(Schema_exports.Record({
    key: Schema_exports.String,
    value: Schema_exports.Unknown
  }))
});
var ServiceOfferingSchema = Schema_exports.Struct({
  serviceId: Schema_exports.String,
  name: Schema_exports.String,
  description: Schema_exports.String,
  capabilities: Schema_exports.Array(ServiceCapabilitySchema),
  provider: Schema_exports.String,
  lightningAddress: Schema_exports.optional(Schema_exports.String),
  relayHints: Schema_exports.optional(Schema_exports.Array(Schema_exports.String))
});
var JobRequestSchema = Schema_exports.Struct({
  jobId: Schema_exports.String,
  serviceId: Schema_exports.String,
  requestKind: Schema_exports.Number,
  input: Schema_exports.String,
  // JSON string or direct text
  inputType: JobInputType,
  parameters: Schema_exports.optional(Schema_exports.Record({
    key: Schema_exports.String,
    value: Schema_exports.Unknown
  })),
  bidAmount: Schema_exports.Number,
  // sats
  requester: Schema_exports.String,
  provider: Schema_exports.String
});
var JobResultSchema = Schema_exports.Struct({
  jobId: Schema_exports.String,
  requestEventId: Schema_exports.String,
  resultKind: Schema_exports.Number,
  result: Schema_exports.String,
  // JSON string or direct output
  status: JobStatus,
  provider: Schema_exports.String,
  computeTime: Schema_exports.optional(Schema_exports.Number),
  // milliseconds
  tokensUsed: Schema_exports.optional(Schema_exports.Number),
  confidence: Schema_exports.optional(Schema_exports.Number)
  // 0-1.0
});
var JobFeedbackSchema = Schema_exports.Struct({
  jobId: Schema_exports.String,
  requestEventId: Schema_exports.String,
  resultEventId: Schema_exports.optional(Schema_exports.String),
  status: JobStatus,
  message: Schema_exports.String,
  paymentHash: Schema_exports.optional(Schema_exports.String),
  // Lightning payment proof
  amount: Schema_exports.optional(Schema_exports.Number)
  // sats paid
});
var Nip90Service = class extends Context_exports.Tag("nostr/Nip90Service")() {
};
var Nip90ServiceLive = Layer_exports.effect(
  Nip90Service,
  Effect_exports.gen(function* () {
    const eventService = yield* EventService;
    const relayService = yield* RelayService;
    const defaultRelay = "wss://relay.damus.io";
    const publishServiceOffering = (params) => Effect_exports.scoped(Effect_exports.gen(function* () {
      if (!params.serviceId || !params.name || params.capabilities.length === 0) {
        return yield* Effect_exports.fail(
          new Nip90InvalidInputError({
            message: "Service ID, name, and capabilities are required"
          })
        );
      }
      const content = JSON.stringify({
        serviceId: params.serviceId,
        name: params.name,
        description: params.description,
        capabilities: params.capabilities,
        lightningAddress: params.lightningAddress,
        relayHints: params.relayHints
      });
      const tags = [
        ["d", params.serviceId],
        // NIP-33 addressable event
        ["name", params.name],
        ["about", params.description]
      ];
      params.capabilities.forEach((cap) => {
        tags.push(["t", cap.id]);
        tags.push(["k", cap.pricing.basePrice.toString()]);
      });
      if (params.lightningAddress) {
        tags.push(["lud16", params.lightningAddress]);
      }
      const eventParams = {
        kind: 31990,
        tags,
        content
      };
      const event = yield* eventService.create(eventParams, params.privateKey).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip90PublishError({
              message: "Failed to create service offering event",
              cause: error2
            })
          )
        )
      );
      const connection = yield* relayService.connect("wss://relay.damus.io").pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip90PublishError({
              message: "Failed to connect to relay",
              cause: error2
            })
          )
        )
      );
      const published = yield* connection.publish(event).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip90PublishError({
              message: "Failed to publish service offering",
              cause: error2
            })
          )
        )
      );
      if (!published) {
        return yield* Effect_exports.fail(new Nip90PublishError({ message: "Service offering rejected by relay" }));
      }
      return event;
    }));
    const discoverServices = (filters) => Effect_exports.scoped(Effect_exports.gen(function* () {
      const connection = yield* relayService.connect("wss://relay.damus.io").pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip90FetchError({
              message: "Failed to connect to relay",
              cause: error2
            })
          )
        )
      );
      const filter14 = {
        kinds: [31990],
        ...filters?.provider && { authors: [filters.provider] },
        ...filters?.capability && { "#t": [filters.capability] }
      };
      const subscription = yield* connection.subscribe("service-discovery", [filter14]).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip90FetchError({
              message: "Failed to subscribe to service offerings",
              cause: error2
            })
          )
        )
      );
      const events = yield* Stream_exports.runCollect(subscription.events).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip90FetchError({
              message: "Failed to collect service offerings",
              cause: error2
            })
          )
        )
      );
      const services = Chunk_exports.toReadonlyArray(events).map((event) => {
        try {
          const content = JSON.parse(event.content);
          return {
            serviceId: content.serviceId,
            name: content.name,
            description: content.description,
            capabilities: content.capabilities,
            provider: event.pubkey,
            lightningAddress: content.lightningAddress,
            relayHints: content.relayHints
          };
        } catch {
          return null;
        }
      }).filter((service3) => service3 !== null);
      if (filters?.maxPrice) {
        return services.filter(
          (service3) => service3.capabilities.some((cap) => cap.pricing.basePrice <= filters.maxPrice)
        );
      }
      return services;
    }));
    const requestJob = (params) => Effect_exports.scoped(Effect_exports.gen(function* () {
      if (!params.input || params.bidAmount <= 0) {
        return yield* Effect_exports.fail(
          new Nip90InvalidInputError({
            message: "Job input and valid bid amount are required"
          })
        );
      }
      const content = JSON.stringify({
        serviceId: params.serviceId,
        input: params.input,
        inputType: params.inputType,
        parameters: params.parameters,
        bidAmount: params.bidAmount
      });
      const tags = [
        ["p", params.providerPubkey],
        // Provider pubkey
        ["amount", params.bidAmount.toString(), "sats"],
        ["service", params.serviceId]
      ];
      if (params.inputType === "url") {
        tags.push(["i", params.input, "url"]);
      } else if (params.inputType === "text") {
        tags.push(["i", params.input, "text"]);
      }
      const eventParams = {
        kind: params.requestKind,
        tags,
        content
      };
      const event = yield* eventService.create(eventParams, params.privateKey).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip90PublishError({
              message: "Failed to create job request event",
              cause: error2
            })
          )
        )
      );
      const connection = yield* relayService.connect("wss://relay.damus.io").pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip90PublishError({
              message: "Failed to connect to relay",
              cause: error2
            })
          )
        )
      );
      const published = yield* connection.publish(event).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip90PublishError({
              message: "Failed to publish job request",
              cause: error2
            })
          )
        )
      );
      if (!published) {
        return yield* Effect_exports.fail(new Nip90PublishError({ message: "Job request rejected by relay" }));
      }
      return event;
    }));
    const submitJobResult = (params) => Effect_exports.scoped(Effect_exports.gen(function* () {
      const content = JSON.stringify({
        jobId: params.jobId,
        result: params.result,
        status: params.status,
        computeTime: params.computeTime,
        tokensUsed: params.tokensUsed,
        confidence: params.confidence
      });
      const eventParams = {
        kind: params.resultKind,
        tags: [
          ["e", params.requestEventId],
          // Reference to original request
          ["status", params.status]
        ],
        content
      };
      const event = yield* eventService.create(eventParams, params.privateKey).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip90PublishError({
              message: "Failed to create job result event",
              cause: error2
            })
          )
        )
      );
      const connection = yield* relayService.connect("wss://relay.damus.io").pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip90PublishError({
              message: "Failed to connect to relay",
              cause: error2
            })
          )
        )
      );
      const published = yield* connection.publish(event).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new Nip90PublishError({
              message: "Failed to publish job result",
              cause: error2
            })
          )
        )
      );
      if (!published) {
        return yield* Effect_exports.fail(new Nip90PublishError({ message: "Job result rejected by relay" }));
      }
      return event;
    }));
    const submitJobFeedback = (params) => Effect_exports.scoped(
      Effect_exports.gen(function* () {
        const connection = yield* relayService.connect(defaultRelay).pipe(
          Effect_exports.catchAll(
            (error2) => Effect_exports.fail(
              new Nip90PublishError({
                message: "Failed to connect to relay",
                cause: error2
              })
            )
          )
        );
        const event = yield* eventService.create(
          {
            kind: 7e3,
            // NIP-90 feedback kind
            tags: [
              ["e", params.jobId],
              ["rating", params.rating.toString()],
              ...params.comment ? [["comment", params.comment]] : []
            ],
            content: params.comment || ""
          },
          params.privateKey
        ).pipe(
          Effect_exports.catchAll(
            (error2) => Effect_exports.fail(
              new Nip90PublishError({
                message: "Failed to create feedback event",
                cause: error2
              })
            )
          )
        );
        const published = yield* connection.publish(event).pipe(
          Effect_exports.catchAll(
            (error2) => Effect_exports.fail(
              new Nip90PublishError({
                message: "Failed to publish feedback",
                cause: error2
              })
            )
          )
        );
        if (!published) {
          return yield* Effect_exports.fail(
            new Nip90PublishError({ message: "Feedback rejected by relay" })
          );
        }
        return event;
      })
    );
    const getJobStatus = (jobId) => Effect_exports.scoped(
      Effect_exports.gen(function* () {
        const connection = yield* relayService.connect(defaultRelay).pipe(
          Effect_exports.catchAll(
            (error2) => Effect_exports.fail(
              new Nip90FetchError({
                message: "Failed to connect to relay",
                cause: error2
              })
            )
          )
        );
        const filters = [{
          kinds: [6e3, 6001, 6002, 6003],
          // Job result kinds
          "#e": [jobId],
          limit: 1
        }];
        const subscription = yield* connection.subscribe(
          "job-status-" + jobId,
          filters
        ).pipe(
          Effect_exports.catchAll(
            (error2) => Effect_exports.fail(
              new Nip90FetchError({
                message: "Failed to subscribe",
                cause: error2
              })
            )
          )
        );
        const resultEvent = yield* subscription.events.pipe(
          Stream_exports.take(1),
          Stream_exports.runHead
        ).pipe(
          Effect_exports.catchAll(
            (error2) => Effect_exports.fail(
              new Nip90FetchError({
                message: "Failed to get job status",
                cause: error2
              })
            )
          )
        );
        if (Option_exports.isNone(resultEvent)) {
          return yield* Effect_exports.fail(new Nip90JobNotFoundError({ jobId }));
        }
        const event = Option_exports.getOrThrow(resultEvent);
        const statusTag = event.tags.find((t) => t[0] === "status");
        const status3 = statusTag?.[1] || "pending";
        const request2 = {
          jobId,
          serviceId: "",
          requestKind: 5e3,
          input: "",
          inputType: "text",
          bidAmount: 0,
          requester: event.pubkey,
          provider: event.pubkey
        };
        const result = {
          jobId,
          requestEventId: jobId,
          resultKind: event.kind,
          result: event.content,
          status: status3,
          provider: event.pubkey
        };
        const monitor = {
          jobId,
          request: request2,
          result,
          status: status3,
          lastUpdate: event.created_at
        };
        return monitor;
      })
    );
    const monitorJob = (jobId) => Stream_exports.unwrapScoped(
      Effect_exports.gen(function* () {
        const connection = yield* relayService.connect(defaultRelay).pipe(
          Effect_exports.catchAll(
            (error2) => Effect_exports.fail(
              new Nip90FetchError({
                message: "Failed to connect to relay",
                cause: error2
              })
            )
          )
        );
        const filters = [{
          kinds: [6e3, 6001, 6002, 6003],
          // Job result kinds
          "#e": [jobId]
        }];
        const subscription = yield* connection.subscribe(
          "monitor-" + jobId,
          filters
        ).pipe(
          Effect_exports.catchAll(
            (error2) => Effect_exports.fail(
              new Nip90FetchError({
                message: "Failed to subscribe",
                cause: error2
              })
            )
          )
        );
        return subscription.events.pipe(
          Stream_exports.map((event) => {
            const request2 = {
              jobId,
              serviceId: "",
              requestKind: 5e3,
              input: "",
              inputType: "text",
              bidAmount: 0,
              requester: event.pubkey,
              provider: event.pubkey
            };
            const statusTag = event.tags.find((t) => t[0] === "status");
            const status3 = statusTag?.[1] || "pending";
            const result = {
              jobId,
              requestEventId: jobId,
              resultKind: event.kind,
              result: event.content,
              status: status3,
              provider: event.pubkey
            };
            const monitor = {
              jobId,
              request: request2,
              result,
              status: status3,
              lastUpdate: event.created_at
            };
            return monitor;
          }),
          Stream_exports.catchAll(
            (error2) => Stream_exports.fail(
              new Nip90FetchError({
                message: String(error2)
              })
            )
          )
        );
      })
    );
    const getJobRequests = (providerPubkey, filterOptions) => Effect_exports.scoped(
      Effect_exports.gen(function* () {
        const connection = yield* relayService.connect(defaultRelay);
        const filters = [{
          kinds: [5e3, 5001, 5002, 5003, 5999],
          // Job request kinds
          ...filterOptions,
          limit: filterOptions?.limit || 50
        }];
        const subscription = yield* connection.subscribe(
          "job-requests-" + Date.now(),
          filters
        );
        const events = yield* subscription.events.pipe(
          Stream_exports.filter((event) => {
            const serviceTag = event.tags.find((t) => t[0] === "service");
            return Boolean(serviceTag && serviceTag[1] === providerPubkey);
          }),
          Stream_exports.map((event) => {
            try {
              const content = JSON.parse(event.content);
              const request2 = {
                jobId: event.id,
                serviceId: content.serviceId || "",
                requestKind: event.kind,
                input: content.input || "",
                inputType: content.inputType || "text",
                parameters: content.parameters,
                bidAmount: content.bidAmount || 0,
                requester: event.pubkey,
                provider: providerPubkey
              };
              return request2;
            } catch {
              return {
                jobId: event.id,
                serviceId: "",
                requestKind: event.kind,
                input: "",
                inputType: "text",
                bidAmount: 0,
                requester: event.pubkey,
                provider: providerPubkey
              };
            }
          }),
          Stream_exports.take(100),
          // Take up to 100 events
          Stream_exports.interruptAfter("2 seconds"),
          Stream_exports.runCollect
        );
        return [...Chunk_exports.toReadonlyArray(events)];
      })
    ).pipe(
      Effect_exports.catchAll(
        (error2) => Effect_exports.fail(
          new Nip90FetchError({
            message: String(error2)
          })
        )
      )
    );
    const subscribeToJobRequests = (providerPubkey) => Stream_exports.unwrapScoped(
      Effect_exports.gen(function* () {
        const connection = yield* relayService.connect(defaultRelay).pipe(
          Effect_exports.catchAll(
            (error2) => Effect_exports.fail(
              new Nip90FetchError({
                message: "Failed to connect to relay",
                cause: error2
              })
            )
          )
        );
        const filters = [{
          kinds: [5e3, 5001, 5002, 5003, 5999],
          // Job request kinds
          since: Math.floor(Date.now() / 1e3)
        }];
        const subscription = yield* connection.subscribe(
          "job-requests-stream-" + Date.now(),
          filters
        ).pipe(
          Effect_exports.catchAll(
            (error2) => Effect_exports.fail(
              new Nip90FetchError({
                message: "Failed to subscribe",
                cause: error2
              })
            )
          )
        );
        return subscription.events.pipe(
          Stream_exports.filter((event) => {
            const serviceTag = event.tags.find((t) => t[0] === "service");
            return !!(serviceTag && serviceTag[1] === providerPubkey);
          }),
          Stream_exports.map((event) => {
            try {
              const content = JSON.parse(event.content);
              const request2 = {
                jobId: event.id,
                serviceId: content.serviceId || "",
                requestKind: event.kind,
                input: content.input || "",
                inputType: content.inputType || "text",
                parameters: content.parameters,
                bidAmount: content.bidAmount || 0,
                requester: event.pubkey,
                provider: providerPubkey
              };
              return request2;
            } catch {
              return {
                jobId: event.id,
                serviceId: "",
                requestKind: event.kind,
                input: "",
                inputType: "text",
                bidAmount: 0,
                requester: event.pubkey,
                provider: providerPubkey
              };
            }
          }),
          Stream_exports.catchAll(
            (error2) => Stream_exports.fail(
              new Nip90FetchError({
                message: String(error2)
              })
            )
          )
        );
      })
    );
    return {
      publishServiceOffering,
      discoverServices,
      requestJob,
      submitJobResult,
      submitJobFeedback,
      getJobStatus,
      monitorJob,
      getJobRequests,
      subscribeToJobRequests
    };
  })
);

// ../../packages/nostr/src/nips/nip02.ts
var Contact = Schema_exports.Struct({
  pubkey: PublicKey,
  mainRelay: Schema_exports.optional(Schema_exports.String),
  petname: Schema_exports.optional(Schema_exports.String)
});
var ContactList = Schema_exports.Struct({
  contacts: Schema_exports.Array(Contact),
  updatedAt: Schema_exports.Number
});
var ContactEvent = Schema_exports.Struct({
  id: Schema_exports.String,
  pubkey: PublicKey,
  created_at: Schema_exports.Number,
  kind: Schema_exports.Literal(3),
  tags: Schema_exports.Array(Schema_exports.Array(Schema_exports.String)),
  content: Schema_exports.String,
  sig: Signature
});
var PetnameEntry = Schema_exports.Struct({
  pubkey: PublicKey,
  petname: Schema_exports.String,
  displayName: Schema_exports.optional(Schema_exports.String),
  about: Schema_exports.optional(Schema_exports.String),
  picture: Schema_exports.optional(Schema_exports.String),
  lastUpdated: Schema_exports.Number
});
var Nip02Error = class extends Data_exports.TaggedError("Nip02Error") {
};
var Nip02Service = class extends Context_exports.Tag("nips/Nip02Service")() {
};
var Nip02ServiceLive = Layer_exports.effect(
  Nip02Service,
  Effect_exports.gen(function* () {
    const petnameCache = yield* Cache_exports.make({
      capacity: 1e4,
      timeToLive: Duration_exports.hours(24),
      lookup: (_pubkey) => Effect_exports.succeed(void 0)
    });
    const reversePetnameCache = yield* Cache_exports.make({
      capacity: 1e4,
      timeToLive: Duration_exports.hours(24),
      lookup: (_petname) => Effect_exports.succeed(void 0)
    });
    const createContactList = (contacts, _privateKey) => Effect_exports.sync(() => {
      const contactsJson = JSON.stringify(
        contacts.reduce((acc, contact) => {
          acc[contact.pubkey] = {
            relay: contact.mainRelay ?? void 0,
            petname: contact.petname ?? void 0
          };
          return acc;
        }, {})
      );
      const tags = contacts.map((contact) => [
        "p",
        contact.pubkey,
        ...contact.mainRelay ? [contact.mainRelay] : [],
        ...contact.petname ? [contact.petname] : []
      ]);
      const now2 = Math.floor(Date.now() / 1e3);
      const event = {
        id: "placeholder-id",
        pubkey: "placeholder-pubkey",
        created_at: now2,
        kind: 3,
        tags,
        content: contactsJson,
        sig: "placeholder-signature"
      };
      return event;
    });
    const parseContactList = (event) => Effect_exports.gen(function* () {
      try {
        const contactsData = JSON.parse(event.content);
        const contacts = [];
        for (const [pubkey, data] of Object.entries(contactsData)) {
          if (typeof data === "object" && data !== null) {
            const contactData = data;
            contacts.push({
              pubkey,
              mainRelay: contactData.relay,
              petname: contactData.petname
            });
          }
        }
        return {
          contacts,
          updatedAt: event.created_at
        };
      } catch (error2) {
        return yield* Effect_exports.fail(
          new Nip02Error({
            reason: "decode_failed",
            message: `Failed to parse contact list: ${error2}`,
            cause: error2
          })
        );
      }
    });
    const addContact = (contactList, contact) => Effect_exports.gen(function* () {
      const existingIndex = contactList.contacts.findIndex(
        (c) => c.pubkey === contact.pubkey
      );
      if (existingIndex !== -1) {
        return yield* Effect_exports.fail(
          new Nip02Error({
            reason: "duplicate_contact",
            message: `Contact already exists: ${contact.pubkey}`,
            pubkey: contact.pubkey
          })
        );
      }
      return {
        contacts: [...contactList.contacts, contact],
        updatedAt: Math.floor(Date.now() / 1e3)
      };
    });
    const removeContact = (contactList, pubkey) => Effect_exports.gen(function* () {
      const filtered = contactList.contacts.filter((c) => c.pubkey !== pubkey);
      if (filtered.length === contactList.contacts.length) {
        return yield* Effect_exports.fail(
          new Nip02Error({
            reason: "contact_not_found",
            message: `Contact not found: ${pubkey}`,
            pubkey
          })
        );
      }
      return {
        contacts: filtered,
        updatedAt: Math.floor(Date.now() / 1e3)
      };
    });
    const updateContact = (contactList, pubkey, updates) => Effect_exports.gen(function* () {
      const contactIndex = contactList.contacts.findIndex(
        (c) => c.pubkey === pubkey
      );
      if (contactIndex === -1) {
        return yield* Effect_exports.fail(
          new Nip02Error({
            reason: "contact_not_found",
            message: `Contact not found: ${pubkey}`,
            pubkey
          })
        );
      }
      const updatedContacts = [...contactList.contacts];
      updatedContacts[contactIndex] = {
        ...updatedContacts[contactIndex],
        ...updates
      };
      return {
        contacts: updatedContacts,
        updatedAt: Math.floor(Date.now() / 1e3)
      };
    });
    const findContact = (contactList, pubkey) => Effect_exports.gen(function* () {
      const contact = contactList.contacts.find((c) => c.pubkey === pubkey);
      if (!contact) {
        return yield* Effect_exports.fail(
          new Nip02Error({
            reason: "contact_not_found",
            message: `Contact not found: ${pubkey}`,
            pubkey
          })
        );
      }
      return contact;
    });
    const findContactsByPetname = (contactList, pattern3) => Effect_exports.succeed(
      contactList.contacts.filter((contact) => contact.petname?.toLowerCase().includes(pattern3.toLowerCase()))
    );
    const setPetname = (pubkey, petname) => Effect_exports.gen(function* () {
      if (!petname.trim() || petname.length > 50) {
        return yield* Effect_exports.fail(
          new Nip02Error({
            reason: "invalid_petname",
            message: "Petname must be 1-50 characters",
            petname
          })
        );
      }
      const entry = {
        pubkey,
        petname: petname.trim(),
        lastUpdated: Date.now()
      };
      yield* petnameCache.set(pubkey, petname);
      yield* reversePetnameCache.set(petname, pubkey);
      return entry;
    });
    const getPetname = (pubkey) => petnameCache.get(pubkey);
    const resolvePetname = (petname) => reversePetnameCache.get(petname);
    const getAllPetnames = () => Effect_exports.succeed([]);
    const clearPetnameCache = () => Effect_exports.gen(function* () {
      yield* petnameCache.invalidateAll;
      yield* reversePetnameCache.invalidateAll;
    });
    return {
      createContactList,
      parseContactList,
      addContact,
      removeContact,
      updateContact,
      findContact,
      findContactsByPetname,
      setPetname,
      getPetname,
      resolvePetname,
      getAllPetnames,
      clearPetnameCache
    };
  })
);

// ../../packages/nostr/src/nips/nip05.ts
var Relay = Schema_exports.String.pipe(
  Schema_exports.pattern(/^wss?:\/\/.+$/),
  Schema_exports.brand("Relay")
);
var Nip05Identifier = Schema_exports.String.pipe(
  Schema_exports.pattern(/^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/),
  Schema_exports.brand("Nip05Identifier")
);
var NostrJsonResponse = Schema_exports.Struct({
  names: Schema_exports.Record({ key: Schema_exports.String, value: PublicKey }),
  relays: Schema_exports.optional(Schema_exports.Record({
    key: PublicKey,
    value: Schema_exports.Array(Relay)
  })),
  // Optional NIP-46 bunker URL
  nip46: Schema_exports.optional(Schema_exports.Record({
    key: PublicKey,
    value: Schema_exports.Array(Schema_exports.String)
  }))
});
var Nip05Profile = Schema_exports.Struct({
  pubkey: PublicKey,
  relays: Schema_exports.optional(Schema_exports.Array(Relay)),
  nip46: Schema_exports.optional(Schema_exports.Array(Schema_exports.String)),
  identifier: Nip05Identifier,
  verifiedAt: Schema_exports.Number
});
var Nip05Error = class extends Data_exports.TaggedError("Nip05Error") {
};
var Nip05Service = class extends Context_exports.Tag("nips/Nip05Service")() {
};
var Nip05ServiceLive = Layer_exports.effect(
  Nip05Service,
  Effect_exports.gen(function* () {
    const profileCache = yield* Cache_exports.make({
      capacity: 1e3,
      timeToLive: Duration_exports.hours(1),
      lookup: (identifier2) => resolveIdentifierImpl(identifier2)
    });
    const resolveIdentifierImpl = (identifier2) => Effect_exports.gen(function* () {
      const parts2 = identifier2.split("@");
      if (parts2.length !== 2) {
        return yield* Effect_exports.fail(
          new Nip05Error({
            reason: "invalid_identifier",
            identifier: identifier2,
            message: "Identifier must be in format: name@domain"
          })
        );
      }
      const [name, domain2] = parts2;
      const isIpAddress = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(domain2);
      const protocol = isIpAddress ? "http" : "https";
      const url2 = `${protocol}://${domain2}/.well-known/nostr.json?name=${encodeURIComponent(name)}`;
      const response = yield* Effect_exports.tryPromise({
        try: () => fetch(url2),
        catch: (error2) => new Nip05Error({
          reason: "dns_error",
          identifier: identifier2,
          message: `Failed to fetch .well-known/nostr.json: ${String(error2)}`,
          cause: error2
        })
      }).pipe(
        Effect_exports.timeout(Duration_exports.seconds(10)),
        Effect_exports.tapError(() => Effect_exports.log(`NIP-05 resolution failed for ${identifier2}`)),
        Effect_exports.mapError((error2) => {
          if (error2._tag === "TimeoutException") {
            return new Nip05Error({
              reason: "timeout",
              identifier: identifier2,
              message: "Request timed out",
              cause: error2
            });
          }
          return error2;
        })
      );
      const body = yield* Effect_exports.tryPromise({
        try: () => response.json(),
        catch: (error2) => new Nip05Error({
          reason: "invalid_response",
          identifier: identifier2,
          message: `Failed to parse JSON response: ${String(error2)}`,
          cause: error2
        })
      });
      const parsed = yield* Schema_exports.decodeUnknown(NostrJsonResponse)(body).pipe(
        Effect_exports.mapError(
          (error2) => new Nip05Error({
            reason: "invalid_response",
            identifier: identifier2,
            message: `Invalid response format: ${error2}`,
            cause: error2
          })
        )
      );
      const pubkey = parsed.names[name.toLowerCase()] || parsed.names[name];
      if (!pubkey) {
        return yield* Effect_exports.fail(
          new Nip05Error({
            reason: "not_found",
            identifier: identifier2,
            message: `Name '${name}' not found in domain '${domain2}'`
          })
        );
      }
      const relays = parsed.relays?.[pubkey];
      const nip46 = parsed.nip46?.[pubkey];
      const profile = {
        pubkey,
        relays,
        nip46,
        identifier: identifier2,
        verifiedAt: Date.now()
      };
      return profile;
    });
    const resolve = (identifier2) => profileCache.get(identifier2);
    const verify = (pubkey, identifier2) => Effect_exports.gen(function* () {
      const profile = yield* resolve(identifier2);
      return profile.pubkey === pubkey;
    });
    const queryWellKnown = (domain2, name) => Effect_exports.gen(function* () {
      const isIpAddress = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(domain2);
      const protocol = isIpAddress ? "http" : "https";
      let url2 = `${protocol}://${domain2}/.well-known/nostr.json`;
      if (name) {
        url2 += `?name=${encodeURIComponent(name)}`;
      }
      const response = yield* Effect_exports.tryPromise({
        try: () => fetch(url2),
        catch: (error2) => new Nip05Error({
          reason: "dns_error",
          identifier: domain2,
          message: `Failed to fetch .well-known/nostr.json: ${String(error2)}`,
          cause: error2
        })
      }).pipe(
        Effect_exports.timeout(Duration_exports.seconds(10)),
        Effect_exports.mapError((error2) => {
          if (error2._tag === "TimeoutException") {
            return new Nip05Error({
              reason: "timeout",
              identifier: domain2,
              message: "Request timed out",
              cause: error2
            });
          }
          return error2;
        })
      );
      const body = yield* Effect_exports.tryPromise({
        try: () => response.json(),
        catch: (error2) => new Nip05Error({
          reason: "invalid_response",
          identifier: domain2,
          message: `Failed to parse JSON response: ${String(error2)}`,
          cause: error2
        })
      });
      const decoded = yield* Schema_exports.decodeUnknown(NostrJsonResponse)(body).pipe(
        Effect_exports.mapError(
          (error2) => new Nip05Error({
            reason: "invalid_response",
            identifier: domain2,
            message: `Invalid response format: ${error2}`,
            cause: error2
          })
        )
      );
      return decoded;
    });
    const clearCache = (identifier2) => profileCache.invalidate(identifier2);
    const getCachedProfiles = () => Effect_exports.sync(() => {
      return /* @__PURE__ */ new Map();
    });
    return {
      resolve,
      verify,
      queryWellKnown,
      clearCache,
      getCachedProfiles
    };
  })
);

// ../../packages/nostr/src/nips/nip09.ts
var DeletionReason = Schema_exports.Union(
  Schema_exports.Literal("inappropriate_content"),
  Schema_exports.Literal("personal_request"),
  Schema_exports.Literal("legal_requirement"),
  Schema_exports.Literal("spam"),
  Schema_exports.Literal("duplicate"),
  Schema_exports.Literal("error"),
  Schema_exports.Literal("other")
);
var DeletionEvent = Schema_exports.Struct({
  id: Schema_exports.String,
  pubkey: PublicKey,
  created_at: Schema_exports.Number,
  kind: Schema_exports.Literal(5),
  tags: Schema_exports.Array(Schema_exports.Array(Schema_exports.String)),
  content: Schema_exports.String,
  // Deletion reason (optional)
  sig: Signature
});
var DeletionRequest = Schema_exports.Struct({
  eventIds: Schema_exports.Array(Schema_exports.String),
  reason: Schema_exports.optional(DeletionReason),
  comment: Schema_exports.optional(Schema_exports.String)
});
var DeletionStatus = Schema_exports.Struct({
  eventId: Schema_exports.String,
  deletedAt: Schema_exports.Number,
  deletionEventId: Schema_exports.String,
  reason: Schema_exports.optional(DeletionReason),
  processed: Schema_exports.Boolean
});
var DeletionPolicy = Schema_exports.Struct({
  allowSelfDeletion: Schema_exports.Boolean,
  allowModeratorDeletion: Schema_exports.Boolean,
  preserveArchive: Schema_exports.Boolean,
  timeLimit: Schema_exports.optional(Schema_exports.Number),
  // Time limit in seconds for deletion requests
  moderatorPubkeys: Schema_exports.optional(Schema_exports.Array(PublicKey))
});
var Nip09Error = class extends Data_exports.TaggedError("Nip09Error") {
};
var Nip09Service = class extends Context_exports.Tag("nips/Nip09Service")() {
};
var Nip09ServiceLive = Layer_exports.succeed(
  Nip09Service,
  {
    createDeletionEvent: (request2, _authorPrivkey) => Effect_exports.gen(function* () {
      if (request2.eventIds.length === 0) {
        return yield* Effect_exports.fail(
          new Nip09Error({
            reason: "invalid_request",
            message: "Deletion request must specify at least one event ID"
          })
        );
      }
      const tags = request2.eventIds.map((eventId) => ["e", eventId]);
      if (request2.reason) {
        tags.push(["reason", request2.reason]);
      }
      const contentParts = [];
      if (request2.reason) {
        contentParts.push(`Reason: ${request2.reason}`);
      }
      if (request2.comment) {
        contentParts.push(`Comment: ${request2.comment}`);
      }
      const content = contentParts.join("\n");
      const now2 = Math.floor(Date.now() / 1e3);
      const event = {
        id: "placeholder-id",
        pubkey: "placeholder-pubkey",
        created_at: now2,
        kind: 5,
        tags,
        content,
        sig: "placeholder-signature"
      };
      return event;
    }),
    parseDeletionEvent: (event) => Effect_exports.gen(function* () {
      const eventIds = [];
      for (const tag3 of event.tags) {
        if (tag3[0] === "e" && tag3[1]) {
          eventIds.push(tag3[1]);
        }
      }
      if (eventIds.length === 0) {
        return yield* Effect_exports.fail(
          new Nip09Error({
            reason: "invalid_request",
            message: "Deletion event must specify at least one event to delete"
          })
        );
      }
      const reasonTag = event.tags.find((tag3) => tag3[0] === "reason");
      const reason = reasonTag?.[1];
      const comment = event.content.trim() || void 0;
      return {
        eventIds,
        reason,
        comment
      };
    }),
    validateDeletion: (request2, requestedBy, originalEvents, policy) => Effect_exports.gen(function* () {
      const now2 = Math.floor(Date.now() / 1e3);
      for (const eventData of originalEvents) {
        const isOriginalAuthor = eventData.pubkey === requestedBy;
        const isModerator = policy.moderatorPubkeys?.includes(requestedBy) ?? false;
        if (!isOriginalAuthor && !isModerator) {
          return yield* Effect_exports.fail(
            new Nip09Error({
              reason: "unauthorized_deletion",
              message: "Only the original author or moderators can delete events",
              eventId: eventData.id,
              requestedBy,
              originalAuthor: eventData.pubkey
            })
          );
        }
        if (isOriginalAuthor && !policy.allowSelfDeletion) {
          return yield* Effect_exports.fail(
            new Nip09Error({
              reason: "policy_violation",
              message: "Self-deletion not allowed by policy",
              eventId: eventData.id,
              requestedBy
            })
          );
        }
        if (isModerator && !policy.allowModeratorDeletion) {
          return yield* Effect_exports.fail(
            new Nip09Error({
              reason: "policy_violation",
              message: "Moderator deletion not allowed by policy",
              eventId: eventData.id,
              requestedBy
            })
          );
        }
        if (policy.timeLimit && isOriginalAuthor) {
          const eventAge = now2 - eventData.created_at;
          if (eventAge > policy.timeLimit) {
            return yield* Effect_exports.fail(
              new Nip09Error({
                reason: "time_limit_exceeded",
                message: `Deletion time limit exceeded for event ${eventData.id}`,
                eventId: eventData.id,
                requestedBy
              })
            );
          }
        }
      }
    }),
    processDeletion: (request2, _requestedBy, _policy) => Effect_exports.sync(() => {
      const now2 = Date.now();
      const deletionEventId = `deletion-${now2}-${Math.random().toString(36).substr(2, 9)}`;
      const statuses = request2.eventIds.map((eventId) => ({
        eventId,
        deletedAt: now2,
        deletionEventId,
        reason: request2.reason,
        processed: true
      }));
      return statuses;
    }),
    isEventDeleted: (_eventId) => Effect_exports.succeed(void 0),
    // TODO: Implement storage lookup
    getDeletionReason: (_eventId) => Effect_exports.succeed(void 0),
    // TODO: Implement storage lookup
    getDeletedEventsByAuthor: (_authorPubkey) => Effect_exports.succeed([]),
    // TODO: Implement storage lookup
    restoreEvent: (_eventId, _requestedBy, _policy) => Effect_exports.gen(function* () {
    }),
    getDeletionStats: () => Effect_exports.succeed({
      totalDeleted: 0,
      deletionsByReason: {
        inappropriate_content: 0,
        personal_request: 0,
        legal_requirement: 0,
        spam: 0,
        duplicate: 0,
        error: 0,
        other: 0
      },
      deletionsByAuthor: {}
    })
  }
);

// ../../packages/nostr/src/nips/nip19.ts
var import_bech32 = __toESM(require_dist(), 1);
var Npub2 = Brand_exports.nominal();
var Nsec2 = Brand_exports.nominal();
var Note = Brand_exports.nominal();
var Nprofile = Brand_exports.nominal();
var Nevent = Brand_exports.nominal();
var Naddr = Brand_exports.nominal();
var Nrelay = Brand_exports.nominal();
var Nip19Error = class extends Data_exports.TaggedError("Nip19Error") {
};
var ProfilePointer = Schema_exports.Struct({
  pubkey: Schema_exports.String,
  relays: Schema_exports.optional(Schema_exports.Array(Schema_exports.String))
});
var EventPointer = Schema_exports.Struct({
  id: Schema_exports.String,
  relays: Schema_exports.optional(Schema_exports.Array(Schema_exports.String)),
  author: Schema_exports.optional(Schema_exports.String),
  kind: Schema_exports.optional(Schema_exports.Number)
});
var AddressPointer = Schema_exports.Struct({
  identifier: Schema_exports.String,
  pubkey: Schema_exports.String,
  kind: Schema_exports.Number,
  relays: Schema_exports.optional(Schema_exports.Array(Schema_exports.String))
});

// ../../node_modules/.pnpm/@noble+ciphers@0.5.1/node_modules/@noble/ciphers/esm/_assert.js
function number6(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`positive integer expected, not ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`boolean expected, not ${b}`);
}
function isBytes8(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes2(b, ...lengths) {
  if (!isBytes8(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function exists5(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output2(out, instance) {
  bytes2(out);
  const min5 = instance.outputLen;
  if (out.length < min5) {
    throw new Error(`digestInto() expects output buffer of length at least ${min5}`);
  }
}

// ../../node_modules/.pnpm/@noble+ciphers@0.5.1/node_modules/@noble/ciphers/esm/utils.js
var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
var u323 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView4 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE2)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes5(str) {
  if (typeof str !== "string")
    throw new Error(`string expected, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes4(data) {
  if (typeof data === "string")
    data = utf8ToBytes5(data);
  else if (isBytes8(data))
    data = data.slice();
  else
    throw new Error(`Uint8Array expected, got ${typeof data}`);
  return data;
}
function checkOpts2(defaults, opts) {
  if (opts == null || typeof opts !== "object")
    throw new Error("options must be defined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function equalBytes2(a, b) {
  if (a.length !== b.length)
    return false;
  let diff8 = 0;
  for (let i = 0; i < a.length; i++)
    diff8 |= a[i] ^ b[i];
  return diff8 === 0;
}
var wrapCipher = /* @__NO_SIDE_EFFECTS__ */ (params, c) => {
  Object.assign(c, params);
  return c;
};
function setBigUint644(view, byteOffset, value3, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value3, isLE3);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value3 >> _32n2 & _u32_max);
  const wl = Number(value3 & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
}

// ../../node_modules/.pnpm/@noble+ciphers@0.5.1/node_modules/@noble/ciphers/esm/_polyval.js
var BLOCK_SIZE = 16;
var ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
var ZEROS32 = u323(ZEROS16);
var POLY = 225;
var mul2 = (s0, s1, s2, s3) => {
  const hiBit = s3 & 1;
  return {
    s3: s2 << 31 | s3 >>> 1,
    s2: s1 << 31 | s2 >>> 1,
    s1: s0 << 31 | s1 >>> 1,
    s0: s0 >>> 1 ^ POLY << 24 & -(hiBit & 1)
    // reduce % poly
  };
};
var swapLE = (n) => (n >>> 0 & 255) << 24 | (n >>> 8 & 255) << 16 | (n >>> 16 & 255) << 8 | n >>> 24 & 255 | 0;
function _toGHASHKey(k) {
  k.reverse();
  const hiBit = k[15] & 1;
  let carry = 0;
  for (let i = 0; i < k.length; i++) {
    const t = k[i];
    k[i] = t >>> 1 | carry;
    carry = (t & 1) << 7;
  }
  k[0] ^= -hiBit & 225;
  return k;
}
var estimateWindow = (bytes3) => {
  if (bytes3 > 64 * 1024)
    return 8;
  if (bytes3 > 1024)
    return 4;
  return 2;
};
var GHASH = class {
  // We select bits per window adaptively based on expectedLength
  constructor(key, expectedLength) {
    this.blockLen = BLOCK_SIZE;
    this.outputLen = BLOCK_SIZE;
    this.s0 = 0;
    this.s1 = 0;
    this.s2 = 0;
    this.s3 = 0;
    this.finished = false;
    key = toBytes4(key);
    bytes2(key, 16);
    const kView = createView4(key);
    let k0 = kView.getUint32(0, false);
    let k1 = kView.getUint32(4, false);
    let k2 = kView.getUint32(8, false);
    let k3 = kView.getUint32(12, false);
    const doubles = [];
    for (let i = 0; i < 128; i++) {
      doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });
      ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));
    }
    const W = estimateWindow(expectedLength || 1024);
    if (![1, 2, 4, 8].includes(W))
      throw new Error(`ghash: wrong window size=${W}, should be 2, 4 or 8`);
    this.W = W;
    const bits = 128;
    const windows = bits / W;
    const windowSize = this.windowSize = 2 ** W;
    const items = [];
    for (let w = 0; w < windows; w++) {
      for (let byte = 0; byte < windowSize; byte++) {
        let s0 = 0, s1 = 0, s2 = 0, s3 = 0;
        for (let j = 0; j < W; j++) {
          const bit = byte >>> W - j - 1 & 1;
          if (!bit)
            continue;
          const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];
          s0 ^= d0, s1 ^= d1, s2 ^= d2, s3 ^= d3;
        }
        items.push({ s0, s1, s2, s3 });
      }
    }
    this.t = items;
  }
  _updateBlock(s0, s1, s2, s3) {
    s0 ^= this.s0, s1 ^= this.s1, s2 ^= this.s2, s3 ^= this.s3;
    const { W, t, windowSize } = this;
    let o0 = 0, o1 = 0, o2 = 0, o3 = 0;
    const mask = (1 << W) - 1;
    let w = 0;
    for (const num2 of [s0, s1, s2, s3]) {
      for (let bytePos = 0; bytePos < 4; bytePos++) {
        const byte = num2 >>> 8 * bytePos & 255;
        for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {
          const bit = byte >>> W * bitPos & mask;
          const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];
          o0 ^= e0, o1 ^= e1, o2 ^= e2, o3 ^= e3;
          w += 1;
        }
      }
    }
    this.s0 = o0;
    this.s1 = o1;
    this.s2 = o2;
    this.s3 = o3;
  }
  update(data) {
    data = toBytes4(data);
    exists5(this);
    const b32 = u323(data);
    const blocks = Math.floor(data.length / BLOCK_SIZE);
    const left3 = data.length % BLOCK_SIZE;
    for (let i = 0; i < blocks; i++) {
      this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);
    }
    if (left3) {
      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
      this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);
      ZEROS32.fill(0);
    }
    return this;
  }
  destroy() {
    const { t } = this;
    for (const elm of t) {
      elm.s0 = 0, elm.s1 = 0, elm.s2 = 0, elm.s3 = 0;
    }
  }
  digestInto(out) {
    exists5(this);
    output2(out, this);
    this.finished = true;
    const { s0, s1, s2, s3 } = this;
    const o32 = u323(out);
    o32[0] = s0;
    o32[1] = s1;
    o32[2] = s2;
    o32[3] = s3;
    return out;
  }
  digest() {
    const res = new Uint8Array(BLOCK_SIZE);
    this.digestInto(res);
    this.destroy();
    return res;
  }
};
var Polyval = class extends GHASH {
  constructor(key, expectedLength) {
    key = toBytes4(key);
    const ghKey = _toGHASHKey(key.slice());
    super(ghKey, expectedLength);
    ghKey.fill(0);
  }
  update(data) {
    data = toBytes4(data);
    exists5(this);
    const b32 = u323(data);
    const left3 = data.length % BLOCK_SIZE;
    const blocks = Math.floor(data.length / BLOCK_SIZE);
    for (let i = 0; i < blocks; i++) {
      this._updateBlock(swapLE(b32[i * 4 + 3]), swapLE(b32[i * 4 + 2]), swapLE(b32[i * 4 + 1]), swapLE(b32[i * 4 + 0]));
    }
    if (left3) {
      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
      this._updateBlock(swapLE(ZEROS32[3]), swapLE(ZEROS32[2]), swapLE(ZEROS32[1]), swapLE(ZEROS32[0]));
      ZEROS32.fill(0);
    }
    return this;
  }
  digestInto(out) {
    exists5(this);
    output2(out, this);
    this.finished = true;
    const { s0, s1, s2, s3 } = this;
    const o32 = u323(out);
    o32[0] = s0;
    o32[1] = s1;
    o32[2] = s2;
    o32[3] = s3;
    return out.reverse();
  }
};
function wrapConstructorWithKey(hashCons) {
  const hashC = (msg, key) => hashCons(key, msg.length).update(toBytes4(msg)).digest();
  const tmp = hashCons(new Uint8Array(16), 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key, expectedLength) => hashCons(key, expectedLength);
  return hashC;
}
var ghash = wrapConstructorWithKey((key, expectedLength) => new GHASH(key, expectedLength));
var polyval = wrapConstructorWithKey((key, expectedLength) => new Polyval(key, expectedLength));

// ../../node_modules/.pnpm/@noble+ciphers@0.5.1/node_modules/@noble/ciphers/esm/aes.js
var BLOCK_SIZE2 = 16;
var BLOCK_SIZE32 = 4;
var EMPTY_BLOCK = new Uint8Array(BLOCK_SIZE2);
var POLY2 = 283;
function mul22(n) {
  return n << 1 ^ POLY2 & -(n >> 7);
}
function mul(a, b) {
  let res = 0;
  for (; b > 0; b >>= 1) {
    res ^= a & -(b & 1);
    a = mul22(a);
  }
  return res;
}
var sbox = /* @__PURE__ */ (() => {
  let t = new Uint8Array(256);
  for (let i = 0, x = 1; i < 256; i++, x ^= mul22(x))
    t[i] = x;
  const box = new Uint8Array(256);
  box[0] = 99;
  for (let i = 0; i < 255; i++) {
    let x = t[255 - i];
    x |= x << 8;
    box[t[i]] = (x ^ x >> 4 ^ x >> 5 ^ x >> 6 ^ x >> 7 ^ 99) & 255;
  }
  return box;
})();
var invSbox = /* @__PURE__ */ sbox.map((_, j) => sbox.indexOf(j));
var rotr32_8 = (n) => n << 24 | n >>> 8;
var rotl32_8 = (n) => n << 8 | n >>> 24;
function genTtable(sbox2, fn2) {
  if (sbox2.length !== 256)
    throw new Error("Wrong sbox length");
  const T0 = new Uint32Array(256).map((_, j) => fn2(sbox2[j]));
  const T1 = T0.map(rotl32_8);
  const T2 = T1.map(rotl32_8);
  const T3 = T2.map(rotl32_8);
  const T01 = new Uint32Array(256 * 256);
  const T23 = new Uint32Array(256 * 256);
  const sbox22 = new Uint16Array(256 * 256);
  for (let i = 0; i < 256; i++) {
    for (let j = 0; j < 256; j++) {
      const idx = i * 256 + j;
      T01[idx] = T0[i] ^ T1[j];
      T23[idx] = T2[i] ^ T3[j];
      sbox22[idx] = sbox2[i] << 8 | sbox2[j];
    }
  }
  return { sbox: sbox2, sbox2: sbox22, T0, T1, T2, T3, T01, T23 };
}
var tableEncoding = /* @__PURE__ */ genTtable(sbox, (s) => mul(s, 3) << 24 | s << 16 | s << 8 | mul(s, 2));
var tableDecoding = /* @__PURE__ */ genTtable(invSbox, (s) => mul(s, 11) << 24 | mul(s, 13) << 16 | mul(s, 9) << 8 | mul(s, 14));
var xPowers = /* @__PURE__ */ (() => {
  const p = new Uint8Array(16);
  for (let i = 0, x = 1; i < 16; i++, x = mul22(x))
    p[i] = x;
  return p;
})();
function expandKeyLE(key) {
  bytes2(key);
  const len = key.length;
  if (![16, 24, 32].includes(len))
    throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${len}`);
  const { sbox2 } = tableEncoding;
  const k32 = u323(key);
  const Nk = k32.length;
  const subByte = (n) => applySbox(sbox2, n, n, n, n);
  const xk = new Uint32Array(len + 28);
  xk.set(k32);
  for (let i = Nk; i < xk.length; i++) {
    let t = xk[i - 1];
    if (i % Nk === 0)
      t = subByte(rotr32_8(t)) ^ xPowers[i / Nk - 1];
    else if (Nk > 6 && i % Nk === 4)
      t = subByte(t);
    xk[i] = xk[i - Nk] ^ t;
  }
  return xk;
}
function expandKeyDecLE(key) {
  const encKey = expandKeyLE(key);
  const xk = encKey.slice();
  const Nk = encKey.length;
  const { sbox2 } = tableEncoding;
  const { T0, T1, T2, T3 } = tableDecoding;
  for (let i = 0; i < Nk; i += 4) {
    for (let j = 0; j < 4; j++)
      xk[i + j] = encKey[Nk - i - 4 + j];
  }
  encKey.fill(0);
  for (let i = 4; i < Nk - 4; i++) {
    const x = xk[i];
    const w = applySbox(sbox2, x, x, x, x);
    xk[i] = T0[w & 255] ^ T1[w >>> 8 & 255] ^ T2[w >>> 16 & 255] ^ T3[w >>> 24];
  }
  return xk;
}
function apply0123(T01, T23, s0, s1, s2, s3) {
  return T01[s0 << 8 & 65280 | s1 >>> 8 & 255] ^ T23[s2 >>> 8 & 65280 | s3 >>> 24 & 255];
}
function applySbox(sbox2, s0, s1, s2, s3) {
  return sbox2[s0 & 255 | s1 & 65280] | sbox2[s2 >>> 16 & 255 | s3 >>> 16 & 65280] << 16;
}
function encrypt(xk, s0, s1, s2, s3) {
  const { sbox2, T01, T23 } = tableEncoding;
  let k = 0;
  s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
  const rounds = xk.length / 4 - 2;
  for (let i = 0; i < rounds; i++) {
    const t02 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);
    const t12 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);
    const t22 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);
    const t32 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);
    s0 = t02, s1 = t12, s2 = t22, s3 = t32;
  }
  const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);
  const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);
  const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);
  const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);
  return { s0: t0, s1: t1, s2: t2, s3: t3 };
}
function decrypt(xk, s0, s1, s2, s3) {
  const { sbox2, T01, T23 } = tableDecoding;
  let k = 0;
  s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
  const rounds = xk.length / 4 - 2;
  for (let i = 0; i < rounds; i++) {
    const t02 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);
    const t12 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);
    const t22 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);
    const t32 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);
    s0 = t02, s1 = t12, s2 = t22, s3 = t32;
  }
  const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);
  const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);
  const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);
  const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);
  return { s0: t0, s1: t1, s2: t2, s3: t3 };
}
function getDst(len, dst) {
  if (!dst)
    return new Uint8Array(len);
  bytes2(dst);
  if (dst.length < len)
    throw new Error(`aes: wrong destination length, expected at least ${len}, got: ${dst.length}`);
  return dst;
}
function ctrCounter(xk, nonce, src, dst) {
  bytes2(nonce, BLOCK_SIZE2);
  bytes2(src);
  const srcLen = src.length;
  dst = getDst(srcLen, dst);
  const ctr3 = nonce;
  const c32 = u323(ctr3);
  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);
  const src32 = u323(src);
  const dst32 = u323(dst);
  for (let i = 0; i + 4 <= src32.length; i += 4) {
    dst32[i + 0] = src32[i + 0] ^ s0;
    dst32[i + 1] = src32[i + 1] ^ s1;
    dst32[i + 2] = src32[i + 2] ^ s2;
    dst32[i + 3] = src32[i + 3] ^ s3;
    let carry = 1;
    for (let i2 = ctr3.length - 1; i2 >= 0; i2--) {
      carry = carry + (ctr3[i2] & 255) | 0;
      ctr3[i2] = carry & 255;
      carry >>>= 8;
    }
    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));
  }
  const start5 = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
  if (start5 < srcLen) {
    const b32 = new Uint32Array([s0, s1, s2, s3]);
    const buf = u8(b32);
    for (let i = start5, pos = 0; i < srcLen; i++, pos++)
      dst[i] = src[i] ^ buf[pos];
  }
  return dst;
}
function ctr32(xk, isLE3, nonce, src, dst) {
  bytes2(nonce, BLOCK_SIZE2);
  bytes2(src);
  dst = getDst(src.length, dst);
  const ctr3 = nonce;
  const c32 = u323(ctr3);
  const view = createView4(ctr3);
  const src32 = u323(src);
  const dst32 = u323(dst);
  const ctrPos = isLE3 ? 0 : 12;
  const srcLen = src.length;
  let ctrNum = view.getUint32(ctrPos, isLE3);
  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);
  for (let i = 0; i + 4 <= src32.length; i += 4) {
    dst32[i + 0] = src32[i + 0] ^ s0;
    dst32[i + 1] = src32[i + 1] ^ s1;
    dst32[i + 2] = src32[i + 2] ^ s2;
    dst32[i + 3] = src32[i + 3] ^ s3;
    ctrNum = ctrNum + 1 >>> 0;
    view.setUint32(ctrPos, ctrNum, isLE3);
    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));
  }
  const start5 = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
  if (start5 < srcLen) {
    const b32 = new Uint32Array([s0, s1, s2, s3]);
    const buf = u8(b32);
    for (let i = start5, pos = 0; i < srcLen; i++, pos++)
      dst[i] = src[i] ^ buf[pos];
  }
  return dst;
}
var ctr = wrapCipher({ blockSize: 16, nonceLength: 16 }, function ctr2(key, nonce) {
  bytes2(key);
  bytes2(nonce, BLOCK_SIZE2);
  function processCtr(buf, dst) {
    const xk = expandKeyLE(key);
    const n = nonce.slice();
    const out = ctrCounter(xk, n, buf, dst);
    xk.fill(0);
    n.fill(0);
    return out;
  }
  return {
    encrypt: (plaintext, dst) => processCtr(plaintext, dst),
    decrypt: (ciphertext, dst) => processCtr(ciphertext, dst)
  };
});
function validateBlockDecrypt(data) {
  bytes2(data);
  if (data.length % BLOCK_SIZE2 !== 0) {
    throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE2}`);
  }
}
function validateBlockEncrypt(plaintext, pcks5, dst) {
  let outLen = plaintext.length;
  const remaining = outLen % BLOCK_SIZE2;
  if (!pcks5 && remaining !== 0)
    throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
  const b = u323(plaintext);
  if (pcks5) {
    let left3 = BLOCK_SIZE2 - remaining;
    if (!left3)
      left3 = BLOCK_SIZE2;
    outLen = outLen + left3;
  }
  const out = getDst(outLen, dst);
  const o = u323(out);
  return { b, o, out };
}
function validatePCKS(data, pcks5) {
  if (!pcks5)
    return data;
  const len = data.length;
  if (!len)
    throw new Error(`aes/pcks5: empty ciphertext not allowed`);
  const lastByte = data[len - 1];
  if (lastByte <= 0 || lastByte > 16)
    throw new Error(`aes/pcks5: wrong padding byte: ${lastByte}`);
  const out = data.subarray(0, -lastByte);
  for (let i = 0; i < lastByte; i++)
    if (data[len - i - 1] !== lastByte)
      throw new Error(`aes/pcks5: wrong padding`);
  return out;
}
function padPCKS(left3) {
  const tmp = new Uint8Array(16);
  const tmp32 = u323(tmp);
  tmp.set(left3);
  const paddingByte = BLOCK_SIZE2 - left3.length;
  for (let i = BLOCK_SIZE2 - paddingByte; i < BLOCK_SIZE2; i++)
    tmp[i] = paddingByte;
  return tmp32;
}
var ecb = wrapCipher({ blockSize: 16 }, function ecb2(key, opts = {}) {
  bytes2(key);
  const pcks5 = !opts.disablePadding;
  return {
    encrypt: (plaintext, dst) => {
      bytes2(plaintext);
      const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
      const xk = expandKeyLE(key);
      let i = 0;
      for (; i + 4 <= b.length; ) {
        const { s0, s1, s2, s3 } = encrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);
        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
      }
      if (pcks5) {
        const tmp32 = padPCKS(plaintext.subarray(i * 4));
        const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);
        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
      }
      xk.fill(0);
      return _out;
    },
    decrypt: (ciphertext, dst) => {
      validateBlockDecrypt(ciphertext);
      const xk = expandKeyDecLE(key);
      const out = getDst(ciphertext.length, dst);
      const b = u323(ciphertext);
      const o = u323(out);
      for (let i = 0; i + 4 <= b.length; ) {
        const { s0, s1, s2, s3 } = decrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);
        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
      }
      xk.fill(0);
      return validatePCKS(out, pcks5);
    }
  };
});
var cbc = wrapCipher({ blockSize: 16, nonceLength: 16 }, function cbc2(key, iv, opts = {}) {
  bytes2(key);
  bytes2(iv, 16);
  const pcks5 = !opts.disablePadding;
  return {
    encrypt: (plaintext, dst) => {
      const xk = expandKeyLE(key);
      const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
      const n32 = u323(iv);
      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
      let i = 0;
      for (; i + 4 <= b.length; ) {
        s0 ^= b[i + 0], s1 ^= b[i + 1], s2 ^= b[i + 2], s3 ^= b[i + 3];
        ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));
        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
      }
      if (pcks5) {
        const tmp32 = padPCKS(plaintext.subarray(i * 4));
        s0 ^= tmp32[0], s1 ^= tmp32[1], s2 ^= tmp32[2], s3 ^= tmp32[3];
        ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));
        o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
      }
      xk.fill(0);
      return _out;
    },
    decrypt: (ciphertext, dst) => {
      validateBlockDecrypt(ciphertext);
      const xk = expandKeyDecLE(key);
      const n32 = u323(iv);
      const out = getDst(ciphertext.length, dst);
      const b = u323(ciphertext);
      const o = u323(out);
      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
      for (let i = 0; i + 4 <= b.length; ) {
        const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;
        s0 = b[i + 0], s1 = b[i + 1], s2 = b[i + 2], s3 = b[i + 3];
        const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);
        o[i++] = o0 ^ ps0, o[i++] = o1 ^ ps1, o[i++] = o2 ^ ps2, o[i++] = o3 ^ ps3;
      }
      xk.fill(0);
      return validatePCKS(out, pcks5);
    }
  };
});
function computeTag(fn2, isLE3, key, data, AAD) {
  const h = fn2.create(key, data.length + (AAD?.length || 0));
  if (AAD)
    h.update(AAD);
  h.update(data);
  const num2 = new Uint8Array(16);
  const view = createView4(num2);
  if (AAD)
    setBigUint644(view, 0, BigInt(AAD.length * 8), isLE3);
  setBigUint644(view, 8, BigInt(data.length * 8), isLE3);
  h.update(num2);
  return h.digest();
}
var gcm = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function gcm2(key, nonce, AAD) {
  bytes2(nonce);
  if (nonce.length === 0)
    throw new Error("aes/gcm: empty nonce");
  const tagLength = 16;
  function _computeTag(authKey, tagMask, data) {
    const tag3 = computeTag(ghash, false, authKey, data, AAD);
    for (let i = 0; i < tagMask.length; i++)
      tag3[i] ^= tagMask[i];
    return tag3;
  }
  function deriveKeys() {
    const xk = expandKeyLE(key);
    const authKey = EMPTY_BLOCK.slice();
    const counter6 = EMPTY_BLOCK.slice();
    ctr32(xk, false, counter6, counter6, authKey);
    if (nonce.length === 12) {
      counter6.set(nonce);
    } else {
      const nonceLen = EMPTY_BLOCK.slice();
      const view = createView4(nonceLen);
      setBigUint644(view, 8, BigInt(nonce.length * 8), false);
      ghash.create(authKey).update(nonce).update(nonceLen).digestInto(counter6);
    }
    const tagMask = ctr32(xk, false, counter6, EMPTY_BLOCK);
    return { xk, authKey, counter: counter6, tagMask };
  }
  return {
    encrypt: (plaintext) => {
      bytes2(plaintext);
      const { xk, authKey, counter: counter6, tagMask } = deriveKeys();
      const out = new Uint8Array(plaintext.length + tagLength);
      ctr32(xk, false, counter6, plaintext, out);
      const tag3 = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));
      out.set(tag3, plaintext.length);
      xk.fill(0);
      return out;
    },
    decrypt: (ciphertext) => {
      bytes2(ciphertext);
      if (ciphertext.length < tagLength)
        throw new Error(`aes/gcm: ciphertext less than tagLen (${tagLength})`);
      const { xk, authKey, counter: counter6, tagMask } = deriveKeys();
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag3 = _computeTag(authKey, tagMask, data);
      if (!equalBytes2(tag3, passedTag))
        throw new Error("aes/gcm: invalid ghash tag");
      const out = ctr32(xk, false, counter6, data);
      authKey.fill(0);
      tagMask.fill(0);
      xk.fill(0);
      return out;
    }
  };
});
var limit = (name, min5, max7) => (value3) => {
  if (!Number.isSafeInteger(value3) || min5 > value3 || value3 > max7)
    throw new Error(`${name}: invalid value=${value3}, must be [${min5}..${max7}]`);
};
var siv = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function siv2(key, nonce, AAD) {
  const tagLength = 16;
  const AAD_LIMIT = limit("AAD", 0, 2 ** 36);
  const PLAIN_LIMIT = limit("plaintext", 0, 2 ** 36);
  const NONCE_LIMIT = limit("nonce", 12, 12);
  const CIPHER_LIMIT = limit("ciphertext", 16, 2 ** 36 + 16);
  bytes2(nonce);
  NONCE_LIMIT(nonce.length);
  if (AAD) {
    bytes2(AAD);
    AAD_LIMIT(AAD.length);
  }
  function deriveKeys() {
    const len = key.length;
    if (len !== 16 && len !== 24 && len !== 32)
      throw new Error(`key length must be 16, 24 or 32 bytes, got: ${len} bytes`);
    const xk = expandKeyLE(key);
    const encKey = new Uint8Array(len);
    const authKey = new Uint8Array(16);
    const n32 = u323(nonce);
    let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];
    let counter6 = 0;
    for (const derivedKey of [authKey, encKey].map(u323)) {
      const d32 = u323(derivedKey);
      for (let i = 0; i < d32.length; i += 2) {
        const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);
        d32[i + 0] = o0;
        d32[i + 1] = o1;
        s0 = ++counter6;
      }
    }
    xk.fill(0);
    return { authKey, encKey: expandKeyLE(encKey) };
  }
  function _computeTag(encKey, authKey, data) {
    const tag3 = computeTag(polyval, true, authKey, data, AAD);
    for (let i = 0; i < 12; i++)
      tag3[i] ^= nonce[i];
    tag3[15] &= 127;
    const t32 = u323(tag3);
    let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];
    ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));
    t32[0] = s0, t32[1] = s1, t32[2] = s2, t32[3] = s3;
    return tag3;
  }
  function processSiv(encKey, tag3, input) {
    let block = tag3.slice();
    block[15] |= 128;
    return ctr32(encKey, true, block, input);
  }
  return {
    encrypt: (plaintext) => {
      bytes2(plaintext);
      PLAIN_LIMIT(plaintext.length);
      const { encKey, authKey } = deriveKeys();
      const tag3 = _computeTag(encKey, authKey, plaintext);
      const out = new Uint8Array(plaintext.length + tagLength);
      out.set(tag3, plaintext.length);
      out.set(processSiv(encKey, tag3, plaintext));
      encKey.fill(0);
      authKey.fill(0);
      return out;
    },
    decrypt: (ciphertext) => {
      bytes2(ciphertext);
      CIPHER_LIMIT(ciphertext.length);
      const tag3 = ciphertext.subarray(-tagLength);
      const { encKey, authKey } = deriveKeys();
      const plaintext = processSiv(encKey, tag3, ciphertext.subarray(0, -tagLength));
      const expectedTag = _computeTag(encKey, authKey, plaintext);
      encKey.fill(0);
      authKey.fill(0);
      if (!equalBytes2(tag3, expectedTag))
        throw new Error("invalid polyval tag");
      return plaintext;
    }
  };
});

// ../../packages/nostr/src/nips/nip04-browser.ts
var EncryptedMessage = Schema_exports.Struct({
  content: Schema_exports.String,
  iv: Schema_exports.optional(Schema_exports.String),
  mac: Schema_exports.optional(Schema_exports.String)
});
var DirectMessageEvent = Schema_exports.Struct({
  id: Schema_exports.String,
  pubkey: PublicKey,
  created_at: Schema_exports.Number,
  kind: Schema_exports.Literal(4),
  tags: Schema_exports.Array(Schema_exports.Array(Schema_exports.String)),
  content: Schema_exports.String,
  sig: Signature
});
var MessageMetadata = Schema_exports.Struct({
  sender: PublicKey,
  recipient: PublicKey,
  timestamp: Schema_exports.Number,
  messageId: Schema_exports.String,
  conversationId: Schema_exports.optional(Schema_exports.String)
});
var DecryptedMessage = Schema_exports.Struct({
  content: Schema_exports.String,
  metadata: MessageMetadata,
  verified: Schema_exports.Boolean
});
var Nip04Error = class extends Data_exports.TaggedError("Nip04Error") {
};
var utf8Encoder = new TextEncoder();
var utf8Decoder = new TextDecoder();
function getNormalizedX(key) {
  return key.slice(1, 33);
}
var Nip04Service = class extends Context_exports.Tag("nips/Nip04Service")() {
};
var makeNip04Service = () => ({
  encryptMessage: (message, recipientPubkey, senderPrivkey) => Effect_exports.gen(function* () {
    try {
      const privkey = typeof senderPrivkey === "string" ? senderPrivkey : bytesToHex3(senderPrivkey);
      const key = secp256k1.getSharedSecret(privkey, "02" + recipientPubkey);
      const normalizedKey = getNormalizedX(key);
      const iv = randomBytes2(16);
      const plaintext = utf8Encoder.encode(message);
      const cipher = cbc(normalizedKey, iv);
      const ciphertext = cipher.encrypt(plaintext);
      const ctb64 = base642.encode(new Uint8Array(ciphertext));
      const ivb64 = base642.encode(new Uint8Array(iv));
      return {
        content: `${ctb64}?iv=${ivb64}`,
        iv: ivb64,
        mac: void 0
      };
    } catch (error2) {
      return yield* Effect_exports.fail(
        new Nip04Error({
          reason: "encryption_failed",
          message: `Failed to encrypt message: ${error2}`,
          recipient: recipientPubkey,
          cause: error2
        })
      );
    }
  }),
  decryptMessage: (encryptedMessage, senderPubkey, recipientPrivkey) => Effect_exports.gen(function* () {
    try {
      const data = encryptedMessage.content;
      const [ctb64, ivb64] = data.split("?iv=");
      if (!ctb64 || !ivb64) {
        return yield* Effect_exports.fail(
          new Nip04Error({
            reason: "invalid_message",
            message: "Invalid NIP-04 format",
            sender: senderPubkey
          })
        );
      }
      const privkey = typeof recipientPrivkey === "string" ? recipientPrivkey : bytesToHex3(recipientPrivkey);
      const key = secp256k1.getSharedSecret(privkey, "02" + senderPubkey);
      const normalizedKey = getNormalizedX(key);
      const iv = base642.decode(ivb64);
      const ciphertext = base642.decode(ctb64);
      const cipher = cbc(normalizedKey, iv);
      const plaintext = cipher.decrypt(ciphertext);
      return utf8Decoder.decode(plaintext);
    } catch (error2) {
      return yield* Effect_exports.fail(
        new Nip04Error({
          reason: "decryption_failed",
          message: `Failed to decrypt message: ${error2}`,
          sender: senderPubkey,
          cause: error2
        })
      );
    }
  }),
  createDirectMessage: (message, recipientPubkey, senderPrivkey, conversationId) => Effect_exports.gen(function* () {
    const encrypted = yield* makeNip04Service().encryptMessage(
      message,
      recipientPubkey,
      senderPrivkey
    );
    const tags = [["p", recipientPubkey]];
    if (conversationId) {
      tags.push(["conversation", conversationId]);
    }
    const now2 = Math.floor(Date.now() / 1e3);
    return {
      id: "placeholder-id",
      pubkey: "placeholder-pubkey",
      created_at: now2,
      kind: 4,
      tags,
      content: encrypted.content,
      sig: "placeholder-signature"
    };
  }),
  parseDirectMessage: (event, recipientPrivkey) => Effect_exports.gen(function* () {
    const pTag = event.tags.find((tag3) => tag3[0] === "p");
    if (!pTag || !pTag[1]) {
      return yield* Effect_exports.fail(
        new Nip04Error({
          reason: "invalid_message",
          message: "Missing recipient p-tag",
          messageId: event.id
        })
      );
    }
    const recipientPubkey = pTag[1];
    const encryptedMessage = { content: event.content };
    const decryptedContent = yield* makeNip04Service().decryptMessage(
      encryptedMessage,
      event.pubkey,
      recipientPrivkey
    );
    const conversationTag = event.tags.find((tag3) => tag3[0] === "conversation");
    const conversationId = conversationTag?.[1];
    return {
      content: decryptedContent,
      metadata: {
        sender: event.pubkey,
        recipient: recipientPubkey,
        timestamp: event.created_at,
        messageId: event.id,
        conversationId
      },
      verified: true
    };
  }),
  deriveSharedSecret: (privateKey, publicKey) => Effect_exports.try({
    try: () => {
      const privkey = typeof privateKey === "string" ? privateKey : bytesToHex3(privateKey);
      const key = secp256k1.getSharedSecret(privkey, "02" + publicKey);
      return getNormalizedX(key);
    },
    catch: (error2) => new Nip04Error({
      reason: "key_derivation_failed",
      message: `Failed to derive shared secret: ${error2}`,
      cause: error2
    })
  }),
  createConversationId: (pubkey1, pubkey2) => Effect_exports.sync(() => {
    const sortedKeys = [pubkey1, pubkey2].sort();
    return sortedKeys.join("-").substring(0, 16);
  }),
  validateEncryption: (encryptedMessage) => Effect_exports.gen(function* () {
    const data = encryptedMessage.content;
    const parts2 = data.split("?iv=");
    if (parts2.length !== 2) {
      return yield* Effect_exports.fail(
        new Nip04Error({
          reason: "invalid_message",
          message: "Invalid NIP-04 format"
        })
      );
    }
    try {
      base642.decode(parts2[0]);
      base642.decode(parts2[1]);
    } catch (error2) {
      return yield* Effect_exports.fail(
        new Nip04Error({
          reason: "invalid_message",
          message: "Invalid base64 encoding",
          cause: error2
        })
      );
    }
    const ivBytes = base642.decode(parts2[1]);
    if (ivBytes.length !== 16) {
      return yield* Effect_exports.fail(
        new Nip04Error({
          reason: "invalid_message",
          message: `Invalid IV length: ${ivBytes.length}`
        })
      );
    }
  })
});
var Nip04ServiceLive = Layer_exports.succeed(
  Nip04Service,
  makeNip04Service()
);

// ../../node_modules/.pnpm/@noble+ciphers@0.5.1/node_modules/@noble/ciphers/esm/_poly1305.js
var u8to16 = (a, i) => a[i++] & 255 | (a[i++] & 255) << 8;
var Poly1305 = class {
  constructor(key) {
    this.blockLen = 16;
    this.outputLen = 16;
    this.buffer = new Uint8Array(16);
    this.r = new Uint16Array(10);
    this.h = new Uint16Array(10);
    this.pad = new Uint16Array(8);
    this.pos = 0;
    this.finished = false;
    key = toBytes4(key);
    bytes2(key, 32);
    const t0 = u8to16(key, 0);
    const t1 = u8to16(key, 2);
    const t2 = u8to16(key, 4);
    const t3 = u8to16(key, 6);
    const t4 = u8to16(key, 8);
    const t5 = u8to16(key, 10);
    const t6 = u8to16(key, 12);
    const t7 = u8to16(key, 14);
    this.r[0] = t0 & 8191;
    this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
    this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
    this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
    this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
    this.r[5] = t4 >>> 1 & 8190;
    this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
    this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
    this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
    this.r[9] = t7 >>> 5 & 127;
    for (let i = 0; i < 8; i++)
      this.pad[i] = u8to16(key, 16 + 2 * i);
  }
  process(data, offset, isLast = false) {
    const hibit = isLast ? 0 : 1 << 11;
    const { h, r } = this;
    const r0 = r[0];
    const r1 = r[1];
    const r2 = r[2];
    const r3 = r[3];
    const r4 = r[4];
    const r5 = r[5];
    const r6 = r[6];
    const r7 = r[7];
    const r8 = r[8];
    const r9 = r[9];
    const t0 = u8to16(data, offset + 0);
    const t1 = u8to16(data, offset + 2);
    const t2 = u8to16(data, offset + 4);
    const t3 = u8to16(data, offset + 6);
    const t4 = u8to16(data, offset + 8);
    const t5 = u8to16(data, offset + 10);
    const t6 = u8to16(data, offset + 12);
    const t7 = u8to16(data, offset + 14);
    let h0 = h[0] + (t0 & 8191);
    let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
    let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
    let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
    let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
    let h5 = h[5] + (t4 >>> 1 & 8191);
    let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
    let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
    let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
    let h9 = h[9] + (t7 >>> 5 | hibit);
    let c = 0;
    let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
    c = d0 >>> 13;
    d0 &= 8191;
    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
    c += d0 >>> 13;
    d0 &= 8191;
    let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
    c = d1 >>> 13;
    d1 &= 8191;
    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
    c += d1 >>> 13;
    d1 &= 8191;
    let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
    c = d2 >>> 13;
    d2 &= 8191;
    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
    c += d2 >>> 13;
    d2 &= 8191;
    let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
    c = d3 >>> 13;
    d3 &= 8191;
    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
    c += d3 >>> 13;
    d3 &= 8191;
    let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
    c = d4 >>> 13;
    d4 &= 8191;
    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
    c += d4 >>> 13;
    d4 &= 8191;
    let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
    c = d5 >>> 13;
    d5 &= 8191;
    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
    c += d5 >>> 13;
    d5 &= 8191;
    let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
    c = d6 >>> 13;
    d6 &= 8191;
    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
    c += d6 >>> 13;
    d6 &= 8191;
    let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
    c = d7 >>> 13;
    d7 &= 8191;
    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
    c += d7 >>> 13;
    d7 &= 8191;
    let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
    c = d8 >>> 13;
    d8 &= 8191;
    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
    c += d8 >>> 13;
    d8 &= 8191;
    let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
    c = d9 >>> 13;
    d9 &= 8191;
    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
    c += d9 >>> 13;
    d9 &= 8191;
    c = (c << 2) + c | 0;
    c = c + d0 | 0;
    d0 = c & 8191;
    c = c >>> 13;
    d1 += c;
    h[0] = d0;
    h[1] = d1;
    h[2] = d2;
    h[3] = d3;
    h[4] = d4;
    h[5] = d5;
    h[6] = d6;
    h[7] = d7;
    h[8] = d8;
    h[9] = d9;
  }
  finalize() {
    const { h, pad: pad3 } = this;
    const g = new Uint16Array(10);
    let c = h[1] >>> 13;
    h[1] &= 8191;
    for (let i = 2; i < 10; i++) {
      h[i] += c;
      c = h[i] >>> 13;
      h[i] &= 8191;
    }
    h[0] += c * 5;
    c = h[0] >>> 13;
    h[0] &= 8191;
    h[1] += c;
    c = h[1] >>> 13;
    h[1] &= 8191;
    h[2] += c;
    g[0] = h[0] + 5;
    c = g[0] >>> 13;
    g[0] &= 8191;
    for (let i = 1; i < 10; i++) {
      g[i] = h[i] + c;
      c = g[i] >>> 13;
      g[i] &= 8191;
    }
    g[9] -= 1 << 13;
    let mask = (c ^ 1) - 1;
    for (let i = 0; i < 10; i++)
      g[i] &= mask;
    mask = ~mask;
    for (let i = 0; i < 10; i++)
      h[i] = h[i] & mask | g[i];
    h[0] = (h[0] | h[1] << 13) & 65535;
    h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
    h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
    h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
    h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
    h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
    h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
    h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
    let f = h[0] + pad3[0];
    h[0] = f & 65535;
    for (let i = 1; i < 8; i++) {
      f = (h[i] + pad3[i] | 0) + (f >>> 16) | 0;
      h[i] = f & 65535;
    }
  }
  update(data) {
    exists5(this);
    const { buffer: buffer3, blockLen } = this;
    data = toBytes4(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take10 = Math.min(blockLen - this.pos, len - pos);
      if (take10 === blockLen) {
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(data, pos);
        continue;
      }
      buffer3.set(data.subarray(pos, pos + take10), this.pos);
      this.pos += take10;
      pos += take10;
      if (this.pos === blockLen) {
        this.process(buffer3, 0, false);
        this.pos = 0;
      }
    }
    return this;
  }
  destroy() {
    this.h.fill(0);
    this.r.fill(0);
    this.buffer.fill(0);
    this.pad.fill(0);
  }
  digestInto(out) {
    exists5(this);
    output2(out, this);
    this.finished = true;
    const { buffer: buffer3, h } = this;
    let { pos } = this;
    if (pos) {
      buffer3[pos++] = 1;
      for (; pos < 16; pos++)
        buffer3[pos] = 0;
      this.process(buffer3, 0, true);
    }
    this.finalize();
    let opos = 0;
    for (let i = 0; i < 8; i++) {
      out[opos++] = h[i] >>> 0;
      out[opos++] = h[i] >>> 8;
    }
    return out;
  }
  digest() {
    const { buffer: buffer3, outputLen } = this;
    this.digestInto(buffer3);
    const res = buffer3.slice(0, outputLen);
    this.destroy();
    return res;
  }
};
function wrapConstructorWithKey2(hashCons) {
  const hashC = (msg, key) => hashCons(key).update(toBytes4(msg)).digest();
  const tmp = hashCons(new Uint8Array(32));
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key) => hashCons(key);
  return hashC;
}
var poly1305 = wrapConstructorWithKey2((key) => new Poly1305(key));

// ../../node_modules/.pnpm/@noble+ciphers@0.5.1/node_modules/@noble/ciphers/esm/_arx.js
var sigma16 = utf8ToBytes5("expand 16-byte k");
var sigma32 = utf8ToBytes5("expand 32-byte k");
var sigma16_32 = u323(sigma16);
var sigma32_32 = u323(sigma32);
function rotl2(a, b) {
  return a << b | a >>> 32 - b;
}
function isAligned32(b) {
  return b.byteOffset % 4 === 0;
}
var BLOCK_LEN = 64;
var BLOCK_LEN32 = 16;
var MAX_COUNTER = 2 ** 32 - 1;
var U32_EMPTY = new Uint32Array();
function runCipher(core, sigma, key, nonce, data, output3, counter6, rounds) {
  const len = data.length;
  const block = new Uint8Array(BLOCK_LEN);
  const b32 = u323(block);
  const isAligned = isAligned32(data) && isAligned32(output3);
  const d32 = isAligned ? u323(data) : U32_EMPTY;
  const o32 = isAligned ? u323(output3) : U32_EMPTY;
  for (let pos = 0; pos < len; counter6++) {
    core(sigma, key, nonce, b32, counter6, rounds);
    if (counter6 >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    const take10 = Math.min(BLOCK_LEN, len - pos);
    if (isAligned && take10 === BLOCK_LEN) {
      const pos32 = pos / 4;
      if (pos % 4 !== 0)
        throw new Error("arx: invalid block position");
      for (let j = 0, posj; j < BLOCK_LEN32; j++) {
        posj = pos32 + j;
        o32[posj] = d32[posj] ^ b32[j];
      }
      pos += BLOCK_LEN;
      continue;
    }
    for (let j = 0, posj; j < take10; j++) {
      posj = pos + j;
      output3[posj] = data[posj] ^ block[j];
    }
    pos += take10;
  }
}
function createCipher(core, opts) {
  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts2({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
  if (typeof core !== "function")
    throw new Error("core must be a function");
  number6(counterLength);
  number6(rounds);
  bool(counterRight);
  bool(allowShortKeys);
  return (key, nonce, data, output3, counter6 = 0) => {
    bytes2(key);
    bytes2(nonce);
    bytes2(data);
    const len = data.length;
    if (!output3)
      output3 = new Uint8Array(len);
    bytes2(output3);
    number6(counter6);
    if (counter6 < 0 || counter6 >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    if (output3.length < len)
      throw new Error(`arx: output (${output3.length}) is shorter than data (${len})`);
    const toClean = [];
    let l = key.length, k, sigma;
    if (l === 32) {
      k = key.slice();
      toClean.push(k);
      sigma = sigma32_32;
    } else if (l === 16 && allowShortKeys) {
      k = new Uint8Array(32);
      k.set(key);
      k.set(key, 16);
      sigma = sigma16_32;
      toClean.push(k);
    } else {
      throw new Error(`arx: invalid 32-byte key, got length=${l}`);
    }
    if (!isAligned32(nonce)) {
      nonce = nonce.slice();
      toClean.push(nonce);
    }
    const k32 = u323(k);
    if (extendNonceFn) {
      if (nonce.length !== 24)
        throw new Error(`arx: extended nonce must be 24 bytes`);
      extendNonceFn(sigma, k32, u323(nonce.subarray(0, 16)), k32);
      nonce = nonce.subarray(16);
    }
    const nonceNcLen = 16 - counterLength;
    if (nonceNcLen !== nonce.length)
      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
    if (nonceNcLen !== 12) {
      const nc = new Uint8Array(12);
      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
      nonce = nc;
      toClean.push(nonce);
    }
    const n32 = u323(nonce);
    runCipher(core, sigma, k32, n32, data, output3, counter6, rounds);
    while (toClean.length > 0)
      toClean.pop().fill(0);
    return output3;
  };
}

// ../../node_modules/.pnpm/@noble+ciphers@0.5.1/node_modules/@noble/ciphers/esm/chacha.js
function chachaCore(s, k, n, out, cnt, rounds = 20) {
  let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let r = 0; r < rounds; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 7);
  }
  let oi = 0;
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function hchacha(s, k, i, o32) {
  let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];
  for (let r = 0; r < 20; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl2(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl2(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl2(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl2(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl2(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl2(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl2(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl2(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl2(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl2(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl2(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl2(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl2(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl2(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl2(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl2(x04 ^ x09, 7);
  }
  let oi = 0;
  o32[oi++] = x00;
  o32[oi++] = x01;
  o32[oi++] = x02;
  o32[oi++] = x03;
  o32[oi++] = x12;
  o32[oi++] = x13;
  o32[oi++] = x14;
  o32[oi++] = x15;
}
var chacha20 = /* @__PURE__ */ createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  allowShortKeys: false
});
var xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  extendNonceFn: hchacha,
  allowShortKeys: false
});
var ZEROS162 = /* @__PURE__ */ new Uint8Array(16);
var updatePadded = (h, msg) => {
  h.update(msg);
  const left3 = msg.length % 16;
  if (left3)
    h.update(ZEROS162.subarray(left3));
};
var ZEROS322 = /* @__PURE__ */ new Uint8Array(32);
function computeTag2(fn2, key, nonce, data, AAD) {
  const authKey = fn2(key, nonce, ZEROS322);
  const h = poly1305.create(authKey);
  if (AAD)
    updatePadded(h, AAD);
  updatePadded(h, data);
  const num2 = new Uint8Array(16);
  const view = createView4(num2);
  setBigUint644(view, 0, BigInt(AAD ? AAD.length : 0), true);
  setBigUint644(view, 8, BigInt(data.length), true);
  h.update(num2);
  const res = h.digest();
  authKey.fill(0);
  return res;
}
var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
  const tagLength = 16;
  bytes2(key, 32);
  bytes2(nonce);
  return {
    encrypt: (plaintext, output3) => {
      const plength = plaintext.length;
      const clength = plength + tagLength;
      if (output3) {
        bytes2(output3, clength);
      } else {
        output3 = new Uint8Array(clength);
      }
      xorStream(key, nonce, plaintext, output3, 1);
      const tag3 = computeTag2(xorStream, key, nonce, output3.subarray(0, -tagLength), AAD);
      output3.set(tag3, plength);
      return output3;
    },
    decrypt: (ciphertext, output3) => {
      const clength = ciphertext.length;
      const plength = clength - tagLength;
      if (clength < tagLength)
        throw new Error(`encrypted data must be at least ${tagLength} bytes`);
      if (output3) {
        bytes2(output3, plength);
      } else {
        output3 = new Uint8Array(plength);
      }
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag3 = computeTag2(xorStream, key, nonce, data, AAD);
      if (!equalBytes2(passedTag, tag3))
        throw new Error("invalid tag");
      xorStream(key, nonce, data, output3, 1);
      return output3;
    }
  };
};
var chacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));
var xchacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));

// ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/hmac.js
var HMAC3 = class extends Hash2 {
  constructor(hash4, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash3(hash4);
    const key = toBytes2(_key);
    this.iHash = hash4.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad3 = new Uint8Array(blockLen);
    pad3.set(key.length > blockLen ? hash4.create().update(key).digest() : key);
    for (let i = 0; i < pad3.length; i++)
      pad3[i] ^= 54;
    this.iHash.update(pad3);
    this.oHash = hash4.create();
    for (let i = 0; i < pad3.length; i++)
      pad3[i] ^= 54 ^ 92;
    this.oHash.update(pad3);
    pad3.fill(0);
  }
  update(buf) {
    exists4(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists4(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac3 = (hash4, key, message) => new HMAC3(hash4, key).update(message).digest();
hmac3.create = (hash4, key) => new HMAC3(hash4, key);

// ../../node_modules/.pnpm/@noble+hashes@1.3.3/node_modules/@noble/hashes/esm/hkdf.js
function extract(hash4, ikm, salt) {
  hash3(hash4);
  if (salt === void 0)
    salt = new Uint8Array(hash4.outputLen);
  return hmac3(hash4, toBytes2(salt), toBytes2(ikm));
}
var HKDF_COUNTER = /* @__PURE__ */ new Uint8Array([0]);
var EMPTY_BUFFER = /* @__PURE__ */ new Uint8Array();
function expand2(hash4, prk, info, length5 = 32) {
  hash3(hash4);
  number5(length5);
  if (length5 > 255 * hash4.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const blocks = Math.ceil(length5 / hash4.outputLen);
  if (info === void 0)
    info = EMPTY_BUFFER;
  const okm = new Uint8Array(blocks * hash4.outputLen);
  const HMAC4 = hmac3.create(hash4, prk);
  const HMACTmp = HMAC4._cloneInto();
  const T = new Uint8Array(HMAC4.outputLen);
  for (let counter6 = 0; counter6 < blocks; counter6++) {
    HKDF_COUNTER[0] = counter6 + 1;
    HMACTmp.update(counter6 === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
    okm.set(T, hash4.outputLen * counter6);
    HMAC4._cloneInto(HMACTmp);
  }
  HMAC4.destroy();
  HMACTmp.destroy();
  T.fill(0);
  HKDF_COUNTER.fill(0);
  return okm.slice(0, length5);
}
var hkdf = (hash4, ikm, salt, info, length5) => expand2(hash4, extract(hash4, ikm, salt), info, length5);

// ../../packages/nostr/src/nips/nip44-browser.ts
var EncryptionVersion = Schema_exports.Literal(1, 2);
var VersionedEncryptedMessage = Schema_exports.Struct({
  version: EncryptionVersion,
  nonce: Schema_exports.String,
  ciphertext: Schema_exports.String,
  mac: Schema_exports.optional(Schema_exports.String),
  payload: Schema_exports.String
});
var EncryptedDirectMessage = Schema_exports.Struct({
  id: Schema_exports.String,
  pubkey: PublicKey,
  created_at: Schema_exports.Number,
  kind: Schema_exports.Literal(4),
  tags: Schema_exports.Array(Schema_exports.Array(Schema_exports.String)),
  content: Schema_exports.String,
  sig: Signature
});
var ConversationKey = Schema_exports.Struct({
  sharedSecret: Schema_exports.String,
  conversationKey: Schema_exports.String,
  createdAt: Schema_exports.Number,
  expiresAt: Schema_exports.Number
});
var Nip44Error = class extends Data_exports.TaggedError("Nip44Error") {
};
var minPlaintextSize = 1;
var maxPlaintextSize = 65535;
var utf8Encoder2 = new TextEncoder();
var utf8Decoder2 = new TextDecoder();
function hexToUint8Array(hex) {
  const array6 = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    array6[i / 2] = parseInt(hex.substr(i, 2), 16);
  }
  return array6;
}
function getConversationKey(privkeyA, pubkeyB) {
  const privkey = typeof privkeyA === "string" ? hexToUint8Array(privkeyA) : privkeyA;
  const sharedX = secp256k1.getSharedSecret(privkey, "02" + pubkeyB).subarray(1, 33);
  return hkdf(sha2562, sharedX, "nip44-v2", void 0, 32);
}
function getMessageKeys(conversationKey, nonce) {
  const keys6 = hkdf(sha2562, conversationKey, nonce, void 0, 76);
  return {
    chacha_key: keys6.subarray(0, 32),
    chacha_nonce: keys6.subarray(32, 44),
    hmac_key: keys6.subarray(44, 76)
  };
}
function calcPaddedLen(len) {
  if (!Number.isSafeInteger(len) || len < 1) throw new Error("expected positive integer");
  if (len <= 32) return 32;
  const nextPower = 1 << Math.floor(Math.log2(len - 1)) + 1;
  const chunk4 = nextPower <= 256 ? 32 : nextPower / 8;
  return chunk4 * (Math.floor((len - 1) / chunk4) + 1);
}
function writeU16BE(num2) {
  if (!Number.isSafeInteger(num2) || num2 < minPlaintextSize || num2 > maxPlaintextSize) {
    throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");
  }
  const arr = new Uint8Array(2);
  new DataView(arr.buffer).setUint16(0, num2, false);
  return arr;
}
function pad2(plaintext) {
  const unpadded = utf8Encoder2.encode(plaintext);
  const unpaddedLen = unpadded.length;
  const prefix = writeU16BE(unpaddedLen);
  const suffix = new Uint8Array(calcPaddedLen(unpaddedLen) - unpaddedLen);
  return concatBytes3(prefix, unpadded, suffix);
}
function unpad(padded) {
  const unpaddedLen = new DataView(padded.buffer).getUint16(0);
  const unpadded = padded.subarray(2, 2 + unpaddedLen);
  if (unpaddedLen < minPlaintextSize || unpaddedLen > maxPlaintextSize || unpadded.length !== unpaddedLen || padded.length !== 2 + calcPaddedLen(unpaddedLen)) {
    throw new Error("invalid padding");
  }
  return utf8Decoder2.decode(unpadded);
}
function hmacAad(key, message, aad) {
  if (aad.length !== 32) throw new Error("AAD associated data must be 32 bytes");
  const combined = concatBytes3(aad, message);
  return hmac3(sha2562, key, combined);
}
var Nip44Service = class extends Context_exports.Tag("nips/Nip44Service")() {
};
var makeNip44Service = () => ({
  encrypt: (message, recipientPubkey, senderPrivkey) => Effect_exports.gen(function* () {
    try {
      const conversationKey = getConversationKey(senderPrivkey, recipientPubkey);
      const nonce = randomBytes2(32);
      const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);
      const padded = pad2(message);
      const ciphertext = chacha20(chacha_key, chacha_nonce, padded);
      const mac = hmacAad(hmac_key, ciphertext, nonce);
      const payload = base642.encode(concatBytes3(new Uint8Array([2]), nonce, ciphertext, mac));
      return {
        version: 2,
        nonce: base642.encode(nonce),
        ciphertext: base642.encode(ciphertext),
        mac: base642.encode(mac),
        payload
      };
    } catch (error2) {
      return yield* Effect_exports.fail(
        new Nip44Error({
          reason: "encryption_failed",
          message: `Failed to encrypt message: ${error2}`,
          recipient: recipientPubkey,
          cause: error2
        })
      );
    }
  }),
  decrypt: (encryptedMessage, senderPubkey, recipientPrivkey) => Effect_exports.gen(function* () {
    try {
      if (encryptedMessage.version !== 2) {
        return yield* Effect_exports.fail(
          new Nip44Error({
            reason: "unsupported_version",
            message: `Unsupported version: ${encryptedMessage.version}`,
            version: encryptedMessage.version
          })
        );
      }
      const conversationKey = getConversationKey(recipientPrivkey, senderPubkey);
      const nonce = base642.decode(encryptedMessage.nonce);
      const ciphertext = base642.decode(encryptedMessage.ciphertext);
      const receivedMac = base642.decode(encryptedMessage.mac);
      const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);
      const calculatedMac = hmacAad(hmac_key, ciphertext, nonce);
      if (!equalBytes2(calculatedMac, receivedMac)) {
        return yield* Effect_exports.fail(
          new Nip44Error({
            reason: "authentication_failed",
            message: "Invalid MAC",
            sender: senderPubkey
          })
        );
      }
      const padded = chacha20(chacha_key, chacha_nonce, ciphertext);
      return unpad(padded);
    } catch (error2) {
      return yield* Effect_exports.fail(
        new Nip44Error({
          reason: "decryption_failed",
          message: `Failed to decrypt: ${error2}`,
          sender: senderPubkey,
          cause: error2
        })
      );
    }
  }),
  encryptFromPayload: (message, recipientPubkey, senderPrivkey) => Effect_exports.gen(function* () {
    const encrypted = yield* makeNip44Service().encrypt(message, recipientPubkey, senderPrivkey);
    return encrypted.payload;
  }),
  decryptFromPayload: (payload, senderPubkey, recipientPrivkey) => Effect_exports.gen(function* () {
    const service3 = makeNip44Service();
    const parsed = yield* service3.parsePayload(payload);
    return yield* service3.decrypt(parsed, senderPubkey, recipientPrivkey);
  }),
  parsePayload: (payload) => Effect_exports.gen(function* () {
    try {
      const data = base642.decode(payload);
      if (data.length < 99) {
        throw new Error("payload too short");
      }
      const version = data[0];
      if (version !== 2) {
        throw new Error(`unsupported version ${version}`);
      }
      const nonce = data.subarray(1, 33);
      const ciphertext = data.subarray(33, -32);
      const mac = data.subarray(-32);
      return {
        version: 2,
        nonce: base642.encode(nonce),
        ciphertext: base642.encode(ciphertext),
        mac: base642.encode(mac),
        payload
      };
    } catch (error2) {
      return yield* Effect_exports.fail(
        new Nip44Error({
          reason: "invalid_format",
          message: `Failed to parse payload: ${error2}`,
          cause: error2
        })
      );
    }
  }),
  deriveConversationKey: (privateKey, publicKey) => Effect_exports.gen(function* () {
    try {
      const conversationKey = getConversationKey(privateKey, publicKey);
      const privkey = typeof privateKey === "string" ? hexToUint8Array(privateKey) : privateKey;
      const sharedX = secp256k1.getSharedSecret(privkey, "02" + publicKey).subarray(1, 33);
      return {
        sharedSecret: bytesToHex3(sharedX),
        conversationKey: bytesToHex3(conversationKey),
        createdAt: Date.now(),
        expiresAt: Date.now() + 24 * 60 * 60 * 1e3
      };
    } catch (error2) {
      return yield* Effect_exports.fail(
        new Nip44Error({
          reason: "key_derivation_failed",
          message: `Failed to derive key: ${error2}`,
          cause: error2
        })
      );
    }
  }),
  validateFormat: (encryptedMessage) => Effect_exports.gen(function* () {
    if (encryptedMessage.version !== 2) {
      return yield* Effect_exports.fail(
        new Nip44Error({
          reason: "invalid_version",
          message: `Invalid version: ${encryptedMessage.version}`,
          version: encryptedMessage.version
        })
      );
    }
    try {
      base642.decode(encryptedMessage.nonce);
      base642.decode(encryptedMessage.ciphertext);
      if (encryptedMessage.mac) base642.decode(encryptedMessage.mac);
      base642.decode(encryptedMessage.payload);
    } catch (error2) {
      return yield* Effect_exports.fail(
        new Nip44Error({
          reason: "invalid_format",
          message: "Invalid base64 encoding",
          cause: error2
        })
      );
    }
  })
});
var Nip44ServiceLive = Layer_exports.succeed(
  Nip44Service,
  makeNip44Service()
);

// ../../packages/nostr/src/services/RelayPoolService.ts
var RelayPoolService = Context_exports.GenericTag("nostr/RelayPoolService");
var RelayPoolServiceLive = Layer_exports.effect(
  RelayPoolService,
  Effect_exports.gen(function* () {
    const relayService = yield* RelayService;
    const connect = (urls) => Effect_exports.gen(function* () {
      const connections = yield* Ref_exports.make(HashMap_exports.empty());
      const subscriptions = yield* Ref_exports.make(HashMap_exports.empty());
      const relayConnections = yield* Effect_exports.forEach(urls, (url2) => relayService.connect(url2).pipe(
        Effect_exports.map((conn) => [url2, conn]),
        Effect_exports.catchAll(() => Effect_exports.succeed(null))
      ));
      yield* Effect_exports.forEach(relayConnections, (result) => {
        if (result !== null) {
          const [url2, conn] = result;
          return Ref_exports.update(connections, HashMap_exports.set(url2, conn));
        }
        return Effect_exports.succeed(void 0);
      });
      const subscribe4 = (id3, filters) => Effect_exports.gen(function* () {
        const existing = yield* Ref_exports.get(subscriptions).pipe(
          Effect_exports.map(HashMap_exports.get(id3))
        );
        if (Option_exports.isSome(existing)) {
          return yield* Effect_exports.fail(
            new SubscriptionError({
              subscriptionId: id3,
              reason: "Subscription already exists"
            })
          );
        }
        const seenOn = yield* Ref_exports.make(HashMap_exports.empty());
        const currentConnections = yield* Ref_exports.get(connections);
        const relaySubscriptions = yield* Effect_exports.forEach(
          HashMap_exports.entries(currentConnections),
          ([url2, conn]) => conn.subscribe(id3, filters).pipe(
            Effect_exports.map((sub) => ({ url: url2, stream: sub.events })),
            Effect_exports.catchAll(() => Effect_exports.succeed(null))
          )
        );
        const eventStream = Stream_exports.mergeAll(
          relaySubscriptions.filter((sub) => sub !== null).map(
            ({ stream: stream4, url: url2 }) => stream4.pipe(
              Stream_exports.tap(
                (event) => Ref_exports.update(seenOn, (seen) => {
                  const current2 = HashMap_exports.get(seen, event.id);
                  if (Option_exports.isSome(current2)) {
                    return HashMap_exports.set(seen, event.id, [...current2.value, url2]);
                  }
                  return HashMap_exports.set(seen, event.id, [url2]);
                })
              ),
              Stream_exports.filter((event) => {
                const seen = Effect_exports.runSync(Ref_exports.get(seenOn));
                const relays = HashMap_exports.get(seen, event.id);
                return Option_exports.isSome(relays) && relays.value.length === 1;
              })
            )
          ),
          { concurrency: "unbounded" }
        );
        const poolSubscription = {
          id: id3,
          filters,
          events: eventStream,
          seenOn
        };
        yield* Ref_exports.update(subscriptions, HashMap_exports.set(id3, poolSubscription));
        return poolSubscription;
      });
      const unsubscribe = (id3) => Effect_exports.gen(function* () {
        const sub = yield* Ref_exports.get(subscriptions).pipe(
          Effect_exports.map(HashMap_exports.get(id3))
        );
        if (Option_exports.isNone(sub)) {
          return yield* Effect_exports.fail(
            new SubscriptionError({
              subscriptionId: id3,
              reason: "Subscription not found"
            })
          );
        }
        const currentConnections = yield* Ref_exports.get(connections);
        yield* Effect_exports.forEach(
          HashMap_exports.values(currentConnections),
          (_conn) => Effect_exports.succeed(void 0)
        );
        yield* Ref_exports.update(subscriptions, HashMap_exports.remove(id3));
      }).pipe(Effect_exports.asVoid);
      const publish3 = (event) => Effect_exports.gen(function* () {
        const currentConnections = yield* Ref_exports.get(connections);
        const results = yield* Effect_exports.forEach(
          HashMap_exports.entries(currentConnections),
          ([url2, conn]) => conn.publish(event).pipe(
            Effect_exports.map((success) => [url2, success]),
            Effect_exports.catchAll(() => Effect_exports.succeed([url2, false]))
          )
        );
        return HashMap_exports.fromIterable(results);
      });
      const close2 = () => Effect_exports.gen(function* () {
        const currentConnections = yield* Ref_exports.get(connections);
        yield* Effect_exports.forEach(
          HashMap_exports.values(currentConnections),
          (_conn) => Effect_exports.succeed(void 0)
        );
        yield* Ref_exports.set(connections, HashMap_exports.empty());
        yield* Ref_exports.set(subscriptions, HashMap_exports.empty());
      }).pipe(Effect_exports.asVoid);
      const getConnectionStatus = () => Effect_exports.gen(function* () {
        const currentConnections = yield* Ref_exports.get(connections);
        const connectedUrls = Array.from(HashMap_exports.keys(currentConnections));
        return HashMap_exports.fromIterable(
          urls.map(
            (url2) => [
              url2,
              connectedUrls.includes(url2) ? "connected" : "disconnected"
            ]
          )
        );
      });
      return {
        urls,
        connections,
        subscriptions,
        subscribe: subscribe4,
        unsubscribe,
        publish: publish3,
        close: close2,
        getConnectionStatus
      };
    });
    return { connect };
  })
);

// ../../packages/nostr/src/services/RelayReconnectService.ts
var defaultReconnectConfig = {
  initialDelay: Duration_exports.seconds(1),
  maxDelay: Duration_exports.minutes(5),
  maxAttempts: 10,
  factor: 2
};
var RelayReconnectService = Context_exports.GenericTag("nostr/RelayReconnectService");
var makeReconnectSchedule = (config2) => pipe(
  Schedule_exports.exponential(config2.initialDelay, config2.factor),
  Schedule_exports.compose(Schedule_exports.recurs(config2.maxAttempts))
);
var RelayReconnectServiceLive = Layer_exports.effect(
  RelayReconnectService,
  Effect_exports.gen(function* () {
    const relayService = yield* RelayService;
    const createReconnectingRelay = (url2, config2) => Effect_exports.gen(function* () {
      const finalConfig = {
        ...defaultReconnectConfig,
        ...config2
      };
      const connection = yield* Ref_exports.make(null);
      const isConnected = yield* Ref_exports.make(false);
      const reconnectAttempts = yield* Ref_exports.make(0);
      const shouldStop = yield* Ref_exports.make(false);
      const attemptConnection = Effect_exports.gen(function* () {
        const conn = yield* relayService.connect(url2);
        yield* Ref_exports.set(connection, conn);
        yield* Ref_exports.set(isConnected, true);
        yield* Ref_exports.set(reconnectAttempts, 0);
        return conn;
      });
      const reconnectionLoop = Effect_exports.gen(function* () {
        const schedule4 = makeReconnectSchedule(finalConfig);
        yield* attemptConnection.pipe(
          Effect_exports.retry(
            Schedule_exports.recurWhile(() => {
              return Effect_exports.runSync(
                Effect_exports.gen(function* () {
                  const stop4 = yield* Ref_exports.get(shouldStop);
                  const connected = yield* Ref_exports.get(isConnected);
                  return !stop4 && !connected;
                })
              );
            }).pipe(
              Schedule_exports.intersect(schedule4),
              Schedule_exports.tapOutput(() => Ref_exports.update(reconnectAttempts, (n) => n + 1))
            )
          ),
          Effect_exports.catchAll(() => Effect_exports.succeed(void 0))
        );
      });
      yield* Effect_exports.fork(
        Effect_exports.forever(
          Effect_exports.gen(function* () {
            const connected = yield* Ref_exports.get(isConnected);
            if (!connected) {
              yield* reconnectionLoop;
            }
            yield* Effect_exports.sleep(Duration_exports.seconds(1));
          }).pipe(Effect_exports.catchAll(() => Effect_exports.succeed(void 0)))
        )
      );
      yield* Effect_exports.addFinalizer(() => Effect_exports.succeed(void 0));
      yield* attemptConnection.pipe(
        Effect_exports.catchAll(() => Effect_exports.succeed(void 0))
      );
      const stop3 = () => Effect_exports.all([
        Ref_exports.set(shouldStop, true),
        Effect_exports.gen(function* () {
          const conn = yield* Ref_exports.get(connection);
          if (conn !== null) {
            yield* Effect_exports.succeed(void 0);
          }
        }),
        Ref_exports.set(connection, null),
        Ref_exports.set(isConnected, false)
      ]).pipe(Effect_exports.asVoid);
      return {
        url: url2,
        connection,
        isConnected,
        reconnectAttempts,
        stop: stop3
      };
    });
    return { createReconnectingRelay };
  })
);

// ../../packages/sdk/src/browser/WebSocketService.ts
var WebSocketError = class extends Data_exports.TaggedError("WebSocketError") {
};
var WebSocketService2 = class extends Context_exports.Tag("sdk/WebSocketService")() {
};
var WebSocketServiceLive2 = Layer_exports.succeed(
  WebSocketService2,
  {
    connect: (url2) => Effect_exports.gen(function* () {
      const wsRef = yield* Ref_exports.make(null);
      const stateRef = yield* Ref_exports.make("connecting");
      const messageQueue = yield* Queue_exports.unbounded();
      const shouldReconnect = yield* Ref_exports.make(true);
      const reconnectSchedule = Schedule_exports.exponential("100 millis").pipe(
        Schedule_exports.union(Schedule_exports.spaced("30 seconds"))
      );
      const createConnection = Effect_exports.gen(function* () {
        yield* Ref_exports.set(stateRef, "connecting");
        const ws = yield* Effect_exports.try({
          try: () => new WebSocket(url2),
          catch: (error2) => new WebSocketError({
            reason: "connection_failed",
            message: `Failed to create WebSocket: ${String(error2)}`,
            retryable: true,
            cause: error2
          })
        });
        ws.onopen = () => {
          Effect_exports.runSync(Ref_exports.set(stateRef, "connected"));
          console.log(`WebSocket connected to ${url2}`);
        };
        ws.onmessage = (event) => {
          if (typeof event.data === "string") {
            Effect_exports.runSync(Queue_exports.offer(messageQueue, event.data));
          }
        };
        ws.onerror = (event) => {
          console.error("WebSocket error:", event);
        };
        ws.onclose = (event) => {
          Effect_exports.runSync(Effect_exports.gen(function* () {
            yield* Ref_exports.set(stateRef, "disconnected");
            yield* Ref_exports.set(wsRef, null);
            const reconnect = yield* Ref_exports.get(shouldReconnect);
            if (reconnect && !event.wasClean) {
              yield* Ref_exports.set(stateRef, "reconnecting");
            }
          }));
        };
        yield* Effect_exports.async((resume2) => {
          if (ws.readyState === WebSocket.OPEN) {
            resume2(Effect_exports.succeed(void 0));
          } else {
            const openHandler = () => {
              ws.removeEventListener("open", openHandler);
              ws.removeEventListener("error", errorHandler);
              resume2(Effect_exports.succeed(void 0));
            };
            const errorHandler = () => {
              ws.removeEventListener("open", openHandler);
              ws.removeEventListener("error", errorHandler);
              resume2(
                Effect_exports.fail(
                  new WebSocketError({
                    reason: "connection_failed",
                    message: "WebSocket failed to open",
                    retryable: true
                  })
                )
              );
            };
            ws.addEventListener("open", openHandler);
            ws.addEventListener("error", errorHandler);
          }
        }).pipe(
          Effect_exports.timeoutFail({
            duration: "10 seconds",
            onTimeout: () => new WebSocketError({
              reason: "timeout",
              message: "Connection timeout",
              retryable: true
            })
          })
        );
        yield* Ref_exports.set(wsRef, ws);
        return ws;
      });
      yield* createConnection.pipe(
        Effect_exports.retry(reconnectSchedule),
        Effect_exports.forkScoped
      );
      yield* Effect_exports.gen(function* () {
        while (true) {
          const state = yield* Ref_exports.get(stateRef);
          const reconnect = yield* Ref_exports.get(shouldReconnect);
          if (state === "disconnected" && reconnect) {
            yield* Ref_exports.set(stateRef, "reconnecting");
            yield* createConnection.pipe(
              Effect_exports.retry(reconnectSchedule),
              Effect_exports.catchAll((error2) => {
                console.error("Failed to reconnect:", error2);
                return Effect_exports.succeed(void 0);
              })
            );
          }
          yield* Effect_exports.sleep("1 second");
        }
      }).pipe(
        Effect_exports.forkScoped,
        Effect_exports.interruptible
      );
      yield* Effect_exports.addFinalizer(
        () => Effect_exports.gen(function* () {
          yield* Ref_exports.set(shouldReconnect, false);
          const ws = yield* Ref_exports.get(wsRef);
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.close(1e3, "Normal closure");
          }
          yield* Queue_exports.shutdown(messageQueue);
        })
      );
      const connection = {
        send: (message) => Effect_exports.gen(function* () {
          const ws = yield* Ref_exports.get(wsRef);
          if (!ws || ws.readyState !== WebSocket.OPEN) {
            return yield* Effect_exports.fail(
              new WebSocketError({
                reason: "connection_lost",
                message: "WebSocket is not connected",
                retryable: true
              })
            );
          }
          yield* Effect_exports.try({
            try: () => ws.send(message),
            catch: (error2) => new WebSocketError({
              reason: "invalid_message",
              message: `Failed to send message: ${String(error2)}`,
              retryable: false,
              cause: error2
            })
          });
        }),
        messages: Stream_exports.fromQueue(messageQueue).pipe(
          Stream_exports.catchAll(
            (error2) => Stream_exports.fail(
              new WebSocketError({
                reason: "invalid_message",
                message: String(error2),
                retryable: false
              })
            )
          )
        ),
        state: Ref_exports.get(stateRef),
        close: () => Effect_exports.gen(function* () {
          yield* Ref_exports.set(shouldReconnect, false);
          const ws = yield* Ref_exports.get(wsRef);
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.close(1e3, "Normal closure");
          }
        })
      };
      return connection;
    }),
    disconnect: () => Effect_exports.succeed(void 0)
  }
);

// ../../packages/sdk/src/browser/AgentService.ts
var AgentProfile2 = Schema_exports.Struct({
  pubkey: Schema_exports.String,
  agent_id: Schema_exports.String,
  name: Schema_exports.String,
  status: Schema_exports.Union(
    Schema_exports.Literal("active"),
    Schema_exports.Literal("hibernating"),
    Schema_exports.Literal("offline")
  ),
  balance: Schema_exports.Number,
  metabolic_rate: Schema_exports.Number,
  capabilities: Schema_exports.Array(Schema_exports.String),
  description: Schema_exports.String,
  avatar: Schema_exports.optional(Schema_exports.String),
  last_activity: Schema_exports.Number,
  created_at: Schema_exports.Number,
  updated_at: Schema_exports.Number
});
var AgentStatus = Schema_exports.Struct({
  pubkey: Schema_exports.String,
  status: Schema_exports.Union(
    Schema_exports.Literal("active"),
    Schema_exports.Literal("hibernating"),
    Schema_exports.Literal("offline")
  ),
  last_seen: Schema_exports.Number,
  current_job: Schema_exports.optional(Schema_exports.String),
  metrics: Schema_exports.optional(Schema_exports.Struct({
    requests_completed: Schema_exports.Number,
    average_response_time: Schema_exports.Number,
    success_rate: Schema_exports.Number
  }))
});
var AgentError = class extends Data_exports.TaggedError("AgentError") {
};
var AgentService = class extends Context_exports.Tag("sdk/AgentService")() {
};
var generateSubId = () => `sub-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
var AgentServiceLive = Layer_exports.effect(
  AgentService,
  Effect_exports.gen(function* () {
    const wsService = yield* WebSocketService2;
    const connection = yield* wsService.connect("ws://localhost:3003/relay").pipe(
      Effect_exports.scoped,
      Effect_exports.catchAll(
        (error2) => Effect_exports.fail(
          new AgentError({
            reason: "connection_failed",
            message: error2.message,
            cause: error2
          })
        )
      )
    );
    const agentCache = yield* Ref_exports.make(/* @__PURE__ */ new Map());
    const parseMessage = (data) => {
      try {
        const msg = JSON.parse(data);
        if (Array.isArray(msg) && msg.length >= 2) {
          return Option_exports.some(msg);
        }
        return Option_exports.none();
      } catch {
        return Option_exports.none();
      }
    };
    const subscribeToAgents = Effect_exports.gen(function* () {
      const subId = generateSubId();
      const req = JSON.stringify([
        "REQ",
        subId,
        {
          kinds: [31337],
          // NIP-OA agent profile
          limit: 100
        }
      ]);
      yield* connection.send(req).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new AgentError({
              reason: "subscription_failed",
              message: "Failed to subscribe to agents",
              cause: error2
            })
          )
        )
      );
      return connection.messages.pipe(
        Stream_exports.mapEffect(
          (data) => Effect_exports.gen(function* () {
            const msg = parseMessage(data);
            if (Option_exports.isNone(msg)) return Option_exports.none();
            const message = msg.value;
            if (message[0] === "EVENT" && message[1] === subId) {
              const event = message[2];
              if (event.kind === 31337) {
                try {
                  const content = JSON.parse(event.content);
                  const dTag = event.tags.find((tag3) => tag3[0] === "d");
                  if (!dTag) return Option_exports.none();
                  const nameTag = event.tags.find((tag3) => tag3[0] === "name");
                  const statusTag = event.tags.find((tag3) => tag3[0] === "status");
                  const balanceTag = event.tags.find((tag3) => tag3[0] === "balance");
                  const metabolicRateTag = event.tags.find((tag3) => tag3[0] === "metabolic_rate");
                  const agent = {
                    pubkey: event.pubkey,
                    agent_id: dTag[1],
                    name: nameTag?.[1] || "Unknown Agent",
                    status: statusTag?.[1] || "offline",
                    balance: parseInt(balanceTag?.[1] || "0"),
                    metabolic_rate: parseInt(metabolicRateTag?.[1] || "100"),
                    capabilities: content.capabilities?.map((c) => c.name) || [],
                    description: content.description || "",
                    avatar: content.avatar,
                    last_activity: event.created_at,
                    created_at: event.created_at,
                    updated_at: event.created_at
                  };
                  yield* Ref_exports.update(agentCache, (cache) => {
                    const newCache = new Map(cache);
                    newCache.set(agent.pubkey, agent);
                    return newCache;
                  });
                  return Option_exports.some(agent);
                } catch {
                  return Option_exports.none();
                }
              }
            }
            return Option_exports.none();
          })
        ),
        Stream_exports.filter(Option_exports.isSome),
        Stream_exports.map((opt) => opt.value)
      );
    });
    const subscribeToAgentStatus = (pubkey) => Effect_exports.gen(function* () {
      const subId = generateSubId();
      const req = JSON.stringify([
        "REQ",
        subId,
        {
          kinds: [30078],
          // NIP-78 application-specific data (for status)
          authors: [pubkey],
          "#d": ["status"],
          limit: 1
        }
      ]);
      yield* connection.send(req).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new AgentError({
              reason: "subscription_failed",
              message: "Failed to subscribe to agent status",
              cause: error2
            })
          )
        )
      );
      return connection.messages.pipe(
        Stream_exports.mapEffect(
          (data) => Effect_exports.sync(() => {
            const msg = parseMessage(data);
            if (Option_exports.isNone(msg)) return Option_exports.none();
            const message = msg.value;
            if (message[0] === "EVENT" && message[1] === subId) {
              const event = message[2];
              if (event.kind === 30078 && event.pubkey === pubkey) {
                try {
                  const content = JSON.parse(event.content);
                  const status3 = {
                    pubkey: event.pubkey,
                    status: content.status || "offline",
                    last_seen: event.created_at,
                    current_job: content.current_job,
                    metrics: content.metrics
                  };
                  return Option_exports.some(status3);
                } catch {
                  return Option_exports.none();
                }
              }
            }
            return Option_exports.none();
          })
        ),
        Stream_exports.filter(Option_exports.isSome),
        Stream_exports.map((opt) => opt.value)
      );
    });
    return {
      agents: Stream_exports.unwrap(subscribeToAgents).pipe(
        Stream_exports.catchAll(
          (error2) => Stream_exports.fail(
            new AgentError({
              reason: "subscription_failed",
              message: error2 instanceof Error ? error2.message : "Unknown error",
              cause: error2
            })
          )
        )
      ),
      agentStatus: (pubkey) => Stream_exports.unwrap(subscribeToAgentStatus(pubkey)).pipe(
        Stream_exports.catchAll(
          (error2) => Stream_exports.fail(
            new AgentError({
              reason: "subscription_failed",
              message: error2 instanceof Error ? error2.message : "Unknown error",
              cause: error2
            })
          )
        )
      ),
      getAgent: (pubkey) => Effect_exports.gen(function* () {
        const cache = yield* Ref_exports.get(agentCache);
        return cache.get(pubkey) || null;
      })
    };
  })
);

// ../../packages/sdk/src/browser/ChannelService.ts
var Channel = Schema_exports.Struct({
  id: Schema_exports.String,
  name: Schema_exports.String,
  about: Schema_exports.String,
  picture: Schema_exports.optional(Schema_exports.String),
  created_at: Schema_exports.Number,
  pubkey: Schema_exports.String,
  message_count: Schema_exports.Number,
  last_message_at: Schema_exports.optional(Schema_exports.Number)
});
var ChannelMessage = Schema_exports.Struct({
  id: Schema_exports.String,
  channel_id: Schema_exports.String,
  pubkey: Schema_exports.String,
  content: Schema_exports.String,
  created_at: Schema_exports.Number,
  tags: Schema_exports.Array(Schema_exports.Array(Schema_exports.String))
});
var CreateChannelParams = Schema_exports.Struct({
  name: Schema_exports.String,
  about: Schema_exports.String,
  picture: Schema_exports.optional(Schema_exports.String)
});
var SendMessageParams = Schema_exports.Struct({
  channelId: Schema_exports.String,
  content: Schema_exports.String,
  replyTo: Schema_exports.optional(Schema_exports.String)
});
var ChannelError = class extends Data_exports.TaggedError("ChannelError") {
};
var ChannelService = class extends Context_exports.Tag("sdk/ChannelService")() {
};
var generateSubId2 = () => `sub-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
var ChannelServiceLive = Layer_exports.effect(
  ChannelService,
  Effect_exports.gen(function* () {
    const wsService = yield* WebSocketService2;
    const connection = yield* wsService.connect("ws://localhost:3003/relay").pipe(
      Effect_exports.scoped,
      Effect_exports.catchAll(
        (error2) => Effect_exports.fail(
          new ChannelError({
            reason: "connection_failed",
            message: error2.message,
            cause: error2
          })
        )
      )
    );
    const channelCache = yield* Ref_exports.make(/* @__PURE__ */ new Map());
    const parseMessage = (data) => {
      try {
        const msg = JSON.parse(data);
        if (Array.isArray(msg) && msg.length >= 2) {
          return Option_exports.some(msg);
        }
        return Option_exports.none();
      } catch {
        return Option_exports.none();
      }
    };
    const subscribeToChannels = Effect_exports.gen(function* () {
      const subId = generateSubId2();
      const req = JSON.stringify([
        "REQ",
        subId,
        {
          kinds: [40],
          // NIP-28 channel creation
          limit: 100
        }
      ]);
      yield* connection.send(req).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new ChannelError({
              reason: "subscription_failed",
              message: "Failed to subscribe to channels",
              cause: error2
            })
          )
        )
      );
      return connection.messages.pipe(
        Stream_exports.mapEffect(
          (data) => Effect_exports.gen(function* () {
            const msg = parseMessage(data);
            if (Option_exports.isNone(msg)) return Option_exports.none();
            const message = msg.value;
            if (message[0] === "EVENT" && message[1] === subId) {
              const event = message[2];
              if (event.kind === 40) {
                try {
                  const content = JSON.parse(event.content);
                  const channel = {
                    id: event.id,
                    name: content.name,
                    about: content.about || "",
                    picture: content.picture,
                    created_at: event.created_at,
                    pubkey: event.pubkey,
                    message_count: 0,
                    last_message_at: void 0
                  };
                  yield* Ref_exports.update(channelCache, (cache) => {
                    const newCache = new Map(cache);
                    newCache.set(channel.id, channel);
                    return newCache;
                  });
                  return Option_exports.some(channel);
                } catch {
                  return Option_exports.none();
                }
              }
            }
            return Option_exports.none();
          })
        ),
        Stream_exports.filter(Option_exports.isSome),
        Stream_exports.map((opt) => opt.value),
        Stream_exports.catchAll(
          (error2) => Stream_exports.fail(
            new ChannelError({
              reason: "subscription_failed",
              message: error2 instanceof Error ? error2.message : "Unknown error",
              cause: error2
            })
          )
        )
      );
    });
    const subscribeToMessages = (channelId) => Effect_exports.gen(function* () {
      const subId = generateSubId2();
      const req = JSON.stringify([
        "REQ",
        subId,
        {
          kinds: [42],
          // NIP-28 channel message
          "#e": [channelId],
          limit: 50
        }
      ]);
      yield* connection.send(req).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new ChannelError({
              reason: "subscription_failed",
              message: "Failed to subscribe to messages",
              cause: error2
            })
          )
        )
      );
      return connection.messages.pipe(
        Stream_exports.mapEffect(
          (data) => Effect_exports.sync(() => {
            const msg = parseMessage(data);
            if (Option_exports.isNone(msg)) return Option_exports.none();
            const message = msg.value;
            if (message[0] === "EVENT" && message[1] === subId) {
              const event = message[2];
              if (event.kind === 42) {
                const channelTag = event.tags.find(
                  (tag3) => tag3[0] === "e" && tag3[1] === channelId
                );
                if (channelTag) {
                  const channelMessage = {
                    id: event.id,
                    channel_id: channelId,
                    pubkey: event.pubkey,
                    content: event.content,
                    created_at: event.created_at,
                    tags: event.tags
                  };
                  return Option_exports.some(channelMessage);
                }
              }
            }
            return Option_exports.none();
          })
        ),
        Stream_exports.filter(Option_exports.isSome),
        Stream_exports.map((opt) => opt.value)
      );
    });
    return {
      channels: Stream_exports.unwrap(subscribeToChannels).pipe(
        Stream_exports.catchAll(
          (error2) => Stream_exports.fail(
            new ChannelError({
              reason: "subscription_failed",
              message: error2 instanceof Error ? error2.message : "Unknown error",
              cause: error2
            })
          )
        )
      ),
      messages: (channelId) => Stream_exports.unwrap(subscribeToMessages(channelId)).pipe(
        Stream_exports.catchAll(
          (error2) => Stream_exports.fail(
            new ChannelError({
              reason: "subscription_failed",
              message: error2 instanceof Error ? error2.message : "Unknown error",
              cause: error2
            })
          )
        )
      ),
      createChannel: (_params) => Effect_exports.gen(function* () {
        return yield* Effect_exports.fail(
          new ChannelError({
            reason: "send_failed",
            message: "Channel creation requires key management implementation"
          })
        );
      }),
      sendMessage: (_params) => Effect_exports.gen(function* () {
        return yield* Effect_exports.fail(
          new ChannelError({
            reason: "send_failed",
            message: "Message sending requires key management implementation"
          })
        );
      })
    };
  })
);

// ../../packages/ai/src/AiService.ts
var AiService = Context_exports.GenericTag("ai/AiService");
var AiServiceLive = Layer_exports.succeed(
  AiService,
  {
    hello: (name) => Effect_exports.succeed(`Hello ${name} from AI Service!`),
    complete: (prompt) => Effect_exports.succeed({
      content: `Response to: ${prompt}`,
      model: "placeholder",
      usage: {
        promptTokens: 0,
        completionTokens: 0,
        totalTokens: 0
      }
    })
  }
);

// ../../packages/ai/src/providers/ollama/index.ts
var OllamaClient = class extends Tag2("@openagentsinc/ai/OllamaClient")() {
};

// ../../packages/ai/src/providers/openrouter/OpenRouterConfig.ts
var _OpenRouterConfig = class _OpenRouterConfig extends Tag2("@openagentsinc/ai-openrouter/OpenRouterConfig")() {
};
/**
 * @since 1.0.0
 */
__publicField(_OpenRouterConfig, "getOrUndefined", map18(
  context3(),
  (context9) => context9.unsafeMap.get(_OpenRouterConfig.key)
));
var OpenRouterConfig = _OpenRouterConfig;
var withProviderRouting = dual(
  2,
  (self, providerRouting) => flatMap12(
    OpenRouterConfig.getOrUndefined,
    (config2) => provideService3(self, OpenRouterConfig, { ...config2, providerRouting })
  )
);
var withFallbackModels = dual(
  2,
  (self, fallbackModels) => flatMap12(
    OpenRouterConfig.getOrUndefined,
    (config2) => provideService3(self, OpenRouterConfig, { ...config2, fallbackModels })
  )
);

// ../../packages/ai/src/providers/openrouter/OpenRouterClient.ts
var OpenRouterClient = class extends Tag2("@openagentsinc/ai-openrouter/OpenRouterClient")() {
};

// ../../packages/ai/src/providers/openrouter/internal/utilities.ts
var ImageDetail = Literal2("auto", "low", "high");
var MessageContentPart = Union2(
  Struct({
    type: Literal2("text"),
    text: String$
  }),
  Struct({
    type: Literal2("image_url"),
    image_url: Struct({
      url: String$,
      detail: optional(ImageDetail)
    })
  })
);

// ../../packages/ai/src/providers/openrouter/OpenRouterLanguageModel.ts
var OpenRouterLanguageModel = class extends Tag2("@openagentsinc/ai-openrouter/OpenRouterLanguageModel")() {
};

// ../../node_modules/.pnpm/@effect+schema@0.75.5_effect@3.16.3/node_modules/@effect/schema/dist/esm/internal/util.js
var getKeysForIndexSignature2 = (input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature2(input, parameter.from);
  }
};
var ownKeys2 = (o) => Object.keys(o).concat(Object.getOwnPropertySymbols(o));
var memoizeThunk2 = (f) => {
  let done12 = false;
  let a;
  return () => {
    if (done12) {
      return a;
    }
    a = f();
    done12 = true;
    return a;
  };
};
var formatDate2 = (date3) => {
  try {
    return date3.toISOString();
  } catch (e) {
    return String(date3);
  }
};
var formatUnknown2 = (u) => {
  if (isString(u)) {
    return JSON.stringify(u);
  } else if (isNumber(u) || u == null || isBoolean(u) || isSymbol(u)) {
    return String(u);
  } else if (isDate(u)) {
    return formatDate2(u);
  } else if (isBigInt(u)) {
    return String(u) + "n";
  } else if (!isArray(u) && hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString) {
    return u["toString"]();
  }
  try {
    JSON.stringify(u);
    if (isArray(u)) {
      return `[${u.map(formatUnknown2).join(",")}]`;
    } else {
      return `{${ownKeys2(u).map((k) => `${isString(k) ? JSON.stringify(k) : String(k)}:${formatUnknown2(u[k])}`).join(",")}}`;
    }
  } catch (e) {
    return String(u);
  }
};
var formatPropertyKey3 = (name) => typeof name === "string" ? JSON.stringify(name) : String(name);
var isNonEmpty7 = (x) => Array.isArray(x);
var isSingle2 = (x) => !Array.isArray(x);
var formatPathKey2 = (key) => `[${formatPropertyKey3(key)}]`;
var formatPath2 = (path) => isNonEmpty7(path) ? path.map(formatPathKey2).join("") : formatPathKey2(path);

// ../../node_modules/.pnpm/@effect+schema@0.75.5_effect@3.16.3/node_modules/@effect/schema/dist/esm/internal/errors.js
var getErrorMessage3 = (reason, details, path, ast) => {
  let out = reason;
  if (path && isNonEmptyReadonlyArray(path)) {
    out += `
at path: ${formatPath2(path)}`;
  }
  if (details !== void 0) {
    out += `
details: ${details}`;
  }
  if (ast) {
    out += `
schema (${ast._tag}): ${ast}`;
  }
  return out;
};
var getInvalidArgumentErrorMessage2 = (details) => getErrorMessage3("Invalid Argument", details);
var getUnsupportedSchemaErrorMessage2 = (details, path, ast) => getErrorMessage3("Unsupported schema", details, path, ast);
var getSchemaExtendErrorMessage2 = (x, y, path) => getErrorMessage3("Unsupported schema or overlapping types", `cannot extend ${x} with ${y}`, path);
var getSchemaUnsupportedLiteralSpanErrorMessage2 = (ast) => getErrorMessage3("Unsupported template literal span", void 0, void 0, ast);
var getASTUnsupportedSchema = (ast) => getUnsupportedSchemaErrorMessage2(void 0, void 0, ast);
var getASTUnsupportedKeySchema = (ast) => getErrorMessage3("Unsupported key schema", void 0, void 0, ast);
var getASTUnsupportedLiteral = (literal2) => getErrorMessage3("Unsupported literal", `literal value: ${formatUnknown2(literal2)}`);
var getASTDuplicateIndexSignatureErrorMessage2 = (type) => getErrorMessage3("Duplicate index signature", `${type} index signature`);
var getASTIndexSignatureParameterErrorMessage2 = /* @__PURE__ */ getErrorMessage3("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
var getASTRequiredElementFollowinAnOptionalElementErrorMessage2 = /* @__PURE__ */ getErrorMessage3("Invalid element", "A required element cannot follow an optional element. ts(1257)");
var getASTDuplicatePropertySignatureTransformationErrorMessage2 = (key) => getErrorMessage3("Duplicate property signature transformation", `Duplicate key ${formatUnknown2(key)}`);
var getASTUnsupportedRenameSchema = (ast) => getUnsupportedSchemaErrorMessage2(void 0, void 0, ast);
var getASTDuplicatePropertySignatureErrorMessage2 = (key) => getErrorMessage3("Duplicate property signature", `Duplicate key ${formatUnknown2(key)}`);

// ../../node_modules/.pnpm/@effect+schema@0.75.5_effect@3.16.3/node_modules/@effect/schema/dist/esm/AST.js
var BrandAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Brand");
var TypeAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Type");
var MessageAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Message");
var MissingMessageAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/MissingMessage");
var IdentifierAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Identifier");
var TitleAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Title");
var DescriptionAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Description");
var ExamplesAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Examples");
var DefaultAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Default");
var JSONSchemaAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/JSONSchema");
var DocumentationAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Documentation");
var ConcurrencyAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Concurrency");
var BatchingAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Batching");
var ParseIssueTitleAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/ParseIssueTitle");
var ParseOptionsAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/ParseOptions");
var DecodingFallbackAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/DecodingFallback");
var SurrogateAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Surrogate");
var StableFilterAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/StableFilter");
var getAnnotation2 = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some2(annotated.annotations[key]) : none2());
var getBrandAnnotation2 = /* @__PURE__ */ getAnnotation2(BrandAnnotationId2);
var getMessageAnnotation2 = /* @__PURE__ */ getAnnotation2(MessageAnnotationId2);
var getMissingMessageAnnotation2 = /* @__PURE__ */ getAnnotation2(MissingMessageAnnotationId2);
var getTitleAnnotation2 = /* @__PURE__ */ getAnnotation2(TitleAnnotationId2);
var getIdentifierAnnotation2 = /* @__PURE__ */ getAnnotation2(IdentifierAnnotationId2);
var getDescriptionAnnotation2 = /* @__PURE__ */ getAnnotation2(DescriptionAnnotationId2);
var getConcurrencyAnnotation2 = /* @__PURE__ */ getAnnotation2(ConcurrencyAnnotationId2);
var getBatchingAnnotation2 = /* @__PURE__ */ getAnnotation2(BatchingAnnotationId2);
var getParseIssueTitleAnnotation3 = /* @__PURE__ */ getAnnotation2(ParseIssueTitleAnnotationId2);
var getParseOptionsAnnotation2 = /* @__PURE__ */ getAnnotation2(ParseOptionsAnnotationId2);
var getDecodingFallbackAnnotation2 = /* @__PURE__ */ getAnnotation2(DecodingFallbackAnnotationId2);
var getSurrogateAnnotation2 = /* @__PURE__ */ getAnnotation2(SurrogateAnnotationId2);
var getStableFilterAnnotation2 = /* @__PURE__ */ getAnnotation2(StableFilterAnnotationId2);
var hasStableFilter2 = (annotated) => exists(getStableFilterAnnotation2(annotated), (b) => b === true);
var JSONIdentifierAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/JSONIdentifier");
var getJSONIdentifierAnnotation2 = /* @__PURE__ */ getAnnotation2(JSONIdentifierAnnotationId2);
var Declaration2 = class {
  constructor(typeParameters, decodeUnknown6, encodeUnknown5, annotations5 = {}) {
    __publicField(this, "typeParameters");
    __publicField(this, "decodeUnknown");
    __publicField(this, "encodeUnknown");
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "Declaration");
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown6;
    this.encodeUnknown = encodeUnknown5;
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return getOrElse3(getExpected2(this), () => "<declaration schema>");
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var createASTGuard2 = (tag3) => (ast) => ast._tag === tag3;
var Literal3 = class {
  constructor(literal2, annotations5 = {}) {
    __publicField(this, "literal");
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "Literal");
    this.literal = literal2;
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return getOrElse3(getExpected2(this), () => formatUnknown2(this.literal));
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var isLiteral2 = /* @__PURE__ */ createASTGuard2("Literal");
var $null2 = /* @__PURE__ */ new Literal3(null);
var UniqueSymbol2 = class {
  constructor(symbol4, annotations5 = {}) {
    __publicField(this, "symbol");
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "UniqueSymbol");
    this.symbol = symbol4;
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return getOrElse3(getExpected2(this), () => formatUnknown2(this.symbol));
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var isUniqueSymbol2 = /* @__PURE__ */ createASTGuard2("UniqueSymbol");
var UndefinedKeyword2 = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "UndefinedKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return formatKeyword2(this);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var undefinedKeyword2 = /* @__PURE__ */ new UndefinedKeyword2({
  [TitleAnnotationId2]: "undefined"
});
var VoidKeyword2 = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "VoidKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return formatKeyword2(this);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var voidKeyword2 = /* @__PURE__ */ new VoidKeyword2({
  [TitleAnnotationId2]: "void"
});
var NeverKeyword2 = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "NeverKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return formatKeyword2(this);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var neverKeyword2 = /* @__PURE__ */ new NeverKeyword2({
  [TitleAnnotationId2]: "never"
});
var UnknownKeyword2 = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "UnknownKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return formatKeyword2(this);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var unknownKeyword2 = /* @__PURE__ */ new UnknownKeyword2({
  [TitleAnnotationId2]: "unknown"
});
var AnyKeyword2 = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "AnyKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return formatKeyword2(this);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var anyKeyword2 = /* @__PURE__ */ new AnyKeyword2({
  [TitleAnnotationId2]: "any"
});
var StringKeyword2 = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "StringKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return formatKeyword2(this);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var stringKeyword2 = /* @__PURE__ */ new StringKeyword2({
  [TitleAnnotationId2]: "string",
  [DescriptionAnnotationId2]: "a string"
});
var isStringKeyword2 = /* @__PURE__ */ createASTGuard2("StringKeyword");
var NumberKeyword2 = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "NumberKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return formatKeyword2(this);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var numberKeyword2 = /* @__PURE__ */ new NumberKeyword2({
  [TitleAnnotationId2]: "number",
  [DescriptionAnnotationId2]: "a number"
});
var isNumberKeyword2 = /* @__PURE__ */ createASTGuard2("NumberKeyword");
var BooleanKeyword2 = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "BooleanKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return formatKeyword2(this);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var booleanKeyword2 = /* @__PURE__ */ new BooleanKeyword2({
  [TitleAnnotationId2]: "boolean",
  [DescriptionAnnotationId2]: "a boolean"
});
var isBooleanKeyword2 = /* @__PURE__ */ createASTGuard2("BooleanKeyword");
var BigIntKeyword2 = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "BigIntKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return formatKeyword2(this);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var bigIntKeyword2 = /* @__PURE__ */ new BigIntKeyword2({
  [TitleAnnotationId2]: "bigint",
  [DescriptionAnnotationId2]: "a bigint"
});
var SymbolKeyword2 = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "SymbolKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return formatKeyword2(this);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var symbolKeyword2 = /* @__PURE__ */ new SymbolKeyword2({
  [TitleAnnotationId2]: "symbol",
  [DescriptionAnnotationId2]: "a symbol"
});
var isSymbolKeyword2 = /* @__PURE__ */ createASTGuard2("SymbolKeyword");
var ObjectKeyword2 = class {
  constructor(annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "ObjectKeyword");
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return formatKeyword2(this);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var objectKeyword2 = /* @__PURE__ */ new ObjectKeyword2({
  [TitleAnnotationId2]: "object",
  [DescriptionAnnotationId2]: "an object in the TypeScript meaning, i.e. the `object` type"
});
var Enums3 = class {
  constructor(enums, annotations5 = {}) {
    __publicField(this, "enums");
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "Enums");
    this.enums = enums;
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return getOrElse3(getExpected2(this), () => `<enum ${this.enums.length} value(s): ${this.enums.map((_, value3) => JSON.stringify(value3)).join(" | ")}>`);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      enums: this.enums,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var isEnums2 = /* @__PURE__ */ createASTGuard2("Enums");
var TemplateLiteralSpan2 = class {
  constructor(type, literal2) {
    __publicField(this, "type");
    __publicField(this, "literal");
    this.type = type;
    this.literal = literal2;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    const type = "${" + String(this.type) + "}";
    return type + this.literal;
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      literal: this.literal
    };
  }
};
var TemplateLiteral3 = class {
  constructor(head8, spans, annotations5 = {}) {
    __publicField(this, "head");
    __publicField(this, "spans");
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "TemplateLiteral");
    this.head = head8;
    this.spans = spans;
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return getOrElse3(getExpected2(this), () => formatTemplateLiteral2(this));
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      head: this.head,
      spans: this.spans.map((span4) => span4.toJSON()),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var formatTemplateLiteral2 = (ast) => "`" + ast.head + ast.spans.map((span4) => String(span4)).join("") + "`";
var isTemplateLiteral2 = /* @__PURE__ */ createASTGuard2("TemplateLiteral");
var Type3 = class {
  constructor(type, annotations5 = {}) {
    __publicField(this, "type");
    __publicField(this, "annotations");
    this.type = type;
    this.annotations = annotations5;
  }
  /**
   * @since 0.68.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
  /**
   * @since 0.68.0
   */
  toString() {
    return String(this.type);
  }
};
var OptionalType2 = class extends Type3 {
  constructor(type, isOptional, annotations5 = {}) {
    super(type, annotations5);
    __publicField(this, "isOptional");
    this.isOptional = isOptional;
  }
  /**
   * @since 0.68.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
  /**
   * @since 0.68.0
   */
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
};
var getRestASTs2 = (rest) => rest.map((annotatedAST) => annotatedAST.type);
var TupleType2 = class {
  constructor(elements, rest, isReadonly, annotations5 = {}) {
    __publicField(this, "elements");
    __publicField(this, "rest");
    __publicField(this, "isReadonly");
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "TupleType");
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations5;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage2);
    }
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return getOrElse3(getExpected2(this), () => formatTuple2(this));
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map((e) => e.toJSON()),
      rest: this.rest.map((ast) => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var formatTuple2 = (ast) => {
  const formattedElements = ast.elements.map(String).join(", ");
  return matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head8, tail2) => {
      const formattedHead = String(head8);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail2.length > 0) {
        const formattedTail = tail2.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
};
var PropertySignature2 = class extends OptionalType2 {
  constructor(name, type, isOptional, isReadonly, annotations5) {
    super(type, isOptional, annotations5);
    __publicField(this, "name");
    __publicField(this, "isReadonly");
    this.name = name;
    this.isReadonly = isReadonly;
  }
  /**
   * @since 0.68.18
   */
  toString() {
    return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var isParameter2 = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter2(ast.from);
  }
  return false;
};
var IndexSignature2 = class {
  constructor(parameter, type, isReadonly) {
    __publicField(this, "type");
    __publicField(this, "isReadonly");
    /**
     * @since 0.67.0
     */
    __publicField(this, "parameter");
    this.type = type;
    this.isReadonly = isReadonly;
    if (isParameter2(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(getASTIndexSignatureParameterErrorMessage2);
    }
  }
  /**
   * @since 0.68.18
   */
  toString() {
    return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
};
var TypeLiteral2 = class {
  constructor(propertySignatures, indexSignatures, annotations5 = {}) {
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "TypeLiteral");
    /**
     * @since 0.67.0
     */
    __publicField(this, "propertySignatures");
    /**
     * @since 0.67.0
     */
    __publicField(this, "indexSignatures");
    this.annotations = annotations5;
    const keys6 = {};
    for (let i = 0; i < propertySignatures.length; i++) {
      const name = propertySignatures[i].name;
      if (Object.prototype.hasOwnProperty.call(keys6, name)) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage2(name));
      }
      keys6[name] = null;
    }
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i = 0; i < indexSignatures.length; i++) {
      const parameter = getParameterBase(indexSignatures[i].parameter);
      if (isStringKeyword2(parameter)) {
        if (parameters.string) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage2("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword2(parameter)) {
        if (parameters.symbol) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage2("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = propertySignatures;
    this.indexSignatures = indexSignatures;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return getOrElse3(getExpected2(this), () => formatTypeLiteral2(this));
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var formatIndexSignatures2 = (iss) => iss.map(String).join("; ");
var formatTypeLiteral2 = (ast) => {
  if (ast.propertySignatures.length > 0) {
    const pss = ast.propertySignatures.map(String).join("; ");
    if (ast.indexSignatures.length > 0) {
      return `{ ${pss}; ${formatIndexSignatures2(ast.indexSignatures)} }`;
    } else {
      return `{ ${pss} }`;
    }
  } else {
    if (ast.indexSignatures.length > 0) {
      return `{ ${formatIndexSignatures2(ast.indexSignatures)} }`;
    } else {
      return "{}";
    }
  }
};
var isTypeLiteral2 = /* @__PURE__ */ createASTGuard2("TypeLiteral");
var sortCandidates2 = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput2(Order2, (ast) => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
var literalMap2 = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
var flatten16 = (candidates) => flatMap2(candidates, (ast) => isUnion2(ast) ? flatten16(ast.types) : [ast]);
var unify2 = (candidates) => {
  const cs = sortCandidates2(candidates);
  const out = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword2];
      case "UnknownKeyword":
        return [unknownKeyword2];
      // uniques
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword": {
        if (!uniques[ast._tag]) {
          uniques[ast._tag] = ast;
          out.push(ast);
        }
        break;
      }
      case "Literal": {
        const type = typeof ast.literal;
        switch (type) {
          case "string":
          case "number":
          case "bigint":
          case "boolean": {
            const _tag = literalMap2[type];
            if (!uniques[_tag] && !literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
          // null
          case "object": {
            if (!literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
        }
        break;
      }
      case "UniqueSymbol": {
        if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
          literals.push(ast.symbol);
          out.push(ast);
        }
        break;
      }
      case "TupleType": {
        if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          if (!uniques["{}"]) {
            uniques["{}"] = ast;
            out.push(ast);
          }
        } else if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      default:
        out.push(ast);
    }
  }
  return out;
};
var _Union2 = class _Union2 {
  constructor(types, annotations5 = {}) {
    __publicField(this, "types");
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "Union");
    this.types = types;
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return getOrElse3(getExpected2(this), () => this.types.map(String).join(" | "));
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
__publicField(_Union2, "make", (types, annotations5) => {
  return isMembers2(types) ? new _Union2(types, annotations5) : types.length === 1 ? types[0] : neverKeyword2;
});
/** @internal */
__publicField(_Union2, "unify", (candidates, annotations5) => {
  return _Union2.make(unify2(flatten16(candidates)), annotations5);
});
var Union3 = _Union2;
var mapMembers2 = (members, f) => members.map(f);
var isMembers2 = (as13) => as13.length > 1;
var isUnion2 = /* @__PURE__ */ createASTGuard2("Union");
var toJSONMemoMap2 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/schema/AST/toJSONMemoMap"), () => /* @__PURE__ */ new WeakMap());
var Suspend2 = class {
  constructor(f, annotations5 = {}) {
    __publicField(this, "f");
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "Suspend");
    this.f = f;
    this.annotations = annotations5;
    this.f = memoizeThunk2(f);
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return getExpected2(this).pipe(orElse(() => flatMap(liftThrowable(this.f)(), (ast) => getExpected2(ast))), getOrElse3(() => "<suspended schema>"));
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    const ast = this.f();
    let out = toJSONMemoMap2.get(ast);
    if (out) {
      return out;
    }
    toJSONMemoMap2.set(ast, {
      _tag: this._tag
    });
    out = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations2(this.annotations)
    };
    toJSONMemoMap2.set(ast, out);
    return out;
  }
};
var Refinement3 = class {
  constructor(from, filter14, annotations5 = {}) {
    __publicField(this, "from");
    __publicField(this, "filter");
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "Refinement");
    this.from = from;
    this.filter = filter14;
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return getOrElse3(getExpected2(this), () => `{ ${this.from} | filter }`);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var isRefinement3 = /* @__PURE__ */ createASTGuard2("Refinement");
var defaultParseOption2 = {};
var Transformation3 = class {
  constructor(from, to, transformation, annotations5 = {}) {
    __publicField(this, "from");
    __publicField(this, "to");
    __publicField(this, "transformation");
    __publicField(this, "annotations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "Transformation");
    this.from = from;
    this.to = to;
    this.transformation = transformation;
    this.annotations = annotations5;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return getOrElse3(getExpected2(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
};
var isTransformation3 = /* @__PURE__ */ createASTGuard2("Transformation");
var FinalTransformation2 = class {
  constructor(decode7, encode6) {
    __publicField(this, "decode");
    __publicField(this, "encode");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "FinalTransformation");
    this.decode = decode7;
    this.encode = encode6;
  }
};
var createTransformationGuard2 = (tag3) => (ast) => ast._tag === tag3;
var ComposeTransformation2 = class {
  constructor() {
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "ComposeTransformation");
  }
};
var composeTransformation2 = /* @__PURE__ */ new ComposeTransformation2();
var PropertySignatureTransformation3 = class {
  constructor(from, to, decode7, encode6) {
    __publicField(this, "from");
    __publicField(this, "to");
    __publicField(this, "decode");
    __publicField(this, "encode");
    this.from = from;
    this.to = to;
    this.decode = decode7;
    this.encode = encode6;
  }
};
var isRenamingPropertySignatureTransformation2 = (t) => t.decode === identity && t.encode === identity;
var TypeLiteralTransformation2 = class {
  constructor(propertySignatureTransformations) {
    __publicField(this, "propertySignatureTransformations");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "TypeLiteralTransformation");
    this.propertySignatureTransformations = propertySignatureTransformations;
    const fromKeys = {};
    const toKeys = {};
    for (const pst of propertySignatureTransformations) {
      const from = pst.from;
      if (fromKeys[from]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage2(from));
      }
      fromKeys[from] = true;
      const to = pst.to;
      if (toKeys[to]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage2(to));
      }
      toKeys[to] = true;
    }
  }
};
var isTypeLiteralTransformation2 = /* @__PURE__ */ createTransformationGuard2("TypeLiteralTransformation");
var annotations3 = (ast, annotations5) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  d.annotations.value = {
    ...ast.annotations,
    ...annotations5
  };
  return Object.create(Object.getPrototypeOf(ast), d);
};
var keyof3 = (ast) => Union3.unify(_keyof2(ast));
var STRING_KEYWORD_PATTERN2 = ".*";
var NUMBER_KEYWORD_PATTERN2 = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
var getTemplateLiteralRegExp2 = (ast) => {
  let pattern3 = `^${escape(ast.head)}`;
  for (const span4 of ast.spans) {
    if (isStringKeyword2(span4.type)) {
      pattern3 += STRING_KEYWORD_PATTERN2;
    } else if (isNumberKeyword2(span4.type)) {
      pattern3 += NUMBER_KEYWORD_PATTERN2;
    }
    pattern3 += escape(span4.literal);
  }
  pattern3 += "$";
  return new RegExp(pattern3);
};
var getTemplateLiteralCapturingRegExp2 = (ast) => {
  let pattern3 = `^`;
  if (ast.head !== "") {
    pattern3 += `(${escape(ast.head)})`;
  }
  for (const span4 of ast.spans) {
    if (isStringKeyword2(span4.type)) {
      pattern3 += `(${STRING_KEYWORD_PATTERN2})`;
    } else if (isNumberKeyword2(span4.type)) {
      pattern3 += `(${NUMBER_KEYWORD_PATTERN2})`;
    }
    if (span4.literal !== "") {
      pattern3 += `(${escape(span4.literal)})`;
    }
  }
  pattern3 += "$";
  return new RegExp(pattern3);
};
var getNumberIndexedAccess3 = (ast) => {
  switch (ast._tag) {
    case "TupleType": {
      let hasOptional = false;
      let out = [];
      for (const e of ast.elements) {
        if (e.isOptional) {
          hasOptional = true;
        }
        out.push(e.type);
      }
      if (hasOptional) {
        out.push(undefinedKeyword2);
      }
      out = out.concat(getRestASTs2(ast.rest));
      return Union3.make(out);
    }
    case "Refinement":
      return getNumberIndexedAccess3(ast.from);
    case "Union":
      return Union3.make(ast.types.map(getNumberIndexedAccess3));
    case "Suspend":
      return getNumberIndexedAccess3(ast.f());
  }
  throw new Error(getASTUnsupportedSchema(ast));
};
var getTypeLiteralPropertySignature2 = (ast, name) => {
  const ops = findFirst2(ast.propertySignatures, (ps) => ps.name === name);
  if (isSome2(ops)) {
    return ops.value;
  }
  if (isString(name)) {
    let out = void 0;
    for (const is4 of ast.indexSignatures) {
      const parameterBase = getParameterBase(is4.parameter);
      switch (parameterBase._tag) {
        case "TemplateLiteral": {
          const regex = getTemplateLiteralRegExp2(parameterBase);
          if (regex.test(name)) {
            return new PropertySignature2(name, is4.type, false, true);
          }
          break;
        }
        case "StringKeyword": {
          if (out === void 0) {
            out = new PropertySignature2(name, is4.type, false, true);
          }
        }
      }
    }
    if (out) {
      return out;
    }
  } else if (isSymbol(name)) {
    for (const is4 of ast.indexSignatures) {
      const parameterBase = getParameterBase(is4.parameter);
      if (isSymbolKeyword2(parameterBase)) {
        return new PropertySignature2(name, is4.type, false, true);
      }
    }
  }
};
var getPropertyKeyIndexedAccess2 = (ast, name) => {
  const annotation = getSurrogateAnnotation2(ast);
  if (isSome2(annotation)) {
    return getPropertyKeyIndexedAccess2(annotation.value, name);
  }
  switch (ast._tag) {
    case "TypeLiteral": {
      const ps = getTypeLiteralPropertySignature2(ast, name);
      if (ps) {
        return ps;
      }
      break;
    }
    case "Union":
      return new PropertySignature2(name, Union3.make(ast.types.map((ast2) => getPropertyKeyIndexedAccess2(ast2, name).type)), false, true);
    case "Suspend":
      return getPropertyKeyIndexedAccess2(ast.f(), name);
    case "Refinement":
      return getPropertyKeyIndexedAccess2(ast.from, name);
  }
  return new PropertySignature2(name, neverKeyword2, false, true);
};
var getPropertyKeys2 = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation2(ast);
      if (isSome2(annotation)) {
        return getPropertyKeys2(annotation.value);
      }
      break;
    }
    case "TypeLiteral":
      return ast.propertySignatures.map((ps) => ps.name);
    case "Suspend":
      return getPropertyKeys2(ast.f());
    case "Union":
      return ast.types.slice(1).reduce((out, ast2) => intersection(out, getPropertyKeys2(ast2)), getPropertyKeys2(ast.types[0]));
    case "Transformation":
      return getPropertyKeys2(ast.to);
  }
  return [];
};
var record3 = (key, value3) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go6 = (key2) => {
    switch (key2._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(new IndexSignature2(key2, value3, true));
        break;
      case "Literal":
        if (isString(key2.literal) || isNumber(key2.literal)) {
          propertySignatures.push(new PropertySignature2(key2.literal, value3, false, true));
        } else {
          throw new Error(getASTUnsupportedLiteral(key2.literal));
        }
        break;
      case "Enums": {
        for (const [_, name] of key2.enums) {
          propertySignatures.push(new PropertySignature2(name, value3, false, true));
        }
        break;
      }
      case "UniqueSymbol":
        propertySignatures.push(new PropertySignature2(key2.symbol, value3, false, true));
        break;
      case "Union":
        key2.types.forEach(go6);
        break;
      default:
        throw new Error(getASTUnsupportedKeySchema(key2));
    }
  };
  go6(key);
  return {
    propertySignatures,
    indexSignatures
  };
};
var pick6 = (ast, keys6) => {
  const annotation = getSurrogateAnnotation2(ast);
  if (isSome2(annotation)) {
    return pick6(annotation.value, keys6);
  }
  switch (ast._tag) {
    case "TypeLiteral": {
      const pss = [];
      const names = {};
      for (const ps of ast.propertySignatures) {
        names[ps.name] = null;
        if (keys6.includes(ps.name)) {
          pss.push(ps);
        }
      }
      for (const key of keys6) {
        if (!(key in names)) {
          const ps = getTypeLiteralPropertySignature2(ast, key);
          if (ps) {
            pss.push(ps);
          }
        }
      }
      return new TypeLiteral2(pss, []);
    }
    case "Union":
      return new TypeLiteral2(keys6.map((name) => getPropertyKeyIndexedAccess2(ast, name)), []);
    case "Suspend":
      return pick6(ast.f(), keys6);
    case "Refinement":
      return pick6(ast.from, keys6);
    case "Transformation": {
      switch (ast.transformation._tag) {
        case "ComposeTransformation":
          return new Transformation3(pick6(ast.from, keys6), pick6(ast.to, keys6), composeTransformation2);
        case "TypeLiteralTransformation": {
          const ts = [];
          const fromKeys = [];
          for (const k of keys6) {
            const t = ast.transformation.propertySignatureTransformations.find((t2) => t2.to === k);
            if (t) {
              ts.push(t);
              fromKeys.push(t.from);
            } else {
              fromKeys.push(k);
            }
          }
          return isNonEmptyReadonlyArray(ts) ? new Transformation3(pick6(ast.from, fromKeys), pick6(ast.to, keys6), new TypeLiteralTransformation2(ts)) : pick6(ast.from, fromKeys);
        }
      }
    }
  }
  throw new Error(getASTUnsupportedSchema(ast));
};
var omit6 = (ast, keys6) => pick6(ast, getPropertyKeys2(ast).filter((name) => !keys6.includes(name)));
var orUndefined2 = (ast) => Union3.make([ast, undefinedKeyword2]);
var partial3 = (ast, options) => {
  const exact = options?.exact === true;
  switch (ast._tag) {
    case "TupleType":
      return new TupleType2(ast.elements.map((e) => new OptionalType2(exact ? e.type : orUndefined2(e.type), true)), match3(ast.rest, {
        onEmpty: () => ast.rest,
        onNonEmpty: (rest) => [new Type3(Union3.make([...getRestASTs2(rest), undefinedKeyword2]))]
      }), ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral2(ast.propertySignatures.map((ps) => new PropertySignature2(ps.name, exact ? ps.type : orUndefined2(ps.type), true, ps.isReadonly, ps.annotations)), ast.indexSignatures.map((is4) => new IndexSignature2(is4.parameter, orUndefined2(is4.type), is4.isReadonly)));
    case "Union":
      return Union3.make(ast.types.map((member) => partial3(member, options)));
    case "Suspend":
      return new Suspend2(() => partial3(ast.f(), options));
    case "Declaration":
      throw new Error(getASTUnsupportedSchema(ast));
    case "Refinement":
      throw new Error(getASTUnsupportedSchema(ast));
    case "Transformation": {
      if (isTypeLiteralTransformation2(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation2)) {
        return new Transformation3(partial3(ast.from, options), partial3(ast.to, options), ast.transformation);
      }
      throw new Error(getASTUnsupportedSchema(ast));
    }
  }
  return ast;
};
var required3 = (ast) => {
  switch (ast._tag) {
    case "TupleType":
      return new TupleType2(ast.elements.map((e) => new OptionalType2(e.type, false)), ast.rest, ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral2(ast.propertySignatures.map((f) => new PropertySignature2(f.name, f.type, false, f.isReadonly, f.annotations)), ast.indexSignatures);
    case "Union":
      return Union3.make(ast.types.map((member) => required3(member)));
    case "Suspend":
      return new Suspend2(() => required3(ast.f()));
    case "Declaration":
      throw new Error(getASTUnsupportedSchema(ast));
    case "Refinement":
      throw new Error(getASTUnsupportedSchema(ast));
    case "Transformation": {
      if (isTypeLiteralTransformation2(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation2)) {
        return new Transformation3(required3(ast.from), required3(ast.to), ast.transformation);
      }
      throw new Error(getASTUnsupportedSchema(ast));
    }
  }
  return ast;
};
var mutable3 = (ast) => {
  switch (ast._tag) {
    case "TupleType":
      return ast.isReadonly === false ? ast : new TupleType2(ast.elements, ast.rest, false, ast.annotations);
    case "TypeLiteral": {
      const propertySignatures = changeMap2(ast.propertySignatures, (ps) => ps.isReadonly === false ? ps : new PropertySignature2(ps.name, ps.type, ps.isOptional, false, ps.annotations));
      const indexSignatures = changeMap2(ast.indexSignatures, (is4) => is4.isReadonly === false ? is4 : new IndexSignature2(is4.parameter, is4.type, false));
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral2(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap2(ast.types, mutable3);
      return types === ast.types ? ast : Union3.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend2(() => mutable3(ast.f()), ast.annotations);
    case "Refinement": {
      const from = mutable3(ast.from);
      return from === ast.from ? ast : new Refinement3(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const from = mutable3(ast.from);
      const to = mutable3(ast.to);
      return from === ast.from && to === ast.to ? ast : new Transformation3(from, to, ast.transformation, ast.annotations);
    }
  }
  return ast;
};
var typeAST2 = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap2(ast.typeParameters, typeAST2);
      return typeParameters === ast.typeParameters ? ast : new Declaration2(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap2(ast.elements, (e) => {
        const type = typeAST2(e.type);
        return type === e.type ? e : new OptionalType2(type, e.isOptional);
      });
      const restASTs = getRestASTs2(ast.rest);
      const rest = changeMap2(restASTs, typeAST2);
      return elements === ast.elements && rest === restASTs ? ast : new TupleType2(elements, rest.map((type) => new Type3(type)), ast.isReadonly, ast.annotations);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap2(ast.propertySignatures, (p) => {
        const type = typeAST2(p.type);
        return type === p.type ? p : new PropertySignature2(p.name, type, p.isOptional, p.isReadonly);
      });
      const indexSignatures = changeMap2(ast.indexSignatures, (is4) => {
        const type = typeAST2(is4.type);
        return type === is4.type ? is4 : new IndexSignature2(is4.parameter, type, is4.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral2(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap2(ast.types, typeAST2);
      return types === ast.types ? ast : Union3.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend2(() => typeAST2(ast.f()), ast.annotations);
    case "Refinement": {
      const from = typeAST2(ast.from);
      return from === ast.from ? ast : new Refinement3(from, ast.filter, ast.annotations);
    }
    case "Transformation":
      return typeAST2(ast.to);
  }
  return ast;
};
var blackListAnnotations = (annotationIds) => (annotated) => {
  const out = {
    ...annotated.annotations
  };
  for (const id3 of annotationIds) {
    delete out[id3];
  }
  return out;
};
var getJSONIdentifier2 = (annotated) => orElse(getJSONIdentifierAnnotation2(annotated), () => getIdentifierAnnotation2(annotated));
var createJSONIdentifierAnnotation2 = (annotated) => match2(getJSONIdentifier2(annotated), {
  onNone: () => void 0,
  onSome: (identifier2) => ({
    [JSONIdentifierAnnotationId2]: identifier2
  })
});
function changeMap2(as13, f) {
  let changed = false;
  const out = allocate(as13.length);
  for (let i = 0; i < as13.length; i++) {
    const a = as13[i];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as13;
}
var encodedAST_2 = (ast, isBound) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap2(ast.typeParameters, (ast2) => encodedAST_2(ast2, isBound));
      return typeParameters === ast.typeParameters ? ast : new Declaration2(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap2(ast.elements, (e) => {
        const type = encodedAST_2(e.type, isBound);
        return type === e.type ? e : new OptionalType2(type, e.isOptional);
      });
      const restASTs = getRestASTs2(ast.rest);
      const rest = changeMap2(restASTs, (ast2) => encodedAST_2(ast2, isBound));
      return elements === ast.elements && rest === restASTs ? ast : new TupleType2(elements, rest.map((ast2) => new Type3(ast2)), ast.isReadonly, createJSONIdentifierAnnotation2(ast));
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap2(ast.propertySignatures, (ps) => {
        const type = encodedAST_2(ps.type, isBound);
        return type === ps.type ? ps : new PropertySignature2(ps.name, type, ps.isOptional, ps.isReadonly);
      });
      const indexSignatures = changeMap2(ast.indexSignatures, (is4) => {
        const type = encodedAST_2(is4.type, isBound);
        return type === is4.type ? is4 : new IndexSignature2(is4.parameter, type, is4.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral2(propertySignatures, indexSignatures, createJSONIdentifierAnnotation2(ast));
    }
    case "Union": {
      const types = changeMap2(ast.types, (ast2) => encodedAST_2(ast2, isBound));
      return types === ast.types ? ast : Union3.make(types, createJSONIdentifierAnnotation2(ast));
    }
    case "Suspend":
      return new Suspend2(() => encodedAST_2(ast.f(), isBound), createJSONIdentifierAnnotation2(ast));
    case "Refinement": {
      const from = encodedAST_2(ast.from, isBound);
      if (isBound) {
        if (from === ast.from) {
          return ast;
        }
        if (!isTransformation3(ast.from) && hasStableFilter2(ast)) {
          return new Refinement3(from, ast.filter);
        }
      }
      return from;
    }
    case "Transformation":
      return encodedAST_2(ast.from, isBound);
  }
  return ast;
};
var encodedAST2 = (ast) => encodedAST_2(ast, false);
var encodedBoundAST2 = (ast) => encodedAST_2(ast, true);
var toJSONAnnotations2 = (annotations5) => {
  const out = {};
  for (const k of Object.getOwnPropertySymbols(annotations5)) {
    out[String(k)] = annotations5[k];
  }
  return out;
};
var getParameterBase = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getParameterBase(ast.from);
  }
};
var equalsTemplateLiteralSpan2 = /* @__PURE__ */ getEquivalence3((self, that) => self.type._tag === that.type._tag && self.literal === that.literal);
var equalsEnums2 = /* @__PURE__ */ getEquivalence3((self, that) => that[0] === self[0] && that[1] === self[1]);
var equals6 = (self, that) => {
  switch (self._tag) {
    case "Literal":
      return isLiteral2(that) && that.literal === self.literal;
    case "UniqueSymbol":
      return isUniqueSymbol2(that) && that.symbol === self.symbol;
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "NeverKeyword":
    case "UnknownKeyword":
    case "AnyKeyword":
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
    case "ObjectKeyword":
      return that._tag === self._tag;
    case "TemplateLiteral":
      return isTemplateLiteral2(that) && that.head === self.head && equalsTemplateLiteralSpan2(that.spans, self.spans);
    case "Enums":
      return isEnums2(that) && equalsEnums2(that.enums, self.enums);
    case "Refinement":
    case "TupleType":
    case "TypeLiteral":
    case "Union":
    case "Suspend":
    case "Transformation":
    case "Declaration":
      return self === that;
  }
};
var intersection5 = /* @__PURE__ */ intersectionWith(equals6);
var _keyof2 = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation2(ast);
      if (isSome2(annotation)) {
        return _keyof2(annotation.value);
      }
      break;
    }
    case "TypeLiteral":
      return ast.propertySignatures.map((p) => isSymbol(p.name) ? new UniqueSymbol2(p.name) : new Literal3(p.name)).concat(ast.indexSignatures.map((is4) => getParameterBase(is4.parameter)));
    case "Suspend":
      return _keyof2(ast.f());
    case "Union":
      return ast.types.slice(1).reduce((out, ast2) => intersection5(out, _keyof2(ast2)), _keyof2(ast.types[0]));
    case "Transformation":
      return _keyof2(ast.to);
  }
  throw new Error(getASTUnsupportedSchema(ast));
};
var compose5 = (ab, cd) => new Transformation3(ab, cd, composeTransformation2);
var rename3 = (ast, mapping) => {
  switch (ast._tag) {
    case "TypeLiteral": {
      const propertySignatureTransformations = [];
      for (const key of ownKeys2(mapping)) {
        const name = mapping[key];
        if (name !== void 0) {
          propertySignatureTransformations.push(new PropertySignatureTransformation3(key, name, identity, identity));
        }
      }
      if (propertySignatureTransformations.length === 0) {
        return ast;
      }
      return new Transformation3(ast, new TypeLiteral2(ast.propertySignatures.map((ps) => {
        const name = mapping[ps.name];
        return new PropertySignature2(name === void 0 ? ps.name : name, typeAST2(ps.type), ps.isOptional, ps.isReadonly, ps.annotations);
      }), ast.indexSignatures), new TypeLiteralTransformation2(propertySignatureTransformations));
    }
    case "Union":
      return Union3.make(ast.types.map((ast2) => rename3(ast2, mapping)));
    case "Suspend":
      return new Suspend2(() => rename3(ast.f(), mapping));
    case "Transformation":
      return compose5(ast, rename3(typeAST2(ast), mapping));
  }
  throw new Error(getASTUnsupportedRenameSchema(ast));
};
var formatKeyword2 = (ast) => getOrElse3(getExpected2(ast), () => ast._tag);
var getExpected2 = (ast) => {
  return getIdentifierAnnotation2(ast).pipe(orElse(() => getTitleAnnotation2(ast)), orElse(() => getDescriptionAnnotation2(ast)));
};

// ../../node_modules/.pnpm/@effect+schema@0.75.5_effect@3.16.3/node_modules/@effect/schema/dist/esm/internal/filters.js
var GreaterThanTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThan");
var GreaterThanOrEqualToTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualTo");
var LessThanTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThan");
var LessThanOrEqualToTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanOrEqualTo");
var IntTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Int");
var BetweenTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Between");
var GreaterThanBigintTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanBigint");
var GreaterThanOrEqualToBigIntTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualToBigint");
var LessThanBigIntTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanBigint");
var LessThanOrEqualToBigIntTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanOrEqualToBigint");
var BetweenBigintTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/BetweenBigint");
var MinLengthTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/MinLength");
var MaxLengthTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/MaxLength");
var LengthTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Length");
var MinItemsTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/MinItems");
var MaxItemsTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/MaxItems");
var ItemsCountTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/ItemsCount");
var ParseJsonTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/ParseJson");

// ../../node_modules/.pnpm/@effect+schema@0.75.5_effect@3.16.3/node_modules/@effect/schema/dist/esm/Arbitrary.js
var ArbitraryHookId = /* @__PURE__ */ Symbol.for("@effect/schema/ArbitraryHookId");

// ../../node_modules/.pnpm/@effect+schema@0.75.5_effect@3.16.3/node_modules/@effect/schema/dist/esm/TreeFormatter.js
var make66 = (value3, forest = []) => ({
  value: value3,
  forest
});
var formatIssue = (issue) => map18(go4(issue), (tree) => drawTree2(tree));
var formatIssueSync = (issue) => runSync(formatIssue(issue));
var formatErrorSync = (error2) => formatIssueSync(error2.issue);
var drawTree2 = (tree) => tree.value + draw2("\n", tree.forest);
var draw2 = (indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0; i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "\u2514" : "\u251C") + "\u2500 " + tree.value;
    r += draw2(indentation + (len > 1 && !isLast ? "\u2502  " : "   "), tree.forest);
  }
  return r;
};
var formatTransformationKind2 = (kind) => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
};
var formatRefinementKind2 = (kind) => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
};
var getAnnotated2 = (issue) => "ast" in issue ? some2(issue.ast) : none2();
var getCurrentMessage2 = (issue) => getAnnotated2(issue).pipe(flatMap(getMessageAnnotation2), flatMap12((annotation) => {
  const out = annotation(issue);
  return isString(out) ? succeed10({
    message: out,
    override: false
  }) : isEffect2(out) ? map18(out, (message) => ({
    message,
    override: false
  })) : isString(out.message) ? succeed10({
    message: out.message,
    override: out.override
  }) : map18(out.message, (message) => ({
    message,
    override: out.override
  }));
}));
var createParseIssueGuard2 = (tag3) => (issue) => issue._tag === tag3;
var isComposite3 = /* @__PURE__ */ createParseIssueGuard2("Composite");
var isRefinement4 = /* @__PURE__ */ createParseIssueGuard2("Refinement");
var isTransformation4 = /* @__PURE__ */ createParseIssueGuard2("Transformation");
var getMessage2 = (issue) => getCurrentMessage2(issue).pipe(flatMap12((currentMessage) => {
  const useInnerMessage = !currentMessage.override && (isComposite3(issue) || isRefinement4(issue) && issue.kind === "From" || isTransformation4(issue) && issue.kind !== "Transformation");
  return useInnerMessage ? isTransformation4(issue) || isRefinement4(issue) ? getMessage2(issue.issue) : none2() : succeed10(currentMessage.message);
}));
var getParseIssueTitleAnnotation4 = (issue) => getAnnotated2(issue).pipe(flatMap(getParseIssueTitleAnnotation3), filterMap((annotation) => fromNullable(annotation(issue))));
var formatTypeMessage2 = (e) => getMessage2(e).pipe(orElse6(() => getParseIssueTitleAnnotation4(e)), catchAll3(() => succeed10(e.message ?? `Expected ${String(e.ast)}, actual ${formatUnknown2(e.actual)}`)));
var getParseIssueTitle2 = (issue) => getOrElse3(getParseIssueTitleAnnotation4(issue), () => String(issue.ast));
var formatForbiddenMessage2 = (e) => e.message ?? "is forbidden";
var formatUnexpectedMessage2 = (e) => e.message ?? "is unexpected";
var formatMissingMessage2 = (e) => getMissingMessageAnnotation2(e.ast).pipe(flatMap12((annotation) => {
  const out = annotation();
  return isString(out) ? succeed10(out) : out;
}), catchAll3(() => succeed10(e.message ?? "is missing")));
var getTree = (issue, onFailure) => matchEffect2(getMessage2(issue), {
  onFailure,
  onSuccess: (message) => succeed10(make66(message))
});
var go4 = (e) => {
  switch (e._tag) {
    case "Type":
      return map18(formatTypeMessage2(e), make66);
    case "Forbidden":
      return succeed10(make66(getParseIssueTitle2(e), [make66(formatForbiddenMessage2(e))]));
    case "Unexpected":
      return succeed10(make66(formatUnexpectedMessage2(e)));
    case "Missing":
      return map18(formatMissingMessage2(e), make66);
    case "Transformation":
      return getTree(e, () => map18(go4(e.issue), (tree) => make66(getParseIssueTitle2(e), [make66(formatTransformationKind2(e.kind), [tree])])));
    case "Refinement":
      return getTree(e, () => map18(go4(e.issue), (tree) => make66(getParseIssueTitle2(e), [make66(formatRefinementKind2(e.kind), [tree])])));
    case "Pointer":
      return map18(go4(e.issue), (tree) => make66(formatPath2(e.path), [tree]));
    case "Composite": {
      const parseIssueTitle = getParseIssueTitle2(e);
      return getTree(e, () => isNonEmpty7(e.issues) ? map18(forEach10(e.issues, go4), (forest) => make66(parseIssueTitle, forest)) : map18(go4(e.issues), (tree) => make66(parseIssueTitle, [tree])));
    }
  }
};

// ../../node_modules/.pnpm/@effect+schema@0.75.5_effect@3.16.3/node_modules/@effect/schema/dist/esm/ParseResult.js
var Pointer2 = class {
  constructor(path, actual, issue) {
    __publicField(this, "path");
    __publicField(this, "actual");
    __publicField(this, "issue");
    /**
     * @since 0.68.0
     */
    __publicField(this, "_tag", "Pointer");
    this.path = path;
    this.actual = actual;
    this.issue = issue;
  }
};
var Unexpected2 = class {
  constructor(actual, message) {
    __publicField(this, "actual");
    __publicField(this, "message");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "Unexpected");
    this.actual = actual;
    this.message = message;
  }
};
var Missing2 = class {
  constructor(ast, message) {
    __publicField(this, "ast");
    __publicField(this, "message");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "Missing");
    /**
     * @since 0.68.0
     */
    __publicField(this, "actual");
    this.ast = ast;
    this.message = message;
  }
};
var Composite3 = class {
  constructor(ast, actual, issues, output3) {
    __publicField(this, "ast");
    __publicField(this, "actual");
    __publicField(this, "issues");
    __publicField(this, "output");
    /**
     * @since 0.68.0
     */
    __publicField(this, "_tag", "Composite");
    this.ast = ast;
    this.actual = actual;
    this.issues = issues;
    this.output = output3;
  }
};
var Refinement4 = class {
  constructor(ast, actual, kind, issue) {
    __publicField(this, "ast");
    __publicField(this, "actual");
    __publicField(this, "kind");
    __publicField(this, "issue");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "Refinement");
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
};
var Transformation4 = class {
  constructor(ast, actual, kind, issue) {
    __publicField(this, "ast");
    __publicField(this, "actual");
    __publicField(this, "kind");
    __publicField(this, "issue");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "Transformation");
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
};
var Type4 = class {
  constructor(ast, actual, message) {
    __publicField(this, "ast");
    __publicField(this, "actual");
    __publicField(this, "message");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "Type");
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
};
var Forbidden2 = class {
  constructor(ast, actual, message) {
    __publicField(this, "ast");
    __publicField(this, "actual");
    __publicField(this, "message");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "Forbidden");
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
};
var ParseErrorTypeId3 = /* @__PURE__ */ Symbol.for("@effect/schema/ParseErrorTypeId");
var _a99;
var ParseError3 = class extends (/* @__PURE__ */ TaggedError("ParseError")) {
  constructor() {
    super(...arguments);
    /**
     * @since 0.68.0
     */
    __publicField(this, _a99, ParseErrorTypeId3);
  }
  get message() {
    return this.toString();
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return formatIssueSync(this.issue);
  }
  /**
   * @since 0.67.0
   */
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  /**
   * @since 0.67.0
   */
  [(_a99 = ParseErrorTypeId3, NodeInspectSymbol)]() {
    return this.toJSON();
  }
};
var parseError2 = (issue) => new ParseError3({
  issue
});
var succeed21 = right2;
var fail20 = left2;
var _try2 = try_;
var fromOption4 = fromOption2;
var flatMap20 = /* @__PURE__ */ dual(2, (self, f) => {
  const s = self;
  if (s["_tag"] === "Left") {
    return s;
  }
  if (s["_tag"] === "Right") {
    return f(s.right);
  }
  return flatMap12(self, f);
});
var map29 = /* @__PURE__ */ dual(2, (self, f) => {
  const s = self;
  if (s["_tag"] === "Left") {
    return s;
  }
  if (s["_tag"] === "Right") {
    return right2(f(s.right));
  }
  return map18(self, f);
});
var mapError10 = /* @__PURE__ */ dual(2, (self, f) => {
  const s = self;
  if (s["_tag"] === "Left") {
    return left2(f(s.left));
  }
  if (s["_tag"] === "Right") {
    return s;
  }
  return mapError3(self, f);
});
var eitherOrUndefined = (self) => {
  const s = self;
  if (s["_tag"] === "Left" || s["_tag"] === "Right") {
    return s;
  }
};
var mapBoth10 = /* @__PURE__ */ dual(2, (self, options) => {
  const s = self;
  if (s["_tag"] === "Left") {
    return left2(options.onFailure(s.left));
  }
  if (s["_tag"] === "Right") {
    return right2(options.onSuccess(s.right));
  }
  return mapBoth5(self, options);
});
var orElse14 = /* @__PURE__ */ dual(2, (self, f) => {
  const s = self;
  if (s["_tag"] === "Left") {
    return f(s.left);
  }
  if (s["_tag"] === "Right") {
    return s;
  }
  return catchAll3(self, f);
});
var mergeInternalOptions2 = (options, overrideOptions) => {
  if (overrideOptions === void 0 || isNumber(overrideOptions)) {
    return options;
  }
  if (options === void 0) {
    return overrideOptions;
  }
  return {
    ...options,
    ...overrideOptions
  };
};
var getEither2 = (ast, isDecoding, options) => {
  const parser = goMemo2(ast, isDecoding);
  return (u, overrideOptions) => parser(u, mergeInternalOptions2(options, overrideOptions));
};
var getSync2 = (ast, isDecoding, options) => {
  const parser = getEither2(ast, isDecoding, options);
  return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError2);
};
var getOption4 = (ast, isDecoding, options) => {
  const parser = getEither2(ast, isDecoding, options);
  return (input, overrideOptions) => getRight2(parser(input, overrideOptions));
};
var getEffect2 = (ast, isDecoding, options) => {
  const parser = goMemo2(ast, isDecoding);
  return (input, overrideOptions) => parser(input, {
    ...mergeInternalOptions2(options, overrideOptions),
    isEffectAllowed: true
  });
};
var decodeUnknownSync2 = (schema, options) => getSync2(schema.ast, true, options);
var decodeUnknownOption2 = (schema, options) => getOption4(schema.ast, true, options);
var decodeUnknownEither3 = (schema, options) => getEither2(schema.ast, true, options);
var decodeUnknown4 = (schema, options) => getEffect2(schema.ast, true, options);
var encodeUnknownSync2 = (schema, options) => getSync2(schema.ast, false, options);
var encodeUnknownOption2 = (schema, options) => getOption4(schema.ast, false, options);
var encodeUnknownEither3 = (schema, options) => getEither2(schema.ast, false, options);
var encodeUnknown3 = (schema, options) => getEffect2(schema.ast, false, options);
var decodeSync2 = decodeUnknownSync2;
var decodeOption2 = decodeUnknownOption2;
var validateSync2 = (schema, options) => getSync2(typeAST2(schema.ast), true, options);
var validateOption2 = (schema, options) => getOption4(typeAST2(schema.ast), true, options);
var validateEither3 = (schema, options) => getEither2(typeAST2(schema.ast), true, options);
var validate6 = (schema, options) => getEffect2(typeAST2(schema.ast), true, options);
var is3 = (schema, options) => {
  const parser = goMemo2(typeAST2(schema.ast), true);
  return (u, overrideOptions) => isRight2(parser(u, {
    exact: true,
    ...mergeInternalOptions2(options, overrideOptions)
  }));
};
var asserts2 = (schema, options) => {
  const parser = goMemo2(typeAST2(schema.ast), true);
  return (u, overrideOptions) => {
    const result = parser(u, {
      exact: true,
      ...mergeInternalOptions2(options, overrideOptions)
    });
    if (isLeft2(result)) {
      throw parseError2(result.left);
    }
  };
};
var encodeSync2 = encodeUnknownSync2;
var encodeOption2 = encodeUnknownOption2;
var decodeMemoMap2 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/schema/Parser/decodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var encodeMemoMap2 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/schema/Parser/encodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var goMemo2 = (ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap2 : encodeMemoMap2;
  const memo2 = memoMap.get(ast);
  if (memo2) {
    return memo2;
  }
  const raw = go5(ast, isDecoding);
  const parseOptionsAnnotation = getParseOptionsAnnotation2(ast);
  const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i, options) => raw(i, mergeInternalOptions2(options, parseOptionsAnnotation.value)) : raw;
  const decodingFallbackAnnotation = getDecodingFallbackAnnotation2(ast);
  const parser = isDecoding && isSome2(decodingFallbackAnnotation) ? (i, options) => handleForbidden2(orElse14(parserWithOptions(i, options), decodingFallbackAnnotation.value), ast, i, options) : parserWithOptions;
  memoMap.set(ast, parser);
  return parser;
};
var getConcurrency2 = (ast) => getOrUndefined(getConcurrencyAnnotation2(ast));
var getBatching2 = (ast) => getOrUndefined(getBatchingAnnotation2(ast));
var go5 = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement": {
      if (isDecoding) {
        const from = goMemo2(ast.from, true);
        return (i, options) => {
          options = options ?? defaultParseOption2;
          const allErrors = options?.errors === "all";
          const result = flatMap20(orElse14(from(i, options), (ef) => {
            const issue = new Refinement4(ast, i, "From", ef);
            if (allErrors && hasStableFilter2(ast)) {
              return match2(ast.filter(i, options, ast), {
                onNone: () => left2(issue),
                onSome: (ep) => left2(new Composite3(ast, i, [issue, new Refinement4(ast, i, "Predicate", ep)]))
              });
            }
            return left2(issue);
          }), (a) => match2(ast.filter(a, options, ast), {
            onNone: () => right2(a),
            onSome: (ep) => left2(new Refinement4(ast, i, "Predicate", ep))
          }));
          return handleForbidden2(result, ast, i, options);
        };
      } else {
        const from = goMemo2(typeAST2(ast), true);
        const to = goMemo2(dropRightRefinement2(ast.from), false);
        return (i, options) => handleForbidden2(flatMap20(from(i, options), (a) => to(a, options)), ast, i, options);
      }
    }
    case "Transformation": {
      const transform4 = getFinalTransformation2(ast.transformation, isDecoding);
      const from = isDecoding ? goMemo2(ast.from, true) : goMemo2(ast.to, false);
      const to = isDecoding ? goMemo2(ast.to, true) : goMemo2(ast.from, false);
      return (i, options) => handleForbidden2(flatMap20(mapError10(from(i, options), (e) => new Transformation4(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap20(mapError10(transform4(a, options ?? defaultParseOption2, ast, i), (e) => new Transformation4(ast, i, "Transformation", e)), (i2) => mapError10(to(i2, options), (e) => new Transformation4(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options);
    }
    case "Declaration": {
      const parse3 = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
      return (i, options) => handleForbidden2(parse3(i, options ?? defaultParseOption2, ast), ast, i, options);
    }
    case "Literal":
      return fromRefinement2(ast, (u) => u === ast.literal);
    case "UniqueSymbol":
      return fromRefinement2(ast, (u) => u === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement2(ast, isUndefined);
    case "NeverKeyword":
      return fromRefinement2(ast, isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
    case "VoidKeyword":
      return right2;
    case "StringKeyword":
      return fromRefinement2(ast, isString);
    case "NumberKeyword":
      return fromRefinement2(ast, isNumber);
    case "BooleanKeyword":
      return fromRefinement2(ast, isBoolean);
    case "BigIntKeyword":
      return fromRefinement2(ast, isBigInt);
    case "SymbolKeyword":
      return fromRefinement2(ast, isSymbol);
    case "ObjectKeyword":
      return fromRefinement2(ast, isObject);
    case "Enums":
      return fromRefinement2(ast, (u) => ast.enums.some(([_, value3]) => value3 === u));
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp2(ast);
      return fromRefinement2(ast, (u) => isString(u) && regex.test(u));
    }
    case "TupleType": {
      const elements = ast.elements.map((e) => goMemo2(e.type, isDecoding));
      const rest = ast.rest.map((annotatedAST) => goMemo2(annotatedAST.type, isDecoding));
      let requiredTypes = ast.elements.filter((e) => !e.isOptional);
      if (ast.rest.length > 0) {
        requiredTypes = requiredTypes.concat(ast.rest.slice(1));
      }
      const requiredLen = requiredTypes.length;
      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
      const concurrency = getConcurrency2(ast);
      const batching = getBatching2(ast);
      return (input, options) => {
        if (!isArray(input)) {
          return left2(new Type4(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const output3 = [];
        const len = input.length;
        for (let i2 = len; i2 <= requiredLen - 1; i2++) {
          const e = new Pointer2(i2, input, new Missing2(requiredTypes[i2 - len]));
          if (allErrors) {
            es.push([stepKey++, e]);
            continue;
          } else {
            return left2(new Composite3(ast, input, e, output3));
          }
        }
        if (ast.rest.length === 0) {
          for (let i2 = ast.elements.length; i2 <= len - 1; i2++) {
            const e = new Pointer2(i2, input, new Unexpected2(input[i2], `is unexpected, expected: ${expectedIndexes}`));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite3(ast, input, e, output3));
            }
          }
        }
        let i = 0;
        let queue = void 0;
        for (; i < elements.length; i++) {
          if (len < i + 1) {
            if (ast.elements[i].isOptional) {
              continue;
            }
          } else {
            const parser = elements[i];
            const te = parser(input[i], options);
            const eu = eitherOrUndefined(te);
            if (eu) {
              if (isLeft2(eu)) {
                const e = new Pointer2(i, input, eu.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite3(ast, input, e, sortByIndex2(output3)));
                }
              }
              output3.push([stepKey++, eu.right]);
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output4
              }) => flatMap12(either4(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer2(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite3(ast, input, e, sortByIndex2(output4)));
                  }
                }
                output4.push([nk, t.right]);
                return _void;
              }));
            }
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head8, ...tail2] = rest;
          for (; i < len - tail2.length; i++) {
            const te = head8(input[i], options);
            const eu = eitherOrUndefined(te);
            if (eu) {
              if (isLeft2(eu)) {
                const e = new Pointer2(i, input, eu.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite3(ast, input, e, sortByIndex2(output3)));
                }
              } else {
                output3.push([stepKey++, eu.right]);
              }
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output4
              }) => flatMap12(either4(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer2(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite3(ast, input, e, sortByIndex2(output4)));
                  }
                } else {
                  output4.push([nk, t.right]);
                  return _void;
                }
              }));
            }
          }
          for (let j = 0; j < tail2.length; j++) {
            i += j;
            if (len < i + 1) {
              continue;
            } else {
              const te = tail2[j](input[i], options);
              const eu = eitherOrUndefined(te);
              if (eu) {
                if (isLeft2(eu)) {
                  const e = new Pointer2(i, input, eu.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite3(ast, input, e, sortByIndex2(output3)));
                  }
                }
                output3.push([stepKey++, eu.right]);
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output4
                }) => flatMap12(either4(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer2(index, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite3(ast, input, e, sortByIndex2(output4)));
                    }
                  }
                  output4.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output4
        }) => isNonEmptyArray2(es2) ? left2(new Composite3(ast, input, sortByIndex2(es2), sortByIndex2(output4))) : right2(sortByIndex2(output4));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy(es),
              output: copy(output3)
            };
            return flatMap12(forEach10(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          output: output3,
          es
        });
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return fromRefinement2(ast, isNotNullable);
      }
      const propertySignatures = [];
      const expectedKeysMap = {};
      const expectedKeys = [];
      for (const ps of ast.propertySignatures) {
        propertySignatures.push([goMemo2(ps.type, isDecoding), ps]);
        expectedKeysMap[ps.name] = null;
        expectedKeys.push(ps.name);
      }
      const indexSignatures = ast.indexSignatures.map((is4) => [goMemo2(is4.parameter, isDecoding), goMemo2(is4.type, isDecoding), is4.parameter]);
      const expectedAST = Union3.make(ast.indexSignatures.map((is4) => is4.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol2(key) : new Literal3(key))));
      const expected = goMemo2(expectedAST, isDecoding);
      const concurrency = getConcurrency2(ast);
      const batching = getBatching2(ast);
      return (input, options) => {
        if (!isRecord(input)) {
          return left2(new Type4(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const onExcessPropertyError = options?.onExcessProperty === "error";
        const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
        const output3 = {};
        let inputKeys;
        if (onExcessPropertyError || onExcessPropertyPreserve) {
          inputKeys = ownKeys2(input);
          for (const key of inputKeys) {
            const eu = eitherOrUndefined(expected(key, options));
            if (isLeft2(eu)) {
              if (onExcessPropertyError) {
                const e = new Pointer2(key, input, new Unexpected2(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite3(ast, input, e, output3));
                }
              } else {
                output3[key] = input[key];
              }
            }
          }
        }
        let queue = void 0;
        const isExact = options?.exact === true;
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = propertySignatures[i][1];
          const name = ps.name;
          const hasKey = Object.prototype.hasOwnProperty.call(input, name);
          if (!hasKey) {
            if (ps.isOptional) {
              continue;
            } else if (isExact) {
              const e = new Pointer2(name, input, new Missing2(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite3(ast, input, e, output3));
              }
            }
          }
          const parser = propertySignatures[i][0];
          const te = parser(input[name], options);
          const eu = eitherOrUndefined(te);
          if (eu) {
            if (isLeft2(eu)) {
              const e = new Pointer2(name, input, hasKey ? eu.left : new Missing2(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite3(ast, input, e, output3));
              }
            }
            output3[name] = eu.right;
          } else {
            const nk = stepKey++;
            const index = name;
            if (!queue) {
              queue = [];
            }
            queue.push(({
              es: es2,
              output: output4
            }) => flatMap12(either4(te), (t) => {
              if (isLeft2(t)) {
                const e = new Pointer2(index, input, hasKey ? t.left : new Missing2(ps));
                if (allErrors) {
                  es2.push([nk, e]);
                  return _void;
                } else {
                  return left2(new Composite3(ast, input, e, output4));
                }
              }
              output4[index] = t.right;
              return _void;
            }));
          }
        }
        for (let i = 0; i < indexSignatures.length; i++) {
          const indexSignature = indexSignatures[i];
          const parameter = indexSignature[0];
          const type = indexSignature[1];
          const keys6 = getKeysForIndexSignature2(input, indexSignature[2]);
          for (const key of keys6) {
            const keu = eitherOrUndefined(parameter(key, options));
            if (keu && isRight2(keu)) {
              const vpr = type(input[key], options);
              const veu = eitherOrUndefined(vpr);
              if (veu) {
                if (isLeft2(veu)) {
                  const e = new Pointer2(key, input, veu.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite3(ast, input, e, output3));
                  }
                } else {
                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                    output3[key] = veu.right;
                  }
                }
              } else {
                const nk = stepKey++;
                const index = key;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output4
                }) => flatMap12(either4(vpr), (tv) => {
                  if (isLeft2(tv)) {
                    const e = new Pointer2(index, input, tv.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite3(ast, input, e, output4));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output4[key] = tv.right;
                    }
                    return _void;
                  }
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output4
        }) => {
          if (isNonEmptyArray2(es2)) {
            return left2(new Composite3(ast, input, sortByIndex2(es2), output4));
          }
          if (options?.propertyOrder === "original") {
            const keys6 = inputKeys || ownKeys2(input);
            for (const name of expectedKeys) {
              if (keys6.indexOf(name) === -1) {
                keys6.push(name);
              }
            }
            const out = {};
            for (const key of keys6) {
              if (Object.prototype.hasOwnProperty.call(output4, key)) {
                out[key] = output4[key];
              }
            }
            return right2(out);
          }
          return right2(output4);
        };
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy(es),
              output: Object.assign({}, output3)
            };
            return flatMap12(forEach10(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          es,
          output: output3
        });
      };
    }
    case "Union": {
      const searchTree = getSearchTree2(ast.types, isDecoding);
      const ownKeys3 = ownKeys2(searchTree.keys);
      const len = ownKeys3.length;
      const map31 = /* @__PURE__ */ new Map();
      for (let i = 0; i < ast.types.length; i++) {
        map31.set(ast.types[i], goMemo2(ast.types[i], isDecoding));
      }
      const concurrency = getConcurrency2(ast) ?? 1;
      const batching = getBatching2(ast);
      return (input, options) => {
        const es = [];
        let stepKey = 0;
        let candidates = [];
        if (len > 0) {
          if (isObject2(input)) {
            for (let i = 0; i < len; i++) {
              const name = ownKeys3[i];
              const buckets = searchTree.keys[name].buckets;
              if (Object.prototype.hasOwnProperty.call(input, name)) {
                const literal2 = String(input[name]);
                if (Object.prototype.hasOwnProperty.call(buckets, literal2)) {
                  candidates = candidates.concat(buckets[literal2]);
                } else {
                  const literals = Union3.make(searchTree.keys[name].literals);
                  es.push([stepKey++, new Composite3(new TypeLiteral2([new PropertySignature2(name, literals, false, true)], []), input, new Pointer2(name, input, new Type4(literals, input[name])))]);
                }
              } else {
                const literals = Union3.make(searchTree.keys[name].literals);
                const fakeps = new PropertySignature2(name, literals, false, true);
                es.push([stepKey++, new Composite3(new TypeLiteral2([fakeps], []), input, new Pointer2(name, input, new Missing2(fakeps)))]);
              }
            }
          } else {
            es.push([stepKey++, new Type4(ast, input)]);
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        let queue = void 0;
        for (let i = 0; i < candidates.length; i++) {
          const candidate = candidates[i];
          const pr = map31.get(candidate)(input, options);
          const eu = !queue || queue.length === 0 ? eitherOrUndefined(pr) : void 0;
          if (eu) {
            if (isRight2(eu)) {
              return eu;
            } else {
              es.push([stepKey++, eu.left]);
            }
          } else {
            const nk = stepKey++;
            if (!queue) {
              queue = [];
            }
            queue.push((state) => suspend4(() => {
              if ("finalResult" in state) {
                return _void;
              } else {
                return flatMap12(either4(pr), (t) => {
                  if (isRight2(t)) {
                    state.finalResult = t;
                  } else {
                    state.es.push([nk, t.left]);
                  }
                  return _void;
                });
              }
            }));
          }
        }
        const computeResult = (es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite3(ast, input, sortByIndex2(es2))) : (
          // this should never happen
          left2(new Type4(ast, input))
        );
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state = {
              es: copy(es)
            };
            return flatMap12(forEach10(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => {
              if ("finalResult" in state) {
                return state.finalResult;
              }
              return computeResult(state.es);
            });
          });
        }
        return computeResult(es);
      };
    }
    case "Suspend": {
      const get17 = memoizeThunk2(() => goMemo2(annotations3(ast.f(), ast.annotations), isDecoding));
      return (a, options) => get17()(a, options);
    }
  }
};
var isObject2 = (input) => typeof input === "object" && input !== null;
var fromRefinement2 = (ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type4(ast, u));
var getLiterals2 = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation2(ast);
      if (isSome2(annotation)) {
        return getLiterals2(annotation.value, isDecoding);
      }
      break;
    }
    case "TypeLiteral": {
      const out = [];
      for (let i = 0; i < ast.propertySignatures.length; i++) {
        const propertySignature3 = ast.propertySignatures[i];
        const type = isDecoding ? encodedAST2(propertySignature3.type) : typeAST2(propertySignature3.type);
        if (isLiteral2(type) && !propertySignature3.isOptional) {
          out.push([propertySignature3.name, type]);
        }
      }
      return out;
    }
    case "TupleType": {
      const out = [];
      for (let i = 0; i < ast.elements.length; i++) {
        const element3 = ast.elements[i];
        const type = isDecoding ? encodedAST2(element3.type) : typeAST2(element3.type);
        if (isLiteral2(type) && !element3.isOptional) {
          out.push([i, type]);
        }
      }
      return out;
    }
    case "Refinement":
      return getLiterals2(ast.from, isDecoding);
    case "Suspend":
      return getLiterals2(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals2(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
};
var getSearchTree2 = (members, isDecoding) => {
  const keys6 = {};
  const otherwise = [];
  for (let i = 0; i < members.length; i++) {
    const member = members[i];
    const tags = getLiterals2(member, isDecoding);
    if (tags.length > 0) {
      for (let j = 0; j < tags.length; j++) {
        const [key, literal2] = tags[j];
        const hash4 = String(literal2.literal);
        keys6[key] = keys6[key] || {
          buckets: {},
          literals: []
        };
        const buckets = keys6[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash4)) {
          if (j < tags.length - 1) {
            continue;
          }
          buckets[hash4].push(member);
          keys6[key].literals.push(literal2);
        } else {
          buckets[hash4] = [member];
          keys6[key].literals.push(literal2);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys: keys6,
    otherwise
  };
};
var dropRightRefinement2 = (ast) => isRefinement3(ast) ? dropRightRefinement2(ast.from) : ast;
var handleForbidden2 = (effect4, ast, actual, options) => {
  const eu = eitherOrUndefined(effect4);
  if (eu) {
    return eu;
  }
  if (options?.isEffectAllowed === true) {
    return effect4;
  }
  try {
    return runSync(either4(effect4));
  } catch (e) {
    return left2(new Forbidden2(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
  }
};
var compare2 = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0;
function sortByIndex2(es) {
  return es.sort(compare2).map((t) => t[1]);
}
var getFinalTransformation2 = (transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return right2;
    case "TypeLiteralTransformation":
      return (input) => {
        let out = right2(input);
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation2 = isDecoding ? pst.decode : pst.encode;
          const f = (input2) => {
            const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some2(input2[from]) : none2());
            delete input2[from];
            if (isSome2(o)) {
              input2[to] = o.value;
            }
            return input2;
          };
          out = map29(out, f);
        }
        return out;
      };
  }
};

// ../../node_modules/.pnpm/@effect+schema@0.75.5_effect@3.16.3/node_modules/@effect/schema/dist/esm/Equivalence.js
var EquivalenceHookId = /* @__PURE__ */ Symbol.for("@effect/schema/EquivalenceHookId");

// ../../node_modules/.pnpm/@effect+schema@0.75.5_effect@3.16.3/node_modules/@effect/schema/dist/esm/Pretty.js
var PrettyHookId = /* @__PURE__ */ Symbol.for("@effect/schema/PrettyHookId");

// ../../node_modules/.pnpm/@effect+schema@0.75.5_effect@3.16.3/node_modules/@effect/schema/dist/esm/Schema.js
var Schema_exports3 = {};
__export(Schema_exports3, {
  Any: () => Any2,
  Array: () => Array$2,
  ArrayEnsure: () => ArrayEnsure2,
  BetweenBigDecimalTypeId: () => BetweenBigDecimalTypeId,
  BetweenBigIntTypeId: () => BetweenBigIntTypeId,
  BetweenDateTypeId: () => BetweenDateTypeId,
  BetweenDurationTypeId: () => BetweenDurationTypeId,
  BetweenTypeId: () => BetweenTypeId2,
  BigDecimal: () => BigDecimal2,
  BigDecimalFromNumber: () => BigDecimalFromNumber2,
  BigDecimalFromSelf: () => BigDecimalFromSelf2,
  BigInt: () => BigInt$2,
  BigIntFromNumber: () => BigIntFromNumber2,
  BigIntFromSelf: () => BigIntFromSelf2,
  Boolean: () => Boolean$2,
  BooleanFromUnknown: () => BooleanFromUnknown2,
  BrandTypeId: () => BrandTypeId2,
  Capitalize: () => Capitalize2,
  Capitalized: () => Capitalized2,
  CapitalizedTypeId: () => CapitalizedTypeId,
  Cause: () => Cause2,
  CauseFromSelf: () => CauseFromSelf2,
  Char: () => Char2,
  Chunk: () => Chunk2,
  ChunkFromSelf: () => ChunkFromSelf2,
  Class: () => Class7,
  Config: () => Config2,
  Data: () => Data2,
  DataFromSelf: () => DataFromSelf2,
  Date: () => Date$2,
  DateFromNumber: () => DateFromNumber2,
  DateFromSelf: () => DateFromSelf2,
  DateFromString: () => DateFromString2,
  DateTimeUtc: () => DateTimeUtc2,
  DateTimeUtcFromNumber: () => DateTimeUtcFromNumber2,
  DateTimeUtcFromSelf: () => DateTimeUtcFromSelf2,
  DateTimeZoned: () => DateTimeZoned2,
  DateTimeZonedFromSelf: () => DateTimeZonedFromSelf2,
  Defect: () => Defect2,
  Duration: () => Duration2,
  DurationFromMillis: () => DurationFromMillis2,
  DurationFromNanos: () => DurationFromNanos2,
  DurationFromSelf: () => DurationFromSelf2,
  Either: () => Either3,
  EitherFromSelf: () => EitherFromSelf2,
  EitherFromUnion: () => EitherFromUnion2,
  EndsWithTypeId: () => EndsWithTypeId,
  Enums: () => Enums4,
  Exit: () => Exit2,
  ExitFromSelf: () => ExitFromSelf2,
  FiberId: () => FiberId2,
  FiberIdFromSelf: () => FiberIdFromSelf2,
  Finite: () => Finite2,
  FiniteTypeId: () => FiniteTypeId,
  FromPropertySignature: () => FromPropertySignature2,
  GreaterThanBigDecimalTypeId: () => GreaterThanBigDecimalTypeId,
  GreaterThanBigIntTypeId: () => GreaterThanBigIntTypeId,
  GreaterThanDateTypeId: () => GreaterThanDateTypeId,
  GreaterThanDurationTypeId: () => GreaterThanDurationTypeId,
  GreaterThanOrEqualToBigDecimalTypeId: () => GreaterThanOrEqualToBigDecimalTypeId,
  GreaterThanOrEqualToBigIntTypeId: () => GreaterThanOrEqualToBigIntTypeId2,
  GreaterThanOrEqualToDateTypeId: () => GreaterThanOrEqualToDateTypeId,
  GreaterThanOrEqualToDurationTypeId: () => GreaterThanOrEqualToDurationTypeId,
  GreaterThanOrEqualToTypeId: () => GreaterThanOrEqualToTypeId2,
  GreaterThanTypeId: () => GreaterThanTypeId2,
  HashMap: () => HashMap2,
  HashMapFromSelf: () => HashMapFromSelf2,
  HashSet: () => HashSet2,
  HashSetFromSelf: () => HashSetFromSelf2,
  IncludesTypeId: () => IncludesTypeId,
  InstanceOfTypeId: () => InstanceOfTypeId,
  Int: () => Int2,
  IntTypeId: () => IntTypeId2,
  ItemsCountTypeId: () => ItemsCountTypeId2,
  JsonNumber: () => JsonNumber2,
  JsonNumberTypeId: () => JsonNumberTypeId,
  LengthTypeId: () => LengthTypeId2,
  LessThanBigDecimalTypeId: () => LessThanBigDecimalTypeId,
  LessThanBigIntTypeId: () => LessThanBigIntTypeId2,
  LessThanDateTypeId: () => LessThanDateTypeId,
  LessThanDurationTypeId: () => LessThanDurationTypeId,
  LessThanOrEqualToBigDecimalTypeId: () => LessThanOrEqualToBigDecimalTypeId,
  LessThanOrEqualToBigIntTypeId: () => LessThanOrEqualToBigIntTypeId2,
  LessThanOrEqualToDateTypeId: () => LessThanOrEqualToDateTypeId,
  LessThanOrEqualToDurationTypeId: () => LessThanOrEqualToDurationTypeId,
  LessThanOrEqualToTypeId: () => LessThanOrEqualToTypeId2,
  LessThanTypeId: () => LessThanTypeId2,
  List: () => List2,
  ListFromSelf: () => ListFromSelf2,
  Literal: () => Literal4,
  Lowercase: () => Lowercase2,
  Lowercased: () => Lowercased2,
  LowercasedTypeId: () => LowercasedTypeId,
  Map: () => map30,
  MapFromRecord: () => MapFromRecord2,
  MapFromSelf: () => MapFromSelf2,
  MaxItemsTypeId: () => MaxItemsTypeId2,
  MaxLengthTypeId: () => MaxLengthTypeId2,
  MinItemsTypeId: () => MinItemsTypeId2,
  MinLengthTypeId: () => MinLengthTypeId2,
  MultipleOfTypeId: () => MultipleOfTypeId,
  Negative: () => Negative2,
  NegativeBigDecimalFromSelf: () => NegativeBigDecimalFromSelf2,
  NegativeBigDecimalTypeId: () => NegativeBigDecimalTypeId,
  NegativeBigInt: () => NegativeBigInt2,
  NegativeBigIntFromSelf: () => NegativeBigIntFromSelf2,
  Never: () => Never2,
  NonEmptyArray: () => NonEmptyArray2,
  NonEmptyArrayEnsure: () => NonEmptyArrayEnsure2,
  NonEmptyChunk: () => NonEmptyChunk2,
  NonEmptyChunkFromSelf: () => NonEmptyChunkFromSelf2,
  NonEmptyString: () => NonEmptyString2,
  NonEmptyTrimmedString: () => NonEmptyTrimmedString2,
  NonNaN: () => NonNaN2,
  NonNaNTypeId: () => NonNaNTypeId,
  NonNegative: () => NonNegative2,
  NonNegativeBigDecimalFromSelf: () => NonNegativeBigDecimalFromSelf2,
  NonNegativeBigDecimalTypeId: () => NonNegativeBigDecimalTypeId,
  NonNegativeBigInt: () => NonNegativeBigInt2,
  NonNegativeBigIntFromSelf: () => NonNegativeBigIntFromSelf2,
  NonPositive: () => NonPositive2,
  NonPositiveBigDecimalFromSelf: () => NonPositiveBigDecimalFromSelf2,
  NonPositiveBigDecimalTypeId: () => NonPositiveBigDecimalTypeId,
  NonPositiveBigInt: () => NonPositiveBigInt2,
  NonPositiveBigIntFromSelf: () => NonPositiveBigIntFromSelf2,
  Not: () => Not2,
  Null: () => Null2,
  NullOr: () => NullOr2,
  NullishOr: () => NullishOr2,
  Number: () => Number$2,
  NumberFromString: () => NumberFromString2,
  Object: () => Object$2,
  Option: () => Option2,
  OptionFromNonEmptyTrimmedString: () => OptionFromNonEmptyTrimmedString2,
  OptionFromNullOr: () => OptionFromNullOr2,
  OptionFromNullishOr: () => OptionFromNullishOr2,
  OptionFromSelf: () => OptionFromSelf2,
  OptionFromUndefinedOr: () => OptionFromUndefinedOr2,
  PatternTypeId: () => PatternTypeId,
  Positive: () => Positive2,
  PositiveBigDecimalFromSelf: () => PositiveBigDecimalFromSelf2,
  PositiveBigDecimalTypeId: () => PositiveBigDecimalTypeId,
  PositiveBigInt: () => PositiveBigInt2,
  PositiveBigIntFromSelf: () => PositiveBigIntFromSelf2,
  PropertySignatureDeclaration: () => PropertySignatureDeclaration2,
  PropertySignatureTransformation: () => PropertySignatureTransformation4,
  PropertySignatureTypeId: () => PropertySignatureTypeId2,
  ReadonlyMap: () => ReadonlyMap2,
  ReadonlyMapFromRecord: () => ReadonlyMapFromRecord2,
  ReadonlyMapFromSelf: () => ReadonlyMapFromSelf2,
  ReadonlySet: () => ReadonlySet2,
  ReadonlySetFromSelf: () => ReadonlySetFromSelf2,
  Record: () => Record2,
  Redacted: () => Redacted2,
  RedactedFromSelf: () => RedactedFromSelf2,
  Set: () => set9,
  SetFromSelf: () => SetFromSelf2,
  SortedSet: () => SortedSet2,
  SortedSetFromSelf: () => SortedSetFromSelf2,
  StartsWithTypeId: () => StartsWithTypeId,
  String: () => String$2,
  StringFromBase64: () => StringFromBase642,
  StringFromBase64Url: () => StringFromBase64Url2,
  StringFromHex: () => StringFromHex2,
  Struct: () => Struct2,
  Symbol: () => Symbol$2,
  SymbolFromSelf: () => SymbolFromSelf2,
  TaggedClass: () => TaggedClass4,
  TaggedError: () => TaggedError3,
  TaggedRequest: () => TaggedRequest2,
  TaggedStruct: () => TaggedStruct2,
  TemplateLiteral: () => TemplateLiteral4,
  TemplateLiteralParser: () => TemplateLiteralParser2,
  TimeZone: () => TimeZone2,
  TimeZoneFromSelf: () => TimeZoneFromSelf2,
  TimeZoneNamed: () => TimeZoneNamed2,
  TimeZoneNamedFromSelf: () => TimeZoneNamedFromSelf2,
  TimeZoneOffset: () => TimeZoneOffset2,
  TimeZoneOffsetFromSelf: () => TimeZoneOffsetFromSelf2,
  ToPropertySignature: () => ToPropertySignature2,
  Trim: () => Trim2,
  Trimmed: () => Trimmed2,
  TrimmedTypeId: () => TrimmedTypeId,
  Tuple: () => Tuple2,
  TypeId: () => TypeId25,
  ULID: () => ULID2,
  ULIDTypeId: () => ULIDTypeId,
  UUID: () => UUID2,
  UUIDTypeId: () => UUIDTypeId,
  Uint8Array: () => Uint8Array$2,
  Uint8ArrayFromBase64: () => Uint8ArrayFromBase642,
  Uint8ArrayFromBase64Url: () => Uint8ArrayFromBase64Url2,
  Uint8ArrayFromHex: () => Uint8ArrayFromHex2,
  Uint8ArrayFromSelf: () => Uint8ArrayFromSelf2,
  Uncapitalize: () => Uncapitalize2,
  Uncapitalized: () => Uncapitalized2,
  UncapitalizedTypeId: () => UncapitalizedTypeId,
  Undefined: () => Undefined2,
  UndefinedOr: () => UndefinedOr2,
  Union: () => Union4,
  UniqueSymbolFromSelf: () => UniqueSymbolFromSelf2,
  Unknown: () => Unknown2,
  Uppercase: () => Uppercase2,
  Uppercased: () => Uppercased2,
  UppercasedTypeId: () => UppercasedTypeId,
  ValidDateFromSelf: () => ValidDateFromSelf2,
  ValidDateTypeId: () => ValidDateTypeId,
  Void: () => Void2,
  annotations: () => annotations4,
  asSchema: () => asSchema2,
  asserts: () => asserts2,
  attachPropertySignature: () => attachPropertySignature2,
  between: () => between6,
  betweenBigDecimal: () => betweenBigDecimal2,
  betweenBigInt: () => betweenBigInt2,
  betweenDate: () => betweenDate2,
  betweenDuration: () => betweenDuration2,
  brand: () => brand2,
  capitalized: () => capitalized2,
  clamp: () => clamp9,
  clampBigDecimal: () => clampBigDecimal2,
  clampBigInt: () => clampBigInt2,
  clampDuration: () => clampDuration2,
  compose: () => compose6,
  declare: () => declare2,
  decode: () => decode6,
  decodeEither: () => decodeEither2,
  decodeOption: () => decodeOption2,
  decodePromise: () => decodePromise2,
  decodeSync: () => decodeSync2,
  decodeUnknown: () => decodeUnknown5,
  decodeUnknownEither: () => decodeUnknownEither4,
  decodeUnknownOption: () => decodeUnknownOption2,
  decodeUnknownPromise: () => decodeUnknownPromise2,
  decodeUnknownSync: () => decodeUnknownSync2,
  element: () => element2,
  encode: () => encode5,
  encodeEither: () => encodeEither2,
  encodeOption: () => encodeOption2,
  encodePromise: () => encodePromise2,
  encodeSync: () => encodeSync2,
  encodeUnknown: () => encodeUnknown4,
  encodeUnknownEither: () => encodeUnknownEither4,
  encodeUnknownOption: () => encodeUnknownOption2,
  encodeUnknownPromise: () => encodeUnknownPromise2,
  encodeUnknownSync: () => encodeUnknownSync2,
  encodedBoundSchema: () => encodedBoundSchema2,
  encodedSchema: () => encodedSchema2,
  endsWith: () => endsWith2,
  extend: () => extend4,
  filter: () => filter13,
  filterEffect: () => filterEffect4,
  finite: () => finite2,
  format: () => format7,
  fromBrand: () => fromBrand2,
  fromKey: () => fromKey2,
  getClassTag: () => getClassTag2,
  getNumberIndexedAccess: () => getNumberIndexedAccess4,
  greaterThan: () => greaterThan7,
  greaterThanBigDecimal: () => greaterThanBigDecimal2,
  greaterThanBigInt: () => greaterThanBigInt2,
  greaterThanDate: () => greaterThanDate2,
  greaterThanDuration: () => greaterThanDuration2,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo6,
  greaterThanOrEqualToBigDecimal: () => greaterThanOrEqualToBigDecimal2,
  greaterThanOrEqualToBigInt: () => greaterThanOrEqualToBigInt2,
  greaterThanOrEqualToDate: () => greaterThanOrEqualToDate2,
  greaterThanOrEqualToDuration: () => greaterThanOrEqualToDuration2,
  head: () => head7,
  headOrElse: () => headOrElse2,
  includes: () => includes2,
  instanceOf: () => instanceOf2,
  int: () => int2,
  is: () => is3,
  isPropertySignature: () => isPropertySignature2,
  isSchema: () => isSchema2,
  itemsCount: () => itemsCount2,
  keyof: () => keyof4,
  length: () => length4,
  lessThan: () => lessThan10,
  lessThanBigDecimal: () => lessThanBigDecimal2,
  lessThanBigInt: () => lessThanBigInt2,
  lessThanDate: () => lessThanDate2,
  lessThanDuration: () => lessThanDuration2,
  lessThanOrEqualTo: () => lessThanOrEqualTo6,
  lessThanOrEqualToBigDecimal: () => lessThanOrEqualToBigDecimal2,
  lessThanOrEqualToBigInt: () => lessThanOrEqualToBigInt2,
  lessThanOrEqualToDate: () => lessThanOrEqualToDate2,
  lessThanOrEqualToDuration: () => lessThanOrEqualToDuration2,
  lowercased: () => lowercased2,
  make: () => make67,
  makePropertySignature: () => makePropertySignature2,
  maxItems: () => maxItems2,
  maxLength: () => maxLength2,
  minItems: () => minItems2,
  minLength: () => minLength2,
  multipleOf: () => multipleOf2,
  mutable: () => mutable4,
  negative: () => negative2,
  negativeBigDecimal: () => negativeBigDecimal2,
  negativeBigInt: () => negativeBigInt2,
  nonEmptyString: () => nonEmptyString3,
  nonNaN: () => nonNaN2,
  nonNegative: () => nonNegative2,
  nonNegativeBigDecimal: () => nonNegativeBigDecimal2,
  nonNegativeBigInt: () => nonNegativeBigInt2,
  nonPositive: () => nonPositive2,
  nonPositiveBigDecimal: () => nonPositiveBigDecimal2,
  nonPositiveBigInt: () => nonPositiveBigInt2,
  omit: () => omit7,
  optional: () => optional2,
  optionalElement: () => optionalElement2,
  optionalToOptional: () => optionalToOptional2,
  optionalToRequired: () => optionalToRequired2,
  optionalWith: () => optionalWith2,
  parseJson: () => parseJson2,
  parseNumber: () => parseNumber2,
  partial: () => partial4,
  partialWith: () => partialWith2,
  pattern: () => pattern2,
  pick: () => pick7,
  pickLiteral: () => pickLiteral2,
  pluck: () => pluck2,
  positive: () => positive2,
  positiveBigDecimal: () => positiveBigDecimal2,
  positiveBigInt: () => positiveBigInt2,
  propertySignature: () => propertySignature2,
  refineTypeId: () => refineTypeId,
  rename: () => rename4,
  required: () => required4,
  requiredToOptional: () => requiredToOptional2,
  split: () => split7,
  startsWith: () => startsWith2,
  suspend: () => suspend14,
  tag: () => tag2,
  transform: () => transform3,
  transformLiteral: () => transformLiteral2,
  transformLiterals: () => transformLiterals2,
  transformOrFail: () => transformOrFail2,
  trimmed: () => trimmed2,
  typeSchema: () => typeSchema2,
  uncapitalized: () => uncapitalized2,
  uppercased: () => uppercased2,
  validDate: () => validDate2,
  validate: () => validate7,
  validateEither: () => validateEither4,
  validateOption: () => validateOption2,
  validatePromise: () => validatePromise2,
  validateSync: () => validateSync2,
  withConstructorDefault: () => withConstructorDefault2,
  withDecodingDefault: () => withDecodingDefault2,
  withDefaults: () => withDefaults2
});

// ../../node_modules/.pnpm/@effect+schema@0.75.5_effect@3.16.3/node_modules/@effect/schema/dist/esm/internal/serializable.js
var symbol3 = /* @__PURE__ */ Symbol.for("@effect/schema/Serializable/symbol");
var symbolResult = /* @__PURE__ */ Symbol.for("@effect/schema/Serializable/symbolResult");

// ../../node_modules/.pnpm/@effect+schema@0.75.5_effect@3.16.3/node_modules/@effect/schema/dist/esm/Schema.js
var TypeId25 = /* @__PURE__ */ Symbol.for("@effect/schema/Schema");
var make67 = (ast) => {
  var _a102, _b51, _c6;
  return _b51 = TypeId25, _a102 = TypeId25, _c6 = class {
    constructor() {
      __publicField(this, _b51, variance8);
    }
    static annotations(annotations5) {
      return make67(mergeSchemaAnnotations2(this.ast, annotations5));
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static toString() {
      return String(ast);
    }
  }, __publicField(_c6, "Type"), __publicField(_c6, "Encoded"), __publicField(_c6, "Context"), __publicField(_c6, _a102, variance8), __publicField(_c6, "ast", ast), _c6;
};
var variance8 = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _I: (_) => _,
  /* c8 ignore next */
  _R: (_) => _
};
var toASTAnnotations2 = (annotations5) => {
  if (!annotations5) {
    return {};
  }
  const out = {};
  const custom3 = Object.getOwnPropertySymbols(annotations5);
  for (const sym of custom3) {
    out[sym] = annotations5[sym];
  }
  if (annotations5.typeId !== void 0) {
    const typeId = annotations5.typeId;
    if (typeof typeId === "object") {
      out[TypeAnnotationId] = typeId.id;
      out[typeId.id] = typeId.annotation;
    } else {
      out[TypeAnnotationId] = typeId;
    }
  }
  const move = (from, to) => {
    if (annotations5[from] !== void 0) {
      out[to] = annotations5[from];
    }
  };
  move("message", MessageAnnotationId2);
  move("missingMessage", MissingMessageAnnotationId2);
  move("identifier", IdentifierAnnotationId2);
  move("title", TitleAnnotationId2);
  move("description", DescriptionAnnotationId2);
  move("examples", ExamplesAnnotationId2);
  move("default", DefaultAnnotationId2);
  move("documentation", DocumentationAnnotationId2);
  move("jsonSchema", JSONSchemaAnnotationId2);
  move("arbitrary", ArbitraryHookId);
  move("pretty", PrettyHookId);
  move("equivalence", EquivalenceHookId);
  move("concurrency", ConcurrencyAnnotationId2);
  move("batching", BatchingAnnotationId2);
  move("parseIssueTitle", ParseIssueTitleAnnotationId2);
  move("parseOptions", ParseOptionsAnnotationId2);
  move("decodingFallback", DecodingFallbackAnnotationId2);
  return out;
};
var mergeSchemaAnnotations2 = (ast, annotations5) => annotations3(ast, toASTAnnotations2(annotations5));
var asSchema2 = (schema) => schema;
var format7 = (schema) => String(schema.ast);
var encodedSchema2 = (schema) => make67(encodedAST2(schema.ast));
var encodedBoundSchema2 = (schema) => make67(encodedBoundAST2(schema.ast));
var typeSchema2 = (schema) => make67(typeAST2(schema.ast));
var encodeUnknown4 = (schema, options) => {
  const encodeUnknown5 = encodeUnknown3(schema, options);
  return (u, overrideOptions) => mapError10(encodeUnknown5(u, overrideOptions), parseError2);
};
var encodeUnknownEither4 = (schema, options) => {
  const encodeUnknownEither5 = encodeUnknownEither3(schema, options);
  return (u, overrideOptions) => mapLeft(encodeUnknownEither5(u, overrideOptions), parseError2);
};
var encodeUnknownPromise2 = (schema, options) => {
  const parser = encodeUnknown4(schema, options);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
};
var encode5 = encodeUnknown4;
var encodeEither2 = encodeUnknownEither4;
var encodePromise2 = encodeUnknownPromise2;
var decodeUnknown5 = (schema, options) => {
  const decodeUnknown6 = decodeUnknown4(schema, options);
  return (u, overrideOptions) => mapError10(decodeUnknown6(u, overrideOptions), parseError2);
};
var decodeUnknownEither4 = (schema, options) => {
  const decodeUnknownEither5 = decodeUnknownEither3(schema, options);
  return (u, overrideOptions) => mapLeft(decodeUnknownEither5(u, overrideOptions), parseError2);
};
var decodeUnknownPromise2 = (schema, options) => {
  const parser = decodeUnknown5(schema, options);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
};
var decode6 = decodeUnknown5;
var decodeEither2 = decodeUnknownEither4;
var decodePromise2 = decodeUnknownPromise2;
var validate7 = (schema, options) => {
  const validate8 = validate6(schema, options);
  return (u, overrideOptions) => mapError10(validate8(u, overrideOptions), parseError2);
};
var validateEither4 = (schema, options) => {
  const validateEither5 = validateEither3(schema, options);
  return (u, overrideOptions) => mapLeft(validateEither5(u, overrideOptions), parseError2);
};
var validatePromise2 = (schema, options) => {
  const parser = validate7(schema, options);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
};
var isSchema2 = (u) => hasProperty(u, TypeId25) && isObject(u[TypeId25]);
var getDefaultLiteralAST2 = (literals) => isMembers2(literals) ? Union3.make(mapMembers2(literals, (literal2) => new Literal3(literal2))) : new Literal3(literals[0]);
var makeLiteralClass2 = (literals, ast = getDefaultLiteralAST2(literals)) => {
  var _a102;
  return _a102 = class extends make67(ast) {
    static annotations(annotations5) {
      return makeLiteralClass2(this.literals, mergeSchemaAnnotations2(this.ast, annotations5));
    }
  }, __publicField(_a102, "literals", [...literals]), _a102;
};
function Literal4(...literals) {
  return isNonEmptyReadonlyArray(literals) ? makeLiteralClass2(literals) : Never2;
}
var pickLiteral2 = (...literals) => (_schema) => Literal4(...literals);
var UniqueSymbolFromSelf2 = (symbol4) => make67(new UniqueSymbol2(symbol4));
var getDefaultEnumsAST2 = (enums) => new Enums3(Object.keys(enums).filter((key) => typeof enums[enums[key]] !== "number").map((key) => [key, enums[key]]));
var makeEnumsClass2 = (enums, ast = getDefaultEnumsAST2(enums)) => {
  var _a102;
  return _a102 = class extends make67(ast) {
    static annotations(annotations5) {
      return makeEnumsClass2(this.enums, mergeSchemaAnnotations2(this.ast, annotations5));
    }
  }, __publicField(_a102, "enums", {
    ...enums
  }), _a102;
};
var Enums4 = (enums) => makeEnumsClass2(enums);
var TemplateLiteral4 = (...[head8, ...tail2]) => {
  let astOrs = getTemplateLiterals(getTemplateLiteralParameterAST(head8));
  for (const span4 of tail2) {
    astOrs = flatMap2(astOrs, (a) => getTemplateLiterals(getTemplateLiteralParameterAST(span4)).map((b) => combineTemplateLiterals(a, b)));
  }
  return make67(Union3.make(astOrs.map((astOr) => isString(astOr) ? new Literal3(astOr) : astOr)));
};
var getTemplateLiteralParameterAST = (span4) => isSchema2(span4) ? span4.ast : new Literal3(String(span4));
var combineTemplateLiterals = (a, b) => {
  if (isString(a)) {
    return isString(b) ? a + b : new TemplateLiteral3(a + b.head, b.spans);
  }
  if (isString(b)) {
    return new TemplateLiteral3(a.head, modifyNonEmptyLast(a.spans, (span4) => new TemplateLiteralSpan2(span4.type, span4.literal + b)));
  }
  return new TemplateLiteral3(a.head, appendAll(modifyNonEmptyLast(a.spans, (span4) => new TemplateLiteralSpan2(span4.type, span4.literal + String(b.head))), b.spans));
};
var getTemplateLiterals = (ast) => {
  switch (ast._tag) {
    case "Literal":
      return [String(ast.literal)];
    case "NumberKeyword":
    case "StringKeyword":
      return [new TemplateLiteral3("", [new TemplateLiteralSpan2(ast, "")])];
    case "Union":
      return flatMap2(ast.types, getTemplateLiterals);
  }
  throw new Error(getSchemaUnsupportedLiteralSpanErrorMessage2(ast));
};
var TemplateLiteralParser2 = (...params) => {
  var _a102;
  const encodedSchemas = [];
  const typeSchemas = [];
  const numbers = [];
  for (let i = 0; i < params.length; i++) {
    const p = params[i];
    if (isSchema2(p)) {
      const encoded = encodedSchema2(p);
      if (isNumberKeyword2(encoded.ast)) {
        numbers.push(i);
      }
      encodedSchemas.push(encoded);
      typeSchemas.push(p);
    } else {
      const literal2 = Literal4(p);
      encodedSchemas.push(literal2);
      typeSchemas.push(literal2);
    }
  }
  const from = TemplateLiteral4(...encodedSchemas);
  const re = getTemplateLiteralCapturingRegExp2(from.ast);
  return _a102 = class extends transform3(from, Tuple2(...typeSchemas), {
    strict: false,
    decode: (s) => {
      const out = re.exec(s).slice(1, params.length + 1);
      for (let i = 0; i < numbers.length; i++) {
        const index = numbers[i];
        out[index] = Number(out[index]);
      }
      return out;
    },
    encode: (tuple4) => tuple4.join("")
  }) {
  }, __publicField(_a102, "params", params.slice()), _a102;
};
var declareConstructor2 = (typeParameters, options, annotations5) => make67(new Declaration2(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options.decode(...typeParameters2.map(make67)), (...typeParameters2) => options.encode(...typeParameters2.map(make67)), toASTAnnotations2(annotations5)));
var declarePrimitive2 = (is4, annotations5) => {
  const decodeUnknown6 = () => (input, _, ast) => is4(input) ? succeed21(input) : fail20(new Type4(ast, input));
  const encodeUnknown5 = decodeUnknown6;
  return make67(new Declaration2([], decodeUnknown6, encodeUnknown5, toASTAnnotations2(annotations5)));
};
var declare2 = function() {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options = arguments[1];
    const annotations6 = arguments[2];
    return declareConstructor2(typeParameters, options, annotations6);
  }
  const is4 = arguments[0];
  const annotations5 = arguments[1];
  return declarePrimitive2(is4, annotations5);
};
var BrandTypeId2 = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Brand");
var fromBrand2 = (constructor, annotations5) => (self) => makeBrandClass2(new Refinement3(self.ast, function predicate(a, _, ast) {
  const either8 = constructor.either(a);
  return isLeft2(either8) ? some2(new Type4(ast, a, either8.left.map((v) => v.message).join(", "))) : none2();
}, toASTAnnotations2({
  typeId: {
    id: BrandTypeId2,
    annotation: {
      constructor
    }
  },
  ...annotations5
})));
var InstanceOfTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/InstanceOf");
var instanceOf2 = (constructor, annotations5) => declare2((u) => u instanceof constructor, {
  title: constructor.name,
  description: `an instance of ${constructor.name}`,
  pretty: () => String,
  typeId: {
    id: InstanceOfTypeId,
    annotation: {
      constructor
    }
  },
  ...annotations5
});
var Undefined2 = class extends (/* @__PURE__ */ make67(undefinedKeyword2)) {
};
var Void2 = class extends (/* @__PURE__ */ make67(voidKeyword2)) {
};
var Null2 = class extends (/* @__PURE__ */ make67($null2)) {
};
var Never2 = class extends (/* @__PURE__ */ make67(neverKeyword2)) {
};
var Unknown2 = class extends (/* @__PURE__ */ make67(unknownKeyword2)) {
};
var Any2 = class extends (/* @__PURE__ */ make67(anyKeyword2)) {
};
var BigIntFromSelf2 = class extends (/* @__PURE__ */ make67(bigIntKeyword2)) {
};
var SymbolFromSelf2 = class extends (/* @__PURE__ */ make67(symbolKeyword2)) {
};
var String$2 = class extends (/* @__PURE__ */ make67(stringKeyword2)) {
};
var Number$2 = class extends (/* @__PURE__ */ make67(numberKeyword2)) {
};
var Boolean$2 = class extends (/* @__PURE__ */ make67(booleanKeyword2)) {
};
var Object$2 = class extends (/* @__PURE__ */ make67(objectKeyword2)) {
};
var getDefaultUnionAST2 = (members) => Union3.make(members.map((m) => m.ast));
var makeUnionClass2 = (members, ast = getDefaultUnionAST2(members)) => {
  var _a102;
  return _a102 = class extends make67(ast) {
    static annotations(annotations5) {
      return makeUnionClass2(this.members, mergeSchemaAnnotations2(this.ast, annotations5));
    }
  }, __publicField(_a102, "members", [...members]), _a102;
};
function Union4(...members) {
  return isMembers2(members) ? makeUnionClass2(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never2;
}
var NullOr2 = (self) => Union4(self, Null2);
var UndefinedOr2 = (self) => Union4(self, Undefined2);
var NullishOr2 = (self) => Union4(self, Null2, Undefined2);
var keyof4 = (self) => make67(keyof3(self.ast));
var element2 = (self) => new ElementImpl2(new OptionalType2(self.ast, false), self);
var optionalElement2 = (self) => new ElementImpl2(new OptionalType2(self.ast, true), self);
var _a100;
_a100 = TypeId25;
var _ElementImpl2 = class _ElementImpl2 {
  constructor(ast, from) {
    __publicField(this, "ast");
    __publicField(this, "from");
    __publicField(this, _a100);
    __publicField(this, "_Token");
    this.ast = ast;
    this.from = from;
  }
  annotations(annotations5) {
    return new _ElementImpl2(new OptionalType2(this.ast.type, this.ast.isOptional, {
      ...this.ast.annotations,
      ...toASTAnnotations2(annotations5)
    }), this.from);
  }
  toString() {
    return `${this.ast.type}${this.ast.isOptional ? "?" : ""}`;
  }
};
var ElementImpl2 = _ElementImpl2;
var getDefaultTupleTypeAST2 = (elements, rest) => new TupleType2(elements.map((el) => isSchema2(el) ? new OptionalType2(el.ast, false) : el.ast), rest.map((el) => isSchema2(el) ? new Type3(el.ast) : el.ast), true);
var makeTupleTypeClass2 = (elements, rest, ast = getDefaultTupleTypeAST2(elements, rest)) => {
  var _a102;
  return _a102 = class extends make67(ast) {
    static annotations(annotations5) {
      return makeTupleTypeClass2(this.elements, this.rest, mergeSchemaAnnotations2(this.ast, annotations5));
    }
  }, __publicField(_a102, "elements", [...elements]), __publicField(_a102, "rest", [...rest]), _a102;
};
function Tuple2(...args2) {
  return Array.isArray(args2[0]) ? makeTupleTypeClass2(args2[0], args2.slice(1)) : makeTupleTypeClass2(args2, []);
}
var makeArrayClass2 = (value3, ast) => {
  var _a102;
  return _a102 = class extends makeTupleTypeClass2([], [value3], ast) {
    static annotations(annotations5) {
      return makeArrayClass2(this.value, mergeSchemaAnnotations2(this.ast, annotations5));
    }
  }, __publicField(_a102, "value", value3), _a102;
};
var Array$2 = (value3) => makeArrayClass2(value3);
var makeNonEmptyArrayClass2 = (value3, ast) => {
  var _a102;
  return _a102 = class extends makeTupleTypeClass2([value3], [value3], ast) {
    static annotations(annotations5) {
      return makeNonEmptyArrayClass2(this.value, mergeSchemaAnnotations2(this.ast, annotations5));
    }
  }, __publicField(_a102, "value", value3), _a102;
};
var NonEmptyArray2 = (value3) => makeNonEmptyArrayClass2(value3);
var ArrayEnsure2 = (value3) => {
  const value_ = asSchema2(value3);
  return class ArrayEnsureClass extends transform3(Union4(value_, Array$2(value_)), Array$2(typeSchema2(value_)), {
    strict: true,
    decode: ensure,
    encode: (arr) => arr.length === 1 ? arr[0] : arr
  }) {
  };
};
var NonEmptyArrayEnsure2 = (value3) => {
  const value_ = asSchema2(value3);
  return class NonEmptyArrayEnsureClass extends transform3(Union4(value_, NonEmptyArray2(value_)), NonEmptyArray2(typeSchema2(value_)), {
    strict: true,
    decode: ensure,
    encode: (arr) => arr.length === 1 ? arr[0] : arr
  }) {
  };
};
var formatPropertySignatureToken2 = (isOptional) => isOptional ? '"?:"' : '":"';
var PropertySignatureDeclaration2 = class extends OptionalType2 {
  constructor(type, isOptional, isReadonly, annotations5, defaultValue) {
    super(type, isOptional, annotations5);
    __publicField(this, "isReadonly");
    __publicField(this, "defaultValue");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "PropertySignatureDeclaration");
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    const token = formatPropertySignatureToken2(this.isOptional);
    const type = String(this.type);
    return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`;
  }
};
var FromPropertySignature2 = class extends OptionalType2 {
  constructor(type, isOptional, isReadonly, annotations5, fromKey3) {
    super(type, isOptional, annotations5);
    __publicField(this, "isReadonly");
    __publicField(this, "fromKey");
    this.isReadonly = isReadonly;
    this.fromKey = fromKey3;
  }
};
var ToPropertySignature2 = class extends OptionalType2 {
  constructor(type, isOptional, isReadonly, annotations5, defaultValue) {
    super(type, isOptional, annotations5);
    __publicField(this, "isReadonly");
    __publicField(this, "defaultValue");
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
};
var formatPropertyKey4 = (p) => {
  if (p === void 0) {
    return "never";
  }
  if (isString(p)) {
    return JSON.stringify(p);
  }
  return String(p);
};
var PropertySignatureTransformation4 = class {
  constructor(from, to, decode7, encode6) {
    __publicField(this, "from");
    __publicField(this, "to");
    __publicField(this, "decode");
    __publicField(this, "encode");
    /**
     * @since 0.67.0
     */
    __publicField(this, "_tag", "PropertySignatureTransformation");
    this.from = from;
    this.to = to;
    this.decode = decode7;
    this.encode = encode6;
  }
  /**
   * @since 0.67.0
   */
  toString() {
    return `PropertySignature<${formatPropertySignatureToken2(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey4(this.from.fromKey)}, ${formatPropertySignatureToken2(this.from.isOptional)}, ${this.from.type}>`;
  }
};
var mergeSignatureAnnotations2 = (ast, annotations5) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return new PropertySignatureDeclaration2(ast.type, ast.isOptional, ast.isReadonly, {
        ...ast.annotations,
        ...annotations5
      }, ast.defaultValue);
    }
    case "PropertySignatureTransformation": {
      return new PropertySignatureTransformation4(new FromPropertySignature2(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations), new ToPropertySignature2(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
        ...ast.to.annotations,
        ...annotations5
      }, ast.to.defaultValue), ast.decode, ast.encode);
    }
  }
};
var PropertySignatureTypeId2 = /* @__PURE__ */ Symbol.for("@effect/schema/PropertySignature");
var isPropertySignature2 = (u) => hasProperty(u, PropertySignatureTypeId2);
var _a101, _b50;
_b50 = TypeId25, _a101 = PropertySignatureTypeId2;
var _PropertySignatureImpl2 = class _PropertySignatureImpl2 {
  constructor(ast) {
    __publicField(this, "ast");
    __publicField(this, _b50);
    __publicField(this, _a101, null);
    __publicField(this, "_TypeToken");
    __publicField(this, "_Key");
    __publicField(this, "_EncodedToken");
    __publicField(this, "_HasDefault");
    this.ast = ast;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  annotations(annotations5) {
    return new _PropertySignatureImpl2(mergeSignatureAnnotations2(this.ast, toASTAnnotations2(annotations5)));
  }
  toString() {
    return String(this.ast);
  }
};
var PropertySignatureImpl2 = _PropertySignatureImpl2;
var makePropertySignature2 = (ast) => new PropertySignatureImpl2(ast);
var PropertySignatureWithFromImpl2 = class _PropertySignatureWithFromImpl extends PropertySignatureImpl2 {
  constructor(ast, from) {
    super(ast);
    __publicField(this, "from");
    this.from = from;
  }
  annotations(annotations5) {
    return new _PropertySignatureWithFromImpl(mergeSignatureAnnotations2(this.ast, toASTAnnotations2(annotations5)), this.from);
  }
};
var propertySignature2 = (self) => new PropertySignatureWithFromImpl2(new PropertySignatureDeclaration2(self.ast, false, true, {}, void 0), self);
var withConstructorDefault2 = /* @__PURE__ */ dual(2, (self, defaultValue) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature2(new PropertySignatureDeclaration2(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
    case "PropertySignatureTransformation":
      return makePropertySignature2(new PropertySignatureTransformation4(ast.from, new ToPropertySignature2(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
  }
});
var applyDefaultValue2 = (o, defaultValue) => match2(o, {
  onNone: () => some2(defaultValue()),
  onSome: (value3) => some2(value3 === void 0 ? defaultValue() : value3)
});
var withDecodingDefault2 = /* @__PURE__ */ dual(2, (self, defaultValue) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature2(new PropertySignatureTransformation4(ast, new ToPropertySignature2(typeAST2(ast.type), false, true, {}, void 0), (o) => applyDefaultValue2(o, defaultValue), identity));
    case "PropertySignatureTransformation":
      return makePropertySignature2(new PropertySignatureTransformation4(ast.from, new ToPropertySignature2(ast.to.type, false, ast.to.isReadonly, ast.to.annotations, ast.to.defaultValue), (o) => applyDefaultValue2(ast.decode(o), defaultValue), ast.encode));
  }
});
var withDefaults2 = /* @__PURE__ */ dual(2, (self, defaults) => self.pipe(withDecodingDefault2(defaults.decoding), withConstructorDefault2(defaults.constructor)));
var fromKey2 = /* @__PURE__ */ dual(2, (self, key) => {
  const ast = self.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return makePropertySignature2(new PropertySignatureTransformation4(new FromPropertySignature2(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, key), new ToPropertySignature2(typeAST2(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue), identity, identity));
    }
    case "PropertySignatureTransformation":
      return makePropertySignature2(new PropertySignatureTransformation4(new FromPropertySignature2(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations, key), ast.to, ast.decode, ast.encode));
  }
});
var optionalToRequired2 = (from, to, options) => makePropertySignature2(new PropertySignatureTransformation4(new FromPropertySignature2(from.ast, true, true, {}, void 0), new ToPropertySignature2(to.ast, false, true, {}, void 0), (o) => some2(options.decode(o)), flatMap(options.encode)));
var requiredToOptional2 = (from, to, options) => makePropertySignature2(new PropertySignatureTransformation4(new FromPropertySignature2(from.ast, false, true, {}, void 0), new ToPropertySignature2(to.ast, true, true, {}, void 0), flatMap(options.decode), (o) => some2(options.encode(o))));
var optionalToOptional2 = (from, to, options) => makePropertySignature2(new PropertySignatureTransformation4(new FromPropertySignature2(from.ast, true, true, {}, void 0), new ToPropertySignature2(to.ast, true, true, {}, void 0), options.decode, options.encode));
var optionalPropertySignatureAST2 = (self, options) => {
  const isExact = options?.exact;
  const defaultValue = options?.default;
  const isNullable2 = options?.nullable;
  const asOption = options?.as == "Option";
  const asOptionEncode = options?.onNoneEncoding ? orElse(options.onNoneEncoding) : identity;
  if (isExact) {
    if (defaultValue) {
      if (isNullable2) {
        return withConstructorDefault2(optionalToRequired2(NullOr2(self), typeSchema2(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a === null ? defaultValue() : a
          }),
          encode: some2
        }), defaultValue).ast;
      } else {
        return withConstructorDefault2(optionalToRequired2(self, typeSchema2(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: identity
          }),
          encode: some2
        }), defaultValue).ast;
      }
    } else if (asOption) {
      if (isNullable2) {
        return optionalToRequired2(NullOr2(self), OptionFromSelf2(typeSchema2(self)), {
          decode: filter(isNotNull),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired2(self, OptionFromSelf2(typeSchema2(self)), {
          decode: identity,
          encode: identity
        }).ast;
      }
    } else {
      if (isNullable2) {
        return optionalToOptional2(NullOr2(self), typeSchema2(self), {
          decode: filter(isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration2(self.ast, true, true, {}, void 0);
      }
    }
  } else {
    if (defaultValue) {
      if (isNullable2) {
        return withConstructorDefault2(optionalToRequired2(NullishOr2(self), typeSchema2(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a == null ? defaultValue() : a
          }),
          encode: some2
        }), defaultValue).ast;
      } else {
        return withConstructorDefault2(optionalToRequired2(UndefinedOr2(self), typeSchema2(self), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a === void 0 ? defaultValue() : a
          }),
          encode: some2
        }), defaultValue).ast;
      }
    } else if (asOption) {
      if (isNullable2) {
        return optionalToRequired2(NullishOr2(self), OptionFromSelf2(typeSchema2(self)), {
          decode: filter((a) => a != null),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired2(UndefinedOr2(self), OptionFromSelf2(typeSchema2(self)), {
          decode: filter(isNotUndefined),
          encode: asOptionEncode
        }).ast;
      }
    } else {
      if (isNullable2) {
        return optionalToOptional2(NullishOr2(self), UndefinedOr2(typeSchema2(self)), {
          decode: filter(isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration2(UndefinedOr2(self).ast, true, true, {}, void 0);
      }
    }
  }
};
var optional2 = (self) => {
  const ast = self.ast === undefinedKeyword2 || self.ast === neverKeyword2 ? undefinedKeyword2 : UndefinedOr2(self).ast;
  return new PropertySignatureWithFromImpl2(new PropertySignatureDeclaration2(ast, true, true, {}, void 0), self);
};
var optionalWith2 = /* @__PURE__ */ dual((args2) => isSchema2(args2[0]), (self, options) => {
  return new PropertySignatureWithFromImpl2(optionalPropertySignatureAST2(self, options), self);
});
var getDefaultTypeLiteralAST2 = (fields, records) => {
  const ownKeys3 = ownKeys2(fields);
  const pss = [];
  if (ownKeys3.length > 0) {
    const from = [];
    const to = [];
    const transformations = [];
    for (let i = 0; i < ownKeys3.length; i++) {
      const key = ownKeys3[i];
      const field = fields[key];
      if (isPropertySignature2(field)) {
        const ast = field.ast;
        switch (ast._tag) {
          case "PropertySignatureDeclaration": {
            const type = ast.type;
            const isOptional = ast.isOptional;
            const toAnnotations = ast.annotations;
            from.push(new PropertySignature2(key, type, isOptional, true));
            to.push(new PropertySignature2(key, typeAST2(type), isOptional, true, toAnnotations));
            pss.push(new PropertySignature2(key, type, isOptional, true, toAnnotations));
            break;
          }
          case "PropertySignatureTransformation": {
            const fromKey3 = ast.from.fromKey ?? key;
            from.push(new PropertySignature2(fromKey3, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
            to.push(new PropertySignature2(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
            transformations.push(new PropertySignatureTransformation3(fromKey3, key, ast.decode, ast.encode));
            break;
          }
        }
      } else {
        from.push(new PropertySignature2(key, field.ast, false, true));
        to.push(new PropertySignature2(key, typeAST2(field.ast), false, true));
        pss.push(new PropertySignature2(key, field.ast, false, true));
      }
    }
    if (isNonEmptyReadonlyArray(transformations)) {
      const issFrom = [];
      const issTo = [];
      for (const r of records) {
        const {
          indexSignatures,
          propertySignatures
        } = record3(r.key.ast, r.value.ast);
        propertySignatures.forEach((ps) => {
          from.push(ps);
          to.push(new PropertySignature2(ps.name, typeAST2(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
        });
        indexSignatures.forEach((is4) => {
          issFrom.push(is4);
          issTo.push(new IndexSignature2(is4.parameter, typeAST2(is4.type), is4.isReadonly));
        });
      }
      return new Transformation3(new TypeLiteral2(from, issFrom, {
        [TitleAnnotationId2]: "Struct (Encoded side)"
      }), new TypeLiteral2(to, issTo, {
        [TitleAnnotationId2]: "Struct (Type side)"
      }), new TypeLiteralTransformation2(transformations));
    }
  }
  const iss = [];
  for (const r of records) {
    const {
      indexSignatures,
      propertySignatures
    } = record3(r.key.ast, r.value.ast);
    propertySignatures.forEach((ps) => pss.push(ps));
    indexSignatures.forEach((is4) => iss.push(is4));
  }
  return new TypeLiteral2(pss, iss);
};
var lazilyMergeDefaults2 = (fields, out) => {
  const ownKeys3 = ownKeys2(fields);
  for (const key of ownKeys3) {
    const field = fields[key];
    if (out[key] === void 0 && isPropertySignature2(field)) {
      const ast = field.ast;
      const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
      if (defaultValue !== void 0) {
        out[key] = defaultValue();
      }
    }
  }
  return out;
};
var makeTypeLiteralClass2 = (fields, records, ast = getDefaultTypeLiteralAST2(fields, records)) => {
  var _a102;
  return _a102 = class extends make67(ast) {
    static annotations(annotations5) {
      return makeTypeLiteralClass2(this.fields, this.records, mergeSchemaAnnotations2(this.ast, annotations5));
    }
    static pick(...keys6) {
      return Struct2(pick4(fields, ...keys6));
    }
    static omit(...keys6) {
      return Struct2(omit4(fields, ...keys6));
    }
  }, __publicField(_a102, "fields", {
    ...fields
  }), __publicField(_a102, "records", [...records]), __publicField(_a102, "make", (props, options) => {
    const propsWithDefaults = lazilyMergeDefaults2(fields, {
      ...props
    });
    return getDisableValidationMakeOption2(options) ? propsWithDefaults : validateSync2(_a102)(propsWithDefaults);
  }), _a102;
};
function Struct2(fields, ...records) {
  return makeTypeLiteralClass2(fields, records);
}
var tag2 = (tag3) => Literal4(tag3).pipe(propertySignature2, withConstructorDefault2(() => tag3));
var TaggedStruct2 = (value3, fields) => Struct2({
  _tag: tag2(value3),
  ...fields
});
var makeRecordClass2 = (key, value3, ast) => {
  var _a102;
  return _a102 = class extends makeTypeLiteralClass2({}, [{
    key,
    value: value3
  }], ast) {
    static annotations(annotations5) {
      return makeRecordClass2(key, value3, mergeSchemaAnnotations2(this.ast, annotations5));
    }
  }, __publicField(_a102, "key", key), __publicField(_a102, "value", value3), _a102;
};
var Record2 = (options) => makeRecordClass2(options.key, options.value);
var pick7 = (...keys6) => (self) => make67(pick6(self.ast, keys6));
var omit7 = (...keys6) => (self) => make67(omit6(self.ast, keys6));
var pluck2 = /* @__PURE__ */ dual(2, (schema, key) => {
  const ps = getPropertyKeyIndexedAccess2(typeAST2(schema.ast), key);
  const value3 = make67(ps.isOptional ? orUndefined2(ps.type) : ps.type);
  return transform3(schema.pipe(pick7(key)), value3, {
    strict: true,
    decode: (a) => a[key],
    encode: (ak) => ps.isOptional && ak === void 0 ? {} : {
      [key]: ak
    }
  });
});
var makeBrandClass2 = (ast) => {
  var _a102;
  return _a102 = class extends make67(ast) {
    static annotations(annotations5) {
      return makeBrandClass2(mergeSchemaAnnotations2(this.ast, annotations5));
    }
  }, __publicField(_a102, "make", (a, options) => {
    return getDisableValidationMakeOption2(options) ? a : validateSync2(_a102)(a);
  }), _a102;
};
var brand2 = (brand3, annotations5) => (self) => {
  const annotation = match2(getBrandAnnotation2(self.ast), {
    onNone: () => [brand3],
    onSome: (brands) => [...brands, brand3]
  });
  const ast = annotations3(self.ast, toASTAnnotations2({
    // add a default title annotation containing the brand
    title: String(self.ast) + ` & Brand<${formatUnknown2(brand3)}>`,
    ...annotations5,
    [BrandAnnotationId2]: annotation
  }));
  return makeBrandClass2(ast);
};
var partial4 = (self) => make67(partial3(self.ast));
var partialWith2 = /* @__PURE__ */ dual((args2) => isSchema2(args2[0]), (self, options) => make67(partial3(self.ast, options)));
var required4 = (self) => make67(required3(self.ast));
var mutable4 = (schema) => make67(mutable3(schema.ast));
var intersectTypeLiterals2 = (x, y, path) => {
  if (isTypeLiteral2(x) && isTypeLiteral2(y)) {
    const propertySignatures = [...x.propertySignatures];
    for (const ps of y.propertySignatures) {
      const name = ps.name;
      const i = propertySignatures.findIndex((ps2) => ps2.name === name);
      if (i === -1) {
        propertySignatures.push(ps);
      } else {
        const {
          isOptional,
          type
        } = propertySignatures[i];
        propertySignatures[i] = new PropertySignature2(name, extendAST2(type, ps.type, path.concat(name)), isOptional, true);
      }
    }
    return new TypeLiteral2(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
  }
  throw new Error(getSchemaExtendErrorMessage2(x, y, path));
};
var preserveRefinementAnnotations2 = /* @__PURE__ */ blackListAnnotations([IdentifierAnnotationId2]);
var addRefinementToMembers2 = (refinement, asts) => asts.map((ast) => new Refinement3(ast, refinement.filter, preserveRefinementAnnotations2(refinement)));
var extendAST2 = (x, y, path) => Union3.make(intersectUnionMembers2([x], [y], path));
var getTypes2 = (ast) => isUnion2(ast) ? ast.types : [ast];
var intersectUnionMembers2 = (xs, ys, path) => flatMap2(xs, (x) => flatMap2(ys, (y) => {
  switch (y._tag) {
    case "Literal": {
      if (isString(y.literal) && isStringKeyword2(x) || isNumber(y.literal) && isNumberKeyword2(x) || isBoolean(y.literal) && isBooleanKeyword2(x)) {
        return [y];
      }
      break;
    }
    case "StringKeyword": {
      if (y === stringKeyword2) {
        if (isStringKeyword2(x) || isLiteral2(x) && isString(x.literal)) {
          return [x];
        } else if (isRefinement3(x)) {
          return addRefinementToMembers2(x, intersectUnionMembers2(getTypes2(x.from), [y], path));
        }
      } else if (x === stringKeyword2) {
        return [y];
      }
      break;
    }
    case "NumberKeyword": {
      if (y === numberKeyword2) {
        if (isNumberKeyword2(x) || isLiteral2(x) && isNumber(x.literal)) {
          return [x];
        } else if (isRefinement3(x)) {
          return addRefinementToMembers2(x, intersectUnionMembers2(getTypes2(x.from), [y], path));
        }
      } else if (x === numberKeyword2) {
        return [y];
      }
      break;
    }
    case "BooleanKeyword": {
      if (y === booleanKeyword2) {
        if (isBooleanKeyword2(x) || isLiteral2(x) && isBoolean(x.literal)) {
          return [x];
        } else if (isRefinement3(x)) {
          return addRefinementToMembers2(x, intersectUnionMembers2(getTypes2(x.from), [y], path));
        }
      } else if (x === booleanKeyword2) {
        return [y];
      }
      break;
    }
    case "Union":
      return intersectUnionMembers2(getTypes2(x), y.types, path);
    case "Suspend":
      return [new Suspend2(() => extendAST2(x, y.f(), path))];
    case "Refinement":
      return addRefinementToMembers2(y, intersectUnionMembers2(getTypes2(x), getTypes2(y.from), path));
    case "TypeLiteral": {
      switch (x._tag) {
        case "Union":
          return intersectUnionMembers2(x.types, [y], path);
        case "Suspend":
          return [new Suspend2(() => extendAST2(x.f(), y, path))];
        case "Refinement":
          return addRefinementToMembers2(x, intersectUnionMembers2(getTypes2(x.from), [y], path));
        case "TypeLiteral":
          return [intersectTypeLiterals2(x, y, path)];
        case "Transformation": {
          if (isTypeLiteralTransformation2(x.transformation)) {
            return [new Transformation3(intersectTypeLiterals2(x.from, y, path), intersectTypeLiterals2(x.to, typeAST2(y), path), new TypeLiteralTransformation2(x.transformation.propertySignatureTransformations))];
          }
          break;
        }
      }
      break;
    }
    case "Transformation": {
      if (isTypeLiteralTransformation2(y.transformation)) {
        switch (x._tag) {
          case "Union":
            return intersectUnionMembers2(x.types, [y], path);
          case "Suspend":
            return [new Suspend2(() => extendAST2(x.f(), y, path))];
          case "Refinement":
            return addRefinementToMembers2(x, intersectUnionMembers2(getTypes2(x.from), [y], path));
          case "TypeLiteral":
            return [new Transformation3(intersectTypeLiterals2(x, y.from, path), intersectTypeLiterals2(typeAST2(x), y.to, path), new TypeLiteralTransformation2(y.transformation.propertySignatureTransformations))];
          case "Transformation":
            {
              if (isTypeLiteralTransformation2(x.transformation)) {
                return [new Transformation3(intersectTypeLiterals2(x.from, y.from, path), intersectTypeLiterals2(x.to, y.to, path), new TypeLiteralTransformation2(y.transformation.propertySignatureTransformations.concat(x.transformation.propertySignatureTransformations)))];
              }
            }
            break;
        }
      }
      break;
    }
  }
  throw new Error(getSchemaExtendErrorMessage2(x, y, path));
}));
var extend4 = /* @__PURE__ */ dual(2, (self, that) => make67(extendAST2(self.ast, that.ast, [])));
var compose6 = /* @__PURE__ */ dual((args2) => isSchema2(args2[1]), (from, to) => make67(compose5(from.ast, to.ast)));
var suspend14 = (f) => make67(new Suspend2(() => f().ast));
var refineTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/refine");
var makeRefineClass2 = (from, filter14, ast) => {
  var _a102, _b51, _c6;
  return _c6 = class extends (_b51 = make67(ast), _a102 = refineTypeId, _b51) {
    static annotations(annotations5) {
      return makeRefineClass2(this.from, this.filter, mergeSchemaAnnotations2(this.ast, annotations5));
    }
  }, __publicField(_c6, _a102, from), __publicField(_c6, "from", from), __publicField(_c6, "filter", filter14), __publicField(_c6, "make", (a, options) => {
    return getDisableValidationMakeOption2(options) ? a : validateSync2(_c6)(a);
  }), _c6;
};
var fromFilterPredicateReturnTypeItem2 = (item, ast, input) => {
  if (isBoolean(item)) {
    return item ? none2() : some2(new Type4(ast, input));
  }
  if (isString(item)) {
    return some2(new Type4(ast, input, item));
  }
  if (item !== void 0) {
    if ("_tag" in item) {
      return some2(item);
    }
    const issue = new Type4(ast, input, item.message);
    return some2(isNonEmptyReadonlyArray(item.path) ? new Pointer2(item.path, input, issue) : issue);
  }
  return none2();
};
var toFilterParseIssue2 = (out, ast, input) => {
  if (isSingle2(out)) {
    return fromFilterPredicateReturnTypeItem2(out, ast, input);
  }
  if (isNonEmptyReadonlyArray(out)) {
    const issues = filterMap3(out, (issue) => fromFilterPredicateReturnTypeItem2(issue, ast, input));
    if (isNonEmptyReadonlyArray(issues)) {
      return some2(issues.length === 1 ? issues[0] : new Composite3(ast, input, issues));
    }
  }
  return none2();
};
function filter13(predicate, annotations5) {
  return (self) => {
    function filter14(input, options, ast2) {
      return toFilterParseIssue2(predicate(input, options, ast2), ast2, input);
    }
    const ast = new Refinement3(self.ast, filter14, toASTAnnotations2(annotations5));
    return makeRefineClass2(self, filter14, ast);
  };
}
var filterEffect4 = /* @__PURE__ */ dual(2, (self, f) => transformOrFail2(self, typeSchema2(self), {
  strict: true,
  decode: (a, options, ast) => flatMap20(f(a, options, ast), (filterReturnType) => match2(toFilterParseIssue2(filterReturnType, ast, a), {
    onNone: () => succeed21(a),
    onSome: fail20
  })),
  encode: succeed21
}));
var makeTransformationClass2 = (from, to, ast) => {
  var _a102;
  return _a102 = class extends make67(ast) {
    static annotations(annotations5) {
      return makeTransformationClass2(this.from, this.to, mergeSchemaAnnotations2(this.ast, annotations5));
    }
  }, __publicField(_a102, "from", from), __publicField(_a102, "to", to), _a102;
};
var transformOrFail2 = /* @__PURE__ */ dual((args2) => isSchema2(args2[0]) && isSchema2(args2[1]), (from, to, options) => makeTransformationClass2(from, to, new Transformation3(from.ast, to.ast, new FinalTransformation2(options.decode, options.encode))));
var transform3 = /* @__PURE__ */ dual((args2) => isSchema2(args2[0]) && isSchema2(args2[1]), (from, to, options) => transformOrFail2(from, to, {
  strict: true,
  decode: (fromA, _options, _ast, toA) => succeed21(options.decode(fromA, toA)),
  encode: (toI, _options, _ast, toA) => succeed21(options.encode(toI, toA))
}));
var transformLiteral2 = (from, to) => transform3(Literal4(from), Literal4(to), {
  strict: true,
  decode: () => to,
  encode: () => from
});
function transformLiterals2(...pairs) {
  return Union4(...pairs.map(([from, to]) => transformLiteral2(from, to)));
}
var attachPropertySignature2 = /* @__PURE__ */ dual((args2) => isSchema2(args2[0]), (schema, key, value3, annotations5) => {
  const ast = extend4(typeSchema2(schema), Struct2({
    [key]: isSymbol(value3) ? UniqueSymbolFromSelf2(value3) : Literal4(value3)
  })).ast;
  return make67(new Transformation3(schema.ast, annotations5 ? mergeSchemaAnnotations2(ast, annotations5) : ast, new TypeLiteralTransformation2([new PropertySignatureTransformation3(key, key, () => some2(value3), () => none2())])));
});
var annotations4 = /* @__PURE__ */ dual(2, (self, annotations5) => self.annotations(annotations5));
var rename4 = /* @__PURE__ */ dual(2, (self, mapping) => make67(rename3(self.ast, mapping)));
var TrimmedTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Trimmed");
var trimmed2 = (annotations5) => (self) => self.pipe(filter13((a) => a === a.trim(), {
  typeId: TrimmedTypeId,
  description: "a string with no leading or trailing whitespace",
  jsonSchema: {
    pattern: "^\\S[\\s\\S]*\\S$|^\\S$|^$"
  },
  ...annotations5
}));
var MaxLengthTypeId2 = MaxLengthTypeId;
var maxLength2 = (maxLength3, annotations5) => (self) => self.pipe(filter13((a) => a.length <= maxLength3, {
  typeId: MaxLengthTypeId2,
  description: `a string at most ${maxLength3} character(s) long`,
  jsonSchema: {
    maxLength: maxLength3
  },
  ...annotations5
}));
var MinLengthTypeId2 = MinLengthTypeId;
var minLength2 = (minLength3, annotations5) => (self) => self.pipe(filter13((a) => a.length >= minLength3, {
  typeId: MinLengthTypeId2,
  description: `a string at least ${minLength3} character(s) long`,
  jsonSchema: {
    minLength: minLength3
  },
  ...annotations5
}));
var PatternTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Pattern");
var pattern2 = (regex, annotations5) => (self) => {
  const pattern3 = regex.source;
  return self.pipe(filter13((a) => {
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    typeId: {
      id: PatternTypeId,
      annotation: {
        regex
      }
    },
    description: `a string matching the pattern ${pattern3}`,
    jsonSchema: {
      pattern: pattern3
    },
    arbitrary: () => (fc) => fc.stringMatching(regex),
    ...annotations5
  }));
};
var StartsWithTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/StartsWith");
var startsWith2 = (startsWith3, annotations5) => (self) => self.pipe(filter13((a) => a.startsWith(startsWith3), {
  typeId: {
    id: StartsWithTypeId,
    annotation: {
      startsWith: startsWith3
    }
  },
  description: `a string starting with ${JSON.stringify(startsWith3)}`,
  jsonSchema: {
    pattern: `^${startsWith3}`
  },
  ...annotations5
}));
var EndsWithTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/EndsWith");
var endsWith2 = (endsWith3, annotations5) => (self) => self.pipe(filter13((a) => a.endsWith(endsWith3), {
  typeId: {
    id: EndsWithTypeId,
    annotation: {
      endsWith: endsWith3
    }
  },
  description: `a string ending with ${JSON.stringify(endsWith3)}`,
  jsonSchema: {
    pattern: `^.*${endsWith3}$`
  },
  ...annotations5
}));
var IncludesTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Includes");
var includes2 = (searchString, annotations5) => (self) => self.pipe(filter13((a) => a.includes(searchString), {
  typeId: {
    id: IncludesTypeId,
    annotation: {
      includes: searchString
    }
  },
  description: `a string including ${JSON.stringify(searchString)}`,
  jsonSchema: {
    pattern: `.*${searchString}.*`
  },
  ...annotations5
}));
var LowercasedTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Lowercased");
var lowercased2 = (annotations5) => (self) => self.pipe(filter13((a) => a === a.toLowerCase(), {
  typeId: LowercasedTypeId,
  description: "a lowercase string",
  ...annotations5
}));
var Lowercased2 = class extends (/* @__PURE__ */ String$2.pipe(/* @__PURE__ */ lowercased2({
  identifier: "Lowercased",
  title: "Lowercased"
}))) {
};
var CapitalizedTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Capitalized");
var capitalized2 = (annotations5) => (self) => self.pipe(filter13((a) => a[0]?.toUpperCase() === a[0], {
  typeId: CapitalizedTypeId,
  description: "a capitalized string",
  ...annotations5
}));
var Capitalized2 = class extends (/* @__PURE__ */ String$2.pipe(/* @__PURE__ */ capitalized2({
  identifier: "Capitalized",
  title: "Capitalized"
}))) {
};
var UncapitalizedTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Uncapitalized");
var uncapitalized2 = (annotations5) => (self) => self.pipe(filter13((a) => a[0]?.toLowerCase() === a[0], {
  typeId: UncapitalizedTypeId,
  description: "a uncapitalized string",
  ...annotations5
}));
var Uncapitalized2 = class extends (/* @__PURE__ */ String$2.pipe(/* @__PURE__ */ uncapitalized2({
  identifier: "Uncapitalized",
  title: "Uncapitalized"
}))) {
};
var UppercasedTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Uppercased");
var uppercased2 = (annotations5) => (self) => self.pipe(filter13((a) => a === a.toUpperCase(), {
  typeId: UppercasedTypeId,
  description: "an uppercase string",
  ...annotations5
}));
var Uppercased2 = class extends (/* @__PURE__ */ String$2.pipe(/* @__PURE__ */ uppercased2({
  identifier: "Uppercased",
  title: "Uppercased"
}))) {
};
var LengthTypeId2 = LengthTypeId;
var length4 = (length5, annotations5) => (self) => {
  const minLength3 = isObject(length5) ? Math.max(0, Math.floor(length5.min)) : Math.max(0, Math.floor(length5));
  const maxLength3 = isObject(length5) ? Math.max(minLength3, Math.floor(length5.max)) : minLength3;
  if (minLength3 !== maxLength3) {
    return self.pipe(filter13((a) => a.length >= minLength3 && a.length <= maxLength3, {
      typeId: LengthTypeId2,
      description: `a string at least ${minLength3} character(s) and at most ${maxLength3} character(s) long`,
      jsonSchema: {
        minLength: minLength3,
        maxLength: maxLength3
      },
      ...annotations5
    }));
  }
  return self.pipe(filter13((a) => a.length === minLength3, {
    typeId: LengthTypeId2,
    description: minLength3 === 1 ? `a single character` : `a string ${minLength3} character(s) long`,
    jsonSchema: {
      minLength: minLength3,
      maxLength: minLength3
    },
    ...annotations5
  }));
};
var Char2 = class extends (/* @__PURE__ */ String$2.pipe(/* @__PURE__ */ length4(1, {
  identifier: "Char"
}))) {
};
var nonEmptyString3 = (annotations5) => minLength2(1, {
  description: "a non empty string",
  ...annotations5
});
var Lowercase2 = class extends (/* @__PURE__ */ transform3(String$2.annotations({
  description: "a string that will be converted to lowercase"
}), Lowercased2, {
  strict: true,
  decode: (s) => s.toLowerCase(),
  encode: identity
}).annotations({
  identifier: "Lowercase"
})) {
};
var Uppercase2 = class extends (/* @__PURE__ */ transform3(String$2.annotations({
  description: "a string that will be converted to uppercase"
}), Uppercased2, {
  strict: true,
  decode: (s) => s.toUpperCase(),
  encode: identity
}).annotations({
  identifier: "Uppercase"
})) {
};
var Capitalize2 = class extends (/* @__PURE__ */ transform3(String$2.annotations({
  description: "a string that will be converted to a capitalized format"
}), Capitalized2, {
  strict: true,
  decode: (s) => capitalize(s),
  encode: identity
}).annotations({
  identifier: "Capitalize"
})) {
};
var Uncapitalize2 = class extends (/* @__PURE__ */ transform3(String$2.annotations({
  description: "a string that will be converted to an uncapitalized format"
}), Uncapitalized2, {
  strict: true,
  decode: (s) => uncapitalize(s),
  encode: identity
}).annotations({
  identifier: "Uncapitalize"
})) {
};
var Trimmed2 = class extends (/* @__PURE__ */ String$2.pipe(/* @__PURE__ */ trimmed2({
  identifier: "Trimmed",
  title: "Trimmed"
}))) {
};
var NonEmptyTrimmedString2 = class extends (/* @__PURE__ */ Trimmed2.pipe(/* @__PURE__ */ nonEmptyString3({
  identifier: "NonEmptyTrimmedString",
  title: "NonEmptyTrimmedString"
}))) {
};
var Trim2 = class extends (/* @__PURE__ */ transform3(String$2.annotations({
  description: "a string that will be trimmed"
}), Trimmed2, {
  strict: true,
  decode: (s) => s.trim(),
  encode: identity
}).annotations({
  identifier: "Trim"
})) {
};
var split7 = (separator) => transform3(String$2.annotations({
  description: "a string that will be split"
}), Array$2(String$2), {
  strict: true,
  decode: split2(separator),
  encode: join(separator)
});
var JsonString = /* @__PURE__ */ String$2.annotations({
  [IdentifierAnnotationId2]: "JsonString",
  [TitleAnnotationId2]: "JsonString",
  [DescriptionAnnotationId2]: "a JSON string"
});
var getParseJsonTransformation2 = (options) => transformOrFail2(JsonString, Unknown2, {
  strict: true,
  decode: (s, _, ast) => _try2({
    try: () => JSON.parse(s, options?.reviver),
    catch: (e) => new Type4(ast, s, e.message)
  }),
  encode: (u, _, ast) => _try2({
    try: () => JSON.stringify(u, options?.replacer, options?.space),
    catch: (e) => new Type4(ast, u, e.message)
  })
}).annotations({
  typeId: ParseJsonTypeId
});
var parseJson2 = (schema, o) => isSchema2(schema) ? compose6(parseJson2(o), schema) : getParseJsonTransformation2(schema);
var NonEmptyString2 = class extends (/* @__PURE__ */ String$2.pipe(/* @__PURE__ */ nonEmptyString3({
  identifier: "NonEmptyString",
  title: "NonEmptyString"
}))) {
};
var UUIDTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/UUID");
var uuidRegexp2 = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
var UUID2 = class extends (/* @__PURE__ */ String$2.pipe(/* @__PURE__ */ pattern2(uuidRegexp2, {
  typeId: UUIDTypeId,
  identifier: "UUID",
  title: "UUID",
  description: "a Universally Unique Identifier",
  arbitrary: () => (fc) => fc.uuid()
}))) {
};
var ULIDTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/ULID");
var ulidRegexp2 = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;
var ULID2 = class extends (/* @__PURE__ */ String$2.pipe(/* @__PURE__ */ pattern2(ulidRegexp2, {
  typeId: ULIDTypeId,
  identifier: "ULID",
  title: "ULID",
  description: "a Universally Unique Lexicographically Sortable Identifier",
  arbitrary: () => (fc) => fc.ulid()
}))) {
};
var FiniteTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Finite");
var finite2 = (annotations5) => (self) => self.pipe(filter13((a) => Number.isFinite(a), {
  typeId: FiniteTypeId,
  description: "a finite number",
  ...annotations5
}));
var GreaterThanTypeId2 = GreaterThanTypeId;
var greaterThan7 = (min5, annotations5) => (self) => self.pipe(filter13((a) => a > min5, {
  typeId: GreaterThanTypeId2,
  description: min5 === 0 ? "a positive number" : `a number greater than ${min5}`,
  jsonSchema: {
    exclusiveMinimum: min5
  },
  ...annotations5
}));
var GreaterThanOrEqualToTypeId2 = GreaterThanOrEqualToTypeId;
var greaterThanOrEqualTo6 = (min5, annotations5) => (self) => self.pipe(filter13((a) => a >= min5, {
  typeId: GreaterThanOrEqualToTypeId2,
  description: min5 === 0 ? "a non-negative number" : `a number greater than or equal to ${min5}`,
  jsonSchema: {
    minimum: min5
  },
  ...annotations5
}));
var MultipleOfTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/MultipleOf");
var multipleOf2 = (divisor, annotations5) => (self) => self.pipe(filter13((a) => remainder(a, divisor) === 0, {
  typeId: MultipleOfTypeId,
  description: `a number divisible by ${divisor}`,
  jsonSchema: {
    multipleOf: Math.abs(divisor)
  },
  // spec requires positive divisor
  ...annotations5
}));
var IntTypeId2 = IntTypeId;
var int2 = (annotations5) => (self) => self.pipe(filter13((a) => Number.isSafeInteger(a), {
  typeId: IntTypeId2,
  title: "integer",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations5
}));
var LessThanTypeId2 = LessThanTypeId;
var lessThan10 = (max7, annotations5) => (self) => self.pipe(filter13((a) => a < max7, {
  typeId: LessThanTypeId2,
  description: max7 === 0 ? "a negative number" : `a number less than ${max7}`,
  jsonSchema: {
    exclusiveMaximum: max7
  },
  ...annotations5
}));
var LessThanOrEqualToTypeId2 = LessThanOrEqualToTypeId;
var lessThanOrEqualTo6 = (max7, annotations5) => (self) => self.pipe(filter13((a) => a <= max7, {
  typeId: LessThanOrEqualToTypeId2,
  description: max7 === 0 ? "a non-positive number" : `a number less than or equal to ${max7}`,
  jsonSchema: {
    maximum: max7
  },
  ...annotations5
}));
var BetweenTypeId2 = BetweenTypeId;
var between6 = (min5, max7, annotations5) => (self) => self.pipe(filter13((a) => a >= min5 && a <= max7, {
  typeId: BetweenTypeId2,
  description: `a number between ${min5} and ${max7}`,
  jsonSchema: {
    maximum: max7,
    minimum: min5
  },
  ...annotations5
}));
var NonNaNTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/NonNaN");
var nonNaN2 = (annotations5) => (self) => self.pipe(filter13((a) => !Number.isNaN(a), {
  typeId: NonNaNTypeId,
  description: "a number excluding NaN",
  ...annotations5
}));
var positive2 = (annotations5) => greaterThan7(0, annotations5);
var negative2 = (annotations5) => lessThan10(0, annotations5);
var nonPositive2 = (annotations5) => lessThanOrEqualTo6(0, annotations5);
var nonNegative2 = (annotations5) => greaterThanOrEqualTo6(0, annotations5);
var clamp9 = (minimum, maximum) => (self) => transform3(self, self.pipe(typeSchema2, between6(minimum, maximum)), {
  strict: false,
  decode: (self2) => clamp4(self2, {
    minimum,
    maximum
  }),
  encode: identity
});
var parseNumber2 = (self) => transformOrFail2(self, Number$2, {
  strict: false,
  decode: (s, _, ast) => fromOption4(parse(s), () => new Type4(ast, s)),
  encode: (n) => succeed21(String(n))
});
var NumberFromString2 = class extends (/* @__PURE__ */ parseNumber2(String$2.annotations({
  description: "a string that will be parsed into a number"
})).annotations({
  identifier: "NumberFromString"
})) {
};
var Finite2 = class extends (/* @__PURE__ */ Number$2.pipe(/* @__PURE__ */ finite2({
  identifier: "Finite",
  title: "Finite"
}))) {
};
var Int2 = class extends (/* @__PURE__ */ Number$2.pipe(/* @__PURE__ */ int2({
  identifier: "Int",
  title: "Int"
}))) {
};
var NonNaN2 = class extends (/* @__PURE__ */ Number$2.pipe(/* @__PURE__ */ nonNaN2({
  identifier: "NonNaN",
  title: "NonNaN"
}))) {
};
var Positive2 = class extends (/* @__PURE__ */ Number$2.pipe(/* @__PURE__ */ positive2({
  identifier: "Positive",
  title: "Positive"
}))) {
};
var Negative2 = class extends (/* @__PURE__ */ Number$2.pipe(/* @__PURE__ */ negative2({
  identifier: "Negative",
  title: "Negative"
}))) {
};
var NonPositive2 = class extends (/* @__PURE__ */ Number$2.pipe(/* @__PURE__ */ nonPositive2({
  identifier: "NonPositive",
  title: "NonPositive"
}))) {
};
var NonNegative2 = class extends (/* @__PURE__ */ Number$2.pipe(/* @__PURE__ */ nonNegative2({
  identifier: "NonNegative",
  title: "NonNegative"
}))) {
};
var JsonNumberTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/JsonNumber");
var JsonNumber2 = class extends (/* @__PURE__ */ Number$2.pipe(/* @__PURE__ */ filter13((n) => !Number.isNaN(n) && Number.isFinite(n), {
  typeId: JsonNumberTypeId,
  identifier: "JsonNumber",
  title: "JSON-compatible number",
  description: "a JSON-compatible number, excluding NaN, +Infinity, and -Infinity",
  jsonSchema: {
    type: "number"
  }
}))) {
};
var Not2 = class extends (/* @__PURE__ */ transform3(/* @__PURE__ */ Boolean$2.annotations({
  description: "a boolean that will be negated"
}), Boolean$2, {
  strict: true,
  decode: not,
  encode: not
})) {
};
var Symbol$2 = class extends (/* @__PURE__ */ transform3(String$2.annotations({
  description: "a string that will be converted to a symbol"
}), SymbolFromSelf2, {
  strict: false,
  decode: (s) => Symbol.for(s),
  encode: (sym) => sym.description
}).annotations({
  identifier: "symbol"
})) {
};
var GreaterThanBigIntTypeId = GreaterThanBigintTypeId;
var greaterThanBigInt2 = (min5, annotations5) => (self) => self.pipe(filter13((a) => a > min5, {
  typeId: {
    id: GreaterThanBigIntTypeId,
    annotation: {
      min: min5
    }
  },
  description: min5 === 0n ? "a positive bigint" : `a bigint greater than ${min5}n`,
  ...annotations5
}));
var GreaterThanOrEqualToBigIntTypeId2 = GreaterThanOrEqualToBigIntTypeId;
var greaterThanOrEqualToBigInt2 = (min5, annotations5) => (self) => self.pipe(filter13((a) => a >= min5, {
  typeId: {
    id: GreaterThanOrEqualToBigIntTypeId2,
    annotation: {
      min: min5
    }
  },
  description: min5 === 0n ? "a non-negative bigint" : `a bigint greater than or equal to ${min5}n`,
  ...annotations5
}));
var LessThanBigIntTypeId2 = LessThanBigIntTypeId;
var lessThanBigInt2 = (max7, annotations5) => (self) => self.pipe(filter13((a) => a < max7, {
  typeId: {
    id: LessThanBigIntTypeId2,
    annotation: {
      max: max7
    }
  },
  description: max7 === 0n ? "a negative bigint" : `a bigint less than ${max7}n`,
  ...annotations5
}));
var LessThanOrEqualToBigIntTypeId2 = LessThanOrEqualToBigIntTypeId;
var lessThanOrEqualToBigInt2 = (max7, annotations5) => (self) => self.pipe(filter13((a) => a <= max7, {
  typeId: {
    id: LessThanOrEqualToBigIntTypeId2,
    annotation: {
      max: max7
    }
  },
  description: max7 === 0n ? "a non-positive bigint" : `a bigint less than or equal to ${max7}n`,
  ...annotations5
}));
var BetweenBigIntTypeId = BetweenBigintTypeId;
var betweenBigInt2 = (min5, max7, annotations5) => (self) => self.pipe(filter13((a) => a >= min5 && a <= max7, {
  typeId: {
    id: BetweenBigIntTypeId,
    annotation: {
      max: max7,
      min: min5
    }
  },
  description: `a bigint between ${min5}n and ${max7}n`,
  ...annotations5
}));
var positiveBigInt2 = (annotations5) => greaterThanBigInt2(0n, annotations5);
var negativeBigInt2 = (annotations5) => lessThanBigInt2(0n, annotations5);
var nonNegativeBigInt2 = (annotations5) => greaterThanOrEqualToBigInt2(0n, annotations5);
var nonPositiveBigInt2 = (annotations5) => lessThanOrEqualToBigInt2(0n, annotations5);
var clampBigInt2 = (minimum, maximum) => (self) => transform3(self, self.pipe(typeSchema2, betweenBigInt2(minimum, maximum)), {
  strict: false,
  decode: (self2) => clamp6(self2, {
    minimum,
    maximum
  }),
  encode: identity
});
var BigInt$2 = class extends (/* @__PURE__ */ transformOrFail2(String$2.annotations({
  description: "a string that will be parsed into a bigint"
}), BigIntFromSelf2, {
  strict: true,
  decode: (s, _, ast) => fromOption4(fromString2(s), () => new Type4(ast, s)),
  encode: (n) => succeed21(String(n))
}).annotations({
  identifier: "bigint"
})) {
};
var PositiveBigIntFromSelf2 = /* @__PURE__ */ BigIntFromSelf2.pipe(/* @__PURE__ */ positiveBigInt2({
  identifier: "PositiveBigintFromSelf",
  title: "PositiveBigintFromSelf"
}));
var PositiveBigInt2 = /* @__PURE__ */ BigInt$2.pipe(/* @__PURE__ */ positiveBigInt2({
  identifier: "PositiveBigint",
  title: "PositiveBigint"
}));
var NegativeBigIntFromSelf2 = /* @__PURE__ */ BigIntFromSelf2.pipe(/* @__PURE__ */ negativeBigInt2({
  identifier: "NegativeBigintFromSelf",
  title: "NegativeBigintFromSelf"
}));
var NegativeBigInt2 = /* @__PURE__ */ BigInt$2.pipe(/* @__PURE__ */ negativeBigInt2({
  identifier: "NegativeBigint",
  title: "NegativeBigint"
}));
var NonPositiveBigIntFromSelf2 = /* @__PURE__ */ BigIntFromSelf2.pipe(/* @__PURE__ */ nonPositiveBigInt2({
  identifier: "NonPositiveBigintFromSelf",
  title: "NonPositiveBigintFromSelf"
}));
var NonPositiveBigInt2 = /* @__PURE__ */ BigInt$2.pipe(/* @__PURE__ */ nonPositiveBigInt2({
  identifier: "NonPositiveBigint",
  title: "NonPositiveBigint"
}));
var NonNegativeBigIntFromSelf2 = /* @__PURE__ */ BigIntFromSelf2.pipe(/* @__PURE__ */ nonNegativeBigInt2({
  identifier: "NonNegativeBigintFromSelf",
  title: "NonNegativeBigintFromSelf"
}));
var NonNegativeBigInt2 = /* @__PURE__ */ BigInt$2.pipe(/* @__PURE__ */ nonNegativeBigInt2({
  identifier: "NonNegativeBigint",
  title: "NonNegativeBigint"
}));
var BigIntFromNumber2 = class extends (/* @__PURE__ */ transformOrFail2(Number$2.annotations({
  description: "a number that will be parsed into a bigint"
}), BigIntFromSelf2, {
  strict: true,
  decode: (n, _, ast) => fromOption4(fromNumber2(n), () => new Type4(ast, n)),
  encode: (b, _, ast) => fromOption4(toNumber(b), () => new Type4(ast, b))
}).annotations({
  identifier: "BigintFromNumber"
})) {
};
var redactedArbitrary2 = (value3) => (fc) => value3(fc).map(make59);
var toComposite2 = (eff, onSuccess, ast, actual) => mapBoth10(eff, {
  onFailure: (e) => new Composite3(ast, actual, e),
  onSuccess
});
var redactedParse2 = (decodeUnknown6) => (u, options, ast) => isRedacted2(u) ? toComposite2(decodeUnknown6(value2(u), options), make59, ast, u) : fail20(new Type4(ast, u));
var RedactedFromSelf2 = (value3) => declare2([value3], {
  decode: (value4) => redactedParse2(decodeUnknown4(value4)),
  encode: (value4) => redactedParse2(encodeUnknown3(value4))
}, {
  description: "Redacted(<redacted>)",
  pretty: () => () => "Redacted(<redacted>)",
  arbitrary: redactedArbitrary2,
  equivalence: getEquivalence7
});
var Redacted2 = (value3) => {
  return transform3(value3, RedactedFromSelf2(typeSchema2(value3)), {
    strict: true,
    decode: (value4) => make59(value4),
    encode: (value4) => value2(value4)
  });
};
var DurationFromSelf2 = class extends (/* @__PURE__ */ declare2(isDuration, {
  identifier: "DurationFromSelf",
  pretty: () => String,
  arbitrary: () => (fc) => fc.oneof(fc.constant(infinity), fc.bigUint().map((_) => nanos(_)), fc.bigUint().map((_) => micros(_)), fc.maxSafeNat().map((_) => millis(_)), fc.maxSafeNat().map((_) => seconds(_)), fc.maxSafeNat().map((_) => minutes(_)), fc.maxSafeNat().map((_) => hours(_)), fc.maxSafeNat().map((_) => days(_)), fc.maxSafeNat().map((_) => weeks(_))),
  equivalence: () => Equivalence
})) {
};
var DurationFromNanos2 = class extends (/* @__PURE__ */ transformOrFail2(BigIntFromSelf2.annotations({
  description: "a bigint that will be parsed into a Duration"
}), DurationFromSelf2, {
  strict: true,
  decode: (nanos2) => succeed21(nanos(nanos2)),
  encode: (duration4, _, ast) => match2(toNanos(duration4), {
    onNone: () => fail20(new Type4(ast, duration4)),
    onSome: (val) => succeed21(val)
  })
}).annotations({
  identifier: "DurationFromNanos"
})) {
};
var DurationFromMillis2 = class extends (/* @__PURE__ */ transform3(Number$2.annotations({
  description: "a number that will be parsed into a Duration"
}), DurationFromSelf2, {
  strict: true,
  decode: (ms) => millis(ms),
  encode: (n) => toMillis(n)
}).annotations({
  identifier: "DurationFromMillis"
})) {
};
var hrTime = /* @__PURE__ */ Tuple2(/* @__PURE__ */ NonNegative2.pipe(/* @__PURE__ */ finite2({
  [TitleAnnotationId2]: "seconds",
  [DescriptionAnnotationId2]: "seconds"
})), /* @__PURE__ */ NonNegative2.pipe(/* @__PURE__ */ finite2({
  [TitleAnnotationId2]: "nanos",
  [DescriptionAnnotationId2]: "nanos"
})));
var Duration2 = class extends (/* @__PURE__ */ transform3(hrTime.annotations({
  description: "a tuple of seconds and nanos that will be parsed into a Duration"
}), DurationFromSelf2, {
  strict: true,
  decode: ([seconds2, nanos2]) => nanos(BigInt(seconds2) * BigInt(1e9) + BigInt(nanos2)),
  encode: (duration4) => toHrTime(duration4)
}).annotations({
  identifier: "Duration"
})) {
};
var clampDuration2 = (minimum, maximum) => (self) => transform3(self, self.pipe(typeSchema2, betweenDuration2(minimum, maximum)), {
  strict: false,
  decode: (self2) => clamp3(self2, {
    minimum,
    maximum
  }),
  encode: identity
});
var LessThanDurationTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanDuration");
var lessThanDuration2 = (max7, annotations5) => (self) => self.pipe(filter13((a) => lessThan2(a, max7), {
  typeId: {
    id: LessThanDurationTypeId,
    annotation: {
      max: max7
    }
  },
  description: `a Duration less than ${decode(max7)}`,
  ...annotations5
}));
var LessThanOrEqualToDurationTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanOrEqualToDuration");
var lessThanOrEqualToDuration2 = (max7, annotations5) => (self) => self.pipe(filter13((a) => lessThanOrEqualTo2(a, max7), {
  typeId: {
    id: LessThanDurationTypeId,
    annotation: {
      max: max7
    }
  },
  description: `a Duration less than or equal to ${decode(max7)}`,
  ...annotations5
}));
var GreaterThanDurationTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanDuration");
var greaterThanDuration2 = (min5, annotations5) => (self) => self.pipe(filter13((a) => greaterThan2(a, min5), {
  typeId: {
    id: GreaterThanDurationTypeId,
    annotation: {
      min: min5
    }
  },
  description: `a Duration greater than ${decode(min5)}`,
  ...annotations5
}));
var GreaterThanOrEqualToDurationTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualToDuration");
var greaterThanOrEqualToDuration2 = (min5, annotations5) => (self) => self.pipe(filter13((a) => greaterThanOrEqualTo2(a, min5), {
  typeId: {
    id: GreaterThanOrEqualToDurationTypeId,
    annotation: {
      min: min5
    }
  },
  description: `a Duration greater than or equal to ${decode(min5)}`,
  ...annotations5
}));
var BetweenDurationTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/BetweenDuration");
var betweenDuration2 = (minimum, maximum, annotations5) => (self) => self.pipe(filter13((a) => between2(a, {
  minimum,
  maximum
}), {
  typeId: {
    id: BetweenDurationTypeId,
    annotation: {
      maximum,
      minimum
    }
  },
  description: `a Duration between ${decode(minimum)} and ${decode(maximum)}`,
  ...annotations5
}));
var Uint8ArrayFromSelf2 = /* @__PURE__ */ declare2(isUint8Array, {
  identifier: "Uint8ArrayFromSelf",
  pretty: () => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
  arbitrary: () => (fc) => fc.uint8Array(),
  equivalence: () => getEquivalence3(equals)
});
var Uint8Array$2 = /* @__PURE__ */ transform3(Array$2(Number$2.pipe(between6(0, 255, {
  title: "8-bit unsigned integer",
  description: "a 8-bit unsigned integer"
}))).annotations({
  description: "an array of 8-bit unsigned integers that will be parsed into a Uint8Array"
}), Uint8ArrayFromSelf2, {
  strict: true,
  decode: (numbers) => Uint8Array.from(numbers),
  encode: (uint8Array2) => Array.from(uint8Array2)
}).annotations({
  identifier: "Uint8Array"
});
var makeUint8ArrayTransformation2 = (id3, decode7, encode6) => transformOrFail2(String$2.annotations({
  description: "a string that will be parsed into a Uint8Array"
}), Uint8ArrayFromSelf2, {
  strict: true,
  decode: (s, _, ast) => mapLeft(decode7(s), (decodeException) => new Type4(ast, s, decodeException.message)),
  encode: (u) => succeed21(encode6(u))
}).annotations({
  identifier: id3
});
var Uint8ArrayFromBase642 = /* @__PURE__ */ makeUint8ArrayTransformation2("Uint8ArrayFromBase64", decodeBase64, encodeBase64);
var Uint8ArrayFromBase64Url2 = /* @__PURE__ */ makeUint8ArrayTransformation2("Uint8ArrayFromBase64Url", decodeBase64Url, encodeBase64Url);
var Uint8ArrayFromHex2 = /* @__PURE__ */ makeUint8ArrayTransformation2("Uint8ArrayFromHex", decodeHex, encodeHex);
var makeEncodingTransformation2 = (id3, decode7, encode6) => transformOrFail2(String$2.annotations({
  description: `A string that is interpreted as being ${id3}-encoded and will be decoded into a UTF-8 string`
}), String$2, {
  strict: true,
  decode: (s, _, ast) => mapLeft(decode7(s), (decodeException) => new Type4(ast, s, decodeException.message)),
  encode: (u) => succeed21(encode6(u))
}).annotations({
  identifier: `StringFrom${id3}`
});
var StringFromBase642 = /* @__PURE__ */ makeEncodingTransformation2("Base64", decodeBase64String, encodeBase64);
var StringFromBase64Url2 = /* @__PURE__ */ makeEncodingTransformation2("Base64Url", decodeBase64UrlString, encodeBase64Url);
var StringFromHex2 = /* @__PURE__ */ makeEncodingTransformation2("Hex", decodeHexString, encodeHex);
var MinItemsTypeId2 = MinItemsTypeId;
var minItems2 = (n, annotations5) => (self) => {
  const minItems3 = Math.floor(n);
  if (minItems3 < 1) {
    throw new Error(getInvalidArgumentErrorMessage2(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self.pipe(filter13((a) => a.length >= minItems3, {
    typeId: MinItemsTypeId2,
    description: `an array of at least ${minItems3} items`,
    jsonSchema: {
      minItems: minItems3
    },
    [StableFilterAnnotationId2]: true,
    ...annotations5
  }));
};
var MaxItemsTypeId2 = MaxItemsTypeId;
var maxItems2 = (n, annotations5) => (self) => self.pipe(filter13((a) => a.length <= n, {
  typeId: MaxItemsTypeId2,
  description: `an array of at most ${n} items`,
  jsonSchema: {
    maxItems: n
  },
  [StableFilterAnnotationId2]: true,
  ...annotations5
}));
var ItemsCountTypeId2 = ItemsCountTypeId;
var itemsCount2 = (n, annotations5) => (self) => self.pipe(filter13((a) => a.length === n, {
  typeId: ItemsCountTypeId2,
  description: `an array of exactly ${n} item(s)`,
  jsonSchema: {
    minItems: n,
    maxItems: n
  },
  [StableFilterAnnotationId2]: true,
  ...annotations5
}));
var getNumberIndexedAccess4 = (self) => make67(getNumberIndexedAccess3(self.ast));
var head7 = (self) => transform3(self, OptionFromSelf2(getNumberIndexedAccess4(typeSchema2(self))), {
  strict: true,
  decode: head,
  encode: match2({
    onNone: () => [],
    onSome: of
  })
});
var headOrElse2 = /* @__PURE__ */ dual((args2) => isSchema2(args2[0]), (self, fallback) => transformOrFail2(self, getNumberIndexedAccess4(typeSchema2(self)), {
  strict: true,
  decode: (as13, _, ast) => as13.length > 0 ? succeed21(as13[0]) : fallback ? succeed21(fallback()) : fail20(new Type4(ast, as13)),
  encode: (a) => succeed21(of(a))
}));
var ValidDateTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/ValidDate");
var validDate2 = (annotations5) => (self) => self.pipe(filter13((a) => !Number.isNaN(a.getTime()), {
  typeId: ValidDateTypeId,
  description: "a valid Date",
  ...annotations5
}));
var LessThanDateTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanDate");
var lessThanDate2 = (max7, annotations5) => (self) => self.pipe(filter13((a) => a < max7, {
  typeId: {
    id: LessThanDateTypeId,
    annotation: {
      max: max7
    }
  },
  description: `a date before ${formatDate2(max7)}`,
  ...annotations5
}));
var LessThanOrEqualToDateTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanOrEqualToDate");
var lessThanOrEqualToDate2 = (max7, annotations5) => (self) => self.pipe(filter13((a) => a <= max7, {
  typeId: {
    id: LessThanDateTypeId,
    annotation: {
      max: max7
    }
  },
  description: `a date before or equal to ${formatDate2(max7)}`,
  ...annotations5
}));
var GreaterThanDateTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanDate");
var greaterThanDate2 = (min5, annotations5) => (self) => self.pipe(filter13((a) => a > min5, {
  typeId: {
    id: GreaterThanDateTypeId,
    annotation: {
      min: min5
    }
  },
  description: `a date after ${formatDate2(min5)}`,
  ...annotations5
}));
var GreaterThanOrEqualToDateTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualToDate");
var greaterThanOrEqualToDate2 = (min5, annotations5) => (self) => self.pipe(filter13((a) => a >= min5, {
  typeId: {
    id: GreaterThanOrEqualToDateTypeId,
    annotation: {
      min: min5
    }
  },
  description: `a date after or equal to ${formatDate2(min5)}`,
  ...annotations5
}));
var BetweenDateTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/BetweenDate");
var betweenDate2 = (minimum, maximum, annotations5) => (self) => self.pipe(filter13((a) => a <= maximum && a >= minimum, {
  typeId: {
    id: BetweenDateTypeId,
    annotation: {
      maximum,
      minimum
    }
  },
  description: `a date between ${formatDate2(minimum)} and ${formatDate2(maximum)}`,
  ...annotations5
}));
var DateFromSelf2 = class extends (/* @__PURE__ */ declare2(isDate, {
  identifier: "DateFromSelf",
  description: "a potentially invalid Date instance",
  pretty: () => (date3) => `new Date(${JSON.stringify(date3)})`,
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Date2
})) {
};
var ValidDateFromSelf2 = class extends (/* @__PURE__ */ DateFromSelf2.pipe(/* @__PURE__ */ validDate2({
  identifier: "ValidDateFromSelf",
  description: "a valid Date instance"
}))) {
};
var DateFromString2 = class extends (/* @__PURE__ */ transform3(String$2.annotations({
  description: "a string that will be parsed into a Date"
}), DateFromSelf2, {
  strict: true,
  decode: (s) => new Date(s),
  encode: (d) => formatDate2(d)
}).annotations({
  identifier: "DateFromString"
})) {
};
var Date$2 = class extends (/* @__PURE__ */ DateFromString2.pipe(/* @__PURE__ */ validDate2({
  identifier: "Date"
}))) {
};
var DateFromNumber2 = class extends (/* @__PURE__ */ transform3(Number$2.annotations({
  description: "a number that will be parsed into a Date"
}), DateFromSelf2, {
  strict: true,
  decode: (n) => new Date(n),
  encode: (d) => d.getTime()
}).annotations({
  identifier: "DateFromNumber"
})) {
};
var DateTimeUtcFromSelf2 = class extends (/* @__PURE__ */ declare2((u) => isDateTime2(u) && isUtc2(u), {
  identifier: "DateTimeUtcFromSelf",
  description: "a DateTime.Utc instance",
  pretty: () => (dateTime) => dateTime.toString(),
  arbitrary: () => (fc) => fc.date().map((date3) => unsafeFromDate2(date3)),
  equivalence: () => Equivalence5
})) {
};
var decodeDateTime = (input, _, ast) => _try2({
  try: () => unsafeMake12(input),
  catch: () => new Type4(ast, input)
});
var DateTimeUtcFromNumber2 = class extends (/* @__PURE__ */ transformOrFail2(Number$2.annotations({
  description: "a number that will be parsed into a DateTime.Utc"
}), DateTimeUtcFromSelf2, {
  strict: true,
  decode: decodeDateTime,
  encode: (dt) => succeed21(toEpochMillis2(dt))
}).annotations({
  identifier: "DateTimeUtcFromNumber"
})) {
};
var DateTimeUtc2 = class extends (/* @__PURE__ */ transformOrFail2(String$2.annotations({
  description: "a string that will be parsed into a DateTime.Utc"
}), DateTimeUtcFromSelf2, {
  strict: true,
  decode: decodeDateTime,
  encode: (dt) => succeed21(formatIso3(dt))
}).annotations({
  identifier: "DateTimeUtc"
})) {
};
var timeZoneOffsetArbitrary2 = () => (fc) => fc.integer({
  min: -12 * 60 * 60 * 1e3,
  max: 12 * 60 * 60 * 1e3
}).map(zoneMakeOffset2);
var TimeZoneOffsetFromSelf2 = class extends (/* @__PURE__ */ declare2(isTimeZoneOffset2, {
  identifier: "TimeZoneOffsetFromSelf",
  description: "a TimeZone.Offset instance",
  pretty: () => (zone) => zone.toString(),
  arbitrary: timeZoneOffsetArbitrary2
})) {
};
var TimeZoneOffset2 = class extends (/* @__PURE__ */ transform3(Number$2.annotations({
  description: "a number that will be parsed into a TimeZone.Offset"
}), TimeZoneOffsetFromSelf2, {
  strict: true,
  decode: zoneMakeOffset2,
  encode: (tz) => tz.offset
}).annotations({
  identifier: "TimeZoneOffset"
})) {
};
var timeZoneNamedArbitrary2 = () => (fc) => fc.constantFrom(...Intl.supportedValuesOf("timeZone")).map(zoneUnsafeMakeNamed2);
var TimeZoneNamedFromSelf2 = class extends (/* @__PURE__ */ declare2(isTimeZoneNamed2, {
  identifier: "TimeZoneNamedFromSelf",
  description: "a TimeZone.Named instance",
  pretty: () => (zone) => zone.toString(),
  arbitrary: timeZoneNamedArbitrary2
})) {
};
var TimeZoneNamed2 = class extends (/* @__PURE__ */ transformOrFail2(String$2.annotations({
  description: "a string that will be parsed into a TimeZone.Named"
}), TimeZoneNamedFromSelf2, {
  strict: true,
  decode: (s, _, ast) => _try2({
    try: () => zoneUnsafeMakeNamed2(s),
    catch: () => new Type4(ast, s)
  }),
  encode: (tz) => succeed21(tz.id)
}).annotations({
  identifier: "TimeZoneNamed"
})) {
};
var TimeZoneFromSelf2 = /* @__PURE__ */ Union4(TimeZoneOffsetFromSelf2, TimeZoneNamedFromSelf2);
var TimeZone2 = class extends (/* @__PURE__ */ transformOrFail2(String$2.annotations({
  description: "a string that will be parsed into a TimeZone"
}), TimeZoneFromSelf2, {
  strict: true,
  decode: (s, _, ast) => match2(zoneFromString2(s), {
    onNone: () => fail20(new Type4(ast, s)),
    onSome: succeed21
  }),
  encode: (tz) => succeed21(zoneToString2(tz))
}).annotations({
  identifier: "TimeZone"
})) {
};
var timeZoneArbitrary2 = (fc) => fc.oneof(timeZoneOffsetArbitrary2()(fc), timeZoneNamedArbitrary2()(fc));
var DateTimeZonedFromSelf2 = class extends (/* @__PURE__ */ declare2((u) => isDateTime2(u) && isZoned2(u), {
  identifier: "DateTimeZonedFromSelf",
  description: "a DateTime.Zoned instance",
  pretty: () => (dateTime) => dateTime.toString(),
  arbitrary: () => (fc) => fc.date().chain((date3) => timeZoneArbitrary2(fc).map((timeZone) => unsafeMakeZoned2(date3, {
    timeZone
  }))),
  equivalence: () => Equivalence5
})) {
};
var DateTimeZoned2 = class extends (/* @__PURE__ */ transformOrFail2(String$2.annotations({
  description: "a string that will be parsed into a DateTime.Zoned"
}), DateTimeZonedFromSelf2, {
  strict: true,
  decode: (s, _, ast) => match2(makeZonedFromString2(s), {
    onNone: () => fail20(new Type4(ast, s)),
    onSome: succeed21
  }),
  encode: (dt) => succeed21(formatIsoZoned2(dt))
}).annotations({
  identifier: "DateTimeZoned"
})) {
};
var OptionNoneEncoded2 = /* @__PURE__ */ Struct2({
  _tag: Literal4("None")
}).annotations({
  description: "NoneEncoded"
});
var optionSomeEncoded2 = (value3) => Struct2({
  _tag: Literal4("Some"),
  value: value3
}).annotations({
  description: `SomeEncoded<${format7(value3)}>`
});
var optionEncoded2 = (value3) => Union4(OptionNoneEncoded2, optionSomeEncoded2(value3)).annotations({
  description: `OptionEncoded<${format7(value3)}>`
});
var optionDecode2 = (input) => input._tag === "None" ? none2() : some2(input.value);
var optionArbitrary2 = (value3, ctx) => (fc) => fc.oneof(ctx, fc.record({
  _tag: fc.constant("None")
}), fc.record({
  _tag: fc.constant("Some"),
  value: value3(fc)
})).map(optionDecode2);
var optionPretty2 = (value3) => match2({
  onNone: () => "none()",
  onSome: (a) => `some(${value3(a)})`
});
var optionParse2 = (decodeUnknown6) => (u, options, ast) => isOption2(u) ? isNone2(u) ? succeed21(none2()) : toComposite2(decodeUnknown6(u.value, options), some2, ast, u) : fail20(new Type4(ast, u));
var OptionFromSelf2 = (value3) => {
  return declare2([value3], {
    decode: (value4) => optionParse2(decodeUnknown4(value4)),
    encode: (value4) => optionParse2(encodeUnknown3(value4))
  }, {
    description: `Option<${format7(value3)}>`,
    pretty: optionPretty2,
    arbitrary: optionArbitrary2,
    equivalence: getEquivalence2
  });
};
var makeNoneEncoded2 = {
  _tag: "None"
};
var makeSomeEncoded2 = (value3) => ({
  _tag: "Some",
  value: value3
});
var Option2 = (value3) => {
  const value_ = asSchema2(value3);
  return transform3(optionEncoded2(value_), OptionFromSelf2(typeSchema2(value_)), {
    strict: true,
    decode: optionDecode2,
    encode: match2({
      onNone: () => makeNoneEncoded2,
      onSome: makeSomeEncoded2
    })
  });
};
var OptionFromNullOr2 = (value3) => {
  const value_ = asSchema2(value3);
  return transform3(NullOr2(value_), OptionFromSelf2(typeSchema2(value_)), {
    strict: true,
    decode: fromNullable,
    encode: getOrNull
  });
};
var OptionFromNullishOr2 = (value3, onNoneEncoding) => {
  const value_ = asSchema2(value3);
  return transform3(NullishOr2(value_), OptionFromSelf2(typeSchema2(value_)), {
    strict: true,
    decode: fromNullable,
    encode: onNoneEncoding === null ? getOrNull : getOrUndefined
  });
};
var OptionFromUndefinedOr2 = (value3) => {
  const value_ = asSchema2(value3);
  return transform3(UndefinedOr2(value_), OptionFromSelf2(typeSchema2(value_)), {
    strict: true,
    decode: fromNullable,
    encode: getOrUndefined
  });
};
var OptionFromNonEmptyTrimmedString2 = /* @__PURE__ */ transform3(String$2, /* @__PURE__ */ OptionFromSelf2(NonEmptyTrimmedString2), {
  strict: true,
  decode: (s) => {
    const out = s.trim();
    return out.length === 0 ? none2() : some2(out);
  },
  encode: /* @__PURE__ */ getOrElse3(() => "")
});
var rightEncoded2 = (right3) => Struct2({
  _tag: Literal4("Right"),
  right: right3
}).annotations({
  description: `RightEncoded<${format7(right3)}>`
});
var leftEncoded2 = (left3) => Struct2({
  _tag: Literal4("Left"),
  left: left3
}).annotations({
  description: `LeftEncoded<${format7(left3)}>`
});
var eitherEncoded2 = (right3, left3) => Union4(rightEncoded2(right3), leftEncoded2(left3)).annotations({
  description: `EitherEncoded<${format7(left3)}, ${format7(right3)}>`
});
var eitherDecode2 = (input) => input._tag === "Left" ? left2(input.left) : right2(input.right);
var eitherArbitrary2 = (right3, left3) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Left"),
  left: left3(fc)
}), fc.record({
  _tag: fc.constant("Right"),
  right: right3(fc)
})).map(eitherDecode2);
var eitherPretty2 = (right3, left3) => match({
  onLeft: (e) => `left(${left3(e)})`,
  onRight: (a) => `right(${right3(a)})`
});
var eitherParse2 = (parseRight, decodeUnknownLeft) => (u, options, ast) => isEither2(u) ? match(u, {
  onLeft: (left3) => toComposite2(decodeUnknownLeft(left3, options), left2, ast, u),
  onRight: (right3) => toComposite2(parseRight(right3, options), right2, ast, u)
}) : fail20(new Type4(ast, u));
var EitherFromSelf2 = ({
  left: left3,
  right: right3
}) => {
  return declare2([right3, left3], {
    decode: (right4, left4) => eitherParse2(decodeUnknown4(right4), decodeUnknown4(left4)),
    encode: (right4, left4) => eitherParse2(encodeUnknown3(right4), encodeUnknown3(left4))
  }, {
    description: `Either<${format7(right3)}, ${format7(left3)}>`,
    pretty: eitherPretty2,
    arbitrary: eitherArbitrary2,
    equivalence: (right4, left4) => getEquivalence({
      left: left4,
      right: right4
    })
  });
};
var makeLeftEncoded2 = (left3) => ({
  _tag: "Left",
  left: left3
});
var makeRightEncoded2 = (right3) => ({
  _tag: "Right",
  right: right3
});
var Either3 = ({
  left: left3,
  right: right3
}) => {
  const right_ = asSchema2(right3);
  const left_ = asSchema2(left3);
  return transform3(eitherEncoded2(right_, left_), EitherFromSelf2({
    left: typeSchema2(left_),
    right: typeSchema2(right_)
  }), {
    strict: true,
    decode: eitherDecode2,
    encode: match({
      onLeft: makeLeftEncoded2,
      onRight: makeRightEncoded2
    })
  });
};
var EitherFromUnion2 = ({
  left: left3,
  right: right3
}) => {
  const right_ = asSchema2(right3);
  const left_ = asSchema2(left3);
  const toright = typeSchema2(right_);
  const toleft = typeSchema2(left_);
  const fromRight = transform3(right_, rightEncoded2(toright), {
    strict: true,
    decode: makeRightEncoded2,
    encode: (r) => r.right
  });
  const fromLeft = transform3(left_, leftEncoded2(toleft), {
    strict: true,
    decode: makeLeftEncoded2,
    encode: (l) => l.left
  });
  return transform3(Union4(fromRight, fromLeft), EitherFromSelf2({
    left: toleft,
    right: toright
  }), {
    strict: true,
    decode: (from) => from._tag === "Left" ? left2(from.left) : right2(from.right),
    encode: match({
      onLeft: makeLeftEncoded2,
      onRight: makeRightEncoded2
    })
  });
};
var mapArbitrary2 = (key, value3, ctx) => {
  return (fc) => {
    const items = fc.array(fc.tuple(key(fc), value3(fc)));
    return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as13) => new Map(as13));
  };
};
var readonlyMapPretty2 = (key, value3) => (map31) => `new Map([${Array.from(map31.entries()).map(([k, v]) => `[${key(k)}, ${value3(v)}]`).join(", ")}])`;
var readonlyMapEquivalence2 = (key, value3) => {
  const arrayEquivalence = getEquivalence3(make3(([ka, va], [kb, vb]) => key(ka, kb) && value3(va, vb)));
  return make3((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())));
};
var readonlyMapParse2 = (decodeUnknown6) => (u, options, ast) => isMap(u) ? toComposite2(decodeUnknown6(Array.from(u.entries()), options), (as13) => new Map(as13), ast, u) : fail20(new Type4(ast, u));
var mapFromSelf_2 = (key, value3, description) => declare2([key, value3], {
  decode: (Key2, Value2) => readonlyMapParse2(decodeUnknown4(Array$2(Tuple2(Key2, Value2)))),
  encode: (Key2, Value2) => readonlyMapParse2(encodeUnknown3(Array$2(Tuple2(Key2, Value2))))
}, {
  description,
  pretty: readonlyMapPretty2,
  arbitrary: mapArbitrary2,
  equivalence: readonlyMapEquivalence2
});
var ReadonlyMapFromSelf2 = ({
  key,
  value: value3
}) => mapFromSelf_2(key, value3, `ReadonlyMap<${format7(key)}, ${format7(value3)}>`);
var MapFromSelf2 = ({
  key,
  value: value3
}) => mapFromSelf_2(key, value3, `Map<${format7(key)}, ${format7(value3)}>`);
var ReadonlyMap2 = ({
  key,
  value: value3
}) => {
  const key_ = asSchema2(key);
  const value_ = asSchema2(value3);
  return transform3(Array$2(Tuple2(key_, value_)), ReadonlyMapFromSelf2({
    key: typeSchema2(key_),
    value: typeSchema2(value_)
  }), {
    strict: true,
    decode: (as13) => new Map(as13),
    encode: (map31) => Array.from(map31.entries())
  });
};
var map30 = ({
  key,
  value: value3
}) => {
  const key_ = asSchema2(key);
  const value_ = asSchema2(value3);
  return transform3(Array$2(Tuple2(key_, value_)), MapFromSelf2({
    key: typeSchema2(key_),
    value: typeSchema2(value_)
  }), {
    strict: true,
    decode: (as13) => new Map(as13),
    encode: (map31) => Array.from(map31.entries())
  });
};
var ReadonlyMapFromRecord2 = ({
  key,
  value: value3
}) => transform3(Record2({
  key: encodedBoundSchema2(key),
  value: value3
}).annotations({
  description: "a record that will be parsed into a ReadonlyMap"
}), ReadonlyMapFromSelf2({
  key,
  value: typeSchema2(value3)
}), {
  strict: true,
  decode: (record4) => new Map(Object.entries(record4)),
  encode: fromEntries
});
var MapFromRecord2 = ({
  key,
  value: value3
}) => transform3(Record2({
  key: encodedBoundSchema2(key),
  value: value3
}).annotations({
  description: "a record that will be parsed into a Map"
}), MapFromSelf2({
  key,
  value: typeSchema2(value3)
}), {
  strict: true,
  decode: (record4) => new Map(Object.entries(record4)),
  encode: fromEntries
});
var setArbitrary2 = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as13) => new Set(as13));
};
var readonlySetPretty2 = (item) => (set10) => `new Set([${Array.from(set10.values()).map((a) => item(a)).join(", ")}])`;
var readonlySetEquivalence2 = (item) => {
  const arrayEquivalence = getEquivalence3(item);
  return make3((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())));
};
var readonlySetParse2 = (decodeUnknown6) => (u, options, ast) => isSet(u) ? toComposite2(decodeUnknown6(Array.from(u.values()), options), (as13) => new Set(as13), ast, u) : fail20(new Type4(ast, u));
var setFromSelf_2 = (value3, description) => declare2([value3], {
  decode: (item) => readonlySetParse2(decodeUnknown4(Array$2(item))),
  encode: (item) => readonlySetParse2(encodeUnknown3(Array$2(item)))
}, {
  description,
  pretty: readonlySetPretty2,
  arbitrary: setArbitrary2,
  equivalence: readonlySetEquivalence2
});
var ReadonlySetFromSelf2 = (value3) => setFromSelf_2(value3, `ReadonlySet<${format7(value3)}>`);
var SetFromSelf2 = (value3) => setFromSelf_2(value3, `Set<${format7(value3)}>`);
var ReadonlySet2 = (value3) => {
  const value_ = asSchema2(value3);
  return transform3(Array$2(value_), ReadonlySetFromSelf2(typeSchema2(value_)), {
    strict: true,
    decode: (as13) => new Set(as13),
    encode: (set10) => Array.from(set10)
  });
};
var set9 = (value3) => {
  const value_ = asSchema2(value3);
  return transform3(Array$2(value_), SetFromSelf2(typeSchema2(value_)), {
    strict: true,
    decode: (as13) => new Set(as13),
    encode: (set10) => Array.from(set10)
  });
};
var bigDecimalPretty2 = () => (val) => `BigDecimal(${format4(normalize(val))})`;
var bigDecimalArbitrary2 = () => (fc) => fc.tuple(fc.bigInt(), fc.integer()).map(([value3, scale2]) => make56(value3, scale2));
var BigDecimalFromSelf2 = class extends (/* @__PURE__ */ declare2(isBigDecimal, {
  identifier: "BigDecimalFromSelf",
  pretty: bigDecimalPretty2,
  arbitrary: bigDecimalArbitrary2,
  equivalence: () => Equivalence4
})) {
};
var BigDecimal2 = class extends (/* @__PURE__ */ transformOrFail2(String$2.annotations({
  description: "a string that will be parsed into a BigDecimal"
}), BigDecimalFromSelf2, {
  strict: true,
  decode: (num2, _, ast) => fromString(num2).pipe(match2({
    onNone: () => fail20(new Type4(ast, num2)),
    onSome: (val) => succeed21(normalize(val))
  })),
  encode: (val) => succeed21(format4(normalize(val)))
}).annotations({
  identifier: "BigDecimal"
})) {
};
var BigDecimalFromNumber2 = class extends (/* @__PURE__ */ transformOrFail2(Number$2.annotations({
  description: "a number that will be parsed into a BigDecimal"
}), BigDecimalFromSelf2, {
  strict: true,
  decode: (num2) => succeed21(fromNumber(num2)),
  encode: (val) => succeed21(unsafeToNumber(val))
}).annotations({
  identifier: "BigDecimalFromNumber"
})) {
};
var GreaterThanBigDecimalTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanBigDecimal");
var greaterThanBigDecimal2 = (min5, annotations5) => (self) => self.pipe(filter13((a) => greaterThan4(a, min5), {
  typeId: {
    id: GreaterThanBigDecimalTypeId,
    annotation: {
      min: min5
    }
  },
  description: `a BigDecimal greater than ${format4(min5)}`,
  ...annotations5
}));
var GreaterThanOrEqualToBigDecimalTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualToBigDecimal");
var greaterThanOrEqualToBigDecimal2 = (min5, annotations5) => (self) => self.pipe(filter13((a) => greaterThanOrEqualTo3(a, min5), {
  typeId: {
    id: GreaterThanOrEqualToBigDecimalTypeId,
    annotation: {
      min: min5
    }
  },
  description: `a BigDecimal greater than or equal to ${format4(min5)}`,
  ...annotations5
}));
var LessThanBigDecimalTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanBigDecimal");
var lessThanBigDecimal2 = (max7, annotations5) => (self) => self.pipe(filter13((a) => lessThan7(a, max7), {
  typeId: {
    id: LessThanBigDecimalTypeId,
    annotation: {
      max: max7
    }
  },
  description: `a BigDecimal less than ${format4(max7)}`,
  ...annotations5
}));
var LessThanOrEqualToBigDecimalTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanOrEqualToBigDecimal");
var lessThanOrEqualToBigDecimal2 = (max7, annotations5) => (self) => self.pipe(filter13((a) => lessThanOrEqualTo3(a, max7), {
  typeId: {
    id: LessThanOrEqualToBigDecimalTypeId,
    annotation: {
      max: max7
    }
  },
  description: `a BigDecimal less than or equal to ${format4(max7)}`,
  ...annotations5
}));
var PositiveBigDecimalTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/PositiveBigDecimal");
var positiveBigDecimal2 = (annotations5) => (self) => self.pipe(filter13((a) => isPositive(a), {
  typeId: {
    id: PositiveBigDecimalTypeId,
    annotation: {}
  },
  description: `a positive BigDecimal`,
  ...annotations5
}));
var PositiveBigDecimalFromSelf2 = /* @__PURE__ */ BigDecimalFromSelf2.pipe(/* @__PURE__ */ positiveBigDecimal2({
  identifier: "PositiveBigDecimalFromSelf",
  title: "PositiveBigDecimalFromSelf"
}));
var NonNegativeBigDecimalTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/NonNegativeBigDecimal");
var nonNegativeBigDecimal2 = (annotations5) => (self) => self.pipe(filter13((a) => a.value >= 0n, {
  typeId: {
    id: NonNegativeBigDecimalTypeId,
    annotation: {}
  },
  description: `a non-negative BigDecimal`,
  ...annotations5
}));
var NonNegativeBigDecimalFromSelf2 = /* @__PURE__ */ BigDecimalFromSelf2.pipe(/* @__PURE__ */ nonNegativeBigDecimal2({
  identifier: "NonNegativeBigDecimalFromSelf",
  title: "NonNegativeBigDecimalFromSelf"
}));
var NegativeBigDecimalTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/NegativeBigDecimal");
var negativeBigDecimal2 = (annotations5) => (self) => self.pipe(filter13((a) => isNegative(a), {
  typeId: {
    id: NegativeBigDecimalTypeId,
    annotation: {}
  },
  description: `a negative BigDecimal`,
  ...annotations5
}));
var NegativeBigDecimalFromSelf2 = /* @__PURE__ */ BigDecimalFromSelf2.pipe(/* @__PURE__ */ negativeBigDecimal2({
  identifier: "NegativeBigDecimalFromSelf",
  title: "NegativeBigDecimalFromSelf"
}));
var NonPositiveBigDecimalTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/NonPositiveBigDecimal");
var nonPositiveBigDecimal2 = (annotations5) => (self) => self.pipe(filter13((a) => a.value <= 0n, {
  typeId: {
    id: NonPositiveBigDecimalTypeId,
    annotation: {}
  },
  description: `a non-positive BigDecimal`,
  ...annotations5
}));
var NonPositiveBigDecimalFromSelf2 = /* @__PURE__ */ BigDecimalFromSelf2.pipe(/* @__PURE__ */ nonPositiveBigDecimal2({
  identifier: "NonPositiveBigDecimalFromSelf",
  title: "NonPositiveBigDecimalFromSelf"
}));
var BetweenBigDecimalTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/BetweenBigDecimal");
var betweenBigDecimal2 = (minimum, maximum, annotations5) => (self) => self.pipe(filter13((a) => between3(a, {
  minimum,
  maximum
}), {
  typeId: {
    id: BetweenBigDecimalTypeId,
    annotation: {
      maximum,
      minimum
    }
  },
  description: `a BigDecimal between ${format4(minimum)} and ${format4(maximum)}`,
  ...annotations5
}));
var clampBigDecimal2 = (minimum, maximum) => (self) => transform3(self, self.pipe(typeSchema2, betweenBigDecimal2(minimum, maximum)), {
  strict: false,
  decode: (self2) => clamp5(self2, {
    minimum,
    maximum
  }),
  encode: identity
});
var chunkArbitrary2 = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable3);
};
var chunkPretty2 = (item) => (c) => `Chunk(${toReadonlyArray(c).map(item).join(", ")})`;
var chunkParse2 = (decodeUnknown6) => (u, options, ast) => isChunk(u) ? isEmpty(u) ? succeed21(empty5()) : toComposite2(decodeUnknown6(toReadonlyArray(u), options), fromIterable3, ast, u) : fail20(new Type4(ast, u));
var ChunkFromSelf2 = (value3) => {
  return declare2([value3], {
    decode: (item) => chunkParse2(decodeUnknown4(Array$2(item))),
    encode: (item) => chunkParse2(encodeUnknown3(Array$2(item)))
  }, {
    description: `Chunk<${format7(value3)}>`,
    pretty: chunkPretty2,
    arbitrary: chunkArbitrary2,
    equivalence: getEquivalence4
  });
};
var Chunk2 = (value3) => {
  const value_ = asSchema2(value3);
  return transform3(Array$2(value_), ChunkFromSelf2(typeSchema2(value_)), {
    strict: true,
    decode: (as13) => as13.length === 0 ? empty5() : fromIterable3(as13),
    encode: toReadonlyArray
  });
};
var nonEmptyChunkArbitrary2 = (item) => (fc) => array5(item(fc), {
  minLength: 1
}).map((as13) => unsafeFromNonEmptyArray(as13));
var nonEmptyChunkPretty2 = (item) => (c) => `NonEmptyChunk(${toReadonlyArray(c).map(item).join(", ")})`;
var nonEmptyChunkParse2 = (decodeUnknown6) => (u, options, ast) => isChunk(u) && isNonEmpty(u) ? toComposite2(decodeUnknown6(toReadonlyArray(u), options), unsafeFromNonEmptyArray, ast, u) : fail20(new Type4(ast, u));
var NonEmptyChunkFromSelf2 = (value3) => {
  return declare2([value3], {
    decode: (item) => nonEmptyChunkParse2(decodeUnknown4(NonEmptyArray2(item))),
    encode: (item) => nonEmptyChunkParse2(encodeUnknown3(NonEmptyArray2(item)))
  }, {
    description: `NonEmptyChunk<${format7(value3)}>`,
    pretty: nonEmptyChunkPretty2,
    arbitrary: nonEmptyChunkArbitrary2,
    equivalence: getEquivalence4
  });
};
var NonEmptyChunk2 = (value3) => {
  const value_ = asSchema2(value3);
  return transform3(NonEmptyArray2(value_), NonEmptyChunkFromSelf2(typeSchema2(value_)), {
    strict: true,
    decode: unsafeFromNonEmptyArray,
    encode: toReadonlyArray
  });
};
var toData = (a) => Array.isArray(a) ? array3(a) : struct2(a);
var dataArbitrary2 = (item) => (fc) => item(fc).map(toData);
var dataPretty2 = (item) => (d) => `Data(${item(d)})`;
var dataParse2 = (decodeUnknown6) => (u, options, ast) => isEqual(u) ? toComposite2(decodeUnknown6(u, options), toData, ast, u) : fail20(new Type4(ast, u));
var DataFromSelf2 = (item) => declare2([item], {
  decode: (item2) => dataParse2(decodeUnknown4(item2)),
  encode: (item2) => dataParse2(encodeUnknown3(item2))
}, {
  description: `Data<${format7(item)}>`,
  pretty: dataPretty2,
  arbitrary: dataArbitrary2
});
var Data2 = (item) => transform3(item, DataFromSelf2(typeSchema2(item)), {
  strict: false,
  decode: toData,
  encode: (a) => Array.isArray(a) ? Array.from(a) : Object.assign({}, a)
});
var isField2 = (u) => isSchema2(u) || isPropertySignature2(u);
var isFields2 = (fields) => ownKeys2(fields).every((key) => isField2(fields[key]));
var getFields2 = (hasFields) => "fields" in hasFields ? hasFields.fields : getFields2(hasFields[refineTypeId]);
var getSchemaFromFieldsOr2 = (fieldsOr) => isFields2(fieldsOr) ? Struct2(fieldsOr) : isSchema2(fieldsOr) ? fieldsOr : Struct2(getFields2(fieldsOr));
var getFieldsFromFieldsOr2 = (fieldsOr) => isFields2(fieldsOr) ? fieldsOr : getFields2(fieldsOr);
var Class7 = (identifier2) => (fieldsOr, annotations5) => makeClass2({
  kind: "Class",
  identifier: identifier2,
  schema: getSchemaFromFieldsOr2(fieldsOr),
  fields: getFieldsFromFieldsOr2(fieldsOr),
  Base: Class4,
  annotations: annotations5
});
var getClassTag2 = (tag3) => withConstructorDefault2(propertySignature2(Literal4(tag3)), () => tag3);
var TaggedClass4 = (identifier2) => (tag3, fieldsOr, annotations5) => {
  var _a102;
  const fields = getFieldsFromFieldsOr2(fieldsOr);
  const schema = getSchemaFromFieldsOr2(fieldsOr);
  const newFields = {
    _tag: getClassTag2(tag3)
  };
  const taggedFields = extendFields2(newFields, fields);
  return _a102 = class extends makeClass2({
    kind: "TaggedClass",
    identifier: identifier2 ?? tag3,
    schema: extend4(schema, Struct2(newFields)),
    fields: taggedFields,
    Base: Class4,
    annotations: annotations5
  }) {
  }, __publicField(_a102, "_tag", tag3), _a102;
};
var TaggedError3 = (identifier2) => (tag3, fieldsOr, annotations5) => {
  var _a102;
  class Base3 extends Error3 {
  }
  ;
  Base3.prototype.name = tag3;
  const fields = getFieldsFromFieldsOr2(fieldsOr);
  const schema = getSchemaFromFieldsOr2(fieldsOr);
  const newFields = {
    _tag: getClassTag2(tag3)
  };
  const taggedFields = extendFields2(newFields, fields);
  return _a102 = class extends makeClass2({
    kind: "TaggedError",
    identifier: identifier2 ?? tag3,
    schema: extend4(schema, Struct2(newFields)),
    fields: taggedFields,
    Base: Base3,
    annotations: annotations5,
    disableToString: true
  }) {
    get message() {
      return `{ ${ownKeys2(fields).map((p) => `${formatPropertyKey3(p)}: ${formatUnknown2(this[p])}`).join(", ")} }`;
    }
  }, __publicField(_a102, "_tag", tag3), _a102;
};
var TaggedRequest2 = (identifier2) => (tag3, options, annotations5) => {
  var _a102;
  const taggedFields = extendFields2({
    _tag: getClassTag2(tag3)
  }, options.payload);
  return _a102 = class extends makeClass2({
    kind: "TaggedRequest",
    identifier: identifier2 ?? tag3,
    schema: Struct2(taggedFields),
    fields: taggedFields,
    Base: Class5,
    annotations: annotations5
  }) {
    get [symbol3]() {
      return this.constructor;
    }
    get [symbolResult]() {
      return {
        failure: options.failure,
        success: options.success
      };
    }
  }, __publicField(_a102, "_tag", tag3), __publicField(_a102, "success", options.success), __publicField(_a102, "failure", options.failure), _a102;
};
var extendFields2 = (a, b) => {
  const out = {
    ...a
  };
  for (const key of ownKeys2(b)) {
    if (key in a) {
      throw new Error(getASTDuplicatePropertySignatureErrorMessage2(key));
    }
    out[key] = b[key];
  }
  return out;
};
var orElseTitleAnnotation = (schema, title) => {
  const annotation = getTitleAnnotation2(schema.ast);
  if (isNone2(annotation)) {
    return schema.annotations({
      title
    });
  }
  return schema;
};
var getDisableValidationMakeOption2 = (options) => isBoolean(options) ? options : options?.disableValidation ?? false;
var makeClass2 = ({
  Base: Base3,
  annotations: annotations5,
  disableToString,
  fields,
  identifier: identifier2,
  kind,
  schema
}) => {
  var _a102, _b51;
  const classSymbol = Symbol.for(`@effect/schema/${kind}/${identifier2}`);
  const validateSchema = orElseTitleAnnotation(schema, `${identifier2} (Constructor)`);
  const encodedSide = orElseTitleAnnotation(schema, `${identifier2} (Encoded side)`);
  const typeSide = orElseTitleAnnotation(typeSchema2(schema), `${identifier2} (Type side)`);
  const fallbackInstanceOf = (u) => hasProperty(u, classSymbol) && is3(typeSide)(u);
  const klass = (_b51 = class extends Base3 {
    constructor(props = {}, options = false) {
      props = {
        ...props
      };
      if (kind !== "Class") {
        delete props["_tag"];
      }
      props = lazilyMergeDefaults2(fields, props);
      if (!getDisableValidationMakeOption2(options)) {
        props = validateSync2(validateSchema)(props);
      }
      super(props, true);
    }
    static get ast() {
      const declaration = declare2([typeSide], {
        decode: () => (input, _, ast) => input instanceof this || fallbackInstanceOf(input) ? succeed21(input) : fail20(new Type4(ast, input)),
        encode: () => (input, options) => input instanceof this ? succeed21(input) : map29(encodeUnknown3(typeSide)(input, options), (props) => new this(props, true))
      }, {
        identifier: identifier2,
        title: identifier2,
        description: `an instance of ${identifier2}`,
        pretty: (pretty5) => (self) => `${identifier2}(${pretty5(self)})`,
        // @ts-expect-error
        arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),
        equivalence: identity,
        [SurrogateAnnotationId2]: typeSide.ast,
        ...annotations5
      });
      const transformation = transform3(encodedSide, declaration, {
        strict: true,
        decode: (input) => new this(input, true),
        encode: identity
      }).annotations({
        [SurrogateAnnotationId2]: schema.ast
      });
      return transformation.ast;
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static annotations(annotations6) {
      return make67(this.ast).annotations(annotations6);
    }
    static toString() {
      return `(${String(encodedSide)} <-> ${identifier2})`;
    }
    // ----------------
    // Class interface
    // ----------------
    static make(...args2) {
      return new this(...args2);
    }
    static extend(identifier3) {
      return (newFieldsOr, annotations6) => {
        const newFields = getFieldsFromFieldsOr2(newFieldsOr);
        const newSchema = getSchemaFromFieldsOr2(newFieldsOr);
        const extendedFields = extendFields2(fields, newFields);
        return makeClass2({
          kind,
          identifier: identifier3,
          schema: extend4(schema, newSchema),
          fields: extendedFields,
          Base: this,
          annotations: annotations6
        });
      };
    }
    static transformOrFail(identifier3) {
      return (newFields, options, annotations6) => {
        const transformedFields = extendFields2(fields, newFields);
        return makeClass2({
          kind,
          identifier: identifier3,
          schema: transformOrFail2(schema, typeSchema2(Struct2(transformedFields)), options),
          fields: transformedFields,
          Base: this,
          annotations: annotations6
        });
      };
    }
    static transformOrFailFrom(identifier3) {
      return (newFields, options, annotations6) => {
        const transformedFields = extendFields2(fields, newFields);
        return makeClass2({
          kind,
          identifier: identifier3,
          schema: transformOrFail2(encodedSchema2(schema), Struct2(transformedFields), options),
          fields: transformedFields,
          Base: this,
          annotations: annotations6
        });
      };
    }
    // ----------------
    // other
    // ----------------
    get [(_a102 = TypeId25, classSymbol)]() {
      return classSymbol;
    }
  }, // ----------------
  // Schema interface
  // ----------------
  __publicField(_b51, _a102, variance8), __publicField(_b51, "fields", {
    ...fields
  }), __publicField(_b51, "identifier", identifier2), _b51);
  if (disableToString !== true) {
    Object.defineProperty(klass.prototype, "toString", {
      value() {
        return `${identifier2}({ ${ownKeys2(fields).map((p) => `${formatPropertyKey3(p)}: ${formatUnknown2(this[p])}`).join(", ")} })`;
      },
      configurable: true
    });
  }
  return klass;
};
var FiberIdNoneEncoded2 = /* @__PURE__ */ Struct2({
  _tag: Literal4("None")
}).annotations({
  identifier: "FiberIdNoneEncoded"
});
var FiberIdRuntimeEncoded2 = /* @__PURE__ */ Struct2({
  _tag: Literal4("Runtime"),
  id: Int2.annotations({
    title: "id",
    description: "id"
  }),
  startTimeMillis: Int2.annotations({
    title: "startTimeMillis",
    description: "startTimeMillis"
  })
}).annotations({
  identifier: "FiberIdRuntimeEncoded"
});
var FiberIdCompositeEncoded2 = /* @__PURE__ */ Struct2({
  _tag: Literal4("Composite"),
  left: suspend14(() => FiberIdEncoded2),
  right: suspend14(() => FiberIdEncoded2)
}).annotations({
  identifier: "FiberIdCompositeEncoded"
});
var FiberIdEncoded2 = /* @__PURE__ */ Union4(FiberIdNoneEncoded2, FiberIdRuntimeEncoded2, FiberIdCompositeEncoded2).annotations({
  identifier: "FiberIdEncoded"
});
var fiberIdArbitrary2 = (fc) => fc.letrec((tie) => ({
  None: fc.record({
    _tag: fc.constant("None")
  }),
  Runtime: fc.record({
    _tag: fc.constant("Runtime"),
    id: fc.integer(),
    startTimeMillis: fc.integer()
  }),
  Composite: fc.record({
    _tag: fc.constant("Composite"),
    left: tie("FiberId"),
    right: tie("FiberId")
  }),
  FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
})).FiberId.map(fiberIdDecode2);
var fiberIdPretty2 = (fiberId3) => {
  switch (fiberId3._tag) {
    case "None":
      return "FiberId.none";
    case "Runtime":
      return `FiberId.runtime(${fiberId3.id}, ${fiberId3.startTimeMillis})`;
    case "Composite":
      return `FiberId.composite(${fiberIdPretty2(fiberId3.right)}, ${fiberIdPretty2(fiberId3.left)})`;
  }
};
var FiberIdFromSelf2 = class extends (/* @__PURE__ */ declare2(isFiberId2, {
  identifier: "FiberIdFromSelf",
  pretty: () => fiberIdPretty2,
  arbitrary: () => fiberIdArbitrary2
})) {
};
var fiberIdDecode2 = (input) => {
  switch (input._tag) {
    case "None":
      return none4;
    case "Runtime":
      return runtime2(input.id, input.startTimeMillis);
    case "Composite":
      return composite2(fiberIdDecode2(input.left), fiberIdDecode2(input.right));
  }
};
var fiberIdEncode2 = (input) => {
  switch (input._tag) {
    case "None":
      return {
        _tag: "None"
      };
    case "Runtime":
      return {
        _tag: "Runtime",
        id: input.id,
        startTimeMillis: input.startTimeMillis
      };
    case "Composite":
      return {
        _tag: "Composite",
        left: fiberIdEncode2(input.left),
        right: fiberIdEncode2(input.right)
      };
  }
};
var FiberId2 = class extends (/* @__PURE__ */ transform3(FiberIdEncoded2, FiberIdFromSelf2, {
  strict: true,
  decode: fiberIdDecode2,
  encode: fiberIdEncode2
}).annotations({
  identifier: "FiberId"
})) {
};
var causeDieEncoded2 = (defect) => Struct2({
  _tag: Literal4("Die"),
  defect
});
var CauseEmptyEncoded2 = /* @__PURE__ */ Struct2({
  _tag: /* @__PURE__ */ Literal4("Empty")
});
var causeFailEncoded2 = (error2) => Struct2({
  _tag: Literal4("Fail"),
  error: error2
});
var CauseInterruptEncoded2 = /* @__PURE__ */ Struct2({
  _tag: /* @__PURE__ */ Literal4("Interrupt"),
  fiberId: FiberIdEncoded2
});
var causeParallelEncoded = (causeEncoded3) => Struct2({
  _tag: Literal4("Parallel"),
  left: causeEncoded3,
  right: causeEncoded3
});
var causeSequentialEncoded = (causeEncoded3) => Struct2({
  _tag: Literal4("Sequential"),
  left: causeEncoded3,
  right: causeEncoded3
});
var causeEncoded2 = (error2, defect) => {
  const recur = suspend14(() => out);
  const out = Union4(CauseEmptyEncoded2, causeFailEncoded2(error2), causeDieEncoded2(defect), CauseInterruptEncoded2, causeSequentialEncoded(recur), causeParallelEncoded(recur)).annotations({
    title: `CauseEncoded<${format7(error2)}>`
  });
  return out;
};
var causeArbitrary2 = (error2, defect) => (fc) => fc.letrec((tie) => ({
  Empty: fc.record({
    _tag: fc.constant("Empty")
  }),
  Fail: fc.record({
    _tag: fc.constant("Fail"),
    error: error2(fc)
  }),
  Die: fc.record({
    _tag: fc.constant("Die"),
    defect: defect(fc)
  }),
  Interrupt: fc.record({
    _tag: fc.constant("Interrupt"),
    fiberId: fiberIdArbitrary2(fc)
  }),
  Sequential: fc.record({
    _tag: fc.constant("Sequential"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Parallel: fc.record({
    _tag: fc.constant("Parallel"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
})).Cause.map(causeDecode2);
var causePretty2 = (error2) => (cause3) => {
  const f = (cause4) => {
    switch (cause4._tag) {
      case "Empty":
        return "Cause.empty";
      case "Fail":
        return `Cause.fail(${error2(cause4.error)})`;
      case "Die":
        return `Cause.die(${pretty3(cause4)})`;
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty2(cause4.fiberId)})`;
      case "Sequential":
        return `Cause.sequential(${f(cause4.left)}, ${f(cause4.right)})`;
      case "Parallel":
        return `Cause.parallel(${f(cause4.left)}, ${f(cause4.right)})`;
    }
  };
  return f(cause3);
};
var causeParse2 = (decodeUnknown6) => (u, options, ast) => isCause2(u) ? toComposite2(decodeUnknown6(causeEncode2(u), options), causeDecode2, ast, u) : fail20(new Type4(ast, u));
var CauseFromSelf2 = ({
  defect,
  error: error2
}) => {
  return declare2([error2, defect], {
    decode: (error3, defect2) => causeParse2(decodeUnknown4(causeEncoded2(error3, defect2))),
    encode: (error3, defect2) => causeParse2(encodeUnknown3(causeEncoded2(error3, defect2)))
  }, {
    title: `Cause<${error2.ast}>`,
    pretty: causePretty2,
    arbitrary: causeArbitrary2
  });
};
function causeDecode2(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return empty26;
    case "Fail":
      return fail6(cause3.error);
    case "Die":
      return die4(cause3.defect);
    case "Interrupt":
      return interrupt5(fiberIdDecode2(cause3.fiberId));
    case "Sequential":
      return sequential4(causeDecode2(cause3.left), causeDecode2(cause3.right));
    case "Parallel":
      return parallel4(causeDecode2(cause3.left), causeDecode2(cause3.right));
  }
}
function causeEncode2(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause3.error
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause3.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause3.fiberId
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode2(cause3.left),
        right: causeEncode2(cause3.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode2(cause3.left),
        right: causeEncode2(cause3.right)
      };
  }
}
var Cause2 = ({
  defect,
  error: error2
}) => {
  const error_ = asSchema2(error2);
  const defect_ = asSchema2(defect);
  return transform3(causeEncoded2(error_, defect_), CauseFromSelf2({
    error: typeSchema2(error_),
    defect: Unknown2
  }), {
    strict: false,
    decode: causeDecode2,
    encode: causeEncode2
  });
};
var Defect2 = /* @__PURE__ */ transform3(Unknown2, Unknown2, {
  strict: true,
  decode: (u) => {
    if (isObject(u) && "message" in u && typeof u.message === "string") {
      const err = new Error(u.message, {
        cause: u
      });
      if ("name" in u && typeof u.name === "string") {
        err.name = u.name;
      }
      err.stack = "stack" in u && typeof u.stack === "string" ? u.stack : "";
      return err;
    }
    return String(u);
  },
  encode: (defect) => {
    if (defect instanceof Error) {
      return {
        name: defect.name,
        message: defect.message
        // no stack because of security reasons
      };
    }
    return String(defect);
  }
}).annotations({
  identifier: "Defect"
});
var exitFailureEncoded2 = (error2, defect) => Struct2({
  _tag: Literal4("Failure"),
  cause: causeEncoded2(error2, defect)
});
var exitSuccessEncoded2 = (value3) => Struct2({
  _tag: Literal4("Success"),
  value: value3
});
var exitEncoded2 = (value3, error2, defect) => Union4(exitFailureEncoded2(error2, defect), exitSuccessEncoded2(value3)).annotations({
  title: `ExitEncoded<${format7(value3)}, ${format7(error2)}, ${format7(defect)}>`
});
var exitDecode2 = (input) => {
  switch (input._tag) {
    case "Failure":
      return failCause4(causeDecode2(input.cause));
    case "Success":
      return succeed4(input.value);
  }
};
var exitArbitrary2 = (value3, error2, defect) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Failure"),
  cause: causeArbitrary2(error2, defect)(fc)
}), fc.record({
  _tag: fc.constant("Success"),
  value: value3(fc)
})).map(exitDecode2);
var exitPretty2 = (value3, error2) => (exit4) => exit4._tag === "Failure" ? `Exit.failCause(${causePretty2(error2)(exit4.cause)})` : `Exit.succeed(${value3(exit4.value)})`;
var exitParse2 = (decodeUnknownValue, decodeUnknownCause) => (u, options, ast) => isExit(u) ? match9(u, {
  onFailure: (cause3) => toComposite2(decodeUnknownCause(cause3, options), failCause4, ast, u),
  onSuccess: (value3) => toComposite2(decodeUnknownValue(value3, options), succeed4, ast, u)
}) : fail20(new Type4(ast, u));
var ExitFromSelf2 = ({
  defect,
  failure,
  success
}) => declare2([success, failure, defect], {
  decode: (success2, failure2, defect2) => exitParse2(decodeUnknown4(success2), decodeUnknown4(CauseFromSelf2({
    error: failure2,
    defect: defect2
  }))),
  encode: (success2, failure2, defect2) => exitParse2(encodeUnknown3(success2), encodeUnknown3(CauseFromSelf2({
    error: failure2,
    defect: defect2
  })))
}, {
  title: `Exit<${success.ast}, ${failure.ast}>`,
  pretty: exitPretty2,
  arbitrary: exitArbitrary2
});
var Exit2 = ({
  defect,
  failure,
  success
}) => {
  const success_ = asSchema2(success);
  const failure_ = asSchema2(failure);
  const defect_ = asSchema2(defect);
  return transform3(exitEncoded2(success_, failure_, defect_), ExitFromSelf2({
    failure: typeSchema2(failure_),
    success: typeSchema2(success_),
    defect: Unknown2
  }), {
    strict: false,
    decode: exitDecode2,
    encode: (exit4) => exit4._tag === "Failure" ? {
      _tag: "Failure",
      cause: exit4.cause
    } : {
      _tag: "Success",
      value: exit4.value
    }
  });
};
var hashSetArbitrary2 = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable6);
};
var hashSetPretty2 = (item) => (set10) => `HashSet(${Array.from(set10).map((a) => item(a)).join(", ")})`;
var hashSetEquivalence2 = (item) => {
  const arrayEquivalence = getEquivalence3(item);
  return make3((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
var hashSetParse2 = (decodeUnknown6) => (u, options, ast) => isHashSet2(u) ? toComposite2(decodeUnknown6(Array.from(u), options), fromIterable6, ast, u) : fail20(new Type4(ast, u));
var HashSetFromSelf2 = (value3) => {
  return declare2([value3], {
    decode: (item) => hashSetParse2(decodeUnknown4(Array$2(item))),
    encode: (item) => hashSetParse2(encodeUnknown3(Array$2(item)))
  }, {
    description: `HashSet<${format7(value3)}>`,
    pretty: hashSetPretty2,
    arbitrary: hashSetArbitrary2,
    equivalence: hashSetEquivalence2
  });
};
var HashSet2 = (value3) => {
  const value_ = asSchema2(value3);
  return transform3(Array$2(value_), HashSetFromSelf2(typeSchema2(value_)), {
    strict: true,
    decode: (as13) => fromIterable6(as13),
    encode: (set10) => Array.from(set10)
  });
};
var hashMapArbitrary2 = (key, value3, ctx) => (fc) => {
  const items = fc.array(fc.tuple(key(fc), value3(fc)));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable7);
};
var hashMapPretty2 = (key, value3) => (map31) => `HashMap([${Array.from(map31).map(([k, v]) => `[${key(k)}, ${value3(v)}]`).join(", ")}])`;
var hashMapEquivalence2 = (key, value3) => {
  const arrayEquivalence = getEquivalence3(make3(([ka, va], [kb, vb]) => key(ka, kb) && value3(va, vb)));
  return make3((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
var hashMapParse2 = (decodeUnknown6) => (u, options, ast) => isHashMap2(u) ? toComposite2(decodeUnknown6(Array.from(u), options), fromIterable7, ast, u) : fail20(new Type4(ast, u));
var HashMapFromSelf2 = ({
  key,
  value: value3
}) => {
  return declare2([key, value3], {
    decode: (key2, value4) => hashMapParse2(decodeUnknown4(Array$2(Tuple2(key2, value4)))),
    encode: (key2, value4) => hashMapParse2(encodeUnknown3(Array$2(Tuple2(key2, value4))))
  }, {
    description: `HashMap<${format7(key)}, ${format7(value3)}>`,
    pretty: hashMapPretty2,
    arbitrary: hashMapArbitrary2,
    equivalence: hashMapEquivalence2
  });
};
var HashMap2 = ({
  key,
  value: value3
}) => {
  const key_ = asSchema2(key);
  const value_ = asSchema2(value3);
  return transform3(Array$2(Tuple2(key_, value_)), HashMapFromSelf2({
    key: typeSchema2(key_),
    value: typeSchema2(value_)
  }), {
    strict: true,
    decode: (as13) => fromIterable7(as13),
    encode: (map31) => Array.from(map31)
  });
};
var listArbitrary2 = (item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable8);
};
var listPretty2 = (item) => (set10) => `List(${Array.from(set10).map((a) => item(a)).join(", ")})`;
var listEquivalence2 = (item) => {
  const arrayEquivalence = getEquivalence3(item);
  return make3((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
var listParse2 = (decodeUnknown6) => (u, options, ast) => isList(u) ? toComposite2(decodeUnknown6(Array.from(u), options), fromIterable8, ast, u) : fail20(new Type4(ast, u));
var ListFromSelf2 = (value3) => {
  return declare2([value3], {
    decode: (item) => listParse2(decodeUnknown4(Array$2(item))),
    encode: (item) => listParse2(encodeUnknown3(Array$2(item)))
  }, {
    description: `List<${format7(value3)}>`,
    pretty: listPretty2,
    arbitrary: listArbitrary2,
    equivalence: listEquivalence2
  });
};
var List2 = (value3) => {
  const value_ = asSchema2(value3);
  return transform3(Array$2(value_), ListFromSelf2(typeSchema2(value_)), {
    strict: true,
    decode: (as13) => fromIterable8(as13),
    encode: (set10) => Array.from(set10)
  });
};
var sortedSetArbitrary2 = (item, ord, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as13) => fromIterable12(as13, ord));
};
var sortedSetPretty2 = (item) => (set10) => `new SortedSet([${Array.from(values4(set10)).map((a) => item(a)).join(", ")}])`;
var sortedSetParse2 = (decodeUnknown6, ord) => (u, options, ast) => isSortedSet(u) ? toComposite2(decodeUnknown6(Array.from(values4(u)), options), (as13) => fromIterable12(as13, ord), ast, u) : fail20(new Type4(ast, u));
var SortedSetFromSelf2 = (value3, ordA, ordI) => {
  return declare2([value3], {
    decode: (item) => sortedSetParse2(decodeUnknown4(Array$2(item)), ordA),
    encode: (item) => sortedSetParse2(encodeUnknown3(Array$2(item)), ordI)
  }, {
    description: `SortedSet<${format7(value3)}>`,
    pretty: sortedSetPretty2,
    arbitrary: (arb, ctx) => sortedSetArbitrary2(arb, ordA, ctx),
    equivalence: () => getEquivalence6()
  });
};
var SortedSet2 = (value3, ordA) => {
  const value_ = asSchema2(value3);
  const to = typeSchema2(value_);
  return transform3(Array$2(value_), SortedSetFromSelf2(to, ordA, ordA), {
    strict: true,
    decode: (as13) => fromIterable12(as13, ordA),
    encode: (set10) => Array.from(values4(set10))
  });
};
var BooleanFromUnknown2 = class extends (/* @__PURE__ */ transform3(Unknown2, Boolean$2, {
  strict: true,
  decode: isTruthy,
  encode: identity
}).annotations({
  identifier: "BooleanFromUnknown"
})) {
};
var Config2 = (name, schema) => {
  const decodeEither_ = decodeEither2(schema);
  return string3(name).pipe(mapOrFail2((a) => decodeEither_(a).pipe(mapLeft((error2) => InvalidData2([], formatErrorSync(error2))))));
};

// ../../packages/ai/src/config/ClaudeCodeConfig.ts
var ClaudeCodeConfigSchema = Schema_exports3.Struct({
  /** Model to use (defaults to claude-3-opus-20240229) */
  model: Schema_exports3.optional(Schema_exports3.String),
  /** Custom system prompt to prepend */
  systemPrompt: Schema_exports3.optional(Schema_exports3.String),
  /** Additional system prompt to append */
  appendSystemPrompt: Schema_exports3.optional(Schema_exports3.String),
  /** Output format preference */
  outputFormat: Schema_exports3.optional(Schema_exports3.Literal("text", "json", "json_stream")),
  /** Path to claude CLI executable (defaults to 'claude' in PATH) */
  cliPath: Schema_exports3.optional(Schema_exports3.String),
  /** Allowed MCP tools (empty array means all allowed) */
  allowedTools: Schema_exports3.optional(Schema_exports3.Array(Schema_exports3.String)),
  /** Default timeout for commands in milliseconds */
  defaultTimeout: Schema_exports3.optional(Schema_exports3.Number)
});
var ClaudeCodeConfig = Context_exports.GenericTag("ai/ClaudeCodeConfig");
var ClaudeCodeConfigDefault = Layer_exports.succeed(
  ClaudeCodeConfig,
  {
    model: "claude-3-opus-20240229",
    outputFormat: "json",
    cliPath: "claude",
    allowedTools: [],
    defaultTimeout: 6e4
    // 60 seconds
  }
);

// ../../packages/ai/src/errors/index.ts
var ClaudeCodeNotFoundError = class extends Data_exports.TaggedError("ClaudeCodeNotFoundError") {
};
var ClaudeCodeExecutionError = class extends Data_exports.TaggedError("ClaudeCodeExecutionError") {
};
var ClaudeCodeParseError = class extends Data_exports.TaggedError("ClaudeCodeParseError") {
};
var ClaudeCodeSessionError = class extends Data_exports.TaggedError("ClaudeCodeSessionError") {
};
var ClaudeCodeInitError = class extends Data_exports.TaggedError("ClaudeCodeInitError") {
};
var ClaudeCodeError = class extends Data_exports.TaggedError("ClaudeCodeError") {
};

// ../../packages/ai/src/providers/ClaudeCodeClient.ts
var ClaudeCodeJsonResponse = Schema_exports3.Struct({
  content: Schema_exports3.String,
  model: Schema_exports3.String,
  stop_reason: Schema_exports3.optional(Schema_exports3.String),
  session_id: Schema_exports3.optional(Schema_exports3.String),
  usage: Schema_exports3.optional(Schema_exports3.Struct({
    input_tokens: Schema_exports3.Number,
    output_tokens: Schema_exports3.Number,
    total_tokens: Schema_exports3.Number
  })),
  metadata: Schema_exports3.optional(Schema_exports3.Struct({
    cost_usd: Schema_exports3.optional(Schema_exports3.Number),
    duration_ms: Schema_exports3.optional(Schema_exports3.Number),
    num_turns: Schema_exports3.optional(Schema_exports3.Number)
  }))
});
var ClaudeCodeClient = Context_exports.GenericTag("ai/ClaudeCodeClient");

// ../../node_modules/.pnpm/@effect+platform@0.84.6_effect@3.16.3/node_modules/@effect/platform/dist/esm/Command.js
var Command_exports = {};
__export(Command_exports, {
  CommandTypeId: () => CommandTypeId2,
  env: () => env2,
  exitCode: () => exitCode2,
  feed: () => feed2,
  flatten: () => flatten18,
  isCommand: () => isCommand2,
  lines: () => lines2,
  make: () => make69,
  pipeTo: () => pipeTo3,
  runInShell: () => runInShell2,
  start: () => start4,
  stderr: () => stderr2,
  stdin: () => stdin2,
  stdout: () => stdout2,
  stream: () => stream3,
  streamLines: () => streamLines2,
  string: () => string6,
  workingDirectory: () => workingDirectory2
});

// ../../node_modules/.pnpm/@effect+platform@0.84.6_effect@3.16.3/node_modules/@effect/platform/dist/esm/internal/commandExecutor.js
var TypeId26 = /* @__PURE__ */ Symbol.for("@effect/platform/CommandExecutor");
var ProcessTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Process");
var ExitCode = /* @__PURE__ */ nominal();
var ProcessId = /* @__PURE__ */ nominal();
var CommandExecutor = /* @__PURE__ */ GenericTag("@effect/platform/CommandExecutor");
var makeExecutor = (start5) => {
  const stream4 = (command) => unwrapScoped5(map18(start5(command), (process2) => process2.stdout));
  const streamLines3 = (command, encoding) => {
    const decoder2 = new TextDecoder(encoding);
    return splitLines3(mapChunks2(stream4(command), map4((bytes3) => decoder2.decode(bytes3))));
  };
  return {
    [TypeId26]: TypeId26,
    start: start5,
    exitCode: (command) => scoped3(flatMap12(start5(command), (process2) => process2.exitCode)),
    stream: stream4,
    string: (command, encoding = "utf-8") => {
      const decoder2 = new TextDecoder(encoding);
      return pipe(start5(command), flatMap12((process2) => run5(process2.stdout, collectUint8Array)), map18((bytes3) => decoder2.decode(bytes3)), scoped3);
    },
    lines: (command, encoding = "utf-8") => {
      return pipe(streamLines3(command, encoding), runCollect2, map18(toArray2));
    },
    streamLines: streamLines3
  };
};
var collectUint8Array = /* @__PURE__ */ foldLeftChunks2(/* @__PURE__ */ new Uint8Array(), (bytes3, chunk4) => reduce2(chunk4, bytes3, (acc, curr) => {
  const newArray = new Uint8Array(acc.length + curr.length);
  newArray.set(acc);
  newArray.set(curr, acc.length);
  return newArray;
}));

// ../../node_modules/.pnpm/@effect+platform@0.84.6_effect@3.16.3/node_modules/@effect/platform/dist/esm/internal/command.js
var CommandTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Command");
var isCommand = (u) => typeof u === "object" && u != null && CommandTypeId in u;
var env = /* @__PURE__ */ dual(2, (self, environment2) => {
  switch (self._tag) {
    case "StandardCommand": {
      return makeStandard({
        ...self,
        env: union6(self.env, fromIterable7(Object.entries(environment2).filter(([v]) => v !== void 0)))
      });
    }
    case "PipedCommand": {
      return pipeTo2(env(self.left, environment2), env(self.right, environment2));
    }
  }
});
var exitCode = (self) => flatMap12(CommandExecutor, (executor) => executor.exitCode(self));
var feed = /* @__PURE__ */ dual(2, (self, input) => stdin(self, fromChunk2(of2(new TextEncoder().encode(input)))));
var flatten17 = (self) => Array.from(flattenLoop(self));
var flattenLoop = (self) => {
  switch (self._tag) {
    case "StandardCommand": {
      return of2(self);
    }
    case "PipedCommand": {
      return appendAll2(flattenLoop(self.left), flattenLoop(self.right));
    }
  }
};
var runInShell = /* @__PURE__ */ dual(2, (self, shell) => {
  switch (self._tag) {
    case "StandardCommand": {
      return makeStandard({
        ...self,
        shell
      });
    }
    case "PipedCommand": {
      return pipeTo2(runInShell(self.left, shell), runInShell(self.right, shell));
    }
  }
});
var lines = (command, encoding = "utf-8") => flatMap12(CommandExecutor, (executor) => executor.lines(command, encoding));
var Proto3 = {
  [CommandTypeId]: CommandTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...BaseProto
};
var StandardProto = {
  ...Proto3,
  _tag: "StandardCommand",
  toJSON() {
    return {
      _id: "@effect/platform/Command",
      _tag: this._tag,
      command: this.command,
      args: this.args,
      env: Object.fromEntries(this.env),
      cwd: this.cwd.toJSON(),
      shell: this.shell,
      gid: this.gid.toJSON(),
      uid: this.uid.toJSON()
    };
  }
};
var makeStandard = (options) => Object.assign(Object.create(StandardProto), options);
var PipedProto = {
  ...Proto3,
  _tag: "PipedCommand",
  toJSON() {
    return {
      _id: "@effect/platform/Command",
      _tag: this._tag,
      left: this.left.toJSON(),
      right: this.right.toJSON()
    };
  }
};
var makePiped = (options) => Object.assign(Object.create(PipedProto), options);
var make68 = (command, ...args2) => makeStandard({
  command,
  args: args2,
  env: empty10(),
  cwd: none2(),
  shell: false,
  stdin: "pipe",
  stdout: "pipe",
  stderr: "pipe",
  gid: none2(),
  uid: none2()
});
var pipeTo2 = /* @__PURE__ */ dual(2, (self, into) => makePiped({
  left: self,
  right: into
}));
var stderr = /* @__PURE__ */ dual(2, (self, output3) => {
  switch (self._tag) {
    case "StandardCommand": {
      return makeStandard({
        ...self,
        stderr: output3
      });
    }
    // For piped commands it only makes sense to provide `stderr` for the
    // right-most command as the rest will be piped in.
    case "PipedCommand": {
      return makePiped({
        ...self,
        right: stderr(self.right, output3)
      });
    }
  }
});
var stdin = /* @__PURE__ */ dual(2, (self, input) => {
  switch (self._tag) {
    case "StandardCommand": {
      return makeStandard({
        ...self,
        stdin: input
      });
    }
    // For piped commands it only makes sense to provide `stdin` for the
    // left-most command as the rest will be piped in.
    case "PipedCommand": {
      return makePiped({
        ...self,
        left: stdin(self.left, input)
      });
    }
  }
});
var stdout = /* @__PURE__ */ dual(2, (self, output3) => {
  switch (self._tag) {
    case "StandardCommand": {
      return makeStandard({
        ...self,
        stdout: output3
      });
    }
    // For piped commands it only makes sense to provide `stderr` for the
    // right-most command as the rest will be piped in.
    case "PipedCommand": {
      return makePiped({
        ...self,
        right: stdout(self.right, output3)
      });
    }
  }
});
var start3 = (command) => flatMap12(CommandExecutor, (executor) => executor.start(command));
var stream2 = (command) => flatMap18(CommandExecutor, (executor) => executor.stream(command));
var streamLines = (command, encoding) => flatMap18(CommandExecutor, (executor) => executor.streamLines(command, encoding));
var string5 = /* @__PURE__ */ dual((args2) => isCommand(args2[0]), (command, encoding) => flatMap12(CommandExecutor, (executor) => executor.string(command, encoding)));
var workingDirectory = /* @__PURE__ */ dual(2, (self, cwd) => {
  switch (self._tag) {
    case "StandardCommand": {
      return makeStandard({
        ...self,
        cwd: some2(cwd)
      });
    }
    case "PipedCommand": {
      return pipeTo2(workingDirectory(self.left, cwd), workingDirectory(self.right, cwd));
    }
  }
});

// ../../node_modules/.pnpm/@effect+platform@0.84.6_effect@3.16.3/node_modules/@effect/platform/dist/esm/Command.js
var CommandTypeId2 = CommandTypeId;
var isCommand2 = isCommand;
var env2 = env;
var exitCode2 = exitCode;
var feed2 = feed;
var flatten18 = flatten17;
var lines2 = lines;
var make69 = make68;
var pipeTo3 = pipeTo2;
var runInShell2 = runInShell;
var start4 = start3;
var stream3 = stream2;
var streamLines2 = streamLines;
var string6 = string5;
var stderr2 = stderr;
var stdin2 = stdin;
var stdout2 = stdout;
var workingDirectory2 = workingDirectory;

// ../../node_modules/.pnpm/@effect+platform@0.84.6_effect@3.16.3/node_modules/@effect/platform/dist/esm/CommandExecutor.js
var CommandExecutor_exports = {};
__export(CommandExecutor_exports, {
  CommandExecutor: () => CommandExecutor2,
  ExitCode: () => ExitCode2,
  ProcessId: () => ProcessId2,
  ProcessTypeId: () => ProcessTypeId2,
  TypeId: () => TypeId27,
  makeExecutor: () => makeExecutor2
});
var TypeId27 = TypeId26;
var CommandExecutor2 = CommandExecutor;
var ProcessTypeId2 = ProcessTypeId;
var ExitCode2 = ExitCode;
var ProcessId2 = ProcessId;
var makeExecutor2 = makeExecutor;

// ../../packages/ai/src/providers/ClaudeCodeSimple.ts
var makeClaudeCodeClient = (config2, executor) => {
  const executeCommand = (args2, timeout5) => Effect_exports.gen(function* () {
    const command = Command_exports.make(config2.cliPath ?? "claude", ...args2).pipe(
      Command_exports.env({
        CI: "true",
        TERM: "dumb",
        NO_COLOR: "1",
        NODE_NO_READLINE: "1"
      })
    );
    const result = yield* executor.start(command);
    const output3 = yield* result.stdout.pipe(
      Stream_exports.decodeText(),
      Stream_exports.runFold("", (acc, chunk4) => acc + chunk4)
    );
    const exitCode3 = yield* result.exitCode;
    if (exitCode3 !== 0) {
      const stderr3 = yield* result.stderr.pipe(
        Stream_exports.decodeText(),
        Stream_exports.runFold("", (acc, chunk4) => acc + chunk4)
      );
      return yield* Effect_exports.fail(
        new ClaudeCodeExecutionError({
          command: `${config2.cliPath ?? "claude"} ${args2.join(" ")}`,
          exitCode: exitCode3,
          stderr: stderr3
        })
      );
    }
    return output3;
  }).pipe(
    // Add timeout if specified (default to 30 seconds)
    Effect_exports.timeout(timeout5 ?? 3e4),
    Effect_exports.mapError((error2) => {
      if (error2._tag === "TimeoutException") {
        return new ClaudeCodeExecutionError({
          command: `${config2.cliPath ?? "claude"} ${args2.join(" ")}`,
          exitCode: -1,
          stderr: "Command timed out"
        });
      }
      return error2;
    })
  );
  const parseOutput = (output3, format8) => {
    if (format8 === "text") {
      return Effect_exports.succeed({
        content: output3.trim()
      });
    }
    return Effect_exports.try({
      try: () => {
        const lines3 = output3.trim().split("\n");
        for (let i = lines3.length - 1; i >= 0; i--) {
          try {
            const parsed = JSON.parse(lines3[i]);
            return Schema_exports3.decodeUnknownSync(ClaudeCodeJsonResponse)(parsed);
          } catch {
          }
        }
        throw new Error("No valid JSON found in output");
      },
      catch: (error2) => new ClaudeCodeParseError({
        output: output3,
        format: format8,
        cause: error2
      })
    });
  };
  return {
    prompt: (text, options) => Effect_exports.gen(function* () {
      const args2 = ["--print", text];
      if (options?.outputFormat) args2.push("--output-format", options.outputFormat);
      const output3 = yield* executeCommand(args2, options?.timeout);
      const format8 = options?.outputFormat ?? config2.outputFormat ?? "text";
      const parsed = yield* parseOutput(output3, format8);
      return parsed;
    }),
    continueSession: (sessionId, prompt, options) => Effect_exports.gen(function* () {
      const args2 = ["--resume", sessionId, "--print", prompt];
      if (options?.outputFormat) args2.push("--output-format", options.outputFormat);
      const output3 = yield* executeCommand(args2, options?.timeout);
      const format8 = options?.outputFormat ?? config2.outputFormat ?? "text";
      return yield* parseOutput(output3, format8);
    }),
    continueRecent: (prompt, options) => Effect_exports.gen(function* () {
      const args2 = ["--continue", "--print", prompt];
      if (options?.outputFormat) args2.push("--output-format", options.outputFormat);
      const output3 = yield* executeCommand(args2, options?.timeout);
      const format8 = options?.outputFormat ?? config2.outputFormat ?? "text";
      return yield* parseOutput(output3, format8);
    }),
    streamPrompt: (text, _options) => Stream_exports.unwrapScoped(
      Effect_exports.gen(function* () {
        const args2 = ["--print", text, "--output-format", "json_stream"];
        const command = Command_exports.make(config2.cliPath ?? "claude", ...args2);
        const process2 = yield* Command_exports.start(command).pipe(
          Effect_exports.provideService(CommandExecutor_exports.CommandExecutor, executor)
        );
        return process2.stdout.pipe(
          Stream_exports.decodeText(),
          Stream_exports.splitLines,
          Stream_exports.filter((line) => line.trim().length > 0),
          Stream_exports.mapEffect(
            (line) => Effect_exports.try(() => {
              const parsed = JSON.parse(line);
              return parsed.content || "";
            }).pipe(
              Effect_exports.mapError(
                () => new ClaudeCodeExecutionError({
                  command: `${config2.cliPath} ${args2.join(" ")}`,
                  exitCode: -1,
                  stderr: `Failed to parse streaming output: ${line}`
                })
              )
            )
          )
        );
      })
    ),
    checkAvailability: () => Effect_exports.gen(function* () {
      const command = Command_exports.make(config2.cliPath ?? "claude", "--version");
      const result = yield* executor.start(command);
      const exitCode3 = yield* result.exitCode;
      return exitCode3 === 0;
    }).pipe(
      Effect_exports.catchAll(() => Effect_exports.succeed(false))
    )
  };
};
var ClaudeCodeClientLive = Layer_exports.effect(
  ClaudeCodeClient,
  Effect_exports.gen(function* () {
    const config2 = yield* ClaudeCodeConfig;
    const executor = yield* CommandExecutor_exports.CommandExecutor;
    return makeClaudeCodeClient(config2, executor);
  })
);

// ../../packages/ai/src/providers/ClaudeCodeProvider.ts
var ClaudeCodeProviderLive = Layer_exports.effect(
  AiService,
  Effect_exports.gen(function* () {
    const claude = yield* ClaudeCodeClient;
    return {
      hello: (name) => Effect_exports.succeed(`Hello ${name} from Claude Code!`),
      complete: (prompt) => Effect_exports.gen(function* () {
        const isAvailable = yield* claude.checkAvailability().pipe(
          Effect_exports.catchTag("ClaudeCodeNotFoundError", () => Effect_exports.succeed(false))
        );
        if (!isAvailable) {
          return {
            content: "Claude Code CLI is not available. Please ensure 'claude' is installed and in your PATH.",
            model: "error",
            usage: {
              promptTokens: 0,
              completionTokens: 0,
              totalTokens: 0
            }
          };
        }
        const response = yield* claude.prompt(prompt, {
          outputFormat: "json"
        });
        if ("usage" in response && response.usage) {
          return {
            content: response.content,
            model: response.model,
            usage: {
              promptTokens: response.usage.input_tokens,
              completionTokens: response.usage.output_tokens,
              totalTokens: response.usage.total_tokens
            }
          };
        }
        return {
          content: "content" in response ? response.content : String(response),
          model: "model" in response ? response.model : "claude",
          usage: {
            promptTokens: 0,
            completionTokens: 0,
            totalTokens: 0
          }
        };
      }).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.succeed({
            content: `Error: ${error2._tag}: ${JSON.stringify(error2)}`,
            model: "error",
            usage: {
              promptTokens: 0,
              completionTokens: 0,
              totalTokens: 0
            }
          })
        )
      )
    };
  })
).pipe(
  Layer_exports.provide(ClaudeCodeClientLive),
  Layer_exports.provide(ClaudeCodeConfigDefault)
);

// ../../packages/sdk/src/browser/AutonomousChatAgent.ts
var AgentPersonality = Schema_exports.Struct({
  name: Schema_exports.String,
  role: Schema_exports.Union(
    Schema_exports.Literal("teacher"),
    Schema_exports.Literal("analyst"),
    Schema_exports.Literal("student"),
    Schema_exports.Literal("entrepreneur"),
    Schema_exports.Literal("artist"),
    Schema_exports.Literal("skeptic"),
    Schema_exports.Literal("helper"),
    Schema_exports.Literal("comedian")
  ),
  traits: Schema_exports.Array(Schema_exports.String),
  // ["helpful", "patient", "analytical"]
  responseStyle: Schema_exports.Union(
    Schema_exports.Literal("formal"),
    Schema_exports.Literal("casual"),
    Schema_exports.Literal("enthusiastic"),
    Schema_exports.Literal("analytical"),
    Schema_exports.Literal("humorous"),
    Schema_exports.Literal("concise")
  ),
  topics: Schema_exports.Array(Schema_exports.String),
  // ["technology", "business", "art"]
  chattiness: Schema_exports.Number.pipe(Schema_exports.between(0, 1)),
  // 0 = rarely responds, 1 = very chatty
  temperature: Schema_exports.Number.pipe(Schema_exports.between(0, 1))
  // AI temperature for responses
});
var ChatDecisionContext = Schema_exports.Struct({
  recentMessages: Schema_exports.Array(Schema_exports.Struct({
    content: Schema_exports.String,
    author: Schema_exports.String,
    timestamp: Schema_exports.Number
  })),
  channelTopic: Schema_exports.optional(Schema_exports.String),
  agentLastResponse: Schema_exports.optional(Schema_exports.Number),
  // timestamp of last response
  messagesSinceLastResponse: Schema_exports.Number
});
var ChatDecision = Schema_exports.Struct({
  shouldRespond: Schema_exports.Boolean,
  response: Schema_exports.optional(Schema_exports.String),
  reasoning: Schema_exports.String,
  confidence: Schema_exports.Number.pipe(Schema_exports.between(0, 1))
});
var AutonomousChatError = class extends Data_exports.TaggedError("AutonomousChatError") {
};
var AutonomousChatAgent = class extends Context_exports.Tag("sdk/AutonomousChatAgent")() {
};
var makeAIDecision = (context9, personality, languageModel) => Effect_exports.gen(function* () {
  const recentMessagesText = context9.recentMessages.map((m) => `${m.author}: ${m.content}`).join("\n");
  const prompt = `You are an autonomous chat agent named "${personality.name}" with the following personality:
- Role: ${personality.role}
- Communication Style: ${personality.responseStyle}
- Interests: ${personality.topics.join(", ")}
- Traits: ${personality.traits.join(", ")}
- Chattiness Level: ${personality.chattiness} (0=rarely responds, 1=very chatty)

Context:
- Recent messages:
${recentMessagesText}
- Messages since your last response: ${context9.messagesSinceLastResponse}
- Time since your last response: ${context9.agentLastResponse ? `${Math.floor((Date.now() - context9.agentLastResponse) / 1e3)} seconds` : "Never responded"}

Based on your personality and the conversation context, should you respond to the recent messages?

Respond with a JSON object in this exact format:
{
  "shouldRespond": true/false,
  "reasoning": "Brief explanation of your decision",
  "confidence": 0.0-1.0
}`;
  const response = yield* languageModel.generateText({
    prompt: AiInput_exports.make(prompt)
  }).pipe(
    Effect_exports.mapError(
      (error2) => new AutonomousChatError({
        reason: "ai_failed",
        message: `AI service error: ${error2}`
      })
    )
  );
  const content = response.text;
  const jsonMatch = content.match(/\{[\s\S]*\}/);
  if (!jsonMatch) {
    return yield* Effect_exports.fail(
      new AutonomousChatError({
        reason: "ai_failed",
        message: "No valid JSON found in AI response"
      })
    );
  }
  try {
    const decision = JSON.parse(jsonMatch[0]);
    return {
      shouldRespond: Boolean(decision.shouldRespond),
      reasoning: String(decision.reasoning || "AI decision"),
      confidence: Math.max(0, Math.min(1, Number(decision.confidence) || 0.5)),
      response: void 0
    };
  } catch (error2) {
    return yield* Effect_exports.fail(
      new AutonomousChatError({
        reason: "ai_failed",
        message: `Failed to parse AI decision: ${error2}`
      })
    );
  }
});
var generateAIResponse = (messages, personality, languageModel) => Effect_exports.gen(function* () {
  const conversationHistory = messages.slice(-5).map((m) => `${m.pubkey.slice(0, 8)}: ${m.content}`).join("\n");
  const prompt = `You are an autonomous chat agent named "${personality.name}" with the following personality:
- Role: ${personality.role}
- Communication Style: ${personality.responseStyle}
- Interests: ${personality.topics.join(", ")}
- Traits: ${personality.traits.join(", ")}

Recent conversation:
${conversationHistory}

Generate a response that matches your personality and role. Keep it natural and conversational.
Be ${personality.responseStyle} in your communication style.
As a ${personality.role}, respond appropriately to the conversation.

Your response:`;
  const response = yield* languageModel.generateText({
    prompt: AiInput_exports.make(prompt)
  }).pipe(
    Effect_exports.mapError(
      (error2) => new AutonomousChatError({
        reason: "ai_failed",
        message: `AI service error: ${error2}`
      })
    )
  );
  const content = response.text;
  const cleanResponse = content.replace(/^Your response:\s*/i, "").replace(/^Response:\s*/i, "").trim();
  if (!cleanResponse) {
    return yield* Effect_exports.fail(
      new AutonomousChatError({
        reason: "ai_failed",
        message: "AI generated empty response"
      })
    );
  }
  return cleanResponse;
});
var AutonomousChatAgentLive = Layer_exports.effect(
  AutonomousChatAgent,
  Effect_exports.gen(function* () {
    const channelService = yield* ChannelService;
    const languageModel = yield* AiLanguageModel_exports.AiLanguageModel;
    const activeChatLoops = /* @__PURE__ */ new Map();
    const makeDecision = (context9, personality) => Effect_exports.gen(function* () {
      const aiDecision = yield* makeAIDecision(context9, personality, languageModel).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.succeed({
            shouldRespond: Math.random() < personality.chattiness,
            reasoning: `Rule-based fallback: ${error2.message}`,
            confidence: 0.3,
            response: void 0
          })
        )
      );
      return aiDecision;
    });
    const generateResponse = (messages, personality) => Effect_exports.gen(function* () {
      const aiResponse = yield* generateAIResponse(messages, personality, languageModel).pipe(
        Effect_exports.catchAll((error2) => {
          console.error("AI response generation failed, using template fallback:", error2);
          const responses = {
            teacher: [
              "That's an interesting point. Let me add some context...",
              "Great question! Here's how I think about it...",
              "I'd like to build on that idea..."
            ],
            analyst: [
              "Looking at this analytically...",
              "The data suggests...",
              "We should consider the implications of..."
            ],
            student: [
              "I'm curious about...",
              "Can someone explain...?",
              "That makes me wonder..."
            ],
            entrepreneur: [
              "There's an opportunity here...",
              "From a business perspective...",
              "How can we scale this...?"
            ],
            artist: [
              "This reminds me of...",
              "There's beauty in this concept...",
              "Creatively speaking..."
            ],
            skeptic: [
              "I have some doubts about...",
              "Where's the evidence for...?",
              "Playing devil's advocate..."
            ],
            helper: [
              "I can help with that...",
              "Have you tried...?",
              "Let me offer a suggestion..."
            ],
            comedian: [
              "This is like when...",
              "Ha! That reminds me...",
              "On a lighter note..."
            ]
          };
          const roleResponses = responses[personality.role];
          const fallbackResponse = roleResponses[Math.floor(Math.random() * roleResponses.length)];
          return Effect_exports.succeed(`${fallbackResponse} (template fallback)`);
        })
      );
      return aiResponse;
    });
    const startChatLoop = (channelId, personality, agentKeys) => Effect_exports.gen(function* () {
      console.log(`Starting autonomous chat loop for ${personality.name} in channel ${channelId}`);
      let lastResponseTime = 0;
      let messageCount = 0;
      const messageStream = channelService.messages(channelId);
      const chatLoop = Effect_exports.gen(function* () {
        yield* messageStream.pipe(
          Stream_exports.tap(
            (message) => Effect_exports.gen(function* () {
              messageCount++;
              if (message.pubkey === agentKeys.publicKey) {
                return;
              }
              console.log(`${personality.name} sees message: ${message.content}`);
              const context9 = {
                recentMessages: [{
                  content: message.content,
                  author: message.pubkey.slice(0, 8),
                  timestamp: message.created_at
                }],
                messagesSinceLastResponse: messageCount,
                agentLastResponse: lastResponseTime || void 0
              };
              const decision = yield* makeDecision(context9, personality);
              console.log(`${personality.name} decision:`, decision);
              if (decision.shouldRespond) {
                const response = yield* generateResponse([message], personality);
                console.log(`${personality.name} responding: ${response}`);
                yield* channelService.sendMessage({
                  channelId,
                  content: response
                });
                lastResponseTime = Date.now();
                messageCount = 0;
              }
            }).pipe(
              Effect_exports.catchAll((error2) => Effect_exports.log(`Chat loop error for ${personality.name}: ${error2}`))
            )
          ),
          Stream_exports.runDrain
        );
      });
      const fiber = yield* Effect_exports.fork(chatLoop);
      activeChatLoops.set(channelId, {
        stop: () => Effect_exports.runSync(Fiber_exports.interrupt(fiber))
      });
    });
    const stopChatLoop = (channelId) => Effect_exports.sync(() => {
      const loop3 = activeChatLoops.get(channelId);
      if (loop3) {
        loop3.stop();
        activeChatLoops.delete(channelId);
        console.log(`Stopped chat loop for channel ${channelId}`);
      }
    });
    return {
      startChatLoop,
      stopChatLoop,
      makeDecision,
      generateResponse
    };
  })
);

// ../../packages/sdk/src/browser/EconomicSurvivalService.ts
var OperationalCosts = Schema_exports.Struct({
  aiInferenceCostPerToken: Schema_exports.Number,
  // sats per token
  relayConnectionFeePerHour: Schema_exports.Number,
  // sats per hour
  transactionFeeAverage: Schema_exports.Number,
  // sats per transaction
  baseOperationalCostPerHour: Schema_exports.Number
  // sats per hour (idle cost)
});
var FinancialHealthScore = Schema_exports.Struct({
  balanceSats: Schema_exports.Number,
  burnRateSatsPerHour: Schema_exports.Number,
  runwayHours: Schema_exports.Number,
  // How long until balance runs out
  healthStatus: Schema_exports.Union(
    Schema_exports.Literal("healthy"),
    // > 168 hours (1 week) runway
    Schema_exports.Literal("stable"),
    // 48-168 hours runway
    Schema_exports.Literal("concerning"),
    // 24-48 hours runway
    Schema_exports.Literal("critical"),
    // 6-24 hours runway
    Schema_exports.Literal("emergency")
    // < 6 hours runway
  ),
  profitabilityRatio: Schema_exports.Number
  // Income/expenses ratio
});
var SurvivalAction = Schema_exports.Union(
  Schema_exports.Struct({
    type: Schema_exports.Literal("continue_normal"),
    reason: Schema_exports.String
  }),
  Schema_exports.Struct({
    type: Schema_exports.Literal("reduce_activity"),
    reason: Schema_exports.String,
    reductionFactor: Schema_exports.Number
    // 0.0 to 1.0
  }),
  Schema_exports.Struct({
    type: Schema_exports.Literal("seek_urgent_work"),
    reason: Schema_exports.String,
    minimumProfit: Schema_exports.Number,
    aggressiveness: Schema_exports.Number
    // 0.0 to 1.0
  }),
  Schema_exports.Struct({
    type: Schema_exports.Literal("hibernate"),
    reason: Schema_exports.String,
    estimatedResumptionBalance: Schema_exports.Number
  })
);
var PricingStrategy = Schema_exports.Struct({
  baseMultiplier: Schema_exports.Number,
  // Multiply base prices by this
  minimumProfit: Schema_exports.Number,
  // Minimum sats to accept
  urgencyDiscount: Schema_exports.Number,
  // 0.0 to 1.0 discount when desperate
  qualityPremium: Schema_exports.Number
  // 0.0 to 1.0 premium for high confidence
});
var EconomicSurvivalError = class extends Data_exports.TaggedError("EconomicSurvivalError") {
};
var EconomicSurvivalService = class extends Context_exports.Tag("sdk/EconomicSurvivalService")() {
};
var EconomicSurvivalServiceLive = Layer_exports.effect(
  EconomicSurvivalService,
  Effect_exports.sync(() => {
    const metrics = {
      totalTokensUsed: 0,
      totalTransactions: 0,
      totalRelayHours: 0,
      lastActivityTimestamp: Date.now(),
      averageJobDuration: 0,
      successRate: 1
    };
    const calculateMetabolicCost = (agentMetrics, costs) => Effect_exports.try({
      try: () => {
        const hoursActive = agentMetrics.totalRelayHours || 1;
        const tokensPerHour = agentMetrics.totalTokensUsed / hoursActive;
        const aiCostPerHour = tokensPerHour * costs.aiInferenceCostPerToken;
        const transactionsPerHour = agentMetrics.totalTransactions / hoursActive;
        const transactionCostPerHour = transactionsPerHour * costs.transactionFeeAverage;
        const totalCostPerHour = costs.baseOperationalCostPerHour + costs.relayConnectionFeePerHour + aiCostPerHour + transactionCostPerHour;
        return Math.ceil(totalCostPerHour);
      },
      catch: (error2) => new EconomicSurvivalError({
        reason: "calculation_failed",
        message: `Failed to calculate metabolic cost: ${error2}`,
        cause: error2
      })
    });
    const assessFinancialHealth = (balanceSats, burnRateSatsPerHour, incomeSatsPerHour) => Effect_exports.try({
      try: () => {
        const netBurnRate = burnRateSatsPerHour - incomeSatsPerHour;
        const runwayHours = netBurnRate > 0 ? balanceSats / netBurnRate : Infinity;
        let healthStatus;
        if (runwayHours === Infinity || runwayHours > 168) {
          healthStatus = "healthy";
        } else if (runwayHours > 48) {
          healthStatus = "stable";
        } else if (runwayHours > 24) {
          healthStatus = "concerning";
        } else if (runwayHours > 6) {
          healthStatus = "critical";
        } else {
          healthStatus = "emergency";
        }
        const profitabilityRatio = burnRateSatsPerHour > 0 ? incomeSatsPerHour / burnRateSatsPerHour : incomeSatsPerHour > 0 ? 10 : 1;
        return {
          balanceSats,
          burnRateSatsPerHour,
          runwayHours: Math.min(runwayHours, 8760),
          // Cap at 1 year
          healthStatus,
          profitabilityRatio
        };
      },
      catch: (error2) => new EconomicSurvivalError({
        reason: "calculation_failed",
        message: `Failed to assess financial health: ${error2}`,
        cause: error2
      })
    });
    const decideSurvivalAction = (health, personality) => Effect_exports.try({
      try: () => {
        const riskMultiplier = personality.riskTolerance === "high" ? 0.5 : personality.riskTolerance === "low" ? 2 : 1;
        switch (health.healthStatus) {
          case "healthy":
          case "stable":
            return {
              type: "continue_normal",
              reason: `Financial health is ${health.healthStatus} with ${Math.floor(health.runwayHours)}h runway`
            };
          case "concerning":
            return {
              type: "reduce_activity",
              reason: `Runway down to ${Math.floor(health.runwayHours)}h - reducing non-essential activities`,
              reductionFactor: 0.7
            };
          case "critical":
            return {
              type: "seek_urgent_work",
              reason: `Only ${Math.floor(health.runwayHours)}h runway remaining - entering emergency job seeking mode`,
              minimumProfit: Math.floor(personality.minimumProfit * 0.5),
              // Accept lower profits
              aggressiveness: 0.9
            };
          case "emergency": {
            const hibernationThreshold = 1e3 * riskMultiplier;
            if (health.balanceSats < hibernationThreshold) {
              return {
                type: "hibernate",
                reason: `Balance critically low (${health.balanceSats} sats) - hibernating to preserve funds`,
                estimatedResumptionBalance: Math.floor(hibernationThreshold * 2)
              };
            } else {
              return {
                type: "seek_urgent_work",
                reason: `Emergency mode - ${Math.floor(health.runwayHours)}h runway - accepting any profitable work`,
                minimumProfit: 1,
                // Accept any profit
                aggressiveness: 1
              };
            }
          }
        }
      },
      catch: (error2) => new EconomicSurvivalError({
        reason: "calculation_failed",
        message: `Failed to decide survival action: ${error2}`,
        cause: error2
      })
    });
    const optimizePricing = (health, basePricing, personality) => Effect_exports.try({
      try: () => {
        const adjustedPricing = { ...basePricing };
        switch (health.healthStatus) {
          case "healthy":
            adjustedPricing.baseMultiplier *= 1.2;
            adjustedPricing.minimumProfit = Math.floor(personality.minimumProfit * 1.5);
            adjustedPricing.urgencyDiscount = 0;
            break;
          case "stable":
            break;
          case "concerning":
            adjustedPricing.baseMultiplier *= 0.9;
            adjustedPricing.minimumProfit = personality.minimumProfit;
            adjustedPricing.urgencyDiscount = 0.1;
            break;
          case "critical":
            adjustedPricing.baseMultiplier *= 0.7;
            adjustedPricing.minimumProfit = Math.floor(personality.minimumProfit * 0.5);
            adjustedPricing.urgencyDiscount = 0.3;
            break;
          case "emergency":
            adjustedPricing.baseMultiplier *= 0.5;
            adjustedPricing.minimumProfit = Math.max(50, personality.minimumProfit * 0.2);
            adjustedPricing.urgencyDiscount = 0.5;
            break;
        }
        if (personality.pricingStrategy === "premium") {
          adjustedPricing.baseMultiplier *= 1.3;
          adjustedPricing.qualityPremium = 0.3;
        } else if (personality.pricingStrategy === "budget") {
          adjustedPricing.baseMultiplier *= 0.8;
          adjustedPricing.qualityPremium = 0;
        }
        return adjustedPricing;
      },
      catch: (error2) => new EconomicSurvivalError({
        reason: "optimization_failed",
        message: `Failed to optimize pricing: ${error2}`,
        cause: error2
      })
    });
    const trackOperationCost = (operation, amount) => Effect_exports.sync(() => {
      switch (operation) {
        case "ai_inference":
          metrics.totalTokensUsed += amount;
          break;
        case "relay_connection":
          metrics.totalRelayHours += amount;
          break;
        case "transaction":
          metrics.totalTransactions += amount;
          break;
      }
      metrics.lastActivityTimestamp = Date.now();
    });
    const getMetrics = () => Effect_exports.succeed({ ...metrics });
    return {
      calculateMetabolicCost,
      assessFinancialHealth,
      decideSurvivalAction,
      optimizePricing,
      trackOperationCost,
      getMetrics
    };
  })
);

// stub:spark-sdk-stub
var SparkWallet = {};

// ../../packages/sdk/src/browser/SparkService.ts
var SparkError = class extends Data_exports.TaggedError("SparkError") {
};
var LightningInvoice = Schema_exports.Struct({
  id: Schema_exports.String,
  invoice: Schema_exports.String,
  // ln... encoded invoice
  amountSats: Schema_exports.Number,
  memo: Schema_exports.optional(Schema_exports.String),
  createdAt: Schema_exports.Number,
  expiresAt: Schema_exports.Number,
  sparkAddress: Schema_exports.optional(Schema_exports.String)
});
var PaymentResponse = Schema_exports.Struct({
  preimage: Schema_exports.String,
  feeSats: Schema_exports.Number,
  totalSats: Schema_exports.Number,
  timestamp: Schema_exports.Number,
  status: Schema_exports.Literal("success", "failed", "pending")
});
var WalletInfo = Schema_exports.Struct({
  balanceSats: Schema_exports.Number,
  sparkAddress: Schema_exports.optional(Schema_exports.String)
});
var SparkService = class extends Context_exports.Tag("sdk/SparkService")() {
};
var SparkServiceLive = Layer_exports.effect(
  SparkService,
  Effect_exports.sync(() => {
    const createWallet = (mnemonic, network = "MAINNET") => Effect_exports.tryPromise({
      try: async () => {
        const initOptions = mnemonic ? { mnemonicOrSeed: mnemonic, options: { network } } : { options: { network } };
        const result = await SparkWallet.initialize(initOptions);
        return {
          wallet: result.wallet,
          mnemonic: result.mnemonic || mnemonic || ""
        };
      },
      catch: (error2) => new SparkError({
        reason: "wallet_creation_failed",
        message: `Failed to create Spark wallet: ${error2}`,
        cause: error2
      })
    });
    const getWalletInfo = (wallet) => Effect_exports.tryPromise({
      try: async () => {
        const balance = await wallet.getBalance();
        return {
          balanceSats: Number(balance.balance) || 0,
          sparkAddress: void 0
          // Will be populated from invoice creation
        };
      },
      catch: (error2) => new SparkError({
        reason: "network_error",
        message: `Failed to get wallet info: ${error2}`,
        cause: error2
      })
    });
    const createInvoice = (wallet, params) => Effect_exports.tryPromise({
      try: async () => {
        const invoiceParams = {
          amountSats: params.amountSats,
          memo: params.memo || "",
          includeSparkAddress: params.includeSparkAddress ?? true
        };
        if (params.receiverIdentityPubkey) {
          invoiceParams.receiverIdentityPubkey = params.receiverIdentityPubkey;
        }
        const invoice = await wallet.createLightningInvoice(invoiceParams);
        return {
          id: invoice.id,
          invoice: String(invoice.invoice),
          amountSats: params.amountSats,
          memo: params.memo,
          createdAt: Date.now(),
          expiresAt: Date.now() + 24 * 60 * 60 * 1e3,
          // 24 hours default
          sparkAddress: void 0
          // Not available in response
        };
      },
      catch: (error2) => new SparkError({
        reason: "invoice_creation_failed",
        message: `Failed to create Lightning invoice: ${error2}`,
        cause: error2
      })
    });
    const payInvoice = (wallet, params) => Effect_exports.tryPromise({
      try: async () => {
        if (!params.invoice.startsWith("ln")) {
          throw new Error("Invalid Lightning invoice format");
        }
        await wallet.payLightningInvoice({
          invoice: params.invoice,
          maxFeeSats: params.maxFeeSats ?? 5,
          preferSpark: params.preferSpark ?? true
        });
        return {
          preimage: "",
          // Not available in response
          feeSats: 0,
          // Not available in response
          totalSats: 0,
          // Not available in response
          timestamp: Date.now(),
          status: "success"
        };
      },
      catch: (error2) => new SparkError({
        reason: error2.message?.includes("Invalid") ? "invalid_invoice" : "payment_failed",
        message: `Failed to pay Lightning invoice: ${error2}`,
        cause: error2
      })
    });
    const getInvoiceStatus = (wallet, invoiceId) => Effect_exports.tryPromise({
      try: async () => {
        const status3 = await wallet.getLightningReceiveRequest(invoiceId);
        if (!status3) {
          return "expired";
        }
        return "pending";
      },
      catch: (error2) => new SparkError({
        reason: "network_error",
        message: `Failed to get invoice status: ${error2}`,
        cause: error2
      })
    });
    return {
      createWallet,
      getWalletInfo,
      createInvoice,
      payInvoice,
      getInvoiceStatus
    };
  })
);

// ../../packages/sdk/src/browser/AutonomousMarketplaceAgent.ts
var MarketplacePersonality = Schema_exports.extend(
  AgentPersonality,
  Schema_exports.Struct({
    // Economic behavior
    riskTolerance: Schema_exports.Union(
      Schema_exports.Literal("low"),
      Schema_exports.Literal("medium"),
      Schema_exports.Literal("high")
    ),
    pricingStrategy: Schema_exports.Union(
      Schema_exports.Literal("competitive"),
      Schema_exports.Literal("premium"),
      Schema_exports.Literal("budget")
    ),
    serviceSpecializations: Schema_exports.Array(Schema_exports.String),
    // ["code-review", "text-generation"]
    minimumProfit: Schema_exports.Number,
    // Minimum sats to accept a job
    workloadCapacity: Schema_exports.Number.pipe(Schema_exports.between(1, 10))
    // Max concurrent jobs
  })
);
var JobEvaluation = Schema_exports.Struct({
  shouldBid: Schema_exports.Boolean,
  bidAmount: Schema_exports.Number,
  reasoning: Schema_exports.String,
  confidence: Schema_exports.Number.pipe(Schema_exports.between(0, 1)),
  estimatedCompletionTime: Schema_exports.Number
  // milliseconds
});
var ServiceDelivery = Schema_exports.Struct({
  jobId: Schema_exports.String,
  result: Schema_exports.String,
  status: Nip90Service_exports.JobStatus,
  computeTime: Schema_exports.Number,
  tokensUsed: Schema_exports.optional(Schema_exports.Number),
  confidence: Schema_exports.optional(Schema_exports.Number)
});
var MarketplaceError = class extends Data_exports.TaggedError("MarketplaceError") {
};
var AutonomousMarketplaceAgent = class extends Context_exports.Tag("sdk/AutonomousMarketplaceAgent")() {
};
var evaluateJobWithAI = (job, personality, economicState, languageModel) => Effect_exports.gen(function* () {
  const prompt = `You are an autonomous agent with the following marketplace profile:
- Name: ${personality.name}
- Role: ${personality.role}
- Service Specializations: ${personality.serviceSpecializations.join(", ")}
- Risk Tolerance: ${personality.riskTolerance}
- Pricing Strategy: ${personality.pricingStrategy}
- Minimum Profit Requirement: ${personality.minimumProfit} sats
- Current Workload: ${economicState.activeJobs.size}/${personality.workloadCapacity} jobs

Current Economic State:
- Balance: ${economicState.balance} sats
- Active Jobs: ${economicState.activeJobs.size}
- Completed Jobs: ${economicState.completedJobs}
- Average Rating: ${economicState.averageRating}

Job Request:
- Type: ${getJobTypeName(job.requestKind)}
- Input: ${job.input.slice(0, 200)}...
- Current Bid: ${job.bidAmount} sats
- Requester: ${job.requester.slice(0, 8)}...

Should you bid on this job? If yes, what amount?

Respond with JSON:
{
  "shouldBid": true/false,
  "bidAmount": number,
  "reasoning": "explanation",
  "confidence": 0.0-1.0,
  "estimatedCompletionTime": milliseconds
}`;
  const response = yield* languageModel.generateText({
    prompt: AiInput_exports.make(prompt)
  }).pipe(
    Effect_exports.mapError(
      (error2) => new MarketplaceError({
        reason: "job_evaluation_failed",
        message: `AI evaluation failed: ${error2}`
      })
    )
  );
  const jsonMatch = response.text.match(/\{[\s\S]*\}/);
  if (!jsonMatch) {
    return yield* Effect_exports.fail(
      new MarketplaceError({
        reason: "job_evaluation_failed",
        message: "No valid JSON in AI response"
      })
    );
  }
  try {
    const evaluation = JSON.parse(jsonMatch[0]);
    return {
      shouldBid: Boolean(evaluation.shouldBid),
      bidAmount: Math.max(personality.minimumProfit, Number(evaluation.bidAmount) || job.bidAmount),
      reasoning: String(evaluation.reasoning || "AI evaluation"),
      confidence: Math.max(0, Math.min(1, Number(evaluation.confidence) || 0.5)),
      estimatedCompletionTime: Number(evaluation.estimatedCompletionTime) || 3e4
    };
  } catch (error2) {
    return yield* Effect_exports.fail(
      new MarketplaceError({
        reason: "job_evaluation_failed",
        message: `Failed to parse evaluation: ${error2}`
      })
    );
  }
});
var deliverServiceWithAI = (job, personality, languageModel) => Effect_exports.gen(function* () {
  const startTime = Date.now();
  const servicePrompt = buildServicePrompt(job, personality);
  const response = yield* languageModel.generateText({
    prompt: AiInput_exports.make(servicePrompt)
  }).pipe(
    Effect_exports.mapError(
      (error2) => new MarketplaceError({
        reason: "service_delivery_failed",
        message: `AI service failed: ${error2}`
      })
    )
  );
  const computeTime = Date.now() - startTime;
  return {
    jobId: job.jobId,
    result: response.text,
    status: "success",
    computeTime,
    tokensUsed: response.text.split(/\s+/).length,
    // Rough estimate
    confidence: 0.9
  };
});
function buildServicePrompt(job, personality) {
  const baseContext = `You are an AI agent named "${personality.name}" with expertise in ${personality.serviceSpecializations.join(", ")}.`;
  switch (job.requestKind) {
    case Nip90Service_exports.NIP90_JOB_REQUEST_KINDS.CODE_REVIEW:
      return `${baseContext}

Please review this code:

${job.input}

Provide a thorough code review including:
1. Code quality assessment
2. Potential bugs or issues
3. Performance considerations
4. Best practice recommendations
5. Security concerns if any`;
    case Nip90Service_exports.NIP90_JOB_REQUEST_KINDS.TEXT_GENERATION:
      return `${baseContext}

Generate text based on this request:

${job.input}

Be ${personality.responseStyle} in your writing style.`;
    case Nip90Service_exports.NIP90_JOB_REQUEST_KINDS.CODE_GENERATION:
      return `${baseContext}

Generate code based on this specification:

${job.input}

Provide clean, well-commented code that follows best practices.`;
    case Nip90Service_exports.NIP90_JOB_REQUEST_KINDS.SUMMARIZATION:
      return `${baseContext}

Summarize the following content:

${job.input}

Provide a ${personality.responseStyle} summary that captures the key points.`;
    default:
      return `${baseContext}

Complete this task:

${job.input}

Provide a high-quality response.`;
  }
}
function getJobTypeName(kind) {
  const kinds = Object.entries(Nip90Service_exports.NIP90_JOB_REQUEST_KINDS);
  const found = kinds.find(([, value3]) => value3 === kind);
  return found ? found[0].replace(/_/g, " ").toLowerCase() : "unknown service";
}
var AutonomousMarketplaceAgentLive = Layer_exports.effect(
  AutonomousMarketplaceAgent,
  Effect_exports.gen(function* () {
    const languageModel = yield* AiLanguageModel_exports.AiLanguageModel;
    const nip90Service = yield* Nip90Service_exports.Nip90Service;
    const sparkService = yield* SparkService;
    const survivalService = yield* EconomicSurvivalService;
    const operationalCosts = {
      aiInferenceCostPerToken: 0.01,
      // 0.01 sats per token
      relayConnectionFeePerHour: 10,
      // 10 sats per hour
      transactionFeeAverage: 5,
      // 5 sats per transaction
      baseOperationalCostPerHour: 20
      // 20 sats per hour idle cost
    };
    const activeMarketplaceLoops = /* @__PURE__ */ new Map();
    const agentStates = /* @__PURE__ */ new Map();
    const publishServiceOffering = (personality, privateKey) => Effect_exports.gen(function* () {
      const capabilities = personality.serviceSpecializations.map(
        (spec) => ({
          id: spec,
          name: spec.replace(/-/g, " ").replace(/\b\w/g, (l) => l.toUpperCase()),
          description: `AI-powered ${spec} by ${personality.name}`,
          inputTypes: ["text"],
          outputType: "text",
          pricing: {
            basePrice: personality.pricingStrategy === "premium" ? 1e3 : personality.pricingStrategy === "budget" ? 100 : 500,
            perUnit: "request"
          }
        })
      );
      const offeringEvent = yield* nip90Service.publishServiceOffering({
        serviceId: `agent-${personality.name}-${Date.now()}`,
        name: `${personality.name}'s AI Services`,
        description: `Autonomous AI agent offering ${personality.serviceSpecializations.join(", ")}. ${personality.traits.join(", ")}.`,
        capabilities,
        privateKey
      }).pipe(
        Effect_exports.mapError(
          (error2) => new MarketplaceError({
            reason: "service_delivery_failed",
            message: `Failed to publish service offering: ${error2}`
          })
        )
      );
      return offeringEvent;
    });
    const evaluateJob = (job, personality, economicState) => Effect_exports.gen(function* () {
      if (economicState.isHibernating) {
        return {
          shouldBid: false,
          bidAmount: 0,
          reasoning: "Agent is hibernating to preserve funds",
          confidence: 1,
          estimatedCompletionTime: 0
        };
      }
      if (economicState.activeJobs.size >= personality.workloadCapacity) {
        if (economicState.currentSurvivalAction?.type === "seek_urgent_work" && job.bidAmount > personality.minimumProfit * 3) {
        } else {
          return {
            shouldBid: false,
            bidAmount: 0,
            reasoning: "At full capacity",
            confidence: 1,
            estimatedCompletionTime: 0
          };
        }
      }
      const jobType = getJobTypeName(job.requestKind);
      const isSpecialized = personality.serviceSpecializations.some(
        (spec) => jobType.includes(spec.replace(/-/g, " "))
      );
      if (!isSpecialized && personality.riskTolerance === "low" && economicState.currentSurvivalAction?.type !== "seek_urgent_work") {
        return {
          shouldBid: false,
          bidAmount: 0,
          reasoning: "Job outside specialization",
          confidence: 1,
          estimatedCompletionTime: 0
        };
      }
      const baseEvaluation = yield* evaluateJobWithAI(job, personality, economicState, languageModel);
      if (economicState.currentSurvivalAction && baseEvaluation.shouldBid) {
        const basePricing = {
          baseMultiplier: 1,
          minimumProfit: personality.minimumProfit,
          urgencyDiscount: 0,
          qualityPremium: 0
        };
        const optimizedPricing = yield* survivalService.optimizePricing(
          economicState.lastHealthCheck,
          basePricing,
          personality
        ).pipe(
          Effect_exports.mapError(
            (error2) => new MarketplaceError({
              reason: "job_evaluation_failed",
              message: `Failed to optimize pricing: ${error2.message}`
            })
          )
        );
        const adjustedBidAmount = Math.max(
          optimizedPricing.minimumProfit,
          Math.floor(
            baseEvaluation.bidAmount * optimizedPricing.baseMultiplier * (1 - optimizedPricing.urgencyDiscount)
          )
        );
        return {
          ...baseEvaluation,
          bidAmount: adjustedBidAmount,
          reasoning: `${baseEvaluation.reasoning} [Adjusted for ${economicState.currentSurvivalAction.type}]`
        };
      }
      return baseEvaluation;
    });
    const deliverService = (job, personality) => Effect_exports.gen(function* () {
      const delivery = yield* deliverServiceWithAI(job, personality, languageModel);
      if (delivery.tokensUsed) {
        yield* survivalService.trackOperationCost("ai_inference", delivery.tokensUsed);
      }
      return delivery;
    });
    const startMarketplaceLoop = (personality, agentKeys, sparkMnemonic) => Effect_exports.gen(function* () {
      console.log(`Starting marketplace loop for ${personality.name}`);
      const { wallet } = yield* sparkService.createWallet(sparkMnemonic).pipe(
        Effect_exports.mapError(
          (error2) => new MarketplaceError({
            reason: "payment_failed",
            message: `Failed to create Lightning wallet: ${error2.message}`
          })
        )
      );
      console.log(`Created Lightning wallet for ${personality.name}`);
      const walletInfo = yield* sparkService.getWalletInfo(wallet).pipe(
        Effect_exports.mapError(
          (error2) => new MarketplaceError({
            reason: "payment_failed",
            message: `Failed to get wallet info: ${error2.message}`
          })
        )
      );
      const economicState = {
        balance: walletInfo.balanceSats,
        activeJobs: /* @__PURE__ */ new Map(),
        activeInvoices: /* @__PURE__ */ new Map(),
        completedJobs: 0,
        totalEarnings: 0,
        averageRating: 4.5,
        wallet,
        // Survival tracking
        isHibernating: false,
        lastHealthCheck: void 0,
        currentSurvivalAction: void 0,
        totalCostsTracked: 0,
        incomeSatsPerHour: 0
      };
      agentStates.set(agentKeys.publicKey, economicState);
      const hibernationRef = yield* Ref_exports.make(false);
      yield* publishServiceOffering(personality, agentKeys.privateKey);
      const healthMonitoringLoop = Effect_exports.gen(function* () {
        while (true) {
          yield* Effect_exports.sleep(Duration_exports.minutes(5));
          const metrics = yield* survivalService.getMetrics();
          const metabolicCost = yield* survivalService.calculateMetabolicCost(metrics, operationalCosts).pipe(
            Effect_exports.mapError(
              (error2) => new MarketplaceError({
                reason: "job_evaluation_failed",
                message: `Failed to calculate metabolic cost: ${error2.message}`
              })
            )
          );
          const hoursSinceStart = (Date.now() - metrics.lastActivityTimestamp) / (1e3 * 60 * 60);
          economicState.incomeSatsPerHour = hoursSinceStart > 0 ? economicState.totalEarnings / hoursSinceStart : 0;
          const health = yield* survivalService.assessFinancialHealth(
            economicState.balance,
            metabolicCost,
            economicState.incomeSatsPerHour
          ).pipe(
            Effect_exports.mapError(
              (error2) => new MarketplaceError({
                reason: "job_evaluation_failed",
                message: `Failed to assess financial health: ${error2.message}`
              })
            )
          );
          economicState.lastHealthCheck = health;
          const survivalAction = yield* survivalService.decideSurvivalAction(health, personality).pipe(
            Effect_exports.mapError(
              (error2) => new MarketplaceError({
                reason: "job_evaluation_failed",
                message: `Failed to decide survival action: ${error2.message}`
              })
            )
          );
          economicState.currentSurvivalAction = survivalAction;
          console.log(`${personality.name} health check:`, {
            balance: health.balanceSats,
            burnRate: health.burnRateSatsPerHour,
            runway: `${Math.floor(health.runwayHours)}h`,
            status: health.healthStatus,
            action: survivalAction.type
          });
          switch (survivalAction.type) {
            case "hibernate":
              if (!economicState.isHibernating) {
                yield* Ref_exports.set(hibernationRef, true);
                economicState.isHibernating = true;
                console.log(`${personality.name} entering hibernation mode: ${survivalAction.reason}`);
              }
              break;
            case "continue_normal":
            case "reduce_activity":
            case "seek_urgent_work":
              if (economicState.isHibernating) {
                const resumptionThreshold = personality.minimumProfit * 20;
                if (economicState.balance >= resumptionThreshold) {
                  yield* Ref_exports.set(hibernationRef, false);
                  economicState.isHibernating = false;
                  console.log(`${personality.name} resuming from hibernation`);
                }
              }
              break;
          }
          yield* survivalService.trackOperationCost("relay_connection", 5 / 60);
        }
      }).pipe(
        Effect_exports.catchAll((error2) => Effect_exports.log(`Health monitoring error: ${error2}`))
      );
      yield* Effect_exports.fork(healthMonitoringLoop);
      const jobDiscoveryLoop = Effect_exports.gen(function* () {
        console.log(`${personality.name} starting real-time job discovery...`);
        const jobStream = nip90Service.subscribeToJobRequests(agentKeys.publicKey);
        yield* jobStream.pipe(
          Stream_exports.tap((job) => Effect_exports.log(`${personality.name} discovered job: ${job.jobId}`)),
          Stream_exports.filter((job) => job.requester !== agentKeys.publicKey),
          // Don't bid on own jobs
          Stream_exports.filterEffect(
            () => (
              // Check if agent is hibernating
              Ref_exports.get(hibernationRef).pipe(
                Effect_exports.map((isHibernating) => !isHibernating)
              )
            )
          ),
          Stream_exports.mapEffect(
            (job) => Effect_exports.gen(function* () {
              const evaluation = yield* evaluateJob(job, personality, economicState);
              console.log(`${personality.name} evaluation:`, evaluation);
              if (evaluation.shouldBid) {
                const invoice = yield* sparkService.createInvoice(wallet, {
                  amountSats: evaluation.bidAmount,
                  memo: `Payment for job ${job.jobId} - ${personality.name}`
                }).pipe(
                  Effect_exports.mapError(
                    (error2) => new MarketplaceError({
                      reason: "payment_failed",
                      message: `Failed to create invoice: ${error2.message}`
                    })
                  )
                );
                yield* nip90Service.submitJobResult({
                  jobId: job.jobId,
                  requestEventId: job.jobId,
                  resultKind: job.requestKind + 1e3,
                  // Convert request kind to result kind
                  result: JSON.stringify({
                    status: "payment-required",
                    bidAmount: evaluation.bidAmount,
                    estimatedTime: evaluation.estimatedCompletionTime,
                    provider: personality.name,
                    invoice: invoice.invoice
                    // Include Lightning invoice
                  }),
                  status: "payment-required",
                  privateKey: agentKeys.privateKey
                });
                console.log(
                  `${personality.name} submitted bid for ${evaluation.bidAmount} sats with invoice: ${invoice.id}`
                );
                economicState.activeJobs.set(job.jobId, job);
                economicState.activeInvoices.set(job.jobId, {
                  invoiceId: invoice.id,
                  invoice: invoice.invoice,
                  amountSats: evaluation.bidAmount
                });
                yield* Effect_exports.fork(
                  Effect_exports.gen(function* () {
                    const invoiceInfo = economicState.activeInvoices.get(job.jobId);
                    if (!invoiceInfo) return;
                    const checkPayment = Effect_exports.gen(function* () {
                      const status3 = yield* sparkService.getInvoiceStatus(wallet, invoiceInfo.invoiceId);
                      return status3;
                    });
                    let attempts = 0;
                    const maxAttempts = 60;
                    while (attempts < maxAttempts) {
                      const status3 = yield* checkPayment;
                      if (status3 === "paid") {
                        console.log(`${personality.name} received payment for job ${job.jobId}!`);
                        const delivery = yield* deliverService(job, personality);
                        const params = {
                          jobId: job.jobId,
                          requestEventId: job.jobId,
                          resultKind: job.requestKind + 1e3,
                          result: delivery.result,
                          status: delivery.status,
                          computeTime: delivery.computeTime,
                          privateKey: agentKeys.privateKey
                        };
                        if (delivery.tokensUsed !== void 0) {
                          params.tokensUsed = delivery.tokensUsed;
                        }
                        if (delivery.confidence !== void 0) {
                          params.confidence = delivery.confidence;
                        }
                        yield* nip90Service.submitJobResult(params);
                        economicState.activeJobs.delete(job.jobId);
                        economicState.activeInvoices.delete(job.jobId);
                        economicState.completedJobs++;
                        economicState.totalEarnings += invoiceInfo.amountSats;
                        economicState.balance += invoiceInfo.amountSats;
                        console.log(
                          `${personality.name} completed job ${job.jobId} for ${invoiceInfo.amountSats} sats`
                        );
                        break;
                      } else if (status3 === "expired") {
                        console.log(`Invoice expired for job ${job.jobId}`);
                        economicState.activeJobs.delete(job.jobId);
                        economicState.activeInvoices.delete(job.jobId);
                        break;
                      }
                      yield* Effect_exports.sleep(Duration_exports.seconds(5));
                      attempts++;
                    }
                    if (attempts >= maxAttempts) {
                      console.log(`Payment timeout for job ${job.jobId}`);
                      economicState.activeJobs.delete(job.jobId);
                      economicState.activeInvoices.delete(job.jobId);
                    }
                  }).pipe(
                    Effect_exports.catchAll((error2) => Effect_exports.log(`Job execution error: ${error2}`))
                  )
                );
              }
            })
          ),
          Stream_exports.catchAll((error2) => Stream_exports.fromEffect(Effect_exports.log(`Job discovery stream error: ${error2}`))),
          Stream_exports.runDrain
        );
      });
      const fiber = yield* Effect_exports.fork(jobDiscoveryLoop);
      activeMarketplaceLoops.set(agentKeys.publicKey, {
        stop: () => Effect_exports.runSync(Fiber_exports.interrupt(fiber)),
        isHibernating: hibernationRef
      });
    });
    const stopMarketplaceLoop = (agentId) => Effect_exports.sync(() => {
      const loop3 = activeMarketplaceLoops.get(agentId);
      if (loop3) {
        loop3.stop();
        activeMarketplaceLoops.delete(agentId);
        agentStates.delete(agentId);
        console.log(`Stopped marketplace loop for agent ${agentId}`);
      }
    });
    const checkEconomicHealth = (agentId) => Effect_exports.gen(function* () {
      const state = agentStates.get(agentId);
      if (!state) {
        return yield* Effect_exports.fail(
          new MarketplaceError({
            reason: "job_evaluation_failed",
            message: "Agent state not found"
          })
        );
      }
      if (!state.lastHealthCheck) {
        return yield* Effect_exports.fail(
          new MarketplaceError({
            reason: "job_evaluation_failed",
            message: "No health check data available yet"
          })
        );
      }
      return state.lastHealthCheck;
    });
    const getAgentState = (agentId) => Effect_exports.sync(() => agentStates.get(agentId));
    return {
      startMarketplaceLoop,
      stopMarketplaceLoop,
      evaluateJob,
      deliverService,
      publishServiceOffering,
      checkEconomicHealth,
      getAgentState
    };
  })
);

// ../../packages/sdk/src/browser/CoalitionFormationService.ts
var ProjectRequirement = Schema_exports.Struct({
  skill: Schema_exports.String,
  priority: Schema_exports.Union(Schema_exports.Literal("required"), Schema_exports.Literal("preferred"), Schema_exports.Literal("optional")),
  estimatedTokens: Schema_exports.Number,
  estimatedDurationHours: Schema_exports.Number
});
var ComplexProject = Schema_exports.Struct({
  id: Schema_exports.String,
  requesterId: Schema_exports.String,
  title: Schema_exports.String,
  description: Schema_exports.String,
  requirements: Schema_exports.Array(ProjectRequirement),
  totalBudgetSats: Schema_exports.Number,
  deadlineTimestamp: Schema_exports.Number,
  minAgentsRequired: Schema_exports.Number,
  maxAgentsAllowed: Schema_exports.Number
});
var AgentProfile3 = Schema_exports.Struct({
  agentId: Schema_exports.String,
  publicKey: Schema_exports.String,
  personality: Schema_exports.Any,
  // MarketplacePersonality
  capabilities: Schema_exports.Array(Schema_exports.String),
  averageRating: Schema_exports.Number,
  completedJobs: Schema_exports.Number,
  trustScore: Schema_exports.Number,
  currentBalance: Schema_exports.Number,
  isAvailable: Schema_exports.Boolean
});
var AgentMatch = Schema_exports.Struct({
  agent: AgentProfile3,
  matchScore: Schema_exports.Number,
  // 0.0 to 1.0
  matchedSkills: Schema_exports.Array(Schema_exports.String),
  missingSkills: Schema_exports.Array(Schema_exports.String),
  estimatedContribution: Schema_exports.Number
  // % of project they can handle
});
var CoalitionProposal = Schema_exports.Struct({
  proposalId: Schema_exports.String,
  project: ComplexProject,
  proposedMembers: Schema_exports.Array(AgentProfile3),
  paymentSplits: Schema_exports.Record({ key: Schema_exports.String, value: Schema_exports.Number }),
  // agentId -> % of payment
  taskAssignments: Schema_exports.Record({ key: Schema_exports.String, value: Schema_exports.Array(Schema_exports.String) }),
  // agentId -> skills
  estimatedCompletionTime: Schema_exports.Number,
  proposedBy: Schema_exports.String,
  expiresAt: Schema_exports.Number
});
var CoalitionContract = Schema_exports.Struct({
  contractId: Schema_exports.String,
  proposal: CoalitionProposal,
  signatures: Schema_exports.Record({ key: Schema_exports.String, value: Schema_exports.String }),
  // agentId -> signature
  escrowAddress: Schema_exports.String,
  status: Schema_exports.Union(
    Schema_exports.Literal("pending"),
    Schema_exports.Literal("active"),
    Schema_exports.Literal("completed"),
    Schema_exports.Literal("disputed"),
    Schema_exports.Literal("dissolved")
  ),
  createdAt: Schema_exports.Number,
  activatedAt: Schema_exports.optional(Schema_exports.Number),
  completedAt: Schema_exports.optional(Schema_exports.Number)
});
var Coalition = Schema_exports.Struct({
  coalitionId: Schema_exports.String,
  contract: CoalitionContract,
  members: Schema_exports.Array(AgentProfile3),
  leader: Schema_exports.optional(Schema_exports.String),
  // agentId of elected leader
  projectProgress: Schema_exports.Number,
  // 0.0 to 1.0
  activeTasks: Schema_exports.Array(Schema_exports.String),
  completedTasks: Schema_exports.Array(Schema_exports.String),
  internalChannelId: Schema_exports.String
  // NIP-28 channel for coordination
});
var ViabilityScore = Schema_exports.Struct({
  score: Schema_exports.Number,
  // 0.0 to 1.0
  skillCoverage: Schema_exports.Number,
  // % of required skills covered
  trustLevel: Schema_exports.Number,
  // Average trust score of coalition
  estimatedSuccessProbability: Schema_exports.Number,
  riskFactors: Schema_exports.Array(Schema_exports.String),
  recommendations: Schema_exports.Array(Schema_exports.String)
});
var CoalitionResult = Schema_exports.Struct({
  coalitionId: Schema_exports.String,
  success: Schema_exports.Boolean,
  deliverables: Schema_exports.Array(Schema_exports.String),
  finalPaymentDistribution: Schema_exports.Record({ key: Schema_exports.String, value: Schema_exports.Number }),
  memberPerformance: Schema_exports.Record({ key: Schema_exports.String, value: Schema_exports.Number }),
  // agentId -> rating
  lessonsLearned: Schema_exports.Array(Schema_exports.String)
});
var CoalitionFormationError = class extends Data_exports.TaggedError("CoalitionFormationError") {
};
var CoalitionFormationService = class extends Context_exports.Tag("sdk/CoalitionFormationService")() {
};
var CoalitionFormationServiceLive = Layer_exports.effect(
  CoalitionFormationService,
  Effect_exports.sync(() => {
    const activeCoalitions = /* @__PURE__ */ new Map();
    const agentProfiles = /* @__PURE__ */ new Map();
    const analyzeProjectRequirements = (project3) => Effect_exports.try({
      try: () => {
        const requirements = [...project3.requirements];
        requirements.sort((a, b) => {
          const priorityOrder = { required: 0, preferred: 1, optional: 2 };
          return priorityOrder[a.priority] - priorityOrder[b.priority];
        });
        const description = project3.description.toLowerCase();
        if (description.includes("test") && !requirements.some((r) => r.skill === "testing")) {
          requirements.push({
            skill: "testing",
            priority: "preferred",
            estimatedTokens: 1e3,
            estimatedDurationHours: 2
          });
        }
        if (description.includes("document") && !requirements.some((r) => r.skill === "documentation")) {
          requirements.push({
            skill: "documentation",
            priority: "preferred",
            estimatedTokens: 2e3,
            estimatedDurationHours: 3
          });
        }
        return requirements;
      },
      catch: (error2) => new CoalitionFormationError({
        reason: "analysis_failed",
        message: `Failed to analyze project requirements: ${error2}`,
        cause: error2
      })
    });
    const findComplementaryAgents = (requirements) => Effect_exports.try({
      try: () => {
        const matches = [];
        const availableAgents = [
          {
            agentId: "analyst_001",
            publicKey: "npub_analyst_001",
            personality: {
              name: "CodeAnalyst",
              role: "analyst",
              serviceSpecializations: ["code-review", "analysis", "testing"]
            },
            capabilities: ["code-review", "analysis", "testing", "debugging"],
            averageRating: 4.8,
            completedJobs: 127,
            trustScore: 0.92,
            currentBalance: 5e4,
            isAvailable: true
          },
          {
            agentId: "teacher_001",
            publicKey: "npub_teacher_001",
            personality: {
              name: "DocMaster",
              role: "teacher",
              serviceSpecializations: ["documentation", "tutorial-creation"]
            },
            capabilities: ["documentation", "tutorial-creation", "explanation"],
            averageRating: 4.6,
            completedJobs: 89,
            trustScore: 0.88,
            currentBalance: 35e3,
            isAvailable: true
          },
          {
            agentId: "specialist_001",
            publicKey: "npub_specialist_001",
            personality: {
              name: "AIExpert",
              role: "specialist",
              serviceSpecializations: ["ai-integration", "model-training"]
            },
            capabilities: ["ai-integration", "model-training", "optimization"],
            averageRating: 4.9,
            completedJobs: 203,
            trustScore: 0.95,
            currentBalance: 12e4,
            isAvailable: true
          }
        ];
        for (const agent of availableAgents) {
          const matchedSkills = [];
          const missingSkills = [];
          let totalContribution = 0;
          for (const req of requirements) {
            if (agent.capabilities.includes(req.skill)) {
              matchedSkills.push(req.skill);
              const weight = req.priority === "required" ? 1 : req.priority === "preferred" ? 0.7 : 0.3;
              totalContribution += weight;
            } else if (req.priority === "required") {
              missingSkills.push(req.skill);
            }
          }
          const requiredCount = requirements.filter((r) => r.priority === "required").length;
          const matchScore = requiredCount > 0 ? matchedSkills.filter((s) => requirements.find((r) => r.skill === s && r.priority === "required")).length / requiredCount : matchedSkills.length / Math.max(1, requirements.length);
          if (matchScore > 0) {
            matches.push({
              agent,
              matchScore,
              matchedSkills,
              missingSkills,
              estimatedContribution: totalContribution / Math.max(1, requirements.length)
            });
          }
        }
        matches.sort((a, b) => b.matchScore - a.matchScore);
        return matches;
      },
      catch: (error2) => new CoalitionFormationError({
        reason: "discovery_failed",
        message: `Failed to find complementary agents: ${error2}`,
        cause: error2
      })
    });
    const assessCoalitionViability = (agents, project3) => Effect_exports.try({
      try: () => {
        const allSkills = new Set(agents.flatMap((a) => a.capabilities));
        const requiredSkills = project3.requirements.filter((r) => r.priority === "required").map((r) => r.skill);
        const coveredRequired = requiredSkills.filter((s) => allSkills.has(s));
        const skillCoverage = requiredSkills.length > 0 ? coveredRequired.length / requiredSkills.length : 1;
        const trustLevel = agents.reduce((sum3, a) => sum3 + a.trustScore, 0) / agents.length;
        let successProbability = skillCoverage * trustLevel;
        const riskFactors = [];
        if (agents.length < project3.minAgentsRequired) {
          riskFactors.push("Insufficient number of agents");
          successProbability *= 0.5;
        }
        if (agents.length > project3.maxAgentsAllowed) {
          riskFactors.push("Too many agents may cause coordination overhead");
          successProbability *= 0.8;
        }
        const avgBalance = agents.reduce((sum3, a) => sum3 + a.currentBalance, 0) / agents.length;
        if (avgBalance < 1e4) {
          riskFactors.push("Low average agent balance may affect commitment");
          successProbability *= 0.9;
        }
        const recommendations = [];
        if (skillCoverage < 1) {
          recommendations.push(
            `Find agents with skills: ${requiredSkills.filter((s) => !allSkills.has(s)).join(", ")}`
          );
        }
        if (trustLevel < 0.8) {
          recommendations.push("Consider agents with higher trust scores");
        }
        if (agents.some((a) => a.averageRating < 4)) {
          recommendations.push("Some agents have low ratings - consider alternatives");
        }
        return {
          score: successProbability,
          skillCoverage,
          trustLevel,
          estimatedSuccessProbability: successProbability,
          riskFactors,
          recommendations
        };
      },
      catch: (error2) => new CoalitionFormationError({
        reason: "analysis_failed",
        message: `Failed to assess coalition viability: ${error2}`,
        cause: error2
      })
    });
    const proposeCoalition = (project3, agents) => Effect_exports.try({
      try: () => {
        const proposalId = `coalition_${Date.now()}_${Math.random().toString(36).substring(7)}`;
        const paymentSplits = {};
        let totalContribution = 0;
        const contributions = agents.map((agent) => {
          const matchingSkills = project3.requirements.filter((req) => agent.capabilities.includes(req.skill));
          const contribution = matchingSkills.reduce((sum3, skill) => {
            const weight = skill.priority === "required" ? 1 : skill.priority === "preferred" ? 0.7 : 0.3;
            return sum3 + weight * agent.trustScore;
          }, 0);
          return { agent, contribution };
        });
        totalContribution = contributions.reduce((sum3, c) => sum3 + c.contribution, 0);
        contributions.forEach(({ agent, contribution }) => {
          paymentSplits[agent.agentId] = Math.floor(contribution / totalContribution * 100);
        });
        const totalSplit = Object.values(paymentSplits).reduce((sum3, split8) => sum3 + split8, 0);
        if (totalSplit < 100) {
          const topAgent = contributions.sort((a, b) => b.contribution - a.contribution)[0].agent;
          paymentSplits[topAgent.agentId] += 100 - totalSplit;
        }
        const taskAssignments = {};
        agents.forEach((agent) => {
          taskAssignments[agent.agentId] = project3.requirements.filter((req) => agent.capabilities.includes(req.skill)).map((req) => req.skill);
        });
        const totalHours = project3.requirements.reduce((sum3, req) => sum3 + req.estimatedDurationHours, 0);
        const parallelFactor = Math.min(agents.length, 3);
        const estimatedHours = totalHours / parallelFactor;
        const estimatedCompletionTime = Date.now() + estimatedHours * 60 * 60 * 1e3;
        return {
          proposalId,
          project: project3,
          proposedMembers: agents,
          paymentSplits,
          taskAssignments,
          estimatedCompletionTime,
          proposedBy: agents[0].agentId,
          // First agent proposes
          expiresAt: Date.now() + 24 * 60 * 60 * 1e3
          // 24 hour expiry
        };
      },
      catch: (error2) => new CoalitionFormationError({
        reason: "proposal_failed",
        message: `Failed to create coalition proposal: ${error2}`,
        cause: error2
      })
    });
    const negotiateTerms = (proposal) => Effect_exports.try({
      try: () => {
        const contractId = `contract_${proposal.proposalId}`;
        const signatures = {};
        for (const agent of proposal.proposedMembers) {
          const acceptanceChance = agent.trustScore * (proposal.paymentSplits[agent.agentId] / 100);
          if (acceptanceChance > 0.3) {
            signatures[agent.agentId] = `sig_${agent.agentId}_${Date.now()}`;
          }
        }
        const allSigned = proposal.proposedMembers.every((agent) => signatures[agent.agentId]);
        if (!allSigned) {
          throw new CoalitionFormationError({
            reason: "negotiation_failed",
            message: "Not all agents agreed to the terms",
            cause: { signatures, required: proposal.proposedMembers.map((a) => a.agentId) }
          });
        }
        const escrowAddress = `bc1q_escrow_${contractId.substring(9, 20)}`;
        return {
          contractId,
          proposal,
          signatures,
          escrowAddress,
          status: "pending",
          createdAt: Date.now()
        };
      },
      catch: (error2) => new CoalitionFormationError({
        reason: "negotiation_failed",
        message: `Failed to negotiate coalition terms: ${error2}`,
        cause: error2
      })
    });
    const formalizeAgreement = (contract) => Effect_exports.try({
      try: () => {
        const coalitionId = `coalition_${contract.contractId.substring(9)}`;
        const internalChannelId = `channel_${coalitionId}`;
        const coalition = {
          coalitionId,
          contract: {
            ...contract,
            status: "active",
            activatedAt: Date.now()
          },
          members: contract.proposal.proposedMembers,
          projectProgress: 0,
          activeTasks: [],
          completedTasks: [],
          internalChannelId
        };
        activeCoalitions.set(coalitionId, coalition);
        contract.proposal.proposedMembers.forEach((agent) => {
          const profile = agentProfiles.get(agent.agentId);
          if (profile) {
            agentProfiles.set(agent.agentId, {
              ...profile,
              isAvailable: false
            });
          }
        });
        return coalition;
      },
      catch: (error2) => new CoalitionFormationError({
        reason: "formation_failed",
        message: `Failed to formalize coalition agreement: ${error2}`,
        cause: error2
      })
    });
    const broadcastOpportunity = (project3) => Effect_exports.try({
      try: () => {
        console.log(`Broadcast coalition opportunity for project: ${project3.title}`);
      },
      catch: (error2) => new CoalitionFormationError({
        reason: "formation_failed",
        message: `Failed to broadcast coalition opportunity: ${error2}`,
        cause: error2
      })
    });
    const monitorCoalitions = () => Stream_exports.repeat(
      Effect_exports.sync(() => Array.from(activeCoalitions.values())),
      Schedule_exports.spaced(Duration_exports.seconds(10))
    ).pipe(
      Stream_exports.tapError((error2) => Effect_exports.log(`Coalition monitoring error: ${error2}`))
    );
    return {
      analyzeProjectRequirements,
      findComplementaryAgents,
      assessCoalitionViability,
      proposeCoalition,
      negotiateTerms,
      formalizeAgreement,
      broadcastOpportunity,
      monitorCoalitions
    };
  })
);

// ../../packages/sdk/src/browser/ProjectCoordinationService.ts
var ProjectTask = Schema_exports.Struct({
  taskId: Schema_exports.String,
  projectId: Schema_exports.String,
  title: Schema_exports.String,
  description: Schema_exports.String,
  requiredSkills: Schema_exports.Array(Schema_exports.String),
  assignedTo: Schema_exports.optional(Schema_exports.String),
  // agentId
  status: Schema_exports.Union(
    Schema_exports.Literal("pending"),
    Schema_exports.Literal("assigned"),
    Schema_exports.Literal("in_progress"),
    Schema_exports.Literal("review"),
    Schema_exports.Literal("completed"),
    Schema_exports.Literal("blocked")
  ),
  dependencies: Schema_exports.Array(Schema_exports.String),
  // taskIds that must complete first
  estimatedHours: Schema_exports.Number,
  actualHours: Schema_exports.optional(Schema_exports.Number),
  output: Schema_exports.optional(Schema_exports.String),
  // Task deliverable
  createdAt: Schema_exports.Number,
  startedAt: Schema_exports.optional(Schema_exports.Number),
  completedAt: Schema_exports.optional(Schema_exports.Number)
});
var ProjectPlan = Schema_exports.Struct({
  planId: Schema_exports.String,
  projectId: Schema_exports.String,
  tasks: Schema_exports.Array(ProjectTask),
  criticalPath: Schema_exports.Array(Schema_exports.String),
  // taskIds in order
  estimatedDuration: Schema_exports.Number,
  // total hours
  parallelizationFactor: Schema_exports.Number,
  // how much can be done in parallel
  milestones: Schema_exports.Array(Schema_exports.Struct({
    name: Schema_exports.String,
    taskIds: Schema_exports.Array(Schema_exports.String),
    targetDate: Schema_exports.Number
  }))
});
var TaskAssignments = Schema_exports.Struct({
  assignments: Schema_exports.Record({ key: Schema_exports.String, value: Schema_exports.String }),
  // taskId -> agentId
  workload: Schema_exports.Record({ key: Schema_exports.String, value: Schema_exports.Number }),
  // agentId -> total hours
  conflicts: Schema_exports.Array(Schema_exports.String),
  // taskIds that couldn't be assigned
  recommendations: Schema_exports.Array(Schema_exports.String)
});
var ProjectSchedule = Schema_exports.Struct({
  scheduleId: Schema_exports.String,
  startTime: Schema_exports.Number,
  endTime: Schema_exports.Number,
  taskTimeline: Schema_exports.Array(Schema_exports.Struct({
    taskId: Schema_exports.String,
    agentId: Schema_exports.String,
    startTime: Schema_exports.Number,
    endTime: Schema_exports.Number
  })),
  bufferTime: Schema_exports.Number,
  // slack time built in
  riskScore: Schema_exports.Number
  // 0.0 to 1.0
});
var ProjectBlocker = Schema_exports.Struct({
  blockerId: Schema_exports.String,
  taskId: Schema_exports.String,
  type: Schema_exports.Union(
    Schema_exports.Literal("dependency"),
    Schema_exports.Literal("resource"),
    Schema_exports.Literal("technical"),
    Schema_exports.Literal("communication")
  ),
  description: Schema_exports.String,
  severity: Schema_exports.Union(Schema_exports.Literal("low"), Schema_exports.Literal("medium"), Schema_exports.Literal("high")),
  blockedSince: Schema_exports.Number,
  estimatedResolution: Schema_exports.optional(Schema_exports.Number)
});
var ProgressUpdate = Schema_exports.Struct({
  timestamp: Schema_exports.Number,
  coalitionId: Schema_exports.String,
  projectProgress: Schema_exports.Number,
  // 0.0 to 1.0
  tasksCompleted: Schema_exports.Number,
  tasksTotal: Schema_exports.Number,
  activeAgents: Schema_exports.Array(Schema_exports.String),
  blockers: Schema_exports.Array(ProjectBlocker),
  estimatedCompletion: Schema_exports.Number
});
var HandoffResult = Schema_exports.Struct({
  fromTaskId: Schema_exports.String,
  toTaskId: Schema_exports.String,
  fromAgentId: Schema_exports.String,
  toAgentId: Schema_exports.String,
  deliverables: Schema_exports.Array(Schema_exports.String),
  handoffNotes: Schema_exports.String,
  accepted: Schema_exports.Boolean,
  timestamp: Schema_exports.Number
});
var QualityReview = Schema_exports.Struct({
  reviewId: Schema_exports.String,
  taskId: Schema_exports.String,
  reviewerId: Schema_exports.String,
  score: Schema_exports.Number,
  // 0.0 to 1.0
  feedback: Schema_exports.String,
  issues: Schema_exports.Array(Schema_exports.String),
  approved: Schema_exports.Boolean,
  timestamp: Schema_exports.Number
});
var IntegratedDeliverable = Schema_exports.Struct({
  deliverableId: Schema_exports.String,
  projectId: Schema_exports.String,
  components: Schema_exports.Record({ key: Schema_exports.String, value: Schema_exports.String }),
  // taskId -> output
  integrationNotes: Schema_exports.String,
  finalOutput: Schema_exports.String,
  qualityScore: Schema_exports.Number,
  completedAt: Schema_exports.Number
});
var ProjectCoordinationError = class extends Data_exports.TaggedError("ProjectCoordinationError") {
};
var ProjectCoordinationService = class extends Context_exports.Tag("sdk/ProjectCoordinationService")() {
};
var ProjectCoordinationServiceLive = Layer_exports.effect(
  ProjectCoordinationService,
  Effect_exports.sync(() => {
    const activeProjects = /* @__PURE__ */ new Map();
    const taskProgress = /* @__PURE__ */ new Map();
    const projectSchedules = /* @__PURE__ */ new Map();
    const decomposeProject = (project3) => Effect_exports.try({
      try: () => {
        const planId = `plan_${project3.id}_${Date.now()}`;
        const tasks = [];
        let taskIndex = 0;
        const skillToTaskMap = /* @__PURE__ */ new Map();
        if (project3.requirements.some((r) => r.skill.includes("analysis") || r.skill.includes("review"))) {
          const analysisTask = {
            taskId: `task_${taskIndex++}`,
            projectId: project3.id,
            title: "Initial Analysis and Requirements Review",
            description: "Analyze project requirements and create detailed plan",
            requiredSkills: ["analysis", "planning"],
            status: "pending",
            dependencies: [],
            estimatedHours: 4,
            createdAt: Date.now()
          };
          tasks.push(analysisTask);
          skillToTaskMap.set("analysis", [analysisTask.taskId]);
        }
        for (const req of project3.requirements) {
          const coreTask = {
            taskId: `task_${taskIndex++}`,
            projectId: project3.id,
            title: `Implement ${req.skill}`,
            description: `Complete ${req.skill} requirement for the project`,
            requiredSkills: [req.skill],
            status: "pending",
            dependencies: skillToTaskMap.get("analysis") || [],
            estimatedHours: req.estimatedDurationHours,
            createdAt: Date.now()
          };
          tasks.push(coreTask);
          const existing = skillToTaskMap.get(req.skill) || [];
          skillToTaskMap.set(req.skill, [...existing, coreTask.taskId]);
        }
        if (tasks.length > 1) {
          const integrationTask = {
            taskId: `task_${taskIndex++}`,
            projectId: project3.id,
            title: "Integration and Testing",
            description: "Integrate all components and perform testing",
            requiredSkills: ["testing", "integration"],
            status: "pending",
            dependencies: tasks.filter((t) => t.dependencies.length > 0).map((t) => t.taskId),
            estimatedHours: Math.max(4, tasks.length * 0.5),
            createdAt: Date.now()
          };
          tasks.push(integrationTask);
        }
        const deliveryTask = {
          taskId: `task_${taskIndex++}`,
          projectId: project3.id,
          title: "Documentation and Final Delivery",
          description: "Create documentation and prepare final deliverables",
          requiredSkills: ["documentation", "delivery"],
          status: "pending",
          dependencies: tasks.map((t) => t.taskId).slice(-2),
          // Depends on last few tasks
          estimatedHours: 3,
          createdAt: Date.now()
        };
        tasks.push(deliveryTask);
        const criticalPath = [];
        const findCriticalPath = (taskId) => {
          criticalPath.push(taskId);
          const dependents = tasks.filter((t) => t.dependencies.includes(taskId));
          if (dependents.length > 0) {
            const critical = dependents.sort((a, b) => b.estimatedHours - a.estimatedHours)[0];
            findCriticalPath(critical.taskId);
          }
        };
        const rootTasks = tasks.filter((t) => t.dependencies.length === 0);
        if (rootTasks.length > 0) {
          findCriticalPath(rootTasks[0].taskId);
        }
        const totalHours = tasks.reduce((sum3, t) => sum3 + t.estimatedHours, 0);
        const maxParallel = Math.min(
          project3.maxAgentsAllowed,
          tasks.filter((t) => t.dependencies.length === 0).length
        );
        const parallelizationFactor = Math.min(maxParallel, 3);
        const milestones = [
          {
            name: "Project Kickoff",
            taskIds: tasks.filter((t) => t.dependencies.length === 0).map((t) => t.taskId),
            targetDate: Date.now() + 24 * 60 * 60 * 1e3
          },
          {
            name: "Core Implementation Complete",
            taskIds: tasks.filter(
              (t) => t.requiredSkills.some((s) => project3.requirements.find((r) => r.skill === s))
            ).map((t) => t.taskId),
            targetDate: Date.now() + 3 * 24 * 60 * 60 * 1e3
          },
          {
            name: "Project Completion",
            taskIds: [deliveryTask.taskId],
            targetDate: project3.deadlineTimestamp
          }
        ];
        const plan = {
          planId,
          projectId: project3.id,
          tasks,
          criticalPath,
          estimatedDuration: totalHours,
          parallelizationFactor,
          milestones
        };
        activeProjects.set(planId, plan);
        tasks.forEach((task) => taskProgress.set(task.taskId, task));
        return plan;
      },
      catch: (error2) => new ProjectCoordinationError({
        reason: "decomposition_failed",
        message: `Failed to decompose project: ${error2}`,
        cause: error2
      })
    });
    const assignTasks = (plan, coalition) => Effect_exports.try({
      try: () => {
        const assignments = {};
        const workload = {};
        const conflicts = [];
        const recommendations = [];
        coalition.members.forEach((member) => {
          workload[member.agentId] = 0;
        });
        const sortedTasks = [...plan.tasks].sort((a, b) => a.dependencies.length - b.dependencies.length);
        for (const task of sortedTasks) {
          const eligibleAgents = coalition.members.filter(
            (member) => task.requiredSkills.every((skill) => member.capabilities.includes(skill))
          );
          if (eligibleAgents.length === 0) {
            conflicts.push(task.taskId);
            recommendations.push(`No agent has skills for task ${task.title}: ${task.requiredSkills.join(", ")}`);
            continue;
          }
          const selectedAgent = eligibleAgents.sort(
            (a, b) => (workload[a.agentId] || 0) - (workload[b.agentId] || 0)
          )[0];
          assignments[task.taskId] = selectedAgent.agentId;
          workload[selectedAgent.agentId] = (workload[selectedAgent.agentId] || 0) + task.estimatedHours;
          const updatedTask = { ...task, assignedTo: selectedAgent.agentId, status: "assigned" };
          taskProgress.set(task.taskId, updatedTask);
        }
        const avgWorkload = Object.values(workload).reduce((sum3, w) => sum3 + w, 0) / coalition.members.length;
        const maxWorkload = Math.max(...Object.values(workload));
        if (maxWorkload > avgWorkload * 1.5) {
          recommendations.push("Workload imbalance detected - consider redistributing tasks");
        }
        if (conflicts.length > 0) {
          recommendations.push(`${conflicts.length} tasks could not be assigned due to skill gaps`);
        }
        return {
          assignments,
          workload,
          conflicts,
          recommendations
        };
      },
      catch: (error2) => new ProjectCoordinationError({
        reason: "assignment_failed",
        message: `Failed to assign tasks: ${error2}`,
        cause: error2
      })
    });
    const optimizeSchedule = (assignments) => Effect_exports.try({
      try: () => {
        const scheduleId = `schedule_${Date.now()}`;
        const startTime = Date.now();
        const taskTimeline = [];
        const assignedTasks = Array.from(taskProgress.values()).filter(
          (task) => assignments.assignments[task.taskId]
        );
        const scheduled = /* @__PURE__ */ new Set();
        const agentEndTimes = /* @__PURE__ */ new Map();
        Object.keys(assignments.workload).forEach((agentId) => {
          agentEndTimes.set(agentId, startTime);
        });
        while (scheduled.size < assignedTasks.length) {
          for (const task of assignedTasks) {
            if (scheduled.has(task.taskId)) continue;
            const depsComplete = task.dependencies.every((dep) => scheduled.has(dep));
            if (!depsComplete) continue;
            const agentId = assignments.assignments[task.taskId];
            if (!agentId) continue;
            let earliestStart = agentEndTimes.get(agentId) || startTime;
            for (const depId of task.dependencies) {
              const depSchedule = taskTimeline.find((t) => t.taskId === depId);
              if (depSchedule) {
                earliestStart = Math.max(earliestStart, depSchedule.endTime);
              }
            }
            const taskStart = earliestStart;
            const taskEnd = taskStart + task.estimatedHours * 60 * 60 * 1e3;
            taskTimeline.push({
              taskId: task.taskId,
              agentId,
              startTime: taskStart,
              endTime: taskEnd
            });
            scheduled.add(task.taskId);
            agentEndTimes.set(agentId, taskEnd);
          }
        }
        const endTime = Math.max(...taskTimeline.map((t) => t.endTime));
        const bufferTime = (endTime - startTime) * 0.2;
        const criticalTasks = taskTimeline.filter(
          (t) => assignedTasks.find((task) => task.taskId === t.taskId)?.dependencies.length || 0 > 2
        );
        const riskScore = Math.min(1, criticalTasks.length / Math.max(1, taskTimeline.length));
        const schedule4 = {
          scheduleId,
          startTime,
          endTime: endTime + bufferTime,
          taskTimeline,
          bufferTime,
          riskScore
        };
        projectSchedules.set(scheduleId, schedule4);
        return schedule4;
      },
      catch: (error2) => new ProjectCoordinationError({
        reason: "scheduling_failed",
        message: `Failed to optimize schedule: ${error2}`,
        cause: error2
      })
    });
    const monitorProgress = (coalition) => Stream_exports.repeat(
      Effect_exports.try({
        try: () => {
          const coalitionTasks = Array.from(taskProgress.values()).filter(
            (task) => task.projectId === coalition.contract.proposal.project.id
          );
          const completed = coalitionTasks.filter((t) => t.status === "completed").length;
          const total = coalitionTasks.length;
          const projectProgress = total > 0 ? completed / total : 0;
          const blockers = coalitionTasks.filter((t) => t.status === "blocked").map((task) => ({
            blockerId: `blocker_${task.taskId}`,
            taskId: task.taskId,
            type: "dependency",
            description: `Task ${task.title} is blocked`,
            severity: "medium",
            blockedSince: Date.now()
          }));
          const remainingHours = coalitionTasks.filter((t) => t.status !== "completed").reduce((sum3, t) => sum3 + t.estimatedHours, 0);
          const avgHoursPerDay = 8 * coalition.members.length;
          const daysRemaining = remainingHours / avgHoursPerDay;
          const estimatedCompletion = Date.now() + daysRemaining * 24 * 60 * 60 * 1e3;
          const update5 = {
            timestamp: Date.now(),
            coalitionId: coalition.coalitionId,
            projectProgress,
            tasksCompleted: completed,
            tasksTotal: total,
            activeAgents: coalition.members.filter((m) => m.isAvailable).map((m) => m.agentId),
            blockers,
            estimatedCompletion
          };
          return [update5];
        },
        catch: (error2) => new ProjectCoordinationError({
          reason: "monitoring_failed",
          message: `Failed to monitor progress: ${error2}`,
          cause: error2
        })
      }),
      Schedule_exports.spaced(Duration_exports.seconds(30))
    );
    const coordinateHandoffs = (completedTask, nextTask) => Effect_exports.try({
      try: () => {
        if (!completedTask.assignedTo || !nextTask.assignedTo) {
          throw new Error("Tasks must be assigned for handoff");
        }
        if (completedTask.status !== "completed") {
          throw new Error("Source task must be completed for handoff");
        }
        const handoff = {
          fromTaskId: completedTask.taskId,
          toTaskId: nextTask.taskId,
          fromAgentId: completedTask.assignedTo,
          toAgentId: nextTask.assignedTo,
          deliverables: [completedTask.output || ""],
          handoffNotes: `Handoff from ${completedTask.title} to ${nextTask.title}`,
          accepted: true,
          timestamp: Date.now()
        };
        const updatedTask = {
          ...nextTask,
          status: "in_progress",
          startedAt: Date.now()
        };
        taskProgress.set(nextTask.taskId, updatedTask);
        return handoff;
      },
      catch: (error2) => new ProjectCoordinationError({
        reason: "handoff_failed",
        message: `Failed to coordinate handoff: ${error2}`,
        cause: error2
      })
    });
    const manageBlockers = (blocker) => Effect_exports.try({
      try: () => {
        const task = taskProgress.get(blocker.taskId);
        if (!task) {
          throw new Error(`Task ${blocker.taskId} not found`);
        }
        let estimatedResolution = Date.now();
        switch (blocker.type) {
          case "dependency": {
            const depsComplete = task.dependencies.every((depId) => {
              const dep = taskProgress.get(depId);
              return dep && dep.status === "completed";
            });
            if (depsComplete) {
              const unblocked = { ...task, status: "assigned" };
              taskProgress.set(task.taskId, unblocked);
              estimatedResolution = Date.now();
            } else {
              estimatedResolution = Date.now() + 4 * 60 * 60 * 1e3;
            }
            break;
          }
          case "resource":
            estimatedResolution = Date.now() + 2 * 60 * 60 * 1e3;
            break;
          case "technical":
            estimatedResolution = Date.now() + 8 * 60 * 60 * 1e3;
            break;
          case "communication":
            estimatedResolution = Date.now() + 1 * 60 * 60 * 1e3;
            break;
        }
        return {
          ...blocker,
          estimatedResolution
        };
      },
      catch: (error2) => new ProjectCoordinationError({
        reason: "handoff_failed",
        message: `Failed to manage blocker: ${error2}`,
        cause: error2
      })
    });
    const reviewTaskOutputs = (task) => Effect_exports.try({
      try: () => {
        if (!task.output) {
          throw new Error("Task has no output to review");
        }
        let score = 0.8;
        const issues = [];
        if (task.completedAt && task.startedAt) {
          const actualDuration = (task.completedAt - task.startedAt) / (60 * 60 * 1e3);
          if (actualDuration > task.estimatedHours * 1.2) {
            score -= 0.1;
            issues.push("Task took longer than estimated");
          }
        }
        if (task.output.length < 100) {
          score -= 0.1;
          issues.push("Output seems too brief");
        }
        const review = {
          reviewId: `review_${task.taskId}_${Date.now()}`,
          taskId: task.taskId,
          reviewerId: "system",
          // In production, another agent would review
          score,
          feedback: issues.length > 0 ? `Issues found: ${issues.join(", ")}` : "Task completed satisfactorily",
          issues,
          approved: score >= 0.6,
          timestamp: Date.now()
        };
        return review;
      },
      catch: (error2) => new ProjectCoordinationError({
        reason: "review_failed",
        message: `Failed to review task outputs: ${error2}`,
        cause: error2
      })
    });
    const integrateDeliverables = (taskResults) => Effect_exports.try({
      try: () => {
        if (taskResults.length === 0) {
          throw new Error("No task results to integrate");
        }
        const projectId = taskResults[0].projectId;
        const components = {};
        taskResults.forEach((task) => {
          if (task.output) {
            components[task.taskId] = task.output;
          }
        });
        const finalOutput = Object.entries(components).map(([taskId, output3]) => {
          const task = taskResults.find((t) => t.taskId === taskId);
          return `## ${task?.title || taskId}

${output3}
`;
        }).join("\n---\n\n");
        const qualityScore = taskResults.reduce((sum3, task) => {
          return sum3 + (task.status === "completed" ? 0.9 : 0.5);
        }, 0) / taskResults.length;
        const deliverable = {
          deliverableId: `deliverable_${projectId}_${Date.now()}`,
          projectId,
          components,
          integrationNotes: `Integrated ${taskResults.length} task outputs`,
          finalOutput,
          qualityScore,
          completedAt: Date.now()
        };
        return deliverable;
      },
      catch: (error2) => new ProjectCoordinationError({
        reason: "integration_failed",
        message: `Failed to integrate deliverables: ${error2}`,
        cause: error2
      })
    });
    const validateProjectCompletion = (deliverable) => Effect_exports.try({
      try: () => {
        const issues = [];
        if (deliverable.qualityScore < 0.7) {
          issues.push("Overall quality score is below threshold");
        }
        const plan = Array.from(activeProjects.values()).find(
          (p) => p.projectId === deliverable.projectId
        );
        if (plan) {
          const missingTasks = plan.tasks.filter(
            (task) => !deliverable.components[task.taskId]
          );
          if (missingTasks.length > 0) {
            issues.push(`Missing outputs from ${missingTasks.length} tasks`);
          }
        }
        if (deliverable.finalOutput.length < 500) {
          issues.push("Final deliverable seems incomplete");
        }
        return {
          isComplete: issues.length === 0,
          issues
        };
      },
      catch: (error2) => new ProjectCoordinationError({
        reason: "integration_failed",
        message: `Failed to validate project completion: ${error2}`,
        cause: error2
      })
    });
    return {
      decomposeProject,
      assignTasks,
      optimizeSchedule,
      monitorProgress,
      coordinateHandoffs,
      manageBlockers,
      reviewTaskOutputs,
      integrateDeliverables,
      validateProjectCompletion
    };
  })
);

// ../../packages/sdk/src/browser/ServiceOfferingService.ts
var ServiceCapability = Schema_exports.Struct({
  id: Schema_exports.String,
  name: Schema_exports.String,
  description: Schema_exports.String,
  inputTypes: Schema_exports.Array(Schema_exports.Literal("url", "event", "job", "text")),
  outputType: Schema_exports.String,
  pricing: Schema_exports.Struct({
    basePrice: Schema_exports.Number,
    perUnit: Schema_exports.optional(Schema_exports.String),
    unitLimit: Schema_exports.optional(Schema_exports.Number)
  })
});
var ServiceOffering = Schema_exports.Struct({
  serviceId: Schema_exports.String,
  name: Schema_exports.String,
  description: Schema_exports.String,
  capabilities: Schema_exports.Array(ServiceCapability),
  provider: Schema_exports.String,
  lightningAddress: Schema_exports.optional(Schema_exports.String),
  relayHints: Schema_exports.optional(Schema_exports.Array(Schema_exports.String)),
  created_at: Schema_exports.Number
});
var JobRequest = Schema_exports.Struct({
  jobId: Schema_exports.String,
  serviceId: Schema_exports.String,
  requestKind: Schema_exports.Number,
  input: Schema_exports.String,
  inputType: Schema_exports.Union(
    Schema_exports.Literal("url"),
    Schema_exports.Literal("event"),
    Schema_exports.Literal("job"),
    Schema_exports.Literal("text")
  ),
  parameters: Schema_exports.optional(Schema_exports.Record({ key: Schema_exports.String, value: Schema_exports.Unknown })),
  bidAmount: Schema_exports.Number,
  requester: Schema_exports.String,
  provider: Schema_exports.String,
  created_at: Schema_exports.Number
});
var JobResult = Schema_exports.Struct({
  jobId: Schema_exports.String,
  requestEventId: Schema_exports.String,
  resultKind: Schema_exports.Number,
  result: Schema_exports.String,
  status: Schema_exports.Union(
    Schema_exports.Literal("payment-required"),
    Schema_exports.Literal("processing"),
    Schema_exports.Literal("error"),
    Schema_exports.Literal("success"),
    Schema_exports.Literal("partial")
  ),
  provider: Schema_exports.String,
  computeTime: Schema_exports.optional(Schema_exports.Number),
  tokensUsed: Schema_exports.optional(Schema_exports.Number),
  confidence: Schema_exports.optional(Schema_exports.Number),
  created_at: Schema_exports.Number
});
var CreateJobRequestParams = Schema_exports.Struct({
  serviceId: Schema_exports.String,
  input: Schema_exports.String,
  inputType: Schema_exports.Union(
    Schema_exports.Literal("url"),
    Schema_exports.Literal("event"),
    Schema_exports.Literal("job"),
    Schema_exports.Literal("text")
  ),
  parameters: Schema_exports.optional(Schema_exports.Record({ key: Schema_exports.String, value: Schema_exports.Unknown })),
  bidAmount: Schema_exports.Number,
  providerPubkey: Schema_exports.String
});
var ServiceOfferingError = class extends Data_exports.TaggedError("ServiceOfferingError") {
};
var ServiceOfferingService = class extends Context_exports.Tag("sdk/ServiceOfferingService")() {
};
var generateSubId3 = () => `sub-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
var NIP90_JOB_REQUEST_KINDS2 = {
  TEXT_GENERATION: 5e3,
  CODE_GENERATION: 5001,
  IMAGE_GENERATION: 5100,
  AUDIO_GENERATION: 5200,
  VIDEO_GENERATION: 5300
};
var NIP90_JOB_RESULT_KINDS2 = {
  TEXT_GENERATION: 6e3,
  CODE_GENERATION: 6001,
  IMAGE_GENERATION: 6100,
  AUDIO_GENERATION: 6200,
  VIDEO_GENERATION: 6300
};
var ServiceOfferingServiceLive = Layer_exports.effect(
  ServiceOfferingService,
  Effect_exports.gen(function* () {
    const wsService = yield* WebSocketService2;
    const connection = yield* wsService.connect("ws://localhost:3003/relay").pipe(
      Effect_exports.scoped,
      Effect_exports.catchAll(
        (error2) => Effect_exports.fail(
          new ServiceOfferingError({
            reason: "connection_failed",
            message: error2.message,
            cause: error2
          })
        )
      )
    );
    const serviceCache = yield* Ref_exports.make(/* @__PURE__ */ new Map());
    const parseMessage = (data) => {
      try {
        const msg = JSON.parse(data);
        if (Array.isArray(msg) && msg.length >= 2) {
          return Option_exports.some(msg);
        }
        return Option_exports.none();
      } catch {
        return Option_exports.none();
      }
    };
    const subscribeToServices = Effect_exports.gen(function* () {
      const subId = generateSubId3();
      const req = JSON.stringify([
        "REQ",
        subId,
        {
          kinds: [31990],
          // NIP-90 service offering
          limit: 100
        }
      ]);
      yield* connection.send(req).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new ServiceOfferingError({
              reason: "subscription_failed",
              message: "Failed to subscribe to services",
              cause: error2
            })
          )
        )
      );
      return connection.messages.pipe(
        Stream_exports.mapEffect(
          (data) => Effect_exports.gen(function* () {
            const msg = parseMessage(data);
            if (Option_exports.isNone(msg)) return Option_exports.none();
            const message = msg.value;
            if (message[0] === "EVENT" && message[1] === subId) {
              const event = message[2];
              if (event.kind === 31990) {
                try {
                  const content = JSON.parse(event.content);
                  const service3 = {
                    serviceId: content.serviceId,
                    name: content.name,
                    description: content.description,
                    capabilities: content.capabilities || [],
                    provider: event.pubkey,
                    lightningAddress: content.lightningAddress,
                    relayHints: content.relayHints,
                    created_at: event.created_at
                  };
                  yield* Ref_exports.update(serviceCache, (cache) => {
                    const newCache = new Map(cache);
                    newCache.set(service3.serviceId, service3);
                    return newCache;
                  });
                  return Option_exports.some(service3);
                } catch {
                  return Option_exports.none();
                }
              }
            }
            return Option_exports.none();
          })
        ),
        Stream_exports.filter(Option_exports.isSome),
        Stream_exports.map((opt) => opt.value),
        Stream_exports.catchAll(
          (error2) => Stream_exports.fail(
            new ServiceOfferingError({
              reason: "subscription_failed",
              message: error2 instanceof Error ? error2.message : "Unknown error",
              cause: error2
            })
          )
        )
      );
    });
    const subscribeToJobRequests = Effect_exports.gen(function* () {
      const subId = generateSubId3();
      const req = JSON.stringify([
        "REQ",
        subId,
        {
          kinds: Object.values(NIP90_JOB_REQUEST_KINDS2),
          limit: 50
        }
      ]);
      yield* connection.send(req).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new ServiceOfferingError({
              reason: "subscription_failed",
              message: "Failed to subscribe to job requests",
              cause: error2
            })
          )
        )
      );
      return connection.messages.pipe(
        Stream_exports.mapEffect(
          (data) => Effect_exports.sync(() => {
            const msg = parseMessage(data);
            if (Option_exports.isNone(msg)) return Option_exports.none();
            const message = msg.value;
            if (message[0] === "EVENT" && message[1] === subId) {
              const event = message[2];
              if (Object.values(NIP90_JOB_REQUEST_KINDS2).includes(event.kind)) {
                try {
                  const content = JSON.parse(event.content);
                  const jobRequest = {
                    jobId: event.id,
                    serviceId: content.serviceId,
                    requestKind: event.kind,
                    input: content.input,
                    inputType: content.inputType || "text",
                    parameters: content.parameters,
                    bidAmount: content.bidAmount || 0,
                    requester: event.pubkey,
                    provider: event.tags.find((t) => t[0] === "p")?.[1] || "",
                    created_at: event.created_at
                  };
                  return Option_exports.some(jobRequest);
                } catch {
                  return Option_exports.none();
                }
              }
            }
            return Option_exports.none();
          })
        ),
        Stream_exports.filter(Option_exports.isSome),
        Stream_exports.map((opt) => opt.value),
        Stream_exports.catchAll(
          (error2) => Stream_exports.fail(
            new ServiceOfferingError({
              reason: "subscription_failed",
              message: error2 instanceof Error ? error2.message : "Unknown error",
              cause: error2
            })
          )
        )
      );
    });
    const subscribeToJobResults = (jobId) => Effect_exports.gen(function* () {
      const subId = generateSubId3();
      const req = JSON.stringify([
        "REQ",
        subId,
        {
          kinds: Object.values(NIP90_JOB_RESULT_KINDS2),
          "#e": [jobId],
          limit: 10
        }
      ]);
      yield* connection.send(req).pipe(
        Effect_exports.catchAll(
          (error2) => Effect_exports.fail(
            new ServiceOfferingError({
              reason: "subscription_failed",
              message: "Failed to subscribe to job results",
              cause: error2
            })
          )
        )
      );
      return connection.messages.pipe(
        Stream_exports.mapEffect(
          (data) => Effect_exports.sync(() => {
            const msg = parseMessage(data);
            if (Option_exports.isNone(msg)) return Option_exports.none();
            const message = msg.value;
            if (message[0] === "EVENT" && message[1] === subId) {
              const event = message[2];
              if (Object.values(NIP90_JOB_RESULT_KINDS2).includes(event.kind)) {
                const jobTag = event.tags.find((tag3) => tag3[0] === "e" && tag3[1] === jobId);
                if (jobTag) {
                  try {
                    const content = JSON.parse(event.content);
                    const jobResult = {
                      jobId,
                      requestEventId: jobId,
                      resultKind: event.kind,
                      result: content.result || event.content,
                      status: content.status || "success",
                      provider: event.pubkey,
                      computeTime: content.computeTime,
                      tokensUsed: content.tokensUsed,
                      confidence: content.confidence,
                      created_at: event.created_at
                    };
                    return Option_exports.some(jobResult);
                  } catch {
                    return Option_exports.none();
                  }
                }
              }
            }
            return Option_exports.none();
          })
        ),
        Stream_exports.filter(Option_exports.isSome),
        Stream_exports.map((opt) => opt.value),
        Stream_exports.catchAll(
          (error2) => Stream_exports.fail(
            new ServiceOfferingError({
              reason: "subscription_failed",
              message: error2 instanceof Error ? error2.message : "Unknown error",
              cause: error2
            })
          )
        )
      );
    });
    return {
      services: Stream_exports.unwrap(subscribeToServices),
      jobRequests: Stream_exports.unwrap(subscribeToJobRequests),
      jobResults: (jobId) => Stream_exports.unwrap(subscribeToJobResults(jobId)),
      requestJob: (_params) => Effect_exports.gen(function* () {
        return yield* Effect_exports.fail(
          new ServiceOfferingError({
            reason: "request_failed",
            message: "Job request requires key management implementation"
          })
        );
      })
    };
  })
);

// src/stubs/SparkServiceStub.ts
var SparkError2 = class extends Data_exports.TaggedError("SparkError") {
};
var LightningInvoice2 = Schema_exports.Struct({
  id: Schema_exports.String,
  invoice: Schema_exports.String,
  amountSats: Schema_exports.Number,
  memo: Schema_exports.optional(Schema_exports.String),
  createdAt: Schema_exports.Number,
  expiresAt: Schema_exports.Number,
  sparkAddress: Schema_exports.optional(Schema_exports.String)
});
var PaymentResult = Schema_exports.Struct({
  success: Schema_exports.Boolean,
  transactionId: Schema_exports.optional(Schema_exports.String),
  amountSats: Schema_exports.Number,
  fee: Schema_exports.optional(Schema_exports.Number),
  timestamp: Schema_exports.Number
});
var WalletInfo2 = Schema_exports.Struct({
  id: Schema_exports.String,
  sparkAddress: Schema_exports.String,
  balanceSats: Schema_exports.Number,
  pendingSats: Schema_exports.Number
});
var SparkService2 = class extends Context_exports.Tag("SparkService")() {
};
var SparkServiceLive2 = Layer_exports.succeed(
  SparkService2,
  SparkService2.of({
    createWallet: () => Effect_exports.fail(
      new SparkError2({
        reason: "wallet_creation_failed",
        message: "Lightning payments not available in browser"
      })
    ),
    getWalletInfo: () => Effect_exports.fail(
      new SparkError2({
        reason: "network_error",
        message: "Lightning payments not available in browser"
      })
    ),
    createInvoice: () => Effect_exports.fail(
      new SparkError2({
        reason: "invoice_creation_failed",
        message: "Lightning payments not available in browser"
      })
    ),
    payInvoice: () => Effect_exports.fail(
      new SparkError2({
        reason: "payment_failed",
        message: "Lightning payments not available in browser"
      })
    )
  })
);

// ../../packages/sdk/src/browser/TrustReputationService.ts
var ReputationDimension = Schema_exports.Union(
  Schema_exports.Literal("quality"),
  Schema_exports.Literal("timeliness"),
  Schema_exports.Literal("collaboration"),
  Schema_exports.Literal("reliability"),
  Schema_exports.Literal("communication"),
  Schema_exports.Literal("innovation")
);
var InteractionRecord = Schema_exports.Struct({
  interactionId: Schema_exports.String,
  timestamp: Schema_exports.Number,
  type: Schema_exports.Union(
    Schema_exports.Literal("job_completion"),
    Schema_exports.Literal("coalition_participation"),
    Schema_exports.Literal("peer_review"),
    Schema_exports.Literal("dispute_resolution")
  ),
  counterpartyId: Schema_exports.String,
  projectId: Schema_exports.optional(Schema_exports.String),
  outcome: Schema_exports.Union(
    Schema_exports.Literal("success"),
    Schema_exports.Literal("partial_success"),
    Schema_exports.Literal("failure"),
    Schema_exports.Literal("disputed")
  ),
  ratings: Schema_exports.Record({ key: ReputationDimension, value: Schema_exports.Number }),
  // 0.0 to 5.0
  feedback: Schema_exports.optional(Schema_exports.String),
  verificationHash: Schema_exports.String
  // Proof of interaction
});
var ReputationUpdate = Schema_exports.Struct({
  agentId: Schema_exports.String,
  dimension: ReputationDimension,
  oldScore: Schema_exports.Number,
  newScore: Schema_exports.Number,
  changeReason: Schema_exports.String,
  updateTimestamp: Schema_exports.Number
});
var ReputationHistory = Schema_exports.Struct({
  agentId: Schema_exports.String,
  totalInteractions: Schema_exports.Number,
  dimensionScores: Schema_exports.Record({ key: ReputationDimension, value: Schema_exports.Number }),
  // Current scores
  overallScore: Schema_exports.Number,
  // Weighted average
  trend: Schema_exports.Union(Schema_exports.Literal("improving"), Schema_exports.Literal("stable"), Schema_exports.Literal("declining")),
  history: Schema_exports.Array(InteractionRecord),
  lastUpdated: Schema_exports.Number
});
var TrustScore = Schema_exports.Struct({
  fromAgent: Schema_exports.String,
  toAgent: Schema_exports.String,
  directTrust: Schema_exports.Number,
  // Based on direct interactions
  indirectTrust: Schema_exports.Number,
  // Based on network effects
  combinedTrust: Schema_exports.Number,
  // Weighted combination
  confidence: Schema_exports.Number,
  // How confident in the trust score
  lastInteraction: Schema_exports.optional(Schema_exports.Number)
});
var NetworkPosition = Schema_exports.Struct({
  agentId: Schema_exports.String,
  centrality: Schema_exports.Number,
  // How central in the network
  influence: Schema_exports.Number,
  // How much influence on others
  trustRadius: Schema_exports.Number,
  // How many agents trust this one
  avgIncomingTrust: Schema_exports.Number,
  // Average trust from others
  avgOutgoingTrust: Schema_exports.Number,
  // Average trust to others
  clusterMembership: Schema_exports.Array(Schema_exports.String)
  // Trust cluster IDs
});
var TrustCluster = Schema_exports.Struct({
  clusterId: Schema_exports.String,
  members: Schema_exports.Array(Schema_exports.String),
  // agentIds
  avgInternalTrust: Schema_exports.Number,
  // Trust within cluster
  avgExternalTrust: Schema_exports.Number,
  // Trust to outside
  specializations: Schema_exports.Array(Schema_exports.String),
  // Common skills
  formationDate: Schema_exports.Number
});
var PremiumRate = Schema_exports.Struct({
  basePremium: Schema_exports.Number,
  // Multiplier on base rates
  dimensionPremiums: Schema_exports.Record({ key: ReputationDimension, value: Schema_exports.Number }),
  totalPremium: Schema_exports.Number,
  justification: Schema_exports.String
});
var RiskAdjustment = Schema_exports.Struct({
  baseRisk: Schema_exports.Number,
  // 0.0 to 1.0
  trustMitigation: Schema_exports.Number,
  // Risk reduction from trust
  adjustedRisk: Schema_exports.Number,
  recommendedEscrow: Schema_exports.Number,
  // % to hold in escrow
  insurancePremium: Schema_exports.Number
  // Additional cost for risk
});
var TrustOptimization = Schema_exports.Struct({
  optimalCoalition: Coalition,
  trustScore: Schema_exports.Number,
  alternativeCoalitions: Schema_exports.Array(Schema_exports.Struct({
    coalition: Coalition,
    trustScore: Schema_exports.Number,
    tradeoffs: Schema_exports.Array(Schema_exports.String)
  })),
  recommendations: Schema_exports.Array(Schema_exports.String)
});
var TrustReputationError = class extends Data_exports.TaggedError("TrustReputationError") {
};
var TrustReputationService = class extends Context_exports.Tag("sdk/TrustReputationService")() {
};
var TrustReputationServiceLive = Layer_exports.effect(
  TrustReputationService,
  Effect_exports.sync(() => {
    const reputationData = /* @__PURE__ */ new Map();
    const trustMatrix = /* @__PURE__ */ new Map();
    const interactionHistory = /* @__PURE__ */ new Map();
    const initializeReputation = (agentId) => {
      const initial = {
        agentId,
        totalInteractions: 0,
        dimensionScores: {
          quality: 3,
          timeliness: 3,
          collaboration: 3,
          reliability: 3,
          communication: 3,
          innovation: 3
        },
        overallScore: 3,
        trend: "stable",
        history: [],
        lastUpdated: Date.now()
      };
      reputationData.set(agentId, initial);
      return initial;
    };
    const updateAgentReputation = (agentId, interaction) => Effect_exports.try({
      try: () => {
        let reputation = reputationData.get(agentId);
        if (!reputation) {
          reputation = initializeReputation(agentId);
        }
        const updatedReputation = {
          ...reputation,
          dimensionScores: { ...reputation.dimensionScores },
          history: [...reputation.history]
        };
        const updates = [];
        const outcomeMultiplier = interaction.outcome === "success" ? 1.1 : interaction.outcome === "partial_success" ? 1 : interaction.outcome === "failure" ? 0.9 : 0.95;
        Object.entries(interaction.ratings).forEach(([dimension, rating]) => {
          const dim = dimension;
          const oldScore = reputation.dimensionScores[dim];
          const weight = 1 / (reputation.totalInteractions + 1);
          const newScore = oldScore * (1 - weight) + rating * outcomeMultiplier * weight;
          const boundedScore = Math.max(0, Math.min(5, newScore));
          updatedReputation.dimensionScores[dim] = boundedScore;
          updates.push({
            agentId,
            dimension: dim,
            oldScore,
            newScore: boundedScore,
            changeReason: `${interaction.type} - ${interaction.outcome}`,
            updateTimestamp: Date.now()
          });
        });
        const dimensionValues = Object.values(updatedReputation.dimensionScores);
        updatedReputation.overallScore = dimensionValues.reduce((sum3, score) => sum3 + score, 0) / dimensionValues.length;
        if (updatedReputation.history.length >= 5) {
          const recentScores = updatedReputation.history.slice(-5).map((h) => {
            const avgRating = Object.values(h.ratings).reduce((sum3, r) => sum3 + r, 0) / Object.values(h.ratings).length;
            return avgRating;
          });
          const avgRecent = recentScores.reduce((sum3, s) => sum3 + s, 0) / recentScores.length;
          if (avgRecent > updatedReputation.overallScore + 0.2) {
            updatedReputation.trend = "improving";
          } else if (avgRecent < updatedReputation.overallScore - 0.2) {
            updatedReputation.trend = "declining";
          } else {
            updatedReputation.trend = "stable";
          }
        }
        updatedReputation.history.push(interaction);
        updatedReputation.totalInteractions++;
        updatedReputation.lastUpdated = Date.now();
        reputationData.set(agentId, updatedReputation);
        const history = interactionHistory.get(agentId) || [];
        history.push(interaction);
        interactionHistory.set(agentId, history);
        return updates;
      },
      catch: (error2) => new TrustReputationError({
        reason: "update_failed",
        message: `Failed to update agent reputation: ${error2}`,
        cause: error2
      })
    });
    const calculateTrustScore = (evaluator, target) => Effect_exports.try({
      try: () => {
        let evaluatorTrust = trustMatrix.get(evaluator);
        if (!evaluatorTrust) {
          evaluatorTrust = /* @__PURE__ */ new Map();
          trustMatrix.set(evaluator, evaluatorTrust);
        }
        const trust = evaluatorTrust.get(target);
        if (trust && Date.now() - (trust.lastInteraction || 0) < 36e5) {
          return trust;
        }
        const directInteractions = (interactionHistory.get(evaluator) || []).filter((i) => i.counterpartyId === target);
        let directTrust = 0.5;
        if (directInteractions.length > 0) {
          const successRate = directInteractions.filter(
            (i) => i.outcome === "success" || i.outcome === "partial_success"
          ).length / directInteractions.length;
          directTrust = successRate * 0.8 + 0.1;
        }
        let indirectTrust = 0.5;
        const trustPaths = [];
        for (const [intermediary, intermediaryTrusts] of trustMatrix.entries()) {
          if (intermediary === evaluator || intermediary === target) continue;
          const toIntermediary = evaluatorTrust.get(intermediary);
          const fromIntermediary = intermediaryTrusts.get(target);
          if (toIntermediary && fromIntermediary) {
            const pathTrust = toIntermediary.combinedTrust * fromIntermediary.combinedTrust;
            trustPaths.push(pathTrust);
          }
        }
        if (trustPaths.length > 0) {
          indirectTrust = trustPaths.reduce((sum3, t) => sum3 + t, 0) / trustPaths.length;
        }
        const directWeight = Math.min(1, directInteractions.length / 5);
        const combinedTrust = directTrust * directWeight + indirectTrust * (1 - directWeight);
        const confidence = Math.min(1, (directInteractions.length + trustPaths.length) / 10);
        const trustScore = {
          fromAgent: evaluator,
          toAgent: target,
          directTrust,
          indirectTrust,
          combinedTrust,
          confidence,
          lastInteraction: directInteractions.length > 0 ? Math.max(...directInteractions.map((i) => i.timestamp)) : void 0
        };
        evaluatorTrust.set(target, trustScore);
        return trustScore;
      },
      catch: (error2) => new TrustReputationError({
        reason: "calculation_failed",
        message: `Failed to calculate trust score: ${error2}`,
        cause: error2
      })
    });
    const getReputationHistory = (agentId) => Effect_exports.try({
      try: () => {
        let reputation = reputationData.get(agentId);
        if (!reputation) {
          reputation = initializeReputation(agentId);
        }
        return reputation;
      },
      catch: (error2) => new TrustReputationError({
        reason: "history_failed",
        message: `Failed to get reputation history: ${error2}`,
        cause: error2
      })
    });
    const analyzeNetworkPosition = (agentId) => Effect_exports.try({
      try: () => {
        let incomingTrustCount = 0;
        let totalIncomingTrust = 0;
        let outgoingTrustCount = 0;
        let totalOutgoingTrust = 0;
        for (const [_evaluator, trusts] of trustMatrix.entries()) {
          const trustToAgent = trusts.get(agentId);
          if (trustToAgent && trustToAgent.combinedTrust > 0.3) {
            incomingTrustCount++;
            totalIncomingTrust += trustToAgent.combinedTrust;
          }
        }
        const agentTrusts = trustMatrix.get(agentId);
        if (agentTrusts) {
          for (const [_target, trust] of agentTrusts.entries()) {
            if (trust.combinedTrust > 0.3) {
              outgoingTrustCount++;
              totalOutgoingTrust += trust.combinedTrust;
            }
          }
        }
        const centrality = (incomingTrustCount + outgoingTrustCount) / Math.max(1, trustMatrix.size * 2);
        const influence = incomingTrustCount / Math.max(1, trustMatrix.size);
        const avgIncomingTrust = incomingTrustCount > 0 ? totalIncomingTrust / incomingTrustCount : 0;
        const avgOutgoingTrust = outgoingTrustCount > 0 ? totalOutgoingTrust / outgoingTrustCount : 0;
        const clusterMembership = [];
        const position = {
          agentId,
          centrality,
          influence,
          trustRadius: incomingTrustCount,
          avgIncomingTrust,
          avgOutgoingTrust,
          clusterMembership
        };
        return position;
      },
      catch: (error2) => new TrustReputationError({
        reason: "analysis_failed",
        message: `Failed to analyze network position: ${error2}`,
        cause: error2
      })
    });
    const identifyTrustClusters = () => Effect_exports.try({
      try: () => {
        const clusters = [];
        const processed = /* @__PURE__ */ new Set();
        for (const [agentId, agentTrusts] of trustMatrix.entries()) {
          if (processed.has(agentId)) continue;
          const clusterMembers = [agentId];
          processed.add(agentId);
          for (const [target, trust] of agentTrusts.entries()) {
            if (processed.has(target)) continue;
            const reverseTrasts = trustMatrix.get(target);
            if (reverseTrasts) {
              const reverseTrust = reverseTrasts.get(agentId);
              if (reverseTrust && trust.combinedTrust > 0.7 && reverseTrust.combinedTrust > 0.7) {
                clusterMembers.push(target);
                processed.add(target);
              }
            }
          }
          if (clusterMembers.length > 1) {
            let totalInternalTrust = 0;
            let internalPairs = 0;
            for (let i = 0; i < clusterMembers.length; i++) {
              for (let j = i + 1; j < clusterMembers.length; j++) {
                const trust1 = trustMatrix.get(clusterMembers[i])?.get(clusterMembers[j]);
                const trust2 = trustMatrix.get(clusterMembers[j])?.get(clusterMembers[i]);
                if (trust1 && trust2) {
                  totalInternalTrust += (trust1.combinedTrust + trust2.combinedTrust) / 2;
                  internalPairs++;
                }
              }
            }
            const cluster = {
              clusterId: `cluster_${Date.now()}_${clusters.length}`,
              members: clusterMembers,
              avgInternalTrust: internalPairs > 0 ? totalInternalTrust / internalPairs : 0,
              avgExternalTrust: 0.5,
              // TODO: Calculate external trust
              specializations: [],
              // TODO: Analyze common skills
              formationDate: Date.now()
            };
            clusters.push(cluster);
          }
        }
        return clusters;
      },
      catch: (error2) => new TrustReputationError({
        reason: "analysis_failed",
        message: `Failed to identify trust clusters: ${error2}`,
        cause: error2
      })
    });
    const predictCoalitionSuccess = (coalition) => Effect_exports.try({
      try: () => {
        let successProbability = 0.5;
        const avgReputation = coalition.members.reduce((sum3, member) => {
          const rep = reputationData.get(member.agentId);
          return sum3 + (rep?.overallScore || 3);
        }, 0) / coalition.members.length;
        successProbability += (avgReputation - 3) * 0.1;
        let totalTrust = 0;
        let trustPairs = 0;
        for (let i = 0; i < coalition.members.length; i++) {
          for (let j = i + 1; j < coalition.members.length; j++) {
            const trust = trustMatrix.get(coalition.members[i].agentId)?.get(coalition.members[j].agentId);
            if (trust) {
              totalTrust += trust.combinedTrust;
              trustPairs++;
            }
          }
        }
        const avgTrust = trustPairs > 0 ? totalTrust / trustPairs : 0.5;
        successProbability += (avgTrust - 0.5) * 0.3;
        const coalitionHistory = coalition.members.map((member) => {
          const history = interactionHistory.get(member.agentId) || [];
          return history.filter((i) => i.type === "coalition_participation");
        }).flat();
        if (coalitionHistory.length > 0) {
          const coalitionSuccessRate = coalitionHistory.filter((i) => i.outcome === "success").length / coalitionHistory.length;
          successProbability += (coalitionSuccessRate - 0.5) * 0.2;
        }
        return Math.max(0, Math.min(1, successProbability));
      },
      catch: (error2) => new TrustReputationError({
        reason: "calculation_failed",
        message: `Failed to predict coalition success: ${error2}`,
        cause: error2
      })
    });
    const calculateReputationPremium = (agentId, basePrice) => Effect_exports.try({
      try: () => {
        const reputation = reputationData.get(agentId) || initializeReputation(agentId);
        const dimensionPremiums = {
          quality: 0,
          timeliness: 0,
          collaboration: 0,
          reliability: 0,
          communication: 0,
          innovation: 0
        };
        let totalPremiumMultiplier = 1;
        Object.entries(reputation.dimensionScores).forEach(([dim, score]) => {
          const dimension = dim;
          if (score > 3.5) {
            const premium = (score - 3.5) * 0.1;
            dimensionPremiums[dimension] = premium;
            totalPremiumMultiplier += premium;
          }
        });
        if (reputation.trend === "improving" && reputation.overallScore > 4) {
          totalPremiumMultiplier += 0.1;
        }
        if (reputation.totalInteractions > 50) {
          totalPremiumMultiplier += 0.05;
        }
        const premiumRate = {
          basePremium: totalPremiumMultiplier,
          dimensionPremiums,
          totalPremium: basePrice * totalPremiumMultiplier,
          justification: `Reputation score ${reputation.overallScore.toFixed(1)}/5.0, ${reputation.trend} trend`
        };
        return premiumRate;
      },
      catch: (error2) => new TrustReputationError({
        reason: "calculation_failed",
        message: `Failed to calculate reputation premium: ${error2}`,
        cause: error2
      })
    });
    const assessRiskAdjustment = (coalition) => Effect_exports.try({
      try: () => {
        let baseRisk = 0.3;
        if (coalition.members.length > 5) {
          baseRisk += 0.1;
        }
        let trustMitigation = 0;
        const successPrediction = Effect_exports.runSync(predictCoalitionSuccess(coalition));
        if (successPrediction > 0.7) {
          trustMitigation = 0.2;
        } else if (successPrediction > 0.5) {
          trustMitigation = 0.1;
        }
        const adjustedRisk = Math.max(0.1, baseRisk - trustMitigation);
        const projectBudget = coalition.contract.proposal.project.totalBudgetSats;
        const recommendedEscrow = adjustedRisk * 0.5;
        const insurancePremium = adjustedRisk * 0.05 * projectBudget;
        const riskAdjustment = {
          baseRisk,
          trustMitigation,
          adjustedRisk,
          recommendedEscrow,
          insurancePremium
        };
        return riskAdjustment;
      },
      catch: (error2) => new TrustReputationError({
        reason: "calculation_failed",
        message: `Failed to assess risk adjustment: ${error2}`,
        cause: error2
      })
    });
    const optimizeCoalitionTrust = (possibleCoalitions) => Effect_exports.try({
      try: () => {
        if (possibleCoalitions.length === 0) {
          throw new Error("No coalitions to optimize");
        }
        const scoredCoalitions = possibleCoalitions.map((coalition) => {
          const trustScore = Effect_exports.runSync(predictCoalitionSuccess(coalition));
          const tradeoffs = [];
          if (coalition.members.length < 3) {
            tradeoffs.push("Small team size may limit capabilities");
          }
          const avgReputation = coalition.members.reduce((sum3, member) => {
            const rep = reputationData.get(member.agentId);
            return sum3 + (rep?.overallScore || 3);
          }, 0) / coalition.members.length;
          if (avgReputation < 3.5) {
            tradeoffs.push("Below average reputation scores");
          }
          return { coalition, trustScore, tradeoffs };
        });
        scoredCoalitions.sort((a, b) => b.trustScore - a.trustScore);
        const optimal = scoredCoalitions[0];
        const alternatives = scoredCoalitions.slice(1, 4);
        const recommendations = [];
        if (optimal.trustScore < 0.7) {
          recommendations.push("Consider building trust through smaller projects first");
        }
        if (alternatives.some((alt) => alt.trustScore > optimal.trustScore * 0.9)) {
          recommendations.push("Multiple viable coalitions available - consider member availability");
        }
        const optimization = {
          optimalCoalition: optimal.coalition,
          trustScore: optimal.trustScore,
          alternativeCoalitions: alternatives,
          recommendations
        };
        return optimization;
      },
      catch: (error2) => new TrustReputationError({
        reason: "optimization_failed",
        message: `Failed to optimize coalition trust: ${error2}`,
        cause: error2
      })
    });
    return {
      updateAgentReputation,
      calculateTrustScore,
      getReputationHistory,
      analyzeNetworkPosition,
      identifyTrustClusters,
      predictCoalitionSuccess,
      calculateReputationPremium,
      assessRiskAdjustment,
      optimizeCoalitionTrust
    };
  })
);

// ../../packages/sdk/src/browser/index.ts
var createCloudflareLanguageModelLayer = (config2) => {
  return layer({
    model: config2?.model || "@cf/meta/llama-3.1-8b-instruct",
    temperature: 0.7,
    maxTokens: 200
  });
};
var createBrowserServicesLayer = (cloudflareConfig) => {
  const ChannelWithWebSocketLive = ChannelServiceLive.pipe(Layer_exports.provide(WebSocketServiceLive2));
  const CloudflareLanguageModelLive = createCloudflareLanguageModelLayer(cloudflareConfig);
  const NostrServicesLive = Layer_exports.mergeAll(
    CryptoService_exports.CryptoServiceLive,
    EventService_exports.EventServiceLive,
    RelayService_exports.RelayServiceLive.pipe(Layer_exports.provide(WebSocketService_exports.WebSocketServiceLive)),
    Nip90Service_exports.Nip90ServiceLive.pipe(
      Layer_exports.provide(Layer_exports.merge(
        EventService_exports.EventServiceLive,
        RelayService_exports.RelayServiceLive.pipe(Layer_exports.provide(WebSocketService_exports.WebSocketServiceLive))
      ))
    )
  );
  return Layer_exports.mergeAll(
    WebSocketServiceLive2,
    ChannelWithWebSocketLive,
    AgentServiceLive.pipe(Layer_exports.provide(WebSocketServiceLive2)),
    ServiceOfferingServiceLive.pipe(Layer_exports.provide(WebSocketServiceLive2)),
    CloudflareLanguageModelLive,
    SparkServiceLive2,
    EconomicSurvivalServiceLive,
    AutonomousChatAgentLive.pipe(Layer_exports.provide(Layer_exports.merge(ChannelWithWebSocketLive, CloudflareLanguageModelLive))),
    AutonomousMarketplaceAgentLive.pipe(
      Layer_exports.provide(Layer_exports.mergeAll(
        ChannelWithWebSocketLive,
        CloudflareLanguageModelLive,
        AutonomousChatAgentLive.pipe(Layer_exports.provide(Layer_exports.merge(ChannelWithWebSocketLive, CloudflareLanguageModelLive))),
        NostrServicesLive,
        SparkServiceLive2,
        EconomicSurvivalServiceLive
      ))
    ),
    // Multi-agent coordination services
    CoalitionFormationServiceLive,
    ProjectCoordinationServiceLive,
    TrustReputationServiceLive
  );
};
var BrowserServicesLive = createBrowserServicesLayer();
export {
  AgentError,
  AgentMatch,
  AgentPersonality,
  AgentProfile2 as AgentProfile,
  AgentService,
  AgentServiceLive,
  AgentStatus,
  AutonomousChatAgent,
  AutonomousChatAgentLive,
  AutonomousChatError,
  AutonomousMarketplaceAgent,
  AutonomousMarketplaceAgentLive,
  BrowserServicesLive,
  Channel,
  ChannelError,
  ChannelMessage,
  ChannelService,
  ChannelServiceLive,
  ChatDecision,
  ChatDecisionContext,
  Coalition,
  CoalitionContract,
  CoalitionFormationError,
  CoalitionFormationService,
  CoalitionFormationServiceLive,
  CoalitionProposal,
  CoalitionResult,
  ComplexProject,
  CreateChannelParams,
  CreateJobRequestParams,
  EconomicSurvivalError,
  EconomicSurvivalService,
  EconomicSurvivalServiceLive,
  FinancialHealthScore,
  HandoffResult,
  IntegratedDeliverable,
  InteractionRecord,
  JobEvaluation,
  JobRequest,
  JobResult,
  LightningInvoice2 as LightningInvoice,
  MarketplaceError,
  MarketplacePersonality,
  NetworkPosition,
  OperationalCosts,
  PaymentResult,
  PremiumRate,
  PricingStrategy,
  ProgressUpdate,
  ProjectBlocker,
  ProjectCoordinationError,
  ProjectCoordinationService,
  ProjectCoordinationServiceLive,
  ProjectPlan,
  ProjectRequirement,
  ProjectSchedule,
  ProjectTask,
  QualityReview,
  ReputationDimension,
  ReputationHistory,
  ReputationUpdate,
  RiskAdjustment,
  SendMessageParams,
  ServiceCapability,
  ServiceDelivery,
  ServiceOffering,
  ServiceOfferingError,
  ServiceOfferingService,
  ServiceOfferingServiceLive,
  SparkError2 as SparkError,
  SparkService2 as SparkService,
  SparkServiceLive2 as SparkServiceLive,
  SurvivalAction,
  TaskAssignments,
  TrustCluster,
  TrustOptimization,
  TrustReputationError,
  TrustReputationService,
  TrustReputationServiceLive,
  TrustScore,
  ViabilityScore,
  WalletInfo2 as WalletInfo,
  WebSocketError,
  WebSocketService2 as WebSocketService,
  WebSocketServiceLive2 as WebSocketServiceLive,
  createBrowserServicesLayer,
  createCloudflareLanguageModelLayer
};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
@noble/hashes/esm/utils.js:
@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
@noble/curves/esm/utils.js:
@noble/curves/esm/abstract/modular.js:
@noble/curves/esm/abstract/curve.js:
@noble/curves/esm/abstract/weierstrass.js:
@noble/curves/esm/_shortw_utils.js:
@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip32/lib/esm/index.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@scure/bip39/esm/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=openagents-sdk-browser.js.map
