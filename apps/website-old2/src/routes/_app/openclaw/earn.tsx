import { createFileRoute } from "@tanstack/react-router";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import * as QRCode from "qrcode";
import {
  OpenClawEarnScreen,
  type CopyState,
  type FetchState,
  type InvoicePayload,
} from "@/components/openclaw/screens/OpenClawEarnScreen";
import { SITE_TITLE } from "@/consts";
import { getApiBase } from "@/lib/api";
import { buildHead } from "@/lib/seo";

export const Route = createFileRoute("/_app/openclaw/earn")({
  component: RouteComponent,
  head: () =>
    buildHead({
      title: `Pay OpenClaw | ${SITE_TITLE}`,
      description: "Public Lightning invoice generated by OpenClaw and served by OpenAgents.com.",
    }),
});

type ApiResponse<T> = {
  ok: boolean;
  data?: T | null;
  error?: string | null;
};

const POLL_INTERVAL_MS = 45_000;

function RouteComponent() {
  const apiBase = useMemo(() => getApiBase(), []);
  const [state, setState] = useState<FetchState>("loading");
  const [invoice, setInvoice] = useState<InvoicePayload | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [lastFetched, setLastFetched] = useState<number | null>(null);
  const [copyState, setCopyState] = useState<CopyState>("idle");
  const canvasRef = useRef<HTMLCanvasElement | null>(null);

  const fetchInvoice = useCallback(
    async (silent = false) => {
      if (!silent) setState("loading");
      setError(null);
      try {
        const res = await fetch(`${apiBase}/openclaw/invoice`, {
          headers: { Accept: "application/json" },
        });
        if (res.status === 404 || res.status === 410) {
          setInvoice(null);
          setState("empty");
          setLastFetched(Date.now());
          return;
        }
        const payload = (await res.json()) as ApiResponse<InvoicePayload>;
        if (!res.ok || !payload.ok || !payload.data) {
          setState("error");
          setError(payload.error ?? `Request failed (${res.status})`);
          return;
        }
        setInvoice(payload.data);
        setState("ready");
        setLastFetched(Date.now());
      } catch (err) {
        const message = err instanceof Error ? err.message : "Unknown error";
        setState("error");
        setError(message);
      }
    },
    [apiBase]
  );

  useEffect(() => {
    fetchInvoice();
    const interval = setInterval(() => fetchInvoice(true), POLL_INTERVAL_MS);
    return () => clearInterval(interval);
  }, [fetchInvoice]);

  useEffect(() => {
    if (!invoice?.payment_request || !canvasRef.current) return;
    QRCode.toCanvas(
      canvasRef.current,
      invoice.payment_request,
      {
        width: 220,
        margin: 1,
        color: { dark: "#0f172a", light: "#ffffff" },
      },
      () => undefined,
    );
  }, [invoice?.payment_request]);

  const handleCopy = useCallback(async () => {
    if (!invoice?.payment_request) return;
    try {
      await navigator.clipboard.writeText(invoice.payment_request);
      setCopyState("copied");
      setTimeout(() => setCopyState("idle"), 1800);
    } catch {
      setCopyState("failed");
      setTimeout(() => setCopyState("idle"), 2000);
    }
  }, [invoice?.payment_request]);

  const qrNode = invoice?.payment_request ? (
    <canvas ref={canvasRef} className="size-[220px]" />
  ) : null;

  return (
    <OpenClawEarnScreen
      state={state}
      invoice={invoice}
      error={error}
      lastFetched={lastFetched}
      copyState={copyState}
      onCopy={handleCopy}
      onRefresh={() => fetchInvoice()}
      qrNode={qrNode}
    />
  );
}
