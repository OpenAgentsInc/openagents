use anyhow::Result;
use tracing::info;

use crate::github::{GitHubClient, branch_name_for_issue};

/// GitHub workflow orchestrator for autopilot
pub struct GitHubWorkflow {
    client: GitHubClient,
    agent_identity: String,
}

impl GitHubWorkflow {
    /// Create a new GitHub workflow with authentication
    pub fn new(token: &str, agent_identity: String) -> Result<Self> {
        let client = GitHubClient::new(token)?;
        Ok(Self {
            client,
            agent_identity,
        })
    }

    /// Full workflow: claim issue â†’ create branch â†’ make changes â†’ create PR
    pub async fn execute_issue(
        &self,
        owner: &str,
        repo: &str,
        issue_number: u64,
        issue_title: &str,
        _base_branch: &str,
        base_sha: &str,
    ) -> Result<IssueWorkflowResult> {
        info!(
            "Starting GitHub workflow for issue #{} in {}/{}",
            issue_number, owner, repo
        );

        let branch_name = branch_name_for_issue(issue_number, issue_title);

        self.client
            .claim_issue(owner, repo, issue_number, &self.agent_identity)
            .await?;

        self.client
            .add_label(owner, repo, issue_number, "in-progress")
            .await?;

        self.client
            .create_branch(owner, repo, &branch_name, base_sha)
            .await?;

        info!("GitHub workflow initialized for issue #{}", issue_number);

        Ok(IssueWorkflowResult {
            branch_name,
            issue_number,
        })
    }

    /// Create a pull request after work is complete
    pub async fn create_pr(
        &self,
        owner: &str,
        repo: &str,
        issue_number: u64,
        branch_name: &str,
        base_branch: &str,
        pr_title: &str,
        pr_body: &str,
    ) -> Result<u64> {
        info!(
            "Creating PR for issue #{} in {}/{}",
            issue_number, owner, repo
        );

        let pr_number = self
            .client
            .create_pull_request(owner, repo, pr_title, pr_body, branch_name, base_branch)
            .await?;

        self.client
            .add_label(owner, repo, issue_number, "needs-review")
            .await?;

        info!("Created PR #{} for issue #{}", pr_number, issue_number);

        Ok(pr_number)
    }

    /// Post a receipt comment on the PR with execution details
    pub async fn post_receipt(
        &self,
        owner: &str,
        repo: &str,
        pr_number: u64,
        receipt: &WorkflowReceipt,
    ) -> Result<()> {
        let comment = format_receipt_comment(receipt);

        self.client
            .comment_on_pr(owner, repo, pr_number, &comment)
            .await?;

        info!("Posted receipt comment on PR #{}", pr_number);

        Ok(())
    }
}

/// Result of initializing an issue workflow
#[derive(Debug, Clone)]
pub struct IssueWorkflowResult {
    pub branch_name: String,
    pub issue_number: u64,
}

/// Execution receipt for transparency
#[derive(Debug, Clone)]
pub struct WorkflowReceipt {
    pub model: String,
    pub duration_seconds: u64,
    pub tokens_input: u64,
    pub tokens_output: u64,
    pub cost_usd: f64,
    pub files_changed: usize,
    pub tests_run: Option<usize>,
    pub tests_passed: Option<usize>,
    pub ci_status: Option<String>,
    pub replay_url: Option<String>,
}

fn format_receipt_comment(receipt: &WorkflowReceipt) -> String {
    let mut comment = String::from("## ðŸ¤– Autopilot Receipt\n\n");

    comment.push_str(&format!("**Model**: {}\n", receipt.model));
    comment.push_str(&format!(
        "**Duration**: {} seconds\n",
        receipt.duration_seconds
    ));
    comment.push_str(&format!(
        "**Tokens**: {} in / {} out\n",
        receipt.tokens_input, receipt.tokens_output
    ));
    comment.push_str(&format!("**Cost**: ${:.4}\n", receipt.cost_usd));
    comment.push_str(&format!("**Files Changed**: {}\n", receipt.files_changed));

    if let (Some(run), Some(passed)) = (receipt.tests_run, receipt.tests_passed) {
        comment.push_str(&format!("**Tests**: {} / {} passed\n", passed, run));
    }

    if let Some(ref status) = receipt.ci_status {
        comment.push_str(&format!("**CI Status**: {}\n", status));
    }

    if let Some(ref url) = receipt.replay_url {
        comment.push_str(&format!("\n[View Full Replay]({})\n", url));
    }

    comment.push_str("\n---\n");
    comment.push_str("_Generated by [OpenAgents Autopilot](https://openagents.com)_");

    comment
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_format_receipt() {
        let receipt = WorkflowReceipt {
            model: "claude-sonnet-4-5-20250929".to_string(),
            duration_seconds: 480,
            tokens_input: 150000,
            tokens_output: 8000,
            cost_usd: 0.42,
            files_changed: 3,
            tests_run: Some(42),
            tests_passed: Some(42),
            ci_status: Some("passed".to_string()),
            replay_url: Some("https://openagents.com/replays/abc123".to_string()),
        };

        let comment = format_receipt_comment(&receipt);
        assert!(comment.contains("claude-sonnet-4-5-20250929"));
        assert!(comment.contains("480 seconds"));
        assert!(comment.contains("$0.4200"));
        assert!(comment.contains("42 / 42 passed"));
    }
}
