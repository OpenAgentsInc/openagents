# MVP Artifacts

> **Status:** Spec (partially implemented)
> **Last verified:** 634f5b627
> **Source of truth:**
> - Artifact layout/emission: `crates/adjutant/src/artifacts/` (not yet implemented)
> - Replay implementation: `crates/autopilot-core/src/replay.rs` (different format)
> **Doc owner:** adjutant
> **If this doc conflicts with code, code wins.**

The "Verified PR Bundle" - three artifacts that capture everything about a completed task. For terminology, see [GLOSSARY.md](../../../GLOSSARY.md).

## Overview

Every module execution in production produces three artifacts:

| Artifact | Format | Purpose |
|----------|--------|---------|
| `PR_SUMMARY.md` | Markdown | Human-readable summary |
| `RECEIPT.json` | JSON | Cryptographic audit trail |
| `REPLAY.jsonl` | JSONL | Event stream for replay/debugging |

Together, these form the **Verified PR Bundle** - the canonical output of an agent task.

---

## Artifact Locations

```
.adjutant/sessions/{session_id}/
├── PR_SUMMARY.md      # Human-readable summary
├── RECEIPT.json       # Cryptographic receipt
└── REPLAY.jsonl       # Event stream
```

---

## PR_SUMMARY.md

Human-readable summary of what was accomplished.

### Schema

```markdown
# PR Summary

## Changes Made
- {bullet list of changes}

## Files Modified
- `{path}` ({N} lines changed)
- ...

## Verification
- `{command}`: {PASS|FAIL}
- ...

## Confidence: {0.00-1.00}

## Session
- ID: {session_id}
- Issue: #{issue_number}
- Duration: {duration}

## Performance (optional but recommended)
- APM: {actions per minute}
- sAPM: {success-adjusted APM}

## Cost (optional but recommended)
- Tokens: {input_tokens} in / {output_tokens} out
- Cost: {msats} msats

## If Failed (optional - only if status != success)
- Root cause: {diagnosis}
- Suggested next steps: {guidance}
```

### Example

```markdown
# PR Summary

## Changes Made
- Fixed authentication bug in password reset flow
- Added test case for edge case handling

## Files Modified
- `src/auth.rs` (15 lines changed)
- `tests/auth_test.rs` (25 lines added)

## Verification
- `cargo check`: PASS
- `cargo test`: PASS (24/24 tests)

## Confidence: 0.92

## Session
- ID: sess_abc123
- Issue: #42
- Duration: 5m 32s

## Performance
- APM: 12.5
- sAPM: 11.5

## Cost
- Tokens: 15,234 in / 8,921 out
- Cost: 750 msats
```

**Generated by:** `ResultSynthesisSignature`

---

## RECEIPT.json

Cryptographic receipt for verifiability and audit.

### Schema

```json
{
  "session_id": "string",
  "started_at": "ISO 8601 timestamp",
  "completed_at": "ISO 8601 timestamp",
  "issue_number": "number | null",
  "plan_hash": "sha256:...",
  "tool_calls": [
    {
      "id": "string",
      "tool": "string",
      "params_hash": "sha256:...",
      "output_hash": "sha256:...",
      "step_utility": "number (-1.0..+1.0)",
      "latency_ms": "number"
    }
  ],
  "verification": {
    "commands_run": ["string"],
    "exit_codes": ["number"],
    "verification_delta": "number"
  },
  "final_confidence": "number (0.0-1.0)",
  "policy_bundle_id": "string",
  "signature": "sig:... | null"
}
```

### Example

```json
{
  "session_id": "sess_abc123",
  "started_at": "2026-01-13T10:00:00Z",
  "completed_at": "2026-01-13T10:05:32Z",
  "issue_number": 42,
  "plan_hash": "sha256:abc123def456...",
  "tool_calls": [
    {
      "id": "tc_001",
      "tool": "file_read",
      "params_hash": "sha256:def456...",
      "output_hash": "sha256:ghi789...",
      "step_utility": 0.8,
      "latency_ms": 45
    },
    {
      "id": "tc_002",
      "tool": "file_edit",
      "params_hash": "sha256:jkl012...",
      "output_hash": "sha256:mno345...",
      "step_utility": 0.95,
      "latency_ms": 120
    }
  ],
  "verification": {
    "commands_run": ["cargo check", "cargo test"],
    "exit_codes": [0, 0],
    "verification_delta": 3
  },
  "final_confidence": 0.92,
  "policy_bundle_id": "v1.2.3",
  "signature": null
}
```

### Field Descriptions

| Field | Description |
|-------|-------------|
| `session_id` | Unique identifier for this execution session |
| `plan_hash` | SHA256 of the canonical plan JSON |
| `params_hash` | SHA256 of canonical tool input parameters |
| `output_hash` | SHA256 of canonical tool output |
| `step_utility` | Learning signal: how useful was this tool call? (-1.0..+1.0) |
| `verification_delta` | Change in failing tests: (before - after) |
| `policy_bundle_id` | Which policy bundle was used |
| `signature` | Optional Nostr signature for attestation |

### Enables

- Audit trail for all agent actions
- Reproducibility verification
- Cost accounting per tool call
- Training data extraction (step_utility labels)
- Nostr-based attestation (future)

---

## REPLAY.jsonl

Canonical event stream for replay and debugging. See [REPLAY.md](REPLAY.md) for full specification.

> **Note:** Current code emits `ReplayBundle` format (`autopilot-core/src/replay.rs`). An exporter to this REPLAY.jsonl spec is pending. See REPLAY.md "Compatibility Plan" for migration path.

### Quick Reference

```jsonl
{"event":"SessionStart","session_id":"sess_abc123","t":"2026-01-13T10:00:00Z",...}
{"event":"PlanStart","plan_hash":"sha256:abc123...","step_count":3,"t":"..."}
{"event":"ToolCall","id":"tc_001","tool":"file_read","params":{...},"t":"..."}
{"event":"ToolResult","id":"tc_001","output_hash":"sha256:...","step_utility":0.8,"t":"..."}
{"event":"StepComplete","step_id":"step-1","status":"Success","t":"..."}
{"event":"Verification","commands":[...],"exit_codes":[0,0],"verification_delta":3,"t":"..."}
{"event":"SessionEnd","status":"Success","confidence":0.92,"t":"..."}
```

### Enables

- CLI replay viewer (`adjutant replay sess_abc123`)
- Counterfactual analysis
- Shadow mode comparison
- Training data generation

---

## Deterministic Hashing

All hashes use canonical JSON serialization:

```rust
pub fn canonical_hash(value: &Value) -> String {
    let canonical = canonical_serialize(value);
    format!("sha256:{}", sha256::digest(canonical.as_bytes()))
}

fn canonical_serialize(value: &Value) -> String {
    match value {
        Value::Object(map) => {
            let mut sorted: Vec<_> = map.iter().collect();
            sorted.sort_by_key(|(k, _)| *k);
            let pairs: Vec<String> = sorted
                .iter()
                .map(|(k, v)| format!("\"{}\":{}", k, canonical_serialize(v)))
                .collect();
            format!("{{{}}}", pairs.join(","))
        }
        Value::Array(arr) => {
            let items: Vec<String> = arr.iter().map(canonical_serialize).collect();
            format!("[{}]", items.join(","))
        }
        _ => serde_json::to_string(value).unwrap(),
    }
}
```

---

## Artifact Generation Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                    Execution Session                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────────┐                                        │
│  │ ReplayWriter         │ ← Emits events throughout session      │
│  │ (REPLAY.jsonl)       │                                        │
│  └──────────────────────┘                                        │
│           │                                                      │
│           │ events                                               │
│           ▼                                                      │
│  ┌──────────────────────┐                                        │
│  │ Tool Execution Loop  │                                        │
│  │                      │                                        │
│  │  ToolCall → Result   │ ← Collects receipts                    │
│  │  ToolCall → Result   │                                        │
│  │  ...                 │                                        │
│  └──────────┬───────────┘                                        │
│             │                                                    │
│             │ receipts                                           │
│             ▼                                                    │
│  ┌──────────────────────┐                                        │
│  │ ResultSynthesisSig   │ ← Generates PR_SUMMARY.md              │
│  └──────────┬───────────┘                                        │
│             │                                                    │
│             ▼                                                    │
│  ┌──────────────────────┐                                        │
│  │ VerificationSig      │ ← Runs verification commands           │
│  └──────────┬───────────┘                                        │
│             │                                                    │
│             │ verification_delta                                 │
│             ▼                                                    │
│  ┌──────────────────────┐                                        │
│  │ ReceiptBuilder       │ ← Assembles RECEIPT.json               │
│  └──────────────────────┘                                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## CLI Commands

```bash
# View session artifacts
adjutant session show sess_abc123

# View replay
adjutant replay sess_abc123

# Verify receipt integrity
adjutant receipt verify sess_abc123

# Export artifacts for sharing
adjutant session export sess_abc123 --output ./artifacts/

# Compare two sessions (counterfactual)
adjutant session diff sess_abc123 sess_def456
```

---

## Integration with Training

Artifacts enable outcome-coupled training data extraction:

```rust
/// Extract labeled training data from a session
pub fn extract_training_data(receipt: &Receipt, replay: &[ReplayEvent]) -> Vec<LabeledToolCall> {
    receipt.tool_calls.iter().map(|tc| {
        LabeledToolCall {
            signature: "ToolCallSignature".into(),
            inputs: get_inputs_for_tool_call(tc, replay),
            outputs: get_outputs_for_tool_call(tc, replay),
            step_utility: tc.step_utility,
            verification_delta: receipt.verification.verification_delta,
            cost_tokens: estimate_tokens(tc),
            cost_tool_calls: 1,
            was_repeated: check_if_repeated(tc, replay),
        }
    }).collect()
}
```

---

## Integration with Other Primitives

| Primitive | Relationship |
|-----------|--------------|
| **MODULES.md** | Execution flow produces artifacts |
| **REPLAY.md** | Full spec for REPLAY.jsonl format |
| **METRICS.md** | step_utility enables outcome-coupled scoring |
| **OPTIMIZERS.md** | Training data feeds into MIPRO optimization |
