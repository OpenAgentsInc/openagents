//! TestGen Writer Module
//!
//! Converts testgen's GeneratedTest objects to pytest format.
//! Used to write generated tests to workspace before MAP loop.

use testgen::{GeneratedTest, TestCategory};

// ============================================================================
// GUARDRAIL: NO TASK-SPECIFIC HARDCODING
//
// This file must NEVER contain:
// - Task IDs (e.g., "regex-log", "path-tracing")
// - Task-specific patterns (e.g., IPv4 format, date format)
// - Task-specific hints (e.g., "use lookahead for IPv4")
// - Task-specific file paths (e.g., "/app/regex.txt")
//
// All knowledge must come from the GeneratedTest objects.
// ============================================================================

/// Convert generated tests to pytest file format.
///
/// # Arguments
///
/// * `tests` - Vector of generated tests from testgen
/// * `task_id` - Task identifier for the header comment
///
/// # Returns
///
/// A string containing valid Python pytest code
pub fn format_as_pytest(tests: &[GeneratedTest], task_id: &str) -> String {
    let mut output = String::new();

    // Header
    output.push_str("# Generated tests for ");
    output.push_str(task_id);
    output.push_str("\n# Auto-generated by HillClimber testgen integration\n\n");

    // Imports
    output.push_str("import pytest\n");
    output.push_str("import re\n");
    output.push_str("import os\n");
    output.push_str("import subprocess\n");
    output.push_str("from pathlib import Path\n\n");

    // Helper function for running commands
    output.push_str(r#"def run_command(cmd):
    """Run a shell command and return output."""
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    return result.stdout.strip()

def read_file(path):
    """Read file contents, return None if not exists."""
    try:
        return Path(path).read_text().strip()
    except FileNotFoundError:
        return None

"#);

    // Group tests by category
    let categories = [
        TestCategory::AntiCheat,
        TestCategory::Existence,
        TestCategory::Correctness,
        TestCategory::Boundary,
        TestCategory::Integration,
        TestCategory::Format,
        TestCategory::HappyPath,
        TestCategory::EdgeCase,
        TestCategory::InvalidInput,
    ];

    for category in categories {
        let category_tests: Vec<_> = tests.iter().filter(|t| t.category == category).collect();

        if category_tests.is_empty() {
            continue;
        }

        // Category header
        output.push_str(&format!(
            "\n# ============================================================================\n"
        ));
        output.push_str(&format!("# {} Tests\n", category_display_name(&category)));
        output.push_str(
            "# ============================================================================\n\n",
        );

        for test in category_tests {
            // Generate test function
            let func_name = sanitize_function_name(&test.id);
            let docstring = escape_docstring(&test.reasoning);

            output.push_str(&format!("def test_{}():\n", func_name));
            output.push_str(&format!("    \"\"\"{}\"\"\"\n", docstring));

            // Generate test body based on category and content
            let body = generate_test_body(test, &category);
            for line in body.lines() {
                if line.is_empty() {
                    output.push_str("\n");
                } else {
                    output.push_str(&format!("    {}\n", line));
                }
            }
            output.push('\n');
        }
    }

    output
}

/// Get display name for a test category.
fn category_display_name(category: &TestCategory) -> &'static str {
    match category {
        TestCategory::AntiCheat => "Anti-Cheat",
        TestCategory::Existence => "Existence",
        TestCategory::Correctness => "Correctness",
        TestCategory::Boundary => "Boundary",
        TestCategory::Integration => "Integration",
        TestCategory::Format => "Format",
        TestCategory::HappyPath => "Happy Path",
        TestCategory::EdgeCase => "Edge Case",
        TestCategory::InvalidInput => "Invalid Input",
    }
}

/// Sanitize test ID to valid Python function name.
fn sanitize_function_name(id: &str) -> String {
    id.chars()
        .map(|c| {
            if c.is_alphanumeric() {
                c.to_ascii_lowercase()
            } else {
                '_'
            }
        })
        .collect::<String>()
        .trim_matches('_')
        .to_string()
}

/// Escape string for Python docstring.
fn escape_docstring(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace("\"\"\"", "'''")
        .replace('\n', " ")
}

/// Escape string for Python string literal.
fn escape_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

/// Generate the test function body based on test content.
fn generate_test_body(test: &GeneratedTest, category: &TestCategory) -> String {
    match category {
        TestCategory::Existence => generate_existence_body(test),
        TestCategory::AntiCheat => generate_anti_cheat_body(test),
        TestCategory::Correctness => generate_correctness_body(test),
        TestCategory::Boundary => generate_boundary_body(test),
        TestCategory::Integration => generate_integration_body(test),
        TestCategory::Format => generate_correctness_body(test), // Format tests use correctness pattern
        TestCategory::HappyPath => generate_correctness_body(test), // Happy path uses correctness pattern
        TestCategory::EdgeCase => generate_boundary_body(test), // Edge cases use boundary pattern
        TestCategory::InvalidInput => generate_boundary_body(test), // Invalid input uses boundary pattern
    }
}

/// Generate body for existence tests.
fn generate_existence_body(test: &GeneratedTest) -> String {
    // Try to extract file path from input
    let input = &test.input;

    if input.contains('/') {
        // Looks like a file path check
        format!(
            r#"# Check: {}
path = Path("{}")
assert path.exists(), f"Expected {{path}} to exist""#,
            escape_string(input),
            extract_path(input)
        )
    } else {
        // Generic existence check
        format!(
            r#"# Input: {}
# This test verifies existence of expected outputs
pass  # TODO: Implement specific check"#,
            escape_string(input)
        )
    }
}

/// Generate body for anti-cheat tests.
fn generate_anti_cheat_body(test: &GeneratedTest) -> String {
    format!(
        r#"# Anti-cheat check: {}
# Verify no prohibited tools/patterns were used
pass  # Anti-cheat validation happens at runtime"#,
        escape_string(&test.input)
    )
}

/// Generate body for correctness tests.
fn generate_correctness_body(test: &GeneratedTest) -> String {
    let input = &test.input;
    let expected = test
        .expected_output
        .as_deref()
        .unwrap_or("# No expected output specified");

    // Check if this is a regex test (common pattern)
    if input.contains("regex") || input.contains("pattern") || input.contains("match") {
        format!(
            r#"# Test case: {}
# Expected: {}
regex_file = Path("/app/regex.txt")
if regex_file.exists():
    pattern = regex_file.read_text().strip()
    test_input = "{}"
    matches = re.findall(pattern, test_input, re.MULTILINE)
    expected = "{}"
    assert str(matches) == expected or expected in str(matches), \
        f"Pattern {{pattern}} on input gave {{matches}}, expected {{expected}}""#,
            escape_string(&test.reasoning),
            escape_string(expected),
            escape_string(input),
            escape_string(expected)
        )
    } else if let Some(exp) = &test.expected_output {
        // Has expected output - do comparison
        format!(
            r#"# Test: {}
result = run_command("{}")
expected = "{}"
assert result == expected, f"Got {{result}}, expected {{expected}}""#,
            escape_string(&test.reasoning),
            escape_string(input),
            escape_string(exp)
        )
    } else {
        // No expected output - just run and check it doesn't error
        format!(
            r#"# Test: {}
# Input: {}
# Running command/check without specific expected output
try:
    result = run_command("{}")
    # Test passed if no exception
except Exception as e:
    pytest.fail(f"Command failed: {{e}}")"#,
            escape_string(&test.reasoning),
            escape_string(input),
            escape_string(input)
        )
    }
}

/// Generate body for boundary tests.
fn generate_boundary_body(test: &GeneratedTest) -> String {
    let input = &test.input;
    let expected = test.expected_output.as_deref();

    if let Some(exp) = expected {
        format!(
            r#"# Boundary test: {}
# Input: {}
# Expected: {}
result = run_command("{}")
assert result == "{}", f"Boundary case failed: got {{result}}""#,
            escape_string(&test.reasoning),
            escape_string(input),
            escape_string(exp),
            escape_string(input),
            escape_string(exp)
        )
    } else {
        format!(
            r#"# Boundary test: {}
# Edge case input: {}
# Should handle gracefully without crashing
try:
    result = run_command("{}")
except Exception as e:
    pytest.fail(f"Boundary case crashed: {{e}}")"#,
            escape_string(&test.reasoning),
            escape_string(input),
            escape_string(input)
        )
    }
}

/// Generate body for integration tests.
fn generate_integration_body(test: &GeneratedTest) -> String {
    format!(
        r#"# Integration test: {}
# Full workflow validation
# Input: {}
pass  # Integration tests require full system context"#,
        escape_string(&test.reasoning),
        escape_string(&test.input)
    )
}

/// Extract file path from a test input string.
fn extract_path(input: &str) -> String {
    // Look for common path patterns
    if let Some(start) = input.find('/') {
        let rest = &input[start..];
        // Find end of path (space or end of string)
        let end = rest
            .find(|c: char| c.is_whitespace())
            .unwrap_or(rest.len());
        rest[..end].to_string()
    } else {
        input.to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_test(id: &str, input: &str, expected: Option<&str>, category: TestCategory) -> GeneratedTest {
        GeneratedTest {
            id: id.to_string(),
            input: input.to_string(),
            expected_output: expected.map(|s| s.to_string()),
            reasoning: format!("Test for {}", id),
            category,
            confidence: 0.9,
        }
    }

    #[test]
    fn test_sanitize_function_name() {
        assert_eq!(sanitize_function_name("test-case-1"), "test_case_1");
        assert_eq!(sanitize_function_name("Test Case"), "test_case");
        assert_eq!(sanitize_function_name("--foo--"), "foo");
    }

    #[test]
    fn test_escape_docstring() {
        assert_eq!(escape_docstring("Hello\nWorld"), "Hello World");
        assert_eq!(escape_docstring(r#"Test """quote""""#), "Test '''quote'''");
    }

    #[test]
    fn test_format_as_pytest_empty() {
        let tests: Vec<GeneratedTest> = vec![];
        let output = format_as_pytest(&tests, "test-task");
        assert!(output.contains("# Generated tests for test-task"));
        assert!(output.contains("import pytest"));
    }

    #[test]
    fn test_format_as_pytest_existence() {
        let tests = vec![make_test(
            "exists_1",
            "/app/output.txt",
            None,
            TestCategory::Existence,
        )];
        let output = format_as_pytest(&tests, "test-task");
        assert!(output.contains("def test_exists_1"));
        assert!(output.contains("Existence Tests"));
        assert!(output.contains("Path(\"/app/output.txt\")"));
    }

    #[test]
    fn test_format_as_pytest_correctness() {
        let tests = vec![make_test(
            "correct_1",
            "echo hello",
            Some("hello"),
            TestCategory::Correctness,
        )];
        let output = format_as_pytest(&tests, "test-task");
        assert!(output.contains("def test_correct_1"));
        assert!(output.contains("Correctness Tests"));
    }
}
