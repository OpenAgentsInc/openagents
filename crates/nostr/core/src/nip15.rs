//! NIP-15: Nostr Marketplace
//!
//! This NIP defines a decentralized marketplace protocol for buying and selling
//! products over Nostr. It includes support for merchant stalls, product listings,
//! auctions, and order processing.
//!
//! ## Purpose
//!
//! Enable merchants to create digital storefronts and list products, while customers
//! can browse, purchase, and communicate with merchants entirely through Nostr events.
//!
//! ## Event Kinds
//!
//! - Kind 30017: Merchant stall (addressable)
//! - Kind 30018: Product listing (addressable)
//! - Kind 30019: Marketplace UI/UX customization (addressable)
//! - Kind 30020: Auction product (addressable)
//! - Kind 1021: Bid on auction
//! - Kind 1022: Bid confirmation
//!
//! ## Examples
//!
//! ```
//! use nostr::nip15::{MerchantStall, Product, ShippingZone};
//!
//! // Create a shipping zone
//! let zone = ShippingZone::new("zone1", "USA", 5.0, vec!["US", "CA"]);
//!
//! // Create a merchant stall
//! let stall = MerchantStall::new("stall1", "My Store", "USD")
//!     .with_description("Best products in town")
//!     .with_shipping_zone(zone);
//!
//! // Create a product
//! let product = Product::new("prod1", "stall1", "Widget", "USD", 19.99)
//!     .with_description("Amazing widget")
//!     .with_quantity(Some(100));
//! ```

use serde::{Deserialize, Serialize};
use thiserror::Error;

/// Event kind for merchant stalls
pub const KIND_STALL: u64 = 30017;

/// Event kind for products
pub const KIND_PRODUCT: u64 = 30018;

/// Event kind for marketplace UI/UX
pub const KIND_MARKETPLACE_UI: u64 = 30019;

/// Event kind for auction products
pub const KIND_AUCTION: u64 = 30020;

/// Event kind for bids
pub const KIND_BID: u64 = 1021;

/// Event kind for bid confirmations
pub const KIND_BID_CONFIRMATION: u64 = 1022;

/// Errors that can occur during NIP-15 operations
#[derive(Debug, Error)]
pub enum Nip15Error {
    #[error("stall ID cannot be empty")]
    EmptyStallId,

    #[error("product ID cannot be empty")]
    EmptyProductId,

    #[error("stall name cannot be empty")]
    EmptyStallName,

    #[error("product name cannot be empty")]
    EmptyProductName,

    #[error("invalid currency code: {0}")]
    InvalidCurrency(String),

    #[error("price must be non-negative")]
    NegativePrice,

    #[error("quantity must be non-negative")]
    NegativeQuantity,

    #[error("shipping zone ID cannot be empty")]
    EmptyShippingZoneId,

    #[error("bid amount must be positive")]
    InvalidBidAmount,

    #[error("auction duration must be positive")]
    InvalidAuctionDuration,
}

/// Check if an event kind is a marketplace kind
pub fn is_marketplace_kind(kind: u64) -> bool {
    matches!(
        kind,
        KIND_STALL
            | KIND_PRODUCT
            | KIND_MARKETPLACE_UI
            | KIND_AUCTION
            | KIND_BID
            | KIND_BID_CONFIRMATION
    )
}

/// Shipping zone for a stall
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ShippingZone {
    /// Zone ID (generated by merchant)
    pub id: String,
    /// Optional zone name
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Base shipping cost in stall currency
    pub cost: f64,
    /// Regions included in this zone
    pub regions: Vec<String>,
}

impl ShippingZone {
    /// Create a new shipping zone
    pub fn new(
        id: impl Into<String>,
        name: impl Into<String>,
        cost: f64,
        regions: Vec<impl Into<String>>,
    ) -> Self {
        Self {
            id: id.into(),
            name: Some(name.into()),
            cost,
            regions: regions.into_iter().map(|r| r.into()).collect(),
        }
    }

    /// Create a new shipping zone without a name
    pub fn new_unnamed(id: impl Into<String>, cost: f64, regions: Vec<impl Into<String>>) -> Self {
        Self {
            id: id.into(),
            name: None,
            cost,
            regions: regions.into_iter().map(|r| r.into()).collect(),
        }
    }

    /// Set the zone name
    pub fn with_name(mut self, name: impl Into<String>) -> Self {
        self.name = Some(name.into());
        self
    }

    /// Add a region to the shipping zone
    pub fn with_region(mut self, region: impl Into<String>) -> Self {
        self.regions.push(region.into());
        self
    }
}

/// Merchant stall (kind 30017)
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct MerchantStall {
    /// Stall ID (must match d tag)
    pub id: String,
    /// Stall name
    pub name: String,
    /// Optional stall description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Currency code (ISO 4217)
    pub currency: String,
    /// Shipping zones
    #[serde(default)]
    pub shipping: Vec<ShippingZone>,
}

impl MerchantStall {
    /// Create a new merchant stall
    pub fn new(
        id: impl Into<String>,
        name: impl Into<String>,
        currency: impl Into<String>,
    ) -> Self {
        Self {
            id: id.into(),
            name: name.into(),
            description: None,
            currency: currency.into(),
            shipping: Vec::new(),
        }
    }

    /// Set the stall description
    pub fn with_description(mut self, description: impl Into<String>) -> Self {
        self.description = Some(description.into());
        self
    }

    /// Add a shipping zone
    pub fn with_shipping_zone(mut self, zone: ShippingZone) -> Self {
        self.shipping.push(zone);
        self
    }

    /// Convert to event tags
    pub fn to_tags(&self) -> Vec<Vec<String>> {
        vec![vec!["d".to_string(), self.id.clone()]]
    }

    /// Validate the stall
    pub fn validate(&self) -> Result<(), Nip15Error> {
        if self.id.trim().is_empty() {
            return Err(Nip15Error::EmptyStallId);
        }
        if self.name.trim().is_empty() {
            return Err(Nip15Error::EmptyStallName);
        }
        if self.currency.trim().is_empty() {
            return Err(Nip15Error::InvalidCurrency(self.currency.clone()));
        }
        for zone in &self.shipping {
            if zone.id.trim().is_empty() {
                return Err(Nip15Error::EmptyShippingZoneId);
            }
            if zone.cost < 0.0 {
                return Err(Nip15Error::NegativePrice);
            }
        }
        Ok(())
    }
}

/// Product shipping cost for a specific zone
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct ProductShipping {
    /// Shipping zone ID (must match a stall zone)
    pub id: String,
    /// Extra cost for this product
    pub cost: f64,
}

impl ProductShipping {
    /// Create a new product shipping cost
    pub fn new(id: impl Into<String>, cost: f64) -> Self {
        Self {
            id: id.into(),
            cost,
        }
    }
}

/// Product specification (key-value pair)
pub type ProductSpec = (String, String);

/// Product listing (kind 30018)
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Product {
    /// Product ID (must match d tag)
    pub id: String,
    /// Stall ID this product belongs to
    pub stall_id: String,
    /// Product name
    pub name: String,
    /// Optional product description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Optional product images
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Vec<String>>,
    /// Currency code (ISO 4217)
    pub currency: String,
    /// Product price
    pub price: f64,
    /// Available quantity (null for unlimited)
    pub quantity: Option<i64>,
    /// Product specifications
    #[serde(default)]
    pub specs: Vec<ProductSpec>,
    /// Per-zone shipping costs
    #[serde(default)]
    pub shipping: Vec<ProductShipping>,
}

impl Product {
    /// Create a new product
    pub fn new(
        id: impl Into<String>,
        stall_id: impl Into<String>,
        name: impl Into<String>,
        currency: impl Into<String>,
        price: f64,
    ) -> Self {
        Self {
            id: id.into(),
            stall_id: stall_id.into(),
            name: name.into(),
            description: None,
            images: None,
            currency: currency.into(),
            price,
            quantity: None,
            specs: Vec::new(),
            shipping: Vec::new(),
        }
    }

    /// Set the product description
    pub fn with_description(mut self, description: impl Into<String>) -> Self {
        self.description = Some(description.into());
        self
    }

    /// Set the product quantity
    pub fn with_quantity(mut self, quantity: Option<i64>) -> Self {
        self.quantity = quantity;
        self
    }

    /// Add a product image
    pub fn with_image(mut self, url: impl Into<String>) -> Self {
        self.images.get_or_insert_with(Vec::new).push(url.into());
        self
    }

    /// Add a product specification
    pub fn with_spec(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.specs.push((key.into(), value.into()));
        self
    }

    /// Add a shipping cost for a specific zone
    pub fn with_shipping_cost(mut self, zone_id: impl Into<String>, cost: f64) -> Self {
        self.shipping.push(ProductShipping::new(zone_id, cost));
        self
    }

    /// Convert to event tags
    pub fn to_tags(&self, categories: &[impl AsRef<str>]) -> Vec<Vec<String>> {
        let mut tags = vec![vec!["d".to_string(), self.id.clone()]];
        for category in categories {
            tags.push(vec!["t".to_string(), category.as_ref().to_string()]);
        }
        tags
    }

    /// Validate the product
    pub fn validate(&self) -> Result<(), Nip15Error> {
        if self.id.trim().is_empty() {
            return Err(Nip15Error::EmptyProductId);
        }
        if self.stall_id.trim().is_empty() {
            return Err(Nip15Error::EmptyStallId);
        }
        if self.name.trim().is_empty() {
            return Err(Nip15Error::EmptyProductName);
        }
        if self.currency.trim().is_empty() {
            return Err(Nip15Error::InvalidCurrency(self.currency.clone()));
        }
        if self.price < 0.0 {
            return Err(Nip15Error::NegativePrice);
        }
        if let Some(qty) = self.quantity
            && qty < 0
        {
            return Err(Nip15Error::NegativeQuantity);
        }
        Ok(())
    }
}

/// Marketplace UI customization (kind 30019)
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct MarketplaceUI {
    /// Market name
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    /// Market description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub about: Option<String>,
    /// UI configuration
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ui: Option<UIConfig>,
    /// Merchant public keys
    #[serde(default)]
    pub merchants: Vec<String>,
}

impl MarketplaceUI {
    /// Create a new marketplace UI configuration
    pub fn new() -> Self {
        Self {
            name: None,
            about: None,
            ui: None,
            merchants: Vec::new(),
        }
    }

    /// Set the marketplace name
    pub fn with_name(mut self, name: impl Into<String>) -> Self {
        self.name = Some(name.into());
        self
    }

    /// Set the marketplace description
    pub fn with_about(mut self, about: impl Into<String>) -> Self {
        self.about = Some(about.into());
        self
    }

    /// Set the UI configuration
    pub fn with_ui(mut self, ui: UIConfig) -> Self {
        self.ui = Some(ui);
        self
    }

    /// Add a merchant public key
    pub fn with_merchant(mut self, pubkey: impl Into<String>) -> Self {
        self.merchants.push(pubkey.into());
        self
    }
}

impl Default for MarketplaceUI {
    fn default() -> Self {
        Self::new()
    }
}

/// UI configuration for marketplace
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct UIConfig {
    /// Market logo URL
    #[serde(skip_serializing_if = "Option::is_none")]
    pub picture: Option<String>,
    /// Market banner URL
    #[serde(skip_serializing_if = "Option::is_none")]
    pub banner: Option<String>,
    /// Market theme
    #[serde(skip_serializing_if = "Option::is_none")]
    pub theme: Option<String>,
    /// Dark mode enabled
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "darkMode")]
    pub dark_mode: Option<bool>,
}

impl UIConfig {
    /// Create a new UI configuration
    pub fn new() -> Self {
        Self {
            picture: None,
            banner: None,
            theme: None,
            dark_mode: None,
        }
    }

    /// Set the picture URL
    pub fn with_picture(mut self, url: impl Into<String>) -> Self {
        self.picture = Some(url.into());
        self
    }

    /// Set the banner URL
    pub fn with_banner(mut self, url: impl Into<String>) -> Self {
        self.banner = Some(url.into());
        self
    }

    /// Set the theme
    pub fn with_theme(mut self, theme: impl Into<String>) -> Self {
        self.theme = Some(theme.into());
        self
    }

    /// Set dark mode
    pub fn with_dark_mode(mut self, enabled: bool) -> Self {
        self.dark_mode = Some(enabled);
        self
    }
}

impl Default for UIConfig {
    fn default() -> Self {
        Self::new()
    }
}

/// Auction product (kind 30020)
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct AuctionProduct {
    /// Product ID (must match d tag)
    pub id: String,
    /// Stall ID this product belongs to
    pub stall_id: String,
    /// Product name
    pub name: String,
    /// Optional product description
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    /// Optional product images
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Vec<String>>,
    /// Starting bid amount
    pub starting_bid: i64,
    /// Optional start date (UNIX timestamp)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start_date: Option<i64>,
    /// Auction duration in seconds
    pub duration: i64,
    /// Product specifications
    #[serde(default)]
    pub specs: Vec<ProductSpec>,
    /// Per-zone shipping costs
    #[serde(default)]
    pub shipping: Vec<ProductShipping>,
}

impl AuctionProduct {
    /// Create a new auction product
    pub fn new(
        id: impl Into<String>,
        stall_id: impl Into<String>,
        name: impl Into<String>,
        starting_bid: i64,
        duration: i64,
    ) -> Self {
        Self {
            id: id.into(),
            stall_id: stall_id.into(),
            name: name.into(),
            description: None,
            images: None,
            starting_bid,
            start_date: None,
            duration,
            specs: Vec::new(),
            shipping: Vec::new(),
        }
    }

    /// Set the product description
    pub fn with_description(mut self, description: impl Into<String>) -> Self {
        self.description = Some(description.into());
        self
    }

    /// Set the start date
    pub fn with_start_date(mut self, timestamp: i64) -> Self {
        self.start_date = Some(timestamp);
        self
    }

    /// Add a product image
    pub fn with_image(mut self, url: impl Into<String>) -> Self {
        self.images.get_or_insert_with(Vec::new).push(url.into());
        self
    }

    /// Add a product specification
    pub fn with_spec(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {
        self.specs.push((key.into(), value.into()));
        self
    }

    /// Add a shipping cost for a specific zone
    pub fn with_shipping_cost(mut self, zone_id: impl Into<String>, cost: f64) -> Self {
        self.shipping.push(ProductShipping::new(zone_id, cost));
        self
    }

    /// Convert to event tags
    pub fn to_tags(&self) -> Vec<Vec<String>> {
        vec![vec!["d".to_string(), self.id.clone()]]
    }

    /// Validate the auction product
    pub fn validate(&self) -> Result<(), Nip15Error> {
        if self.id.trim().is_empty() {
            return Err(Nip15Error::EmptyProductId);
        }
        if self.stall_id.trim().is_empty() {
            return Err(Nip15Error::EmptyStallId);
        }
        if self.name.trim().is_empty() {
            return Err(Nip15Error::EmptyProductName);
        }
        if self.starting_bid <= 0 {
            return Err(Nip15Error::InvalidBidAmount);
        }
        if self.duration <= 0 {
            return Err(Nip15Error::InvalidAuctionDuration);
        }
        Ok(())
    }
}

/// Bid status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum BidStatus {
    /// Bid accepted
    Accepted,
    /// Bid rejected
    Rejected,
    /// Bid pending verification
    Pending,
    /// Winning bid
    Winner,
}

/// Bid confirmation (kind 1022)
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct BidConfirmation {
    /// Bid status
    pub status: BidStatus,
    /// Optional message to bidder
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    /// Optional auction duration extension in seconds
    #[serde(skip_serializing_if = "Option::is_none")]
    pub duration_extended: Option<i64>,
}

impl BidConfirmation {
    /// Create a new bid confirmation
    pub fn new(status: BidStatus) -> Self {
        Self {
            status,
            message: None,
            duration_extended: None,
        }
    }

    /// Create an accepted bid confirmation
    pub fn accepted() -> Self {
        Self::new(BidStatus::Accepted)
    }

    /// Create a rejected bid confirmation
    pub fn rejected(message: impl Into<String>) -> Self {
        Self {
            status: BidStatus::Rejected,
            message: Some(message.into()),
            duration_extended: None,
        }
    }

    /// Create a pending bid confirmation
    pub fn pending(message: impl Into<String>) -> Self {
        Self {
            status: BidStatus::Pending,
            message: Some(message.into()),
            duration_extended: None,
        }
    }

    /// Create a winner bid confirmation
    pub fn winner() -> Self {
        Self::new(BidStatus::Winner)
    }

    /// Set the message
    pub fn with_message(mut self, message: impl Into<String>) -> Self {
        self.message = Some(message.into());
        self
    }

    /// Set the duration extension
    pub fn with_duration_extension(mut self, seconds: i64) -> Self {
        self.duration_extended = Some(seconds);
        self
    }

    /// Convert to event tags (bid event ID and auction event ID)
    pub fn to_tags(bid_event_id: &str, auction_event_id: &str) -> Vec<Vec<String>> {
        vec![
            vec!["e".to_string(), bid_event_id.to_string()],
            vec!["e".to_string(), auction_event_id.to_string()],
        ]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_marketplace_kind() {
        assert!(is_marketplace_kind(KIND_STALL));
        assert!(is_marketplace_kind(KIND_PRODUCT));
        assert!(is_marketplace_kind(KIND_MARKETPLACE_UI));
        assert!(is_marketplace_kind(KIND_AUCTION));
        assert!(is_marketplace_kind(KIND_BID));
        assert!(is_marketplace_kind(KIND_BID_CONFIRMATION));
        assert!(!is_marketplace_kind(1));
    }

    #[test]
    fn test_shipping_zone() {
        let zone = ShippingZone::new("zone1", "USA", 5.0, vec!["US", "CA"]);
        assert_eq!(zone.id, "zone1");
        assert_eq!(zone.name, Some("USA".to_string()));
        assert_eq!(zone.cost, 5.0);
        assert_eq!(zone.regions.len(), 2);
    }

    #[test]
    fn test_shipping_zone_unnamed() {
        let zone = ShippingZone::new_unnamed("zone1", 10.0, vec!["UK", "IE"]);
        assert_eq!(zone.id, "zone1");
        assert_eq!(zone.name, None);
        assert_eq!(zone.cost, 10.0);
    }

    #[test]
    fn test_merchant_stall() {
        let zone = ShippingZone::new("zone1", "USA", 5.0, vec!["US"]);
        let stall = MerchantStall::new("stall1", "My Store", "USD")
            .with_description("Best store")
            .with_shipping_zone(zone);

        assert_eq!(stall.id, "stall1");
        assert_eq!(stall.name, "My Store");
        assert_eq!(stall.description, Some("Best store".to_string()));
        assert_eq!(stall.currency, "USD");
        assert_eq!(stall.shipping.len(), 1);
    }

    #[test]
    fn test_merchant_stall_tags() {
        let stall = MerchantStall::new("stall1", "My Store", "USD");
        let tags = stall.to_tags();
        assert_eq!(tags.len(), 1);
        assert_eq!(tags[0], vec!["d", "stall1"]);
    }

    #[test]
    fn test_merchant_stall_validate() {
        let stall = MerchantStall::new("stall1", "My Store", "USD");
        assert!(stall.validate().is_ok());

        let invalid = MerchantStall::new("", "My Store", "USD");
        assert!(invalid.validate().is_err());
    }

    #[test]
    fn test_product() {
        let product = Product::new("prod1", "stall1", "Widget", "USD", 19.99)
            .with_description("Amazing widget")
            .with_quantity(Some(100))
            .with_image("https://example.com/widget.jpg")
            .with_spec("color", "blue")
            .with_shipping_cost("zone1", 2.5);

        assert_eq!(product.id, "prod1");
        assert_eq!(product.stall_id, "stall1");
        assert_eq!(product.name, "Widget");
        assert_eq!(product.price, 19.99);
        assert_eq!(product.quantity, Some(100));
        assert_eq!(product.images.as_ref().unwrap().len(), 1);
        assert_eq!(product.specs.len(), 1);
        assert_eq!(product.shipping.len(), 1);
    }

    #[test]
    fn test_product_tags() {
        let product = Product::new("prod1", "stall1", "Widget", "USD", 19.99);
        let tags = product.to_tags(&["electronics", "gadgets"]);
        assert_eq!(tags.len(), 3);
        assert_eq!(tags[0], vec!["d", "prod1"]);
        assert_eq!(tags[1], vec!["t", "electronics"]);
        assert_eq!(tags[2], vec!["t", "gadgets"]);
    }

    #[test]
    fn test_product_validate() {
        let product = Product::new("prod1", "stall1", "Widget", "USD", 19.99);
        assert!(product.validate().is_ok());

        let invalid = Product::new("", "stall1", "Widget", "USD", -5.0);
        assert!(invalid.validate().is_err());
    }

    #[test]
    fn test_marketplace_ui() {
        let ui_config = UIConfig::new()
            .with_picture("https://example.com/logo.png")
            .with_dark_mode(true);

        let marketplace = MarketplaceUI::new()
            .with_name("My Market")
            .with_about("Best marketplace")
            .with_ui(ui_config)
            .with_merchant("pubkey1")
            .with_merchant("pubkey2");

        assert_eq!(marketplace.name, Some("My Market".to_string()));
        assert_eq!(marketplace.about, Some("Best marketplace".to_string()));
        assert!(marketplace.ui.is_some());
        assert_eq!(marketplace.merchants.len(), 2);
    }

    #[test]
    fn test_auction_product() {
        let auction = AuctionProduct::new("auction1", "stall1", "Rare Item", 1000, 86400)
            .with_description("Very rare")
            .with_start_date(1234567890)
            .with_image("https://example.com/rare.jpg")
            .with_spec("condition", "mint");

        assert_eq!(auction.id, "auction1");
        assert_eq!(auction.starting_bid, 1000);
        assert_eq!(auction.duration, 86400);
        assert_eq!(auction.start_date, Some(1234567890));
    }

    #[test]
    fn test_auction_validate() {
        let auction = AuctionProduct::new("auction1", "stall1", "Item", 100, 3600);
        assert!(auction.validate().is_ok());

        let invalid = AuctionProduct::new("", "stall1", "Item", 0, 3600);
        assert!(invalid.validate().is_err());
    }

    #[test]
    fn test_bid_confirmation_accepted() {
        let confirmation = BidConfirmation::accepted();
        assert_eq!(confirmation.status, BidStatus::Accepted);
        assert!(confirmation.message.is_none());
    }

    #[test]
    fn test_bid_confirmation_rejected() {
        let confirmation = BidConfirmation::rejected("Bid too low");
        assert_eq!(confirmation.status, BidStatus::Rejected);
        assert_eq!(confirmation.message, Some("Bid too low".to_string()));
    }

    #[test]
    fn test_bid_confirmation_pending() {
        let confirmation = BidConfirmation::pending("Awaiting verification");
        assert_eq!(confirmation.status, BidStatus::Pending);
        assert_eq!(
            confirmation.message,
            Some("Awaiting verification".to_string())
        );
    }

    #[test]
    fn test_bid_confirmation_winner() {
        let confirmation = BidConfirmation::winner().with_message("Congratulations!");
        assert_eq!(confirmation.status, BidStatus::Winner);
        assert_eq!(confirmation.message, Some("Congratulations!".to_string()));
    }

    #[test]
    fn test_bid_confirmation_with_extension() {
        let confirmation = BidConfirmation::accepted().with_duration_extension(300);
        assert_eq!(confirmation.duration_extended, Some(300));
    }

    #[test]
    fn test_bid_confirmation_tags() {
        let tags = BidConfirmation::to_tags("bid123", "auction456");
        assert_eq!(tags.len(), 2);
        assert_eq!(tags[0], vec!["e", "bid123"]);
        assert_eq!(tags[1], vec!["e", "auction456"]);
    }

    #[test]
    fn test_product_unlimited_quantity() {
        let product = Product::new("digital1", "stall1", "Ebook", "USD", 9.99).with_quantity(None);
        assert_eq!(product.quantity, None);
        assert!(product.validate().is_ok());
    }

    #[test]
    fn test_product_multiple_images() {
        let product = Product::new("prod1", "stall1", "Item", "USD", 10.0)
            .with_image("image1.jpg")
            .with_image("image2.jpg")
            .with_image("image3.jpg");
        assert_eq!(product.images.as_ref().unwrap().len(), 3);
    }

    #[test]
    fn test_product_multiple_specs() {
        let product = Product::new("prod1", "stall1", "Phone", "USD", 599.0)
            .with_spec("os", "Android")
            .with_spec("screen", "6.5 inches")
            .with_spec("storage", "128GB");
        assert_eq!(product.specs.len(), 3);
    }

    #[test]
    fn test_shipping_zone_with_region() {
        let zone = ShippingZone::new("zone1", "Europe", 8.0, vec!["DE", "FR"])
            .with_region("IT")
            .with_region("ES");
        assert_eq!(zone.regions.len(), 4);
    }
}
