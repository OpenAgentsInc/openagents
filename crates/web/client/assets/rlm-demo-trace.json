{
  "query": "What are the main components of the Repo-RLM runtime spec?",
  "document_preview": "## 0) What we're building\n\n### External contract (drop-in)\n\n```text\nanswer = repo_rlm(prompt: String) -> String\n```\n\n### Internal reality\n\n* `prompt` stays small (task/question)\n* repo is mounted into a sandbox\n* the runtime exposes a **tool API** (list/read/grep/symbols/diff)...",
  "events": [
    {"t": 0, "type": "phase_start", "phase": "routing"},
    {"t": 400, "type": "routing_result", "sections": "External Contract, Core Design Goals, Repository Environment, Tool API, Program Graph, Budgets, Tracing, Safety Model"},
    {"t": 800, "type": "phase_start", "phase": "chunking"},
    {"t": 1000, "type": "chunk_created", "id": 0, "section": "External Contract", "preview": "answer = repo_rlm(prompt: String) -> String. External API is string-in/string-out. Internally: prompt stays small, repo mounted in sandbox, runtime exposes tool API."},
    {"t": 1200, "type": "chunk_created", "id": 1, "section": "Core Design Goals", "preview": "Out-of-core repo access, Reproducible (pin to commit SHA), Safe (sandboxed FS), Auditable (every byte logged), Controllable cost (budgets), Composable (modular program graph)."},
    {"t": 1400, "type": "chunk_created", "id": 2, "section": "Repository Environment", "preview": "Repo handle with commit pinning. SpanRef as provenance primitive: path, commit SHA, line range, byte range, content hash. Every tool returns (SpanRef, text)."},
    {"t": 1600, "type": "chunk_created", "id": 3, "section": "Tool API", "preview": "File discovery: list_files, tree, stat. Reading: read_lines, read_bytes, head/tail. Search: grep, rg. Structure: symbols (tree-sitter), imports, chunk_by_ast. Git: git_diff, git_blame."},
    {"t": 1800, "type": "chunk_created", "id": 4, "section": "Program Graph", "preview": "DSPy-like modules: Router (pick candidate files), Reader/Chunker (fetch spans safely), Extractor (per-chunk semantic extraction), Reducer (combine facts), Verifier (check citations)."},
    {"t": 2000, "type": "chunk_created", "id": 5, "section": "Budgets & Stopping", "preview": "Budget struct: max_wall_ms, max_tool_calls, max_llm_calls, max_input_tokens, max_output_tokens, max_usd_micros. Hard stop on any limit, best-effort finalize."},
    {"t": 2200, "type": "chunk_created", "id": 6, "section": "Tracing & Provenance", "preview": "TraceEvent enum: ToolCall, LlmCall, Read, Fact, Decision, Final. Store as JSONL per run. Enables debugging, eval reproducibility, prompt optimization."},
    {"t": 2400, "type": "chunk_created", "id": 7, "section": "Module Signatures", "preview": "RouterSignature: query + hints -> candidates. ExtractorSignature: query + span + text -> facts. ReducerSignature: query + facts -> answer + citations. VerifierSignature: query + answer + citations -> pass/fail."},

    {"t": 2800, "type": "phase_start", "phase": "extraction"},
    {"t": 3000, "type": "extraction_start", "chunk_id": 0},
    {"t": 3800, "type": "extraction_complete", "chunk_id": 0, "findings": "The external API maintains LLM compatibility: string in, string out. Internally, the prompt stays small while the repo is mounted in a sandbox with tool access for selective reading.", "relevance": 0.95},

    {"t": 4000, "type": "extraction_start", "chunk_id": 1},
    {"t": 4800, "type": "extraction_complete", "chunk_id": 1, "findings": "Six core design goals: (1) out-of-core repo access, (2) reproducibility via commit pinning, (3) sandboxed safety, (4) full auditability, (5) cost control via budgets, (6) composable modular architecture.", "relevance": 0.92},

    {"t": 5000, "type": "extraction_start", "chunk_id": 2},
    {"t": 5800, "type": "extraction_complete", "chunk_id": 2, "findings": "Repository Environment uses SpanRef as the provenance primitive, tracking path, commit SHA, line/byte ranges, and content hash. Every tool operation returns (SpanRef, text) for full traceability.", "relevance": 0.88},

    {"t": 6000, "type": "extraction_start", "chunk_id": 3},
    {"t": 6800, "type": "extraction_complete", "chunk_id": 3, "findings": "Tool API is minimal but powerful: file discovery (list_files, tree, stat), reading (read_lines, read_bytes), search (grep, rg), structure (symbols via tree-sitter), and optional git operations.", "relevance": 0.90},

    {"t": 7000, "type": "extraction_start", "chunk_id": 4},
    {"t": 7800, "type": "extraction_complete", "chunk_id": 4, "findings": "Program Graph follows DSPy-style modules: Router selects candidate files, Reader/Chunker fetches spans safely, Extractor does per-chunk semantic extraction, Reducer combines facts, Verifier ensures citations are valid.", "relevance": 0.94},

    {"t": 8000, "type": "extraction_start", "chunk_id": 5},
    {"t": 8800, "type": "extraction_complete", "chunk_id": 5, "findings": "Budget system enforces limits on wall time, tool calls, LLM calls, tokens, and cost. Hard stop on any limit with best-effort finalization returning most supported answer.", "relevance": 0.85},

    {"t": 9000, "type": "extraction_start", "chunk_id": 6},
    {"t": 9800, "type": "extraction_complete", "chunk_id": 6, "findings": "Tracing system records all events (ToolCall, LlmCall, Read, Fact, Decision, Final) as JSONL. Enables debugging ('why did it read that file?'), reproducibility, and prompt optimization.", "relevance": 0.87},

    {"t": 10000, "type": "extraction_start", "chunk_id": 7},
    {"t": 10800, "type": "extraction_complete", "chunk_id": 7, "findings": "Four typed module signatures: Router (query -> candidates), Extractor (span -> facts with confidence), Reducer (facts -> answer with citations), Verifier (answer -> pass/fail with missing requests).", "relevance": 0.91},

    {"t": 11200, "type": "phase_start", "phase": "synthesis"},
    {"t": 13500, "type": "synthesis_complete", "answer": "The Repo-RLM runtime spec consists of 6 main components:\n\n1. **External Contract**: String-in/string-out API for LLM compatibility, with repo mounted internally.\n\n2. **Repository Environment**: Repo handle with commit pinning and SpanRef provenance (path, SHA, line/byte ranges, content hash) for every operation.\n\n3. **Tool API**: Minimal orthogonal primitives - file discovery (list_files, tree), reading (read_lines, read_bytes), search (grep), and optional structure/git tools.\n\n4. **Program Graph**: DSPy-style modular pipeline - Router (candidate selection) -> Reader/Chunker (safe span fetching) -> Extractor (per-chunk facts) -> Reducer (combine with citations) -> Verifier (validate claims).\n\n5. **Budget System**: Enforces max_wall_ms, max_tool_calls, max_llm_calls, max_tokens, max_cost with hard stops and best-effort finalization.\n\n6. **Tracing & Provenance**: JSONL event logging (ToolCall, LlmCall, Read, Fact, Decision, Final) for debugging, reproducibility, and optimization.\n\nThe design achieves out-of-core repo access while maintaining safety (sandboxed), auditability (full trace), and cost control (budgets).", "confidence": 0.91},
    {"t": 14000, "type": "complete"}
  ]
}
