# WGPUI Web Architecture

Technical architecture of the WGPUI web deployment.

## Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                         Browser                                  │
├─────────────────────────────────────────────────────────────────┤
│  index.html                                                      │
│    └── <script type="module">                                   │
│          └── import init, { start_demo } from './pkg/...'       │
│                │                                                 │
│                ▼                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  openagents_web.js (wasm-bindgen glue)                  │   │
│  │    • Loads WASM binary                                   │   │
│  │    • Marshals JS ↔ Rust types                           │   │
│  │    • Manages memory                                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                │                                                 │
│                ▼                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  openagents_web_bg.wasm                                  │   │
│  │    • Rust compiled to WebAssembly                        │   │
│  │    • WGPUI rendering engine                              │   │
│  │    • Text shaping (cosmic-text)                          │   │
│  │    • Layout (taffy)                                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                │                                                 │
│                ▼                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  WebGPU / WebGL                                          │   │
│  │    • GPU-accelerated rendering                           │   │
│  │    • Canvas output                                       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                │                                                 │
│                ▼                                                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  <canvas id="canvas">                                    │   │
│  │    • GPU renders directly here                           │   │
│  │    • No DOM manipulation for UI                          │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

## Module Structure

### Rust Side (lib.rs)

```rust
// Entry point - called when WASM loads
#[wasm_bindgen(start)]
pub fn main() {
    console_error_panic_hook::set_once();
}

// Exposed to JavaScript
#[wasm_bindgen]
pub async fn start_demo(canvas_id: &str) -> Result<(), JsValue> {
    // Initialize WebPlatform (wgpu surface, device, queue)
    // Set up event handlers
    // Start animation loop
}
```

### JavaScript Side (generated)

```javascript
// openagents_web.js (auto-generated by wasm-bindgen)

export async function default init() {
    // Fetch and compile WASM
    // Initialize memory
    // Set up imports/exports
}

export function start_demo(canvas_id) {
    // Call into WASM
    // Returns Promise
}
```

### HTML Side

```html
<canvas id="canvas"></canvas>
<script type="module">
    import init, { start_demo } from './pkg/openagents_web.js';
    await init();
    await start_demo('canvas');
</script>
```

## Data Flow

### Initialization

```
1. Browser loads index.html
2. ES module import triggers openagents_web.js load
3. init() fetches openagents_web_bg.wasm
4. WebAssembly.instantiateStreaming() compiles WASM
5. start_demo() called from JS
6. Rust initializes WebPlatform:
   a. Get canvas element from DOM
   b. Create wgpu Instance
   c. Create Surface from canvas
   d. Request GPU adapter
   e. Create Device and Queue
   f. Initialize TextSystem with embedded fonts
   g. Create Renderer with shaders
7. Set up event listeners (keyboard, mouse, wheel, resize)
8. Start requestAnimationFrame loop
```

### Render Loop

```
Each frame (16.6ms at 60fps):

1. requestAnimationFrame callback fires
2. Rust closure invoked via wasm-bindgen
3. Update demo state (frame count, animations)
4. Advance streaming markdown
5. Build Scene (collect draw commands):
   a. draw_quad() - Background, panels
   b. draw_text() - Text runs with glyphs
6. If text atlas dirty, upload to GPU
7. Renderer.prepare() - Convert scene to GPU buffers
8. Renderer.render() - Issue draw calls
9. surface.present() - Swap buffers
10. Schedule next frame
```

### Event Handling

```
Browser Event → JS Callback → WASM → Rust Handler

Keyboard:
  keydown → Closure<dyn FnMut(KeyboardEvent)> → demo.restart_stream()

Mouse:
  mousemove → Closure<dyn FnMut(MouseEvent)> → demo.mouse_pos = ...

Wheel:
  wheel → Closure<dyn FnMut(WheelEvent)> → demo.scroll_offset += ...

Resize:
  ResizeObserver → Closure → platform.handle_resize()
```

## Memory Model

### Linear Memory

WASM has a single linear memory buffer shared between Rust and JS:

```
┌────────────────────────────────────────────────────────┐
│                    WASM Linear Memory                   │
├────────────────────────────────────────────────────────┤
│  Stack (grows down)                                     │
│    • Local variables                                    │
│    • Function call frames                               │
├────────────────────────────────────────────────────────┤
│  Heap (grows up)                                        │
│    • Box, Vec, String allocations                       │
│    • Scene primitives                                   │
│    • Text layouts                                       │
│    • Glyph cache                                        │
├────────────────────────────────────────────────────────┤
│  Static Data                                            │
│    • Embedded fonts (~800KB)                            │
│    • Syntax highlighting themes                         │
│    • String literals                                    │
└────────────────────────────────────────────────────────┘
```

### GPU Memory

Separate from WASM memory, managed by wgpu:

```
┌────────────────────────────────────────────────────────┐
│                      GPU Memory                         │
├────────────────────────────────────────────────────────┤
│  Textures                                               │
│    • Glyph atlas (2048x2048 R8)                        │
│    • Image cache                                        │
├────────────────────────────────────────────────────────┤
│  Buffers                                                │
│    • Vertex buffer (quads, text)                       │
│    • Index buffer                                       │
│    • Uniform buffer (viewport, scale)                  │
├────────────────────────────────────────────────────────┤
│  Pipelines                                              │
│    • Quad pipeline (SDF rendering)                     │
│    • Text pipeline (glyph rendering)                   │
└────────────────────────────────────────────────────────┘
```

## Platform Abstraction

### WebPlatform (wgpui/src/platform.rs)

```rust
pub struct WebPlatform {
    canvas: HtmlCanvasElement,      // DOM canvas element
    device: wgpu::Device,           // GPU device handle
    queue: wgpu::Queue,             // Command submission
    surface: wgpu::Surface,         // Render target
    surface_config: SurfaceConfiguration,
    renderer: Renderer,             // Draw primitives
    text_system: TextSystem,        // Font/glyph handling
    scale_factor: f32,              // HiDPI scaling
    logical_size: Size,             // Canvas dimensions
}
```

### Platform Trait

```rust
pub trait Platform {
    fn logical_size(&self) -> Size;
    fn scale_factor(&self) -> f32;
    fn text_system(&mut self) -> &mut TextSystem;
    fn render(&mut self, scene: &Scene) -> Result<(), String>;
    fn request_redraw(&self);
    fn set_cursor(&self, cursor: Cursor);
    fn handle_resize(&mut self);
}
```

Allows same rendering code to work on:
- Web (WebPlatform)
- Desktop (via winit)
- Headless (for testing)

## Text Rendering Pipeline

```
"Hello" → TextSystem → Scene → Renderer → GPU

1. TextSystem.layout("Hello", position, size, color)
   └── cosmic-text shapes text
   └── Looks up glyphs in cache
   └── Rasterizes missing glyphs to atlas
   └── Returns TextRun with glyph positions

2. Scene.draw_text(text_run)
   └── Stores TextRun in scene's text list

3. Renderer.prepare(scene)
   └── Converts TextRuns to GlyphInstances
   └── Uploads to vertex buffer

4. Renderer.render()
   └── Binds glyph atlas texture
   └── Draws instanced quads
   └── Each quad samples atlas for glyph
```

## Coordinate System

```
Screen Space (physical pixels)
┌─────────────────────────────────────┐
│ (0,0)                               │
│   ┌───────────────────────────┐     │
│   │ Logical Space             │     │
│   │ (CSS pixels)              │     │
│   │                           │     │
│   │   UI coordinates here     │     │
│   │                           │     │
│   └───────────────────────────┘     │
│                        (width*dpr,  │
│                         height*dpr) │
└─────────────────────────────────────┘

scale_factor = window.devicePixelRatio (e.g., 2.0 for Retina)

Physical = Logical * scale_factor
Logical = Physical / scale_factor
```

All UI code uses logical coordinates. Conversion happens at GPU boundary.

## Shader Architecture

### Quad Shader

Renders filled rectangles with optional:
- Background color
- Border (all sides or individual)
- Corner radius (SDF-based)

```wgsl
// Vertex
struct QuadVertex {
    @location(0) position: vec2<f32>,
    @location(1) bounds: vec4<f32>,      // x, y, w, h
    @location(2) background: vec4<f32>,  // RGBA
    @location(3) border_color: vec4<f32>,
    @location(4) border_width: f32,
    @location(5) corner_radius: f32,
}

// Fragment
fn sdf_rounded_rect(p: vec2<f32>, size: vec2<f32>, radius: f32) -> f32 {
    let q = abs(p) - size + radius;
    return length(max(q, vec2(0.0))) + min(max(q.x, q.y), 0.0) - radius;
}
```

### Text Shader

Renders glyphs from atlas:

```wgsl
struct GlyphVertex {
    @location(0) position: vec2<f32>,
    @location(1) uv: vec2<f32>,
    @location(2) color: vec4<f32>,
}

@fragment
fn fs_main(in: GlyphInput) -> @location(0) vec4<f32> {
    let alpha = textureSample(glyph_atlas, sampler, in.uv).r;
    return vec4(in.color.rgb, in.color.a * alpha);
}
```

## Dependencies Graph

```
openagents-web
└── wgpui
    ├── wgpu (GPU abstraction)
    │   ├── wgpu-core (cross-platform core)
    │   └── wgpu-hal (WebGPU/WebGL backends)
    ├── cosmic-text (text shaping)
    │   ├── fontdb (font database)
    │   ├── rustybuzz (shaping)
    │   └── swash (font parsing)
    ├── taffy (flexbox layout)
    ├── syntect (syntax highlighting)
    │   └── fancy-regex
    ├── pulldown-cmark (markdown)
    ├── wasm-bindgen (JS interop)
    └── web-sys (DOM bindings)
```

## Thread Model

WASM is single-threaded by default. All execution happens on the main thread:

```
Main Thread (Browser UI Thread)
├── JS event loop
├── WASM execution
├── requestAnimationFrame
└── GPU command submission

GPU Thread (Browser internal)
└── Command execution
└── Texture uploads
└── Present
```

### Future: Web Workers

For background work (e.g., syntax highlighting large files):

```javascript
// Main thread
const worker = new Worker('worker.js');
worker.postMessage({ type: 'highlight', code: '...' });

// worker.js
importScripts('pkg/openagents_web.js');
onmessage = async (e) => {
    const result = await highlight(e.data.code);
    postMessage(result);
};
```

Requires `--target no-modules` and careful memory management.
