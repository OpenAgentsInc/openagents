# Effect Migration Notes (apps/web)

This repo’s **`apps/web`** app is built on **TanStack Start** (Vite plugin + file-based routing), with **Convex** and **WorkOS AuthKit** integrated.

If you want to “convert basically EVERYTHING to Effect”, you’ll have the best results if you **start at the composition roots** (where global dependencies are created/wired) and then migrate inward (services → loaders/serverFns → components).

---

## What is the “entry point” here?

TanStack Start does not have a classic `src/main.tsx` or `index.html` entry file that you own. The Start Vite plugin bootstraps the runtime and then loads your app via its router config and route tree.

In *this* codebase, the earliest “entry” surfaces you own are:

- `apps/web/src/start.ts`
  - Creates the Start instance via `createStart(...)`
  - Wires request middleware (currently WorkOS `authkitMiddleware()`)
  - This is the **request pipeline seam** (good for request-scoped Effect runtime, logging/tracing, etc.)

- `apps/web/src/router.tsx`
  - `getRouter()` builds and returns the TanStack Router instance
  - Creates **Convex client**, **ConvexQueryClient**, and **React Query QueryClient**
  - Injects these into router `context`
  - This is the **primary composition root** (best first place to introduce Effect Layers/Services)

- `apps/web/src/routes/__root.tsx`
  - Defines the root route + app shell (providers, document layout)
  - Owns important cross-cutting wiring:
    - SSR/client boundary logic via `beforeLoad`
    - WorkOS server call via `createServerFn` + `getAuth()`
    - “set Convex auth token for SSR HTTP client” behavior
  - This is the **SSR/auth + provider seam**

Generated-but-informative:

- `apps/web/src/routeTree.gen.ts`
  - Autogenerated route tree + module augmentation that “registers” `getRouter()` and `startInstance`.

---

## Where to start the Effect migration (recommended)

### Start in `apps/web/src/router.tsx`

This file is already the place where the app constructs “global” dependencies (Convex + query clients) and pushes them into router context.

**Effect-first goal**: define an `AppLayer` (or similar) that provides:

- Configuration (`VITE_CONVEX_URL`, etc.)
- `ConvexReactClient`
- `ConvexQueryClient`
- `QueryClient`
- Any logging/telemetry service you want everywhere

Then `getRouter()` becomes a thin bridge that:

- Builds the Layer once per environment (server vs client) as appropriate
- Exposes the constructed dependencies through router context

This lets every route/component migrate at its own pace by reading from a unified “service surface” rather than importing singletons directly.

### Then adapt `apps/web/src/routes/__root.tsx`

This is where auth and SSR boundaries are currently handled. Once you have an Effect runtime/service surface, you can wrap:

- `createServerFn` handlers (server-side effects)
- `beforeLoad` logic (route “loader” effects)
- auth/token plumbing for Convex SSR HTTP client

Effect provides a consistent way to model:

- typed failures
- structured logging
- retries/timeouts (where appropriate)
- tracing/span context

### Use `apps/web/src/start.ts` for request-scoped concerns

If/when you want request-scoped context (trace IDs, per-request logging, cookie/session context), `start.ts` is a good place to bridge Start middleware into an Effect runtime for server requests.

---

## Suggested migration order (incremental, no big bang)

1. **Composition root**
   - Introduce Effect runtime + `AppLayer` in the web app, wired through `getRouter()` context.

2. **Service boundaries**
   - Wrap external boundaries behind services first:
     - Convex client
     - WorkOS auth (server: `getAuth`, client: hooks)
     - Environment/config (`import.meta.env`)
     - Telemetry/logging (spec: `docs/autopilot/effect-telemetry-service.md`)

3. **Route loaders + serverFns**
   - Convert `loader` / `beforeLoad` / `createServerFn` logic to Effect programs.
   - Keep the public shape the same (Start expects promises), but run Effect inside.

4. **UI + components**
   - Only after services are clean: migrate components/hook usage.
   - Treat components as “dumb” view layer over Effect-backed hooks/services.

---

## What “success” looks like

- No route/module constructs “global” singletons ad hoc; everything is composed in one place (Layer).
- SSR/client behavior is explicit (separate Layers if needed).
- Auth/Convex/query wiring is not scattered; it’s services with small adapters.

---

## Related references

- Patterns to adopt from `~/code/crest` (Next.js + Effect + Convex): `docs/autopilot/effect-patterns-from-crest.md`

