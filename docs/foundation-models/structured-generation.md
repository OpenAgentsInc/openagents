#+ Structured Generation with Schemas

Structured generation produces typed Swift objects using `@Generable` and `@Guide`, avoiding brittle text parsing. The framework performs constrained decoding to match your schema during token generation.

## Key Macros

- `@Generable`: declares a type whose instances can be generated by the model; also emits a JSON Schema
- `@Guide`: constrains/annotates fields (descriptions, counts, ranges, one‑of, regex)

## Example

```swift
@Generable
struct RecipeRecommendation {
    @Guide(description: "Dish name") var name: String
    @Guide(description: "Brief instructions") var instructions: String
}

let rec = try await session.respond(
    to: "Suggest a quick vegetarian pasta",
    generating: RecipeRecommendation.self
)
```

## Constraints

- Count: `.count(3)` for fixed list lengths
- Range: `.range(1...5)` for numeric bounds
- One‑of enums: model picks a valid case
- Regex (when supported): match simple patterns

Use descriptions to steer style/length (“50–100 words”, “max 60 chars”).

## Optional Fields & Collections

`@Generable` supports optionals and arrays naturally. Keep schemas compact; prefer names that read well in UI.

## Streaming Structured Results

```swift
let stream = session.streamResponse(to: prompt, generating: RecipeRecommendation.self)
for try await snap in stream {
    // Bind snap.content?.name / .instructions as they appear
}
```

## OpenAgents Guidance

- Prefer structured generation for anything you would otherwise parse (plans, summaries, result cards)
- Reuse the same `@Generable` types to export JSON Schema to external providers when falling back (see external-json-apis.md)
- Keep types small and focused per surface; use nested structures for richer cards only where needed

