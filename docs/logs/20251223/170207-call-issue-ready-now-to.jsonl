{"type":"system","message":{"subtype":"init","agents":["general-purpose","statusline-setup","Explore","Plan"],"apiKeySource":"none","betas":null,"claude_code_version":"2.0.76","cwd":"/home/christopherdavid/code/openagents","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","KillShell","AskUserQuestion","Skill","EnterPlanMode","LSP","mcp__issues__issue_list","mcp__issues__issue_create","mcp__issues__issue_get","mcp__issues__issue_claim","mcp__issues__issue_complete","mcp__issues__issue_block","mcp__issues__issue_ready","mcp__issues__issue_update","mcp__issues__enter_plan_mode","mcp__issues__exit_plan_mode","mcp__issues__advance_plan_phase","mcp__issues__get_current_phase","mcp__issues__issue_delete","mcp__issues__directive_list","mcp__issues__directive_get","mcp__issues__directive_create","mcp__issues__directive_update","mcp__effect-docs__effect_docs_search","mcp__effect-docs__get_effect_doc","ListMcpResourcesTool","ReadMcpResourceTool"],"mcp_servers":[{"name":"issues","status":"connected"},{"name":"effect-docs","status":"connected"}],"model":"claude-sonnet-4-5-20250929","permissionMode":"bypassPermissions","slash_commands":["codex","compact","context","cost","init","pr-comments","release-notes","review","security-review"],"output_style":"default","skills":["codex"],"plugins":[{"name":"rust-analyzer-lsp","path":"/home/christopherdavid/.claude/plugins/cache/claude-plugins-official/rust-analyzer-lsp/1.0.0"}],"uuid":"93cbea40-f9d2-414d-9da7-0bc13f5f7a72","session_id":"35102d4b-d2d2-49b7-9f66-151565886fda"},"timestamp":"2025-12-23T23:02:09.011528030+00:00"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01WLBKxvno63nyaN6EnEUVRU","type":"message","role":"assistant","content":[{"type":"text","text":"I'll start the autonomous loop by calling issue_ready to get the first issue."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":16317,"cache_read_input_tokens":12673,"cache_creation":{"ephemeral_5m_input_tokens":16317,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"timestamp":"2025-12-23T23:02:12.912610968+00:00"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01WLBKxvno63nyaN6EnEUVRU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017hbVirZCHE89rEELu3ohDx","name":"mcp__issues__issue_ready","input":{}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":16317,"cache_read_input_tokens":12673,"cache_creation":{"ephemeral_5m_input_tokens":16317,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"timestamp":"2025-12-23T23:02:13.007141945+00:00"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017hbVirZCHE89rEELu3ohDx","type":"tool_result","content":[{"type":"text","text":"{\n  \"number\": 1015,\n  \"title\": \"Tune model selection rules based on task complexity outcomes\",\n  \"description\": \"Analyze which model (sonnet/opus/haiku) performs best for different task types:\\n- Correlate model choice with task completion rate\\n- Identify task complexity indicators\\n- Create decision tree for optimal model selection\\n- Update autopilot to auto-select model based on task characteristics\",\n  \"priority\": \"medium\",\n  \"issue_type\": \"feature\",\n  \"agent\": \"claude\"\n}"}]}]},"timestamp":"2025-12-23T23:02:13.045753964+00:00"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Xk4iG6DEChhVvyg962Lae4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Gf3ryr22a52zDhUQs8sgue","name":"mcp__issues__issue_claim","input":{"number":1015,"run_id":"auto-20251223-172547"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":194,"cache_read_input_tokens":28990,"cache_creation":{"ephemeral_5m_input_tokens":194,"ephemeral_1h_input_tokens":0},"output_tokens":85,"service_tier":"standard"},"context_management":null},"timestamp":"2025-12-23T23:02:16.415073074+00:00"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Gf3ryr22a52zDhUQs8sgue","type":"tool_result","content":[{"type":"text","text":"Claimed issue #1015"}]}]},"timestamp":"2025-12-23T23:02:16.429381542+00:00"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01C6dZcPtzQaKuQqEc5dR5mP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RWWjkji9uB52iCCUKCqvLF","name":"TodoWrite","input":{"todos":[{"content":"Analyze existing metrics to understand model performance patterns","activeForm":"Analyzing existing metrics to understand model performance patterns","status":"in_progress"},{"content":"Correlate model choice with task completion rate","activeForm":"Correlating model choice with task completion rate","status":"pending"},{"content":"Identify task complexity indicators","activeForm":"Identifying task complexity indicators","status":"pending"},{"content":"Create decision tree for optimal model selection","activeForm":"Creating decision tree for optimal model selection","status":"pending"},{"content":"Update autopilot to auto-select model based on task characteristics","activeForm":"Updating autopilot to auto-select model based on task characteristics","status":"pending"},{"content":"Test model selection logic","activeForm":"Testing model selection logic","status":"pending"},{"content":"Commit and push changes","activeForm":"Committing and pushing changes","status":"pending"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":103,"cache_read_input_tokens":29184,"cache_creation":{"ephemeral_5m_input_tokens":103,"ephemeral_1h_input_tokens":0},"output_tokens":365,"service_tier":"standard"},"context_management":null},"timestamp":"2025-12-23T23:02:22.360612785+00:00"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RWWjkji9uB52iCCUKCqvLF","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"timestamp":"2025-12-23T23:02:22.370599632+00:00"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_018ZBTNQFALGiqor8fBWYkhv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NHDqsqc29F4VMzAwvX6YnX","name":"Glob","input":{"pattern":"**/autopilot/**/*.rs"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":328,"cache_read_input_tokens":29287,"cache_creation":{"ephemeral_5m_input_tokens":328,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"timestamp":"2025-12-23T23:02:25.119076429+00:00"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NHDqsqc29F4VMzAwvX6YnX","type":"tool_result","content":"/home/christopherdavid/code/openagents/crates/autopilot/src/redact.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/timestamp.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/ui_renderer.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/goals.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/nostr_agent.rs\n/home/christopherdavid/code/openagents/crates/autopilot/benches/nip_sa_state.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/trajectory_publisher.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/dashboard/state.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/tests/mod.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/daemon/state.rs\n/home/christopherdavid/code/openagents/crates/autopilot/benches/task_execution.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/benchmark/tasks.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/nip_sa_trajectory.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/profiling.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/trajectory.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/tests/dashboard_snapshots.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/tool_patterns.rs\n/home/christopherdavid/code/openagents/crates/autopilot/benches/trajectory_overhead.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/daemon/metrics.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/benchmark/mod.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/daemon/mod.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/tests/dashboard_api.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/daemon/http.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/notifications.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/alerts.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/apm_parser.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/metrics/baseline.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/planmode.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/state.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/logs.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/replay.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/daemon/memory.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/rlog.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/apm.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/daemon/config.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/daemon/supervisor.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/daemon/control.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/bin/autopilotd.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/memory.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/lockfile.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/metrics/mod.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/reports.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/apm_storage.rs\n/home/christopherdavid/code/openagents/crates/autopilot/src/parallel/mod.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/benches/nip_sa_state.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/benches/task_execution.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/benches/trajectory_overhead.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/examples/issue_workflow.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/examples/simple_task.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/examples/trajectory_analysis.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/alerts.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/analyze.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/apm.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/apm_parser.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/apm_storage.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/auto_issues.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/benchmark/mod.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/benchmark/tasks.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/bin/autopilotd.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/compaction.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/daemon/config.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/daemon/control.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/daemon/http.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/daemon/memory.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/daemon/metrics.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/daemon/mod.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/daemon/state.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/daemon/supervisor.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/dashboard.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/dashboard/state.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/goals.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/learning.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/lib.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/lockfile.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/logs.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/main.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/memory.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/metrics/baseline.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/metrics/mod.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/nip_sa_trajectory.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/nostr_agent.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/notifications.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/parallel/docker.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/parallel/mod.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/parallel/worktree.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/planmode.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/profiling.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/redact.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/replay.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/reports.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/rlog.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/state.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/tests/dashboard_api.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/tests/dashboard_snapshots.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/tests/mod.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/timestamp.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/tool_patterns.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/trajectory.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/trajectory_publisher.rs\n/home/christopherdavid/code/openagents/.worktrees/agent-002/crates/autopilot/src/ui_renderer.rs\n(Results are truncated. Consider using a more specific path or pattern.)"}]},"timestamp":"2025-12-23T23:02:25.196602943+00:00"}
{"type":"assistant","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01Lb9RWEstjgR3etoZiZ2YTo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Y5RwiFX6j4BuBayRQYBD5T","name":"Read","input":{"file_path":"/home/christopherdavid/code/openagents/crates/autopilot/src/lib.rs"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":3512,"cache_read_input_tokens":29615,"cache_creation":{"ephemeral_5m_input_tokens":3512,"ephemeral_1h_input_tokens":0},"output_tokens":79,"service_tier":"standard"},"context_management":null},"timestamp":"2025-12-23T23:02:29.102368605+00:00"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Y5RwiFX6j4BuBayRQYBD5T","type":"tool_result","content":"     1→//! Autopilot - Autonomous task runner with trajectory logging\n     2→//!\n     3→//! This crate provides a CLI tool that executes tasks via the Claude Agent SDK\n     4→//! and logs the complete trajectory in both rlog and JSON formats.\n     5→\n     6→use std::path::PathBuf;\n     7→\n     8→pub mod alerts;\n     9→pub mod analyze;\n    10→pub mod apm;\n    11→pub mod apm_parser;\n    12→pub mod apm_storage;\n    13→pub mod auto_issues;\n    14→pub mod benchmark;\n    15→pub mod cli;\n    16→pub mod compaction;\n    17→pub mod context_analysis;\n    18→pub mod daemon;\n    19→pub mod dashboard;\n    20→pub mod goals;\n    21→pub mod learning;\n    22→pub mod lockfile;\n    23→pub mod logs;\n    24→pub mod memory;\n    25→pub mod metrics;\n    26→pub mod nip_sa_trajectory;\n    27→pub mod notifications;\n    28→pub mod nostr_agent;\n    29→pub mod parallel;\n    30→pub mod planmode;\n    31→pub mod profiling;\n    32→pub mod redact;\n    33→pub mod replay;\n    34→pub mod reports;\n    35→pub mod rlog;\n    36→pub mod state;\n    37→pub mod timestamp;\n    38→pub mod tool_patterns;\n    39→pub mod trajectory;\n    40→pub mod trajectory_publisher;\n    41→pub mod ui_renderer;\n    42→pub mod weekly_report;\n    43→\n    44→#[cfg(test)]\n    45→mod tests;\n    46→\n    47→use chrono::Utc;\n    48→use claude_agent_sdk::{\n    49→    SdkAssistantMessage, SdkMessage, SdkResultMessage, SdkSystemMessage, SdkUserMessage,\n    50→};\n    51→use serde_json::Value;\n    52→use trajectory::{JsonlWriter, StepType, SubagentStatus, TokenUsage, Trajectory, TrajectoryResult};\n    53→use rlog::RlogWriter;\n    54→\n    55→/// Callback invoked when session_id becomes available\n    56→pub type SessionIdCallback = Box<dyn FnOnce(&str) + Send>;\n    57→\n    58→/// Collects SdkMessages into a Trajectory\n    59→///\n    60→/// The TrajectoryCollector processes Claude Agent SDK messages and builds\n    61→/// a complete trajectory of an agent's execution, including tool calls,\n    62→/// thinking blocks, and results. It supports streaming output to both\n    63→/// rlog (human-readable) and JSONL (Claude Code compatible) formats.\n    64→///\n    65→/// # Examples\n    66→///\n    67→/// Basic usage:\n    68→///\n    69→/// ```no_run\n    70→/// use autopilot::TrajectoryCollector;\n    71→///\n    72→/// let mut collector = TrajectoryCollector::new(\n    73→///     \"Fix the bug in auth.rs\".to_string(),\n    74→///     \"claude-sonnet-4-5-20250929\".to_string(),\n    75→///     \"/home/user/project\".to_string(),\n    76→///     \"abc123\".to_string(),\n    77→///     Some(\"main\".to_string()),\n    78→/// );\n    79→///\n    80→/// // Enable streaming output\n    81→/// collector.enable_streaming(\"logs/session.rlog\").unwrap();\n    82→/// collector.enable_jsonl_streaming(\"logs/session.jsonl\").unwrap();\n    83→///\n    84→/// // Process SDK messages as they arrive\n    85→/// // for msg in sdk_stream {\n    86→/// //     collector.process_message(&msg);\n    87→/// // }\n    88→///\n    89→/// // Get the final trajectory\n    90→/// let trajectory = collector.finish();\n    91→/// println!(\"Session completed: {}\", trajectory.session_id);\n    92→/// ```\n    93→pub struct TrajectoryCollector {\n    94→    trajectory: Trajectory,\n    95→    /// Optional rlog writer for streaming output (truncated, human-readable)\n    96→    rlog_writer: Option<RlogWriter>,\n    97→    /// Path to the rlog file for header updates\n    98→    rlog_path: Option<std::path::PathBuf>,\n    99→    /// Optional JSONL writer for full data capture (untruncated, Claude Code compatible)\n   100→    jsonl_writer: Option<JsonlWriter>,\n   101→    /// Callback invoked when session_id is set\n   102→    session_id_callback: Option<SessionIdCallback>,\n   103→    /// Active subagents: tool_id -> (agent_type, description)\n   104→    active_subagents: std::collections::HashMap<String, (String, String)>,\n   105→    /// APM session ID (if APM tracking is enabled)\n   106→    apm_session_id: Option<String>,\n   107→    /// Path to APM database (if APM tracking is enabled)\n   108→    apm_db_path: Option<PathBuf>,\n   109→    /// Whether to stream full JSON to stdout (for GUI)\n   110→    json_stdout: bool,\n   111→}\n   112→\n   113→impl TrajectoryCollector {\n   114→    /// Create a new collector\n   115→    pub fn new(\n   116→        prompt: String,\n   117→        model: String,\n   118→        cwd: String,\n   119→        repo_sha: String,\n   120→        branch: Option<String>,\n   121→    ) -> Self {\n   122→        Self {\n   123→            trajectory: Trajectory::new(prompt, model, cwd, repo_sha, branch),\n   124→            rlog_writer: None,\n   125→            rlog_path: None,\n   126→            jsonl_writer: None,\n   127→            session_id_callback: None,\n   128→            active_subagents: std::collections::HashMap::new(),\n   129→            apm_session_id: None,\n   130→            apm_db_path: None,\n   131→            json_stdout: false,\n   132→        }\n   133→    }\n   134→\n   135→    /// Set a callback to be invoked when session_id becomes available\n   136→    ///\n   137→    /// This is useful for tasks that need to know the session ID as soon as\n   138→    /// it's assigned by the SDK, such as updating databases or creating\n   139→    /// trajectory links.\n   140→    ///\n   141→    /// # Examples\n   142→    ///\n   143→    /// ```no_run\n   144→    /// use autopilot::TrajectoryCollector;\n   145→    ///\n   146→    /// let mut collector = TrajectoryCollector::new(\n   147→    ///     \"Task\".to_string(),\n   148→    ///     \"claude-sonnet-4-5-20250929\".to_string(),\n   149→    ///     \"/home/user/project\".to_string(),\n   150→    ///     \"abc123\".to_string(),\n   151→    ///     None,\n   152→    /// );\n   153→    ///\n   154→    /// collector.on_session_id(|session_id| {\n   155→    ///     println!(\"Session started: {}\", session_id);\n   156→    ///     // Update database, send notification, etc.\n   157→    /// });\n   158→    /// ```\n   159→    pub fn on_session_id<F>(&mut self, callback: F)\n   160→    where\n   161→        F: FnOnce(&str) + Send + 'static,\n   162→    {\n   163→        self.session_id_callback = Some(Box::new(callback));\n   164→    }\n   165→\n   166→    /// Enable streaming rlog output to a file\n   167→    pub fn enable_streaming(&mut self, path: impl AsRef<std::path::Path>) -> std::io::Result<()> {\n   168→        let path = path.as_ref();\n   169→        let mut writer = RlogWriter::new_streaming(path)?;\n   170→        writer.write_header(&self.trajectory)?;\n   171→        self.rlog_writer = Some(writer);\n   172→        self.rlog_path = Some(path.to_path_buf());\n   173→        Ok(())\n   174→    }\n   175→\n   176→    /// Enable JSONL streaming for full data capture (Claude Code compatible format)\n   177→    pub fn enable_jsonl_streaming(&mut self, path: impl AsRef<std::path::Path>) -> std::io::Result<()> {\n   178→        let mut writer = JsonlWriter::new();\n   179→        writer.init(path, &self.trajectory.session_id)?;\n   180→        self.jsonl_writer = Some(writer);\n   181→        Ok(())\n   182→    }\n   183→\n   184→    /// Enable JSON stdout streaming for GUI consumption\n   185→    ///\n   186→    /// When enabled, raw JSON events are printed to stdout with a `j:` prefix\n   187→    /// for the desktop GUI to consume. This provides complete, untruncated\n   188→    /// JSON data for debugging and inspection.\n   189→    pub fn enable_json_stdout(&mut self) {\n   190→        self.json_stdout = true;\n   191→    }\n   192→\n   193→    /// Enable APM tracking with database storage\n   194→    ///\n   195→    /// Creates an APM session and records events to the database during execution.\n   196→    /// This allows for historical APM analysis and trend tracking.\n   197→    ///\n   198→    /// # Arguments\n   199→    /// * `db_path` - Path to the database file (will be initialized with APM tables if needed)\n   200→    /// * `source` - APM source (Autopilot or ClaudeCode)\n   201→    ///\n   202→    /// # Returns\n   203→    /// Result with the APM session ID on success\n   204→    pub fn enable_apm_tracking(\n   205→        &mut self,\n   206→        db_path: impl AsRef<std::path::Path>,\n   207→        source: apm::APMSource,\n   208→    ) -> anyhow::Result<String> {\n   209→        use apm_storage::{create_session, init_apm_tables};\n   210→        use rusqlite::Connection;\n   211→\n   212→        let db_path = db_path.as_ref();\n   213→        let conn = Connection::open(db_path)?;\n   214→        init_apm_tables(&conn)?;\n   215→\n   216→        // Create APM session with a unique ID\n   217→        let session_id = format!(\"apm-{}\", uuid::Uuid::new_v4());\n   218→        create_session(&conn, &session_id, source)?;\n   219→\n   220→        self.apm_session_id = Some(session_id.clone());\n   221→        self.apm_db_path = Some(db_path.to_path_buf());\n   222→\n   223→        Ok(session_id)\n   224→    }\n   225→\n   226→    /// Record an APM event (if APM tracking is enabled)\n   227→    fn record_apm_event(&self, event_type: apm_storage::APMEventType, metadata: Option<&str>) {\n   228→        use apm_storage::record_event;\n   229→        use rusqlite::Connection;\n   230→\n   231→        if let (Some(session_id), Some(db_path)) = (&self.apm_session_id, &self.apm_db_path) {\n   232→            if let Ok(conn) = Connection::open(db_path) {\n   233→                if let Err(e) = record_event(&conn, session_id, event_type, metadata) {\n   234→                    eprintln!(\"ERROR: Failed to record APM event: {}\", e);\n   235→                }\n   236→            }\n   237→        }\n   238→    }\n   239→\n   240→    /// Set the session_id (useful when resuming a session)\n   241→    pub fn set_session_id(&mut self, session_id: String) {\n   242→        self.trajectory.session_id = session_id;\n   243→    }\n   244→\n   245→    /// Stream the last added step to rlog file (if streaming is enabled)\n   246→    fn stream_last_step(&mut self) {\n   247→        if let (Some(writer), Some(last_step)) = (&mut self.rlog_writer, self.trajectory.steps.last()) {\n   248→            if let Err(e) = writer.append_step(last_step) {\n   249→                eprintln!(\"ERROR: Failed to append step to rlog: {}\", e);\n   250→            }\n   251→        }\n   252→    }\n   253→\n   254→    /// Stream a raw SDK message to JSONL file (if JSONL streaming is enabled)\n   255→    fn stream_message_to_jsonl(&mut self, msg: &SdkMessage) {\n   256→        if let Some(writer) = &mut self.jsonl_writer {\n   257→            // Convert SdkMessage to a serializable format\n   258→            let json_value = match msg {\n   259→                SdkMessage::System(sys) => {\n   260→                    serde_json::json!({\n   261→                        \"type\": \"system\",\n   262→                        \"message\": sys,\n   263→                        \"timestamp\": chrono::Utc::now().to_rfc3339()\n   264→                    })\n   265→                }\n   266→                SdkMessage::Assistant(asst) => {\n   267→                    serde_json::json!({\n   268→                        \"type\": \"assistant\",\n   269→                        \"message\": asst.message,\n   270→                        \"timestamp\": chrono::Utc::now().to_rfc3339()\n   271→                    })\n   272→                }\n   273→                SdkMessage::User(user) => {\n   274→                    serde_json::json!({\n   275→                        \"type\": \"user\",\n   276→                        \"message\": user.message,\n   277→                        \"timestamp\": chrono::Utc::now().to_rfc3339()\n   278→                    })\n   279→                }\n   280→                SdkMessage::Result(result) => {\n   281→                    serde_json::json!({\n   282→                        \"type\": \"result\",\n   283→                        \"message\": result,\n   284→                        \"timestamp\": chrono::Utc::now().to_rfc3339()\n   285→                    })\n   286→                }\n   287→                SdkMessage::ToolProgress(progress) => {\n   288→                    serde_json::json!({\n   289→                        \"type\": \"tool_progress\",\n   290→                        \"message\": progress,\n   291→                        \"timestamp\": chrono::Utc::now().to_rfc3339()\n   292→                    })\n   293→                }\n   294→                SdkMessage::StreamEvent(event) => {\n   295→                    serde_json::json!({\n   296→                        \"type\": \"stream_event\",\n   297→                        \"message\": event,\n   298→                        \"timestamp\": chrono::Utc::now().to_rfc3339()\n   299→                    })\n   300→                }\n   301→                SdkMessage::AuthStatus(auth) => {\n   302→                    serde_json::json!({\n   303→                        \"type\": \"auth_status\",\n   304→                        \"message\": auth,\n   305→                        \"timestamp\": chrono::Utc::now().to_rfc3339()\n   306→                    })\n   307→                }\n   308→            };\n   309→            if let Err(e) = writer.write_value(&json_value) {\n   310→                eprintln!(\"ERROR: Failed to write value to JSONL: {}\", e);\n   311→            }\n   312→        }\n   313→    }\n   314→\n   315→    /// Stream raw SDK message JSON to stdout (if json_stdout is enabled)\n   316→    fn stream_message_to_stdout(&self, msg: &SdkMessage) {\n   317→        if !self.json_stdout {\n   318→            return;\n   319→        }\n   320→\n   321→        // Convert SdkMessage to JSON (same format as JSONL)\n   322→        let json_value = match msg {\n   323→            SdkMessage::System(sys) => {\n   324→                serde_json::json!({\n   325→                    \"type\": \"system\",\n   326→                    \"message\": sys,\n   327→                    \"timestamp\": chrono::Utc::now().to_rfc3339()\n   328→                })\n   329→            }\n   330→            SdkMessage::Assistant(asst) => {\n   331→                serde_json::json!({\n   332→                    \"type\": \"assistant\",\n   333→                    \"message\": asst.message,\n   334→                    \"timestamp\": chrono::Utc::now().to_rfc3339()\n   335→                })\n   336→            }\n   337→            SdkMessage::User(user) => {\n   338→                serde_json::json!({\n   339→                    \"type\": \"user\",\n   340→                    \"message\": user.message,\n   341→                    \"timestamp\": chrono::Utc::now().to_rfc3339()\n   342→                })\n   343→            }\n   344→            SdkMessage::Result(result) => {\n   345→                serde_json::json!({\n   346→                    \"type\": \"result\",\n   347→                    \"message\": result,\n   348→                    \"timestamp\": chrono::Utc::now().to_rfc3339()\n   349→                })\n   350→            }\n   351→            SdkMessage::ToolProgress(progress) => {\n   352→                serde_json::json!({\n   353→                    \"type\": \"tool_progress\",\n   354→                    \"message\": progress,\n   355→                    \"timestamp\": chrono::Utc::now().to_rfc3339()\n   356→                })\n   357→            }\n   358→            SdkMessage::StreamEvent(event) => {\n   359→                serde_json::json!({\n   360→                    \"type\": \"stream_event\",\n   361→                    \"message\": event,\n   362→                    \"timestamp\": chrono::Utc::now().to_rfc3339()\n   363→                })\n   364→            }\n   365→            SdkMessage::AuthStatus(auth) => {\n   366→                serde_json::json!({\n   367→                    \"type\": \"auth_status\",\n   368→                    \"message\": auth,\n   369→                    \"timestamp\": chrono::Utc::now().to_rfc3339()\n   370→                })\n   371→            }\n   372→        };\n   373→\n   374→        // Print to stdout with j: prefix for GUI to parse\n   375→        if let Ok(json_str) = serde_json::to_string(&json_value) {\n   376→            println!(\"j:{}\", json_str);\n   377→            // Flush to ensure immediate delivery\n   378→            let _ = std::io::Write::flush(&mut std::io::stdout());\n   379→        }\n   380→    }\n   381→\n   382→    /// Process an SdkMessage and add to trajectory\n   383→    pub fn process_message(&mut self, msg: &SdkMessage) {\n   384→        // Stream raw message to JSONL file (full data capture)\n   385→        self.stream_message_to_jsonl(msg);\n   386→\n   387→        // Stream raw message to stdout for GUI (if enabled)\n   388→        self.stream_message_to_stdout(msg);\n   389→\n   390→        // Then process into trajectory steps (for rlog and analysis)\n   391→        match msg {\n   392→            SdkMessage::System(sys) => self.process_system(sys),\n   393→            SdkMessage::Assistant(asst) => self.process_assistant(asst),\n   394→            SdkMessage::User(user) => self.process_user(user),\n   395→            SdkMessage::Result(result) => self.process_result(result),\n   396→            SdkMessage::ToolProgress(_) => { /* Could track progress */ }\n   397→            SdkMessage::StreamEvent(_) => { /* Could track streaming */ }\n   398→            SdkMessage::AuthStatus(_) => { /* Could track auth */ }\n   399→        }\n   400→    }\n   401→\n   402→    fn process_system(&mut self, sys: &SdkSystemMessage) {\n   403→        match sys {\n   404→            SdkSystemMessage::Init(init) => {\n   405→                self.trajectory.session_id = init.session_id.clone();\n   406→                self.trajectory.add_step(StepType::SystemInit {\n   407→                    model: init.model.clone(),\n   408→                });\n   409→\n   410→                // Update the header now that we have the session_id\n   411→                if let (Some(writer), Some(path)) = (&mut self.rlog_writer, &self.rlog_path) {\n   412→                    if let Err(e) = writer.update_header(path, &self.trajectory) {\n   413→                        eprintln!(\"ERROR: Failed to update rlog header: {}\", e);\n   414→                    }\n   415→                }\n   416→\n   417→                // Invoke session_id callback if set\n   418→                if let Some(callback) = self.session_id_callback.take() {\n   419→                    callback(&init.session_id);\n   420→                }\n   421→\n   422→                self.stream_last_step();\n   423→            }\n   424→            SdkSystemMessage::Status(status) => {\n   425→                if let Some(s) = &status.status {\n   426→                    self.trajectory.add_step(StepType::SystemStatus {\n   427→                        status: format!(\"{:?}\", s),\n   428→                    });\n   429→                    self.stream_last_step();\n   430→                }\n   431→            }\n   432→            _ => {}\n   433→        }\n   434→    }\n   435→\n   436→    fn process_assistant(&mut self, asst: &SdkAssistantMessage) {\n   437→        // Extract token info before adding steps (to avoid borrow issues)\n   438→        let (tokens_in, tokens_out, tokens_cached) = Self::extract_tokens(&asst.message);\n   439→\n   440→        // Parse the message content which contains content blocks\n   441→        if let Some(content) = asst.message.get(\"content\").and_then(|c| c.as_array()) {\n   442→            for block in content {\n   443→                let block_type = block.get(\"type\").and_then(|t| t.as_str()).unwrap_or(\"\");\n   444→\n   445→                match block_type {\n   446→                    \"thinking\" => {\n   447→                        let text = block\n   448→                            .get(\"thinking\")\n   449→                            .and_then(|t| t.as_str())\n   450→                            .unwrap_or(\"\");\n   451→                        let sig = block\n   452→                            .get(\"signature\")\n   453→                            .and_then(|s| s.as_str())\n   454→                            .map(String::from);\n   455→                        let step = self.trajectory.add_step(StepType::Thinking {\n   456→                            content: text.to_string(),\n   457→                            signature: sig,\n   458→                        });\n   459→                        step.tokens_in = tokens_in;\n   460→                        step.tokens_out = tokens_out;\n   461→                        step.tokens_cached = tokens_cached;\n   462→                        self.stream_last_step();\n   463→                    }\n   464→                    \"text\" => {\n   465→                        let text = block.get(\"text\").and_then(|t| t.as_str()).unwrap_or(\"\");\n   466→                        let step = self.trajectory.add_step(StepType::Assistant {\n   467→                            content: text.to_string(),\n   468→                        });\n   469→                        step.tokens_in = tokens_in;\n   470→                        step.tokens_out = tokens_out;\n   471→                        step.tokens_cached = tokens_cached;\n   472→                        self.stream_last_step();\n   473→\n   474→                        // Record APM event\n   475→                        self.record_apm_event(apm_storage::APMEventType::Message, None);\n   476→                    }\n   477→                    \"tool_use\" => {\n   478→                        let tool_name = block\n   479→                            .get(\"name\")\n   480→                            .and_then(|n| n.as_str())\n   481→                            .unwrap_or(\"unknown\");\n   482→                        let tool_id = block.get(\"id\").and_then(|i| i.as_str()).unwrap_or(\"\");\n   483→                        let input = block.get(\"input\").cloned().unwrap_or(Value::Null);\n   484→\n   485→                        // Track issue_complete calls\n   486→                        if tool_name == \"mcp__issues__issue_complete\" {\n   487→                            if let Some(result) = &mut self.trajectory.result {\n   488→                                result.issues_completed += 1;\n   489→                            }\n   490→                        }\n   491→\n   492→                        // Track Task tool calls (subagent spawns)\n   493→                        if tool_name == \"Task\" {\n   494→                            let agent_type = input\n   495→                                .get(\"subagent_type\")\n   496→                                .and_then(|t| t.as_str())\n   497→                                .unwrap_or(\"unknown\")\n   498→                                .to_string();\n   499→                            let description = input\n   500→                                .get(\"description\")\n   501→                                .and_then(|d| d.as_str())\n   502→                                .unwrap_or(\"\")\n   503→                                .to_string();\n   504→\n   505→                            // Store in active subagents map\n   506→                            self.active_subagents.insert(\n   507→                                tool_id.to_string(),\n   508→                                (agent_type.clone(), description.clone()),\n   509→                            );\n   510→\n   511→                            // Add subagent started step\n   512→                            self.trajectory.add_step(StepType::Subagent {\n   513→                                agent_id: tool_id.to_string(),\n   514→                                agent_type,\n   515→                                status: SubagentStatus::Started,\n   516→                                summary: Some(description),\n   517→                            });\n   518→                            self.stream_last_step();\n   519→                        }\n   520→\n   521→                        let step = self.trajectory.add_step(StepType::ToolCall {\n   522→                            tool: tool_name.to_string(),\n   523→                            tool_id: tool_id.to_string(),\n   524→                            input: input.clone(),\n   525→                        });\n   526→                        step.tokens_in = tokens_in;\n   527→                        step.tokens_out = tokens_out;\n   528→                        step.tokens_cached = tokens_cached;\n   529→                        self.stream_last_step();\n   530→\n   531→                        // Record APM event with tool name as metadata\n   532→                        let metadata = serde_json::json!({\"tool\": tool_name}).to_string();\n   533→                        self.record_apm_event(\n   534→                            apm_storage::APMEventType::ToolCall,\n   535→                            Some(&metadata),\n   536→                        );\n   537→                    }\n   538→                    _ => {}\n   539→                }\n   540→            }\n   541→        }\n   542→\n   543→        // Update token usage from message usage field\n   544→        if let Some(inp) = tokens_in {\n   545→            self.trajectory.usage.input_tokens += inp;\n   546→        }\n   547→        if let Some(out) = tokens_out {\n   548→            self.trajectory.usage.output_tokens += out;\n   549→        }\n   550→        if let Some(cached) = tokens_cached {\n   551→            self.trajectory.usage.cache_read_tokens += cached;\n   552→        }\n   553→    }\n   554→\n   555→    fn extract_tokens(message: &Value) -> (Option<u64>, Option<u64>, Option<u64>) {\n   556→        if let Some(usage) = message.get(\"usage\") {\n   557→            (\n   558→                usage.get(\"input_tokens\").and_then(|t| t.as_u64()),\n   559→                usage.get(\"output_tokens\").and_then(|t| t.as_u64()),\n   560→                usage.get(\"cache_read_input_tokens\").and_then(|t| t.as_u64()),\n   561→            )\n   562→        } else {\n   563→            (None, None, None)\n   564→        }\n   565→    }\n   566→\n   567→    fn process_user(&mut self, user: &SdkUserMessage) {\n   568→        // Check if this is a tool result\n   569→        if let Some(content) = user.message.get(\"content\") {\n   570→            match content {\n   571→                Value::Array(arr) => {\n   572→                    // Handle tool_result blocks\n   573→                    for block in arr {\n   574→                        if block.get(\"type\").and_then(|t| t.as_str()) == Some(\"tool_result\") {\n   575→                            let tool_id = block\n   576→                                .get(\"tool_use_id\")\n   577→                                .and_then(|i| i.as_str())\n   578→                                .unwrap_or(\"\");\n   579→                            let is_error = block\n   580→                                .get(\"is_error\")\n   581→                                .and_then(|e| e.as_bool())\n   582→                                .unwrap_or(false);\n   583→                            let output = self.extract_tool_result_content(block);\n   584→\n   585→                            // Check if this is a subagent completion\n   586→                            if let Some((agent_type, _)) = self.active_subagents.remove(tool_id) {\n   587→                                // Extract summary from tool result\n   588→                                let summary = if output.is_empty() {\n   589→                                    None\n   590→                                } else {\n   591→                                    // Truncate summary to first 200 chars for readability\n   592→                                    let trunc = if output.len() > 200 {\n   593→                                        format!(\"{}...\", &output[..200])\n   594→                                    } else {\n   595→                                        output.clone()\n   596→                                    };\n   597→                                    Some(trunc)\n   598→                                };\n   599→\n   600→                                // Add subagent completion step\n   601→                                self.trajectory.add_step(StepType::Subagent {\n   602→                                    agent_id: tool_id.to_string(),\n   603→                                    agent_type,\n   604→                                    status: if is_error {\n   605→                                        SubagentStatus::Error\n   606→                                    } else {\n   607→                                        SubagentStatus::Done\n   608→                                    },\n   609→                                    summary,\n   610→                                });\n   611→                                self.stream_last_step();\n   612→                            }\n   613→\n   614→                            self.trajectory.add_step(StepType::ToolResult {\n   615→                                tool_id: tool_id.to_string(),\n   616→                                success: !is_error,\n   617→                                output: if output.is_empty() {\n   618→                                    None\n   619→                                } else {\n   620→                                    Some(output)\n   621→                                },\n   622→                            });\n   623→                            self.stream_last_step();\n   624→                        }\n   625→                    }\n   626→                }\n   627→                Value::String(s) => {\n   628→                    // Plain user message\n   629→                    self.trajectory.add_step(StepType::User {\n   630→                        content: s.clone(),\n   631→                    });\n   632→                    self.stream_last_step();\n   633→\n   634→                    // Record APM event\n   635→                    self.record_apm_event(apm_storage::APMEventType::Message, None);\n   636→                }\n   637→                _ => {}\n   638→            }\n   639→        }\n   640→    }\n   641→\n   642→    fn process_result(&mut self, result: &SdkResultMessage) {\n   643→        self.trajectory.ended_at = Some(Utc::now());\n   644→\n   645→        match result {\n   646→            SdkResultMessage::Success(success) => {\n   647→                self.trajectory.usage = TokenUsage {\n   648→                    input_tokens: success.usage.input_tokens,\n   649→                    output_tokens: success.usage.output_tokens,\n   650→                    cache_read_tokens: success.usage.cache_read_input_tokens.unwrap_or(0),\n   651→                    cache_creation_tokens: success.usage.cache_creation_input_tokens.unwrap_or(0),\n   652→                    cost_usd: success.total_cost_usd,\n   653→                };\n   654→\n   655→                // Calculate APM for the trajectory\n   656→                let apm = self.calculate_trajectory_apm();\n   657→\n   658→                self.trajectory.result = Some(TrajectoryResult {\n   659→                    success: !success.is_error,\n   660→                    duration_ms: success.duration_ms,\n   661→                    num_turns: success.num_turns,\n   662→                    result_text: Some(success.result.clone()),\n   663→                    errors: Vec::new(),\n   664→                    issues_completed: 0,\n   665→                    apm,\n   666→                });\n   667→            }\n   668→            SdkResultMessage::ErrorDuringExecution(err)\n   669→            | SdkResultMessage::ErrorMaxTurns(err)\n   670→            | SdkResultMessage::ErrorMaxBudget(err)\n   671→            | SdkResultMessage::ErrorMaxStructuredOutputRetries(err) => {\n   672→                self.trajectory.usage = TokenUsage {\n   673→                    input_tokens: err.usage.input_tokens,\n   674→                    output_tokens: err.usage.output_tokens,\n   675→                    cache_read_tokens: err.usage.cache_read_input_tokens.unwrap_or(0),\n   676→                    cache_creation_tokens: err.usage.cache_creation_input_tokens.unwrap_or(0),\n   677→                    cost_usd: err.total_cost_usd,\n   678→                };\n   679→\n   680→                // Calculate APM for the trajectory\n   681→                let apm = self.calculate_trajectory_apm();\n   682→\n   683→                self.trajectory.result = Some(TrajectoryResult {\n   684→                    success: false,\n   685→                    duration_ms: err.duration_ms,\n   686→                    num_turns: err.num_turns,\n   687→                    result_text: None,\n   688→                    errors: err.errors.clone(),\n   689→                    issues_completed: 0,\n   690→                    apm,\n   691→                });\n   692→            }\n   693→        }\n   694→    }\n   695→\n   696→    /// Calculate APM (Actions Per Minute) for the current trajectory\n   697→    fn calculate_trajectory_apm(&self) -> Option<f64> {\n   698→        use crate::apm::calculate_apm_from_timestamps;\n   699→\n   700→        // Count messages (user + assistant)\n   701→        let messages = self.trajectory.steps.iter()\n   702→            .filter(|s| matches!(&s.step_type, StepType::User { .. } | StepType::Assistant { .. }))\n   703→            .count() as u32;\n   704→\n   705→        // Count tool calls\n   706→        let tool_calls = self.trajectory.steps.iter()\n   707→            .filter(|s| matches!(&s.step_type, StepType::ToolCall { .. }))\n   708→            .count() as u32;\n   709→\n   710→        // Get start and end times\n   711→        let start_time = self.trajectory.started_at;\n   712→        let end_time = self.trajectory.ended_at.unwrap_or_else(|| Utc::now());\n   713→\n   714→        calculate_apm_from_timestamps(messages, tool_calls, start_time, end_time)\n   715→    }\n   716→\n   717→    fn extract_tool_result_content(&self, block: &Value) -> String {\n   718→        match block.get(\"content\") {\n   719→            Some(Value::String(s)) => s.clone(),\n   720→            Some(Value::Array(arr)) => arr\n   721→                .iter()\n   722→                .filter_map(|b| b.get(\"text\").and_then(|t| t.as_str()))\n   723→                .collect::<Vec<_>>()\n   724→                .join(\"\\n\"),\n   725→            _ => String::new(),\n   726→        }\n   727→    }\n   728→\n   729→    /// Process a Codex ThreadEvent and add to trajectory\n   730→    pub fn process_codex_event(&mut self, event: &codex_agent_sdk::ThreadEvent) {\n   731→        use codex_agent_sdk::{ThreadEvent, ThreadItemDetails};\n   732→\n   733→        match event {\n   734→            ThreadEvent::ThreadStarted(e) => {\n   735→                // Store thread ID as session_id\n   736→                self.trajectory.session_id = e.thread_id.clone();\n   737→\n   738→                // Update the header now that we have the thread_id\n   739→                if let (Some(writer), Some(path)) = (&mut self.rlog_writer, &self.rlog_path) {\n   740→                    if let Err(e) = writer.update_header(path, &self.trajectory) {\n   741→                        eprintln!(\"ERROR: Failed to update rlog header: {}\", e);\n   742→                    }\n   743→                }\n   744→            }\n   745→            ThreadEvent::ItemCompleted(item_event) => {\n   746→                match &item_event.item.details {\n   747→                    ThreadItemDetails::AgentMessage(msg) => {\n   748→                        self.trajectory.add_step(StepType::Assistant {\n   749→                            content: msg.text.clone(),\n   750→                        });\n   751→                        self.stream_last_step();\n   752→                    }\n   753→                    ThreadItemDetails::Reasoning(reasoning) => {\n   754→                        self.trajectory.add_step(StepType::Thinking {\n   755→                            content: reasoning.text.clone(),\n   756→                            signature: None,\n   757→                        });\n   758→                        self.stream_last_step();\n   759→                    }\n   760→                    ThreadItemDetails::CommandExecution(cmd) => {\n   761→                        self.trajectory.add_step(StepType::ToolCall {\n   762→                            tool: \"Bash\".to_string(),\n   763→                            tool_id: item_event.item.id.clone(),\n   764→                            input: serde_json::json!({ \"command\": cmd.command }),\n   765→                        });\n   766→                        self.stream_last_step();\n   767→\n   768→                        // Add tool result\n   769→                        let success = matches!(cmd.status, codex_agent_sdk::CommandExecutionStatus::Completed);\n   770→                        self.trajectory.add_step(StepType::ToolResult {\n   771→                            tool_id: item_event.item.id.clone(),\n   772→                            success,\n   773→                            output: if cmd.aggregated_output.is_empty() {\n   774→                                None\n   775→                            } else {\n   776→                                Some(cmd.aggregated_output.clone())\n   777→                            },\n   778→                        });\n   779→                        self.stream_last_step();\n   780→                    }\n   781→                    ThreadItemDetails::FileChange(fc) => {\n   782→                        let changes_json = serde_json::to_value(&fc.changes).unwrap_or(serde_json::json!([]));\n   783→                        self.trajectory.add_step(StepType::ToolCall {\n   784→                            tool: \"Edit\".to_string(),\n   785→                            tool_id: item_event.item.id.clone(),\n   786→                            input: serde_json::json!({ \"changes\": changes_json }),\n   787→                        });\n   788→                        self.stream_last_step();\n   789→\n   790→                        // Add tool result\n   791→                        let success = matches!(fc.status, codex_agent_sdk::PatchApplyStatus::Completed);\n   792→                        self.trajectory.add_step(StepType::ToolResult {\n   793→                            tool_id: item_event.item.id.clone(),\n   794→                            success,\n   795→                            output: Some(format!(\"{} file(s) changed\", fc.changes.len())),\n   796→                        });\n   797→                        self.stream_last_step();\n   798→                    }\n   799→                    ThreadItemDetails::McpToolCall(mcp) => {\n   800→                        self.trajectory.add_step(StepType::ToolCall {\n   801→                            tool: format!(\"{}:{}\", mcp.server, mcp.tool),\n   802→                            tool_id: item_event.item.id.clone(),\n   803→                            input: mcp.arguments.clone(),\n   804→                        });\n   805→                        self.stream_last_step();\n   806→\n   807→                        // Add tool result\n   808→                        let success = matches!(mcp.status, codex_agent_sdk::McpToolCallStatus::Completed);\n   809→                        let output = mcp.result.as_ref().map(|r| {\n   810→                            serde_json::to_string_pretty(r).unwrap_or_else(|_| format!(\"{:?}\", r))\n   811→                        });\n   812→                        self.trajectory.add_step(StepType::ToolResult {\n   813→                            tool_id: item_event.item.id.clone(),\n   814→                            success,\n   815→                            output,\n   816→                        });\n   817→                        self.stream_last_step();\n   818→                    }\n   819→                    ThreadItemDetails::WebSearch(ws) => {\n   820→                        self.trajectory.add_step(StepType::ToolCall {\n   821→                            tool: \"WebSearch\".to_string(),\n   822→                            tool_id: item_event.item.id.clone(),\n   823→                            input: serde_json::json!({ \"query\": ws.query }),\n   824→                        });\n   825→                        self.stream_last_step();\n   826→\n   827→                        // Add result\n   828→                        self.trajectory.add_step(StepType::ToolResult {\n   829→                            tool_id: item_event.item.id.clone(),\n   830→                            success: true,\n   831→                            output: Some(format!(\"Search: {}\", ws.query)),\n   832→                        });\n   833→                        self.stream_last_step();\n   834→                    }\n   835→                    ThreadItemDetails::TodoList(todo) => {\n   836→                        let items_json = serde_json::to_value(&todo.items).unwrap_or(serde_json::json!([]));\n   837→                        self.trajectory.add_step(StepType::ToolCall {\n   838→                            tool: \"TodoWrite\".to_string(),\n   839→                            tool_id: item_event.item.id.clone(),\n   840→                            input: serde_json::json!({ \"todos\": items_json }),\n   841→                        });\n   842→                        self.stream_last_step();\n   843→\n   844→                        self.trajectory.add_step(StepType::ToolResult {\n   845→                            tool_id: item_event.item.id.clone(),\n   846→                            success: true,\n   847→                            output: Some(format!(\"{} todo items\", todo.items.len())),\n   848→                        });\n   849→                        self.stream_last_step();\n   850→                    }\n   851→                    ThreadItemDetails::Error(err) => {\n   852→                        self.trajectory.add_step(StepType::SystemStatus {\n   853→                            status: format!(\"Error: {}\", err.message),\n   854→                        });\n   855→                        self.stream_last_step();\n   856→                    }\n   857→                }\n   858→            }\n   859→            ThreadEvent::TurnCompleted(tc) => {\n   860→                // Update token usage\n   861→                self.trajectory.usage.input_tokens += tc.usage.input_tokens as u64;\n   862→                self.trajectory.usage.output_tokens += tc.usage.output_tokens as u64;\n   863→                self.trajectory.usage.cache_read_tokens += tc.usage.cached_input_tokens as u64;\n   864→\n   865→                // Add token info to the last step if available\n   866→                if let Some(step) = self.trajectory.steps.last_mut() {\n   867→                    step.tokens_in = Some(tc.usage.input_tokens as u64);\n   868→                    step.tokens_out = Some(tc.usage.output_tokens as u64);\n   869→                    step.tokens_cached = Some(tc.usage.cached_input_tokens as u64);\n   870→                }\n   871→            }\n   872→            ThreadEvent::TurnFailed(tf) => {\n   873→                self.trajectory.ended_at = Some(Utc::now());\n   874→                self.trajectory.add_step(StepType::SystemStatus {\n   875→                    status: format!(\"Turn failed: {}\", tf.error.message),\n   876→                });\n   877→                self.stream_last_step();\n   878→            }\n   879→            ThreadEvent::Error(e) => {\n   880→                self.trajectory.add_step(StepType::SystemStatus {\n   881→                    status: format!(\"Error: {}\", e.message),\n   882→                });\n   883→                self.stream_last_step();\n   884→            }\n   885→            _ => {\n   886→                // Ignore other events (TurnStarted, ItemStarted, ItemUpdated)\n   887→            }\n   888→        }\n   889→    }\n   890→\n   891→    /// Finish collecting and return the trajectory\n   892→    pub fn finish(mut self) -> Trajectory {\n   893→        // End APM session and save snapshot if tracking is enabled\n   894→        if let (Some(session_id), Some(db_path)) = (&self.apm_session_id, &self.apm_db_path) {\n   895→            use apm_storage::{end_session, get_session_stats, save_snapshot};\n   896→            use rusqlite::Connection;\n   897→\n   898→            if let Ok(conn) = Connection::open(db_path) {\n   899→                if let Err(e) = end_session(&conn, session_id) {\n   900→                    eprintln!(\"ERROR: Failed to end APM session: {}\", e);\n   901→                }\n   902→\n   903→                // Calculate and save APM snapshot\n   904→                if let (Some(apm), Ok((messages, tool_calls))) = (\n   905→                    self.trajectory.result.as_ref().and_then(|r| r.apm),\n   906→                    get_session_stats(&conn, session_id),\n   907→                ) {\n   908→                    let duration_minutes = if let (Some(_result), Some(end)) =\n   909→                        (&self.trajectory.result, self.trajectory.ended_at)\n   910→                    {\n   911→                        (end.timestamp_millis() - self.trajectory.started_at.timestamp_millis())\n   912→                            as f64\n   913→                            / 60_000.0\n   914→                    } else {\n   915→                        0.0\n   916→                    };\n   917→\n   918→                    let snapshot = apm::APMSnapshot {\n   919→                        timestamp: chrono::Utc::now(),\n   920→                        source: apm::APMSource::Autopilot, // Hardcoded for now, could be parameterized\n   921→                        window: apm::APMWindow::Session,\n   922→                        apm,\n   923→                        actions: messages + tool_calls,\n   924→                        duration_minutes,\n   925→                        messages,\n   926→                        tool_calls,\n   927→                    };\n   928→\n   929→                    if let Err(e) = save_snapshot(&conn, &snapshot) {\n   930→                        eprintln!(\"ERROR: Failed to save APM snapshot: {}\", e);\n   931→                    }\n   932→                }\n   933→            }\n   934→        }\n   935→\n   936→        // Write footer to rlog if streaming is enabled\n   937→        if let Some(writer) = &mut self.rlog_writer {\n   938→            if let Err(e) = writer.write_footer(&self.trajectory) {\n   939→                eprintln!(\"ERROR: Failed to write rlog footer: {}\", e);\n   940→            }\n   941→            if let Err(e) = writer.close() {\n   942→                eprintln!(\"ERROR: Failed to close rlog writer: {}\", e);\n   943→            }\n   944→        }\n   945→\n   946→        // Flush JSONL writer if streaming is enabled\n   947→        if let Some(writer) = &mut self.jsonl_writer {\n   948→            if let Err(e) = writer.flush() {\n   949→                eprintln!(\"ERROR: Failed to flush JSONL writer: {}\", e);\n   950→            }\n   951→        }\n   952→\n   953→        self.trajectory\n   954→    }\n   955→\n   956→    /// Get a reference to the current trajectory\n   957→    pub fn trajectory(&self) -> &Trajectory {\n   958→        &self.trajectory\n   959→    }\n   960→\n   961→    /// Consume the collector and return the trajectory (for testing)\n   962→    pub fn into_trajectory(self) -> Trajectory {\n   963→        self.trajectory\n   964→    }\n   965→}\n   966→\n   967→/// Extract session_id from a trajectory JSON file.\n   968→pub fn extract_session_id_from_json(path: &std::path::Path) -> anyhow::Result<String> {\n   969→    let content = std::fs::read_to_string(path)?;\n   970→    let traj: trajectory::Trajectory = serde_json::from_str(&content)?;\n   971→    if traj.session_id.is_empty() {\n   972→        anyhow::bail!(\"No session_id in trajectory file\");\n   973→    }\n   974→    Ok(traj.session_id)\n   975→}\n   976→\n   977→/// Extract session_id from rlog YAML header.\n   978→/// Returns None if the id field is empty or missing.\n   979→pub fn extract_session_id_from_rlog(path: &std::path::Path) -> anyhow::Result<Option<String>> {\n   980→    let content = std::fs::read_to_string(path)?;\n   981→\n   982→    // Find YAML header between --- markers\n   983→    let lines: Vec<&str> = content.lines().collect();\n   984→    if lines.len() < 2 || lines[0] != \"---\" {\n   985→        return Ok(None);\n   986→    }\n   987→\n   988→    // Find end marker\n   989→    let end_idx = lines.iter().skip(1).position(|l| *l == \"---\");\n   990→    let end_idx = match end_idx {\n   991→        Some(idx) => idx + 1, // +1 because we skipped first line\n   992→        None => return Ok(None),\n   993→    };\n   994→\n   995→    // Parse header lines looking for id:\n   996→    for line in &lines[1..end_idx] {\n   997→        if let Some(rest) = line.strip_prefix(\"id:\") {\n   998→            let id = rest.trim();\n   999→            if !id.is_empty() {\n  1000→                return Ok(Some(id.to_string()));\n  1001→            }\n  1002→        }\n  1003→    }\n  1004→\n  1005→    Ok(None)\n  1006→}\n  1007→\n  1008→/// Find the workspace root directory by looking for Cargo.toml with `[workspace]`.\n  1009→///\n  1010→/// Starts from the current directory and walks up until it finds a Cargo.toml\n  1011→/// containing `[workspace]`. This ensures autopilot.db is always created at\n  1012→/// the workspace root, not in subdirectories.\n  1013→///\n  1014→/// Returns the current directory if no workspace root is found (fallback).\n  1015→///\n  1016→/// # Examples\n  1017→///\n  1018→/// ```no_run\n  1019→/// use autopilot::find_workspace_root;\n  1020→///\n  1021→/// let workspace_root = find_workspace_root();\n  1022→/// println!(\"Workspace root: {}\", workspace_root.display());\n  1023→///\n  1024→/// // Use for database path\n  1025→/// let db_path = workspace_root.join(\"autopilot.db\");\n  1026→/// ```\n  1027→pub fn find_workspace_root() -> PathBuf {\n  1028→    let cwd = std::env::current_dir().unwrap_or_else(|_| PathBuf::from(\".\"));\n  1029→    let mut current = cwd.as_path();\n  1030→\n  1031→    loop {\n  1032→        let cargo_toml = current.join(\"Cargo.toml\");\n  1033→        if cargo_toml.exists() {\n  1034→            if let Ok(content) = std::fs::read_to_string(&cargo_toml) {\n  1035→                if content.contains(\"[workspace]\") {\n  1036→                    return current.to_path_buf();\n  1037→                }\n  1038→            }\n  1039→        }\n  1040→\n  1041→        match current.parent() {\n  1042→            Some(parent) => current = parent,\n  1043→            None => break,\n  1044→        }\n  1045→    }\n  1046→\n  1047→    // Fallback to current directory if no workspace found\n  1048→    cwd\n  1049→}\n  1050→\n  1051→/// Get the default path for autopilot.db at the workspace root.\n  1052→///\n  1053→/// This ensures the database is always created in a consistent location\n  1054→/// regardless of which subdirectory the command is run from.\n  1055→pub fn default_db_path() -> PathBuf {\n  1056→    find_workspace_root().join(\"autopilot.db\")\n  1057→}\n  1058→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"timestamp":"2025-12-23T23:02:29.343984502+00:00"}