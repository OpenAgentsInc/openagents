# Plan: Port Backroom to Cloudflare Workers (D1/Axum/KV)

## Overview

Port the existing Actix-web backend from `~/code/backroom/` to Cloudflare Workers using:
- **workers-rs** with Axum HTTP compatibility
- **D1** (SQLite) for database
- **KV** for sessions (replacing Redis)
- **WGPUI** frontend served from same worker

This enables the GTM strategy: live fishbowl HUD, personal shareable HUD URLs, and <30s onboarding.

---

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Cloudflare Edge                          │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │   Worker    │  │     D1      │  │     KV      │         │
│  │  (Rust/    │──│  (SQLite)   │  │ (Sessions)  │         │
│  │   Axum)     │  └─────────────┘  └─────────────┘         │
│  └──────┬──────┘                                            │
│         │ serves                                            │
│  ┌──────┴──────┐                                            │
│  │   WGPUI     │                                            │
│  │   (WASM)    │                                            │
│  └─────────────┘                                            │
└─────────────────────────────────────────────────────────────┘
```

---

## Phase 1: Project Setup

### 1.1 Restructure `crates/web/`

```
crates/web/
├── Cargo.toml              # worker-build + axum dependencies
├── wrangler.toml           # D1, KV bindings
├── src/
│   ├── lib.rs              # Worker entry point (Axum router)
│   ├── routes/
│   │   ├── mod.rs
│   │   ├── auth.rs         # GitHub OAuth
│   │   ├── billing.rs      # Credits, plans
│   │   ├── stripe.rs       # Payment methods, webhooks
│   │   ├── account.rs      # User settings
│   │   ├── hud.rs          # Personal HUD URLs, embed
│   │   └── api.rs          # Misc API routes
│   ├── db/
│   │   ├── mod.rs
│   │   ├── users.rs
│   │   ├── sessions.rs
│   │   └── billing.rs
│   ├── middleware/
│   │   ├── mod.rs
│   │   ├── auth.rs         # Session validation
│   │   └── cors.rs
│   └── services/
│       ├── github.rs       # GitHub API client
│       └── stripe.rs       # Stripe API client
├── wasm/                   # WGPUI client build (separate)
│   └── (existing lib.rs for client-side WASM)
├── migrations/
│   └── 0001_initial.sql    # D1 schema
└── static/
    └── (HTML shell, JS bindings)
```

### 1.2 Cargo.toml Dependencies

```toml
[dependencies]
worker = { version = "0.4", features = ["http", "d1"] }
axum = { version = "0.7", default-features = false }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
uuid = { version = "1", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
hmac = "0.12"
sha2 = "0.10"
base64 = "0.21"

[lib]
crate-type = ["cdylib"]
```

### 1.3 wrangler.toml Configuration

```toml
name = "openagents-web"
main = "build/worker/shim.mjs"
compatibility_date = "2024-12-01"

[build]
command = "cargo install worker-build && worker-build --release"

[[d1_databases]]
binding = "DB"
database_name = "openagents"
database_id = "<create with wrangler d1 create>"

[[kv_namespaces]]
binding = "SESSIONS"
id = "<create with wrangler kv:namespace create>"

[vars]
GITHUB_CLIENT_ID = ""
STRIPE_PUBLISHABLE_KEY = ""

[secrets]
# Set via: wrangler secret put <NAME>
# GITHUB_CLIENT_SECRET
# STRIPE_SECRET_KEY
# STRIPE_WEBHOOK_SECRET
# SESSION_SECRET

[assets]
directory = "./dist"
```

---

## Phase 2: D1 Schema Migration

### 2.1 Schema Translation (PostgreSQL → SQLite)

Create `migrations/0001_initial.sql`:

```sql
-- Users table
CREATE TABLE users (
    user_id TEXT PRIMARY KEY,  -- UUID as TEXT
    email TEXT,
    username TEXT,
    github_id TEXT UNIQUE,
    github_username TEXT,
    github_access_token_encrypted TEXT,
    api_key_encrypted TEXT,
    billing_info_encrypted TEXT,
    handoff_token_encrypted TEXT,
    handoff_expires_at TEXT,  -- ISO8601 timestamp
    deleted_at TEXT,
    updated_at TEXT,
    signup_credits INTEGER NOT NULL DEFAULT 100000,
    purchased_credits INTEGER NOT NULL DEFAULT 0,
    credits_balance INTEGER NOT NULL DEFAULT 100000,
    payment_method_status TEXT DEFAULT 'none',
    payment_method_brand TEXT,
    payment_method_last4 TEXT,
    payment_method_added_at TEXT,
    low_balance_threshold INTEGER DEFAULT 20000,
    low_balance_warned INTEGER DEFAULT 0,  -- SQLite boolean
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX idx_users_github_id ON users(github_id);
CREATE INDEX idx_users_username ON users(username);

-- Stripe customers
CREATE TABLE stripe_customers (
    user_id TEXT PRIMARY KEY REFERENCES users(user_id),
    stripe_customer_id TEXT NOT NULL UNIQUE,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT
);

-- Stripe payment methods
CREATE TABLE stripe_payment_methods (
    stripe_payment_method_id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL REFERENCES users(user_id),
    pm_type TEXT NOT NULL,
    brand TEXT,
    last4 TEXT,
    exp_month INTEGER,
    exp_year INTEGER,
    is_default INTEGER NOT NULL DEFAULT 0,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT
);

CREATE INDEX idx_stripe_pm_user ON stripe_payment_methods(user_id);

-- Usage events (credits tracking)
CREATE TABLE usage_events (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL REFERENCES users(user_id),
    session_id TEXT,
    event_type TEXT NOT NULL,
    model TEXT,
    input_tokens INTEGER DEFAULT 0,
    output_tokens INTEGER DEFAULT 0,
    credits_used INTEGER NOT NULL DEFAULT 0,
    refunded INTEGER DEFAULT 0,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX idx_usage_user ON usage_events(user_id);
CREATE INDEX idx_usage_session ON usage_events(session_id);

-- Invoices
CREATE TABLE invoices (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL REFERENCES users(user_id),
    amount_cents INTEGER NOT NULL,
    status TEXT NOT NULL DEFAULT 'draft',
    pdf_url TEXT,
    issued_at TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);

-- Repo write access
CREATE TABLE repo_write_access (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL REFERENCES users(user_id),
    repo TEXT NOT NULL,
    scope TEXT NOT NULL DEFAULT 'write',
    granted_at TEXT NOT NULL DEFAULT (datetime('now')),
    UNIQUE(user_id, repo)
);

-- Persistent sessions (for KV backup/audit)
CREATE TABLE persistent_sessions (
    id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL REFERENCES users(user_id),
    token_hash TEXT NOT NULL UNIQUE,
    user_agent TEXT,
    ip_address TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    expires_at TEXT NOT NULL,
    last_active_at TEXT NOT NULL
);

-- HUD visibility settings (GTM requirement)
CREATE TABLE hud_settings (
    user_id TEXT PRIMARY KEY REFERENCES users(user_id),
    repo TEXT NOT NULL,
    is_public INTEGER NOT NULL DEFAULT 1,
    embed_allowed INTEGER NOT NULL DEFAULT 1,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
);

CREATE INDEX idx_hud_repo ON hud_settings(repo);
```

### 2.2 Key SQLite Differences

| PostgreSQL | SQLite (D1) |
|------------|-------------|
| UUID | TEXT (store as string) |
| TIMESTAMPTZ | TEXT (ISO8601) |
| BOOLEAN | INTEGER (0/1) |
| JSONB | TEXT (JSON string) |
| BYTEA | BLOB or TEXT (base64) |
| gen_random_uuid() | Generate in Rust |
| now() | datetime('now') |

---

## Phase 3: KV Session Layer

### 3.1 Session Structure

```rust
// src/db/sessions.rs
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
pub struct Session {
    pub user_id: String,
    pub github_oauth_state: Option<String>,
    pub created_at: String,
    pub last_active_at: String,
}

const SESSION_TTL_SECONDS: u64 = 30 * 24 * 60 * 60; // 30 days
const SESSION_COOKIE_NAME: &str = "oa_session";
```

### 3.2 Session Operations

```rust
impl Session {
    pub async fn create(kv: &KvStore, user_id: &str) -> Result<String> {
        let token = generate_secure_token(); // 32 bytes, base64
        let session = Session {
            user_id: user_id.to_string(),
            github_oauth_state: None,
            created_at: now_iso8601(),
            last_active_at: now_iso8601(),
        };

        kv.put(&format!("session:{}", token), serde_json::to_string(&session)?)
            .expiration_ttl(SESSION_TTL_SECONDS)
            .await?;

        Ok(token)
    }

    pub async fn get(kv: &KvStore, token: &str) -> Result<Option<Session>> {
        kv.get(&format!("session:{}", token))
            .json()
            .await
    }

    pub async fn delete(kv: &KvStore, token: &str) -> Result<()> {
        kv.delete(&format!("session:{}", token)).await
    }
}
```

### 3.3 Cookie Configuration

```rust
fn session_cookie(token: &str, secure: bool) -> String {
    format!(
        "{}={}; HttpOnly; SameSite=Lax; Path=/; Max-Age={}{}",
        SESSION_COOKIE_NAME,
        token,
        SESSION_TTL_SECONDS,
        if secure { "; Secure" } else { "" }
    )
}
```

---

## Phase 4: Axum Router Setup

### 4.1 Worker Entry Point

```rust
// src/lib.rs
use axum::{Router, routing::{get, post, delete}};
use worker::*;

mod routes;
mod db;
mod middleware;
mod services;

#[event(fetch)]
async fn fetch(req: HttpRequest, env: Env, _ctx: Context) -> Result<Response> {
    console_error_panic_hook::set_once();

    let router = Router::new()
        // Auth
        .route("/api/auth/github/start", get(routes::auth::github_start))
        .route("/api/auth/github/callback", get(routes::auth::github_callback))
        .route("/api/auth/logout", post(routes::auth::logout))

        // Account
        .route("/api/account", get(routes::account::get_settings))
        .route("/api/account/api-key", post(routes::account::generate_api_key))
        .route("/api/account/delete", post(routes::account::delete_account))

        // Billing
        .route("/api/billing/balance", get(routes::billing::get_balance))
        .route("/api/billing/plans", get(routes::billing::list_plans))
        .route("/api/billing/credits", get(routes::billing::list_credit_packages))
        .route("/api/billing/credits/purchase", post(routes::billing::purchase_credits))

        // Stripe
        .route("/api/stripe/config", get(routes::stripe::get_config))
        .route("/api/stripe/payment-methods", get(routes::stripe::list_payment_methods))
        .route("/api/stripe/setup-intent", post(routes::stripe::create_setup_intent))
        .route("/api/stripe/payment-methods/:id", delete(routes::stripe::delete_payment_method))
        .route("/api/stripe/payment-methods/:id/default", post(routes::stripe::set_default))
        .route("/webhooks/stripe", post(routes::stripe::webhook))

        // HUD (GTM)
        .route("/hud/:username/:repo", get(routes::hud::view_hud))
        .route("/embed/:username/:repo", get(routes::hud::embed_hud))
        .route("/api/hud/settings", post(routes::hud::update_settings))

        // Static/WGPUI
        .fallback(routes::static_handler);

    // Convert Axum to worker Response
    Ok(router.call(req).await)
}
```

---

## Phase 5: Route Implementations

### 5.1 GitHub OAuth

```rust
// src/routes/auth.rs
pub async fn github_start(
    State(env): State<Env>,
    session: Session,
) -> impl IntoResponse {
    let state = generate_oauth_state();
    session.set_github_oauth_state(&state).await?;

    let client_id = env.var("GITHUB_CLIENT_ID")?.to_string();
    let redirect_uri = "https://openagents.com/api/auth/github/callback";
    let scope = "read:user user:email read:org repo";

    let url = format!(
        "https://github.com/login/oauth/authorize?client_id={}&redirect_uri={}&state={}&scope={}",
        client_id, redirect_uri, state, scope
    );

    Redirect::temporary(&url)
}

pub async fn github_callback(
    State(env): State<Env>,
    Query(params): Query<OAuthCallback>,
    session: Session,
) -> impl IntoResponse {
    // Validate state
    let stored_state = session.github_oauth_state().await?;
    if stored_state != Some(params.state) {
        return Err(Error::InvalidOAuthState);
    }
    session.clear_github_oauth_state().await?;

    // Exchange code for token
    let token = exchange_code_for_token(&env, &params.code).await?;

    // Get user info from GitHub
    let github_user = get_github_user(&token).await?;

    // Create or update user in D1
    let db = env.d1("DB")?;
    let user = upsert_user(&db, &github_user, &token).await?;

    // Create session
    let kv = env.kv("SESSIONS")?;
    let session_token = Session::create(&kv, &user.user_id).await?;

    // Set cookie and redirect to HUD
    let cookie = session_cookie(&session_token, true);
    let redirect_url = format!("/hud/{}/{}", github_user.login, ""); // Select repo next

    Response::builder()
        .status(302)
        .header("Location", redirect_url)
        .header("Set-Cookie", cookie)
        .body(Body::empty())
}
```

### 5.2 Billing Routes

```rust
// src/routes/billing.rs
pub async fn get_balance(
    State(env): State<Env>,
    user: AuthenticatedUser,
) -> impl IntoResponse {
    let db = env.d1("DB")?;

    let row = db.prepare(
        "SELECT signup_credits, purchased_credits, credits_balance FROM users WHERE user_id = ?"
    )
    .bind(&[user.user_id.into()])?
    .first::<BalanceRow>(None)
    .await?;

    Json(BalanceResponse {
        signup_credits: row.signup_credits,
        purchased_credits: row.purchased_credits,
        total_credits: row.credits_balance,
    })
}

pub async fn purchase_credits(
    State(env): State<Env>,
    user: AuthenticatedUser,
    Json(req): Json<PurchaseRequest>,
) -> impl IntoResponse {
    let db = env.d1("DB")?;

    // Verify user has valid payment method
    let pm_status = db.prepare(
        "SELECT payment_method_status FROM users WHERE user_id = ?"
    )
    .bind(&[user.user_id.into()])?
    .first::<String>(None)
    .await?;

    if pm_status != Some("valid".to_string()) {
        return Err(Error::NoPaymentMethod);
    }

    // Process via Stripe
    let stripe_customer = get_stripe_customer(&db, &user.user_id).await?;
    charge_credits(&env, &stripe_customer, req.package_id).await?;

    // Add credits
    db.prepare(
        "UPDATE users SET purchased_credits = purchased_credits + ?,
         credits_balance = credits_balance + ? WHERE user_id = ?"
    )
    .bind(&[req.credits.into(), req.credits.into(), user.user_id.into()])?
    .run()
    .await?;

    Json(json!({ "success": true }))
}
```

### 5.3 HUD Routes (GTM)

```rust
// src/routes/hud.rs

/// Personal HUD view: /hud/@username/repo
pub async fn view_hud(
    State(env): State<Env>,
    Path((username, repo)): Path<(String, String)>,
    maybe_user: Option<AuthenticatedUser>,
) -> impl IntoResponse {
    let db = env.d1("DB")?;

    // Check if HUD is public or user is owner
    let settings = db.prepare(
        "SELECT u.user_id, h.is_public FROM users u
         LEFT JOIN hud_settings h ON u.user_id = h.user_id
         WHERE u.github_username = ? AND h.repo = ?"
    )
    .bind(&[username.into(), repo.into()])?
    .first::<HudSettingsRow>(None)
    .await?;

    let is_owner = maybe_user.as_ref().map(|u| u.user_id == settings.user_id).unwrap_or(false);
    let is_public = settings.is_public.unwrap_or(true);

    if !is_public && !is_owner {
        return Err(Error::HudPrivate);
    }

    // Serve WGPUI with HUD context
    serve_wgpui_with_context(HudContext {
        username,
        repo,
        is_owner,
        embed_mode: false,
    })
}

/// Embeddable HUD: /embed/@username/repo
pub async fn embed_hud(
    State(env): State<Env>,
    Path((username, repo)): Path<(String, String)>,
) -> impl IntoResponse {
    let db = env.d1("DB")?;

    // Check embed allowed
    let settings = db.prepare(
        "SELECT embed_allowed FROM hud_settings h
         JOIN users u ON h.user_id = u.user_id
         WHERE u.github_username = ? AND h.repo = ?"
    )
    .bind(&[username.into(), repo.into()])?
    .first::<EmbedRow>(None)
    .await?;

    if !settings.embed_allowed.unwrap_or(true) {
        return Err(Error::EmbedDisabled);
    }

    // Serve minimal WGPUI for iframe
    serve_wgpui_with_context(HudContext {
        username,
        repo,
        is_owner: false,
        embed_mode: true,
    })
}
```

---

## Phase 6: Stripe Integration

### 6.1 Setup Intent Flow

```rust
// src/routes/stripe.rs
pub async fn create_setup_intent(
    State(env): State<Env>,
    user: AuthenticatedUser,
) -> impl IntoResponse {
    let db = env.d1("DB")?;
    let stripe_secret = env.secret("STRIPE_SECRET_KEY")?.to_string();

    // Get or create Stripe customer
    let customer_id = get_or_create_stripe_customer(&db, &stripe_secret, &user).await?;

    // Create SetupIntent via Stripe API
    let response = fetch(
        "https://api.stripe.com/v1/setup_intents",
        &stripe_secret,
        json!({
            "customer": customer_id,
            "payment_method_types": ["card"],
        })
    ).await?;

    Json(json!({
        "client_secret": response.client_secret,
    }))
}
```

### 6.2 Webhook Handler

```rust
pub async fn webhook(
    State(env): State<Env>,
    headers: HeaderMap,
    body: Bytes,
) -> impl IntoResponse {
    let webhook_secret = env.secret("STRIPE_WEBHOOK_SECRET")?.to_string();
    let signature = headers.get("stripe-signature").ok_or(Error::MissingSignature)?;

    // Verify webhook signature
    verify_stripe_signature(&body, signature, &webhook_secret)?;

    let event: StripeEvent = serde_json::from_slice(&body)?;
    let db = env.d1("DB")?;

    match event.event_type.as_str() {
        "setup_intent.succeeded" => {
            let pm_id = event.data.object.payment_method;
            let customer_id = event.data.object.customer;

            // Sync payment method to D1
            sync_payment_method(&db, &env, &customer_id, &pm_id).await?;

            // Update user payment status
            update_payment_status(&db, &customer_id, "valid").await?;
        }
        "payment_intent.succeeded" => {
            // Credit purchase succeeded
            let metadata = event.data.object.metadata;
            add_purchased_credits(&db, &metadata.user_id, metadata.credits).await?;
        }
        _ => {}
    }

    Json(json!({ "received": true }))
}
```

---

## Phase 7: Auth Middleware

```rust
// src/middleware/auth.rs
use axum::{extract::FromRequestParts, http::request::Parts};

pub struct AuthenticatedUser {
    pub user_id: String,
    pub github_username: String,
}

#[async_trait]
impl<S> FromRequestParts<S> for AuthenticatedUser
where
    S: Send + Sync,
{
    type Rejection = AuthError;

    async fn from_request_parts(parts: &mut Parts, state: &S) -> Result<Self, Self::Rejection> {
        let env = parts.extensions.get::<Env>().ok_or(AuthError::Internal)?;

        // Extract session token from cookie
        let cookie = parts.headers.get("cookie").ok_or(AuthError::NoSession)?;
        let token = extract_session_token(cookie)?;

        // Validate session in KV
        let kv = env.kv("SESSIONS").map_err(|_| AuthError::Internal)?;
        let session = Session::get(&kv, &token).await?.ok_or(AuthError::InvalidSession)?;

        // Get user from D1
        let db = env.d1("DB").map_err(|_| AuthError::Internal)?;
        let user = db.prepare("SELECT user_id, github_username FROM users WHERE user_id = ?")
            .bind(&[session.user_id.into()])?
            .first::<UserRow>(None)
            .await?
            .ok_or(AuthError::UserNotFound)?;

        Ok(AuthenticatedUser {
            user_id: user.user_id,
            github_username: user.github_username,
        })
    }
}
```

---

## Phase 8: Deployment

### 8.1 Commands

```bash
# Create D1 database
wrangler d1 create openagents

# Create KV namespace
wrangler kv:namespace create SESSIONS

# Update wrangler.toml with IDs from above commands

# Run migrations
wrangler d1 migrations apply openagents

# Set secrets
wrangler secret put GITHUB_CLIENT_SECRET
wrangler secret put STRIPE_SECRET_KEY
wrangler secret put STRIPE_WEBHOOK_SECRET
wrangler secret put SESSION_SECRET

# Deploy
wrangler deploy
```

### 8.2 package.json Scripts

```json
{
  "scripts": {
    "build:wasm": "wasm-pack build --target web ./wasm",
    "build:worker": "worker-build --release",
    "build": "bun run build:wasm && bun run build:worker",
    "dev": "wrangler dev",
    "deploy": "bun run build && wrangler deploy",
    "db:migrate": "wrangler d1 migrations apply openagents"
  }
}
```

---

## Implementation Order

1. **Project scaffolding** - Restructure `crates/web/`, add dependencies
2. **D1 schema** - Create and apply migrations
3. **KV sessions** - Implement session layer
4. **Axum router** - Basic routing infrastructure
5. **Auth middleware** - Session validation extractor
6. **GitHub OAuth** - Full OAuth flow
7. **Account routes** - User settings, API keys
8. **Billing routes** - Credits, plans
9. **Stripe routes** - Payment methods, webhooks
10. **HUD routes** - Personal URLs, embeds (GTM critical)
11. **WGPUI integration** - Serve frontend with context
12. **Testing** - Local dev with `wrangler dev`
13. **Deploy** - Production deployment

---

## Critical Files to Modify/Create

| File | Action |
|------|--------|
| `crates/web/Cargo.toml` | Rewrite for workers-rs |
| `crates/web/wrangler.toml` | Add D1, KV bindings |
| `crates/web/src/lib.rs` | Axum router entry |
| `crates/web/src/routes/*.rs` | All route handlers |
| `crates/web/src/db/*.rs` | D1 query helpers |
| `crates/web/src/middleware/auth.rs` | Session validation |
| `crates/web/migrations/0001_initial.sql` | D1 schema |

---

## GTM Alignment

| GTM Requirement | Implementation |
|-----------------|----------------|
| Live Fishbowl | `/` serves WGPUI with live session context |
| Personal HUD URLs | `/hud/:username/:repo` route |
| <30s onboarding | Single OAuth click → repo select → HUD live |
| Public by default | `hud_settings.is_public` defaults to 1 |
| Embeddable | `/embed/:username/:repo` minimal iframe mode |
| Shareable URLs | Personal HUD URLs are shareable |

---

## Notes

- **No Hyperdrive** - Pure edge deployment with D1
- **UUID handling** - Generate in Rust, store as TEXT in SQLite
- **Timestamps** - ISO8601 strings, not native timestamps
- **Encryption** - HMAC for sensitive fields (tokens, API keys)
- **CORS** - Headers set in middleware for WGPUI requirements
