# Plan: Web Autopilot Backend Architecture

## Problem Statement

The web UI app shell is complete (sidebars, docks, status bar), but the center pane is empty. We need to connect it to actual autopilot functionality. The desktop autopilot has local access to the user's computer; the web version does not.

## Current Architecture

```
DESKTOP (what works today):
┌─────────────────────────────────────────────────────────────┐
│  Desktop App                                                 │
│  └── autopilot daemon (Unix socket)                         │
│      └── claude-agent-sdk                                   │
│          └── spawns Claude Code CLI (child process)         │
│              └── JSONL streaming over stdin/stdout          │
└─────────────────────────────────────────────────────────────┘

WEB (what we have):
┌─────────────────────────────────────────────────────────────┐
│  Browser (WGPUI WASM)                                       │
│  └── App shell with empty center pane                       │
│      └── HTTP requests to CF Worker                         │
│          └── Auth, repos, billing (no autopilot)            │
└─────────────────────────────────────────────────────────────┘
```

## Key Constraint

**Must be fully Rust in this codebase** - no external services, TypeScript, or separate deployments.

## Research Findings

### Cloudflare Options

1. **Cloudflare Containers** (via Durable Objects)
   - Can run Docker containers at edge
   - TCP port exposure, WebSocket support
   - Requires wrapping autopilot in HTTP server
   - Resource limits unclear, production readiness uncertain

2. **Cloudflare Sandbox**
   - Code execution sandbox at edge
   - TypeScript API only (`@cloudflare/sandbox`)
   - No Rust SDK available
   - **Not viable for pure Rust**

3. **CF Workers limitations**
   - 30-second timeout
   - No WebSocket (standard runtime)
   - Stateless request/response only

### Existing Infrastructure

- `crates/autopilot/src/claude.rs` - Claude SDK integration, streaming
- `crates/claude-agent-sdk/` - JSONL protocol, session resumption
- `crates/web-platform/src/autopilot_runner.rs` - Stubbed job queue API
- `docs/autopilot/DAEMON.md` - Unix socket daemon architecture

---

## Architectural Options

### Option A: Local Tunnel (User-Initiated Bridge)

User runs a command to connect their machine to the web UI.

```
┌─────────────────────────────────────────────────────────────┐
│  USER'S MACHINE                                              │
│  $ openagents connect                                        │
│  └── Local autopilot daemon                                 │
│      └── WebSocket tunnel to CF Worker                      │
│          └── Worker relays to browser                       │
└─────────────────────────────────────────────────────────────┘
```

**Implementation:**
1. New `crates/connect/` - tunnel client
2. CF Worker adds WebSocket relay endpoint
3. Browser connects to relay, gets routed to user's machine
4. Full autopilot runs locally with user's Claude API key

**Pros:** Full desktop access, uses existing code, user controls compute
**Cons:** Requires user action, not purely cloud

### Option B: Hosted Backend Service

New Rust service that runs autopilot remotely.

```
┌─────────────────────────────────────────────────────────────┐
│  Browser ──WebSocket──▶ CF Worker ──proxy──▶ Backend        │
│                                              │               │
│                                    ┌─────────┘               │
│                                    ▼                         │
│                         Autopilot Service (fly.io/render)   │
│                         └── claude-agent-sdk                │
│                             └── User's API key              │
└─────────────────────────────────────────────────────────────┘
```

**Implementation:**
1. New `crates/autopilot-service/` - HTTP/WebSocket API wrapping autopilot
2. Deploy separately (fly.io, render, or self-hosted)
3. CF Worker proxies WebSocket connections
4. User provides Claude API key (stored encrypted)

**Pros:** Fully cloud, no user CLI needed
**Cons:** Separate deployment, user API key handling

### Option C: Cloudflare Containers (Edge Compute)

Run autopilot in Durable Object containers.

```
┌─────────────────────────────────────────────────────────────┐
│  Browser ──▶ CF Worker ──▶ Durable Object                   │
│                            └── Container                    │
│                                └── Autopilot HTTP server   │
│                                    └── claude-agent-sdk    │
└─────────────────────────────────────────────────────────────┘
```

**Implementation:**
1. Wrap autopilot in Axum HTTP server (Dockerized)
2. Create Durable Object class that manages container lifecycle
3. Container exposes WebSocket endpoint for streaming
4. Worker routes requests to appropriate user's container

**Pros:** Serverless, scalable, all in CF ecosystem
**Cons:** Complex, needs Claude CLI in container, unclear limits

### Option D: Hybrid Demo Mode (GTM-First)

For GTM launch, show curated content; real autopilot requires Option A.

```
┌─────────────────────────────────────────────────────────────┐
│  LANDING PAGE (not logged in):                               │
│  └── Live fishbowl: Embedded view of OUR running autopilot  │
│      └── Streams from openagents.com/api/fishbowl           │
│                                                              │
│  APP SHELL (logged in):                                      │
│  └── "Connect your machine" prompt                          │
│      └── User runs `openagents connect`                     │
│          └── Real autopilot on their machine                │
└─────────────────────────────────────────────────────────────┘
```

**Implementation:**
1. Run autopilot on openagents repo continuously (our machine)
2. Stream to `/api/fishbowl` WebSocket endpoint
3. Landing page embeds this live stream
4. Logged-in users prompted to connect their machine (Option A)

**Pros:** Gets GTM live fast, shows real autopilot
**Cons:** Two-tier experience, delayed full cloud support

---

## Chosen Approach: Tunnel-First

Focus on `openagents connect` tunnel. Skip fishbowl for now.

**Authentication Strategy:** Support both options:
1. **Claude OAuth** (web-native) - User authorizes via Claude OAuth, tokens stored securely
2. **User's own API key** (CLI-native) - User provides key when running `openagents connect`

Copy OAuth patterns from `~/code/openauth`:
- Provider pattern for Claude OAuth
- Token exchange and refresh logic
- HTTP-only cookie storage for tokens
- PKCE support for SPAs

---

## Implementation Plan

### Step 0: Claude OAuth Integration

Add Claude as an OAuth provider (alongside GitHub). Copy patterns from `~/code/openauth`.

**New file:** `crates/web/worker/src/routes/claude_auth.rs`

```rust
// Claude OAuth endpoints (mirrors GitHub OAuth flow)

/// GET /api/auth/claude/start
/// Redirects to Claude authorization URL
pub async fn claude_start(req: Request, env: Env) -> Result<Response> {
    let state = generate_state_token();
    store_oauth_state(&env, &state).await?;

    let auth_url = format!(
        "https://claude.ai/oauth/authorize?client_id={}&redirect_uri={}&response_type=code&state={}&scope={}",
        env.var("CLAUDE_CLIENT_ID")?,
        urlencoding::encode(&redirect_uri),
        state,
        "openid profile"
    );

    Response::redirect(auth_url.parse()?)
}

/// GET /api/auth/claude/callback
/// Exchange code for tokens, store in session
pub async fn claude_callback(req: Request, env: Env) -> Result<Response> {
    let code = get_query_param(&req, "code")?;
    let state = get_query_param(&req, "state")?;

    verify_oauth_state(&env, &state).await?;

    // Exchange code for tokens
    let tokens = exchange_claude_code(&env, &code).await?;

    // Store tokens in session (HTTP-only cookie)
    let session = create_claude_session(&env, &tokens).await?;

    // Redirect back to app
    Response::redirect_with_cookie("/", &session_cookie(session))
}
```

**Claude OAuth endpoints:**
- `https://claude.ai/oauth/authorize` - Authorization
- `https://claude.ai/oauth/token` - Token exchange
- `https://claude.ai/oauth/userinfo` - User info (optional)

**Token storage:**
- Access token: KV with TTL matching expiry
- Refresh token: KV with longer TTL
- Link to user_id in D1

**Changes to existing auth:**
- Add `claude_access_token` and `claude_refresh_token` to session
- Add `CLAUDE_CLIENT_ID` and `CLAUDE_CLIENT_SECRET` to wrangler.toml secrets

### Step 1: WebSocket Support in CF Worker

CF Workers don't natively support WebSockets, but Durable Objects do. Add a relay Durable Object.

**File:** `crates/web/worker/src/relay.rs` (new)

```rust
#[durable_object]
pub struct TunnelRelay {
    state: State,
    env: Env,
    // Map: session_id -> (client_ws, tunnel_ws)
}

impl DurableObject for TunnelRelay {
    // Handle WebSocket upgrade for both browser and tunnel client
    // Relay messages bidirectionally
}
```

**Changes to `crates/web/worker/src/lib.rs`:**
- Add route: `GET /api/tunnel/ws/:session_id` → Durable Object
- Add route: `POST /api/tunnel/register` → Create session, return ID + auth token

### Step 2: Tunnel Client CLI

**New crate:** `crates/connect/`

```
crates/connect/
├── Cargo.toml
└── src/
    ├── main.rs         # CLI entry point
    ├── tunnel.rs       # WebSocket tunnel to relay
    ├── autopilot.rs    # Interface to local autopilot daemon
    └── auth.rs         # Session auth handling
```

**CLI interface:**
```bash
# Connect with user's own Claude API key (default)
openagents connect

# Connect using our proxy (requires credits)
openagents connect --use-credits

# Connect to specific repo
openagents connect --repo owner/repo
```

**Flow:**
1. User runs `openagents connect`
2. CLI authenticates with CF Worker (OAuth token from browser)
3. Worker creates session, returns session_id + token
4. CLI opens WebSocket to `/api/tunnel/ws/:session_id`
5. CLI starts local autopilot daemon (or connects to existing)
6. CLI relays autopilot stream ↔ WebSocket

### Step 3: Browser WebSocket Client

**File:** `crates/web/client/src/lib.rs`

Add WebSocket connection to center pane:

```rust
struct AppState {
    // ... existing ...

    // Tunnel state
    tunnel_status: TunnelStatus,  // Disconnected | Connecting | Connected
    tunnel_session_id: Option<String>,
    thread_messages: Vec<ThreadMessage>,
}

enum TunnelStatus {
    Disconnected,
    WaitingForConnect,  // Show "Run `openagents connect`" prompt
    Connecting,
    Connected,
}
```

**Center pane behavior:**
- If `TunnelStatus::Disconnected`: Show "Connect Your Machine" with CLI instructions
- If `TunnelStatus::WaitingForConnect`: Polling for tunnel connection
- If `TunnelStatus::Connected`: Render ThreadView with streaming messages

### Step 4: Message Protocol

Define protocol between browser ↔ relay ↔ tunnel client:

```rust
// Shared in crates/relay/src/protocol.rs

#[derive(Serialize, Deserialize)]
enum RelayMessage {
    // Browser → Tunnel
    StartTask { repo: String, task: String, use_credits: bool },
    CancelTask,
    SendInput { text: String },

    // Tunnel → Browser
    TunnelConnected { version: String },
    TunnelDisconnected,

    // Autopilot streaming (both directions)
    AutopilotToken(AutopilotToken),

    // Errors
    Error { code: String, message: String },
}

#[derive(Serialize, Deserialize)]
enum AutopilotToken {
    Chunk(String),
    ToolUse { name: String, params: Value },
    ToolDone { name: String, output: String, is_error: bool },
    Progress { tool_name: String, elapsed_secs: f32 },
    Usage { input_tokens: u64, output_tokens: u64, cost: f64 },
    Done(String),
}
```

### Step 5: Center Pane ThreadView

Render autopilot stream in center pane:

```rust
fn draw_center_pane(scene: &mut Scene, text: &mut TextSystem, state: &AppState, ...) {
    match state.tunnel_status {
        TunnelStatus::Disconnected | TunnelStatus::WaitingForConnect => {
            draw_connect_prompt(scene, text, ...);
        }
        TunnelStatus::Connected => {
            draw_thread_view(scene, text, &state.thread_messages, ...);
        }
    }
}

fn draw_connect_prompt(scene: &mut Scene, text: &mut TextSystem, ...) {
    // "Connect Your Machine"
    // "Run this in your terminal:"
    // `openagents connect`
    // [Copy] button
}

fn draw_thread_view(scene: &mut Scene, text: &mut TextSystem, messages: &[ThreadMessage], ...) {
    // Render messages with:
    // - Text chunks (streaming)
    // - Tool cards (collapsible)
    // - Code blocks (syntax highlighted)
    // - Progress indicators
}
```

---

## Files to Create/Modify

### New Files
| File | Purpose |
|------|---------|
| `crates/connect/Cargo.toml` | Tunnel client crate |
| `crates/connect/src/main.rs` | CLI entry point |
| `crates/connect/src/tunnel.rs` | WebSocket tunnel logic |
| `crates/relay/Cargo.toml` | Shared protocol crate |
| `crates/relay/src/protocol.rs` | Message types |
| `crates/web/worker/src/relay.rs` | Durable Object relay |
| `crates/web/worker/src/routes/claude_auth.rs` | Claude OAuth routes |
| `crates/web/worker/src/services/claude.rs` | Claude API client |

### Modified Files
| File | Changes |
|------|---------|
| `crates/web/worker/src/lib.rs` | Add tunnel routes, Claude OAuth routes, Durable Object binding |
| `crates/web/worker/src/routes/mod.rs` | Export claude_auth module |
| `crates/web/worker/Cargo.toml` | Add WebSocket deps if needed |
| `crates/web/worker/wrangler.toml` | Add CLAUDE_CLIENT_ID, Durable Object bindings |
| `crates/web/client/src/lib.rs` | WebSocket client, ThreadView, Claude OAuth button |
| `crates/cli/src/main.rs` | Add `connect` subcommand |
| `Cargo.toml` (workspace) | Add new crates |

### New API Endpoints
| Endpoint | Type | Purpose |
|----------|------|---------|
| `GET /api/auth/claude/start` | HTTP | Start Claude OAuth flow |
| `GET /api/auth/claude/callback` | HTTP | Claude OAuth callback |
| `POST /api/tunnel/register` | HTTP | Create tunnel session |
| `GET /api/tunnel/ws/:session_id` | WebSocket | Durable Object relay |
| `GET /api/tunnel/status/:session_id` | HTTP | Check if tunnel connected |

### Environment Variables / Secrets
| Name | Type | Purpose |
|------|------|---------|
| `CLAUDE_CLIENT_ID` | var | Claude OAuth client ID |
| `CLAUDE_CLIENT_SECRET` | secret | Claude OAuth client secret |

---

## Execution Order

1. **Add Claude OAuth** (`crates/web/worker/src/routes/claude_auth.rs`) - web users auth with Claude
2. **Create relay protocol crate** (`crates/relay/`) - shared message types
3. **Add Durable Object relay** (`crates/web/worker/src/relay.rs`) - WebSocket support
4. **Update worker routes** for tunnel + Claude OAuth endpoints
5. **Create connect CLI** (`crates/connect/`) - tunnel client
6. **Update web client** - WebSocket connection + ThreadView + Claude OAuth button
7. **Test end-to-end** - CLI → Worker → Browser

---

## Security Considerations

1. **Session tokens**: Generate cryptographically secure tokens for each session
2. **User authentication**: Verify user owns the session via OAuth token
3. **Rate limiting**: Limit tunnel registrations per user
4. **Message validation**: Validate all relay messages, reject malformed

---

## Future Enhancements (Not This PR)

- Live fishbowl on landing page
- Cloud compute option (CF Containers or hosted backend)
- Mobile-friendly read-only viewing
- Session persistence across browser refreshes
- Multi-session support (multiple tunnels per user)
