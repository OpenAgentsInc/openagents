Yeah, this all lines up: right now you’re trying to use the FM runner like a tiny Claude Code clone with memory, and the bridge is screaming “NOPE” every time. The micro-task supervisor doc is basically the first correct pivot: treat FM as a **single-step tool-caller** with *zero* conversational memory and let your orchestrator + TB harness do the heavy lifting.

Let me break it into:

1. What’s still fundamentally wrong with the current FM runner
2. Why the “FM Micro-Task Supervisor” doc is the right direction (with a few tweaks)
3. How I’d concretely refactor from today’s code to that architecture

---

## 1. What’s fundamentally off in the current FM runner

You’ve *already* tightened a ton of things (truncate, shorter system prompt, path normalization, context logging), but the core mismatch is still:

> You’re treating FM like a chatty agent with history; the bridge only supports tiny, stateless **function calls**.

Concretely:

### a) The `messages` loop is the enemy

In `createFMRunner.runTask` you still have:

* A multi-turn `while (turns < maxTurns)` loop.
* A `messages: [system, user, assistant, user, …]` array that grows.
* `truncateMessagesForFM()` trying to salvage that by trimming.

Even in its improved form, truncation is band-aid on the wrong wound:

* Every turn you re-encode the **entire conversation** (system + history + tool results) and send it over the FM bridge.
* The bridge has some tiny internal budget (your logs show ~200–250 chars total request) and just nopes out.

Given those logs, **no amount of clever truncation will make “chat history” viable**. The architecture has to switch to:

* **One FM call = one tiny prompt = one tool call.**
* No persistent `messages` array.
* No “assistant says X, we then append and send it back”.

### b) Tool results are way too big to ever live in the prompt

Even with condensation, you currently do:

* FM returns a full human-readable explanation + tool call markup.
* You log the assistant content.
* Then you **append the whole assistant content** to `messages` and pass back into the model (with truncation).

But FM doesn’t need any of that:

* It only needs a *summary* of what happened on previous steps (at most a sentence or two).
* The actual stdout/stderr, file contents, etc. should live in **orchestrator state**, never in FM context.

Right now, you’re trying to give it both:

* Raw tool output (hundreds of chars) *and*
* Prior conversation.

Given the 200–250 char reality, that just can’t work.

### c) Skills/memory/reflexion inside the prompt are counter-productive

You already wisely default `useSkills/useMemory/useReflection` to false for FM, but the code still has the wiring to jam that text into the system prompt.

With a microscopic context:

* Skills and reflections should mostly influence **orchestrator behaviour**, not be injected as multi-line prose.
* At most, FM sees a 1-2 line “lesson” or constraint (“Don’t touch X, just update the test in Y”).

Anything more verbose will blow the budget.

---

## 2. Thoughts on the “FM Micro-Task Supervisor” document

That doc is actually the right mental model. A few key things you nailed, plus some refinements.

### What’s very right

1. **Supervisor / Worker split**

   * Supervisor FM: decomposes a TB-style task into micro-steps (JSON list).
   * Worker FM: executes a *single* action per call, via tools.

   That fits the hard limit: planning and acting are separate, each with tiny prompts.

2. **State lives outside FM**

   * Orchestrator owns:

     * Step list, current step index, status.
     * File cache.
     * Condensed tool results.
   * FM gets only:

     * The current “Action: …”
     * A tiny bit of context (“Previous: compile failed – missing image.c”).
   * That’s exactly what we need.

3. **Aggressive condensation of tool results**

   You propose turning this:

   > Working directory …
   > Command: gcc …
   > Exit code: 1
   > STDERR: …

   Into:

   > Previous: compile failed – image.c not found

   capped at ~50 chars. That’s perfect: the FM just needs the *nature* of the failure.

4. **File access by range / chunk**

   * `read_file(path, start, end)` instead of dumping the whole file.
   * Using “named chunks” (functions/types) as the unit.

   That’s exactly how you avoid ever sending a 300-line C file back into the prompt.

5. **Path-tracing worked example**

   The step list:

   1. Read header lines from `/app/image.ppm`
   2. Write `image.c` with `read_ppm`
   3. Add `main`
   4. Compile
   5. Run and check output

   …is the right *shape* of plan: each step is doable with tiny context.

### Where I’d tweak the design

#### a) Consider: do you actually need FM as the supervisor?

The supervisor FM sees only a ~50–70 char task description and outputs a JSON list of steps.

That’s fine, but:

* For **TerminalBench**, tasks are fairly structured and limited in variety.
* You could:

  * Start with **static or heuristic planners** per TB task family.
  * Only later, once the loop is stable, explore FM-based planning.

This would:

* Avoid burning FM tokens on planning during early debugging.
* Let you iterate on the worker/orchestrator side without planning noise.

You can always keep the interface:

```ts
type Plan = { steps: string[] };
type Planner = (task: TerminalBenchTask) => Promise<Plan>;
```

And provide two implementations:

* `StaticPlanner` (hand-rolled for TB tasks).
* `FMPlanner` (what your doc describes).

#### b) One unified “worker FM” with different templates

You describe both a supervisor and a worker FM, but practically, you can just have **one FM endpoint** with two prompt templates:

* `mode: "plan"` → use the decomposition template.
* `mode: "act"` → use the action template.

The actual runner code then calls:

```ts
await fmCall({ mode: "plan", taskDescription });
await fmCall({ mode: "act", action, context, previous });
```

This keeps `createFMRunner` much simpler: it only knows “I can do a tiny planning call” and “I can do a tiny action call,” both single-turn.

#### c) Be rigid about action vocabulary

The doc already pushes in this direction, but I’d emphasize:

* Don’t let worker FM invent arbitrary English steps like “examine surrounding code more carefully”.
* Make steps/actions be from a **closed set of primitives**:

  * `READ_HEADER path`
  * `WRITE_FILE path kind=read_ppm`
  * `ADD_MAIN path`
  * `COMPILE command`
  * `RUN command`
  * `FIX_COMPILE_ERROR path errorSummary`

  And encode them as structured JSON / enums.

That way:

* The planner only emits those.
* The worker prompt can be very tight:

  * “Action: ADD_MAIN to image.c using read_ppm()”
* Orchestrator knows exactly how to route each action → tool calls.

It keeps both prompts and tool execution logic lean and predictable.

---

## 3. How I’d refactor the current FM runner toward this

Let’s talk concrete changes to `createFMRunner` / `runTask` and friends.

### Step 0: Admit defeat on multi-turn FM for TB

For the FM path, I’d *stop* trying to make it look like the Claude Code / Ollama runners.

Specifically:

* Remove / bypass:

  * `while (turns < maxTurns)` conversational loop for FM.
  * `messages` array and `truncateMessagesForFM` in the TB path.
  * Feeding tool results back in as user messages.

Instead:

* Treat FM as a **single-turn call per micro-step**.
* The TB orchestration loop lives **outside** FM.

### Step 1: Introduce an explicit micro-task layer

Create something like:

```ts
interface MicroStep {
  id: number;
  kind:
    | "READ_FILE_RANGE"
    | "WRITE_FILE"
    | "EDIT_FILE"
    | "COMPILE"
    | "RUN"
    | "FIX_COMPILE_ERROR"
    | "OTHER";
  description: string;        // short, human-readable
  params: Record<string, any>; // path, range, command, etc.
  status: "pending" | "in_progress" | "done" | "failed";
  resultSummary?: string;     // <= 50 chars
  errorSummary?: string;      // <= 50 chars
}
```

And a “plan”:

```ts
interface MicroPlan {
  steps: MicroStep[];
}
```

Now `runTask` for FM becomes roughly:

```ts
async function runTaskWithFM(task, options): Promise<TaskRunResult> {
  const plan = await planForTask(task);      // planner: static or FM
  const state = initState(plan, options.workspace);

  for (const step of plan.steps) {
    const actionPrompt = buildWorkerPrompt(step, state);
    const toolCall = await callFMWorker(actionPrompt);
    const toolResult = await executeTool(toolCall, options.workspace);
    updateStateFromTool(step, state, toolResult);
    if (stepFailedBadly) break;
  }

  return summarizeResult(state);
}
```

Notice: **no `messages` or chat history** here.

### Step 2: Implement `callFMWorker()` as a pure single-turn function

Replace the whole inner loop + truncation block with something like:

```ts
async function callFMWorker(args: {
  action: MicroStep;
  contextSummary: string;  // ≤ ~50 chars
  previousSummary: string; // ≤ ~50 chars
}): Promise<ToolCallResult> {
  const messages = [
    { role: "system", content: WORKER_SYSTEM_PROMPT }, // ~60–80 chars
    {
      role: "user",
      content: buildTinyWorkerUserMessage(args), // keep < 120 chars
    },
  ];

  const response = await Effect.runPromise(client.chat({ messages }));
  return parseToolCallsFromSingleTurn(response);
}
```

* No accumulation.
* No truncation.
* No retries for context overflow; if it overflows, the bug is in prompt template, not runtime.

You can re-use your `parseToolCalls` / `createFMToolParseError`, but now it’s seeing very small outputs.

### Step 3: Keep tool results out of the FM prompt

Instead of pushing raw tool output into messages, do:

```ts
const toolResult = await executeTool(...);
// Summarize to ≤ 50 chars:
const summary = summarizeToolResult(toolResult);

step.resultSummary = summary;
state.history.push(summary);
```

And when you build the next worker prompt:

```ts
const contextSummary = summarizeContext(state, step);   // e.g. "File image.c exists with read_ppm()"
const previousSummary = state.history.at(-1) ?? "";
```

Now the FM only ever sees **summaries**, which you can strictly cap.

### Step 4: Use the micro-planner doc as your TB “FM mode” spec

For the TB -> FM integration specifically:

* Use that “FM Micro-Task Supervisor Architecture” doc as the **FM task mode**:

  * For `path-tracing`, planner returns that exact step list.
  * For other TB tasks, define similar micro-plans.
  * Later (if desired) swap planner implementation for FM-based one; the interface stays the same.

And have `createModelRunner({ type: "foundation-models" })`:

* Detect when it’s used for TB vs some other FM use.
* Route TB through the micro-task pipeline.
* Possibly keep your old multi-turn FM runner for *non-TB*, non-coding quick tasks (where constraints are less brutal).

### Step 5: Treat skills/memory/reflexion as orchestrator hints

With this architecture, skills/memory/reflexion still matter, but mostly:

* They guide:

  * Planner: how to decompose TB tasks.
  * Orchestrator: which micro-step to try next when something fails.
* For FM itself, you can inject only the absolute minimum, like:

  * “Previous reflection: last time, we forgot to update tests.”

…which is just a sentence inside `contextSummary`, not a whole reflection blob.

---

## Big picture: what you’re actually doing here

You’re basically turning the FM bridge into:

> A **micro-tool-caller** that only ever sees:
>
> * What to do (one tiny action),
> * A sliver of local code context,
> * A two-sentence summary of what just happened.

Everything else—

* Codebase navigation
* State
* History
* Planning
* Learning

—lives in:

* TerminalBench harness
* Your orchestrator
* Skills/memory/reflexion services
* ATIF logs

Given how constrained the FM context window really is, this isn’t just a nice pattern; it’s almost the *only* way to make it code reliably.

So in short:

* The micro-task supervisor doc is the right direction.
* The main refactor is: **stop treating FM like a chat agent; treat it like a pure function from “tiny prompt → single tool call”, orchestrated by your own logic.**
* Let TB + tests + typechecker be the “global brain,” and FM just be the fingers that type one local patch at a time.
