EP212 is the point where OpenAgents moves Lightning from an impressive subsystem into a coherent product capability in the Laravel stack, anchored in `apps/openagents.com`, with behavior that is understandable in a live demo and defensible in production operations. The immediate outcome we are targeting is simple to describe but nontrivial to deliver correctly: an agent requests access to a paid endpoint, requests explicit approval before spending, pays through a user-owned Spark wallet backend, retries with L402 authorization, returns the premium payload, and leaves behind receipts that can be inspected in chat, pages, and APIs. The strategic outcome is bigger than one paid call, because EP212 is also where we align identity, policy, runtime, and observability so that paid agent behavior can scale as a platform feature rather than remain a handcrafted scenario.

The reason this epic exists in its current shape is that we now have two things converging at once. The first is the Laravel rebuild, where the canonical runtime and API surface live in `apps/openagents.com`. The second is the demand for economically meaningful agent behavior, where execution is not complete until policy is explicit, payment is auditable, and outcomes are replayable. If we only delivered a working `lightning_l402_fetch` path, we would still have a single persona with global assumptions. If we only delivered Autopilot API resources, we would have cleaner data management but no proof that the system can responsibly spend and recover value in real operations. EP212 is the first place these concerns have to work together end to end.

In practical terms, the buyer-side foundation in Laravel is already strong. Chat execution persists through threads, runs, messages, and run events. The L402 fetch and approve tools are in place. Approval is first-class rather than implied. Host allowlists and spend caps are checked before payment. Invoices are paid through configured invoice payers, with Spark wallet support as the current default. Retry authorization uses the L402 macaroon and preimage pattern, and response capture is bounded with preview and hashing so receipts stay useful without turning storage into an unbounded dump. The L402 wallet, transactions, paywalls, settlements, and deployments pages are already present, and API endpoints expose corresponding data for machine-side consumption.

The major architectural transformation still underway is autopilot scoping. Right now most Lightning state is still user-centered, but the platform direction requires autopilot-centered policy, attribution, and tool governance. That is why the Autopilot API plan introduces dedicated autopilot entities, profile and policy records, runtime bindings, and autopilot linkage propagated into the existing run pipeline. This is not schema decoration; it is the mechanism that makes statements like “this specific autopilot spent this amount under this policy version on this host” true in a verifiable way. Without that, multi-agent ownership and safety controls become brittle, especially once multiple autopilots and potentially multiple payment behaviors share one account.

The epic therefore breaks into phases that intentionally build on each other rather than parallelize into chaos. First, route and OpenAPI parity establish an honest public contract and remove stale publishing drift. Next, migrations and models make autopilot identity durable in storage. Then services and controllers turn that model into actual API resources and thread lifecycles. After that, orchestrator propagation makes sure autopilot context and actor metadata survive execution and become queryable in receipts. Contract normalization and policy enforcement then remove naming and unit drift in L402 inputs while enforcing autopilot policy at tool execution time. Tool resolver work follows so each autopilot only gets explicitly permitted tools. Finally, EP212-focused surface work ensures presets and wallet visibility are demo-legible in the same user experience that invokes the run.

Seller-side capability is the most important remaining gap if we want to claim full two-sided readiness. The app today can analyze paywalls and settlements but cannot create or mutate paywalls through API. In other words, the buyer story is substantially real while the seller lifecycle is still infra-operated through Aperture and GCP runbooks. That is acceptable for current operation but incomplete for a platform narrative where agents can both consume and publish paid resources. The epic addresses this with dedicated work for paywall lifecycle APIs, safe Aperture orchestration, and constrained seller tools that emit deployment receipts. This is where we convert “we can read paywall outcomes” into “we can deliberately manage paywall lifecycle through controlled product interfaces.”

What we intend to have ready to show for EP212 is a full sequence that does not rely on hidden operator intervention during the performance. A user asks for a paid fetch with a strict cap, receives an approval request, approves the payment, gets a successful protected response, sees proof and payment references, and can inspect correlated records in L402 pages and APIs. Repeating the request can demonstrate cache behavior, while an over-cap or disallowed-host request demonstrates pre-payment policy denial rather than post-failure confusion. If we include optional API callouts during the demo, we can show that the same underlying state is available programmatically, proving the behavior is an API-backed system capability and not a UI-only illusion.

Observability is part of the product, not just engineering hygiene. EP212 requires that intent, approval, quote, payment, cache status, deny reason, and execution identity be reconstructable from durable events. In this design, run events are the canonical receipt ledger, and pages or API summaries are derived views over that ledger. This discipline gives us a strict standard for correctness: chat and pages should never disagree about what happened, policy claims should be traceable to config state, and payment outcomes should always include enough metadata to explain why a spend occurred or why it was blocked. The epic’s data propagation and filtering tasks exist precisely to keep that standard enforceable once multiple autopilots and seller flows are active.

OpenAPI parity and deployment discipline are equally central because this capability must be trusted by both internal operators and external API consumers. A stale or inaccurate spec undermines everything else, especially when we are introducing new autopilot-scoped routes and L402 contract normalization. That is why spec generation, published parity checks, route coverage tests, and release gates are part of the plan rather than afterthoughts. EP212 is supposed to demonstrate a platform maturing, and platform maturity includes contract integrity, not just successful payment screenshots.

By the end of this epic, the expected result is a single coherent system where Autopilot identity, payment policy, tool exposure, chat execution, and Lightning receipts all align under the Laravel runtime. We should be able to show a credible buyer demo immediately, show the API surfaces that back it, and show a clear near-term path to seller lifecycle automation in the same stack. That is the meaning of EP212 MVP in this context: not merely that a paid request can succeed once, but that paid agent behavior is explicit, governable, attributable, replayable, and extensible across both product and operations.
