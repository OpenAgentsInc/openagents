## Programmatic Usage and Rate Limits

This guide shows how to retrieve usage information programmatically from Codex:

- Per‑turn token usage via the CLI (`codex exec --json`).
- Account rate‑limit snapshots (daily/weekly/monthly windows) via the App Server JSON‑RPC.

Use these to power dashboards or to display weekly/daily usage in a separate CLI.

---

### Per‑turn token usage (CLI)

`codex exec` supports a JSON mode that streams events as JSON Lines (JSONL). The final `turn.completed` event contains the token usage for the turn.

Example:

```sh
codex exec --json "Summarize this repository"
```

You will see a stream of events; the usage arrives at the end:

```jsonl
{"type":"turn.completed","usage":{"input_tokens":24763,"cached_input_tokens":24448,"output_tokens":122}}
```

Usage object shape:

- `input_tokens` number — total input tokens for the turn
- `cached_input_tokens` number — portion of `input_tokens` served from cache
- `output_tokens` number — tokens generated by the model in the turn

Notes:

- The JSON event format and fields are stable and mirrored in the TypeScript SDK (`Usage` in `sdk/typescript/src/events.ts`) and Rust exec events (`codex-rs/exec/src/exec_events.rs`).
- If you only need the final assistant message and usage, read stdout for `turn.completed` and parse the `usage` object.

---

### Account rate limits (daily/weekly)

Codex exposes current account rate‑limit windows via the App Server using JSON‑RPC over stdio. This returns a snapshot with primary and secondary rolling windows that you can present as “daily”, “weekly”, etc.

Primary and secondary windows:

- `primary` — the shorter window (e.g., hours or a day)
- `secondary` — the longer window (e.g., weekly or monthly)

The exact duration comes from `window_minutes` and should be labeled by duration, not by a hardcoded name. Internally, the TUI maps windows like:

- ≤ 1 day → display as hours (e.g., `24h`)
- ≤ 1 week → `weekly`
- ≤ 1 month → `monthly`
- > 1 month → `annual`

#### Quick CLI example

You can query the App Server directly from a shell by piping a JSON‑RPC request into `codex app-server`:

```sh
echo '{"id":1,"method":"account/rateLimits/read"}' | codex app-server
```

Expected response (shape):

```json
{
  "id": 1,
  "result": {
    "rateLimits": {
      "primary": {
        "used_percent": 63.0,
        "window_minutes": 300,
        "resets_at": 1732579200
      },
      "secondary": {
        "used_percent": 12.5,
        "window_minutes": 10080,
        "resets_at": 1733000000
      }
    }
  }
}
```

Response fields:

- `rateLimits.primary|secondary` object or null when unavailable
  - `used_percent` number — percentage [0–100] consumed in the window
  - `window_minutes` number|null — rolling window size in minutes
  - `resets_at` number|null — UNIX timestamp (seconds) when the window resets

Authentication/requirements:

- Rate‑limit data is available when logged in with ChatGPT account auth (the same auth Codex uses). If unauthenticated or not using a supported provider, the server returns an error or `null` windows.

#### Programmatic invocation (Node.js)

Minimal example that spawns the App Server, sends a request, and parses the result:

```js
import { spawn } from 'node:child_process';

function getRateLimits() {
  return new Promise((resolve, reject) => {
    const proc = spawn('codex', ['app-server']);
    const req = JSON.stringify({ id: 1, method: 'account/rateLimits/read' }) + '\n';

    let buf = '';
    proc.stdout.on('data', (chunk) => { buf += chunk.toString('utf8'); });
    proc.stderr.on('data', (chunk) => { /* optional: log */ });
    proc.on('error', reject);

    proc.stdin.write(req);

    proc.stdout.on('end', () => {
      // The server stays running; in a one‑shot flow you can parse the first line and then kill it.
    });

    proc.stdout.on('data', () => {
      // Parse the first complete line and exit.
      const line = buf.split('\n')[0];
      try {
        const msg = JSON.parse(line);
        if (msg && msg.result && msg.result.rateLimits) {
          resolve(msg.result.rateLimits);
          proc.kill();
        }
      } catch (_) {}
    });
  });
}

getRateLimits().then(console.log).catch(console.error);
```

Interpretation tips:

- Weekly usage: `secondary.window_minutes` is typically `7 * 24 * 60 = 10080`. Label as “weekly”.
- Daily/5‑hour usage: `primary.window_minutes` may be `24 * 60 = 1440` (label `24h`) or another shorter horizon (e.g., `300` → `5h`).
- Reset times: convert `resets_at` (UNIX seconds) to local time for display and compute countdowns.

---

### TypeScript SDK equivalents

If you prefer a library interface, the TypeScript SDK exposes the same structures:

- Per‑turn usage: the `run()` and `runStreamed()` helpers yield/return `Usage` with `input_tokens`, `cached_input_tokens`, and `output_tokens`.
  - See `sdk/typescript/src/events.ts` and `sdk/typescript/src/thread.ts`.

---

### Reference types (Rust)

- Token usage event: `codex-rs/exec/src/exec_events.rs` → `TurnCompletedEvent { usage }` and `Usage`.
- App Server request: method `account/rateLimits/read` → result `GetAccountRateLimitsResponse { rate_limits }` in `codex-rs/app-server-protocol/src/protocol.rs`.
- Rate‑limit snapshot payload: `RateLimitSnapshot` and `RateLimitWindow` in `codex-rs/protocol/src/protocol.rs`.

