import React, { createContext, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react'
import { useBridge } from './ws'
import { useThreadProviders } from '@/lib/thread-provider-store'
import { createPerKeyThrottle, createPerKeyDebounce } from '@/utils/throttle'
// Types generated by bridge (ts-rs). These use bigint for i64; define number-compatible shims below.
import type { ThreadSummaryTs as ThreadRowBase } from '../types/bridge/ThreadSummaryTs'
import type { MessageRowTs as MessageRowBase } from '../types/bridge/MessageRowTs'
import type { ToolCallRowTs as ToolCallRowBase } from '../types/bridge/ToolCallRowTs'

// Tunables for provider behavior. Keep these conservative to avoid WS bursts.
const MSG_QUERY_THROTTLE_MS = 350 // per-thread throttle window for messages.list
const THREADS_REFRESH_DEBOUNCE_MS = 400 // debounce for threads.list refresh on updates
const PREFETCH_TOP_THREADS = 10 // number of recent threads to warm on connect
const DEFAULT_THREAD_TAIL = 50 // number of most recent messages to fetch per thread

// Number-compatible shims for bigint fields from ts-rs exports
export type ThreadRow = Omit<ThreadRowBase, 'created_at'|'updated_at'|'last_message_ts'|'message_count'> & {
  created_at: number
  updated_at: number
  last_message_ts: number | null
  message_count?: number | null
}
export type MessageRow = Omit<MessageRowBase, 'id'|'partial'|'seq'|'ts'|'created_at'|'updated_at'> & {
  id: number
  partial: number | null
  seq: number | null
  ts: number
  created_at: number
  updated_at: number | null
}
export type ToolCallRow = Omit<ToolCallRowBase, 'created_at'|'updated_at'> & {
  created_at: number
  updated_at: number
}

// WS envelope typings (subset used by this provider)
type TvxSnapshotThreads = { type: 'tinyvex.snapshot'; stream: 'threads'; rows: ThreadRow[]; rev: number }
type TvxSnapshotMessages = { type: 'tinyvex.snapshot'; stream: 'messages'; thread_id: string; rows: MessageRow[]; rev: number }
type TvxQueryThreads = { type: 'tinyvex.query_result'; name: 'threads.list'; rows: ThreadRow[] }
type TvxQueryMessages = { type: 'tinyvex.query_result'; name: 'messages.list'; thread_id: string; rows: MessageRow[] }
type TvxQueryToolCalls = { type: 'tinyvex.query_result'; name: 'toolCalls.list'; thread_id: string; rows: ToolCallRow[] }
type TvxQueryThreadsAndTails = { type: 'tinyvex.query_result'; name: 'threadsAndTails.list'; threads: ThreadRow[]; tails: { thread_id: string; rows: MessageRow[] }[] }
type TvxUpdateMessages = { type: 'tinyvex.update'; stream: 'messages'; thread_id: string }
type TvxUpdateThreadsRow = { type: 'tinyvex.update'; stream: 'threads'; row?: Partial<ThreadRow> & { id?: string; thread_id?: string } }
type TvxUpdateToolCalls = { type: 'tinyvex.update'; stream: 'toolCalls'; thread_id: string }
type TvxUpdatePlan = { type: 'tinyvex.update'; stream: 'plan'; thread_id: string }
type TvxUpdateState = { type: 'tinyvex.update'; stream: 'state'; thread_id: string }

export type TinyvexContextValue = {
  threads: ThreadRow[];
  messagesByThread: Record<string, MessageRow[]>;
  toolCallsByThread: Record<string, ToolCallRow[]>;
  planTouched: Record<string, number>;
  stateTouched: Record<string, number>;
  subscribeThreads: () => void;
  subscribeMessages: (threadId: string) => void;
  queryThreads: (limit?: number) => void;
  queryMessages: (threadId: string, limit?: number) => void;
  queryToolCalls: (threadId: string, limit?: number) => void;
}

const TinyvexContext = createContext<TinyvexContextValue | undefined>(undefined)

/**
 * TinyvexProvider
 *
 * Centralizes Tinyvex bootstrap and live update handling:
 * - On WS connect, subscribe to `threads` and fetch an initial list.
 * - Prefetch a bounded number of message tails for top threads.
 * - Throttle per-thread `messages.list` re-queries when `tinyvex.update` fires
 *   during streaming to avoid flooding the bridge.
 * - Debounce `threads.list` refresh after `tinyvex.update(stream:"threads")`.
 */
export function TinyvexProvider({ children }: { children: React.ReactNode }) {
  const bridge = useBridge();
  const connected = bridge.connected;
  const [threads, setThreads] = useState<ThreadRow[]>([])
  const [messagesByThread, setMessagesByThread] = useState<Record<string, MessageRow[]>>({})
  const [toolCallsByThread, setToolCallsByThread] = useState<Record<string, ToolCallRow[]>>({})
  const [planTouched, setPlanTouched] = useState<Record<string, number>>({})
  const [stateTouched, setStateTouched] = useState<Record<string, number>>({})
  // Latest threads in a ref to avoid recreating callbacks; used for stable lookups
  const threadsRef = useRef<ThreadRow[]>(threads)
  useEffect(() => { threadsRef.current = threads }, [threads])

  // Helpers to resolve aliasing between a client thread doc id and the
  // canonical session id (resume_id). When the bridge restarts before the
  // alias map is re-established, the watcher may mirror only to the session id.
  // We compensate on the client by querying canonical ids and storing results
  // under the client doc key as well.
  const getResumeForId = useCallback((tid: string): string | null => {
    try {
      const list = Array.isArray(threadsRef.current) ? threadsRef.current : []
      const row = list.find((r) => String(r.id) === String(tid))
      const rid = row?.resume_id ?? null
      return rid ? String(rid) : null
    } catch { return null }
  }, [])
  const getAliasForCanonical = useCallback((canonicalId: string): string | null => {
    try {
      const list = Array.isArray(threadsRef.current) ? threadsRef.current : []
      const row = list.find((r) => String(r.resume_id ?? '') === String(canonicalId))
      return row ? String(row.id) : null
    } catch { return null }
  }, [])

  // Handle incoming bridge events. We only parse JSON objects and ignore
  // plaintext rows for safety/perf. This function mutates provider state and
  // may schedule follow-up queries via throttled/debounced helpers.
  const onMessage = useCallback((raw: string) => {
    if (!raw || raw[0] !== '{') return;
    let obj: unknown; try { obj = JSON.parse(raw) } catch { return }
    const ot = (obj as any)?.type as string | undefined
    if (ot === 'tinyvex.snapshot') {
      const s = obj as TvxSnapshotThreads | TvxSnapshotMessages
      if (s.stream === 'threads') {
        setThreads(s.rows)
        try {
          const setProvider = useThreadProviders.getState().setProvider
          for (const r of s.rows) {
            const tid = String(r.id)
            const src = String(r.source ?? '')
            if (tid) setProvider(tid, src === 'claude_code' ? 'claude_code' : 'codex')
          }
        } catch {}
      } else if (s.stream === 'messages') {
        setMessagesByThread((prev) => ({ ...prev, [s.thread_id]: s.rows }))
        try {
          const alias = getAliasForCanonical(String(s.thread_id))
          if (alias && alias !== s.thread_id) {
            setMessagesByThread((prev) => ({ ...prev, [alias]: s.rows }))
          }
        } catch {}
      }
    } else if (ot === 'tinyvex.update') {
      const u = obj as TvxUpdateMessages | TvxUpdateThreadsRow | TvxUpdateToolCalls | TvxUpdatePlan | TvxUpdateState
      if (u.stream === 'messages' && typeof (u as TvxUpdateMessages).thread_id === 'string') {
        // Live message writes can emit many updates while streaming.
        // Throttle per thread to avoid storms during streaming.
        try { scheduleMsgQuery((u as TvxUpdateMessages).thread_id) } catch {}
        // Also schedule a query for the canonical id if this was the client doc id,
        // or vice-versa schedule for the alias if we received a canonical update.
        try {
          const tid = String((u as TvxUpdateMessages).thread_id)
          const resume = getResumeForId(tid)
          if (resume && resume !== tid) { scheduleMsgQuery(resume) }
          const alias = getAliasForCanonical(tid)
          if (alias && alias !== tid) { scheduleMsgQuery(alias) }
        } catch {}
      } else if (u.stream === 'threads') {
        // Prefer merging the provided row to avoid a full refresh
        const row = (u as TvxUpdateThreadsRow).row
        if (row && typeof row === 'object') {
          setThreads((prev) => {
            const tid = String(((row as any)?.id || (row as any)?.thread_id || ''))
            if (!tid) return prev
            const next = Array.isArray(prev) ? [...prev] : []
            const idx = next.findIndex((r: any) => String(((r as any)?.id || (r as any)?.thread_id || '')) === tid)
            if (idx >= 0) next.splice(idx, 1)
            next.unshift(row as ThreadRow)
            return next
          })
          try {
            const setProvider = useThreadProviders.getState().setProvider
            const tid = String(((row as any)?.id || (row as any)?.thread_id || ''))
            const src = String(((row as any)?.source || ''))
            if (tid) setProvider(tid, src === 'claude_code' ? 'claude_code' : 'codex')
          } catch {}
        } else {
          // Fallback: Debounce refreshes to avoid repeated full refreshes on bursts.
          try { scheduleThreadsRefresh() } catch {}
        }
      } else if (u.stream === 'toolCalls' && typeof (u as TvxUpdateToolCalls).thread_id === 'string') {
        try { scheduleToolQuery((u as TvxUpdateToolCalls).thread_id) } catch {}
      } else if (u.stream === 'plan' && typeof (u as TvxUpdatePlan).thread_id === 'string') {
        const tid: string = (u as TvxUpdatePlan).thread_id
        setPlanTouched((prev) => ({ ...prev, [tid]: Date.now() }))
      } else if (u.stream === 'state' && typeof (u as TvxUpdateState).thread_id === 'string') {
        const tid: string = (u as TvxUpdateState).thread_id
        setStateTouched((prev) => ({ ...prev, [tid]: Date.now() }))
      }
    } else if (ot === 'tinyvex.query_result') {
      const q = obj as TvxQueryThreads | TvxQueryMessages | TvxQueryToolCalls | TvxQueryThreadsAndTails
      if (q.name === 'threads.list') {
        setThreads(q.rows)
        try {
          const setProvider = useThreadProviders.getState().setProvider
          for (const r of q.rows) {
            const tid = String(r.id)
            const src = String(r.source ?? '')
            if (tid) setProvider(tid, src === 'claude_code' ? 'claude_code' : 'codex')
          }
        } catch {}
      } else if (q.name === 'messages.list') {
        setMessagesByThread((prev) => ({ ...prev, [q.thread_id]: q.rows }))
        // If these rows correspond to a canonical session id, also project them onto the
        // client doc id so thread screens keyed by that id hydrate immediately.
        try {
          const alias = getAliasForCanonical(String(q.thread_id))
          if (alias && alias !== q.thread_id) {
            setMessagesByThread((prev) => ({ ...prev, [alias]: q.rows }))
          }
        } catch {}
      } else if (q.name === 'toolCalls.list') {
        setToolCallsByThread((prev) => ({ ...prev, [q.thread_id]: q.rows }))
        // Also project onto the client doc id if this thread_id is canonical
        try {
          const alias = getAliasForCanonical(String(q.thread_id))
          if (alias && alias !== q.thread_id) {
            setToolCallsByThread((prev) => ({ ...prev, [alias]: q.rows }))
          }
        } catch {}
      } else if (q.name === 'threadsAndTails.list') {
        // cancel fallback to threads.list if pending
        try {
          if (bootstrapPendingRef.current) {
            bootstrapPendingRef.current = false
            const id = fallbackTimerRef.current
            if (id != null) { clearTimeout(id as unknown as number); fallbackTimerRef.current = null as unknown as number | null }
          }
        } catch {}
        const threadsRows = q.threads
        const tails = q.tails
        // Build a complete list of threads from rows + tails. If Tinyvex DB is cold
        // after a bridge restart, tails may include additional threads that are not
        // yet in `threadsRows`. Synthesize minimal entries for them so the drawer
        // shows full history immediately.
        const known = new Set<string>()
        const nextThreads: ThreadRow[] = []
        for (const r of threadsRows) {
          const tid = String(r.id)
          if (!tid) continue
          known.add(tid)
          nextThreads.push(r)
        }
        for (const t of tails) {
          const tid = String((t?.thread_id) || '')
          if (!tid || known.has(tid)) continue
          const rows = Array.isArray(t?.rows) ? (t.rows as MessageRow[]) : []
          const ts = (() => {
            try {
              if (!rows.length) return 0
              const last = rows[rows.length - 1]
              return Number(last.ts || 0)
            } catch { return 0 }
          })()
          nextThreads.push({
            id: tid,
            thread_id: tid,
            title: 'Thread',
            project_id: null,
            resume_id: null,
            rollout_path: null,
            source: 'codex',
            created_at: ts || Date.now(),
            updated_at: ts || Date.now(),
            message_count: rows.length,
            last_message_ts: ts || Date.now(),
          } as ThreadRow)
        }
        setThreads(nextThreads)
        try {
          const setProvider = useThreadProviders.getState().setProvider
          for (const r of nextThreads) {
            const tid = String((r as any)?.id || (r as any)?.thread_id || '')
            const src = String((r as any)?.source || '')
            if (tid) setProvider(tid, src === 'claude_code' ? 'claude_code' : 'codex')
          }
        } catch {}
        
        setMessagesByThread((prev) => {
          const next = { ...prev }
          for (const t of tails) {
            const tid = String((t?.thread_id) || '')
            const rows = Array.isArray(t?.rows) ? (t.rows as MessageRow[]) : []
            if (tid && rows.length) next[tid] = rows
          }
          return next
        })
      }
    }
  }, [getAliasForCanonical, getResumeForId])

  useEffect(() => bridge.addSubscriber(onMessage), [bridge, onMessage])

  // Throttlers and debouncers used for follow-up queries
  // Use stable `send` from bridge to keep these throttles persistent across renders
  const stableSend = bridge.send
  const scheduleMsgQuery = useMemo(() => {
    const throttle = createPerKeyThrottle(MSG_QUERY_THROTTLE_MS)
    return (threadId: string) => throttle(threadId, () => {
      try { stableSend(JSON.stringify({ control: 'tvx.query', name: 'messages.list', args: { thread_id: threadId, limit: DEFAULT_THREAD_TAIL } })) } catch {}
    })
  }, [stableSend])
  const scheduleThreadsRefresh = useMemo(() => {
    const debounce = createPerKeyDebounce(THREADS_REFRESH_DEBOUNCE_MS)
    return () => debounce('threads', () => {
      try { stableSend(JSON.stringify({ control: 'tvx.query', name: 'threads.list', args: { limit: 50 } })) } catch {}
    })
  }, [stableSend])
  const scheduleToolQuery = useMemo(() => {
    const throttle = createPerKeyThrottle(MSG_QUERY_THROTTLE_MS)
    return (threadId: string) => throttle(`tool-${threadId}`, () => {
      try { stableSend(JSON.stringify({ control: 'tvx.query', name: 'toolCalls.list', args: { thread_id: threadId, limit: 50 } })) } catch {}
    })
  }, [stableSend])

  // Auto-subscribe and fetch when the bridge connects
  useEffect(() => {
    if (!connected) return;
    // Single bootstrap: subscribe + list
    try { bridge.send(JSON.stringify({ control: 'tvx.subscribe', stream: 'threads' })) } catch {}
    try {
      bootstrapPendingRef.current = true
      bridge.send(JSON.stringify({ control: 'tvx.query', name: 'threadsAndTails.list', args: { limit: 50, perThreadTail: DEFAULT_THREAD_TAIL } }))
      const timer = setTimeout(() => {
        try {
          if (bootstrapPendingRef.current) {
            bridge.send(JSON.stringify({ control: 'tvx.query', name: 'threads.list', args: { limit: 50 } }))
            bootstrapPendingRef.current = false
          }
        } catch {}
      }, 1200)
      fallbackTimerRef.current = timer as any
    } catch {}
  }, [connected])

  // Prefetch messages for known threads so history opens instantly
  const prefetchRef = useRef<Set<string>>(new Set())
  // Track aggregated bootstrap status and fallback timer
  const bootstrapPendingRef = useRef<boolean>(false)
  const fallbackTimerRef = useRef<number | null>(null)
  useEffect(() => {
    if (!connected) return
    try {
      const seen = prefetchRef.current
      const arr = Array.isArray(threads) ? threads : []
      // Prefetch a bounded recent set (reduce connect burst). We keep
      // a `seen` set to avoid re-subscribing while the provider lives.
      const copy = arr.slice().sort((a, b) => {
        const at = Number((a as ThreadRow).updated_at ?? (a as ThreadRow).created_at ?? 0)
        const bt = Number((b as ThreadRow).updated_at ?? (b as ThreadRow).created_at ?? 0)
        return bt - at
      }).slice(0, PREFETCH_TOP_THREADS)
      for (const r of copy) {
        const tid = String((r as ThreadRow).id || '')
        if (!tid || seen.has(tid)) continue
    try { bridge.send(JSON.stringify({ control: 'tvx.subscribe', stream: 'messages', thread_id: tid })) } catch {}
        try { scheduleMsgQuery(tid) } catch {}
        seen.add(tid)
      }
    } catch {}
  }, [threads, connected])

  const subscribeThreads = useCallback(() => {
    stableSend(JSON.stringify({ control: 'tvx.subscribe', stream: 'threads' }))
  }, [stableSend])
  // Track which threads we've subscribed to for idempotency
  const subscribedThreadsRef = useRef<Set<string>>(new Set())
  const subscribeMessages = useCallback((threadId: string) => {
    const trySub = (tid: string) => {
      if (!tid) return
      const set = subscribedThreadsRef.current
      if (set.has(tid)) return
      set.add(tid)
      try { stableSend(JSON.stringify({ control: 'tvx.subscribe', stream: 'messages', thread_id: tid })) } catch {}
    }
    trySub(threadId)
    try {
      const canonical = getResumeForId(threadId)
      if (canonical && canonical !== threadId) trySub(canonical)
    } catch {}
  }, [stableSend, getResumeForId])
  const queryThreads = useCallback((limit: number = 50) => {
    stableSend(JSON.stringify({ control: 'tvx.query', name: 'threads.list', args: { limit } }))
  }, [stableSend])
  const queryMessages = useCallback((threadId: string, limit: number = DEFAULT_THREAD_TAIL) => {
    try { stableSend(JSON.stringify({ control: 'tvx.query', name: 'messages.list', args: { thread_id: threadId, limit } })) } catch {}
    try {
      const canonical = getResumeForId(threadId)
      if (canonical && canonical !== threadId) {
        stableSend(JSON.stringify({ control: 'tvx.query', name: 'messages.list', args: { thread_id: canonical, limit } }))
      }
    } catch {}
  }, [stableSend, getResumeForId])
  const queryToolCalls = useCallback((threadId: string, limit: number = 50) => {
    try { stableSend(JSON.stringify({ control: 'tvx.query', name: 'toolCalls.list', args: { thread_id: threadId, limit } })) } catch {}
    try {
      const canonical = getResumeForId(threadId)
      if (canonical && canonical !== threadId) {
        stableSend(JSON.stringify({ control: 'tvx.query', name: 'toolCalls.list', args: { thread_id: canonical, limit } }))
      }
    } catch {}
  }, [stableSend, getResumeForId])

  // On reconnect, re-subscribe to any message streams we previously subscribed to.
  useEffect(() => {
    if (!connected) return
    try {
      const set = subscribedThreadsRef.current
      for (const tid of Array.from(set)) {
        try { stableSend(JSON.stringify({ control: 'tvx.subscribe', stream: 'messages', thread_id: tid })) } catch {}
      }
    } catch {}
  }, [connected, stableSend])

  const value = useMemo(() => ({ threads, messagesByThread, subscribeThreads, subscribeMessages, queryThreads, queryMessages, queryToolCalls }), [threads, messagesByThread, subscribeThreads, subscribeMessages, queryThreads, queryMessages, queryToolCalls])
  const ctxValue = useMemo(() => ({
    threads,
    messagesByThread,
    toolCallsByThread,
    planTouched,
    stateTouched,
    subscribeThreads,
    subscribeMessages,
    queryThreads,
    queryMessages,
    queryToolCalls,
  }), [threads, messagesByThread, toolCallsByThread, planTouched, stateTouched, subscribeThreads, subscribeMessages, queryThreads, queryMessages, queryToolCalls])
  return <TinyvexContext.Provider value={ctxValue}>{children}</TinyvexContext.Provider>
}

export function useTinyvex() {
  const ctx = useContext(TinyvexContext)
  if (!ctx) throw new Error('useTinyvex must be used within TinyvexProvider')
  return ctx
}
