import React, { createContext, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react'
import { useBridge } from './ws'
import { useThreadProviders } from '@/lib/thread-provider-store'
import { createPerKeyThrottle, createPerKeyDebounce } from '@/utils/throttle'
// Types generated by bridge (ts-rs). These use bigint for i64; define number-compatible shims below.
import type { ThreadSummaryTs as ThreadRowBase } from '../types/bridge/ThreadSummaryTs'
import type { MessageRowTs as MessageRowBase } from '../types/bridge/MessageRowTs'
import type { ToolCallRowTs as ToolCallRowBase } from '../types/bridge/ToolCallRowTs'

// Tunables for provider behavior. Keep these conservative to avoid WS bursts.
const MSG_QUERY_THROTTLE_MS = 350 // per-thread throttle window for messages.list
const THREADS_REFRESH_DEBOUNCE_MS = 400 // debounce for threads.list refresh on updates
const PREFETCH_TOP_THREADS = 10 // number of recent threads to warm on connect
const DEFAULT_THREAD_TAIL = 50 // number of most recent messages to fetch per thread

// Number-compatible shims for bigint fields from ts-rs exports
export type ThreadRow = Omit<ThreadRowBase, 'created_at'|'updated_at'|'last_message_ts'|'message_count'> & {
  created_at: number
  updated_at: number
  last_message_ts: number | null
  message_count?: number | null
}
export type MessageRow = Omit<MessageRowBase, 'id'|'partial'|'seq'|'ts'|'created_at'|'updated_at'> & {
  id: number
  partial: number | null
  seq: number | null
  ts: number
  created_at: number
  updated_at: number | null
}
export type ToolCallRow = Omit<ToolCallRowBase, 'created_at'|'updated_at'> & {
  created_at: number
  updated_at: number
}

// WS envelope typings (subset used by this provider)
type TvxSnapshotThreads = { type: 'tinyvex.snapshot'; stream: 'threads'; rows: ThreadRow[]; rev: number }
type TvxSnapshotMessages = { type: 'tinyvex.snapshot'; stream: 'messages'; thread_id: string; rows: MessageRow[]; rev: number }
type TvxQueryThreads = { type: 'tinyvex.query_result'; name: 'threads.list'; rows: ThreadRow[] }
type TvxQueryMessages = { type: 'tinyvex.query_result'; name: 'messages.list'; thread_id: string; rows: MessageRow[] }
type TvxQueryToolCalls = { type: 'tinyvex.query_result'; name: 'toolCalls.list'; thread_id: string; rows: ToolCallRow[] }
type TvxQueryThreadsAndTails = { type: 'tinyvex.query_result'; name: 'threadsAndTails.list'; threads: ThreadRow[]; tails: { thread_id: string; rows: MessageRow[] }[] }
type TvxUpdateMessages = { type: 'tinyvex.update'; stream: 'messages'; thread_id: string }
type TvxUpdateThreadsRow = { type: 'tinyvex.update'; stream: 'threads'; row?: Partial<ThreadRow> & { id?: string; thread_id?: string } }
type TvxUpdateToolCalls = { type: 'tinyvex.update'; stream: 'toolCalls'; thread_id: string }
type TvxUpdatePlan = { type: 'tinyvex.update'; stream: 'plan'; thread_id: string }
type TvxUpdateState = { type: 'tinyvex.update'; stream: 'state'; thread_id: string }

// Discriminated unions for all possible envelope types
type TvxSnapshot = TvxSnapshotThreads | TvxSnapshotMessages
type TvxQuery = TvxQueryThreads | TvxQueryMessages | TvxQueryToolCalls | TvxQueryThreadsAndTails
type TvxUpdate = TvxUpdateMessages | TvxUpdateThreadsRow | TvxUpdateToolCalls | TvxUpdatePlan | TvxUpdateState
type TvxEnvelope = TvxSnapshot | TvxQuery | TvxUpdate

// Type guards for envelope discrimination
function isTvxSnapshot(obj: unknown): obj is TvxSnapshot {
  return typeof obj === 'object' && obj !== null && 'type' in obj && obj.type === 'tinyvex.snapshot' && 'stream' in obj
}

function isTvxSnapshotThreads(obj: unknown): obj is TvxSnapshotThreads {
  return isTvxSnapshot(obj) && obj.stream === 'threads' && 'rows' in obj
}

function isTvxSnapshotMessages(obj: unknown): obj is TvxSnapshotMessages {
  return isTvxSnapshot(obj) && obj.stream === 'messages' && 'thread_id' in obj && 'rows' in obj
}

function isTvxUpdate(obj: unknown): obj is TvxUpdate {
  return typeof obj === 'object' && obj !== null && 'type' in obj && obj.type === 'tinyvex.update' && 'stream' in obj
}

function isTvxUpdateMessages(obj: unknown): obj is TvxUpdateMessages {
  return isTvxUpdate(obj) && obj.stream === 'messages' && 'thread_id' in obj
}

function isTvxUpdateThreads(obj: unknown): obj is TvxUpdateThreadsRow {
  return isTvxUpdate(obj) && obj.stream === 'threads'
}

function isTvxUpdateToolCalls(obj: unknown): obj is TvxUpdateToolCalls {
  return isTvxUpdate(obj) && obj.stream === 'toolCalls' && 'thread_id' in obj
}

function isTvxUpdatePlan(obj: unknown): obj is TvxUpdatePlan {
  return isTvxUpdate(obj) && obj.stream === 'plan' && 'thread_id' in obj
}

function isTvxUpdateState(obj: unknown): obj is TvxUpdateState {
  return isTvxUpdate(obj) && obj.stream === 'state' && 'thread_id' in obj
}

function isTvxQuery(obj: unknown): obj is TvxQuery {
  return typeof obj === 'object' && obj !== null && 'type' in obj && obj.type === 'tinyvex.query_result' && 'name' in obj
}

function isTvxQueryThreads(obj: unknown): obj is TvxQueryThreads {
  return isTvxQuery(obj) && obj.name === 'threads.list' && 'rows' in obj
}

function isTvxQueryMessages(obj: unknown): obj is TvxQueryMessages {
  return isTvxQuery(obj) && obj.name === 'messages.list' && 'thread_id' in obj && 'rows' in obj
}

function isTvxQueryToolCalls(obj: unknown): obj is TvxQueryToolCalls {
  return isTvxQuery(obj) && obj.name === 'toolCalls.list' && 'thread_id' in obj && 'rows' in obj
}

function isTvxQueryThreadsAndTails(obj: unknown): obj is TvxQueryThreadsAndTails {
  return isTvxQuery(obj) && obj.name === 'threadsAndTails.list' && 'threads' in obj && 'tails' in obj
}

// Helper to extract thread id from row (either id or thread_id field)
function getThreadIdFromRow(row: Partial<ThreadRow> | undefined): string {
  if (!row) return ''
  return String(row.id || row.thread_id || '')
}

export type TinyvexContextValue = {
  threads: ThreadRow[];
  messagesByThread: Record<string, MessageRow[]>;
  toolCallsByThread: Record<string, ToolCallRow[]>;
  planTouched: Record<string, number>;
  stateTouched: Record<string, number>;
  subscribeThreads: () => void;
  subscribeMessages: (threadId: string) => void;
  queryThreads: (limit?: number) => void;
  queryMessages: (threadId: string, limit?: number) => void;
  queryToolCalls: (threadId: string, limit?: number) => void;
}

const TinyvexContext = createContext<TinyvexContextValue | undefined>(undefined)

/**
 * TinyvexProvider
 *
 * Centralizes Tinyvex bootstrap and live update handling:
 * - On WS connect, subscribe to `threads` and fetch an initial list.
 * - Prefetch a bounded number of message tails for top threads.
 * - Throttle per-thread `messages.list` re-queries when `tinyvex.update` fires
 *   during streaming to avoid flooding the bridge.
 * - Debounce `threads.list` refresh after `tinyvex.update(stream:"threads")`.
 */
export function TinyvexProvider({ children }: { children: React.ReactNode }) {
  const bridge = useBridge();
  const connected = bridge.connected;
  const [threads, setThreads] = useState<ThreadRow[]>([])
  const [messagesByThread, setMessagesByThread] = useState<Record<string, MessageRow[]>>({})
  const [toolCallsByThread, setToolCallsByThread] = useState<Record<string, ToolCallRow[]>>({})
  const [planTouched, setPlanTouched] = useState<Record<string, number>>({})
  const [stateTouched, setStateTouched] = useState<Record<string, number>>({})
  // Latest threads in a ref to avoid recreating callbacks; used for stable lookups
  const threadsRef = useRef<ThreadRow[]>(threads)
  useEffect(() => { threadsRef.current = threads }, [threads])

  // Helpers to resolve aliasing between a client thread doc id and the
  // canonical session id (resume_id). When the bridge restarts before the
  // alias map is re-established, the watcher may mirror only to the session id.
  // We compensate on the client by querying canonical ids and storing results
  // under the client doc key as well.
  const getResumeForId = useCallback((tid: string): string | null => {
    try {
      const list = Array.isArray(threadsRef.current) ? threadsRef.current : []
      const row = list.find((r) => String(r.id) === String(tid))
      const rid = row?.resume_id ?? null
      return rid ? String(rid) : null
    } catch { return null }
  }, [])
  const getAliasForCanonical = useCallback((canonicalId: string): string | null => {
    try {
      const list = Array.isArray(threadsRef.current) ? threadsRef.current : []
      const row = list.find((r) => String(r.resume_id ?? '') === String(canonicalId))
      return row ? String(row.id) : null
    } catch { return null }
  }, [])

  // Handle incoming bridge events. We only parse JSON objects and ignore
  // plaintext rows for safety/perf. This function mutates provider state and
  // may schedule follow-up queries via throttled/debounced helpers.
  const onMessage = useCallback((raw: string) => {
    if (!raw || raw[0] !== '{') return;
    let obj: unknown; try { obj = JSON.parse(raw) } catch { return }
    
    if (isTvxSnapshotThreads(obj)) {
      setThreads(obj.rows)
      try {
        const setProvider = useThreadProviders.getState().setProvider
        for (const r of obj.rows) {
          const tid = String(r.id)
          const src = String(r.source ?? '')
          if (tid) setProvider(tid, src === 'claude_code' ? 'claude_code' : 'codex')
        }
      } catch {}
    } else if (isTvxSnapshotMessages(obj)) {
      setMessagesByThread((prev) => ({ ...prev, [obj.thread_id]: obj.rows }))
      try {
        const alias = getAliasForCanonical(String(obj.thread_id))
        if (alias && alias !== obj.thread_id) {
          setMessagesByThread((prev) => ({ ...prev, [alias]: obj.rows }))
        }
      } catch {}
    } else if (isTvxUpdateMessages(obj)) {
      // Live message writes can emit many updates while streaming.
      // Throttle per thread to avoid storms during streaming.
      try { scheduleMsgQuery(obj.thread_id) } catch {}
      // Also schedule a query for the canonical id if this was the client doc id,
      // or vice-versa schedule for the alias if we received a canonical update.
      try {
        const tid = String(obj.thread_id)
        const resume = getResumeForId(tid)
        if (resume && resume !== tid) { scheduleMsgQuery(resume) }
        const alias = getAliasForCanonical(tid)
        if (alias && alias !== tid) { scheduleMsgQuery(alias) }
      } catch {}
    } else if (isTvxUpdateThreads(obj)) {
      // Prefer merging the provided row to avoid a full refresh
      const row = obj.row
      if (row && typeof row === 'object') {
        setThreads((prev) => {
          const tid = getThreadIdFromRow(row)
          if (!tid) return prev
          const next = Array.isArray(prev) ? [...prev] : []
          const idx = next.findIndex((r) => getThreadIdFromRow(r) === tid)
          if (idx >= 0) next.splice(idx, 1)
          next.unshift(row as ThreadRow)
          return next
        })
        try {
          const setProvider = useThreadProviders.getState().setProvider
          const tid = getThreadIdFromRow(row)
          const src = String(row.source || '')
          if (tid) setProvider(tid, src === 'claude_code' ? 'claude_code' : 'codex')
        } catch {}
      } else {
        // Fallback: Debounce refreshes to avoid repeated full refreshes on bursts.
        try { scheduleThreadsRefresh() } catch {}
      }
    } else if (isTvxUpdateToolCalls(obj)) {
      try { scheduleToolQuery(obj.thread_id) } catch {}
    } else if (isTvxUpdatePlan(obj)) {
      setPlanTouched((prev) => ({ ...prev, [obj.thread_id]: Date.now() }))
    } else if (isTvxUpdateState(obj)) {
      setStateTouched((prev) => ({ ...prev, [obj.thread_id]: Date.now() }))
    } else if (isTvxQueryThreads(obj)) {
      setThreads(obj.rows)
      try {
        const setProvider = useThreadProviders.getState().setProvider
        for (const r of obj.rows) {
          const tid = String(r.id)
          const src = String(r.source ?? '')
          if (tid) setProvider(tid, src === 'claude_code' ? 'claude_code' : 'codex')
        }
      } catch {}
    } else if (isTvxQueryMessages(obj)) {
      setMessagesByThread((prev) => ({ ...prev, [obj.thread_id]: obj.rows }))
      // If these rows correspond to a canonical session id, also project them onto the
      // client doc id so thread screens keyed by that id hydrate immediately.
      try {
        const alias = getAliasForCanonical(String(obj.thread_id))
        if (alias && alias !== obj.thread_id) {
          console.log(`[Tinyvex Provider] Also projecting ${obj.rows.length} rows onto alias=${alias}`)
          setMessagesByThread((prev) => ({ ...prev, [alias]: obj.rows }))
        }
      } catch {}
    } else if (isTvxQueryToolCalls(obj)) {
      setToolCallsByThread((prev) => ({ ...prev, [obj.thread_id]: obj.rows }))
      // Also project onto the client doc id if this thread_id is canonical
      try {
        const alias = getAliasForCanonical(String(obj.thread_id))
        if (alias && alias !== obj.thread_id) {
          setToolCallsByThread((prev) => ({ ...prev, [alias]: obj.rows }))
        }
      } catch {}
    } else if (isTvxQueryThreadsAndTails(obj)) {
      // cancel fallback to threads.list if pending
      try {
        if (bootstrapPendingRef.current) {
          bootstrapPendingRef.current = false
          const id = fallbackTimerRef.current
          if (id != null) { clearTimeout(id); fallbackTimerRef.current = null }
        }
      } catch {}
      const threadsRows = obj.threads
      const tails = obj.tails
      // Build a complete list of threads from rows + tails. If Tinyvex DB is cold
      // after a bridge restart, tails may include additional threads that are not
      // yet in `threadsRows`. Synthesize minimal entries for them so the drawer
      // shows full history immediately.
      const known = new Set<string>()
      const nextThreads: ThreadRow[] = []
      for (const r of threadsRows) {
        const tid = String(r.id)
        if (!tid) continue
        known.add(tid)
        nextThreads.push(r)
      }
      for (const t of tails) {
        const tid = String(t.thread_id || '')
        if (!tid || known.has(tid)) continue
        const rows = Array.isArray(t.rows) ? t.rows : []
        const ts = (() => {
          try {
            if (!rows.length) return 0
            const last = rows[rows.length - 1]
            return Number(last.ts || 0)
          } catch { return 0 }
        })()
        nextThreads.push({
          id: tid,
          thread_id: tid,
          title: 'Thread',
          project_id: null,
          resume_id: null,
          rollout_path: null,
          source: 'codex',
          created_at: ts || Date.now(),
          updated_at: ts || Date.now(),
          message_count: rows.length,
          last_message_ts: ts || Date.now(),
        })
      }
      setThreads(nextThreads)
      try {
        const setProvider = useThreadProviders.getState().setProvider
        for (const r of nextThreads) {
          const tid = getThreadIdFromRow(r)
          const src = String(r.source || '')
          if (tid) setProvider(tid, src === 'claude_code' ? 'claude_code' : 'codex')
        }
      } catch {}
      
      setMessagesByThread((prev) => {
        const next = { ...prev }
        for (const t of tails) {
          const tid = String(t.thread_id || '')
          const rows = Array.isArray(t.rows) ? t.rows : []
          if (tid && rows.length) next[tid] = rows
        }
        return next
      })
    }
  // Note: scheduleMsgQuery, scheduleThreadsRefresh, scheduleToolQuery are defined below and stable via stableSend
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [getAliasForCanonical, getResumeForId])

  useEffect(() => bridge.addSubscriber(onMessage), [bridge, onMessage])

  // Throttlers and debouncers used for follow-up queries
  // Use stable `send` from bridge to keep these throttles persistent across renders
  const stableSend = bridge.send
  const scheduleMsgQuery = useMemo(() => {
    const throttle = createPerKeyThrottle(MSG_QUERY_THROTTLE_MS)
    return (threadId: string) => throttle(threadId, () => {
      try { stableSend(JSON.stringify({ control: 'tvx.query', name: 'messages.list', args: { thread_id: threadId, limit: DEFAULT_THREAD_TAIL } })) } catch {}
    })
  }, [stableSend])
  const scheduleThreadsRefresh = useMemo(() => {
    const debounce = createPerKeyDebounce(THREADS_REFRESH_DEBOUNCE_MS)
    return () => debounce('threads', () => {
      try { stableSend(JSON.stringify({ control: 'tvx.query', name: 'threads.list', args: { limit: 50 } })) } catch {}
    })
  }, [stableSend])
  const scheduleToolQuery = useMemo(() => {
    const throttle = createPerKeyThrottle(MSG_QUERY_THROTTLE_MS)
    return (threadId: string) => throttle(`tool-${threadId}`, () => {
      try { stableSend(JSON.stringify({ control: 'tvx.query', name: 'toolCalls.list', args: { thread_id: threadId, limit: 50 } })) } catch {}
    })
  }, [stableSend])

  // Auto-subscribe and fetch when the bridge connects
  useEffect(() => {
    if (!connected) return;
    // Single bootstrap: subscribe + list
    try { bridge.send(JSON.stringify({ control: 'tvx.subscribe', stream: 'threads' })) } catch {}
    try {
      bootstrapPendingRef.current = true
      bridge.send(JSON.stringify({ control: 'tvx.query', name: 'threadsAndTails.list', args: { limit: 50, perThreadTail: DEFAULT_THREAD_TAIL } }))
      const timer = setTimeout(() => {
        try {
          if (bootstrapPendingRef.current) {
            bridge.send(JSON.stringify({ control: 'tvx.query', name: 'threads.list', args: { limit: 50 } }))
            bootstrapPendingRef.current = false
          }
        } catch {}
      }, 1200)
      fallbackTimerRef.current = timer
    } catch {}
  }, [connected, bridge])

  // Prefetch messages for known threads so history opens instantly
  const prefetchRef = useRef<Set<string>>(new Set())
  // Track aggregated bootstrap status and fallback timer
  const bootstrapPendingRef = useRef<boolean>(false)
  const fallbackTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null)
  useEffect(() => {
    if (!connected) return
    try {
      const seen = prefetchRef.current
      const arr = Array.isArray(threads) ? threads : []
      // Prefetch a bounded recent set (reduce connect burst). We keep
      // a `seen` set to avoid re-subscribing while the provider lives.
      const copy = arr.slice().sort((a, b) => {
        const at = Number(a.updated_at ?? a.created_at ?? 0)
        const bt = Number(b.updated_at ?? b.created_at ?? 0)
        return bt - at
      }).slice(0, PREFETCH_TOP_THREADS)
      for (const r of copy) {
        const tid = String(r.id || '')
        if (!tid || seen.has(tid)) continue
        try { bridge.send(JSON.stringify({ control: 'tvx.subscribe', stream: 'messages', thread_id: tid })) } catch {}
        try { scheduleMsgQuery(tid) } catch {}
        seen.add(tid)
      }
    } catch {}
  }, [threads, connected, bridge, scheduleMsgQuery])

  const subscribeThreads = useCallback(() => {
    stableSend(JSON.stringify({ control: 'tvx.subscribe', stream: 'threads' }))
  }, [stableSend])
  // Track which threads we've subscribed to for idempotency
  const subscribedThreadsRef = useRef<Set<string>>(new Set())
  const subscribeMessages = useCallback((threadId: string) => {
    const trySub = (tid: string) => {
      if (!tid) return
      const set = subscribedThreadsRef.current
      if (set.has(tid)) return
      set.add(tid)
      try { stableSend(JSON.stringify({ control: 'tvx.subscribe', stream: 'messages', thread_id: tid })) } catch {}
    }
    trySub(threadId)
    try {
      const canonical = getResumeForId(threadId)
      if (canonical && canonical !== threadId) trySub(canonical)
    } catch {}
  }, [stableSend, getResumeForId])
  const queryThreads = useCallback((limit: number = 50) => {
    stableSend(JSON.stringify({ control: 'tvx.query', name: 'threads.list', args: { limit } }))
  }, [stableSend])
  const queryMessages = useCallback((threadId: string, limit: number = DEFAULT_THREAD_TAIL) => {
    try { stableSend(JSON.stringify({ control: 'tvx.query', name: 'messages.list', args: { thread_id: threadId, limit } })) } catch {}
    try {
      const canonical = getResumeForId(threadId)
      if (canonical && canonical !== threadId) {
        stableSend(JSON.stringify({ control: 'tvx.query', name: 'messages.list', args: { thread_id: canonical, limit } }))
      }
    } catch {}
  }, [stableSend, getResumeForId])
  const queryToolCalls = useCallback((threadId: string, limit: number = 50) => {
    try { stableSend(JSON.stringify({ control: 'tvx.query', name: 'toolCalls.list', args: { thread_id: threadId, limit } })) } catch {}
    try {
      const canonical = getResumeForId(threadId)
      if (canonical && canonical !== threadId) {
        stableSend(JSON.stringify({ control: 'tvx.query', name: 'toolCalls.list', args: { thread_id: canonical, limit } }))
      }
    } catch {}
  }, [stableSend, getResumeForId])

  // On reconnect, re-subscribe to any message streams we previously subscribed to.
  useEffect(() => {
    if (!connected) return
    try {
      const set = subscribedThreadsRef.current
      for (const tid of Array.from(set)) {
        try { stableSend(JSON.stringify({ control: 'tvx.subscribe', stream: 'messages', thread_id: tid })) } catch {}
      }
    } catch {}
  }, [connected, stableSend])

  const value = useMemo(() => ({ threads, messagesByThread, subscribeThreads, subscribeMessages, queryThreads, queryMessages, queryToolCalls }), [threads, messagesByThread, subscribeThreads, subscribeMessages, queryThreads, queryMessages, queryToolCalls])
  const ctxValue = useMemo(() => ({
    threads,
    messagesByThread,
    toolCallsByThread,
    planTouched,
    stateTouched,
    subscribeThreads,
    subscribeMessages,
    queryThreads,
    queryMessages,
    queryToolCalls,
  }), [threads, messagesByThread, toolCallsByThread, planTouched, stateTouched, subscribeThreads, subscribeMessages, queryThreads, queryMessages, queryToolCalls])
  return <TinyvexContext.Provider value={ctxValue}>{children}</TinyvexContext.Provider>
}

export function useTinyvex() {
  const ctx = useContext(TinyvexContext)
  if (!ctx) throw new Error('useTinyvex must be used within TinyvexProvider')
  return ctx
}
