// OrchestrationPlan.swift â€” Typed plan structures for Foundation Models orchestration
// Part of Phase 2: On-device FM orchestrator

import Foundation

// MARK: - Explore Plan

/// Plan for workspace exploration generated by Foundation Models
public struct ExplorePlan: Codable, Sendable, Equatable {
    /// Unique plan identifier
    public var planId: UUID

    /// High-level goals for exploration
    public var goals: [String]

    /// Queue of operations to execute
    public var nextOps: [AgentOp]

    /// Plan generation timestamp
    public var createdAt: Date

    public init(
        planId: UUID = UUID(),
        goals: [String],
        nextOps: [AgentOp] = [],
        createdAt: Date = Date()
    ) {
        self.planId = planId
        self.goals = goals
        self.nextOps = nextOps
        self.createdAt = createdAt
    }
}

// MARK: - Agent Operation

/// An atomic operation the orchestrator can execute
public struct AgentOp: Codable, Sendable, Equatable, Hashable {
    /// Unique operation identifier
    public var opId: UUID

    /// Operation type and parameters
    public var kind: AgentOpKind

    /// Operation priority (lower = higher priority)
    public var priority: Int

    /// Hash of operation parameters for deduplication
    public var opHash: UInt32

    public init(
        opId: UUID = UUID(),
        kind: AgentOpKind,
        priority: Int = 0
    ) {
        self.opId = opId
        self.kind = kind
        self.priority = priority
        self.opHash = Self.computeHash(for: kind)
    }

    /// Compute hash for deduplication
    private static func computeHash(for kind: AgentOpKind) -> UInt32 {
        // Simple hash based on operation parameters
        // In production, use xxhash32 as per spec
        let description = "\(kind)"
        return UInt32(description.hashValue & 0xFFFFFFFF)
    }

    // Hashable conformance for Set operations
    public func hash(into hasher: inout Hasher) {
        hasher.combine(opHash)
    }

    public static func == (lhs: AgentOp, rhs: AgentOp) -> Bool {
        lhs.opHash == rhs.opHash && lhs.kind == rhs.kind
    }
}

/// Types of operations the orchestrator can execute
public enum AgentOpKind: Codable, Sendable, Equatable {
    /// Read a span of lines from a file
    case readSpan(ReadSpanParams)

    /// Search for pattern using grep
    case grep(GrepParams)

    /// List directory contents
    case listDir(ListDirParams)

    /// Index repository (Phase 3+)
    case indexRepo(path: String)

    /// Semantic search (Phase 3+)
    case semantic(query: String, k: Int)

    // MARK: - Session History Tools (Phase 2.5)

    /// List conversation sessions
    case sessionList(SessionListParams)

    /// Search across sessions
    case sessionSearch(SessionSearchParams)

    /// Read session content
    case sessionRead(SessionReadParams)

    /// Analyze sessions for patterns
    case sessionAnalyze(SessionAnalyzeParams)
}

/// Parameters for readSpan operation
public struct ReadSpanParams: Codable, Sendable, Equatable {
    /// File path relative to workspace root
    public var path: String

    /// Start line (1-indexed)
    public var startLine: Int

    /// End line (1-indexed)
    public var endLine: Int

    /// Optional context lines before/after
    public var context: Int?

    public init(path: String, startLine: Int, endLine: Int, context: Int? = nil) {
        self.path = path
        self.startLine = startLine
        self.endLine = endLine
        self.context = context
    }
}

/// Parameters for grep operation
public struct GrepParams: Codable, Sendable, Equatable {
    /// Search pattern (regex)
    public var pattern: String

    /// Optional path prefix to limit search
    public var pathPrefix: String?

    /// Case-insensitive search
    public var caseInsensitive: Bool

    /// Maximum results to return
    public var maxResults: Int

    public init(
        pattern: String,
        pathPrefix: String? = nil,
        caseInsensitive: Bool = false,
        maxResults: Int = 200
    ) {
        self.pattern = pattern
        self.pathPrefix = pathPrefix
        self.caseInsensitive = caseInsensitive
        self.maxResults = maxResults
    }
}

/// Parameters for listDir operation
public struct ListDirParams: Codable, Sendable, Equatable {
    /// Directory path relative to workspace root
    public var path: String

    /// Recursion depth (0 = just this dir)
    public var depth: Int

    public init(path: String, depth: Int = 0) {
        self.path = path
        self.depth = depth
    }
}

// MARK: - ACP Conversion

extension ExplorePlan {
    /// Convert to ACP Plan format for streaming
    public func toACPPlan() -> ACPPlan {
        let entries = nextOps.map { op in
            ACPPlanEntry(
                content: op.description,
                priority: priorityFromInt(op.priority),
                status: .pending
            )
        }
        return ACPPlan(entries: entries, _meta: [
            "plan_id": AnyEncodable(planId.uuidString),
            "goals": AnyEncodable(goals)
        ])
    }

    private func priorityFromInt(_ value: Int) -> ACPPlanEntryPriority {
        switch value {
        case ...0: return .high
        case 1: return .medium
        default: return .low
        }
    }
}

extension AgentOp {
    /// Human-readable description for ACP plan entries
    public var description: String {
        switch kind {
        case .readSpan(let params):
            return "Read \(params.path):\(params.startLine)-\(params.endLine)"
        case .grep(let params):
            let prefix = params.pathPrefix ?? "workspace"
            return "Search '\(params.pattern)' in \(prefix)"
        case .listDir(let params):
            return "List directory \(params.path)"
        case .indexRepo(let path):
            return "Index repository at \(path)"
        case .semantic(let query, let k):
            return "Semantic search: \(query) (top \(k))"

        // Session history tools (Phase 2.5)
        case .sessionList(let params):
            let provider = params.provider ?? "all"
            let count = params.topK ?? 20
            return "List \(count) \(provider) sessions"
        case .sessionSearch(let params):
            let provider = params.provider ?? "all"
            return "Search '\(params.pattern)' in \(provider) sessions"
        case .sessionRead(let params):
            return "Read session \(params.sessionId) (\(params.provider))"
        case .sessionAnalyze(let params):
            if params.sessionIds.isEmpty {
                let prov = params.provider ?? "all providers"
                return "Analyze recent sessions (\(prov))"
            } else {
                return "Analyze \(params.sessionIds.count) sessions"
            }
        }
    }

    /// Convert to ACP tool name
    public var toolName: String {
        switch kind {
        case .readSpan: return "content.get_span"
        case .grep: return "search.grep"
        case .listDir: return "fs.list_dir"
        case .indexRepo: return "index.rebuild"
        case .semantic: return "search.semantic"

        // Session history tools (Phase 2.5)
        case .sessionList: return "session.list"
        case .sessionSearch: return "session.search"
        case .sessionRead: return "session.read"
        case .sessionAnalyze: return "session.analyze"
        }
    }
}
