{
  "version": 3,
  "sources": ["../../../../src/cli/lib/logs.ts"],
  "sourcesContent": ["import { Context } from \"../../bundler/context.js\";\nimport { logMessage, logOutput, logWarning } from \"../../bundler/log.js\";\nimport { nextBackoff } from \"./dev.js\";\nimport chalk from \"chalk\";\nimport { stripVTControlCharacters } from \"node:util\";\nimport { format } from \"node:util\";\nimport { deploymentFetch } from \"./utils/utils.js\";\nimport { FunctionExecution } from \"./apiTypes.js\";\n\nexport type LogMode = \"always\" | \"pause-on-deploy\" | \"disable\";\n\nexport class LogManager {\n  private paused: boolean = false;\n\n  constructor(private mode: LogMode) {}\n\n  async waitForUnpaused() {\n    while (this.paused) {\n      await new Promise((resolve) => setTimeout(resolve, 100));\n    }\n  }\n\n  beginDeploy() {\n    if (this.mode === \"pause-on-deploy\") {\n      this.paused = true;\n    }\n  }\n\n  endDeploy() {\n    if (this.mode === \"pause-on-deploy\") {\n      this.paused = false;\n    }\n  }\n}\n\nconst MAX_UDF_STREAM_FAILURE_COUNT = 5;\n\ntype LogDestination = \"stdout\" | \"stderr\";\n\nexport async function logsForDeployment(\n  ctx: Context,\n  credentials: {\n    url: string;\n    adminKey: string;\n  },\n  options: {\n    success: boolean;\n    history: number;\n    jsonl: boolean;\n    deploymentNotice: string;\n  },\n) {\n  logMessage(chalk.yellow(`Watching logs${options.deploymentNotice}...`));\n  await watchLogs(ctx, credentials.url, credentials.adminKey, \"stdout\", {\n    history: options.history,\n    success: options.success,\n    jsonl: options.jsonl,\n  });\n}\n\nexport async function watchLogs(\n  ctx: Context,\n  url: string,\n  adminKey: string,\n  dest: LogDestination,\n  options?: {\n    success: boolean;\n    history?: number | boolean;\n    jsonl?: boolean;\n    logManager?: LogManager;\n  },\n) {\n  let numFailures = 0;\n  let isFirst = true;\n  let cursorMs = 0;\n\n  for (;;) {\n    try {\n      const { entries, newCursor } = await pollUdfLog(\n        ctx,\n        cursorMs,\n        url,\n        adminKey,\n      );\n      cursorMs = newCursor;\n      numFailures = 0;\n\n      // Delay printing logs until the log manager is unpaused.\n      await options?.logManager?.waitForUnpaused();\n\n      // The first execution, we just want to fetch the current head cursor so we don't send stale\n      // logs to the client.\n      if (isFirst) {\n        isFirst = false;\n        if (\n          options?.history === true ||\n          (typeof options?.history === \"number\" && options?.history > 0)\n        ) {\n          const entriesSlice =\n            options?.history === true\n              ? entries\n              : entries.slice(entries.length - options?.history);\n          processLogs(\n            entriesSlice,\n            (s: string) => logToDestination(dest, s),\n            options?.success,\n            options?.jsonl,\n          );\n        }\n      } else {\n        processLogs(\n          entries,\n          (s: string) => logToDestination(dest, s),\n          options?.success === true,\n          options?.jsonl,\n        );\n      }\n    } catch {\n      numFailures += 1;\n    }\n    // Handle backoff\n    if (numFailures > 0) {\n      const backoff = nextBackoff(numFailures);\n\n      // If we exceed a threshold number of failures, warn the user and display backoff.\n      if (numFailures > MAX_UDF_STREAM_FAILURE_COUNT) {\n        logWarning(\n          `Convex [WARN] Failed to fetch logs. Waiting ${backoff}ms before next retry.`,\n        );\n      }\n      await new Promise((resolve) => {\n        setTimeout(() => resolve(null), backoff);\n      });\n    }\n  }\n}\n\ntype UdfType = \"Query\" | \"Mutation\" | \"Action\" | \"HttpAction\";\n\ntype StructuredLogLine = {\n  messages: string[];\n  level: \"LOG\" | \"DEBUG\" | \"INFO\" | \"WARN\" | \"ERROR\";\n  timestamp: number;\n  isTruncated: boolean;\n};\ntype LogLine = string | StructuredLogLine;\n\nasync function pollUdfLog(\n  ctx: Context,\n  cursor: number,\n  url: string,\n  adminKey: string,\n): Promise<{ entries: FunctionExecution[]; newCursor: number }> {\n  const fetch = deploymentFetch(ctx, {\n    deploymentUrl: url,\n    adminKey,\n  });\n  const response = await fetch(`/api/stream_function_logs?cursor=${cursor}`, {\n    method: \"GET\",\n  });\n  return await response.json();\n}\n\nconst prefixForSource = (udfType: UdfType): string => {\n  return udfType.charAt(0);\n};\n\nfunction processLogs(\n  rawLogs: FunctionExecution[],\n  write: (message: string) => void,\n  shouldShowSuccessLogs: boolean,\n  jsonl?: boolean,\n) {\n  if (jsonl) {\n    for (let i = 0; i < rawLogs.length; i++) {\n      const log = rawLogs[i];\n      write(JSON.stringify(log));\n    }\n    return;\n  }\n\n  for (let i = 0; i < rawLogs.length; i++) {\n    const log = rawLogs[i];\n    if (log.logLines) {\n      const id = log.identifier;\n      const udfType = log.udfType;\n      const timestampMs = log.timestamp * 1000;\n      const executionTimeMs =\n        \"executionTime\" in log ? log.executionTime * 1000 : NaN;\n\n      for (let j = 0; j < log.logLines.length; j++) {\n        const formatted = formatLogLineMessage(\n          \"info\",\n          timestampMs,\n          udfType,\n          id,\n          log.logLines[j],\n        );\n        write(formatted);\n      }\n\n      if (\"error\" in log && log.error) {\n        const formatted = formatLogLineMessage(\n          \"error\",\n          timestampMs,\n          udfType,\n          id,\n          log.error!,\n        );\n        write(formatted);\n      } else if (log.kind === \"Completion\" && shouldShowSuccessLogs) {\n        const formatted = chalk.green(\n          formatFunctionExecutionMessage(\n            timestampMs,\n            udfType,\n            id,\n            executionTimeMs,\n          ),\n        );\n        write(formatted);\n      }\n    }\n  }\n}\n\nexport function formatFunctionExecutionMessage(\n  timestampMs: number,\n  udfType: UdfType,\n  udfPath: string,\n  executionTimeMs: number,\n): string {\n  return `${prefixLog(timestampMs, udfType, udfPath)} Function executed in ${Math.ceil(executionTimeMs)} ms`;\n}\n\nexport function formatLogLineMessage(\n  type: \"info\" | \"error\",\n  timestampMs: number,\n  udfType: UdfType,\n  udfPath: string,\n  message: LogLine,\n): string {\n  const prefix = prefixForSource(udfType);\n  if (typeof message === \"string\") {\n    if (type === \"info\") {\n      const match = message.match(/^\\[.*?\\] /);\n      if (match === null) {\n        return chalk.red(\n          `[CONVEX ${prefix}(${udfPath})] Could not parse console.log`,\n        );\n      }\n      const level = message.slice(1, match[0].length - 2);\n      const args = message.slice(match[0].length);\n      return `${chalk.cyan(`${prefixLog(timestampMs, udfType, udfPath)} [${level}]`)} ${format(args)}`;\n    } else {\n      return chalk.red(\n        `${prefixLog(timestampMs, udfType, udfPath)} ${message}`,\n      );\n    }\n  } else {\n    const level = message.level;\n    const formattedMessage = `${message.messages.join(\" \")}${message.isTruncated ? \" (truncated due to length)\" : \"\"}`;\n    return `${chalk.cyan(\n      `${prefixLog(message.timestamp, udfType, udfPath)} [${level}]`,\n    )} ${formattedMessage}`;\n  }\n}\n\nfunction logToDestination(dest: LogDestination, s: string) {\n  switch (dest) {\n    case \"stdout\":\n      logOutput(s);\n      break;\n    case \"stderr\":\n      logMessage(s);\n      break;\n  }\n}\n\nfunction prefixLog(timestampMs: number, udfType: UdfType, udfPath: string) {\n  const prefix = prefixForSource(udfType);\n  const localizedTimestamp = new Date(timestampMs).toLocaleString();\n\n  return `${localizedTimestamp} [CONVEX ${prefix}(${udfPath})]`;\n}\n\nexport function formatLogsAsText(\n  rawLogs: FunctionExecution[],\n  shouldShowSuccessLogs: boolean = false,\n): string {\n  const lines: string[] = [];\n  const write = (message: string) =>\n    lines.push(stripVTControlCharacters(message));\n  processLogs(rawLogs, write, shouldShowSuccessLogs);\n  return lines.join(\"\\n\");\n}\n"],
  "mappings": "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",
  "names": ["import_node_util", "chalk"]
}
