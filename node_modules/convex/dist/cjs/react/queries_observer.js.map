{
  "version": 3,
  "sources": ["../../../src/react/queries_observer.ts"],
  "sourcesContent": ["import { convexToJson, Value } from \"../values/index.js\";\nimport { Watch } from \"./client.js\";\nimport { QueryJournal } from \"../browser/sync/protocol.js\";\nimport { FunctionReference, getFunctionName } from \"../server/api.js\";\n\ntype Identifier = string;\n\ntype QueryInfo = {\n  query: FunctionReference<\"query\">;\n  args: Record<string, Value>;\n  watch: Watch<Value>;\n  unsubscribe: () => void;\n};\n\nexport type CreateWatch = (\n  query: FunctionReference<\"query\">,\n  args: Record<string, Value>,\n  journal?: QueryJournal,\n) => Watch<Value>;\n\n/**\n * A class for observing the results of multiple queries at the same time.\n *\n * Any time the result of a query changes, the listeners are notified.\n */\nexport class QueriesObserver {\n  public createWatch: CreateWatch;\n  private queries: Record<Identifier, QueryInfo>;\n  private listeners: Set<() => void>;\n\n  constructor(createWatch: CreateWatch) {\n    this.createWatch = createWatch;\n    this.queries = {};\n    this.listeners = new Set();\n  }\n\n  setQueries(\n    newQueries: Record<\n      Identifier,\n      { query: FunctionReference<\"query\">; args: Record<string, Value> }\n    >,\n  ) {\n    // Add the new queries before unsubscribing from the old ones so that\n    // the deduping in the `ConvexReactClient` can help if there are duplicates.\n    for (const identifier of Object.keys(newQueries)) {\n      const { query, args } = newQueries[identifier];\n      // Might throw\n      getFunctionName(query);\n\n      if (this.queries[identifier] === undefined) {\n        // No existing query => add it.\n        this.addQuery(identifier, query, args);\n      } else {\n        const existingInfo = this.queries[identifier];\n        if (\n          getFunctionName(query) !== getFunctionName(existingInfo.query) ||\n          JSON.stringify(convexToJson(args)) !==\n            JSON.stringify(convexToJson(existingInfo.args))\n        ) {\n          // Existing query that doesn't match => remove the old and add the new.\n          this.removeQuery(identifier);\n          this.addQuery(identifier, query, args);\n        }\n      }\n    }\n\n    // Prune all the existing queries that we no longer need.\n    for (const identifier of Object.keys(this.queries)) {\n      if (newQueries[identifier] === undefined) {\n        this.removeQuery(identifier);\n      }\n    }\n  }\n\n  subscribe(listener: () => void): () => void {\n    this.listeners.add(listener);\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  getLocalResults(\n    queries: Record<\n      Identifier,\n      { query: FunctionReference<\"query\">; args: Record<string, Value> }\n    >,\n  ): Record<Identifier, Value | undefined | Error> {\n    const result: Record<Identifier, Value | Error | undefined> = {};\n    for (const identifier of Object.keys(queries)) {\n      const { query, args } = queries[identifier];\n      // Might throw\n      getFunctionName(query);\n\n      // Note: We're not gonna watch, we could save some allocations\n      // by getting a reference to the client directly instead.\n      const watch = this.createWatch(query, args);\n      let value: Value | undefined | Error;\n      try {\n        value = watch.localQueryResult();\n      } catch (e) {\n        // Only collect instances of `Error` because thats how callers\n        // will distinguish errors from normal results.\n        if (e instanceof Error) {\n          value = e;\n        } else {\n          throw e;\n        }\n      }\n      result[identifier] = value;\n    }\n    return result;\n  }\n\n  setCreateWatch(createWatch: CreateWatch) {\n    this.createWatch = createWatch;\n    // If we have a new watch, we might be using a new Convex client.\n    // Recreate all the watches being careful to preserve the journals.\n    for (const identifier of Object.keys(this.queries)) {\n      const { query, args, watch } = this.queries[identifier];\n      const journal = watch.journal();\n      this.removeQuery(identifier);\n      this.addQuery(identifier, query, args, journal);\n    }\n  }\n\n  destroy() {\n    for (const identifier of Object.keys(this.queries)) {\n      this.removeQuery(identifier);\n    }\n    this.listeners = new Set();\n  }\n\n  private addQuery(\n    identifier: Identifier,\n    query: FunctionReference<\"query\">,\n    args: Record<string, Value>,\n    journal?: QueryJournal,\n  ) {\n    if (this.queries[identifier] !== undefined) {\n      throw new Error(\n        `Tried to add a new query with identifier ${identifier} when it already exists.`,\n      );\n    }\n    const watch = this.createWatch(query, args, journal);\n    const unsubscribe = watch.onUpdate(() => this.notifyListeners());\n    this.queries[identifier] = {\n      query,\n      args,\n      watch,\n      unsubscribe,\n    };\n  }\n\n  private removeQuery(identifier: Identifier) {\n    const info = this.queries[identifier];\n    if (info === undefined) {\n      throw new Error(`No query found with identifier ${identifier}.`);\n    }\n    info.unsubscribe();\n    delete this.queries[identifier];\n  }\n\n  private notifyListeners(): void {\n    for (const listener of this.listeners) {\n      listener();\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
