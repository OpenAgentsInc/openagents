{
  "version": 3,
  "sources": ["../../../../src/cli/lib/deploy2.ts"],
  "sourcesContent": ["import { Context } from \"../../bundler/context.js\";\nimport {\n  changeSpinner,\n  logError,\n  logFailure,\n  logFinishedStep,\n  logVerbose,\n  showSpinner,\n} from \"../../bundler/log.js\";\nimport { spawnSync } from \"child_process\";\nimport { deploymentFetch, logAndHandleFetchError } from \"./utils/utils.js\";\nimport {\n  schemaStatus,\n  SchemaStatus,\n  StartPushRequest,\n  startPushResponse,\n  StartPushResponse,\n} from \"./deployApi/startPush.js\";\nimport {\n  AppDefinitionConfig,\n  ComponentDefinitionConfig,\n} from \"./deployApi/definitionConfig.js\";\nimport chalk from \"chalk\";\nimport { finishPushDiff, FinishPushDiff } from \"./deployApi/finishPush.js\";\nimport { Reporter, Span } from \"./tracing.js\";\nimport { promisify } from \"node:util\";\nimport zlib from \"node:zlib\";\nimport { PushOptions } from \"./push.js\";\nimport { runPush } from \"./components.js\";\nimport { suggestedEnvVarName } from \"./envvars.js\";\nimport { runSystemQuery } from \"./run.js\";\nimport { handlePushConfigError } from \"./config.js\";\nimport { deploymentDashboardUrlPage } from \"./dashboard.js\";\nimport { addProgressLinkIfSlow } from \"./indexes.js\";\n\nconst brotli = promisify(zlib.brotliCompress);\n\nasync function brotliCompress(ctx: Context, data: string): Promise<Buffer> {\n  const start = performance.now();\n  const result = await brotli(data, {\n    params: {\n      [zlib.constants.BROTLI_PARAM_MODE]: zlib.constants.BROTLI_MODE_TEXT,\n      [zlib.constants.BROTLI_PARAM_QUALITY]: 4,\n    },\n  });\n  const end = performance.now();\n  const duration = end - start;\n  logVerbose(\n    `Compressed ${(data.length / 1024).toFixed(2)}KiB to ${(result.length / 1024).toFixed(2)}KiB (${((result.length / data.length) * 100).toFixed(2)}%) in ${duration.toFixed(2)}ms`,\n  );\n  return result;\n}\n\n/** Push configuration2 to the given remote origin. */\nexport async function startPush(\n  ctx: Context,\n  span: Span,\n  request: StartPushRequest,\n  options: {\n    url: string;\n    deploymentName: string | null;\n  },\n): Promise<StartPushResponse> {\n  const custom = (_k: string | number, s: any) =>\n    typeof s === \"string\" ? s.slice(0, 40) + (s.length > 40 ? \"...\" : \"\") : s;\n  logVerbose(JSON.stringify(request, custom, 2));\n  const onError = (err: any) => {\n    if (err.toString() === \"TypeError: fetch failed\") {\n      changeSpinner(`Fetch failed, is ${options.url} correct? Retrying...`);\n    }\n  };\n  const fetch = deploymentFetch(ctx, {\n    deploymentUrl: options.url,\n    adminKey: request.adminKey,\n    onError,\n  });\n  changeSpinner(\"Analyzing source code...\");\n  try {\n    const response = await fetch(\"/api/deploy2/start_push\", {\n      body: await brotliCompress(ctx, JSON.stringify(request)),\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Content-Encoding\": \"br\",\n        traceparent: span.encodeW3CTraceparent(),\n      },\n    });\n    return startPushResponse.parse(await response.json());\n  } catch (error: unknown) {\n    return await handlePushConfigError(\n      ctx,\n      error,\n      \"Error: Unable to start push to \" + options.url,\n      options.deploymentName,\n      {\n        adminKey: request.adminKey,\n        deploymentUrl: options.url,\n        deploymentNotice: \"\",\n      },\n    );\n  }\n}\n\n// Long poll every 10s for progress on schema validation.\nconst SCHEMA_TIMEOUT_MS = 10_000;\n\nexport async function waitForSchema(\n  ctx: Context,\n  span: Span,\n  startPush: StartPushResponse,\n  options: {\n    adminKey: string;\n    url: string;\n    dryRun: boolean;\n    deploymentName: string | null;\n  },\n) {\n  const fetch = deploymentFetch(ctx, {\n    deploymentUrl: options.url,\n    adminKey: options.adminKey,\n  });\n\n  const start = Date.now();\n  changeSpinner(\"Pushing code to your Convex deployment...\");\n\n  while (true) {\n    let currentStatus: SchemaStatus;\n    try {\n      const response = await fetch(\"/api/deploy2/wait_for_schema\", {\n        body: JSON.stringify({\n          adminKey: options.adminKey,\n          schemaChange: startPush.schemaChange,\n          timeoutMs: SCHEMA_TIMEOUT_MS,\n          dryRun: options.dryRun,\n        }),\n        method: \"POST\",\n        headers: {\n          traceparent: span.encodeW3CTraceparent(),\n        },\n      });\n      currentStatus = schemaStatus.parse(await response.json());\n    } catch (error: unknown) {\n      logFailure(\"Error: Unable to wait for schema from \" + options.url);\n      return await logAndHandleFetchError(ctx, error);\n    }\n    switch (currentStatus.type) {\n      case \"inProgress\": {\n        let schemaDone = true;\n        let indexesComplete = 0;\n        let indexesTotal = 0;\n        for (const componentStatus of Object.values(currentStatus.components)) {\n          if (!componentStatus.schemaValidationComplete) {\n            schemaDone = false;\n          }\n          indexesComplete += componentStatus.indexesComplete;\n          indexesTotal += componentStatus.indexesTotal;\n        }\n        const indexesDone = indexesComplete === indexesTotal;\n        let msg: string;\n        if (!indexesDone && !schemaDone) {\n          msg = addProgressLinkIfSlow(\n            `Backfilling indexes (${indexesComplete}/${indexesTotal} ready) and checking that documents match your schema...`,\n            options.deploymentName,\n            start,\n          );\n        } else if (!indexesDone) {\n          msg = `Backfilling indexes (${indexesComplete}/${indexesTotal} ready)...`;\n          // Set a more specific message if the backfill is taking a long time\n          if (Date.now() - start > 10_000) {\n            const rootDiff = startPush.schemaChange.indexDiffs?.[\"\"];\n            const indexName = (\n              rootDiff?.added_indexes[0] || rootDiff?.enabled_indexes?.[0]\n            )?.name;\n            if (indexName) {\n              const table = indexName.split(\".\")[0];\n              const dashboardUrl = deploymentDashboardUrlPage(\n                options.deploymentName,\n                `/data?table=${table}&showIndexes=true`,\n              );\n              msg = `Backfilling index ${indexName} (${indexesComplete}/${indexesTotal} ready), see progress here: ${dashboardUrl}`;\n            }\n          }\n        } else {\n          msg = addProgressLinkIfSlow(\n            \"Checking that documents match your schema...\",\n            options.deploymentName,\n            start,\n          );\n        }\n        changeSpinner(msg);\n        break;\n      }\n      case \"failed\": {\n        // Schema validation failed. This could be either because the data\n        // is bad or the schema is wrong. Classify this as a filesystem error\n        // because adjusting `schema.ts` is the most normal next step.\n        let msg = \"Schema validation failed\";\n        if (currentStatus.componentPath) {\n          msg += ` in component \"${currentStatus.componentPath}\"`;\n        }\n        msg += \".\";\n        logFailure(msg);\n        logError(chalk.red(`${currentStatus.error}`));\n        return await ctx.crash({\n          exitCode: 1,\n          errorType: {\n            \"invalid filesystem or db data\": currentStatus.tableName\n              ? {\n                  tableName: currentStatus.tableName,\n                  componentPath: currentStatus.componentPath,\n                }\n              : null,\n          },\n          printedMessage: null, // TODO - move logging into here\n        });\n      }\n      case \"raceDetected\": {\n        return await ctx.crash({\n          exitCode: 1,\n          errorType: \"fatal\",\n          printedMessage: `Schema was overwritten by another push.`,\n        });\n      }\n      case \"complete\": {\n        changeSpinner(\"Schema validation complete.\");\n        return;\n      }\n    }\n  }\n}\n\nexport async function finishPush(\n  ctx: Context,\n  span: Span,\n  startPush: StartPushResponse,\n  options: {\n    adminKey: string;\n    url: string;\n    dryRun: boolean;\n    verbose?: boolean;\n  },\n): Promise<FinishPushDiff> {\n  changeSpinner(\"Finalizing push...\");\n  const fetch = deploymentFetch(ctx, {\n    deploymentUrl: options.url,\n    adminKey: options.adminKey,\n  });\n  const request = {\n    adminKey: options.adminKey,\n    startPush,\n    dryRun: options.dryRun,\n  };\n  try {\n    const response = await fetch(\"/api/deploy2/finish_push\", {\n      body: await brotliCompress(ctx, JSON.stringify(request)),\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Content-Encoding\": \"br\",\n        traceparent: span.encodeW3CTraceparent(),\n      },\n    });\n    return finishPushDiff.parse(await response.json());\n  } catch (error: unknown) {\n    logFailure(\"Error: Unable to finish push to \" + options.url);\n    return await logAndHandleFetchError(ctx, error);\n  }\n}\n\nexport type ComponentDefinitionConfigWithoutImpls = Omit<\n  ComponentDefinitionConfig,\n  \"schema\" | \"functions\"\n>;\nexport type AppDefinitionConfigWithoutImpls = Omit<\n  AppDefinitionConfig,\n  \"schema\" | \"functions\" | \"auth\"\n>;\n\nexport async function reportPushCompleted(\n  ctx: Context,\n  adminKey: string,\n  url: string,\n  reporter: Reporter,\n) {\n  const fetch = deploymentFetch(ctx, {\n    deploymentUrl: url,\n    adminKey,\n  });\n  try {\n    const response = await fetch(\"/api/deploy2/report_push_completed\", {\n      body: JSON.stringify({\n        adminKey,\n        spans: reporter.spans,\n      }),\n      method: \"POST\",\n    });\n    await response.json();\n  } catch (error: unknown) {\n    logFailure(\n      \"Error: Unable to report push completed to \" + url + \": \" + error,\n    );\n  }\n}\n\nexport async function deployToDeployment(\n  ctx: Context,\n  credentials: {\n    url: string;\n    adminKey: string;\n    deploymentName: string | null;\n  },\n  options: {\n    verbose?: boolean | undefined;\n    dryRun?: boolean | undefined;\n    yes?: boolean | undefined;\n    typecheck: \"enable\" | \"try\" | \"disable\";\n    typecheckComponents: boolean;\n    codegen: \"enable\" | \"disable\";\n    cmd?: string | undefined;\n    cmdUrlEnvVarName?: string | undefined;\n\n    debugBundlePath?: string | undefined;\n    debug?: boolean | undefined;\n    writePushRequest?: string | undefined;\n    liveComponentSources?: boolean | undefined;\n  },\n) {\n  const { url, adminKey } = credentials;\n  await runCommand(ctx, { ...options, url, adminKey });\n\n  const pushOptions: PushOptions = {\n    deploymentName: credentials.deploymentName,\n    adminKey,\n    verbose: !!options.verbose,\n    dryRun: !!options.dryRun,\n    typecheck: options.typecheck,\n    typecheckComponents: options.typecheckComponents,\n    debug: !!options.debug,\n    debugBundlePath: options.debugBundlePath,\n    debugNodeApis: false,\n    codegen: options.codegen === \"enable\",\n    url,\n    writePushRequest: options.writePushRequest,\n    liveComponentSources: !!options.liveComponentSources,\n  };\n  showSpinner(`Deploying to ${url}...${options.dryRun ? \" [dry run]\" : \"\"}`);\n  await runPush(ctx, pushOptions);\n  logFinishedStep(\n    `${\n      options.dryRun ? \"Would have deployed\" : \"Deployed\"\n    } Convex functions to ${url}`,\n  );\n}\n\nexport async function runCommand(\n  ctx: Context,\n  options: {\n    cmdUrlEnvVarName?: string | undefined;\n    cmd?: string | undefined;\n    dryRun?: boolean | undefined;\n    url: string;\n    adminKey: string;\n  },\n) {\n  if (options.cmd === undefined) {\n    return;\n  }\n\n  const urlVar =\n    options.cmdUrlEnvVarName ?? (await suggestedEnvVarName(ctx)).envVar;\n  showSpinner(\n    `Running '${options.cmd}' with environment variable \"${urlVar}\" set...${\n      options.dryRun ? \" [dry run]\" : \"\"\n    }`,\n  );\n  if (!options.dryRun) {\n    const canonicalCloudUrl = await fetchDeploymentCanonicalCloudUrl(ctx, {\n      deploymentUrl: options.url,\n      adminKey: options.adminKey,\n    });\n\n    const env = { ...process.env };\n    env[urlVar] = canonicalCloudUrl;\n    const result = spawnSync(options.cmd, {\n      env,\n      stdio: \"inherit\",\n      shell: true,\n    });\n    if (result.status !== 0) {\n      await ctx.crash({\n        exitCode: 1,\n        errorType: \"invalid filesystem data\",\n        printedMessage: `'${options.cmd}' failed`,\n      });\n    }\n  }\n  logFinishedStep(\n    `${options.dryRun ? \"Would have run\" : \"Ran\"} \"${\n      options.cmd\n    }\" with environment variable \"${urlVar}\" set`,\n  );\n}\n\nexport async function fetchDeploymentCanonicalCloudUrl(\n  ctx: Context,\n  options: { deploymentUrl: string; adminKey: string },\n): Promise<string> {\n  const result = await runSystemQuery(ctx, {\n    ...options,\n    functionName: \"_system/cli/convexUrl:cloudUrl\",\n    componentPath: undefined,\n    args: {},\n  });\n  if (typeof result !== \"string\") {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"invalid filesystem or env vars\",\n      printedMessage: \"Invalid process.env.CONVEX_CLOUD_URL\",\n    });\n  }\n  return result;\n}\n"],
  "mappings": "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",
  "names": ["startPush"]
}
