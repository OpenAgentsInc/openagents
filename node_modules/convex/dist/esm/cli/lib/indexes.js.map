{
  "version": 3,
  "sources": ["../../../../src/cli/lib/indexes.ts"],
  "sourcesContent": ["import chalk from \"chalk\";\nimport path from \"path\";\nimport { bundleSchema } from \"../../bundler/index.js\";\nimport { Context } from \"../../bundler/context.js\";\nimport {\n  changeSpinner,\n  logFailure,\n  logFinishedStep,\n  logError,\n} from \"../../bundler/log.js\";\nimport {\n  poll,\n  logAndHandleFetchError,\n  deploymentFetch,\n  deprecationCheckWarning,\n} from \"./utils/utils.js\";\nimport { deploymentDashboardUrlPage } from \"./dashboard.js\";\nimport { DeveloperIndexConfig } from \"./deployApi/finishPush.js\";\n\nexport type IndexMetadata = {\n  table: string;\n  name: string;\n  fields:\n    | string[]\n    | {\n        searchField: string;\n        filterFields: string[];\n      }\n    | {\n        dimensions: number;\n        vectorField: string;\n        filterFields: string[];\n      };\n  backfill: {\n    state: \"in_progress\" | \"done\";\n  };\n  staged: boolean;\n};\n\ntype SchemaState =\n  | { state: \"pending\" }\n  | { state: \"validated\" }\n  | { state: \"active\" }\n  | { state: \"overwritten\" }\n  | { state: \"failed\"; error: string; tableName?: string };\n\ntype SchemaStateResponse = {\n  indexes: IndexMetadata[];\n  schemaState: SchemaState;\n};\ntype PrepareSchemaResponse = {\n  added: IndexMetadata[];\n  dropped: IndexMetadata[];\n  schemaId: string;\n  // added August 22 2025\n  enabled?: IndexMetadata[];\n  disabled?: IndexMetadata[];\n};\n\nexport async function pushSchema(\n  ctx: Context,\n  origin: string,\n  adminKey: string,\n  schemaDir: string,\n  dryRun: boolean,\n  deploymentName: string | null,\n): Promise<{ schemaId?: string; schemaState?: SchemaState }> {\n  if (\n    !ctx.fs.exists(path.resolve(schemaDir, \"schema.ts\")) &&\n    !ctx.fs.exists(path.resolve(schemaDir, \"schema.js\"))\n  ) {\n    // Don't do anything.\n    return {};\n  }\n  const bundles = await bundleSchema(ctx, schemaDir, []);\n\n  changeSpinner(\"Checking for index or schema changes...\");\n\n  let data: PrepareSchemaResponse;\n  const fetch = deploymentFetch(ctx, {\n    deploymentUrl: origin,\n    adminKey,\n  });\n  try {\n    const res = await fetch(\"/api/prepare_schema\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        bundle: bundles[0],\n        adminKey,\n        dryRun,\n      }),\n    });\n    deprecationCheckWarning(ctx, res);\n    data = await res.json();\n  } catch (err: unknown) {\n    logFailure(`Error: Unable to run schema validation on ${origin}`);\n    return await logAndHandleFetchError(ctx, err);\n  }\n\n  logIndexChanges(data, dryRun, deploymentName);\n  const schemaId = data.schemaId;\n  const schemaState = await waitForReadySchema(\n    ctx,\n    origin,\n    adminKey,\n    schemaId,\n    deploymentName,\n  );\n  return { schemaId, schemaState };\n}\n\n/// Wait for indexes to build and schema to be validated.\nasync function waitForReadySchema(\n  ctx: Context,\n  origin: string,\n  adminKey: string,\n  schemaId: string,\n  deploymentName: string | null,\n): Promise<SchemaState> {\n  const path = `api/schema_state/${schemaId}`;\n  const depFetch = deploymentFetch(ctx, {\n    deploymentUrl: origin,\n    adminKey,\n  });\n  const fetch = async () => {\n    try {\n      const resp = await depFetch(path, { method: \"GET\" });\n      const data: SchemaStateResponse = await resp.json();\n      return data;\n    } catch (err: unknown) {\n      logFailure(\n        `Error: Unable to build indexes and run schema validation on ${origin}`,\n      );\n      return await logAndHandleFetchError(ctx, err);\n    }\n  };\n\n  // Set the spinner to the default progress message before the first `fetch` call returns.\n  const start = Date.now();\n\n  setSchemaProgressSpinner(null, start, deploymentName);\n\n  const data = await poll(fetch, (data: SchemaStateResponse) => {\n    setSchemaProgressSpinner(data, start, deploymentName);\n    return (\n      data.indexes.every(\n        (index) => index.backfill.state === \"done\" || index.staged,\n      ) && data.schemaState.state !== \"pending\"\n    );\n  });\n\n  switch (data.schemaState.state) {\n    case \"failed\":\n      // Schema validation failed. This could be either because the data\n      // is bad or the schema is wrong. Classify this as a filesystem error\n      // because adjusting `schema.ts` is the most normal next step.\n      logFailure(\"Schema validation failed\");\n      logError(chalk.red(`${data.schemaState.error}`));\n      return await ctx.crash({\n        exitCode: 1,\n        errorType: {\n          \"invalid filesystem or db data\": data.schemaState.tableName\n            ? {\n                tableName: data.schemaState.tableName,\n              }\n            : null,\n        },\n        printedMessage: null, // TODO - move logging into here\n      });\n\n    case \"overwritten\":\n      return await ctx.crash({\n        exitCode: 1,\n        errorType: \"fatal\",\n        printedMessage: `Schema was overwritten by another push.`,\n      });\n    case \"validated\":\n      changeSpinner(\"Schema validation complete.\");\n      break;\n    case \"active\":\n      break;\n  }\n  return data.schemaState;\n}\n\nfunction setSchemaProgressSpinner(\n  data: SchemaStateResponse | null,\n  start: number,\n  deploymentName: string | null,\n) {\n  if (!data) {\n    changeSpinner(\"Pushing code to your deployment...\");\n    return;\n  }\n  const indexesCompleted = data.indexes.filter(\n    (index) => index.backfill.state === \"done\",\n  ).length;\n  const numIndexes = data.indexes.length;\n\n  const indexesDone = indexesCompleted === numIndexes;\n  const schemaDone = data.schemaState.state !== \"pending\";\n\n  if (indexesDone && schemaDone) {\n    return;\n  }\n\n  let msg = \"Pushing your code to your Convex deployment...\";\n  if (!indexesDone && !schemaDone) {\n    msg = addProgressLinkIfSlow(\n      `Backfilling indexes (${indexesCompleted}/${numIndexes} ready) and checking that documents match your schema...`,\n      deploymentName,\n      start,\n    );\n  } else if (!indexesDone) {\n    if (Date.now() - start > 10_000) {\n      for (const index of data.indexes) {\n        if (index.backfill.state === \"in_progress\") {\n          const dashboardUrl = deploymentDashboardUrlPage(\n            deploymentName,\n            `/data?table=${index.table}&showIndexes=true`,\n          );\n          msg = `Backfilling index ${index.name} (${indexesCompleted}/${numIndexes} ready), \\\nsee progress: ${dashboardUrl}`;\n          break;\n        }\n      }\n    } else {\n      msg = `Backfilling indexes (${indexesCompleted}/${numIndexes} ready)...`;\n    }\n  } else {\n    msg = addProgressLinkIfSlow(\n      \"Checking that documents match your schema...\",\n      deploymentName,\n      start,\n    );\n  }\n  changeSpinner(msg);\n}\n\nexport function addProgressLinkIfSlow(\n  msg: string,\n  deploymentName: string | null,\n  start: number,\n): string {\n  if (Date.now() - start > 10_000) {\n    const dashboardUrl = deploymentDashboardUrlPage(\n      deploymentName,\n      `/data?showSchema=true`,\n    );\n    msg = msg.concat(`\\nSee progress here: ${dashboardUrl}`);\n  }\n  return msg;\n}\n\nfunction logIndexChanges(\n  indexes: PrepareSchemaResponse,\n  dryRun: boolean,\n  deploymentName: string | null,\n) {\n  if (indexes.dropped.length > 0) {\n    let indexDiff = \"\";\n    for (const index of indexes.dropped) {\n      indexDiff += `  [-] ${formatIndex(toDeveloperIndexConfig(index))}\\n`;\n    }\n    // strip last new line\n    indexDiff = indexDiff.slice(0, -1);\n    logFinishedStep(\n      `${dryRun ? \"Would delete\" : \"Deleted\"} table indexes:\\n${indexDiff}`,\n    );\n  }\n  const addedStaged = indexes.added.filter((index) => index.staged);\n  const addedEnabled = indexes.added.filter((index) => !index.staged);\n  if (addedEnabled.length > 0) {\n    let indexDiff = \"\";\n    for (const index of addedEnabled) {\n      indexDiff += `  [+] ${formatIndex(toDeveloperIndexConfig(index))}\\n`;\n    }\n    // strip last new line\n    indexDiff = indexDiff.slice(0, -1);\n    logFinishedStep(\n      `${dryRun ? \"Would add\" : \"Added\"} table indexes:\\n${indexDiff}`,\n    );\n  }\n  if (addedStaged.length > 0) {\n    let indexDiff = \"\";\n    for (const index of addedStaged) {\n      const progressLink = deploymentDashboardUrlPage(\n        deploymentName,\n        `/data?table=${index.table}&showIndexes=true`,\n      );\n      indexDiff += `  [+] ${formatIndex(toDeveloperIndexConfig(index))}, see progress: ${progressLink}\\n`;\n    }\n    // strip last new line\n    indexDiff = indexDiff.slice(0, -1);\n    logFinishedStep(\n      `${dryRun ? \"Would add\" : \"Added\"} staged table indexes:\\n${indexDiff}`,\n    );\n  }\n  if (indexes.enabled && indexes.enabled.length > 0) {\n    let indexDiff = \"\";\n    for (const index of indexes.enabled) {\n      indexDiff += `  [*] ${formatIndex(toDeveloperIndexConfig(index))}\\n`;\n    }\n    // strip last new line\n    indexDiff = indexDiff.slice(0, -1);\n    const text = dryRun\n      ? `These indexes would be enabled`\n      : `These indexes are now enabled`;\n    logFinishedStep(`${text}:\\n${indexDiff}`);\n  }\n  if (indexes.disabled && indexes.disabled.length > 0) {\n    let indexDiff = \"\";\n    for (const index of indexes.disabled) {\n      indexDiff += `  [*] ${formatIndex(toDeveloperIndexConfig(index))}\\n`;\n    }\n    // strip last new line\n    indexDiff = indexDiff.slice(0, -1);\n    const text = dryRun\n      ? `These indexes would be staged`\n      : `These indexes are now staged`;\n    logFinishedStep(`${text}:\\n${indexDiff}`);\n  }\n}\n\nexport function toIndexMetadata(index: DeveloperIndexConfig): IndexMetadata {\n  function extractFields(index: DeveloperIndexConfig): IndexMetadata[\"fields\"] {\n    if (index.type === \"database\") {\n      return index.fields;\n    } else if (index.type === \"search\") {\n      return {\n        searchField: index.searchField,\n        filterFields: index.filterFields,\n      };\n    } else if (index.type === \"vector\") {\n      return {\n        dimensions: index.dimensions,\n        vectorField: index.vectorField,\n        filterFields: index.filterFields,\n      };\n    } else {\n      index satisfies never;\n      return [];\n    }\n  }\n\n  const [table, indexName] = index.name.split(\".\");\n  return {\n    table,\n    name: indexName,\n    fields: extractFields(index),\n    backfill: {\n      state: \"done\",\n    },\n    staged: index.staged ?? false,\n  };\n}\n\nexport function toDeveloperIndexConfig(\n  index: IndexMetadata,\n): DeveloperIndexConfig {\n  const name = `${index.table}.${index.name}`;\n  const commonProps = { name, staged: index.staged };\n\n  const { fields } = index;\n  if (Array.isArray(fields)) {\n    return {\n      ...commonProps,\n      type: \"database\",\n      fields: fields,\n    };\n  } else if (\"searchField\" in fields) {\n    return {\n      ...commonProps,\n      type: \"search\",\n      searchField: fields.searchField,\n      filterFields: fields.filterFields,\n    };\n  } else if (\"vectorField\" in fields) {\n    return {\n      ...commonProps,\n      type: \"vector\",\n      vectorField: fields.vectorField,\n      dimensions: fields.dimensions,\n      filterFields: fields.filterFields,\n    };\n  } else {\n    fields satisfies never;\n    return { ...commonProps, type: \"database\", fields: [] };\n  }\n}\n\nexport function formatIndex(index: DeveloperIndexConfig) {\n  const [tableName, indexName] = index.name.split(\".\");\n  return `${tableName}.${chalk.bold(indexName)} ${chalk.gray(formatIndexFields(index))}`;\n}\n\nfunction formatIndexFields(index: DeveloperIndexConfig) {\n  switch (index.type) {\n    case \"database\":\n      return \"  \" + index.fields.map((f) => chalk.underline(f)).join(\", \");\n    case \"search\":\n      return `${chalk.cyan(\"(text)\")}   ${chalk.underline(index.searchField)}${formatFilterFields(index.filterFields)}`;\n    case \"vector\":\n      return `${chalk.cyan(\"(vector)\")}   ${chalk.underline(index.vectorField)} (${index.dimensions} dimensions)${formatFilterFields(index.filterFields)}`;\n    default:\n      index satisfies never;\n      return \"\";\n  }\n}\n\nfunction formatFilterFields(filterFields: string[]) {\n  if (filterFields.length === 0) {\n    return \"\";\n  }\n  return `, filter${filterFields.length === 1 ? \"\" : \"s\"} on ${filterFields.map((f) => chalk.underline(f)).join(\", \")}`;\n}\n"],
  "mappings": "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",
  "names": ["path", "data", "index"]
}
