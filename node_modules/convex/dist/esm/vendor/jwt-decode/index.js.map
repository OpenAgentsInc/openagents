{
  "version": 3,
  "sources": ["../../../../src/vendor/jwt-decode/index.ts"],
  "sourcesContent": ["export interface JwtDecodeOptions {\n  header?: boolean;\n}\n\nexport interface JwtHeader {\n  typ?: string;\n  alg?: string;\n  kid?: string;\n}\n\nexport interface JwtPayload {\n  iss?: string;\n  sub?: string;\n  aud?: string[] | string;\n  exp?: number;\n  nbf?: number;\n  iat?: number;\n  jti?: string;\n}\n\nexport class InvalidTokenError extends Error {}\n\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\n\nfunction b64DecodeUnicode(str: string) {\n  return decodeURIComponent(\n    atob(str).replace(/(.)/g, (_m, p) => {\n      let code = (p as string).charCodeAt(0).toString(16).toUpperCase();\n      if (code.length < 2) {\n        code = \"0\" + code;\n      }\n      return \"%\" + code;\n    }),\n  );\n}\n\nfunction base64UrlDecode(str: string) {\n  let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  switch (output.length % 4) {\n    case 0:\n      break;\n    case 2:\n      output += \"==\";\n      break;\n    case 3:\n      output += \"=\";\n      break;\n    default:\n      throw new Error(\"base64 string is not of the correct length\");\n  }\n\n  try {\n    return b64DecodeUnicode(output);\n  } catch {\n    return atob(output);\n  }\n}\n\nexport function jwtDecode<T = JwtHeader>(\n  token: string,\n  options: JwtDecodeOptions & { header: true },\n): T;\nexport function jwtDecode<T = JwtPayload>(\n  token: string,\n  options?: JwtDecodeOptions,\n): T;\nexport function jwtDecode<T = JwtHeader | JwtPayload>(\n  token: string,\n  options?: JwtDecodeOptions,\n): T {\n  if (typeof token !== \"string\") {\n    throw new InvalidTokenError(\"Invalid token specified: must be a string\");\n  }\n\n  options ||= {};\n\n  const pos = options.header === true ? 0 : 1;\n  const part = token.split(\".\")[pos];\n\n  if (typeof part !== \"string\") {\n    throw new InvalidTokenError(\n      `Invalid token specified: missing part #${pos + 1}`,\n    );\n  }\n\n  let decoded: string;\n  try {\n    decoded = base64UrlDecode(part);\n  } catch (e) {\n    throw new InvalidTokenError(\n      `Invalid token specified: invalid base64 for part #${pos + 1} (${(e as Error).message})`,\n    );\n  }\n\n  try {\n    return JSON.parse(decoded) as T;\n  } catch (e) {\n    throw new InvalidTokenError(\n      `Invalid token specified: invalid json for part #${pos + 1} (${(e as Error).message})`,\n    );\n  }\n}\n"],
  "mappings": ";AAoBO,aAAM,0BAA0B,MAAM;AAAC;AAE9C,kBAAkB,UAAU,OAAO;AAEnC,SAAS,iBAAiB,KAAa;AACrC,SAAO;AAAA,IACL,KAAK,GAAG,EAAE,QAAQ,QAAQ,CAAC,IAAI,MAAM;AACnC,UAAI,OAAQ,EAAa,WAAW,CAAC,EAAE,SAAS,EAAE,EAAE,YAAY;AAChE,UAAI,KAAK,SAAS,GAAG;AACnB,eAAO,MAAM;AAAA,MACf;AACA,aAAO,MAAM;AAAA,IACf,CAAC;AAAA,EACH;AACF;AAEA,SAAS,gBAAgB,KAAa;AACpC,MAAI,SAAS,IAAI,QAAQ,MAAM,GAAG,EAAE,QAAQ,MAAM,GAAG;AACrD,UAAQ,OAAO,SAAS,GAAG;AAAA,IACzB,KAAK;AACH;AAAA,IACF,KAAK;AACH,gBAAU;AACV;AAAA,IACF,KAAK;AACH,gBAAU;AACV;AAAA,IACF;AACE,YAAM,IAAI,MAAM,4CAA4C;AAAA,EAChE;AAEA,MAAI;AACF,WAAO,iBAAiB,MAAM;AAAA,EAChC,QAAQ;AACN,WAAO,KAAK,MAAM;AAAA,EACpB;AACF;AAUO,gBAAS,UACd,OACA,SACG;AACH,MAAI,OAAO,UAAU,UAAU;AAC7B,UAAM,IAAI,kBAAkB,2CAA2C;AAAA,EACzE;AAEA,wBAAY,CAAC;AAEb,QAAM,MAAM,QAAQ,WAAW,OAAO,IAAI;AAC1C,QAAM,OAAO,MAAM,MAAM,GAAG,EAAE,GAAG;AAEjC,MAAI,OAAO,SAAS,UAAU;AAC5B,UAAM,IAAI;AAAA,MACR,0CAA0C,MAAM,CAAC;AAAA,IACnD;AAAA,EACF;AAEA,MAAI;AACJ,MAAI;AACF,cAAU,gBAAgB,IAAI;AAAA,EAChC,SAAS,GAAG;AACV,UAAM,IAAI;AAAA,MACR,qDAAqD,MAAM,CAAC,KAAM,EAAY,OAAO;AAAA,IACvF;AAAA,EACF;AAEA,MAAI;AACF,WAAO,KAAK,MAAM,OAAO;AAAA,EAC3B,SAAS,GAAG;AACV,UAAM,IAAI;AAAA,MACR,mDAAmD,MAAM,CAAC,KAAM,EAAY,OAAO;AAAA,IACrF;AAAA,EACF;AACF;",
  "names": []
}
