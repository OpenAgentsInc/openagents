# Effect Migration Notes (apps/web)

This repo’s **`apps/web`** app is built on **TanStack Start** (Vite plugin + file-based routing), with **Convex** and **WorkOS AuthKit** integrated.

If you want to “convert basically EVERYTHING to Effect”, you’ll have the best results if you **start at the composition roots** (where global dependencies are created/wired) and then migrate inward (services → loaders/serverFns → components).

---

## Current State (2026-02-06)

- Effect scaffold exists in `apps/web/src/effect/*`:
  - `AppConfigService` (reads `VITE_CONVEX_URL`)
  - `TelemetryService` (console sink)
  - `AgentApiService` (typed Effect boundary for `/agents/*` endpoints)
  - `AgentRpcClientService` (typed `@effect/rpc` client for `/api/rpc`)
  - `makeAppRuntime()` (single `ManagedRuntime` for the app, created with a shared `MemoMap`)
  - `getServerRuntime()` (shared server runtime + `MemoMap` accessor for API handlers)
- `apps/web/src/router.tsx` creates the runtime and exposes it via router context (`effectRuntime`).
- `apps/web/src/start.ts` adds request middleware that:
  - creates a `requestId` and passes it into Start `serverContext`
  - emits a best-effort `TelemetryService` event (`http: request.start`)
- Effect RPC + atom hydration:
  - RPC is mounted at `POST /api/rpc` via `apps/web/src/routes/api.rpc.tsx` using `RpcServer.toWebHandler(...)` with `disableFatalDefects: true` and the shared `MemoMap`.
  - Example call site: `apps/web/src/routes/modules.tsx` uses `AgentRpcClientService` to fetch `agent.getModuleContracts`.
  - SSR atom hydration is wired in `apps/web/src/routes/__root.tsx`:
    - server fn `fetchWorkosAuth` produces a dehydrated `atomState` for `SessionAtom`
    - app is wrapped in `RegistryProvider` + `HydrationBoundary` so atoms are hydrated before child render

---

## What is the “entry point” here?

TanStack Start does not have a classic `src/main.tsx` or `index.html` entry file that you own. The Start Vite plugin bootstraps the runtime and then loads your app via its router config and route tree.

In *this* codebase, the earliest “entry” surfaces you own are:

- `apps/web/src/start.ts`
  - Creates the Start instance via `createStart(...)`
  - Wires request middleware (currently WorkOS `authkitMiddleware()`)
  - This is the **request pipeline seam** (good for request-scoped Effect runtime, logging/tracing, etc.)

- `apps/web/src/router.tsx`
  - `getRouter()` builds and returns the TanStack Router instance
  - Creates **Convex client**, **ConvexQueryClient**, and **React Query QueryClient**
  - Injects these into router `context`
  - This is the **primary composition root** (best first place to introduce Effect Layers/Services)

- `apps/web/src/routes/__root.tsx`
  - Defines the root route + app shell (providers, document layout)
  - Owns important cross-cutting wiring:
    - SSR/client boundary logic via `beforeLoad`
    - WorkOS server call via `createServerFn` + `getAuth()`
    - “set Convex auth token for SSR HTTP client” behavior
  - This is the **SSR/auth + provider seam**

Generated-but-informative:

- `apps/web/src/routeTree.gen.ts`
  - Autogenerated route tree + module augmentation that “registers” `getRouter()` and `startInstance`.

---

## Where to start the Effect migration (recommended)

### Start in `apps/web/src/router.tsx`

This file is already the place where the app constructs “global” dependencies (Convex + query clients) and pushes them into router context.

**Effect-first goal**: define an `AppLayer` (or similar) that provides:

- Configuration (`VITE_CONVEX_URL`, etc.)
- `ConvexReactClient`
- `ConvexQueryClient`
- `QueryClient`
- Any logging/telemetry service you want everywhere

Then `getRouter()` becomes a thin bridge that:

- Builds the Layer once per environment (server vs client) as appropriate
- Exposes the constructed dependencies through router context

This lets every route/component migrate at its own pace by reading from a unified “service surface” rather than importing singletons directly.

### Then adapt `apps/web/src/routes/__root.tsx`

This is where auth and SSR boundaries are currently handled. Once you have an Effect runtime/service surface, you can wrap:

- `createServerFn` handlers (server-side effects)
- `beforeLoad` logic (route “loader” effects)
- auth/token plumbing for Convex SSR HTTP client

Effect provides a consistent way to model:

- typed failures
- structured logging
- retries/timeouts (where appropriate)
- tracing/span context

### Use `apps/web/src/start.ts` for request-scoped concerns

If/when you want request-scoped context (trace IDs, per-request logging, cookie/session context), `start.ts` is a good place to bridge Start middleware into an Effect runtime for server requests.

---

## Suggested migration order (incremental, no big bang)

1. **Composition root**
   - Introduce Effect runtime + `AppLayer` in the web app, wired through `getRouter()` context.

2. **Service boundaries**
   - Wrap external boundaries behind services first:
     - Convex client
     - WorkOS auth (server: `getAuth`, client: hooks)
     - Environment/config (`import.meta.env`)
     - Telemetry/logging (see effect-telemetry-service in repo docs if present)

3. **Route loaders + serverFns**
   - Convert `loader` / `beforeLoad` / `createServerFn` logic to Effect programs.
   - Keep the public shape the same (Start expects promises), but run Effect inside.

4. **UI + components**
   - Only after services are clean: migrate components/hook usage.
   - Treat components as “dumb” view layer over Effect-backed hooks/services.

---

## What “success” looks like

- No route/module constructs “global” singletons ad hoc; everything is composed in one place (Layer).
- SSR/client behavior is explicit (separate Layers if needed).
- Auth/Convex/query wiring is not scattered; it’s services with small adapters.

---

## Routing, navigation, and avoiding full-page behavior

**How routing relates to Effect:** The router is created once in `getRouter()` and receives `effectRuntime: makeAppRuntime(appConfig)` in context. Every route and component that uses `router.options.context.effectRuntime` shares that same runtime (and thus the same app layer, RPC client, etc.). The RPC endpoint (`POST /api/rpc`) is just another route; page navigation does not touch it. So routing decides which page component and loaders run; Effect is in router context and used inside those.

**We do not do full browser reloads.** Navigation uses TanStack Router’s client-side routing (e.g. `<Link>`), so the document never reloads—only the tree under `<Outlet />` changes.

Two things can still feel heavy:

1. **Root `beforeLoad` runs on every navigation.** TanStack Router runs `beforeLoad` from root down on each navigation. We avoid refetching auth on every client-side navigation by caching the root auth result on the client (see `clientAuthCache` and `clearRootAuthCache()` in `apps/web/src/routes/__root.tsx`). On the server we always fetch; on the client we reuse the cache until sign-out or a full page load.
2. **App pages are direct children of root.** Routes like `/autopilot`, `/modules`, `/tools` are direct children of `__root__`, so the entire page component swaps on navigation. To get a persistent “app shell” (e.g. sidebar stays mounted, only main content changes), add a shared layout route (e.g. `_app` or `_dashboard`) that wraps those routes and renders a persistent shell + `<Outlet />` for the main content. Then only the outlet remounts when switching pages.

---

## Related references

- Full router + integration overview: [ROUTER-AND-APPS-WEB-INTEGRATION.md](./ROUTER-AND-APPS-WEB-INTEGRATION.md)
- RPC details: [effect-rpc-web.md](./effect-rpc-web.md)
- Effuse conversion: [effuse-conversion-apps-web.md](./effuse-conversion-apps-web.md)
