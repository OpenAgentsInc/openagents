import { spawnSync } from "child_process";
import { existsSync, readFileSync, writeFileSync } from "fs";
import path from "path";

type CommandResult = {
  name: string;
  ok: boolean;
  status: number | null;
  durationMs: number;
};

type CoverageTotals = {
  linesFound: number;
  linesHit: number;
  branchesFound: number;
  branchesHit: number;
};

type CoverageReport = Record<string, CoverageTotals>;

const commands: Array<{ name: string; cmd: string[] }> = [
  { name: "typecheck", cmd: ["bun", "run", "typecheck"] },
  { name: "tests", cmd: ["bun", "test", "--coverage", "--coverage-reporter=lcov"] },
];

const CATEGORY_RULES: Array<{ id: string; test: (file: string) => boolean }> = [
  { id: "agent", test: (file) => /src[\\/]+agent[\\/]+/.test(file) },
  { id: "tools", test: (file) => /src[\\/]+tools[\\/]+/.test(file) },
  { id: "tasks", test: (file) => /src[\\/]+tasks[\\/]+/.test(file) },
];

function runCommand(def: { name: string; cmd: string[] }): CommandResult {
  const started = Date.now();
  const result = spawnSync(def.cmd[0]!, def.cmd.slice(1), { stdio: "inherit" });
  return {
    name: def.name,
    ok: result.status === 0,
    status: result.status,
    durationMs: Date.now() - started,
  };
}

function ensureCommandsPass(results: CommandResult[]): void {
  const failed = results.filter((r) => !r.ok);
  if (failed.length > 0) {
    const names = failed.map((r) => r.name).join(", ");
    throw new Error(`Build health generation failed: ${names}`);
  }
}

function parseLcov(lcovPath: string): CoverageReport {
  if (!existsSync(lcovPath)) {
    throw new Error(`Coverage file not found at ${lcovPath}`);
  }

  const content = readFileSync(lcovPath, "utf8");
  const records = content.split("end_of_record").map((r) => r.trim());

  const totals: CoverageReport = {
    overall: {
      linesFound: 0,
      linesHit: 0,
      branchesFound: 0,
      branchesHit: 0,
    },
  };

  for (const rule of CATEGORY_RULES) {
    totals[rule.id] = {
      linesFound: 0,
      linesHit: 0,
      branchesFound: 0,
      branchesHit: 0,
    };
  }

  for (const record of records) {
    if (!record) continue;

    let file = "";
    let linesFound = 0;
    let linesHit = 0;
    let branchesFound = 0;
    let branchesHit = 0;

    for (const line of record.split("\n")) {
      if (line.startsWith("SF:")) file = line.slice(3).trim();
      else if (line.startsWith("LF:")) linesFound = Number(line.slice(3));
      else if (line.startsWith("LH:")) linesHit = Number(line.slice(3));
      else if (line.startsWith("BRF:")) branchesFound = Number(line.slice(4));
      else if (line.startsWith("BRH:")) branchesHit = Number(line.slice(4));
    }

    totals.overall.linesFound += linesFound;
    totals.overall.linesHit += linesHit;
    totals.overall.branchesFound += branchesFound;
    totals.overall.branchesHit += branchesHit;

    for (const rule of CATEGORY_RULES) {
      if (rule.test(file)) {
        const bucket = totals[rule.id]!;
        bucket.linesFound += linesFound;
        bucket.linesHit += linesHit;
        bucket.branchesFound += branchesFound;
        bucket.branchesHit += branchesHit;
      }
    }
  }

  return totals;
}

function percent(hit: number, found: number): number {
  if (found === 0) return 100;
  return (hit / found) * 100;
}

function formatPercent(hit: number, found: number): string {
  if (found === 0) return `n/a (${hit}/${found})`;
  return `${percent(hit, found).toFixed(1)}% (${hit}/${found})`;
}

function renderCoverageTable(report: CoverageReport): string {
  const rows = ["| Area | Lines | Branches |", "| --- | --- | --- |"];
  const entries = Object.entries(report);
  const ordered = entries.sort(([a], [b]) => (a === "overall" ? -1 : b === "overall" ? 1 : a.localeCompare(b)));

  for (const [key, totals] of ordered) {
    rows.push(
      `| ${key} | ${formatPercent(totals.linesHit, totals.linesFound)} | ${formatPercent(totals.branchesHit, totals.branchesFound)} |`,
    );
  }

  return rows.join("\n");
}

function renderMarkdown(options: {
  generatedAt: string;
  results: CommandResult[];
  coverage: CoverageReport;
}): string {
  const [typecheck, tests] = options.results;
  const lines: string[] = [];
  lines.push("# Build Health");
  lines.push("");
  lines.push("_Generated by scripts/generate-build-health.ts_");
  lines.push("");
  lines.push(`- Generated at: ${options.generatedAt}`);
  lines.push(`- Typecheck: ${typecheck.ok ? "passed" : "failed"} (${(typecheck.durationMs / 1000).toFixed(1)}s)`);
  lines.push(`- Tests: ${tests.ok ? "passed" : "failed"} (${(tests.durationMs / 1000).toFixed(1)}s with coverage)`);
  lines.push("");
  lines.push("## Coverage");
  lines.push("");
  lines.push(renderCoverageTable(options.coverage));
  lines.push("");
  lines.push("## How to regenerate");
  lines.push("");
  lines.push("```bash");
  lines.push("bun run build:health");
  lines.push("```");
  lines.push("");
  lines.push("Outputs:");
  lines.push("- docs/build-health.md (this file)");
  lines.push("- docs/build-health.json (machine-readable summary)");
  lines.push("- coverage/lcov.info (lcov report)");

  return lines.join("\n");
}

function main(): void {
  const results = commands.map(runCommand);
  ensureCommandsPass(results);

  const lcovPath = path.join("coverage", "lcov.info");
  const coverage = parseLcov(lcovPath);

  const payload = {
    generatedAt: new Date().toISOString(),
    results,
    coverage,
  };

  writeFileSync("docs/build-health.json", JSON.stringify(payload, null, 2));
  writeFileSync("docs/build-health.md", renderMarkdown(payload));
  console.log("Wrote docs/build-health.md and docs/build-health.json");
}

main();
