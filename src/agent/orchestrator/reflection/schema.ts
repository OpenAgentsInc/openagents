/**
 * Reflection Schema Types
 *
 * Effect/Schema definitions for the Reflexion pattern.
 * Stores verbal self-reflections on failed task attempts.
 */
import * as S from "effect/Schema";

// ============================================================================
// Reflection Schema
// ============================================================================

/**
 * Category of the failure reflection.
 */
export const ReflectionCategory = S.Literal(
  "root_cause", // What caused the failure
  "misconception", // What the agent misunderstood
  "environment", // Environment/dependency issues
  "approach_error", // Wrong approach taken
  "edge_case", // Missed edge case
  "verification" // Verification-specific insight
);
export type ReflectionCategory = S.Schema.Type<typeof ReflectionCategory>;

/**
 * A reflection on a failed subtask attempt.
 * Generated by LLM analysis of the failure.
 */
export const Reflection = S.Struct({
  /** Unique ID for this reflection (ref-<hash>) */
  id: S.String,
  /** Session ID where the reflection was generated */
  sessionId: S.String,
  /** Task ID this reflection belongs to */
  taskId: S.String,
  /** Subtask ID this reflection is for */
  subtaskId: S.String,
  /** Which attempt number this reflection is from (1-indexed) */
  attemptNumber: S.Number,
  /** Category of the failure */
  category: ReflectionCategory,
  /** What went wrong (1-2 sentences) */
  analysis: S.String,
  /** What to do differently (1-2 sentences) */
  suggestion: S.String,
  /** Specific action items for next attempt */
  actionItems: S.Array(S.String),
  /** Confidence score 0-1 */
  confidence: S.Number,
  /** ISO timestamp when reflection was created */
  createdAt: S.String,
});
export type Reflection = S.Schema.Type<typeof Reflection>;

// ============================================================================
// FailureContext Schema
// ============================================================================

/**
 * Type of failure that triggered the reflection.
 */
export const FailureType = S.Literal(
  "test_failure",
  "typecheck_failure",
  "runtime_error",
  "timeout",
  "verification_failed"
);
export type FailureType = S.Schema.Type<typeof FailureType>;

/**
 * Context about a failure, used to generate a reflection.
 */
export const FailureContext = S.Struct({
  /** Unique ID for this failure context */
  id: S.String,
  /** Session ID where the failure occurred */
  sessionId: S.String,
  /** Task ID */
  taskId: S.String,
  /** Subtask ID */
  subtaskId: S.String,
  /** Description of what the subtask was trying to do */
  subtaskDescription: S.String,
  /** Which attempt number this is (1-indexed) */
  attemptNumber: S.Number,
  /** Type of failure */
  failureType: FailureType,
  /** Error output (truncated if needed) */
  errorOutput: S.String,
  /** Files that were modified in this attempt */
  filesModified: S.Array(S.String),
  /** Previous reflections to avoid repetition */
  previousReflections: S.Array(S.String),
  /** ISO timestamp */
  createdAt: S.String,
});
export type FailureContext = S.Schema.Type<typeof FailureContext>;

// ============================================================================
// Configuration Schema
// ============================================================================

/**
 * Configuration for the Reflexion feature.
 * Added to ProjectConfig.
 */
export const ReflexionConfig = S.Struct({
  /** Whether Reflexion is enabled (default: true) */
  enabled: S.optionalWith(S.Boolean, { default: () => true }),
  /** Maximum reflections to include per retry (default: 3) */
  maxReflectionsPerRetry: S.optionalWith(S.Number, { default: () => 3 }),
  /** Timeout for reflection generation in ms (default: 30000) */
  generationTimeoutMs: S.optionalWith(S.Number, { default: () => 30000 }),
});
export type ReflexionConfig = S.Schema.Type<typeof ReflexionConfig>;
