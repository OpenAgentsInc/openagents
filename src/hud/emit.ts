/**
 * HUD Emit Helpers
 *
 * Converts OrchestratorEvents to HudMessages and sends them via HudClient.
 * Use createHudEmitter() to get an emit function compatible with runOrchestrator().
 *
 * ## Golden Loop Phase â†’ HUD Event Mapping
 *
 * The orchestrator emits events during each phase of the Golden Loop. This module
 * filters and transforms those events for display in the HUD UI.
 *
 * | Golden Loop Phase | OrchestratorEvent(s)              | HudMessage(s)                |
 * |-------------------|-----------------------------------|------------------------------|
 * | Session Start     | session_start                     | session_start                |
 * | Orient            | lock_acquired, init_script_*,     | (none - internal only)       |
 * |                   | orientation_complete              |                              |
 * | Select Task       | task_selected                     | task_selected                |
 * | Decompose         | task_decomposed                   | task_decomposed              |
 * | Execute           | subtask_start, subtask_complete,  | subtask_start,               |
 * |                   | subtask_failed                    | subtask_complete,            |
 * |                   |                                   | subtask_failed               |
 * | Verify            | verification_start,               | verification_start,          |
 * |                   | verification_complete             | verification_complete        |
 * | Commit            | commit_created, push_complete     | commit_created, push_complete|
 * | Update            | task_updated, progress_written    | (none - internal only)       |
 * | Session End       | session_complete                  | session_complete             |
 * | Errors            | error                             | error                        |
 *
 * ## Filtered Events (Internal Only)
 *
 * The following events are NOT forwarded to the HUD (they're internal bookkeeping):
 * - orientation_complete: Repo state assessment (internal)
 * - init_script_start/complete: Preflight script execution (internal)
 * - task_updated: Task status changes (shown via task_selected/decomposed)
 * - progress_written: Progress file updates (internal)
 * - lock_acquired/released/failed/stale_removed: Lock management (internal)
 *
 * ## Streaming Output
 *
 * In addition to phase events, the HUD receives streaming text output via
 * text_output messages. These are generated by createHudOutputCallback() and
 * include the source (claude-code, minimal, or orchestrator).
 *
 * ## Usage
 *
 * ```typescript
 * import { createHudCallbacks } from "./emit.js";
 *
 * const { emit, onOutput, client } = createHudCallbacks();
 *
 * // Pass emit to orchestrator
 * runOrchestrator({ ...config, onOutput }, emit);
 *
 * // Clean up when done
 * client.close();
 * ```
 *
 * @see emit.test.ts for sample event sequences and assertions
 * @see protocol.ts for HudMessage type definitions
 */

import type { OrchestratorEvent } from "../agent/orchestrator/types.js";
import type {
  HudMessage,
  HudTaskInfo,
  HudSubtaskInfo,
  HudSubagentResult,
  APMUpdateMessage,
  APMSnapshotMessage,
} from "./protocol.js";
import { HudClient, getHudClient, type HudClientOptions } from "./client.js";
import type { APMCollector } from "../agent/apm.js";
import type { APMBySource } from "../agent/apm.js";
import { StatusStreamServer, type StatusStreamOptions } from "./status-stream.js";

/**
 * Convert an OrchestratorEvent to a HudMessage.
 *
 * This is the core mapping function that determines which orchestrator events
 * are relevant for UI display and transforms them into the HUD protocol format.
 *
 * @param event - The orchestrator event to convert
 * @returns The corresponding HudMessage, or null if the event should not be forwarded
 *
 * @example
 * ```typescript
 * const event: OrchestratorEvent = { type: "task_selected", task: myTask };
 * const hudMsg = orchestratorEventToHudMessage(event);
 * // hudMsg = { type: "task_selected", task: { id, title, status, priority } }
 * ```
 */
export const orchestratorEventToHudMessage = (event: OrchestratorEvent): HudMessage | null => {
  switch (event.type) {
    case "session_start":
      return {
        type: "session_start",
        sessionId: event.sessionId,
        timestamp: event.timestamp,
      };

    case "session_complete":
      return {
        type: "session_complete",
        success: event.success,
        summary: event.summary,
      };

    case "task_selected": {
      const task: HudTaskInfo = {
        id: event.task.id,
        title: event.task.title,
        status: event.task.status,
        priority: event.task.priority,
      };
      return { type: "task_selected", task };
    }

    case "task_decomposed": {
      const subtasks: HudSubtaskInfo[] = event.subtasks.map((s) => ({
        id: s.id,
        description: s.description,
        status: s.status,
      }));
      return { type: "task_decomposed", subtasks };
    }

    case "subtask_start": {
      const subtask: HudSubtaskInfo = {
        id: event.subtask.id,
        description: event.subtask.description,
        status: event.subtask.status,
      };
      return { type: "subtask_start", subtask };
    }

    case "subtask_complete": {
      const subtask: HudSubtaskInfo = {
        id: event.subtask.id,
        description: event.subtask.description,
        status: event.subtask.status,
      };
      const result: HudSubagentResult = {
        success: event.result.success,
        filesModified: event.result.filesModified,
        turns: event.result.turns,
        ...(event.result.agent ? { agent: event.result.agent } : {}),
        ...(event.result.error ? { error: event.result.error } : {}),
      };
      return { type: "subtask_complete", subtask, result };
    }

    case "subtask_failed": {
      const subtask: HudSubtaskInfo = {
        id: event.subtask.id,
        description: event.subtask.description,
        status: event.subtask.status,
      };
      return { type: "subtask_failed", subtask, error: event.error };
    }

    case "verification_start":
      return { type: "verification_start", command: event.command };

    case "verification_complete":
      return {
        type: "verification_complete",
        command: event.command,
        passed: event.passed,
        output: event.output,
      };

    case "commit_created":
      return {
        type: "commit_created",
        sha: event.sha,
        message: event.message,
      };

    case "push_complete":
      return { type: "push_complete", branch: event.branch };

    case "error":
      return {
        type: "error",
        phase: event.phase,
        error: event.error,
      };

    // Events we don't forward to HUD (internal or not useful for display)
    case "orientation_complete":
    case "init_script_start":
    case "init_script_complete":
    case "task_updated":
    case "progress_written":
    case "lock_acquired":
    case "lock_stale_removed":
    case "lock_failed":
    case "lock_released":
      return null;
  }
};

/**
 * Create an emit function that sends OrchestratorEvents to the HUD.
 *
 * Usage:
 *   const emit = createHudEmitter();
 *   runOrchestrator(config, emit);
 */
export const createHudEmitter = (
  clientOptions?: HudClientOptions
): ((event: OrchestratorEvent) => void) => {
  const client = getHudClient(clientOptions);

  return (event: OrchestratorEvent) => {
    const hudMessage = orchestratorEventToHudMessage(event);
    if (hudMessage) {
      client.send(hudMessage);
    }
  };
};

/**
 * Create an output callback that sends streaming text to the HUD.
 *
 * Usage:
 *   const onOutput = createHudOutputCallback();
 *   runOrchestrator({ ...config, onOutput });
 */
export const createHudOutputCallback = (
  clientOptions?: HudClientOptions,
  source: "claude-code" | "minimal" | "orchestrator" = "claude-code"
): ((text: string) => void) => {
  const client = getHudClient(clientOptions);

  return (text: string) => {
    client.send({
      type: "text_output",
      text,
      source,
    });
  };
};

/**
 * Create both an emit function and an onOutput callback that share the same client.
 *
 * Usage:
 *   const { emit, onOutput, client } = createHudCallbacks();
 *   runOrchestrator({ ...config, onOutput }, emit);
 *   // Later:
 *   client.close();
 */
export interface HudCallbackOptions extends HudClientOptions {
  statusStream?: StatusStreamOptions & { enabled?: boolean };
}

export const createHudCallbacks = (options?: HudCallbackOptions) => {
  const client = new HudClient(options);
  const envEnabled = process.env.STATUS_STREAM_ENABLED?.toLowerCase() === "true";
  const streamEnabled = options?.statusStream?.enabled ?? envEnabled ?? false;
  const statusOpts: StatusStreamOptions = {
    ...(options?.statusStream?.port !== undefined ? { port: options.statusStream.port } : {}),
    ...(options?.statusStream?.token !== undefined ? { token: options.statusStream.token } : {}),
    ...(options?.statusStream?.verbose !== undefined ? { verbose: options.statusStream.verbose } : {}),
  };
  const statusStream = streamEnabled ? new StatusStreamServer(statusOpts) : null;

  const emit = (event: OrchestratorEvent) => {
    const hudMessage = orchestratorEventToHudMessage(event);
    if (hudMessage) {
      client.send(hudMessage);
      statusStream?.broadcast(hudMessage);
    }
  };

  const onOutput = (text: string) => {
    const msg: HudMessage = {
      type: "text_output",
      text,
      source: "claude-code",
    };
    client.send(msg);
    statusStream?.broadcast(msg);
  };

  return { emit, onOutput, client, statusStream };
};

// ============================================================================
// APM Emitters
// ============================================================================

const APM_UPDATE_INTERVAL = 30000; // 30 seconds

/**
 * Create an APM emitter that sends periodic updates to the HUD.
 *
 * Call the returned function periodically (or after significant actions)
 * to update the HUD with current APM metrics.
 *
 * @example
 * ```typescript
 * const apmEmit = createAPMEmitter(client, collector);
 *
 * // In orchestrator loop:
 * apmEmit(); // Sends update if interval elapsed
 * apmEmit(true); // Force send regardless of interval
 * ```
 */
export const createAPMEmitter = (
  client: HudClient,
  collector: APMCollector,
): ((force?: boolean) => void) => {
  let lastUpdate = 0;

  return (force = false) => {
    const now = Date.now();
    if (!force && now - lastUpdate < APM_UPDATE_INTERVAL) return;
    lastUpdate = now;

    const message: APMUpdateMessage = {
      type: "apm_update",
      sessionId: (collector as any).sessionId,
      sessionAPM: collector.getSessionAPM(),
      recentAPM: collector.getRecentAPM(5),
      totalActions: (collector as any).actions?.length ?? 0,
      durationMinutes: (Date.now() - (collector as any).startMs) / 60000,
    };

    client.send(message);
  };
};

/**
 * Send an APM snapshot with historical data to the HUD.
 *
 * Call this at session start/end to provide full context.
 */
export const sendAPMSnapshot = (
  client: HudClient,
  stats: APMBySource,
): void => {
  const message: APMSnapshotMessage = {
    type: "apm_snapshot",
    combined: {
      apm1h: stats.combined.apm1h,
      apm6h: stats.combined.apm6h,
      apm1d: stats.combined.apm1d,
      apm1w: stats.combined.apm1w,
      apm1m: stats.combined.apm1m,
      apmLifetime: stats.combined.apmLifetime,
      totalSessions: stats.combined.totalSessions,
      totalActions: stats.combined.totalMessages + stats.combined.totalToolCalls,
    },
    comparison: {
      claudeCodeAPM: stats.claudeCode.apmLifetime,
      mechaCoderAPM: stats.mechaCoder.apmLifetime,
      efficiencyRatio: stats.comparison.efficiencyRatio,
    },
  };

  client.send(message);
};

/**
 * Extended HUD callbacks including APM support.
 *
 * @example
 * ```typescript
 * const { emit, onOutput, client, apmCollector, apmEmit } = createHudCallbacksWithAPM({
 *   sessionId: "session-123",
 *   projectName: "openagents",
 * });
 *
 * runOrchestrator({ ...config, onOutput }, (event) => {
 *   emit(event);
 *   if (event.type === "subtask_complete") {
 *     apmCollector.recordAction("tool_call");
 *     apmEmit();
 *   }
 * });
 * ```
 */
export const createHudCallbacksWithAPM = (
  options: HudClientOptions & { sessionId: string; projectName: string },
) => {
  // Import APMCollector dynamically to avoid circular dependency issues
  const { APMCollector } = require("../agent/apm.js") as typeof import("../agent/apm.js");

  const client = new HudClient(options);
  const apmCollector = new APMCollector(options.sessionId, options.projectName);

  const emit = (event: OrchestratorEvent) => {
    const hudMessage = orchestratorEventToHudMessage(event);
    if (hudMessage) {
      client.send(hudMessage);
    }
  };

  const onOutput = (text: string) => {
    client.send({
      type: "text_output",
      text,
      source: "claude-code",
    });
  };

  const apmEmit = createAPMEmitter(client, apmCollector);

  return { emit, onOutput, client, apmCollector, apmEmit };
};
