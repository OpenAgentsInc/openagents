(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __moduleCache = /* @__PURE__ */ new WeakMap;
  var __toCommonJS = (from) => {
    var entry = __moduleCache.get(from), desc;
    if (entry)
      return entry;
    entry = __defProp({}, "__esModule", { value: true });
    if (from && typeof from === "object" || typeof from === "function")
      __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
        get: () => from[key],
        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
      }));
    __moduleCache.set(from, entry);
    return entry;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, {
        get: all[name],
        enumerable: true,
        configurable: true,
        set: (newValue) => all[name] = () => newValue
      });
  };

  // src/mainview/effuse-main.ts
  var exports_effuse_main = {};
  __export(exports_effuse_main, {
    initEffuse: () => initEffuse
  });

  // node_modules/effect/dist/esm/Function.js
  var isFunction = (input) => typeof input === "function";
  var dual = function(arity, body) {
    if (typeof arity === "function") {
      return function() {
        if (arity(arguments)) {
          return body.apply(this, arguments);
        }
        return (self) => body(self, ...arguments);
      };
    }
    switch (arity) {
      case 0:
      case 1:
        throw new RangeError(`Invalid arity ${arity}`);
      case 2:
        return function(a, b) {
          if (arguments.length >= 2) {
            return body(a, b);
          }
          return function(self) {
            return body(self, a);
          };
        };
      case 3:
        return function(a, b, c) {
          if (arguments.length >= 3) {
            return body(a, b, c);
          }
          return function(self) {
            return body(self, a, b);
          };
        };
      case 4:
        return function(a, b, c, d) {
          if (arguments.length >= 4) {
            return body(a, b, c, d);
          }
          return function(self) {
            return body(self, a, b, c);
          };
        };
      case 5:
        return function(a, b, c, d, e) {
          if (arguments.length >= 5) {
            return body(a, b, c, d, e);
          }
          return function(self) {
            return body(self, a, b, c, d);
          };
        };
      default:
        return function() {
          if (arguments.length >= arity) {
            return body.apply(this, arguments);
          }
          const args = arguments;
          return function(self) {
            return body(self, ...args);
          };
        };
    }
  };
  var identity = (a) => a;
  var constant = (value) => () => value;
  var constTrue = /* @__PURE__ */ constant(true);
  var constFalse = /* @__PURE__ */ constant(false);
  var constUndefined = /* @__PURE__ */ constant(undefined);
  var constVoid = constUndefined;
  function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
    switch (arguments.length) {
      case 1:
        return a;
      case 2:
        return ab(a);
      case 3:
        return bc(ab(a));
      case 4:
        return cd(bc(ab(a)));
      case 5:
        return de(cd(bc(ab(a))));
      case 6:
        return ef(de(cd(bc(ab(a)))));
      case 7:
        return fg(ef(de(cd(bc(ab(a))))));
      case 8:
        return gh(fg(ef(de(cd(bc(ab(a)))))));
      case 9:
        return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
      default: {
        let ret = arguments[0];
        for (let i = 1;i < arguments.length; i++) {
          ret = arguments[i](ret);
        }
        return ret;
      }
    }
  }
  // node_modules/effect/dist/esm/Equivalence.js
  var make = (isEquivalent) => (self, that) => self === that || isEquivalent(self, that);
  var isStrictEquivalent = (x, y) => x === y;
  var strict = () => isStrictEquivalent;
  var number = /* @__PURE__ */ strict();
  var mapInput = /* @__PURE__ */ dual(2, (self, f) => make((x, y) => self(f(x), f(y))));
  var Date2 = /* @__PURE__ */ mapInput(number, (date) => date.getTime());
  var array = (item) => make((self, that) => {
    if (self.length !== that.length) {
      return false;
    }
    for (let i = 0;i < self.length; i++) {
      const isEq = item(self[i], that[i]);
      if (!isEq) {
        return false;
      }
    }
    return true;
  });

  // node_modules/effect/dist/esm/internal/doNotation.js
  var let_ = (map) => dual(3, (self, name, f) => map(self, (a) => ({
    ...a,
    [name]: f(a)
  })));
  var bindTo = (map) => dual(2, (self, name) => map(self, (a) => ({
    [name]: a
  })));
  var bind = (map, flatMap) => dual(3, (self, name, f) => flatMap(self, (a) => map(f(a), (b) => ({
    ...a,
    [name]: b
  }))));

  // node_modules/effect/dist/esm/GlobalValue.js
  var globalStoreId = `effect/GlobalValue`;
  var globalStore;
  var globalValue = (id, compute) => {
    if (!globalStore) {
      globalThis[globalStoreId] ??= new Map;
      globalStore = globalThis[globalStoreId];
    }
    if (!globalStore.has(id)) {
      globalStore.set(id, compute());
    }
    return globalStore.get(id);
  };

  // node_modules/effect/dist/esm/Predicate.js
  var isString = (input) => typeof input === "string";
  var isNumber = (input) => typeof input === "number";
  var isBoolean = (input) => typeof input === "boolean";
  var isBigInt = (input) => typeof input === "bigint";
  var isSymbol = (input) => typeof input === "symbol";
  var isFunction2 = isFunction;
  var isUndefined = (input) => input === undefined;
  var isNever = (_) => false;
  var isRecordOrArray = (input) => typeof input === "object" && input !== null;
  var isObject = (input) => isRecordOrArray(input) || isFunction2(input);
  var hasProperty = /* @__PURE__ */ dual(2, (self, property) => isObject(self) && (property in self));
  var isTagged = /* @__PURE__ */ dual(2, (self, tag) => hasProperty(self, "_tag") && self["_tag"] === tag);
  var isNullable = (input) => input === null || input === undefined;
  var isNotNullable = (input) => input !== null && input !== undefined;
  var isDate = (input) => input instanceof Date;
  var isIterable = (input) => typeof input === "string" || hasProperty(input, Symbol.iterator);
  var isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);
  var isPromiseLike = (input) => hasProperty(input, "then") && isFunction2(input.then);

  // node_modules/effect/dist/esm/internal/errors.js
  var getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

  // node_modules/effect/dist/esm/Utils.js
  class SingleShotGen {
    self;
    called = false;
    constructor(self) {
      this.self = self;
    }
    next(a) {
      return this.called ? {
        value: a,
        done: true
      } : (this.called = true, {
        value: this.self,
        done: false
      });
    }
    return(a) {
      return {
        value: a,
        done: true
      };
    }
    throw(e) {
      throw e;
    }
    [Symbol.iterator]() {
      return new SingleShotGen(this.self);
    }
  }
  var defaultIncHi = 335903614;
  var defaultIncLo = 4150755663;
  var MUL_HI = 1481765933 >>> 0;
  var MUL_LO = 1284865837 >>> 0;
  var BIT_53 = 9007199254740992;
  var BIT_27 = 134217728;

  class PCGRandom {
    _state;
    constructor(seedHi, seedLo, incHi, incLo) {
      if (isNullable(seedLo) && isNullable(seedHi)) {
        seedLo = Math.random() * 4294967295 >>> 0;
        seedHi = 0;
      } else if (isNullable(seedLo)) {
        seedLo = seedHi;
        seedHi = 0;
      }
      if (isNullable(incLo) && isNullable(incHi)) {
        incLo = this._state ? this._state[3] : defaultIncLo;
        incHi = this._state ? this._state[2] : defaultIncHi;
      } else if (isNullable(incLo)) {
        incLo = incHi;
        incHi = 0;
      }
      this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
      this._next();
      add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
      this._next();
      return this;
    }
    getState() {
      return [this._state[0], this._state[1], this._state[2], this._state[3]];
    }
    setState(state) {
      this._state[0] = state[0];
      this._state[1] = state[1];
      this._state[2] = state[2];
      this._state[3] = state[3] | 1;
    }
    integer(max) {
      return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max;
    }
    number() {
      const hi = (this._next() & 67108863) * 1;
      const lo = (this._next() & 134217727) * 1;
      return (hi * BIT_27 + lo) / BIT_53;
    }
    _next() {
      const oldHi = this._state[0] >>> 0;
      const oldLo = this._state[1] >>> 0;
      mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
      add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
      let xsHi = oldHi >>> 18;
      let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
      xsHi = (xsHi ^ oldHi) >>> 0;
      xsLo = (xsLo ^ oldLo) >>> 0;
      const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
      const rot = oldHi >>> 27;
      const rot2 = (-rot >>> 0 & 31) >>> 0;
      return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
    }
  }
  function mul64(out, aHi, aLo, bHi, bLo) {
    let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
    let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
    let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
    let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
    c0 = c0 << 16 >>> 0;
    lo = lo + c0 >>> 0;
    if (lo >>> 0 < c0 >>> 0) {
      hi = hi + 1 >>> 0;
    }
    c1 = c1 << 16 >>> 0;
    lo = lo + c1 >>> 0;
    if (lo >>> 0 < c1 >>> 0) {
      hi = hi + 1 >>> 0;
    }
    hi = hi + Math.imul(aLo, bHi) >>> 0;
    hi = hi + Math.imul(aHi, bLo) >>> 0;
    out[0] = hi;
    out[1] = lo;
  }
  function add64(out, aHi, aLo, bHi, bLo) {
    let hi = aHi + bHi >>> 0;
    const lo = aLo + bLo >>> 0;
    if (lo >>> 0 < aLo >>> 0) {
      hi = hi + 1 | 0;
    }
    out[0] = hi;
    out[1] = lo;
  }
  var YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");

  class YieldWrap {
    #value;
    constructor(value) {
      this.#value = value;
    }
    [YieldWrapTypeId]() {
      return this.#value;
    }
  }
  function yieldWrapGet(self) {
    if (typeof self === "object" && self !== null && YieldWrapTypeId in self) {
      return self[YieldWrapTypeId]();
    }
    throw new Error(getBugErrorMessage("yieldWrapGet"));
  }
  var structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
    enabled: false,
    tester: undefined
  }));
  var standard = {
    effect_internal_function: (body) => {
      return body();
    }
  };
  var forced = {
    effect_internal_function: (body) => {
      try {
        return body();
      } finally {}
    }
  };
  var isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
  var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
  var genConstructor = function* () {}.constructor;
  var isGeneratorFunction = (u) => isObject(u) && u.constructor === genConstructor;

  // node_modules/effect/dist/esm/Hash.js
  var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => new WeakMap);
  var symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
  var hash = (self) => {
    if (structuralRegionState.enabled === true) {
      return 0;
    }
    switch (typeof self) {
      case "number":
        return number2(self);
      case "bigint":
        return string(self.toString(10));
      case "boolean":
        return string(String(self));
      case "symbol":
        return string(String(self));
      case "string":
        return string(self);
      case "undefined":
        return string("undefined");
      case "function":
      case "object": {
        if (self === null) {
          return string("null");
        } else if (self instanceof Date) {
          return hash(self.toISOString());
        } else if (self instanceof URL) {
          return hash(self.href);
        } else if (isHash(self)) {
          return self[symbol]();
        } else {
          return random(self);
        }
      }
      default:
        throw new Error(`BUG: unhandled typeof ${typeof self} - please report an issue at https://github.com/Effect-TS/effect/issues`);
    }
  };
  var random = (self) => {
    if (!randomHashCache.has(self)) {
      randomHashCache.set(self, number2(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
    }
    return randomHashCache.get(self);
  };
  var combine = (b) => (self) => self * 53 ^ b;
  var optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
  var isHash = (u) => hasProperty(u, symbol);
  var number2 = (n) => {
    if (n !== n || n === Infinity) {
      return 0;
    }
    let h = n | 0;
    if (h !== n) {
      h ^= n * 4294967295;
    }
    while (n > 4294967295) {
      h ^= n /= 4294967295;
    }
    return optimize(h);
  };
  var string = (str) => {
    let h = 5381, i = str.length;
    while (i) {
      h = h * 33 ^ str.charCodeAt(--i);
    }
    return optimize(h);
  };
  var structureKeys = (o, keys) => {
    let h = 12289;
    for (let i = 0;i < keys.length; i++) {
      h ^= pipe(string(keys[i]), combine(hash(o[keys[i]])));
    }
    return optimize(h);
  };
  var structure = (o) => structureKeys(o, Object.keys(o));
  var array2 = (arr) => {
    let h = 6151;
    for (let i = 0;i < arr.length; i++) {
      h = pipe(h, combine(hash(arr[i])));
    }
    return optimize(h);
  };
  var cached = function() {
    if (arguments.length === 1) {
      const self2 = arguments[0];
      return function(hash3) {
        Object.defineProperty(self2, symbol, {
          value() {
            return hash3;
          },
          enumerable: false
        });
        return hash3;
      };
    }
    const self = arguments[0];
    const hash2 = arguments[1];
    Object.defineProperty(self, symbol, {
      value() {
        return hash2;
      },
      enumerable: false
    });
    return hash2;
  };

  // node_modules/effect/dist/esm/Equal.js
  var symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
  function equals() {
    if (arguments.length === 1) {
      return (self) => compareBoth(self, arguments[0]);
    }
    return compareBoth(arguments[0], arguments[1]);
  }
  function compareBoth(self, that) {
    if (self === that) {
      return true;
    }
    const selfType = typeof self;
    if (selfType !== typeof that) {
      return false;
    }
    if (selfType === "object" || selfType === "function") {
      if (self !== null && that !== null) {
        if (isEqual(self) && isEqual(that)) {
          if (hash(self) === hash(that) && self[symbol2](that)) {
            return true;
          } else {
            return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
          }
        } else if (self instanceof Date && that instanceof Date) {
          return self.toISOString() === that.toISOString();
        } else if (self instanceof URL && that instanceof URL) {
          return self.href === that.href;
        }
      }
      if (structuralRegionState.enabled) {
        if (Array.isArray(self) && Array.isArray(that)) {
          return self.length === that.length && self.every((v, i) => compareBoth(v, that[i]));
        }
        if (Object.getPrototypeOf(self) === Object.prototype && Object.getPrototypeOf(self) === Object.prototype) {
          const keysSelf = Object.keys(self);
          const keysThat = Object.keys(that);
          if (keysSelf.length === keysThat.length) {
            for (const key of keysSelf) {
              if (!((key in that) && compareBoth(self[key], that[key]))) {
                return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
              }
            }
            return true;
          }
        }
        return structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
      }
    }
    return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self, that) : false;
  }
  var isEqual = (u) => hasProperty(u, symbol2);
  var equivalence = () => equals;

  // node_modules/effect/dist/esm/Inspectable.js
  var NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
  var toJSON = (x) => {
    try {
      if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
        return x.toJSON();
      } else if (Array.isArray(x)) {
        return x.map(toJSON);
      }
    } catch {
      return {};
    }
    return redact(x);
  };
  var CIRCULAR = "[Circular]";
  function formatDate(date) {
    try {
      return date.toISOString();
    } catch {
      return "Invalid Date";
    }
  }
  function safeToString(input) {
    try {
      const s = input.toString();
      return typeof s === "string" ? s : String(s);
    } catch {
      return "[toString threw]";
    }
  }
  function formatPropertyKey(name) {
    return isString(name) ? JSON.stringify(name) : String(name);
  }
  function formatUnknown(input, options) {
    const space = options?.space ?? 0;
    const seen = new WeakSet;
    const gap = !space ? "" : isNumber(space) ? " ".repeat(space) : space;
    const ind = (d) => gap.repeat(d);
    const wrap = (v, body) => {
      const ctor = v?.constructor;
      return ctor && ctor !== Object.prototype.constructor && ctor.name ? `${ctor.name}(${body})` : body;
    };
    const ownKeys = (o) => {
      try {
        return Reflect.ownKeys(o);
      } catch {
        return ["[ownKeys threw]"];
      }
    };
    function go(v, d = 0) {
      if (Array.isArray(v)) {
        if (seen.has(v))
          return CIRCULAR;
        seen.add(v);
        if (!gap || v.length <= 1)
          return `[${v.map((x) => go(x, d)).join(",")}]`;
        const inner = v.map((x) => go(x, d + 1)).join(`,
` + ind(d + 1));
        return `[
${ind(d + 1)}${inner}
${ind(d)}]`;
      }
      if (isDate(v))
        return formatDate(v);
      if (!options?.ignoreToString && hasProperty(v, "toString") && isFunction2(v["toString"]) && v["toString"] !== Object.prototype.toString && v["toString"] !== Array.prototype.toString) {
        const s = safeToString(v);
        if (v instanceof Error && v.cause) {
          return `${s} (cause: ${go(v.cause, d)})`;
        }
        return s;
      }
      if (isString(v))
        return JSON.stringify(v);
      if (isNumber(v) || v == null || isBoolean(v) || isSymbol(v))
        return String(v);
      if (isBigInt(v))
        return String(v) + "n";
      if (v instanceof Set || v instanceof Map) {
        if (seen.has(v))
          return CIRCULAR;
        seen.add(v);
        return `${v.constructor.name}(${go(Array.from(v), d)})`;
      }
      if (isObject(v)) {
        if (seen.has(v))
          return CIRCULAR;
        seen.add(v);
        const keys = ownKeys(v);
        if (!gap || keys.length <= 1) {
          const body2 = `{${keys.map((k) => `${formatPropertyKey(k)}:${go(v[k], d)}`).join(",")}}`;
          return wrap(v, body2);
        }
        const body = `{
${keys.map((k) => `${ind(d + 1)}${formatPropertyKey(k)}: ${go(v[k], d + 1)}`).join(`,
`)}
${ind(d)}}`;
        return wrap(v, body);
      }
      return String(v);
    }
    return go(input, 0);
  }
  var format = (x) => JSON.stringify(x, null, 2);
  var BaseProto = {
    toJSON() {
      return toJSON(this);
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    toString() {
      return format(this.toJSON());
    }
  };
  var toStringUnknown = (u, whitespace = 2) => {
    if (typeof u === "string") {
      return u;
    }
    try {
      return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
    } catch {
      return String(u);
    }
  };
  var stringifyCircular = (obj, whitespace) => {
    let cache = [];
    const retVal = JSON.stringify(obj, (_key, value) => typeof value === "object" && value !== null ? cache.includes(value) ? undefined : cache.push(value) && (redactableState.fiberRefs !== undefined && isRedactable(value) ? value[symbolRedactable](redactableState.fiberRefs) : value) : value, whitespace);
    cache = undefined;
    return retVal;
  };
  var symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
  var isRedactable = (u) => typeof u === "object" && u !== null && (symbolRedactable in u);
  var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
    fiberRefs: undefined
  }));
  var withRedactableContext = (context, f) => {
    const prev = redactableState.fiberRefs;
    redactableState.fiberRefs = context;
    try {
      return f();
    } finally {
      redactableState.fiberRefs = prev;
    }
  };
  var redact = (u) => {
    if (isRedactable(u) && redactableState.fiberRefs !== undefined) {
      return u[symbolRedactable](redactableState.fiberRefs);
    }
    return u;
  };

  // node_modules/effect/dist/esm/Pipeable.js
  var pipeArguments = (self, args) => {
    switch (args.length) {
      case 0:
        return self;
      case 1:
        return args[0](self);
      case 2:
        return args[1](args[0](self));
      case 3:
        return args[2](args[1](args[0](self)));
      case 4:
        return args[3](args[2](args[1](args[0](self))));
      case 5:
        return args[4](args[3](args[2](args[1](args[0](self)))));
      case 6:
        return args[5](args[4](args[3](args[2](args[1](args[0](self))))));
      case 7:
        return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))));
      case 8:
        return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self))))))));
      case 9:
        return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self)))))))));
      default: {
        let ret = self;
        for (let i = 0, len = args.length;i < len; i++) {
          ret = args[i](ret);
        }
        return ret;
      }
    }
  };

  // node_modules/effect/dist/esm/internal/opCodes/effect.js
  var OP_ASYNC = "Async";
  var OP_COMMIT = "Commit";
  var OP_FAILURE = "Failure";
  var OP_ON_FAILURE = "OnFailure";
  var OP_ON_SUCCESS = "OnSuccess";
  var OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
  var OP_SUCCESS = "Success";
  var OP_SYNC = "Sync";
  var OP_TAG = "Tag";
  var OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
  var OP_WHILE = "While";
  var OP_ITERATOR = "Iterator";
  var OP_WITH_RUNTIME = "WithRuntime";
  var OP_YIELD = "Yield";
  var OP_REVERT_FLAGS = "RevertFlags";

  // node_modules/effect/dist/esm/internal/version.js
  var moduleVersion = "3.19.8";
  var getCurrentVersion = () => moduleVersion;

  // node_modules/effect/dist/esm/internal/effectable.js
  var EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
  var StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
  var SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
  var ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
  var effectVariance = {
    _R: (_) => _,
    _E: (_) => _,
    _A: (_) => _,
    _V: /* @__PURE__ */ getCurrentVersion()
  };
  var sinkVariance = {
    _A: (_) => _,
    _In: (_) => _,
    _L: (_) => _,
    _E: (_) => _,
    _R: (_) => _
  };
  var channelVariance = {
    _Env: (_) => _,
    _InErr: (_) => _,
    _InElem: (_) => _,
    _InDone: (_) => _,
    _OutErr: (_) => _,
    _OutElem: (_) => _,
    _OutDone: (_) => _
  };
  var EffectPrototype = {
    [EffectTypeId]: effectVariance,
    [StreamTypeId]: effectVariance,
    [SinkTypeId]: sinkVariance,
    [ChannelTypeId]: channelVariance,
    [symbol2](that) {
      return this === that;
    },
    [symbol]() {
      return cached(this, random(this));
    },
    [Symbol.iterator]() {
      return new SingleShotGen(new YieldWrap(this));
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var StructuralPrototype = {
    [symbol]() {
      return cached(this, structure(this));
    },
    [symbol2](that) {
      const selfKeys = Object.keys(this);
      const thatKeys = Object.keys(that);
      if (selfKeys.length !== thatKeys.length) {
        return false;
      }
      for (const key of selfKeys) {
        if (!((key in that) && equals(this[key], that[key]))) {
          return false;
        }
      }
      return true;
    }
  };
  var CommitPrototype = {
    ...EffectPrototype,
    _op: OP_COMMIT
  };
  var StructuralCommitPrototype = {
    ...CommitPrototype,
    ...StructuralPrototype
  };
  var Base = /* @__PURE__ */ function() {
    function Base2() {}
    Base2.prototype = CommitPrototype;
    return Base2;
  }();

  // node_modules/effect/dist/esm/internal/option.js
  var TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
  var CommonProto = {
    ...EffectPrototype,
    [TypeId]: {
      _A: (_) => _
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    toString() {
      return format(this.toJSON());
    }
  };
  var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
    _tag: "Some",
    _op: "Some",
    [symbol2](that) {
      return isOption(that) && isSome(that) && equals(this.value, that.value);
    },
    [symbol]() {
      return cached(this, combine(hash(this._tag))(hash(this.value)));
    },
    toJSON() {
      return {
        _id: "Option",
        _tag: this._tag,
        value: toJSON(this.value)
      };
    }
  });
  var NoneHash = /* @__PURE__ */ hash("None");
  var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
    _tag: "None",
    _op: "None",
    [symbol2](that) {
      return isOption(that) && isNone(that);
    },
    [symbol]() {
      return NoneHash;
    },
    toJSON() {
      return {
        _id: "Option",
        _tag: this._tag
      };
    }
  });
  var isOption = (input) => hasProperty(input, TypeId);
  var isNone = (fa) => fa._tag === "None";
  var isSome = (fa) => fa._tag === "Some";
  var none = /* @__PURE__ */ Object.create(NoneProto);
  var some = (value) => {
    const a = Object.create(SomeProto);
    a.value = value;
    return a;
  };

  // node_modules/effect/dist/esm/internal/either.js
  var TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
  var CommonProto2 = {
    ...EffectPrototype,
    [TypeId2]: {
      _R: (_) => _
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    toString() {
      return format(this.toJSON());
    }
  };
  var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
    _tag: "Right",
    _op: "Right",
    [symbol2](that) {
      return isEither(that) && isRight(that) && equals(this.right, that.right);
    },
    [symbol]() {
      return combine(hash(this._tag))(hash(this.right));
    },
    toJSON() {
      return {
        _id: "Either",
        _tag: this._tag,
        right: toJSON(this.right)
      };
    }
  });
  var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
    _tag: "Left",
    _op: "Left",
    [symbol2](that) {
      return isEither(that) && isLeft(that) && equals(this.left, that.left);
    },
    [symbol]() {
      return combine(hash(this._tag))(hash(this.left));
    },
    toJSON() {
      return {
        _id: "Either",
        _tag: this._tag,
        left: toJSON(this.left)
      };
    }
  });
  var isEither = (input) => hasProperty(input, TypeId2);
  var isLeft = (ma) => ma._tag === "Left";
  var isRight = (ma) => ma._tag === "Right";
  var left = (left2) => {
    const a = Object.create(LeftProto);
    a.left = left2;
    return a;
  };
  var right = (right2) => {
    const a = Object.create(RightProto);
    a.right = right2;
    return a;
  };

  // node_modules/effect/dist/esm/Either.js
  var right2 = right;
  var left2 = left;
  var isEither2 = isEither;
  var isLeft2 = isLeft;
  var isRight2 = isRight;
  var mapLeft = /* @__PURE__ */ dual(2, (self, f) => isLeft2(self) ? left2(f(self.left)) : right2(self.right));
  var map = /* @__PURE__ */ dual(2, (self, f) => isRight2(self) ? right2(f(self.right)) : left2(self.left));
  var match = /* @__PURE__ */ dual(2, (self, {
    onLeft,
    onRight
  }) => isLeft2(self) ? onLeft(self.left) : onRight(self.right));
  var merge = /* @__PURE__ */ match({
    onLeft: identity,
    onRight: identity
  });
  var getOrThrowWith = /* @__PURE__ */ dual(2, (self, onLeft) => {
    if (isRight2(self)) {
      return self.right;
    }
    throw onLeft(self.left);
  });
  var getOrThrow = /* @__PURE__ */ getOrThrowWith(() => new Error("getOrThrow called on a Left"));

  // node_modules/effect/dist/esm/internal/array.js
  var isNonEmptyArray = (self) => self.length > 0;

  // node_modules/effect/dist/esm/Order.js
  var make2 = (compare) => (self, that) => self === that ? 0 : compare(self, that);
  var number3 = /* @__PURE__ */ make2((self, that) => self < that ? -1 : 1);
  var mapInput2 = /* @__PURE__ */ dual(2, (self, f) => make2((b1, b2) => self(f(b1), f(b2))));
  var greaterThan = (O) => dual(2, (self, that) => O(self, that) === 1);

  // node_modules/effect/dist/esm/Option.js
  var none2 = () => none;
  var some2 = some;
  var isNone2 = isNone;
  var isSome2 = isSome;
  var match2 = /* @__PURE__ */ dual(2, (self, {
    onNone,
    onSome
  }) => isNone2(self) ? onNone() : onSome(self.value));
  var getOrElse = /* @__PURE__ */ dual(2, (self, onNone) => isNone2(self) ? onNone() : self.value);
  var orElse = /* @__PURE__ */ dual(2, (self, that) => isNone2(self) ? that() : self);
  var orElseSome = /* @__PURE__ */ dual(2, (self, onNone) => isNone2(self) ? some2(onNone()) : self);
  var fromNullable = (nullableValue) => nullableValue == null ? none2() : some2(nullableValue);
  var getOrUndefined = /* @__PURE__ */ getOrElse(constUndefined);
  var liftThrowable = (f) => (...a) => {
    try {
      return some2(f(...a));
    } catch {
      return none2();
    }
  };
  var getOrThrowWith2 = /* @__PURE__ */ dual(2, (self, onNone) => {
    if (isSome2(self)) {
      return self.value;
    }
    throw onNone();
  });
  var getOrThrow2 = /* @__PURE__ */ getOrThrowWith2(() => new Error("getOrThrow called on a None"));
  var map2 = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : some2(f(self.value)));
  var flatMap = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : f(self.value));
  var flatMapNullable = /* @__PURE__ */ dual(2, (self, f) => isNone2(self) ? none2() : fromNullable(f(self.value)));
  var containsWith = (isEquivalent) => dual(2, (self, a) => isNone2(self) ? false : isEquivalent(self.value, a));
  var _equivalence = /* @__PURE__ */ equivalence();
  var contains = /* @__PURE__ */ containsWith(_equivalence);
  var exists = /* @__PURE__ */ dual(2, (self, refinement) => isNone2(self) ? false : refinement(self.value));
  var mergeWith = (f) => (o1, o2) => {
    if (isNone2(o1)) {
      return o2;
    } else if (isNone2(o2)) {
      return o1;
    }
    return some2(f(o1.value, o2.value));
  };

  // node_modules/effect/dist/esm/Tuple.js
  var make3 = (...elements) => elements;

  // node_modules/effect/dist/esm/Iterable.js
  var findFirst = /* @__PURE__ */ dual(2, (self, f) => {
    let i = 0;
    for (const a of self) {
      const o = f(a, i);
      if (isBoolean(o)) {
        if (o) {
          return some2(a);
        }
      } else {
        if (isSome2(o)) {
          return o;
        }
      }
      i++;
    }
    return none2();
  });
  var constEmpty = {
    [Symbol.iterator]() {
      return constEmptyIterator;
    }
  };
  var constEmptyIterator = {
    next() {
      return {
        done: true,
        value: undefined
      };
    }
  };

  // node_modules/effect/dist/esm/Array.js
  var allocate = (n) => new Array(n);
  var makeBy = /* @__PURE__ */ dual(2, (n, f) => {
    const max = Math.max(1, Math.floor(n));
    const out = new Array(max);
    for (let i = 0;i < max; i++) {
      out[i] = f(i);
    }
    return out;
  });
  var fromIterable = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
  var ensure = (self) => Array.isArray(self) ? self : [self];
  var matchLeft = /* @__PURE__ */ dual(2, (self, {
    onEmpty,
    onNonEmpty
  }) => isNonEmptyReadonlyArray(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty());
  var prepend = /* @__PURE__ */ dual(2, (self, head) => [head, ...self]);
  var append = /* @__PURE__ */ dual(2, (self, last) => [...self, last]);
  var appendAll = /* @__PURE__ */ dual(2, (self, that) => fromIterable(self).concat(fromIterable(that)));
  var isArray = Array.isArray;
  var isEmptyArray = (self) => self.length === 0;
  var isEmptyReadonlyArray = isEmptyArray;
  var isNonEmptyArray2 = isNonEmptyArray;
  var isNonEmptyReadonlyArray = isNonEmptyArray;
  var isOutOfBounds = (i, as) => i < 0 || i >= as.length;
  var clamp = (i, as) => Math.floor(Math.min(Math.max(0, i), as.length));
  var get = /* @__PURE__ */ dual(2, (self, index) => {
    const i = Math.floor(index);
    return isOutOfBounds(i, self) ? none2() : some2(self[i]);
  });
  var unsafeGet = /* @__PURE__ */ dual(2, (self, index) => {
    const i = Math.floor(index);
    if (isOutOfBounds(i, self)) {
      throw new Error(`Index ${i} out of bounds`);
    }
    return self[i];
  });
  var head = /* @__PURE__ */ get(0);
  var headNonEmpty = /* @__PURE__ */ unsafeGet(0);
  var last = (self) => isNonEmptyReadonlyArray(self) ? some2(lastNonEmpty(self)) : none2();
  var lastNonEmpty = (self) => self[self.length - 1];
  var tailNonEmpty = (self) => self.slice(1);
  var spanIndex = (self, predicate) => {
    let i = 0;
    for (const a of self) {
      if (!predicate(a, i)) {
        break;
      }
      i++;
    }
    return i;
  };
  var span = /* @__PURE__ */ dual(2, (self, predicate) => splitAt(self, spanIndex(self, predicate)));
  var drop = /* @__PURE__ */ dual(2, (self, n) => {
    const input = fromIterable(self);
    return input.slice(clamp(n, input), input.length);
  });
  var findFirst2 = findFirst;
  var reverse = (self) => Array.from(self).reverse();
  var sort = /* @__PURE__ */ dual(2, (self, O) => {
    const out = Array.from(self);
    out.sort(O);
    return out;
  });
  var zip = /* @__PURE__ */ dual(2, (self, that) => zipWith(self, that, make3));
  var zipWith = /* @__PURE__ */ dual(3, (self, that, f) => {
    const as = fromIterable(self);
    const bs = fromIterable(that);
    if (isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs)) {
      const out = [f(headNonEmpty(as), headNonEmpty(bs))];
      const len = Math.min(as.length, bs.length);
      for (let i = 1;i < len; i++) {
        out[i] = f(as[i], bs[i]);
      }
      return out;
    }
    return [];
  });
  var _equivalence2 = /* @__PURE__ */ equivalence();
  var splitAt = /* @__PURE__ */ dual(2, (self, n) => {
    const input = Array.from(self);
    const _n = Math.floor(n);
    if (isNonEmptyReadonlyArray(input)) {
      if (_n >= 1) {
        return splitNonEmptyAt(input, _n);
      }
      return [[], input];
    }
    return [input, []];
  });
  var splitNonEmptyAt = /* @__PURE__ */ dual(2, (self, n) => {
    const _n = Math.max(1, Math.floor(n));
    return _n >= self.length ? [copy(self), []] : [prepend(self.slice(1, _n), headNonEmpty(self)), self.slice(_n)];
  });
  var copy = (self) => self.slice();
  var unionWith = /* @__PURE__ */ dual(3, (self, that, isEquivalent) => {
    const a = fromIterable(self);
    const b = fromIterable(that);
    if (isNonEmptyReadonlyArray(a)) {
      if (isNonEmptyReadonlyArray(b)) {
        const dedupe = dedupeWith(isEquivalent);
        return dedupe(appendAll(a, b));
      }
      return a;
    }
    return b;
  });
  var union = /* @__PURE__ */ dual(2, (self, that) => unionWith(self, that, _equivalence2));
  var empty = () => [];
  var of = (a) => [a];
  var map3 = /* @__PURE__ */ dual(2, (self, f) => self.map(f));
  var flatMap2 = /* @__PURE__ */ dual(2, (self, f) => {
    if (isEmptyReadonlyArray(self)) {
      return [];
    }
    const out = [];
    for (let i = 0;i < self.length; i++) {
      const inner = f(self[i], i);
      for (let j = 0;j < inner.length; j++) {
        out.push(inner[j]);
      }
    }
    return out;
  });
  var flatten = /* @__PURE__ */ flatMap2(identity);
  var filterMap = /* @__PURE__ */ dual(2, (self, f) => {
    const as = fromIterable(self);
    const out = [];
    for (let i = 0;i < as.length; i++) {
      const o = f(as[i], i);
      if (isSome2(o)) {
        out.push(o.value);
      }
    }
    return out;
  });
  var filterMapWhile = /* @__PURE__ */ dual(2, (self, f) => {
    let i = 0;
    const out = [];
    for (const a of self) {
      const b = f(a, i);
      if (isSome2(b)) {
        out.push(b.value);
      } else {
        break;
      }
      i++;
    }
    return out;
  });
  var partitionMap = /* @__PURE__ */ dual(2, (self, f) => {
    const left3 = [];
    const right3 = [];
    const as = fromIterable(self);
    for (let i = 0;i < as.length; i++) {
      const e = f(as[i], i);
      if (isLeft2(e)) {
        left3.push(e.left);
      } else {
        right3.push(e.right);
      }
    }
    return [left3, right3];
  });
  var getSomes = /* @__PURE__ */ filterMap(identity);
  var filter = /* @__PURE__ */ dual(2, (self, predicate) => {
    const as = fromIterable(self);
    const out = [];
    for (let i = 0;i < as.length; i++) {
      if (predicate(as[i], i)) {
        out.push(as[i]);
      }
    }
    return out;
  });
  var reduce = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable(self).reduce((b2, a, i) => f(b2, a, i), b));
  var reduceRight = /* @__PURE__ */ dual(3, (self, b, f) => fromIterable(self).reduceRight((b2, a, i) => f(b2, a, i), b));
  var every = /* @__PURE__ */ dual(2, (self, refinement) => self.every(refinement));
  var unfold = (b, f) => {
    const out = [];
    let next = b;
    let o;
    while (isSome2(o = f(next))) {
      const [a, b2] = o.value;
      out.push(a);
      next = b2;
    }
    return out;
  };
  var getEquivalence = array;
  var dedupeWith = /* @__PURE__ */ dual(2, (self, isEquivalent) => {
    const input = fromIterable(self);
    if (isNonEmptyReadonlyArray(input)) {
      const out = [headNonEmpty(input)];
      const rest = tailNonEmpty(input);
      for (const r of rest) {
        if (out.every((a) => !isEquivalent(r, a))) {
          out.push(r);
        }
      }
      return out;
    }
    return [];
  });
  var dedupe = (self) => dedupeWith(self, equivalence());
  var join = /* @__PURE__ */ dual(2, (self, sep) => fromIterable(self).join(sep));
  var mapAccum = /* @__PURE__ */ dual(3, (self, s, f) => {
    let i = 0;
    let s1 = s;
    const out = [];
    for (const a of self) {
      const r = f(s1, a, i);
      s1 = r[0];
      out.push(r[1]);
      i++;
    }
    return [s1, out];
  });

  // node_modules/effect/dist/esm/internal/schema/util.js
  var getKeysForIndexSignature = (input, parameter) => {
    switch (parameter._tag) {
      case "StringKeyword":
      case "TemplateLiteral":
        return Object.keys(input);
      case "SymbolKeyword":
        return Object.getOwnPropertySymbols(input);
      case "Refinement":
        return getKeysForIndexSignature(input, parameter.from);
    }
  };
  var memoizeThunk = (f) => {
    let done = false;
    let a;
    return () => {
      if (done) {
        return a;
      }
      a = f();
      done = true;
      return a;
    };
  };
  var isNonEmpty = (x) => Array.isArray(x);
  var isSingle = (x) => !Array.isArray(x);
  var formatPathKey = (key) => `[${formatPropertyKey(key)}]`;
  var formatPath = (path) => isNonEmpty(path) ? path.map(formatPathKey).join("") : formatPathKey(path);

  // node_modules/effect/dist/esm/internal/schema/errors.js
  var getErrorMessage = (reason, details, path, ast) => {
    let out = reason;
    if (path && isNonEmptyReadonlyArray(path)) {
      out += `
at path: ${formatPath(path)}`;
    }
    if (details !== undefined) {
      out += `
details: ${details}`;
    }
    if (ast) {
      out += `
schema (${ast._tag}): ${ast}`;
    }
    return out;
  };
  var getASTUnsupportedKeySchemaErrorMessage = (ast) => getErrorMessage("Unsupported key schema", undefined, undefined, ast);
  var getASTUnsupportedLiteralErrorMessage = (literal) => getErrorMessage("Unsupported literal", `literal value: ${formatUnknown(literal)}`);
  var getASTDuplicateIndexSignatureErrorMessage = (type) => getErrorMessage("Duplicate index signature", `${type} index signature`);
  var getASTIndexSignatureParameterErrorMessage = /* @__PURE__ */ getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
  var getASTRequiredElementFollowinAnOptionalElementErrorMessage = /* @__PURE__ */ getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
  var getASTDuplicatePropertySignatureTransformationErrorMessage = (key) => getErrorMessage("Duplicate property signature transformation", `Duplicate key ${formatUnknown(key)}`);
  var getASTDuplicatePropertySignatureErrorMessage = (key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`);

  // node_modules/effect/dist/esm/internal/schema/schemaId.js
  var DateFromSelfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/DateFromSelf");
  var GreaterThanSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThan");
  var IntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Int");

  // node_modules/effect/dist/esm/Number.js
  var Order = number3;
  var nextPow2 = (n) => {
    const nextPow = Math.ceil(Math.log(n) / Math.log(2));
    return Math.max(Math.pow(2, nextPow), 2);
  };

  // node_modules/effect/dist/esm/RegExp.js
  var escape = (string2) => string2.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

  // node_modules/effect/dist/esm/SchemaAST.js
  var BrandAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Brand");
  var SchemaIdAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/SchemaId");
  var MessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Message");
  var MissingMessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/MissingMessage");
  var IdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Identifier");
  var TitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Title");
  var AutoTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/AutoTitle");
  var DescriptionAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Description");
  var ExamplesAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Examples");
  var DefaultAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Default");
  var JSONSchemaAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONSchema");
  var ArbitraryAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Arbitrary");
  var PrettyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Pretty");
  var EquivalenceAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Equivalence");
  var DocumentationAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Documentation");
  var ConcurrencyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Concurrency");
  var BatchingAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Batching");
  var ParseIssueTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseIssueTitle");
  var ParseOptionsAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseOptions");
  var DecodingFallbackAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/DecodingFallback");
  var SurrogateAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Surrogate");
  var StableFilterAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/StableFilter");
  var getAnnotation = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some2(annotated.annotations[key]) : none2());
  var getBrandAnnotation = /* @__PURE__ */ getAnnotation(BrandAnnotationId);
  var getMessageAnnotation = /* @__PURE__ */ getAnnotation(MessageAnnotationId);
  var getMissingMessageAnnotation = /* @__PURE__ */ getAnnotation(MissingMessageAnnotationId);
  var getTitleAnnotation = /* @__PURE__ */ getAnnotation(TitleAnnotationId);
  var getAutoTitleAnnotation = /* @__PURE__ */ getAnnotation(AutoTitleAnnotationId);
  var getIdentifierAnnotation = /* @__PURE__ */ getAnnotation(IdentifierAnnotationId);
  var getDescriptionAnnotation = /* @__PURE__ */ getAnnotation(DescriptionAnnotationId);
  var getConcurrencyAnnotation = /* @__PURE__ */ getAnnotation(ConcurrencyAnnotationId);
  var getBatchingAnnotation = /* @__PURE__ */ getAnnotation(BatchingAnnotationId);
  var getParseIssueTitleAnnotation = /* @__PURE__ */ getAnnotation(ParseIssueTitleAnnotationId);
  var getParseOptionsAnnotation = /* @__PURE__ */ getAnnotation(ParseOptionsAnnotationId);
  var getDecodingFallbackAnnotation = /* @__PURE__ */ getAnnotation(DecodingFallbackAnnotationId);
  var getSurrogateAnnotation = /* @__PURE__ */ getAnnotation(SurrogateAnnotationId);
  var getStableFilterAnnotation = /* @__PURE__ */ getAnnotation(StableFilterAnnotationId);
  var hasStableFilter = (annotated) => exists(getStableFilterAnnotation(annotated), (b) => b === true);
  var JSONIdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONIdentifier");
  var getJSONIdentifierAnnotation = /* @__PURE__ */ getAnnotation(JSONIdentifierAnnotationId);
  var getJSONIdentifier = (annotated) => orElse(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
  class Declaration {
    typeParameters;
    decodeUnknown;
    encodeUnknown;
    annotations;
    _tag = "Declaration";
    constructor(typeParameters, decodeUnknown, encodeUnknown, annotations = {}) {
      this.typeParameters = typeParameters;
      this.decodeUnknown = decodeUnknown;
      this.encodeUnknown = encodeUnknown;
      this.annotations = annotations;
    }
    toString() {
      return getOrElse(getExpected(this), () => "<declaration schema>");
    }
    toJSON() {
      return {
        _tag: this._tag,
        typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var createASTGuard = (tag) => (ast) => ast._tag === tag;
  class Literal {
    literal;
    annotations;
    _tag = "Literal";
    constructor(literal, annotations = {}) {
      this.literal = literal;
      this.annotations = annotations;
    }
    toString() {
      return getOrElse(getExpected(this), () => formatUnknown(this.literal));
    }
    toJSON() {
      return {
        _tag: this._tag,
        literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var isLiteral = /* @__PURE__ */ createASTGuard("Literal");
  class UniqueSymbol {
    symbol;
    annotations;
    _tag = "UniqueSymbol";
    constructor(symbol3, annotations = {}) {
      this.symbol = symbol3;
      this.annotations = annotations;
    }
    toString() {
      return getOrElse(getExpected(this), () => formatUnknown(this.symbol));
    }
    toJSON() {
      return {
        _tag: this._tag,
        symbol: String(this.symbol),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  class UndefinedKeyword {
    annotations;
    _tag = "UndefinedKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var undefinedKeyword = /* @__PURE__ */ new UndefinedKeyword({
    [TitleAnnotationId]: "undefined"
  });
  class VoidKeyword {
    annotations;
    _tag = "VoidKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var voidKeyword = /* @__PURE__ */ new VoidKeyword({
    [TitleAnnotationId]: "void"
  });
  class NeverKeyword {
    annotations;
    _tag = "NeverKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var neverKeyword = /* @__PURE__ */ new NeverKeyword({
    [TitleAnnotationId]: "never"
  });
  class UnknownKeyword {
    annotations;
    _tag = "UnknownKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var unknownKeyword = /* @__PURE__ */ new UnknownKeyword({
    [TitleAnnotationId]: "unknown"
  });
  class AnyKeyword {
    annotations;
    _tag = "AnyKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var anyKeyword = /* @__PURE__ */ new AnyKeyword({
    [TitleAnnotationId]: "any"
  });
  class StringKeyword {
    annotations;
    _tag = "StringKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var stringKeyword = /* @__PURE__ */ new StringKeyword({
    [TitleAnnotationId]: "string",
    [DescriptionAnnotationId]: "a string"
  });
  var isStringKeyword = /* @__PURE__ */ createASTGuard("StringKeyword");

  class NumberKeyword {
    annotations;
    _tag = "NumberKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var numberKeyword = /* @__PURE__ */ new NumberKeyword({
    [TitleAnnotationId]: "number",
    [DescriptionAnnotationId]: "a number"
  });
  class BooleanKeyword {
    annotations;
    _tag = "BooleanKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var booleanKeyword = /* @__PURE__ */ new BooleanKeyword({
    [TitleAnnotationId]: "boolean",
    [DescriptionAnnotationId]: "a boolean"
  });
  class BigIntKeyword {
    annotations;
    _tag = "BigIntKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var bigIntKeyword = /* @__PURE__ */ new BigIntKeyword({
    [TitleAnnotationId]: "bigint",
    [DescriptionAnnotationId]: "a bigint"
  });
  class SymbolKeyword {
    annotations;
    _tag = "SymbolKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var symbolKeyword = /* @__PURE__ */ new SymbolKeyword({
    [TitleAnnotationId]: "symbol",
    [DescriptionAnnotationId]: "a symbol"
  });
  var isSymbolKeyword = /* @__PURE__ */ createASTGuard("SymbolKeyword");

  class ObjectKeyword {
    annotations;
    _tag = "ObjectKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var objectKeyword = /* @__PURE__ */ new ObjectKeyword({
    [TitleAnnotationId]: "object",
    [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
  });
  class Type {
    type;
    annotations;
    constructor(type, annotations = {}) {
      this.type = type;
      this.annotations = annotations;
    }
    toJSON() {
      return {
        type: this.type.toJSON(),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
    toString() {
      return String(this.type);
    }
  }

  class OptionalType extends Type {
    isOptional;
    constructor(type, isOptional, annotations = {}) {
      super(type, annotations);
      this.isOptional = isOptional;
    }
    toJSON() {
      return {
        type: this.type.toJSON(),
        isOptional: this.isOptional,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
    toString() {
      return String(this.type) + (this.isOptional ? "?" : "");
    }
  }
  var getRestASTs = (rest) => rest.map((annotatedAST) => annotatedAST.type);

  class TupleType {
    elements;
    rest;
    isReadonly;
    annotations;
    _tag = "TupleType";
    constructor(elements, rest, isReadonly, annotations = {}) {
      this.elements = elements;
      this.rest = rest;
      this.isReadonly = isReadonly;
      this.annotations = annotations;
      let hasOptionalElement = false;
      let hasIllegalRequiredElement = false;
      for (const e of elements) {
        if (e.isOptional) {
          hasOptionalElement = true;
        } else if (hasOptionalElement) {
          hasIllegalRequiredElement = true;
          break;
        }
      }
      if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
        throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
      }
    }
    toString() {
      return getOrElse(getExpected(this), () => formatTuple(this));
    }
    toJSON() {
      return {
        _tag: this._tag,
        elements: this.elements.map((e) => e.toJSON()),
        rest: this.rest.map((ast) => ast.toJSON()),
        isReadonly: this.isReadonly,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var formatTuple = (ast) => {
    const formattedElements = ast.elements.map(String).join(", ");
    return matchLeft(ast.rest, {
      onEmpty: () => `readonly [${formattedElements}]`,
      onNonEmpty: (head2, tail) => {
        const formattedHead = String(head2);
        const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
        if (tail.length > 0) {
          const formattedTail = tail.map(String).join(", ");
          if (ast.elements.length > 0) {
            return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
          } else {
            return `readonly [...${wrappedHead}[], ${formattedTail}]`;
          }
        } else {
          if (ast.elements.length > 0) {
            return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
          } else {
            return `ReadonlyArray<${formattedHead}>`;
          }
        }
      }
    });
  };
  class PropertySignature extends OptionalType {
    name;
    isReadonly;
    constructor(name, type, isOptional, isReadonly, annotations) {
      super(type, isOptional, annotations);
      this.name = name;
      this.isReadonly = isReadonly;
    }
    toString() {
      return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
    }
    toJSON() {
      return {
        name: String(this.name),
        type: this.type.toJSON(),
        isOptional: this.isOptional,
        isReadonly: this.isReadonly,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var isParameter = (ast) => {
    switch (ast._tag) {
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
        return true;
      case "Refinement":
        return isParameter(ast.from);
    }
    return false;
  };

  class IndexSignature {
    type;
    isReadonly;
    parameter;
    constructor(parameter, type, isReadonly) {
      this.type = type;
      this.isReadonly = isReadonly;
      if (isParameter(parameter)) {
        this.parameter = parameter;
      } else {
        throw new Error(getASTIndexSignatureParameterErrorMessage);
      }
    }
    toString() {
      return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
    }
    toJSON() {
      return {
        parameter: this.parameter.toJSON(),
        type: this.type.toJSON(),
        isReadonly: this.isReadonly
      };
    }
  }

  class TypeLiteral {
    annotations;
    _tag = "TypeLiteral";
    propertySignatures;
    indexSignatures;
    constructor(propertySignatures, indexSignatures, annotations = {}) {
      this.annotations = annotations;
      const keys = {};
      for (let i = 0;i < propertySignatures.length; i++) {
        const name = propertySignatures[i].name;
        if (Object.prototype.hasOwnProperty.call(keys, name)) {
          throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
        }
        keys[name] = null;
      }
      const parameters = {
        string: false,
        symbol: false
      };
      for (let i = 0;i < indexSignatures.length; i++) {
        const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
        if (isStringKeyword(encodedParameter)) {
          if (parameters.string) {
            throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
          }
          parameters.string = true;
        } else if (isSymbolKeyword(encodedParameter)) {
          if (parameters.symbol) {
            throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
          }
          parameters.symbol = true;
        }
      }
      this.propertySignatures = propertySignatures;
      this.indexSignatures = indexSignatures;
    }
    toString() {
      return getOrElse(getExpected(this), () => formatTypeLiteral(this));
    }
    toJSON() {
      return {
        _tag: this._tag,
        propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
        indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var formatIndexSignatures = (iss) => iss.map(String).join("; ");
  var formatTypeLiteral = (ast) => {
    if (ast.propertySignatures.length > 0) {
      const pss = ast.propertySignatures.map(String).join("; ");
      if (ast.indexSignatures.length > 0) {
        return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
      } else {
        return `{ ${pss} }`;
      }
    } else {
      if (ast.indexSignatures.length > 0) {
        return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
      } else {
        return "{}";
      }
    }
  };
  var sortCandidates = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput2(Order, (ast) => {
    switch (ast._tag) {
      case "AnyKeyword":
        return 0;
      case "UnknownKeyword":
        return 1;
      case "ObjectKeyword":
        return 2;
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword":
        return 3;
    }
    return 4;
  }));
  var literalMap = {
    string: "StringKeyword",
    number: "NumberKeyword",
    boolean: "BooleanKeyword",
    bigint: "BigIntKeyword"
  };
  var flatten2 = (candidates) => flatMap2(candidates, (ast) => isUnion(ast) ? flatten2(ast.types) : [ast]);
  var unify = (candidates) => {
    const cs = sortCandidates(candidates);
    const out = [];
    const uniques = {};
    const literals = [];
    for (const ast of cs) {
      switch (ast._tag) {
        case "NeverKeyword":
          break;
        case "AnyKeyword":
          return [anyKeyword];
        case "UnknownKeyword":
          return [unknownKeyword];
        case "ObjectKeyword":
        case "UndefinedKeyword":
        case "VoidKeyword":
        case "StringKeyword":
        case "NumberKeyword":
        case "BooleanKeyword":
        case "BigIntKeyword":
        case "SymbolKeyword": {
          if (!uniques[ast._tag]) {
            uniques[ast._tag] = ast;
            out.push(ast);
          }
          break;
        }
        case "Literal": {
          const type = typeof ast.literal;
          switch (type) {
            case "string":
            case "number":
            case "bigint":
            case "boolean": {
              const _tag = literalMap[type];
              if (!uniques[_tag] && !literals.includes(ast.literal)) {
                literals.push(ast.literal);
                out.push(ast);
              }
              break;
            }
            case "object": {
              if (!literals.includes(ast.literal)) {
                literals.push(ast.literal);
                out.push(ast);
              }
              break;
            }
          }
          break;
        }
        case "UniqueSymbol": {
          if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
            literals.push(ast.symbol);
            out.push(ast);
          }
          break;
        }
        case "TupleType": {
          if (!uniques["ObjectKeyword"]) {
            out.push(ast);
          }
          break;
        }
        case "TypeLiteral": {
          if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
            if (!uniques["{}"]) {
              uniques["{}"] = ast;
              out.push(ast);
            }
          } else if (!uniques["ObjectKeyword"]) {
            out.push(ast);
          }
          break;
        }
        default:
          out.push(ast);
      }
    }
    return out;
  };

  class Union {
    types;
    annotations;
    static make = (types, annotations) => {
      return isMembers(types) ? new Union(types, annotations) : types.length === 1 ? types[0] : neverKeyword;
    };
    static unify = (candidates, annotations) => {
      return Union.make(unify(flatten2(candidates)), annotations);
    };
    _tag = "Union";
    constructor(types, annotations = {}) {
      this.types = types;
      this.annotations = annotations;
    }
    toString() {
      return getOrElse(getExpected(this), () => this.types.map(String).join(" | "));
    }
    toJSON() {
      return {
        _tag: this._tag,
        types: this.types.map((ast) => ast.toJSON()),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var mapMembers = (members, f) => members.map(f);
  var isMembers = (as) => as.length > 1;
  var isUnion = /* @__PURE__ */ createASTGuard("Union");
  var toJSONMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => new WeakMap);

  class Suspend {
    f;
    annotations;
    _tag = "Suspend";
    constructor(f, annotations = {}) {
      this.f = f;
      this.annotations = annotations;
      this.f = memoizeThunk(f);
    }
    toString() {
      return getExpected(this).pipe(orElse(() => flatMap(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse(() => "<suspended schema>"));
    }
    toJSON() {
      const ast = this.f();
      let out = toJSONMemoMap.get(ast);
      if (out) {
        return out;
      }
      toJSONMemoMap.set(ast, {
        _tag: this._tag
      });
      out = {
        _tag: this._tag,
        ast: ast.toJSON(),
        annotations: toJSONAnnotations(this.annotations)
      };
      toJSONMemoMap.set(ast, out);
      return out;
    }
  }
  class Refinement {
    from;
    filter;
    annotations;
    _tag = "Refinement";
    constructor(from, filter2, annotations = {}) {
      this.from = from;
      this.filter = filter2;
      this.annotations = annotations;
    }
    toString() {
      return getIdentifierAnnotation(this).pipe(getOrElse(() => match2(getOrElseExpected(this), {
        onNone: () => `{ ${this.from} | filter }`,
        onSome: (expected) => isRefinement(this.from) ? String(this.from) + " & " + expected : expected
      })));
    }
    toJSON() {
      return {
        _tag: this._tag,
        from: this.from.toJSON(),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var isRefinement = /* @__PURE__ */ createASTGuard("Refinement");
  var defaultParseOption = {};

  class Transformation {
    from;
    to;
    transformation;
    annotations;
    _tag = "Transformation";
    constructor(from, to, transformation, annotations = {}) {
      this.from = from;
      this.to = to;
      this.transformation = transformation;
      this.annotations = annotations;
    }
    toString() {
      return getOrElse(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
    }
    toJSON() {
      return {
        _tag: this._tag,
        from: this.from.toJSON(),
        to: this.to.toJSON(),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  class PropertySignatureTransformation {
    from;
    to;
    decode;
    encode;
    constructor(from, to, decode, encode) {
      this.from = from;
      this.to = to;
      this.decode = decode;
      this.encode = encode;
    }
  }
  class TypeLiteralTransformation {
    propertySignatureTransformations;
    _tag = "TypeLiteralTransformation";
    constructor(propertySignatureTransformations) {
      this.propertySignatureTransformations = propertySignatureTransformations;
      const fromKeys = {};
      const toKeys = {};
      for (const pst of propertySignatureTransformations) {
        const from = pst.from;
        if (fromKeys[from]) {
          throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(from));
        }
        fromKeys[from] = true;
        const to = pst.to;
        if (toKeys[to]) {
          throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(to));
        }
        toKeys[to] = true;
      }
    }
  }
  var annotations = (ast, overrides) => {
    const d = Object.getOwnPropertyDescriptors(ast);
    const base = {
      ...ast.annotations
    };
    delete base[IdentifierAnnotationId];
    const value = {
      ...base,
      ...overrides
    };
    const surrogate = getSurrogateAnnotation(ast);
    if (isSome2(surrogate)) {
      value[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
    }
    d.annotations.value = value;
    return Object.create(Object.getPrototypeOf(ast), d);
  };
  var STRING_KEYWORD_PATTERN = "[\\s\\S]*?";
  var NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
  var getTemplateLiteralSpanTypePattern = (type, capture) => {
    switch (type._tag) {
      case "Literal":
        return escape(String(type.literal));
      case "StringKeyword":
        return STRING_KEYWORD_PATTERN;
      case "NumberKeyword":
        return NUMBER_KEYWORD_PATTERN;
      case "TemplateLiteral":
        return getTemplateLiteralPattern(type, capture, false);
      case "Union":
        return type.types.map((type2) => getTemplateLiteralSpanTypePattern(type2, capture)).join("|");
    }
  };
  var handleTemplateLiteralSpanTypeParens = (type, s, capture, top) => {
    if (isUnion(type)) {
      if (capture && !top) {
        return `(?:${s})`;
      }
    } else if (!capture || !top) {
      return s;
    }
    return `(${s})`;
  };
  var getTemplateLiteralPattern = (ast, capture, top) => {
    let pattern = ``;
    if (ast.head !== "") {
      const head2 = escape(ast.head);
      pattern += capture && top ? `(${head2})` : head2;
    }
    for (const span2 of ast.spans) {
      const spanPattern = getTemplateLiteralSpanTypePattern(span2.type, capture);
      pattern += handleTemplateLiteralSpanTypeParens(span2.type, spanPattern, capture, top);
      if (span2.literal !== "") {
        const literal = escape(span2.literal);
        pattern += capture && top ? `(${literal})` : literal;
      }
    }
    return pattern;
  };
  var getTemplateLiteralRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`);
  var record = (key, value) => {
    const propertySignatures = [];
    const indexSignatures = [];
    const go = (key2) => {
      switch (key2._tag) {
        case "NeverKeyword":
          break;
        case "StringKeyword":
        case "SymbolKeyword":
        case "TemplateLiteral":
        case "Refinement":
          indexSignatures.push(new IndexSignature(key2, value, true));
          break;
        case "Literal":
          if (isString(key2.literal) || isNumber(key2.literal)) {
            propertySignatures.push(new PropertySignature(key2.literal, value, false, true));
          } else {
            throw new Error(getASTUnsupportedLiteralErrorMessage(key2.literal));
          }
          break;
        case "Enums": {
          for (const [_, name] of key2.enums) {
            propertySignatures.push(new PropertySignature(name, value, false, true));
          }
          break;
        }
        case "UniqueSymbol":
          propertySignatures.push(new PropertySignature(key2.symbol, value, false, true));
          break;
        case "Union":
          key2.types.forEach(go);
          break;
        default:
          throw new Error(getASTUnsupportedKeySchemaErrorMessage(key2));
      }
    };
    go(key);
    return {
      propertySignatures,
      indexSignatures
    };
  };
  var pickAnnotations = (annotationIds) => (annotated) => {
    let out = undefined;
    for (const id of annotationIds) {
      if (Object.prototype.hasOwnProperty.call(annotated.annotations, id)) {
        if (out === undefined) {
          out = {};
        }
        out[id] = annotated.annotations[id];
      }
    }
    return out;
  };
  var preserveTransformationAnnotations = /* @__PURE__ */ pickAnnotations([ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId]);
  var typeAST = (ast) => {
    switch (ast._tag) {
      case "Declaration": {
        const typeParameters = changeMap(ast.typeParameters, typeAST);
        return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
      }
      case "TupleType": {
        const elements = changeMap(ast.elements, (e) => {
          const type = typeAST(e.type);
          return type === e.type ? e : new OptionalType(type, e.isOptional);
        });
        const restASTs = getRestASTs(ast.rest);
        const rest = changeMap(restASTs, typeAST);
        return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type) => new Type(type)), ast.isReadonly, ast.annotations);
      }
      case "TypeLiteral": {
        const propertySignatures = changeMap(ast.propertySignatures, (p) => {
          const type = typeAST(p.type);
          return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly);
        });
        const indexSignatures = changeMap(ast.indexSignatures, (is) => {
          const type = typeAST(is.type);
          return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
        });
        return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
      }
      case "Union": {
        const types = changeMap(ast.types, typeAST);
        return types === ast.types ? ast : Union.make(types, ast.annotations);
      }
      case "Suspend":
        return new Suspend(() => typeAST(ast.f()), ast.annotations);
      case "Refinement": {
        const from = typeAST(ast.from);
        return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
      }
      case "Transformation": {
        const preserve = preserveTransformationAnnotations(ast);
        return typeAST(preserve !== undefined ? annotations(ast.to, preserve) : ast.to);
      }
    }
    return ast;
  };
  function changeMap(as, f) {
    let changed = false;
    const out = allocate(as.length);
    for (let i = 0;i < as.length; i++) {
      const a = as[i];
      const fa = f(a);
      if (fa !== a) {
        changed = true;
      }
      out[i] = fa;
    }
    return changed ? out : as;
  }
  var getTransformationFrom = (ast) => {
    switch (ast._tag) {
      case "Transformation":
        return ast.from;
      case "Refinement":
        return getTransformationFrom(ast.from);
      case "Suspend":
        return getTransformationFrom(ast.f());
    }
  };
  var encodedAST_ = (ast, isBound) => {
    switch (ast._tag) {
      case "Declaration": {
        const typeParameters = changeMap(ast.typeParameters, (ast2) => encodedAST_(ast2, isBound));
        return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown);
      }
      case "TupleType": {
        const elements = changeMap(ast.elements, (e) => {
          const type = encodedAST_(e.type, isBound);
          return type === e.type ? e : new OptionalType(type, e.isOptional);
        });
        const restASTs = getRestASTs(ast.rest);
        const rest = changeMap(restASTs, (ast2) => encodedAST_(ast2, isBound));
        return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast2) => new Type(ast2)), ast.isReadonly);
      }
      case "TypeLiteral": {
        const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
          const type = encodedAST_(ps.type, isBound);
          return type === ps.type ? ps : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly);
        });
        const indexSignatures = changeMap(ast.indexSignatures, (is) => {
          const type = encodedAST_(is.type, isBound);
          return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
        });
        return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures);
      }
      case "Union": {
        const types = changeMap(ast.types, (ast2) => encodedAST_(ast2, isBound));
        return types === ast.types ? ast : Union.make(types);
      }
      case "Suspend": {
        let borrowedAnnotations = undefined;
        const identifier = getJSONIdentifier(ast);
        if (isSome2(identifier)) {
          const suffix = isBound ? "Bound" : "";
          borrowedAnnotations = {
            [JSONIdentifierAnnotationId]: `${identifier.value}Encoded${suffix}`
          };
        }
        return new Suspend(() => encodedAST_(ast.f(), isBound), borrowedAnnotations);
      }
      case "Refinement": {
        const from = encodedAST_(ast.from, isBound);
        if (isBound) {
          if (from === ast.from)
            return ast;
          if (getTransformationFrom(ast.from) === undefined && hasStableFilter(ast)) {
            return new Refinement(from, ast.filter, ast.annotations);
          }
          return from;
        } else {
          return from;
        }
      }
      case "Transformation":
        return encodedAST_(ast.from, isBound);
    }
    return ast;
  };
  var encodedAST = (ast) => encodedAST_(ast, false);
  var toJSONAnnotations = (annotations2) => {
    const out = {};
    for (const k of Object.getOwnPropertySymbols(annotations2)) {
      out[String(k)] = annotations2[k];
    }
    return out;
  };
  var getEncodedParameter = (ast) => {
    switch (ast._tag) {
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
        return ast;
      case "Refinement":
        return getEncodedParameter(ast.from);
    }
  };
  var formatKeyword = (ast) => getOrElse(getExpected(ast), () => ast._tag);
  function getBrands(ast) {
    return match2(getBrandAnnotation(ast), {
      onNone: () => "",
      onSome: (brands) => brands.map((brand) => ` & Brand<${formatUnknown(brand)}>`).join("")
    });
  }
  var getOrElseExpected = (ast) => getTitleAnnotation(ast).pipe(orElse(() => getDescriptionAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), map2((s) => s + getBrands(ast)));
  var getExpected = (ast) => orElse(getIdentifierAnnotation(ast), () => getOrElseExpected(ast));
  // node_modules/effect/dist/esm/Boolean.js
  var not = (self) => !self;
  // node_modules/effect/dist/esm/Context.js
  var exports_Context = {};
  __export(exports_Context, {
    unsafeMake: () => unsafeMake,
    unsafeGet: () => unsafeGet3,
    pick: () => pick2,
    omit: () => omit2,
    mergeAll: () => mergeAll2,
    merge: () => merge3,
    make: () => make5,
    isTag: () => isTag2,
    isReference: () => isReference2,
    isContext: () => isContext2,
    getOrElse: () => getOrElse3,
    getOption: () => getOption2,
    get: () => get3,
    empty: () => empty3,
    add: () => add2,
    TagTypeId: () => TagTypeId2,
    Tag: () => Tag2,
    ReferenceTypeId: () => ReferenceTypeId2,
    Reference: () => Reference2,
    GenericTag: () => GenericTag
  });

  // node_modules/effect/dist/esm/internal/context.js
  var TagTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
  var ReferenceTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
  var STMSymbolKey = "effect/STM";
  var STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
  var TagProto = {
    ...EffectPrototype,
    _op: "Tag",
    [STMTypeId]: effectVariance,
    [TagTypeId]: {
      _Service: (_) => _,
      _Identifier: (_) => _
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "Tag",
        key: this.key,
        stack: this.stack
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    of(self) {
      return self;
    },
    context(self) {
      return make4(this, self);
    }
  };
  var ReferenceProto = {
    ...TagProto,
    [ReferenceTypeId]: ReferenceTypeId
  };
  var makeGenericTag = (key) => {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error;
    Error.stackTraceLimit = limit;
    const tag = Object.create(TagProto);
    Object.defineProperty(tag, "stack", {
      get() {
        return creationError.stack;
      }
    });
    tag.key = key;
    return tag;
  };
  var Tag = (id) => () => {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error;
    Error.stackTraceLimit = limit;
    function TagClass() {}
    Object.setPrototypeOf(TagClass, TagProto);
    TagClass.key = id;
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    return TagClass;
  };
  var Reference = () => (id, options) => {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error;
    Error.stackTraceLimit = limit;
    function ReferenceClass() {}
    Object.setPrototypeOf(ReferenceClass, ReferenceProto);
    ReferenceClass.key = id;
    ReferenceClass.defaultValue = options.defaultValue;
    Object.defineProperty(ReferenceClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    return ReferenceClass;
  };
  var TypeId3 = /* @__PURE__ */ Symbol.for("effect/Context");
  var ContextProto = {
    [TypeId3]: {
      _Services: (_) => _
    },
    [symbol2](that) {
      if (isContext(that)) {
        if (this.unsafeMap.size === that.unsafeMap.size) {
          for (const k of this.unsafeMap.keys()) {
            if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
              return false;
            }
          }
          return true;
        }
      }
      return false;
    },
    [symbol]() {
      return cached(this, number2(this.unsafeMap.size));
    },
    pipe() {
      return pipeArguments(this, arguments);
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "Context",
        services: Array.from(this.unsafeMap).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  };
  var makeContext = (unsafeMap) => {
    const context = Object.create(ContextProto);
    context.unsafeMap = unsafeMap;
    return context;
  };
  var serviceNotFoundError = (tag) => {
    const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : ""}`);
    if (tag.stack) {
      const lines = tag.stack.split(`
`);
      if (lines.length > 2) {
        const afterAt = lines[2].match(/at (.*)/);
        if (afterAt) {
          error.message = error.message + ` (defined at ${afterAt[1]})`;
        }
      }
    }
    if (error.stack) {
      const lines = error.stack.split(`
`);
      lines.splice(1, 3);
      error.stack = lines.join(`
`);
    }
    return error;
  };
  var isContext = (u) => hasProperty(u, TypeId3);
  var isTag = (u) => hasProperty(u, TagTypeId);
  var isReference = (u) => hasProperty(u, ReferenceTypeId);
  var _empty = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map);
  var empty2 = () => _empty;
  var make4 = (tag, service) => makeContext(new Map([[tag.key, service]]));
  var add = /* @__PURE__ */ dual(3, (self, tag, service) => {
    const map4 = new Map(self.unsafeMap);
    map4.set(tag.key, service);
    return makeContext(map4);
  });
  var defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => new Map);
  var getDefaultValue = (tag) => {
    if (defaultValueCache.has(tag.key)) {
      return defaultValueCache.get(tag.key);
    }
    const value = tag.defaultValue();
    defaultValueCache.set(tag.key, value);
    return value;
  };
  var unsafeGetReference = (self, tag) => {
    return self.unsafeMap.has(tag.key) ? self.unsafeMap.get(tag.key) : getDefaultValue(tag);
  };
  var unsafeGet2 = /* @__PURE__ */ dual(2, (self, tag) => {
    if (!self.unsafeMap.has(tag.key)) {
      if (ReferenceTypeId in tag)
        return getDefaultValue(tag);
      throw serviceNotFoundError(tag);
    }
    return self.unsafeMap.get(tag.key);
  });
  var get2 = unsafeGet2;
  var getOrElse2 = /* @__PURE__ */ dual(3, (self, tag, orElse2) => {
    if (!self.unsafeMap.has(tag.key)) {
      return isReference(tag) ? getDefaultValue(tag) : orElse2();
    }
    return self.unsafeMap.get(tag.key);
  });
  var getOption = /* @__PURE__ */ dual(2, (self, tag) => {
    if (!self.unsafeMap.has(tag.key)) {
      return isReference(tag) ? some(getDefaultValue(tag)) : none;
    }
    return some(self.unsafeMap.get(tag.key));
  });
  var merge2 = /* @__PURE__ */ dual(2, (self, that) => {
    const map4 = new Map(self.unsafeMap);
    for (const [tag, s] of that.unsafeMap) {
      map4.set(tag, s);
    }
    return makeContext(map4);
  });
  var mergeAll = (...ctxs) => {
    const map4 = new Map;
    for (let i = 0;i < ctxs.length; i++) {
      ctxs[i].unsafeMap.forEach((value, key) => {
        map4.set(key, value);
      });
    }
    return makeContext(map4);
  };
  var pick = (...tags) => (self) => {
    const tagSet = new Set(tags.map((_) => _.key));
    const newEnv = new Map;
    for (const [tag, s] of self.unsafeMap.entries()) {
      if (tagSet.has(tag)) {
        newEnv.set(tag, s);
      }
    }
    return makeContext(newEnv);
  };
  var omit = (...tags) => (self) => {
    const newEnv = new Map(self.unsafeMap);
    for (const tag of tags) {
      newEnv.delete(tag.key);
    }
    return makeContext(newEnv);
  };

  // node_modules/effect/dist/esm/Context.js
  var TagTypeId2 = TagTypeId;
  var ReferenceTypeId2 = ReferenceTypeId;
  var GenericTag = makeGenericTag;
  var unsafeMake = makeContext;
  var isContext2 = isContext;
  var isTag2 = isTag;
  var isReference2 = isReference;
  var empty3 = empty2;
  var make5 = make4;
  var add2 = add;
  var get3 = get2;
  var getOrElse3 = getOrElse2;
  var unsafeGet3 = unsafeGet2;
  var getOption2 = getOption;
  var merge3 = merge2;
  var mergeAll2 = mergeAll;
  var pick2 = pick;
  var omit2 = omit;
  var Tag2 = Tag;
  var Reference2 = Reference;

  // node_modules/effect/dist/esm/Chunk.js
  var TypeId4 = /* @__PURE__ */ Symbol.for("effect/Chunk");
  function copy2(src, srcPos, dest, destPos, len) {
    for (let i = srcPos;i < Math.min(src.length, srcPos + len); i++) {
      dest[destPos + i - srcPos] = src[i];
    }
    return dest;
  }
  var emptyArray = [];
  var getEquivalence2 = (isEquivalent) => make((self, that) => self.length === that.length && toReadonlyArray(self).every((value, i) => isEquivalent(value, unsafeGet4(that, i))));
  var _equivalence3 = /* @__PURE__ */ getEquivalence2(equals);
  var ChunkProto = {
    [TypeId4]: {
      _A: (_) => _
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "Chunk",
        values: toReadonlyArray(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    [symbol2](that) {
      return isChunk(that) && _equivalence3(this, that);
    },
    [symbol]() {
      return cached(this, array2(toReadonlyArray(this)));
    },
    [Symbol.iterator]() {
      switch (this.backing._tag) {
        case "IArray": {
          return this.backing.array[Symbol.iterator]();
        }
        case "IEmpty": {
          return emptyArray[Symbol.iterator]();
        }
        default: {
          return toReadonlyArray(this)[Symbol.iterator]();
        }
      }
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var makeChunk = (backing) => {
    const chunk = Object.create(ChunkProto);
    chunk.backing = backing;
    switch (backing._tag) {
      case "IEmpty": {
        chunk.length = 0;
        chunk.depth = 0;
        chunk.left = chunk;
        chunk.right = chunk;
        break;
      }
      case "IConcat": {
        chunk.length = backing.left.length + backing.right.length;
        chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
        chunk.left = backing.left;
        chunk.right = backing.right;
        break;
      }
      case "IArray": {
        chunk.length = backing.array.length;
        chunk.depth = 0;
        chunk.left = _empty2;
        chunk.right = _empty2;
        break;
      }
      case "ISingleton": {
        chunk.length = 1;
        chunk.depth = 0;
        chunk.left = _empty2;
        chunk.right = _empty2;
        break;
      }
      case "ISlice": {
        chunk.length = backing.length;
        chunk.depth = backing.chunk.depth + 1;
        chunk.left = _empty2;
        chunk.right = _empty2;
        break;
      }
    }
    return chunk;
  };
  var isChunk = (u) => hasProperty(u, TypeId4);
  var _empty2 = /* @__PURE__ */ makeChunk({
    _tag: "IEmpty"
  });
  var empty4 = () => _empty2;
  var make6 = (...as) => unsafeFromNonEmptyArray(as);
  var of2 = (a) => makeChunk({
    _tag: "ISingleton",
    a
  });
  var fromIterable2 = (self) => isChunk(self) ? self : unsafeFromArray(fromIterable(self));
  var copyToArray = (self, array3, initial) => {
    switch (self.backing._tag) {
      case "IArray": {
        copy2(self.backing.array, 0, array3, initial, self.length);
        break;
      }
      case "IConcat": {
        copyToArray(self.left, array3, initial);
        copyToArray(self.right, array3, initial + self.left.length);
        break;
      }
      case "ISingleton": {
        array3[initial] = self.backing.a;
        break;
      }
      case "ISlice": {
        let i = 0;
        let j = initial;
        while (i < self.length) {
          array3[j] = unsafeGet4(self, i);
          i += 1;
          j += 1;
        }
        break;
      }
    }
  };
  var toReadonlyArray_ = (self) => {
    switch (self.backing._tag) {
      case "IEmpty": {
        return emptyArray;
      }
      case "IArray": {
        return self.backing.array;
      }
      default: {
        const arr = new Array(self.length);
        copyToArray(self, arr, 0);
        self.backing = {
          _tag: "IArray",
          array: arr
        };
        self.left = _empty2;
        self.right = _empty2;
        self.depth = 0;
        return arr;
      }
    }
  };
  var toReadonlyArray = toReadonlyArray_;
  var reverseChunk = (self) => {
    switch (self.backing._tag) {
      case "IEmpty":
      case "ISingleton":
        return self;
      case "IArray": {
        return makeChunk({
          _tag: "IArray",
          array: reverse(self.backing.array)
        });
      }
      case "IConcat": {
        return makeChunk({
          _tag: "IConcat",
          left: reverse2(self.backing.right),
          right: reverse2(self.backing.left)
        });
      }
      case "ISlice":
        return unsafeFromArray(reverse(toReadonlyArray(self)));
    }
  };
  var reverse2 = reverseChunk;
  var get4 = /* @__PURE__ */ dual(2, (self, index) => index < 0 || index >= self.length ? none2() : some2(unsafeGet4(self, index)));
  var unsafeFromArray = (self) => self.length === 0 ? empty4() : self.length === 1 ? of2(self[0]) : makeChunk({
    _tag: "IArray",
    array: self
  });
  var unsafeFromNonEmptyArray = (self) => unsafeFromArray(self);
  var unsafeGet4 = /* @__PURE__ */ dual(2, (self, index) => {
    switch (self.backing._tag) {
      case "IEmpty": {
        throw new Error(`Index out of bounds`);
      }
      case "ISingleton": {
        if (index !== 0) {
          throw new Error(`Index out of bounds`);
        }
        return self.backing.a;
      }
      case "IArray": {
        if (index >= self.length || index < 0) {
          throw new Error(`Index out of bounds`);
        }
        return self.backing.array[index];
      }
      case "IConcat": {
        return index < self.left.length ? unsafeGet4(self.left, index) : unsafeGet4(self.right, index - self.left.length);
      }
      case "ISlice": {
        return unsafeGet4(self.backing.chunk, index + self.backing.offset);
      }
    }
  });
  var append2 = /* @__PURE__ */ dual(2, (self, a) => appendAll2(self, of2(a)));
  var prepend2 = /* @__PURE__ */ dual(2, (self, elem) => appendAll2(of2(elem), self));
  var take = /* @__PURE__ */ dual(2, (self, n) => {
    if (n <= 0) {
      return _empty2;
    } else if (n >= self.length) {
      return self;
    } else {
      switch (self.backing._tag) {
        case "ISlice": {
          return makeChunk({
            _tag: "ISlice",
            chunk: self.backing.chunk,
            length: n,
            offset: self.backing.offset
          });
        }
        case "IConcat": {
          if (n > self.left.length) {
            return makeChunk({
              _tag: "IConcat",
              left: self.left,
              right: take(self.right, n - self.left.length)
            });
          }
          return take(self.left, n);
        }
        default: {
          return makeChunk({
            _tag: "ISlice",
            chunk: self,
            offset: 0,
            length: n
          });
        }
      }
    }
  });
  var drop2 = /* @__PURE__ */ dual(2, (self, n) => {
    if (n <= 0) {
      return self;
    } else if (n >= self.length) {
      return _empty2;
    } else {
      switch (self.backing._tag) {
        case "ISlice": {
          return makeChunk({
            _tag: "ISlice",
            chunk: self.backing.chunk,
            offset: self.backing.offset + n,
            length: self.backing.length - n
          });
        }
        case "IConcat": {
          if (n > self.left.length) {
            return drop2(self.right, n - self.left.length);
          }
          return makeChunk({
            _tag: "IConcat",
            left: drop2(self.left, n),
            right: self.right
          });
        }
        default: {
          return makeChunk({
            _tag: "ISlice",
            chunk: self,
            offset: n,
            length: self.length - n
          });
        }
      }
    }
  });
  var dropWhile = /* @__PURE__ */ dual(2, (self, predicate) => {
    const arr = toReadonlyArray(self);
    const len = arr.length;
    let i = 0;
    while (i < len && predicate(arr[i])) {
      i++;
    }
    return drop2(self, i);
  });
  var appendAll2 = /* @__PURE__ */ dual(2, (self, that) => {
    if (self.backing._tag === "IEmpty") {
      return that;
    }
    if (that.backing._tag === "IEmpty") {
      return self;
    }
    const diff = that.depth - self.depth;
    if (Math.abs(diff) <= 1) {
      return makeChunk({
        _tag: "IConcat",
        left: self,
        right: that
      });
    } else if (diff < -1) {
      if (self.left.depth >= self.right.depth) {
        const nr = appendAll2(self.right, that);
        return makeChunk({
          _tag: "IConcat",
          left: self.left,
          right: nr
        });
      } else {
        const nrr = appendAll2(self.right.right, that);
        if (nrr.depth === self.depth - 3) {
          const nr = makeChunk({
            _tag: "IConcat",
            left: self.right.left,
            right: nrr
          });
          return makeChunk({
            _tag: "IConcat",
            left: self.left,
            right: nr
          });
        } else {
          const nl = makeChunk({
            _tag: "IConcat",
            left: self.left,
            right: self.right.left
          });
          return makeChunk({
            _tag: "IConcat",
            left: nl,
            right: nrr
          });
        }
      }
    } else {
      if (that.right.depth >= that.left.depth) {
        const nl = appendAll2(self, that.left);
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nll = appendAll2(self, that.left.left);
        if (nll.depth === that.depth - 3) {
          const nl = makeChunk({
            _tag: "IConcat",
            left: nll,
            right: that.left.right
          });
          return makeChunk({
            _tag: "IConcat",
            left: nl,
            right: that.right
          });
        } else {
          const nr = makeChunk({
            _tag: "IConcat",
            left: that.left.right,
            right: that.right
          });
          return makeChunk({
            _tag: "IConcat",
            left: nll,
            right: nr
          });
        }
      }
    }
  });
  var filterMap2 = /* @__PURE__ */ dual(2, (self, f) => unsafeFromArray(filterMap(self, f)));
  var filter2 = /* @__PURE__ */ dual(2, (self, predicate) => unsafeFromArray(filter(self, predicate)));
  var filterMapWhile2 = /* @__PURE__ */ dual(2, (self, f) => unsafeFromArray(filterMapWhile(self, f)));
  var flatMap3 = /* @__PURE__ */ dual(2, (self, f) => {
    if (self.backing._tag === "ISingleton") {
      return f(self.backing.a, 0);
    }
    let out = _empty2;
    let i = 0;
    for (const k of self) {
      out = appendAll2(out, f(k, i++));
    }
    return out;
  });
  var flatten3 = /* @__PURE__ */ flatMap3(identity);
  var isEmpty = (self) => self.length === 0;
  var isNonEmpty2 = (self) => self.length > 0;
  var head2 = /* @__PURE__ */ get4(0);
  var unsafeHead = (self) => unsafeGet4(self, 0);
  var headNonEmpty2 = unsafeHead;
  var last2 = (self) => get4(self, self.length - 1);
  var unsafeLast = (self) => unsafeGet4(self, self.length - 1);
  var map4 = /* @__PURE__ */ dual(2, (self, f) => self.backing._tag === "ISingleton" ? of2(f(self.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self), map3((a, i) => f(a, i)))));
  var mapAccum2 = /* @__PURE__ */ dual(3, (self, s, f) => {
    const [s1, as] = mapAccum(self, s, f);
    return [s1, unsafeFromArray(as)];
  });
  var splitAt2 = /* @__PURE__ */ dual(2, (self, n) => [take(self, n), drop2(self, n)]);
  var splitWhere = /* @__PURE__ */ dual(2, (self, predicate) => {
    let i = 0;
    for (const a of toReadonlyArray(self)) {
      if (predicate(a)) {
        break;
      } else {
        i++;
      }
    }
    return splitAt2(self, i);
  });
  var tailNonEmpty2 = (self) => drop2(self, 1);
  var takeRight = /* @__PURE__ */ dual(2, (self, n) => drop2(self, self.length - n));
  var takeWhile = /* @__PURE__ */ dual(2, (self, predicate) => {
    const out = [];
    for (const a of toReadonlyArray(self)) {
      if (predicate(a)) {
        out.push(a);
      } else {
        break;
      }
    }
    return unsafeFromArray(out);
  });
  var zipWith2 = /* @__PURE__ */ dual(3, (self, that, f) => unsafeFromArray(zipWith(self, that, f)));
  var makeBy2 = /* @__PURE__ */ dual(2, (n, f) => fromIterable2(makeBy(n, f)));
  var range = (start, end) => start <= end ? makeBy2(end - start + 1, (i) => start + i) : of2(start);
  var findFirst3 = findFirst2;
  var reduce2 = reduce;
  var reduceRight2 = reduceRight;

  // node_modules/effect/dist/esm/Duration.js
  var TypeId5 = /* @__PURE__ */ Symbol.for("effect/Duration");
  var bigint0 = /* @__PURE__ */ BigInt(0);
  var bigint24 = /* @__PURE__ */ BigInt(24);
  var bigint60 = /* @__PURE__ */ BigInt(60);
  var bigint1e3 = /* @__PURE__ */ BigInt(1000);
  var bigint1e6 = /* @__PURE__ */ BigInt(1e6);
  var bigint1e9 = /* @__PURE__ */ BigInt(1e9);
  var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
  var decode = (input) => {
    if (isDuration(input)) {
      return input;
    } else if (isNumber(input)) {
      return millis(input);
    } else if (isBigInt(input)) {
      return nanos(input);
    } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
      if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
        return zero;
      }
      if (input[0] === Infinity || input[1] === Infinity) {
        return infinity;
      }
      return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
    } else if (isString(input)) {
      const match4 = DURATION_REGEX.exec(input);
      if (match4) {
        const [_, valueStr, unit] = match4;
        const value = Number(valueStr);
        switch (unit) {
          case "nano":
          case "nanos":
            return nanos(BigInt(valueStr));
          case "micro":
          case "micros":
            return micros(BigInt(valueStr));
          case "milli":
          case "millis":
            return millis(value);
          case "second":
          case "seconds":
            return seconds(value);
          case "minute":
          case "minutes":
            return minutes(value);
          case "hour":
          case "hours":
            return hours(value);
          case "day":
          case "days":
            return days(value);
          case "week":
          case "weeks":
            return weeks(value);
        }
      }
    }
    throw new Error("Invalid DurationInput");
  };
  var zeroValue = {
    _tag: "Millis",
    millis: 0
  };
  var infinityValue = {
    _tag: "Infinity"
  };
  var DurationProto = {
    [TypeId5]: TypeId5,
    [symbol]() {
      return cached(this, structure(this.value));
    },
    [symbol2](that) {
      return isDuration(that) && equals2(this, that);
    },
    toString() {
      return `Duration(${format2(this)})`;
    },
    toJSON() {
      switch (this.value._tag) {
        case "Millis":
          return {
            _id: "Duration",
            _tag: "Millis",
            millis: this.value.millis
          };
        case "Nanos":
          return {
            _id: "Duration",
            _tag: "Nanos",
            hrtime: toHrTime(this)
          };
        case "Infinity":
          return {
            _id: "Duration",
            _tag: "Infinity"
          };
      }
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var make7 = (input) => {
    const duration = Object.create(DurationProto);
    if (isNumber(input)) {
      if (isNaN(input) || input <= 0) {
        duration.value = zeroValue;
      } else if (!Number.isFinite(input)) {
        duration.value = infinityValue;
      } else if (!Number.isInteger(input)) {
        duration.value = {
          _tag: "Nanos",
          nanos: BigInt(Math.round(input * 1e6))
        };
      } else {
        duration.value = {
          _tag: "Millis",
          millis: input
        };
      }
    } else if (input <= bigint0) {
      duration.value = zeroValue;
    } else {
      duration.value = {
        _tag: "Nanos",
        nanos: input
      };
    }
    return duration;
  };
  var isDuration = (u) => hasProperty(u, TypeId5);
  var isFinite = (self) => self.value._tag !== "Infinity";
  var isZero = (self) => {
    switch (self.value._tag) {
      case "Millis": {
        return self.value.millis === 0;
      }
      case "Nanos": {
        return self.value.nanos === bigint0;
      }
      case "Infinity": {
        return false;
      }
    }
  };
  var zero = /* @__PURE__ */ make7(0);
  var infinity = /* @__PURE__ */ make7(Infinity);
  var nanos = (nanos2) => make7(nanos2);
  var micros = (micros2) => make7(micros2 * bigint1e3);
  var millis = (millis2) => make7(millis2);
  var seconds = (seconds2) => make7(seconds2 * 1000);
  var minutes = (minutes2) => make7(minutes2 * 60000);
  var hours = (hours2) => make7(hours2 * 3600000);
  var days = (days2) => make7(days2 * 86400000);
  var weeks = (weeks2) => make7(weeks2 * 604800000);
  var toMillis = (self) => match4(self, {
    onMillis: (millis2) => millis2,
    onNanos: (nanos2) => Number(nanos2) / 1e6
  });
  var unsafeToNanos = (self) => {
    const _self = decode(self);
    switch (_self.value._tag) {
      case "Infinity":
        throw new Error("Cannot convert infinite duration to nanos");
      case "Nanos":
        return _self.value.nanos;
      case "Millis":
        return BigInt(Math.round(_self.value.millis * 1e6));
    }
  };
  var toHrTime = (self) => {
    const _self = decode(self);
    switch (_self.value._tag) {
      case "Infinity":
        return [Infinity, 0];
      case "Nanos":
        return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
      case "Millis":
        return [Math.floor(_self.value.millis / 1000), Math.round(_self.value.millis % 1000 * 1e6)];
    }
  };
  var match4 = /* @__PURE__ */ dual(2, (self, options) => {
    const _self = decode(self);
    switch (_self.value._tag) {
      case "Nanos":
        return options.onNanos(_self.value.nanos);
      case "Infinity":
        return options.onMillis(Infinity);
      case "Millis":
        return options.onMillis(_self.value.millis);
    }
  });
  var matchWith = /* @__PURE__ */ dual(3, (self, that, options) => {
    const _self = decode(self);
    const _that = decode(that);
    if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
      return options.onMillis(toMillis(_self), toMillis(_that));
    } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
      const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
      const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
      return options.onNanos(selfNanos, thatNanos);
    }
    return options.onMillis(_self.value.millis, _that.value.millis);
  });
  var Equivalence = (self, that) => matchWith(self, that, {
    onMillis: (self2, that2) => self2 === that2,
    onNanos: (self2, that2) => self2 === that2
  });
  var sum = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
    onMillis: (self2, that2) => make7(self2 + that2),
    onNanos: (self2, that2) => make7(self2 + that2)
  }));
  var lessThanOrEqualTo2 = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
    onMillis: (self2, that2) => self2 <= that2,
    onNanos: (self2, that2) => self2 <= that2
  }));
  var greaterThan2 = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
    onMillis: (self2, that2) => self2 > that2,
    onNanos: (self2, that2) => self2 > that2
  }));
  var greaterThanOrEqualTo2 = /* @__PURE__ */ dual(2, (self, that) => matchWith(self, that, {
    onMillis: (self2, that2) => self2 >= that2,
    onNanos: (self2, that2) => self2 >= that2
  }));
  var equals2 = /* @__PURE__ */ dual(2, (self, that) => Equivalence(decode(self), decode(that)));
  var parts = (self) => {
    const duration = decode(self);
    if (duration.value._tag === "Infinity") {
      return {
        days: Infinity,
        hours: Infinity,
        minutes: Infinity,
        seconds: Infinity,
        millis: Infinity,
        nanos: Infinity
      };
    }
    const nanos2 = unsafeToNanos(duration);
    const ms = nanos2 / bigint1e6;
    const sec = ms / bigint1e3;
    const min2 = sec / bigint60;
    const hr = min2 / bigint60;
    const days2 = hr / bigint24;
    return {
      days: Number(days2),
      hours: Number(hr % bigint24),
      minutes: Number(min2 % bigint60),
      seconds: Number(sec % bigint60),
      millis: Number(ms % bigint1e3),
      nanos: Number(nanos2 % bigint1e6)
    };
  };
  var format2 = (self) => {
    const duration = decode(self);
    if (duration.value._tag === "Infinity") {
      return "Infinity";
    }
    if (isZero(duration)) {
      return "0";
    }
    const fragments = parts(duration);
    const pieces = [];
    if (fragments.days !== 0) {
      pieces.push(`${fragments.days}d`);
    }
    if (fragments.hours !== 0) {
      pieces.push(`${fragments.hours}h`);
    }
    if (fragments.minutes !== 0) {
      pieces.push(`${fragments.minutes}m`);
    }
    if (fragments.seconds !== 0) {
      pieces.push(`${fragments.seconds}s`);
    }
    if (fragments.millis !== 0) {
      pieces.push(`${fragments.millis}ms`);
    }
    if (fragments.nanos !== 0) {
      pieces.push(`${fragments.nanos}ns`);
    }
    return pieces.join(" ");
  };

  // node_modules/effect/dist/esm/internal/hashMap/config.js
  var SIZE = 5;
  var BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
  var MASK = BUCKET_SIZE - 1;
  var MAX_INDEX_NODE = BUCKET_SIZE / 2;
  var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

  // node_modules/effect/dist/esm/internal/hashMap/bitwise.js
  function popcount(x) {
    x -= x >> 1 & 1431655765;
    x = (x & 858993459) + (x >> 2 & 858993459);
    x = x + (x >> 4) & 252645135;
    x += x >> 8;
    x += x >> 16;
    return x & 127;
  }
  function hashFragment(shift, h) {
    return h >>> shift & MASK;
  }
  function toBitmap(x) {
    return 1 << x;
  }
  function fromBitmap(bitmap, bit) {
    return popcount(bitmap & bit - 1);
  }

  // node_modules/effect/dist/esm/internal/stack.js
  var make8 = (value, previous) => ({
    value,
    previous
  });

  // node_modules/effect/dist/esm/internal/hashMap/array.js
  function arrayUpdate(mutate, at, v, arr) {
    let out = arr;
    if (!mutate) {
      const len = arr.length;
      out = new Array(len);
      for (let i = 0;i < len; ++i)
        out[i] = arr[i];
    }
    out[at] = v;
    return out;
  }
  function arraySpliceOut(mutate, at, arr) {
    const newLen = arr.length - 1;
    let i = 0;
    let g = 0;
    let out = arr;
    if (mutate) {
      i = g = at;
    } else {
      out = new Array(newLen);
      while (i < at)
        out[g++] = arr[i++];
    }
    ++i;
    while (i <= newLen)
      out[g++] = arr[i++];
    if (mutate) {
      out.length = newLen;
    }
    return out;
  }
  function arraySpliceIn(mutate, at, v, arr) {
    const len = arr.length;
    if (mutate) {
      let i2 = len;
      while (i2 >= at)
        arr[i2--] = arr[i2];
      arr[at] = v;
      return arr;
    }
    let i = 0, g = 0;
    const out = new Array(len + 1);
    while (i < at)
      out[g++] = arr[i++];
    out[at] = v;
    while (i < len)
      out[++g] = arr[i++];
    return out;
  }

  // node_modules/effect/dist/esm/internal/hashMap/node.js
  class EmptyNode {
    _tag = "EmptyNode";
    modify(edit, _shift, f, hash2, key, size) {
      const v = f(none2());
      if (isNone2(v))
        return new EmptyNode;
      ++size.value;
      return new LeafNode(edit, hash2, key, v);
    }
  }
  function isEmptyNode(a) {
    return isTagged(a, "EmptyNode");
  }
  function isLeafNode(node) {
    return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
  }
  function canEditNode(node, edit) {
    return isEmptyNode(node) ? false : edit === node.edit;
  }

  class LeafNode {
    edit;
    hash;
    key;
    value;
    _tag = "LeafNode";
    constructor(edit, hash2, key, value) {
      this.edit = edit;
      this.hash = hash2;
      this.key = key;
      this.value = value;
    }
    modify(edit, shift, f, hash2, key, size) {
      if (equals(key, this.key)) {
        const v2 = f(this.value);
        if (v2 === this.value)
          return this;
        else if (isNone2(v2)) {
          --size.value;
          return new EmptyNode;
        }
        if (canEditNode(this, edit)) {
          this.value = v2;
          return this;
        }
        return new LeafNode(edit, hash2, key, v2);
      }
      const v = f(none2());
      if (isNone2(v))
        return this;
      ++size.value;
      return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
    }
  }

  class CollisionNode {
    edit;
    hash;
    children;
    _tag = "CollisionNode";
    constructor(edit, hash2, children) {
      this.edit = edit;
      this.hash = hash2;
      this.children = children;
    }
    modify(edit, shift, f, hash2, key, size) {
      if (hash2 === this.hash) {
        const canEdit = canEditNode(this, edit);
        const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size);
        if (list === this.children)
          return this;
        return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0];
      }
      const v = f(none2());
      if (isNone2(v))
        return this;
      ++size.value;
      return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
    }
    updateCollisionList(mutate, edit, hash2, list, f, key, size) {
      const len = list.length;
      for (let i = 0;i < len; ++i) {
        const child = list[i];
        if ("key" in child && equals(key, child.key)) {
          const value = child.value;
          const newValue2 = f(value);
          if (newValue2 === value)
            return list;
          if (isNone2(newValue2)) {
            --size.value;
            return arraySpliceOut(mutate, i, list);
          }
          return arrayUpdate(mutate, i, new LeafNode(edit, hash2, key, newValue2), list);
        }
      }
      const newValue = f(none2());
      if (isNone2(newValue))
        return list;
      ++size.value;
      return arrayUpdate(mutate, len, new LeafNode(edit, hash2, key, newValue), list);
    }
  }

  class IndexedNode {
    edit;
    mask;
    children;
    _tag = "IndexedNode";
    constructor(edit, mask, children) {
      this.edit = edit;
      this.mask = mask;
      this.children = children;
    }
    modify(edit, shift, f, hash2, key, size) {
      const mask = this.mask;
      const children = this.children;
      const frag = hashFragment(shift, hash2);
      const bit = toBitmap(frag);
      const indx = fromBitmap(mask, bit);
      const exists2 = mask & bit;
      const canEdit = canEditNode(this, edit);
      if (!exists2) {
        const _newChild = new EmptyNode().modify(edit, shift + SIZE, f, hash2, key, size);
        if (!_newChild)
          return this;
        return children.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children) : new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children));
      }
      const current = children[indx];
      const child = current.modify(edit, shift + SIZE, f, hash2, key, size);
      if (current === child)
        return this;
      let bitmap = mask;
      let newChildren;
      if (isEmptyNode(child)) {
        bitmap &= ~bit;
        if (!bitmap)
          return new EmptyNode;
        if (children.length <= 2 && isLeafNode(children[indx ^ 1])) {
          return children[indx ^ 1];
        }
        newChildren = arraySpliceOut(canEdit, indx, children);
      } else {
        newChildren = arrayUpdate(canEdit, indx, child, children);
      }
      if (canEdit) {
        this.mask = bitmap;
        this.children = newChildren;
        return this;
      }
      return new IndexedNode(edit, bitmap, newChildren);
    }
  }

  class ArrayNode {
    edit;
    size;
    children;
    _tag = "ArrayNode";
    constructor(edit, size, children) {
      this.edit = edit;
      this.size = size;
      this.children = children;
    }
    modify(edit, shift, f, hash2, key, size) {
      let count = this.size;
      const children = this.children;
      const frag = hashFragment(shift, hash2);
      const child = children[frag];
      const newChild = (child || new EmptyNode).modify(edit, shift + SIZE, f, hash2, key, size);
      if (child === newChild)
        return this;
      const canEdit = canEditNode(this, edit);
      let newChildren;
      if (isEmptyNode(child) && !isEmptyNode(newChild)) {
        ++count;
        newChildren = arrayUpdate(canEdit, frag, newChild, children);
      } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
        --count;
        if (count <= MIN_ARRAY_NODE) {
          return pack(edit, count, frag, children);
        }
        newChildren = arrayUpdate(canEdit, frag, new EmptyNode, children);
      } else {
        newChildren = arrayUpdate(canEdit, frag, newChild, children);
      }
      if (canEdit) {
        this.size = count;
        this.children = newChildren;
        return this;
      }
      return new ArrayNode(edit, count, newChildren);
    }
  }
  function pack(edit, count, removed, elements) {
    const children = new Array(count - 1);
    let g = 0;
    let bitmap = 0;
    for (let i = 0, len = elements.length;i < len; ++i) {
      if (i !== removed) {
        const elem = elements[i];
        if (elem && !isEmptyNode(elem)) {
          children[g++] = elem;
          bitmap |= 1 << i;
        }
      }
    }
    return new IndexedNode(edit, bitmap, children);
  }
  function expand(edit, frag, child, bitmap, subNodes) {
    const arr = [];
    let bit = bitmap;
    let count = 0;
    for (let i = 0;bit; ++i) {
      if (bit & 1)
        arr[i] = subNodes[count++];
      bit >>>= 1;
    }
    arr[frag] = child;
    return new ArrayNode(edit, count + 1, arr);
  }
  function mergeLeavesInner(edit, shift, h1, n1, h2, n2) {
    if (h1 === h2)
      return new CollisionNode(edit, h1, [n2, n1]);
    const subH1 = hashFragment(shift, h1);
    const subH2 = hashFragment(shift, h2);
    if (subH1 === subH2) {
      return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
    } else {
      const children = subH1 < subH2 ? [n1, n2] : [n2, n1];
      return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children);
    }
  }
  function mergeLeaves(edit, shift, h1, n1, h2, n2) {
    let stack = undefined;
    let currentShift = shift;
    while (true) {
      const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
      if (typeof res === "function") {
        stack = make8(res, stack);
        currentShift = currentShift + SIZE;
      } else {
        let final = res;
        while (stack != null) {
          final = stack.value(final);
          stack = stack.previous;
        }
        return final;
      }
    }
  }

  // node_modules/effect/dist/esm/internal/hashMap.js
  var HashMapSymbolKey = "effect/HashMap";
  var HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
  var HashMapProto = {
    [HashMapTypeId]: HashMapTypeId,
    [Symbol.iterator]() {
      return new HashMapIterator(this, (k, v) => [k, v]);
    },
    [symbol]() {
      let hash2 = hash(HashMapSymbolKey);
      for (const item of this) {
        hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
      }
      return cached(this, hash2);
    },
    [symbol2](that) {
      if (isHashMap(that)) {
        if (that._size !== this._size) {
          return false;
        }
        for (const item of this) {
          const elem = pipe(that, getHash(item[0], hash(item[0])));
          if (isNone2(elem)) {
            return false;
          } else {
            if (!equals(item[1], elem.value)) {
              return false;
            }
          }
        }
        return true;
      }
      return false;
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "HashMap",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var makeImpl = (editable, edit, root, size) => {
    const map5 = Object.create(HashMapProto);
    map5._editable = editable;
    map5._edit = edit;
    map5._root = root;
    map5._size = size;
    return map5;
  };

  class HashMapIterator {
    map;
    f;
    v;
    constructor(map5, f) {
      this.map = map5;
      this.f = f;
      this.v = visitLazy(this.map._root, this.f, undefined);
    }
    next() {
      if (isNone2(this.v)) {
        return {
          done: true,
          value: undefined
        };
      }
      const v0 = this.v.value;
      this.v = applyCont(v0.cont);
      return {
        done: false,
        value: v0.value
      };
    }
    [Symbol.iterator]() {
      return new HashMapIterator(this.map, this.f);
    }
  }
  var applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2();
  var visitLazy = (node, f, cont = undefined) => {
    switch (node._tag) {
      case "LeafNode": {
        if (isSome2(node.value)) {
          return some2({
            value: f(node.key, node.value.value),
            cont
          });
        }
        return applyCont(cont);
      }
      case "CollisionNode":
      case "ArrayNode":
      case "IndexedNode": {
        const children = node.children;
        return visitLazyChildren(children.length, children, 0, f, cont);
      }
      default: {
        return applyCont(cont);
      }
    }
  };
  var visitLazyChildren = (len, children, i, f, cont) => {
    while (i < len) {
      const child = children[i++];
      if (child && !isEmptyNode(child)) {
        return visitLazy(child, f, [len, children, i, f, cont]);
      }
    }
    return applyCont(cont);
  };
  var _empty3 = /* @__PURE__ */ makeImpl(false, 0, /* @__PURE__ */ new EmptyNode, 0);
  var empty5 = () => _empty3;
  var fromIterable3 = (entries) => {
    const map5 = beginMutation(empty5());
    for (const entry of entries) {
      set(map5, entry[0], entry[1]);
    }
    return endMutation(map5);
  };
  var isHashMap = (u) => hasProperty(u, HashMapTypeId);
  var isEmpty2 = (self) => self && isEmptyNode(self._root);
  var get5 = /* @__PURE__ */ dual(2, (self, key) => getHash(self, key, hash(key)));
  var getHash = /* @__PURE__ */ dual(3, (self, key, hash2) => {
    let node = self._root;
    let shift = 0;
    while (true) {
      switch (node._tag) {
        case "LeafNode": {
          return equals(key, node.key) ? node.value : none2();
        }
        case "CollisionNode": {
          if (hash2 === node.hash) {
            const children = node.children;
            for (let i = 0, len = children.length;i < len; ++i) {
              const child = children[i];
              if ("key" in child && equals(key, child.key)) {
                return child.value;
              }
            }
          }
          return none2();
        }
        case "IndexedNode": {
          const frag = hashFragment(shift, hash2);
          const bit = toBitmap(frag);
          if (node.mask & bit) {
            node = node.children[fromBitmap(node.mask, bit)];
            shift += SIZE;
            break;
          }
          return none2();
        }
        case "ArrayNode": {
          node = node.children[hashFragment(shift, hash2)];
          if (node) {
            shift += SIZE;
            break;
          }
          return none2();
        }
        default:
          return none2();
      }
    }
  });
  var has = /* @__PURE__ */ dual(2, (self, key) => isSome2(getHash(self, key, hash(key))));
  var set = /* @__PURE__ */ dual(3, (self, key, value) => modifyAt(self, key, () => some2(value)));
  var setTree = /* @__PURE__ */ dual(3, (self, newRoot, newSize) => {
    if (self._editable) {
      self._root = newRoot;
      self._size = newSize;
      return self;
    }
    return newRoot === self._root ? self : makeImpl(self._editable, self._edit, newRoot, newSize);
  });
  var keys = (self) => new HashMapIterator(self, (key) => key);
  var size = (self) => self._size;
  var beginMutation = (self) => makeImpl(true, self._edit + 1, self._root, self._size);
  var endMutation = (self) => {
    self._editable = false;
    return self;
  };
  var mutate = /* @__PURE__ */ dual(2, (self, f) => {
    const transient = beginMutation(self);
    f(transient);
    return endMutation(transient);
  });
  var modifyAt = /* @__PURE__ */ dual(3, (self, key, f) => modifyHash(self, key, hash(key), f));
  var modifyHash = /* @__PURE__ */ dual(4, (self, key, hash2, f) => {
    const size2 = {
      value: self._size
    };
    const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash2, key, size2);
    return pipe(self, setTree(newRoot, size2.value));
  });
  var remove2 = /* @__PURE__ */ dual(2, (self, key) => modifyAt(self, key, none2));
  var map5 = /* @__PURE__ */ dual(2, (self, f) => reduce3(self, empty5(), (map6, value, key) => set(map6, key, f(value, key))));
  var forEach = /* @__PURE__ */ dual(2, (self, f) => reduce3(self, undefined, (_, value, key) => f(value, key)));
  var reduce3 = /* @__PURE__ */ dual(3, (self, zero2, f) => {
    const root = self._root;
    if (root._tag === "LeafNode") {
      return isSome2(root.value) ? f(zero2, root.value.value, root.key) : zero2;
    }
    if (root._tag === "EmptyNode") {
      return zero2;
    }
    const toVisit = [root.children];
    let children;
    while (children = toVisit.pop()) {
      for (let i = 0, len = children.length;i < len; ) {
        const child = children[i++];
        if (child && !isEmptyNode(child)) {
          if (child._tag === "LeafNode") {
            if (isSome2(child.value)) {
              zero2 = f(zero2, child.value.value, child.key);
            }
          } else {
            toVisit.push(child.children);
          }
        }
      }
    }
    return zero2;
  });

  // node_modules/effect/dist/esm/internal/hashSet.js
  var HashSetSymbolKey = "effect/HashSet";
  var HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
  var HashSetProto = {
    [HashSetTypeId]: HashSetTypeId,
    [Symbol.iterator]() {
      return keys(this._keyMap);
    },
    [symbol]() {
      return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
    },
    [symbol2](that) {
      if (isHashSet(that)) {
        return size(this._keyMap) === size(that._keyMap) && equals(this._keyMap, that._keyMap);
      }
      return false;
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "HashSet",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var makeImpl2 = (keyMap) => {
    const set2 = Object.create(HashSetProto);
    set2._keyMap = keyMap;
    return set2;
  };
  var isHashSet = (u) => hasProperty(u, HashSetTypeId);
  var _empty4 = /* @__PURE__ */ makeImpl2(/* @__PURE__ */ empty5());
  var empty6 = () => _empty4;
  var fromIterable4 = (elements) => {
    const set2 = beginMutation2(empty6());
    for (const value of elements) {
      add3(set2, value);
    }
    return endMutation2(set2);
  };
  var make9 = (...elements) => {
    const set2 = beginMutation2(empty6());
    for (const value of elements) {
      add3(set2, value);
    }
    return endMutation2(set2);
  };
  var has2 = /* @__PURE__ */ dual(2, (self, value) => has(self._keyMap, value));
  var size2 = (self) => size(self._keyMap);
  var beginMutation2 = (self) => makeImpl2(beginMutation(self._keyMap));
  var endMutation2 = (self) => {
    self._keyMap._editable = false;
    return self;
  };
  var mutate2 = /* @__PURE__ */ dual(2, (self, f) => {
    const transient = beginMutation2(self);
    f(transient);
    return endMutation2(transient);
  });
  var add3 = /* @__PURE__ */ dual(2, (self, value) => self._keyMap._editable ? (set(value, true)(self._keyMap), self) : makeImpl2(set(value, true)(self._keyMap)));
  var remove3 = /* @__PURE__ */ dual(2, (self, value) => self._keyMap._editable ? (remove2(value)(self._keyMap), self) : makeImpl2(remove2(value)(self._keyMap)));
  var difference2 = /* @__PURE__ */ dual(2, (self, that) => mutate2(self, (set2) => {
    for (const value of that) {
      remove3(set2, value);
    }
  }));
  var union2 = /* @__PURE__ */ dual(2, (self, that) => mutate2(empty6(), (set2) => {
    forEach2(self, (value) => add3(set2, value));
    for (const value of that) {
      add3(set2, value);
    }
  }));
  var forEach2 = /* @__PURE__ */ dual(2, (self, f) => forEach(self._keyMap, (_, k) => f(k)));
  var reduce4 = /* @__PURE__ */ dual(3, (self, zero2, f) => reduce3(self._keyMap, zero2, (z, _, a) => f(z, a)));

  // node_modules/effect/dist/esm/HashSet.js
  var empty7 = empty6;
  var fromIterable5 = fromIterable4;
  var make10 = make9;
  var has3 = has2;
  var size3 = size2;
  var add4 = add3;
  var remove4 = remove3;
  var difference3 = difference2;
  var union3 = union2;
  var forEach3 = forEach2;
  var reduce5 = reduce4;

  // node_modules/effect/dist/esm/MutableRef.js
  var TypeId6 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
  var MutableRefProto = {
    [TypeId6]: TypeId6,
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "MutableRef",
        current: toJSON(this.current)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var make11 = (value) => {
    const ref = Object.create(MutableRefProto);
    ref.current = value;
    return ref;
  };
  var compareAndSet = /* @__PURE__ */ dual(3, (self, oldValue, newValue) => {
    if (equals(oldValue, self.current)) {
      self.current = newValue;
      return true;
    }
    return false;
  });
  var get6 = (self) => self.current;
  var set2 = /* @__PURE__ */ dual(2, (self, value) => {
    self.current = value;
    return self;
  });

  // node_modules/effect/dist/esm/internal/fiberId.js
  var FiberIdSymbolKey = "effect/FiberId";
  var FiberIdTypeId = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
  var OP_NONE = "None";
  var OP_RUNTIME = "Runtime";
  var OP_COMPOSITE = "Composite";
  var emptyHash = /* @__PURE__ */ string(`${FiberIdSymbolKey}-${OP_NONE}`);

  class None {
    [FiberIdTypeId] = FiberIdTypeId;
    _tag = OP_NONE;
    id = -1;
    startTimeMillis = -1;
    [symbol]() {
      return emptyHash;
    }
    [symbol2](that) {
      return isFiberId(that) && that._tag === OP_NONE;
    }
    toString() {
      return format(this.toJSON());
    }
    toJSON() {
      return {
        _id: "FiberId",
        _tag: this._tag
      };
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  }

  class Runtime {
    id;
    startTimeMillis;
    [FiberIdTypeId] = FiberIdTypeId;
    _tag = OP_RUNTIME;
    constructor(id, startTimeMillis) {
      this.id = id;
      this.startTimeMillis = startTimeMillis;
    }
    [symbol]() {
      return cached(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
    }
    [symbol2](that) {
      return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
    }
    toString() {
      return format(this.toJSON());
    }
    toJSON() {
      return {
        _id: "FiberId",
        _tag: this._tag,
        id: this.id,
        startTimeMillis: this.startTimeMillis
      };
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  }

  class Composite {
    left;
    right;
    [FiberIdTypeId] = FiberIdTypeId;
    _tag = OP_COMPOSITE;
    constructor(left3, right3) {
      this.left = left3;
      this.right = right3;
    }
    _hash;
    [symbol]() {
      return pipe(string(`${FiberIdSymbolKey}-${this._tag}`), combine(hash(this.left)), combine(hash(this.right)), cached(this));
    }
    [symbol2](that) {
      return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
    }
    toString() {
      return format(this.toJSON());
    }
    toJSON() {
      return {
        _id: "FiberId",
        _tag: this._tag,
        left: toJSON(this.left),
        right: toJSON(this.right)
      };
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  }
  var none3 = /* @__PURE__ */ new None;
  var isFiberId = (self) => hasProperty(self, FiberIdTypeId);
  var combine2 = /* @__PURE__ */ dual(2, (self, that) => {
    if (self._tag === OP_NONE) {
      return that;
    }
    if (that._tag === OP_NONE) {
      return self;
    }
    return new Composite(self, that);
  });
  var combineAll = (fiberIds) => {
    return pipe(fiberIds, reduce5(none3, (a, b) => combine2(b)(a)));
  };
  var ids = (self) => {
    switch (self._tag) {
      case OP_NONE: {
        return empty7();
      }
      case OP_RUNTIME: {
        return make10(self.id);
      }
      case OP_COMPOSITE: {
        return pipe(ids(self.left), union3(ids(self.right)));
      }
    }
  };
  var _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make11(0));
  var threadName = (self) => {
    const identifiers = Array.from(ids(self)).map((n) => `#${n}`).join(",");
    return identifiers;
  };
  var unsafeMake2 = () => {
    const id = get6(_fiberCounter);
    pipe(_fiberCounter, set2(id + 1));
    return new Runtime(id, Date.now());
  };

  // node_modules/effect/dist/esm/FiberId.js
  var none4 = none3;
  var combine3 = combine2;
  var combineAll2 = combineAll;
  var ids2 = ids;
  var threadName2 = threadName;
  var unsafeMake3 = unsafeMake2;

  // node_modules/effect/dist/esm/HashMap.js
  var empty8 = empty5;
  var fromIterable6 = fromIterable3;
  var isEmpty3 = isEmpty2;
  var get7 = get5;
  var set3 = set;
  var keys2 = keys;
  var mutate3 = mutate;
  var modifyAt2 = modifyAt;
  var map7 = map5;
  var forEach4 = forEach;
  var reduce6 = reduce3;

  // node_modules/effect/dist/esm/List.js
  var TypeId7 = /* @__PURE__ */ Symbol.for("effect/List");
  var toArray2 = (self) => fromIterable(self);
  var getEquivalence3 = (isEquivalent) => mapInput(getEquivalence(isEquivalent), toArray2);
  var _equivalence4 = /* @__PURE__ */ getEquivalence3(equals);
  var ConsProto = {
    [TypeId7]: TypeId7,
    _tag: "Cons",
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "List",
        _tag: "Cons",
        values: toArray2(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    [symbol2](that) {
      return isList(that) && this._tag === that._tag && _equivalence4(this, that);
    },
    [symbol]() {
      return cached(this, array2(toArray2(this)));
    },
    [Symbol.iterator]() {
      let done = false;
      let self = this;
      return {
        next() {
          if (done) {
            return this.return();
          }
          if (self._tag === "Nil") {
            done = true;
            return this.return();
          }
          const value = self.head;
          self = self.tail;
          return {
            done,
            value
          };
        },
        return(value) {
          if (!done) {
            done = true;
          }
          return {
            done: true,
            value
          };
        }
      };
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var makeCons = (head3, tail) => {
    const cons = Object.create(ConsProto);
    cons.head = head3;
    cons.tail = tail;
    return cons;
  };
  var NilHash = /* @__PURE__ */ string("Nil");
  var NilProto = {
    [TypeId7]: TypeId7,
    _tag: "Nil",
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "List",
        _tag: "Nil"
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    [symbol]() {
      return NilHash;
    },
    [symbol2](that) {
      return isList(that) && this._tag === that._tag;
    },
    [Symbol.iterator]() {
      return {
        next() {
          return {
            done: true,
            value: undefined
          };
        }
      };
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var _Nil = /* @__PURE__ */ Object.create(NilProto);
  var isList = (u) => hasProperty(u, TypeId7);
  var isNil = (self) => self._tag === "Nil";
  var isCons = (self) => self._tag === "Cons";
  var nil = () => _Nil;
  var cons = (head3, tail) => makeCons(head3, tail);
  var empty9 = nil;
  var of3 = (value) => makeCons(value, _Nil);
  var appendAll3 = /* @__PURE__ */ dual(2, (self, that) => prependAll(that, self));
  var prepend3 = /* @__PURE__ */ dual(2, (self, element) => cons(element, self));
  var prependAll = /* @__PURE__ */ dual(2, (self, prefix) => {
    if (isNil(self)) {
      return prefix;
    } else if (isNil(prefix)) {
      return self;
    } else {
      const result = makeCons(prefix.head, self);
      let curr = result;
      let that = prefix.tail;
      while (!isNil(that)) {
        const temp = makeCons(that.head, self);
        curr.tail = temp;
        curr = temp;
        that = that.tail;
      }
      return result;
    }
  });
  var reduce7 = /* @__PURE__ */ dual(3, (self, zero2, f) => {
    let acc = zero2;
    let these = self;
    while (!isNil(these)) {
      acc = f(acc, these.head);
      these = these.tail;
    }
    return acc;
  });
  var reverse3 = (self) => {
    let result = empty9();
    let these = self;
    while (!isNil(these)) {
      result = prepend3(result, these.head);
      these = these.tail;
    }
    return result;
  };

  // node_modules/effect/dist/esm/internal/data.js
  var ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
    [symbol]() {
      return cached(this, array2(this));
    },
    [symbol2](that) {
      if (Array.isArray(that) && this.length === that.length) {
        return this.every((v, i) => equals(v, that[i]));
      } else {
        return false;
      }
    }
  });
  var Structural = /* @__PURE__ */ function() {
    function Structural2(args) {
      if (args) {
        Object.assign(this, args);
      }
    }
    Structural2.prototype = StructuralPrototype;
    return Structural2;
  }();
  var struct = (as) => Object.assign(Object.create(StructuralPrototype), as);

  // node_modules/effect/dist/esm/internal/differ/contextPatch.js
  var ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
  function variance(a) {
    return a;
  }
  var PatchProto = {
    ...Structural.prototype,
    [ContextPatchTypeId]: {
      _Value: variance,
      _Patch: variance
    }
  };
  var EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
    _tag: "Empty"
  });
  var _empty5 = /* @__PURE__ */ Object.create(EmptyProto);
  var empty10 = () => _empty5;
  var AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
    _tag: "AndThen"
  });
  var makeAndThen = (first, second) => {
    const o = Object.create(AndThenProto);
    o.first = first;
    o.second = second;
    return o;
  };
  var AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
    _tag: "AddService"
  });
  var makeAddService = (key, service) => {
    const o = Object.create(AddServiceProto);
    o.key = key;
    o.service = service;
    return o;
  };
  var RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
    _tag: "RemoveService"
  });
  var makeRemoveService = (key) => {
    const o = Object.create(RemoveServiceProto);
    o.key = key;
    return o;
  };
  var UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
    _tag: "UpdateService"
  });
  var makeUpdateService = (key, update) => {
    const o = Object.create(UpdateServiceProto);
    o.key = key;
    o.update = update;
    return o;
  };
  var diff = (oldValue, newValue) => {
    const missingServices = new Map(oldValue.unsafeMap);
    let patch = empty10();
    for (const [tag, newService] of newValue.unsafeMap.entries()) {
      if (missingServices.has(tag)) {
        const old = missingServices.get(tag);
        missingServices.delete(tag);
        if (!equals(old, newService)) {
          patch = combine4(makeUpdateService(tag, () => newService))(patch);
        }
      } else {
        missingServices.delete(tag);
        patch = combine4(makeAddService(tag, newService))(patch);
      }
    }
    for (const [tag] of missingServices.entries()) {
      patch = combine4(makeRemoveService(tag))(patch);
    }
    return patch;
  };
  var combine4 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen(self, that));
  var patch = /* @__PURE__ */ dual(2, (self, context) => {
    if (self._tag === "Empty") {
      return context;
    }
    let wasServiceUpdated = false;
    let patches = of2(self);
    const updatedContext = new Map(context.unsafeMap);
    while (isNonEmpty2(patches)) {
      const head3 = headNonEmpty2(patches);
      const tail = tailNonEmpty2(patches);
      switch (head3._tag) {
        case "Empty": {
          patches = tail;
          break;
        }
        case "AddService": {
          updatedContext.set(head3.key, head3.service);
          patches = tail;
          break;
        }
        case "AndThen": {
          patches = prepend2(prepend2(tail, head3.second), head3.first);
          break;
        }
        case "RemoveService": {
          updatedContext.delete(head3.key);
          patches = tail;
          break;
        }
        case "UpdateService": {
          updatedContext.set(head3.key, head3.update(updatedContext.get(head3.key)));
          wasServiceUpdated = true;
          patches = tail;
          break;
        }
      }
    }
    if (!wasServiceUpdated) {
      return makeContext(updatedContext);
    }
    const map8 = new Map;
    for (const [tag] of context.unsafeMap) {
      if (updatedContext.has(tag)) {
        map8.set(tag, updatedContext.get(tag));
        updatedContext.delete(tag);
      }
    }
    for (const [tag, s] of updatedContext) {
      map8.set(tag, s);
    }
    return makeContext(map8);
  });

  // node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
  var HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
  function variance2(a) {
    return a;
  }
  var PatchProto2 = {
    ...Structural.prototype,
    [HashSetPatchTypeId]: {
      _Value: variance2,
      _Key: variance2,
      _Patch: variance2
    }
  };
  var EmptyProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
    _tag: "Empty"
  });
  var _empty6 = /* @__PURE__ */ Object.create(EmptyProto2);
  var empty11 = () => _empty6;
  var AndThenProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
    _tag: "AndThen"
  });
  var makeAndThen2 = (first, second) => {
    const o = Object.create(AndThenProto2);
    o.first = first;
    o.second = second;
    return o;
  };
  var AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
    _tag: "Add"
  });
  var makeAdd = (value) => {
    const o = Object.create(AddProto);
    o.value = value;
    return o;
  };
  var RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
    _tag: "Remove"
  });
  var makeRemove = (value) => {
    const o = Object.create(RemoveProto);
    o.value = value;
    return o;
  };
  var diff2 = (oldValue, newValue) => {
    const [removed, patch2] = reduce5([oldValue, empty11()], ([set4, patch3], value) => {
      if (has3(value)(set4)) {
        return [remove4(value)(set4), patch3];
      }
      return [set4, combine5(makeAdd(value))(patch3)];
    })(newValue);
    return reduce5(patch2, (patch3, value) => combine5(makeRemove(value))(patch3))(removed);
  };
  var combine5 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen2(self, that));
  var patch2 = /* @__PURE__ */ dual(2, (self, oldValue) => {
    if (self._tag === "Empty") {
      return oldValue;
    }
    let set4 = oldValue;
    let patches = of2(self);
    while (isNonEmpty2(patches)) {
      const head3 = headNonEmpty2(patches);
      const tail = tailNonEmpty2(patches);
      switch (head3._tag) {
        case "Empty": {
          patches = tail;
          break;
        }
        case "AndThen": {
          patches = prepend2(head3.first)(prepend2(head3.second)(tail));
          break;
        }
        case "Add": {
          set4 = add4(head3.value)(set4);
          patches = tail;
          break;
        }
        case "Remove": {
          set4 = remove4(head3.value)(set4);
          patches = tail;
        }
      }
    }
    return set4;
  });

  // node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
  var ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
  function variance3(a) {
    return a;
  }
  var PatchProto3 = {
    ...Structural.prototype,
    [ReadonlyArrayPatchTypeId]: {
      _Value: variance3,
      _Patch: variance3
    }
  };
  var EmptyProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
    _tag: "Empty"
  });
  var _empty7 = /* @__PURE__ */ Object.create(EmptyProto3);
  var empty12 = () => _empty7;
  var AndThenProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
    _tag: "AndThen"
  });
  var makeAndThen3 = (first, second) => {
    const o = Object.create(AndThenProto3);
    o.first = first;
    o.second = second;
    return o;
  };
  var AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
    _tag: "Append"
  });
  var makeAppend = (values3) => {
    const o = Object.create(AppendProto);
    o.values = values3;
    return o;
  };
  var SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
    _tag: "Slice"
  });
  var makeSlice = (from, until) => {
    const o = Object.create(SliceProto);
    o.from = from;
    o.until = until;
    return o;
  };
  var UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
    _tag: "Update"
  });
  var makeUpdate = (index, patch3) => {
    const o = Object.create(UpdateProto);
    o.index = index;
    o.patch = patch3;
    return o;
  };
  var diff3 = (options) => {
    let i = 0;
    let patch3 = empty12();
    while (i < options.oldValue.length && i < options.newValue.length) {
      const oldElement = options.oldValue[i];
      const newElement = options.newValue[i];
      const valuePatch = options.differ.diff(oldElement, newElement);
      if (!equals(valuePatch, options.differ.empty)) {
        patch3 = combine6(patch3, makeUpdate(i, valuePatch));
      }
      i = i + 1;
    }
    if (i < options.oldValue.length) {
      patch3 = combine6(patch3, makeSlice(0, i));
    }
    if (i < options.newValue.length) {
      patch3 = combine6(patch3, makeAppend(drop(i)(options.newValue)));
    }
    return patch3;
  };
  var combine6 = /* @__PURE__ */ dual(2, (self, that) => makeAndThen3(self, that));
  var patch3 = /* @__PURE__ */ dual(3, (self, oldValue, differ) => {
    if (self._tag === "Empty") {
      return oldValue;
    }
    let readonlyArray = oldValue.slice();
    let patches = of(self);
    while (isNonEmptyArray2(patches)) {
      const head3 = headNonEmpty(patches);
      const tail = tailNonEmpty(patches);
      switch (head3._tag) {
        case "Empty": {
          patches = tail;
          break;
        }
        case "AndThen": {
          tail.unshift(head3.first, head3.second);
          patches = tail;
          break;
        }
        case "Append": {
          for (const value of head3.values) {
            readonlyArray.push(value);
          }
          patches = tail;
          break;
        }
        case "Slice": {
          readonlyArray = readonlyArray.slice(head3.from, head3.until);
          patches = tail;
          break;
        }
        case "Update": {
          readonlyArray[head3.index] = differ.patch(head3.patch, readonlyArray[head3.index]);
          patches = tail;
          break;
        }
      }
    }
    return readonlyArray;
  });

  // node_modules/effect/dist/esm/internal/differ.js
  var DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
  var DifferProto = {
    [DifferTypeId]: {
      _P: identity,
      _V: identity
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var make14 = (params) => {
    const differ = Object.create(DifferProto);
    differ.empty = params.empty;
    differ.diff = params.diff;
    differ.combine = params.combine;
    differ.patch = params.patch;
    return differ;
  };
  var environment = () => make14({
    empty: empty10(),
    combine: (first, second) => combine4(second)(first),
    diff: (oldValue, newValue) => diff(oldValue, newValue),
    patch: (patch4, oldValue) => patch(oldValue)(patch4)
  });
  var hashSet = () => make14({
    empty: empty11(),
    combine: (first, second) => combine5(second)(first),
    diff: (oldValue, newValue) => diff2(oldValue, newValue),
    patch: (patch4, oldValue) => patch2(oldValue)(patch4)
  });
  var readonlyArray = (differ) => make14({
    empty: empty12(),
    combine: (first, second) => combine6(first, second),
    diff: (oldValue, newValue) => diff3({
      oldValue,
      newValue,
      differ
    }),
    patch: (patch4, oldValue) => patch3(patch4, oldValue, differ)
  });
  var update = () => updateWith((_, a) => a);
  var updateWith = (f) => make14({
    empty: identity,
    combine: (first, second) => {
      if (first === identity) {
        return second;
      }
      if (second === identity) {
        return first;
      }
      return (a) => second(first(a));
    },
    diff: (oldValue, newValue) => {
      if (equals(oldValue, newValue)) {
        return identity;
      }
      return constant(newValue);
    },
    patch: (patch4, oldValue) => f(oldValue, patch4(oldValue))
  });

  // node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
  var BIT_MASK = 255;
  var BIT_SHIFT = 8;
  var active = (patch4) => patch4 & BIT_MASK;
  var enabled = (patch4) => patch4 >> BIT_SHIFT & BIT_MASK;
  var make15 = (active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT);
  var empty13 = /* @__PURE__ */ make15(0, 0);
  var enable = (flag) => make15(flag, flag);
  var disable = (flag) => make15(flag, 0);
  var exclude = /* @__PURE__ */ dual(2, (self, flag) => make15(active(self) & ~flag, enabled(self)));
  var andThen = /* @__PURE__ */ dual(2, (self, that) => self | that);
  var invert = (n) => ~n >>> 0 & BIT_MASK;

  // node_modules/effect/dist/esm/internal/runtimeFlags.js
  var None2 = 0;
  var Interruption = 1 << 0;
  var OpSupervision = 1 << 1;
  var RuntimeMetrics = 1 << 2;
  var WindDown = 1 << 4;
  var CooperativeYielding = 1 << 5;
  var cooperativeYielding = (self) => isEnabled(self, CooperativeYielding);
  var disable2 = /* @__PURE__ */ dual(2, (self, flag) => self & ~flag);
  var enable2 = /* @__PURE__ */ dual(2, (self, flag) => self | flag);
  var interruptible = (self) => interruption(self) && !windDown(self);
  var interruption = (self) => isEnabled(self, Interruption);
  var isEnabled = /* @__PURE__ */ dual(2, (self, flag) => (self & flag) !== 0);
  var make16 = (...flags) => flags.reduce((a, b) => a | b, 0);
  var none5 = /* @__PURE__ */ make16(None2);
  var runtimeMetrics = (self) => isEnabled(self, RuntimeMetrics);
  var windDown = (self) => isEnabled(self, WindDown);
  var diff4 = /* @__PURE__ */ dual(2, (self, that) => make15(self ^ that, that));
  var patch4 = /* @__PURE__ */ dual(2, (self, patch5) => self & (invert(active(patch5)) | enabled(patch5)) | active(patch5) & enabled(patch5));
  var differ = /* @__PURE__ */ make14({
    empty: empty13,
    diff: (oldValue, newValue) => diff4(oldValue, newValue),
    combine: (first, second) => andThen(second)(first),
    patch: (_patch, oldValue) => patch4(oldValue, _patch)
  });

  // node_modules/effect/dist/esm/RuntimeFlagsPatch.js
  var empty14 = empty13;
  var enable3 = enable;
  var disable3 = disable;
  var exclude2 = exclude;

  // node_modules/effect/dist/esm/internal/blockedRequests.js
  var empty15 = {
    _tag: "Empty"
  };
  var par = (self, that) => ({
    _tag: "Par",
    left: self,
    right: that
  });
  var seq = (self, that) => ({
    _tag: "Seq",
    left: self,
    right: that
  });
  var single = (dataSource, blockedRequest) => ({
    _tag: "Single",
    dataSource,
    blockedRequest
  });
  var flatten4 = (self) => {
    let current = of3(self);
    let updated = empty9();
    while (true) {
      const [parallel, sequential] = reduce7(current, [parallelCollectionEmpty(), empty9()], ([parallel2, sequential2], blockedRequest) => {
        const [par2, seq2] = step(blockedRequest);
        return [parallelCollectionCombine(parallel2, par2), appendAll3(sequential2, seq2)];
      });
      updated = merge4(updated, parallel);
      if (isNil(sequential)) {
        return reverse3(updated);
      }
      current = sequential;
    }
    throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
  };
  var step = (requests) => {
    let current = requests;
    let parallel = parallelCollectionEmpty();
    let stack = empty9();
    let sequential = empty9();
    while (true) {
      switch (current._tag) {
        case "Empty": {
          if (isNil(stack)) {
            return [parallel, sequential];
          }
          current = stack.head;
          stack = stack.tail;
          break;
        }
        case "Par": {
          stack = cons(current.right, stack);
          current = current.left;
          break;
        }
        case "Seq": {
          const left3 = current.left;
          const right3 = current.right;
          switch (left3._tag) {
            case "Empty": {
              current = right3;
              break;
            }
            case "Par": {
              const l = left3.left;
              const r = left3.right;
              current = par(seq(l, right3), seq(r, right3));
              break;
            }
            case "Seq": {
              const l = left3.left;
              const r = left3.right;
              current = seq(l, seq(r, right3));
              break;
            }
            case "Single": {
              current = left3;
              sequential = cons(right3, sequential);
              break;
            }
          }
          break;
        }
        case "Single": {
          parallel = parallelCollectionAdd(parallel, current);
          if (isNil(stack)) {
            return [parallel, sequential];
          }
          current = stack.head;
          stack = stack.tail;
          break;
        }
      }
    }
    throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
  };
  var merge4 = (sequential, parallel) => {
    if (isNil(sequential)) {
      return of3(parallelCollectionToSequentialCollection(parallel));
    }
    if (parallelCollectionIsEmpty(parallel)) {
      return sequential;
    }
    const seqHeadKeys = sequentialCollectionKeys(sequential.head);
    const parKeys = parallelCollectionKeys(parallel);
    if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
      return cons(sequentialCollectionCombine(sequential.head, parallelCollectionToSequentialCollection(parallel)), sequential.tail);
    }
    return cons(parallelCollectionToSequentialCollection(parallel), sequential);
  };
  var EntryTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/Entry");

  class EntryImpl {
    request;
    result;
    listeners;
    ownerId;
    state;
    [EntryTypeId] = blockedRequestVariance;
    constructor(request, result, listeners, ownerId, state) {
      this.request = request;
      this.result = result;
      this.listeners = listeners;
      this.ownerId = ownerId;
      this.state = state;
    }
  }
  var blockedRequestVariance = {
    _R: (_) => _
  };
  var makeEntry = (options) => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state);
  var RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
  var parallelVariance = {
    _R: (_) => _
  };

  class ParallelImpl {
    map;
    [RequestBlockParallelTypeId] = parallelVariance;
    constructor(map8) {
      this.map = map8;
    }
  }
  var parallelCollectionEmpty = () => new ParallelImpl(empty8());
  var parallelCollectionAdd = (self, blockedRequest) => new ParallelImpl(modifyAt2(self.map, blockedRequest.dataSource, (_) => orElseSome(map2(_, append2(blockedRequest.blockedRequest)), () => of2(blockedRequest.blockedRequest))));
  var parallelCollectionCombine = (self, that) => new ParallelImpl(reduce6(self.map, that.map, (map8, value, key) => set3(map8, key, match2(get7(map8, key), {
    onNone: () => value,
    onSome: (other) => appendAll2(value, other)
  }))));
  var parallelCollectionIsEmpty = (self) => isEmpty3(self.map);
  var parallelCollectionKeys = (self) => Array.from(keys2(self.map));
  var parallelCollectionToSequentialCollection = (self) => sequentialCollectionMake(map7(self.map, (x) => of2(x)));
  var SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
  var sequentialVariance = {
    _R: (_) => _
  };

  class SequentialImpl {
    map;
    [SequentialCollectionTypeId] = sequentialVariance;
    constructor(map8) {
      this.map = map8;
    }
  }
  var sequentialCollectionMake = (map8) => new SequentialImpl(map8);
  var sequentialCollectionCombine = (self, that) => new SequentialImpl(reduce6(that.map, self.map, (map8, value, key) => set3(map8, key, match2(get7(map8, key), {
    onNone: () => empty4(),
    onSome: (a) => appendAll2(a, value)
  }))));
  var sequentialCollectionKeys = (self) => Array.from(keys2(self.map));
  var sequentialCollectionToChunk = (self) => Array.from(self.map);

  // node_modules/effect/dist/esm/internal/opCodes/cause.js
  var OP_DIE = "Die";
  var OP_EMPTY = "Empty";
  var OP_FAIL = "Fail";
  var OP_INTERRUPT = "Interrupt";
  var OP_PARALLEL = "Parallel";
  var OP_SEQUENTIAL = "Sequential";

  // node_modules/effect/dist/esm/internal/cause.js
  var CauseSymbolKey = "effect/Cause";
  var CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
  var variance4 = {
    _E: (_) => _
  };
  var proto = {
    [CauseTypeId]: variance4,
    [symbol]() {
      return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
    },
    [symbol2](that) {
      return isCause(that) && causeEquals(this, that);
    },
    pipe() {
      return pipeArguments(this, arguments);
    },
    toJSON() {
      switch (this._tag) {
        case "Empty":
          return {
            _id: "Cause",
            _tag: this._tag
          };
        case "Die":
          return {
            _id: "Cause",
            _tag: this._tag,
            defect: toJSON(this.defect)
          };
        case "Interrupt":
          return {
            _id: "Cause",
            _tag: this._tag,
            fiberId: this.fiberId.toJSON()
          };
        case "Fail":
          return {
            _id: "Cause",
            _tag: this._tag,
            failure: toJSON(this.error)
          };
        case "Sequential":
        case "Parallel":
          return {
            _id: "Cause",
            _tag: this._tag,
            left: toJSON(this.left),
            right: toJSON(this.right)
          };
      }
    },
    toString() {
      return pretty(this);
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  };
  var empty16 = /* @__PURE__ */ (() => {
    const o = /* @__PURE__ */ Object.create(proto);
    o._tag = OP_EMPTY;
    return o;
  })();
  var fail = (error) => {
    const o = Object.create(proto);
    o._tag = OP_FAIL;
    o.error = error;
    return o;
  };
  var die = (defect) => {
    const o = Object.create(proto);
    o._tag = OP_DIE;
    o.defect = defect;
    return o;
  };
  var interrupt = (fiberId) => {
    const o = Object.create(proto);
    o._tag = OP_INTERRUPT;
    o.fiberId = fiberId;
    return o;
  };
  var parallel = (left3, right3) => {
    const o = Object.create(proto);
    o._tag = OP_PARALLEL;
    o.left = left3;
    o.right = right3;
    return o;
  };
  var sequential = (left3, right3) => {
    const o = Object.create(proto);
    o._tag = OP_SEQUENTIAL;
    o.left = left3;
    o.right = right3;
    return o;
  };
  var isCause = (u) => hasProperty(u, CauseTypeId);
  var isEmptyType = (self) => self._tag === OP_EMPTY;
  var isFailType = (self) => self._tag === OP_FAIL;
  var isDieType = (self) => self._tag === OP_DIE;
  var isEmpty5 = (self) => {
    if (self._tag === OP_EMPTY) {
      return true;
    }
    return reduce8(self, true, (acc, cause) => {
      switch (cause._tag) {
        case OP_EMPTY: {
          return some2(acc);
        }
        case OP_DIE:
        case OP_FAIL:
        case OP_INTERRUPT: {
          return some2(false);
        }
        default: {
          return none2();
        }
      }
    });
  };
  var isInterrupted = (self) => isSome2(interruptOption(self));
  var isInterruptedOnly = (self) => reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)(self);
  var failures = (self) => reverse2(reduce8(self, empty4(), (list, cause) => cause._tag === OP_FAIL ? some2(pipe(list, prepend2(cause.error))) : none2()));
  var defects = (self) => reverse2(reduce8(self, empty4(), (list, cause) => cause._tag === OP_DIE ? some2(pipe(list, prepend2(cause.defect))) : none2()));
  var interruptors = (self) => reduce8(self, empty7(), (set4, cause) => cause._tag === OP_INTERRUPT ? some2(pipe(set4, add4(cause.fiberId))) : none2());
  var failureOption = (self) => find(self, (cause) => cause._tag === OP_FAIL ? some2(cause.error) : none2());
  var failureOrCause = (self) => {
    const option = failureOption(self);
    switch (option._tag) {
      case "None": {
        return right2(self);
      }
      case "Some": {
        return left2(option.value);
      }
    }
  };
  var flipCauseOption = (self) => match5(self, {
    onEmpty: some2(empty16),
    onFail: map2(fail),
    onDie: (defect) => some2(die(defect)),
    onInterrupt: (fiberId) => some2(interrupt(fiberId)),
    onSequential: mergeWith(sequential),
    onParallel: mergeWith(parallel)
  });
  var interruptOption = (self) => find(self, (cause) => cause._tag === OP_INTERRUPT ? some2(cause.fiberId) : none2());
  var keepDefects = (self) => match5(self, {
    onEmpty: none2(),
    onFail: () => none2(),
    onDie: (defect) => some2(die(defect)),
    onInterrupt: () => none2(),
    onSequential: mergeWith(sequential),
    onParallel: mergeWith(parallel)
  });
  var keepDefectsAndElectFailures = (self) => match5(self, {
    onEmpty: none2(),
    onFail: (failure) => some2(die(failure)),
    onDie: (defect) => some2(die(defect)),
    onInterrupt: () => none2(),
    onSequential: mergeWith(sequential),
    onParallel: mergeWith(parallel)
  });
  var stripFailures = (self) => match5(self, {
    onEmpty: empty16,
    onFail: () => empty16,
    onDie: die,
    onInterrupt: interrupt,
    onSequential: sequential,
    onParallel: parallel
  });
  var electFailures = (self) => match5(self, {
    onEmpty: empty16,
    onFail: die,
    onDie: die,
    onInterrupt: interrupt,
    onSequential: sequential,
    onParallel: parallel
  });
  var map9 = /* @__PURE__ */ dual(2, (self, f) => flatMap7(self, (e) => fail(f(e))));
  var flatMap7 = /* @__PURE__ */ dual(2, (self, f) => match5(self, {
    onEmpty: empty16,
    onFail: (error) => f(error),
    onDie: (defect) => die(defect),
    onInterrupt: (fiberId) => interrupt(fiberId),
    onSequential: (left3, right3) => sequential(left3, right3),
    onParallel: (left3, right3) => parallel(left3, right3)
  }));
  var flatten5 = (self) => flatMap7(self, identity);
  var causeEquals = (left3, right3) => {
    let leftStack = of2(left3);
    let rightStack = of2(right3);
    while (isNonEmpty2(leftStack) && isNonEmpty2(rightStack)) {
      const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce8([empty7(), empty4()], ([parallel2, sequential2], cause) => {
        const [par2, seq2] = evaluateCause(cause);
        return some2([pipe(parallel2, union3(par2)), pipe(sequential2, appendAll2(seq2))]);
      }));
      const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce8([empty7(), empty4()], ([parallel2, sequential2], cause) => {
        const [par2, seq2] = evaluateCause(cause);
        return some2([pipe(parallel2, union3(par2)), pipe(sequential2, appendAll2(seq2))]);
      }));
      if (!equals(leftParallel, rightParallel)) {
        return false;
      }
      leftStack = leftSequential;
      rightStack = rightSequential;
    }
    return true;
  };
  var flattenCause = (cause) => {
    return flattenCauseLoop(of2(cause), empty4());
  };
  var flattenCauseLoop = (causes, flattened) => {
    while (true) {
      const [parallel2, sequential2] = pipe(causes, reduce([empty7(), empty4()], ([parallel3, sequential3], cause) => {
        const [par2, seq2] = evaluateCause(cause);
        return [pipe(parallel3, union3(par2)), pipe(sequential3, appendAll2(seq2))];
      }));
      const updated = size3(parallel2) > 0 ? pipe(flattened, prepend2(parallel2)) : flattened;
      if (isEmpty(sequential2)) {
        return reverse2(updated);
      }
      causes = sequential2;
      flattened = updated;
    }
    throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
  };
  var find = /* @__PURE__ */ dual(2, (self, pf) => {
    const stack = [self];
    while (stack.length > 0) {
      const item = stack.pop();
      const option = pf(item);
      switch (option._tag) {
        case "None": {
          switch (item._tag) {
            case OP_SEQUENTIAL:
            case OP_PARALLEL: {
              stack.push(item.right);
              stack.push(item.left);
              break;
            }
          }
          break;
        }
        case "Some": {
          return option;
        }
      }
    }
    return none2();
  });
  var evaluateCause = (self) => {
    let cause = self;
    const stack = [];
    let _parallel = empty7();
    let _sequential = empty4();
    while (cause !== undefined) {
      switch (cause._tag) {
        case OP_EMPTY: {
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
        case OP_FAIL: {
          _parallel = add4(_parallel, make6(cause._tag, cause.error));
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
        case OP_DIE: {
          _parallel = add4(_parallel, make6(cause._tag, cause.defect));
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
        case OP_INTERRUPT: {
          _parallel = add4(_parallel, make6(cause._tag, cause.fiberId));
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
        case OP_SEQUENTIAL: {
          switch (cause.left._tag) {
            case OP_EMPTY: {
              cause = cause.right;
              break;
            }
            case OP_SEQUENTIAL: {
              cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));
              break;
            }
            case OP_PARALLEL: {
              cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));
              break;
            }
            default: {
              _sequential = prepend2(_sequential, cause.right);
              cause = cause.left;
              break;
            }
          }
          break;
        }
        case OP_PARALLEL: {
          stack.push(cause.right);
          cause = cause.left;
          break;
        }
      }
    }
    throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
  };
  var IsInterruptedOnlyCauseReducer = {
    emptyCase: constTrue,
    failCase: constFalse,
    dieCase: constFalse,
    interruptCase: constTrue,
    sequentialCase: (_, left3, right3) => left3 && right3,
    parallelCase: (_, left3, right3) => left3 && right3
  };
  var OP_SEQUENTIAL_CASE = "SequentialCase";
  var OP_PARALLEL_CASE = "ParallelCase";
  var match5 = /* @__PURE__ */ dual(2, (self, {
    onDie,
    onEmpty,
    onFail,
    onInterrupt,
    onParallel,
    onSequential
  }) => {
    return reduceWithContext(self, undefined, {
      emptyCase: () => onEmpty,
      failCase: (_, error) => onFail(error),
      dieCase: (_, defect) => onDie(defect),
      interruptCase: (_, fiberId) => onInterrupt(fiberId),
      sequentialCase: (_, left3, right3) => onSequential(left3, right3),
      parallelCase: (_, left3, right3) => onParallel(left3, right3)
    });
  });
  var reduce8 = /* @__PURE__ */ dual(3, (self, zero2, pf) => {
    let accumulator = zero2;
    let cause = self;
    const causes = [];
    while (cause !== undefined) {
      const option = pf(accumulator, cause);
      accumulator = isSome2(option) ? option.value : accumulator;
      switch (cause._tag) {
        case OP_SEQUENTIAL: {
          causes.push(cause.right);
          cause = cause.left;
          break;
        }
        case OP_PARALLEL: {
          causes.push(cause.right);
          cause = cause.left;
          break;
        }
        default: {
          cause = undefined;
          break;
        }
      }
      if (cause === undefined && causes.length > 0) {
        cause = causes.pop();
      }
    }
    return accumulator;
  });
  var reduceWithContext = /* @__PURE__ */ dual(3, (self, context, reducer) => {
    const input = [self];
    const output = [];
    while (input.length > 0) {
      const cause = input.pop();
      switch (cause._tag) {
        case OP_EMPTY: {
          output.push(right2(reducer.emptyCase(context)));
          break;
        }
        case OP_FAIL: {
          output.push(right2(reducer.failCase(context, cause.error)));
          break;
        }
        case OP_DIE: {
          output.push(right2(reducer.dieCase(context, cause.defect)));
          break;
        }
        case OP_INTERRUPT: {
          output.push(right2(reducer.interruptCase(context, cause.fiberId)));
          break;
        }
        case OP_SEQUENTIAL: {
          input.push(cause.right);
          input.push(cause.left);
          output.push(left2({
            _tag: OP_SEQUENTIAL_CASE
          }));
          break;
        }
        case OP_PARALLEL: {
          input.push(cause.right);
          input.push(cause.left);
          output.push(left2({
            _tag: OP_PARALLEL_CASE
          }));
          break;
        }
      }
    }
    const accumulator = [];
    while (output.length > 0) {
      const either2 = output.pop();
      switch (either2._tag) {
        case "Left": {
          switch (either2.left._tag) {
            case OP_SEQUENTIAL_CASE: {
              const left3 = accumulator.pop();
              const right3 = accumulator.pop();
              const value = reducer.sequentialCase(context, left3, right3);
              accumulator.push(value);
              break;
            }
            case OP_PARALLEL_CASE: {
              const left3 = accumulator.pop();
              const right3 = accumulator.pop();
              const value = reducer.parallelCase(context, left3, right3);
              accumulator.push(value);
              break;
            }
          }
          break;
        }
        case "Right": {
          accumulator.push(either2.right);
          break;
        }
      }
    }
    if (accumulator.length === 0) {
      throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    return accumulator.pop();
  });
  var pretty = (cause, options) => {
    if (isInterruptedOnly(cause)) {
      return "All fibers interrupted without errors.";
    }
    return prettyErrors(cause).map(function(e) {
      if (options?.renderErrorCause !== true || e.cause === undefined) {
        return e.stack;
      }
      return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
    }).join(`
`);
  };
  var renderErrorCause = (cause, prefix) => {
    const lines = cause.stack.split(`
`);
    let stack = `${prefix}[cause]: ${lines[0]}`;
    for (let i = 1, len = lines.length;i < len; i++) {
      stack += `
${prefix}${lines[i]}`;
    }
    if (cause.cause) {
      stack += ` {
${renderErrorCause(cause.cause, `${prefix}  `)}
${prefix}}`;
    }
    return stack;
  };

  class PrettyError extends globalThis.Error {
    span = undefined;
    constructor(originalError) {
      const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
      const prevLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 1;
      super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
        cause: new PrettyError(originalError.cause)
      } : undefined);
      if (this.message === "") {
        this.message = "An error has occurred";
      }
      Error.stackTraceLimit = prevLimit;
      this.name = originalError instanceof Error ? originalError.name : "Error";
      if (originalErrorIsObject) {
        if (spanSymbol in originalError) {
          this.span = originalError[spanSymbol];
        }
        Object.keys(originalError).forEach((key) => {
          if (!(key in this)) {
            this[key] = originalError[key];
          }
        });
      }
      this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
    }
  }
  var prettyErrorMessage = (u) => {
    if (typeof u === "string") {
      return u;
    }
    if (typeof u === "object" && u !== null && u instanceof Error) {
      return u.message;
    }
    try {
      if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
        return u["toString"]();
      }
    } catch {}
    return stringifyCircular(u);
  };
  var locationRegex = /\((.*)\)/g;
  var spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => new WeakMap);
  var prettyErrorStack = (message, stack, span2) => {
    const out = [message];
    const lines = stack.startsWith(message) ? stack.slice(message.length).split(`
`) : stack.split(`
`);
    for (let i = 1;i < lines.length; i++) {
      if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
        i++;
        continue;
      }
      if (lines[i].includes("Generator.next")) {
        break;
      }
      if (lines[i].includes("effect_internal_function")) {
        break;
      }
      out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
    }
    if (span2) {
      let current = span2;
      let i = 0;
      while (current && current._tag === "Span" && i < 10) {
        const stackFn = spanToTrace.get(current);
        if (typeof stackFn === "function") {
          const stack2 = stackFn();
          if (typeof stack2 === "string") {
            const locationMatchAll = stack2.matchAll(locationRegex);
            let match6 = false;
            for (const [, location2] of locationMatchAll) {
              match6 = true;
              out.push(`    at ${current.name} (${location2})`);
            }
            if (!match6) {
              out.push(`    at ${current.name} (${stack2.replace(/^at /, "")})`);
            }
          } else {
            out.push(`    at ${current.name}`);
          }
        } else {
          out.push(`    at ${current.name}`);
        }
        current = getOrUndefined(current.parent);
        i++;
      }
    }
    return out.join(`
`);
  };
  var spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
  var prettyErrors = (cause) => reduceWithContext(cause, undefined, {
    emptyCase: () => [],
    dieCase: (_, unknownError) => {
      return [new PrettyError(unknownError)];
    },
    failCase: (_, error) => {
      return [new PrettyError(error)];
    },
    interruptCase: () => [],
    parallelCase: (_, l, r) => [...l, ...r],
    sequentialCase: (_, l, r) => [...l, ...r]
  });

  // node_modules/effect/dist/esm/internal/opCodes/deferred.js
  var OP_STATE_PENDING = "Pending";
  var OP_STATE_DONE = "Done";

  // node_modules/effect/dist/esm/internal/deferred.js
  var DeferredSymbolKey = "effect/Deferred";
  var DeferredTypeId = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
  var deferredVariance = {
    _E: (_) => _,
    _A: (_) => _
  };
  var pending = (joiners) => {
    return {
      _tag: OP_STATE_PENDING,
      joiners
    };
  };
  var done = (effect) => {
    return {
      _tag: OP_STATE_DONE,
      effect
    };
  };

  // node_modules/effect/dist/esm/internal/singleShotGen.js
  class SingleShotGen2 {
    self;
    called = false;
    constructor(self) {
      this.self = self;
    }
    next(a) {
      return this.called ? {
        value: a,
        done: true
      } : (this.called = true, {
        value: this.self,
        done: false
      });
    }
    return(a) {
      return {
        value: a,
        done: true
      };
    }
    throw(e) {
      throw e;
    }
    [Symbol.iterator]() {
      return new SingleShotGen2(this.self);
    }
  }

  // node_modules/effect/dist/esm/internal/core.js
  var blocked = (blockedRequests, _continue) => {
    const effect = new EffectPrimitive("Blocked");
    effect.effect_instruction_i0 = blockedRequests;
    effect.effect_instruction_i1 = _continue;
    return effect;
  };
  var runRequestBlock = (blockedRequests) => {
    const effect = new EffectPrimitive("RunBlocked");
    effect.effect_instruction_i0 = blockedRequests;
    return effect;
  };
  var EffectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Effect");

  class RevertFlags {
    patch;
    op;
    _op = OP_REVERT_FLAGS;
    constructor(patch5, op) {
      this.patch = patch5;
      this.op = op;
    }
  }

  class EffectPrimitive {
    _op;
    effect_instruction_i0 = undefined;
    effect_instruction_i1 = undefined;
    effect_instruction_i2 = undefined;
    trace = undefined;
    [EffectTypeId2] = effectVariance;
    constructor(_op) {
      this._op = _op;
    }
    [symbol2](that) {
      return this === that;
    }
    [symbol]() {
      return cached(this, random(this));
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    toJSON() {
      return {
        _id: "Effect",
        _op: this._op,
        effect_instruction_i0: toJSON(this.effect_instruction_i0),
        effect_instruction_i1: toJSON(this.effect_instruction_i1),
        effect_instruction_i2: toJSON(this.effect_instruction_i2)
      };
    }
    toString() {
      return format(this.toJSON());
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
    [Symbol.iterator]() {
      return new SingleShotGen2(new YieldWrap(this));
    }
  }

  class EffectPrimitiveFailure {
    _op;
    effect_instruction_i0 = undefined;
    effect_instruction_i1 = undefined;
    effect_instruction_i2 = undefined;
    trace = undefined;
    [EffectTypeId2] = effectVariance;
    constructor(_op) {
      this._op = _op;
      this._tag = _op;
    }
    [symbol2](that) {
      return exitIsExit(that) && that._op === "Failure" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
    }
    [symbol]() {
      return pipe(string(this._tag), combine(hash(this.effect_instruction_i0)), cached(this));
    }
    get cause() {
      return this.effect_instruction_i0;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    toJSON() {
      return {
        _id: "Exit",
        _tag: this._op,
        cause: this.cause.toJSON()
      };
    }
    toString() {
      return format(this.toJSON());
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
    [Symbol.iterator]() {
      return new SingleShotGen2(new YieldWrap(this));
    }
  }

  class EffectPrimitiveSuccess {
    _op;
    effect_instruction_i0 = undefined;
    effect_instruction_i1 = undefined;
    effect_instruction_i2 = undefined;
    trace = undefined;
    [EffectTypeId2] = effectVariance;
    constructor(_op) {
      this._op = _op;
      this._tag = _op;
    }
    [symbol2](that) {
      return exitIsExit(that) && that._op === "Success" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
    }
    [symbol]() {
      return pipe(string(this._tag), combine(hash(this.effect_instruction_i0)), cached(this));
    }
    get value() {
      return this.effect_instruction_i0;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    toJSON() {
      return {
        _id: "Exit",
        _tag: this._op,
        value: toJSON(this.value)
      };
    }
    toString() {
      return format(this.toJSON());
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
    [Symbol.iterator]() {
      return new SingleShotGen2(new YieldWrap(this));
    }
  }
  var isEffect = (u) => hasProperty(u, EffectTypeId2);
  var withFiberRuntime = (withRuntime) => {
    const effect = new EffectPrimitive(OP_WITH_RUNTIME);
    effect.effect_instruction_i0 = withRuntime;
    return effect;
  };
  var acquireUseRelease = /* @__PURE__ */ dual(3, (acquire, use, release) => uninterruptibleMask((restore) => flatMap8(acquire, (a) => flatMap8(exit(suspend(() => restore(use(a)))), (exit) => {
    return suspend(() => release(a, exit)).pipe(matchCauseEffect({
      onFailure: (cause) => {
        switch (exit._tag) {
          case OP_FAILURE:
            return failCause(sequential(exit.effect_instruction_i0, cause));
          case OP_SUCCESS:
            return failCause(cause);
        }
      },
      onSuccess: () => exit
    }));
  }))));
  var as = /* @__PURE__ */ dual(2, (self, value) => flatMap8(self, () => succeed(value)));
  var asVoid = (self) => as(self, undefined);
  var custom = function() {
    const wrapper = new EffectPrimitive(OP_COMMIT);
    switch (arguments.length) {
      case 2: {
        wrapper.effect_instruction_i0 = arguments[0];
        wrapper.commit = arguments[1];
        break;
      }
      case 3: {
        wrapper.effect_instruction_i0 = arguments[0];
        wrapper.effect_instruction_i1 = arguments[1];
        wrapper.commit = arguments[2];
        break;
      }
      case 4: {
        wrapper.effect_instruction_i0 = arguments[0];
        wrapper.effect_instruction_i1 = arguments[1];
        wrapper.effect_instruction_i2 = arguments[2];
        wrapper.commit = arguments[3];
        break;
      }
      default: {
        throw new Error(getBugErrorMessage("you're not supposed to end up here"));
      }
    }
    return wrapper;
  };
  var unsafeAsync = (register, blockingOn = none4) => {
    const effect = new EffectPrimitive(OP_ASYNC);
    let cancelerRef = undefined;
    effect.effect_instruction_i0 = (resume) => {
      cancelerRef = register(resume);
    };
    effect.effect_instruction_i1 = blockingOn;
    return onInterrupt(effect, (_) => isEffect(cancelerRef) ? cancelerRef : void_);
  };
  var asyncInterrupt = (register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn));
  var async_ = (resume, blockingOn = none4) => {
    return custom(resume, function() {
      let backingResume = undefined;
      let pendingEffect = undefined;
      function proxyResume(effect2) {
        if (backingResume) {
          backingResume(effect2);
        } else if (pendingEffect === undefined) {
          pendingEffect = effect2;
        }
      }
      const effect = new EffectPrimitive(OP_ASYNC);
      effect.effect_instruction_i0 = (resume2) => {
        backingResume = resume2;
        if (pendingEffect) {
          resume2(pendingEffect);
        }
      };
      effect.effect_instruction_i1 = blockingOn;
      let cancelerRef = undefined;
      let controllerRef = undefined;
      if (this.effect_instruction_i0.length !== 1) {
        controllerRef = new AbortController;
        cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
      } else {
        cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
      }
      return cancelerRef || controllerRef ? onInterrupt(effect, (_) => {
        if (controllerRef) {
          controllerRef.abort();
        }
        return cancelerRef ?? void_;
      }) : effect;
    });
  };
  var catchAllCause = /* @__PURE__ */ dual(2, (self, f) => {
    const effect = new EffectPrimitive(OP_ON_FAILURE);
    effect.effect_instruction_i0 = self;
    effect.effect_instruction_i1 = f;
    return effect;
  });
  var catchAll = /* @__PURE__ */ dual(2, (self, f) => matchEffect(self, {
    onFailure: f,
    onSuccess: succeed
  }));
  var catchIf = /* @__PURE__ */ dual(3, (self, predicate, f) => catchAllCause(self, (cause) => {
    const either2 = failureOrCause(cause);
    switch (either2._tag) {
      case "Left":
        return predicate(either2.left) ? f(either2.left) : failCause(cause);
      case "Right":
        return failCause(either2.right);
    }
  }));
  var catchSome = /* @__PURE__ */ dual(2, (self, pf) => catchAllCause(self, (cause) => {
    const either2 = failureOrCause(cause);
    switch (either2._tag) {
      case "Left":
        return pipe(pf(either2.left), getOrElse(() => failCause(cause)));
      case "Right":
        return failCause(either2.right);
    }
  }));
  var checkInterruptible = (f) => withFiberRuntime((_, status) => f(interruption(status.runtimeFlags)));
  var originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
  var capture = (obj, span2) => {
    if (isSome2(span2)) {
      return new Proxy(obj, {
        has(target, p) {
          return p === spanSymbol || p === originalSymbol || p in target;
        },
        get(target, p) {
          if (p === spanSymbol) {
            return span2.value;
          }
          if (p === originalSymbol) {
            return obj;
          }
          return target[p];
        }
      });
    }
    return obj;
  };
  var die2 = (defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect));
  var dieMessage = (message) => failCauseSync(() => die(new RuntimeException(message)));
  var dieSync = (evaluate) => flatMap8(sync(evaluate), die2);
  var either2 = (self) => matchEffect(self, {
    onFailure: (e) => succeed(left2(e)),
    onSuccess: (a) => succeed(right2(a))
  });
  var exit = (self) => matchCause(self, {
    onFailure: exitFailCause,
    onSuccess: exitSucceed
  });
  var fail2 = (error) => isObject(error) && !(spanSymbol in error) ? withFiberRuntime((fiber) => failCause(fail(capture(error, currentSpanFromFiber(fiber))))) : failCause(fail(error));
  var failSync = (evaluate) => flatMap8(sync(evaluate), fail2);
  var failCause = (cause) => {
    const effect = new EffectPrimitiveFailure(OP_FAILURE);
    effect.effect_instruction_i0 = cause;
    return effect;
  };
  var failCauseSync = (evaluate) => flatMap8(sync(evaluate), failCause);
  var fiberId = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.id()));
  var fiberIdWith = (f) => withFiberRuntime((state) => f(state.id()));
  var flatMap8 = /* @__PURE__ */ dual(2, (self, f) => {
    const effect = new EffectPrimitive(OP_ON_SUCCESS);
    effect.effect_instruction_i0 = self;
    effect.effect_instruction_i1 = f;
    return effect;
  });
  var andThen2 = /* @__PURE__ */ dual(2, (self, f) => flatMap8(self, (a) => {
    const b = typeof f === "function" ? f(a) : f;
    if (isEffect(b)) {
      return b;
    } else if (isPromiseLike(b)) {
      return unsafeAsync((resume) => {
        b.then((a2) => resume(succeed(a2)), (e) => resume(fail2(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
      });
    }
    return succeed(b);
  }));
  var step2 = (self) => {
    const effect = new EffectPrimitive("OnStep");
    effect.effect_instruction_i0 = self;
    return effect;
  };
  var flatten6 = (self) => flatMap8(self, identity);
  var flip = (self) => matchEffect(self, {
    onFailure: succeed,
    onSuccess: fail2
  });
  var matchCause = /* @__PURE__ */ dual(2, (self, options) => matchCauseEffect(self, {
    onFailure: (cause) => succeed(options.onFailure(cause)),
    onSuccess: (a) => succeed(options.onSuccess(a))
  }));
  var matchCauseEffect = /* @__PURE__ */ dual(2, (self, options) => {
    const effect = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
    effect.effect_instruction_i0 = self;
    effect.effect_instruction_i1 = options.onFailure;
    effect.effect_instruction_i2 = options.onSuccess;
    return effect;
  });
  var matchEffect = /* @__PURE__ */ dual(2, (self, options) => matchCauseEffect(self, {
    onFailure: (cause) => {
      const defects2 = defects(cause);
      if (defects2.length > 0) {
        return failCause(electFailures(cause));
      }
      const failures2 = failures(cause);
      if (failures2.length > 0) {
        return options.onFailure(unsafeHead(failures2));
      }
      return failCause(cause);
    },
    onSuccess: options.onSuccess
  }));
  var forEachSequential = /* @__PURE__ */ dual(2, (self, f) => suspend(() => {
    const arr = fromIterable(self);
    const ret = allocate(arr.length);
    let i = 0;
    return as(whileLoop({
      while: () => i < arr.length,
      body: () => f(arr[i], i),
      step: (b) => {
        ret[i++] = b;
      }
    }), ret);
  }));
  var forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self, f) => suspend(() => {
    const arr = fromIterable(self);
    let i = 0;
    return whileLoop({
      while: () => i < arr.length,
      body: () => f(arr[i], i),
      step: () => {
        i++;
      }
    });
  }));
  var if_ = /* @__PURE__ */ dual((args) => typeof args[0] === "boolean" || isEffect(args[0]), (self, options) => isEffect(self) ? flatMap8(self, (b) => b ? options.onTrue() : options.onFalse()) : self ? options.onTrue() : options.onFalse());
  var interrupt2 = /* @__PURE__ */ flatMap8(fiberId, (fiberId2) => interruptWith(fiberId2));
  var interruptWith = (fiberId2) => failCause(interrupt(fiberId2));
  var interruptible2 = (self) => {
    const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
    effect.effect_instruction_i0 = enable3(Interruption);
    effect.effect_instruction_i1 = () => self;
    return effect;
  };
  var interruptibleMask = (f) => custom(f, function() {
    const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
    effect.effect_instruction_i0 = enable3(Interruption);
    effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
    return effect;
  });
  var intoDeferred = /* @__PURE__ */ dual(2, (self, deferred) => uninterruptibleMask((restore) => flatMap8(exit(restore(self)), (exit2) => deferredDone(deferred, exit2))));
  var map10 = /* @__PURE__ */ dual(2, (self, f) => flatMap8(self, (a) => sync(() => f(a))));
  var mapBoth = /* @__PURE__ */ dual(2, (self, options) => matchEffect(self, {
    onFailure: (e) => failSync(() => options.onFailure(e)),
    onSuccess: (a) => sync(() => options.onSuccess(a))
  }));
  var mapError = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
    onFailure: (cause) => {
      const either3 = failureOrCause(cause);
      switch (either3._tag) {
        case "Left": {
          return failSync(() => f(either3.left));
        }
        case "Right": {
          return failCause(either3.right);
        }
      }
    },
    onSuccess: succeed
  }));
  var onError = /* @__PURE__ */ dual(2, (self, cleanup) => onExit(self, (exit2) => exitIsSuccess(exit2) ? void_ : cleanup(exit2.effect_instruction_i0)));
  var onExit = /* @__PURE__ */ dual(2, (self, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
    onFailure: (cause1) => {
      const result = exitFailCause(cause1);
      return matchCauseEffect(cleanup(result), {
        onFailure: (cause2) => exitFailCause(sequential(cause1, cause2)),
        onSuccess: () => result
      });
    },
    onSuccess: (success) => {
      const result = exitSucceed(success);
      return zipRight(cleanup(result), result);
    }
  })));
  var onInterrupt = /* @__PURE__ */ dual(2, (self, cleanup) => onExit(self, exitMatch({
    onFailure: (cause) => isInterruptedOnly(cause) ? asVoid(cleanup(interruptors(cause))) : void_,
    onSuccess: () => void_
  })));
  var orElse2 = /* @__PURE__ */ dual(2, (self, that) => attemptOrElse(self, that, succeed));
  var orDie = (self) => orDieWith(self, identity);
  var orDieWith = /* @__PURE__ */ dual(2, (self, f) => matchEffect(self, {
    onFailure: (e) => die2(f(e)),
    onSuccess: succeed
  }));
  var partitionMap2 = partitionMap;
  var runtimeFlags = /* @__PURE__ */ withFiberRuntime((_, status) => succeed(status.runtimeFlags));
  var succeed = (value) => {
    const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
    effect.effect_instruction_i0 = value;
    return effect;
  };
  var suspend = (evaluate) => {
    const effect = new EffectPrimitive(OP_COMMIT);
    effect.commit = evaluate;
    return effect;
  };
  var sync = (thunk) => {
    const effect = new EffectPrimitive(OP_SYNC);
    effect.effect_instruction_i0 = thunk;
    return effect;
  };
  var tap = /* @__PURE__ */ dual((args) => args.length === 3 || args.length === 2 && !(isObject(args[1]) && ("onlyEffect" in args[1])), (self, f) => flatMap8(self, (a) => {
    const b = typeof f === "function" ? f(a) : f;
    if (isEffect(b)) {
      return as(b, a);
    } else if (isPromiseLike(b)) {
      return unsafeAsync((resume) => {
        b.then((_) => resume(succeed(a)), (e) => resume(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
      });
    }
    return succeed(a);
  }));
  var transplant = (f) => withFiberRuntime((state) => {
    const scopeOverride = state.getFiberRef(currentForkScopeOverride);
    const scope = pipe(scopeOverride, getOrElse(() => state.scope()));
    return f(fiberRefLocally(currentForkScopeOverride, some2(scope)));
  });
  var attemptOrElse = /* @__PURE__ */ dual(3, (self, that, onSuccess) => matchCauseEffect(self, {
    onFailure: (cause) => {
      const defects2 = defects(cause);
      if (defects2.length > 0) {
        return failCause(getOrThrow2(keepDefectsAndElectFailures(cause)));
      }
      return that();
    },
    onSuccess
  }));
  var uninterruptible = (self) => {
    const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
    effect.effect_instruction_i0 = disable3(Interruption);
    effect.effect_instruction_i1 = () => self;
    return effect;
  };
  var uninterruptibleMask = (f) => custom(f, function() {
    const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
    effect.effect_instruction_i0 = disable3(Interruption);
    effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
    return effect;
  });
  var void_ = /* @__PURE__ */ succeed(undefined);
  var updateRuntimeFlags = (patch5) => {
    const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
    effect.effect_instruction_i0 = patch5;
    effect.effect_instruction_i1 = undefined;
    return effect;
  };
  var whenEffect = /* @__PURE__ */ dual(2, (self, condition) => flatMap8(condition, (b) => {
    if (b) {
      return pipe(self, map10(some2));
    }
    return succeed(none2());
  }));
  var whileLoop = (options) => {
    const effect = new EffectPrimitive(OP_WHILE);
    effect.effect_instruction_i0 = options.while;
    effect.effect_instruction_i1 = options.body;
    effect.effect_instruction_i2 = options.step;
    return effect;
  };
  var fromIterator = (iterator) => suspend(() => {
    const effect = new EffectPrimitive(OP_ITERATOR);
    effect.effect_instruction_i0 = iterator();
    return effect;
  });
  var gen = function() {
    const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
    return fromIterator(() => f(pipe));
  };
  var fnUntraced = (body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args) {
    return fromIterator(() => body.apply(this, args));
  } : function(...args) {
    let effect = fromIterator(() => body.apply(this, args));
    for (const x of pipeables) {
      effect = x(effect, ...args);
    }
    return effect;
  }, "length", {
    value: body.length,
    configurable: true
  });
  var withConcurrency = /* @__PURE__ */ dual(2, (self, concurrency) => fiberRefLocally(self, currentConcurrency, concurrency));
  var withRequestBatching = /* @__PURE__ */ dual(2, (self, requestBatching) => fiberRefLocally(self, currentRequestBatching, requestBatching));
  var withRuntimeFlags = /* @__PURE__ */ dual(2, (self, update2) => {
    const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
    effect.effect_instruction_i0 = update2;
    effect.effect_instruction_i1 = () => self;
    return effect;
  });
  var withTracerEnabled = /* @__PURE__ */ dual(2, (effect, enabled2) => fiberRefLocally(effect, currentTracerEnabled, enabled2));
  var withTracerTiming = /* @__PURE__ */ dual(2, (effect, enabled2) => fiberRefLocally(effect, currentTracerTimingEnabled, enabled2));
  var yieldNow = (options) => {
    const effect = new EffectPrimitive(OP_YIELD);
    return typeof options?.priority !== "undefined" ? withSchedulingPriority(effect, options.priority) : effect;
  };
  var zip2 = /* @__PURE__ */ dual(2, (self, that) => flatMap8(self, (a) => map10(that, (b) => [a, b])));
  var zipLeft = /* @__PURE__ */ dual(2, (self, that) => flatMap8(self, (a) => as(that, a)));
  var zipRight = /* @__PURE__ */ dual(2, (self, that) => flatMap8(self, () => that));
  var zipWith3 = /* @__PURE__ */ dual(3, (self, that, f) => flatMap8(self, (a) => map10(that, (b) => f(a, b))));
  var never = /* @__PURE__ */ asyncInterrupt(() => {
    const interval = setInterval(() => {}, 2 ** 31 - 1);
    return sync(() => clearInterval(interval));
  });
  var interruptFiber = (self) => flatMap8(fiberId, (fiberId2) => pipe(self, interruptAsFiber(fiberId2)));
  var interruptAsFiber = /* @__PURE__ */ dual(2, (self, fiberId2) => flatMap8(self.interruptAsFork(fiberId2), () => self.await));
  var logLevelAll = {
    _tag: "All",
    syslog: 0,
    label: "ALL",
    ordinal: Number.MIN_SAFE_INTEGER,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var logLevelFatal = {
    _tag: "Fatal",
    syslog: 2,
    label: "FATAL",
    ordinal: 50000,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var logLevelError = {
    _tag: "Error",
    syslog: 3,
    label: "ERROR",
    ordinal: 40000,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var logLevelWarning = {
    _tag: "Warning",
    syslog: 4,
    label: "WARN",
    ordinal: 30000,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var logLevelInfo = {
    _tag: "Info",
    syslog: 6,
    label: "INFO",
    ordinal: 20000,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var logLevelDebug = {
    _tag: "Debug",
    syslog: 7,
    label: "DEBUG",
    ordinal: 1e4,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var logLevelTrace = {
    _tag: "Trace",
    syslog: 7,
    label: "TRACE",
    ordinal: 0,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var logLevelNone = {
    _tag: "None",
    syslog: 7,
    label: "OFF",
    ordinal: Number.MAX_SAFE_INTEGER,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var FiberRefSymbolKey = "effect/FiberRef";
  var FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
  var fiberRefVariance = {
    _A: (_) => _
  };
  var fiberRefGet = (self) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self)));
  var fiberRefGetWith = /* @__PURE__ */ dual(2, (self, f) => flatMap8(fiberRefGet(self), f));
  var fiberRefSet = /* @__PURE__ */ dual(2, (self, value) => fiberRefModify(self, () => [undefined, value]));
  var fiberRefModify = /* @__PURE__ */ dual(2, (self, f) => withFiberRuntime((state) => {
    const [b, a] = f(state.getFiberRef(self));
    state.setFiberRef(self, a);
    return succeed(b);
  }));
  var fiberRefLocally = /* @__PURE__ */ dual(3, (use, self, value) => acquireUseRelease(zipLeft(fiberRefGet(self), fiberRefSet(self, value)), () => use, (oldValue) => fiberRefSet(self, oldValue)));
  var fiberRefLocallyWith = /* @__PURE__ */ dual(3, (use, self, f) => fiberRefGetWith(self, (a) => fiberRefLocally(use, self, f(a))));
  var fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
    differ: update(),
    fork: options?.fork ?? identity,
    join: options?.join
  });
  var fiberRefUnsafeMakeHashSet = (initial) => {
    const differ2 = hashSet();
    return fiberRefUnsafeMakePatch(initial, {
      differ: differ2,
      fork: differ2.empty
    });
  };
  var fiberRefUnsafeMakeReadonlyArray = (initial) => {
    const differ2 = readonlyArray(update());
    return fiberRefUnsafeMakePatch(initial, {
      differ: differ2,
      fork: differ2.empty
    });
  };
  var fiberRefUnsafeMakeContext = (initial) => {
    const differ2 = environment();
    return fiberRefUnsafeMakePatch(initial, {
      differ: differ2,
      fork: differ2.empty
    });
  };
  var fiberRefUnsafeMakePatch = (initial, options) => {
    const _fiberRef = {
      ...CommitPrototype,
      [FiberRefTypeId]: fiberRefVariance,
      initial,
      commit() {
        return fiberRefGet(this);
      },
      diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
      combine: (first, second) => options.differ.combine(first, second),
      patch: (patch5) => (oldValue) => options.differ.patch(patch5, oldValue),
      fork: options.fork,
      join: options.join ?? ((_, n) => n)
    };
    return _fiberRef;
  };
  var fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
    differ,
    fork: differ.empty
  });
  var currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty3()));
  var currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
  var currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
  var currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty8()));
  var currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
  var currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty9()));
  var withSchedulingPriority = /* @__PURE__ */ dual(2, (self, scheduler) => fiberRefLocally(self, currentSchedulingPriority, scheduler));
  var withMaxOpsBeforeYield = /* @__PURE__ */ dual(2, (self, scheduler) => fiberRefLocally(self, currentMaxOpsBeforeYield, scheduler));
  var currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
  var currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
  var currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelDebug)));
  var currentVersionMismatchErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/versionMismatchErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelWarning)));
  var withUnhandledErrorLogLevel = /* @__PURE__ */ dual(2, (self, level) => fiberRefLocally(self, currentUnhandledErrorLogLevel, level));
  var currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty()));
  var metricLabels = /* @__PURE__ */ fiberRefGet(currentMetricLabels);
  var currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
    fork: () => none2(),
    join: (parent, _) => parent
  }));
  var currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty16, {
    fork: () => empty16,
    join: (parent, _) => parent
  }));
  var currentTracerEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
  var currentTracerTimingEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
  var currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty8()));
  var currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty4()));
  var ScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Scope");
  var CloseableScopeTypeId = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
  var scopeAddFinalizer = (self, finalizer) => self.addFinalizer(() => asVoid(finalizer));
  var scopeAddFinalizerExit = (self, finalizer) => self.addFinalizer(finalizer);
  var scopeClose = (self, exit2) => self.close(exit2);
  var scopeFork = (self, strategy) => self.fork(strategy);
  var causeSquash = (self) => {
    return causeSquashWith(identity)(self);
  };
  var causeSquashWith = /* @__PURE__ */ dual(2, (self, f) => {
    const option = pipe(self, failureOption, map2(f));
    switch (option._tag) {
      case "None": {
        return pipe(defects(self), head2, match2({
          onNone: () => {
            const interrupts = fromIterable(interruptors(self)).flatMap((fiberId2) => fromIterable(ids2(fiberId2)).map((id) => `#${id}`));
            return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : undefined);
          },
          onSome: identity
        }));
      }
      case "Some": {
        return option.value;
      }
    }
  });
  var YieldableError = /* @__PURE__ */ function() {

    class YieldableError2 extends globalThis.Error {
      commit() {
        return fail2(this);
      }
      toJSON() {
        const obj = {
          ...this
        };
        if (this.message)
          obj.message = this.message;
        if (this.cause)
          obj.cause = this.cause;
        return obj;
      }
      [NodeInspectSymbol]() {
        if (this.toString !== globalThis.Error.prototype.toString) {
          return this.stack ? `${this.toString()}
${this.stack.split(`
`).slice(1).join(`
`)}` : this.toString();
        } else if ("Bun" in globalThis) {
          return pretty(fail(this), {
            renderErrorCause: true
          });
        }
        return this;
      }
    }
    Object.assign(YieldableError2.prototype, StructuralCommitPrototype);
    return YieldableError2;
  }();
  var makeException = (proto2, tag) => {

    class Base2 extends YieldableError {
      _tag = tag;
    }
    Object.assign(Base2.prototype, proto2);
    Base2.prototype.name = tag;
    return Base2;
  };
  var RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
  var RuntimeException = /* @__PURE__ */ makeException({
    [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
  }, "RuntimeException");
  var isRuntimeException = (u) => hasProperty(u, RuntimeExceptionTypeId);
  var InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
  var InterruptedException = /* @__PURE__ */ makeException({
    [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
  }, "InterruptedException");
  var isInterruptedException = (u) => hasProperty(u, InterruptedExceptionTypeId);
  var IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
  var IllegalArgumentException = /* @__PURE__ */ makeException({
    [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
  }, "IllegalArgumentException");
  var NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
  var NoSuchElementException = /* @__PURE__ */ makeException({
    [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
  }, "NoSuchElementException");
  var isNoSuchElementException = (u) => hasProperty(u, NoSuchElementExceptionTypeId);
  var InvalidPubSubCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
  var InvalidPubSubCapacityException = /* @__PURE__ */ makeException({
    [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
  }, "InvalidPubSubCapacityException");
  var ExceededCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
  var ExceededCapacityException = /* @__PURE__ */ makeException({
    [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
  }, "ExceededCapacityException");
  var TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
  var TimeoutException = /* @__PURE__ */ makeException({
    [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
  }, "TimeoutException");
  var timeoutExceptionFromDuration = (duration) => new TimeoutException(`Operation timed out after '${format2(duration)}'`);
  var UnknownExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
  var UnknownException = /* @__PURE__ */ function() {

    class UnknownException2 extends YieldableError {
      _tag = "UnknownException";
      error;
      constructor(cause, message) {
        super(message ?? "An unknown error occurred", {
          cause
        });
        this.error = cause;
      }
    }
    Object.assign(UnknownException2.prototype, {
      [UnknownExceptionTypeId]: UnknownExceptionTypeId,
      name: "UnknownException"
    });
    return UnknownException2;
  }();
  var exitIsExit = (u) => isEffect(u) && ("_tag" in u) && (u._tag === "Success" || u._tag === "Failure");
  var exitIsFailure = (self) => self._tag === "Failure";
  var exitIsSuccess = (self) => self._tag === "Success";
  var exitAs = /* @__PURE__ */ dual(2, (self, value) => {
    switch (self._tag) {
      case OP_FAILURE: {
        return exitFailCause(self.effect_instruction_i0);
      }
      case OP_SUCCESS: {
        return exitSucceed(value);
      }
    }
  });
  var exitAsVoid = (self) => exitAs(self, undefined);
  var exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel : sequential);
  var exitDie = (defect) => exitFailCause(die(defect));
  var exitFail = (error) => exitFailCause(fail(error));
  var exitFailCause = (cause) => {
    const effect = new EffectPrimitiveFailure(OP_FAILURE);
    effect.effect_instruction_i0 = cause;
    return effect;
  };
  var exitFlatMap = /* @__PURE__ */ dual(2, (self, f) => {
    switch (self._tag) {
      case OP_FAILURE: {
        return exitFailCause(self.effect_instruction_i0);
      }
      case OP_SUCCESS: {
        return f(self.effect_instruction_i0);
      }
    }
  });
  var exitFlatten = (self) => pipe(self, exitFlatMap(identity));
  var exitInterrupt = (fiberId2) => exitFailCause(interrupt(fiberId2));
  var exitMap = /* @__PURE__ */ dual(2, (self, f) => {
    switch (self._tag) {
      case OP_FAILURE:
        return exitFailCause(self.effect_instruction_i0);
      case OP_SUCCESS:
        return exitSucceed(f(self.effect_instruction_i0));
    }
  });
  var exitMapBoth = /* @__PURE__ */ dual(2, (self, {
    onFailure,
    onSuccess
  }) => {
    switch (self._tag) {
      case OP_FAILURE:
        return exitFailCause(pipe(self.effect_instruction_i0, map9(onFailure)));
      case OP_SUCCESS:
        return exitSucceed(onSuccess(self.effect_instruction_i0));
    }
  });
  var exitMatch = /* @__PURE__ */ dual(2, (self, {
    onFailure,
    onSuccess
  }) => {
    switch (self._tag) {
      case OP_FAILURE:
        return onFailure(self.effect_instruction_i0);
      case OP_SUCCESS:
        return onSuccess(self.effect_instruction_i0);
    }
  });
  var exitMatchEffect = /* @__PURE__ */ dual(2, (self, {
    onFailure,
    onSuccess
  }) => {
    switch (self._tag) {
      case OP_FAILURE:
        return onFailure(self.effect_instruction_i0);
      case OP_SUCCESS:
        return onSuccess(self.effect_instruction_i0);
    }
  });
  var exitSucceed = (value) => {
    const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
    effect.effect_instruction_i0 = value;
    return effect;
  };
  var exitVoid = /* @__PURE__ */ exitSucceed(undefined);
  var exitZip = /* @__PURE__ */ dual(2, (self, that) => exitZipWith(self, that, {
    onSuccess: (a, a2) => [a, a2],
    onFailure: sequential
  }));
  var exitZipRight = /* @__PURE__ */ dual(2, (self, that) => exitZipWith(self, that, {
    onSuccess: (_, a2) => a2,
    onFailure: sequential
  }));
  var exitZipWith = /* @__PURE__ */ dual(3, (self, that, {
    onFailure,
    onSuccess
  }) => {
    switch (self._tag) {
      case OP_FAILURE: {
        switch (that._tag) {
          case OP_SUCCESS:
            return exitFailCause(self.effect_instruction_i0);
          case OP_FAILURE: {
            return exitFailCause(onFailure(self.effect_instruction_i0, that.effect_instruction_i0));
          }
        }
      }
      case OP_SUCCESS: {
        switch (that._tag) {
          case OP_SUCCESS:
            return exitSucceed(onSuccess(self.effect_instruction_i0, that.effect_instruction_i0));
          case OP_FAILURE:
            return exitFailCause(that.effect_instruction_i0);
        }
      }
    }
  });
  var exitCollectAllInternal = (exits, combineCauses) => {
    const list = fromIterable2(exits);
    if (!isNonEmpty2(list)) {
      return none2();
    }
    return pipe(tailNonEmpty2(list), reduce(pipe(headNonEmpty2(list), exitMap(of2)), (accumulator, current) => pipe(accumulator, exitZipWith(current, {
      onSuccess: (list2, value) => pipe(list2, prepend2(value)),
      onFailure: combineCauses
    }))), exitMap(reverse2), exitMap((chunk) => toReadonlyArray(chunk)), some2);
  };
  var deferredUnsafeMake = (fiberId2) => {
    const _deferred = {
      ...CommitPrototype,
      [DeferredTypeId]: deferredVariance,
      state: make11(pending([])),
      commit() {
        return deferredAwait(this);
      },
      blockingOn: fiberId2
    };
    return _deferred;
  };
  var deferredMake = () => flatMap8(fiberId, (id) => deferredMakeAs(id));
  var deferredMakeAs = (fiberId2) => sync(() => deferredUnsafeMake(fiberId2));
  var deferredAwait = (self) => asyncInterrupt((resume) => {
    const state = get6(self.state);
    switch (state._tag) {
      case OP_STATE_DONE: {
        return resume(state.effect);
      }
      case OP_STATE_PENDING: {
        state.joiners.push(resume);
        return deferredInterruptJoiner(self, resume);
      }
    }
  }, self.blockingOn);
  var deferredComplete = /* @__PURE__ */ dual(2, (self, effect) => intoDeferred(effect, self));
  var deferredCompleteWith = /* @__PURE__ */ dual(2, (self, effect) => sync(() => {
    const state = get6(self.state);
    switch (state._tag) {
      case OP_STATE_DONE: {
        return false;
      }
      case OP_STATE_PENDING: {
        set2(self.state, done(effect));
        for (let i = 0, len = state.joiners.length;i < len; i++) {
          state.joiners[i](effect);
        }
        return true;
      }
    }
  }));
  var deferredDone = /* @__PURE__ */ dual(2, (self, exit2) => deferredCompleteWith(self, exit2));
  var deferredFail = /* @__PURE__ */ dual(2, (self, error) => deferredCompleteWith(self, fail2(error)));
  var deferredFailCause = /* @__PURE__ */ dual(2, (self, cause) => deferredCompleteWith(self, failCause(cause)));
  var deferredInterrupt = (self) => flatMap8(fiberId, (fiberId2) => deferredCompleteWith(self, interruptWith(fiberId2)));
  var deferredInterruptWith = /* @__PURE__ */ dual(2, (self, fiberId2) => deferredCompleteWith(self, interruptWith(fiberId2)));
  var deferredIsDone = (self) => sync(() => get6(self.state)._tag === OP_STATE_DONE);
  var deferredPoll = (self) => sync(() => {
    const state = get6(self.state);
    switch (state._tag) {
      case OP_STATE_DONE: {
        return some2(state.effect);
      }
      case OP_STATE_PENDING: {
        return none2();
      }
    }
  });
  var deferredSucceed = /* @__PURE__ */ dual(2, (self, value) => deferredCompleteWith(self, succeed(value)));
  var deferredUnsafeDone = (self, effect) => {
    const state = get6(self.state);
    if (state._tag === OP_STATE_PENDING) {
      set2(self.state, done(effect));
      for (let i = 0, len = state.joiners.length;i < len; i++) {
        state.joiners[i](effect);
      }
    }
  };
  var deferredInterruptJoiner = (self, joiner) => sync(() => {
    const state = get6(self.state);
    if (state._tag === OP_STATE_PENDING) {
      const index = state.joiners.indexOf(joiner);
      if (index >= 0) {
        state.joiners.splice(index, 1);
      }
    }
  });
  var constContext = /* @__PURE__ */ withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
  var context = () => constContext;
  var contextWithEffect = (f) => flatMap8(context(), f);
  var provideContext = /* @__PURE__ */ dual(2, (self, context2) => fiberRefLocally(currentContext, context2)(self));
  var provideSomeContext = /* @__PURE__ */ dual(2, (self, context2) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context2))(self));
  var mapInputContext = /* @__PURE__ */ dual(2, (self, f) => contextWithEffect((context2) => provideContext(self, f(context2))));
  var filterEffectOrElse = /* @__PURE__ */ dual(2, (self, options) => flatMap8(self, (a) => flatMap8(options.predicate(a), (pass) => pass ? succeed(a) : options.orElse(a))));
  var filterEffectOrFail = /* @__PURE__ */ dual(2, (self, options) => filterEffectOrElse(self, {
    predicate: options.predicate,
    orElse: (a) => fail2(options.orFailWith(a))
  }));
  var currentSpanFromFiber = (fiber) => {
    const span2 = fiber.currentSpan;
    return span2 !== undefined && span2._tag === "Span" ? some2(span2) : none2();
  };
  var NoopSpanProto = {
    _tag: "Span",
    spanId: "noop",
    traceId: "noop",
    sampled: false,
    status: {
      _tag: "Ended",
      startTime: /* @__PURE__ */ BigInt(0),
      endTime: /* @__PURE__ */ BigInt(0),
      exit: exitVoid
    },
    attributes: /* @__PURE__ */ new Map,
    links: [],
    kind: "internal",
    attribute() {},
    event() {},
    end() {},
    addLinks() {}
  };
  var noopSpan = (options) => Object.assign(Object.create(NoopSpanProto), options);

  // node_modules/effect/dist/esm/Deferred.js
  var make18 = deferredMake;
  var _await = deferredAwait;
  var done2 = deferredDone;
  var fail3 = deferredFail;
  var failCause2 = deferredFailCause;
  var interrupt3 = deferredInterrupt;
  var isDone = deferredIsDone;
  var poll = deferredPoll;
  var succeed2 = deferredSucceed;
  var unsafeMake4 = deferredUnsafeMake;
  var unsafeDone = deferredUnsafeDone;

  // node_modules/effect/dist/esm/Exit.js
  var isExit = exitIsExit;
  var isFailure = exitIsFailure;
  var isSuccess = exitIsSuccess;
  var all = exitCollectAll;
  var die3 = exitDie;
  var fail4 = exitFail;
  var failCause3 = exitFailCause;
  var flatten7 = exitFlatten;
  var interrupt4 = exitInterrupt;
  var map11 = exitMap;
  var mapBoth2 = exitMapBoth;
  var match6 = exitMatch;
  var succeed3 = exitSucceed;
  var void_2 = exitVoid;
  var zip3 = exitZip;
  var zipRight2 = exitZipRight;

  // node_modules/effect/dist/esm/MutableHashMap.js
  var TypeId8 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
  var MutableHashMapProto = {
    [TypeId8]: TypeId8,
    [Symbol.iterator]() {
      return new MutableHashMapIterator(this);
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "MutableHashMap",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };

  class MutableHashMapIterator {
    self;
    referentialIterator;
    bucketIterator;
    constructor(self) {
      this.self = self;
      this.referentialIterator = self.referential[Symbol.iterator]();
    }
    next() {
      if (this.bucketIterator !== undefined) {
        return this.bucketIterator.next();
      }
      const result = this.referentialIterator.next();
      if (result.done) {
        this.bucketIterator = new BucketIterator(this.self.buckets.values());
        return this.next();
      }
      return result;
    }
    [Symbol.iterator]() {
      return new MutableHashMapIterator(this.self);
    }
  }

  class BucketIterator {
    backing;
    constructor(backing) {
      this.backing = backing;
    }
    currentBucket;
    next() {
      if (this.currentBucket === undefined) {
        const result2 = this.backing.next();
        if (result2.done) {
          return result2;
        }
        this.currentBucket = result2.value[Symbol.iterator]();
      }
      const result = this.currentBucket.next();
      if (result.done) {
        this.currentBucket = undefined;
        return this.next();
      }
      return result;
    }
  }
  var empty17 = () => {
    const self = Object.create(MutableHashMapProto);
    self.referential = new Map;
    self.buckets = new Map;
    self.bucketsSize = 0;
    return self;
  };
  var get8 = /* @__PURE__ */ dual(2, (self, key) => {
    if (isEqual(key) === false) {
      return self.referential.has(key) ? some2(self.referential.get(key)) : none2();
    }
    const hash2 = key[symbol]();
    const bucket = self.buckets.get(hash2);
    if (bucket === undefined) {
      return none2();
    }
    return getFromBucket(self, bucket, key);
  });
  var getFromBucket = (self, bucket, key, remove5 = false) => {
    for (let i = 0, len = bucket.length;i < len; i++) {
      if (key[symbol2](bucket[i][0])) {
        const value = bucket[i][1];
        if (remove5) {
          bucket.splice(i, 1);
          self.bucketsSize--;
        }
        return some2(value);
      }
    }
    return none2();
  };
  var has4 = /* @__PURE__ */ dual(2, (self, key) => isSome2(get8(self, key)));
  var set4 = /* @__PURE__ */ dual(3, (self, key, value) => {
    if (isEqual(key) === false) {
      self.referential.set(key, value);
      return self;
    }
    const hash2 = key[symbol]();
    const bucket = self.buckets.get(hash2);
    if (bucket === undefined) {
      self.buckets.set(hash2, [[key, value]]);
      self.bucketsSize++;
      return self;
    }
    removeFromBucket(self, bucket, key);
    bucket.push([key, value]);
    self.bucketsSize++;
    return self;
  });
  var removeFromBucket = (self, bucket, key) => {
    for (let i = 0, len = bucket.length;i < len; i++) {
      if (key[symbol2](bucket[i][0])) {
        bucket.splice(i, 1);
        self.bucketsSize--;
        return;
      }
    }
  };
  var remove5 = /* @__PURE__ */ dual(2, (self, key) => {
    if (isEqual(key) === false) {
      self.referential.delete(key);
      return self;
    }
    const hash2 = key[symbol]();
    const bucket = self.buckets.get(hash2);
    if (bucket === undefined) {
      return self;
    }
    removeFromBucket(self, bucket, key);
    if (bucket.length === 0) {
      self.buckets.delete(hash2);
    }
    return self;
  });
  var size4 = (self) => {
    return self.referential.size + self.bucketsSize;
  };

  // node_modules/effect/dist/esm/MutableList.js
  var TypeId9 = /* @__PURE__ */ Symbol.for("effect/MutableList");
  var MutableListProto = {
    [TypeId9]: TypeId9,
    [Symbol.iterator]() {
      let done3 = false;
      let head3 = this.head;
      return {
        next() {
          if (done3) {
            return this.return();
          }
          if (head3 == null) {
            done3 = true;
            return this.return();
          }
          const value = head3.value;
          head3 = head3.next;
          return {
            done: done3,
            value
          };
        },
        return(value) {
          if (!done3) {
            done3 = true;
          }
          return {
            done: true,
            value
          };
        }
      };
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "MutableList",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var makeNode = (value) => ({
    value,
    removed: false,
    prev: undefined,
    next: undefined
  });
  var empty18 = () => {
    const list = Object.create(MutableListProto);
    list.head = undefined;
    list.tail = undefined;
    list._length = 0;
    return list;
  };
  var isEmpty6 = (self) => length(self) === 0;
  var length = (self) => self._length;
  var append3 = /* @__PURE__ */ dual(2, (self, value) => {
    const node = makeNode(value);
    if (self.head === undefined) {
      self.head = node;
    }
    if (self.tail === undefined) {
      self.tail = node;
    } else {
      self.tail.next = node;
      node.prev = self.tail;
      self.tail = node;
    }
    self._length += 1;
    return self;
  });
  var shift = (self) => {
    const head3 = self.head;
    if (head3 !== undefined) {
      remove6(self, head3);
      return head3.value;
    }
    return;
  };
  var remove6 = (self, node) => {
    if (node.removed) {
      return;
    }
    node.removed = true;
    if (node.prev !== undefined && node.next !== undefined) {
      node.prev.next = node.next;
      node.next.prev = node.prev;
    } else if (node.prev !== undefined) {
      self.tail = node.prev;
      node.prev.next = undefined;
    } else if (node.next !== undefined) {
      self.head = node.next;
      node.next.prev = undefined;
    } else {
      self.tail = undefined;
      self.head = undefined;
    }
    if (self._length > 0) {
      self._length -= 1;
    }
  };

  // node_modules/effect/dist/esm/MutableQueue.js
  var TypeId10 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
  var EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
  var MutableQueueProto = {
    [TypeId10]: TypeId10,
    [Symbol.iterator]() {
      return Array.from(this.queue)[Symbol.iterator]();
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "MutableQueue",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var make19 = (capacity) => {
    const queue = Object.create(MutableQueueProto);
    queue.queue = empty18();
    queue.capacity = capacity;
    return queue;
  };
  var bounded = (capacity) => make19(capacity);
  var unbounded = () => make19(undefined);
  var length2 = (self) => length(self.queue);
  var isEmpty7 = (self) => isEmpty6(self.queue);
  var capacity = (self) => self.capacity === undefined ? Infinity : self.capacity;
  var offer = /* @__PURE__ */ dual(2, (self, value) => {
    const queueLength = length(self.queue);
    if (self.capacity !== undefined && queueLength === self.capacity) {
      return false;
    }
    append3(value)(self.queue);
    return true;
  });
  var offerAll = /* @__PURE__ */ dual(2, (self, values3) => {
    const iterator = values3[Symbol.iterator]();
    let next;
    let remainder = empty4();
    let offering = true;
    while (offering && (next = iterator.next()) && !next.done) {
      offering = offer(next.value)(self);
    }
    while (next != null && !next.done) {
      remainder = prepend2(next.value)(remainder);
      next = iterator.next();
    }
    return reverse2(remainder);
  });
  var poll2 = /* @__PURE__ */ dual(2, (self, def) => {
    if (isEmpty6(self.queue)) {
      return def;
    }
    return shift(self.queue);
  });
  var pollUpTo = /* @__PURE__ */ dual(2, (self, n) => {
    let result = empty4();
    let count = 0;
    while (count < n) {
      const element = poll2(EmptyMutableQueue)(self);
      if (element === EmptyMutableQueue) {
        break;
      }
      result = prepend2(element)(result);
      count += 1;
    }
    return reverse2(result);
  });

  // node_modules/effect/dist/esm/internal/clock.js
  var ClockSymbolKey = "effect/Clock";
  var ClockTypeId = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
  var clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
  var MAX_TIMER_MILLIS = 2 ** 31 - 1;
  var globalClockScheduler = {
    unsafeSchedule(task, duration) {
      const millis2 = toMillis(duration);
      if (millis2 > MAX_TIMER_MILLIS) {
        return constFalse;
      }
      let completed = false;
      const handle = setTimeout(() => {
        completed = true;
        task();
      }, millis2);
      return () => {
        clearTimeout(handle);
        return !completed;
      };
    }
  };
  var performanceNowNanos = /* @__PURE__ */ function() {
    const bigint1e62 = /* @__PURE__ */ BigInt(1e6);
    if (typeof performance === "undefined") {
      return () => BigInt(Date.now()) * bigint1e62;
    }
    let origin;
    return () => {
      if (origin === undefined) {
        origin = BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
      }
      return origin + BigInt(Math.round(performance.now() * 1e6));
    };
  }();
  var processOrPerformanceNow = /* @__PURE__ */ function() {
    const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : undefined;
    if (!processHrtime) {
      return performanceNowNanos;
    }
    const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
    return () => origin + processHrtime.bigint();
  }();

  class ClockImpl {
    [ClockTypeId] = ClockTypeId;
    unsafeCurrentTimeMillis() {
      return Date.now();
    }
    unsafeCurrentTimeNanos() {
      return processOrPerformanceNow();
    }
    currentTimeMillis = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeMillis());
    currentTimeNanos = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeNanos());
    scheduler() {
      return succeed(globalClockScheduler);
    }
    sleep(duration) {
      return async_((resume) => {
        const canceler = globalClockScheduler.unsafeSchedule(() => resume(void_), duration);
        return asVoid(sync(canceler));
      });
    }
  }
  var make20 = () => new ClockImpl;

  // node_modules/effect/dist/esm/internal/opCodes/configError.js
  var OP_AND = "And";
  var OP_OR = "Or";
  var OP_INVALID_DATA = "InvalidData";
  var OP_MISSING_DATA = "MissingData";
  var OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
  var OP_UNSUPPORTED = "Unsupported";

  // node_modules/effect/dist/esm/internal/configError.js
  var ConfigErrorSymbolKey = "effect/ConfigError";
  var ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
  var proto2 = {
    _tag: "ConfigError",
    [ConfigErrorTypeId]: ConfigErrorTypeId
  };
  var And = (self, that) => {
    const error = Object.create(proto2);
    error._op = OP_AND;
    error.left = self;
    error.right = that;
    Object.defineProperty(error, "toString", {
      enumerable: false,
      value() {
        return `${this.left} and ${this.right}`;
      }
    });
    Object.defineProperty(error, "message", {
      enumerable: false,
      get() {
        return this.toString();
      }
    });
    return error;
  };
  var Or = (self, that) => {
    const error = Object.create(proto2);
    error._op = OP_OR;
    error.left = self;
    error.right = that;
    Object.defineProperty(error, "toString", {
      enumerable: false,
      value() {
        return `${this.left} or ${this.right}`;
      }
    });
    Object.defineProperty(error, "message", {
      enumerable: false,
      get() {
        return this.toString();
      }
    });
    return error;
  };
  var InvalidData = (path, message, options = {
    pathDelim: "."
  }) => {
    const error = Object.create(proto2);
    error._op = OP_INVALID_DATA;
    error.path = path;
    error.message = message;
    Object.defineProperty(error, "toString", {
      enumerable: false,
      value() {
        const path2 = pipe(this.path, join(options.pathDelim));
        return `(Invalid data at ${path2}: "${this.message}")`;
      }
    });
    return error;
  };
  var MissingData = (path, message, options = {
    pathDelim: "."
  }) => {
    const error = Object.create(proto2);
    error._op = OP_MISSING_DATA;
    error.path = path;
    error.message = message;
    Object.defineProperty(error, "toString", {
      enumerable: false,
      value() {
        const path2 = pipe(this.path, join(options.pathDelim));
        return `(Missing data at ${path2}: "${this.message}")`;
      }
    });
    return error;
  };
  var SourceUnavailable = (path, message, cause, options = {
    pathDelim: "."
  }) => {
    const error = Object.create(proto2);
    error._op = OP_SOURCE_UNAVAILABLE;
    error.path = path;
    error.message = message;
    error.cause = cause;
    Object.defineProperty(error, "toString", {
      enumerable: false,
      value() {
        const path2 = pipe(this.path, join(options.pathDelim));
        return `(Source unavailable at ${path2}: "${this.message}")`;
      }
    });
    return error;
  };
  var Unsupported = (path, message, options = {
    pathDelim: "."
  }) => {
    const error = Object.create(proto2);
    error._op = OP_UNSUPPORTED;
    error.path = path;
    error.message = message;
    Object.defineProperty(error, "toString", {
      enumerable: false,
      value() {
        const path2 = pipe(this.path, join(options.pathDelim));
        return `(Unsupported operation at ${path2}: "${this.message}")`;
      }
    });
    return error;
  };
  var prefixed = /* @__PURE__ */ dual(2, (self, prefix) => {
    switch (self._op) {
      case OP_AND: {
        return And(prefixed(self.left, prefix), prefixed(self.right, prefix));
      }
      case OP_OR: {
        return Or(prefixed(self.left, prefix), prefixed(self.right, prefix));
      }
      case OP_INVALID_DATA: {
        return InvalidData([...prefix, ...self.path], self.message);
      }
      case OP_MISSING_DATA: {
        return MissingData([...prefix, ...self.path], self.message);
      }
      case OP_SOURCE_UNAVAILABLE: {
        return SourceUnavailable([...prefix, ...self.path], self.message, self.cause);
      }
      case OP_UNSUPPORTED: {
        return Unsupported([...prefix, ...self.path], self.message);
      }
    }
  });

  // node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
  var empty19 = {
    _tag: "Empty"
  };
  var patch5 = /* @__PURE__ */ dual(2, (path, patch6) => {
    let input = of3(patch6);
    let output = path;
    while (isCons(input)) {
      const patch7 = input.head;
      switch (patch7._tag) {
        case "Empty": {
          input = input.tail;
          break;
        }
        case "AndThen": {
          input = cons(patch7.first, cons(patch7.second, input.tail));
          break;
        }
        case "MapName": {
          output = map3(output, patch7.f);
          input = input.tail;
          break;
        }
        case "Nested": {
          output = prepend(output, patch7.name);
          input = input.tail;
          break;
        }
        case "Unnested": {
          const containsName = pipe(head(output), contains(patch7.name));
          if (containsName) {
            output = tailNonEmpty(output);
            input = input.tail;
          } else {
            return left2(MissingData(output, `Expected ${patch7.name} to be in path in ConfigProvider#unnested`));
          }
          break;
        }
      }
    }
    return right2(output);
  });

  // node_modules/effect/dist/esm/internal/opCodes/config.js
  var OP_CONSTANT = "Constant";
  var OP_FAIL2 = "Fail";
  var OP_FALLBACK = "Fallback";
  var OP_DESCRIBED = "Described";
  var OP_LAZY = "Lazy";
  var OP_MAP_OR_FAIL = "MapOrFail";
  var OP_NESTED = "Nested";
  var OP_PRIMITIVE = "Primitive";
  var OP_SEQUENCE = "Sequence";
  var OP_HASHMAP = "HashMap";
  var OP_ZIP_WITH = "ZipWith";

  // node_modules/effect/dist/esm/internal/configProvider.js
  var concat = (l, r) => [...l, ...r];
  var ConfigProviderSymbolKey = "effect/ConfigProvider";
  var ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
  var configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
  var FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
  var FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
  var make22 = (options) => ({
    [ConfigProviderTypeId]: ConfigProviderTypeId,
    pipe() {
      return pipeArguments(this, arguments);
    },
    ...options
  });
  var makeFlat = (options) => ({
    [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
    patch: options.patch,
    load: (path, config, split = true) => options.load(path, config, split),
    enumerateChildren: options.enumerateChildren
  });
  var fromFlat = (flat) => make22({
    load: (config) => flatMap8(fromFlatLoop(flat, empty(), config, false), (chunk) => match2(head(chunk), {
      onNone: () => fail2(MissingData(empty(), `Expected a single value having structure: ${config}`)),
      onSome: succeed
    })),
    flattened: flat
  });
  var fromEnv = (options) => {
    const {
      pathDelim,
      seqDelim
    } = Object.assign({}, {
      pathDelim: "_",
      seqDelim: ","
    }, options);
    const makePathString = (path) => pipe(path, join(pathDelim));
    const unmakePathString = (pathString) => pathString.split(pathDelim);
    const getEnv = () => typeof process !== "undefined" && ("env" in process) && typeof process.env === "object" ? process.env : {};
    const load = (path, primitive, split = true) => {
      const pathString = makePathString(path);
      const current = getEnv();
      const valueOpt = pathString in current ? some2(current[pathString]) : none2();
      return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap8((value) => parsePrimitive(value, path, primitive, seqDelim, split)));
    };
    const enumerateChildren = (path) => sync(() => {
      const current = getEnv();
      const keys3 = Object.keys(current);
      const keyPaths = keys3.map((value) => unmakePathString(value.toUpperCase()));
      const filteredKeyPaths = keyPaths.filter((keyPath) => {
        for (let i = 0;i < path.length; i++) {
          const pathComponent = pipe(path, unsafeGet(i));
          const currentElement = keyPath[i];
          if (currentElement === undefined || pathComponent !== currentElement) {
            return false;
          }
        }
        return true;
      }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
      return fromIterable5(filteredKeyPaths);
    });
    return fromFlat(makeFlat({
      load,
      enumerateChildren,
      patch: empty19
    }));
  };
  var extend = (leftDef, rightDef, left3, right3) => {
    const leftPad = unfold(left3.length, (index) => index >= right3.length ? none2() : some2([leftDef(index), index + 1]));
    const rightPad = unfold(right3.length, (index) => index >= left3.length ? none2() : some2([rightDef(index), index + 1]));
    const leftExtension = concat(left3, leftPad);
    const rightExtension = concat(right3, rightPad);
    return [leftExtension, rightExtension];
  };
  var appendConfigPath = (path, config) => {
    let op = config;
    if (op._tag === "Nested") {
      const out = path.slice();
      while (op._tag === "Nested") {
        out.push(op.name);
        op = op.config;
      }
      return out;
    }
    return path;
  };
  var fromFlatLoop = (flat, prefix, config, split) => {
    const op = config;
    switch (op._tag) {
      case OP_CONSTANT: {
        return succeed(of(op.value));
      }
      case OP_DESCRIBED: {
        return suspend(() => fromFlatLoop(flat, prefix, op.config, split));
      }
      case OP_FAIL2: {
        return fail2(MissingData(prefix, op.message));
      }
      case OP_FALLBACK: {
        return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split)), catchAll((error1) => {
          if (op.condition(error1)) {
            return pipe(fromFlatLoop(flat, prefix, op.second, split), catchAll((error2) => fail2(Or(error1, error2))));
          }
          return fail2(error1);
        }));
      }
      case OP_LAZY: {
        return suspend(() => fromFlatLoop(flat, prefix, op.config(), split));
      }
      case OP_MAP_OR_FAIL: {
        return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split), flatMap8(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
      }
      case OP_NESTED: {
        return suspend(() => fromFlatLoop(flat, concat(prefix, of(op.name)), op.config, split));
      }
      case OP_PRIMITIVE: {
        return pipe(patch5(prefix, flat.patch), flatMap8((prefix2) => pipe(flat.load(prefix2, op, split), flatMap8((values3) => {
          if (values3.length === 0) {
            const name = pipe(last(prefix2), getOrElse(() => "<n/a>"));
            return fail2(MissingData([], `Expected ${op.description} with name ${name}`));
          }
          return succeed(values3);
        }))));
      }
      case OP_SEQUENCE: {
        return pipe(patch5(prefix, flat.patch), flatMap8((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap8(indicesFrom), flatMap8((indices) => {
          if (indices.length === 0) {
            return suspend(() => map10(fromFlatLoop(flat, prefix, op.config, true), of));
          }
          return pipe(forEachSequential(indices, (index) => fromFlatLoop(flat, append(prefix, `[${index}]`), op.config, true)), map10((chunkChunk) => {
            const flattened = flatten(chunkChunk);
            if (flattened.length === 0) {
              return of(empty());
            }
            return of(flattened);
          }));
        }))));
      }
      case OP_HASHMAP: {
        return suspend(() => pipe(patch5(prefix, flat.patch), flatMap8((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap8((keys3) => {
          return pipe(keys3, forEachSequential((key) => fromFlatLoop(flat, concat(prefix2, of(key)), op.valueConfig, split)), map10((matrix) => {
            if (matrix.length === 0) {
              return of(empty8());
            }
            return pipe(transpose(matrix), map3((values3) => fromIterable6(zip(fromIterable(keys3), values3))));
          }));
        })))));
      }
      case OP_ZIP_WITH: {
        return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split), either2, flatMap8((left3) => pipe(fromFlatLoop(flat, prefix, op.right, split), either2, flatMap8((right3) => {
          if (isLeft2(left3) && isLeft2(right3)) {
            return fail2(And(left3.left, right3.left));
          }
          if (isLeft2(left3) && isRight2(right3)) {
            return fail2(left3.left);
          }
          if (isRight2(left3) && isLeft2(right3)) {
            return fail2(right3.left);
          }
          if (isRight2(left3) && isRight2(right3)) {
            const path = pipe(prefix, join("."));
            const fail5 = fromFlatLoopFail(prefix, path);
            const [lefts, rights] = extend(fail5, fail5, pipe(left3.right, map3(right2)), pipe(right3.right, map3(right2)));
            return pipe(lefts, zip(rights), forEachSequential(([left4, right4]) => pipe(zip2(left4, right4), map10(([left5, right5]) => op.zip(left5, right5)))));
          }
          throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
        })))));
      }
    }
  };
  var fromFlatLoopFail = (prefix, path) => (index) => left2(MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`));
  var splitPathString = (text, delim) => {
    const split = text.split(new RegExp(`\\s*${escape(delim)}\\s*`));
    return split;
  };
  var parsePrimitive = (text, path, primitive, delimiter, split) => {
    if (!split) {
      return pipe(primitive.parse(text), mapBoth({
        onFailure: prefixed(path),
        onSuccess: of
      }));
    }
    return pipe(splitPathString(text, delimiter), forEachSequential((char) => primitive.parse(char.trim())), mapError(prefixed(path)));
  };
  var transpose = (array3) => {
    return Object.keys(array3[0]).map((column) => array3.map((row) => row[column]));
  };
  var indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth({
    onFailure: () => empty(),
    onSuccess: sort(Order)
  }), either2, map10(merge));
  var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
  var parseQuotedIndex = (str) => {
    const match7 = str.match(QUOTED_INDEX_REGEX);
    if (match7 !== null) {
      const matchedIndex = match7[2];
      return pipe(matchedIndex !== undefined && matchedIndex.length > 0 ? some2(matchedIndex) : none2(), flatMap(parseInteger));
    }
    return none2();
  };
  var parseInteger = (str) => {
    const parsedIndex = Number.parseInt(str);
    return Number.isNaN(parsedIndex) ? none2() : some2(parsedIndex);
  };

  // node_modules/effect/dist/esm/internal/defaultServices/console.js
  var TypeId11 = /* @__PURE__ */ Symbol.for("effect/Console");
  var consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
  var defaultConsole = {
    [TypeId11]: TypeId11,
    assert(condition, ...args) {
      return sync(() => {
        console.assert(condition, ...args);
      });
    },
    clear: /* @__PURE__ */ sync(() => {
      console.clear();
    }),
    count(label) {
      return sync(() => {
        console.count(label);
      });
    },
    countReset(label) {
      return sync(() => {
        console.countReset(label);
      });
    },
    debug(...args) {
      return sync(() => {
        console.debug(...args);
      });
    },
    dir(item, options) {
      return sync(() => {
        console.dir(item, options);
      });
    },
    dirxml(...args) {
      return sync(() => {
        console.dirxml(...args);
      });
    },
    error(...args) {
      return sync(() => {
        console.error(...args);
      });
    },
    group(options) {
      return options?.collapsed ? sync(() => console.groupCollapsed(options?.label)) : sync(() => console.group(options?.label));
    },
    groupEnd: /* @__PURE__ */ sync(() => {
      console.groupEnd();
    }),
    info(...args) {
      return sync(() => {
        console.info(...args);
      });
    },
    log(...args) {
      return sync(() => {
        console.log(...args);
      });
    },
    table(tabularData, properties) {
      return sync(() => {
        console.table(tabularData, properties);
      });
    },
    time(label) {
      return sync(() => console.time(label));
    },
    timeEnd(label) {
      return sync(() => console.timeEnd(label));
    },
    timeLog(label, ...args) {
      return sync(() => {
        console.timeLog(label, ...args);
      });
    },
    trace(...args) {
      return sync(() => {
        console.trace(...args);
      });
    },
    warn(...args) {
      return sync(() => {
        console.warn(...args);
      });
    },
    unsafe: console
  };

  // node_modules/effect/dist/esm/internal/random.js
  var RandomSymbolKey = "effect/Random";
  var RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
  var randomTag = /* @__PURE__ */ GenericTag("effect/Random");

  class RandomImpl {
    seed;
    [RandomTypeId] = RandomTypeId;
    PRNG;
    constructor(seed) {
      this.seed = seed;
      this.PRNG = new PCGRandom(seed);
    }
    get next() {
      return sync(() => this.PRNG.number());
    }
    get nextBoolean() {
      return map10(this.next, (n) => n > 0.5);
    }
    get nextInt() {
      return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
    }
    nextRange(min2, max2) {
      return map10(this.next, (n) => (max2 - min2) * n + min2);
    }
    nextIntBetween(min2, max2) {
      return sync(() => this.PRNG.integer(max2 - min2) + min2);
    }
    shuffle(elements) {
      return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
    }
  }
  var shuffleWith = (elements, nextIntBounded) => {
    return suspend(() => pipe(sync(() => Array.from(elements)), flatMap8((buffer) => {
      const numbers = [];
      for (let i = buffer.length;i >= 2; i = i - 1) {
        numbers.push(i);
      }
      return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map10((k) => swap(buffer, n - 1, k)))), as(fromIterable2(buffer)));
    })));
  };
  var swap = (buffer, index1, index2) => {
    const tmp = buffer[index1];
    buffer[index1] = buffer[index2];
    buffer[index2] = tmp;
    return buffer;
  };
  var make23 = (seed) => new RandomImpl(hash(seed));

  class FixedRandomImpl {
    values;
    [RandomTypeId] = RandomTypeId;
    index = 0;
    constructor(values3) {
      this.values = values3;
      if (values3.length === 0) {
        throw new Error("Requires at least one value");
      }
    }
    getNextValue() {
      const value = this.values[this.index];
      this.index = (this.index + 1) % this.values.length;
      return value;
    }
    get next() {
      return sync(() => {
        const value = this.getNextValue();
        if (typeof value === "number") {
          return Math.max(0, Math.min(1, value));
        }
        return hash(value) / 2147483647;
      });
    }
    get nextBoolean() {
      return sync(() => {
        const value = this.getNextValue();
        if (typeof value === "boolean") {
          return value;
        }
        return hash(value) % 2 === 0;
      });
    }
    get nextInt() {
      return sync(() => {
        const value = this.getNextValue();
        if (typeof value === "number" && Number.isFinite(value)) {
          return Math.round(value);
        }
        return Math.abs(hash(value));
      });
    }
    nextRange(min2, max2) {
      return map10(this.next, (n) => (max2 - min2) * n + min2);
    }
    nextIntBetween(min2, max2) {
      return sync(() => {
        const value = this.getNextValue();
        if (typeof value === "number" && Number.isFinite(value)) {
          return Math.max(min2, Math.min(max2 - 1, Math.round(value)));
        }
        const hash2 = Math.abs(hash(value));
        return min2 + hash2 % (max2 - min2);
      });
    }
    shuffle(elements) {
      return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
    }
  }
  var fixed = (values3) => new FixedRandomImpl(values3);

  // node_modules/effect/dist/esm/internal/tracer.js
  var TracerTypeId = /* @__PURE__ */ Symbol.for("effect/Tracer");
  var make24 = (options) => ({
    [TracerTypeId]: TracerTypeId,
    ...options
  });
  var tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
  var spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
  var randomHexString = /* @__PURE__ */ function() {
    const characters = "abcdef0123456789";
    const charactersLength = characters.length;
    return function(length3) {
      let result = "";
      for (let i = 0;i < length3; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
      }
      return result;
    };
  }();

  class NativeSpan {
    name;
    parent;
    context;
    startTime;
    kind;
    _tag = "Span";
    spanId;
    traceId = "native";
    sampled = true;
    status;
    attributes;
    events = [];
    links;
    constructor(name, parent, context2, links, startTime, kind) {
      this.name = name;
      this.parent = parent;
      this.context = context2;
      this.startTime = startTime;
      this.kind = kind;
      this.status = {
        _tag: "Started",
        startTime
      };
      this.attributes = new Map;
      this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
      this.spanId = randomHexString(16);
      this.links = Array.from(links);
    }
    end(endTime, exit2) {
      this.status = {
        _tag: "Ended",
        endTime,
        exit: exit2,
        startTime: this.status.startTime
      };
    }
    attribute(key, value) {
      this.attributes.set(key, value);
    }
    event(name, startTime, attributes) {
      this.events.push([name, startTime, attributes ?? {}]);
    }
    addLinks(links) {
      this.links.push(...links);
    }
  }
  var nativeTracer = /* @__PURE__ */ make24({
    span: (name, parent, context2, links, startTime, kind) => new NativeSpan(name, parent, context2, links, startTime, kind),
    context: (f) => f()
  });
  var addSpanStackTrace = (options) => {
    if (options?.captureStackTrace === false) {
      return options;
    } else if (options?.captureStackTrace !== undefined && typeof options.captureStackTrace !== "boolean") {
      return options;
    }
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 3;
    const traceError = new Error;
    Error.stackTraceLimit = limit;
    let cache = false;
    return {
      ...options,
      captureStackTrace: () => {
        if (cache !== false) {
          return cache;
        }
        if (traceError.stack !== undefined) {
          const stack = traceError.stack.split(`
`);
          if (stack[3] !== undefined) {
            cache = stack[3].trim();
            return cache;
          }
        }
      }
    };
  };
  var DisablePropagation = /* @__PURE__ */ Reference2()("effect/Tracer/DisablePropagation", {
    defaultValue: constFalse
  });

  // node_modules/effect/dist/esm/internal/defaultServices.js
  var liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty3(), /* @__PURE__ */ add2(clockTag, /* @__PURE__ */ make20()), /* @__PURE__ */ add2(consoleTag, defaultConsole), /* @__PURE__ */ add2(randomTag, /* @__PURE__ */ make23(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add2(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add2(tracerTag, nativeTracer));
  var currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
  var sleep = (duration) => {
    const decodedDuration = decode(duration);
    return clockWith((clock) => clock.sleep(decodedDuration));
  };
  var defaultServicesWith = (f) => withFiberRuntime((fiber) => f(fiber.currentDefaultServices));
  var clockWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key)));
  var currentTimeMillis = /* @__PURE__ */ clockWith((clock) => clock.currentTimeMillis);
  var currentTimeNanos = /* @__PURE__ */ clockWith((clock) => clock.currentTimeNanos);
  var withClock = /* @__PURE__ */ dual(2, (effect, c) => fiberRefLocallyWith(currentServices, add2(clockTag, c))(effect));
  var withConfigProvider = /* @__PURE__ */ dual(2, (self, provider) => fiberRefLocallyWith(currentServices, add2(configProviderTag, provider))(self));
  var configProviderWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(configProviderTag.key)));
  var randomWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(randomTag.key)));
  var withRandom = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add2(randomTag, value))(effect));
  var tracerWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(tracerTag.key)));
  var withTracer = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add2(tracerTag, value))(effect));

  // node_modules/effect/dist/esm/Clock.js
  var sleep2 = sleep;
  var currentTimeMillis2 = currentTimeMillis;
  var currentTimeNanos2 = currentTimeNanos;
  var clockWith2 = clockWith;
  var Clock = clockTag;

  // node_modules/effect/dist/esm/internal/fiberRefs.js
  function unsafeMake5(fiberRefLocals) {
    return new FiberRefsImpl(fiberRefLocals);
  }
  function empty20() {
    return unsafeMake5(new Map);
  }
  var FiberRefsSym = /* @__PURE__ */ Symbol.for("effect/FiberRefs");

  class FiberRefsImpl {
    locals;
    [FiberRefsSym] = FiberRefsSym;
    constructor(locals) {
      this.locals = locals;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
    const ref = _ref;
    let parentStack = _parentStack;
    let childStack = _childStack;
    let childModified = _childModified;
    let ret = undefined;
    while (ret === undefined) {
      if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
        const parentFiberId = headNonEmpty(parentStack)[0];
        const parentAncestors = tailNonEmpty(parentStack);
        const childFiberId = headNonEmpty(childStack)[0];
        const childRefValue = headNonEmpty(childStack)[1];
        const childAncestors = tailNonEmpty(childStack);
        if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
          parentStack = parentAncestors;
        } else {
          if (parentFiberId.id < childFiberId.id) {
            childStack = childAncestors;
            childModified = true;
          } else if (parentFiberId.id > childFiberId.id) {
            parentStack = parentAncestors;
          } else {
            ret = [childRefValue, childModified];
          }
        }
      } else {
        ret = [ref.initial, true];
      }
    }
    return ret;
  };
  var joinAs = /* @__PURE__ */ dual(3, (self, fiberId2, that) => {
    const parentFiberRefs = new Map(self.locals);
    that.locals.forEach((childStack, fiberRef) => {
      const childValue = childStack[0][1];
      if (!childStack[0][0][symbol2](fiberId2)) {
        if (!parentFiberRefs.has(fiberRef)) {
          if (equals(childValue, fiberRef.initial)) {
            return;
          }
          parentFiberRefs.set(fiberRef, [[fiberId2, fiberRef.join(fiberRef.initial, childValue)]]);
          return;
        }
        const parentStack = parentFiberRefs.get(fiberRef);
        const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
        if (wasModified) {
          const patch6 = fiberRef.diff(ancestor, childValue);
          const oldValue = parentStack[0][1];
          const newValue = fiberRef.join(oldValue, fiberRef.patch(patch6)(oldValue));
          if (!equals(oldValue, newValue)) {
            let newStack;
            const parentFiberId = parentStack[0][0];
            if (parentFiberId[symbol2](fiberId2)) {
              newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
            } else {
              newStack = [[fiberId2, newValue], ...parentStack];
            }
            parentFiberRefs.set(fiberRef, newStack);
          }
        }
      }
    });
    return new FiberRefsImpl(parentFiberRefs);
  });
  var forkAs = /* @__PURE__ */ dual(2, (self, childId) => {
    const map12 = new Map;
    unsafeForkAs(self, map12, childId);
    return new FiberRefsImpl(map12);
  });
  var unsafeForkAs = (self, map12, fiberId2) => {
    self.locals.forEach((stack, fiberRef) => {
      const oldValue = stack[0][1];
      const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
      if (equals(oldValue, newValue)) {
        map12.set(fiberRef, stack);
      } else {
        map12.set(fiberRef, [[fiberId2, newValue], ...stack]);
      }
    });
  };
  var fiberRefs = (self) => fromIterable5(self.locals.keys());
  var setAll = (self) => forEachSequentialDiscard(fiberRefs(self), (fiberRef) => fiberRefSet(fiberRef, getOrDefault(self, fiberRef)));
  var delete_ = /* @__PURE__ */ dual(2, (self, fiberRef) => {
    const locals = new Map(self.locals);
    locals.delete(fiberRef);
    return new FiberRefsImpl(locals);
  });
  var get9 = /* @__PURE__ */ dual(2, (self, fiberRef) => {
    if (!self.locals.has(fiberRef)) {
      return none2();
    }
    return some2(headNonEmpty(self.locals.get(fiberRef))[1]);
  });
  var getOrDefault = /* @__PURE__ */ dual(2, (self, fiberRef) => pipe(get9(self, fiberRef), getOrElse(() => fiberRef.initial)));
  var updateAs = /* @__PURE__ */ dual(2, (self, {
    fiberId: fiberId2,
    fiberRef,
    value
  }) => {
    if (self.locals.size === 0) {
      return new FiberRefsImpl(new Map([[fiberRef, [[fiberId2, value]]]]));
    }
    const locals = new Map(self.locals);
    unsafeUpdateAs(locals, fiberId2, fiberRef, value);
    return new FiberRefsImpl(locals);
  });
  var unsafeUpdateAs = (locals, fiberId2, fiberRef, value) => {
    const oldStack = locals.get(fiberRef) ?? [];
    let newStack;
    if (isNonEmptyReadonlyArray(oldStack)) {
      const [currentId, currentValue] = headNonEmpty(oldStack);
      if (currentId[symbol2](fiberId2)) {
        if (equals(currentValue, value)) {
          return;
        } else {
          newStack = [[fiberId2, value], ...oldStack.slice(1)];
        }
      } else {
        newStack = [[fiberId2, value], ...oldStack];
      }
    } else {
      newStack = [[fiberId2, value]];
    }
    locals.set(fiberRef, newStack);
  };
  var updateManyAs = /* @__PURE__ */ dual(2, (self, {
    entries: entries2,
    forkAs: forkAs2
  }) => {
    if (self.locals.size === 0) {
      return new FiberRefsImpl(new Map(entries2));
    }
    const locals = new Map(self.locals);
    if (forkAs2 !== undefined) {
      unsafeForkAs(self, locals, forkAs2);
    }
    entries2.forEach(([fiberRef, values3]) => {
      if (values3.length === 1) {
        unsafeUpdateAs(locals, values3[0][0], fiberRef, values3[0][1]);
      } else {
        values3.forEach(([fiberId2, value]) => {
          unsafeUpdateAs(locals, fiberId2, fiberRef, value);
        });
      }
    });
    return new FiberRefsImpl(locals);
  });

  // node_modules/effect/dist/esm/FiberRefs.js
  var get10 = get9;
  var getOrDefault2 = getOrDefault;
  var joinAs2 = joinAs;
  var setAll2 = setAll;
  var updateManyAs2 = updateManyAs;
  var empty21 = empty20;

  // node_modules/effect/dist/esm/LogLevel.js
  var All = logLevelAll;
  var Fatal = logLevelFatal;
  var Error2 = logLevelError;
  var Warning = logLevelWarning;
  var Info = logLevelInfo;
  var Debug = logLevelDebug;
  var Trace = logLevelTrace;
  var None3 = logLevelNone;
  var Order2 = /* @__PURE__ */ pipe(Order, /* @__PURE__ */ mapInput2((level) => level.ordinal));
  var greaterThan3 = /* @__PURE__ */ greaterThan(Order2);
  var fromLiteral = (literal) => {
    switch (literal) {
      case "All":
        return All;
      case "Debug":
        return Debug;
      case "Error":
        return Error2;
      case "Fatal":
        return Fatal;
      case "Info":
        return Info;
      case "Trace":
        return Trace;
      case "None":
        return None3;
      case "Warning":
        return Warning;
    }
  };

  // node_modules/effect/dist/esm/internal/logSpan.js
  var make25 = (label, startTime) => ({
    label,
    startTime
  });
  var formatLabel = (key) => key.replace(/[\s="]/g, "_");
  var render = (now) => (self) => {
    const label = formatLabel(self.label);
    return `${label}=${now - self.startTime}ms`;
  };

  // node_modules/effect/dist/esm/LogSpan.js
  var make26 = make25;

  // node_modules/effect/dist/esm/Ref.js
  var exports_Ref = {};
  __export(exports_Ref, {
    updateSomeAndGet: () => updateSomeAndGet2,
    updateSome: () => updateSome2,
    updateAndGet: () => updateAndGet2,
    update: () => update3,
    unsafeMake: () => unsafeMake7,
    setAndGet: () => setAndGet2,
    set: () => set6,
    modifySome: () => modifySome2,
    modify: () => modify4,
    make: () => make28,
    getAndUpdateSome: () => getAndUpdateSome2,
    getAndUpdate: () => getAndUpdate2,
    getAndSet: () => getAndSet2,
    get: () => get12,
    RefTypeId: () => RefTypeId2
  });

  // node_modules/effect/dist/esm/Effectable.js
  var EffectPrototype2 = EffectPrototype;
  var CommitPrototype2 = CommitPrototype;
  var Base2 = Base;
  class Class extends Base2 {
  }

  // node_modules/effect/dist/esm/Readable.js
  var TypeId12 = /* @__PURE__ */ Symbol.for("effect/Readable");
  var Proto = {
    [TypeId12]: TypeId12,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };

  // node_modules/effect/dist/esm/internal/ref.js
  var RefTypeId = /* @__PURE__ */ Symbol.for("effect/Ref");
  var refVariance = {
    _A: (_) => _
  };

  class RefImpl extends Class {
    ref;
    commit() {
      return this.get;
    }
    [RefTypeId] = refVariance;
    [TypeId12] = TypeId12;
    constructor(ref) {
      super();
      this.ref = ref;
      this.get = sync(() => get6(this.ref));
    }
    get;
    modify(f) {
      return sync(() => {
        const current = get6(this.ref);
        const [b, a] = f(current);
        if (current !== a) {
          set2(a)(this.ref);
        }
        return b;
      });
    }
  }
  var unsafeMake6 = (value) => new RefImpl(make11(value));
  var make27 = (value) => sync(() => unsafeMake6(value));
  var get11 = (self) => self.get;
  var set5 = /* @__PURE__ */ dual(2, (self, value) => self.modify(() => [undefined, value]));
  var getAndSet = /* @__PURE__ */ dual(2, (self, value) => self.modify((a) => [a, value]));
  var getAndUpdate = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => [a, f(a)]));
  var getAndUpdateSome = /* @__PURE__ */ dual(2, (self, pf) => self.modify((value) => {
    const option = pf(value);
    switch (option._tag) {
      case "None": {
        return [value, value];
      }
      case "Some": {
        return [value, option.value];
      }
    }
  }));
  var setAndGet = /* @__PURE__ */ dual(2, (self, value) => self.modify(() => [value, value]));
  var modify3 = /* @__PURE__ */ dual(2, (self, f) => self.modify(f));
  var modifySome = /* @__PURE__ */ dual(3, (self, fallback, pf) => self.modify((value) => {
    const option = pf(value);
    switch (option._tag) {
      case "None": {
        return [fallback, value];
      }
      case "Some": {
        return option.value;
      }
    }
  }));
  var update2 = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => [undefined, f(a)]));
  var updateAndGet = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => {
    const result = f(a);
    return [result, result];
  }));
  var updateSome = /* @__PURE__ */ dual(2, (self, f) => self.modify((a) => [undefined, match2(f(a), {
    onNone: () => a,
    onSome: (b) => b
  })]));
  var updateSomeAndGet = /* @__PURE__ */ dual(2, (self, pf) => self.modify((value) => {
    const option = pf(value);
    switch (option._tag) {
      case "None": {
        return [value, value];
      }
      case "Some": {
        return [option.value, option.value];
      }
    }
  }));

  // node_modules/effect/dist/esm/Ref.js
  var RefTypeId2 = RefTypeId;
  var make28 = make27;
  var get12 = get11;
  var getAndSet2 = getAndSet;
  var getAndUpdate2 = getAndUpdate;
  var getAndUpdateSome2 = getAndUpdateSome;
  var modify4 = modify3;
  var modifySome2 = modifySome;
  var set6 = set5;
  var setAndGet2 = setAndGet;
  var update3 = update2;
  var updateAndGet2 = updateAndGet;
  var updateSome2 = updateSome;
  var updateSomeAndGet2 = updateSomeAndGet;
  var unsafeMake7 = unsafeMake6;

  // node_modules/effect/dist/esm/Tracer.js
  var tracerWith2 = tracerWith;

  // node_modules/effect/dist/esm/internal/fiberRefs/patch.js
  var OP_EMPTY2 = "Empty";
  var OP_ADD = "Add";
  var OP_REMOVE = "Remove";
  var OP_UPDATE = "Update";
  var OP_AND_THEN = "AndThen";
  var empty22 = {
    _tag: OP_EMPTY2
  };
  var diff5 = (oldValue, newValue) => {
    const missingLocals = new Map(oldValue.locals);
    let patch6 = empty22;
    for (const [fiberRef, pairs] of newValue.locals.entries()) {
      const newValue2 = headNonEmpty(pairs)[1];
      const old = missingLocals.get(fiberRef);
      if (old !== undefined) {
        const oldValue2 = headNonEmpty(old)[1];
        if (!equals(oldValue2, newValue2)) {
          patch6 = combine7({
            _tag: OP_UPDATE,
            fiberRef,
            patch: fiberRef.diff(oldValue2, newValue2)
          })(patch6);
        }
      } else {
        patch6 = combine7({
          _tag: OP_ADD,
          fiberRef,
          value: newValue2
        })(patch6);
      }
      missingLocals.delete(fiberRef);
    }
    for (const [fiberRef] of missingLocals.entries()) {
      patch6 = combine7({
        _tag: OP_REMOVE,
        fiberRef
      })(patch6);
    }
    return patch6;
  };
  var combine7 = /* @__PURE__ */ dual(2, (self, that) => ({
    _tag: OP_AND_THEN,
    first: self,
    second: that
  }));
  var patch6 = /* @__PURE__ */ dual(3, (self, fiberId2, oldValue) => {
    let fiberRefs2 = oldValue;
    let patches = of(self);
    while (isNonEmptyReadonlyArray(patches)) {
      const head3 = headNonEmpty(patches);
      const tail = tailNonEmpty(patches);
      switch (head3._tag) {
        case OP_EMPTY2: {
          patches = tail;
          break;
        }
        case OP_ADD: {
          fiberRefs2 = updateAs(fiberRefs2, {
            fiberId: fiberId2,
            fiberRef: head3.fiberRef,
            value: head3.value
          });
          patches = tail;
          break;
        }
        case OP_REMOVE: {
          fiberRefs2 = delete_(fiberRefs2, head3.fiberRef);
          patches = tail;
          break;
        }
        case OP_UPDATE: {
          const value = getOrDefault(fiberRefs2, head3.fiberRef);
          fiberRefs2 = updateAs(fiberRefs2, {
            fiberId: fiberId2,
            fiberRef: head3.fiberRef,
            value: head3.fiberRef.patch(head3.patch)(value)
          });
          patches = tail;
          break;
        }
        case OP_AND_THEN: {
          patches = prepend(head3.first)(prepend(head3.second)(tail));
          break;
        }
      }
    }
    return fiberRefs2;
  });

  // node_modules/effect/dist/esm/internal/metric/label.js
  var MetricLabelSymbolKey = "effect/MetricLabel";
  var MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);

  class MetricLabelImpl {
    key;
    value;
    [MetricLabelTypeId] = MetricLabelTypeId;
    _hash;
    constructor(key, value) {
      this.key = key;
      this.value = value;
      this._hash = string(MetricLabelSymbolKey + this.key + this.value);
    }
    [symbol]() {
      return this._hash;
    }
    [symbol2](that) {
      return isMetricLabel(that) && this.key === that.key && this.value === that.value;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var make29 = (key, value) => {
    return new MetricLabelImpl(key, value);
  };
  var isMetricLabel = (u) => hasProperty(u, MetricLabelTypeId);

  // node_modules/effect/dist/esm/internal/core-effect.js
  var annotateLogs = /* @__PURE__ */ dual((args) => isEffect(args[0]), function() {
    const args = arguments;
    return fiberRefLocallyWith(args[0], currentLogAnnotations, typeof args[1] === "string" ? set3(args[1], args[2]) : (annotations2) => Object.entries(args[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
  });
  var asSome = (self) => map10(self, some2);
  var asSomeError = (self) => mapError(self, some2);
  var try_ = (arg) => {
    let evaluate;
    let onFailure = undefined;
    if (typeof arg === "function") {
      evaluate = arg;
    } else {
      evaluate = arg.try;
      onFailure = arg.catch;
    }
    return suspend(() => {
      try {
        return succeed(internalCall(evaluate));
      } catch (error) {
        return fail2(onFailure ? internalCall(() => onFailure(error)) : new UnknownException(error, "An unknown error occurred in Effect.try"));
      }
    });
  };
  var _catch = /* @__PURE__ */ dual(3, (self, tag, options) => catchAll(self, (e) => {
    if (hasProperty(e, tag) && e[tag] === options.failure) {
      return options.onFailure(e);
    }
    return fail2(e);
  }));
  var catchAllDefect = /* @__PURE__ */ dual(2, (self, f) => catchAllCause(self, (cause) => {
    const option = find(cause, (_) => isDieType(_) ? some2(_) : none2());
    switch (option._tag) {
      case "None": {
        return failCause(cause);
      }
      case "Some": {
        return f(option.value.defect);
      }
    }
  }));
  var catchSomeCause = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
    onFailure: (cause) => {
      const option = f(cause);
      switch (option._tag) {
        case "None": {
          return failCause(cause);
        }
        case "Some": {
          return option.value;
        }
      }
    },
    onSuccess: succeed
  }));
  var catchSomeDefect = /* @__PURE__ */ dual(2, (self, pf) => catchAllCause(self, (cause) => {
    const option = find(cause, (_) => isDieType(_) ? some2(_) : none2());
    switch (option._tag) {
      case "None": {
        return failCause(cause);
      }
      case "Some": {
        const optionEffect = pf(option.value.defect);
        return optionEffect._tag === "Some" ? optionEffect.value : failCause(cause);
      }
    }
  }));
  var catchTag = /* @__PURE__ */ dual((args) => isEffect(args[0]), (self, ...args) => {
    const f = args[args.length - 1];
    let predicate;
    if (args.length === 2) {
      predicate = isTagged(args[0]);
    } else {
      predicate = (e) => {
        const tag = hasProperty(e, "_tag") ? e["_tag"] : undefined;
        if (!tag)
          return false;
        for (let i = 0;i < args.length - 1; i++) {
          if (args[i] === tag)
            return true;
        }
        return false;
      };
    }
    return catchIf(self, predicate, f);
  });
  var catchTags = /* @__PURE__ */ dual(2, (self, cases) => {
    let keys3;
    return catchIf(self, (e) => {
      keys3 ??= Object.keys(cases);
      return hasProperty(e, "_tag") && isString(e["_tag"]) && keys3.includes(e["_tag"]);
    }, (e) => cases[e["_tag"]](e));
  });
  var cause = (self) => matchCause(self, {
    onFailure: identity,
    onSuccess: () => empty16
  });
  var clockWith3 = clockWith2;
  var clock = /* @__PURE__ */ clockWith3(succeed);
  var delay = /* @__PURE__ */ dual(2, (self, duration) => zipRight(sleep2(duration), self));
  var descriptorWith = (f) => withFiberRuntime((state, status) => f({
    id: state.id(),
    status,
    interruptors: interruptors(state.getFiberRef(currentInterruptedCause))
  }));
  var allowInterrupt = /* @__PURE__ */ descriptorWith((descriptor) => size3(descriptor.interruptors) > 0 ? interrupt2 : void_);
  var descriptor = /* @__PURE__ */ descriptorWith(succeed);
  var diffFiberRefs = (self) => summarized(self, fiberRefs2, diff5);
  var diffFiberRefsAndRuntimeFlags = (self) => summarized(self, zip2(fiberRefs2, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff5(refs, refsNew), diff4(flags, flagsNew)]);
  var Do = /* @__PURE__ */ succeed({});
  var bind2 = /* @__PURE__ */ bind(map10, flatMap8);
  var bindTo2 = /* @__PURE__ */ bindTo(map10);
  var let_2 = /* @__PURE__ */ let_(map10);
  var dropUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
    const iterator = elements[Symbol.iterator]();
    const builder = [];
    let next;
    let dropping = succeed(false);
    let i = 0;
    while ((next = iterator.next()) && !next.done) {
      const a = next.value;
      const index = i++;
      dropping = flatMap8(dropping, (bool) => {
        if (bool) {
          builder.push(a);
          return succeed(true);
        }
        return predicate(a, index);
      });
    }
    return map10(dropping, () => builder);
  }));
  var dropWhile2 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
    const iterator = elements[Symbol.iterator]();
    const builder = [];
    let next;
    let dropping = succeed(true);
    let i = 0;
    while ((next = iterator.next()) && !next.done) {
      const a = next.value;
      const index = i++;
      dropping = flatMap8(dropping, (d) => map10(d ? predicate(a, index) : succeed(false), (b) => {
        if (!b) {
          builder.push(a);
        }
        return b;
      }));
    }
    return map10(dropping, () => builder);
  }));
  var contextWith = (f) => map10(context(), f);
  var eventually = (self) => orElse2(self, () => flatMap8(yieldNow(), () => eventually(self)));
  var filterMap4 = /* @__PURE__ */ dual(2, (elements, pf) => map10(forEachSequential(elements, identity), filterMap(pf)));
  var filterOrDie = /* @__PURE__ */ dual(3, (self, predicate, orDieWith2) => filterOrElse(self, predicate, (a) => dieSync(() => orDieWith2(a))));
  var filterOrDieMessage = /* @__PURE__ */ dual(3, (self, predicate, message) => filterOrElse(self, predicate, () => dieMessage(message)));
  var filterOrElse = /* @__PURE__ */ dual(3, (self, predicate, orElse3) => flatMap8(self, (a) => predicate(a) ? succeed(a) : orElse3(a)));
  var liftPredicate = /* @__PURE__ */ dual(3, (self, predicate, orFailWith) => suspend(() => predicate(self) ? succeed(self) : fail2(orFailWith(self))));
  var filterOrFail = /* @__PURE__ */ dual((args) => isEffect(args[0]), (self, predicate, orFailWith) => filterOrElse(self, predicate, (a) => orFailWith === undefined ? fail2(new NoSuchElementException) : failSync(() => orFailWith(a))));
  var findFirst5 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
    const iterator = elements[Symbol.iterator]();
    const next = iterator.next();
    if (!next.done) {
      return findLoop(iterator, 0, predicate, next.value);
    }
    return succeed(none2());
  }));
  var findLoop = (iterator, index, f, value) => flatMap8(f(value, index), (result) => {
    if (result) {
      return succeed(some2(value));
    }
    const next = iterator.next();
    if (!next.done) {
      return findLoop(iterator, index + 1, f, next.value);
    }
    return succeed(none2());
  });
  var firstSuccessOf = (effects) => suspend(() => {
    const list = fromIterable2(effects);
    if (!isNonEmpty2(list)) {
      return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
    }
    return pipe(tailNonEmpty2(list), reduce(headNonEmpty2(list), (left3, right3) => orElse2(left3, () => right3)));
  });
  var flipWith = /* @__PURE__ */ dual(2, (self, f) => flip(f(flip(self))));
  var match7 = /* @__PURE__ */ dual(2, (self, options) => matchEffect(self, {
    onFailure: (e) => succeed(options.onFailure(e)),
    onSuccess: (a) => succeed(options.onSuccess(a))
  }));
  var every5 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));
  var forAllLoop = (iterator, index, f) => {
    const next = iterator.next();
    return next.done ? succeed(true) : flatMap8(f(next.value, index), (b) => b ? forAllLoop(iterator, index + 1, f) : succeed(b));
  };
  var forever = (self) => {
    const loop = flatMap8(flatMap8(self, () => yieldNow()), () => loop);
    return loop;
  };
  var fiberRefs2 = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.getFiberRefs()));
  var head3 = (self) => flatMap8(self, (as2) => {
    const iterator = as2[Symbol.iterator]();
    const next = iterator.next();
    if (next.done) {
      return fail2(new NoSuchElementException);
    }
    return succeed(next.value);
  });
  var ignore = (self) => match7(self, {
    onFailure: constVoid,
    onSuccess: constVoid
  });
  var ignoreLogged = (self) => matchCauseEffect(self, {
    onFailure: (cause2) => logDebug(cause2, "An error was silently ignored because it is not anticipated to be useful"),
    onSuccess: () => void_
  });
  var inheritFiberRefs = (childFiberRefs) => updateFiberRefs((parentFiberId, parentFiberRefs) => joinAs2(parentFiberRefs, parentFiberId, childFiberRefs));
  var isFailure2 = (self) => match7(self, {
    onFailure: constTrue,
    onSuccess: constFalse
  });
  var isSuccess2 = (self) => match7(self, {
    onFailure: constFalse,
    onSuccess: constTrue
  });
  var iterate = (initial, options) => suspend(() => {
    if (options.while(initial)) {
      return flatMap8(options.body(initial), (z2) => iterate(z2, options));
    }
    return succeed(initial);
  });
  var logWithLevel = (level) => (...message) => {
    const levelOption = fromNullable(level);
    let cause2 = undefined;
    for (let i = 0, len = message.length;i < len; i++) {
      const msg = message[i];
      if (isCause(msg)) {
        if (cause2 !== undefined) {
          cause2 = sequential(cause2, msg);
        } else {
          cause2 = msg;
        }
        message = [...message.slice(0, i), ...message.slice(i + 1)];
        i--;
      }
    }
    if (cause2 === undefined) {
      cause2 = empty16;
    }
    return withFiberRuntime((fiberState) => {
      fiberState.log(message, cause2, levelOption);
      return void_;
    });
  };
  var log = /* @__PURE__ */ logWithLevel();
  var logTrace = /* @__PURE__ */ logWithLevel(Trace);
  var logDebug = /* @__PURE__ */ logWithLevel(Debug);
  var logInfo = /* @__PURE__ */ logWithLevel(Info);
  var logWarning = /* @__PURE__ */ logWithLevel(Warning);
  var logError = /* @__PURE__ */ logWithLevel(Error2);
  var logFatal = /* @__PURE__ */ logWithLevel(Fatal);
  var withLogSpan = /* @__PURE__ */ dual(2, (effect, label) => flatMap8(currentTimeMillis2, (now) => fiberRefLocallyWith(effect, currentLogSpan, prepend3(make26(label, now)))));
  var logAnnotations = /* @__PURE__ */ fiberRefGet(currentLogAnnotations);
  var loop = (initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : map10(loopInternal(initial, options.while, options.step, options.body), fromIterable);
  var loopInternal = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap8(body(initial), (a) => map10(loopInternal(inc(initial), cont, inc, body), prepend3(a))) : sync(() => empty9()));
  var loopDiscard = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap8(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : void_);
  var mapAccum3 = /* @__PURE__ */ dual(3, (elements, initial, f) => suspend(() => {
    const iterator = elements[Symbol.iterator]();
    const builder = [];
    let result = succeed(initial);
    let next;
    let i = 0;
    while (!(next = iterator.next()).done) {
      const index = i++;
      const value = next.value;
      result = flatMap8(result, (state) => map10(f(state, value, index), ([z, b]) => {
        builder.push(b);
        return z;
      }));
    }
    return map10(result, (z) => [z, builder]);
  }));
  var mapErrorCause = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
    onFailure: (c) => failCauseSync(() => f(c)),
    onSuccess: succeed
  }));
  var memoize = (self) => pipe(deferredMake(), flatMap8((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self), intoDeferred(deferred), once, map10((complete) => zipRight(complete, pipe(deferredAwait(deferred), flatMap8(([patch7, a]) => as(zip2(patchFiberRefs(patch7[0]), updateRuntimeFlags(patch7[1])), a))))))));
  var merge5 = (self) => matchEffect(self, {
    onFailure: (e) => succeed(e),
    onSuccess: succeed
  });
  var negate = (self) => map10(self, (b) => !b);
  var none6 = (self) => flatMap8(self, (option) => {
    switch (option._tag) {
      case "None":
        return void_;
      case "Some":
        return fail2(new NoSuchElementException);
    }
  });
  var once = (self) => map10(make28(true), (ref) => asVoid(whenEffect(self, getAndSet2(ref, false))));
  var option = (self) => matchEffect(self, {
    onFailure: () => succeed(none2()),
    onSuccess: (a) => succeed(some2(a))
  });
  var orElseFail = /* @__PURE__ */ dual(2, (self, evaluate) => orElse2(self, () => failSync(evaluate)));
  var orElseSucceed = /* @__PURE__ */ dual(2, (self, evaluate) => orElse2(self, () => sync(evaluate)));
  var parallelErrors = (self) => matchCauseEffect(self, {
    onFailure: (cause2) => {
      const errors = fromIterable(failures(cause2));
      return errors.length === 0 ? failCause(cause2) : fail2(errors);
    },
    onSuccess: succeed
  });
  var patchFiberRefs = (patch7) => updateFiberRefs((fiberId2, fiberRefs3) => pipe(patch7, patch6(fiberId2, fiberRefs3)));
  var promise = (evaluate) => evaluate.length >= 1 ? async_((resolve, signal) => {
    try {
      evaluate(signal).then((a) => resolve(succeed(a)), (e) => resolve(die2(e)));
    } catch (e) {
      resolve(die2(e));
    }
  }) : async_((resolve) => {
    try {
      evaluate().then((a) => resolve(succeed(a)), (e) => resolve(die2(e)));
    } catch (e) {
      resolve(die2(e));
    }
  });
  var provideService = /* @__PURE__ */ dual(3, (self, tag, service) => contextWithEffect((env) => provideContext(self, add2(env, tag, service))));
  var provideServiceEffect = /* @__PURE__ */ dual(3, (self, tag, effect) => contextWithEffect((env) => flatMap8(effect, (service) => provideContext(self, pipe(env, add2(tag, service))))));
  var random2 = /* @__PURE__ */ randomWith(succeed);
  var reduce9 = /* @__PURE__ */ dual(3, (elements, zero2, f) => fromIterable(elements).reduce((acc, el, i) => flatMap8(acc, (a) => f(a, el, i)), succeed(zero2)));
  var reduceRight3 = /* @__PURE__ */ dual(3, (elements, zero2, f) => fromIterable(elements).reduceRight((acc, el, i) => flatMap8(acc, (a) => f(el, a, i)), succeed(zero2)));
  var reduceWhile = /* @__PURE__ */ dual(3, (elements, zero2, options) => flatMap8(sync(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop(iterator, 0, zero2, options.while, options.body)));
  var reduceWhileLoop = (iterator, index, state, predicate, f) => {
    const next = iterator.next();
    if (!next.done && predicate(state)) {
      return flatMap8(f(state, next.value, index), (nextState) => reduceWhileLoop(iterator, index + 1, nextState, predicate, f));
    }
    return succeed(state);
  };
  var repeatN = /* @__PURE__ */ dual(2, (self, n) => suspend(() => repeatNLoop(self, n)));
  var repeatNLoop = (self, n) => flatMap8(self, (a) => n <= 0 ? succeed(a) : zipRight(yieldNow(), repeatNLoop(self, n - 1)));
  var sandbox = (self) => matchCauseEffect(self, {
    onFailure: fail2,
    onSuccess: succeed
  });
  var setFiberRefs = (fiberRefs3) => suspend(() => setAll2(fiberRefs3));
  var sleep3 = sleep2;
  var succeedNone = /* @__PURE__ */ succeed(/* @__PURE__ */ none2());
  var succeedSome = (value) => succeed(some2(value));
  var summarized = /* @__PURE__ */ dual(3, (self, summary, f) => flatMap8(summary, (start) => flatMap8(self, (value) => map10(summary, (end) => [f(start, end), value]))));
  var tagMetrics = /* @__PURE__ */ dual((args) => isEffect(args[0]), function() {
    return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [make29(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => make29(k, v)));
  });
  var labelMetrics = /* @__PURE__ */ dual(2, (self, labels) => fiberRefLocallyWith(self, currentMetricLabels, (old) => union(old, labels)));
  var takeUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
    const iterator = elements[Symbol.iterator]();
    const builder = [];
    let next;
    let effect = succeed(false);
    let i = 0;
    while ((next = iterator.next()) && !next.done) {
      const a = next.value;
      const index = i++;
      effect = flatMap8(effect, (bool) => {
        if (bool) {
          return succeed(true);
        }
        builder.push(a);
        return predicate(a, index);
      });
    }
    return map10(effect, () => builder);
  }));
  var takeWhile2 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
    const iterator = elements[Symbol.iterator]();
    const builder = [];
    let next;
    let taking = succeed(true);
    let i = 0;
    while ((next = iterator.next()) && !next.done) {
      const a = next.value;
      const index = i++;
      taking = flatMap8(taking, (taking2) => pipe(taking2 ? predicate(a, index) : succeed(false), map10((bool) => {
        if (bool) {
          builder.push(a);
        }
        return bool;
      })));
    }
    return map10(taking, () => builder);
  }));
  var tapBoth = /* @__PURE__ */ dual(2, (self, {
    onFailure,
    onSuccess
  }) => matchCauseEffect(self, {
    onFailure: (cause2) => {
      const either3 = failureOrCause(cause2);
      switch (either3._tag) {
        case "Left": {
          return zipRight(onFailure(either3.left), failCause(cause2));
        }
        case "Right": {
          return failCause(cause2);
        }
      }
    },
    onSuccess: (a) => as(onSuccess(a), a)
  }));
  var tapDefect = /* @__PURE__ */ dual(2, (self, f) => catchAllCause(self, (cause2) => match2(keepDefects(cause2), {
    onNone: () => failCause(cause2),
    onSome: (a) => zipRight(f(a), failCause(cause2))
  })));
  var tapError = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
    onFailure: (cause2) => {
      const either3 = failureOrCause(cause2);
      switch (either3._tag) {
        case "Left":
          return zipRight(f(either3.left), failCause(cause2));
        case "Right":
          return failCause(cause2);
      }
    },
    onSuccess: succeed
  }));
  var tapErrorTag = /* @__PURE__ */ dual(3, (self, k, f) => tapError(self, (e) => {
    if (isTagged(e, k)) {
      return f(e);
    }
    return void_;
  }));
  var tapErrorCause = /* @__PURE__ */ dual(2, (self, f) => matchCauseEffect(self, {
    onFailure: (cause2) => zipRight(f(cause2), failCause(cause2)),
    onSuccess: succeed
  }));
  var timed = (self) => timedWith(self, currentTimeNanos2);
  var timedWith = /* @__PURE__ */ dual(2, (self, nanos2) => summarized(self, nanos2, (start, end) => nanos(end - start)));
  var tracerWith3 = tracerWith2;
  var tracer = /* @__PURE__ */ tracerWith3(succeed);
  var tryPromise = (arg) => {
    let evaluate;
    let catcher = undefined;
    if (typeof arg === "function") {
      evaluate = arg;
    } else {
      evaluate = arg.try;
      catcher = arg.catch;
    }
    const fail5 = (e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
    if (evaluate.length >= 1) {
      return async_((resolve, signal) => {
        try {
          evaluate(signal).then((a) => resolve(succeed(a)), (e) => resolve(fail5(e)));
        } catch (e) {
          resolve(fail5(e));
        }
      });
    }
    return async_((resolve) => {
      try {
        evaluate().then((a) => resolve(succeed(a)), (e) => resolve(fail5(e)));
      } catch (e) {
        resolve(fail5(e));
      }
    });
  };
  var tryMap = /* @__PURE__ */ dual(2, (self, options) => flatMap8(self, (a) => try_({
    try: () => options.try(a),
    catch: options.catch
  })));
  var tryMapPromise = /* @__PURE__ */ dual(2, (self, options) => flatMap8(self, (a) => tryPromise({
    try: options.try.length >= 1 ? (signal) => options.try(a, signal) : () => options.try(a),
    catch: options.catch
  })));
  var unless = /* @__PURE__ */ dual(2, (self, condition) => suspend(() => condition() ? succeedNone : asSome(self)));
  var unlessEffect = /* @__PURE__ */ dual(2, (self, condition) => flatMap8(condition, (b) => b ? succeedNone : asSome(self)));
  var unsandbox = (self) => mapErrorCause(self, flatten5);
  var updateFiberRefs = (f) => withFiberRuntime((state) => {
    state.setFiberRefs(f(state.id(), state.getFiberRefs()));
    return void_;
  });
  var updateService = /* @__PURE__ */ dual(3, (self, tag, f) => mapInputContext(self, (context2) => add2(context2, tag, f(unsafeGet3(context2, tag)))));
  var when = /* @__PURE__ */ dual(2, (self, condition) => suspend(() => condition() ? map10(self, some2) : succeed(none2())));
  var whenFiberRef = /* @__PURE__ */ dual(3, (self, fiberRef, predicate) => flatMap8(fiberRefGet(fiberRef), (s) => predicate(s) ? map10(self, (a) => [s, some2(a)]) : succeed([s, none2()])));
  var whenRef = /* @__PURE__ */ dual(3, (self, ref, predicate) => flatMap8(get12(ref), (s) => predicate(s) ? map10(self, (a) => [s, some2(a)]) : succeed([s, none2()])));
  var withMetric = /* @__PURE__ */ dual(2, (self, metric) => metric(self));
  var serviceFunctionEffect = (getService, f) => (...args) => flatMap8(getService, (a) => f(a)(...args));
  var serviceFunction = (getService, f) => (...args) => map10(getService, (a) => f(a)(...args));
  var serviceFunctions = (getService) => new Proxy({}, {
    get(_target, prop, _receiver) {
      return (...args) => flatMap8(getService, (s) => s[prop](...args));
    }
  });
  var serviceConstants = (getService) => new Proxy({}, {
    get(_target, prop, _receiver) {
      return flatMap8(getService, (s) => isEffect(s[prop]) ? s[prop] : succeed(s[prop]));
    }
  });
  var serviceMembers = (getService) => ({
    functions: serviceFunctions(getService),
    constants: serviceConstants(getService)
  });
  var serviceOption = (tag) => map10(context(), getOption2(tag));
  var serviceOptional = (tag) => flatMap8(context(), getOption2(tag));
  var annotateCurrentSpan = function() {
    const args = arguments;
    return ignore(flatMap8(currentSpan, (span2) => sync(() => {
      if (typeof args[0] === "string") {
        span2.attribute(args[0], args[1]);
      } else {
        for (const key in args[0]) {
          span2.attribute(key, args[0][key]);
        }
      }
    })));
  };
  var linkSpanCurrent = function() {
    const args = arguments;
    const links = Array.isArray(args[0]) ? args[0] : [{
      _tag: "SpanLink",
      span: args[0],
      attributes: args[1] ?? {}
    }];
    return ignore(flatMap8(currentSpan, (span2) => sync(() => span2.addLinks(links))));
  };
  var annotateSpans = /* @__PURE__ */ dual((args) => isEffect(args[0]), function() {
    const args = arguments;
    return fiberRefLocallyWith(args[0], currentTracerSpanAnnotations, typeof args[1] === "string" ? set3(args[1], args[2]) : (annotations2) => Object.entries(args[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
  });
  var currentParentSpan = /* @__PURE__ */ serviceOptional(spanTag);
  var currentSpan = /* @__PURE__ */ flatMap8(/* @__PURE__ */ context(), (context2) => {
    const span2 = context2.unsafeMap.get(spanTag.key);
    return span2 !== undefined && span2._tag === "Span" ? succeed(span2) : fail2(new NoSuchElementException);
  });
  var linkSpans = /* @__PURE__ */ dual((args) => isEffect(args[0]), (self, span2, attributes) => fiberRefLocallyWith(self, currentTracerSpanLinks, append2({
    _tag: "SpanLink",
    span: span2,
    attributes: attributes ?? {}
  })));
  var bigint02 = /* @__PURE__ */ BigInt(0);
  var filterDisablePropagation = /* @__PURE__ */ flatMap((span2) => get3(span2.context, DisablePropagation) ? span2._tag === "Span" ? filterDisablePropagation(span2.parent) : none2() : some2(span2));
  var unsafeMakeSpan = (fiber, name, options) => {
    const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options.context && get3(options.context, DisablePropagation);
    const context2 = fiber.getFiberRef(currentContext);
    const parent = options.parent ? some2(options.parent) : options.root ? none2() : filterDisablePropagation(getOption2(context2, spanTag));
    let span2;
    if (disablePropagation) {
      span2 = noopSpan({
        name,
        parent,
        context: add2(options.context ?? empty3(), DisablePropagation, true)
      });
    } else {
      const services = fiber.getFiberRef(currentServices);
      const tracer2 = get3(services, tracerTag);
      const clock2 = get3(services, Clock);
      const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
      const fiberRefs3 = fiber.getFiberRefs();
      const annotationsFromEnv = get10(fiberRefs3, currentTracerSpanAnnotations);
      const linksFromEnv = get10(fiberRefs3, currentTracerSpanLinks);
      const links = linksFromEnv._tag === "Some" ? options.links !== undefined ? [...toReadonlyArray(linksFromEnv.value), ...options.links ?? []] : toReadonlyArray(linksFromEnv.value) : options.links ?? empty();
      span2 = tracer2.span(name, parent, options.context ?? empty3(), links, timingEnabled ? clock2.unsafeCurrentTimeNanos() : bigint02, options.kind ?? "internal", options);
      if (annotationsFromEnv._tag === "Some") {
        forEach4(annotationsFromEnv.value, (value, key) => span2.attribute(key, value));
      }
      if (options.attributes !== undefined) {
        Object.entries(options.attributes).forEach(([k, v]) => span2.attribute(k, v));
      }
    }
    if (typeof options.captureStackTrace === "function") {
      spanToTrace.set(span2, options.captureStackTrace);
    }
    return span2;
  };
  var makeSpan = (name, options) => {
    options = addSpanStackTrace(options);
    return withFiberRuntime((fiber) => succeed(unsafeMakeSpan(fiber, name, options)));
  };
  var spanAnnotations = /* @__PURE__ */ fiberRefGet(currentTracerSpanAnnotations);
  var spanLinks = /* @__PURE__ */ fiberRefGet(currentTracerSpanLinks);
  var endSpan = (span2, exit2, clock2, timingEnabled) => sync(() => {
    if (span2.status._tag === "Ended") {
      return;
    }
    if (exitIsFailure(exit2) && spanToTrace.has(span2)) {
      span2.attribute("code.stacktrace", spanToTrace.get(span2)());
    }
    span2.end(timingEnabled ? clock2.unsafeCurrentTimeNanos() : bigint02, exit2);
  });
  var useSpan = (name, ...args) => {
    const options = addSpanStackTrace(args.length === 1 ? undefined : args[0]);
    const evaluate = args[args.length - 1];
    return withFiberRuntime((fiber) => {
      const span2 = unsafeMakeSpan(fiber, name, options);
      const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
      const clock2 = get3(fiber.getFiberRef(currentServices), clockTag);
      return onExit(evaluate(span2), (exit2) => endSpan(span2, exit2, clock2, timingEnabled));
    });
  };
  var withParentSpan = /* @__PURE__ */ dual(2, (self, span2) => provideService(self, spanTag, span2));
  var withSpan = function() {
    const dataFirst = typeof arguments[0] !== "string";
    const name = dataFirst ? arguments[1] : arguments[0];
    const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
    if (dataFirst) {
      const self = arguments[0];
      return useSpan(name, options, (span2) => withParentSpan(self, span2));
    }
    return (self) => useSpan(name, options, (span2) => withParentSpan(self, span2));
  };
  var functionWithSpan = (options) => function() {
    let captureStackTrace = options.captureStackTrace ?? false;
    if (options.captureStackTrace !== false) {
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const error = new Error;
      Error.stackTraceLimit = limit;
      let cache = false;
      captureStackTrace = () => {
        if (cache !== false) {
          return cache;
        }
        if (error.stack) {
          const stack = error.stack.trim().split(`
`);
          cache = stack.slice(2).join(`
`).trim();
          return cache;
        }
      };
    }
    return suspend(() => {
      const opts = typeof options.options === "function" ? options.options.apply(null, arguments) : options.options;
      return withSpan(suspend(() => internalCall(() => options.body.apply(this, arguments))), opts.name, {
        ...opts,
        captureStackTrace
      });
    });
  };
  var fromNullable2 = (value) => value == null ? fail2(new NoSuchElementException) : succeed(value);
  var optionFromOptional = (self) => catchAll(map10(self, some2), (error) => isNoSuchElementException(error) ? succeedNone : fail2(error));

  // node_modules/effect/dist/esm/internal/executionStrategy.js
  var OP_SEQUENTIAL2 = "Sequential";
  var OP_PARALLEL2 = "Parallel";
  var OP_PARALLEL_N = "ParallelN";
  var sequential2 = {
    _tag: OP_SEQUENTIAL2
  };
  var parallel2 = {
    _tag: OP_PARALLEL2
  };
  var parallelN = (parallelism) => ({
    _tag: OP_PARALLEL_N,
    parallelism
  });
  var isSequential = (self) => self._tag === OP_SEQUENTIAL2;
  var isParallel = (self) => self._tag === OP_PARALLEL2;

  // node_modules/effect/dist/esm/ExecutionStrategy.js
  var sequential3 = sequential2;
  var parallel3 = parallel2;
  var parallelN2 = parallelN;

  // node_modules/effect/dist/esm/FiberRefsPatch.js
  var diff6 = diff5;
  var patch7 = patch6;

  // node_modules/effect/dist/esm/internal/fiberStatus.js
  var FiberStatusSymbolKey = "effect/FiberStatus";
  var FiberStatusTypeId = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
  var OP_DONE = "Done";
  var OP_RUNNING = "Running";
  var OP_SUSPENDED = "Suspended";
  var DoneHash = /* @__PURE__ */ string(`${FiberStatusSymbolKey}-${OP_DONE}`);

  class Done {
    [FiberStatusTypeId] = FiberStatusTypeId;
    _tag = OP_DONE;
    [symbol]() {
      return DoneHash;
    }
    [symbol2](that) {
      return isFiberStatus(that) && that._tag === OP_DONE;
    }
  }

  class Running {
    runtimeFlags;
    [FiberStatusTypeId] = FiberStatusTypeId;
    _tag = OP_RUNNING;
    constructor(runtimeFlags2) {
      this.runtimeFlags = runtimeFlags2;
    }
    [symbol]() {
      return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), cached(this));
    }
    [symbol2](that) {
      return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
    }
  }

  class Suspended {
    runtimeFlags;
    blockingOn;
    [FiberStatusTypeId] = FiberStatusTypeId;
    _tag = OP_SUSPENDED;
    constructor(runtimeFlags2, blockingOn) {
      this.runtimeFlags = runtimeFlags2;
      this.blockingOn = blockingOn;
    }
    [symbol]() {
      return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), combine(hash(this.blockingOn)), cached(this));
    }
    [symbol2](that) {
      return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
    }
  }
  var done3 = /* @__PURE__ */ new Done;
  var running = (runtimeFlags2) => new Running(runtimeFlags2);
  var suspended = (runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn);
  var isFiberStatus = (u) => hasProperty(u, FiberStatusTypeId);
  var isDone2 = (self) => self._tag === OP_DONE;

  // node_modules/effect/dist/esm/FiberStatus.js
  var done4 = done3;
  var running2 = running;
  var suspended2 = suspended;
  var isDone3 = isDone2;

  // node_modules/effect/dist/esm/Micro.js
  var TypeId13 = /* @__PURE__ */ Symbol.for("effect/Micro");
  var MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
  var MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
  var microCauseVariance = {
    _E: identity
  };

  class MicroCauseImpl extends globalThis.Error {
    _tag;
    traces;
    [MicroCauseTypeId];
    constructor(_tag, originalError, traces) {
      const causeName = `MicroCause.${_tag}`;
      let name;
      let message;
      let stack;
      if (originalError instanceof globalThis.Error) {
        name = `(${causeName}) ${originalError.name}`;
        message = originalError.message;
        const messageLines = message.split(`
`).length;
        stack = originalError.stack ? `(${causeName}) ${originalError.stack.split(`
`).slice(0, messageLines + 3).join(`
`)}` : `${name}: ${message}`;
      } else {
        name = causeName;
        message = toStringUnknown(originalError, 0);
        stack = `${name}: ${message}`;
      }
      if (traces.length > 0) {
        stack += `
    ${traces.join(`
    `)}`;
      }
      super(message);
      this._tag = _tag;
      this.traces = traces;
      this[MicroCauseTypeId] = microCauseVariance;
      this.name = name;
      this.stack = stack;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    toString() {
      return this.stack;
    }
    [NodeInspectSymbol]() {
      return this.stack;
    }
  }
  class Die extends MicroCauseImpl {
    defect;
    constructor(defect, traces = []) {
      super("Die", defect, traces);
      this.defect = defect;
    }
  }
  var causeDie = (defect, traces = []) => new Die(defect, traces);

  class Interrupt extends MicroCauseImpl {
    constructor(traces = []) {
      super("Interrupt", "interrupted", traces);
    }
  }
  var causeInterrupt = (traces = []) => new Interrupt(traces);
  var causeIsInterrupt = (self) => self._tag === "Interrupt";
  var MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
  var fiberVariance = {
    _A: identity,
    _E: identity
  };

  class MicroFiberImpl {
    context;
    interruptible;
    [MicroFiberTypeId];
    _stack = [];
    _observers = [];
    _exit;
    _children;
    currentOpCount = 0;
    constructor(context2, interruptible3 = true) {
      this.context = context2;
      this.interruptible = interruptible3;
      this[MicroFiberTypeId] = fiberVariance;
    }
    getRef(ref) {
      return unsafeGetReference(this.context, ref);
    }
    addObserver(cb) {
      if (this._exit) {
        cb(this._exit);
        return constVoid;
      }
      this._observers.push(cb);
      return () => {
        const index = this._observers.indexOf(cb);
        if (index >= 0) {
          this._observers.splice(index, 1);
        }
      };
    }
    _interrupted = false;
    unsafeInterrupt() {
      if (this._exit) {
        return;
      }
      this._interrupted = true;
      if (this.interruptible) {
        this.evaluate(exitInterrupt2);
      }
    }
    unsafePoll() {
      return this._exit;
    }
    evaluate(effect) {
      if (this._exit) {
        return;
      } else if (this._yielded !== undefined) {
        const yielded = this._yielded;
        this._yielded = undefined;
        yielded();
      }
      const exit2 = this.runLoop(effect);
      if (exit2 === Yield) {
        return;
      }
      const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
      if (interruptChildren !== undefined) {
        return this.evaluate(flatMap9(interruptChildren, () => exit2));
      }
      this._exit = exit2;
      for (let i = 0;i < this._observers.length; i++) {
        this._observers[i](exit2);
      }
      this._observers.length = 0;
    }
    runLoop(effect) {
      let yielding = false;
      let current = effect;
      this.currentOpCount = 0;
      try {
        while (true) {
          this.currentOpCount++;
          if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
            yielding = true;
            const prev = current;
            current = flatMap9(yieldNow2, () => prev);
          }
          current = current[evaluate](this);
          if (current === Yield) {
            const yielded = this._yielded;
            if (MicroExitTypeId in yielded) {
              this._yielded = undefined;
              return yielded;
            }
            return Yield;
          }
        }
      } catch (error) {
        if (!hasProperty(current, evaluate)) {
          return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
        }
        return exitDie2(error);
      }
    }
    getCont(symbol3) {
      while (true) {
        const op = this._stack.pop();
        if (!op)
          return;
        const cont = op[ensureCont] && op[ensureCont](this);
        if (cont)
          return {
            [symbol3]: cont
          };
        if (op[symbol3])
          return op;
      }
    }
    _yielded = undefined;
    yieldWith(value) {
      this._yielded = value;
      return Yield;
    }
    children() {
      return this._children ??= new Set;
    }
  }
  var fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({
    interruptChildren: undefined
  }));
  var identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
  var args = /* @__PURE__ */ Symbol.for("effect/Micro/args");
  var evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
  var successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
  var failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
  var ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
  var Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
  var microVariance = {
    _A: identity,
    _E: identity,
    _R: identity
  };
  var MicroProto = {
    ...EffectPrototype2,
    _op: "Micro",
    [TypeId13]: microVariance,
    pipe() {
      return pipeArguments(this, arguments);
    },
    [Symbol.iterator]() {
      return new SingleShotGen(new YieldWrap(this));
    },
    toJSON() {
      return {
        _id: "Micro",
        op: this[identifier],
        ...args in this ? {
          args: this[args]
        } : undefined
      };
    },
    toString() {
      return format(this);
    },
    [NodeInspectSymbol]() {
      return format(this);
    }
  };
  function defaultEvaluate(_fiber) {
    return exitDie2(`Micro.evaluate: Not implemented`);
  }
  var makePrimitiveProto = (options) => ({
    ...MicroProto,
    [identifier]: options.op,
    [evaluate]: options.eval ?? defaultEvaluate,
    [successCont]: options.contA,
    [failureCont]: options.contE,
    [ensureCont]: options.ensure
  });
  var makePrimitive = (options) => {
    const Proto2 = makePrimitiveProto(options);
    return function() {
      const self = Object.create(Proto2);
      self[args] = options.single === false ? arguments : arguments[0];
      return self;
    };
  };
  var makeExit = (options) => {
    const Proto2 = {
      ...makePrimitiveProto(options),
      [MicroExitTypeId]: MicroExitTypeId,
      _tag: options.op,
      get [options.prop]() {
        return this[args];
      },
      toJSON() {
        return {
          _id: "MicroExit",
          _tag: options.op,
          [options.prop]: this[args]
        };
      },
      [symbol2](that) {
        return isMicroExit(that) && that._tag === options.op && equals(this[args], that[args]);
      },
      [symbol]() {
        return cached(this, combine(string(options.op))(hash(this[args])));
      }
    };
    return function(value) {
      const self = Object.create(Proto2);
      self[args] = value;
      self[successCont] = undefined;
      self[failureCont] = undefined;
      self[ensureCont] = undefined;
      return self;
    };
  };
  var succeed4 = /* @__PURE__ */ makeExit({
    op: "Success",
    prop: "value",
    eval(fiber) {
      const cont = fiber.getCont(successCont);
      return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
    }
  });
  var failCause4 = /* @__PURE__ */ makeExit({
    op: "Failure",
    prop: "cause",
    eval(fiber) {
      let cont = fiber.getCont(failureCont);
      while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
        cont = fiber.getCont(failureCont);
      }
      return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
    }
  });
  var yieldNowWith = /* @__PURE__ */ makePrimitive({
    op: "Yield",
    eval(fiber) {
      let resumed = false;
      fiber.getRef(CurrentScheduler).scheduleTask(() => {
        if (resumed)
          return;
        fiber.evaluate(exitVoid2);
      }, this[args] ?? 0);
      return fiber.yieldWith(() => {
        resumed = true;
      });
    }
  });
  var yieldNow2 = /* @__PURE__ */ yieldNowWith(0);
  var void_3 = /* @__PURE__ */ succeed4(undefined);
  var withMicroFiber = /* @__PURE__ */ makePrimitive({
    op: "WithMicroFiber",
    eval(fiber) {
      return this[args](fiber);
    }
  });
  var flatMap9 = /* @__PURE__ */ dual(2, (self, f) => {
    const onSuccess = Object.create(OnSuccessProto);
    onSuccess[args] = self;
    onSuccess[successCont] = f;
    return onSuccess;
  });
  var OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
    op: "OnSuccess",
    eval(fiber) {
      fiber._stack.push(this);
      return this[args];
    }
  });
  var isMicroExit = (u) => hasProperty(u, MicroExitTypeId);
  var exitSucceed2 = succeed4;
  var exitFailCause2 = failCause4;
  var exitInterrupt2 = /* @__PURE__ */ exitFailCause2(/* @__PURE__ */ causeInterrupt());
  var exitDie2 = (defect) => exitFailCause2(causeDie(defect));
  var exitVoid2 = /* @__PURE__ */ exitSucceed2(undefined);
  var setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);

  class MicroSchedulerDefault {
    tasks = [];
    running = false;
    scheduleTask(task, _priority) {
      this.tasks.push(task);
      if (!this.running) {
        this.running = true;
        setImmediate(this.afterScheduled);
      }
    }
    afterScheduled = () => {
      this.running = false;
      this.runTasks();
    };
    runTasks() {
      const tasks = this.tasks;
      this.tasks = [];
      for (let i = 0, len = tasks.length;i < len; i++) {
        tasks[i]();
      }
    }
    shouldYield(fiber) {
      return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
    }
    flush() {
      while (this.tasks.length > 0) {
        this.runTasks();
      }
    }
  }
  var updateContext = /* @__PURE__ */ dual(2, (self, f) => withMicroFiber((fiber) => {
    const prev = fiber.context;
    fiber.context = f(prev);
    return onExit2(self, () => {
      fiber.context = prev;
      return void_3;
    });
  }));
  var provideContext2 = /* @__PURE__ */ dual(2, (self, provided) => updateContext(self, merge3(provided)));
  class MaxOpsBeforeYield extends (/* @__PURE__ */ Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
    defaultValue: () => 2048
  })) {
  }
  class CurrentScheduler extends (/* @__PURE__ */ Reference2()("effect/Micro/currentScheduler", {
    defaultValue: () => new MicroSchedulerDefault
  })) {
  }
  var matchCauseEffect2 = /* @__PURE__ */ dual(2, (self, options) => {
    const primitive = Object.create(OnSuccessAndFailureProto);
    primitive[args] = self;
    primitive[successCont] = options.onSuccess;
    primitive[failureCont] = options.onFailure;
    return primitive;
  });
  var OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
    op: "OnSuccessAndFailure",
    eval(fiber) {
      fiber._stack.push(this);
      return this[args];
    }
  });
  var onExit2 = /* @__PURE__ */ dual(2, (self, f) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self), {
    onFailure: (cause2) => flatMap9(f(exitFailCause2(cause2)), () => failCause4(cause2)),
    onSuccess: (a) => flatMap9(f(exitSucceed2(a)), () => succeed4(a))
  })));
  var setInterruptible = /* @__PURE__ */ makePrimitive({
    op: "SetInterruptible",
    ensure(fiber) {
      fiber.interruptible = this[args];
      if (fiber._interrupted && fiber.interruptible) {
        return () => exitInterrupt2;
      }
    }
  });
  var interruptible3 = (self) => withMicroFiber((fiber) => {
    if (fiber.interruptible)
      return self;
    fiber.interruptible = true;
    fiber._stack.push(setInterruptible(false));
    if (fiber._interrupted)
      return exitInterrupt2;
    return self;
  });
  var uninterruptibleMask2 = (f) => withMicroFiber((fiber) => {
    if (!fiber.interruptible)
      return f(identity);
    fiber.interruptible = false;
    fiber._stack.push(setInterruptible(true));
    return f(interruptible3);
  });
  var runFork = (effect, options) => {
    const fiber = new MicroFiberImpl(CurrentScheduler.context(options?.scheduler ?? new MicroSchedulerDefault));
    fiber.evaluate(effect);
    if (options?.signal) {
      if (options.signal.aborted) {
        fiber.unsafeInterrupt();
      } else {
        const abort = () => fiber.unsafeInterrupt();
        options.signal.addEventListener("abort", abort, {
          once: true
        });
        fiber.addObserver(() => options.signal.removeEventListener("abort", abort));
      }
    }
    return fiber;
  };

  // node_modules/effect/dist/esm/Scheduler.js
  class PriorityBuckets {
    buckets = [];
    scheduleTask(task, priority) {
      const length3 = this.buckets.length;
      let bucket = undefined;
      let index = 0;
      for (;index < length3; index++) {
        if (this.buckets[index][0] <= priority) {
          bucket = this.buckets[index];
        } else {
          break;
        }
      }
      if (bucket && bucket[0] === priority) {
        bucket[1].push(task);
      } else if (index === length3) {
        this.buckets.push([priority, [task]]);
      } else {
        this.buckets.splice(index, 0, [priority, [task]]);
      }
    }
  }

  class MixedScheduler {
    maxNextTickBeforeTimer;
    running = false;
    tasks = /* @__PURE__ */ new PriorityBuckets;
    constructor(maxNextTickBeforeTimer) {
      this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
    }
    starveInternal(depth) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0;i < toRun.length; i++) {
          toRun[i]();
        }
      }
      if (this.tasks.buckets.length === 0) {
        this.running = false;
      } else {
        this.starve(depth);
      }
    }
    starve(depth = 0) {
      if (depth >= this.maxNextTickBeforeTimer) {
        setTimeout(() => this.starveInternal(0), 0);
      } else {
        Promise.resolve(undefined).then(() => this.starveInternal(depth + 1));
      }
    }
    shouldYield(fiber) {
      return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
    }
    scheduleTask(task, priority) {
      this.tasks.scheduleTask(task, priority);
      if (!this.running) {
        this.running = true;
        this.starve();
      }
    }
  }
  var defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));

  class SyncScheduler {
    tasks = /* @__PURE__ */ new PriorityBuckets;
    deferred = false;
    scheduleTask(task, priority) {
      if (this.deferred) {
        defaultScheduler.scheduleTask(task, priority);
      } else {
        this.tasks.scheduleTask(task, priority);
      }
    }
    shouldYield(fiber) {
      return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
    }
    flush() {
      while (this.tasks.buckets.length > 0) {
        const tasks = this.tasks.buckets;
        this.tasks.buckets = [];
        for (const [_, toRun] of tasks) {
          for (let i = 0;i < toRun.length; i++) {
            toRun[i]();
          }
        }
      }
      this.deferred = true;
    }
  }
  var currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
  var withScheduler = /* @__PURE__ */ dual(2, (self, scheduler) => fiberRefLocally(self, currentScheduler, scheduler));

  // node_modules/effect/dist/esm/internal/completedRequestMap.js
  var currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(new Map));

  // node_modules/effect/dist/esm/internal/concurrency.js
  var match9 = (concurrency, sequential4, unbounded2, bounded2) => {
    switch (concurrency) {
      case undefined:
        return sequential4();
      case "unbounded":
        return unbounded2();
      case "inherit":
        return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded2() : concurrency2 > 1 ? bounded2(concurrency2) : sequential4());
      default:
        return concurrency > 1 ? bounded2(concurrency) : sequential4();
    }
  };
  var matchSimple = (concurrency, sequential4, concurrent) => {
    switch (concurrency) {
      case undefined:
        return sequential4();
      case "unbounded":
        return concurrent();
      case "inherit":
        return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential4());
      default:
        return concurrency > 1 ? concurrent() : sequential4();
    }
  };

  // node_modules/effect/dist/esm/internal/fiberMessage.js
  var OP_INTERRUPT_SIGNAL = "InterruptSignal";
  var OP_STATEFUL = "Stateful";
  var OP_RESUME = "Resume";
  var OP_YIELD_NOW = "YieldNow";
  var interruptSignal = (cause2) => ({
    _tag: OP_INTERRUPT_SIGNAL,
    cause: cause2
  });
  var stateful = (onFiber) => ({
    _tag: OP_STATEFUL,
    onFiber
  });
  var resume = (effect) => ({
    _tag: OP_RESUME,
    effect
  });
  var yieldNow3 = () => ({
    _tag: OP_YIELD_NOW
  });

  // node_modules/effect/dist/esm/internal/fiberScope.js
  var FiberScopeSymbolKey = "effect/FiberScope";
  var FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);

  class Global {
    [FiberScopeTypeId] = FiberScopeTypeId;
    fiberId = none4;
    roots = /* @__PURE__ */ new Set;
    add(_runtimeFlags, child) {
      this.roots.add(child);
      child.addObserver(() => {
        this.roots.delete(child);
      });
    }
  }

  class Local {
    fiberId;
    parent;
    [FiberScopeTypeId] = FiberScopeTypeId;
    constructor(fiberId2, parent) {
      this.fiberId = fiberId2;
      this.parent = parent;
    }
    add(_runtimeFlags, child) {
      this.parent.tell(stateful((parentFiber) => {
        parentFiber.addChild(child);
        child.addObserver(() => {
          parentFiber.removeChild(child);
        });
      }));
    }
  }
  var unsafeMake8 = (fiber) => {
    return new Local(fiber.id(), fiber);
  };
  var globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global);

  // node_modules/effect/dist/esm/internal/fiber.js
  var FiberSymbolKey = "effect/Fiber";
  var FiberTypeId = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
  var fiberVariance2 = {
    _E: (_) => _,
    _A: (_) => _
  };
  var fiberProto = {
    [FiberTypeId]: fiberVariance2,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var RuntimeFiberSymbolKey = "effect/Fiber";
  var RuntimeFiberTypeId = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
  var isRuntimeFiber = (self) => (RuntimeFiberTypeId in self);
  var _await2 = (self) => self.await;
  var inheritAll = (self) => self.inheritAll;
  var interruptAllAs = /* @__PURE__ */ dual(2, /* @__PURE__ */ fnUntraced(function* (fibers, fiberId2) {
    for (const fiber of fibers) {
      if (isRuntimeFiber(fiber)) {
        fiber.unsafeInterruptAsFork(fiberId2);
        continue;
      }
      yield* fiber.interruptAsFork(fiberId2);
    }
    for (const fiber of fibers) {
      if (isRuntimeFiber(fiber) && fiber.unsafePoll()) {
        continue;
      }
      yield* fiber.await;
    }
  }));
  var interruptAsFork = /* @__PURE__ */ dual(2, (self, fiberId2) => self.interruptAsFork(fiberId2));
  var join2 = (self) => zipLeft(flatten6(self.await), self.inheritAll);
  var _never = {
    ...CommitPrototype,
    commit() {
      return join2(this);
    },
    ...fiberProto,
    id: () => none4,
    await: never,
    children: /* @__PURE__ */ succeed([]),
    inheritAll: never,
    poll: /* @__PURE__ */ succeed(/* @__PURE__ */ none2()),
    interruptAsFork: () => never
  };
  var poll3 = (self) => self.poll;
  var currentFiberURI = "effect/FiberCurrent";

  // node_modules/effect/dist/esm/internal/logger.js
  var LoggerSymbolKey = "effect/Logger";
  var LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
  var loggerVariance = {
    _Message: (_) => _,
    _Output: (_) => _
  };
  var makeLogger = (log2) => ({
    [LoggerTypeId]: loggerVariance,
    log: log2,
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  var none7 = {
    [LoggerTypeId]: loggerVariance,
    log: constVoid,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var textOnly = /^[^\s"=]*$/;
  var format3 = (quoteValue, whitespace) => ({
    annotations: annotations2,
    cause: cause2,
    date,
    fiberId: fiberId2,
    logLevel,
    message,
    spans
  }) => {
    const formatValue = (value) => value.match(textOnly) ? value : quoteValue(value);
    const format4 = (label, value) => `${formatLabel(label)}=${formatValue(value)}`;
    const append4 = (label, value) => " " + format4(label, value);
    let out = format4("timestamp", date.toISOString());
    out += append4("level", logLevel.label);
    out += append4("fiber", threadName(fiberId2));
    const messages = ensure(message);
    for (let i = 0;i < messages.length; i++) {
      out += append4("message", toStringUnknown(messages[i], whitespace));
    }
    if (!isEmptyType(cause2)) {
      out += append4("cause", pretty(cause2, {
        renderErrorCause: true
      }));
    }
    for (const span2 of spans) {
      out += " " + render(date.getTime())(span2);
    }
    for (const [label, value] of annotations2) {
      out += append4(label, toStringUnknown(value, whitespace));
    }
    return out;
  };
  var escapeDoubleQuotes = (s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
  var stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format3(escapeDoubleQuotes));
  var colors = {
    bold: "1",
    red: "31",
    green: "32",
    yellow: "33",
    blue: "34",
    cyan: "36",
    white: "37",
    gray: "90",
    black: "30",
    bgBrightRed: "101"
  };
  var logLevelColors = {
    None: [],
    All: [],
    Trace: [colors.gray],
    Debug: [colors.blue],
    Info: [colors.green],
    Warning: [colors.yellow],
    Error: [colors.red],
    Fatal: [colors.bgBrightRed, colors.black]
  };
  var hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
  var processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
  var hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;

  // node_modules/effect/dist/esm/internal/metric/boundaries.js
  var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
  var MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);

  class MetricBoundariesImpl {
    values;
    [MetricBoundariesTypeId] = MetricBoundariesTypeId;
    constructor(values3) {
      this.values = values3;
      this._hash = pipe(string(MetricBoundariesSymbolKey), combine(array2(this.values)));
    }
    _hash;
    [symbol]() {
      return this._hash;
    }
    [symbol2](u) {
      return isMetricBoundaries(u) && equals(this.values, u.values);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var isMetricBoundaries = (u) => hasProperty(u, MetricBoundariesTypeId);
  var fromIterable7 = (iterable) => {
    const values3 = pipe(iterable, appendAll(of2(Number.POSITIVE_INFINITY)), dedupe);
    return new MetricBoundariesImpl(values3);
  };
  var exponential = (options) => pipe(makeBy(options.count - 1, (i) => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromIterable7);

  // node_modules/effect/dist/esm/internal/metric/keyType.js
  var MetricKeyTypeSymbolKey = "effect/MetricKeyType";
  var MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
  var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
  var CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
  var FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
  var FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
  var GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
  var GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
  var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
  var HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
  var SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
  var SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
  var metricKeyTypeVariance = {
    _In: (_) => _,
    _Out: (_) => _
  };

  class CounterKeyType {
    incremental;
    bigint;
    [MetricKeyTypeTypeId] = metricKeyTypeVariance;
    [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
    constructor(incremental, bigint) {
      this.incremental = incremental;
      this.bigint = bigint;
      this._hash = string(CounterKeyTypeSymbolKey);
    }
    _hash;
    [symbol]() {
      return this._hash;
    }
    [symbol2](that) {
      return isCounterKey(that);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  class HistogramKeyType {
    boundaries;
    [MetricKeyTypeTypeId] = metricKeyTypeVariance;
    [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
    constructor(boundaries) {
      this.boundaries = boundaries;
      this._hash = pipe(string(HistogramKeyTypeSymbolKey), combine(hash(this.boundaries)));
    }
    _hash;
    [symbol]() {
      return this._hash;
    }
    [symbol2](that) {
      return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var counter = (options) => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);
  var histogram = (boundaries) => {
    return new HistogramKeyType(boundaries);
  };
  var isCounterKey = (u) => hasProperty(u, CounterKeyTypeTypeId);
  var isFrequencyKey = (u) => hasProperty(u, FrequencyKeyTypeTypeId);
  var isGaugeKey = (u) => hasProperty(u, GaugeKeyTypeTypeId);
  var isHistogramKey = (u) => hasProperty(u, HistogramKeyTypeTypeId);
  var isSummaryKey = (u) => hasProperty(u, SummaryKeyTypeTypeId);

  // node_modules/effect/dist/esm/internal/metric/key.js
  var MetricKeySymbolKey = "effect/MetricKey";
  var MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
  var metricKeyVariance = {
    _Type: (_) => _
  };
  var arrayEquivilence = /* @__PURE__ */ getEquivalence(equals);

  class MetricKeyImpl {
    name;
    keyType;
    description;
    tags;
    [MetricKeyTypeId] = metricKeyVariance;
    constructor(name, keyType, description, tags = []) {
      this.name = name;
      this.keyType = keyType;
      this.description = description;
      this.tags = tags;
      this._hash = pipe(string(this.name + this.description), combine(hash(this.keyType)), combine(array2(this.tags)));
    }
    _hash;
    [symbol]() {
      return this._hash;
    }
    [symbol2](u) {
      return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var isMetricKey = (u) => hasProperty(u, MetricKeyTypeId);
  var counter2 = (name, options) => new MetricKeyImpl(name, counter(options), fromNullable(options?.description));
  var histogram2 = (name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable(description));
  var taggedWithLabels = /* @__PURE__ */ dual(2, (self, extraTags) => extraTags.length === 0 ? self : new MetricKeyImpl(self.name, self.keyType, self.description, union(self.tags, extraTags)));

  // node_modules/effect/dist/esm/internal/metric/state.js
  var MetricStateSymbolKey = "effect/MetricState";
  var MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
  var CounterStateSymbolKey = "effect/MetricState/Counter";
  var CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
  var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
  var FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
  var GaugeStateSymbolKey = "effect/MetricState/Gauge";
  var GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
  var HistogramStateSymbolKey = "effect/MetricState/Histogram";
  var HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
  var SummaryStateSymbolKey = "effect/MetricState/Summary";
  var SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
  var metricStateVariance = {
    _A: (_) => _
  };

  class CounterState {
    count;
    [MetricStateTypeId] = metricStateVariance;
    [CounterStateTypeId] = CounterStateTypeId;
    constructor(count) {
      this.count = count;
    }
    [symbol]() {
      return pipe(hash(CounterStateSymbolKey), combine(hash(this.count)), cached(this));
    }
    [symbol2](that) {
      return isCounterState(that) && this.count === that.count;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var arrayEquals = /* @__PURE__ */ getEquivalence(equals);

  class FrequencyState {
    occurrences;
    [MetricStateTypeId] = metricStateVariance;
    [FrequencyStateTypeId] = FrequencyStateTypeId;
    constructor(occurrences) {
      this.occurrences = occurrences;
    }
    _hash;
    [symbol]() {
      return pipe(string(FrequencyStateSymbolKey), combine(array2(fromIterable(this.occurrences.entries()))), cached(this));
    }
    [symbol2](that) {
      return isFrequencyState(that) && arrayEquals(fromIterable(this.occurrences.entries()), fromIterable(that.occurrences.entries()));
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }

  class GaugeState {
    value;
    [MetricStateTypeId] = metricStateVariance;
    [GaugeStateTypeId] = GaugeStateTypeId;
    constructor(value) {
      this.value = value;
    }
    [symbol]() {
      return pipe(hash(GaugeStateSymbolKey), combine(hash(this.value)), cached(this));
    }
    [symbol2](u) {
      return isGaugeState(u) && this.value === u.value;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }

  class HistogramState {
    buckets;
    count;
    min;
    max;
    sum;
    [MetricStateTypeId] = metricStateVariance;
    [HistogramStateTypeId] = HistogramStateTypeId;
    constructor(buckets, count, min2, max2, sum2) {
      this.buckets = buckets;
      this.count = count;
      this.min = min2;
      this.max = max2;
      this.sum = sum2;
    }
    [symbol]() {
      return pipe(hash(HistogramStateSymbolKey), combine(hash(this.buckets)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
    }
    [symbol2](that) {
      return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }

  class SummaryState {
    error;
    quantiles;
    count;
    min;
    max;
    sum;
    [MetricStateTypeId] = metricStateVariance;
    [SummaryStateTypeId] = SummaryStateTypeId;
    constructor(error, quantiles, count, min2, max2, sum2) {
      this.error = error;
      this.quantiles = quantiles;
      this.count = count;
      this.min = min2;
      this.max = max2;
      this.sum = sum2;
    }
    [symbol]() {
      return pipe(hash(SummaryStateSymbolKey), combine(hash(this.error)), combine(hash(this.quantiles)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
    }
    [symbol2](that) {
      return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var counter3 = (count) => new CounterState(count);
  var frequency2 = (occurrences) => {
    return new FrequencyState(occurrences);
  };
  var gauge2 = (count) => new GaugeState(count);
  var histogram3 = (options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
  var summary2 = (options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
  var isCounterState = (u) => hasProperty(u, CounterStateTypeId);
  var isFrequencyState = (u) => hasProperty(u, FrequencyStateTypeId);
  var isGaugeState = (u) => hasProperty(u, GaugeStateTypeId);
  var isHistogramState = (u) => hasProperty(u, HistogramStateTypeId);
  var isSummaryState = (u) => hasProperty(u, SummaryStateTypeId);

  // node_modules/effect/dist/esm/internal/metric/hook.js
  var MetricHookSymbolKey = "effect/MetricHook";
  var MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
  var metricHookVariance = {
    _In: (_) => _,
    _Out: (_) => _
  };
  var make30 = (options) => ({
    [MetricHookTypeId]: metricHookVariance,
    pipe() {
      return pipeArguments(this, arguments);
    },
    ...options
  });
  var bigint03 = /* @__PURE__ */ BigInt(0);
  var counter4 = (key) => {
    let sum2 = key.keyType.bigint ? bigint03 : 0;
    const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value) => value >= bigint03 : (value) => value >= 0 : (_value) => true;
    const update4 = (value) => {
      if (canUpdate(value)) {
        sum2 = sum2 + value;
      }
    };
    return make30({
      get: () => counter3(sum2),
      update: update4,
      modify: update4
    });
  };
  var frequency3 = (key) => {
    const values3 = new Map;
    for (const word of key.keyType.preregisteredWords) {
      values3.set(word, 0);
    }
    const update4 = (word) => {
      const slotCount = values3.get(word) ?? 0;
      values3.set(word, slotCount + 1);
    };
    return make30({
      get: () => frequency2(values3),
      update: update4,
      modify: update4
    });
  };
  var gauge3 = (_key, startAt) => {
    let value = startAt;
    return make30({
      get: () => gauge2(value),
      update: (v) => {
        value = v;
      },
      modify: (v) => {
        value = value + v;
      }
    });
  };
  var histogram4 = (key) => {
    const bounds = key.keyType.boundaries.values;
    const size5 = bounds.length;
    const values3 = new Uint32Array(size5 + 1);
    const boundaries = new Float64Array(size5);
    let count = 0;
    let sum2 = 0;
    let min2 = Number.MAX_VALUE;
    let max2 = Number.MIN_VALUE;
    pipe(bounds, sort(Order), map3((n, i) => {
      boundaries[i] = n;
    }));
    const update4 = (value) => {
      let from = 0;
      let to = size5;
      while (from !== to) {
        const mid = Math.floor(from + (to - from) / 2);
        const boundary = boundaries[mid];
        if (value <= boundary) {
          to = mid;
        } else {
          from = mid;
        }
        if (to === from + 1) {
          if (value <= boundaries[from]) {
            to = from;
          } else {
            from = to;
          }
        }
      }
      values3[from] = values3[from] + 1;
      count = count + 1;
      sum2 = sum2 + value;
      if (value < min2) {
        min2 = value;
      }
      if (value > max2) {
        max2 = value;
      }
    };
    const getBuckets = () => {
      const builder = allocate(size5);
      let cumulated = 0;
      for (let i = 0;i < size5; i++) {
        const boundary = boundaries[i];
        const value = values3[i];
        cumulated = cumulated + value;
        builder[i] = [boundary, cumulated];
      }
      return builder;
    };
    return make30({
      get: () => histogram3({
        buckets: getBuckets(),
        count,
        min: min2,
        max: max2,
        sum: sum2
      }),
      update: update4,
      modify: update4
    });
  };
  var summary3 = (key) => {
    const {
      error,
      maxAge,
      maxSize,
      quantiles
    } = key.keyType;
    const sortedQuantiles = pipe(quantiles, sort(Order));
    const values3 = allocate(maxSize);
    let head4 = 0;
    let count = 0;
    let sum2 = 0;
    let min2 = 0;
    let max2 = 0;
    const snapshot = (now) => {
      const builder = [];
      let i = 0;
      while (i !== maxSize - 1) {
        const item = values3[i];
        if (item != null) {
          const [t, v] = item;
          const age = millis(now - t);
          if (greaterThanOrEqualTo2(age, zero) && lessThanOrEqualTo2(age, maxAge)) {
            builder.push(v);
          }
        }
        i = i + 1;
      }
      return calculateQuantiles(error, sortedQuantiles, sort(builder, Order));
    };
    const observe = (value, timestamp) => {
      if (maxSize > 0) {
        head4 = head4 + 1;
        const target = head4 % maxSize;
        values3[target] = [timestamp, value];
      }
      min2 = count === 0 ? value : Math.min(min2, value);
      max2 = count === 0 ? value : Math.max(max2, value);
      count = count + 1;
      sum2 = sum2 + value;
    };
    return make30({
      get: () => summary2({
        error,
        quantiles: snapshot(Date.now()),
        count,
        min: min2,
        max: max2,
        sum: sum2
      }),
      update: ([value, timestamp]) => observe(value, timestamp),
      modify: ([value, timestamp]) => observe(value, timestamp)
    });
  };
  var calculateQuantiles = (error, sortedQuantiles, sortedSamples) => {
    const sampleCount = sortedSamples.length;
    if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
      return empty();
    }
    const head4 = sortedQuantiles[0];
    const tail = sortedQuantiles.slice(1);
    const resolvedHead = resolveQuantile(error, sampleCount, none2(), 0, head4, sortedSamples);
    const resolved = of(resolvedHead);
    tail.forEach((quantile) => {
      resolved.push(resolveQuantile(error, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
    });
    return map3(resolved, (rq) => [rq.quantile, rq.value]);
  };
  var resolveQuantile = (error, sampleCount, current, consumed, quantile, rest) => {
    let error_1 = error;
    let sampleCount_1 = sampleCount;
    let current_1 = current;
    let consumed_1 = consumed;
    let quantile_1 = quantile;
    let rest_1 = rest;
    let error_2 = error;
    let sampleCount_2 = sampleCount;
    let current_2 = current;
    let consumed_2 = consumed;
    let quantile_2 = quantile;
    let rest_2 = rest;
    while (true) {
      if (!isNonEmptyReadonlyArray(rest_1)) {
        return {
          quantile: quantile_1,
          value: none2(),
          consumed: consumed_1,
          rest: []
        };
      }
      if (quantile_1 === 1) {
        return {
          quantile: quantile_1,
          value: some2(lastNonEmpty(rest_1)),
          consumed: consumed_1 + rest_1.length,
          rest: []
        };
      }
      const headValue = headNonEmpty(rest_1);
      const sameHead = span(rest_1, (n) => n === headValue);
      const desired = quantile_1 * sampleCount_1;
      const allowedError = error_1 / 2 * desired;
      const candConsumed = consumed_1 + sameHead[0].length;
      const candError = Math.abs(candConsumed - desired);
      if (candConsumed < desired - allowedError) {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      if (candConsumed > desired + allowedError) {
        const valueToReturn = isNone2(current_1) ? some2(headValue) : current_1;
        return {
          quantile: quantile_1,
          value: valueToReturn,
          consumed: consumed_1,
          rest: rest_1
        };
      }
      switch (current_1._tag) {
        case "None": {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        case "Some": {
          const prevError = Math.abs(desired - current_1.value);
          if (candError < prevError) {
            error_2 = error_1;
            sampleCount_2 = sampleCount_1;
            current_2 = head(rest_1);
            consumed_2 = candConsumed;
            quantile_2 = quantile_1;
            rest_2 = sameHead[1];
            error_1 = error_2;
            sampleCount_1 = sampleCount_2;
            current_1 = current_2;
            consumed_1 = consumed_2;
            quantile_1 = quantile_2;
            rest_1 = rest_2;
            continue;
          }
          return {
            quantile: quantile_1,
            value: some2(current_1.value),
            consumed: consumed_1,
            rest: rest_1
          };
        }
      }
    }
    throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
  };

  // node_modules/effect/dist/esm/internal/metric/pair.js
  var MetricPairSymbolKey = "effect/MetricPair";
  var MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
  var metricPairVariance = {
    _Type: (_) => _
  };
  var unsafeMake9 = (metricKey, metricState) => {
    return {
      [MetricPairTypeId]: metricPairVariance,
      metricKey,
      metricState,
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
  };

  // node_modules/effect/dist/esm/internal/metric/registry.js
  var MetricRegistrySymbolKey = "effect/MetricRegistry";
  var MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);

  class MetricRegistryImpl {
    [MetricRegistryTypeId] = MetricRegistryTypeId;
    map = /* @__PURE__ */ empty17();
    snapshot() {
      const result = [];
      for (const [key, hook] of this.map) {
        result.push(unsafeMake9(key, hook.get()));
      }
      return result;
    }
    get(key) {
      const hook = pipe(this.map, get8(key), getOrUndefined);
      if (hook == null) {
        if (isCounterKey(key.keyType)) {
          return this.getCounter(key);
        }
        if (isGaugeKey(key.keyType)) {
          return this.getGauge(key);
        }
        if (isFrequencyKey(key.keyType)) {
          return this.getFrequency(key);
        }
        if (isHistogramKey(key.keyType)) {
          return this.getHistogram(key);
        }
        if (isSummaryKey(key.keyType)) {
          return this.getSummary(key);
        }
        throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
      } else {
        return hook;
      }
    }
    getCounter(key) {
      let value = pipe(this.map, get8(key), getOrUndefined);
      if (value == null) {
        const counter5 = counter4(key);
        if (!pipe(this.map, has4(key))) {
          pipe(this.map, set4(key, counter5));
        }
        value = counter5;
      }
      return value;
    }
    getFrequency(key) {
      let value = pipe(this.map, get8(key), getOrUndefined);
      if (value == null) {
        const frequency4 = frequency3(key);
        if (!pipe(this.map, has4(key))) {
          pipe(this.map, set4(key, frequency4));
        }
        value = frequency4;
      }
      return value;
    }
    getGauge(key) {
      let value = pipe(this.map, get8(key), getOrUndefined);
      if (value == null) {
        const gauge4 = gauge3(key, key.keyType.bigint ? BigInt(0) : 0);
        if (!pipe(this.map, has4(key))) {
          pipe(this.map, set4(key, gauge4));
        }
        value = gauge4;
      }
      return value;
    }
    getHistogram(key) {
      let value = pipe(this.map, get8(key), getOrUndefined);
      if (value == null) {
        const histogram5 = histogram4(key);
        if (!pipe(this.map, has4(key))) {
          pipe(this.map, set4(key, histogram5));
        }
        value = histogram5;
      }
      return value;
    }
    getSummary(key) {
      let value = pipe(this.map, get8(key), getOrUndefined);
      if (value == null) {
        const summary4 = summary3(key);
        if (!pipe(this.map, has4(key))) {
          pipe(this.map, set4(key, summary4));
        }
        value = summary4;
      }
      return value;
    }
  }
  var make31 = () => {
    return new MetricRegistryImpl;
  };

  // node_modules/effect/dist/esm/internal/metric.js
  var MetricSymbolKey = "effect/Metric";
  var MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
  var metricVariance = {
    _Type: (_) => _,
    _In: (_) => _,
    _Out: (_) => _
  };
  var globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make31());
  var make32 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
    const metric = Object.assign((effect) => tap(effect, (a) => update4(metric, a)), {
      [MetricTypeId]: metricVariance,
      keyType,
      unsafeUpdate,
      unsafeValue,
      unsafeModify,
      register() {
        this.unsafeValue([]);
        return this;
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    });
    return metric;
  };
  var counter5 = (name, options) => fromMetricKey(counter2(name, options));
  var fromMetricKey = (key) => {
    let untaggedHook;
    const hookCache = new WeakMap;
    const hook = (extraTags) => {
      if (extraTags.length === 0) {
        if (untaggedHook !== undefined) {
          return untaggedHook;
        }
        untaggedHook = globalMetricRegistry.get(key);
        return untaggedHook;
      }
      let hook2 = hookCache.get(extraTags);
      if (hook2 !== undefined) {
        return hook2;
      }
      hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
      hookCache.set(extraTags, hook2);
      return hook2;
    };
    return make32(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
  };
  var histogram5 = (name, boundaries, description) => fromMetricKey(histogram2(name, boundaries, description));
  var tagged = /* @__PURE__ */ dual(3, (self, key, value) => taggedWithLabels2(self, [make29(key, value)]));
  var taggedWithLabels2 = /* @__PURE__ */ dual(2, (self, extraTags) => {
    return make32(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, union(extraTags, extraTags1)), (extraTags1) => self.unsafeValue(union(extraTags, extraTags1)), (input, extraTags1) => self.unsafeModify(input, union(extraTags, extraTags1)));
  });
  var update4 = /* @__PURE__ */ dual(2, (self, input) => fiberRefGetWith(currentMetricLabels, (tags) => sync(() => self.unsafeUpdate(input, tags))));

  // node_modules/effect/dist/esm/internal/request.js
  var RequestSymbolKey = "effect/Request";
  var RequestTypeId = /* @__PURE__ */ Symbol.for(RequestSymbolKey);
  var requestVariance = {
    _E: (_) => _,
    _A: (_) => _
  };
  var RequestPrototype = {
    ...StructuralPrototype,
    [RequestTypeId]: requestVariance
  };
  var isRequest = (u) => hasProperty(u, RequestTypeId);
  var complete = /* @__PURE__ */ dual(2, (self, result) => fiberRefGetWith(currentRequestMap, (map12) => sync(() => {
    if (map12.has(self)) {
      const entry = map12.get(self);
      if (!entry.state.completed) {
        entry.state.completed = true;
        deferredUnsafeDone(entry.result, result);
      }
    }
  })));
  class Listeners {
    count = 0;
    observers = /* @__PURE__ */ new Set;
    interrupted = false;
    addObserver(f) {
      this.observers.add(f);
    }
    removeObserver(f) {
      this.observers.delete(f);
    }
    increment() {
      this.count++;
      this.observers.forEach((f) => f(this.count));
    }
    decrement() {
      this.count--;
      this.observers.forEach((f) => f(this.count));
    }
  }

  // node_modules/effect/dist/esm/internal/supervisor.js
  var SupervisorSymbolKey = "effect/Supervisor";
  var SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
  var supervisorVariance = {
    _T: (_) => _
  };

  class ProxySupervisor {
    underlying;
    value0;
    [SupervisorTypeId] = supervisorVariance;
    constructor(underlying, value0) {
      this.underlying = underlying;
      this.value0 = value0;
    }
    get value() {
      return this.value0;
    }
    onStart(context2, effect, parent, fiber) {
      this.underlying.onStart(context2, effect, parent, fiber);
    }
    onEnd(value, fiber) {
      this.underlying.onEnd(value, fiber);
    }
    onEffect(fiber, effect) {
      this.underlying.onEffect(fiber, effect);
    }
    onSuspend(fiber) {
      this.underlying.onSuspend(fiber);
    }
    onResume(fiber) {
      this.underlying.onResume(fiber);
    }
    map(f) {
      return new ProxySupervisor(this, pipe(this.value, map10(f)));
    }
    zip(right3) {
      return new Zip(this, right3);
    }
  }

  class Zip {
    left;
    right;
    _tag = "Zip";
    [SupervisorTypeId] = supervisorVariance;
    constructor(left3, right3) {
      this.left = left3;
      this.right = right3;
    }
    get value() {
      return zip2(this.left.value, this.right.value);
    }
    onStart(context2, effect, parent, fiber) {
      this.left.onStart(context2, effect, parent, fiber);
      this.right.onStart(context2, effect, parent, fiber);
    }
    onEnd(value, fiber) {
      this.left.onEnd(value, fiber);
      this.right.onEnd(value, fiber);
    }
    onEffect(fiber, effect) {
      this.left.onEffect(fiber, effect);
      this.right.onEffect(fiber, effect);
    }
    onSuspend(fiber) {
      this.left.onSuspend(fiber);
      this.right.onSuspend(fiber);
    }
    onResume(fiber) {
      this.left.onResume(fiber);
      this.right.onResume(fiber);
    }
    map(f) {
      return new ProxySupervisor(this, pipe(this.value, map10(f)));
    }
    zip(right3) {
      return new Zip(this, right3);
    }
  }
  var isZip = (self) => hasProperty(self, SupervisorTypeId) && isTagged(self, "Zip");

  class Track {
    [SupervisorTypeId] = supervisorVariance;
    fibers = /* @__PURE__ */ new Set;
    get value() {
      return sync(() => Array.from(this.fibers));
    }
    onStart(_context, _effect, _parent, fiber) {
      this.fibers.add(fiber);
    }
    onEnd(_value, fiber) {
      this.fibers.delete(fiber);
    }
    onEffect(_fiber, _effect) {}
    onSuspend(_fiber) {}
    onResume(_fiber) {}
    map(f) {
      return new ProxySupervisor(this, pipe(this.value, map10(f)));
    }
    zip(right3) {
      return new Zip(this, right3);
    }
    onRun(execution, _fiber) {
      return execution();
    }
  }

  class Const {
    effect;
    [SupervisorTypeId] = supervisorVariance;
    constructor(effect) {
      this.effect = effect;
    }
    get value() {
      return this.effect;
    }
    onStart(_context, _effect, _parent, _fiber) {}
    onEnd(_value, _fiber) {}
    onEffect(_fiber, _effect) {}
    onSuspend(_fiber) {}
    onResume(_fiber) {}
    map(f) {
      return new ProxySupervisor(this, pipe(this.value, map10(f)));
    }
    zip(right3) {
      return new Zip(this, right3);
    }
    onRun(execution, _fiber) {
      return execution();
    }
  }
  var unsafeTrack = () => {
    return new Track;
  };
  var track = /* @__PURE__ */ sync(unsafeTrack);
  var fromEffect = (effect) => {
    return new Const(effect);
  };
  var none8 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect(void_));

  // node_modules/effect/dist/esm/Differ.js
  var make33 = make14;

  // node_modules/effect/dist/esm/internal/supervisor/patch.js
  var OP_EMPTY3 = "Empty";
  var OP_ADD_SUPERVISOR = "AddSupervisor";
  var OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
  var OP_AND_THEN2 = "AndThen";
  var empty23 = {
    _tag: OP_EMPTY3
  };
  var combine8 = (self, that) => {
    return {
      _tag: OP_AND_THEN2,
      first: self,
      second: that
    };
  };
  var patch8 = (self, supervisor) => {
    return patchLoop(supervisor, of2(self));
  };
  var patchLoop = (_supervisor, _patches) => {
    let supervisor = _supervisor;
    let patches = _patches;
    while (isNonEmpty2(patches)) {
      const head4 = headNonEmpty2(patches);
      switch (head4._tag) {
        case OP_EMPTY3: {
          patches = tailNonEmpty2(patches);
          break;
        }
        case OP_ADD_SUPERVISOR: {
          supervisor = supervisor.zip(head4.supervisor);
          patches = tailNonEmpty2(patches);
          break;
        }
        case OP_REMOVE_SUPERVISOR: {
          supervisor = removeSupervisor(supervisor, head4.supervisor);
          patches = tailNonEmpty2(patches);
          break;
        }
        case OP_AND_THEN2: {
          patches = prepend2(head4.first)(prepend2(head4.second)(tailNonEmpty2(patches)));
          break;
        }
      }
    }
    return supervisor;
  };
  var removeSupervisor = (self, that) => {
    if (equals(self, that)) {
      return none8;
    } else {
      if (isZip(self)) {
        return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));
      } else {
        return self;
      }
    }
  };
  var toSet2 = (self) => {
    if (equals(self, none8)) {
      return empty7();
    } else {
      if (isZip(self)) {
        return pipe(toSet2(self.left), union3(toSet2(self.right)));
      } else {
        return make10(self);
      }
    }
  };
  var diff7 = (oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return empty23;
    }
    const oldSupervisors = toSet2(oldValue);
    const newSupervisors = toSet2(newValue);
    const added = pipe(newSupervisors, difference3(oldSupervisors), reduce5(empty23, (patch9, supervisor) => combine8(patch9, {
      _tag: OP_ADD_SUPERVISOR,
      supervisor
    })));
    const removed = pipe(oldSupervisors, difference3(newSupervisors), reduce5(empty23, (patch9, supervisor) => combine8(patch9, {
      _tag: OP_REMOVE_SUPERVISOR,
      supervisor
    })));
    return combine8(added, removed);
  };
  var differ2 = /* @__PURE__ */ make33({
    empty: empty23,
    patch: patch8,
    combine: combine8,
    diff: diff7
  });

  // node_modules/effect/dist/esm/internal/fiberRuntime.js
  var fiberStarted = /* @__PURE__ */ counter5("effect_fiber_started", {
    incremental: true
  });
  var fiberActive = /* @__PURE__ */ counter5("effect_fiber_active");
  var fiberSuccesses = /* @__PURE__ */ counter5("effect_fiber_successes", {
    incremental: true
  });
  var fiberFailures = /* @__PURE__ */ counter5("effect_fiber_failures", {
    incremental: true
  });
  var fiberLifetimes = /* @__PURE__ */ tagged(/* @__PURE__ */ histogram5("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
    start: 0.5,
    factor: 2,
    count: 35
  })), "time_unit", "milliseconds");
  var EvaluationSignalContinue = "Continue";
  var EvaluationSignalDone = "Done";
  var EvaluationSignalYieldNow = "Yield";
  var runtimeFiberVariance = {
    _E: (_) => _,
    _A: (_) => _
  };
  var absurd = (_) => {
    throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  };
  var YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
  var yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
    currentOp: null
  }));
  var contOpSuccess = {
    [OP_ON_SUCCESS]: (_, cont, value) => {
      return internalCall(() => cont.effect_instruction_i1(value));
    },
    ["OnStep"]: (_, _cont, value) => {
      return exitSucceed(exitSucceed(value));
    },
    [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value) => {
      return internalCall(() => cont.effect_instruction_i2(value));
    },
    [OP_REVERT_FLAGS]: (self, cont, value) => {
      self.patchRuntimeFlags(self.currentRuntimeFlags, cont.patch);
      if (interruptible(self.currentRuntimeFlags) && self.isInterrupted()) {
        return exitFailCause(self.getInterruptedCause());
      } else {
        return exitSucceed(value);
      }
    },
    [OP_WHILE]: (self, cont, value) => {
      internalCall(() => cont.effect_instruction_i2(value));
      if (internalCall(() => cont.effect_instruction_i0())) {
        self.pushStack(cont);
        return internalCall(() => cont.effect_instruction_i1());
      } else {
        return void_;
      }
    },
    [OP_ITERATOR]: (self, cont, value) => {
      while (true) {
        const state = internalCall(() => cont.effect_instruction_i0.next(value));
        if (state.done) {
          return exitSucceed(state.value);
        }
        const primitive = yieldWrapGet(state.value);
        if (!exitIsExit(primitive)) {
          self.pushStack(cont);
          return primitive;
        } else if (primitive._tag === "Failure") {
          return primitive;
        }
        value = primitive.value;
      }
    }
  };
  var drainQueueWhileRunningTable = {
    [OP_INTERRUPT_SIGNAL]: (self, runtimeFlags2, cur, message) => {
      self.processNewInterruptSignal(message.cause);
      return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
    },
    [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
      throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
    },
    [OP_STATEFUL]: (self, runtimeFlags2, cur, message) => {
      message.onFiber(self, running2(runtimeFlags2));
      return cur;
    },
    [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
      return flatMap8(yieldNow(), () => cur);
    }
  };
  var runBlockedRequests = (self) => forEachSequentialDiscard(flatten4(self), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential4]) => {
    const map12 = new Map;
    const arr = [];
    for (const block of sequential4) {
      arr.push(toReadonlyArray(block));
      for (const entry of block) {
        map12.set(entry.request, entry);
      }
    }
    const flat = arr.flat();
    return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
      entry.listeners.interrupted = true;
    })), currentRequestMap, map12);
  }, false, false));
  var _version = /* @__PURE__ */ getCurrentVersion();

  class FiberRuntime extends Class {
    [FiberTypeId] = fiberVariance2;
    [RuntimeFiberTypeId] = runtimeFiberVariance;
    _fiberRefs;
    _fiberId;
    _queue = /* @__PURE__ */ new Array;
    _children = null;
    _observers = /* @__PURE__ */ new Array;
    _running = false;
    _stack = [];
    _asyncInterruptor = null;
    _asyncBlockingOn = null;
    _exitValue = null;
    _steps = [];
    _isYielding = false;
    currentRuntimeFlags;
    currentOpCount = 0;
    currentSupervisor;
    currentScheduler;
    currentTracer;
    currentSpan;
    currentContext;
    currentDefaultServices;
    constructor(fiberId2, fiberRefs0, runtimeFlags0) {
      super();
      this.currentRuntimeFlags = runtimeFlags0;
      this._fiberId = fiberId2;
      this._fiberRefs = fiberRefs0;
      if (runtimeMetrics(runtimeFlags0)) {
        const tags = this.getFiberRef(currentMetricLabels);
        fiberStarted.unsafeUpdate(1, tags);
        fiberActive.unsafeUpdate(1, tags);
      }
      this.refreshRefCache();
    }
    commit() {
      return join2(this);
    }
    id() {
      return this._fiberId;
    }
    resume(effect) {
      this.tell(resume(effect));
    }
    get status() {
      return this.ask((_, status) => status);
    }
    get runtimeFlags() {
      return this.ask((state, status) => {
        if (isDone3(status)) {
          return state.currentRuntimeFlags;
        }
        return status.runtimeFlags;
      });
    }
    scope() {
      return unsafeMake8(this);
    }
    get children() {
      return this.ask((fiber) => Array.from(fiber.getChildren()));
    }
    getChildren() {
      if (this._children === null) {
        this._children = new Set;
      }
      return this._children;
    }
    getInterruptedCause() {
      return this.getFiberRef(currentInterruptedCause);
    }
    fiberRefs() {
      return this.ask((fiber) => fiber.getFiberRefs());
    }
    ask(f) {
      return suspend(() => {
        const deferred = deferredUnsafeMake(this._fiberId);
        this.tell(stateful((fiber, status) => {
          deferredUnsafeDone(deferred, sync(() => f(fiber, status)));
        }));
        return deferredAwait(deferred);
      });
    }
    tell(message) {
      this._queue.push(message);
      if (!this._running) {
        this._running = true;
        this.drainQueueLaterOnExecutor();
      }
    }
    get await() {
      return async_((resume2) => {
        const cb = (exit2) => resume2(succeed(exit2));
        this.tell(stateful((fiber, _) => {
          if (fiber._exitValue !== null) {
            cb(this._exitValue);
          } else {
            fiber.addObserver(cb);
          }
        }));
        return sync(() => this.tell(stateful((fiber, _) => {
          fiber.removeObserver(cb);
        })));
      }, this.id());
    }
    get inheritAll() {
      return withFiberRuntime((parentFiber, parentStatus) => {
        const parentFiberId = parentFiber.id();
        const parentFiberRefs = parentFiber.getFiberRefs();
        const parentRuntimeFlags = parentStatus.runtimeFlags;
        const childFiberRefs = this.getFiberRefs();
        const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
        parentFiber.setFiberRefs(updatedFiberRefs);
        const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
        const patch9 = pipe(diff4(parentRuntimeFlags, updatedRuntimeFlags), exclude2(Interruption), exclude2(WindDown));
        return updateRuntimeFlags(patch9);
      });
    }
    get poll() {
      return sync(() => fromNullable(this._exitValue));
    }
    unsafePoll() {
      return this._exitValue;
    }
    interruptAsFork(fiberId2) {
      return sync(() => this.tell(interruptSignal(interrupt(fiberId2))));
    }
    unsafeInterruptAsFork(fiberId2) {
      this.tell(interruptSignal(interrupt(fiberId2)));
    }
    addObserver(observer) {
      if (this._exitValue !== null) {
        observer(this._exitValue);
      } else {
        this._observers.push(observer);
      }
    }
    removeObserver(observer) {
      this._observers = this._observers.filter((o) => o !== observer);
    }
    getFiberRefs() {
      this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
      return this._fiberRefs;
    }
    unsafeDeleteFiberRef(fiberRef) {
      this._fiberRefs = delete_(this._fiberRefs, fiberRef);
    }
    getFiberRef(fiberRef) {
      if (this._fiberRefs.locals.has(fiberRef)) {
        return this._fiberRefs.locals.get(fiberRef)[0][1];
      }
      return fiberRef.initial;
    }
    setFiberRef(fiberRef, value) {
      this._fiberRefs = updateAs(this._fiberRefs, {
        fiberId: this._fiberId,
        fiberRef,
        value
      });
      this.refreshRefCache();
    }
    refreshRefCache() {
      this.currentDefaultServices = this.getFiberRef(currentServices);
      this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
      this.currentSupervisor = this.getFiberRef(currentSupervisor);
      this.currentScheduler = this.getFiberRef(currentScheduler);
      this.currentContext = this.getFiberRef(currentContext);
      this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
    }
    setFiberRefs(fiberRefs3) {
      this._fiberRefs = fiberRefs3;
      this.refreshRefCache();
    }
    addChild(child) {
      this.getChildren().add(child);
    }
    removeChild(child) {
      this.getChildren().delete(child);
    }
    transferChildren(scope) {
      const children = this._children;
      this._children = null;
      if (children !== null && children.size > 0) {
        for (const child of children) {
          if (child._exitValue === null) {
            scope.add(this.currentRuntimeFlags, child);
          }
        }
      }
    }
    drainQueueOnCurrentThread() {
      let recurse = true;
      while (recurse) {
        let evaluationSignal = EvaluationSignalContinue;
        const prev = globalThis[currentFiberURI];
        globalThis[currentFiberURI] = this;
        try {
          while (evaluationSignal === EvaluationSignalContinue) {
            evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
          }
        } finally {
          this._running = false;
          globalThis[currentFiberURI] = prev;
        }
        if (this._queue.length > 0 && !this._running) {
          this._running = true;
          if (evaluationSignal === EvaluationSignalYieldNow) {
            this.drainQueueLaterOnExecutor();
            recurse = false;
          } else {
            recurse = true;
          }
        } else {
          recurse = false;
        }
      }
    }
    drainQueueLaterOnExecutor() {
      this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
    }
    drainQueueWhileRunning(runtimeFlags2, cur0) {
      let cur = cur0;
      while (this._queue.length > 0) {
        const message = this._queue.splice(0, 1)[0];
        cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
      }
      return cur;
    }
    isInterrupted() {
      return !isEmpty5(this.getFiberRef(currentInterruptedCause));
    }
    addInterruptedCause(cause2) {
      const oldSC = this.getFiberRef(currentInterruptedCause);
      this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause2));
    }
    processNewInterruptSignal(cause2) {
      this.addInterruptedCause(cause2);
      this.sendInterruptSignalToAllChildren();
    }
    sendInterruptSignalToAllChildren() {
      if (this._children === null || this._children.size === 0) {
        return false;
      }
      let told = false;
      for (const child of this._children) {
        child.tell(interruptSignal(interrupt(this.id())));
        told = true;
      }
      return told;
    }
    interruptAllChildren() {
      if (this.sendInterruptSignalToAllChildren()) {
        const it = this._children.values();
        this._children = null;
        let isDone4 = false;
        const body = () => {
          const next = it.next();
          if (!next.done) {
            return asVoid(next.value.await);
          } else {
            return sync(() => {
              isDone4 = true;
            });
          }
        };
        return whileLoop({
          while: () => !isDone4,
          body,
          step: () => {}
        });
      }
      return null;
    }
    reportExitValue(exit2) {
      if (runtimeMetrics(this.currentRuntimeFlags)) {
        const tags = this.getFiberRef(currentMetricLabels);
        const startTimeMillis = this.id().startTimeMillis;
        const endTimeMillis = Date.now();
        fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
        fiberActive.unsafeUpdate(-1, tags);
        switch (exit2._tag) {
          case OP_SUCCESS: {
            fiberSuccesses.unsafeUpdate(1, tags);
            break;
          }
          case OP_FAILURE: {
            fiberFailures.unsafeUpdate(1, tags);
            break;
          }
        }
      }
      if (exit2._tag === "Failure") {
        const level = this.getFiberRef(currentUnhandledErrorLogLevel);
        if (!isInterruptedOnly(exit2.cause) && level._tag === "Some") {
          this.log("Fiber terminated with an unhandled error", exit2.cause, level);
        }
      }
    }
    setExitValue(exit2) {
      this._exitValue = exit2;
      this.reportExitValue(exit2);
      for (let i = this._observers.length - 1;i >= 0; i--) {
        this._observers[i](exit2);
      }
      this._observers = [];
    }
    getLoggers() {
      return this.getFiberRef(currentLoggers);
    }
    log(message, cause2, overrideLogLevel) {
      const logLevel = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
      const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
      if (greaterThan3(minimumLogLevel, logLevel)) {
        return;
      }
      const spans = this.getFiberRef(currentLogSpan);
      const annotations2 = this.getFiberRef(currentLogAnnotations);
      const loggers = this.getLoggers();
      const contextMap = this.getFiberRefs();
      if (size3(loggers) > 0) {
        const clockService = get3(this.getFiberRef(currentServices), clockTag);
        const date = new Date(clockService.unsafeCurrentTimeMillis());
        withRedactableContext(contextMap, () => {
          for (const logger of loggers) {
            logger.log({
              fiberId: this.id(),
              logLevel,
              message,
              cause: cause2,
              context: contextMap,
              spans,
              annotations: annotations2,
              date
            });
          }
        });
      }
    }
    evaluateMessageWhileSuspended(message) {
      switch (message._tag) {
        case OP_YIELD_NOW: {
          return EvaluationSignalYieldNow;
        }
        case OP_INTERRUPT_SIGNAL: {
          this.processNewInterruptSignal(message.cause);
          if (this._asyncInterruptor !== null) {
            this._asyncInterruptor(exitFailCause(message.cause));
            this._asyncInterruptor = null;
          }
          return EvaluationSignalContinue;
        }
        case OP_RESUME: {
          this._asyncInterruptor = null;
          this._asyncBlockingOn = null;
          this.evaluateEffect(message.effect);
          return EvaluationSignalContinue;
        }
        case OP_STATEFUL: {
          message.onFiber(this, this._exitValue !== null ? done4 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
          return EvaluationSignalContinue;
        }
        default: {
          return absurd(message);
        }
      }
    }
    evaluateEffect(effect0) {
      this.currentSupervisor.onResume(this);
      try {
        let effect = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
        while (effect !== null) {
          const eff = effect;
          const exit2 = this.runLoop(eff);
          if (exit2 === YieldedOp) {
            const op = yieldedOpChannel.currentOp;
            yieldedOpChannel.currentOp = null;
            if (op._op === OP_YIELD) {
              if (cooperativeYielding(this.currentRuntimeFlags)) {
                this.tell(yieldNow3());
                this.tell(resume(exitVoid));
                effect = null;
              } else {
                effect = exitVoid;
              }
            } else if (op._op === OP_ASYNC) {
              effect = null;
            }
          } else {
            this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
            const interruption2 = this.interruptAllChildren();
            if (interruption2 !== null) {
              effect = flatMap8(interruption2, () => exit2);
            } else {
              if (this._queue.length === 0) {
                this.setExitValue(exit2);
              } else {
                this.tell(resume(exit2));
              }
              effect = null;
            }
          }
        }
      } finally {
        this.currentSupervisor.onSuspend(this);
      }
    }
    start(effect) {
      if (!this._running) {
        this._running = true;
        const prev = globalThis[currentFiberURI];
        globalThis[currentFiberURI] = this;
        try {
          this.evaluateEffect(effect);
        } finally {
          this._running = false;
          globalThis[currentFiberURI] = prev;
          if (this._queue.length > 0) {
            this.drainQueueLaterOnExecutor();
          }
        }
      } else {
        this.tell(resume(effect));
      }
    }
    startFork(effect) {
      this.tell(resume(effect));
    }
    patchRuntimeFlags(oldRuntimeFlags, patch9) {
      const newRuntimeFlags = patch4(oldRuntimeFlags, patch9);
      globalThis[currentFiberURI] = this;
      this.currentRuntimeFlags = newRuntimeFlags;
      return newRuntimeFlags;
    }
    initiateAsync(runtimeFlags2, asyncRegister) {
      let alreadyCalled = false;
      const callback = (effect) => {
        if (!alreadyCalled) {
          alreadyCalled = true;
          this.tell(resume(effect));
        }
      };
      if (interruptible(runtimeFlags2)) {
        this._asyncInterruptor = callback;
      }
      try {
        asyncRegister(callback);
      } catch (e) {
        callback(failCause(die(e)));
      }
    }
    pushStack(cont) {
      this._stack.push(cont);
      if (cont._op === "OnStep") {
        this._steps.push({
          refs: this.getFiberRefs(),
          flags: this.currentRuntimeFlags
        });
      }
    }
    popStack() {
      const item = this._stack.pop();
      if (item) {
        if (item._op === "OnStep") {
          this._steps.pop();
        }
        return item;
      }
      return;
    }
    getNextSuccessCont() {
      let frame = this.popStack();
      while (frame) {
        if (frame._op !== OP_ON_FAILURE) {
          return frame;
        }
        frame = this.popStack();
      }
    }
    getNextFailCont() {
      let frame = this.popStack();
      while (frame) {
        if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
          return frame;
        }
        frame = this.popStack();
      }
    }
    [OP_TAG](op) {
      return sync(() => unsafeGet3(this.currentContext, op));
    }
    ["Left"](op) {
      return fail2(op.left);
    }
    ["None"](_) {
      return fail2(new NoSuchElementException);
    }
    ["Right"](op) {
      return exitSucceed(op.right);
    }
    ["Some"](op) {
      return exitSucceed(op.value);
    }
    ["Micro"](op) {
      return unsafeAsync((microResume) => {
        let resume2 = microResume;
        const fiber = runFork(provideContext2(op, this.currentContext));
        fiber.addObserver((exit2) => {
          if (exit2._tag === "Success") {
            return resume2(exitSucceed(exit2.value));
          }
          switch (exit2.cause._tag) {
            case "Interrupt": {
              return resume2(exitFailCause(interrupt(none4)));
            }
            case "Fail": {
              return resume2(fail2(exit2.cause.error));
            }
            case "Die": {
              return resume2(die2(exit2.cause.defect));
            }
          }
        });
        return unsafeAsync((abortResume) => {
          resume2 = (_) => {
            abortResume(void_);
          };
          fiber.unsafeInterrupt();
        });
      });
    }
    [OP_SYNC](op) {
      const value = internalCall(() => op.effect_instruction_i0());
      const cont = this.getNextSuccessCont();
      if (cont !== undefined) {
        if (!(cont._op in contOpSuccess)) {
          absurd(cont);
        }
        return contOpSuccess[cont._op](this, cont, value);
      } else {
        yieldedOpChannel.currentOp = exitSucceed(value);
        return YieldedOp;
      }
    }
    [OP_SUCCESS](op) {
      const oldCur = op;
      const cont = this.getNextSuccessCont();
      if (cont !== undefined) {
        if (!(cont._op in contOpSuccess)) {
          absurd(cont);
        }
        return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
      } else {
        yieldedOpChannel.currentOp = oldCur;
        return YieldedOp;
      }
    }
    [OP_FAILURE](op) {
      const cause2 = op.effect_instruction_i0;
      const cont = this.getNextFailCont();
      if (cont !== undefined) {
        switch (cont._op) {
          case OP_ON_FAILURE:
          case OP_ON_SUCCESS_AND_FAILURE: {
            if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
              return internalCall(() => cont.effect_instruction_i1(cause2));
            } else {
              return exitFailCause(stripFailures(cause2));
            }
          }
          case "OnStep": {
            if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
              return exitSucceed(exitFailCause(cause2));
            } else {
              return exitFailCause(stripFailures(cause2));
            }
          }
          case OP_REVERT_FLAGS: {
            this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
            if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
              return exitFailCause(sequential(cause2, this.getInterruptedCause()));
            } else {
              return exitFailCause(cause2);
            }
          }
          default: {
            absurd(cont);
          }
        }
      } else {
        yieldedOpChannel.currentOp = exitFailCause(cause2);
        return YieldedOp;
      }
    }
    [OP_WITH_RUNTIME](op) {
      return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
    }
    ["Blocked"](op) {
      const refs = this.getFiberRefs();
      const flags = this.currentRuntimeFlags;
      if (this._steps.length > 0) {
        const frames = [];
        const snap = this._steps[this._steps.length - 1];
        let frame = this.popStack();
        while (frame && frame._op !== "OnStep") {
          frames.push(frame);
          frame = this.popStack();
        }
        this.setFiberRefs(snap.refs);
        this.currentRuntimeFlags = snap.flags;
        const patchRefs = diff6(snap.refs, refs);
        const patchFlags = diff4(snap.flags, flags);
        return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
          while (frames.length > 0) {
            newFiber.pushStack(frames.pop());
          }
          newFiber.setFiberRefs(patch7(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
          newFiber.currentRuntimeFlags = patch4(patchFlags)(newFiber.currentRuntimeFlags);
          return op.effect_instruction_i1;
        })));
      }
      return uninterruptibleMask((restore) => flatMap8(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
    }
    ["RunBlocked"](op) {
      return runBlockedRequests(op.effect_instruction_i0);
    }
    [OP_UPDATE_RUNTIME_FLAGS](op) {
      const updateFlags = op.effect_instruction_i0;
      const oldRuntimeFlags = this.currentRuntimeFlags;
      const newRuntimeFlags = patch4(oldRuntimeFlags, updateFlags);
      if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
        return exitFailCause(this.getInterruptedCause());
      } else {
        this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
        if (op.effect_instruction_i1) {
          const revertFlags = diff4(newRuntimeFlags, oldRuntimeFlags);
          this.pushStack(new RevertFlags(revertFlags, op));
          return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
        } else {
          return exitVoid;
        }
      }
    }
    [OP_ON_SUCCESS](op) {
      this.pushStack(op);
      return op.effect_instruction_i0;
    }
    ["OnStep"](op) {
      this.pushStack(op);
      return op.effect_instruction_i0;
    }
    [OP_ON_FAILURE](op) {
      this.pushStack(op);
      return op.effect_instruction_i0;
    }
    [OP_ON_SUCCESS_AND_FAILURE](op) {
      this.pushStack(op);
      return op.effect_instruction_i0;
    }
    [OP_ASYNC](op) {
      this._asyncBlockingOn = op.effect_instruction_i1;
      this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
      yieldedOpChannel.currentOp = op;
      return YieldedOp;
    }
    [OP_YIELD](op) {
      this._isYielding = false;
      yieldedOpChannel.currentOp = op;
      return YieldedOp;
    }
    [OP_WHILE](op) {
      const check = op.effect_instruction_i0;
      const body = op.effect_instruction_i1;
      if (check()) {
        this.pushStack(op);
        return body();
      } else {
        return exitVoid;
      }
    }
    [OP_ITERATOR](op) {
      return contOpSuccess[OP_ITERATOR](this, op, undefined);
    }
    [OP_COMMIT](op) {
      return internalCall(() => op.commit());
    }
    runLoop(effect0) {
      let cur = effect0;
      this.currentOpCount = 0;
      while (true) {
        if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
          this.currentSupervisor.onEffect(this, cur);
        }
        if (this._queue.length > 0) {
          cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
        }
        if (!this._isYielding) {
          this.currentOpCount += 1;
          const shouldYield = this.currentScheduler.shouldYield(this);
          if (shouldYield !== false) {
            this._isYielding = true;
            this.currentOpCount = 0;
            const oldCur = cur;
            cur = flatMap8(yieldNow({
              priority: shouldYield
            }), () => oldCur);
          }
        }
        try {
          cur = this.currentTracer.context(() => {
            if (_version !== cur[EffectTypeId2]._V) {
              const level = this.getFiberRef(currentVersionMismatchErrorLogLevel);
              if (level._tag === "Some") {
                const effectVersion = cur[EffectTypeId2]._V;
                this.log(`Executing an Effect versioned ${effectVersion} with a Runtime of version ${getCurrentVersion()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`, empty16, level);
              }
            }
            return this[cur._op](cur);
          }, this);
          if (cur === YieldedOp) {
            const op = yieldedOpChannel.currentOp;
            if (op._op === OP_YIELD || op._op === OP_ASYNC) {
              return YieldedOp;
            }
            yieldedOpChannel.currentOp = null;
            return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
          }
        } catch (e) {
          if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
            cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
          } else if (isInterruptedException(e)) {
            cur = exitFailCause(sequential(die(e), interrupt(none4)));
          } else {
            cur = die2(e);
          }
        }
      }
    }
    run = () => {
      this.drainQueueOnCurrentThread();
    };
  }
  var currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
  var loggerWithConsoleLog = (self) => makeLogger((opts) => {
    const services = getOrDefault2(opts.context, currentServices);
    get3(services, consoleTag).unsafe.log(self.log(opts));
  });
  var defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
  var tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
    annotations: annotations2,
    cause: cause2,
    context: context2,
    fiberId: fiberId2,
    logLevel,
    message
  }) => {
    const span2 = getOption2(getOrDefault(context2, currentContext), spanTag);
    if (span2._tag === "None" || span2.value._tag === "ExternalSpan") {
      return;
    }
    const clockService = unsafeGet3(getOrDefault(context2, currentServices), clockTag);
    const attributes = {};
    for (const [key, value] of annotations2) {
      attributes[key] = value;
    }
    attributes["effect.fiberId"] = threadName2(fiberId2);
    attributes["effect.logLevel"] = logLevel.label;
    if (cause2 !== null && cause2._tag !== "Empty") {
      attributes["effect.cause"] = pretty(cause2, {
        renderErrorCause: true
      });
    }
    span2.value.event(toStringUnknown(Array.isArray(message) && message.length === 1 ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
  }));
  var currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make10(defaultLogger, tracerLogger)));
  var annotateLogsScoped = function() {
    if (typeof arguments[0] === "string") {
      return fiberRefLocallyScopedWith(currentLogAnnotations, set3(arguments[0], arguments[1]));
    }
    const entries2 = Object.entries(arguments[0]);
    return fiberRefLocallyScopedWith(currentLogAnnotations, mutate3((annotations2) => {
      for (let i = 0;i < entries2.length; i++) {
        const [key, value] = entries2[i];
        set3(annotations2, key, value);
      }
      return annotations2;
    }));
  };
  var whenLogLevel = /* @__PURE__ */ dual(2, (effect, level) => {
    const requiredLogLevel = typeof level === "string" ? fromLiteral(level) : level;
    return withFiberRuntime((fiberState) => {
      const minimumLogLevel = fiberState.getFiberRef(currentMinimumLogLevel);
      if (greaterThan3(minimumLogLevel, requiredLogLevel)) {
        return succeed(none2());
      }
      return map10(effect, some2);
    });
  });
  var acquireRelease = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => uninterruptible(tap(acquire, (a) => addFinalizer((exit2) => release(a, exit2)))));
  var acquireReleaseInterruptible = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => ensuring(acquire, addFinalizer((exit2) => release(exit2))));
  var addFinalizer = (finalizer) => withFiberRuntime((runtime2) => {
    const acquireRefs = runtime2.getFiberRefs();
    const acquireFlags = disable2(runtime2.currentRuntimeFlags, Interruption);
    return flatMap8(scope, (scope) => scopeAddFinalizerExit(scope, (exit2) => withFiberRuntime((runtimeFinalizer) => {
      const preRefs = runtimeFinalizer.getFiberRefs();
      const preFlags = runtimeFinalizer.currentRuntimeFlags;
      const patchRefs = diff6(preRefs, acquireRefs);
      const patchFlags = diff4(preFlags, acquireFlags);
      const inverseRefs = diff6(acquireRefs, preRefs);
      runtimeFinalizer.setFiberRefs(patch7(patchRefs, runtimeFinalizer.id(), acquireRefs));
      return ensuring(withRuntimeFlags(finalizer(exit2), patchFlags), sync(() => {
        runtimeFinalizer.setFiberRefs(patch7(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
      }));
    })));
  });
  var daemonChildren = (self) => {
    const forkScope = fiberRefLocally(currentForkScopeOverride, some2(globalScope));
    return forkScope(self);
  };
  var _existsParFound = /* @__PURE__ */ Symbol.for("effect/Effect/existsPar/found");
  var exists2 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => matchSimple(options?.concurrency, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => matchEffect(forEach5(elements, (a, i) => if_(predicate(a, i), {
    onTrue: () => fail2(_existsParFound),
    onFalse: () => void_
  }), options), {
    onFailure: (e) => e === _existsParFound ? succeed(true) : fail2(e),
    onSuccess: () => succeed(false)
  })));
  var existsLoop = (iterator, index, f) => {
    const next = iterator.next();
    if (next.done) {
      return succeed(false);
    }
    return flatMap8(f(next.value, index), (b) => b ? succeed(b) : existsLoop(iterator, index + 1, f));
  };
  var filter5 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => {
    const predicate_ = options?.negate ? (a, i) => map10(predicate(a, i), not) : predicate;
    return matchSimple(options?.concurrency, () => suspend(() => fromIterable(elements).reduceRight((effect, a, i) => zipWith3(effect, suspend(() => predicate_(a, i)), (list, b) => b ? [a, ...list] : list), sync(() => new Array))), () => map10(forEach5(elements, (a, i) => map10(predicate_(a, i), (b) => b ? some2(a) : none2()), options), getSomes));
  });
  var allResolveInput = (input) => {
    if (Array.isArray(input) || isIterable(input)) {
      return [input, none2()];
    }
    const keys3 = Object.keys(input);
    const size5 = keys3.length;
    return [keys3.map((k) => input[k]), some2((values3) => {
      const res = {};
      for (let i = 0;i < size5; i++) {
        res[keys3[i]] = values3[i];
      }
      return res;
    })];
  };
  var allValidate = (effects, reconcile, options) => {
    const eitherEffects = [];
    for (const effect of effects) {
      eitherEffects.push(either2(effect));
    }
    return flatMap8(forEach5(eitherEffects, identity, {
      concurrency: options?.concurrency,
      batching: options?.batching,
      concurrentFinalizers: options?.concurrentFinalizers
    }), (eithers) => {
      const none9 = none2();
      const size5 = eithers.length;
      const errors = new Array(size5);
      const successes = new Array(size5);
      let errored = false;
      for (let i = 0;i < size5; i++) {
        const either3 = eithers[i];
        if (either3._tag === "Left") {
          errors[i] = some2(either3.left);
          errored = true;
        } else {
          successes[i] = either3.right;
          errors[i] = none9;
        }
      }
      if (errored) {
        return reconcile._tag === "Some" ? fail2(reconcile.value(errors)) : fail2(errors);
      } else if (options?.discard) {
        return void_;
      }
      return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
    });
  };
  var allEither = (effects, reconcile, options) => {
    const eitherEffects = [];
    for (const effect of effects) {
      eitherEffects.push(either2(effect));
    }
    if (options?.discard) {
      return forEach5(eitherEffects, identity, {
        concurrency: options?.concurrency,
        batching: options?.batching,
        discard: true,
        concurrentFinalizers: options?.concurrentFinalizers
      });
    }
    return map10(forEach5(eitherEffects, identity, {
      concurrency: options?.concurrency,
      batching: options?.batching,
      concurrentFinalizers: options?.concurrentFinalizers
    }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
  };
  var all3 = (arg, options) => {
    const [effects, reconcile] = allResolveInput(arg);
    if (options?.mode === "validate") {
      return allValidate(effects, reconcile, options);
    } else if (options?.mode === "either") {
      return allEither(effects, reconcile, options);
    }
    return options?.discard !== true && reconcile._tag === "Some" ? map10(forEach5(effects, identity, options), reconcile.value) : forEach5(effects, identity, options);
  };
  var allWith = (options) => (arg) => all3(arg, options);
  var allSuccesses = (elements, options) => map10(all3(fromIterable(elements).map(exit), options), filterMap((exit2) => exitIsSuccess(exit2) ? some2(exit2.effect_instruction_i0) : none2()));
  var replicate = /* @__PURE__ */ dual(2, (self, n) => Array.from({
    length: n
  }, () => self));
  var replicateEffect = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self, n, options) => all3(replicate(self, n), options));
  var forEach5 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (self, f, options) => withFiberRuntime((r) => {
    const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
    if (options?.discard) {
      return match9(options.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
    }
    return match9(options?.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachParUnbounded(self, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachParN(self, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
  }));
  var forEachParUnbounded = (self, f, batching) => suspend(() => {
    const as2 = fromIterable(self);
    const array3 = new Array(as2.length);
    const fn = (a, i) => flatMap8(f(a, i), (b) => sync(() => array3[i] = b));
    return zipRight(forEachConcurrentDiscard(as2, fn, batching, false), succeed(array3));
  });
  var forEachConcurrentDiscard = (self, f, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
    let todos = Array.from(self).reverse();
    let target = todos.length;
    if (target === 0) {
      return void_;
    }
    let counter6 = 0;
    let interrupted = false;
    const fibersCount = n ? Math.min(todos.length, n) : todos.length;
    const fibers = new Set;
    const results = new Array;
    const interruptAll = () => fibers.forEach((fiber) => {
      fiber.currentScheduler.scheduleTask(() => {
        fiber.unsafeInterruptAsFork(parent.id());
      }, 0);
    });
    const startOrder = new Array;
    const joinOrder = new Array;
    const residual = new Array;
    const collectExits = () => {
      const exits = results.filter(({
        exit: exit2
      }) => exit2._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
        exit: exit2
      }) => exit2);
      if (exits.length === 0) {
        exits.push(exitVoid);
      }
      return exits;
    };
    const runFiber = (eff, interruptImmediately = false) => {
      const runnable = uninterruptible(graft(eff));
      const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
      parent.currentScheduler.scheduleTask(() => {
        if (interruptImmediately) {
          fiber.unsafeInterruptAsFork(parent.id());
        }
        fiber.resume(runnable);
      }, 0);
      return fiber;
    };
    const onInterruptSignal = () => {
      if (!processAll) {
        target -= todos.length;
        todos = [];
      }
      interrupted = true;
      interruptAll();
    };
    const stepOrExit = batching ? step2 : exit;
    const processingFiber = runFiber(async_((resume2) => {
      const pushResult = (res, index) => {
        if (res._op === "Blocked") {
          residual.push(res);
        } else {
          results.push({
            index,
            exit: res
          });
          if (res._op === "Failure" && !interrupted) {
            onInterruptSignal();
          }
        }
      };
      const next = () => {
        if (todos.length > 0) {
          const a = todos.pop();
          let index = counter6++;
          const returnNextElement = () => {
            const a2 = todos.pop();
            index = counter6++;
            return flatMap8(yieldNow(), () => flatMap8(stepOrExit(restore(f(a2, index))), onRes));
          };
          const onRes = (res) => {
            if (todos.length > 0) {
              pushResult(res, index);
              if (todos.length > 0) {
                return returnNextElement();
              }
            }
            return succeed(res);
          };
          const todo = flatMap8(stepOrExit(restore(f(a, index))), onRes);
          const fiber = runFiber(todo);
          startOrder.push(fiber);
          fibers.add(fiber);
          if (interrupted) {
            fiber.currentScheduler.scheduleTask(() => {
              fiber.unsafeInterruptAsFork(parent.id());
            }, 0);
          }
          fiber.addObserver((wrapped) => {
            let exit2;
            if (wrapped._op === "Failure") {
              exit2 = wrapped;
            } else {
              exit2 = wrapped.effect_instruction_i0;
            }
            joinOrder.push(fiber);
            fibers.delete(fiber);
            pushResult(exit2, index);
            if (results.length === target) {
              resume2(succeed(getOrElse(exitCollectAll(collectExits(), {
                parallel: true
              }), () => exitVoid)));
            } else if (residual.length + results.length === target) {
              const exits = collectExits();
              const requests = residual.map((blocked2) => blocked2.effect_instruction_i0).reduce(par);
              resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse(exitCollectAll(exits, {
                parallel: true
              }), () => exitVoid), ...residual.map((blocked2) => blocked2.effect_instruction_i1)], (i) => i, batching, true, n))));
            } else {
              next();
            }
          });
        }
      };
      for (let i = 0;i < fibersCount; i++) {
        next();
      }
    }));
    return asVoid(onExit(flatten6(restore(join2(processingFiber))), exitMatch({
      onFailure: (cause2) => {
        onInterruptSignal();
        const target2 = residual.length + 1;
        const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
        const toPop = Array.from(residual);
        return async_((cb) => {
          const exits = [];
          let count = 0;
          let index = 0;
          const check = (index2, hitNext) => (exit2) => {
            exits[index2] = exit2;
            count++;
            if (count === target2) {
              cb(exitSucceed(exitFailCause(cause2)));
            }
            if (toPop.length > 0 && hitNext) {
              next();
            }
          };
          const next = () => {
            runFiber(toPop.pop(), true).addObserver(check(index, true));
            index++;
          };
          processingFiber.addObserver(check(index, false));
          index++;
          for (let i = 0;i < concurrency; i++) {
            next();
          }
        });
      },
      onSuccess: () => forEachSequential(joinOrder, (f2) => f2.inheritAll)
    })));
  })));
  var forEachParN = (self, n, f, batching) => suspend(() => {
    const as2 = fromIterable(self);
    const array3 = new Array(as2.length);
    const fn = (a, i) => map10(f(a, i), (b) => array3[i] = b);
    return zipRight(forEachConcurrentDiscard(as2, fn, batching, false, n), succeed(array3));
  });
  var fork = (self) => withFiberRuntime((state, status) => succeed(unsafeFork(self, state, status.runtimeFlags)));
  var forkDaemon = (self) => forkWithScopeOverride(self, globalScope);
  var forkWithErrorHandler = /* @__PURE__ */ dual(2, (self, handler) => fork(onError(self, (cause2) => {
    const either3 = failureOrCause(cause2);
    switch (either3._tag) {
      case "Left":
        return handler(either3.left);
      case "Right":
        return failCause(either3.right);
    }
  })));
  var unsafeFork = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
    const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
    childFiber.resume(effect);
    return childFiber;
  };
  var unsafeForkUnstarted = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
    const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
    return childFiber;
  };
  var unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
    const childId = unsafeMake3();
    const parentFiberRefs = parentFiber.getFiberRefs();
    const childFiberRefs = forkAs(parentFiberRefs, childId);
    const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
    const childContext = getOrDefault(childFiberRefs, currentContext);
    const supervisor = childFiber.currentSupervisor;
    supervisor.onStart(childContext, effect, some2(parentFiber), childFiber);
    childFiber.addObserver((exit2) => supervisor.onEnd(exit2, childFiber));
    const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse(() => parentFiber.scope()));
    parentScope.add(parentRuntimeFlags, childFiber);
    return childFiber;
  };
  var forkWithScopeOverride = (self, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
  var mergeAll3 = /* @__PURE__ */ dual((args2) => isFunction2(args2[2]), (elements, zero2, f, options) => matchSimple(options?.concurrency, () => fromIterable(elements).reduce((acc, a, i) => zipWith3(acc, a, (acc2, a2) => f(acc2, a2, i)), succeed(zero2)), () => flatMap8(make28(zero2), (acc) => flatMap8(forEach5(elements, (effect, i) => flatMap8(effect, (a) => update3(acc, (b) => f(b, a, i))), options), () => get12(acc)))));
  var partition3 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => pipe(forEach5(elements, (a, i) => either2(f(a, i)), options), map10((chunk2) => partitionMap2(chunk2, identity))));
  var validateAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => flatMap8(partition3(elements, f, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), ([es, bs]) => isNonEmptyArray2(es) ? fail2(es) : options?.discard ? void_ : succeed(bs)));
  var raceAll = (all4) => withFiberRuntime((state, status) => async_((resume2) => {
    const fibers = new Set;
    let winner;
    let failures2 = empty16;
    const interruptAll = () => {
      for (const fiber of fibers) {
        fiber.unsafeInterruptAsFork(state.id());
      }
    };
    let latch = false;
    let empty24 = true;
    for (const self of all4) {
      empty24 = false;
      const fiber = unsafeFork(interruptible2(self), state, status.runtimeFlags);
      fibers.add(fiber);
      fiber.addObserver((exit2) => {
        fibers.delete(fiber);
        if (!winner) {
          if (exit2._tag === "Success") {
            latch = true;
            winner = fiber;
            failures2 = empty16;
            interruptAll();
          } else {
            failures2 = parallel(exit2.cause, failures2);
          }
        }
        if (latch && fibers.size === 0) {
          resume2(winner ? zipRight(inheritAll(winner), winner.unsafePoll()) : failCause(failures2));
        }
      });
      if (winner)
        break;
    }
    if (empty24) {
      return resume2(dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`)));
    }
    latch = true;
    return interruptAllAs(fibers, state.id());
  }));
  var reduceEffect = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, zero2, f, options) => matchSimple(options?.concurrency, () => fromIterable(elements).reduce((acc, a, i) => zipWith3(acc, a, (acc2, a2) => f(acc2, a2, i)), zero2), () => suspend(() => pipe(mergeAll3([zero2, ...elements], none2(), (acc, elem, i) => {
    switch (acc._tag) {
      case "None": {
        return some2(elem);
      }
      case "Some": {
        return some2(f(acc.value, elem, i));
      }
    }
  }, options), map10((option2) => {
    switch (option2._tag) {
      case "None": {
        throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
      }
      case "Some": {
        return option2.value;
      }
    }
  })))));
  var parallelFinalizers = (self) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
    onNone: () => self,
    onSome: (scope) => {
      switch (scope.strategy._tag) {
        case "Parallel":
          return self;
        case "Sequential":
        case "ParallelN":
          return flatMap8(scopeFork(scope, parallel3), (inner) => scopeExtend(self, inner));
      }
    }
  }));
  var parallelNFinalizers = (parallelism) => (self) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
    onNone: () => self,
    onSome: (scope) => {
      if (scope.strategy._tag === "ParallelN" && scope.strategy.parallelism === parallelism) {
        return self;
      }
      return flatMap8(scopeFork(scope, parallelN2(parallelism)), (inner) => scopeExtend(self, inner));
    }
  }));
  var finalizersMask = (strategy) => (self) => finalizersMaskInternal(strategy, true)(self);
  var finalizersMaskInternal = (strategy, concurrentFinalizers) => (self) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
    onNone: () => self(identity),
    onSome: (scope) => {
      if (concurrentFinalizers === true) {
        const patch9 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
        switch (scope.strategy._tag) {
          case "Parallel":
            return patch9(self(parallelFinalizers));
          case "Sequential":
            return patch9(self(sequentialFinalizers));
          case "ParallelN":
            return patch9(self(parallelNFinalizers(scope.strategy.parallelism)));
        }
      } else {
        return self(identity);
      }
    }
  }));
  var scopeWith = (f) => flatMap8(scopeTag, f);
  var scopedWith = (f) => flatMap8(scopeMake(), (scope) => onExit(f(scope), (exit2) => scope.close(exit2)));
  var scopedEffect = (effect) => flatMap8(scopeMake(), (scope) => scopeUse(effect, scope));
  var sequentialFinalizers = (self) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
    onNone: () => self,
    onSome: (scope) => {
      switch (scope.strategy._tag) {
        case "Sequential":
          return self;
        case "Parallel":
        case "ParallelN":
          return flatMap8(scopeFork(scope, sequential3), (inner) => scopeExtend(self, inner));
      }
    }
  }));
  var tagMetricsScoped = (key, value) => labelMetricsScoped([make29(key, value)]);
  var labelMetricsScoped = (labels) => fiberRefLocallyScopedWith(currentMetricLabels, (old) => union(old, labels));
  var using = /* @__PURE__ */ dual(2, (self, use) => scopedWith((scope) => flatMap8(scopeExtend(self, scope), use)));
  var validate = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, options) => validateWith(self, that, (a, b) => [a, b], options));
  var validateWith = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, f, options) => flatten6(zipWithOptions(exit(self), exit(that), (ea, eb) => exitZipWith(ea, eb, {
    onSuccess: f,
    onFailure: (ca, cb) => options?.concurrent ? parallel(ca, cb) : sequential(ca, cb)
  }), options)));
  var validateFirst = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => flip(forEach5(elements, (a, i) => flip(f(a, i)), options)));
  var withClockScoped = (c) => fiberRefLocallyScopedWith(currentServices, add2(clockTag, c));
  var withRandomScoped = (value) => fiberRefLocallyScopedWith(currentServices, add2(randomTag, value));
  var withConfigProviderScoped = (provider) => fiberRefLocallyScopedWith(currentServices, add2(configProviderTag, provider));
  var withEarlyRelease = (self) => scopeWith((parent) => flatMap8(scopeFork(parent, sequential2), (child) => pipe(self, scopeExtend(child), map10((value) => [fiberIdWith((fiberId2) => scopeClose(child, exitInterrupt(fiberId2))), value]))));
  var zipOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, options) => zipWithOptions(self, that, (a, b) => [a, b], options));
  var zipLeftOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, options) => {
    if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
      return zipLeft(self, that);
    }
    return zipWithOptions(self, that, (a, _) => a, options);
  });
  var zipRightOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, options) => {
    if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
      return zipRight(self, that);
    }
    return zipWithOptions(self, that, (_, b) => b, options);
  });
  var zipWithOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self, that, f, options) => map10(all3([self, that], {
    concurrency: options?.concurrent ? 2 : 1,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), ([a, a2]) => f(a, a2)));
  var withRuntimeFlagsScoped = (update5) => {
    if (update5 === empty14) {
      return void_;
    }
    return pipe(runtimeFlags, flatMap8((runtimeFlags2) => {
      const updatedRuntimeFlags = patch4(runtimeFlags2, update5);
      const revertRuntimeFlags = diff4(updatedRuntimeFlags, runtimeFlags2);
      return pipe(updateRuntimeFlags(update5), zipRight(addFinalizer(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid);
    }), uninterruptible);
  };
  var scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
  var scope = scopeTag;
  var scopeUnsafeAddFinalizer = (scope2, fin) => {
    if (scope2.state._tag === "Open") {
      scope2.state.finalizers.set({}, fin);
    }
  };
  var ScopeImplProto = {
    [ScopeTypeId]: ScopeTypeId,
    [CloseableScopeTypeId]: CloseableScopeTypeId,
    pipe() {
      return pipeArguments(this, arguments);
    },
    fork(strategy) {
      return sync(() => {
        const newScope = scopeUnsafeMake(strategy);
        if (this.state._tag === "Closed") {
          newScope.state = this.state;
          return newScope;
        }
        const key = {};
        const fin = (exit2) => newScope.close(exit2);
        this.state.finalizers.set(key, fin);
        scopeUnsafeAddFinalizer(newScope, (_) => sync(() => {
          if (this.state._tag === "Open") {
            this.state.finalizers.delete(key);
          }
        }));
        return newScope;
      });
    },
    close(exit2) {
      return suspend(() => {
        if (this.state._tag === "Closed") {
          return void_;
        }
        const finalizers = Array.from(this.state.finalizers.values()).reverse();
        this.state = {
          _tag: "Closed",
          exit: exit2
        };
        if (finalizers.length === 0) {
          return void_;
        }
        return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit(fin(exit2))), flatMap8((results) => pipe(exitCollectAll(results), map2(exitAsVoid), getOrElse(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit(fin(exit2)), false), flatMap8((results) => pipe(exitCollectAll(results, {
          parallel: true
        }), map2(exitAsVoid), getOrElse(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit(fin(exit2)), false), flatMap8((results) => pipe(exitCollectAll(results, {
          parallel: true
        }), map2(exitAsVoid), getOrElse(() => exitVoid))));
      });
    },
    addFinalizer(fin) {
      return suspend(() => {
        if (this.state._tag === "Closed") {
          return fin(this.state.exit);
        }
        this.state.finalizers.set({}, fin);
        return void_;
      });
    }
  };
  var scopeUnsafeMake = (strategy = sequential2) => {
    const scope2 = Object.create(ScopeImplProto);
    scope2.strategy = strategy;
    scope2.state = {
      _tag: "Open",
      finalizers: new Map
    };
    return scope2;
  };
  var scopeMake = (strategy = sequential2) => sync(() => scopeUnsafeMake(strategy));
  var scopeExtend = /* @__PURE__ */ dual(2, (effect, scope2) => mapInputContext(effect, merge3(make5(scopeTag, scope2))));
  var scopeUse = /* @__PURE__ */ dual(2, (effect, scope2) => pipe(effect, scopeExtend(scope2), onExit((exit2) => scope2.close(exit2))));
  var fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: empty23
  });
  var fiberRefLocallyScoped = /* @__PURE__ */ dual(2, (self, value) => asVoid(acquireRelease(flatMap8(fiberRefGet(self), (oldValue) => as(fiberRefSet(self, value), oldValue)), (oldValue) => fiberRefSet(self, oldValue))));
  var fiberRefLocallyScopedWith = /* @__PURE__ */ dual(2, (self, f) => fiberRefGetWith(self, (a) => fiberRefLocallyScoped(self, f(a))));
  var currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none5);
  var currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none8);
  var fiberAwaitAll = (fibers) => forEach5(fibers, _await2);
  var fiberAll = (fibers) => {
    const _fiberAll = {
      ...CommitPrototype2,
      commit() {
        return join2(this);
      },
      [FiberTypeId]: fiberVariance2,
      id: () => fromIterable(fibers).reduce((id, fiber) => combine3(id, fiber.id()), none4),
      await: exit(forEachParUnbounded(fibers, (fiber) => flatten6(fiber.await), false)),
      children: map10(forEachParUnbounded(fibers, (fiber) => fiber.children, false), flatten),
      inheritAll: forEachSequentialDiscard(fibers, (fiber) => fiber.inheritAll),
      poll: map10(forEachSequential(fibers, (fiber) => fiber.poll), reduceRight(some2(exitSucceed(new Array)), (optionB, optionA) => {
        switch (optionA._tag) {
          case "None": {
            return none2();
          }
          case "Some": {
            switch (optionB._tag) {
              case "None": {
                return none2();
              }
              case "Some": {
                return some2(exitZipWith(optionA.value, optionB.value, {
                  onSuccess: (a, chunk2) => [a, ...chunk2],
                  onFailure: parallel
                }));
              }
            }
          }
        }
      })),
      interruptAsFork: (fiberId2) => forEachSequentialDiscard(fibers, (fiber) => fiber.interruptAsFork(fiberId2))
    };
    return _fiberAll;
  };
  var raceWith = /* @__PURE__ */ dual(3, (self, other, options) => raceFibersWith(self, other, {
    onSelfWin: (winner, loser) => flatMap8(winner.await, (exit2) => {
      switch (exit2._tag) {
        case OP_SUCCESS: {
          return flatMap8(winner.inheritAll, () => options.onSelfDone(exit2, loser));
        }
        case OP_FAILURE: {
          return options.onSelfDone(exit2, loser);
        }
      }
    }),
    onOtherWin: (winner, loser) => flatMap8(winner.await, (exit2) => {
      switch (exit2._tag) {
        case OP_SUCCESS: {
          return flatMap8(winner.inheritAll, () => options.onOtherDone(exit2, loser));
        }
        case OP_FAILURE: {
          return options.onOtherDone(exit2, loser);
        }
      }
    })
  }));
  var disconnect = (self) => uninterruptibleMask((restore) => fiberIdWith((fiberId2) => flatMap8(forkDaemon(restore(self)), (fiber) => pipe(restore(join2(fiber)), onInterrupt(() => pipe(fiber, interruptAsFork(fiberId2)))))));
  var race = /* @__PURE__ */ dual(2, (self, that) => fiberIdWith((parentFiberId) => raceWith(self, that, {
    onSelfDone: (exit2, right3) => exitMatchEffect(exit2, {
      onFailure: (cause2) => pipe(join2(right3), mapErrorCause((cause22) => parallel(cause2, cause22))),
      onSuccess: (value) => pipe(right3, interruptAsFiber(parentFiberId), as(value))
    }),
    onOtherDone: (exit2, left3) => exitMatchEffect(exit2, {
      onFailure: (cause2) => pipe(join2(left3), mapErrorCause((cause22) => parallel(cause22, cause2))),
      onSuccess: (value) => pipe(left3, interruptAsFiber(parentFiberId), as(value))
    })
  })));
  var raceFibersWith = /* @__PURE__ */ dual(3, (self, other, options) => withFiberRuntime((parentFiber, parentStatus) => {
    const parentRuntimeFlags = parentStatus.runtimeFlags;
    const raceIndicator = make11(true);
    const leftFiber = unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags, options.selfScope);
    const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
    return async_((cb) => {
      leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
      rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
      leftFiber.startFork(self);
      rightFiber.startFork(other);
    }, combine3(leftFiber.id(), rightFiber.id()));
  }));
  var completeRace = (winner, loser, cont, ab, cb) => {
    if (compareAndSet(true, false)(ab)) {
      cb(cont(winner, loser));
    }
  };
  var ensuring = /* @__PURE__ */ dual(2, (self, finalizer) => uninterruptibleMask((restore) => matchCauseEffect(restore(self), {
    onFailure: (cause1) => matchCauseEffect(finalizer, {
      onFailure: (cause2) => failCause(sequential(cause1, cause2)),
      onSuccess: () => failCause(cause1)
    }),
    onSuccess: (a) => as(finalizer, a)
  })));
  var invokeWithInterrupt = (self, entries2, onInterrupt2) => fiberIdWith((id) => flatMap8(flatMap8(forkDaemon(interruptible2(self)), (processing) => async_((cb) => {
    const counts = entries2.map((_) => _.listeners.count);
    const checkDone = () => {
      if (counts.every((count) => count === 0)) {
        if (entries2.every((_) => {
          if (_.result.state.current._tag === "Pending") {
            return true;
          } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted(_.result.state.current.effect.cause)) {
            return true;
          } else {
            return false;
          }
        })) {
          cleanup.forEach((f) => f());
          onInterrupt2?.();
          cb(interruptFiber(processing));
        }
      }
    };
    processing.addObserver((exit2) => {
      cleanup.forEach((f) => f());
      cb(exit2);
    });
    const cleanup = entries2.map((r, i) => {
      const observer = (count) => {
        counts[i] = count;
        checkDone();
      };
      r.listeners.addObserver(observer);
      return () => r.listeners.removeObserver(observer);
    });
    checkDone();
    return sync(() => {
      cleanup.forEach((f) => f());
    });
  })), () => suspend(() => {
    const residual = entries2.flatMap((entry) => {
      if (!entry.state.completed) {
        return [entry];
      }
      return [];
    });
    return forEachSequentialDiscard(residual, (entry) => complete(entry.request, exitInterrupt(id)));
  })));
  var makeSpanScoped = (name, options) => {
    options = addSpanStackTrace(options);
    return uninterruptible(withFiberRuntime((fiber) => {
      const scope2 = unsafeGet3(fiber.getFiberRef(currentContext), scopeTag);
      const span2 = unsafeMakeSpan(fiber, name, options);
      const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
      const clock_ = get3(fiber.getFiberRef(currentServices), clockTag);
      return as(scopeAddFinalizerExit(scope2, (exit2) => endSpan(span2, exit2, clock_, timingEnabled)), span2);
    }));
  };
  var withTracerScoped = (value) => fiberRefLocallyScopedWith(currentServices, add2(tracerTag, value));
  var withSpanScoped = function() {
    const dataFirst = typeof arguments[0] !== "string";
    const name = dataFirst ? arguments[1] : arguments[0];
    const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
    if (dataFirst) {
      const self = arguments[0];
      return flatMap8(makeSpanScoped(name, addSpanStackTrace(options)), (span2) => provideService(self, spanTag, span2));
    }
    return (self) => flatMap8(makeSpanScoped(name, addSpanStackTrace(options)), (span2) => provideService(self, spanTag, span2));
  };

  // node_modules/effect/dist/esm/internal/cache.js
  var complete2 = (key, exit2, entryStats, timeToLiveMillis) => struct({
    _tag: "Complete",
    key,
    exit: exit2,
    entryStats,
    timeToLiveMillis
  });
  var pending2 = (key, deferred) => struct({
    _tag: "Pending",
    key,
    deferred
  });
  var refreshing = (deferred, complete3) => struct({
    _tag: "Refreshing",
    deferred,
    complete: complete3
  });
  var MapKeyTypeId = /* @__PURE__ */ Symbol.for("effect/Cache/MapKey");

  class MapKeyImpl {
    current;
    [MapKeyTypeId] = MapKeyTypeId;
    previous = undefined;
    next = undefined;
    constructor(current) {
      this.current = current;
    }
    [symbol]() {
      return pipe(hash(this.current), combine(hash(this.previous)), combine(hash(this.next)), cached(this));
    }
    [symbol2](that) {
      if (this === that) {
        return true;
      }
      return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
    }
  }
  var makeMapKey = (current) => new MapKeyImpl(current);
  var isMapKey = (u) => hasProperty(u, MapKeyTypeId);

  class KeySetImpl {
    head = undefined;
    tail = undefined;
    add(key) {
      if (key !== this.tail) {
        if (this.tail === undefined) {
          this.head = key;
          this.tail = key;
        } else {
          const previous = key.previous;
          const next = key.next;
          if (next !== undefined) {
            key.next = undefined;
            if (previous !== undefined) {
              previous.next = next;
              next.previous = previous;
            } else {
              this.head = next;
              this.head.previous = undefined;
            }
          }
          this.tail.next = key;
          key.previous = this.tail;
          this.tail = key;
        }
      }
    }
    remove() {
      const key = this.head;
      if (key !== undefined) {
        const next = key.next;
        if (next !== undefined) {
          key.next = undefined;
          this.head = next;
          this.head.previous = undefined;
        } else {
          this.head = undefined;
          this.tail = undefined;
        }
      }
      return key;
    }
  }
  var makeKeySet = () => new KeySetImpl;
  var makeCacheState = (map12, keys3, accesses, updating, hits, misses) => ({
    map: map12,
    keys: keys3,
    accesses,
    updating,
    hits,
    misses
  });
  var initialCacheState = () => makeCacheState(empty17(), makeKeySet(), unbounded(), make11(false), 0, 0);
  var CacheSymbolKey = "effect/Cache";
  var CacheTypeId = /* @__PURE__ */ Symbol.for(CacheSymbolKey);
  var cacheVariance = {
    _Key: (_) => _,
    _Error: (_) => _,
    _Value: (_) => _
  };
  var ConsumerCacheSymbolKey = "effect/ConsumerCache";
  var ConsumerCacheTypeId = /* @__PURE__ */ Symbol.for(ConsumerCacheSymbolKey);
  var consumerCacheVariance = {
    _Key: (_) => _,
    _Error: (_) => _,
    _Value: (_) => _
  };
  var makeCacheStats = (options) => options;
  var makeEntryStats = (loadedMillis) => ({
    loadedMillis
  });

  class CacheImpl {
    capacity;
    context;
    fiberId;
    lookup;
    timeToLive;
    [CacheTypeId] = cacheVariance;
    [ConsumerCacheTypeId] = consumerCacheVariance;
    cacheState;
    constructor(capacity2, context2, fiberId2, lookup, timeToLive) {
      this.capacity = capacity2;
      this.context = context2;
      this.fiberId = fiberId2;
      this.lookup = lookup;
      this.timeToLive = timeToLive;
      this.cacheState = initialCacheState();
    }
    get(key) {
      return map10(this.getEither(key), merge);
    }
    get cacheStats() {
      return sync(() => makeCacheStats({
        hits: this.cacheState.hits,
        misses: this.cacheState.misses,
        size: size4(this.cacheState.map)
      }));
    }
    getOption(key) {
      return suspend(() => match2(get8(this.cacheState.map, key), {
        onNone: () => {
          const mapKey = makeMapKey(key);
          this.trackAccess(mapKey);
          this.trackMiss();
          return succeed(none2());
        },
        onSome: (value) => this.resolveMapValue(value)
      }));
    }
    getOptionComplete(key) {
      return suspend(() => match2(get8(this.cacheState.map, key), {
        onNone: () => {
          const mapKey = makeMapKey(key);
          this.trackAccess(mapKey);
          this.trackMiss();
          return succeed(none2());
        },
        onSome: (value) => this.resolveMapValue(value, true)
      }));
    }
    contains(key) {
      return sync(() => has4(this.cacheState.map, key));
    }
    entryStats(key) {
      return sync(() => {
        const option2 = get8(this.cacheState.map, key);
        if (isSome2(option2)) {
          switch (option2.value._tag) {
            case "Complete": {
              const loaded = option2.value.entryStats.loadedMillis;
              return some2(makeEntryStats(loaded));
            }
            case "Pending": {
              return none2();
            }
            case "Refreshing": {
              const loaded = option2.value.complete.entryStats.loadedMillis;
              return some2(makeEntryStats(loaded));
            }
          }
        }
        return none2();
      });
    }
    getEither(key) {
      return suspend(() => {
        const k = key;
        let mapKey = undefined;
        let deferred = undefined;
        let value = getOrUndefined(get8(this.cacheState.map, k));
        if (value === undefined) {
          deferred = unsafeMake4(this.fiberId);
          mapKey = makeMapKey(k);
          if (has4(this.cacheState.map, k)) {
            value = getOrUndefined(get8(this.cacheState.map, k));
          } else {
            set4(this.cacheState.map, k, pending2(mapKey, deferred));
          }
        }
        if (value === undefined) {
          this.trackAccess(mapKey);
          this.trackMiss();
          return map10(this.lookupValueOf(key, deferred), right2);
        } else {
          return flatMap8(this.resolveMapValue(value), match2({
            onNone: () => this.getEither(key),
            onSome: (value2) => succeed(left2(value2))
          }));
        }
      });
    }
    invalidate(key) {
      return sync(() => {
        remove5(this.cacheState.map, key);
      });
    }
    invalidateWhen(key, when2) {
      return sync(() => {
        const value = get8(this.cacheState.map, key);
        if (isSome2(value) && value.value._tag === "Complete") {
          if (value.value.exit._tag === "Success") {
            if (when2(value.value.exit.value)) {
              remove5(this.cacheState.map, key);
            }
          }
        }
      });
    }
    get invalidateAll() {
      return sync(() => {
        this.cacheState.map = empty17();
      });
    }
    refresh(key) {
      return clockWith3((clock2) => suspend(() => {
        const k = key;
        const deferred = unsafeMake4(this.fiberId);
        let value = getOrUndefined(get8(this.cacheState.map, k));
        if (value === undefined) {
          if (has4(this.cacheState.map, k)) {
            value = getOrUndefined(get8(this.cacheState.map, k));
          } else {
            set4(this.cacheState.map, k, pending2(makeMapKey(k), deferred));
          }
        }
        if (value === undefined) {
          return asVoid(this.lookupValueOf(key, deferred));
        } else {
          switch (value._tag) {
            case "Complete": {
              if (this.hasExpired(clock2, value.timeToLiveMillis)) {
                const found = getOrUndefined(get8(this.cacheState.map, k));
                if (equals(found, value)) {
                  remove5(this.cacheState.map, k);
                }
                return asVoid(this.get(key));
              }
              return pipe(this.lookupValueOf(key, deferred), when(() => {
                const current = getOrUndefined(get8(this.cacheState.map, k));
                if (equals(current, value)) {
                  const mapValue = refreshing(deferred, value);
                  set4(this.cacheState.map, k, mapValue);
                  return true;
                }
                return false;
              }), asVoid);
            }
            case "Pending": {
              return _await(value.deferred);
            }
            case "Refreshing": {
              return _await(value.deferred);
            }
          }
        }
      }));
    }
    set(key, value) {
      return clockWith3((clock2) => sync(() => {
        const now = clock2.unsafeCurrentTimeMillis();
        const k = key;
        const lookupResult = succeed3(value);
        const mapValue = complete2(makeMapKey(k), lookupResult, makeEntryStats(now), now + toMillis(decode(this.timeToLive(lookupResult))));
        set4(this.cacheState.map, k, mapValue);
      }));
    }
    get size() {
      return sync(() => {
        return size4(this.cacheState.map);
      });
    }
    get values() {
      return sync(() => {
        const values3 = [];
        for (const entry of this.cacheState.map) {
          if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
            values3.push(entry[1].exit.value);
          }
        }
        return values3;
      });
    }
    get entries() {
      return sync(() => {
        const values3 = [];
        for (const entry of this.cacheState.map) {
          if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
            values3.push([entry[0], entry[1].exit.value]);
          }
        }
        return values3;
      });
    }
    get keys() {
      return sync(() => {
        const keys3 = [];
        for (const entry of this.cacheState.map) {
          if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
            keys3.push(entry[0]);
          }
        }
        return keys3;
      });
    }
    resolveMapValue(value, ignorePending = false) {
      return clockWith3((clock2) => {
        switch (value._tag) {
          case "Complete": {
            this.trackAccess(value.key);
            if (this.hasExpired(clock2, value.timeToLiveMillis)) {
              remove5(this.cacheState.map, value.key.current);
              return succeed(none2());
            }
            this.trackHit();
            return map10(value.exit, some2);
          }
          case "Pending": {
            this.trackAccess(value.key);
            this.trackHit();
            if (ignorePending) {
              return succeed(none2());
            }
            return map10(_await(value.deferred), some2);
          }
          case "Refreshing": {
            this.trackAccess(value.complete.key);
            this.trackHit();
            if (this.hasExpired(clock2, value.complete.timeToLiveMillis)) {
              if (ignorePending) {
                return succeed(none2());
              }
              return map10(_await(value.deferred), some2);
            }
            return map10(value.complete.exit, some2);
          }
        }
      });
    }
    trackHit() {
      this.cacheState.hits = this.cacheState.hits + 1;
    }
    trackMiss() {
      this.cacheState.misses = this.cacheState.misses + 1;
    }
    trackAccess(key) {
      offer(this.cacheState.accesses, key);
      if (compareAndSet(this.cacheState.updating, false, true)) {
        let loop2 = true;
        while (loop2) {
          const key2 = poll2(this.cacheState.accesses, EmptyMutableQueue);
          if (key2 === EmptyMutableQueue) {
            loop2 = false;
          } else {
            this.cacheState.keys.add(key2);
          }
        }
        let size5 = size4(this.cacheState.map);
        loop2 = size5 > this.capacity;
        while (loop2) {
          const key2 = this.cacheState.keys.remove();
          if (key2 !== undefined) {
            if (has4(this.cacheState.map, key2.current)) {
              remove5(this.cacheState.map, key2.current);
              size5 = size5 - 1;
              loop2 = size5 > this.capacity;
            }
          } else {
            loop2 = false;
          }
        }
        set2(this.cacheState.updating, false);
      }
    }
    hasExpired(clock2, timeToLiveMillis) {
      return clock2.unsafeCurrentTimeMillis() > timeToLiveMillis;
    }
    lookupValueOf(input, deferred) {
      return clockWith3((clock2) => suspend(() => {
        const key = input;
        return pipe(this.lookup(input), provideContext(this.context), exit, flatMap8((exit2) => {
          const now = clock2.unsafeCurrentTimeMillis();
          const stats = makeEntryStats(now);
          const value = complete2(makeMapKey(key), exit2, stats, now + toMillis(decode(this.timeToLive(exit2))));
          set4(this.cacheState.map, key, value);
          return zipRight(done2(deferred, exit2), exit2);
        }), onInterrupt(() => zipRight(interrupt3(deferred), sync(() => {
          remove5(this.cacheState.map, key);
        }))));
      }));
    }
  }
  var unsafeMakeWith = (capacity2, lookup, timeToLive) => new CacheImpl(capacity2, empty3(), none3, lookup, (exit2) => decode(timeToLive(exit2)));
  // node_modules/effect/dist/esm/Cause.js
  var fail5 = fail;
  var die4 = die;
  var interrupt5 = interrupt;
  var isFailType2 = isFailType;
  var isDieType2 = isDieType;
  var isInterrupted2 = isInterrupted;
  var isInterruptedOnly2 = isInterruptedOnly;
  var interruptors2 = interruptors;
  var failureOrCause2 = failureOrCause;
  var flipCauseOption2 = flipCauseOption;
  var map12 = map9;
  var squash = causeSquash;
  var IllegalArgumentException2 = IllegalArgumentException;
  var NoSuchElementException2 = NoSuchElementException;
  var RuntimeException2 = RuntimeException;
  var isRuntimeException2 = isRuntimeException;
  var pretty2 = pretty;
  // node_modules/effect/dist/esm/Effect.js
  var exports_Effect = {};
  __export(exports_Effect, {
    zipWith: () => zipWith5,
    zipRight: () => zipRight3,
    zipLeft: () => zipLeft2,
    zip: () => zip5,
    yieldNow: () => yieldNow4,
    withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel2,
    withTracerTiming: () => withTracerTiming2,
    withTracerScoped: () => withTracerScoped2,
    withTracerEnabled: () => withTracerEnabled2,
    withTracer: () => withTracer2,
    withSpanScoped: () => withSpanScoped2,
    withSpan: () => withSpan3,
    withSchedulingPriority: () => withSchedulingPriority2,
    withScheduler: () => withScheduler2,
    withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped,
    withRuntimeFlagsPatch: () => withRuntimeFlagsPatch,
    withRequestCaching: () => withRequestCaching2,
    withRequestCache: () => withRequestCache2,
    withRequestBatching: () => withRequestBatching2,
    withRandomScoped: () => withRandomScoped2,
    withRandomFixed: () => withRandomFixed,
    withRandom: () => withRandom2,
    withParentSpan: () => withParentSpan3,
    withMetric: () => withMetric2,
    withMaxOpsBeforeYield: () => withMaxOpsBeforeYield2,
    withLogSpan: () => withLogSpan2,
    withFiberRuntime: () => withFiberRuntime2,
    withExecutionPlan: () => withExecutionPlan2,
    withEarlyRelease: () => withEarlyRelease2,
    withConsoleScoped: () => withConsoleScoped2,
    withConsole: () => withConsole2,
    withConfigProviderScoped: () => withConfigProviderScoped2,
    withConfigProvider: () => withConfigProvider2,
    withConcurrency: () => withConcurrency2,
    withClockScoped: () => withClockScoped2,
    withClock: () => withClock2,
    whileLoop: () => whileLoop2,
    whenRef: () => whenRef2,
    whenLogLevel: () => whenLogLevel2,
    whenFiberRef: () => whenFiberRef2,
    whenEffect: () => whenEffect2,
    when: () => when2,
    void: () => _void,
    validateWith: () => validateWith2,
    validateFirst: () => validateFirst2,
    validateAll: () => validateAll2,
    validate: () => validate2,
    using: () => using2,
    useSpan: () => useSpan2,
    updateService: () => updateService2,
    updateFiberRefs: () => updateFiberRefs2,
    unsandbox: () => unsandbox2,
    unsafeMakeSemaphore: () => unsafeMakeSemaphore2,
    unsafeMakeLatch: () => unsafeMakeLatch2,
    unlessEffect: () => unlessEffect2,
    unless: () => unless2,
    uninterruptibleMask: () => uninterruptibleMask3,
    uninterruptible: () => uninterruptible2,
    tryPromise: () => tryPromise2,
    tryMapPromise: () => tryMapPromise2,
    tryMap: () => tryMap2,
    try: () => try_2,
    transposeOption: () => transposeOption,
    transposeMapOption: () => transposeMapOption,
    transplant: () => transplant2,
    tracerWith: () => tracerWith4,
    tracer: () => tracer2,
    timeoutTo: () => timeoutTo2,
    timeoutOption: () => timeoutOption2,
    timeoutFailCause: () => timeoutFailCause2,
    timeoutFail: () => timeoutFail2,
    timeout: () => timeout2,
    timedWith: () => timedWith2,
    timed: () => timed2,
    tapErrorTag: () => tapErrorTag2,
    tapErrorCause: () => tapErrorCause3,
    tapError: () => tapError3,
    tapDefect: () => tapDefect2,
    tapBoth: () => tapBoth2,
    tap: () => tap3,
    takeWhile: () => takeWhile3,
    takeUntil: () => takeUntil2,
    tagMetricsScoped: () => tagMetricsScoped2,
    tagMetrics: () => tagMetrics2,
    sync: () => sync3,
    suspend: () => suspend3,
    supervised: () => supervised2,
    summarized: () => summarized2,
    succeedSome: () => succeedSome2,
    succeedNone: () => succeedNone2,
    succeed: () => succeed8,
    step: () => step3,
    spanLinks: () => spanLinks2,
    spanAnnotations: () => spanAnnotations2,
    sleep: () => sleep4,
    setFiberRefs: () => setFiberRefs2,
    serviceOptional: () => serviceOptional2,
    serviceOption: () => serviceOption2,
    serviceMembers: () => serviceMembers2,
    serviceFunctions: () => serviceFunctions2,
    serviceFunctionEffect: () => serviceFunctionEffect2,
    serviceFunction: () => serviceFunction2,
    serviceConstants: () => serviceConstants2,
    sequentialFinalizers: () => sequentialFinalizers2,
    scopedWith: () => scopedWith2,
    scoped: () => scoped2,
    scopeWith: () => scopeWith2,
    scope: () => scope3,
    scheduleFrom: () => scheduleFrom,
    scheduleForked: () => scheduleForked2,
    schedule: () => schedule,
    sandbox: () => sandbox2,
    runtime: () => runtime3,
    runSyncExit: () => runSyncExit,
    runSync: () => runSync,
    runRequestBlock: () => runRequestBlock2,
    runPromiseExit: () => runPromiseExit,
    runPromise: () => runPromise,
    runFork: () => runFork2,
    runCallback: () => runCallback,
    retryOrElse: () => retryOrElse,
    retry: () => retry2,
    request: () => request,
    replicateEffect: () => replicateEffect2,
    replicate: () => replicate2,
    repeatOrElse: () => repeatOrElse,
    repeatN: () => repeatN2,
    repeat: () => repeat,
    reduceWhile: () => reduceWhile2,
    reduceRight: () => reduceRight4,
    reduceEffect: () => reduceEffect2,
    reduce: () => reduce10,
    randomWith: () => randomWith2,
    random: () => random3,
    raceWith: () => raceWith2,
    raceFirst: () => raceFirst2,
    raceAll: () => raceAll2,
    race: () => race2,
    provideServiceEffect: () => provideServiceEffect2,
    provideService: () => provideService2,
    provide: () => provide2,
    promise: () => promise2,
    patchRuntimeFlags: () => patchRuntimeFlags,
    patchFiberRefs: () => patchFiberRefs2,
    partition: () => partition4,
    parallelFinalizers: () => parallelFinalizers2,
    parallelErrors: () => parallelErrors2,
    orElseSucceed: () => orElseSucceed2,
    orElseFail: () => orElseFail2,
    orElse: () => orElse5,
    orDieWith: () => orDieWith2,
    orDie: () => orDie3,
    optionFromOptional: () => optionFromOptional2,
    option: () => option2,
    once: () => once3,
    onInterrupt: () => onInterrupt2,
    onExit: () => onExit3,
    onError: () => onError2,
    none: () => none9,
    never: () => never3,
    negate: () => negate2,
    metricLabels: () => metricLabels2,
    mergeAll: () => mergeAll5,
    merge: () => merge7,
    matchEffect: () => matchEffect2,
    matchCauseEffect: () => matchCauseEffect3,
    matchCause: () => matchCause3,
    match: () => match12,
    mapInputContext: () => mapInputContext2,
    mapErrorCause: () => mapErrorCause2,
    mapError: () => mapError3,
    mapBoth: () => mapBoth3,
    mapAccum: () => mapAccum4,
    map: () => map16,
    makeSpanScoped: () => makeSpanScoped2,
    makeSpan: () => makeSpan2,
    makeSemaphore: () => makeSemaphore2,
    makeLatch: () => makeLatch2,
    loop: () => loop2,
    logWithLevel: () => logWithLevel2,
    logWarning: () => logWarning2,
    logTrace: () => logTrace2,
    logInfo: () => logInfo2,
    logFatal: () => logFatal2,
    logError: () => logError2,
    logDebug: () => logDebug2,
    logAnnotations: () => logAnnotations2,
    log: () => log2,
    locallyWith: () => locallyWith,
    locallyScopedWith: () => locallyScopedWith,
    locallyScoped: () => locallyScoped,
    locally: () => locally,
    linkSpans: () => linkSpans2,
    linkSpanCurrent: () => linkSpanCurrent2,
    liftPredicate: () => liftPredicate2,
    let: () => let_3,
    labelMetricsScoped: () => labelMetricsScoped2,
    labelMetrics: () => labelMetrics2,
    iterate: () => iterate2,
    isSuccess: () => isSuccess3,
    isFailure: () => isFailure4,
    isEffect: () => isEffect2,
    intoDeferred: () => intoDeferred2,
    interruptibleMask: () => interruptibleMask2,
    interruptible: () => interruptible4,
    interruptWith: () => interruptWith2,
    interrupt: () => interrupt7,
    inheritFiberRefs: () => inheritFiberRefs2,
    ignoreLogged: () => ignoreLogged2,
    ignore: () => ignore2,
    if: () => if_2,
    head: () => head4,
    getRuntimeFlags: () => getRuntimeFlags,
    getFiberRefs: () => getFiberRefs,
    gen: () => gen2,
    functionWithSpan: () => functionWithSpan2,
    fromNullable: () => fromNullable3,
    fromFiberEffect: () => fromFiberEffect2,
    fromFiber: () => fromFiber2,
    forkWithErrorHandler: () => forkWithErrorHandler2,
    forkScoped: () => forkScoped2,
    forkIn: () => forkIn2,
    forkDaemon: () => forkDaemon2,
    forkAll: () => forkAll2,
    fork: () => fork3,
    forever: () => forever3,
    forEach: () => forEach6,
    fnUntraced: () => fnUntraced2,
    fn: () => fn,
    flipWith: () => flipWith2,
    flip: () => flip2,
    flatten: () => flatten9,
    flatMap: () => flatMap11,
    firstSuccessOf: () => firstSuccessOf2,
    findFirst: () => findFirst6,
    finalizersMask: () => finalizersMask2,
    filterOrFail: () => filterOrFail2,
    filterOrElse: () => filterOrElse2,
    filterOrDieMessage: () => filterOrDieMessage2,
    filterOrDie: () => filterOrDie2,
    filterMap: () => filterMap5,
    filterEffectOrFail: () => filterEffectOrFail2,
    filterEffectOrElse: () => filterEffectOrElse2,
    filter: () => filter7,
    fiberIdWith: () => fiberIdWith2,
    fiberId: () => fiberId2,
    failSync: () => failSync3,
    failCauseSync: () => failCauseSync3,
    failCause: () => failCause8,
    fail: () => fail9,
    exit: () => exit2,
    exists: () => exists3,
    every: () => every6,
    eventually: () => eventually2,
    ensuringChildren: () => ensuringChildren2,
    ensuringChild: () => ensuringChild2,
    ensuring: () => ensuring2,
    ensureSuccessType: () => ensureSuccessType,
    ensureRequirementsType: () => ensureRequirementsType,
    ensureErrorType: () => ensureErrorType,
    either: () => either3,
    dropWhile: () => dropWhile3,
    dropUntil: () => dropUntil2,
    disconnect: () => disconnect2,
    diffFiberRefs: () => diffFiberRefs2,
    dieSync: () => dieSync3,
    dieMessage: () => dieMessage2,
    die: () => die6,
    descriptorWith: () => descriptorWith2,
    descriptor: () => descriptor2,
    delay: () => delay2,
    daemonChildren: () => daemonChildren2,
    custom: () => custom2,
    currentSpan: () => currentSpan2,
    currentParentSpan: () => currentParentSpan2,
    contextWithEffect: () => contextWithEffect2,
    contextWith: () => contextWith2,
    context: () => context3,
    consoleWith: () => consoleWith2,
    console: () => console3,
    configProviderWith: () => configProviderWith2,
    clockWith: () => clockWith4,
    clock: () => clock2,
    checkInterruptible: () => checkInterruptible2,
    cause: () => cause2,
    catchTags: () => catchTags2,
    catchTag: () => catchTag2,
    catchSomeDefect: () => catchSomeDefect2,
    catchSomeCause: () => catchSomeCause2,
    catchSome: () => catchSome2,
    catchIf: () => catchIf2,
    catchAllDefect: () => catchAllDefect2,
    catchAllCause: () => catchAllCause3,
    catchAll: () => catchAll3,
    catch: () => _catch2,
    cachedWithTTL: () => cachedWithTTL,
    cachedInvalidateWithTTL: () => cachedInvalidateWithTTL2,
    cachedFunction: () => cachedFunction2,
    cached: () => cached3,
    cacheRequestResult: () => cacheRequestResult,
    blocked: () => blocked2,
    bindTo: () => bindTo3,
    bindAll: () => bindAll2,
    bind: () => bind3,
    awaitAllChildren: () => awaitAllChildren2,
    asyncEffect: () => asyncEffect2,
    async: () => async,
    asVoid: () => asVoid3,
    asSomeError: () => asSomeError2,
    asSome: () => asSome2,
    as: () => as3,
    ap: () => ap,
    annotateSpans: () => annotateSpans3,
    annotateLogsScoped: () => annotateLogsScoped2,
    annotateLogs: () => annotateLogs3,
    annotateCurrentSpan: () => annotateCurrentSpan2,
    andThen: () => andThen4,
    allowInterrupt: () => allowInterrupt2,
    allWith: () => allWith2,
    allSuccesses: () => allSuccesses2,
    all: () => all4,
    addFinalizer: () => addFinalizer3,
    acquireUseRelease: () => acquireUseRelease2,
    acquireReleaseInterruptible: () => acquireReleaseInterruptible2,
    acquireRelease: () => acquireRelease2,
    Tag: () => Tag3,
    Service: () => Service,
    EffectTypeId: () => EffectTypeId3,
    Do: () => Do2
  });

  // node_modules/effect/dist/esm/internal/schedule/interval.js
  var IntervalSymbolKey = "effect/ScheduleInterval";
  var IntervalTypeId = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
  var empty24 = {
    [IntervalTypeId]: IntervalTypeId,
    startMillis: 0,
    endMillis: 0
  };
  var make34 = (startMillis, endMillis) => {
    if (startMillis > endMillis) {
      return empty24;
    }
    return {
      [IntervalTypeId]: IntervalTypeId,
      startMillis,
      endMillis
    };
  };
  var lessThan2 = /* @__PURE__ */ dual(2, (self, that) => min2(self, that) === self);
  var min2 = /* @__PURE__ */ dual(2, (self, that) => {
    if (self.endMillis <= that.startMillis)
      return self;
    if (that.endMillis <= self.startMillis)
      return that;
    if (self.startMillis < that.startMillis)
      return self;
    if (that.startMillis < self.startMillis)
      return that;
    if (self.endMillis <= that.endMillis)
      return self;
    return that;
  });
  var isEmpty8 = (self) => {
    return self.startMillis >= self.endMillis;
  };
  var intersect = /* @__PURE__ */ dual(2, (self, that) => {
    const start = Math.max(self.startMillis, that.startMillis);
    const end = Math.min(self.endMillis, that.endMillis);
    return make34(start, end);
  });
  var size6 = (self) => {
    return millis(self.endMillis - self.startMillis);
  };
  var after = (startMilliseconds) => {
    return make34(startMilliseconds, Number.POSITIVE_INFINITY);
  };

  // node_modules/effect/dist/esm/ScheduleInterval.js
  var make35 = make34;
  var empty25 = empty24;
  var lessThan3 = lessThan2;
  var isEmpty9 = isEmpty8;
  var intersect2 = intersect;
  var size7 = size6;
  var after2 = after;

  // node_modules/effect/dist/esm/internal/schedule/intervals.js
  var IntervalsSymbolKey = "effect/ScheduleIntervals";
  var IntervalsTypeId = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
  var make36 = (intervals) => {
    return {
      [IntervalsTypeId]: IntervalsTypeId,
      intervals
    };
  };
  var intersect3 = /* @__PURE__ */ dual(2, (self, that) => intersectLoop(self.intervals, that.intervals, empty4()));
  var intersectLoop = (_left, _right, _acc) => {
    let left3 = _left;
    let right3 = _right;
    let acc = _acc;
    while (isNonEmpty2(left3) && isNonEmpty2(right3)) {
      const interval = pipe(headNonEmpty2(left3), intersect2(headNonEmpty2(right3)));
      const intervals = isEmpty9(interval) ? acc : pipe(acc, prepend2(interval));
      if (pipe(headNonEmpty2(left3), lessThan3(headNonEmpty2(right3)))) {
        left3 = tailNonEmpty2(left3);
      } else {
        right3 = tailNonEmpty2(right3);
      }
      acc = intervals;
    }
    return make36(reverse2(acc));
  };
  var start = (self) => {
    return pipe(self.intervals, head2, getOrElse(() => empty25)).startMillis;
  };
  var end = (self) => {
    return pipe(self.intervals, head2, getOrElse(() => empty25)).endMillis;
  };
  var lessThan4 = /* @__PURE__ */ dual(2, (self, that) => start(self) < start(that));
  var isNonEmpty4 = (self) => {
    return isNonEmpty2(self.intervals);
  };

  // node_modules/effect/dist/esm/ScheduleIntervals.js
  var make37 = make36;
  var intersect4 = intersect3;
  var start2 = start;
  var end2 = end;
  var lessThan5 = lessThan4;
  var isNonEmpty5 = isNonEmpty4;

  // node_modules/effect/dist/esm/internal/schedule/decision.js
  var OP_CONTINUE = "Continue";
  var OP_DONE2 = "Done";
  var _continue = (intervals) => {
    return {
      _tag: OP_CONTINUE,
      intervals
    };
  };
  var continueWith = (interval) => {
    return {
      _tag: OP_CONTINUE,
      intervals: make37(of2(interval))
    };
  };
  var done5 = {
    _tag: OP_DONE2
  };
  var isContinue = (self) => {
    return self._tag === OP_CONTINUE;
  };
  var isDone4 = (self) => {
    return self._tag === OP_DONE2;
  };

  // node_modules/effect/dist/esm/ScheduleDecision.js
  var _continue2 = _continue;
  var continueWith2 = continueWith;
  var done6 = done5;
  var isContinue2 = isContinue;
  var isDone5 = isDone4;

  // node_modules/effect/dist/esm/Scope.js
  var Scope = scopeTag;
  var addFinalizer2 = scopeAddFinalizer;
  var addFinalizerExit = scopeAddFinalizerExit;
  var close = scopeClose;
  var extend2 = scopeExtend;
  var fork2 = scopeFork;
  var make38 = scopeMake;

  // node_modules/effect/dist/esm/internal/effect/circular.js
  class Semaphore {
    permits;
    waiters = /* @__PURE__ */ new Set;
    taken = 0;
    constructor(permits) {
      this.permits = permits;
    }
    get free() {
      return this.permits - this.taken;
    }
    take = (n) => asyncInterrupt((resume2) => {
      if (this.free < n) {
        const observer = () => {
          if (this.free < n) {
            return;
          }
          this.waiters.delete(observer);
          this.taken += n;
          resume2(succeed(n));
        };
        this.waiters.add(observer);
        return sync(() => {
          this.waiters.delete(observer);
        });
      }
      this.taken += n;
      return resume2(succeed(n));
    });
    updateTakenUnsafe(fiber, f) {
      this.taken = f(this.taken);
      if (this.waiters.size > 0) {
        fiber.getFiberRef(currentScheduler).scheduleTask(() => {
          const iter = this.waiters.values();
          let item = iter.next();
          while (item.done === false && this.free > 0) {
            item.value();
            item = iter.next();
          }
        }, fiber.getFiberRef(currentSchedulingPriority));
      }
      return succeed(this.free);
    }
    updateTaken(f) {
      return withFiberRuntime((fiber) => this.updateTakenUnsafe(fiber, f));
    }
    resize = (permits) => asVoid(withFiberRuntime((fiber) => {
      this.permits = permits;
      if (this.free < 0) {
        return void_;
      }
      return this.updateTakenUnsafe(fiber, (taken) => taken);
    }));
    release = (n) => this.updateTaken((taken) => taken - n);
    releaseAll = /* @__PURE__ */ this.updateTaken((_) => 0);
    withPermits = (n) => (self) => uninterruptibleMask((restore) => flatMap8(restore(this.take(n)), (permits) => ensuring(restore(self), this.release(permits))));
    withPermitsIfAvailable = (n) => (self) => uninterruptibleMask((restore) => suspend(() => {
      if (this.free < n) {
        return succeedNone;
      }
      this.taken += n;
      return ensuring(restore(asSome(self)), this.release(n));
    }));
  }
  var unsafeMakeSemaphore = (permits) => new Semaphore(permits);
  var makeSemaphore = (permits) => sync(() => unsafeMakeSemaphore(permits));

  class Latch extends Class {
    isOpen;
    waiters = [];
    scheduled = false;
    constructor(isOpen) {
      super();
      this.isOpen = isOpen;
    }
    commit() {
      return this.await;
    }
    unsafeSchedule(fiber) {
      if (this.scheduled || this.waiters.length === 0) {
        return void_;
      }
      this.scheduled = true;
      fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
      return void_;
    }
    flushWaiters = () => {
      this.scheduled = false;
      const waiters = this.waiters;
      this.waiters = [];
      for (let i = 0;i < waiters.length; i++) {
        waiters[i](exitVoid);
      }
    };
    open = /* @__PURE__ */ withFiberRuntime((fiber) => {
      if (this.isOpen) {
        return void_;
      }
      this.isOpen = true;
      return this.unsafeSchedule(fiber);
    });
    unsafeOpen() {
      if (this.isOpen)
        return;
      this.isOpen = true;
      this.flushWaiters();
    }
    release = /* @__PURE__ */ withFiberRuntime((fiber) => {
      if (this.isOpen) {
        return void_;
      }
      return this.unsafeSchedule(fiber);
    });
    await = /* @__PURE__ */ asyncInterrupt((resume2) => {
      if (this.isOpen) {
        return resume2(void_);
      }
      this.waiters.push(resume2);
      return sync(() => {
        const index = this.waiters.indexOf(resume2);
        if (index !== -1) {
          this.waiters.splice(index, 1);
        }
      });
    });
    unsafeClose() {
      this.isOpen = false;
    }
    close = /* @__PURE__ */ sync(() => {
      this.isOpen = false;
    });
    whenOpen = (self) => {
      return zipRight(this.await, self);
    };
  }
  var unsafeMakeLatch = (open) => new Latch(open ?? false);
  var makeLatch = (open) => sync(() => unsafeMakeLatch(open));
  var awaitAllChildren = (self) => ensuringChildren(self, fiberAwaitAll);
  var cached2 = /* @__PURE__ */ dual(2, (self, timeToLive) => map10(cachedInvalidateWithTTL(self, timeToLive), (tuple) => tuple[0]));
  var cachedInvalidateWithTTL = /* @__PURE__ */ dual(2, (self, timeToLive) => {
    const duration = decode(timeToLive);
    return flatMap8(context(), (env) => map10(makeSynchronized(none2()), (cache) => [provideContext(getCachedValue(self, duration, cache), env), invalidateCache(cache)]));
  });
  var computeCachedValue = (self, timeToLive, start3) => {
    const timeToLiveMillis = toMillis(decode(timeToLive));
    return pipe(deferredMake(), tap((deferred) => intoDeferred(self, deferred)), map10((deferred) => some2([start3 + timeToLiveMillis, deferred])));
  };
  var getCachedValue = (self, timeToLive, cache) => uninterruptibleMask((restore) => pipe(clockWith3((clock2) => clock2.currentTimeMillis), flatMap8((time) => updateSomeAndGetEffectSynchronized(cache, (option2) => {
    switch (option2._tag) {
      case "None": {
        return some2(computeCachedValue(self, timeToLive, time));
      }
      case "Some": {
        const [end3] = option2.value;
        return end3 - time <= 0 ? some2(computeCachedValue(self, timeToLive, time)) : none2();
      }
    }
  })), flatMap8((option2) => isNone2(option2) ? dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option2.value[1])))));
  var invalidateCache = (cache) => set5(cache, none2());
  var ensuringChild = /* @__PURE__ */ dual(2, (self, f) => ensuringChildren(self, (children) => f(fiberAll(children))));
  var ensuringChildren = /* @__PURE__ */ dual(2, (self, children) => flatMap8(track, (supervisor) => pipe(supervised(self, supervisor), ensuring(flatMap8(supervisor.value, children)))));
  var forkAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (effects, options) => options?.discard ? forEachSequentialDiscard(effects, fork) : map10(forEachSequential(effects, fork), fiberAll));
  var forkIn = /* @__PURE__ */ dual(2, (self, scope2) => withFiberRuntime((parent, parentStatus) => {
    const scopeImpl = scope2;
    const fiber = unsafeFork(self, parent, parentStatus.runtimeFlags, globalScope);
    if (scopeImpl.state._tag === "Open") {
      const finalizer = () => fiberIdWith((fiberId2) => equals(fiberId2, fiber.id()) ? void_ : asVoid(interruptFiber(fiber)));
      const key = {};
      scopeImpl.state.finalizers.set(key, finalizer);
      fiber.addObserver(() => {
        if (scopeImpl.state._tag === "Closed")
          return;
        scopeImpl.state.finalizers.delete(key);
      });
    } else {
      fiber.unsafeInterruptAsFork(parent.id());
    }
    return succeed(fiber);
  }));
  var forkScoped = (self) => scopeWith((scope2) => forkIn(self, scope2));
  var fromFiber = (fiber) => join2(fiber);
  var fromFiberEffect = (fiber) => suspend(() => flatMap8(fiber, join2));
  var memoKeySymbol = /* @__PURE__ */ Symbol.for("effect/Effect/memoizeFunction.key");

  class Key {
    a;
    eq;
    [memoKeySymbol] = memoKeySymbol;
    constructor(a, eq) {
      this.a = a;
      this.eq = eq;
    }
    [symbol2](that) {
      if (hasProperty(that, memoKeySymbol)) {
        if (this.eq) {
          return this.eq(this.a, that.a);
        } else {
          return equals(this.a, that.a);
        }
      }
      return false;
    }
    [symbol]() {
      return this.eq ? 0 : cached(this, hash(this.a));
    }
  }
  var cachedFunction = (f, eq) => {
    return pipe(sync(() => empty17()), flatMap8(makeSynchronized), map10((ref) => (a) => pipe(ref.modifyEffect((map13) => {
      const result = pipe(map13, get8(new Key(a, eq)));
      if (isNone2(result)) {
        return pipe(deferredMake(), tap((deferred) => pipe(diffFiberRefs(f(a)), intoDeferred(deferred), fork)), map10((deferred) => [deferred, pipe(map13, set4(new Key(a, eq), deferred))]));
      }
      return succeed([result.value, map13]);
    }), flatMap8(deferredAwait), flatMap8(([patch9, b]) => pipe(patchFiberRefs(patch9), as(b))))));
  };
  var raceFirst = /* @__PURE__ */ dual(2, (self, that) => pipe(exit(self), race(exit(that)), (effect) => flatten6(effect)));
  var supervised = /* @__PURE__ */ dual(2, (self, supervisor) => {
    const supervise = fiberRefLocallyWith(currentSupervisor, (s) => s.zip(supervisor));
    return supervise(self);
  });
  var timeout = /* @__PURE__ */ dual(2, (self, duration) => timeoutFail(self, {
    onTimeout: () => timeoutExceptionFromDuration(duration),
    duration
  }));
  var timeoutFail = /* @__PURE__ */ dual(2, (self, {
    duration,
    onTimeout
  }) => flatten6(timeoutTo(self, {
    onTimeout: () => failSync(onTimeout),
    onSuccess: succeed,
    duration
  })));
  var timeoutFailCause = /* @__PURE__ */ dual(2, (self, {
    duration,
    onTimeout
  }) => flatten6(timeoutTo(self, {
    onTimeout: () => failCauseSync(onTimeout),
    onSuccess: succeed,
    duration
  })));
  var timeoutOption = /* @__PURE__ */ dual(2, (self, duration) => timeoutTo(self, {
    duration,
    onSuccess: some2,
    onTimeout: none2
  }));
  var timeoutTo = /* @__PURE__ */ dual(2, (self, {
    duration,
    onSuccess,
    onTimeout
  }) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self), interruptible2(sleep3(duration)), {
    onSelfWin: (winner, loser) => flatMap8(winner.await, (exit2) => {
      if (exit2._tag === "Success") {
        return flatMap8(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onSuccess(exit2.value)));
      } else {
        return flatMap8(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit2.cause));
      }
    }),
    onOtherWin: (winner, loser) => flatMap8(winner.await, (exit2) => {
      if (exit2._tag === "Success") {
        return flatMap8(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onTimeout()));
      } else {
        return flatMap8(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit2.cause));
      }
    }),
    otherScope: globalScope
  }))));
  var SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
  var SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
  var synchronizedVariance = {
    _A: (_) => _
  };

  class SynchronizedImpl extends Class {
    ref;
    withLock;
    [SynchronizedTypeId] = synchronizedVariance;
    [RefTypeId] = refVariance;
    [TypeId12] = TypeId12;
    constructor(ref, withLock) {
      super();
      this.ref = ref;
      this.withLock = withLock;
      this.get = get11(this.ref);
    }
    get;
    commit() {
      return this.get;
    }
    modify(f) {
      return this.modifyEffect((a) => succeed(f(a)));
    }
    modifyEffect(f) {
      return this.withLock(pipe(flatMap8(get11(this.ref), f), flatMap8(([b, a]) => as(set5(this.ref, a), b))));
    }
  }
  var makeSynchronized = (value) => sync(() => unsafeMakeSynchronized(value));
  var unsafeMakeSynchronized = (value) => {
    const ref = unsafeMake6(value);
    const sem = unsafeMakeSemaphore(1);
    return new SynchronizedImpl(ref, sem.withPermits(1));
  };
  var updateSomeAndGetEffectSynchronized = /* @__PURE__ */ dual(2, (self, pf) => self.modifyEffect((value) => {
    const result = pf(value);
    switch (result._tag) {
      case "None": {
        return succeed([value, value]);
      }
      case "Some": {
        return map10(result.value, (a) => [a, a]);
      }
    }
  }));
  var bindAll = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self, f, options) => flatMap8(self, (a) => all3(f(a), options).pipe(map10((record2) => Object.assign({}, a, record2)))));

  // node_modules/effect/dist/esm/internal/managedRuntime/circular.js
  var TypeId14 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");

  // node_modules/effect/dist/esm/internal/opCodes/layer.js
  var OP_EXTEND_SCOPE = "ExtendScope";
  var OP_FOLD = "Fold";
  var OP_FRESH = "Fresh";
  var OP_FROM_EFFECT = "FromEffect";
  var OP_SCOPED = "Scoped";
  var OP_SUSPEND = "Suspend";
  var OP_PROVIDE = "Provide";
  var OP_PROVIDE_MERGE = "ProvideMerge";
  var OP_MERGE_ALL = "MergeAll";
  var OP_ZIP_WITH2 = "ZipWith";

  // node_modules/effect/dist/esm/Fiber.js
  var _await3 = _await2;
  var inheritAll2 = inheritAll;
  var interrupt6 = interruptFiber;
  var interruptAs = interruptAsFiber;
  var join3 = join2;
  var poll4 = poll3;

  // node_modules/effect/dist/esm/internal/runtime.js
  var makeDual = (f) => function() {
    if (arguments.length === 1) {
      const runtime2 = arguments[0];
      return (effect, ...args2) => f(runtime2, effect, ...args2);
    }
    return f.apply(this, arguments);
  };
  var unsafeFork2 = /* @__PURE__ */ makeDual((runtime2, self, options) => {
    const fiberId2 = unsafeMake3();
    const fiberRefUpdates = [[currentContext, [[fiberId2, runtime2.context]]]];
    if (options?.scheduler) {
      fiberRefUpdates.push([currentScheduler, [[fiberId2, options.scheduler]]]);
    }
    let fiberRefs3 = updateManyAs2(runtime2.fiberRefs, {
      entries: fiberRefUpdates,
      forkAs: fiberId2
    });
    if (options?.updateRefs) {
      fiberRefs3 = options.updateRefs(fiberRefs3, fiberId2);
    }
    const fiberRuntime = new FiberRuntime(fiberId2, fiberRefs3, runtime2.runtimeFlags);
    let effect = self;
    if (options?.scope) {
      effect = flatMap8(fork2(options.scope, sequential2), (closeableScope) => zipRight(scopeAddFinalizer(closeableScope, fiberIdWith((id2) => equals(id2, fiberRuntime.id()) ? void_ : interruptAsFiber(fiberRuntime, id2))), onExit(self, (exit2) => close(closeableScope, exit2))));
    }
    const supervisor = fiberRuntime.currentSupervisor;
    if (supervisor !== none8) {
      supervisor.onStart(runtime2.context, effect, none2(), fiberRuntime);
      fiberRuntime.addObserver((exit2) => supervisor.onEnd(exit2, fiberRuntime));
    }
    globalScope.add(runtime2.runtimeFlags, fiberRuntime);
    if (options?.immediate === false) {
      fiberRuntime.resume(effect);
    } else {
      fiberRuntime.start(effect);
    }
    return fiberRuntime;
  });
  var unsafeRunCallback = /* @__PURE__ */ makeDual((runtime2, effect, options = {}) => {
    const fiberRuntime = unsafeFork2(runtime2, effect, options);
    if (options.onExit) {
      fiberRuntime.addObserver((exit2) => {
        options.onExit(exit2);
      });
    }
    return (id2, cancelOptions) => unsafeRunCallback(runtime2)(pipe(fiberRuntime, interruptAs(id2 ?? none4)), {
      ...cancelOptions,
      onExit: cancelOptions?.onExit ? (exit2) => cancelOptions.onExit(flatten7(exit2)) : undefined
    });
  });
  var unsafeRunSync = /* @__PURE__ */ makeDual((runtime2, effect) => {
    const result = unsafeRunSyncExit(runtime2)(effect);
    if (result._tag === "Failure") {
      throw fiberFailure(result.effect_instruction_i0);
    }
    return result.effect_instruction_i0;
  });

  class AsyncFiberExceptionImpl extends Error {
    fiber;
    _tag = "AsyncFiberException";
    constructor(fiber) {
      super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
      this.fiber = fiber;
      this.name = this._tag;
      this.stack = this.message;
    }
  }
  var asyncFiberException = (fiber) => {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    const error = new AsyncFiberExceptionImpl(fiber);
    Error.stackTraceLimit = limit;
    return error;
  };
  var FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
  var FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");

  class FiberFailureImpl extends Error {
    [FiberFailureId];
    [FiberFailureCauseId];
    constructor(cause2) {
      const head4 = prettyErrors(cause2)[0];
      super(head4?.message || "An error has occurred");
      this[FiberFailureId] = FiberFailureId;
      this[FiberFailureCauseId] = cause2;
      this.name = head4 ? `(FiberFailure) ${head4.name}` : "FiberFailure";
      if (head4?.stack) {
        this.stack = head4.stack;
      }
    }
    toJSON() {
      return {
        _id: "FiberFailure",
        cause: this[FiberFailureCauseId].toJSON()
      };
    }
    toString() {
      return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
        renderErrorCause: true
      });
    }
    [NodeInspectSymbol]() {
      return this.toString();
    }
  }
  var fiberFailure = (cause2) => {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    const error = new FiberFailureImpl(cause2);
    Error.stackTraceLimit = limit;
    return error;
  };
  var fastPath = (effect) => {
    const op = effect;
    switch (op._op) {
      case "Failure":
      case "Success": {
        return op;
      }
      case "Left": {
        return exitFail(op.left);
      }
      case "Right": {
        return exitSucceed(op.right);
      }
      case "Some": {
        return exitSucceed(op.value);
      }
      case "None": {
        return exitFail(NoSuchElementException());
      }
    }
  };
  var unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime2, effect) => {
    const op = fastPath(effect);
    if (op) {
      return op;
    }
    const scheduler = new SyncScheduler;
    const fiberRuntime = unsafeFork2(runtime2)(effect, {
      scheduler
    });
    scheduler.flush();
    const result = fiberRuntime.unsafePoll();
    if (result) {
      return result;
    }
    return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
  });
  var unsafeRunPromise = /* @__PURE__ */ makeDual((runtime2, effect, options) => unsafeRunPromiseExit(runtime2, effect, options).then((result) => {
    switch (result._tag) {
      case OP_SUCCESS: {
        return result.effect_instruction_i0;
      }
      case OP_FAILURE: {
        throw fiberFailure(result.effect_instruction_i0);
      }
    }
  }));
  var unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime2, effect, options) => new Promise((resolve) => {
    const op = fastPath(effect);
    if (op) {
      resolve(op);
    }
    const fiber = unsafeFork2(runtime2)(effect);
    fiber.addObserver((exit2) => {
      resolve(exit2);
    });
    if (options?.signal !== undefined) {
      if (options.signal.aborted) {
        fiber.unsafeInterruptAsFork(fiber.id());
      } else {
        options.signal.addEventListener("abort", () => {
          fiber.unsafeInterruptAsFork(fiber.id());
        }, {
          once: true
        });
      }
    }
  }));

  class RuntimeImpl {
    context;
    runtimeFlags;
    fiberRefs;
    constructor(context2, runtimeFlags2, fiberRefs3) {
      this.context = context2;
      this.runtimeFlags = runtimeFlags2;
      this.fiberRefs = fiberRefs3;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var make39 = (options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
  var runtime2 = () => withFiberRuntime((state, status2) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status2.runtimeFlags, state.getFiberRefs())));
  var defaultRuntimeFlags = /* @__PURE__ */ make16(Interruption, CooperativeYielding, RuntimeMetrics);
  var defaultRuntime = /* @__PURE__ */ make39({
    context: /* @__PURE__ */ empty3(),
    runtimeFlags: defaultRuntimeFlags,
    fiberRefs: /* @__PURE__ */ empty21()
  });
  var unsafeRunEffect = /* @__PURE__ */ unsafeRunCallback(defaultRuntime);
  var unsafeForkEffect = /* @__PURE__ */ unsafeFork2(defaultRuntime);
  var unsafeRunPromiseEffect = /* @__PURE__ */ unsafeRunPromise(defaultRuntime);
  var unsafeRunPromiseExitEffect = /* @__PURE__ */ unsafeRunPromiseExit(defaultRuntime);
  var unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);
  var unsafeRunSyncExitEffect = /* @__PURE__ */ unsafeRunSyncExit(defaultRuntime);
  var asyncEffect = (register) => suspend(() => {
    let cleanup = undefined;
    return flatMap8(deferredMake(), (deferred) => flatMap8(runtime2(), (runtime3) => uninterruptibleMask((restore) => zipRight(fork(restore(matchCauseEffect(register((cb) => unsafeRunCallback(runtime3)(intoDeferred(cb, deferred))), {
      onFailure: (cause2) => deferredFailCause(deferred, cause2),
      onSuccess: (cleanup_) => {
        cleanup = cleanup_;
        return void_;
      }
    }))), restore(onInterrupt(deferredAwait(deferred), () => cleanup ?? void_))))));
  });

  // node_modules/effect/dist/esm/internal/synchronizedRef.js
  var modifyEffect = /* @__PURE__ */ dual(2, (self, f) => self.modifyEffect(f));

  // node_modules/effect/dist/esm/internal/layer.js
  var LayerSymbolKey = "effect/Layer";
  var LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
  var layerVariance = {
    _RIn: (_) => _,
    _E: (_) => _,
    _ROut: (_) => _
  };
  var proto3 = {
    [LayerTypeId]: layerVariance,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var MemoMapTypeIdKey = "effect/Layer/MemoMap";
  var MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
  var CurrentMemoMap = /* @__PURE__ */ Reference2()("effect/Layer/CurrentMemoMap", {
    defaultValue: () => unsafeMakeMemoMap()
  });
  var isLayer = (u) => hasProperty(u, LayerTypeId);
  var isFresh = (self) => {
    return self._op_layer === OP_FRESH;
  };

  class MemoMapImpl {
    ref;
    [MemoMapTypeId];
    constructor(ref) {
      this.ref = ref;
      this[MemoMapTypeId] = MemoMapTypeId;
    }
    getOrElseMemoize(layer, scope2) {
      return pipe(modifyEffect(this.ref, (map14) => {
        const inMap = map14.get(layer);
        if (inMap !== undefined) {
          const [acquire, release] = inMap;
          const cached3 = pipe(acquire, flatMap8(([patch9, b]) => pipe(patchFiberRefs(patch9), as(b))), onExit(exitMatch({
            onFailure: () => void_,
            onSuccess: () => scopeAddFinalizerExit(scope2, release)
          })));
          return succeed([cached3, map14]);
        }
        return pipe(make27(0), flatMap8((observers) => pipe(deferredMake(), flatMap8((deferred) => pipe(make27(() => void_), map10((finalizerRef) => {
          const resource = uninterruptibleMask((restore) => pipe(scopeMake(), flatMap8((innerScope) => pipe(restore(flatMap8(makeBuilder(layer, innerScope, true), (f) => diffFiberRefs(f(this)))), exit, flatMap8((exit2) => {
            switch (exit2._tag) {
              case OP_FAILURE: {
                return pipe(deferredFailCause(deferred, exit2.effect_instruction_i0), zipRight(scopeClose(innerScope, exit2)), zipRight(failCause(exit2.effect_instruction_i0)));
              }
              case OP_SUCCESS: {
                return pipe(set5(finalizerRef, (exit3) => pipe(scopeClose(innerScope, exit3), whenEffect(modify3(observers, (n) => [n === 1, n - 1])), asVoid)), zipRight(update2(observers, (n) => n + 1)), zipRight(scopeAddFinalizerExit(scope2, (exit3) => pipe(sync(() => map14.delete(layer)), zipRight(get11(finalizerRef)), flatMap8((finalizer) => finalizer(exit3))))), zipRight(deferredSucceed(deferred, exit2.effect_instruction_i0)), as(exit2.effect_instruction_i0[1]));
              }
            }
          })))));
          const memoized = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
            onFailure: () => void_,
            onSuccess: () => update2(observers, (n) => n + 1)
          }))), (exit2) => pipe(get11(finalizerRef), flatMap8((finalizer) => finalizer(exit2)))];
          return [resource, isFresh(layer) ? map14 : map14.set(layer, memoized)];
        }))))));
      }), flatten6);
    }
  }
  var makeMemoMap = /* @__PURE__ */ suspend(() => map10(makeSynchronized(new Map), (ref) => new MemoMapImpl(ref)));
  var unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(new Map));
  var build = (self) => scopeWith((scope2) => buildWithScope(self, scope2));
  var buildWithScope = /* @__PURE__ */ dual(2, (self, scope2) => flatMap8(makeMemoMap, (memoMap) => buildWithMemoMap(self, memoMap, scope2)));
  var buildWithMemoMap = /* @__PURE__ */ dual(3, (self, memoMap, scope2) => flatMap8(makeBuilder(self, scope2), (run) => provideService(run(memoMap), CurrentMemoMap, memoMap)));
  var makeBuilder = (self, scope2, inMemoMap = false) => {
    const op = self;
    switch (op._op_layer) {
      case "Locally": {
        return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope2)));
      }
      case "ExtendScope": {
        return sync(() => (memoMap) => scopeWith((scope3) => memoMap.getOrElseMemoize(op.layer, scope3)));
      }
      case "Fold": {
        return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope2), matchCauseEffect({
          onFailure: (cause2) => memoMap.getOrElseMemoize(op.failureK(cause2), scope2),
          onSuccess: (value) => memoMap.getOrElseMemoize(op.successK(value), scope2)
        })));
      }
      case "Fresh": {
        return sync(() => (_) => pipe(op.layer, buildWithScope(scope2)));
      }
      case "FromEffect": {
        return inMemoMap ? sync(() => (_) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope2));
      }
      case "Provide": {
        return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), flatMap8((env) => pipe(memoMap.getOrElseMemoize(op.second, scope2), provideContext(env)))));
      }
      case "Scoped": {
        return inMemoMap ? sync(() => (_) => scopeExtend(op.effect, scope2)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self, scope2));
      }
      case "Suspend": {
        return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope2));
      }
      case "ProvideMerge": {
        return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), zipWith3(memoMap.getOrElseMemoize(op.second, scope2), op.zipK)));
      }
      case "ZipWith": {
        return gen(function* () {
          const parallelScope = yield* scopeFork(scope2, parallel2);
          const firstScope = yield* scopeFork(parallelScope, sequential2);
          const secondScope = yield* scopeFork(parallelScope, sequential2);
          return (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, firstScope), zipWithOptions(memoMap.getOrElseMemoize(op.second, secondScope), op.zipK, {
            concurrent: true
          }));
        });
      }
      case "MergeAll": {
        const layers = op.layers;
        return map10(scopeFork(scope2, parallel2), (parallelScope) => (memoMap) => {
          const contexts = new Array(layers.length);
          return map10(forEachConcurrentDiscard(layers, fnUntraced(function* (layer, i) {
            const scope3 = yield* scopeFork(parallelScope, sequential2);
            const context2 = yield* memoMap.getOrElseMemoize(layer, scope3);
            contexts[i] = context2;
          }), false, false), () => mergeAll2(...contexts));
        });
      }
    }
  };
  var catchAll2 = /* @__PURE__ */ dual(2, (self, onFailure) => match11(self, {
    onFailure,
    onSuccess: succeedContext
  }));
  var catchAllCause2 = /* @__PURE__ */ dual(2, (self, onFailure) => matchCause2(self, {
    onFailure,
    onSuccess: succeedContext
  }));
  var die5 = (defect) => failCause6(die4(defect));
  var dieSync2 = (evaluate2) => failCauseSync2(() => die4(evaluate2()));
  var discard = (self) => map14(self, () => empty3());
  var context2 = () => fromEffectContext(context());
  var extendScope = (self) => {
    const extendScope2 = Object.create(proto3);
    extendScope2._op_layer = OP_EXTEND_SCOPE;
    extendScope2.layer = self;
    return extendScope2;
  };
  var fail7 = (error) => failCause6(fail5(error));
  var failSync2 = (evaluate2) => failCauseSync2(() => fail5(evaluate2()));
  var failCause6 = (cause2) => fromEffectContext(failCause(cause2));
  var failCauseSync2 = (evaluate2) => fromEffectContext(failCauseSync(evaluate2));
  var flatMap10 = /* @__PURE__ */ dual(2, (self, f) => match11(self, {
    onFailure: fail7,
    onSuccess: f
  }));
  var flatten8 = /* @__PURE__ */ dual(2, (self, tag) => flatMap10(self, get3(tag)));
  var fresh = (self) => {
    const fresh2 = Object.create(proto3);
    fresh2._op_layer = OP_FRESH;
    fresh2.layer = self;
    return fresh2;
  };
  var fromEffect3 = /* @__PURE__ */ dual(2, (a, b) => {
    const tagFirst = isTag2(a);
    const tag = tagFirst ? a : b;
    const effect = tagFirst ? b : a;
    return fromEffectContext(map10(effect, (service) => make5(tag, service)));
  });
  var fromEffectDiscard = (effect) => fromEffectContext(map10(effect, () => empty3()));
  function fromEffectContext(effect) {
    const fromEffect4 = Object.create(proto3);
    fromEffect4._op_layer = OP_FROM_EFFECT;
    fromEffect4.effect = effect;
    return fromEffect4;
  }
  var fiberRefLocally2 = /* @__PURE__ */ dual(3, (self, ref, value) => locallyEffect(self, fiberRefLocally(ref, value)));
  var locallyEffect = /* @__PURE__ */ dual(2, (self, f) => {
    const locally = Object.create(proto3);
    locally._op_layer = "Locally";
    locally.self = self;
    locally.f = f;
    return locally;
  });
  var fiberRefLocallyWith2 = /* @__PURE__ */ dual(3, (self, ref, value) => locallyEffect(self, fiberRefLocallyWith(ref, value)));
  var fiberRefLocallyScoped2 = (self, value) => scopedDiscard(fiberRefLocallyScoped(self, value));
  var fiberRefLocallyScopedWith2 = (self, value) => scopedDiscard(fiberRefLocallyScopedWith(self, value));
  var fromFunction = (tagA, tagB, f) => fromEffectContext(map10(tagA, (a) => make5(tagB, f(a))));
  var launch = (self) => scopedEffect(zipRight(scopeWith((scope2) => pipe(self, buildWithScope(scope2))), never));
  var mock = function() {
    if (arguments.length === 1) {
      return (service) => mockImpl(arguments[0], service);
    }
    return mockImpl(arguments[0], arguments[1]);
  };
  var mockImpl = (tag, service) => succeed6(tag, new Proxy({
    ...service
  }, {
    get(target, prop, _receiver) {
      if (prop in target) {
        return target[prop];
      }
      const prevLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const error = new Error(`${tag.key}: Unimplemented method "${prop.toString()}"`);
      Error.stackTraceLimit = prevLimit;
      error.name = "UnimplementedError";
      return makeUnimplemented(error);
    },
    has: constTrue
  }));
  var makeUnimplemented = (error) => {
    const dead = die2(error);
    function unimplemented() {
      return dead;
    }
    Object.assign(unimplemented, dead);
    Object.setPrototypeOf(unimplemented, Object.getPrototypeOf(dead));
    return unimplemented;
  };
  var map14 = /* @__PURE__ */ dual(2, (self, f) => flatMap10(self, (context3) => succeedContext(f(context3))));
  var mapError2 = /* @__PURE__ */ dual(2, (self, f) => catchAll2(self, (error) => failSync2(() => f(error))));
  var matchCause2 = /* @__PURE__ */ dual(2, (self, {
    onFailure,
    onSuccess
  }) => {
    const fold = Object.create(proto3);
    fold._op_layer = OP_FOLD;
    fold.layer = self;
    fold.failureK = onFailure;
    fold.successK = onSuccess;
    return fold;
  });
  var match11 = /* @__PURE__ */ dual(2, (self, {
    onFailure,
    onSuccess
  }) => matchCause2(self, {
    onFailure: (cause2) => {
      const failureOrCause3 = failureOrCause2(cause2);
      switch (failureOrCause3._tag) {
        case "Left": {
          return onFailure(failureOrCause3.left);
        }
        case "Right": {
          return failCause6(failureOrCause3.right);
        }
      }
    },
    onSuccess
  }));
  var memoize2 = (self) => scopeWith((scope2) => map10(memoize(buildWithScope(self, scope2)), fromEffectContext));
  var merge6 = /* @__PURE__ */ dual(2, (self, that) => zipWith4(self, that, (a, b) => merge3(a, b)));
  var mergeAll4 = (...layers) => {
    const mergeAll5 = Object.create(proto3);
    mergeAll5._op_layer = OP_MERGE_ALL;
    mergeAll5.layers = layers;
    return mergeAll5;
  };
  var orDie2 = (self) => catchAll2(self, (defect) => die5(defect));
  var orElse4 = /* @__PURE__ */ dual(2, (self, that) => catchAll2(self, that));
  var passthrough = (self) => merge6(context2(), self);
  var project = /* @__PURE__ */ dual(4, (self, tagA, tagB, f) => map14(self, (context3) => make5(tagB, f(unsafeGet3(context3, tagA)))));
  var retry = /* @__PURE__ */ dual(2, (self, schedule) => suspend2(() => {
    const stateTag = GenericTag("effect/Layer/retry/{ state: unknown }");
    return pipe(succeed6(stateTag, {
      state: schedule.initial
    }), flatMap10((env) => retryLoop(self, schedule, stateTag, pipe(env, get3(stateTag)).state)));
  }));
  var retryLoop = (self, schedule, stateTag, state) => {
    return pipe(self, catchAll2((error) => pipe(retryUpdate(schedule, stateTag, error, state), flatMap10((env) => fresh(retryLoop(self, schedule, stateTag, pipe(env, get3(stateTag)).state))))));
  };
  var retryUpdate = (schedule, stateTag, error, state) => {
    return fromEffect3(stateTag, pipe(currentTimeMillis2, flatMap8((now) => pipe(schedule.step(now, error, state), flatMap8(([state2, _, decision]) => isDone5(decision) ? fail2(error) : pipe(sleep2(millis(start2(decision.intervals) - now)), as({
      state: state2
    })))))));
  };
  var scoped = /* @__PURE__ */ dual(2, (a, b) => {
    const tagFirst = isTag2(a);
    const tag = tagFirst ? a : b;
    const effect = tagFirst ? b : a;
    return scopedContext(map10(effect, (service) => make5(tag, service)));
  });
  var scopedDiscard = (effect) => scopedContext(pipe(effect, as(empty3())));
  var scopedContext = (effect) => {
    const scoped2 = Object.create(proto3);
    scoped2._op_layer = OP_SCOPED;
    scoped2.effect = effect;
    return scoped2;
  };
  var scope2 = /* @__PURE__ */ scopedContext(/* @__PURE__ */ map10(/* @__PURE__ */ acquireRelease(/* @__PURE__ */ scopeMake(), (scope3, exit2) => scope3.close(exit2)), (scope3) => make5(Scope, scope3)));
  var service = (tag) => fromEffect3(tag, tag);
  var succeed6 = /* @__PURE__ */ dual(2, (a, b) => {
    const tagFirst = isTag2(a);
    const tag = tagFirst ? a : b;
    const resource = tagFirst ? b : a;
    return fromEffectContext(succeed(make5(tag, resource)));
  });
  var succeedContext = (context3) => {
    return fromEffectContext(succeed(context3));
  };
  var empty27 = /* @__PURE__ */ succeedContext(/* @__PURE__ */ empty3());
  var suspend2 = (evaluate2) => {
    const suspend3 = Object.create(proto3);
    suspend3._op_layer = OP_SUSPEND;
    suspend3.evaluate = evaluate2;
    return suspend3;
  };
  var sync2 = /* @__PURE__ */ dual(2, (a, b) => {
    const tagFirst = isTag2(a);
    const tag = tagFirst ? a : b;
    const evaluate2 = tagFirst ? b : a;
    return fromEffectContext(sync(() => make5(tag, evaluate2())));
  });
  var syncContext = (evaluate2) => {
    return fromEffectContext(sync(evaluate2));
  };
  var tap2 = /* @__PURE__ */ dual(2, (self, f) => flatMap10(self, (context3) => fromEffectContext(as(f(context3), context3))));
  var tapError2 = /* @__PURE__ */ dual(2, (self, f) => catchAll2(self, (e) => fromEffectContext(flatMap8(f(e), () => fail2(e)))));
  var tapErrorCause2 = /* @__PURE__ */ dual(2, (self, f) => catchAllCause2(self, (cause2) => fromEffectContext(flatMap8(f(cause2), () => failCause(cause2)))));
  var toRuntime = (self) => pipe(scopeWith((scope3) => buildWithScope(self, scope3)), flatMap8((context3) => pipe(runtime2(), provideContext(context3))));
  var toRuntimeWithMemoMap = /* @__PURE__ */ dual(2, (self, memoMap) => flatMap8(scopeWith((scope3) => buildWithMemoMap(self, memoMap, scope3)), (context3) => pipe(runtime2(), provideContext(context3))));
  var provide = /* @__PURE__ */ dual(2, (self, that) => suspend2(() => {
    const provideTo = Object.create(proto3);
    provideTo._op_layer = OP_PROVIDE;
    provideTo.first = Object.create(proto3, {
      _op_layer: {
        value: OP_PROVIDE_MERGE,
        enumerable: true
      },
      first: {
        value: context2(),
        enumerable: true
      },
      second: {
        value: Array.isArray(that) ? mergeAll4(...that) : that
      },
      zipK: {
        value: (a, b) => pipe(a, merge3(b))
      }
    });
    provideTo.second = self;
    return provideTo;
  }));
  var provideMerge = /* @__PURE__ */ dual(2, (that, self) => {
    const zipWith4 = Object.create(proto3);
    zipWith4._op_layer = OP_PROVIDE_MERGE;
    zipWith4.first = self;
    zipWith4.second = provide(that, self);
    zipWith4.zipK = (a, b) => {
      return pipe(a, merge3(b));
    };
    return zipWith4;
  });
  var zipWith4 = /* @__PURE__ */ dual(3, (self, that, f) => suspend2(() => {
    const zipWith5 = Object.create(proto3);
    zipWith5._op_layer = OP_ZIP_WITH2;
    zipWith5.first = self;
    zipWith5.second = that;
    zipWith5.zipK = f;
    return zipWith5;
  }));
  var unwrapEffect = (self) => {
    const tag = GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
    return flatMap10(fromEffect3(tag, self), (context3) => get3(context3, tag));
  };
  var unwrapScoped = (self) => {
    const tag = GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
    return flatMap10(scoped(tag, self), (context3) => get3(context3, tag));
  };
  var annotateLogs2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
    const args2 = arguments;
    return fiberRefLocallyWith2(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations2) => Object.entries(args2[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
  });
  var annotateSpans2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
    const args2 = arguments;
    return fiberRefLocallyWith2(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations2) => Object.entries(args2[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
  });
  var withSpan2 = function() {
    const dataFirst = typeof arguments[0] !== "string";
    const name = dataFirst ? arguments[1] : arguments[0];
    const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
    if (dataFirst) {
      const self = arguments[0];
      return unwrapScoped(map10(options?.onEnd ? tap(makeSpanScoped(name, options), (span2) => addFinalizer((exit2) => options.onEnd(span2, exit2))) : makeSpanScoped(name, options), (span2) => withParentSpan2(self, span2)));
    }
    return (self) => unwrapScoped(map10(options?.onEnd ? tap(makeSpanScoped(name, options), (span2) => addFinalizer((exit2) => options.onEnd(span2, exit2))) : makeSpanScoped(name, options), (span2) => withParentSpan2(self, span2)));
  };
  var withParentSpan2 = /* @__PURE__ */ dual(2, (self, span2) => provide(self, succeedContext(make5(spanTag, span2))));
  var provideSomeLayer = /* @__PURE__ */ dual(2, (self, layer) => scopedWith((scope3) => flatMap8(buildWithScope(layer, scope3), (context3) => provideSomeContext(self, context3))));
  var provideSomeRuntime = /* @__PURE__ */ dual(2, (self, rt) => {
    const patchRefs = diff6(defaultRuntime.fiberRefs, rt.fiberRefs);
    const patchFlags = diff4(defaultRuntime.runtimeFlags, rt.runtimeFlags);
    return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
      const oldContext = fiber.getFiberRef(currentContext);
      const oldRefs = fiber.getFiberRefs();
      const newRefs = patch7(fiber.id(), oldRefs)(patchRefs);
      const oldFlags = fiber.currentRuntimeFlags;
      const newFlags = patch4(patchFlags)(oldFlags);
      const rollbackRefs = diff6(newRefs, oldRefs);
      const rollbackFlags = diff4(newFlags, oldFlags);
      fiber.setFiberRefs(newRefs);
      fiber.currentRuntimeFlags = newFlags;
      return ensuring(provideSomeContext(restore(self), merge3(oldContext, rt.context)), withFiberRuntime((fiber2) => {
        fiber2.setFiberRefs(patch7(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
        fiber2.currentRuntimeFlags = patch4(rollbackFlags)(fiber2.currentRuntimeFlags);
        return void_;
      }));
    }));
  });
  var effect_provide = /* @__PURE__ */ dual(2, (self, source) => {
    if (Array.isArray(source)) {
      return provideSomeLayer(self, mergeAll4(...source));
    } else if (isLayer(source)) {
      return provideSomeLayer(self, source);
    } else if (isContext2(source)) {
      return provideSomeContext(self, source);
    } else if (TypeId14 in source) {
      return flatMap8(source.runtimeEffect, (rt) => provideSomeRuntime(self, rt));
    } else {
      return provideSomeRuntime(self, source);
    }
  });

  // node_modules/effect/dist/esm/internal/console.js
  var console2 = /* @__PURE__ */ map10(/* @__PURE__ */ fiberRefGet(currentServices), /* @__PURE__ */ get3(consoleTag));
  var consoleWith = (f) => fiberRefGetWith(currentServices, (services) => f(get3(services, consoleTag)));
  var withConsole = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(effect, currentServices, add2(consoleTag, value)));
  var withConsoleScoped = (console3) => fiberRefLocallyScopedWith(currentServices, add2(consoleTag, console3));

  // node_modules/effect/dist/esm/Data.js
  var Error3 = /* @__PURE__ */ function() {
    const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
    const O = {
      BaseEffectError: class extends YieldableError {
        constructor(args2) {
          super(args2?.message, args2?.cause ? {
            cause: args2.cause
          } : undefined);
          if (args2) {
            Object.assign(this, args2);
            Object.defineProperty(this, plainArgsSymbol, {
              value: args2,
              enumerable: false
            });
          }
        }
        toJSON() {
          return {
            ...this[plainArgsSymbol],
            ...this
          };
        }
      }
    };
    return O.BaseEffectError;
  }();
  var TaggedError = (tag) => {
    const O = {
      BaseEffectError: class extends Error3 {
        _tag = tag;
      }
    };
    O.BaseEffectError.prototype.name = tag;
    return O.BaseEffectError;
  };

  // node_modules/effect/dist/esm/Random.js
  var fixed2 = fixed;

  // node_modules/effect/dist/esm/internal/schedule.js
  var ScheduleSymbolKey = "effect/Schedule";
  var ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
  var isSchedule = (u) => hasProperty(u, ScheduleTypeId);
  var ScheduleDriverSymbolKey = "effect/ScheduleDriver";
  var ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
  var defaultIterationMetadata = {
    start: 0,
    now: 0,
    input: undefined,
    output: undefined,
    elapsed: zero,
    elapsedSincePrevious: zero,
    recurrence: 0
  };
  var CurrentIterationMetadata = /* @__PURE__ */ Reference2()("effect/Schedule/CurrentIterationMetadata", {
    defaultValue: () => defaultIterationMetadata
  });
  var scheduleVariance = {
    _Out: (_) => _,
    _In: (_) => _,
    _R: (_) => _
  };
  var scheduleDriverVariance = {
    _Out: (_) => _,
    _In: (_) => _,
    _R: (_) => _
  };

  class ScheduleImpl {
    initial;
    step;
    [ScheduleTypeId] = scheduleVariance;
    constructor(initial, step3) {
      this.initial = initial;
      this.step = step3;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var updateInfo = (iterationMetaRef, now, input, output) => update2(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
    now,
    input,
    output,
    recurrence: prev.recurrence + 1,
    elapsed: zero,
    elapsedSincePrevious: zero,
    start: now
  } : {
    now,
    input,
    output,
    recurrence: prev.recurrence + 1,
    elapsed: millis(now - prev.start),
    elapsedSincePrevious: millis(now - prev.now),
    start: prev.start
  });

  class ScheduleDriverImpl {
    schedule;
    ref;
    [ScheduleDriverTypeId] = scheduleDriverVariance;
    constructor(schedule, ref) {
      this.schedule = schedule;
      this.ref = ref;
    }
    get state() {
      return map10(get11(this.ref), (tuple) => tuple[1]);
    }
    get last() {
      return flatMap8(get11(this.ref), ([element, _]) => {
        switch (element._tag) {
          case "None": {
            return failSync(() => new NoSuchElementException);
          }
          case "Some": {
            return succeed(element.value);
          }
        }
      });
    }
    iterationMeta = /* @__PURE__ */ unsafeMake6(defaultIterationMetadata);
    get reset() {
      return set5(this.ref, [none2(), this.schedule.initial]).pipe(zipLeft(set5(this.iterationMeta, defaultIterationMetadata)));
    }
    next(input) {
      return pipe(map10(get11(this.ref), (tuple) => tuple[1]), flatMap8((state) => pipe(currentTimeMillis2, flatMap8((now) => pipe(suspend(() => this.schedule.step(now, input, state)), flatMap8(([state2, out, decision]) => {
        const setState = set5(this.ref, [some2(out), state2]);
        if (isDone5(decision)) {
          return setState.pipe(zipRight(fail2(none2())));
        }
        const millis2 = start2(decision.intervals) - now;
        if (millis2 <= 0) {
          return setState.pipe(zipRight(updateInfo(this.iterationMeta, now, input, out)), as(out));
        }
        const duration = millis(millis2);
        return pipe(setState, zipRight(updateInfo(this.iterationMeta, now, input, out)), zipRight(sleep3(duration)), as(out));
      }))))));
    }
  }
  var makeWithState = (initial, step3) => new ScheduleImpl(initial, step3);
  var addDelay = /* @__PURE__ */ dual(2, (self, f) => addDelayEffect(self, (out) => sync(() => f(out))));
  var addDelayEffect = /* @__PURE__ */ dual(2, (self, f) => modifyDelayEffect(self, (out, duration) => map10(f(out), (delay2) => sum(duration, decode(delay2)))));
  var asVoid2 = (self) => map15(self, constVoid);
  var check = /* @__PURE__ */ dual(2, (self, test) => checkEffect(self, (input, out) => sync(() => test(input, out))));
  var checkEffect = /* @__PURE__ */ dual(2, (self, test) => makeWithState(self.initial, (now, input, state) => flatMap8(self.step(now, input, state), ([state2, out, decision]) => {
    if (isDone5(decision)) {
      return succeed([state2, out, done6]);
    }
    return map10(test(input, out), (cont) => cont ? [state2, out, decision] : [state2, out, done6]);
  })));
  var driver = (self) => pipe(make27([none2(), self.initial]), map10((ref) => new ScheduleDriverImpl(self, ref)));
  var intersect5 = /* @__PURE__ */ dual(2, (self, that) => intersectWith(self, that, intersect4));
  var intersectWith = /* @__PURE__ */ dual(3, (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => pipe(zipWith3(self.step(now, input, state[0]), that.step(now, input, state[1]), (a, b) => [a, b]), flatMap8(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
    if (isContinue2(lDecision) && isContinue2(rDecision)) {
      return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
    }
    return succeed([[lState, rState], [out, out2], done6]);
  }))));
  var intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
    const combined = f(lInterval, rInterval);
    if (isNonEmpty5(combined)) {
      return succeed([[lState, rState], [out, out2], _continue2(combined)]);
    }
    if (pipe(lInterval, lessThan5(rInterval))) {
      return flatMap8(self.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
        if (isDone5(decision)) {
          return succeed([[lState2, rState], [out3, out2], done6]);
        }
        return intersectWithLoop(self, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f);
      });
    }
    return flatMap8(that.step(end2(rInterval), input, rState), ([rState2, out22, decision]) => {
      if (isDone5(decision)) {
        return succeed([[lState, rState2], [out, out22], done6]);
      }
      return intersectWithLoop(self, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f);
    });
  };
  var map15 = /* @__PURE__ */ dual(2, (self, f) => mapEffect2(self, (out) => sync(() => f(out))));
  var mapEffect2 = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap8(self.step(now, input, state), ([state2, out, decision]) => map10(f(out), (out2) => [state2, out2, decision]))));
  var modifyDelayEffect = /* @__PURE__ */ dual(2, (self, f) => makeWithState(self.initial, (now, input, state) => flatMap8(self.step(now, input, state), ([state2, out, decision]) => {
    if (isDone5(decision)) {
      return succeed([state2, out, decision]);
    }
    const intervals = decision.intervals;
    const delay2 = size7(make35(now, start2(intervals)));
    return map10(f(out, delay2), (durationInput) => {
      const duration = decode(durationInput);
      const oldStart = start2(intervals);
      const newStart = now + toMillis(duration);
      const delta = newStart - oldStart;
      const newEnd = Math.max(0, end2(intervals) + delta);
      const newInterval = make35(newStart, newEnd);
      return [state2, out, continueWith2(newInterval)];
    });
  })));
  var passthrough2 = (self) => makeWithState(self.initial, (now, input, state) => pipe(self.step(now, input, state), map10(([state2, _, decision]) => [state2, input, decision])));
  var recurs = (n) => whileOutput(forever2, (out) => out < n);
  var spaced = (duration) => addDelay(forever2, () => duration);
  var unfold2 = (initial, f) => makeWithState(initial, (now, _, state) => sync(() => [f(state), state, continueWith2(after2(now))]));
  var untilInputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (input, _) => negate(f(input))));
  var whileInputEffect = /* @__PURE__ */ dual(2, (self, f) => checkEffect(self, (input, _) => f(input)));
  var whileOutput = /* @__PURE__ */ dual(2, (self, f) => check(self, (_, out) => f(out)));
  var ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");

  class ScheduleDefect {
    error;
    [ScheduleDefectTypeId];
    constructor(error) {
      this.error = error;
      this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
    }
  }
  var isScheduleDefect = (u) => hasProperty(u, ScheduleDefectTypeId);
  var scheduleDefectWrap = (self) => catchAll(self, (e) => die2(new ScheduleDefect(e)));
  var scheduleDefectRefailCause = (cause2) => match2(find(cause2, (_) => isDieType(_) && isScheduleDefect(_.defect) ? some2(_.defect) : none2()), {
    onNone: () => cause2,
    onSome: (error) => fail(error.error)
  });
  var scheduleDefectRefail = (effect) => catchAllCause(effect, (cause2) => failCause(scheduleDefectRefailCause(cause2)));
  var repeat_Effect = /* @__PURE__ */ dual(2, (self, schedule) => repeatOrElse_Effect(self, schedule, (e, _) => fail2(e)));
  var repeat_combined = /* @__PURE__ */ dual(2, (self, options) => {
    if (isSchedule(options)) {
      return repeat_Effect(self, options);
    }
    const base = options.schedule ?? passthrough2(forever2);
    const withWhile = options.while ? whileInputEffect(base, (a) => {
      const applied = options.while(a);
      if (typeof applied === "boolean") {
        return succeed(applied);
      }
      return scheduleDefectWrap(applied);
    }) : base;
    const withUntil = options.until ? untilInputEffect(withWhile, (a) => {
      const applied = options.until(a);
      if (typeof applied === "boolean") {
        return succeed(applied);
      }
      return scheduleDefectWrap(applied);
    }) : withWhile;
    const withTimes = options.times ? intersect5(withUntil, recurs(options.times)).pipe(map15((intersectionPair) => intersectionPair[0])) : withUntil;
    return scheduleDefectRefail(repeat_Effect(self, withTimes));
  });
  var repeatOrElse_Effect = /* @__PURE__ */ dual(3, (self, schedule, orElse5) => flatMap8(driver(schedule), (driver2) => matchEffect(self, {
    onFailure: (error) => orElse5(error, none2()),
    onSuccess: (value) => repeatOrElseEffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get11(driver2.iterationMeta)), driver2, (error, option2) => provideServiceEffect(orElse5(error, option2), CurrentIterationMetadata, get11(driver2.iterationMeta)), value)
  })));
  var repeatOrElseEffectLoop = (self, driver2, orElse5, value) => matchEffect(driver2.next(value), {
    onFailure: () => orDie(driver2.last),
    onSuccess: (b) => matchEffect(self, {
      onFailure: (error) => orElse5(error, some2(b)),
      onSuccess: (value2) => repeatOrElseEffectLoop(self, driver2, orElse5, value2)
    })
  });
  var retry_Effect = /* @__PURE__ */ dual(2, (self, policy) => retryOrElse_Effect(self, policy, (e, _) => fail2(e)));
  var retry_combined = /* @__PURE__ */ dual(2, (self, options) => {
    if (isSchedule(options)) {
      return retry_Effect(self, options);
    }
    return scheduleDefectRefail(retry_Effect(self, fromRetryOptions(options)));
  });
  var fromRetryOptions = (options) => {
    const base = options.schedule ?? forever2;
    const withWhile = options.while ? whileInputEffect(base, (e) => {
      const applied = options.while(e);
      if (typeof applied === "boolean") {
        return succeed(applied);
      }
      return scheduleDefectWrap(applied);
    }) : base;
    const withUntil = options.until ? untilInputEffect(withWhile, (e) => {
      const applied = options.until(e);
      if (typeof applied === "boolean") {
        return succeed(applied);
      }
      return scheduleDefectWrap(applied);
    }) : withWhile;
    return options.times ? intersect5(withUntil, recurs(options.times)) : withUntil;
  };
  var retryOrElse_Effect = /* @__PURE__ */ dual(3, (self, policy, orElse5) => flatMap8(driver(policy), (driver2) => retryOrElse_EffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get11(driver2.iterationMeta)), driver2, (e, out) => provideServiceEffect(orElse5(e, out), CurrentIterationMetadata, get11(driver2.iterationMeta)))));
  var retryOrElse_EffectLoop = (self, driver2, orElse5) => {
    return catchAll(self, (e) => matchEffect(driver2.next(e), {
      onFailure: () => pipe(driver2.last, orDie, flatMap8((out) => orElse5(e, out))),
      onSuccess: () => retryOrElse_EffectLoop(self, driver2, orElse5)
    }));
  };
  var schedule_Effect = /* @__PURE__ */ dual(2, (self, schedule) => scheduleFrom_Effect(self, undefined, schedule));
  var scheduleFrom_Effect = /* @__PURE__ */ dual(3, (self, initial, schedule) => flatMap8(driver(schedule), (driver2) => scheduleFrom_EffectLoop(provideServiceEffect(self, CurrentIterationMetadata, get11(driver2.iterationMeta)), initial, driver2)));
  var scheduleFrom_EffectLoop = (self, initial, driver2) => matchEffect(driver2.next(initial), {
    onFailure: () => orDie(driver2.last),
    onSuccess: () => flatMap8(self, (a) => scheduleFrom_EffectLoop(self, a, driver2))
  });
  var forever2 = /* @__PURE__ */ unfold2(0, (n) => n + 1);
  var once2 = /* @__PURE__ */ asVoid2(/* @__PURE__ */ recurs(1));
  var scheduleForked = /* @__PURE__ */ dual(2, (self, schedule) => forkScoped(schedule_Effect(self, schedule)));

  // node_modules/effect/dist/esm/internal/executionPlan.js
  var withExecutionPlan = /* @__PURE__ */ dual(2, (effect, plan) => suspend(() => {
    let i = 0;
    let result;
    return flatMap8(whileLoop({
      while: () => i < plan.steps.length && (result === undefined || isLeft2(result)),
      body: () => {
        const step3 = plan.steps[i];
        let nextEffect = effect_provide(effect, step3.provide);
        if (result) {
          let attempted = false;
          const wrapped = nextEffect;
          nextEffect = suspend(() => {
            if (attempted)
              return wrapped;
            attempted = true;
            return result;
          });
          nextEffect = scheduleDefectRefail(retry_Effect(nextEffect, scheduleFromStep(step3, false)));
        } else {
          const schedule = scheduleFromStep(step3, true);
          nextEffect = schedule ? scheduleDefectRefail(retry_Effect(nextEffect, schedule)) : nextEffect;
        }
        return either2(nextEffect);
      },
      step: (either3) => {
        result = either3;
        i++;
      }
    }), () => result);
  }));
  var scheduleFromStep = (step3, first) => {
    if (!first) {
      return fromRetryOptions({
        schedule: step3.schedule ? step3.schedule : step3.attempts ? undefined : once2,
        times: step3.attempts,
        while: step3.while
      });
    } else if (step3.attempts === 1 || !(step3.schedule || step3.attempts)) {
      return;
    }
    return fromRetryOptions({
      schedule: step3.schedule,
      while: step3.while,
      times: step3.attempts ? step3.attempts - 1 : undefined
    });
  };

  // node_modules/effect/dist/esm/internal/query.js
  var currentCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map10(deferredMake(), (handle) => ({
    listeners: new Listeners,
    handle
  })), () => seconds(60))));
  var currentCacheEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
  var fromRequest = (request, dataSource) => flatMap8(isEffect(dataSource) ? dataSource : succeed(dataSource), (ds) => fiberIdWith((id2) => {
    const proxy = new Proxy(request, {});
    return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
      if (cacheEnabled) {
        const cached3 = fiberRefGetWith(currentCache, (cache) => flatMap8(cache.getEither(proxy), (orNew) => {
          switch (orNew._tag) {
            case "Left": {
              if (orNew.left.listeners.interrupted) {
                return flatMap8(cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached3);
              }
              orNew.left.listeners.increment();
              return uninterruptibleMask((restore) => flatMap8(exit(blocked(empty15, restore(deferredAwait(orNew.left.handle)))), (exit2) => {
                orNew.left.listeners.decrement();
                return exit2;
              }));
            }
            case "Right": {
              orNew.right.listeners.increment();
              return uninterruptibleMask((restore) => flatMap8(exit(blocked(single(ds, makeEntry({
                request: proxy,
                result: orNew.right.handle,
                listeners: orNew.right.listeners,
                ownerId: id2,
                state: {
                  completed: false
                }
              })), restore(deferredAwait(orNew.right.handle)))), () => {
                orNew.right.listeners.decrement();
                return deferredAwait(orNew.right.handle);
              }));
            }
          }
        }));
        return cached3;
      }
      const listeners = new Listeners;
      listeners.increment();
      return flatMap8(deferredMake(), (ref) => ensuring(blocked(single(ds, makeEntry({
        request: proxy,
        result: ref,
        listeners,
        ownerId: id2,
        state: {
          completed: false
        }
      })), deferredAwait(ref)), sync(() => listeners.decrement())));
    });
  }));
  var cacheRequest = (request, result) => {
    return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
      if (cacheEnabled) {
        return fiberRefGetWith(currentCache, (cache) => flatMap8(cache.getEither(request), (orNew) => {
          switch (orNew._tag) {
            case "Left": {
              return void_;
            }
            case "Right": {
              return deferredComplete(orNew.right.handle, result);
            }
          }
        }));
      }
      return void_;
    });
  };
  var withRequestCaching = /* @__PURE__ */ dual(2, (self, strategy) => fiberRefLocally(self, currentCacheEnabled, strategy));
  var withRequestCache = /* @__PURE__ */ dual(2, (self, cache) => fiberRefLocally(self, currentCache, cache));

  // node_modules/effect/dist/esm/Request.js
  var isRequest2 = isRequest;

  // node_modules/effect/dist/esm/Effect.js
  var EffectTypeId3 = EffectTypeId2;
  var isEffect2 = isEffect;
  var cachedWithTTL = cached2;
  var cachedInvalidateWithTTL2 = cachedInvalidateWithTTL;
  var cached3 = memoize;
  var cachedFunction2 = cachedFunction;
  var once3 = once;
  var all4 = all3;
  var allWith2 = allWith;
  var allSuccesses2 = allSuccesses;
  var dropUntil2 = dropUntil;
  var dropWhile3 = dropWhile2;
  var takeUntil2 = takeUntil;
  var takeWhile3 = takeWhile2;
  var every6 = every5;
  var exists3 = exists2;
  var filter7 = filter5;
  var filterMap5 = filterMap4;
  var findFirst6 = findFirst5;
  var forEach6 = forEach5;
  var head4 = head3;
  var mergeAll5 = mergeAll3;
  var partition4 = partition3;
  var reduce10 = reduce9;
  var reduceWhile2 = reduceWhile;
  var reduceRight4 = reduceRight3;
  var reduceEffect2 = reduceEffect;
  var replicate2 = replicate;
  var replicateEffect2 = replicateEffect;
  var validateAll2 = validateAll;
  var validateFirst2 = validateFirst;
  var async = async_;
  var asyncEffect2 = asyncEffect;
  var custom2 = custom;
  var withFiberRuntime2 = withFiberRuntime;
  var fail9 = fail2;
  var failSync3 = failSync;
  var failCause8 = failCause;
  var failCauseSync3 = failCauseSync;
  var die6 = die2;
  var dieMessage2 = dieMessage;
  var dieSync3 = dieSync;
  var gen2 = gen;
  var never3 = never;
  var none9 = none6;
  var promise2 = promise;
  var succeed8 = succeed;
  var succeedNone2 = succeedNone;
  var succeedSome2 = succeedSome;
  var suspend3 = suspend;
  var sync3 = sync;
  var _void = void_;
  var yieldNow4 = yieldNow;
  var _catch2 = _catch;
  var catchAll3 = catchAll;
  var catchAllCause3 = catchAllCause;
  var catchAllDefect2 = catchAllDefect;
  var catchIf2 = catchIf;
  var catchSome2 = catchSome;
  var catchSomeCause2 = catchSomeCause;
  var catchSomeDefect2 = catchSomeDefect;
  var catchTag2 = catchTag;
  var catchTags2 = catchTags;
  var cause2 = cause;
  var eventually2 = eventually;
  var ignore2 = ignore;
  var ignoreLogged2 = ignoreLogged;
  var parallelErrors2 = parallelErrors;
  var sandbox2 = sandbox;
  var retry2 = retry_combined;
  var withExecutionPlan2 = withExecutionPlan;
  var retryOrElse = retryOrElse_Effect;
  var try_2 = try_;
  var tryMap2 = tryMap;
  var tryMapPromise2 = tryMapPromise;
  var tryPromise2 = tryPromise;
  var unsandbox2 = unsandbox;
  var allowInterrupt2 = allowInterrupt;
  var checkInterruptible2 = checkInterruptible;
  var disconnect2 = disconnect;
  var interrupt7 = interrupt2;
  var interruptWith2 = interruptWith;
  var interruptible4 = interruptible2;
  var interruptibleMask2 = interruptibleMask;
  var onInterrupt2 = onInterrupt;
  var uninterruptible2 = uninterruptible;
  var uninterruptibleMask3 = uninterruptibleMask;
  var liftPredicate2 = liftPredicate;
  var as3 = as;
  var asSome2 = asSome;
  var asSomeError2 = asSomeError;
  var asVoid3 = asVoid;
  var flip2 = flip;
  var flipWith2 = flipWith;
  var map16 = map10;
  var mapAccum4 = mapAccum3;
  var mapBoth3 = mapBoth;
  var mapError3 = mapError;
  var mapErrorCause2 = mapErrorCause;
  var merge7 = merge5;
  var negate2 = negate;
  var acquireRelease2 = acquireRelease;
  var acquireReleaseInterruptible2 = acquireReleaseInterruptible;
  var acquireUseRelease2 = acquireUseRelease;
  var addFinalizer3 = addFinalizer;
  var ensuring2 = ensuring;
  var onError2 = onError;
  var onExit3 = onExit;
  var parallelFinalizers2 = parallelFinalizers;
  var sequentialFinalizers2 = sequentialFinalizers;
  var finalizersMask2 = finalizersMask;
  var scope3 = scope;
  var scopeWith2 = scopeWith;
  var scopedWith2 = scopedWith;
  var scoped2 = scopedEffect;
  var using2 = using;
  var withEarlyRelease2 = withEarlyRelease;
  var awaitAllChildren2 = awaitAllChildren;
  var daemonChildren2 = daemonChildren;
  var descriptor2 = descriptor;
  var descriptorWith2 = descriptorWith;
  var diffFiberRefs2 = diffFiberRefs;
  var ensuringChild2 = ensuringChild;
  var ensuringChildren2 = ensuringChildren;
  var fiberId2 = fiberId;
  var fiberIdWith2 = fiberIdWith;
  var fork3 = fork;
  var forkDaemon2 = forkDaemon;
  var forkAll2 = forkAll;
  var forkIn2 = forkIn;
  var forkScoped2 = forkScoped;
  var forkWithErrorHandler2 = forkWithErrorHandler;
  var fromFiber2 = fromFiber;
  var fromFiberEffect2 = fromFiberEffect;
  var supervised2 = supervised;
  var transplant2 = transplant;
  var withConcurrency2 = withConcurrency;
  var withScheduler2 = withScheduler;
  var withSchedulingPriority2 = withSchedulingPriority;
  var withMaxOpsBeforeYield2 = withMaxOpsBeforeYield;
  var clock2 = clock;
  var clockWith4 = clockWith3;
  var withClockScoped2 = withClockScoped;
  var withClock2 = withClock;
  var console3 = console2;
  var consoleWith2 = consoleWith;
  var withConsoleScoped2 = withConsoleScoped;
  var withConsole2 = withConsole;
  var delay2 = delay;
  var sleep4 = sleep3;
  var timed2 = timed;
  var timedWith2 = timedWith;
  var timeout2 = timeout;
  var timeoutOption2 = timeoutOption;
  var timeoutFail2 = timeoutFail;
  var timeoutFailCause2 = timeoutFailCause;
  var timeoutTo2 = timeoutTo;
  var configProviderWith2 = configProviderWith;
  var withConfigProvider2 = withConfigProvider;
  var withConfigProviderScoped2 = withConfigProviderScoped;
  var context3 = context;
  var contextWith2 = contextWith;
  var contextWithEffect2 = contextWithEffect;
  var mapInputContext2 = mapInputContext;
  var provide2 = effect_provide;
  var provideService2 = provideService;
  var provideServiceEffect2 = provideServiceEffect;
  var serviceFunction2 = serviceFunction;
  var serviceFunctionEffect2 = serviceFunctionEffect;
  var serviceFunctions2 = serviceFunctions;
  var serviceConstants2 = serviceConstants;
  var serviceMembers2 = serviceMembers;
  var serviceOption2 = serviceOption;
  var serviceOptional2 = serviceOptional;
  var updateService2 = updateService;
  var Do2 = Do;
  var bind3 = bind2;
  var bindAll2 = bindAll;
  var bindTo3 = bindTo2;
  var let_3 = let_2;
  var option2 = option;
  var either3 = either2;
  var exit2 = exit;
  var intoDeferred2 = intoDeferred;
  var if_2 = if_;
  var filterOrDie2 = filterOrDie;
  var filterOrDieMessage2 = filterOrDieMessage;
  var filterOrElse2 = filterOrElse;
  var filterOrFail2 = filterOrFail;
  var filterEffectOrElse2 = filterEffectOrElse;
  var filterEffectOrFail2 = filterEffectOrFail;
  var unless2 = unless;
  var unlessEffect2 = unlessEffect;
  var when2 = when;
  var whenEffect2 = whenEffect;
  var whenFiberRef2 = whenFiberRef;
  var whenRef2 = whenRef;
  var flatMap11 = flatMap8;
  var andThen4 = andThen2;
  var flatten9 = flatten6;
  var race2 = race;
  var raceAll2 = raceAll;
  var raceFirst2 = raceFirst;
  var raceWith2 = raceWith;
  var summarized2 = summarized;
  var tap3 = tap;
  var tapBoth2 = tapBoth;
  var tapDefect2 = tapDefect;
  var tapError3 = tapError;
  var tapErrorTag2 = tapErrorTag;
  var tapErrorCause3 = tapErrorCause;
  var forever3 = forever;
  var iterate2 = iterate;
  var loop2 = loop;
  var repeat = repeat_combined;
  var repeatN2 = repeatN;
  var repeatOrElse = repeatOrElse_Effect;
  var schedule = schedule_Effect;
  var scheduleForked2 = scheduleForked;
  var scheduleFrom = scheduleFrom_Effect;
  var whileLoop2 = whileLoop;
  var getFiberRefs = fiberRefs2;
  var inheritFiberRefs2 = inheritFiberRefs;
  var locally = fiberRefLocally;
  var locallyWith = fiberRefLocallyWith;
  var locallyScoped = fiberRefLocallyScoped;
  var locallyScopedWith = fiberRefLocallyScopedWith;
  var patchFiberRefs2 = patchFiberRefs;
  var setFiberRefs2 = setFiberRefs;
  var updateFiberRefs2 = updateFiberRefs;
  var isFailure4 = isFailure2;
  var isSuccess3 = isSuccess2;
  var match12 = match7;
  var matchCause3 = matchCause;
  var matchCauseEffect3 = matchCauseEffect;
  var matchEffect2 = matchEffect;
  var log2 = log;
  var logWithLevel2 = (level, ...message) => logWithLevel(level)(...message);
  var logTrace2 = logTrace;
  var logDebug2 = logDebug;
  var logInfo2 = logInfo;
  var logWarning2 = logWarning;
  var logError2 = logError;
  var logFatal2 = logFatal;
  var withLogSpan2 = withLogSpan;
  var annotateLogs3 = annotateLogs;
  var annotateLogsScoped2 = annotateLogsScoped;
  var logAnnotations2 = logAnnotations;
  var withUnhandledErrorLogLevel2 = withUnhandledErrorLogLevel;
  var whenLogLevel2 = whenLogLevel;
  var orDie3 = orDie;
  var orDieWith2 = orDieWith;
  var orElse5 = orElse2;
  var orElseFail2 = orElseFail;
  var orElseSucceed2 = orElseSucceed;
  var firstSuccessOf2 = firstSuccessOf;
  var random3 = random2;
  var randomWith2 = randomWith;
  var withRandom2 = withRandom;
  var withRandomFixed = /* @__PURE__ */ dual(2, (effect, values3) => withRandom2(effect, fixed2(values3)));
  var withRandomScoped2 = withRandomScoped;
  var runtime3 = runtime2;
  var getRuntimeFlags = runtimeFlags;
  var patchRuntimeFlags = updateRuntimeFlags;
  var withRuntimeFlagsPatch = withRuntimeFlags;
  var withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
  var tagMetrics2 = tagMetrics;
  var labelMetrics2 = labelMetrics;
  var tagMetricsScoped2 = tagMetricsScoped;
  var labelMetricsScoped2 = labelMetricsScoped;
  var metricLabels2 = metricLabels;
  var withMetric2 = withMetric;
  var unsafeMakeSemaphore2 = unsafeMakeSemaphore;
  var makeSemaphore2 = makeSemaphore;
  var unsafeMakeLatch2 = unsafeMakeLatch;
  var makeLatch2 = makeLatch;
  var runFork2 = unsafeForkEffect;
  var runCallback = unsafeRunEffect;
  var runPromise = unsafeRunPromiseEffect;
  var runPromiseExit = unsafeRunPromiseExitEffect;
  var runSync = unsafeRunSyncEffect;
  var runSyncExit = unsafeRunSyncExitEffect;
  var validate2 = validate;
  var validateWith2 = validateWith;
  var zip5 = zipOptions;
  var zipLeft2 = zipLeftOptions;
  var zipRight3 = zipRightOptions;
  var zipWith5 = zipWithOptions;
  var ap = /* @__PURE__ */ dual(2, (self, that) => zipWith5(self, that, (f, a) => f(a)));
  var blocked2 = blocked;
  var runRequestBlock2 = runRequestBlock;
  var step3 = step2;
  var request = /* @__PURE__ */ dual((args2) => isRequest2(args2[0]), fromRequest);
  var cacheRequestResult = cacheRequest;
  var withRequestBatching2 = withRequestBatching;
  var withRequestCaching2 = withRequestCaching;
  var withRequestCache2 = withRequestCache;
  var tracer2 = tracer;
  var tracerWith4 = tracerWith;
  var withTracer2 = withTracer;
  var withTracerScoped2 = withTracerScoped;
  var withTracerEnabled2 = withTracerEnabled;
  var withTracerTiming2 = withTracerTiming;
  var annotateSpans3 = annotateSpans;
  var annotateCurrentSpan2 = annotateCurrentSpan;
  var currentSpan2 = currentSpan;
  var currentParentSpan2 = currentParentSpan;
  var spanAnnotations2 = spanAnnotations;
  var spanLinks2 = spanLinks;
  var linkSpans2 = linkSpans;
  var linkSpanCurrent2 = linkSpanCurrent;
  var makeSpan2 = makeSpan;
  var makeSpanScoped2 = makeSpanScoped;
  var useSpan2 = useSpan;
  var withSpan3 = withSpan;
  var functionWithSpan2 = functionWithSpan;
  var withSpanScoped2 = withSpanScoped;
  var withParentSpan3 = withParentSpan;
  var fromNullable3 = fromNullable2;
  var optionFromOptional2 = optionFromOptional;
  var transposeOption = (self) => {
    return isNone(self) ? succeedNone2 : map16(self.value, some);
  };
  var transposeMapOption = /* @__PURE__ */ dual(2, (self, f) => isNone(self) ? succeedNone2 : map16(f(self.value), some));
  var makeTagProxy = (TagClass) => {
    const cache = new Map;
    return new Proxy(TagClass, {
      get(target, prop, receiver) {
        if (prop in target) {
          return Reflect.get(target, prop, receiver);
        }
        if (cache.has(prop)) {
          return cache.get(prop);
        }
        const fn = (...args2) => andThen2(target, (s) => {
          if (typeof s[prop] === "function") {
            cache.set(prop, (...args3) => andThen2(target, (s2) => s2[prop](...args3)));
            return s[prop](...args2);
          }
          cache.set(prop, andThen2(target, (s2) => s2[prop]));
          return s[prop];
        });
        const cn = andThen2(target, (s) => s[prop]);
        Object.assign(fn, cn);
        const apply = fn.apply;
        const bind4 = fn.bind;
        const call = fn.call;
        const proto4 = Object.setPrototypeOf({}, Object.getPrototypeOf(cn));
        proto4.apply = apply;
        proto4.bind = bind4;
        proto4.call = call;
        Object.setPrototypeOf(fn, proto4);
        cache.set(prop, fn);
        return fn;
      }
    });
  };
  var Tag3 = (id2) => () => {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error;
    Error.stackTraceLimit = limit;
    function TagClass() {}
    Object.setPrototypeOf(TagClass, TagProto);
    TagClass.key = id2;
    Object.defineProperty(TagClass, "use", {
      get() {
        return (body) => andThen2(this, body);
      }
    });
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    return makeTagProxy(TagClass);
  };
  var Service = function() {
    return function() {
      const [id2, maker] = arguments;
      const proxy = "accessors" in maker ? maker["accessors"] : false;
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const creationError = new Error;
      Error.stackTraceLimit = limit;
      let patchState = "unchecked";
      const TagClass = function(service2) {
        if (patchState === "unchecked") {
          const proto4 = Object.getPrototypeOf(service2);
          if (proto4 === Object.prototype || proto4 === null) {
            patchState = "plain";
          } else {
            const selfProto = Object.getPrototypeOf(this);
            Object.setPrototypeOf(selfProto, proto4);
            patchState = "patched";
          }
        }
        if (patchState === "plain") {
          Object.assign(this, service2);
        } else if (patchState === "patched") {
          Object.setPrototypeOf(service2, Object.getPrototypeOf(this));
          return service2;
        }
      };
      TagClass.prototype._tag = id2;
      Object.defineProperty(TagClass, "make", {
        get() {
          return (service2) => new this(service2);
        }
      });
      Object.defineProperty(TagClass, "use", {
        get() {
          return (body) => andThen2(this, body);
        }
      });
      TagClass.key = id2;
      Object.assign(TagClass, TagProto);
      Object.defineProperty(TagClass, "stack", {
        get() {
          return creationError.stack;
        }
      });
      const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
      const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
      let layerCache;
      let isFunction3 = false;
      if ("effect" in maker) {
        isFunction3 = typeof maker.effect === "function";
        Object.defineProperty(TagClass, layerName, {
          get() {
            if (isFunction3) {
              return function() {
                return fromEffect3(TagClass, map16(maker.effect.apply(null, arguments), (_) => new this(_)));
              }.bind(this);
            }
            return layerCache ??= fromEffect3(TagClass, map16(maker.effect, (_) => new this(_)));
          }
        });
      } else if ("scoped" in maker) {
        isFunction3 = typeof maker.scoped === "function";
        Object.defineProperty(TagClass, layerName, {
          get() {
            if (isFunction3) {
              return function() {
                return scoped(TagClass, map16(maker.scoped.apply(null, arguments), (_) => new this(_)));
              }.bind(this);
            }
            return layerCache ??= scoped(TagClass, map16(maker.scoped, (_) => new this(_)));
          }
        });
      } else if ("sync" in maker) {
        Object.defineProperty(TagClass, layerName, {
          get() {
            return layerCache ??= sync2(TagClass, () => new this(maker.sync()));
          }
        });
      } else {
        Object.defineProperty(TagClass, layerName, {
          get() {
            return layerCache ??= succeed6(TagClass, new this(maker.succeed));
          }
        });
      }
      if (hasDeps) {
        let layerWithDepsCache;
        Object.defineProperty(TagClass, "Default", {
          get() {
            if (isFunction3) {
              return function() {
                return provide(this.DefaultWithoutDependencies.apply(null, arguments), maker.dependencies);
              };
            }
            return layerWithDepsCache ??= provide(this.DefaultWithoutDependencies, maker.dependencies);
          }
        });
      }
      return proxy === true ? makeTagProxy(TagClass) : TagClass;
    };
  };
  var fn = function(nameOrBody, ...pipeables) {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const errorDef = new Error;
    Error.stackTraceLimit = limit;
    if (typeof nameOrBody !== "string") {
      return defineLength(nameOrBody.length, function(...args2) {
        const limit2 = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        const errorCall = new Error;
        Error.stackTraceLimit = limit2;
        return fnApply({
          self: this,
          body: nameOrBody,
          args: args2,
          pipeables,
          spanName: "<anonymous>",
          spanOptions: {
            context: DisablePropagation.context(true)
          },
          errorDef,
          errorCall
        });
      });
    }
    const name = nameOrBody;
    const options = pipeables[0];
    return (body, ...pipeables2) => defineLength(body.length, {
      [name](...args2) {
        const limit2 = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        const errorCall = new Error;
        Error.stackTraceLimit = limit2;
        return fnApply({
          self: this,
          body,
          args: args2,
          pipeables: pipeables2,
          spanName: name,
          spanOptions: options,
          errorDef,
          errorCall
        });
      }
    }[name]);
  };
  function defineLength(length3, fn2) {
    return Object.defineProperty(fn2, "length", {
      value: length3,
      configurable: true
    });
  }
  function fnApply(options) {
    let effect;
    let fnError = undefined;
    if (isGeneratorFunction(options.body)) {
      effect = fromIterator(() => options.body.apply(options.self, options.args));
    } else {
      try {
        effect = options.body.apply(options.self, options.args);
      } catch (error) {
        fnError = error;
        effect = die6(error);
      }
    }
    if (options.pipeables.length > 0) {
      try {
        for (const x of options.pipeables) {
          effect = x(effect, ...options.args);
        }
      } catch (error) {
        effect = fnError ? failCause8(sequential(die(fnError), die(error))) : die6(error);
      }
    }
    let cache = false;
    const captureStackTrace = () => {
      if (cache !== false) {
        return cache;
      }
      if (options.errorCall.stack) {
        const stackDef = options.errorDef.stack.trim().split(`
`);
        const stackCall = options.errorCall.stack.trim().split(`
`);
        let endStackDef = stackDef.slice(2).join(`
`).trim();
        if (!endStackDef.includes(`(`)) {
          endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
        }
        let endStackCall = stackCall.slice(2).join(`
`).trim();
        if (!endStackCall.includes(`(`)) {
          endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
        }
        cache = `${endStackDef}
${endStackCall}`;
        return cache;
      }
    };
    const opts = options.spanOptions && "captureStackTrace" in options.spanOptions ? options.spanOptions : {
      captureStackTrace,
      ...options.spanOptions
    };
    return withSpan3(effect, options.spanName, opts);
  }
  var fnUntraced2 = fnUntraced;
  var ensureSuccessType = () => (effect) => effect;
  var ensureErrorType = () => (effect) => effect;
  var ensureRequirementsType = () => (effect) => effect;

  // node_modules/effect/dist/esm/FiberRef.js
  var get13 = fiberRefGet;
  var getWith = fiberRefGetWith;
  var currentContext2 = currentContext;
  var currentSchedulingPriority2 = currentSchedulingPriority;
  var currentScheduler2 = currentScheduler;
  var currentTracerTimingEnabled2 = currentTracerTimingEnabled;

  // node_modules/effect/dist/esm/Layer.js
  var exports_Layer = {};
  __export(exports_Layer, {
    zipWith: () => zipWith6,
    withSpan: () => withSpan4,
    withParentSpan: () => withParentSpan4,
    updateService: () => updateService3,
    unwrapScoped: () => unwrapScoped2,
    unwrapEffect: () => unwrapEffect2,
    toRuntimeWithMemoMap: () => toRuntimeWithMemoMap2,
    toRuntime: () => toRuntime2,
    tapErrorCause: () => tapErrorCause4,
    tapError: () => tapError4,
    tap: () => tap4,
    syncContext: () => syncContext2,
    sync: () => sync4,
    suspend: () => suspend4,
    succeedContext: () => succeedContext2,
    succeed: () => succeed9,
    span: () => span3,
    setVersionMismatchErrorLogLevel: () => setVersionMismatchErrorLogLevel,
    setUnhandledErrorLogLevel: () => setUnhandledErrorLogLevel,
    setTracerTiming: () => setTracerTiming,
    setTracerEnabled: () => setTracerEnabled,
    setTracer: () => setTracer2,
    setScheduler: () => setScheduler,
    setRequestCaching: () => setRequestCaching,
    setRequestCache: () => setRequestCache,
    setRequestBatching: () => setRequestBatching,
    setRandom: () => setRandom,
    setConfigProvider: () => setConfigProvider2,
    setClock: () => setClock,
    service: () => service2,
    scopedDiscard: () => scopedDiscard2,
    scopedContext: () => scopedContext2,
    scoped: () => scoped3,
    scope: () => scope4,
    retry: () => retry3,
    provideMerge: () => provideMerge2,
    provide: () => provide3,
    project: () => project2,
    passthrough: () => passthrough3,
    parentSpan: () => parentSpan2,
    orElse: () => orElse6,
    orDie: () => orDie4,
    mock: () => mock2,
    mergeAll: () => mergeAll6,
    merge: () => merge8,
    memoize: () => memoize3,
    matchCause: () => matchCause4,
    match: () => match13,
    mapError: () => mapError4,
    map: () => map17,
    makeMemoMap: () => makeMemoMap2,
    locallyWith: () => locallyWith2,
    locallyScoped: () => locallyScoped2,
    locallyEffect: () => locallyEffect2,
    locally: () => locally2,
    launch: () => launch2,
    isLayer: () => isLayer2,
    isFresh: () => isFresh2,
    function: () => fromFunction2,
    fresh: () => fresh2,
    flatten: () => flatten10,
    flatMap: () => flatMap12,
    fiberRefLocallyScopedWith: () => fiberRefLocallyScopedWith3,
    failSync: () => failSync4,
    failCauseSync: () => failCauseSync4,
    failCause: () => failCause9,
    fail: () => fail10,
    extendScope: () => extendScope2,
    empty: () => empty28,
    effectDiscard: () => effectDiscard,
    effectContext: () => effectContext,
    effect: () => effect,
    discard: () => discard2,
    dieSync: () => dieSync4,
    die: () => die7,
    context: () => context4,
    catchAllCause: () => catchAllCause4,
    catchAll: () => catchAll4,
    buildWithScope: () => buildWithScope2,
    buildWithMemoMap: () => buildWithMemoMap2,
    build: () => build2,
    annotateSpans: () => annotateSpans4,
    annotateLogs: () => annotateLogs4,
    MemoMapTypeId: () => MemoMapTypeId2,
    LayerTypeId: () => LayerTypeId2,
    CurrentMemoMap: () => CurrentMemoMap2
  });

  // node_modules/effect/dist/esm/internal/layer/circular.js
  var setConfigProvider = (configProvider) => scopedDiscard(withConfigProviderScoped(configProvider));
  var parentSpan = (span2) => succeedContext(make5(spanTag, span2));
  var span2 = (name, options) => {
    options = addSpanStackTrace(options);
    return scoped(spanTag, options?.onEnd ? tap(makeSpanScoped(name, options), (span3) => addFinalizer((exit3) => options.onEnd(span3, exit3))) : makeSpanScoped(name, options));
  };
  var setTracer = (tracer3) => scopedDiscard(withTracerScoped(tracer3));

  // node_modules/effect/dist/esm/Layer.js
  var LayerTypeId2 = LayerTypeId;
  var MemoMapTypeId2 = MemoMapTypeId;
  var CurrentMemoMap2 = CurrentMemoMap;
  var isLayer2 = isLayer;
  var isFresh2 = isFresh;
  var annotateLogs4 = annotateLogs2;
  var annotateSpans4 = annotateSpans2;
  var build2 = build;
  var buildWithScope2 = buildWithScope;
  var catchAll4 = catchAll2;
  var catchAllCause4 = catchAllCause2;
  var context4 = context2;
  var die7 = die5;
  var dieSync4 = dieSync2;
  var discard2 = discard;
  var effect = fromEffect3;
  var effectDiscard = fromEffectDiscard;
  var effectContext = fromEffectContext;
  var empty28 = empty27;
  var extendScope2 = extendScope;
  var fail10 = fail7;
  var failSync4 = failSync2;
  var failCause9 = failCause6;
  var failCauseSync4 = failCauseSync2;
  var flatMap12 = flatMap10;
  var flatten10 = flatten8;
  var fresh2 = fresh;
  var mock2 = mock;
  var fromFunction2 = fromFunction;
  var launch2 = launch;
  var map17 = map14;
  var mapError4 = mapError2;
  var match13 = match11;
  var matchCause4 = matchCause2;
  var memoize3 = memoize2;
  var merge8 = merge6;
  var mergeAll6 = mergeAll4;
  var orDie4 = orDie2;
  var orElse6 = orElse4;
  var passthrough3 = passthrough;
  var project2 = project;
  var locallyEffect2 = locallyEffect;
  var locally2 = fiberRefLocally2;
  var locallyWith2 = fiberRefLocallyWith2;
  var locallyScoped2 = fiberRefLocallyScoped2;
  var fiberRefLocallyScopedWith3 = fiberRefLocallyScopedWith2;
  var retry3 = retry;
  var scope4 = scope2;
  var scoped3 = scoped;
  var scopedDiscard2 = scopedDiscard;
  var scopedContext2 = scopedContext;
  var service2 = service;
  var succeed9 = succeed6;
  var succeedContext2 = succeedContext;
  var suspend4 = suspend2;
  var sync4 = sync2;
  var syncContext2 = syncContext;
  var tap4 = tap2;
  var tapError4 = tapError2;
  var tapErrorCause4 = tapErrorCause2;
  var toRuntime2 = toRuntime;
  var toRuntimeWithMemoMap2 = toRuntimeWithMemoMap;
  var provide3 = provide;
  var provideMerge2 = provideMerge;
  var zipWith6 = zipWith4;
  var unwrapEffect2 = unwrapEffect;
  var unwrapScoped2 = unwrapScoped;
  var setClock = (clock3) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(clockTag, clock3)));
  var setConfigProvider2 = setConfigProvider;
  var parentSpan2 = parentSpan;
  var setRandom = (random4) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(randomTag, random4)));
  var setRequestBatching = (requestBatching) => scopedDiscard2(fiberRefLocallyScoped(currentRequestBatching, requestBatching));
  var setRequestCaching = (requestCaching) => scopedDiscard2(fiberRefLocallyScoped(currentCacheEnabled, requestCaching));
  var setRequestCache = (cache) => scopedDiscard2(isEffect(cache) ? flatMap8(cache, (x) => fiberRefLocallyScoped(currentCache, x)) : fiberRefLocallyScoped(currentCache, cache));
  var setScheduler = (scheduler) => scopedDiscard2(fiberRefLocallyScoped(currentScheduler, scheduler));
  var span3 = span2;
  var setTracer2 = setTracer;
  var setTracerEnabled = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerEnabled, enabled2));
  var setTracerTiming = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerTimingEnabled, enabled2));
  var setUnhandledErrorLogLevel = (level) => scopedDiscard2(fiberRefLocallyScoped(currentUnhandledErrorLogLevel, level));
  var setVersionMismatchErrorLogLevel = (level) => scopedDiscard2(fiberRefLocallyScoped(currentVersionMismatchErrorLogLevel, level));
  var withSpan4 = withSpan2;
  var withParentSpan4 = withParentSpan2;
  var makeMemoMap2 = makeMemoMap;
  var buildWithMemoMap2 = buildWithMemoMap;
  var updateService3 = /* @__PURE__ */ dual(3, (layer, tag, f) => provide3(layer, map17(context4(), (c) => add2(c, tag, f(unsafeGet3(c, tag))))));

  // node_modules/effect/dist/esm/internal/queue.js
  var EnqueueSymbolKey = "effect/QueueEnqueue";
  var EnqueueTypeId = /* @__PURE__ */ Symbol.for(EnqueueSymbolKey);
  var DequeueSymbolKey = "effect/QueueDequeue";
  var DequeueTypeId = /* @__PURE__ */ Symbol.for(DequeueSymbolKey);
  var QueueStrategySymbolKey = "effect/QueueStrategy";
  var QueueStrategyTypeId = /* @__PURE__ */ Symbol.for(QueueStrategySymbolKey);
  var BackingQueueSymbolKey = "effect/BackingQueue";
  var BackingQueueTypeId = /* @__PURE__ */ Symbol.for(BackingQueueSymbolKey);
  var queueStrategyVariance = {
    _A: (_) => _
  };
  var backingQueueVariance = {
    _A: (_) => _
  };
  var enqueueVariance = {
    _In: (_) => _
  };
  var dequeueVariance = {
    _Out: (_) => _
  };

  class QueueImpl extends Class {
    queue;
    takers;
    shutdownHook;
    shutdownFlag;
    strategy;
    [EnqueueTypeId] = enqueueVariance;
    [DequeueTypeId] = dequeueVariance;
    constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
      super();
      this.queue = queue;
      this.takers = takers;
      this.shutdownHook = shutdownHook;
      this.shutdownFlag = shutdownFlag;
      this.strategy = strategy;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    commit() {
      return this.take;
    }
    capacity() {
      return this.queue.capacity();
    }
    get size() {
      return suspend(() => catchAll(this.unsafeSize(), () => interrupt2));
    }
    unsafeSize() {
      if (get6(this.shutdownFlag)) {
        return none2();
      }
      return some2(this.queue.length() - length2(this.takers) + this.strategy.surplusSize());
    }
    get isEmpty() {
      return map10(this.size, (size8) => size8 <= 0);
    }
    get isFull() {
      return map10(this.size, (size8) => size8 >= this.capacity());
    }
    get shutdown() {
      return uninterruptible(withFiberRuntime((state) => {
        pipe(this.shutdownFlag, set2(true));
        return pipe(forEachConcurrentDiscard(unsafePollAll(this.takers), (d) => deferredInterruptWith(d, state.id()), false, false), zipRight(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, undefined)), asVoid);
      }));
    }
    get isShutdown() {
      return sync(() => get6(this.shutdownFlag));
    }
    get awaitShutdown() {
      return deferredAwait(this.shutdownHook);
    }
    isActive() {
      return !get6(this.shutdownFlag);
    }
    unsafeOffer(value) {
      if (get6(this.shutdownFlag)) {
        return false;
      }
      let noRemaining;
      if (this.queue.length() === 0) {
        const taker = pipe(this.takers, poll2(EmptyMutableQueue));
        if (taker !== EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, value);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return true;
      }
      const succeeded = this.queue.offer(value);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded;
    }
    offer(value) {
      return suspend(() => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        let noRemaining;
        if (this.queue.length() === 0) {
          const taker = pipe(this.takers, poll2(EmptyMutableQueue));
          if (taker !== EmptyMutableQueue) {
            unsafeCompleteDeferred(taker, value);
            noRemaining = true;
          } else {
            noRemaining = false;
          }
        } else {
          noRemaining = false;
        }
        if (noRemaining) {
          return succeed(true);
        }
        const succeeded = this.queue.offer(value);
        unsafeCompleteTakers(this.strategy, this.queue, this.takers);
        return succeeded ? succeed(true) : this.strategy.handleSurplus([value], this.queue, this.takers, this.shutdownFlag);
      });
    }
    offerAll(iterable) {
      return suspend(() => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        const values3 = fromIterable(iterable);
        const pTakers = this.queue.length() === 0 ? fromIterable(unsafePollN(this.takers, values3.length)) : empty;
        const [forTakers, remaining] = pipe(values3, splitAt(pTakers.length));
        for (let i = 0;i < pTakers.length; i++) {
          const taker = pTakers[i];
          const item = forTakers[i];
          unsafeCompleteDeferred(taker, item);
        }
        if (remaining.length === 0) {
          return succeed(true);
        }
        const surplus = this.queue.offerAll(remaining);
        unsafeCompleteTakers(this.strategy, this.queue, this.takers);
        return isEmpty(surplus) ? succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
      });
    }
    get take() {
      return withFiberRuntime((state) => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        const item = this.queue.poll(EmptyMutableQueue);
        if (item !== EmptyMutableQueue) {
          this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
          return succeed(item);
        } else {
          const deferred = deferredUnsafeMake(state.id());
          return pipe(suspend(() => {
            pipe(this.takers, offer(deferred));
            unsafeCompleteTakers(this.strategy, this.queue, this.takers);
            return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
          }), onInterrupt(() => {
            return sync(() => unsafeRemove(this.takers, deferred));
          }));
        }
      });
    }
    get takeAll() {
      return suspend(() => {
        return get6(this.shutdownFlag) ? interrupt2 : sync(() => {
          const values3 = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
          this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
          return fromIterable2(values3);
        });
      });
    }
    takeUpTo(max5) {
      return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => {
        const values3 = this.queue.pollUpTo(max5);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return fromIterable2(values3);
      }));
    }
    takeBetween(min3, max5) {
      return suspend(() => takeRemainderLoop(this, min3, max5, empty4()));
    }
  }
  var takeRemainderLoop = (self, min3, max5, acc) => {
    if (max5 < min3) {
      return succeed(acc);
    }
    return pipe(takeUpTo(self, max5), flatMap8((bs) => {
      const remaining = min3 - bs.length;
      if (remaining === 1) {
        return pipe(take2(self), map10((b) => pipe(acc, appendAll2(bs), append2(b))));
      }
      if (remaining > 1) {
        return pipe(take2(self), flatMap8((b) => takeRemainderLoop(self, remaining - 1, max5 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
      }
      return succeed(pipe(acc, appendAll2(bs)));
    }));
  };
  var isQueue = (u) => isEnqueue(u) && isDequeue(u);
  var isEnqueue = (u) => hasProperty(u, EnqueueTypeId);
  var isDequeue = (u) => hasProperty(u, DequeueTypeId);
  var bounded2 = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap8((queue) => make40(backingQueueFromMutableQueue(queue), backPressureStrategy())));
  var dropping = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap8((queue) => make40(backingQueueFromMutableQueue(queue), droppingStrategy())));
  var sliding = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap8((queue) => make40(backingQueueFromMutableQueue(queue), slidingStrategy())));
  var unbounded2 = () => pipe(sync(() => unbounded()), flatMap8((queue) => make40(backingQueueFromMutableQueue(queue), droppingStrategy())));
  var unsafeMake10 = (queue, takers, shutdownHook, shutdownFlag, strategy) => {
    return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
  };
  var make40 = (queue, strategy) => pipe(deferredMake(), map10((deferred) => unsafeMake10(queue, unbounded(), deferred, make11(false), strategy)));

  class BackingQueueFromMutableQueue {
    mutable;
    [BackingQueueTypeId] = backingQueueVariance;
    constructor(mutable) {
      this.mutable = mutable;
    }
    poll(def) {
      return poll2(this.mutable, def);
    }
    pollUpTo(limit) {
      return pollUpTo(this.mutable, limit);
    }
    offerAll(elements) {
      return offerAll(this.mutable, elements);
    }
    offer(element) {
      return offer(this.mutable, element);
    }
    capacity() {
      return capacity(this.mutable);
    }
    length() {
      return length2(this.mutable);
    }
  }
  var backingQueueFromMutableQueue = (mutable) => new BackingQueueFromMutableQueue(mutable);
  var capacity2 = (self) => self.capacity();
  var size8 = (self) => self.size;
  var isFull = (self) => self.isFull;
  var isEmpty10 = (self) => self.isEmpty;
  var isShutdown = (self) => self.isShutdown;
  var awaitShutdown = (self) => self.awaitShutdown;
  var shutdown = (self) => self.shutdown;
  var offer2 = /* @__PURE__ */ dual(2, (self, value) => self.offer(value));
  var unsafeOffer = /* @__PURE__ */ dual(2, (self, value) => self.unsafeOffer(value));
  var offerAll2 = /* @__PURE__ */ dual(2, (self, iterable) => self.offerAll(iterable));
  var poll5 = (self) => map10(self.takeUpTo(1), head2);
  var take2 = (self) => self.take;
  var takeAll = (self) => self.takeAll;
  var takeUpTo = /* @__PURE__ */ dual(2, (self, max5) => self.takeUpTo(max5));
  var takeBetween = /* @__PURE__ */ dual(3, (self, min3, max5) => self.takeBetween(min3, max5));
  var takeN = /* @__PURE__ */ dual(2, (self, n) => self.takeBetween(n, n));
  var backPressureStrategy = () => new BackPressureStrategy;
  var droppingStrategy = () => new DroppingStrategy;
  var slidingStrategy = () => new SlidingStrategy;

  class BackPressureStrategy {
    [QueueStrategyTypeId] = queueStrategyVariance;
    putters = /* @__PURE__ */ unbounded();
    surplusSize() {
      return length2(this.putters);
    }
    onCompleteTakersWithEmptyQueue(takers) {
      while (!isEmpty7(this.putters) && !isEmpty7(takers)) {
        const taker = poll2(takers, undefined);
        const putter = poll2(this.putters, undefined);
        if (putter[2]) {
          unsafeCompleteDeferred(putter[1], true);
        }
        unsafeCompleteDeferred(taker, putter[0]);
      }
    }
    get shutdown() {
      return pipe(fiberId, flatMap8((fiberId3) => pipe(sync(() => unsafePollAll(this.putters)), flatMap8((putters) => forEachConcurrentDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred, fiberId3), asVoid) : void_, false, false)))));
    }
    handleSurplus(iterable, queue, takers, isShutdown2) {
      return withFiberRuntime((state) => {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          this.unsafeOffer(iterable, deferred);
          this.unsafeOnQueueEmptySpace(queue, takers);
          unsafeCompleteTakers(this, queue, takers);
          return get6(isShutdown2) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
      });
    }
    unsafeOnQueueEmptySpace(queue, takers) {
      let keepPolling = true;
      while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {
        const putter = pipe(this.putters, poll2(EmptyMutableQueue));
        if (putter === EmptyMutableQueue) {
          keepPolling = false;
        } else {
          const offered = queue.offer(putter[0]);
          if (offered && putter[2]) {
            unsafeCompleteDeferred(putter[1], true);
          } else if (!offered) {
            unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), prepend2(putter)));
          }
          unsafeCompleteTakers(this, queue, takers);
        }
      }
    }
    unsafeOffer(iterable, deferred) {
      const stuff = fromIterable(iterable);
      for (let i = 0;i < stuff.length; i++) {
        const value = stuff[i];
        if (i === stuff.length - 1) {
          pipe(this.putters, offer([value, deferred, true]));
        } else {
          pipe(this.putters, offer([value, deferred, false]));
        }
      }
    }
    unsafeRemove(deferred) {
      unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), filter2(([, _]) => _ !== deferred)));
    }
  }

  class DroppingStrategy {
    [QueueStrategyTypeId] = queueStrategyVariance;
    surplusSize() {
      return 0;
    }
    get shutdown() {
      return void_;
    }
    onCompleteTakersWithEmptyQueue() {}
    handleSurplus(_iterable, _queue, _takers, _isShutdown) {
      return succeed(false);
    }
    unsafeOnQueueEmptySpace(_queue, _takers) {}
  }

  class SlidingStrategy {
    [QueueStrategyTypeId] = queueStrategyVariance;
    surplusSize() {
      return 0;
    }
    get shutdown() {
      return void_;
    }
    onCompleteTakersWithEmptyQueue() {}
    handleSurplus(iterable, queue, takers, _isShutdown) {
      return sync(() => {
        this.unsafeOffer(queue, iterable);
        unsafeCompleteTakers(this, queue, takers);
        return true;
      });
    }
    unsafeOnQueueEmptySpace(_queue, _takers) {}
    unsafeOffer(queue, iterable) {
      const iterator = iterable[Symbol.iterator]();
      let next;
      let offering = true;
      while (!(next = iterator.next()).done && offering) {
        if (queue.capacity() === 0) {
          return;
        }
        queue.poll(EmptyMutableQueue);
        offering = queue.offer(next.value);
      }
    }
  }
  var unsafeCompleteDeferred = (deferred, a) => {
    return deferredUnsafeDone(deferred, succeed(a));
  };
  var unsafeOfferAll = (queue, as4) => {
    return pipe(queue, offerAll(as4));
  };
  var unsafePollAll = (queue) => {
    return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
  };
  var unsafePollN = (queue, max5) => {
    return pipe(queue, pollUpTo(max5));
  };
  var unsafeRemove = (queue, a) => {
    unsafeOfferAll(queue, pipe(unsafePollAll(queue), filter2((b) => a !== b)));
  };
  var unsafeCompleteTakers = (strategy, queue, takers) => {
    let keepPolling = true;
    while (keepPolling && queue.length() !== 0) {
      const taker = pipe(takers, poll2(EmptyMutableQueue));
      if (taker !== EmptyMutableQueue) {
        const element = queue.poll(EmptyMutableQueue);
        if (element !== EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, element);
          strategy.unsafeOnQueueEmptySpace(queue, takers);
        } else {
          unsafeOfferAll(takers, pipe(unsafePollAll(takers), prepend2(taker)));
        }
        keepPolling = true;
      } else {
        keepPolling = false;
      }
    }
    if (keepPolling && queue.length() === 0 && !isEmpty7(takers)) {
      strategy.onCompleteTakersWithEmptyQueue(takers);
    }
  };

  // node_modules/effect/dist/esm/internal/pubsub.js
  var AbsentValue = /* @__PURE__ */ Symbol.for("effect/PubSub/AbsentValue");
  var addSubscribers = (subscription, pollers) => (subscribers) => {
    if (!subscribers.has(subscription)) {
      subscribers.set(subscription, new Set);
    }
    const set7 = subscribers.get(subscription);
    set7.add(pollers);
  };
  var removeSubscribers = (subscription, pollers) => (subscribers) => {
    if (!subscribers.has(subscription)) {
      return;
    }
    const set7 = subscribers.get(subscription);
    set7.delete(pollers);
    if (set7.size === 0) {
      subscribers.delete(subscription);
    }
  };
  var bounded3 = (capacity3) => suspend(() => {
    const pubsub = makeBoundedPubSub(capacity3);
    return makePubSub(pubsub, new BackPressureStrategy2);
  });
  var dropping2 = (capacity3) => suspend(() => {
    const pubsub = makeBoundedPubSub(capacity3);
    return makePubSub(pubsub, new DroppingStrategy2);
  });
  var sliding2 = (capacity3) => suspend(() => {
    const pubsub = makeBoundedPubSub(capacity3);
    return makePubSub(pubsub, new SlidingStrategy2);
  });
  var unbounded3 = (options) => suspend(() => {
    const pubsub = makeUnboundedPubSub(options);
    return makePubSub(pubsub, new DroppingStrategy2);
  });
  var shutdown2 = (self) => self.shutdown;
  var subscribe = (self) => self.subscribe;
  var makeBoundedPubSub = (capacity3) => {
    const options = typeof capacity3 === "number" ? {
      capacity: capacity3
    } : capacity3;
    ensureCapacity(options.capacity);
    const replayBuffer = options.replay && options.replay > 0 ? new ReplayBuffer(Math.ceil(options.replay)) : undefined;
    if (options.capacity === 1) {
      return new BoundedPubSubSingle(replayBuffer);
    } else if (nextPow2(options.capacity) === options.capacity) {
      return new BoundedPubSubPow2(options.capacity, replayBuffer);
    } else {
      return new BoundedPubSubArb(options.capacity, replayBuffer);
    }
  };
  var makeUnboundedPubSub = (options) => new UnboundedPubSub(options?.replay ? new ReplayBuffer(options.replay) : undefined);
  var makeSubscription = (pubsub, subscribers, strategy) => map10(deferredMake(), (deferred) => unsafeMakeSubscription(pubsub, subscribers, pubsub.subscribe(), unbounded(), deferred, make11(false), strategy));
  var unsafeMakeSubscription = (pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) => new SubscriptionImpl(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, pubsub.replayWindow());

  class BoundedPubSubArb {
    capacity;
    replayBuffer;
    array;
    publisherIndex = 0;
    subscribers;
    subscriberCount = 0;
    subscribersIndex = 0;
    constructor(capacity3, replayBuffer) {
      this.capacity = capacity3;
      this.replayBuffer = replayBuffer;
      this.array = Array.from({
        length: capacity3
      });
      this.subscribers = Array.from({
        length: capacity3
      });
    }
    replayWindow() {
      return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
    }
    isEmpty() {
      return this.publisherIndex === this.subscribersIndex;
    }
    isFull() {
      return this.publisherIndex === this.subscribersIndex + this.capacity;
    }
    size() {
      return this.publisherIndex - this.subscribersIndex;
    }
    publish(value) {
      if (this.isFull()) {
        return false;
      }
      if (this.subscriberCount !== 0) {
        const index = this.publisherIndex % this.capacity;
        this.array[index] = value;
        this.subscribers[index] = this.subscriberCount;
        this.publisherIndex += 1;
      }
      if (this.replayBuffer) {
        this.replayBuffer.offer(value);
      }
      return true;
    }
    publishAll(elements) {
      if (this.subscriberCount === 0) {
        if (this.replayBuffer) {
          this.replayBuffer.offerAll(elements);
        }
        return empty4();
      }
      const chunk2 = fromIterable2(elements);
      const n = chunk2.length;
      const size9 = this.publisherIndex - this.subscribersIndex;
      const available = this.capacity - size9;
      const forPubSub = Math.min(n, available);
      if (forPubSub === 0) {
        return chunk2;
      }
      let iteratorIndex = 0;
      const publishAllIndex = this.publisherIndex + forPubSub;
      while (this.publisherIndex !== publishAllIndex) {
        const a = unsafeGet4(chunk2, iteratorIndex++);
        const index = this.publisherIndex % this.capacity;
        this.array[index] = a;
        this.subscribers[index] = this.subscriberCount;
        this.publisherIndex += 1;
        if (this.replayBuffer) {
          this.replayBuffer.offer(a);
        }
      }
      return drop2(chunk2, iteratorIndex);
    }
    slide() {
      if (this.subscribersIndex !== this.publisherIndex) {
        const index = this.subscribersIndex % this.capacity;
        this.array[index] = AbsentValue;
        this.subscribers[index] = 0;
        this.subscribersIndex += 1;
      }
      if (this.replayBuffer) {
        this.replayBuffer.slide();
      }
    }
    subscribe() {
      this.subscriberCount += 1;
      return new BoundedPubSubArbSubscription(this, this.publisherIndex, false);
    }
  }

  class BoundedPubSubArbSubscription {
    self;
    subscriberIndex;
    unsubscribed;
    constructor(self, subscriberIndex, unsubscribed) {
      this.self = self;
      this.subscriberIndex = subscriberIndex;
      this.unsubscribed = unsubscribed;
    }
    isEmpty() {
      return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
    }
    size() {
      if (this.unsubscribed) {
        return 0;
      }
      return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
    }
    poll(default_) {
      if (this.unsubscribed) {
        return default_;
      }
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      if (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex % this.self.capacity;
        const elem = this.self.array[index];
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
        return elem;
      }
      return default_;
    }
    pollUpTo(n) {
      if (this.unsubscribed) {
        return empty4();
      }
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      const size9 = this.self.publisherIndex - this.subscriberIndex;
      const toPoll = Math.min(n, size9);
      if (toPoll <= 0) {
        return empty4();
      }
      const builder = [];
      const pollUpToIndex = this.subscriberIndex + toPoll;
      while (this.subscriberIndex !== pollUpToIndex) {
        const index = this.subscriberIndex % this.self.capacity;
        const a = this.self.array[index];
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        builder.push(a);
        this.subscriberIndex += 1;
      }
      return fromIterable2(builder);
    }
    unsubscribe() {
      if (!this.unsubscribed) {
        this.unsubscribed = true;
        this.self.subscriberCount -= 1;
        this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
        while (this.subscriberIndex !== this.self.publisherIndex) {
          const index = this.subscriberIndex % this.self.capacity;
          this.self.subscribers[index] -= 1;
          if (this.self.subscribers[index] === 0) {
            this.self.array[index] = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          this.subscriberIndex += 1;
        }
      }
    }
  }

  class BoundedPubSubPow2 {
    capacity;
    replayBuffer;
    array;
    mask;
    publisherIndex = 0;
    subscribers;
    subscriberCount = 0;
    subscribersIndex = 0;
    constructor(capacity3, replayBuffer) {
      this.capacity = capacity3;
      this.replayBuffer = replayBuffer;
      this.array = Array.from({
        length: capacity3
      });
      this.mask = capacity3 - 1;
      this.subscribers = Array.from({
        length: capacity3
      });
    }
    replayWindow() {
      return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
    }
    isEmpty() {
      return this.publisherIndex === this.subscribersIndex;
    }
    isFull() {
      return this.publisherIndex === this.subscribersIndex + this.capacity;
    }
    size() {
      return this.publisherIndex - this.subscribersIndex;
    }
    publish(value) {
      if (this.isFull()) {
        return false;
      }
      if (this.subscriberCount !== 0) {
        const index = this.publisherIndex & this.mask;
        this.array[index] = value;
        this.subscribers[index] = this.subscriberCount;
        this.publisherIndex += 1;
      }
      if (this.replayBuffer) {
        this.replayBuffer.offer(value);
      }
      return true;
    }
    publishAll(elements) {
      if (this.subscriberCount === 0) {
        if (this.replayBuffer) {
          this.replayBuffer.offerAll(elements);
        }
        return empty4();
      }
      const chunk2 = fromIterable2(elements);
      const n = chunk2.length;
      const size9 = this.publisherIndex - this.subscribersIndex;
      const available = this.capacity - size9;
      const forPubSub = Math.min(n, available);
      if (forPubSub === 0) {
        return chunk2;
      }
      let iteratorIndex = 0;
      const publishAllIndex = this.publisherIndex + forPubSub;
      while (this.publisherIndex !== publishAllIndex) {
        const elem = unsafeGet4(chunk2, iteratorIndex++);
        const index = this.publisherIndex & this.mask;
        this.array[index] = elem;
        this.subscribers[index] = this.subscriberCount;
        this.publisherIndex += 1;
        if (this.replayBuffer) {
          this.replayBuffer.offer(elem);
        }
      }
      return drop2(chunk2, iteratorIndex);
    }
    slide() {
      if (this.subscribersIndex !== this.publisherIndex) {
        const index = this.subscribersIndex & this.mask;
        this.array[index] = AbsentValue;
        this.subscribers[index] = 0;
        this.subscribersIndex += 1;
      }
      if (this.replayBuffer) {
        this.replayBuffer.slide();
      }
    }
    subscribe() {
      this.subscriberCount += 1;
      return new BoundedPubSubPow2Subscription(this, this.publisherIndex, false);
    }
  }

  class BoundedPubSubPow2Subscription {
    self;
    subscriberIndex;
    unsubscribed;
    constructor(self, subscriberIndex, unsubscribed) {
      this.self = self;
      this.subscriberIndex = subscriberIndex;
      this.unsubscribed = unsubscribed;
    }
    isEmpty() {
      return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
    }
    size() {
      if (this.unsubscribed) {
        return 0;
      }
      return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
    }
    poll(default_) {
      if (this.unsubscribed) {
        return default_;
      }
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      if (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex & this.self.mask;
        const elem = this.self.array[index];
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
        return elem;
      }
      return default_;
    }
    pollUpTo(n) {
      if (this.unsubscribed) {
        return empty4();
      }
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      const size9 = this.self.publisherIndex - this.subscriberIndex;
      const toPoll = Math.min(n, size9);
      if (toPoll <= 0) {
        return empty4();
      }
      const builder = [];
      const pollUpToIndex = this.subscriberIndex + toPoll;
      while (this.subscriberIndex !== pollUpToIndex) {
        const index = this.subscriberIndex & this.self.mask;
        const elem = this.self.array[index];
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        builder.push(elem);
        this.subscriberIndex += 1;
      }
      return fromIterable2(builder);
    }
    unsubscribe() {
      if (!this.unsubscribed) {
        this.unsubscribed = true;
        this.self.subscriberCount -= 1;
        this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
        while (this.subscriberIndex !== this.self.publisherIndex) {
          const index = this.subscriberIndex & this.self.mask;
          this.self.subscribers[index] -= 1;
          if (this.self.subscribers[index] === 0) {
            this.self.array[index] = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          this.subscriberIndex += 1;
        }
      }
    }
  }

  class BoundedPubSubSingle {
    replayBuffer;
    publisherIndex = 0;
    subscriberCount = 0;
    subscribers = 0;
    value = AbsentValue;
    capacity = 1;
    constructor(replayBuffer) {
      this.replayBuffer = replayBuffer;
    }
    replayWindow() {
      return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    isEmpty() {
      return this.subscribers === 0;
    }
    isFull() {
      return !this.isEmpty();
    }
    size() {
      return this.isEmpty() ? 0 : 1;
    }
    publish(value) {
      if (this.isFull()) {
        return false;
      }
      if (this.subscriberCount !== 0) {
        this.value = value;
        this.subscribers = this.subscriberCount;
        this.publisherIndex += 1;
      }
      if (this.replayBuffer) {
        this.replayBuffer.offer(value);
      }
      return true;
    }
    publishAll(elements) {
      if (this.subscriberCount === 0) {
        if (this.replayBuffer) {
          this.replayBuffer.offerAll(elements);
        }
        return empty4();
      }
      const chunk2 = fromIterable2(elements);
      if (isEmpty(chunk2)) {
        return chunk2;
      }
      if (this.publish(unsafeHead(chunk2))) {
        return drop2(chunk2, 1);
      } else {
        return chunk2;
      }
    }
    slide() {
      if (this.isFull()) {
        this.subscribers = 0;
        this.value = AbsentValue;
      }
      if (this.replayBuffer) {
        this.replayBuffer.slide();
      }
    }
    subscribe() {
      this.subscriberCount += 1;
      return new BoundedPubSubSingleSubscription(this, this.publisherIndex, false);
    }
  }

  class BoundedPubSubSingleSubscription {
    self;
    subscriberIndex;
    unsubscribed;
    constructor(self, subscriberIndex, unsubscribed) {
      this.self = self;
      this.subscriberIndex = subscriberIndex;
      this.unsubscribed = unsubscribed;
    }
    isEmpty() {
      return this.unsubscribed || this.self.subscribers === 0 || this.subscriberIndex === this.self.publisherIndex;
    }
    size() {
      return this.isEmpty() ? 0 : 1;
    }
    poll(default_) {
      if (this.isEmpty()) {
        return default_;
      }
      const elem = this.self.value;
      this.self.subscribers -= 1;
      if (this.self.subscribers === 0) {
        this.self.value = AbsentValue;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    pollUpTo(n) {
      if (this.isEmpty() || n < 1) {
        return empty4();
      }
      const a = this.self.value;
      this.self.subscribers -= 1;
      if (this.self.subscribers === 0) {
        this.self.value = AbsentValue;
      }
      this.subscriberIndex += 1;
      return of2(a);
    }
    unsubscribe() {
      if (!this.unsubscribed) {
        this.unsubscribed = true;
        this.self.subscriberCount -= 1;
        if (this.subscriberIndex !== this.self.publisherIndex) {
          this.self.subscribers -= 1;
          if (this.self.subscribers === 0) {
            this.self.value = AbsentValue;
          }
        }
      }
    }
  }

  class UnboundedPubSub {
    replayBuffer;
    publisherHead = {
      value: AbsentValue,
      subscribers: 0,
      next: null
    };
    publisherTail = this.publisherHead;
    publisherIndex = 0;
    subscribersIndex = 0;
    capacity = Number.MAX_SAFE_INTEGER;
    constructor(replayBuffer) {
      this.replayBuffer = replayBuffer;
    }
    replayWindow() {
      return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
    }
    isEmpty() {
      return this.publisherHead === this.publisherTail;
    }
    isFull() {
      return false;
    }
    size() {
      return this.publisherIndex - this.subscribersIndex;
    }
    publish(value) {
      const subscribers = this.publisherTail.subscribers;
      if (subscribers !== 0) {
        this.publisherTail.next = {
          value,
          subscribers,
          next: null
        };
        this.publisherTail = this.publisherTail.next;
        this.publisherIndex += 1;
      }
      if (this.replayBuffer) {
        this.replayBuffer.offer(value);
      }
      return true;
    }
    publishAll(elements) {
      if (this.publisherTail.subscribers !== 0) {
        for (const a of elements) {
          this.publish(a);
        }
      } else if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty4();
    }
    slide() {
      if (this.publisherHead !== this.publisherTail) {
        this.publisherHead = this.publisherHead.next;
        this.publisherHead.value = AbsentValue;
        this.subscribersIndex += 1;
      }
      if (this.replayBuffer) {
        this.replayBuffer.slide();
      }
    }
    subscribe() {
      this.publisherTail.subscribers += 1;
      return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
    }
  }

  class UnboundedPubSubSubscription {
    self;
    subscriberHead;
    subscriberIndex;
    unsubscribed;
    constructor(self, subscriberHead, subscriberIndex, unsubscribed) {
      this.self = self;
      this.subscriberHead = subscriberHead;
      this.subscriberIndex = subscriberIndex;
      this.unsubscribed = unsubscribed;
    }
    isEmpty() {
      if (this.unsubscribed) {
        return true;
      }
      let empty29 = true;
      let loop3 = true;
      while (loop3) {
        if (this.subscriberHead === this.self.publisherTail) {
          loop3 = false;
        } else {
          if (this.subscriberHead.next.value !== AbsentValue) {
            empty29 = false;
            loop3 = false;
          } else {
            this.subscriberHead = this.subscriberHead.next;
            this.subscriberIndex += 1;
          }
        }
      }
      return empty29;
    }
    size() {
      if (this.unsubscribed) {
        return 0;
      }
      return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
    }
    poll(default_) {
      if (this.unsubscribed) {
        return default_;
      }
      let loop3 = true;
      let polled = default_;
      while (loop3) {
        if (this.subscriberHead === this.self.publisherTail) {
          loop3 = false;
        } else {
          const elem = this.subscriberHead.next.value;
          if (elem !== AbsentValue) {
            polled = elem;
            this.subscriberHead.subscribers -= 1;
            if (this.subscriberHead.subscribers === 0) {
              this.self.publisherHead = this.self.publisherHead.next;
              this.self.publisherHead.value = AbsentValue;
              this.self.subscribersIndex += 1;
            }
            loop3 = false;
          }
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
      return polled;
    }
    pollUpTo(n) {
      const builder = [];
      const default_ = AbsentValue;
      let i = 0;
      while (i !== n) {
        const a = this.poll(default_);
        if (a === default_) {
          i = n;
        } else {
          builder.push(a);
          i += 1;
        }
      }
      return fromIterable2(builder);
    }
    unsubscribe() {
      if (!this.unsubscribed) {
        this.unsubscribed = true;
        this.self.publisherTail.subscribers -= 1;
        while (this.subscriberHead !== this.self.publisherTail) {
          if (this.subscriberHead.next.value !== AbsentValue) {
            this.subscriberHead.subscribers -= 1;
            if (this.subscriberHead.subscribers === 0) {
              this.self.publisherHead = this.self.publisherHead.next;
              this.self.publisherHead.value = AbsentValue;
              this.self.subscribersIndex += 1;
            }
          }
          this.subscriberHead = this.subscriberHead.next;
        }
      }
    }
  }

  class SubscriptionImpl extends Class {
    pubsub;
    subscribers;
    subscription;
    pollers;
    shutdownHook;
    shutdownFlag;
    strategy;
    replayWindow;
    [DequeueTypeId] = dequeueVariance;
    constructor(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, replayWindow) {
      super();
      this.pubsub = pubsub;
      this.subscribers = subscribers;
      this.subscription = subscription;
      this.pollers = pollers;
      this.shutdownHook = shutdownHook;
      this.shutdownFlag = shutdownFlag;
      this.strategy = strategy;
      this.replayWindow = replayWindow;
    }
    commit() {
      return this.take;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    capacity() {
      return this.pubsub.capacity;
    }
    isActive() {
      return !get6(this.shutdownFlag);
    }
    get size() {
      return suspend(() => get6(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() + this.replayWindow.remaining));
    }
    unsafeSize() {
      if (get6(this.shutdownFlag)) {
        return none2();
      }
      return some2(this.subscription.size() + this.replayWindow.remaining);
    }
    get isFull() {
      return suspend(() => get6(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() === this.capacity()));
    }
    get isEmpty() {
      return map10(this.size, (size9) => size9 === 0);
    }
    get shutdown() {
      return uninterruptible(withFiberRuntime((state) => {
        set2(this.shutdownFlag, true);
        return pipe(forEachParUnbounded(unsafePollAllQueue(this.pollers), (d) => deferredInterruptWith(d, state.id()), false), zipRight(sync(() => {
          this.subscribers.delete(this.subscription);
          this.subscription.unsubscribe();
          this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        })), whenEffect(deferredSucceed(this.shutdownHook, undefined)), asVoid);
      }));
    }
    get isShutdown() {
      return sync(() => get6(this.shutdownFlag));
    }
    get awaitShutdown() {
      return deferredAwait(this.shutdownHook);
    }
    get take() {
      return withFiberRuntime((state) => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        if (this.replayWindow.remaining > 0) {
          const message2 = this.replayWindow.take();
          return succeed(message2);
        }
        const message = isEmpty7(this.pollers) ? this.subscription.poll(EmptyMutableQueue) : EmptyMutableQueue;
        if (message === EmptyMutableQueue) {
          const deferred = deferredUnsafeMake(state.id());
          return pipe(suspend(() => {
            pipe(this.pollers, offer(deferred));
            pipe(this.subscribers, addSubscribers(this.subscription, this.pollers));
            this.strategy.unsafeCompletePollers(this.pubsub, this.subscribers, this.subscription, this.pollers);
            return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
          }), onInterrupt(() => sync(() => unsafeRemove2(this.pollers, deferred))));
        } else {
          this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
          return succeed(message);
        }
      });
    }
    get takeAll() {
      return suspend(() => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        const as4 = isEmpty7(this.pollers) ? unsafePollAllSubscription(this.subscription) : empty4();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        if (this.replayWindow.remaining > 0) {
          return succeed(appendAll2(this.replayWindow.takeAll(), as4));
        }
        return succeed(as4);
      });
    }
    takeUpTo(max5) {
      return suspend(() => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        let replay = undefined;
        if (this.replayWindow.remaining >= max5) {
          const as5 = this.replayWindow.takeN(max5);
          return succeed(as5);
        } else if (this.replayWindow.remaining > 0) {
          replay = this.replayWindow.takeAll();
          max5 = max5 - replay.length;
        }
        const as4 = isEmpty7(this.pollers) ? unsafePollN2(this.subscription, max5) : empty4();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        return replay ? succeed(appendAll2(replay, as4)) : succeed(as4);
      });
    }
    takeBetween(min3, max5) {
      return suspend(() => takeRemainderLoop2(this, min3, max5, empty4()));
    }
  }
  var takeRemainderLoop2 = (self, min3, max5, acc) => {
    if (max5 < min3) {
      return succeed(acc);
    }
    return pipe(self.takeUpTo(max5), flatMap8((bs) => {
      const remaining = min3 - bs.length;
      if (remaining === 1) {
        return pipe(self.take, map10((b) => pipe(acc, appendAll2(bs), append2(b))));
      }
      if (remaining > 1) {
        return pipe(self.take, flatMap8((b) => takeRemainderLoop2(self, remaining - 1, max5 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
      }
      return succeed(pipe(acc, appendAll2(bs)));
    }));
  };

  class PubSubImpl {
    pubsub;
    subscribers;
    scope;
    shutdownHook;
    shutdownFlag;
    strategy;
    [EnqueueTypeId] = enqueueVariance;
    [DequeueTypeId] = dequeueVariance;
    constructor(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) {
      this.pubsub = pubsub;
      this.subscribers = subscribers;
      this.scope = scope5;
      this.shutdownHook = shutdownHook;
      this.shutdownFlag = shutdownFlag;
      this.strategy = strategy;
    }
    capacity() {
      return this.pubsub.capacity;
    }
    get size() {
      return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => this.pubsub.size()));
    }
    unsafeSize() {
      if (get6(this.shutdownFlag)) {
        return none2();
      }
      return some2(this.pubsub.size());
    }
    get isFull() {
      return map10(this.size, (size9) => size9 === this.capacity());
    }
    get isEmpty() {
      return map10(this.size, (size9) => size9 === 0);
    }
    get awaitShutdown() {
      return deferredAwait(this.shutdownHook);
    }
    get isShutdown() {
      return sync(() => get6(this.shutdownFlag));
    }
    get shutdown() {
      return uninterruptible(withFiberRuntime((state) => {
        pipe(this.shutdownFlag, set2(true));
        return pipe(this.scope.close(exitInterrupt(state.id())), zipRight(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, undefined)), asVoid);
      }));
    }
    publish(value) {
      return suspend(() => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        if (this.pubsub.publish(value)) {
          this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
          return succeed(true);
        }
        return this.strategy.handleSurplus(this.pubsub, this.subscribers, of2(value), this.shutdownFlag);
      });
    }
    isActive() {
      return !get6(this.shutdownFlag);
    }
    unsafeOffer(value) {
      if (get6(this.shutdownFlag)) {
        return false;
      }
      if (this.pubsub.publish(value)) {
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        return true;
      }
      return false;
    }
    publishAll(elements) {
      return suspend(() => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        const surplus = unsafePublishAll(this.pubsub, elements);
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        if (isEmpty(surplus)) {
          return succeed(true);
        }
        return this.strategy.handleSurplus(this.pubsub, this.subscribers, surplus, this.shutdownFlag);
      });
    }
    get subscribe() {
      const acquire = tap(all3([this.scope.fork(sequential2), makeSubscription(this.pubsub, this.subscribers, this.strategy)]), (tuple) => tuple[0].addFinalizer(() => tuple[1].shutdown));
      return map10(acquireRelease(acquire, (tuple, exit3) => tuple[0].close(exit3)), (tuple) => tuple[1]);
    }
    offer(value) {
      return this.publish(value);
    }
    offerAll(elements) {
      return this.publishAll(elements);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var makePubSub = (pubsub, strategy) => flatMap8(scopeMake(), (scope5) => map10(deferredMake(), (deferred) => unsafeMakePubSub(pubsub, new Map, scope5, deferred, make11(false), strategy)));
  var unsafeMakePubSub = (pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) => new PubSubImpl(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy);
  var ensureCapacity = (capacity3) => {
    if (capacity3 <= 0) {
      throw new InvalidPubSubCapacityException(`Cannot construct PubSub with capacity of ${capacity3}`);
    }
  };
  var unsafeCompleteDeferred2 = (deferred, a) => {
    deferredUnsafeDone(deferred, succeed(a));
  };
  var unsafeOfferAll2 = (queue, as4) => {
    return pipe(queue, offerAll(as4));
  };
  var unsafePollAllQueue = (queue) => {
    return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
  };
  var unsafePollAllSubscription = (subscription) => {
    return subscription.pollUpTo(Number.POSITIVE_INFINITY);
  };
  var unsafePollN2 = (subscription, max5) => {
    return subscription.pollUpTo(max5);
  };
  var unsafePublishAll = (pubsub, as4) => {
    return pubsub.publishAll(as4);
  };
  var unsafeRemove2 = (queue, value) => {
    unsafeOfferAll2(queue, pipe(unsafePollAllQueue(queue), filter2((elem) => elem !== value)));
  };

  class BackPressureStrategy2 {
    publishers = /* @__PURE__ */ unbounded();
    get shutdown() {
      return flatMap8(fiberId, (fiberId3) => flatMap8(sync(() => unsafePollAllQueue(this.publishers)), (publishers) => forEachConcurrentDiscard(publishers, ([_, deferred, last3]) => last3 ? pipe(deferredInterruptWith(deferred, fiberId3), asVoid) : void_, false, false)));
    }
    handleSurplus(pubsub, subscribers, elements, isShutdown2) {
      return withFiberRuntime((state) => {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          this.unsafeOffer(elements, deferred);
          this.unsafeOnPubSubEmptySpace(pubsub, subscribers);
          this.unsafeCompleteSubscribers(pubsub, subscribers);
          return get6(isShutdown2) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
      });
    }
    unsafeOnPubSubEmptySpace(pubsub, subscribers) {
      let keepPolling = true;
      while (keepPolling && !pubsub.isFull()) {
        const publisher = pipe(this.publishers, poll2(EmptyMutableQueue));
        if (publisher === EmptyMutableQueue) {
          keepPolling = false;
        } else {
          const published = pubsub.publish(publisher[0]);
          if (published && publisher[2]) {
            unsafeCompleteDeferred2(publisher[1], true);
          } else if (!published) {
            unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), prepend2(publisher)));
          }
          this.unsafeCompleteSubscribers(pubsub, subscribers);
        }
      }
    }
    unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
      return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
    }
    unsafeCompleteSubscribers(pubsub, subscribers) {
      return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
    }
    unsafeOffer(elements, deferred) {
      const iterator = elements[Symbol.iterator]();
      let next = iterator.next();
      if (!next.done) {
        while (true) {
          const value = next.value;
          next = iterator.next();
          if (next.done) {
            pipe(this.publishers, offer([value, deferred, true]));
            break;
          }
          pipe(this.publishers, offer([value, deferred, false]));
        }
      }
    }
    unsafeRemove(deferred) {
      unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), filter2(([_, a]) => a !== deferred)));
    }
  }

  class DroppingStrategy2 {
    get shutdown() {
      return void_;
    }
    handleSurplus(_pubsub, _subscribers, _elements, _isShutdown) {
      return succeed(false);
    }
    unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {}
    unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
      return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
    }
    unsafeCompleteSubscribers(pubsub, subscribers) {
      return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
    }
  }

  class SlidingStrategy2 {
    get shutdown() {
      return void_;
    }
    handleSurplus(pubsub, subscribers, elements, _isShutdown) {
      return sync(() => {
        this.unsafeSlidingPublish(pubsub, elements);
        this.unsafeCompleteSubscribers(pubsub, subscribers);
        return true;
      });
    }
    unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {}
    unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
      return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
    }
    unsafeCompleteSubscribers(pubsub, subscribers) {
      return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
    }
    unsafeSlidingPublish(pubsub, elements) {
      const it = elements[Symbol.iterator]();
      let next = it.next();
      if (!next.done && pubsub.capacity > 0) {
        let a = next.value;
        let loop3 = true;
        while (loop3) {
          pubsub.slide();
          const pub = pubsub.publish(a);
          if (pub && (next = it.next()) && !next.done) {
            a = next.value;
          } else if (pub) {
            loop3 = false;
          }
        }
      }
    }
  }
  var unsafeStrategyCompletePollers = (strategy, pubsub, subscribers, subscription, pollers) => {
    let keepPolling = true;
    while (keepPolling && !subscription.isEmpty()) {
      const poller = pipe(pollers, poll2(EmptyMutableQueue));
      if (poller === EmptyMutableQueue) {
        pipe(subscribers, removeSubscribers(subscription, pollers));
        if (isEmpty7(pollers)) {
          keepPolling = false;
        } else {
          pipe(subscribers, addSubscribers(subscription, pollers));
        }
      } else {
        const pollResult = subscription.poll(EmptyMutableQueue);
        if (pollResult === EmptyMutableQueue) {
          unsafeOfferAll2(pollers, pipe(unsafePollAllQueue(pollers), prepend2(poller)));
        } else {
          unsafeCompleteDeferred2(poller, pollResult);
          strategy.unsafeOnPubSubEmptySpace(pubsub, subscribers);
        }
      }
    }
  };
  var unsafeStrategyCompleteSubscribers = (strategy, pubsub, subscribers) => {
    for (const [subscription, pollersSet] of subscribers) {
      for (const pollers of pollersSet) {
        strategy.unsafeCompletePollers(pubsub, subscribers, subscription, pollers);
      }
    }
  };

  class ReplayBuffer {
    capacity;
    constructor(capacity3) {
      this.capacity = capacity3;
    }
    head = {
      value: AbsentValue,
      next: null
    };
    tail = this.head;
    size = 0;
    index = 0;
    slide() {
      this.index++;
    }
    offer(a) {
      this.tail.value = a;
      this.tail.next = {
        value: AbsentValue,
        next: null
      };
      this.tail = this.tail.next;
      if (this.size === this.capacity) {
        this.head = this.head.next;
      } else {
        this.size += 1;
      }
    }
    offerAll(as4) {
      for (const a of as4) {
        this.offer(a);
      }
    }
  }

  class ReplayWindowImpl {
    buffer;
    head;
    index;
    remaining;
    constructor(buffer) {
      this.buffer = buffer;
      this.index = buffer.index;
      this.remaining = buffer.size;
      this.head = buffer.head;
    }
    fastForward() {
      while (this.index < this.buffer.index) {
        this.head = this.head.next;
        this.index++;
      }
    }
    take() {
      if (this.remaining === 0) {
        return;
      } else if (this.index < this.buffer.index) {
        this.fastForward();
      }
      this.remaining--;
      const value = this.head.value;
      this.head = this.head.next;
      return value;
    }
    takeN(n) {
      if (this.remaining === 0) {
        return empty4();
      } else if (this.index < this.buffer.index) {
        this.fastForward();
      }
      const len = Math.min(n, this.remaining);
      const items = new Array(len);
      for (let i = 0;i < len; i++) {
        const value = this.head.value;
        this.head = this.head.next;
        items[i] = value;
      }
      this.remaining -= len;
      return unsafeFromArray(items);
    }
    takeAll() {
      return this.takeN(this.remaining);
    }
  }
  var emptyReplayWindow = {
    remaining: 0,
    take: () => {
      return;
    },
    takeN: () => empty4(),
    takeAll: () => empty4()
  };

  // node_modules/effect/dist/esm/PubSub.js
  var bounded4 = bounded3;
  var dropping3 = dropping2;
  var sliding3 = sliding2;
  var unbounded4 = unbounded3;
  var shutdown3 = shutdown2;
  var subscribe2 = subscribe;

  // node_modules/effect/dist/esm/Queue.js
  var exports_Queue = {};
  __export(exports_Queue, {
    unsafeOffer: () => unsafeOffer2,
    unbounded: () => unbounded5,
    takeUpTo: () => takeUpTo2,
    takeN: () => takeN2,
    takeBetween: () => takeBetween2,
    takeAll: () => takeAll2,
    take: () => take3,
    slidingStrategy: () => slidingStrategy2,
    sliding: () => sliding4,
    size: () => size10,
    shutdown: () => shutdown4,
    poll: () => poll6,
    offerAll: () => offerAll3,
    offer: () => offer3,
    make: () => make41,
    isShutdown: () => isShutdown3,
    isQueue: () => isQueue2,
    isFull: () => isFull3,
    isEnqueue: () => isEnqueue2,
    isEmpty: () => isEmpty12,
    isDequeue: () => isDequeue2,
    droppingStrategy: () => droppingStrategy2,
    dropping: () => dropping4,
    capacity: () => capacity4,
    bounded: () => bounded5,
    backPressureStrategy: () => backPressureStrategy2,
    awaitShutdown: () => awaitShutdown3,
    QueueStrategyTypeId: () => QueueStrategyTypeId2,
    EnqueueTypeId: () => EnqueueTypeId2,
    DequeueTypeId: () => DequeueTypeId2,
    BackingQueueTypeId: () => BackingQueueTypeId2
  });
  var EnqueueTypeId2 = EnqueueTypeId;
  var DequeueTypeId2 = DequeueTypeId;
  var QueueStrategyTypeId2 = QueueStrategyTypeId;
  var BackingQueueTypeId2 = BackingQueueTypeId;
  var isQueue2 = isQueue;
  var isDequeue2 = isDequeue;
  var isEnqueue2 = isEnqueue;
  var backPressureStrategy2 = backPressureStrategy;
  var droppingStrategy2 = droppingStrategy;
  var slidingStrategy2 = slidingStrategy;
  var make41 = make40;
  var bounded5 = bounded2;
  var dropping4 = dropping;
  var sliding4 = sliding;
  var unbounded5 = unbounded2;
  var capacity4 = capacity2;
  var size10 = size8;
  var isEmpty12 = isEmpty10;
  var isFull3 = isFull;
  var isShutdown3 = isShutdown;
  var awaitShutdown3 = awaitShutdown;
  var shutdown4 = shutdown;
  var offer3 = offer2;
  var unsafeOffer2 = unsafeOffer;
  var offerAll3 = offerAll2;
  var poll6 = poll5;
  var take3 = take2;
  var takeAll2 = takeAll;
  var takeUpTo2 = takeUpTo;
  var takeBetween2 = takeBetween;
  var takeN2 = takeN;

  // node_modules/effect/dist/esm/internal/opCodes/channelChildExecutorDecision.js
  var OP_CONTINUE2 = "Continue";
  var OP_CLOSE = "Close";
  var OP_YIELD2 = "Yield";

  // node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
  var ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
  var ChildExecutorDecisionTypeId = /* @__PURE__ */ Symbol.for(ChildExecutorDecisionSymbolKey);
  var proto4 = {
    [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
  };
  var Continue = (_) => {
    const op = Object.create(proto4);
    op._tag = OP_CONTINUE2;
    return op;
  };

  // node_modules/effect/dist/esm/internal/opCodes/continuation.js
  var OP_CONTINUATION_K = "ContinuationK";
  var OP_CONTINUATION_FINALIZER = "ContinuationFinalizer";

  // node_modules/effect/dist/esm/internal/channel/continuation.js
  var ContinuationTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelContinuation");
  var continuationVariance = {
    _Env: (_) => _,
    _InErr: (_) => _,
    _InElem: (_) => _,
    _InDone: (_) => _,
    _OutErr: (_) => _,
    _OutDone: (_) => _,
    _OutErr2: (_) => _,
    _OutElem: (_) => _,
    _OutDone2: (_) => _
  };

  class ContinuationKImpl {
    onSuccess;
    onHalt;
    _tag = OP_CONTINUATION_K;
    [ContinuationTypeId] = continuationVariance;
    constructor(onSuccess, onHalt) {
      this.onSuccess = onSuccess;
      this.onHalt = onHalt;
    }
    onExit(exit3) {
      return isFailure(exit3) ? this.onHalt(exit3.cause) : this.onSuccess(exit3.value);
    }
  }

  class ContinuationFinalizerImpl {
    finalizer;
    _tag = OP_CONTINUATION_FINALIZER;
    [ContinuationTypeId] = continuationVariance;
    constructor(finalizer) {
      this.finalizer = finalizer;
    }
  }

  // node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullStrategy.js
  var OP_PULL_AFTER_NEXT = "PullAfterNext";
  var OP_PULL_AFTER_ALL_ENQUEUED = "PullAfterAllEnqueued";

  // node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
  var UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
  var UpstreamPullStrategyTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullStrategySymbolKey);
  var upstreamPullStrategyVariance = {
    _A: (_) => _
  };
  var proto5 = {
    [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
  };
  var PullAfterNext = (emitSeparator) => {
    const op = Object.create(proto5);
    op._tag = OP_PULL_AFTER_NEXT;
    op.emitSeparator = emitSeparator;
    return op;
  };

  // node_modules/effect/dist/esm/internal/opCodes/channel.js
  var OP_BRACKET_OUT = "BracketOut";
  var OP_BRIDGE = "Bridge";
  var OP_CONCAT_ALL = "ConcatAll";
  var OP_EMIT = "Emit";
  var OP_ENSURING = "Ensuring";
  var OP_FAIL3 = "Fail";
  var OP_FOLD2 = "Fold";
  var OP_FROM_EFFECT2 = "FromEffect";
  var OP_PIPE_TO = "PipeTo";
  var OP_PROVIDE2 = "Provide";
  var OP_READ = "Read";
  var OP_SUCCEED = "Succeed";
  var OP_SUCCEED_NOW = "SucceedNow";
  var OP_SUSPEND2 = "Suspend";

  // node_modules/effect/dist/esm/internal/core-stream.js
  var ChannelSymbolKey = "effect/Channel";
  var ChannelTypeId2 = /* @__PURE__ */ Symbol.for(ChannelSymbolKey);
  var channelVariance2 = {
    _Env: (_) => _,
    _InErr: (_) => _,
    _InElem: (_) => _,
    _InDone: (_) => _,
    _OutErr: (_) => _,
    _OutElem: (_) => _,
    _OutDone: (_) => _
  };
  var proto6 = {
    [ChannelTypeId2]: channelVariance2,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var isChannel = (u) => hasProperty(u, ChannelTypeId2) || isEffect2(u);
  var acquireReleaseOut = /* @__PURE__ */ dual(2, (self, release) => {
    const op = Object.create(proto6);
    op._tag = OP_BRACKET_OUT;
    op.acquire = () => self;
    op.finalizer = release;
    return op;
  });
  var catchAllCause5 = /* @__PURE__ */ dual(2, (self, f) => {
    const op = Object.create(proto6);
    op._tag = OP_FOLD2;
    op.channel = self;
    op.k = new ContinuationKImpl(succeed10, f);
    return op;
  });
  var collectElements = (self) => {
    return suspend5(() => {
      const builder = [];
      return flatMap13(pipeTo(self, collectElementsReader(builder)), (value) => sync5(() => [fromIterable2(builder), value]));
    });
  };
  var collectElementsReader = (builder) => readWith({
    onInput: (outElem) => flatMap13(sync5(() => {
      builder.push(outElem);
    }), () => collectElementsReader(builder)),
    onFailure: fail11,
    onDone: succeedNow
  });
  var concatAllWith = (channels, f, g) => {
    const op = Object.create(proto6);
    op._tag = OP_CONCAT_ALL;
    op.combineInners = f;
    op.combineAll = g;
    op.onPull = () => PullAfterNext(none2());
    op.onEmit = () => Continue;
    op.value = () => channels;
    op.k = identity;
    return op;
  };
  var concatMapWith = /* @__PURE__ */ dual(4, (self, f, g, h) => {
    const op = Object.create(proto6);
    op._tag = OP_CONCAT_ALL;
    op.combineInners = g;
    op.combineAll = h;
    op.onPull = () => PullAfterNext(none2());
    op.onEmit = () => Continue;
    op.value = () => self;
    op.k = f;
    return op;
  });
  var embedInput = /* @__PURE__ */ dual(2, (self, input) => {
    const op = Object.create(proto6);
    op._tag = OP_BRIDGE;
    op.input = input;
    op.channel = self;
    return op;
  });
  var ensuringWith = /* @__PURE__ */ dual(2, (self, finalizer) => {
    const op = Object.create(proto6);
    op._tag = OP_ENSURING;
    op.channel = self;
    op.finalizer = finalizer;
    return op;
  });
  var fail11 = (error) => failCause10(fail5(error));
  var failCause10 = (cause3) => failCauseSync5(() => cause3);
  var failCauseSync5 = (evaluate2) => {
    const op = Object.create(proto6);
    op._tag = OP_FAIL3;
    op.error = evaluate2;
    return op;
  };
  var flatMap13 = /* @__PURE__ */ dual(2, (self, f) => {
    const op = Object.create(proto6);
    op._tag = OP_FOLD2;
    op.channel = self;
    op.k = new ContinuationKImpl(f, failCause10);
    return op;
  });
  var foldCauseChannel = /* @__PURE__ */ dual(2, (self, options) => {
    const op = Object.create(proto6);
    op._tag = OP_FOLD2;
    op.channel = self;
    op.k = new ContinuationKImpl(options.onSuccess, options.onFailure);
    return op;
  });
  var fromEffect4 = (effect2) => {
    const op = Object.create(proto6);
    op._tag = OP_FROM_EFFECT2;
    op.effect = () => effect2;
    return op;
  };
  var pipeTo = /* @__PURE__ */ dual(2, (self, that) => {
    const op = Object.create(proto6);
    op._tag = OP_PIPE_TO;
    op.left = () => self;
    op.right = () => that;
    return op;
  });
  var provideContext3 = /* @__PURE__ */ dual(2, (self, env) => {
    const op = Object.create(proto6);
    op._tag = OP_PROVIDE2;
    op.context = () => env;
    op.inner = self;
    return op;
  });
  var readWith = (options) => readWithCause({
    onInput: options.onInput,
    onFailure: (cause3) => match(failureOrCause2(cause3), {
      onLeft: options.onFailure,
      onRight: failCause10
    }),
    onDone: options.onDone
  });
  var readWithCause = (options) => {
    const op = Object.create(proto6);
    op._tag = OP_READ;
    op.more = options.onInput;
    op.done = new ContinuationKImpl(options.onDone, options.onFailure);
    return op;
  };
  var succeed10 = (value) => sync5(() => value);
  var succeedNow = (result) => {
    const op = Object.create(proto6);
    op._tag = OP_SUCCEED_NOW;
    op.terminal = result;
    return op;
  };
  var suspend5 = (evaluate2) => {
    const op = Object.create(proto6);
    op._tag = OP_SUSPEND2;
    op.channel = evaluate2;
    return op;
  };
  var sync5 = (evaluate2) => {
    const op = Object.create(proto6);
    op._tag = OP_SUCCEED;
    op.evaluate = evaluate2;
    return op;
  };
  var void_5 = /* @__PURE__ */ succeedNow(undefined);
  var write = (out) => {
    const op = Object.create(proto6);
    op._tag = OP_EMIT;
    op.out = out;
    return op;
  };

  // node_modules/effect/dist/esm/internal/opCodes/channelState.js
  var OP_DONE3 = "Done";
  var OP_EMIT2 = "Emit";
  var OP_FROM_EFFECT3 = "FromEffect";
  var OP_READ2 = "Read";

  // node_modules/effect/dist/esm/internal/channel/channelState.js
  var ChannelStateTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelState");
  var channelStateVariance = {
    _E: (_) => _,
    _R: (_) => _
  };
  var proto7 = {
    [ChannelStateTypeId]: channelStateVariance
  };
  var Done2 = () => {
    const op = Object.create(proto7);
    op._tag = OP_DONE3;
    return op;
  };
  var Emit = () => {
    const op = Object.create(proto7);
    op._tag = OP_EMIT2;
    return op;
  };
  var fromEffect5 = (effect2) => {
    const op = Object.create(proto7);
    op._tag = OP_FROM_EFFECT3;
    op.effect = effect2;
    return op;
  };
  var Read = (upstream, onEffect, onEmit, onDone) => {
    const op = Object.create(proto7);
    op._tag = OP_READ2;
    op.upstream = upstream;
    op.onEffect = onEffect;
    op.onEmit = onEmit;
    op.onDone = onDone;
    return op;
  };
  var isFromEffect = (self) => self._tag === OP_FROM_EFFECT3;
  var effect2 = (self) => isFromEffect(self) ? self.effect : _void;
  var effectOrUndefinedIgnored = (self) => isFromEffect(self) ? ignore2(self.effect) : undefined;

  // node_modules/effect/dist/esm/internal/channel/subexecutor.js
  var OP_PULL_FROM_CHILD = "PullFromChild";
  var OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
  var OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
  var OP_EMIT3 = "Emit";

  class PullFromChild {
    childExecutor;
    parentSubexecutor;
    onEmit;
    _tag = OP_PULL_FROM_CHILD;
    constructor(childExecutor, parentSubexecutor, onEmit) {
      this.childExecutor = childExecutor;
      this.parentSubexecutor = parentSubexecutor;
      this.onEmit = onEmit;
    }
    close(exit3) {
      const fin1 = this.childExecutor.close(exit3);
      const fin2 = this.parentSubexecutor.close(exit3);
      if (fin1 !== undefined && fin2 !== undefined) {
        return zipWith5(exit2(fin1), exit2(fin2), (exit1, exit22) => pipe(exit1, zipRight2(exit22)));
      } else if (fin1 !== undefined) {
        return fin1;
      } else if (fin2 !== undefined) {
        return fin2;
      } else {
        return;
      }
    }
    enqueuePullFromChild(_child) {
      return this;
    }
  }

  class PullFromUpstream {
    upstreamExecutor;
    createChild;
    lastDone;
    activeChildExecutors;
    combineChildResults;
    combineWithChildResult;
    onPull;
    onEmit;
    _tag = OP_PULL_FROM_UPSTREAM;
    constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
      this.upstreamExecutor = upstreamExecutor;
      this.createChild = createChild;
      this.lastDone = lastDone;
      this.activeChildExecutors = activeChildExecutors;
      this.combineChildResults = combineChildResults;
      this.combineWithChildResult = combineWithChildResult;
      this.onPull = onPull;
      this.onEmit = onEmit;
    }
    close(exit3) {
      const fin1 = this.upstreamExecutor.close(exit3);
      const fins = [...this.activeChildExecutors.map((child) => child !== undefined ? child.childExecutor.close(exit3) : undefined), fin1];
      const result = fins.reduce((acc, next) => {
        if (acc !== undefined && next !== undefined) {
          return zipWith5(acc, exit2(next), (exit1, exit22) => zipRight2(exit1, exit22));
        } else if (acc !== undefined) {
          return acc;
        } else if (next !== undefined) {
          return exit2(next);
        } else {
          return;
        }
      }, undefined);
      return result === undefined ? result : result;
    }
    enqueuePullFromChild(child) {
      return new PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
    }
  }

  class DrainChildExecutors {
    upstreamExecutor;
    lastDone;
    activeChildExecutors;
    upstreamDone;
    combineChildResults;
    combineWithChildResult;
    onPull;
    _tag = OP_DRAIN_CHILD_EXECUTORS;
    constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
      this.upstreamExecutor = upstreamExecutor;
      this.lastDone = lastDone;
      this.activeChildExecutors = activeChildExecutors;
      this.upstreamDone = upstreamDone;
      this.combineChildResults = combineChildResults;
      this.combineWithChildResult = combineWithChildResult;
      this.onPull = onPull;
    }
    close(exit3) {
      const fin1 = this.upstreamExecutor.close(exit3);
      const fins = [...this.activeChildExecutors.map((child) => child !== undefined ? child.childExecutor.close(exit3) : undefined), fin1];
      const result = fins.reduce((acc, next) => {
        if (acc !== undefined && next !== undefined) {
          return zipWith5(acc, exit2(next), (exit1, exit22) => zipRight2(exit1, exit22));
        } else if (acc !== undefined) {
          return acc;
        } else if (next !== undefined) {
          return exit2(next);
        } else {
          return;
        }
      }, undefined);
      return result === undefined ? result : result;
    }
    enqueuePullFromChild(child) {
      return new DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
    }
  }

  class Emit2 {
    value;
    next;
    _tag = OP_EMIT3;
    constructor(value, next) {
      this.value = value;
      this.next = next;
    }
    close(exit3) {
      const result = this.next.close(exit3);
      return result === undefined ? result : result;
    }
    enqueuePullFromChild(_child) {
      return this;
    }
  }

  // node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullRequest.js
  var OP_PULLED = "Pulled";
  var OP_NO_UPSTREAM = "NoUpstream";

  // node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
  var UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
  var UpstreamPullRequestTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullRequestSymbolKey);
  var upstreamPullRequestVariance = {
    _A: (_) => _
  };
  var proto8 = {
    [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
  };
  var Pulled = (value) => {
    const op = Object.create(proto8);
    op._tag = OP_PULLED;
    op.value = value;
    return op;
  };
  var NoUpstream = (activeDownstreamCount) => {
    const op = Object.create(proto8);
    op._tag = OP_NO_UPSTREAM;
    op.activeDownstreamCount = activeDownstreamCount;
    return op;
  };

  // node_modules/effect/dist/esm/internal/channel/channelExecutor.js
  class ChannelExecutor {
    _activeSubexecutor = undefined;
    _cancelled = undefined;
    _closeLastSubstream = undefined;
    _currentChannel;
    _done = undefined;
    _doneStack = [];
    _emitted = undefined;
    _executeCloseLastSubstream;
    _input = undefined;
    _inProgressFinalizer = undefined;
    _providedEnv;
    constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
      this._currentChannel = initialChannel;
      this._executeCloseLastSubstream = executeCloseLastSubstream;
      this._providedEnv = providedEnv;
    }
    run() {
      let result = undefined;
      while (result === undefined) {
        if (this._cancelled !== undefined) {
          result = this.processCancellation();
        } else if (this._activeSubexecutor !== undefined) {
          result = this.runSubexecutor();
        } else {
          try {
            if (this._currentChannel === undefined) {
              result = Done2();
            } else {
              if (isEffect2(this._currentChannel)) {
                this._currentChannel = fromEffect4(this._currentChannel);
              }
              switch (this._currentChannel._tag) {
                case OP_BRACKET_OUT: {
                  result = this.runBracketOut(this._currentChannel);
                  break;
                }
                case OP_BRIDGE: {
                  const bridgeInput = this._currentChannel.input;
                  this._currentChannel = this._currentChannel.channel;
                  if (this._input !== undefined) {
                    const inputExecutor = this._input;
                    this._input = undefined;
                    const drainer = () => flatMap11(bridgeInput.awaitRead(), () => suspend3(() => {
                      const state = inputExecutor.run();
                      switch (state._tag) {
                        case OP_DONE3: {
                          return match6(inputExecutor.getDone(), {
                            onFailure: (cause3) => bridgeInput.error(cause3),
                            onSuccess: (value) => bridgeInput.done(value)
                          });
                        }
                        case OP_EMIT2: {
                          return flatMap11(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                        }
                        case OP_FROM_EFFECT3: {
                          return matchCauseEffect3(state.effect, {
                            onFailure: (cause3) => bridgeInput.error(cause3),
                            onSuccess: () => drainer()
                          });
                        }
                        case OP_READ2: {
                          return readUpstream(state, () => drainer(), (cause3) => bridgeInput.error(cause3));
                        }
                      }
                    }));
                    result = fromEffect5(flatMap11(forkDaemon2(interruptible4(drainer())), (fiber) => sync3(() => this.addFinalizer((exit3) => flatMap11(interrupt6(fiber), () => suspend3(() => {
                      const effect3 = this.restorePipe(exit3, inputExecutor);
                      return effect3 !== undefined ? effect3 : _void;
                    }))))));
                  }
                  break;
                }
                case OP_CONCAT_ALL: {
                  const executor = new ChannelExecutor(this._currentChannel.value(), this._providedEnv, (effect3) => sync3(() => {
                    const prevLastClose = this._closeLastSubstream === undefined ? _void : this._closeLastSubstream;
                    this._closeLastSubstream = pipe(prevLastClose, zipRight3(effect3));
                  }));
                  executor._input = this._input;
                  const channel = this._currentChannel;
                  this._activeSubexecutor = new PullFromUpstream(executor, (value) => channel.k(value), undefined, [], (x, y) => channel.combineInners(x, y), (x, y) => channel.combineAll(x, y), (request2) => channel.onPull(request2), (value) => channel.onEmit(value));
                  this._closeLastSubstream = undefined;
                  this._currentChannel = undefined;
                  break;
                }
                case OP_EMIT: {
                  this._emitted = this._currentChannel.out;
                  this._currentChannel = this._activeSubexecutor !== undefined ? undefined : void_5;
                  result = Emit();
                  break;
                }
                case OP_ENSURING: {
                  this.runEnsuring(this._currentChannel);
                  break;
                }
                case OP_FAIL3: {
                  result = this.doneHalt(this._currentChannel.error());
                  break;
                }
                case OP_FOLD2: {
                  this._doneStack.push(this._currentChannel.k);
                  this._currentChannel = this._currentChannel.channel;
                  break;
                }
                case OP_FROM_EFFECT2: {
                  const effect3 = this._providedEnv === undefined ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide2(this._providedEnv));
                  result = fromEffect5(matchCauseEffect3(effect3, {
                    onFailure: (cause3) => {
                      const state = this.doneHalt(cause3);
                      return state !== undefined && isFromEffect(state) ? state.effect : _void;
                    },
                    onSuccess: (value) => {
                      const state = this.doneSucceed(value);
                      return state !== undefined && isFromEffect(state) ? state.effect : _void;
                    }
                  }));
                  break;
                }
                case OP_PIPE_TO: {
                  const previousInput = this._input;
                  const leftExec = new ChannelExecutor(this._currentChannel.left(), this._providedEnv, (effect3) => this._executeCloseLastSubstream(effect3));
                  leftExec._input = previousInput;
                  this._input = leftExec;
                  this.addFinalizer((exit3) => {
                    const effect3 = this.restorePipe(exit3, previousInput);
                    return effect3 !== undefined ? effect3 : _void;
                  });
                  this._currentChannel = this._currentChannel.right();
                  break;
                }
                case OP_PROVIDE2: {
                  const previousEnv = this._providedEnv;
                  this._providedEnv = this._currentChannel.context();
                  this._currentChannel = this._currentChannel.inner;
                  this.addFinalizer(() => sync3(() => {
                    this._providedEnv = previousEnv;
                  }));
                  break;
                }
                case OP_READ: {
                  const read = this._currentChannel;
                  result = Read(this._input, identity, (emitted) => {
                    try {
                      this._currentChannel = read.more(emitted);
                    } catch (error) {
                      this._currentChannel = read.done.onExit(die3(error));
                    }
                    return;
                  }, (exit3) => {
                    const onExit4 = (exit4) => {
                      return read.done.onExit(exit4);
                    };
                    this._currentChannel = onExit4(exit3);
                    return;
                  });
                  break;
                }
                case OP_SUCCEED: {
                  result = this.doneSucceed(this._currentChannel.evaluate());
                  break;
                }
                case OP_SUCCEED_NOW: {
                  result = this.doneSucceed(this._currentChannel.terminal);
                  break;
                }
                case OP_SUSPEND2: {
                  this._currentChannel = this._currentChannel.channel();
                  break;
                }
              }
            }
          } catch (error) {
            this._currentChannel = failCause10(die4(error));
          }
        }
      }
      return result;
    }
    getDone() {
      return this._done;
    }
    getEmit() {
      return this._emitted;
    }
    cancelWith(exit3) {
      this._cancelled = exit3;
    }
    clearInProgressFinalizer() {
      this._inProgressFinalizer = undefined;
    }
    storeInProgressFinalizer(finalizer) {
      this._inProgressFinalizer = finalizer;
    }
    popAllFinalizers(exit3) {
      const finalizers = [];
      let next = this._doneStack.pop();
      while (next) {
        if (next._tag === "ContinuationFinalizer") {
          finalizers.push(next.finalizer);
        }
        next = this._doneStack.pop();
      }
      const effect3 = finalizers.length === 0 ? _void : runFinalizers(finalizers, exit3);
      this.storeInProgressFinalizer(effect3);
      return effect3;
    }
    popNextFinalizers() {
      const builder = [];
      while (this._doneStack.length !== 0) {
        const cont = this._doneStack[this._doneStack.length - 1];
        if (cont._tag === OP_CONTINUATION_K) {
          return builder;
        }
        builder.push(cont);
        this._doneStack.pop();
      }
      return builder;
    }
    restorePipe(exit3, prev) {
      const currInput = this._input;
      this._input = prev;
      if (currInput !== undefined) {
        const effect3 = currInput.close(exit3);
        return effect3;
      }
      return _void;
    }
    close(exit3) {
      let runInProgressFinalizers = undefined;
      const finalizer = this._inProgressFinalizer;
      if (finalizer !== undefined) {
        runInProgressFinalizers = pipe(finalizer, ensuring2(sync3(() => this.clearInProgressFinalizer())));
      }
      let closeSelf = undefined;
      const selfFinalizers = this.popAllFinalizers(exit3);
      if (selfFinalizers !== undefined) {
        closeSelf = pipe(selfFinalizers, ensuring2(sync3(() => this.clearInProgressFinalizer())));
      }
      const closeSubexecutors = this._activeSubexecutor === undefined ? undefined : this._activeSubexecutor.close(exit3);
      if (closeSubexecutors === undefined && runInProgressFinalizers === undefined && closeSelf === undefined) {
        return;
      }
      return pipe(exit2(ifNotNull(closeSubexecutors)), zip5(exit2(ifNotNull(runInProgressFinalizers))), zip5(exit2(ifNotNull(closeSelf))), map16(([[exit1, exit22], exit32]) => pipe(exit1, zipRight2(exit22), zipRight2(exit32))), uninterruptible2, flatMap11((exit4) => suspend3(() => exit4)));
    }
    doneSucceed(value) {
      if (this._doneStack.length === 0) {
        this._done = succeed3(value);
        this._currentChannel = undefined;
        return Done2();
      }
      const head5 = this._doneStack[this._doneStack.length - 1];
      if (head5._tag === OP_CONTINUATION_K) {
        this._doneStack.pop();
        this._currentChannel = head5.onSuccess(value);
        return;
      }
      const finalizers = this.popNextFinalizers();
      if (this._doneStack.length === 0) {
        this._doneStack = finalizers.reverse();
        this._done = succeed3(value);
        this._currentChannel = undefined;
        return Done2();
      }
      const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), succeed3(value));
      this.storeInProgressFinalizer(finalizerEffect);
      const effect3 = pipe(finalizerEffect, ensuring2(sync3(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap11(() => sync3(() => this.doneSucceed(value))));
      return fromEffect5(effect3);
    }
    doneHalt(cause3) {
      if (this._doneStack.length === 0) {
        this._done = failCause3(cause3);
        this._currentChannel = undefined;
        return Done2();
      }
      const head5 = this._doneStack[this._doneStack.length - 1];
      if (head5._tag === OP_CONTINUATION_K) {
        this._doneStack.pop();
        try {
          this._currentChannel = head5.onHalt(cause3);
        } catch (error) {
          this._currentChannel = failCause10(die4(error));
        }
        return;
      }
      const finalizers = this.popNextFinalizers();
      if (this._doneStack.length === 0) {
        this._doneStack = finalizers.reverse();
        this._done = failCause3(cause3);
        this._currentChannel = undefined;
        return Done2();
      }
      const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), failCause3(cause3));
      this.storeInProgressFinalizer(finalizerEffect);
      const effect3 = pipe(finalizerEffect, ensuring2(sync3(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap11(() => sync3(() => this.doneHalt(cause3))));
      return fromEffect5(effect3);
    }
    processCancellation() {
      this._currentChannel = undefined;
      this._done = this._cancelled;
      this._cancelled = undefined;
      return Done2();
    }
    runBracketOut(bracketOut) {
      const effect3 = uninterruptible2(matchCauseEffect3(this.provide(bracketOut.acquire()), {
        onFailure: (cause3) => sync3(() => {
          this._currentChannel = failCause10(cause3);
        }),
        onSuccess: (out) => sync3(() => {
          this.addFinalizer((exit3) => this.provide(bracketOut.finalizer(out, exit3)));
          this._currentChannel = write(out);
        })
      }));
      return fromEffect5(effect3);
    }
    provide(effect3) {
      if (this._providedEnv === undefined) {
        return effect3;
      }
      return pipe(effect3, provide2(this._providedEnv));
    }
    runEnsuring(ensuring3) {
      this.addFinalizer(ensuring3.finalizer);
      this._currentChannel = ensuring3.channel;
    }
    addFinalizer(f) {
      this._doneStack.push(new ContinuationFinalizerImpl(f));
    }
    runSubexecutor() {
      const subexecutor = this._activeSubexecutor;
      switch (subexecutor._tag) {
        case OP_PULL_FROM_CHILD: {
          return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
        }
        case OP_PULL_FROM_UPSTREAM: {
          return this.pullFromUpstream(subexecutor);
        }
        case OP_DRAIN_CHILD_EXECUTORS: {
          return this.drainChildExecutors(subexecutor);
        }
        case OP_EMIT3: {
          this._emitted = subexecutor.value;
          this._activeSubexecutor = subexecutor.next;
          return Emit();
        }
      }
    }
    replaceSubexecutor(nextSubExec) {
      this._currentChannel = undefined;
      this._activeSubexecutor = nextSubExec;
    }
    finishWithExit(exit3) {
      const state = match6(exit3, {
        onFailure: (cause3) => this.doneHalt(cause3),
        onSuccess: (value) => this.doneSucceed(value)
      });
      this._activeSubexecutor = undefined;
      return state === undefined ? _void : effect2(state);
    }
    finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
      this.addFinalizer(() => pipe(closeFuncs, forEach6((closeFunc) => pipe(sync3(() => closeFunc(subexecutorDone)), flatMap11((closeEffect) => closeEffect !== undefined ? closeEffect : _void)), {
        discard: true
      })));
      const state = pipe(subexecutorDone, match6({
        onFailure: (cause3) => this.doneHalt(cause3),
        onSuccess: (value) => this.doneSucceed(value)
      }));
      this._activeSubexecutor = undefined;
      return state;
    }
    applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
      switch (strategy._tag) {
        case OP_PULL_AFTER_NEXT: {
          const shouldPrepend = !upstreamFinished || queue.some((subexecutor) => subexecutor !== undefined);
          return [strategy.emitSeparator, shouldPrepend ? [undefined, ...queue] : queue];
        }
        case OP_PULL_AFTER_ALL_ENQUEUED: {
          const shouldEnqueue = !upstreamFinished || queue.some((subexecutor) => subexecutor !== undefined);
          return [strategy.emitSeparator, shouldEnqueue ? [...queue, undefined] : queue];
        }
      }
    }
    pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
      return Read(childExecutor, identity, (emitted) => {
        const childExecutorDecision = onEmitted(emitted);
        switch (childExecutorDecision._tag) {
          case OP_CONTINUE2: {
            break;
          }
          case OP_CLOSE: {
            this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
            break;
          }
          case OP_YIELD2: {
            const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
            this.replaceSubexecutor(modifiedParent);
            break;
          }
        }
        this._activeSubexecutor = new Emit2(emitted, this._activeSubexecutor);
        return;
      }, match6({
        onFailure: (cause3) => {
          const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3);
          return state === undefined ? undefined : effectOrUndefinedIgnored(state);
        },
        onSuccess: (doneValue) => {
          this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
          return;
        }
      }));
    }
    finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
      const subexecutor = parentSubexecutor;
      switch (subexecutor._tag) {
        case OP_PULL_FROM_UPSTREAM: {
          const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
          this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
          this.replaceSubexecutor(modifiedParent);
          break;
        }
        case OP_DRAIN_CHILD_EXECUTORS: {
          const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
          this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
          this.replaceSubexecutor(modifiedParent);
          break;
        }
        default: {
          break;
        }
      }
    }
    handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3) {
      return this.finishSubexecutorWithCloseEffect(failCause3(cause3), (exit3) => parentSubexecutor.close(exit3), (exit3) => childExecutor.close(exit3));
    }
    pullFromUpstream(subexecutor) {
      if (subexecutor.activeChildExecutors.length === 0) {
        return this.performPullFromUpstream(subexecutor);
      }
      const activeChild = subexecutor.activeChildExecutors[0];
      const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
      if (activeChild === undefined) {
        return this.performPullFromUpstream(parentSubexecutor);
      }
      this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
      return;
    }
    performPullFromUpstream(subexecutor) {
      return Read(subexecutor.upstreamExecutor, (effect3) => {
        const closeLastSubstream = this._closeLastSubstream === undefined ? _void : this._closeLastSubstream;
        this._closeLastSubstream = undefined;
        return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight3(effect3));
      }, (emitted) => {
        if (this._closeLastSubstream !== undefined) {
          const closeLastSubstream = this._closeLastSubstream;
          this._closeLastSubstream = undefined;
          return pipe(this._executeCloseLastSubstream(closeLastSubstream), map16(() => {
            const childExecutor2 = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
            childExecutor2._input = this._input;
            const [emitSeparator2, updatedChildExecutors2] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
            this._activeSubexecutor = new PullFromChild(childExecutor2, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors2, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
            if (isSome2(emitSeparator2)) {
              this._activeSubexecutor = new Emit2(emitSeparator2.value, this._activeSubexecutor);
            }
            return;
          }));
        }
        const childExecutor = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
        childExecutor._input = this._input;
        const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
        this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
        if (isSome2(emitSeparator)) {
          this._activeSubexecutor = new Emit2(emitSeparator.value, this._activeSubexecutor);
        }
        return;
      }, (exit3) => {
        if (subexecutor.activeChildExecutors.some((subexecutor2) => subexecutor2 !== undefined)) {
          const drain = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [undefined, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
          if (this._closeLastSubstream !== undefined) {
            const closeLastSubstream2 = this._closeLastSubstream;
            this._closeLastSubstream = undefined;
            return pipe(this._executeCloseLastSubstream(closeLastSubstream2), map16(() => this.replaceSubexecutor(drain)));
          }
          this.replaceSubexecutor(drain);
          return;
        }
        const closeLastSubstream = this._closeLastSubstream;
        const state = this.finishSubexecutorWithCloseEffect(pipe(exit3, map11((a) => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, (exit4) => subexecutor.upstreamExecutor.close(exit4));
        return state === undefined ? undefined : effectOrUndefinedIgnored(state);
      });
    }
    drainChildExecutors(subexecutor) {
      if (subexecutor.activeChildExecutors.length === 0) {
        const lastClose = this._closeLastSubstream;
        if (lastClose !== undefined) {
          this.addFinalizer(() => succeed8(lastClose));
        }
        return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, (exit3) => subexecutor.upstreamExecutor.close(exit3));
      }
      const activeChild = subexecutor.activeChildExecutors[0];
      const rest = subexecutor.activeChildExecutors.slice(1);
      if (activeChild === undefined) {
        const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n, curr) => curr !== undefined ? n + 1 : n, 0))));
        this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
        if (isSome2(emitSeparator)) {
          this._emitted = emitSeparator.value;
          return Emit();
        }
        return;
      }
      const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
      this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
      return;
    }
  }
  var ifNotNull = (effect3) => effect3 !== undefined ? effect3 : _void;
  var runFinalizers = (finalizers, exit3) => {
    return pipe(forEach6(finalizers, (fin) => exit2(fin(exit3))), map16((exits) => pipe(all(exits), getOrElse(() => void_2))), flatMap11((exit4) => suspend3(() => exit4)));
  };
  var readUpstream = (r, onSuccess, onFailure) => {
    const readStack = [r];
    const read = () => {
      const current = readStack.pop();
      if (current === undefined || current.upstream === undefined) {
        return dieMessage2("Unexpected end of input for channel execution");
      }
      const state = current.upstream.run();
      switch (state._tag) {
        case OP_EMIT2: {
          const emitEffect = current.onEmit(current.upstream.getEmit());
          if (readStack.length === 0) {
            if (emitEffect === undefined) {
              return suspend3(onSuccess);
            }
            return pipe(emitEffect, matchCauseEffect3({
              onFailure,
              onSuccess
            }));
          }
          if (emitEffect === undefined) {
            return suspend3(() => read());
          }
          return pipe(emitEffect, matchCauseEffect3({
            onFailure,
            onSuccess: () => read()
          }));
        }
        case OP_DONE3: {
          const doneEffect = current.onDone(current.upstream.getDone());
          if (readStack.length === 0) {
            if (doneEffect === undefined) {
              return suspend3(onSuccess);
            }
            return pipe(doneEffect, matchCauseEffect3({
              onFailure,
              onSuccess
            }));
          }
          if (doneEffect === undefined) {
            return suspend3(() => read());
          }
          return pipe(doneEffect, matchCauseEffect3({
            onFailure,
            onSuccess: () => read()
          }));
        }
        case OP_FROM_EFFECT3: {
          readStack.push(current);
          return pipe(current.onEffect(state.effect), catchAllCause3((cause3) => suspend3(() => {
            const doneEffect = current.onDone(failCause3(cause3));
            return doneEffect === undefined ? _void : doneEffect;
          })), matchCauseEffect3({
            onFailure,
            onSuccess: () => read()
          }));
        }
        case OP_READ2: {
          readStack.push(current);
          readStack.push(state);
          return suspend3(() => read());
        }
      }
    };
    return read();
  };
  var runIn = /* @__PURE__ */ dual(2, (self, scope5) => {
    const run = (channelDeferred, scopeDeferred, scope6) => acquireUseRelease2(sync3(() => new ChannelExecutor(self, undefined, identity)), (exec) => suspend3(() => runScopedInterpret(exec.run(), exec).pipe(intoDeferred2(channelDeferred), zipRight3(_await(channelDeferred)), zipLeft2(_await(scopeDeferred)))), (exec, exit3) => {
      const finalize = exec.close(exit3);
      if (finalize === undefined) {
        return _void;
      }
      return tapErrorCause3(finalize, (cause3) => addFinalizer2(scope6, failCause8(cause3)));
    });
    return uninterruptibleMask3((restore) => all4([fork2(scope5, sequential3), make18(), make18()]).pipe(flatMap11(([child, channelDeferred, scopeDeferred]) => restore(run(channelDeferred, scopeDeferred, child)).pipe(forkIn2(scope5), flatMap11((fiber) => scope5.addFinalizer((exit3) => {
      const interruptors3 = isFailure(exit3) ? interruptors2(exit3.cause) : undefined;
      return isDone(channelDeferred).pipe(flatMap11((isDone6) => isDone6 ? succeed2(scopeDeferred, undefined).pipe(zipRight3(_await3(fiber)), zipRight3(inheritAll2(fiber))) : succeed2(scopeDeferred, undefined).pipe(zipRight3(interruptors3 && size3(interruptors3) > 0 ? interruptAs(fiber, combineAll2(interruptors3)) : interrupt6(fiber)), zipRight3(inheritAll2(fiber)))));
    }).pipe(zipRight3(restore(_await(channelDeferred)))))))));
  });
  var runScopedInterpret = (channelState, exec) => {
    const op = channelState;
    switch (op._tag) {
      case OP_FROM_EFFECT3: {
        return pipe(op.effect, flatMap11(() => runScopedInterpret(exec.run(), exec)));
      }
      case OP_EMIT2: {
        return runScopedInterpret(exec.run(), exec);
      }
      case OP_DONE3: {
        return suspend3(() => exec.getDone());
      }
      case OP_READ2: {
        return readUpstream(op, () => runScopedInterpret(exec.run(), exec), failCause8);
      }
    }
  };

  // node_modules/effect/dist/esm/internal/opCodes/channelMergeDecision.js
  var OP_DONE4 = "Done";
  var OP_AWAIT = "Await";

  // node_modules/effect/dist/esm/internal/channel/mergeDecision.js
  var MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
  var MergeDecisionTypeId = /* @__PURE__ */ Symbol.for(MergeDecisionSymbolKey);
  var proto9 = {
    [MergeDecisionTypeId]: {
      _R: (_) => _,
      _E0: (_) => _,
      _Z0: (_) => _,
      _E: (_) => _,
      _Z: (_) => _
    }
  };
  var Done3 = (effect3) => {
    const op = Object.create(proto9);
    op._tag = OP_DONE4;
    op.effect = effect3;
    return op;
  };
  var Await = (f) => {
    const op = Object.create(proto9);
    op._tag = OP_AWAIT;
    op.f = f;
    return op;
  };

  // node_modules/effect/dist/esm/internal/opCodes/channelMergeState.js
  var OP_BOTH_RUNNING = "BothRunning";
  var OP_LEFT_DONE = "LeftDone";
  var OP_RIGHT_DONE = "RightDone";

  // node_modules/effect/dist/esm/internal/channel/mergeState.js
  var MergeStateSymbolKey = "effect/ChannelMergeState";
  var MergeStateTypeId = /* @__PURE__ */ Symbol.for(MergeStateSymbolKey);
  var proto10 = {
    [MergeStateTypeId]: MergeStateTypeId
  };
  var BothRunning = (left3, right3) => {
    const op = Object.create(proto10);
    op._tag = OP_BOTH_RUNNING;
    op.left = left3;
    op.right = right3;
    return op;
  };
  var LeftDone = (f) => {
    const op = Object.create(proto10);
    op._tag = OP_LEFT_DONE;
    op.f = f;
    return op;
  };
  var RightDone = (f) => {
    const op = Object.create(proto10);
    op._tag = OP_RIGHT_DONE;
    op.f = f;
    return op;
  };

  // node_modules/effect/dist/esm/internal/opCodes/channelMergeStrategy.js
  var OP_BACK_PRESSURE = "BackPressure";
  var OP_BUFFER_SLIDING = "BufferSliding";

  // node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
  var MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
  var MergeStrategyTypeId = /* @__PURE__ */ Symbol.for(MergeStrategySymbolKey);
  var proto11 = {
    [MergeStrategyTypeId]: MergeStrategyTypeId
  };
  var BackPressure = (_) => {
    const op = Object.create(proto11);
    op._tag = OP_BACK_PRESSURE;
    return op;
  };
  var BufferSliding = (_) => {
    const op = Object.create(proto11);
    op._tag = OP_BUFFER_SLIDING;
    return op;
  };
  var match14 = /* @__PURE__ */ dual(2, (self, {
    onBackPressure,
    onBufferSliding
  }) => {
    switch (self._tag) {
      case OP_BACK_PRESSURE: {
        return onBackPressure();
      }
      case OP_BUFFER_SLIDING: {
        return onBufferSliding();
      }
    }
  });

  // node_modules/effect/dist/esm/internal/channel/singleProducerAsyncInput.js
  var OP_STATE_EMPTY = "Empty";
  var OP_STATE_EMIT = "Emit";
  var OP_STATE_ERROR = "Error";
  var OP_STATE_DONE2 = "Done";
  var stateEmpty = (notifyProducer) => ({
    _tag: OP_STATE_EMPTY,
    notifyProducer
  });
  var stateEmit = (notifyConsumers) => ({
    _tag: OP_STATE_EMIT,
    notifyConsumers
  });
  var stateError = (cause3) => ({
    _tag: OP_STATE_ERROR,
    cause: cause3
  });
  var stateDone = (done8) => ({
    _tag: OP_STATE_DONE2,
    done: done8
  });

  class SingleProducerAsyncInputImpl {
    ref;
    constructor(ref) {
      this.ref = ref;
    }
    awaitRead() {
      return flatten9(modify4(this.ref, (state) => state._tag === OP_STATE_EMPTY ? [_await(state.notifyProducer), state] : [_void, state]));
    }
    get close() {
      return fiberIdWith2((fiberId3) => this.error(interrupt5(fiberId3)));
    }
    done(value) {
      return flatten9(modify4(this.ref, (state) => {
        switch (state._tag) {
          case OP_STATE_EMPTY: {
            return [_await(state.notifyProducer), state];
          }
          case OP_STATE_EMIT: {
            return [forEach6(state.notifyConsumers, (deferred) => succeed2(deferred, left2(value)), {
              discard: true
            }), stateDone(value)];
          }
          case OP_STATE_ERROR: {
            return [interrupt7, state];
          }
          case OP_STATE_DONE2: {
            return [interrupt7, state];
          }
        }
      }));
    }
    emit(element) {
      return flatMap11(make18(), (deferred) => flatten9(modify4(this.ref, (state) => {
        switch (state._tag) {
          case OP_STATE_EMPTY: {
            return [_await(state.notifyProducer), state];
          }
          case OP_STATE_EMIT: {
            const notifyConsumer = state.notifyConsumers[0];
            const notifyConsumers = state.notifyConsumers.slice(1);
            if (notifyConsumer !== undefined) {
              return [succeed2(notifyConsumer, right2(element)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
            }
            throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues");
          }
          case OP_STATE_ERROR: {
            return [interrupt7, state];
          }
          case OP_STATE_DONE2: {
            return [interrupt7, state];
          }
        }
      })));
    }
    error(cause3) {
      return flatten9(modify4(this.ref, (state) => {
        switch (state._tag) {
          case OP_STATE_EMPTY: {
            return [_await(state.notifyProducer), state];
          }
          case OP_STATE_EMIT: {
            return [forEach6(state.notifyConsumers, (deferred) => failCause2(deferred, cause3), {
              discard: true
            }), stateError(cause3)];
          }
          case OP_STATE_ERROR: {
            return [interrupt7, state];
          }
          case OP_STATE_DONE2: {
            return [interrupt7, state];
          }
        }
      }));
    }
    get take() {
      return this.takeWith((cause3) => failCause3(map12(cause3, left2)), (elem) => succeed3(elem), (done8) => fail4(right2(done8)));
    }
    takeWith(onError3, onElement, onDone) {
      return flatMap11(make18(), (deferred) => flatten9(modify4(this.ref, (state) => {
        switch (state._tag) {
          case OP_STATE_EMPTY: {
            return [zipRight3(succeed2(state.notifyProducer, undefined), matchCause3(_await(deferred), {
              onFailure: onError3,
              onSuccess: match({
                onLeft: onDone,
                onRight: onElement
              })
            })), stateEmit([deferred])];
          }
          case OP_STATE_EMIT: {
            return [matchCause3(_await(deferred), {
              onFailure: onError3,
              onSuccess: match({
                onLeft: onDone,
                onRight: onElement
              })
            }), stateEmit([...state.notifyConsumers, deferred])];
          }
          case OP_STATE_ERROR: {
            return [succeed8(onError3(state.cause)), state];
          }
          case OP_STATE_DONE2: {
            return [succeed8(onDone(state.done)), state];
          }
        }
      })));
    }
  }
  var make42 = () => pipe(make18(), flatMap11((deferred) => make28(stateEmpty(deferred))), map16((ref) => new SingleProducerAsyncInputImpl(ref)));

  // node_modules/effect/dist/esm/internal/channel.js
  var acquireUseRelease3 = (acquire, use, release) => flatMap13(fromEffect4(make28(() => _void)), (ref) => pipe(fromEffect4(uninterruptible2(tap3(acquire, (a) => set6(ref, (exit3) => release(a, exit3))))), flatMap13(use), ensuringWith((exit3) => flatMap11(get12(ref), (f) => f(exit3)))));
  var as4 = /* @__PURE__ */ dual(2, (self, value) => map18(self, () => value));
  var catchAll5 = /* @__PURE__ */ dual(2, (self, f) => catchAllCause5(self, (cause3) => match(failureOrCause2(cause3), {
    onLeft: f,
    onRight: failCause10
  })));
  var concatMap = /* @__PURE__ */ dual(2, (self, f) => concatMapWith(self, f, () => {
    return;
  }, () => {
    return;
  }));
  var drain = (self) => {
    const drainer = readWithCause({
      onInput: () => drainer,
      onFailure: failCause10,
      onDone: succeed10
    });
    return pipeTo(self, drainer);
  };
  var ensuring3 = /* @__PURE__ */ dual(2, (self, finalizer) => ensuringWith(self, () => finalizer));
  var flatten11 = (self) => flatMap13(self, identity);
  var foldChannel = /* @__PURE__ */ dual(2, (self, options) => foldCauseChannel(self, {
    onFailure: (cause3) => {
      const either4 = failureOrCause2(cause3);
      switch (either4._tag) {
        case "Left": {
          return options.onFailure(either4.left);
        }
        case "Right": {
          return failCause10(either4.right);
        }
      }
    },
    onSuccess: options.onSuccess
  }));
  var fromInput = (input) => unwrap(input.takeWith(failCause10, (elem) => flatMap13(write(elem), () => fromInput(input)), succeed10));
  var fromQueue = (queue) => suspend5(() => fromQueueInternal(queue));
  var fromQueueInternal = (queue) => pipe(fromEffect4(take3(queue)), flatMap13(match({
    onLeft: match6({
      onFailure: failCause10,
      onSuccess: succeedNow
    }),
    onRight: (elem) => flatMap13(write(elem), () => fromQueueInternal(queue))
  })));
  var identityChannel = () => readWith({
    onInput: (input) => flatMap13(write(input), () => identityChannel()),
    onFailure: fail11,
    onDone: succeedNow
  });
  var interruptWhen = /* @__PURE__ */ dual(2, (self, effect3) => mergeWith2(self, {
    other: fromEffect4(effect3),
    onSelfDone: (selfDone) => Done3(suspend3(() => selfDone)),
    onOtherDone: (effectDone) => Done3(suspend3(() => effectDone))
  }));
  var interruptWhenDeferred = /* @__PURE__ */ dual(2, (self, deferred) => interruptWhen(self, _await(deferred)));
  var map18 = /* @__PURE__ */ dual(2, (self, f) => flatMap13(self, (a) => sync5(() => f(a))));
  var mapError5 = /* @__PURE__ */ dual(2, (self, f) => mapErrorCause3(self, map12(f)));
  var mapErrorCause3 = /* @__PURE__ */ dual(2, (self, f) => catchAllCause5(self, (cause3) => failCause10(f(cause3))));
  var mapOut = /* @__PURE__ */ dual(2, (self, f) => {
    const reader = readWith({
      onInput: (outElem) => flatMap13(write(f(outElem)), () => reader),
      onFailure: fail11,
      onDone: succeedNow
    });
    return pipeTo(self, reader);
  });
  var mapOutEffect = /* @__PURE__ */ dual(2, (self, f) => {
    const reader = readWithCause({
      onInput: (outElem) => pipe(fromEffect4(f(outElem)), flatMap13(write), flatMap13(() => reader)),
      onFailure: failCause10,
      onDone: succeedNow
    });
    return pipeTo(self, reader);
  });
  var mapOutEffectPar = /* @__PURE__ */ dual(3, (self, f, n) => unwrapScopedWith((scope5) => gen2(function* () {
    const input = yield* make42();
    const queueReader = fromInput(input);
    const queue = yield* bounded5(n);
    yield* addFinalizer2(scope5, shutdown4(queue));
    const errorSignal = yield* make18();
    const withPermits = n === Number.POSITIVE_INFINITY ? (_) => identity : (yield* makeSemaphore2(n)).withPermits;
    const pull = yield* queueReader.pipe(pipeTo(self), toPullIn(scope5));
    yield* pull.pipe(matchCauseEffect3({
      onFailure: (cause3) => offer3(queue, failCause8(cause3)),
      onSuccess: match({
        onLeft: (outDone) => zipRight3(interruptible4(withPermits(n)(_void)), asVoid3(offer3(queue, succeed8(left2(outDone))))),
        onRight: (outElem) => gen2(function* () {
          const deferred = yield* make18();
          const latch = yield* make18();
          yield* offer3(queue, map16(_await(deferred), right2));
          yield* succeed2(latch, undefined).pipe(zipRight3(uninterruptibleMask3((restore) => exit2(restore(_await(errorSignal))).pipe(raceFirst2(exit2(restore(f(outElem)))), flatMap11(identity))).pipe(tapErrorCause3((cause3) => failCause2(errorSignal, cause3)), intoDeferred2(deferred))), withPermits(1), forkIn2(scope5));
          yield* _await(latch);
        })
      })
    }), forever3, interruptible4, forkIn2(scope5));
    const consumer = unwrap(matchCause3(flatten9(take3(queue)), {
      onFailure: failCause10,
      onSuccess: match({
        onLeft: succeedNow,
        onRight: (outElem) => flatMap13(write(outElem), () => consumer)
      })
    }));
    return embedInput(consumer, input);
  })));
  var mergeAll7 = (options) => {
    return (channels) => mergeAllWith(options)(channels, constVoid);
  };
  var mergeAllWith = ({
    bufferSize = 16,
    concurrency,
    mergeStrategy = BackPressure()
  }) => (channels, f) => unwrapScopedWith((scope5) => gen2(function* () {
    const concurrencyN = concurrency === "unbounded" ? Number.MAX_SAFE_INTEGER : concurrency;
    const input = yield* make42();
    const queueReader = fromInput(input);
    const queue = yield* bounded5(bufferSize);
    yield* addFinalizer2(scope5, shutdown4(queue));
    const cancelers = yield* unbounded5();
    yield* addFinalizer2(scope5, shutdown4(cancelers));
    const lastDone = yield* make28(none2());
    const errorSignal = yield* make18();
    const withPermits = (yield* makeSemaphore2(concurrencyN)).withPermits;
    const pull = yield* toPullIn(pipeTo(queueReader, channels), scope5);
    function evaluatePull(pull2) {
      return pull2.pipe(flatMap11(match({
        onLeft: (done8) => succeed8(some2(done8)),
        onRight: (outElem) => as3(offer3(queue, succeed8(right2(outElem))), none2())
      })), repeat({
        until: (_) => isSome2(_)
      }), flatMap11((outDone) => update3(lastDone, match2({
        onNone: () => some2(outDone.value),
        onSome: (lastDone2) => some2(f(lastDone2, outDone.value))
      }))), catchAllCause3((cause3) => isInterrupted2(cause3) ? failCause8(cause3) : offer3(queue, failCause8(cause3)).pipe(zipRight3(succeed2(errorSignal, undefined)), asVoid3)));
    }
    yield* pull.pipe(matchCauseEffect3({
      onFailure: (cause3) => offer3(queue, failCause8(cause3)).pipe(zipRight3(succeed8(false))),
      onSuccess: match({
        onLeft: (outDone) => raceWith2(interruptible4(_await(errorSignal)), interruptible4(withPermits(concurrencyN)(_void)), {
          onSelfDone: (_, permitAcquisition) => as3(interrupt6(permitAcquisition), false),
          onOtherDone: (_, failureAwait) => zipRight3(interrupt6(failureAwait), get12(lastDone).pipe(flatMap11(match2({
            onNone: () => offer3(queue, succeed8(left2(outDone))),
            onSome: (lastDone2) => offer3(queue, succeed8(left2(f(lastDone2, outDone))))
          })), as3(false)))
        }),
        onRight: (channel) => match14(mergeStrategy, {
          onBackPressure: () => gen2(function* () {
            const latch = yield* make18();
            const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel), scope6).pipe(flatMap11((pull2) => race2(exit2(evaluatePull(pull2)), exit2(interruptible4(_await(errorSignal))))), flatMap11(identity)));
            yield* succeed2(latch, undefined).pipe(zipRight3(raceEffects), withPermits(1), forkIn2(scope5));
            yield* _await(latch);
            const errored = yield* isDone(errorSignal);
            return !errored;
          }),
          onBufferSliding: () => gen2(function* () {
            const canceler = yield* make18();
            const latch = yield* make18();
            const size11 = yield* size10(cancelers);
            yield* take3(cancelers).pipe(flatMap11((canceler2) => succeed2(canceler2, undefined)), when2(() => size11 >= concurrencyN));
            yield* offer3(cancelers, canceler);
            const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel), scope6).pipe(flatMap11((pull2) => exit2(evaluatePull(pull2)).pipe(race2(exit2(interruptible4(_await(errorSignal)))), race2(exit2(interruptible4(_await(canceler)))))), flatMap11(identity)));
            yield* succeed2(latch, undefined).pipe(zipRight3(raceEffects), withPermits(1), forkIn2(scope5));
            yield* _await(latch);
            const errored = yield* isDone(errorSignal);
            return !errored;
          })
        })
      })
    }), repeat({
      while: (_) => _
    }), forkIn2(scope5));
    const consumer = pipe(take3(queue), flatten9, matchCause3({
      onFailure: failCause10,
      onSuccess: match({
        onLeft: succeedNow,
        onRight: (outElem) => flatMap13(write(outElem), () => consumer)
      })
    }), unwrap);
    return embedInput(consumer, input);
  }));
  var mergeMap = /* @__PURE__ */ dual(3, (self, f, options) => mergeAll7(options)(mapOut(self, f)));
  var mergeWith2 = /* @__PURE__ */ dual(2, (self, options) => {
    function merge9(scope5) {
      return gen2(function* () {
        const input = yield* make42();
        const queueReader = fromInput(input);
        const pullL = yield* toPullIn(pipeTo(queueReader, self), scope5);
        const pullR = yield* toPullIn(pipeTo(queueReader, options.other), scope5);
        function handleSide(exit3, fiber, pull) {
          return (done8, both2, single2) => {
            function onDecision(decision) {
              const op = decision;
              if (op._tag === OP_DONE4) {
                return succeed8(fromEffect4(zipRight3(interrupt6(fiber), op.effect)));
              }
              return map16(_await3(fiber), match6({
                onFailure: (cause3) => fromEffect4(op.f(failCause3(cause3))),
                onSuccess: match({
                  onLeft: (done9) => fromEffect4(op.f(succeed3(done9))),
                  onRight: (elem) => zipRight4(write(elem), go(single2(op.f)))
                })
              }));
            }
            return match6(exit3, {
              onFailure: (cause3) => onDecision(done8(failCause3(cause3))),
              onSuccess: match({
                onLeft: (z) => onDecision(done8(succeed3(z))),
                onRight: (elem) => succeed8(flatMap13(write(elem), () => flatMap13(fromEffect4(forkIn2(interruptible4(pull), scope5)), (leftFiber) => go(both2(leftFiber, fiber)))))
              })
            });
          };
        }
        function go(state) {
          switch (state._tag) {
            case OP_BOTH_RUNNING: {
              const leftJoin = interruptible4(join3(state.left));
              const rightJoin = interruptible4(join3(state.right));
              return unwrap(raceWith2(leftJoin, rightJoin, {
                onSelfDone: (leftExit, rf) => zipRight3(interrupt6(rf), handleSide(leftExit, state.right, pullL)(options.onSelfDone, BothRunning, (f) => LeftDone(f))),
                onOtherDone: (rightExit, lf) => zipRight3(interrupt6(lf), handleSide(rightExit, state.left, pullR)(options.onOtherDone, (left3, right3) => BothRunning(right3, left3), (f) => RightDone(f)))
              }));
            }
            case OP_LEFT_DONE: {
              return unwrap(map16(exit2(pullR), match6({
                onFailure: (cause3) => fromEffect4(state.f(failCause3(cause3))),
                onSuccess: match({
                  onLeft: (done8) => fromEffect4(state.f(succeed3(done8))),
                  onRight: (elem) => flatMap13(write(elem), () => go(LeftDone(state.f)))
                })
              })));
            }
            case OP_RIGHT_DONE: {
              return unwrap(map16(exit2(pullL), match6({
                onFailure: (cause3) => fromEffect4(state.f(failCause3(cause3))),
                onSuccess: match({
                  onLeft: (done8) => fromEffect4(state.f(succeed3(done8))),
                  onRight: (elem) => flatMap13(write(elem), () => go(RightDone(state.f)))
                })
              })));
            }
          }
        }
        return fromEffect4(withFiberRuntime2((parent) => {
          const inherit = withFiberRuntime2((state) => {
            state.transferChildren(parent.scope());
            return _void;
          });
          const leftFiber = interruptible4(pullL).pipe(ensuring2(inherit), forkIn2(scope5));
          const rightFiber = interruptible4(pullR).pipe(ensuring2(inherit), forkIn2(scope5));
          return zipWith5(leftFiber, rightFiber, (left3, right3) => BothRunning(left3, right3));
        })).pipe(flatMap13(go), embedInput(input));
      });
    }
    return unwrapScopedWith(merge9);
  });
  var orDieWith3 = /* @__PURE__ */ dual(2, (self, f) => catchAll5(self, (e) => failCauseSync5(() => die4(f(e)))));
  var orElse7 = /* @__PURE__ */ dual(2, (self, that) => catchAll5(self, that));
  var pipeToOrFail = /* @__PURE__ */ dual(2, (self, that) => suspend5(() => {
    let channelException = undefined;
    const reader = readWith({
      onInput: (outElem) => flatMap13(write(outElem), () => reader),
      onFailure: (outErr) => {
        channelException = ChannelException(outErr);
        return failCause10(die4(channelException));
      },
      onDone: succeedNow
    });
    const writer = readWithCause({
      onInput: (outElem) => pipe(write(outElem), flatMap13(() => writer)),
      onFailure: (cause3) => isDieType2(cause3) && isChannelException(cause3.defect) && equals(cause3.defect, channelException) ? fail11(cause3.defect.error) : failCause10(cause3),
      onDone: succeedNow
    });
    return pipeTo(pipeTo(pipeTo(self, reader), that), writer);
  }));
  var repeated = (self) => flatMap13(self, () => repeated(self));
  var run = (self) => scopedWith2((scope5) => runIn(self, scope5));
  var runDrain = (self) => run(drain(self));
  var runScoped = (self) => scopeWith2((scope5) => runIn(self, scope5));
  var scoped4 = (effect3) => unwrap(uninterruptibleMask3((restore) => map16(make38(), (scope5) => acquireReleaseOut(tapErrorCause3(restore(extend2(effect3, scope5)), (cause3) => close(scope5, failCause3(cause3))), (_, exit3) => close(scope5, exit3)))));
  var scopedWith3 = (f) => unwrapScoped3(map16(scope3, (scope5) => flatMap13(fromEffect4(f(scope5)), write)));
  var splitLines = () => suspend5(() => {
    let stringBuilder = "";
    let midCRLF = false;
    const splitLinesChunk = (chunk2) => {
      const chunkBuilder = [];
      map4(chunk2, (str) => {
        if (str.length !== 0) {
          let from = 0;
          let indexOfCR = str.indexOf("\r");
          let indexOfLF = str.indexOf(`
`);
          if (midCRLF) {
            if (indexOfLF === 0) {
              chunkBuilder.push(stringBuilder);
              stringBuilder = "";
              from = 1;
              indexOfLF = str.indexOf(`
`, from);
            } else {
              stringBuilder = stringBuilder + "\r";
            }
            midCRLF = false;
          }
          while (indexOfCR !== -1 || indexOfLF !== -1) {
            if (indexOfCR === -1 || indexOfLF !== -1 && indexOfLF < indexOfCR) {
              if (stringBuilder.length === 0) {
                chunkBuilder.push(str.substring(from, indexOfLF));
              } else {
                chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF));
                stringBuilder = "";
              }
              from = indexOfLF + 1;
              indexOfLF = str.indexOf(`
`, from);
            } else {
              if (str.length === indexOfCR + 1) {
                midCRLF = true;
                indexOfCR = -1;
              } else {
                if (indexOfLF === indexOfCR + 1) {
                  if (stringBuilder.length === 0) {
                    chunkBuilder.push(str.substring(from, indexOfCR));
                  } else {
                    stringBuilder = stringBuilder + str.substring(from, indexOfCR);
                    chunkBuilder.push(stringBuilder);
                    stringBuilder = "";
                  }
                  from = indexOfCR + 2;
                  indexOfCR = str.indexOf("\r", from);
                  indexOfLF = str.indexOf(`
`, from);
                } else {
                  indexOfCR = str.indexOf("\r", indexOfCR + 1);
                }
              }
            }
          }
          if (midCRLF) {
            stringBuilder = stringBuilder + str.substring(from, str.length - 1);
          } else {
            stringBuilder = stringBuilder + str.substring(from, str.length);
          }
        }
      });
      return unsafeFromArray(chunkBuilder);
    };
    const loop3 = readWithCause({
      onInput: (input) => {
        const out = splitLinesChunk(input);
        return isEmpty(out) ? loop3 : flatMap13(write(out), () => loop3);
      },
      onFailure: (cause3) => stringBuilder.length === 0 ? failCause10(cause3) : flatMap13(write(of2(stringBuilder)), () => failCause10(cause3)),
      onDone: (done8) => stringBuilder.length === 0 ? succeed10(done8) : flatMap13(write(of2(stringBuilder)), () => succeed10(done8))
    });
    return loop3;
  });
  var toPubSub = (pubsub) => toQueue(pubsub);
  var toPull = (self) => flatMap11(scope3, (scope5) => toPullIn(self, scope5));
  var toPullIn = /* @__PURE__ */ dual(2, (self, scope5) => zip5(sync3(() => new ChannelExecutor(self, undefined, identity)), runtime3()).pipe(tap3(([executor, runtime4]) => addFinalizerExit(scope5, (exit3) => {
    const finalizer = executor.close(exit3);
    return finalizer !== undefined ? provide2(finalizer, runtime4) : _void;
  })), uninterruptible2, map16(([executor]) => suspend3(() => interpretToPull(executor.run(), executor)))));
  var interpretToPull = (channelState, exec) => {
    const state = channelState;
    switch (state._tag) {
      case OP_DONE3: {
        return match6(exec.getDone(), {
          onFailure: failCause8,
          onSuccess: (done8) => succeed8(left2(done8))
        });
      }
      case OP_EMIT2: {
        return succeed8(right2(exec.getEmit()));
      }
      case OP_FROM_EFFECT3: {
        return pipe(state.effect, flatMap11(() => interpretToPull(exec.run(), exec)));
      }
      case OP_READ2: {
        return readUpstream(state, () => interpretToPull(exec.run(), exec), (cause3) => failCause8(cause3));
      }
    }
  };
  var toQueue = (queue) => suspend5(() => toQueueInternal(queue));
  var toQueueInternal = (queue) => {
    return readWithCause({
      onInput: (elem) => flatMap13(fromEffect4(offer3(queue, right2(elem))), () => toQueueInternal(queue)),
      onFailure: (cause3) => fromEffect4(offer3(queue, left2(failCause3(cause3)))),
      onDone: (done8) => fromEffect4(offer3(queue, left2(succeed3(done8))))
    });
  };
  var unwrap = (channel) => flatten11(fromEffect4(channel));
  var unwrapScoped3 = (self) => concatAllWith(scoped4(self), (d, _) => d, (d, _) => d);
  var unwrapScopedWith = (f) => concatAllWith(scopedWith3(f), (d, _) => d, (d, _) => d);
  var withSpan5 = function() {
    const dataFirst = typeof arguments[0] !== "string";
    const name = dataFirst ? arguments[1] : arguments[0];
    const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
    const acquire = all4([makeSpan2(name, options), context3(), clock2, get13(currentTracerTimingEnabled2)]);
    if (dataFirst) {
      const self = arguments[0];
      return acquireUseRelease3(acquire, ([span4, context5]) => provideContext3(self, add2(context5, spanTag, span4)), ([span4, , clock3, timingEnabled], exit3) => endSpan(span4, exit3, clock3, timingEnabled));
    }
    return (self) => acquireUseRelease3(acquire, ([span4, context5]) => provideContext3(self, add2(context5, spanTag, span4)), ([span4, , clock3, timingEnabled], exit3) => endSpan(span4, exit3, clock3, timingEnabled));
  };
  var writeAll = (...outs) => writeChunk(fromIterable2(outs));
  var writeChunk = (outs) => writeChunkWriter(0, outs.length, outs);
  var writeChunkWriter = (idx, len, chunk2) => {
    return idx === len ? void_5 : pipe(write(pipe(chunk2, unsafeGet4(idx))), flatMap13(() => writeChunkWriter(idx + 1, len, chunk2)));
  };
  var zip6 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self, that, options) => options?.concurrent ? mergeWith2(self, {
    other: that,
    onSelfDone: (exit1) => Await((exit22) => suspend3(() => zip3(exit1, exit22))),
    onOtherDone: (exit22) => Await((exit1) => suspend3(() => zip3(exit1, exit22)))
  }) : flatMap13(self, (a) => map18(that, (b) => [a, b])));
  var zipLeft3 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self, that, options) => options?.concurrent ? map18(zip6(self, that, {
    concurrent: true
  }), (tuple) => tuple[0]) : flatMap13(self, (z) => as4(that, z)));
  var zipRight4 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self, that, options) => options?.concurrent ? map18(zip6(self, that, {
    concurrent: true
  }), (tuple) => tuple[1]) : flatMap13(self, () => that));
  var ChannelExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Channel/ChannelException");
  var ChannelException = (error) => ({
    _tag: "ChannelException",
    [ChannelExceptionTypeId]: ChannelExceptionTypeId,
    error
  });
  var isChannelException = (u) => hasProperty(u, ChannelExceptionTypeId);

  // node_modules/effect/dist/esm/internal/sink.js
  var SinkTypeId2 = /* @__PURE__ */ Symbol.for("effect/Sink");
  var sinkVariance2 = {
    _A: (_) => _,
    _In: (_) => _,
    _L: (_) => _,
    _E: (_) => _,
    _R: (_) => _
  };

  class SinkImpl {
    channel;
    [SinkTypeId2] = sinkVariance2;
    constructor(channel) {
      this.channel = channel;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var isSink = (u) => hasProperty(u, SinkTypeId2);
  var suspend6 = (evaluate2) => new SinkImpl(suspend5(() => toChannel(evaluate2())));
  var collectAll = () => new SinkImpl(collectAllLoop(empty4()));
  var collectAllLoop = (acc) => readWithCause({
    onInput: (chunk2) => collectAllLoop(pipe(acc, appendAll2(chunk2))),
    onFailure: failCause10,
    onDone: () => succeed10(acc)
  });
  var collectAllN = (n) => suspend6(() => fromChannel(collectAllNLoop(n, empty4())));
  var collectAllNLoop = (n, acc) => readWithCause({
    onInput: (chunk2) => {
      const [collected, leftovers] = splitAt2(chunk2, n);
      if (collected.length < n) {
        return collectAllNLoop(n - collected.length, appendAll2(acc, collected));
      }
      if (isEmpty(leftovers)) {
        return succeed10(appendAll2(acc, collected));
      }
      return flatMap13(write(leftovers), () => succeed10(appendAll2(acc, collected)));
    },
    onFailure: failCause10,
    onDone: () => succeed10(acc)
  });
  var collectLeftover = (self) => new SinkImpl(pipe(collectElements(toChannel(self)), map18(([chunks, z]) => [z, flatten3(chunks)])));
  var drain2 = /* @__PURE__ */ new SinkImpl(/* @__PURE__ */ drain(/* @__PURE__ */ identityChannel()));
  var fail12 = (e) => new SinkImpl(fail11(e));
  var fold = (s, contFn, f) => suspend6(() => new SinkImpl(foldReader(s, contFn, f)));
  var foldReader = (s, contFn, f) => {
    if (!contFn(s)) {
      return succeedNow(s);
    }
    return readWith({
      onInput: (input) => {
        const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f, 0, input.length);
        if (isNonEmpty2(leftovers)) {
          return pipe(write(leftovers), as4(nextS));
        }
        return foldReader(nextS, contFn, f);
      },
      onFailure: fail11,
      onDone: () => succeedNow(s)
    });
  };
  var foldChunkSplit = (s, chunk2, contFn, f, index, length3) => {
    if (index === length3) {
      return [s, empty4()];
    }
    const s1 = f(s, pipe(chunk2, unsafeGet4(index)));
    if (contFn(s1)) {
      return foldChunkSplit(s1, chunk2, contFn, f, index + 1, length3);
    }
    return [s1, pipe(chunk2, drop2(index + 1))];
  };
  var foldSink = /* @__PURE__ */ dual(2, (self, options) => {
    const newChannel = pipe(toChannel(self), collectElements, foldChannel({
      onFailure: (error) => toChannel(options.onFailure(error)),
      onSuccess: ([leftovers, z]) => suspend5(() => {
        const leftoversRef = {
          ref: pipe(leftovers, filter2(isNonEmpty2))
        };
        const refReader = pipe(sync5(() => {
          const ref = leftoversRef.ref;
          leftoversRef.ref = empty4();
          return ref;
        }), flatMap13((chunk2) => writeChunk(chunk2)));
        const passthrough4 = identityChannel();
        const continuationSink = pipe(refReader, zipRight4(passthrough4), pipeTo(toChannel(options.onSuccess(z))));
        return flatMap13(collectElements(continuationSink), ([newLeftovers, z1]) => pipe(succeed10(leftoversRef.ref), flatMap13(writeChunk), zipRight4(writeChunk(newLeftovers)), as4(z1)));
      })
    }));
    return new SinkImpl(newChannel);
  });
  var foldChunks = (s, contFn, f) => suspend6(() => new SinkImpl(foldChunksReader(s, contFn, f)));
  var foldChunksReader = (s, contFn, f) => {
    if (!contFn(s)) {
      return succeedNow(s);
    }
    return readWith({
      onInput: (input) => foldChunksReader(f(s, input), contFn, f),
      onFailure: fail11,
      onDone: () => succeedNow(s)
    });
  };
  var foldEffect = (s, contFn, f) => suspend6(() => new SinkImpl(foldEffectReader(s, contFn, f)));
  var foldEffectReader = (s, contFn, f) => {
    if (!contFn(s)) {
      return succeedNow(s);
    }
    return readWith({
      onInput: (input) => pipe(fromEffect4(foldChunkSplitEffect(s, input, contFn, f)), flatMap13(([nextS, leftovers]) => pipe(leftovers, match2({
        onNone: () => foldEffectReader(nextS, contFn, f),
        onSome: (leftover) => pipe(write(leftover), as4(nextS))
      })))),
      onFailure: fail11,
      onDone: () => succeedNow(s)
    });
  };
  var foldChunkSplitEffect = (s, chunk2, contFn, f) => foldChunkSplitEffectInternal(s, chunk2, 0, chunk2.length, contFn, f);
  var foldChunkSplitEffectInternal = (s, chunk2, index, length3, contFn, f) => {
    if (index === length3) {
      return succeed8([s, none2()]);
    }
    return pipe(f(s, pipe(chunk2, unsafeGet4(index))), flatMap11((s1) => contFn(s1) ? foldChunkSplitEffectInternal(s1, chunk2, index + 1, length3, contFn, f) : succeed8([s1, some2(pipe(chunk2, drop2(index + 1)))])));
  };
  var foldLeftChunks = (s, f) => foldChunks(s, constTrue, f);
  var flatMap14 = /* @__PURE__ */ dual(2, (self, f) => foldSink(self, {
    onFailure: fail12,
    onSuccess: f
  }));
  var forEach7 = (f) => {
    const process2 = readWithCause({
      onInput: (input) => pipe(fromEffect4(forEach6(input, (v) => f(v), {
        discard: true
      })), flatMap13(() => process2)),
      onFailure: failCause10,
      onDone: () => void_5
    });
    return new SinkImpl(process2);
  };
  var forEachChunk = (f) => {
    const process2 = readWithCause({
      onInput: (input) => pipe(fromEffect4(f(input)), flatMap13(() => process2)),
      onFailure: failCause10,
      onDone: () => void_5
    });
    return new SinkImpl(process2);
  };
  var forEachWhile = (f) => {
    const process2 = readWithCause({
      onInput: (input) => forEachWhileReader(f, input, 0, input.length, process2),
      onFailure: failCause10,
      onDone: () => void_5
    });
    return new SinkImpl(process2);
  };
  var forEachWhileReader = (f, input, index, length3, cont) => {
    if (index === length3) {
      return cont;
    }
    return pipe(fromEffect4(f(pipe(input, unsafeGet4(index)))), flatMap13((bool) => bool ? forEachWhileReader(f, input, index + 1, length3, cont) : write(pipe(input, drop2(index)))), catchAll5((error) => pipe(write(pipe(input, drop2(index))), zipRight4(fail11(error)))));
  };
  var fromChannel = (channel) => new SinkImpl(channel);
  var fromEffect6 = (effect3) => new SinkImpl(fromEffect4(effect3));
  var head5 = () => fold(none2(), isNone2, (option3, input) => match2(option3, {
    onNone: () => some2(input),
    onSome: () => option3
  }));
  var last3 = () => foldLeftChunks(none2(), (s, input) => orElse(last2(input), () => s));
  var map19 = /* @__PURE__ */ dual(2, (self, f) => {
    return new SinkImpl(pipe(toChannel(self), map18(f)));
  });
  var raceWith3 = /* @__PURE__ */ dual(2, (self, options) => {
    function race3(scope5) {
      return gen2(function* () {
        const pubsub = yield* bounded4(options?.capacity ?? 16);
        const subscription1 = yield* extend2(subscribe2(pubsub), scope5);
        const subscription2 = yield* extend2(subscribe2(pubsub), scope5);
        const reader = toPubSub(pubsub);
        const writer = fromQueue(subscription1).pipe(pipeTo(toChannel(self)), zipLeft3(fromEffect4(shutdown4(subscription1))), mergeWith2({
          other: fromQueue(subscription2).pipe(pipeTo(toChannel(options.other)), zipLeft3(fromEffect4(shutdown4(subscription2)))),
          onSelfDone: options.onSelfDone,
          onOtherDone: options.onOtherDone
        }));
        const racedChannel = mergeWith2(reader, {
          other: writer,
          onSelfDone: () => Await(identity),
          onOtherDone: (exit3) => Done3(exit3)
        });
        return new SinkImpl(racedChannel);
      });
    }
    return unwrapScopedWith2(race3);
  });
  var sum2 = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk2) => acc + reduce2(chunk2, 0, (s, a) => s + a));
  var toChannel = (self) => isEffect2(self) ? toChannel(fromEffect6(self)) : self.channel;
  var unwrapScopedWith2 = (f) => new SinkImpl(unwrapScopedWith((scope5) => f(scope5).pipe(map16((sink) => toChannel(sink)))));
  var zipRight5 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self, that, options) => zipWith7(self, that, (_, z2) => z2, options));
  var zipWith7 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self, that, f, options) => options?.concurrent ? raceWith3(self, {
    other: that,
    onSelfDone: match6({
      onFailure: (cause3) => Done3(failCause8(cause3)),
      onSuccess: (leftZ) => Await(match6({
        onFailure: failCause8,
        onSuccess: (rightZ) => succeed8(f(leftZ, rightZ))
      }))
    }),
    onOtherDone: match6({
      onFailure: (cause3) => Done3(failCause8(cause3)),
      onSuccess: (rightZ) => Await(match6({
        onFailure: failCause8,
        onSuccess: (leftZ) => succeed8(f(leftZ, rightZ))
      }))
    })
  }) : flatMap14(self, (z) => map19(that, (z2) => f(z, z2))));
  var count = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk2) => acc + chunk2.length);
  var mkString = /* @__PURE__ */ suspend6(() => {
    const strings = [];
    return pipe(foldLeftChunks(undefined, (_, elems) => map4(elems, (elem) => {
      strings.push(String(elem));
    })), map19(() => strings.join("")));
  });

  // node_modules/effect/dist/esm/MergeDecision.js
  var Done4 = Done3;
  var Await2 = Await;

  // node_modules/effect/dist/esm/internal/rcRef.js
  var TypeId15 = /* @__PURE__ */ Symbol.for("effect/RcRef");
  var stateEmpty2 = {
    _tag: "Empty"
  };
  var stateClosed = {
    _tag: "Closed"
  };
  var variance5 = {
    _A: identity,
    _E: identity
  };

  class RcRefImpl extends Class {
    acquire;
    context;
    scope;
    idleTimeToLive;
    [TypeId15] = variance5;
    [TypeId12] = TypeId12;
    state = stateEmpty2;
    semaphore = /* @__PURE__ */ unsafeMakeSemaphore(1);
    constructor(acquire, context5, scope5, idleTimeToLive) {
      super();
      this.acquire = acquire;
      this.context = context5;
      this.scope = scope5;
      this.idleTimeToLive = idleTimeToLive;
      this.get = get14(this);
    }
    get;
    commit() {
      return this.get;
    }
  }
  var make43 = (options) => withFiberRuntime((fiber) => {
    const context5 = fiber.getFiberRef(currentContext);
    const scope5 = get3(context5, scopeTag);
    const ref = new RcRefImpl(options.acquire, context5, scope5, options.idleTimeToLive ? decode(options.idleTimeToLive) : undefined);
    return as(scope5.addFinalizer(() => ref.semaphore.withPermits(1)(suspend(() => {
      const close2 = ref.state._tag === "Acquired" ? scopeClose(ref.state.scope, exitVoid) : void_;
      ref.state = stateClosed;
      return close2;
    }))), ref);
  });
  var get14 = (self_) => {
    const self = self_;
    const isInfinite = self.idleTimeToLive && !isFinite(self.idleTimeToLive);
    return uninterruptibleMask((restore) => suspend(() => {
      switch (self.state._tag) {
        case "Closed": {
          return interrupt2;
        }
        case "Acquired": {
          self.state.refCount++;
          return self.state.fiber ? as(interruptFiber(self.state.fiber), self.state) : succeed(self.state);
        }
        case "Empty": {
          return scopeMake().pipe(bindTo2("scope"), bind2("value", ({
            scope: scope5
          }) => restore(fiberRefLocally(self.acquire, currentContext, add2(self.context, scopeTag, scope5)))), map10(({
            scope: scope5,
            value
          }) => {
            const state = {
              _tag: "Acquired",
              value,
              scope: scope5,
              fiber: undefined,
              refCount: 1
            };
            self.state = state;
            return state;
          }));
        }
      }
    })).pipe(self.semaphore.withPermits(1), bindTo2("state"), bind2("scope", () => scopeTag), tap(({
      scope: scope5,
      state
    }) => scope5.addFinalizer(() => suspend(() => {
      state.refCount--;
      if (state.refCount > 0 || isInfinite) {
        return void_;
      }
      if (self.idleTimeToLive === undefined) {
        self.state = stateEmpty2;
        return scopeClose(state.scope, exitVoid);
      }
      return sleep3(self.idleTimeToLive).pipe(interruptible2, zipRight(suspend(() => {
        if (self.state._tag === "Acquired" && self.state.refCount === 0) {
          self.state = stateEmpty2;
          return scopeClose(state.scope, exitVoid);
        }
        return void_;
      })), ensuring(sync(() => {
        state.fiber = undefined;
      })), forkIn(self.scope), tap((fiber) => {
        state.fiber = fiber;
      }), self.semaphore.withPermits(1));
    }))), map10(({
      state
    }) => state.value));
  };

  // node_modules/effect/dist/esm/RcRef.js
  var make44 = make43;
  var get15 = get14;

  // node_modules/effect/dist/esm/Runtime.js
  var runFork3 = unsafeFork2;
  var runPromiseExit2 = unsafeRunPromiseExit;
  var defaultRuntime2 = defaultRuntime;

  // node_modules/effect/dist/esm/Schedule.js
  var driver2 = driver;
  var forever4 = forever2;
  var spaced2 = spaced;
  var CurrentIterationMetadata2 = CurrentIterationMetadata;

  // node_modules/effect/dist/esm/internal/opCodes/streamHaltStrategy.js
  var OP_LEFT = "Left";
  var OP_RIGHT = "Right";
  var OP_BOTH = "Both";
  var OP_EITHER = "Either";

  // node_modules/effect/dist/esm/internal/stream/haltStrategy.js
  var Left = {
    _tag: OP_LEFT
  };
  var Right = {
    _tag: OP_RIGHT
  };
  var Both = {
    _tag: OP_BOTH
  };
  var Either = {
    _tag: OP_EITHER
  };
  var fromInput2 = (input) => {
    switch (input) {
      case "left":
        return Left;
      case "right":
        return Right;
      case "both":
        return Both;
      case "either":
        return Either;
      default:
        return input;
    }
  };

  // node_modules/effect/dist/esm/StreamHaltStrategy.js
  var Both2 = Both;

  // node_modules/effect/dist/esm/internal/stm/versioned.js
  class Versioned {
    value;
    constructor(value) {
      this.value = value;
    }
  }

  // node_modules/effect/dist/esm/internal/stm/entry.js
  var make45 = (ref, isNew) => ({
    ref,
    isNew,
    isChanged: false,
    expected: ref.versioned,
    newValue: ref.versioned.value
  });
  var unsafeGet6 = (self) => {
    return self.newValue;
  };
  var unsafeSet = (self, value) => {
    self.isChanged = true;
    self.newValue = value;
  };
  var commit = (self) => {
    self.ref.versioned = new Versioned(self.newValue);
  };
  var isInvalid = (self) => {
    return self.ref.versioned !== self.expected;
  };
  var isChanged = (self) => {
    return self.isChanged;
  };

  // node_modules/effect/dist/esm/internal/stm/journal.js
  var JournalAnalysisInvalid = "Invalid";
  var JournalAnalysisReadWrite = "ReadWrite";
  var JournalAnalysisReadOnly = "ReadOnly";
  var commitJournal = (journal) => {
    for (const entry of journal) {
      commit(entry[1]);
    }
  };
  var analyzeJournal = (journal) => {
    let val = JournalAnalysisReadOnly;
    for (const [, entry] of journal) {
      val = isInvalid(entry) ? JournalAnalysisInvalid : isChanged(entry) ? JournalAnalysisReadWrite : val;
      if (val === JournalAnalysisInvalid) {
        return val;
      }
    }
    return val;
  };
  var collectTodos = (journal) => {
    const allTodos = new Map;
    for (const [, entry] of journal) {
      for (const todo of entry.ref.todos) {
        allTodos.set(todo[0], todo[1]);
      }
      entry.ref.todos = new Map;
    }
    return allTodos;
  };
  var execTodos = (todos) => {
    const todosSorted = Array.from(todos.entries()).sort((x, y) => x[0] - y[0]);
    for (const [_, todo] of todosSorted) {
      todo();
    }
  };
  var addTodo = (txnId, journal, todoEffect) => {
    let added = false;
    for (const [, entry] of journal) {
      if (!entry.ref.todos.has(txnId)) {
        entry.ref.todos.set(txnId, todoEffect);
        added = true;
      }
    }
    return added;
  };

  // node_modules/effect/dist/esm/internal/stm/opCodes/stm.js
  var OP_WITH_STM_RUNTIME = "WithSTMRuntime";
  var OP_ON_FAILURE2 = "OnFailure";
  var OP_ON_RETRY = "OnRetry";
  var OP_ON_SUCCESS2 = "OnSuccess";
  var OP_PROVIDE3 = "Provide";
  var OP_SYNC2 = "Sync";
  var OP_SUCCEED2 = "Succeed";
  var OP_RETRY = "Retry";
  var OP_FAIL4 = "Fail";
  var OP_DIE2 = "Die";
  var OP_INTERRUPT2 = "Interrupt";

  // node_modules/effect/dist/esm/internal/stm/opCodes/tExit.js
  var OP_FAIL5 = "Fail";
  var OP_DIE3 = "Die";
  var OP_INTERRUPT3 = "Interrupt";
  var OP_SUCCEED3 = "Succeed";
  var OP_RETRY2 = "Retry";

  // node_modules/effect/dist/esm/internal/stm/opCodes/tryCommit.js
  var OP_DONE5 = "Done";
  var OP_SUSPEND3 = "Suspend";

  // node_modules/effect/dist/esm/internal/stm/opCodes/stmState.js
  var OP_DONE6 = "Done";
  var OP_INTERRUPTED = "Interrupted";
  var OP_RUNNING2 = "Running";

  // node_modules/effect/dist/esm/internal/stm/stmState.js
  var STMStateSymbolKey = "effect/STM/State";
  var STMStateTypeId = /* @__PURE__ */ Symbol.for(STMStateSymbolKey);
  var isSTMState = (u) => hasProperty(u, STMStateTypeId);
  var isRunning2 = (self) => {
    return self._tag === OP_RUNNING2;
  };
  var isDone6 = (self) => {
    return self._tag === OP_DONE6;
  };
  var done8 = (exit3) => {
    return {
      [STMStateTypeId]: STMStateTypeId,
      _tag: OP_DONE6,
      exit: exit3,
      [symbol]() {
        return pipe(hash(STMStateSymbolKey), combine(hash(OP_DONE6)), combine(hash(exit3)), cached(this));
      },
      [symbol2](that) {
        return isSTMState(that) && that._tag === OP_DONE6 && equals(exit3, that.exit);
      }
    };
  };
  var interruptedHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_INTERRUPTED)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("interrupted")));
  var interrupted2 = {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_INTERRUPTED,
    [symbol]() {
      return interruptedHash;
    },
    [symbol2](that) {
      return isSTMState(that) && that._tag === OP_INTERRUPTED;
    }
  };
  var runningHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RUNNING2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("running")));
  var running3 = {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_RUNNING2,
    [symbol]() {
      return runningHash;
    },
    [symbol2](that) {
      return isSTMState(that) && that._tag === OP_RUNNING2;
    }
  };
  var fromTExit = (tExit) => {
    switch (tExit._tag) {
      case OP_FAIL5: {
        return done8(fail4(tExit.error));
      }
      case OP_DIE3: {
        return done8(die3(tExit.defect));
      }
      case OP_INTERRUPT3: {
        return done8(interrupt4(tExit.fiberId));
      }
      case OP_SUCCEED3: {
        return done8(succeed3(tExit.value));
      }
      case OP_RETRY2: {
        throw new Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues");
      }
    }
  };

  // node_modules/effect/dist/esm/internal/stm/tExit.js
  var TExitSymbolKey = "effect/TExit";
  var TExitTypeId = /* @__PURE__ */ Symbol.for(TExitSymbolKey);
  var variance6 = {
    _A: (_) => _,
    _E: (_) => _
  };
  var isExit2 = (u) => hasProperty(u, TExitTypeId);
  var isSuccess4 = (self) => {
    return self._tag === OP_SUCCEED3;
  };
  var isRetry = (self) => {
    return self._tag === OP_RETRY2;
  };
  var fail13 = (error) => ({
    [TExitTypeId]: variance6,
    _tag: OP_FAIL5,
    error,
    [symbol]() {
      return pipe(hash(TExitSymbolKey), combine(hash(OP_FAIL5)), combine(hash(error)), cached(this));
    },
    [symbol2](that) {
      return isExit2(that) && that._tag === OP_FAIL5 && equals(error, that.error);
    }
  });
  var die8 = (defect) => ({
    [TExitTypeId]: variance6,
    _tag: OP_DIE3,
    defect,
    [symbol]() {
      return pipe(hash(TExitSymbolKey), combine(hash(OP_DIE3)), combine(hash(defect)), cached(this));
    },
    [symbol2](that) {
      return isExit2(that) && that._tag === OP_DIE3 && equals(defect, that.defect);
    }
  });
  var interrupt8 = (fiberId3) => ({
    [TExitTypeId]: variance6,
    _tag: OP_INTERRUPT3,
    fiberId: fiberId3,
    [symbol]() {
      return pipe(hash(TExitSymbolKey), combine(hash(OP_INTERRUPT3)), combine(hash(fiberId3)), cached(this));
    },
    [symbol2](that) {
      return isExit2(that) && that._tag === OP_INTERRUPT3 && equals(fiberId3, that.fiberId);
    }
  });
  var succeed12 = (value) => ({
    [TExitTypeId]: variance6,
    _tag: OP_SUCCEED3,
    value,
    [symbol]() {
      return pipe(hash(TExitSymbolKey), combine(hash(OP_SUCCEED3)), combine(hash(value)), cached(this));
    },
    [symbol2](that) {
      return isExit2(that) && that._tag === OP_SUCCEED3 && equals(value, that.value);
    }
  });
  var retryHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(TExitSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RETRY2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("retry")));
  var retry4 = {
    [TExitTypeId]: variance6,
    _tag: OP_RETRY2,
    [symbol]() {
      return retryHash;
    },
    [symbol2](that) {
      return isExit2(that) && isRetry(that);
    }
  };

  // node_modules/effect/dist/esm/internal/stm/tryCommit.js
  var done9 = (exit3) => {
    return {
      _tag: OP_DONE5,
      exit: exit3
    };
  };
  var suspend7 = (journal) => {
    return {
      _tag: OP_SUSPEND3,
      journal
    };
  };

  // node_modules/effect/dist/esm/internal/stm/txnId.js
  var txnCounter = {
    ref: 0
  };
  var make46 = () => {
    const newId = txnCounter.ref + 1;
    txnCounter.ref = newId;
    return newId;
  };

  // node_modules/effect/dist/esm/internal/stm/core.js
  var STMSymbolKey2 = "effect/STM";
  var STMTypeId2 = /* @__PURE__ */ Symbol.for(STMSymbolKey2);
  var stmVariance = {
    _R: (_) => _,
    _E: (_) => _,
    _A: (_) => _
  };

  class STMPrimitive {
    effect_instruction_i0;
    _op = OP_COMMIT;
    effect_instruction_i1 = undefined;
    effect_instruction_i2 = undefined;
    [EffectTypeId3];
    [StreamTypeId];
    [SinkTypeId2];
    [ChannelTypeId2];
    get [STMTypeId2]() {
      return stmVariance;
    }
    constructor(effect_instruction_i0) {
      this.effect_instruction_i0 = effect_instruction_i0;
      this[EffectTypeId3] = effectVariance;
      this[StreamTypeId] = stmVariance;
      this[SinkTypeId2] = stmVariance;
      this[ChannelTypeId2] = stmVariance;
    }
    [symbol2](that) {
      return this === that;
    }
    [symbol]() {
      return cached(this, random(this));
    }
    [Symbol.iterator]() {
      return new SingleShotGen2(new YieldWrap(this));
    }
    commit() {
      return unsafeAtomically(this, constVoid, constVoid);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var unsafeAtomically = (self, onDone, onInterrupt3) => withFiberRuntime((state) => {
    const fiberId3 = state.id();
    const env = state.getFiberRef(currentContext2);
    const scheduler = state.getFiberRef(currentScheduler2);
    const priority = state.getFiberRef(currentSchedulingPriority2);
    const commitResult = tryCommitSync(fiberId3, self, env, scheduler, priority);
    switch (commitResult._tag) {
      case OP_DONE5: {
        onDone(commitResult.exit);
        return commitResult.exit;
      }
      case OP_SUSPEND3: {
        const txnId = make46();
        const state2 = {
          value: running3
        };
        const effect3 = async((k) => tryCommitAsync(fiberId3, self, txnId, state2, env, scheduler, priority, k));
        return uninterruptibleMask3((restore) => pipe(restore(effect3), catchAllCause3((cause3) => {
          let currentState = state2.value;
          if (isRunning2(currentState)) {
            state2.value = interrupted2;
          }
          currentState = state2.value;
          if (isDone6(currentState)) {
            onDone(currentState.exit);
            return currentState.exit;
          }
          onInterrupt3();
          return failCause8(cause3);
        })));
      }
    }
  });
  var tryCommit = (fiberId3, stm, state, env, scheduler, priority) => {
    const journal = new Map;
    const tExit = new STMDriver(stm, journal, fiberId3, env).run();
    const analysis = analyzeJournal(journal);
    if (analysis === JournalAnalysisReadWrite) {
      commitJournal(journal);
    } else if (analysis === JournalAnalysisInvalid) {
      throw new Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    switch (tExit._tag) {
      case OP_SUCCEED3: {
        state.value = fromTExit(tExit);
        return completeTodos(succeed3(tExit.value), journal, scheduler, priority);
      }
      case OP_FAIL5: {
        state.value = fromTExit(tExit);
        const cause3 = fail5(tExit.error);
        return completeTodos(failCause3(cause3), journal, scheduler, priority);
      }
      case OP_DIE3: {
        state.value = fromTExit(tExit);
        const cause3 = die4(tExit.defect);
        return completeTodos(failCause3(cause3), journal, scheduler, priority);
      }
      case OP_INTERRUPT3: {
        state.value = fromTExit(tExit);
        const cause3 = interrupt5(fiberId3);
        return completeTodos(failCause3(cause3), journal, scheduler, priority);
      }
      case OP_RETRY2: {
        return suspend7(journal);
      }
    }
  };
  var tryCommitSync = (fiberId3, stm, env, scheduler, priority) => {
    const journal = new Map;
    const tExit = new STMDriver(stm, journal, fiberId3, env).run();
    const analysis = analyzeJournal(journal);
    if (analysis === JournalAnalysisReadWrite && isSuccess4(tExit)) {
      commitJournal(journal);
    } else if (analysis === JournalAnalysisInvalid) {
      throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    switch (tExit._tag) {
      case OP_SUCCEED3: {
        return completeTodos(succeed3(tExit.value), journal, scheduler, priority);
      }
      case OP_FAIL5: {
        const cause3 = fail5(tExit.error);
        return completeTodos(failCause3(cause3), journal, scheduler, priority);
      }
      case OP_DIE3: {
        const cause3 = die4(tExit.defect);
        return completeTodos(failCause3(cause3), journal, scheduler, priority);
      }
      case OP_INTERRUPT3: {
        const cause3 = interrupt5(fiberId3);
        return completeTodos(failCause3(cause3), journal, scheduler, priority);
      }
      case OP_RETRY2: {
        return suspend7(journal);
      }
    }
  };
  var tryCommitAsync = (fiberId3, self, txnId, state, context5, scheduler, priority, k) => {
    if (isRunning2(state.value)) {
      const result = tryCommit(fiberId3, self, state, context5, scheduler, priority);
      switch (result._tag) {
        case OP_DONE5: {
          completeTryCommit(result.exit, k);
          break;
        }
        case OP_SUSPEND3: {
          addTodo(txnId, result.journal, () => tryCommitAsync(fiberId3, self, txnId, state, context5, scheduler, priority, k));
          break;
        }
      }
    }
  };
  var completeTodos = (exit3, journal, scheduler, priority) => {
    const todos = collectTodos(journal);
    if (todos.size > 0) {
      scheduler.scheduleTask(() => execTodos(todos), priority);
    }
    return done9(exit3);
  };
  var completeTryCommit = (exit3, k) => {
    k(exit3);
  };
  class STMDriver {
    self;
    journal;
    fiberId;
    contStack = [];
    env;
    constructor(self, journal, fiberId3, r0) {
      this.self = self;
      this.journal = journal;
      this.fiberId = fiberId3;
      this.env = r0;
    }
    getEnv() {
      return this.env;
    }
    pushStack(cont) {
      this.contStack.push(cont);
    }
    popStack() {
      return this.contStack.pop();
    }
    nextSuccess() {
      let current = this.popStack();
      while (current !== undefined && current.effect_instruction_i0 !== OP_ON_SUCCESS2) {
        current = this.popStack();
      }
      return current;
    }
    nextFailure() {
      let current = this.popStack();
      while (current !== undefined && current.effect_instruction_i0 !== OP_ON_FAILURE2) {
        current = this.popStack();
      }
      return current;
    }
    nextRetry() {
      let current = this.popStack();
      while (current !== undefined && current.effect_instruction_i0 !== OP_ON_RETRY) {
        current = this.popStack();
      }
      return current;
    }
    run() {
      let curr = this.self;
      let exit3 = undefined;
      while (exit3 === undefined && curr !== undefined) {
        try {
          const current = curr;
          if (current) {
            switch (current._op) {
              case "Tag": {
                curr = effect3((_, __, env) => unsafeGet3(env, current));
                break;
              }
              case "Left": {
                curr = fail14(current.left);
                break;
              }
              case "None": {
                curr = fail14(new NoSuchElementException2);
                break;
              }
              case "Right": {
                curr = succeed13(current.right);
                break;
              }
              case "Some": {
                curr = succeed13(current.value);
                break;
              }
              case "Commit": {
                switch (current.effect_instruction_i0) {
                  case OP_DIE2: {
                    exit3 = die8(internalCall(() => current.effect_instruction_i1()));
                    break;
                  }
                  case OP_FAIL4: {
                    const cont = this.nextFailure();
                    if (cont === undefined) {
                      exit3 = fail13(internalCall(() => current.effect_instruction_i1()));
                    } else {
                      curr = internalCall(() => cont.effect_instruction_i2(internalCall(() => current.effect_instruction_i1())));
                    }
                    break;
                  }
                  case OP_RETRY: {
                    const cont = this.nextRetry();
                    if (cont === undefined) {
                      exit3 = retry4;
                    } else {
                      curr = internalCall(() => cont.effect_instruction_i2());
                    }
                    break;
                  }
                  case OP_INTERRUPT2: {
                    exit3 = interrupt8(this.fiberId);
                    break;
                  }
                  case OP_WITH_STM_RUNTIME: {
                    curr = internalCall(() => current.effect_instruction_i1(this));
                    break;
                  }
                  case OP_ON_SUCCESS2:
                  case OP_ON_FAILURE2:
                  case OP_ON_RETRY: {
                    this.pushStack(current);
                    curr = current.effect_instruction_i1;
                    break;
                  }
                  case OP_PROVIDE3: {
                    const env = this.env;
                    this.env = internalCall(() => current.effect_instruction_i2(env));
                    curr = pipe(current.effect_instruction_i1, ensuring5(sync7(() => this.env = env)));
                    break;
                  }
                  case OP_SUCCEED2: {
                    const value = current.effect_instruction_i1;
                    const cont = this.nextSuccess();
                    if (cont === undefined) {
                      exit3 = succeed12(value);
                    } else {
                      curr = internalCall(() => cont.effect_instruction_i2(value));
                    }
                    break;
                  }
                  case OP_SYNC2: {
                    const value = internalCall(() => current.effect_instruction_i1());
                    const cont = this.nextSuccess();
                    if (cont === undefined) {
                      exit3 = succeed12(value);
                    } else {
                      curr = internalCall(() => cont.effect_instruction_i2(value));
                    }
                    break;
                  }
                }
                break;
              }
            }
          }
        } catch (e) {
          curr = die9(e);
        }
      }
      return exit3;
    }
  }
  var catchAll6 = /* @__PURE__ */ dual(2, (self, f) => {
    const stm = new STMPrimitive(OP_ON_FAILURE2);
    stm.effect_instruction_i1 = self;
    stm.effect_instruction_i2 = f;
    return stm;
  });
  var die9 = (defect) => dieSync5(() => defect);
  var dieSync5 = (evaluate2) => {
    const stm = new STMPrimitive(OP_DIE2);
    stm.effect_instruction_i1 = evaluate2;
    return stm;
  };
  var effect3 = (f) => withSTMRuntime((_) => succeed13(f(_.journal, _.fiberId, _.getEnv())));
  var ensuring5 = /* @__PURE__ */ dual(2, (self, finalizer) => matchSTM(self, {
    onFailure: (e) => zipRight7(finalizer, fail14(e)),
    onSuccess: (a) => zipRight7(finalizer, succeed13(a))
  }));
  var fail14 = (error) => failSync6(() => error);
  var failSync6 = (evaluate2) => {
    const stm = new STMPrimitive(OP_FAIL4);
    stm.effect_instruction_i1 = evaluate2;
    return stm;
  };
  var flatMap15 = /* @__PURE__ */ dual(2, (self, f) => {
    const stm = new STMPrimitive(OP_ON_SUCCESS2);
    stm.effect_instruction_i1 = self;
    stm.effect_instruction_i2 = f;
    return stm;
  });
  var matchSTM = /* @__PURE__ */ dual(2, (self, {
    onFailure,
    onSuccess
  }) => pipe(self, map20(right2), catchAll6((e) => pipe(onFailure(e), map20(left2))), flatMap15((either5) => {
    switch (either5._tag) {
      case "Left": {
        return succeed13(either5.left);
      }
      case "Right": {
        return onSuccess(either5.right);
      }
    }
  })));
  var withSTMRuntime = (f) => {
    const stm = new STMPrimitive(OP_WITH_STM_RUNTIME);
    stm.effect_instruction_i1 = f;
    return stm;
  };
  var interruptAs2 = (fiberId3) => {
    const stm = new STMPrimitive(OP_INTERRUPT2);
    stm.effect_instruction_i1 = fiberId3;
    return stm;
  };
  var map20 = /* @__PURE__ */ dual(2, (self, f) => pipe(self, flatMap15((a) => sync7(() => f(a)))));
  var retry5 = /* @__PURE__ */ new STMPrimitive(OP_RETRY);
  var succeed13 = (value) => {
    const stm = new STMPrimitive(OP_SUCCEED2);
    stm.effect_instruction_i1 = value;
    return stm;
  };
  var sync7 = (evaluate2) => {
    const stm = new STMPrimitive(OP_SYNC2);
    stm.effect_instruction_i1 = evaluate2;
    return stm;
  };
  var zipRight7 = /* @__PURE__ */ dual(2, (self, that) => pipe(self, flatMap15(() => that)));
  var zipWith9 = /* @__PURE__ */ dual(3, (self, that, f) => pipe(self, flatMap15((a) => pipe(that, map20((b) => f(a, b))))));

  // node_modules/effect/dist/esm/internal/stm/opCodes/strategy.js
  var OP_BACKPRESSURE_STRATEGY = "BackPressure";
  var OP_DROPPING_STRATEGY = "Dropping";
  var OP_SLIDING_STRATEGY = "Sliding";

  // node_modules/effect/dist/esm/internal/stm/stm.js
  var as6 = /* @__PURE__ */ dual(2, (self, value) => pipe(self, map20(() => value)));
  var flatten12 = (self) => flatMap15(self, identity);
  var forEach8 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (iterable, f, options) => {
    if (options?.discard) {
      return pipe(sync7(() => iterable[Symbol.iterator]()), flatMap15((iterator) => {
        const loop3 = suspend8(() => {
          const next = iterator.next();
          if (next.done) {
            return void_6;
          }
          return pipe(f(next.value), flatMap15(() => loop3));
        });
        return loop3;
      }));
    }
    return suspend8(() => fromIterable(iterable).reduce((acc, curr) => zipWith9(acc, f(curr), (array3, elem) => {
      array3.push(elem);
      return array3;
    }), succeed13([])));
  });
  var all5 = (input, options) => {
    if (Symbol.iterator in input) {
      return forEach8(input, identity, options);
    } else if (options?.discard) {
      return forEach8(Object.values(input), identity, options);
    }
    return map20(forEach8(Object.entries(input), ([_, e]) => map20(e, (a) => [_, a])), (values3) => {
      const res = {};
      for (const [k, v] of values3) {
        res[k] = v;
      }
      return res;
    });
  };
  var suspend8 = (evaluate2) => flatten12(sync7(evaluate2));
  var tap5 = /* @__PURE__ */ dual(2, (self, f) => flatMap15(self, (a) => as6(f(a), a)));
  var void_6 = /* @__PURE__ */ succeed13(undefined);

  // node_modules/effect/dist/esm/internal/stm/tRef.js
  var TRefSymbolKey = "effect/TRef";
  var TRefTypeId = /* @__PURE__ */ Symbol.for(TRefSymbolKey);
  var tRefVariance = {
    _A: (_) => _
  };

  class TRefImpl {
    [TRefTypeId] = tRefVariance;
    todos;
    versioned;
    constructor(value) {
      this.versioned = new Versioned(value);
      this.todos = new Map;
    }
    modify(f) {
      return effect3((journal) => {
        const entry = getOrMakeEntry(this, journal);
        const [retValue, newValue] = f(unsafeGet6(entry));
        unsafeSet(entry, newValue);
        return retValue;
      });
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var make47 = (value) => effect3((journal) => {
    const ref = new TRefImpl(value);
    journal.set(ref, make45(ref, true));
    return ref;
  });
  var get16 = (self) => self.modify((a) => [a, a]);
  var set7 = /* @__PURE__ */ dual(2, (self, value) => self.modify(() => [undefined, value]));
  var getOrMakeEntry = (self, journal) => {
    if (journal.has(self)) {
      return journal.get(self);
    }
    const entry = make45(self, false);
    journal.set(self, entry);
    return entry;
  };
  var unsafeGet7 = /* @__PURE__ */ dual(2, (self, journal) => unsafeGet6(getOrMakeEntry(self, journal)));
  var unsafeSet2 = /* @__PURE__ */ dual(3, (self, value, journal) => {
    const entry = getOrMakeEntry(self, journal);
    unsafeSet(entry, value);
    return;
  });

  // node_modules/effect/dist/esm/internal/stm/tQueue.js
  var TEnqueueSymbolKey = "effect/TQueue/TEnqueue";
  var TEnqueueTypeId = /* @__PURE__ */ Symbol.for(TEnqueueSymbolKey);
  var TDequeueSymbolKey = "effect/TQueue/TDequeue";
  var TDequeueTypeId = /* @__PURE__ */ Symbol.for(TDequeueSymbolKey);
  var tDequeueVariance = {
    _Out: (_) => _
  };
  var tEnqueueVariance = {
    _In: (_) => _
  };

  class TQueueImpl {
    ref;
    requestedCapacity;
    strategy;
    [TDequeueTypeId] = tDequeueVariance;
    [TEnqueueTypeId] = tEnqueueVariance;
    constructor(ref, requestedCapacity, strategy) {
      this.ref = ref;
      this.requestedCapacity = requestedCapacity;
      this.strategy = strategy;
    }
    capacity() {
      return this.requestedCapacity;
    }
    size = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      const queue = unsafeGet7(this.ref, runtime4.journal);
      if (queue === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      return succeed13(queue.length);
    });
    isFull = /* @__PURE__ */ map20(this.size, (size11) => size11 === this.requestedCapacity);
    isEmpty = /* @__PURE__ */ map20(this.size, (size11) => size11 === 0);
    shutdown = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      unsafeSet2(this.ref, undefined, runtime4.journal);
      return void_6;
    });
    isShutdown = /* @__PURE__ */ effect3((journal) => {
      const queue = unsafeGet7(this.ref, journal);
      return queue === undefined;
    });
    awaitShutdown = /* @__PURE__ */ flatMap15(this.isShutdown, (isShutdown4) => isShutdown4 ? void_6 : retry5);
    offer(value) {
      return withSTMRuntime((runtime4) => {
        const queue = pipe(this.ref, unsafeGet7(runtime4.journal));
        if (queue === undefined) {
          return interruptAs2(runtime4.fiberId);
        }
        if (queue.length < this.requestedCapacity) {
          queue.push(value);
          unsafeSet2(this.ref, queue, runtime4.journal);
          return succeed13(true);
        }
        switch (this.strategy._tag) {
          case OP_BACKPRESSURE_STRATEGY: {
            return retry5;
          }
          case OP_DROPPING_STRATEGY: {
            return succeed13(false);
          }
          case OP_SLIDING_STRATEGY: {
            if (queue.length === 0) {
              return succeed13(true);
            }
            queue.shift();
            queue.push(value);
            unsafeSet2(this.ref, queue, runtime4.journal);
            return succeed13(true);
          }
        }
      });
    }
    offerAll(iterable) {
      return withSTMRuntime((runtime4) => {
        const as7 = Array.from(iterable);
        const queue = unsafeGet7(this.ref, runtime4.journal);
        if (queue === undefined) {
          return interruptAs2(runtime4.fiberId);
        }
        if (queue.length + as7.length <= this.requestedCapacity) {
          unsafeSet2(this.ref, [...queue, ...as7], runtime4.journal);
          return succeed13(true);
        }
        switch (this.strategy._tag) {
          case OP_BACKPRESSURE_STRATEGY: {
            return retry5;
          }
          case OP_DROPPING_STRATEGY: {
            const forQueue = as7.slice(0, this.requestedCapacity - queue.length);
            unsafeSet2(this.ref, [...queue, ...forQueue], runtime4.journal);
            return succeed13(false);
          }
          case OP_SLIDING_STRATEGY: {
            const forQueue = as7.slice(0, this.requestedCapacity - queue.length);
            const toDrop = queue.length + forQueue.length - this.requestedCapacity;
            const newQueue = queue.slice(toDrop);
            unsafeSet2(this.ref, [...newQueue, ...forQueue], runtime4.journal);
            return succeed13(true);
          }
        }
      });
    }
    peek = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      const queue = unsafeGet7(this.ref, runtime4.journal);
      if (queue === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      if (queue.length === 0) {
        return retry5;
      }
      return succeed13(queue[0]);
    });
    peekOption = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      const queue = unsafeGet7(this.ref, runtime4.journal);
      if (queue === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      return succeed13(fromNullable(queue[0]));
    });
    take = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      const queue = unsafeGet7(this.ref, runtime4.journal);
      if (queue === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      if (queue.length === 0) {
        return retry5;
      }
      const dequeued = queue.shift();
      unsafeSet2(this.ref, queue, runtime4.journal);
      return succeed13(dequeued);
    });
    takeAll = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      const queue = unsafeGet7(this.ref, runtime4.journal);
      if (queue === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      unsafeSet2(this.ref, [], runtime4.journal);
      return succeed13(queue);
    });
    takeUpTo(max5) {
      return withSTMRuntime((runtime4) => {
        const queue = unsafeGet7(this.ref, runtime4.journal);
        if (queue === undefined) {
          return interruptAs2(runtime4.fiberId);
        }
        const [toTake, remaining] = splitAt2(unsafeFromArray(queue), max5);
        unsafeSet2(this.ref, Array.from(remaining), runtime4.journal);
        return succeed13(Array.from(toTake));
      });
    }
  }
  var isShutdown4 = (self) => self.isShutdown;
  var shutdown5 = (self) => self.shutdown;
  var take4 = (self) => self.take;

  // node_modules/effect/dist/esm/internal/stm/tPubSub.js
  var TPubSubSymbolKey = "effect/TPubSub";
  var TPubSubTypeId = /* @__PURE__ */ Symbol.for(TPubSubSymbolKey);
  var AbsentValue2 = /* @__PURE__ */ Symbol.for("effect/TPubSub/AbsentValue");
  var makeNode2 = (head6, subscribers, tail) => ({
    head: head6,
    subscribers,
    tail
  });

  class TPubSubImpl {
    pubsubSize;
    publisherHead;
    publisherTail;
    requestedCapacity;
    strategy;
    subscriberCount;
    subscribers;
    [TPubSubTypeId] = {
      _A: (_) => _
    };
    [TEnqueueTypeId] = tEnqueueVariance;
    constructor(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers) {
      this.pubsubSize = pubsubSize;
      this.publisherHead = publisherHead;
      this.publisherTail = publisherTail;
      this.requestedCapacity = requestedCapacity;
      this.strategy = strategy;
      this.subscriberCount = subscriberCount;
      this.subscribers = subscribers;
    }
    isShutdown = /* @__PURE__ */ effect3((journal) => {
      const currentPublisherTail = unsafeGet7(this.publisherTail, journal);
      return currentPublisherTail === undefined;
    });
    awaitShutdown = /* @__PURE__ */ flatMap15(this.isShutdown, (isShutdown5) => isShutdown5 ? void_6 : retry5);
    capacity() {
      return this.requestedCapacity;
    }
    size = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      const currentPublisherTail = unsafeGet7(this.publisherTail, runtime4.journal);
      if (currentPublisherTail === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      return succeed13(unsafeGet7(this.pubsubSize, runtime4.journal));
    });
    isEmpty = /* @__PURE__ */ map20(this.size, (size11) => size11 === 0);
    isFull = /* @__PURE__ */ map20(this.size, (size11) => size11 === this.capacity());
    offer(value) {
      return withSTMRuntime((runtime4) => {
        const currentPublisherTail = unsafeGet7(this.publisherTail, runtime4.journal);
        if (currentPublisherTail === undefined) {
          return interruptAs2(runtime4.fiberId);
        }
        const currentSubscriberCount = unsafeGet7(this.subscriberCount, runtime4.journal);
        if (currentSubscriberCount === 0) {
          return succeed13(true);
        }
        const currentPubSubSize = unsafeGet7(this.pubsubSize, runtime4.journal);
        if (currentPubSubSize < this.requestedCapacity) {
          const updatedPublisherTail = new TRefImpl(undefined);
          const updatedNode = makeNode2(value, currentSubscriberCount, updatedPublisherTail);
          unsafeSet2(currentPublisherTail, updatedNode, runtime4.journal);
          unsafeSet2(this.publisherTail, updatedPublisherTail, runtime4.journal);
          unsafeSet2(this.pubsubSize, currentPubSubSize + 1, runtime4.journal);
          return succeed13(true);
        }
        switch (this.strategy._tag) {
          case OP_BACKPRESSURE_STRATEGY: {
            return retry5;
          }
          case OP_DROPPING_STRATEGY: {
            return succeed13(false);
          }
          case OP_SLIDING_STRATEGY: {
            if (this.requestedCapacity > 0) {
              let currentPublisherHead = unsafeGet7(this.publisherHead, runtime4.journal);
              let loop3 = true;
              while (loop3) {
                const node = unsafeGet7(currentPublisherHead, runtime4.journal);
                if (node === undefined) {
                  return retry5;
                }
                const head6 = node.head;
                const tail = node.tail;
                if (head6 !== AbsentValue2) {
                  const updatedNode2 = makeNode2(AbsentValue2, node.subscribers, node.tail);
                  unsafeSet2(currentPublisherHead, updatedNode2, runtime4.journal);
                  unsafeSet2(this.publisherHead, tail, runtime4.journal);
                  loop3 = false;
                } else {
                  currentPublisherHead = tail;
                }
              }
            }
            const updatedPublisherTail = new TRefImpl(undefined);
            const updatedNode = makeNode2(value, currentSubscriberCount, updatedPublisherTail);
            unsafeSet2(currentPublisherTail, updatedNode, runtime4.journal);
            unsafeSet2(this.publisherTail, updatedPublisherTail, runtime4.journal);
            return succeed13(true);
          }
        }
      });
    }
    offerAll(iterable) {
      return map20(forEach8(iterable, (a) => this.offer(a)), every(identity));
    }
    shutdown = /* @__PURE__ */ effect3((journal) => {
      const currentPublisherTail = unsafeGet7(this.publisherTail, journal);
      if (currentPublisherTail !== undefined) {
        unsafeSet2(this.publisherTail, undefined, journal);
        const currentSubscribers = unsafeGet7(this.subscribers, journal);
        forEach3(currentSubscribers, (subscriber) => {
          unsafeSet2(subscriber, undefined, journal);
        });
        unsafeSet2(this.subscribers, empty7(), journal);
      }
    });
  }

  class TPubSubSubscriptionImpl {
    pubsubSize;
    publisherHead;
    requestedCapacity;
    subscriberHead;
    subscriberCount;
    subscribers;
    [TPubSubTypeId] = TPubSubTypeId;
    [TDequeueTypeId] = tDequeueVariance;
    constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
      this.pubsubSize = pubsubSize;
      this.publisherHead = publisherHead;
      this.requestedCapacity = requestedCapacity;
      this.subscriberHead = subscriberHead;
      this.subscriberCount = subscriberCount;
      this.subscribers = subscribers;
    }
    isShutdown = /* @__PURE__ */ effect3((journal) => {
      const currentSubscriberHead = unsafeGet7(this.subscriberHead, journal);
      return currentSubscriberHead === undefined;
    });
    awaitShutdown = /* @__PURE__ */ flatMap15(this.isShutdown, (isShutdown5) => isShutdown5 ? void_6 : retry5);
    capacity() {
      return this.requestedCapacity;
    }
    size = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime4.journal);
      if (currentSubscriberHead === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      let loop3 = true;
      let size11 = 0;
      while (loop3) {
        const node = unsafeGet7(currentSubscriberHead, runtime4.journal);
        if (node === undefined) {
          loop3 = false;
        } else {
          const head6 = node.head;
          const tail = node.tail;
          if (head6 !== AbsentValue2) {
            size11 = size11 + 1;
            if (size11 >= Number.MAX_SAFE_INTEGER) {
              loop3 = false;
            }
          }
          currentSubscriberHead = tail;
        }
      }
      return succeed13(size11);
    });
    isEmpty = /* @__PURE__ */ map20(this.size, (size11) => size11 === 0);
    isFull = /* @__PURE__ */ map20(this.size, (size11) => size11 === this.capacity());
    peek = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime4.journal);
      if (currentSubscriberHead === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      let value = AbsentValue2;
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet7(currentSubscriberHead, runtime4.journal);
        if (node === undefined) {
          return retry5;
        }
        const head6 = node.head;
        const tail = node.tail;
        if (head6 !== AbsentValue2) {
          value = head6;
          loop3 = false;
        } else {
          currentSubscriberHead = tail;
        }
      }
      return succeed13(value);
    });
    peekOption = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime4.journal);
      if (currentSubscriberHead === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      let value = none2();
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet7(currentSubscriberHead, runtime4.journal);
        if (node === undefined) {
          value = none2();
          loop3 = false;
        } else {
          const head6 = node.head;
          const tail = node.tail;
          if (head6 !== AbsentValue2) {
            value = some2(head6);
            loop3 = false;
          } else {
            currentSubscriberHead = tail;
          }
        }
      }
      return succeed13(value);
    });
    shutdown = /* @__PURE__ */ effect3((journal) => {
      let currentSubscriberHead = unsafeGet7(this.subscriberHead, journal);
      if (currentSubscriberHead !== undefined) {
        unsafeSet2(this.subscriberHead, undefined, journal);
        let loop3 = true;
        while (loop3) {
          const node = unsafeGet7(currentSubscriberHead, journal);
          if (node === undefined) {
            loop3 = false;
          } else {
            const head6 = node.head;
            const tail = node.tail;
            if (head6 !== AbsentValue2) {
              const subscribers = node.subscribers;
              if (subscribers === 1) {
                const size11 = unsafeGet7(this.pubsubSize, journal);
                const updatedNode = makeNode2(AbsentValue2, 0, tail);
                unsafeSet2(currentSubscriberHead, updatedNode, journal);
                unsafeSet2(this.publisherHead, tail, journal);
                unsafeSet2(this.pubsubSize, size11 - 1, journal);
              } else {
                const updatedNode = makeNode2(head6, subscribers - 1, tail);
                unsafeSet2(currentSubscriberHead, updatedNode, journal);
              }
            }
            currentSubscriberHead = tail;
          }
        }
        const currentSubscriberCount = unsafeGet7(this.subscriberCount, journal);
        unsafeSet2(this.subscriberCount, currentSubscriberCount - 1, journal);
        unsafeSet2(this.subscribers, remove4(unsafeGet7(this.subscribers, journal), this.subscriberHead), journal);
      }
    });
    take = /* @__PURE__ */ withSTMRuntime((runtime4) => {
      let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime4.journal);
      if (currentSubscriberHead === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      let value = AbsentValue2;
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet7(currentSubscriberHead, runtime4.journal);
        if (node === undefined) {
          return retry5;
        }
        const head6 = node.head;
        const tail = node.tail;
        if (head6 !== AbsentValue2) {
          const subscribers = node.subscribers;
          if (subscribers === 1) {
            const size11 = unsafeGet7(this.pubsubSize, runtime4.journal);
            const updatedNode = makeNode2(AbsentValue2, 0, tail);
            unsafeSet2(currentSubscriberHead, updatedNode, runtime4.journal);
            unsafeSet2(this.publisherHead, tail, runtime4.journal);
            unsafeSet2(this.pubsubSize, size11 - 1, runtime4.journal);
          } else {
            const updatedNode = makeNode2(head6, subscribers - 1, tail);
            unsafeSet2(currentSubscriberHead, updatedNode, runtime4.journal);
          }
          unsafeSet2(this.subscriberHead, tail, runtime4.journal);
          value = head6;
          loop3 = false;
        } else {
          currentSubscriberHead = tail;
        }
      }
      return succeed13(value);
    });
    takeAll = /* @__PURE__ */ this.takeUpTo(Number.POSITIVE_INFINITY);
    takeUpTo(max5) {
      return withSTMRuntime((runtime4) => {
        let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime4.journal);
        if (currentSubscriberHead === undefined) {
          return interruptAs2(runtime4.fiberId);
        }
        const builder = [];
        let n = 0;
        while (n !== max5) {
          const node = unsafeGet7(currentSubscriberHead, runtime4.journal);
          if (node === undefined) {
            n = max5;
          } else {
            const head6 = node.head;
            const tail = node.tail;
            if (head6 !== AbsentValue2) {
              const subscribers = node.subscribers;
              if (subscribers === 1) {
                const size11 = unsafeGet7(this.pubsubSize, runtime4.journal);
                const updatedNode = makeNode2(AbsentValue2, 0, tail);
                unsafeSet2(currentSubscriberHead, updatedNode, runtime4.journal);
                unsafeSet2(this.publisherHead, tail, runtime4.journal);
                unsafeSet2(this.pubsubSize, size11 - 1, runtime4.journal);
              } else {
                const updatedNode = makeNode2(head6, subscribers - 1, tail);
                unsafeSet2(currentSubscriberHead, updatedNode, runtime4.journal);
              }
              builder.push(head6);
              n = n + 1;
            }
            currentSubscriberHead = tail;
          }
        }
        unsafeSet2(this.subscriberHead, currentSubscriberHead, runtime4.journal);
        return succeed13(builder);
      });
    }
  }
  var makeSubscription2 = (pubsubSize, publisherHead, publisherTail, requestedCapacity, subscriberCount, subscribers) => pipe(get16(publisherTail), flatMap15((currentPublisherTail) => pipe(all5([make47(currentPublisherTail), get16(subscriberCount), get16(subscribers)]), tap5(([_, currentSubscriberCount]) => pipe(subscriberCount, set7(currentSubscriberCount + 1))), tap5(([subscriberHead, _, currentSubscribers]) => pipe(subscribers, set7(pipe(currentSubscribers, add4(subscriberHead))))), map20(([subscriberHead]) => new TPubSubSubscriptionImpl(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers)))));
  var subscribe3 = (self) => makeSubscription2(self.pubsubSize, self.publisherHead, self.publisherTail, self.requestedCapacity, self.subscriberCount, self.subscribers);
  var subscribeScoped = (self) => acquireRelease2(subscribe3(self), (dequeue) => shutdown5(dequeue));

  // node_modules/effect/dist/esm/TPubSub.js
  var subscribeScoped2 = subscribeScoped;

  // node_modules/effect/dist/esm/TQueue.js
  var isShutdown6 = isShutdown4;
  var take5 = take4;

  // node_modules/effect/dist/esm/internal/ringBuffer.js
  class RingBuffer {
    capacity;
    array;
    size = 0;
    current = 0;
    constructor(capacity7) {
      this.capacity = capacity7;
      this.array = Array.from({
        length: capacity7
      }, constUndefined);
    }
    head() {
      return fromNullable(this.array[this.current]);
    }
    lastOrNull() {
      if (this.size === 0) {
        return;
      }
      const index = this.current === 0 ? this.array.length - 1 : this.current - 1;
      return this.array[index] ?? undefined;
    }
    put(value) {
      this.array[this.current] = value;
      this.increment();
    }
    dropLast() {
      if (this.size > 0) {
        this.decrement();
        this.array[this.current] = undefined;
      }
    }
    toChunk() {
      const begin = this.current - this.size;
      const newArray = begin < 0 ? [...this.array.slice(this.capacity + begin, this.capacity), ...this.array.slice(0, this.current)] : this.array.slice(begin, this.current);
      return fromIterable2(newArray);
    }
    increment() {
      if (this.size < this.capacity) {
        this.size += 1;
      }
      this.current = (this.current + 1) % this.capacity;
    }
    decrement() {
      this.size -= 1;
      if (this.current > 0) {
        this.current -= 1;
      } else {
        this.current = this.capacity - 1;
      }
    }
  }

  // node_modules/effect/dist/esm/internal/stream/debounceState.js
  var OP_NOT_STARTED = "NotStarted";
  var OP_PREVIOUS = "Previous";
  var OP_CURRENT = "Current";
  var notStarted = {
    _tag: OP_NOT_STARTED
  };
  var previous = (fiber) => ({
    _tag: OP_PREVIOUS,
    fiber
  });
  var current = (fiber) => ({
    _tag: OP_CURRENT,
    fiber
  });

  // node_modules/effect/dist/esm/internal/stream/emit.js
  var make48 = (emit) => {
    const ops = {
      chunk(as7) {
        return this(succeed8(as7));
      },
      die(defect) {
        return this(die6(defect));
      },
      dieMessage(message) {
        return this(dieMessage2(message));
      },
      done(exit3) {
        return this(suspend3(() => mapBoth2(exit3, {
          onFailure: some2,
          onSuccess: of2
        })));
      },
      end() {
        return this(fail9(none2()));
      },
      fail(e) {
        return this(fail9(some2(e)));
      },
      fromEffect(effect4) {
        return this(mapBoth3(effect4, {
          onFailure: some2,
          onSuccess: of2
        }));
      },
      fromEffectChunk(effect4) {
        return this(pipe(effect4, mapError3(some2)));
      },
      halt(cause3) {
        return this(failCause8(pipe(cause3, map12(some2))));
      },
      single(value) {
        return this(succeed8(of2(value)));
      }
    };
    return Object.assign(emit, ops);
  };
  var makePush = (queue, scheduler) => {
    let finished = false;
    let buffer = [];
    let running4 = false;
    function array3(items) {
      if (finished)
        return false;
      if (items.length <= 50000) {
        buffer.push.apply(buffer, items);
      } else {
        for (let i = 0;i < items.length; i++) {
          buffer.push(items[0]);
        }
      }
      if (!running4) {
        running4 = true;
        scheduler.scheduleTask(flush, 0);
      }
      return true;
    }
    function flush() {
      running4 = false;
      if (buffer.length > 0) {
        queue.unsafeOffer(buffer);
        buffer = [];
      }
    }
    function done10(exit3) {
      if (finished)
        return;
      finished = true;
      if (exit3._tag === "Success") {
        buffer.push(exit3.value);
      }
      flush();
      queue.unsafeOffer(exit3._tag === "Success" ? void_2 : exit3);
    }
    return {
      single(value) {
        if (finished)
          return false;
        buffer.push(value);
        if (!running4) {
          running4 = true;
          scheduler.scheduleTask(flush, 0);
        }
        return true;
      },
      array: array3,
      chunk(chunk2) {
        return array3(toReadonlyArray(chunk2));
      },
      done: done10,
      end() {
        if (finished)
          return;
        finished = true;
        flush();
        queue.unsafeOffer(void_2);
      },
      halt(cause3) {
        return done10(failCause3(cause3));
      },
      fail(error) {
        return done10(fail4(error));
      },
      die(defect) {
        return done10(die3(defect));
      },
      dieMessage(message) {
        return done10(die3(new Error(message)));
      }
    };
  };

  // node_modules/effect/dist/esm/internal/stream/handoff.js
  var HandoffTypeId = /* @__PURE__ */ Symbol.for("effect/Stream/Handoff");
  var OP_HANDOFF_STATE_EMPTY = "Empty";
  var OP_HANDOFF_STATE_FULL = "Full";
  var handoffStateEmpty = (notifyConsumer) => ({
    _tag: OP_HANDOFF_STATE_EMPTY,
    notifyConsumer
  });
  var handoffStateFull = (value, notifyProducer) => ({
    _tag: OP_HANDOFF_STATE_FULL,
    value,
    notifyProducer
  });
  var handoffStateMatch = (onEmpty, onFull) => {
    return (self) => {
      switch (self._tag) {
        case OP_HANDOFF_STATE_EMPTY: {
          return onEmpty(self.notifyConsumer);
        }
        case OP_HANDOFF_STATE_FULL: {
          return onFull(self.value, self.notifyProducer);
        }
      }
    };
  };
  var handoffVariance = {
    _A: (_) => _
  };
  var make49 = () => pipe(make18(), flatMap11((deferred) => make28(handoffStateEmpty(deferred))), map16((ref) => ({
    [HandoffTypeId]: handoffVariance,
    ref
  })));
  var offer5 = /* @__PURE__ */ dual(2, (self, value) => {
    return flatMap11(make18(), (deferred) => flatten9(modify4(self.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [zipRight3(succeed2(notifyConsumer, undefined), _await(deferred)), handoffStateFull(value, deferred)], (_, notifyProducer) => [flatMap11(_await(notifyProducer), () => pipe(self, offer5(value))), state])))));
  });
  var take6 = (self) => flatMap11(make18(), (deferred) => flatten9(modify4(self.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [flatMap11(_await(notifyConsumer), () => take6(self)), state], (value, notifyProducer) => [as3(succeed2(notifyProducer, undefined), value), handoffStateEmpty(deferred)])))));

  // node_modules/effect/dist/esm/internal/stream/handoffSignal.js
  var OP_EMIT4 = "Emit";
  var OP_HALT = "Halt";
  var OP_END = "End";
  var emit = (elements) => ({
    _tag: OP_EMIT4,
    elements
  });
  var halt = (cause3) => ({
    _tag: OP_HALT,
    cause: cause3
  });
  var end3 = (reason) => ({
    _tag: OP_END,
    reason
  });

  // node_modules/effect/dist/esm/internal/take.js
  var TakeSymbolKey = "effect/Take";
  var TakeTypeId = /* @__PURE__ */ Symbol.for(TakeSymbolKey);
  var takeVariance = {
    _A: (_) => _,
    _E: (_) => _
  };

  class TakeImpl {
    exit;
    [TakeTypeId] = takeVariance;
    constructor(exit3) {
      this.exit = exit3;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var chunk2 = (chunk3) => new TakeImpl(succeed3(chunk3));
  var done10 = (self) => suspend3(() => self.exit);
  var end4 = /* @__PURE__ */ new TakeImpl(/* @__PURE__ */ fail4(/* @__PURE__ */ none2()));
  var failCause11 = (cause3) => new TakeImpl(failCause3(pipe(cause3, map12(some2))));
  var fromPull = (pull) => matchCause3(pull, {
    onFailure: (cause3) => match2(flipCauseOption2(cause3), {
      onNone: () => end4,
      onSome: failCause11
    }),
    onSuccess: chunk2
  });
  var match17 = /* @__PURE__ */ dual(2, (self, {
    onEnd,
    onFailure,
    onSuccess
  }) => match6(self.exit, {
    onFailure: (cause3) => match2(flipCauseOption2(cause3), {
      onNone: onEnd,
      onSome: onFailure
    }),
    onSuccess
  }));
  var of5 = (value) => new TakeImpl(succeed3(of2(value)));

  // node_modules/effect/dist/esm/internal/stream/pull.js
  var end5 = () => fail9(none2());
  var failCause12 = (cause3) => mapError3(failCause8(cause3), some2);

  // node_modules/effect/dist/esm/internal/stream/sinkEndReason.js
  var OP_SCHEDULE_END = "ScheduleEnd";
  var OP_UPSTREAM_END = "UpstreamEnd";
  var ScheduleEnd = {
    _tag: OP_SCHEDULE_END
  };
  var UpstreamEnd = {
    _tag: OP_UPSTREAM_END
  };

  // node_modules/effect/dist/esm/internal/stream/zipAllState.js
  var OP_DRAIN_LEFT = "DrainLeft";
  var OP_DRAIN_RIGHT = "DrainRight";
  var OP_PULL_BOTH = "PullBoth";
  var OP_PULL_LEFT = "PullLeft";
  var OP_PULL_RIGHT = "PullRight";
  var DrainLeft = {
    _tag: OP_DRAIN_LEFT
  };
  var DrainRight = {
    _tag: OP_DRAIN_RIGHT
  };
  var PullBoth = {
    _tag: OP_PULL_BOTH
  };
  var PullLeft = (rightChunk) => ({
    _tag: OP_PULL_LEFT,
    rightChunk
  });
  var PullRight = (leftChunk) => ({
    _tag: OP_PULL_RIGHT,
    leftChunk
  });

  // node_modules/effect/dist/esm/internal/stream/zipChunksState.js
  var OP_PULL_BOTH2 = "PullBoth";
  var OP_PULL_LEFT2 = "PullLet";
  var OP_PULL_RIGHT2 = "PullRight";
  var PullBoth2 = {
    _tag: OP_PULL_BOTH2
  };
  var PullLeft2 = (rightChunk) => ({
    _tag: OP_PULL_LEFT2,
    rightChunk
  });
  var PullRight2 = (leftChunk) => ({
    _tag: OP_PULL_RIGHT2,
    leftChunk
  });

  // node_modules/effect/dist/esm/internal/stream.js
  var StreamSymbolKey = "effect/Stream";
  var StreamTypeId2 = /* @__PURE__ */ Symbol.for(StreamSymbolKey);
  var streamVariance = {
    _R: (_) => _,
    _E: (_) => _,
    _A: (_) => _
  };

  class StreamImpl {
    channel;
    [StreamTypeId2] = streamVariance;
    constructor(channel) {
      this.channel = channel;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var isStream = (u) => hasProperty(u, StreamTypeId2) || isEffect2(u);
  var DefaultChunkSize = 4096;
  var accumulate = (self) => chunks(accumulateChunks(self));
  var accumulateChunks = (self) => {
    const accumulator = (s) => readWith({
      onInput: (input) => {
        const next = appendAll2(s, input);
        return flatMap13(write(next), () => accumulator(next));
      },
      onFailure: fail11,
      onDone: () => void_5
    });
    return new StreamImpl(pipeTo(toChannel2(self), accumulator(empty4())));
  };
  var acquireRelease3 = (acquire, release) => scoped5(acquireRelease2(acquire, release));
  var aggregate = /* @__PURE__ */ dual(2, (self, sink) => aggregateWithin(self, sink, forever4));
  var aggregateWithin = /* @__PURE__ */ dual(3, (self, sink, schedule2) => filterMap6(aggregateWithinEither(self, sink, schedule2), (_) => match(_, {
    onLeft: none2,
    onRight: some2
  })));
  var aggregateWithinEither = /* @__PURE__ */ dual(3, (self, sink, schedule2) => {
    const layer = all4([make49(), make28(ScheduleEnd), make28(empty4()), driver2(schedule2), make28(false), make28(false)]);
    return fromEffect7(layer).pipe(flatMap16(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {
      const handoffProducer = readWithCause({
        onInput: (input) => flatMap13(fromEffect4(pipe(handoff, offer5(emit(input)), when2(() => isNonEmpty2(input)))), () => handoffProducer),
        onFailure: (cause3) => fromEffect4(offer5(handoff, halt(cause3))),
        onDone: () => fromEffect4(offer5(handoff, end3(UpstreamEnd)))
      });
      const handoffConsumer = pipe(getAndSet2(sinkLeftovers, empty4()), flatMap11((leftovers) => {
        if (isNonEmpty2(leftovers)) {
          return pipe(set6(consumed, true), zipRight3(succeed8(pipe(write(leftovers), flatMap13(() => handoffConsumer)))));
        }
        return pipe(take6(handoff), map16((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return pipe(fromEffect4(set6(consumed, true)), zipRight4(write(signal.elements)), zipRight4(fromEffect4(get12(endAfterEmit))), flatMap13((bool) => bool ? void_5 : handoffConsumer));
            }
            case OP_HALT: {
              return failCause10(signal.cause);
            }
            case OP_END: {
              if (signal.reason._tag === OP_SCHEDULE_END) {
                return pipe(get12(consumed), map16((bool) => bool ? fromEffect4(pipe(set6(sinkEndReason, ScheduleEnd), zipRight3(set6(endAfterEmit, true)))) : pipe(fromEffect4(pipe(set6(sinkEndReason, ScheduleEnd), zipRight3(set6(endAfterEmit, true)))), flatMap13(() => handoffConsumer))), unwrap);
              }
              return pipe(set6(sinkEndReason, signal.reason), zipRight3(set6(endAfterEmit, true)), fromEffect4);
            }
          }
        }));
      }), unwrap);
      const timeout3 = (lastB) => scheduleDriver.next(lastB);
      const scheduledAggregator = (sinkFiber, scheduleFiber, scope5) => {
        const forkSink = pipe(set6(consumed, false), zipRight3(set6(endAfterEmit, false)), zipRight3(pipe(handoffConsumer, pipeToOrFail(toChannel(sink)), collectElements, run, forkIn2(scope5))));
        const handleSide = (leftovers, b, c) => pipe(set6(sinkLeftovers, flatten3(leftovers)), zipRight3(map16(get12(sinkEndReason), (reason) => {
          switch (reason._tag) {
            case OP_SCHEDULE_END: {
              return pipe(all4([get12(consumed), forkSink, pipe(timeout3(some2(b)), forkIn2(scope5))]), map16(([wasConsumed, sinkFiber2, scheduleFiber2]) => {
                const toWrite = pipe(c, match2({
                  onNone: () => of2(right2(b)),
                  onSome: (c2) => make6(right2(b), left2(c2))
                }));
                if (wasConsumed) {
                  return pipe(write(toWrite), flatMap13(() => scheduledAggregator(sinkFiber2, scheduleFiber2, scope5)));
                }
                return scheduledAggregator(sinkFiber2, scheduleFiber2, scope5);
              }), unwrap);
            }
            case OP_UPSTREAM_END: {
              return pipe(get12(consumed), map16((wasConsumed) => wasConsumed ? write(of2(right2(b))) : void_5), unwrap);
            }
          }
        })), unwrap);
        return unwrap(raceWith2(join3(sinkFiber), join3(scheduleFiber), {
          onSelfDone: (sinkExit, _) => pipe(interrupt6(scheduleFiber), zipRight3(pipe(suspend3(() => sinkExit), map16(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
          onOtherDone: (scheduleExit, _) => matchCauseEffect3(suspend3(() => scheduleExit), {
            onFailure: (cause3) => match(failureOrCause2(cause3), {
              onLeft: () => pipe(handoff, offer5(end3(ScheduleEnd)), forkDaemon2, zipRight3(pipe(join3(sinkFiber), map16(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
              onRight: (cause4) => pipe(handoff, offer5(halt(cause4)), forkDaemon2, zipRight3(pipe(join3(sinkFiber), map16(([leftovers, b]) => handleSide(leftovers, b, none2())))))
            }),
            onSuccess: (c) => pipe(handoff, offer5(end3(ScheduleEnd)), forkDaemon2, zipRight3(pipe(join3(sinkFiber), map16(([leftovers, b]) => handleSide(leftovers, b, some2(c))))))
          })
        }));
      };
      return unwrapScopedWith3((scope5) => pipeTo(toChannel2(self), handoffProducer).pipe(run, forkIn2(scope5), zipRight3(pipeToOrFail(handoffConsumer, toChannel(sink)).pipe(collectElements, run, forkIn2(scope5), flatMap11((sinkFiber) => timeout3(none2()).pipe(forkIn2(scope5), map16((scheduleFiber) => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope5)))))))));
    }));
  });
  var as7 = /* @__PURE__ */ dual(2, (self, value) => map21(self, () => value));
  var queueFromBufferOptions = (bufferSize) => {
    if (bufferSize === "unbounded") {
      return unbounded5();
    } else if (typeof bufferSize === "number" || bufferSize === undefined) {
      return bounded5(bufferSize ?? 16);
    }
    switch (bufferSize.strategy) {
      case "dropping":
        return dropping4(bufferSize.bufferSize ?? 16);
      case "sliding":
        return sliding4(bufferSize.bufferSize ?? 16);
      default:
        return bounded5(bufferSize.bufferSize ?? 16);
    }
  };
  var _async = (register, bufferSize) => acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)).pipe(flatMap11((output) => runtime3().pipe(flatMap11((runtime4) => sync3(() => {
    const runPromiseExit3 = runPromiseExit2(runtime4);
    const canceler = register(make48((resume2) => fromPull(resume2).pipe(flatMap11((take7) => offer3(output, take7)), asVoid3, runPromiseExit3).then((exit3) => {
      if (isFailure(exit3)) {
        if (!isInterrupted2(exit3.cause)) {
          throw squash(exit3.cause);
        }
      }
    })));
    return canceler;
  })), map16((value) => {
    const loop3 = take3(output).pipe(flatMap11((take7) => done10(take7)), match12({
      onFailure: (maybeError) => fromEffect4(shutdown4(output)).pipe(zipRight4(match2(maybeError, {
        onNone: () => void_5,
        onSome: (error) => fail11(error)
      }))),
      onSuccess: (chunk3) => write(chunk3).pipe(flatMap13(() => loop3))
    }), unwrap);
    return fromChannel2(loop3).pipe(ensuring6(value ?? _void));
  }))), unwrapScoped4);
  var asyncEffect3 = (register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)), flatMap11((output) => pipe(runtime3(), flatMap11((runtime4) => pipe(register(make48((k) => pipe(fromPull(k), flatMap11((take7) => offer3(output, take7)), asVoid3, runPromiseExit2(runtime4)).then((exit3) => {
    if (isFailure(exit3)) {
      if (!isInterrupted2(exit3.cause)) {
        throw squash(exit3.cause);
      }
    }
  }))), map16(() => {
    const loop3 = pipe(take3(output), flatMap11(done10), match12({
      onFailure: (maybeError) => pipe(fromEffect4(shutdown4(output)), zipRight4(match2(maybeError, {
        onNone: () => void_5,
        onSome: fail11
      }))),
      onSuccess: (chunk3) => pipe(write(chunk3), flatMap13(() => loop3))
    }), unwrap);
    return loop3;
  }))))), unwrapScoped3, fromChannel2);
  var queueFromBufferOptionsPush = (options) => {
    if (options?.bufferSize === "unbounded" || options?.bufferSize === undefined && options?.strategy === undefined) {
      return unbounded5();
    }
    switch (options?.strategy) {
      case "sliding":
        return sliding4(options.bufferSize ?? 16);
      default:
        return dropping4(options?.bufferSize ?? 16);
    }
  };
  var asyncPush = (register, options) => acquireRelease2(queueFromBufferOptionsPush(options), shutdown4).pipe(tap3((queue) => getWith(currentScheduler2, (scheduler) => register(makePush(queue, scheduler)))), map16((queue) => {
    const loop3 = flatMap13(take3(queue), (item) => isExit(item) ? isSuccess(item) ? void_5 : failCause10(item.cause) : zipRight4(write(unsafeFromArray(item)), loop3));
    return loop3;
  }), unwrapScoped3, fromChannel2);
  var asyncScoped = (register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)), flatMap11((output) => pipe(runtime3(), flatMap11((runtime4) => pipe(register(make48((k) => pipe(fromPull(k), flatMap11((take7) => offer3(output, take7)), asVoid3, runPromiseExit2(runtime4)).then((exit3) => {
    if (isFailure(exit3)) {
      if (!isInterrupted2(exit3.cause)) {
        throw squash(exit3.cause);
      }
    }
  }))), zipRight3(make28(false)), flatMap11((ref) => pipe(get12(ref), map16((isDone7) => isDone7 ? end5() : pipe(take3(output), flatMap11(done10), onError2(() => pipe(set6(ref, true), zipRight3(shutdown4(output)))))))))))), scoped5, flatMap16(repeatEffectChunkOption));
  var branchAfter = /* @__PURE__ */ dual(3, (self, n, f) => suspend9(() => {
    const buffering = (acc) => readWith({
      onInput: (input) => {
        const nextSize = acc.length + input.length;
        if (nextSize >= n) {
          const [b1, b2] = pipe(input, splitAt2(n - acc.length));
          return running4(pipe(acc, appendAll2(b1)), b2);
        }
        return buffering(pipe(acc, appendAll2(input)));
      },
      onFailure: fail11,
      onDone: () => running4(acc, empty4())
    });
    const running4 = (prefix, leftover) => pipeTo(zipRight4(write(leftover), identityChannel()), toChannel2(f(prefix)));
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(buffering(empty4()))));
  }));
  var broadcast = /* @__PURE__ */ dual(3, (self, n, maximumLag) => pipe(self, broadcastedQueues(n, maximumLag), map16((tuple) => tuple.map((queue) => flattenTake(fromQueue2(queue, {
    shutdown: true
  }))))));
  var broadcastDynamic = /* @__PURE__ */ dual(2, (self, maximumLag) => map16(toPubSub2(self, maximumLag), (pubsub) => flattenTake(fromPubSub(pubsub))));
  var share = /* @__PURE__ */ dual(2, (self, options) => map16(make44({
    acquire: broadcastDynamic(self, options),
    idleTimeToLive: options.idleTimeToLive
  }), (rcRef) => unwrapScoped4(get15(rcRef))));
  var broadcastedQueues = /* @__PURE__ */ dual(3, (self, n, maximumLag) => flatMap11(pubsubFromOptions(maximumLag), (pubsub) => pipe(all4(Array.from({
    length: n
  }, () => subscribe2(pubsub))), tap3(() => forkScoped2(runIntoPubSubScoped(self, pubsub))))));
  var broadcastedQueuesDynamic = /* @__PURE__ */ dual(2, (self, maximumLag) => map16(toPubSub2(self, maximumLag), subscribe2));
  var buffer = /* @__PURE__ */ dual(2, (self, options) => {
    if (options.capacity === "unbounded") {
      return bufferUnbounded(self);
    } else if (options.strategy === "dropping") {
      return bufferDropping(self, options.capacity);
    } else if (options.strategy === "sliding") {
      return bufferSliding(self, options.capacity);
    }
    const queue = toQueueOfElements(self, options);
    return new StreamImpl(unwrapScoped3(map16(queue, (queue2) => {
      const process2 = pipe(fromEffect4(take3(queue2)), flatMap13(match6({
        onFailure: (cause3) => pipe(flipCauseOption2(cause3), match2({
          onNone: () => void_5,
          onSome: failCause10
        })),
        onSuccess: (value) => flatMap13(write(of2(value)), () => process2)
      })));
      return process2;
    })));
  });
  var bufferChunks = /* @__PURE__ */ dual(2, (self, options) => {
    if (options.strategy === "dropping") {
      return bufferChunksDropping(self, options.capacity);
    } else if (options.strategy === "sliding") {
      return bufferChunksSliding(self, options.capacity);
    }
    const queue = toQueue2(self, options);
    return new StreamImpl(unwrapScoped3(map16(queue, (queue2) => {
      const process2 = pipe(fromEffect4(take3(queue2)), flatMap13(match17({
        onEnd: () => void_5,
        onFailure: failCause10,
        onSuccess: (value) => pipe(write(value), flatMap13(() => process2))
      })));
      return process2;
    })));
  });
  var bufferChunksDropping = /* @__PURE__ */ dual(2, (self, capacity7) => {
    const queue = acquireRelease2(dropping4(capacity7), (queue2) => shutdown4(queue2));
    return new StreamImpl(bufferSignal(queue, toChannel2(self)));
  });
  var bufferChunksSliding = /* @__PURE__ */ dual(2, (self, capacity7) => {
    const queue = acquireRelease2(sliding4(capacity7), (queue2) => shutdown4(queue2));
    return new StreamImpl(bufferSignal(queue, toChannel2(self)));
  });
  var bufferDropping = /* @__PURE__ */ dual(2, (self, capacity7) => {
    const queue = acquireRelease2(dropping4(capacity7), (queue2) => shutdown4(queue2));
    return new StreamImpl(bufferSignal(queue, toChannel2(rechunk(1)(self))));
  });
  var bufferSliding = /* @__PURE__ */ dual(2, (self, capacity7) => {
    const queue = acquireRelease2(sliding4(capacity7), (queue2) => shutdown4(queue2));
    return new StreamImpl(bufferSignal(queue, toChannel2(pipe(self, rechunk(1)))));
  });
  var bufferUnbounded = (self) => {
    const queue = toQueue2(self, {
      strategy: "unbounded"
    });
    return new StreamImpl(unwrapScoped3(map16(queue, (queue2) => {
      const process2 = pipe(fromEffect4(take3(queue2)), flatMap13(match17({
        onEnd: () => void_5,
        onFailure: failCause10,
        onSuccess: (value) => flatMap13(write(value), () => process2)
      })));
      return process2;
    })));
  };
  var bufferSignal = (scoped5, bufferChannel) => {
    const producer = (queue, ref) => {
      const terminate = (take7) => pipe(get12(ref), tap3(_await), zipRight3(make18()), flatMap11((deferred) => pipe(offer3(queue, [take7, deferred]), zipRight3(set6(ref, deferred)), zipRight3(_await(deferred)))), asVoid3, fromEffect4);
      return readWithCause({
        onInput: (input) => pipe(make18(), flatMap11((deferred) => pipe(offer3(queue, [chunk2(input), deferred]), flatMap11((added) => pipe(set6(ref, deferred), when2(() => added))))), asVoid3, fromEffect4, flatMap13(() => producer(queue, ref))),
        onFailure: (error) => terminate(failCause11(error)),
        onDone: () => terminate(end4)
      });
    };
    const consumer = (queue) => {
      const process2 = pipe(fromEffect4(take3(queue)), flatMap13(([take7, deferred]) => zipRight4(fromEffect4(succeed2(deferred, undefined)), match17(take7, {
        onEnd: () => void_5,
        onFailure: failCause10,
        onSuccess: (value) => pipe(write(value), flatMap13(() => process2))
      }))));
      return process2;
    };
    return unwrapScoped3(pipe(scoped5, flatMap11((queue) => pipe(make18(), tap3((start3) => succeed2(start3, undefined)), flatMap11((start3) => pipe(make28(start3), flatMap11((ref) => pipe(bufferChannel, pipeTo(producer(queue, ref)), runScoped, forkScoped2)), as3(consumer(queue))))))));
  };
  var catchAll7 = /* @__PURE__ */ dual(2, (self, f) => catchAllCause6(self, (cause3) => match(failureOrCause2(cause3), {
    onLeft: f,
    onRight: failCause13
  })));
  var catchAllCause6 = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), catchAllCause5((cause3) => toChannel2(f(cause3))))));
  var catchSome3 = /* @__PURE__ */ dual(2, (self, pf) => pipe(self, catchAll7((error) => pipe(pf(error), getOrElse(() => fail15(error))))));
  var catchSomeCause3 = /* @__PURE__ */ dual(2, (self, pf) => pipe(self, catchAllCause6((cause3) => pipe(pf(cause3), getOrElse(() => failCause13(cause3))))));
  var catchTag3 = /* @__PURE__ */ dual(3, (self, k, f) => catchAll7(self, (e) => {
    if ("_tag" in e && e["_tag"] === k) {
      return f(e);
    }
    return fail15(e);
  }));
  var catchTags3 = /* @__PURE__ */ dual(2, (self, cases) => catchAll7(self, (e) => {
    const keys3 = Object.keys(cases);
    if ("_tag" in e && keys3.includes(e["_tag"])) {
      return cases[e["_tag"]](e);
    }
    return fail15(e);
  }));
  var changes = (self) => pipe(self, changesWith((x, y) => equals(y)(x)));
  var changesWith = /* @__PURE__ */ dual(2, (self, f) => {
    const writer = (last4) => readWithCause({
      onInput: (input) => {
        const [newLast, newChunk] = reduce2(input, [last4, empty4()], ([option3, outputs], output) => {
          if (isSome2(option3) && f(option3.value, output)) {
            return [some2(output), outputs];
          }
          return [some2(output), pipe(outputs, append2(output))];
        });
        return flatMap13(write(newChunk), () => writer(newLast));
      },
      onFailure: failCause10,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(writer(none2()))));
  });
  var changesWithEffect = /* @__PURE__ */ dual(2, (self, f) => {
    const writer = (last4) => readWithCause({
      onInput: (input) => pipe(input, reduce10([last4, empty4()], ([option3, outputs], output) => {
        if (isSome2(option3)) {
          return pipe(f(option3.value, output), map16((bool) => bool ? [some2(output), outputs] : [some2(output), pipe(outputs, append2(output))]));
        }
        return succeed8([some2(output), pipe(outputs, append2(output))]);
      }), fromEffect4, flatMap13(([newLast, newChunk]) => pipe(write(newChunk), flatMap13(() => writer(newLast))))),
      onFailure: failCause10,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(writer(none2()))));
  });
  var chunks = (self) => pipe(self, mapChunks(of2));
  var chunksWith = /* @__PURE__ */ dual(2, (self, f) => flattenChunks(f(chunks(self))));
  var unsome = (effect4) => catchAll3(asSome2(effect4), (o) => o._tag === "None" ? succeedNone2 : fail9(o.value));
  var combine9 = /* @__PURE__ */ dual(4, (self, that, s, f) => {
    function producer(handoff, latch) {
      return fromEffect4(take6(latch)).pipe(zipRight4(readWithCause({
        onInput: (input) => flatMap13(fromEffect4(offer5(handoff, succeed3(input))), () => producer(handoff, latch)),
        onFailure: (cause3) => fromEffect4(offer5(handoff, failCause3(pipe(cause3, map12(some2))))),
        onDone: () => flatMap13(fromEffect4(offer5(handoff, fail4(none2()))), () => producer(handoff, latch))
      })));
    }
    return new StreamImpl(unwrapScopedWith((scope5) => all4([make49(), make49(), make49(), make49()]).pipe(tap3(([left3, _, latchL]) => toChannel2(self).pipe(concatMap(writeChunk), pipeTo(producer(left3, latchL)), runIn(scope5), forkIn2(scope5))), tap3(([, right3, _, rightL]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3, rightL)), runIn(scope5), forkIn2(scope5))), map16(([left3, right3, latchL, latchR]) => {
      const pullLeft = offer5(latchL, undefined).pipe(zipRight3(take6(left3).pipe(flatMap11(identity))));
      const pullRight = offer5(latchR, undefined).pipe(zipRight3(take6(right3).pipe(flatMap11(identity))));
      return toChannel2(unfoldEffect(s, (s2) => flatMap11(f(s2, pullLeft, pullRight), unsome)));
    }))));
  });
  var combineChunks = /* @__PURE__ */ dual(4, (self, that, s, f) => {
    const producer = (handoff, latch) => zipRight4(fromEffect4(take6(latch)), readWithCause({
      onInput: (input) => flatMap13(fromEffect4(pipe(handoff, offer5(chunk2(input)))), () => producer(handoff, latch)),
      onFailure: (cause3) => fromEffect4(offer5(handoff, failCause11(cause3))),
      onDone: () => fromEffect4(offer5(handoff, end4))
    }));
    return new StreamImpl(unwrapScopedWith((scope5) => all4([make49(), make49(), make49(), make49()]).pipe(tap3(([left3, _, latchL]) => pipeTo(toChannel2(self), producer(left3, latchL)).pipe(runIn(scope5), forkIn2(scope5))), tap3(([_, right3, __, latchR]) => pipeTo(toChannel2(that), producer(right3, latchR)).pipe(runIn(scope5), forkIn2(scope5))), map16(([left3, right3, latchL, latchR]) => {
      const pullLeft = offer5(latchL, undefined).pipe(zipRight3(take6(left3).pipe(flatMap11(done10))));
      const pullRight = offer5(latchR, undefined).pipe(zipRight3(take6(right3).pipe(flatMap11(done10))));
      return toChannel2(unfoldChunkEffect(s, (s2) => flatMap11(f(s2, pullLeft, pullRight), unsome)));
    }))));
  });
  var concat2 = /* @__PURE__ */ dual(2, (self, that) => new StreamImpl(pipe(toChannel2(self), zipRight4(toChannel2(that)))));
  var concatAll2 = (streams) => suspend9(() => pipe(streams, reduce2(empty29, (x, y) => concat2(y)(x))));
  var cross = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, a2) => [a, a2])));
  var crossLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, _) => a)));
  var crossRight = /* @__PURE__ */ dual(2, (left3, right3) => flatMap16(left3, () => right3));
  var crossWith = /* @__PURE__ */ dual(3, (left3, right3, f) => pipe(left3, flatMap16((a) => pipe(right3, map21((b) => f(a, b))))));
  var debounce = /* @__PURE__ */ dual(2, (self, duration2) => unwrapScopedWith3((scope5) => gen2(function* () {
    const handoff = yield* make49();
    function enqueue(last4) {
      return sleep2(duration2).pipe(as3(last4), forkIn2(scope5), map16((fiber) => consumer(previous(fiber))));
    }
    const producer = readWithCause({
      onInput: (input) => match2(last2(input), {
        onNone: () => producer,
        onSome: (elem) => fromEffect4(offer5(handoff, emit(of2(elem)))).pipe(flatMap13(() => producer))
      }),
      onFailure: (cause3) => fromEffect4(offer5(handoff, halt(cause3))),
      onDone: () => fromEffect4(offer5(handoff, end3(UpstreamEnd)))
    });
    function consumer(state) {
      switch (state._tag) {
        case OP_NOT_STARTED: {
          return unwrap(take6(handoff).pipe(map16((signal) => {
            switch (signal._tag) {
              case OP_EMIT4: {
                return unwrap(enqueue(signal.elements));
              }
              case OP_HALT: {
                return failCause10(signal.cause);
              }
              case OP_END: {
                return void_5;
              }
            }
          })));
        }
        case OP_PREVIOUS: {
          return unwrap(take6(handoff).pipe(forkIn2(scope5), flatMap11((handoffFiber) => raceWith2(join3(state.fiber), join3(handoffFiber), {
            onSelfDone: (leftExit, current2) => match6(leftExit, {
              onFailure: (cause3) => interrupt6(current2).pipe(as3(failCause10(cause3))),
              onSuccess: (chunk3) => interrupt6(current2).pipe(zipRight3(succeed8(write(chunk3).pipe(flatMap13(() => consumer(current(handoffFiber)))))))
            }),
            onOtherDone: (rightExit, previous2) => match6(rightExit, {
              onFailure: (cause3) => interrupt6(previous2).pipe(as3(failCause10(cause3))),
              onSuccess: (signal) => {
                switch (signal._tag) {
                  case OP_EMIT4: {
                    return interrupt6(previous2).pipe(zipRight3(enqueue(signal.elements)));
                  }
                  case OP_HALT: {
                    return interrupt6(previous2).pipe(as3(failCause10(signal.cause)));
                  }
                  case OP_END: {
                    return join3(previous2).pipe(map16((chunk3) => write(chunk3).pipe(zipRight4(void_5))));
                  }
                }
              }
            })
          }))));
        }
        case OP_CURRENT: {
          return unwrap(join3(state.fiber).pipe(map16((signal) => {
            switch (signal._tag) {
              case OP_EMIT4: {
                return unwrap(enqueue(signal.elements));
              }
              case OP_HALT: {
                return failCause10(signal.cause);
              }
              case OP_END: {
                return void_5;
              }
            }
          })));
        }
      }
    }
    return scopedWith4((scope6) => pipeTo(toChannel2(self), producer).pipe(runIn(scope6), forkIn2(scope6))).pipe(crossRight(new StreamImpl(consumer(notStarted))));
  })));
  var die10 = (defect) => fromEffect7(die6(defect));
  var dieSync6 = (evaluate2) => fromEffect7(dieSync3(evaluate2));
  var dieMessage4 = (message) => fromEffect7(dieMessage2(message));
  var distributedWith = /* @__PURE__ */ dual(2, (self, options) => pipe(make18(), flatMap11((deferred) => pipe(self, distributedWithDynamic({
    maximumLag: options.maximumLag,
    decide: (a) => flatMap11(_await(deferred), (f) => f(a))
  }), flatMap11((next) => pipe(all4(map4(range(0, options.size - 1), (id2) => map16(next, ([key, queue]) => [[key, id2], queue]))), map16(unsafeFromArray), flatMap11((entries2) => {
    const [mappings, queues] = reduceRight2(entries2, [new Map, empty4()], ([mappings2, queues2], [mapping, queue]) => [mappings2.set(mapping[0], mapping[1]), pipe(queues2, prepend2(queue))]);
    return pipe(succeed2(deferred, (a) => map16(options.decide(a), (f) => (key) => f(mappings.get(key)))), as3(Array.from(queues)));
  })))))));
  var distributedWithDynamicId = {
    ref: 0
  };
  var newDistributedWithDynamicId = () => {
    const current2 = distributedWithDynamicId.ref;
    distributedWithDynamicId.ref = current2 + 1;
    return current2;
  };
  var distributedWithDynamic = /* @__PURE__ */ dual(2, (self, options) => distributedWithDynamicCallback(self, options.maximumLag, options.decide, () => _void));
  var distributedWithDynamicCallback = /* @__PURE__ */ dual(4, (self, maximumLag, decide, done11) => pipe(acquireRelease2(make28(new Map), (ref, _) => pipe(get12(ref), flatMap11((queues) => pipe(queues.values(), forEach6(shutdown4))))), flatMap11((queuesRef) => gen2(function* () {
    const offer6 = (a) => pipe(decide(a), flatMap11((shouldProcess) => pipe(get12(queuesRef), flatMap11((queues) => pipe(queues.entries(), reduce10(empty4(), (acc, [id2, queue]) => {
      if (shouldProcess(id2)) {
        return pipe(offer3(queue, succeed3(a)), matchCauseEffect3({
          onFailure: (cause3) => isInterrupted2(cause3) ? succeed8(pipe(acc, prepend2(id2))) : failCause8(cause3),
          onSuccess: () => succeed8(acc)
        }));
      }
      return succeed8(acc);
    }), flatMap11((ids3) => {
      if (isNonEmpty2(ids3)) {
        return update3(queuesRef, (map21) => {
          for (const id2 of ids3) {
            map21.delete(id2);
          }
          return map21;
        });
      }
      return _void;
    }))))), asVoid3);
    const queuesLock = yield* makeSemaphore2(1);
    const newQueue = yield* make28(pipe(bounded5(maximumLag), flatMap11((queue) => {
      const id2 = newDistributedWithDynamicId();
      return pipe(update3(queuesRef, (map21) => map21.set(id2, queue)), as3([id2, queue]));
    })));
    const finalize = (endTake) => queuesLock.withPermits(1)(pipe(set6(newQueue, pipe(bounded5(1), tap3((queue) => offer3(queue, endTake)), flatMap11((queue) => {
      const id2 = newDistributedWithDynamicId();
      return pipe(update3(queuesRef, (map21) => map21.set(id2, queue)), as3(make3(id2, queue)));
    }))), zipRight3(pipe(get12(queuesRef), flatMap11((map21) => pipe(fromIterable2(map21.values()), forEach6((queue) => pipe(offer3(queue, endTake), catchSomeCause2((cause3) => isInterrupted2(cause3) ? some2(_void) : none2()))))))), zipRight3(done11(endTake)), asVoid3));
    yield* pipe(self, runForEachScoped(offer6), matchCauseEffect3({
      onFailure: (cause3) => finalize(failCause3(pipe(cause3, map12(some2)))),
      onSuccess: () => finalize(fail4(none2()))
    }), forkScoped2);
    return queuesLock.withPermits(1)(flatten9(get12(newQueue)));
  }))));
  var drain3 = (self) => new StreamImpl(drain(toChannel2(self)));
  var drainFork = /* @__PURE__ */ dual(2, (self, that) => fromEffect7(make18()).pipe(flatMap16((backgroundDied) => scopedWith4((scope5) => toChannel2(that).pipe(drain, runIn(scope5), catchAllCause3((cause3) => failCause2(backgroundDied, cause3)), forkIn2(scope5))).pipe(crossRight(interruptWhenDeferred2(self, backgroundDied))))));
  var drop3 = /* @__PURE__ */ dual(2, (self, n) => {
    const loop3 = (r) => readWith({
      onInput: (input) => {
        const dropped = pipe(input, drop2(r));
        const leftover = Math.max(0, r - input.length);
        const more = isEmpty(input) || leftover > 0;
        if (more) {
          return loop3(leftover);
        }
        return pipe(write(dropped), zipRight4(identityChannel()));
      },
      onFailure: fail11,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3(n))));
  });
  var dropRight = /* @__PURE__ */ dual(2, (self, n) => {
    if (n <= 0) {
      return identityStream();
    }
    return suspend9(() => {
      const queue = new RingBuffer(n);
      const reader = readWith({
        onInput: (input) => {
          const outputs = pipe(input, filterMap2((elem) => {
            const head6 = queue.head();
            queue.put(elem);
            return head6;
          }));
          return pipe(write(outputs), flatMap13(() => reader));
        },
        onFailure: fail11,
        onDone: () => void_5
      });
      return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(reader)));
    });
  });
  var dropUntil3 = /* @__PURE__ */ dual(2, (self, predicate) => drop3(dropWhile4(self, (a) => !predicate(a)), 1));
  var dropUntilEffect = /* @__PURE__ */ dual(2, (self, predicate) => {
    const loop3 = readWith({
      onInput: (input) => pipe(dropUntil2(input, predicate), map16(unsafeFromArray), map16((leftover) => {
        const more = isEmpty(leftover);
        if (more) {
          return suspend5(() => loop3);
        }
        return pipe(write(leftover), zipRight4(identityChannel()));
      }), unwrap),
      onFailure: fail11,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3)));
  });
  var dropWhile4 = /* @__PURE__ */ dual(2, (self, predicate) => {
    const loop3 = readWith({
      onInput: (input) => {
        const output = dropWhile(input, predicate);
        if (isEmpty(output)) {
          return suspend5(() => loop3);
        }
        return zipRight4(write(output), identityChannel());
      },
      onFailure: fail11,
      onDone: succeedNow
    });
    return new StreamImpl(pipeToOrFail(toChannel2(self), loop3));
  });
  var dropWhileEffect = /* @__PURE__ */ dual(2, (self, predicate) => {
    const loop3 = readWith({
      onInput: (input) => pipe(dropWhile3(input, predicate), map16(unsafeFromArray), map16((leftover) => {
        const more = isEmpty(leftover);
        if (more) {
          return suspend5(() => loop3);
        }
        return zipRight4(write(leftover), identityChannel());
      }), unwrap),
      onFailure: fail11,
      onDone: () => void_5
    });
    return new StreamImpl(pipeToOrFail(toChannel2(self), loop3));
  });
  var either5 = (self) => pipe(self, map21(right2), catchAll7((error) => make50(left2(error))));
  var empty29 = /* @__PURE__ */ new StreamImpl(void_5);
  var ensuring6 = /* @__PURE__ */ dual(2, (self, finalizer) => new StreamImpl(pipe(toChannel2(self), ensuring3(finalizer))));
  var ensuringWith2 = /* @__PURE__ */ dual(2, (self, finalizer) => new StreamImpl(ensuringWith(toChannel2(self), finalizer)));
  var context5 = () => fromEffect7(context3());
  var contextWith3 = (f) => pipe(context5(), map21(f));
  var contextWithEffect3 = (f) => pipe(context5(), mapEffectSequential(f));
  var contextWithStream = (f) => pipe(context5(), flatMap16(f));
  var execute = (effect4) => drain3(fromEffect7(effect4));
  var fail15 = (error) => fromEffectOption(fail9(some2(error)));
  var failSync7 = (evaluate2) => fromEffectOption(failSync3(() => some2(evaluate2())));
  var failCause13 = (cause3) => fromEffect7(failCause8(cause3));
  var failCauseSync6 = (evaluate2) => fromEffect7(failCauseSync3(evaluate2));
  var filter8 = /* @__PURE__ */ dual(2, (self, predicate) => mapChunks(self, filter2(predicate)));
  var filterEffect = /* @__PURE__ */ dual(2, (self, f) => {
    const loop3 = (iterator) => {
      const next = iterator.next();
      if (next.done) {
        return readWithCause({
          onInput: (input) => loop3(input[Symbol.iterator]()),
          onFailure: failCause10,
          onDone: succeed10
        });
      } else {
        return pipe(f(next.value), map16((bool) => bool ? pipe(write(of2(next.value)), flatMap13(() => loop3(iterator))) : loop3(iterator)), unwrap);
      }
    };
    return new StreamImpl(suspend5(() => pipe(toChannel2(self), pipeTo(loop3(empty4()[Symbol.iterator]())))));
  });
  var filterMap6 = /* @__PURE__ */ dual(2, (self, pf) => mapChunks(self, filterMap2(pf)));
  var filterMapEffect = /* @__PURE__ */ dual(2, (self, pf) => suspend9(() => {
    const loop3 = (iterator) => {
      const next = iterator.next();
      if (next.done) {
        return readWithCause({
          onInput: (input) => loop3(input[Symbol.iterator]()),
          onFailure: failCause10,
          onDone: succeed10
        });
      } else {
        return pipe(pf(next.value), match2({
          onNone: () => sync3(() => loop3(iterator)),
          onSome: map16((a2) => flatMap13(write(of2(a2)), () => loop3(iterator)))
        }), unwrap);
      }
    };
    return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3(empty4()[Symbol.iterator]()))));
  }));
  var filterMapWhile3 = /* @__PURE__ */ dual(2, (self, pf) => {
    const loop3 = readWith({
      onInput: (input) => {
        const mapped = filterMapWhile2(input, pf);
        if (mapped.length === input.length) {
          return pipe(write(mapped), flatMap13(() => loop3));
        }
        return write(mapped);
      },
      onFailure: fail11,
      onDone: succeed10
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3)));
  });
  var filterMapWhileEffect = /* @__PURE__ */ dual(2, (self, pf) => suspend9(() => {
    const loop3 = (iterator) => {
      const next = iterator.next();
      if (next.done) {
        return readWithCause({
          onInput: (input) => loop3(input[Symbol.iterator]()),
          onFailure: failCause10,
          onDone: succeed10
        });
      } else {
        return unwrap(match2(pf(next.value), {
          onNone: () => succeed8(void_5),
          onSome: map16((a2) => flatMap13(write(of2(a2)), () => loop3(iterator)))
        }));
      }
    };
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3(empty4()[Symbol.iterator]()))));
  }));
  var finalizer = (finalizer2) => acquireRelease3(_void, () => finalizer2);
  var find2 = /* @__PURE__ */ dual(2, (self, predicate) => {
    const loop3 = readWith({
      onInput: (input) => match2(findFirst3(input, predicate), {
        onNone: () => loop3,
        onSome: (n) => write(of2(n))
      }),
      onFailure: fail11,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3)));
  });
  var findEffect = /* @__PURE__ */ dual(2, (self, predicate) => {
    const loop3 = readWith({
      onInput: (input) => pipe(findFirst6(input, predicate), map16(match2({
        onNone: () => loop3,
        onSome: (n) => write(of2(n))
      })), unwrap),
      onFailure: fail11,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3)));
  });
  var flatMap16 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, f, options) => {
    const bufferSize = options?.bufferSize ?? 16;
    if (options?.switch) {
      return matchConcurrency(options?.concurrency, () => flatMapParSwitchBuffer(self, 1, bufferSize, f), (n) => flatMapParSwitchBuffer(self, n, bufferSize, f));
    }
    return matchConcurrency(options?.concurrency, () => new StreamImpl(concatMap(toChannel2(self), (as8) => pipe(as8, map4((a) => toChannel2(f(a))), reduce2(void_5, (left3, right3) => pipe(left3, zipRight4(right3)))))), (_) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), options))));
  });
  var matchConcurrency = (concurrency, sequential4, bounded8) => {
    switch (concurrency) {
      case undefined:
        return sequential4();
      case "unbounded":
        return bounded8(Number.MAX_SAFE_INTEGER);
      default:
        return concurrency > 1 ? bounded8(concurrency) : sequential4();
    }
  };
  var flatMapParSwitchBuffer = /* @__PURE__ */ dual(4, (self, n, bufferSize, f) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), {
    concurrency: n,
    mergeStrategy: BufferSliding(),
    bufferSize
  }))));
  var flatten13 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options) => flatMap16(self, identity, options));
  var flattenChunks = (self) => {
    const flatten14 = readWithCause({
      onInput: (chunks2) => flatMap13(writeChunk(chunks2), () => flatten14),
      onFailure: failCause10,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(flatten14)));
  };
  var flattenEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options) => options?.unordered ? flatMap16(self, (a) => fromEffect7(a), {
    concurrency: options.concurrency
  }) : matchConcurrency(options?.concurrency, () => mapEffectSequential(self, identity), (n) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mapOutEffectPar(identity, n), mapOut(of2)))));
  var flattenExitOption = (self) => {
    const processChunk = (chunk3, cont) => {
      const [toEmit, rest] = pipe(chunk3, splitWhere((exit3) => !isSuccess(exit3)));
      const next = pipe(head2(rest), match2({
        onNone: () => cont,
        onSome: match6({
          onFailure: (cause3) => match2(flipCauseOption2(cause3), {
            onNone: () => void_5,
            onSome: failCause10
          }),
          onSuccess: () => void_5
        })
      }));
      return pipe(write(pipe(toEmit, filterMap2((exit3) => isSuccess(exit3) ? some2(exit3.value) : none2()))), flatMap13(() => next));
    };
    const process2 = readWithCause({
      onInput: (chunk3) => processChunk(chunk3, process2),
      onFailure: (cause3) => failCause10(cause3),
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(process2)));
  };
  var flattenIterables = (self) => pipe(self, map21(fromIterable2), flattenChunks);
  var flattenTake = (self) => flattenChunks(flattenExitOption(pipe(self, map21((take7) => take7.exit))));
  var forever5 = (self) => new StreamImpl(repeated(toChannel2(self)));
  var fromAsyncIterable = (iterable, onError3) => pipe(acquireRelease2(sync3(() => iterable[Symbol.asyncIterator]()), (iterator) => iterator.return ? promise2(async () => iterator.return()) : _void), map16((iterator) => repeatEffectOption(pipe(tryPromise2({
    try: async () => iterator.next(),
    catch: (reason) => some2(onError3(reason))
  }), flatMap11((result) => result.done ? fail9(none2()) : succeed8(result.value))))), unwrapScoped4);
  var fromChannel2 = (channel) => new StreamImpl(channel);
  var toChannel2 = (stream) => {
    if ("channel" in stream) {
      return stream.channel;
    } else if (isEffect2(stream)) {
      return toChannel2(fromEffect7(stream));
    } else {
      throw new TypeError(`Expected a Stream.`);
    }
  };
  var fromChunk = (chunk3) => new StreamImpl(isEmpty(chunk3) ? void_5 : write(chunk3));
  var fromChunkPubSub = (pubsub, options) => {
    if (options?.scoped) {
      const effect4 = map16(subscribe2(pubsub), fromChunkQueue);
      return options.shutdown ? map16(effect4, ensuring6(shutdown3(pubsub))) : effect4;
    }
    const stream = flatMap16(scoped5(subscribe2(pubsub)), fromChunkQueue);
    return options?.shutdown ? ensuring6(stream, shutdown3(pubsub)) : stream;
  };
  var fromChunkQueue = (queue, options) => pipe(take3(queue), catchAllCause3((cause3) => pipe(isShutdown3(queue), flatMap11((isShutdown7) => isShutdown7 && isInterrupted2(cause3) ? end5() : failCause12(cause3)))), repeatEffectChunkOption, options?.shutdown ? ensuring6(shutdown4(queue)) : identity);
  var fromChunks = (...chunks2) => pipe(fromIterable9(chunks2), flatMap16(fromChunk));
  var fromEffect7 = (effect4) => pipe(effect4, mapError3(some2), fromEffectOption);
  var fromEffectOption = (effect4) => new StreamImpl(unwrap(match12(effect4, {
    onFailure: match2({
      onNone: () => void_5,
      onSome: fail11
    }),
    onSuccess: (a) => write(of2(a))
  })));
  var fromPubSub = (pubsub, options) => {
    const maxChunkSize = options?.maxChunkSize ?? DefaultChunkSize;
    if (options?.scoped) {
      const effect4 = map16(subscribe2(pubsub), (queue) => fromQueue2(queue, {
        maxChunkSize,
        shutdown: true
      }));
      return options.shutdown ? map16(effect4, ensuring6(shutdown3(pubsub))) : effect4;
    }
    const stream = flatMap16(scoped5(subscribe2(pubsub)), (queue) => fromQueue2(queue, {
      maxChunkSize
    }));
    return options?.shutdown ? ensuring6(stream, shutdown3(pubsub)) : stream;
  };
  var fromTPubSub = (pubsub) => {
    return unwrapScoped4(map16(subscribeScoped2(pubsub), (queue) => fromTQueue(queue)));
  };
  var fromIterable9 = (iterable) => suspend9(() => isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]()));
  var fromIterableEffect = (effect4) => pipe(effect4, map16(fromIterable9), unwrap2);
  var fromIteratorSucceed = (iterator, maxChunkSize = DefaultChunkSize) => {
    return pipe(sync3(() => {
      let builder = [];
      const loop3 = (iterator2) => pipe(sync3(() => {
        let next = iterator2.next();
        if (maxChunkSize === 1) {
          if (next.done) {
            return void_5;
          }
          return pipe(write(of2(next.value)), flatMap13(() => loop3(iterator2)));
        }
        builder = [];
        let count3 = 0;
        while (next.done === false) {
          builder.push(next.value);
          count3 = count3 + 1;
          if (count3 >= maxChunkSize) {
            break;
          }
          next = iterator2.next();
        }
        if (count3 > 0) {
          return pipe(write(unsafeFromArray(builder)), flatMap13(() => loop3(iterator2)));
        }
        return void_5;
      }), unwrap);
      return new StreamImpl(loop3(iterator));
    }), unwrap2);
  };
  var fromPull2 = (effect4) => pipe(effect4, map16(repeatEffectChunkOption), unwrapScoped4);
  var fromQueue2 = (queue, options) => pipe(takeBetween2(queue, 1, options?.maxChunkSize ?? DefaultChunkSize), catchAllCause3((cause3) => pipe(isShutdown3(queue), flatMap11((isShutdown7) => isShutdown7 && isInterrupted2(cause3) ? end5() : failCause12(cause3)))), repeatEffectChunkOption, options?.shutdown ? ensuring6(shutdown4(queue)) : identity);
  var fromTQueue = (queue) => pipe(take5(queue), map16(of2), catchAllCause3((cause3) => pipe(isShutdown6(queue), flatMap11((isShutdown7) => isShutdown7 && isInterrupted2(cause3) ? end5() : failCause12(cause3)))), repeatEffectChunkOption);
  var fromSchedule = (schedule2) => pipe(driver2(schedule2), map16((driver3) => repeatEffectOption(driver3.next(undefined))), unwrap2);
  var fromReadableStream = (...args2) => {
    const evaluate2 = args2.length === 1 ? args2[0].evaluate : args2[0];
    const onError3 = args2.length === 1 ? args2[0].onError : args2[1];
    const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
    return unwrapScoped4(map16(acquireRelease2(sync3(() => evaluate2().getReader()), (reader) => releaseLockOnEnd ? sync3(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => repeatEffectOption(flatMap11(tryPromise2({
      try: () => reader.read(),
      catch: (reason) => some2(onError3(reason))
    }), ({
      done: done11,
      value
    }) => done11 ? fail9(none2()) : succeed8(value)))));
  };
  var fromReadableStreamByob = (...args2) => {
    const evaluate2 = args2.length === 1 ? args2[0].evaluate : args2[0];
    const onError3 = args2.length === 1 ? args2[0].onError : args2[1];
    const allocSize = (args2.length === 1 ? args2[0].bufferSize : args2[2]) ?? 4096;
    const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
    return unwrapScoped4(map16(acquireRelease2(sync3(() => evaluate2().getReader({
      mode: "byob"
    })), (reader) => releaseLockOnEnd ? sync3(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => catchAll7(forever5(readChunkStreamByobReader(reader, onError3, allocSize)), (error) => error === EOF ? empty29 : fail15(error))));
  };
  var EOF = /* @__PURE__ */ Symbol.for("effect/Stream/EOF");
  var readChunkStreamByobReader = (reader, onError3, size13) => {
    const buffer2 = new ArrayBuffer(size13);
    return paginateEffect(0, (offset) => flatMap11(tryPromise2({
      try: () => reader.read(new Uint8Array(buffer2, offset, buffer2.byteLength - offset)),
      catch: (reason) => onError3(reason)
    }), ({
      done: done11,
      value
    }) => {
      if (done11) {
        return fail9(EOF);
      }
      const newOffset = offset + value.byteLength;
      return succeed8([value, newOffset >= buffer2.byteLength ? none2() : some2(newOffset)]);
    }));
  };
  var groupAdjacentBy = /* @__PURE__ */ dual(2, (self, f) => {
    const groupAdjacentByChunk = (state, chunk3) => {
      if (isEmpty(chunk3)) {
        return [state, empty4()];
      }
      const builder = [];
      let from = 0;
      let until = 0;
      let key = undefined;
      let previousChunk = empty4();
      switch (state._tag) {
        case "Some": {
          const tuple = state.value;
          key = tuple[0];
          let loop3 = true;
          while (loop3 && until < chunk3.length) {
            const input = unsafeGet4(chunk3, until);
            const updatedKey = f(input);
            if (!equals(key, updatedKey)) {
              const previousChunk2 = tuple[1];
              const additionalChunk = unsafeFromArray(Array.from(chunk3).slice(from, until));
              const group = appendAll2(previousChunk2, additionalChunk);
              builder.push([key, group]);
              key = updatedKey;
              from = until;
              loop3 = false;
            }
            until = until + 1;
          }
          if (loop3) {
            previousChunk = tuple[1];
          }
          break;
        }
        case "None": {
          key = f(unsafeGet4(chunk3, until));
          until = until + 1;
          break;
        }
      }
      while (until < chunk3.length) {
        const input = unsafeGet4(chunk3, until);
        const updatedKey = f(input);
        if (!equals(key, updatedKey)) {
          builder.push([key, unsafeFromArray(Array.from(chunk3).slice(from, until))]);
          key = updatedKey;
          from = until;
        }
        until = until + 1;
      }
      const nonEmptyChunk = appendAll2(previousChunk, unsafeFromArray(Array.from(chunk3).slice(from, until)));
      const output = unsafeFromArray(builder);
      return [some2([key, nonEmptyChunk]), output];
    };
    const groupAdjacent = (state) => readWithCause({
      onInput: (input) => {
        const [updatedState, output] = groupAdjacentByChunk(state, input);
        return isEmpty(output) ? groupAdjacent(updatedState) : flatMap13(write(output), () => groupAdjacent(updatedState));
      },
      onFailure: (cause3) => match2(state, {
        onNone: () => failCause10(cause3),
        onSome: (output) => flatMap13(write(of2(output)), () => failCause10(cause3))
      }),
      onDone: (done11) => match2(state, {
        onNone: () => succeedNow(done11),
        onSome: (output) => flatMap13(write(of2(output)), () => succeedNow(done11))
      })
    });
    return new StreamImpl(pipeToOrFail(toChannel2(self), groupAdjacent(none2())));
  });
  var grouped = /* @__PURE__ */ dual(2, (self, chunkSize) => pipe(self, rechunk(chunkSize), chunks));
  var groupedWithin = /* @__PURE__ */ dual(3, (self, chunkSize, duration2) => aggregateWithin(self, collectAllN(chunkSize), spaced2(duration2)));
  var haltWhen = /* @__PURE__ */ dual(2, (self, effect4) => {
    const writer = (fiber) => pipe(poll4(fiber), map16(match2({
      onNone: () => readWith({
        onInput: (input) => flatMap13(write(input), () => writer(fiber)),
        onFailure: fail11,
        onDone: () => void_5
      }),
      onSome: match6({
        onFailure: failCause10,
        onSuccess: () => void_5
      })
    })), unwrap);
    return new StreamImpl(unwrapScopedWith((scope5) => effect4.pipe(forkIn2(scope5), map16((fiber) => toChannel2(self).pipe(pipeTo(writer(fiber)))))));
  });
  var haltAfter = /* @__PURE__ */ dual(2, (self, duration2) => pipe(self, haltWhen(sleep2(duration2))));
  var haltWhenDeferred = /* @__PURE__ */ dual(2, (self, deferred) => {
    const writer = pipe(poll(deferred), map16(match2({
      onNone: () => readWith({
        onInput: (input) => pipe(write(input), flatMap13(() => writer)),
        onFailure: fail11,
        onDone: () => void_5
      }),
      onSome: (effect4) => unwrap(match12(effect4, {
        onFailure: fail11,
        onSuccess: () => void_5
      }))
    })), unwrap);
    return new StreamImpl(pipe(toChannel2(self), pipeTo(writer)));
  });
  var identityStream = () => new StreamImpl(identityChannel());
  var interleave = /* @__PURE__ */ dual(2, (self, that) => pipe(self, interleaveWith(that, forever5(make50(true, false)))));
  var interleaveWith = /* @__PURE__ */ dual(3, (self, that, decider) => {
    const producer = (handoff) => readWithCause({
      onInput: (value) => flatMap13(fromEffect4(offer5(handoff, of5(value))), () => producer(handoff)),
      onFailure: (cause3) => fromEffect4(offer5(handoff, failCause11(cause3))),
      onDone: () => fromEffect4(offer5(handoff, end4))
    });
    return new StreamImpl(unwrapScopedWith((scope5) => pipe(make49(), zip5(make49()), tap3(([left3]) => toChannel2(self).pipe(concatMap(writeChunk), pipeTo(producer(left3)), runIn(scope5), forkIn2(scope5))), tap3(([_, right3]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3)), runIn(scope5), forkIn2(scope5))), map16(([left3, right3]) => {
      const process2 = (leftDone, rightDone) => readWithCause({
        onInput: (bool) => {
          if (bool && !leftDone) {
            return pipe(fromEffect4(take6(left3)), flatMap13(match17({
              onEnd: () => rightDone ? void_5 : process2(true, rightDone),
              onFailure: failCause10,
              onSuccess: (chunk3) => pipe(write(chunk3), flatMap13(() => process2(leftDone, rightDone)))
            })));
          }
          if (!bool && !rightDone) {
            return pipe(fromEffect4(take6(right3)), flatMap13(match17({
              onEnd: () => leftDone ? void_5 : process2(leftDone, true),
              onFailure: failCause10,
              onSuccess: (chunk3) => pipe(write(chunk3), flatMap13(() => process2(leftDone, rightDone)))
            })));
          }
          return process2(leftDone, rightDone);
        },
        onFailure: failCause10,
        onDone: () => void_5
      });
      return pipe(toChannel2(decider), concatMap(writeChunk), pipeTo(process2(false, false)));
    }))));
  });
  var intersperse = /* @__PURE__ */ dual(2, (self, element) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(suspend5(() => {
    const writer = (isFirst) => readWithCause({
      onInput: (chunk3) => {
        const builder = [];
        let flagResult = isFirst;
        for (const output of chunk3) {
          if (flagResult) {
            flagResult = false;
            builder.push(output);
          } else {
            builder.push(element);
            builder.push(output);
          }
        }
        return pipe(write(unsafeFromArray(builder)), flatMap13(() => writer(flagResult)));
      },
      onFailure: failCause10,
      onDone: () => void_5
    });
    return writer(true);
  })))));
  var intersperseAffixes = /* @__PURE__ */ dual(2, (self, {
    end: end6,
    middle,
    start: start3
  }) => pipe(make50(start3), concat2(pipe(self, intersperse(middle))), concat2(make50(end6))));
  var interruptAfter = /* @__PURE__ */ dual(2, (self, duration2) => pipe(self, interruptWhen2(sleep2(duration2))));
  var interruptWhen2 = /* @__PURE__ */ dual(2, (self, effect4) => new StreamImpl(pipe(toChannel2(self), interruptWhen(effect4))));
  var interruptWhenDeferred2 = /* @__PURE__ */ dual(2, (self, deferred) => new StreamImpl(pipe(toChannel2(self), interruptWhenDeferred(deferred))));
  var iterate3 = (value, next) => unfold3(value, (a) => some2([a, next(a)]));
  var make50 = (...as8) => fromIterable9(as8);
  var map21 = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapOut(map4(f)))));
  var mapAccum5 = /* @__PURE__ */ dual(3, (self, s, f) => {
    const accumulator = (s2) => readWith({
      onInput: (input) => {
        const [nextS, chunk3] = mapAccum2(input, s2, f);
        return flatMap13(write(chunk3), () => accumulator(nextS));
      },
      onFailure: fail11,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(accumulator(s))));
  });
  var mapAccumEffect = /* @__PURE__ */ dual(3, (self, s, f) => suspend9(() => {
    const accumulator = (s2) => readWith({
      onInput: (input) => pipe(suspend3(() => {
        const outputs = [];
        const emit2 = (output) => sync3(() => {
          outputs.push(output);
        });
        return pipe(input, reduce10(s2, (s3, a) => pipe(f(s3, a), flatMap11(([s4, a2]) => pipe(emit2(a2), as3(s4))))), match12({
          onFailure: (error) => {
            if (outputs.length !== 0) {
              return zipRight4(write(unsafeFromArray(outputs)), fail11(error));
            }
            return fail11(error);
          },
          onSuccess: (s3) => flatMap13(write(unsafeFromArray(outputs)), () => accumulator(s3))
        }));
      }), unwrap),
      onFailure: fail11,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(accumulator(s))));
  }));
  var mapBoth5 = /* @__PURE__ */ dual(2, (self, options) => pipe(self, mapError6(options.onFailure), map21(options.onSuccess)));
  var mapChunks = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapOut(f))));
  var mapChunksEffect = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapOutEffect(f))));
  var mapConcat = /* @__PURE__ */ dual(2, (self, f) => pipe(self, mapConcatChunk((a) => fromIterable2(f(a)))));
  var mapConcatChunk = /* @__PURE__ */ dual(2, (self, f) => pipe(self, mapChunks(flatMap3(f))));
  var mapConcatChunkEffect = /* @__PURE__ */ dual(2, (self, f) => pipe(self, mapEffectSequential(f), mapConcatChunk(identity)));
  var mapConcatEffect = /* @__PURE__ */ dual(2, (self, f) => pipe(self, mapEffectSequential((a) => pipe(f(a), map16(fromIterable2))), mapConcatChunk(identity)));
  var mapEffectSequential = /* @__PURE__ */ dual(2, (self, f) => {
    const loop3 = (iterator) => {
      const next = iterator.next();
      if (next.done) {
        return readWithCause({
          onInput: (elem) => loop3(elem[Symbol.iterator]()),
          onFailure: failCause10,
          onDone: succeed10
        });
      } else {
        const value = next.value;
        return unwrap(map16(f(value), (a2) => flatMap13(write(of2(a2)), () => loop3(iterator))));
      }
    };
    return new StreamImpl(pipe(toChannel2(self), pipeTo(suspend5(() => loop3(empty4()[Symbol.iterator]())))));
  });
  var mapEffectPar = /* @__PURE__ */ dual(3, (self, n, f) => new StreamImpl(pipe(toChannel2(self), concatMap(writeChunk), mapOutEffectPar(f, n), mapOut(of2))));
  var mapError6 = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapError5(f))));
  var mapErrorCause4 = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), mapErrorCause3(f))));
  var merge9 = /* @__PURE__ */ dual((args2) => isStream(args2[1]), (self, that, options) => mergeWith3(self, that, {
    onSelf: identity,
    onOther: identity,
    haltStrategy: options?.haltStrategy
  }));
  var mergeAll8 = /* @__PURE__ */ dual((args2) => (Symbol.iterator in args2[0]), (streams, options) => flatten13(fromIterable9(streams), options));
  var mergeWithTag = /* @__PURE__ */ dual(2, (streams, options) => {
    const keys3 = Object.keys(streams);
    const values3 = keys3.map((key) => streams[key].pipe(map21((value) => ({
      _tag: key,
      value
    }))));
    return mergeAll8(values3, options);
  });
  var mergeEither = /* @__PURE__ */ dual(2, (self, that) => mergeWith3(self, that, {
    onSelf: left2,
    onOther: right2
  }));
  var mergeLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, merge9(drain3(right3))));
  var mergeRight = /* @__PURE__ */ dual(2, (left3, right3) => pipe(drain3(left3), merge9(right3)));
  var mergeWith3 = /* @__PURE__ */ dual(3, (self, other, options) => {
    const strategy = options.haltStrategy ? fromInput2(options.haltStrategy) : Both2;
    const handler = (terminate) => (exit3) => terminate || !isSuccess(exit3) ? Done4(suspend3(() => exit3)) : Await2((exit4) => suspend3(() => exit4));
    return new StreamImpl(mergeWith2(toChannel2(map21(self, options.onSelf)), {
      other: toChannel2(map21(other, options.onOther)),
      onSelfDone: handler(strategy._tag === "Either" || strategy._tag === "Left"),
      onOtherDone: handler(strategy._tag === "Either" || strategy._tag === "Right")
    }));
  });
  var mkString2 = (self) => run3(self, mkString);
  var never4 = /* @__PURE__ */ fromEffect7(never3);
  var onEnd = /* @__PURE__ */ dual(2, (self, effect4) => concat2(self, drain3(fromEffect7(effect4))));
  var onError3 = /* @__PURE__ */ dual(2, (self, cleanup) => pipe(self, catchAllCause6((cause3) => fromEffect7(pipe(cleanup(cause3), zipRight3(failCause8(cause3)))))));
  var onDone = /* @__PURE__ */ dual(2, (self, cleanup) => new StreamImpl(pipe(toChannel2(self), ensuringWith((exit3) => isSuccess(exit3) ? cleanup() : _void))));
  var onStart = /* @__PURE__ */ dual(2, (self, effect4) => unwrap2(as3(effect4, self)));
  var orDie5 = (self) => pipe(self, orDieWith4(identity));
  var orDieWith4 = /* @__PURE__ */ dual(2, (self, f) => new StreamImpl(pipe(toChannel2(self), orDieWith3(f))));
  var orElse8 = /* @__PURE__ */ dual(2, (self, that) => new StreamImpl(pipe(toChannel2(self), orElse7(() => toChannel2(that())))));
  var orElseEither3 = /* @__PURE__ */ dual(2, (self, that) => pipe(self, map21(left2), orElse8(() => pipe(that(), map21(right2)))));
  var orElseFail3 = /* @__PURE__ */ dual(2, (self, error) => pipe(self, orElse8(() => failSync7(error))));
  var orElseIfEmpty = /* @__PURE__ */ dual(2, (self, element) => pipe(self, orElseIfEmptyChunk(() => of2(element()))));
  var orElseIfEmptyChunk = /* @__PURE__ */ dual(2, (self, chunk3) => pipe(self, orElseIfEmptyStream(() => new StreamImpl(write(chunk3())))));
  var orElseIfEmptyStream = /* @__PURE__ */ dual(2, (self, stream) => {
    const writer = readWith({
      onInput: (input) => {
        if (isEmpty(input)) {
          return suspend5(() => writer);
        }
        return pipe(write(input), zipRight4(identityChannel()));
      },
      onFailure: fail11,
      onDone: () => suspend5(() => toChannel2(stream()))
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(writer)));
  });
  var orElseSucceed3 = /* @__PURE__ */ dual(2, (self, value) => pipe(self, orElse8(() => sync8(value))));
  var paginate = (s, f) => paginateChunk(s, (s2) => {
    const page = f(s2);
    return [of2(page[0]), page[1]];
  });
  var paginateChunk = (s, f) => {
    const loop3 = (s2) => {
      const page = f(s2);
      return match2(page[1], {
        onNone: () => zipRight4(write(page[0]), void_5),
        onSome: (s3) => flatMap13(write(page[0]), () => loop3(s3))
      });
    };
    return new StreamImpl(suspend5(() => loop3(s)));
  };
  var paginateChunkEffect = (s, f) => {
    const loop3 = (s2) => unwrap(map16(f(s2), ([chunk3, option3]) => match2(option3, {
      onNone: () => zipRight4(write(chunk3), void_5),
      onSome: (s3) => flatMap13(write(chunk3), () => loop3(s3))
    })));
    return new StreamImpl(suspend5(() => loop3(s)));
  };
  var paginateEffect = (s, f) => paginateChunkEffect(s, (s2) => pipe(f(s2), map16(([a, s3]) => [of2(a), s3])));
  var peel = /* @__PURE__ */ dual(2, (self, sink) => {
    const OP_EMIT5 = "Emit";
    const OP_HALT2 = "Halt";
    const OP_END2 = "End";
    return pipe(make18(), flatMap11((deferred) => pipe(make49(), map16((handoff) => {
      const consumer = foldSink(collectLeftover(sink), {
        onFailure: (error) => zipRight5(fromEffect6(fail3(deferred, error)), fail12(error)),
        onSuccess: ([z, leftovers]) => {
          const loop3 = readWithCause({
            onInput: (elements) => flatMap13(fromEffect4(offer5(handoff, {
              _tag: OP_EMIT5,
              elements
            })), () => loop3),
            onFailure: (cause3) => zipRight4(fromEffect4(offer5(handoff, {
              _tag: OP_HALT2,
              cause: cause3
            })), failCause10(cause3)),
            onDone: (_) => zipRight4(fromEffect4(offer5(handoff, {
              _tag: OP_END2
            })), void_5)
          });
          return fromChannel(pipe(fromEffect4(succeed2(deferred, z)), zipRight4(fromEffect4(pipe(handoff, offer5({
            _tag: OP_EMIT5,
            elements: leftovers
          })))), zipRight4(loop3)));
        }
      });
      const producer = pipe(take6(handoff), map16((signal) => {
        switch (signal._tag) {
          case OP_EMIT5: {
            return pipe(write(signal.elements), flatMap13(() => producer));
          }
          case OP_HALT2: {
            return failCause10(signal.cause);
          }
          case OP_END2: {
            return void_5;
          }
        }
      }), unwrap);
      return pipe(self, tapErrorCause5((cause3) => failCause2(deferred, cause3)), run3(consumer), forkScoped2, zipRight3(_await(deferred)), map16((z) => [z, new StreamImpl(producer)]));
    }))), flatten9);
  });
  var partition5 = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self, predicate, options) => partitionEither(self, (a) => succeed8(predicate(a) ? right2(a) : left2(a)), options));
  var partitionEither = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self, predicate, options) => pipe(mapEffectSequential(self, predicate), distributedWith({
    size: 2,
    maximumLag: options?.bufferSize ?? 16,
    decide: match({
      onLeft: () => succeed8((n) => n === 0),
      onRight: () => succeed8((n) => n === 1)
    })
  }), flatMap11(([queue1, queue2]) => succeed8([filterMap6(flattenExitOption(fromQueue2(queue1, {
    shutdown: true
  })), (_) => match(_, {
    onLeft: some2,
    onRight: none2
  })), filterMap6(flattenExitOption(fromQueue2(queue2, {
    shutdown: true
  })), (_) => match(_, {
    onLeft: none2,
    onRight: some2
  }))]))));
  var pipeThrough = /* @__PURE__ */ dual(2, (self, sink) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(toChannel(sink)))));
  var pipeThroughChannel = /* @__PURE__ */ dual(2, (self, channel) => new StreamImpl(pipeTo(toChannel2(self), channel)));
  var pipeThroughChannelOrFail = /* @__PURE__ */ dual(2, (self, chan) => new StreamImpl(pipe(toChannel2(self), pipeToOrFail(chan))));
  var prepend4 = /* @__PURE__ */ dual(2, (self, values3) => new StreamImpl(zipRight4(write(values3), toChannel2(self))));
  var provideContext5 = /* @__PURE__ */ dual(2, (self, context6) => new StreamImpl(pipe(toChannel2(self), provideContext3(context6))));
  var provideSomeContext2 = /* @__PURE__ */ dual(2, (self, context6) => mapInputContext5(self, merge3(context6)));
  var provideLayer = /* @__PURE__ */ dual(2, (self, layer) => new StreamImpl(unwrapScopedWith((scope5) => buildWithScope2(layer, scope5).pipe(map16((env) => pipe(toChannel2(self), provideContext3(env)))))));
  var provideService5 = /* @__PURE__ */ dual(3, (self, tag, resource) => provideServiceEffect3(self, tag, succeed8(resource)));
  var provideServiceEffect3 = /* @__PURE__ */ dual(3, (self, tag, effect4) => provideServiceStream(self, tag, fromEffect7(effect4)));
  var provideServiceStream = /* @__PURE__ */ dual(3, (self, tag, stream) => contextWithStream((env) => flatMap16(stream, (service3) => pipe(self, provideContext5(add2(env, tag, service3))))));
  var mapInputContext5 = /* @__PURE__ */ dual(2, (self, f) => contextWithStream((env) => pipe(self, provideContext5(f(env)))));
  var provideSomeLayer2 = /* @__PURE__ */ dual(2, (self, layer) => pipe(self, provideLayer(pipe(context4(), merge8(layer)))));
  var range2 = (min3, max5, chunkSize = DefaultChunkSize) => suspend9(() => {
    if (min3 > max5) {
      return empty29;
    }
    const go = (min4, max6, chunkSize2) => {
      const remaining = max6 - min4 + 1;
      if (remaining > chunkSize2) {
        return pipe(write(range(min4, min4 + chunkSize2 - 1)), flatMap13(() => go(min4 + chunkSize2, max6, chunkSize2)));
      }
      return write(range(min4, min4 + remaining - 1));
    };
    return new StreamImpl(go(min3, max5, chunkSize));
  });
  var race3 = /* @__PURE__ */ dual(2, (left3, right3) => raceAll3(left3, right3));
  var raceAll3 = (...streams) => make18().pipe(map16((halt2) => {
    let winner = null;
    return mergeAll8(streams.map((stream, index) => stream.pipe(takeWhile4(() => {
      if (winner === null) {
        winner = index;
        unsafeDone(halt2, void_2);
        return true;
      }
      return winner === index;
    }), interruptWhen2(_await(halt2).pipe(flatMap11(() => winner === index ? never3 : _void))))), {
      concurrency: streams.length
    });
  }), unwrap2);
  var rechunk = /* @__PURE__ */ dual(2, (self, n) => suspend9(() => {
    const target = Math.max(n, 1);
    const process2 = rechunkProcess(new StreamRechunker(target), target);
    return new StreamImpl(pipe(toChannel2(self), pipeTo(process2)));
  }));
  var rechunkProcess = (rechunker, target) => readWithCause({
    onInput: (chunk3) => {
      if (chunk3.length === target && rechunker.isEmpty()) {
        return flatMap13(write(chunk3), () => rechunkProcess(rechunker, target));
      }
      if (chunk3.length > 0) {
        const chunks2 = [];
        let result = undefined;
        let index = 0;
        while (index < chunk3.length) {
          while (index < chunk3.length && result === undefined) {
            result = rechunker.write(pipe(chunk3, unsafeGet4(index)));
            index = index + 1;
          }
          if (result !== undefined) {
            chunks2.push(result);
            result = undefined;
          }
        }
        return flatMap13(writeAll(...chunks2), () => rechunkProcess(rechunker, target));
      }
      return suspend5(() => rechunkProcess(rechunker, target));
    },
    onFailure: (cause3) => zipRight4(rechunker.emitIfNotEmpty(), failCause10(cause3)),
    onDone: () => rechunker.emitIfNotEmpty()
  });

  class StreamRechunker {
    n;
    builder = [];
    pos = 0;
    constructor(n) {
      this.n = n;
    }
    isEmpty() {
      return this.pos === 0;
    }
    write(elem) {
      this.builder.push(elem);
      this.pos += 1;
      if (this.pos === this.n) {
        const result = unsafeFromArray(this.builder);
        this.builder = [];
        this.pos = 0;
        return result;
      }
      return;
    }
    emitIfNotEmpty() {
      if (this.pos !== 0) {
        return write(unsafeFromArray(this.builder));
      }
      return void_5;
    }
  }
  var refineOrDie = /* @__PURE__ */ dual(2, (self, pf) => pipe(self, refineOrDieWith(pf, identity)));
  var refineOrDieWith = /* @__PURE__ */ dual(3, (self, pf, f) => new StreamImpl(catchAll5(toChannel2(self), (error) => match2(pf(error), {
    onNone: () => failCause10(die4(f(error))),
    onSome: fail11
  }))));
  var repeat2 = /* @__PURE__ */ dual(2, (self, schedule2) => filterMap6(repeatEither(self, schedule2), (_) => match(_, {
    onLeft: none2,
    onRight: some2
  })));
  var repeatEffect = (effect4) => repeatEffectOption(pipe(effect4, mapError3(some2)));
  var repeatEffectChunk = (effect4) => repeatEffectChunkOption(pipe(effect4, mapError3(some2)));
  var repeatEffectChunkOption = (effect4) => unfoldChunkEffect(effect4, (effect5) => pipe(map16(effect5, (chunk3) => some2([chunk3, effect5])), catchAll3(match2({
    onNone: () => succeed8(none2()),
    onSome: fail9
  }))));
  var repeatEffectOption = (effect4) => repeatEffectChunkOption(pipe(effect4, map16(of2)));
  var repeatEither = /* @__PURE__ */ dual(2, (self, schedule2) => repeatWith(self, schedule2, {
    onElement: (a) => right2(a),
    onSchedule: left2
  }));
  var repeatElements = /* @__PURE__ */ dual(2, (self, schedule2) => filterMap6(repeatElementsWith(self, schedule2, {
    onElement: (a) => some2(a),
    onSchedule: none2
  }), identity));
  var repeatElementsWith = /* @__PURE__ */ dual(3, (self, schedule2, options) => {
    const driver3 = pipe(driver2(schedule2), map16((driver4) => {
      const feed = (input) => match2(head2(input), {
        onNone: () => loop3,
        onSome: (a) => zipRight4(write(of2(options.onElement(a))), step4(pipe(input, drop2(1)), a))
      });
      const step4 = (input, a) => {
        const advance = pipe(driver4.next(a), as3(pipe(write(of2(options.onElement(a))), flatMap13(() => step4(input, a)))));
        const reset = pipe(driver4.last, orDie3, flatMap11((b) => pipe(driver4.reset, map16(() => pipe(write(of2(options.onSchedule(b))), zipRight4(feed(input)))))));
        return pipe(advance, orElse5(() => reset), unwrap);
      };
      const loop3 = readWith({
        onInput: feed,
        onFailure: fail11,
        onDone: () => void_5
      });
      return loop3;
    }), unwrap);
    return new StreamImpl(pipe(toChannel2(self), pipeTo(driver3)));
  });
  var repeatValue = (value) => new StreamImpl(repeated(write(of2(value))));
  var repeatWith = /* @__PURE__ */ dual(3, (self, schedule2, options) => {
    return pipe(driver2(schedule2), map16((driver3) => {
      const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get12(driver3.iterationMeta));
      const process2 = pipe(self, provideLastIterationInfo, map21(options.onElement), toChannel2);
      const loop3 = unwrap(match12(driver3.next(undefined), {
        onFailure: () => void_5,
        onSuccess: (output) => flatMap13(process2, () => zipRight4(write(of2(options.onSchedule(output))), loop3))
      }));
      return new StreamImpl(zipRight4(process2, loop3));
    }), unwrap2);
  });
  var repeatWithSchedule = (value, schedule2) => repeatEffectWithSchedule(succeed8(value), schedule2);
  var repeatEffectWithSchedule = (effect4, schedule2) => flatMap16(fromEffect7(zip5(effect4, driver2(schedule2))), ([a, driver3]) => {
    const provideLastIterationInfo = provideServiceEffect2(CurrentIterationMetadata2, get12(driver3.iterationMeta));
    return concat2(succeed14(a), unfoldEffect(a, (s) => matchEffect2(driver3.next(s), {
      onFailure: succeed8,
      onSuccess: () => map16(provideLastIterationInfo(effect4), (nextA) => some2([nextA, nextA]))
    })));
  });
  var retry6 = /* @__PURE__ */ dual(2, (self, policy) => driver2(policy).pipe(map16((driver3) => {
    const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get12(driver3.iterationMeta));
    const loop3 = toChannel2(provideLastIterationInfo(self)).pipe(mapOutEffect((out) => as3(driver3.reset, out)), catchAll5((error) => driver3.next(error).pipe(match12({
      onFailure: () => fail11(error),
      onSuccess: () => loop3
    }), unwrap)));
    return loop3;
  }), unwrap, fromChannel2));
  var withExecutionPlan3 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, policy, options) => suspend9(() => {
    const preventFallbackOnPartialStream = options?.preventFallbackOnPartialStream ?? false;
    let i = 0;
    let lastError = none2();
    const loop3 = suspend9(() => {
      const step4 = policy.steps[i++];
      if (!step4) {
        return fail15(getOrThrow2(lastError));
      }
      let nextStream = isContext2(step4.provide) ? provideSomeContext2(self, step4.provide) : provideSomeLayer2(self, step4.provide);
      let receivedElements = false;
      if (isSome2(lastError)) {
        const error = lastError.value;
        let attempted = false;
        const wrapped = nextStream;
        nextStream = suspend9(() => {
          if (attempted)
            return wrapped;
          attempted = true;
          return fail15(error);
        });
        nextStream = scheduleDefectRefail2(retry6(nextStream, scheduleFromStep(step4, false)));
      } else {
        const schedule2 = scheduleFromStep(step4, true);
        nextStream = schedule2 ? scheduleDefectRefail2(retry6(nextStream, schedule2)) : nextStream;
      }
      return catchAll7(preventFallbackOnPartialStream ? mapChunks(nextStream, (chunk3) => {
        receivedElements = true;
        return chunk3;
      }) : nextStream, (error) => {
        if (preventFallbackOnPartialStream && receivedElements) {
          return fail15(error);
        }
        lastError = some2(error);
        return loop3;
      });
    });
    return loop3;
  }));
  var scheduleDefectRefail2 = (self) => catchAllCause6(self, (cause3) => failCause13(scheduleDefectRefailCause(cause3)));
  var run3 = /* @__PURE__ */ dual(2, (self, sink) => toChannel2(self).pipe(pipeToOrFail(toChannel(sink)), runDrain));
  var runCollect = (self) => run3(self, collectAll());
  var runCount = (self) => run3(self, count);
  var runDrain2 = (self) => run3(self, drain2);
  var runFold = /* @__PURE__ */ dual(3, (self, s, f) => runFoldWhile(self, s, constTrue, f));
  var runFoldEffect = /* @__PURE__ */ dual(3, (self, s, f) => runFoldWhileEffect(self, s, constTrue, f));
  var runFoldScoped = /* @__PURE__ */ dual(3, (self, s, f) => pipe(self, runFoldWhileScoped(s, constTrue, f)));
  var runFoldScopedEffect = /* @__PURE__ */ dual(3, (self, s, f) => pipe(self, runFoldWhileScopedEffect(s, constTrue, f)));
  var runFoldWhile = /* @__PURE__ */ dual(4, (self, s, cont, f) => run3(self, fold(s, cont, f)));
  var runFoldWhileEffect = /* @__PURE__ */ dual(4, (self, s, cont, f) => run3(self, foldEffect(s, cont, f)));
  var runFoldWhileScoped = /* @__PURE__ */ dual(4, (self, s, cont, f) => pipe(self, runScoped2(fold(s, cont, f))));
  var runFoldWhileScopedEffect = /* @__PURE__ */ dual(4, (self, s, cont, f) => pipe(self, runScoped2(foldEffect(s, cont, f))));
  var runForEach = /* @__PURE__ */ dual(2, (self, f) => run3(self, forEach7(f)));
  var runForEachChunk = /* @__PURE__ */ dual(2, (self, f) => run3(self, forEachChunk(f)));
  var runForEachChunkScoped = /* @__PURE__ */ dual(2, (self, f) => pipe(self, runScoped2(forEachChunk(f))));
  var runForEachScoped = /* @__PURE__ */ dual(2, (self, f) => pipe(self, runScoped2(forEach7(f))));
  var runForEachWhile = /* @__PURE__ */ dual(2, (self, f) => run3(self, forEachWhile(f)));
  var runForEachWhileScoped = /* @__PURE__ */ dual(2, (self, f) => pipe(self, runScoped2(forEachWhile(f))));
  var runHead = (self) => run3(self, head5());
  var runIntoPubSub = /* @__PURE__ */ dual(2, (self, pubsub) => pipe(self, runIntoQueue(pubsub)));
  var runIntoPubSubScoped = /* @__PURE__ */ dual(2, (self, pubsub) => pipe(self, runIntoQueueScoped(pubsub)));
  var runIntoQueue = /* @__PURE__ */ dual(2, (self, queue) => pipe(self, runIntoQueueScoped(queue), scoped2));
  var runIntoQueueElementsScoped = /* @__PURE__ */ dual(2, (self, queue) => {
    const writer = readWithCause({
      onInput: (input) => flatMap13(fromEffect4(offerAll3(queue, map4(input, succeed3))), () => writer),
      onFailure: (cause3) => fromEffect4(offer3(queue, failCause3(map12(cause3, some2)))),
      onDone: () => fromEffect4(offer3(queue, fail4(none2())))
    });
    return pipe(pipeTo(toChannel2(self), writer), drain, runScoped, asVoid3);
  });
  var runIntoQueueScoped = /* @__PURE__ */ dual(2, (self, queue) => {
    const writer = readWithCause({
      onInput: (input) => flatMap13(write(chunk2(input)), () => writer),
      onFailure: (cause3) => write(failCause11(cause3)),
      onDone: () => write(end4)
    });
    return pipe(pipeTo(toChannel2(self), writer), mapOutEffect((take7) => offer3(queue, take7)), drain, runScoped, asVoid3);
  });
  var runLast = (self) => run3(self, last3());
  var runScoped2 = /* @__PURE__ */ dual(2, (self, sink) => pipe(toChannel2(self), pipeToOrFail(toChannel(sink)), drain, runScoped));
  var runSum = (self) => run3(self, sum2);
  var scan = /* @__PURE__ */ dual(3, (self, s, f) => pipe(self, scanEffect(s, (s2, a) => succeed8(f(s2, a)))));
  var scanReduce = /* @__PURE__ */ dual(2, (self, f) => pipe(self, scanReduceEffect((a2, a) => succeed8(f(a2, a)))));
  var scanReduceEffect = /* @__PURE__ */ dual(2, (self, f) => pipe(self, mapAccumEffect(none2(), (option3, a) => {
    switch (option3._tag) {
      case "None": {
        return succeed8([some2(a), a]);
      }
      case "Some": {
        return pipe(f(option3.value, a), map16((b) => [some2(b), b]));
      }
    }
  })));
  var schedule2 = /* @__PURE__ */ dual(2, (self, schedule3) => filterMap6(scheduleWith(self, schedule3, {
    onElement: some2,
    onSchedule: none2
  }), identity));
  var scheduleWith = /* @__PURE__ */ dual(3, (self, schedule3, options) => {
    const loop3 = (driver3, iterator) => {
      const next = iterator.next();
      if (next.done) {
        return readWithCause({
          onInput: (chunk3) => loop3(driver3, chunk3[Symbol.iterator]()),
          onFailure: failCause10,
          onDone: succeedNow
        });
      }
      return unwrap(matchEffect2(driver3.next(next.value), {
        onFailure: () => pipe(driver3.last, orDie3, map16((b) => pipe(write(make6(options.onElement(next.value), options.onSchedule(b))), flatMap13(() => loop3(driver3, iterator)))), zipLeft2(driver3.reset)),
        onSuccess: () => succeed8(pipe(write(of2(options.onElement(next.value))), flatMap13(() => loop3(driver3, iterator))))
      }));
    };
    return new StreamImpl(pipe(fromEffect4(driver2(schedule3)), flatMap13((driver3) => pipe(toChannel2(self), pipeTo(loop3(driver3, empty4()[Symbol.iterator]()))))));
  });
  var scanEffect = /* @__PURE__ */ dual(3, (self, s, f) => new StreamImpl(pipe(write(of2(s)), flatMap13(() => toChannel2(pipe(self, mapAccumEffect(s, (s2, a) => pipe(f(s2, a), map16((s3) => [s3, s3])))))))));
  var scoped5 = (effect4) => new StreamImpl(ensuring3(scoped4(pipe(effect4, map16(of2))), _void));
  var scopedWith4 = (f) => new StreamImpl(scopedWith3((scope5) => f(scope5).pipe(map16(of2))));
  var some5 = (self) => pipe(self, mapError6(some2), someOrFail(() => none2()));
  var someOrElse = /* @__PURE__ */ dual(2, (self, fallback) => pipe(self, map21(getOrElse(fallback))));
  var someOrFail = /* @__PURE__ */ dual(2, (self, error) => mapEffectSequential(self, match2({
    onNone: () => failSync3(error),
    onSome: succeed8
  })));
  var sliding7 = /* @__PURE__ */ dual(2, (self, chunkSize) => slidingSize(self, chunkSize, 1));
  var slidingSize = /* @__PURE__ */ dual(3, (self, chunkSize, stepSize) => {
    if (chunkSize <= 0 || stepSize <= 0) {
      return die10(new IllegalArgumentException2("Invalid bounds - `chunkSize` and `stepSize` must be greater than zero"));
    }
    return new StreamImpl(suspend5(() => {
      const queue = new RingBuffer(chunkSize);
      const emitOnStreamEnd = (queueSize, channelEnd) => {
        if (queueSize < chunkSize) {
          const items = queue.toChunk();
          const result2 = isEmpty(items) ? empty4() : of2(items);
          return pipe(write(result2), flatMap13(() => channelEnd));
        }
        const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;
        if (lastEmitIndex === queueSize) {
          return channelEnd;
        }
        const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);
        const lastItems = pipe(queue.toChunk(), takeRight(leftovers));
        const result = isEmpty(lastItems) ? empty4() : of2(lastItems);
        return pipe(write(result), flatMap13(() => channelEnd));
      };
      const reader = (queueSize) => readWithCause({
        onInput: (input) => flatMap13(write(filterMap2(input, (element, index) => {
          queue.put(element);
          const currentIndex = queueSize + index + 1;
          if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {
            return none2();
          }
          return some2(queue.toChunk());
        })), () => reader(queueSize + input.length)),
        onFailure: (cause3) => emitOnStreamEnd(queueSize, failCause10(cause3)),
        onDone: () => emitOnStreamEnd(queueSize, void_5)
      });
      return pipe(toChannel2(self), pipeTo(reader(0)));
    }));
  });
  var split = /* @__PURE__ */ dual(2, (self, predicate) => {
    const split2 = (leftovers, input) => {
      const [chunk3, remaining] = pipe(leftovers, appendAll2(input), splitWhere(predicate));
      if (isEmpty(chunk3) || isEmpty(remaining)) {
        return loop3(pipe(chunk3, appendAll2(pipe(remaining, drop2(1)))));
      }
      return pipe(write(of2(chunk3)), flatMap13(() => split2(empty4(), pipe(remaining, drop2(1)))));
    };
    const loop3 = (leftovers) => readWith({
      onInput: (input) => split2(leftovers, input),
      onFailure: fail11,
      onDone: () => {
        if (isEmpty(leftovers)) {
          return void_5;
        }
        if (isNone2(pipe(leftovers, findFirst3(predicate)))) {
          return zipRight4(write(of2(leftovers)), void_5);
        }
        return zipRight4(split2(empty4(), leftovers), void_5);
      }
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3(empty4()))));
  });
  var splitOnChunk = /* @__PURE__ */ dual(2, (self, delimiter) => {
    const next = (leftover, delimiterIndex) => readWithCause({
      onInput: (inputChunk) => {
        let buffer2;
        const [carry, delimiterCursor] = pipe(inputChunk, reduce2([pipe(leftover, getOrElse(() => empty4())), delimiterIndex], ([carry2, delimiterCursor2], a) => {
          const concatenated = pipe(carry2, append2(a));
          if (delimiterCursor2 < delimiter.length && equals(a, pipe(delimiter, unsafeGet4(delimiterCursor2)))) {
            if (delimiterCursor2 + 1 === delimiter.length) {
              if (buffer2 === undefined) {
                buffer2 = [];
              }
              buffer2.push(pipe(concatenated, take(concatenated.length - delimiter.length)));
              return [empty4(), 0];
            }
            return [concatenated, delimiterCursor2 + 1];
          }
          return [concatenated, equals(a, pipe(delimiter, unsafeGet4(0))) ? 1 : 0];
        }));
        const output = buffer2 === undefined ? empty4() : unsafeFromArray(buffer2);
        return flatMap13(write(output), () => next(isNonEmpty2(carry) ? some2(carry) : none2(), delimiterCursor));
      },
      onFailure: (cause3) => match2(leftover, {
        onNone: () => failCause10(cause3),
        onSome: (chunk3) => zipRight4(write(of2(chunk3)), failCause10(cause3))
      }),
      onDone: (done11) => match2(leftover, {
        onNone: () => succeed10(done11),
        onSome: (chunk3) => zipRight4(write(of2(chunk3)), succeed10(done11))
      })
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(next(none2(), 0))));
  });
  var splitLines2 = (self) => pipeThroughChannel(self, splitLines());
  var succeed14 = (value) => fromChunk(of2(value));
  var sync8 = (evaluate2) => suspend9(() => fromChunk(of2(evaluate2())));
  var suspend9 = (stream) => new StreamImpl(suspend5(() => toChannel2(stream())));
  var take7 = /* @__PURE__ */ dual(2, (self, n) => {
    if (!Number.isInteger(n)) {
      return die10(new IllegalArgumentException2(`${n} must be an integer`));
    }
    const loop3 = (n2) => readWith({
      onInput: (input) => {
        const taken = pipe(input, take(Math.min(n2, Number.POSITIVE_INFINITY)));
        const leftover = Math.max(0, n2 - taken.length);
        const more = leftover > 0;
        if (more) {
          return pipe(write(taken), flatMap13(() => loop3(leftover)));
        }
        return write(taken);
      },
      onFailure: fail11,
      onDone: succeed10
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(0 < n ? loop3(n) : void_5)));
  });
  var takeRight2 = /* @__PURE__ */ dual(2, (self, n) => {
    if (n <= 0) {
      return empty29;
    }
    return new StreamImpl(pipe(succeed8(new RingBuffer(n)), map16((queue) => {
      const reader = readWith({
        onInput: (input) => {
          for (const element of input) {
            queue.put(element);
          }
          return reader;
        },
        onFailure: fail11,
        onDone: () => pipe(write(queue.toChunk()), zipRight4(void_5))
      });
      return pipe(toChannel2(self), pipeTo(reader));
    }), unwrap));
  });
  var takeUntil3 = /* @__PURE__ */ dual(2, (self, predicate) => {
    const loop3 = readWith({
      onInput: (input) => {
        const taken = pipe(input, takeWhile((a) => !predicate(a)));
        const last4 = pipe(input, drop2(taken.length), take(1));
        if (isEmpty(last4)) {
          return pipe(write(taken), flatMap13(() => loop3));
        }
        return write(pipe(taken, appendAll2(last4)));
      },
      onFailure: fail11,
      onDone: succeed10
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3)));
  });
  var takeUntilEffect = /* @__PURE__ */ dual(2, (self, predicate) => {
    const loop3 = (iterator) => {
      const next = iterator.next();
      if (next.done) {
        return readWithCause({
          onInput: (elem) => loop3(elem[Symbol.iterator]()),
          onFailure: failCause10,
          onDone: succeed10
        });
      }
      return pipe(predicate(next.value), map16((bool) => bool ? write(of2(next.value)) : pipe(write(of2(next.value)), flatMap13(() => loop3(iterator)))), unwrap);
    };
    return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3(empty4()[Symbol.iterator]()))));
  });
  var takeWhile4 = /* @__PURE__ */ dual(2, (self, predicate) => {
    const loop3 = readWith({
      onInput: (input) => {
        const taken = pipe(input, takeWhile(predicate));
        const more = taken.length === input.length;
        if (more) {
          return pipe(write(taken), flatMap13(() => loop3));
        }
        return write(taken);
      },
      onFailure: fail11,
      onDone: succeed10
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(loop3)));
  });
  var tap6 = /* @__PURE__ */ dual(2, (self, f) => mapEffectSequential(self, (a) => as3(f(a), a)));
  var tapBoth3 = /* @__PURE__ */ dual(2, (self, options) => pipe(self, tapError5(options.onFailure), tap6(options.onSuccess)));
  var tapError5 = /* @__PURE__ */ dual(2, (self, f) => catchAll7(self, (error) => fromEffect7(zipRight3(f(error), fail9(error)))));
  var tapErrorCause5 = /* @__PURE__ */ dual(2, (self, f) => {
    const loop3 = readWithCause({
      onInput: (chunk3) => flatMap13(write(chunk3), () => loop3),
      onFailure: (cause3) => fromEffect4(zipRight3(f(cause3), failCause8(cause3))),
      onDone: succeedNow
    });
    return new StreamImpl(pipe(toChannel2(self), pipeTo(loop3)));
  });
  var tapSink = /* @__PURE__ */ dual(2, (self, sink) => pipe(fromEffect7(all4([bounded5(1), make18()])), flatMap16(([queue, deferred]) => {
    const right3 = flattenTake(fromQueue2(queue, {
      maxChunkSize: 1
    }));
    const loop3 = readWithCause({
      onInput: (chunk3) => pipe(fromEffect4(offer3(queue, chunk2(chunk3))), foldCauseChannel({
        onFailure: () => flatMap13(write(chunk3), () => identityChannel()),
        onSuccess: () => flatMap13(write(chunk3), () => loop3)
      })),
      onFailure: (cause3) => pipe(fromEffect4(offer3(queue, failCause11(cause3))), foldCauseChannel({
        onFailure: () => failCause10(cause3),
        onSuccess: () => failCause10(cause3)
      })),
      onDone: () => pipe(fromEffect4(offer3(queue, end4)), foldCauseChannel({
        onFailure: () => void_5,
        onSuccess: () => void_5
      }))
    });
    return pipe(new StreamImpl(pipe(pipeTo(toChannel2(self), loop3), ensuring3(zipRight3(forkDaemon2(offer3(queue, end4)), _await(deferred))))), merge9(execute(pipe(run3(right3, sink), ensuring2(zipRight3(shutdown4(queue), succeed2(deferred, undefined)))))));
  })));
  var throttle = /* @__PURE__ */ dual(2, (self, options) => throttleEffect(self, {
    ...options,
    cost: (chunk3) => succeed8(options.cost(chunk3))
  }));
  var throttleEffect = /* @__PURE__ */ dual(2, (self, options) => {
    if (options.strategy === "enforce") {
      return throttleEnforceEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);
    }
    return throttleShapeEffect(self, options.cost, options.units, options.duration, options.burst ?? 0);
  });
  var throttleEnforceEffect = (self, cost, units, duration2, burst) => {
    const loop3 = (tokens, timestampMillis) => readWithCause({
      onInput: (input) => pipe(cost(input), zip5(currentTimeMillis2), map16(([weight, currentTimeMillis3]) => {
        const elapsed2 = currentTimeMillis3 - timestampMillis;
        const cycles = elapsed2 / toMillis(duration2);
        const sum3 = tokens + cycles * units;
        const max5 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
        const available = sum3 < 0 ? max5 : Math.min(sum3, max5);
        if (weight <= available) {
          return pipe(write(input), flatMap13(() => loop3(available - weight, currentTimeMillis3)));
        }
        return loop3(tokens, timestampMillis);
      }), unwrap),
      onFailure: failCause10,
      onDone: () => void_5
    });
    const throttled = pipe(currentTimeMillis2, map16((currentTimeMillis3) => loop3(units, currentTimeMillis3)), unwrap);
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(throttled)));
  };
  var throttleShapeEffect = (self, costFn, units, duration2, burst) => {
    const loop3 = (tokens, timestampMillis) => readWithCause({
      onInput: (input) => pipe(costFn(input), zip5(currentTimeMillis2), map16(([weight, currentTimeMillis3]) => {
        const elapsed2 = currentTimeMillis3 - timestampMillis;
        const cycles = elapsed2 / toMillis(duration2);
        const sum3 = tokens + cycles * units;
        const max5 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
        const available = sum3 < 0 ? max5 : Math.min(sum3, max5);
        const remaining = available - weight;
        const waitCycles = remaining >= 0 ? 0 : -remaining / units;
        const delay3 = millis(Math.max(0, waitCycles * toMillis(duration2)));
        if (greaterThan2(delay3, zero)) {
          return pipe(fromEffect4(sleep2(delay3)), zipRight4(write(input)), flatMap13(() => loop3(remaining, currentTimeMillis3)));
        }
        return flatMap13(write(input), () => loop3(remaining, currentTimeMillis3));
      }), unwrap),
      onFailure: failCause10,
      onDone: () => void_5
    });
    const throttled = pipe(currentTimeMillis2, map16((currentTimeMillis3) => loop3(units, currentTimeMillis3)), unwrap);
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(throttled)));
  };
  var tick = (interval) => repeatWithSchedule(undefined, spaced2(interval));
  var timeout3 = /* @__PURE__ */ dual(2, (self, duration2) => pipe(toPull2(self), map16(timeoutFail2({
    onTimeout: () => none2(),
    duration: duration2
  })), fromPull2));
  var timeoutFail3 = /* @__PURE__ */ dual(3, (self, error, duration2) => pipe(self, timeoutTo3(duration2, failSync7(error))));
  var timeoutFailCause3 = /* @__PURE__ */ dual(3, (self, cause3, duration2) => pipe(toPull2(self), map16(timeoutFailCause2({
    onTimeout: () => map12(cause3(), some2),
    duration: duration2
  })), fromPull2));
  var timeoutTo3 = /* @__PURE__ */ dual(3, (self, duration2, that) => {
    const StreamTimeout = new RuntimeException2("Stream Timeout");
    return pipe(self, timeoutFailCause3(() => die4(StreamTimeout), duration2), catchSomeCause3((cause3) => isDieType2(cause3) && isRuntimeException2(cause3.defect) && cause3.defect.message !== undefined && cause3.defect.message === "Stream Timeout" ? some2(that) : none2()));
  });
  var pubsubFromOptions = (options) => {
    if (typeof options === "number") {
      return bounded4(options);
    } else if (options.capacity === "unbounded") {
      return unbounded4({
        replay: options.replay
      });
    }
    switch (options.strategy) {
      case "dropping":
        return dropping3(options);
      case "sliding":
        return sliding3(options);
      default:
        return bounded4(options);
    }
  };
  var toPubSub2 = /* @__PURE__ */ dual(2, (self, capacity7) => pipe(acquireRelease2(pubsubFromOptions(capacity7), (pubsub) => shutdown3(pubsub)), tap3((pubsub) => pipe(self, runIntoPubSubScoped(pubsub), forkScoped2))));
  var toPull2 = (self) => map16(toPull(toChannel2(self)), (pull) => pipe(pull, mapError3(some2), flatMap11(match({
    onLeft: () => fail9(none2()),
    onRight: succeed8
  }))));
  var toQueue2 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options) => tap3(acquireRelease2(options?.strategy === "unbounded" ? unbounded5() : options?.strategy === "dropping" ? dropping4(options.capacity ?? 2) : options?.strategy === "sliding" ? sliding4(options.capacity ?? 2) : bounded5(options?.capacity ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped2(runIntoQueueScoped(self, queue))));
  var toQueueOfElements = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options) => tap3(acquireRelease2(bounded5(options?.capacity ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped2(runIntoQueueElementsScoped(self, queue))));
  var toReadableStream = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options) => toReadableStreamRuntime(self, defaultRuntime2, options));
  var toReadableStreamEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, options) => map16(runtime3(), (runtime4) => toReadableStreamRuntime(self, runtime4, options)));
  var toReadableStreamRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, runtime4, options) => {
    const runFork4 = runFork3(runtime4);
    let currentResolve = undefined;
    let fiber = undefined;
    const latch = unsafeMakeLatch2(false);
    return new ReadableStream({
      start(controller) {
        fiber = runFork4(runForEachChunk(self, (chunk3) => {
          if (chunk3.length === 0)
            return _void;
          return latch.whenOpen(sync3(() => {
            latch.unsafeClose();
            for (const item of chunk3) {
              controller.enqueue(item);
            }
            currentResolve();
            currentResolve = undefined;
          }));
        }));
        fiber.addObserver((exit3) => {
          try {
            if (exit3._tag === "Failure") {
              controller.error(squash(exit3.cause));
            } else {
              controller.close();
            }
          } catch {}
        });
      },
      pull() {
        return new Promise((resolve) => {
          currentResolve = resolve;
          runSync(latch.open);
        });
      },
      cancel() {
        if (!fiber)
          return;
        return runPromise(asVoid3(interrupt6(fiber)));
      }
    }, options?.strategy);
  });
  var transduce = /* @__PURE__ */ dual(2, (self, sink) => {
    const newChannel = suspend5(() => {
      const leftovers = {
        ref: empty4()
      };
      const upstreamDone = {
        ref: false
      };
      const buffer2 = suspend5(() => {
        const leftover = leftovers.ref;
        if (isEmpty(leftover)) {
          return readWith({
            onInput: (input) => pipe(write(input), flatMap13(() => buffer2)),
            onFailure: fail11,
            onDone: succeedNow
          });
        }
        leftovers.ref = empty4();
        return pipe(writeChunk(leftover), flatMap13(() => buffer2));
      });
      const concatAndGet = (chunk3) => {
        const leftover = leftovers.ref;
        const concatenated = appendAll2(leftover, filter2(chunk3, (chunk4) => chunk4.length !== 0));
        leftovers.ref = concatenated;
        return concatenated;
      };
      const upstreamMarker = readWith({
        onInput: (input) => flatMap13(write(input), () => upstreamMarker),
        onFailure: fail11,
        onDone: (done11) => zipRight4(sync5(() => {
          upstreamDone.ref = true;
        }), succeedNow(done11))
      });
      const transducer = pipe(sink, toChannel, collectElements, flatMap13(([leftover, z]) => pipe(succeed10([upstreamDone.ref, concatAndGet(leftover)]), flatMap13(([done11, newLeftovers]) => {
        const nextChannel = done11 && isEmpty(newLeftovers) ? void_5 : transducer;
        return pipe(write(of2(z)), flatMap13(() => nextChannel));
      }))));
      return pipe(toChannel2(self), pipeTo(upstreamMarker), pipeTo(buffer2), pipeToOrFail(transducer));
    });
    return new StreamImpl(newChannel);
  });
  var toAsyncIterableRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, runtime4) => {
    const runFork4 = runFork3(runtime4);
    return {
      [Symbol.asyncIterator]() {
        let currentResolve = undefined;
        let currentReject = undefined;
        let fiber = undefined;
        const latch = unsafeMakeLatch2(false);
        let returned = false;
        return {
          next() {
            if (!fiber) {
              fiber = runFork4(runForEach(self, (value) => latch.whenOpen(sync3(() => {
                latch.unsafeClose();
                currentResolve({
                  done: false,
                  value
                });
                currentResolve = currentReject = undefined;
              }))));
              fiber.addObserver((exit3) => {
                if (returned)
                  return;
                fiber = runFork2(latch.whenOpen(sync3(() => {
                  if (exit3._tag === "Failure") {
                    currentReject(squash(exit3.cause));
                  } else {
                    currentResolve({
                      done: true,
                      value: undefined
                    });
                  }
                  currentResolve = currentReject = undefined;
                })));
              });
            }
            return new Promise((resolve, reject) => {
              currentResolve = resolve;
              currentReject = reject;
              latch.unsafeOpen();
            });
          },
          return() {
            returned = true;
            if (!fiber)
              return Promise.resolve({
                done: true,
                value: undefined
              });
            return runPromise(as3(interrupt6(fiber), {
              done: true,
              value: undefined
            }));
          }
        };
      }
    };
  });
  var toAsyncIterable = (self) => toAsyncIterableRuntime(self, defaultRuntime2);
  var toAsyncIterableEffect = (self) => map16(runtime3(), (runtime4) => toAsyncIterableRuntime(self, runtime4));
  var unfold3 = (s, f) => unfoldChunk(s, (s2) => pipe(f(s2), map2(([a, s3]) => [of2(a), s3])));
  var unfoldChunk = (s, f) => {
    const loop3 = (s2) => match2(f(s2), {
      onNone: () => void_5,
      onSome: ([chunk3, s3]) => flatMap13(write(chunk3), () => loop3(s3))
    });
    return new StreamImpl(suspend5(() => loop3(s)));
  };
  var unfoldChunkEffect = (s, f) => suspend9(() => {
    const loop3 = (s2) => unwrap(map16(f(s2), match2({
      onNone: () => void_5,
      onSome: ([chunk3, s3]) => flatMap13(write(chunk3), () => loop3(s3))
    })));
    return new StreamImpl(loop3(s));
  });
  var unfoldEffect = (s, f) => unfoldChunkEffect(s, (s2) => pipe(f(s2), map16(map2(([a, s3]) => [of2(a), s3]))));
  var void_7 = /* @__PURE__ */ succeed14(undefined);
  var unwrap2 = (effect4) => flatten13(fromEffect7(effect4));
  var unwrapScoped4 = (effect4) => flatten13(scoped5(effect4));
  var unwrapScopedWith3 = (f) => flatten13(scopedWith4((scope5) => f(scope5)));
  var updateService4 = /* @__PURE__ */ dual(3, (self, tag, f) => pipe(self, mapInputContext5((context6) => pipe(context6, add2(tag, f(pipe(context6, unsafeGet3(tag))))))));
  var when3 = /* @__PURE__ */ dual(2, (self, test) => pipe(self, whenEffect3(sync3(test))));
  var whenCase = (evaluate2, pf) => whenCaseEffect(pf)(sync3(evaluate2));
  var whenCaseEffect = /* @__PURE__ */ dual(2, (self, pf) => pipe(fromEffect7(self), flatMap16((a) => pipe(pf(a), getOrElse(() => empty29)))));
  var whenEffect3 = /* @__PURE__ */ dual(2, (self, effect4) => pipe(fromEffect7(effect4), flatMap16((bool) => bool ? self : empty29)));
  var withSpan6 = function() {
    const dataFirst = typeof arguments[0] !== "string";
    const name = dataFirst ? arguments[1] : arguments[0];
    const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
    if (dataFirst) {
      const self = arguments[0];
      return new StreamImpl(withSpan5(toChannel2(self), name, options));
    }
    return (self) => new StreamImpl(withSpan5(toChannel2(self), name, options));
  };
  var zip7 = /* @__PURE__ */ dual(2, (self, that) => pipe(self, zipWith10(that, (a, a2) => [a, a2])));
  var zipFlatten = /* @__PURE__ */ dual(2, (self, that) => pipe(self, zipWith10(that, (a, a2) => [...a, a2])));
  var zipAll = /* @__PURE__ */ dual(2, (self, options) => zipAllWith(self, {
    other: options.other,
    onSelf: (a) => [a, options.defaultOther],
    onOther: (a2) => [options.defaultSelf, a2],
    onBoth: (a, a2) => [a, a2]
  }));
  var zipAllLeft = /* @__PURE__ */ dual(3, (self, other, defaultSelf) => zipAllWith(self, {
    other,
    onSelf: identity,
    onOther: () => defaultSelf,
    onBoth: (a) => a
  }));
  var zipAllRight = /* @__PURE__ */ dual(3, (self, other, defaultRight) => zipAllWith(self, {
    other,
    onSelf: () => defaultRight,
    onOther: identity,
    onBoth: (_, a2) => a2
  }));
  var zipAllSortedByKey = /* @__PURE__ */ dual(2, (self, options) => zipAllSortedByKeyWith(self, {
    other: options.other,
    onSelf: (a) => [a, options.defaultOther],
    onOther: (a2) => [options.defaultSelf, a2],
    onBoth: (a, a2) => [a, a2],
    order: options.order
  }));
  var zipAllSortedByKeyLeft = /* @__PURE__ */ dual(2, (self, options) => zipAllSortedByKeyWith(self, {
    other: options.other,
    onSelf: identity,
    onOther: () => options.defaultSelf,
    onBoth: (a) => a,
    order: options.order
  }));
  var zipAllSortedByKeyRight = /* @__PURE__ */ dual(2, (self, options) => zipAllSortedByKeyWith(self, {
    other: options.other,
    onSelf: () => options.defaultOther,
    onOther: identity,
    onBoth: (_, a2) => a2,
    order: options.order
  }));
  var zipAllSortedByKeyWith = /* @__PURE__ */ dual(2, (self, options) => {
    const pull = (state, pullLeft, pullRight) => {
      switch (state._tag) {
        case OP_DRAIN_LEFT: {
          return pipe(pullLeft, match12({
            onFailure: fail4,
            onSuccess: (leftChunk) => succeed3([map4(leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])
          }));
        }
        case OP_DRAIN_RIGHT: {
          return pipe(pullRight, match12({
            onFailure: fail4,
            onSuccess: (rightChunk) => succeed3([map4(rightChunk, ([k, a2]) => [k, options.onOther(a2)]), DrainRight])
          }));
        }
        case OP_PULL_BOTH: {
          return pipe(unsome(pullLeft), zip5(unsome(pullRight), {
            concurrent: true
          }), matchEffect2({
            onFailure: (error) => succeed8(fail4(some2(error))),
            onSuccess: ([leftOption, rightOption]) => {
              if (isSome2(leftOption) && isSome2(rightOption)) {
                if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                  return pull(PullBoth, pullLeft, pullRight);
                }
                if (isEmpty(leftOption.value)) {
                  return pull(PullLeft(rightOption.value), pullLeft, pullRight);
                }
                if (isEmpty(rightOption.value)) {
                  return pull(PullRight(leftOption.value), pullLeft, pullRight);
                }
                return succeed8(succeed3(merge10(leftOption.value, rightOption.value)));
              }
              if (isSome2(leftOption) && isNone2(rightOption)) {
                if (isEmpty(leftOption.value)) {
                  return pull(DrainLeft, pullLeft, pullRight);
                }
                return succeed8(succeed3([pipe(leftOption.value, map4(([k, a]) => [k, options.onSelf(a)])), DrainLeft]));
              }
              if (isNone2(leftOption) && isSome2(rightOption)) {
                if (isEmpty(rightOption.value)) {
                  return pull(DrainRight, pullLeft, pullRight);
                }
                return succeed8(succeed3([pipe(rightOption.value, map4(([k, a2]) => [k, options.onOther(a2)])), DrainRight]));
              }
              return succeed8(fail4(none2()));
            }
          }));
        }
        case OP_PULL_LEFT: {
          return matchEffect2(pullLeft, {
            onFailure: match2({
              onNone: () => succeed8(succeed3([pipe(state.rightChunk, map4(([k, a2]) => [k, options.onOther(a2)])), DrainRight])),
              onSome: (error) => succeed8(fail4(some2(error)))
            }),
            onSuccess: (leftChunk) => isEmpty(leftChunk) ? pull(PullLeft(state.rightChunk), pullLeft, pullRight) : succeed8(succeed3(merge10(leftChunk, state.rightChunk)))
          });
        }
        case OP_PULL_RIGHT: {
          return matchEffect2(pullRight, {
            onFailure: match2({
              onNone: () => succeed8(succeed3([map4(state.leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])),
              onSome: (error) => succeed8(fail4(some2(error)))
            }),
            onSuccess: (rightChunk) => isEmpty(rightChunk) ? pull(PullRight(state.leftChunk), pullLeft, pullRight) : succeed8(succeed3(merge10(state.leftChunk, rightChunk)))
          });
        }
      }
    };
    const merge10 = (leftChunk, rightChunk) => {
      const hasNext = (chunk3, index) => index < chunk3.length - 1;
      const builder = [];
      let state = undefined;
      let leftIndex = 0;
      let rightIndex = 0;
      let leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
      let rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
      let k1 = leftTuple[0];
      let a = leftTuple[1];
      let k2 = rightTuple[0];
      let a2 = rightTuple[1];
      let loop3 = true;
      while (loop3) {
        const compare = options.order(k1, k2);
        if (compare === 0) {
          builder.push([k1, options.onBoth(a, a2)]);
          if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {
            leftIndex = leftIndex + 1;
            rightIndex = rightIndex + 1;
            leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
            rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
            k1 = leftTuple[0];
            a = leftTuple[1];
            k2 = rightTuple[0];
            a2 = rightTuple[1];
          } else if (hasNext(leftChunk, leftIndex)) {
            state = PullRight(pipe(leftChunk, drop2(leftIndex + 1)));
            loop3 = false;
          } else if (hasNext(rightChunk, rightIndex)) {
            state = PullLeft(pipe(rightChunk, drop2(rightIndex + 1)));
            loop3 = false;
          } else {
            state = PullBoth;
            loop3 = false;
          }
        } else if (compare < 0) {
          builder.push([k1, options.onSelf(a)]);
          if (hasNext(leftChunk, leftIndex)) {
            leftIndex = leftIndex + 1;
            leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
            k1 = leftTuple[0];
            a = leftTuple[1];
          } else {
            const rightBuilder = [];
            rightBuilder.push(rightTuple);
            while (hasNext(rightChunk, rightIndex)) {
              rightIndex = rightIndex + 1;
              rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
              rightBuilder.push(rightTuple);
            }
            state = PullLeft(unsafeFromArray(rightBuilder));
            loop3 = false;
          }
        } else {
          builder.push([k2, options.onOther(a2)]);
          if (hasNext(rightChunk, rightIndex)) {
            rightIndex = rightIndex + 1;
            rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
            k2 = rightTuple[0];
            a2 = rightTuple[1];
          } else {
            const leftBuilder = [];
            leftBuilder.push(leftTuple);
            while (hasNext(leftChunk, leftIndex)) {
              leftIndex = leftIndex + 1;
              leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
              leftBuilder.push(leftTuple);
            }
            state = PullRight(unsafeFromArray(leftBuilder));
            loop3 = false;
          }
        }
      }
      return [unsafeFromArray(builder), state];
    };
    return combineChunks(self, options.other, PullBoth, pull);
  });
  var zipAllWith = /* @__PURE__ */ dual(2, (self, options) => {
    const pull = (state, pullLeft, pullRight) => {
      switch (state._tag) {
        case OP_DRAIN_LEFT: {
          return matchEffect2(pullLeft, {
            onFailure: (error) => succeed8(fail4(error)),
            onSuccess: (leftChunk) => succeed8(succeed3([map4(leftChunk, options.onSelf), DrainLeft]))
          });
        }
        case OP_DRAIN_RIGHT: {
          return matchEffect2(pullRight, {
            onFailure: (error) => succeed8(fail4(error)),
            onSuccess: (rightChunk) => succeed8(succeed3([map4(rightChunk, options.onOther), DrainRight]))
          });
        }
        case OP_PULL_BOTH: {
          return pipe(unsome(pullLeft), zip5(unsome(pullRight), {
            concurrent: true
          }), matchEffect2({
            onFailure: (error) => succeed8(fail4(some2(error))),
            onSuccess: ([leftOption, rightOption]) => {
              if (isSome2(leftOption) && isSome2(rightOption)) {
                if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                  return pull(PullBoth, pullLeft, pullRight);
                }
                if (isEmpty(leftOption.value)) {
                  return pull(PullLeft(rightOption.value), pullLeft, pullRight);
                }
                if (isEmpty(rightOption.value)) {
                  return pull(PullRight(leftOption.value), pullLeft, pullRight);
                }
                return succeed8(succeed3(zip8(leftOption.value, rightOption.value, options.onBoth)));
              }
              if (isSome2(leftOption) && isNone2(rightOption)) {
                return succeed8(succeed3([map4(leftOption.value, options.onSelf), DrainLeft]));
              }
              if (isNone2(leftOption) && isSome2(rightOption)) {
                return succeed8(succeed3([map4(rightOption.value, options.onOther), DrainRight]));
              }
              return succeed8(fail4(none2()));
            }
          }));
        }
        case OP_PULL_LEFT: {
          return matchEffect2(pullLeft, {
            onFailure: match2({
              onNone: () => succeed8(succeed3([map4(state.rightChunk, options.onOther), DrainRight])),
              onSome: (error) => succeed8(fail4(some2(error)))
            }),
            onSuccess: (leftChunk) => {
              if (isEmpty(leftChunk)) {
                return pull(PullLeft(state.rightChunk), pullLeft, pullRight);
              }
              if (isEmpty(state.rightChunk)) {
                return pull(PullRight(leftChunk), pullLeft, pullRight);
              }
              return succeed8(succeed3(zip8(leftChunk, state.rightChunk, options.onBoth)));
            }
          });
        }
        case OP_PULL_RIGHT: {
          return matchEffect2(pullRight, {
            onFailure: match2({
              onNone: () => succeed8(succeed3([map4(state.leftChunk, options.onSelf), DrainLeft])),
              onSome: (error) => succeed8(fail4(some2(error)))
            }),
            onSuccess: (rightChunk) => {
              if (isEmpty(rightChunk)) {
                return pull(PullRight(state.leftChunk), pullLeft, pullRight);
              }
              if (isEmpty(state.leftChunk)) {
                return pull(PullLeft(rightChunk), pullLeft, pullRight);
              }
              return succeed8(succeed3(zip8(state.leftChunk, rightChunk, options.onBoth)));
            }
          });
        }
      }
    };
    const zip8 = (leftChunk, rightChunk, f) => {
      const [output, either6] = zipChunks(leftChunk, rightChunk, f);
      switch (either6._tag) {
        case "Left": {
          if (isEmpty(either6.left)) {
            return [output, PullBoth];
          }
          return [output, PullRight(either6.left)];
        }
        case "Right": {
          if (isEmpty(either6.right)) {
            return [output, PullBoth];
          }
          return [output, PullLeft(either6.right)];
        }
      }
    };
    return combineChunks(self, options.other, PullBoth, pull);
  });
  var zipLatest = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipLatestWith(right3, (a, a2) => [a, a2])));
  var zipLatestAll = (...streams) => {
    if (streams.length === 0) {
      return empty29;
    } else if (streams.length === 1) {
      return map21(streams[0], (x) => [x]);
    }
    const [head6, ...tail] = streams;
    return zipLatestWith(head6, zipLatestAll(...tail), (first, second) => [first, ...second]);
  };
  var zipLatestWith = /* @__PURE__ */ dual(3, (left3, right3, f) => {
    const pullNonEmpty = (pull) => pipe(pull, flatMap11((chunk3) => isEmpty(chunk3) ? pullNonEmpty(pull) : succeed8(chunk3)));
    return pipe(toPull2(left3), map16(pullNonEmpty), zip5(pipe(toPull2(right3), map16(pullNonEmpty))), flatMap11(([left4, right4]) => pipe(fromEffectOption(raceWith2(left4, right4, {
      onSelfDone: (leftDone, rightFiber) => pipe(suspend3(() => leftDone), zipWith5(join3(rightFiber), (l, r) => [l, r, true])),
      onOtherDone: (rightDone, leftFiber) => pipe(suspend3(() => rightDone), zipWith5(join3(leftFiber), (l, r) => [r, l, false]))
    })), flatMap16(([l, r, leftFirst]) => pipe(fromEffect7(make28([unsafeLast(l), unsafeLast(r)])), flatMap16((latest) => pipe(fromChunk(leftFirst ? pipe(r, map4((a2) => f(unsafeLast(l), a2))) : pipe(l, map4((a) => f(a, unsafeLast(r))))), concat2(pipe(repeatEffectOption(left4), mergeEither(repeatEffectOption(right4)), mapEffectSequential(match({
      onLeft: (leftChunk) => modify4(latest, ([_, rightLatest]) => [pipe(leftChunk, map4((a) => f(a, rightLatest))), [unsafeLast(leftChunk), rightLatest]]),
      onRight: (rightChunk) => modify4(latest, ([leftLatest, _]) => [pipe(rightChunk, map4((a2) => f(leftLatest, a2))), [leftLatest, unsafeLast(rightChunk)]])
    })), flatMap16(fromChunk))))))), toPull2)), fromPull2);
  });
  var zipLeft5 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
    if (left4.length > right4.length) {
      return [pipe(left4, take(right4.length)), left2(pipe(left4, take(right4.length)))];
    }
    return [left4, right2(pipe(right4, drop2(left4.length)))];
  })));
  var zipRight8 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
    if (left4.length > right4.length) {
      return [right4, left2(pipe(left4, take(right4.length)))];
    }
    return [pipe(right4, take(left4.length)), right2(pipe(right4, drop2(left4.length)))];
  })));
  var zipWith10 = /* @__PURE__ */ dual(3, (left3, right3, f) => pipe(left3, zipWithChunks(right3, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f))));
  var zipWithChunks = /* @__PURE__ */ dual(3, (self, that, f) => {
    const pull = (state, pullLeft, pullRight) => {
      switch (state._tag) {
        case OP_PULL_BOTH2: {
          return pipe(unsome(pullLeft), zip5(unsome(pullRight), {
            concurrent: true
          }), matchEffect2({
            onFailure: (error) => succeed8(fail4(some2(error))),
            onSuccess: ([leftOption, rightOption]) => {
              if (isSome2(leftOption) && isSome2(rightOption)) {
                if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                  return pull(PullBoth2, pullLeft, pullRight);
                }
                if (isEmpty(leftOption.value)) {
                  return pull(PullLeft2(rightOption.value), pullLeft, pullRight);
                }
                if (isEmpty(rightOption.value)) {
                  return pull(PullRight2(leftOption.value), pullLeft, pullRight);
                }
                return succeed8(succeed3(zip8(leftOption.value, rightOption.value)));
              }
              return succeed8(fail4(none2()));
            }
          }));
        }
        case OP_PULL_LEFT2: {
          return matchEffect2(pullLeft, {
            onFailure: (error) => succeed8(fail4(error)),
            onSuccess: (leftChunk) => {
              if (isEmpty(leftChunk)) {
                return pull(PullLeft2(state.rightChunk), pullLeft, pullRight);
              }
              if (isEmpty(state.rightChunk)) {
                return pull(PullRight2(leftChunk), pullLeft, pullRight);
              }
              return succeed8(succeed3(zip8(leftChunk, state.rightChunk)));
            }
          });
        }
        case OP_PULL_RIGHT2: {
          return matchEffect2(pullRight, {
            onFailure: (error) => succeed8(fail4(error)),
            onSuccess: (rightChunk) => {
              if (isEmpty(rightChunk)) {
                return pull(PullRight2(state.leftChunk), pullLeft, pullRight);
              }
              if (isEmpty(state.leftChunk)) {
                return pull(PullLeft2(rightChunk), pullLeft, pullRight);
              }
              return succeed8(succeed3(zip8(state.leftChunk, rightChunk)));
            }
          });
        }
      }
    };
    const zip8 = (leftChunk, rightChunk) => {
      const [output, either6] = f(leftChunk, rightChunk);
      switch (either6._tag) {
        case "Left": {
          if (isEmpty(either6.left)) {
            return [output, PullBoth2];
          }
          return [output, PullRight2(either6.left)];
        }
        case "Right": {
          if (isEmpty(either6.right)) {
            return [output, PullBoth2];
          }
          return [output, PullLeft2(either6.right)];
        }
      }
    };
    return pipe(self, combineChunks(that, PullBoth2, pull));
  });
  var zipWithIndex = (self) => pipe(self, mapAccum5(0, (index, a) => [index + 1, [a, index]]));
  var zipWithNext = (self) => {
    const process2 = (last4) => readWithCause({
      onInput: (input) => {
        const [newLast, chunk3] = mapAccum2(input, last4, (prev, curr) => [some2(curr), pipe(prev, map2((a) => [a, curr]))]);
        const output = filterMap2(chunk3, (option3) => isSome2(option3) ? some2([option3.value[0], some2(option3.value[1])]) : none2());
        return flatMap13(write(output), () => process2(newLast));
      },
      onFailure: failCause10,
      onDone: () => match2(last4, {
        onNone: () => void_5,
        onSome: (value) => zipRight4(write(of2([value, none2()])), void_5)
      })
    });
    return new StreamImpl(pipe(toChannel2(self), pipeToOrFail(process2(none2()))));
  };
  var zipWithPrevious = (self) => pipe(self, mapAccum5(none2(), (prev, curr) => [some2(curr), [prev, curr]]));
  var zipWithPreviousAndNext = (self) => pipe(zipWithNext(zipWithPrevious(self)), map21(([[prev, curr], next]) => [prev, curr, pipe(next, map2((tuple) => tuple[1]))]));
  var zipChunks = (left3, right3, f) => {
    if (left3.length > right3.length) {
      return [pipe(left3, take(right3.length), zipWith2(right3, f)), left2(pipe(left3, drop2(right3.length)))];
    }
    return [pipe(left3, zipWith2(pipe(right3, take(left3.length)), f)), right2(pipe(right3, drop2(left3.length)))];
  };
  var Do3 = /* @__PURE__ */ succeed14({});
  var bind4 = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self, tag, f, options) => flatMap16(self, (k) => map21(f(k), (a) => ({
    ...k,
    [tag]: a
  })), options));
  var bindTo4 = /* @__PURE__ */ bindTo(map21);
  var let_4 = /* @__PURE__ */ let_(map21);
  var decodeText = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, encoding = "utf-8") => suspend9(() => {
    const decoder = new TextDecoder(encoding);
    return map21(self, (s) => decoder.decode(s));
  }));
  var encodeText = (self) => suspend9(() => {
    const encoder = new TextEncoder;
    return map21(self, (s) => encoder.encode(s));
  });
  var fromEventListener = (target, type, options) => asyncPush((emit2) => acquireRelease2(sync3(() => target.addEventListener(type, emit2.single, options)), () => sync3(() => target.removeEventListener(type, emit2.single, options))), {
    bufferSize: typeof options === "object" ? options.bufferSize : undefined
  });
  // node_modules/effect/dist/esm/internal/groupBy.js
  var GroupBySymbolKey = "effect/GroupBy";
  var GroupByTypeId = /* @__PURE__ */ Symbol.for(GroupBySymbolKey);
  var groupByVariance = {
    _R: (_) => _,
    _E: (_) => _,
    _K: (_) => _,
    _V: (_) => _
  };
  var isGroupBy = (u) => hasProperty(u, GroupByTypeId);
  var evaluate2 = /* @__PURE__ */ dual((args2) => isGroupBy(args2[0]), (self, f, options) => flatMap16(self.grouped, ([key, queue]) => f(key, flattenTake(fromQueue2(queue, {
    shutdown: true
  }))), {
    concurrency: "unbounded",
    bufferSize: options?.bufferSize ?? 16
  }));
  var make51 = (grouped2) => ({
    [GroupByTypeId]: groupByVariance,
    pipe() {
      return pipeArguments(this, arguments);
    },
    grouped: grouped2
  });
  var groupBy = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self, f, options) => make51(unwrapScoped4(gen2(function* () {
    const decider = yield* make18();
    const output = yield* acquireRelease2(bounded5(options?.bufferSize ?? 16), (queue) => shutdown4(queue));
    const ref = yield* make28(new Map);
    const add5 = yield* pipe(mapEffectSequential(self, f), distributedWithDynamicCallback(options?.bufferSize ?? 16, ([key, value]) => flatMap11(_await(decider), (f2) => f2(key, value)), (exit3) => offer3(output, exit3)));
    yield* succeed2(decider, (key, _) => pipe(get12(ref), map16((map22) => fromNullable(map22.get(key))), flatMap11(match2({
      onNone: () => flatMap11(add5, ([index, queue]) => zipRight3(update3(ref, (map22) => map22.set(key, index)), pipe(offer3(output, succeed3([key, mapDequeue(queue, (exit3) => new TakeImpl(pipe(exit3, map11((tuple) => of2(tuple[1])))))])), as3((n) => n === index)))),
      onSome: (index) => succeed8((n) => n === index)
    }))));
    return flattenExitOption(fromQueue2(output, {
      shutdown: true
    }));
  }))));
  var mapEffectOptions = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self, f, options) => {
    if (options?.key) {
      return evaluate2(groupByKey(self, options.key, {
        bufferSize: options.bufferSize
      }), (_, s) => mapEffectSequential(s, f));
    }
    return matchConcurrency(options?.concurrency, () => mapEffectSequential(self, f), (n) => options?.unordered ? flatMap16(self, (a) => fromEffect7(f(a)), {
      concurrency: n
    }) : mapEffectPar(self, n, f));
  });
  var bindEffect = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self, tag, f, options) => mapEffectOptions(self, (k) => map16(f(k), (a) => ({
    ...k,
    [tag]: a
  })), options));
  var mapDequeue = (dequeue, f) => new MapDequeue(dequeue, f);

  class MapDequeue extends Class {
    dequeue;
    f;
    [DequeueTypeId2] = {
      _Out: (_) => _
    };
    constructor(dequeue, f) {
      super();
      this.dequeue = dequeue;
      this.f = f;
    }
    capacity() {
      return capacity4(this.dequeue);
    }
    get size() {
      return size10(this.dequeue);
    }
    unsafeSize() {
      return this.dequeue.unsafeSize();
    }
    get awaitShutdown() {
      return awaitShutdown3(this.dequeue);
    }
    isActive() {
      return this.dequeue.isActive();
    }
    get isShutdown() {
      return isShutdown3(this.dequeue);
    }
    get shutdown() {
      return shutdown4(this.dequeue);
    }
    get isFull() {
      return isFull3(this.dequeue);
    }
    get isEmpty() {
      return isEmpty12(this.dequeue);
    }
    get take() {
      return pipe(take3(this.dequeue), map16((a) => this.f(a)));
    }
    get takeAll() {
      return pipe(takeAll2(this.dequeue), map16(map4((a) => this.f(a))));
    }
    takeUpTo(max5) {
      return pipe(takeUpTo2(this.dequeue, max5), map16(map4((a) => this.f(a))));
    }
    takeBetween(min3, max5) {
      return pipe(takeBetween2(this.dequeue, min3, max5), map16(map4((a) => this.f(a))));
    }
    takeN(n) {
      return pipe(takeN2(this.dequeue, n), map16(map4((a) => this.f(a))));
    }
    poll() {
      return pipe(poll6(this.dequeue), map16(map2((a) => this.f(a))));
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    commit() {
      return this.take;
    }
  }
  var groupByKey = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self, f, options) => {
    const loop3 = (map22, outerQueue) => readWithCause({
      onInput: (input) => flatMap13(fromEffect4(forEach6(groupByIterable(input, f), ([key, values3]) => {
        const innerQueue = map22.get(key);
        if (innerQueue === undefined) {
          return pipe(bounded5(options?.bufferSize ?? 16), flatMap11((innerQueue2) => pipe(sync3(() => {
            map22.set(key, innerQueue2);
          }), zipRight3(offer3(outerQueue, of5([key, innerQueue2]))), zipRight3(pipe(offer3(innerQueue2, chunk2(values3)), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2()))))));
        }
        return catchSomeCause2(offer3(innerQueue, chunk2(values3)), (cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2());
      }, {
        discard: true
      })), () => loop3(map22, outerQueue)),
      onFailure: (cause3) => fromEffect4(offer3(outerQueue, failCause11(cause3))),
      onDone: () => fromEffect4(pipe(forEach6(map22.entries(), ([_, innerQueue]) => pipe(offer3(innerQueue, end4), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2())), {
        discard: true
      }), zipRight3(offer3(outerQueue, end4))))
    });
    return make51(unwrapScopedWith3((scope5) => gen2(function* () {
      const map22 = new Map;
      const queue = yield* unbounded5();
      yield* addFinalizer2(scope5, shutdown4(queue));
      return yield* toChannel2(self).pipe(pipeTo(loop3(map22, queue)), drain, runIn(scope5), forkIn2(scope5), as3(flattenTake(fromQueue2(queue, {
        shutdown: true
      }))));
    })));
  });
  var groupByIterable = /* @__PURE__ */ dual(2, (iterable, f) => {
    const builder = [];
    const iterator = iterable[Symbol.iterator]();
    const map22 = new Map;
    let next;
    while ((next = iterator.next()) && !next.done) {
      const value = next.value;
      const key = f(value);
      if (map22.has(key)) {
        const innerBuilder = map22.get(key);
        innerBuilder.push(value);
      } else {
        const innerBuilder = [value];
        builder.push([key, innerBuilder]);
        map22.set(key, innerBuilder);
      }
    }
    return unsafeFromArray(builder.map((tuple) => [tuple[0], unsafeFromArray(tuple[1])]));
  });
  // node_modules/effect/dist/esm/ParseResult.js
  class Pointer {
    path;
    actual;
    issue;
    _tag = "Pointer";
    constructor(path, actual, issue) {
      this.path = path;
      this.actual = actual;
      this.issue = issue;
    }
  }

  class Unexpected {
    actual;
    message;
    _tag = "Unexpected";
    constructor(actual, message) {
      this.actual = actual;
      this.message = message;
    }
  }

  class Missing {
    ast;
    message;
    _tag = "Missing";
    actual = undefined;
    constructor(ast, message) {
      this.ast = ast;
      this.message = message;
    }
  }

  class Composite2 {
    ast;
    actual;
    issues;
    output;
    _tag = "Composite";
    constructor(ast, actual, issues, output) {
      this.ast = ast;
      this.actual = actual;
      this.issues = issues;
      this.output = output;
    }
  }

  class Refinement2 {
    ast;
    actual;
    kind;
    issue;
    _tag = "Refinement";
    constructor(ast, actual, kind, issue) {
      this.ast = ast;
      this.actual = actual;
      this.kind = kind;
      this.issue = issue;
    }
  }

  class Transformation2 {
    ast;
    actual;
    kind;
    issue;
    _tag = "Transformation";
    constructor(ast, actual, kind, issue) {
      this.ast = ast;
      this.actual = actual;
      this.kind = kind;
      this.issue = issue;
    }
  }

  class Type2 {
    ast;
    actual;
    message;
    _tag = "Type";
    constructor(ast, actual, message) {
      this.ast = ast;
      this.actual = actual;
      this.message = message;
    }
  }

  class Forbidden {
    ast;
    actual;
    message;
    _tag = "Forbidden";
    constructor(ast, actual, message) {
      this.ast = ast;
      this.actual = actual;
      this.message = message;
    }
  }
  var ParseErrorTypeId = /* @__PURE__ */ Symbol.for("effect/Schema/ParseErrorTypeId");
  class ParseError extends (/* @__PURE__ */ TaggedError("ParseError")) {
    [ParseErrorTypeId] = ParseErrorTypeId;
    get message() {
      return this.toString();
    }
    toString() {
      return TreeFormatter.formatIssueSync(this.issue);
    }
    toJSON() {
      return {
        _id: "ParseError",
        message: this.toString()
      };
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  }
  var parseError = (issue) => new ParseError({
    issue
  });
  var succeed15 = right2;
  var fail16 = left2;
  var isEither4 = isEither2;
  var flatMap17 = /* @__PURE__ */ dual(2, (self, f) => {
    return isEither4(self) ? match(self, {
      onLeft: left2,
      onRight: f
    }) : flatMap11(self, f);
  });
  var map22 = /* @__PURE__ */ dual(2, (self, f) => {
    return isEither4(self) ? map(self, f) : map16(self, f);
  });
  var mapError7 = /* @__PURE__ */ dual(2, (self, f) => {
    return isEither4(self) ? mapLeft(self, f) : mapError3(self, f);
  });
  var orElse9 = /* @__PURE__ */ dual(2, (self, f) => {
    return isEither4(self) ? match(self, {
      onLeft: f,
      onRight: right2
    }) : catchAll3(self, f);
  });
  var mergeInternalOptions = (options, overrideOptions) => {
    if (overrideOptions === undefined || isNumber(overrideOptions)) {
      return options;
    }
    if (options === undefined) {
      return overrideOptions;
    }
    return {
      ...options,
      ...overrideOptions
    };
  };
  var getEither = (ast, isDecoding, options) => {
    const parser = goMemo(ast, isDecoding);
    return (u, overrideOptions) => parser(u, mergeInternalOptions(options, overrideOptions));
  };
  var getSync = (ast, isDecoding, options) => {
    const parser = getEither(ast, isDecoding, options);
    return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError);
  };
  var decodeUnknownSync = (schema, options) => getSync(schema.ast, true, options);
  var encodeUnknownSync = (schema, options) => getSync(schema.ast, false, options);
  var validateSync = (schema, options) => getSync(typeAST(schema.ast), true, options);
  var encodeSync = encodeUnknownSync;
  var decodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/decodeMemoMap"), () => new WeakMap);
  var encodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/encodeMemoMap"), () => new WeakMap);
  var goMemo = (ast, isDecoding) => {
    const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
    const memo = memoMap.get(ast);
    if (memo) {
      return memo;
    }
    const raw = go(ast, isDecoding);
    const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
    const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i, options) => raw(i, mergeInternalOptions(options, parseOptionsAnnotation.value)) : raw;
    const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
    const parser = isDecoding && isSome2(decodingFallbackAnnotation) ? (i, options) => handleForbidden(orElse9(parserWithOptions(i, options), decodingFallbackAnnotation.value), ast, i, options) : parserWithOptions;
    memoMap.set(ast, parser);
    return parser;
  };
  var getConcurrency = (ast) => getOrUndefined(getConcurrencyAnnotation(ast));
  var getBatching = (ast) => getOrUndefined(getBatchingAnnotation(ast));
  var go = (ast, isDecoding) => {
    switch (ast._tag) {
      case "Refinement": {
        if (isDecoding) {
          const from = goMemo(ast.from, true);
          return (i, options) => {
            options = options ?? defaultParseOption;
            const allErrors = options?.errors === "all";
            const result = flatMap17(orElse9(from(i, options), (ef) => {
              const issue = new Refinement2(ast, i, "From", ef);
              if (allErrors && hasStableFilter(ast) && isComposite2(ef)) {
                return match2(ast.filter(i, options, ast), {
                  onNone: () => left2(issue),
                  onSome: (ep) => left2(new Composite2(ast, i, [issue, new Refinement2(ast, i, "Predicate", ep)]))
                });
              }
              return left2(issue);
            }), (a) => match2(ast.filter(a, options, ast), {
              onNone: () => right2(a),
              onSome: (ep) => left2(new Refinement2(ast, i, "Predicate", ep))
            }));
            return handleForbidden(result, ast, i, options);
          };
        } else {
          const from = goMemo(typeAST(ast), true);
          const to = goMemo(dropRightRefinement(ast.from), false);
          return (i, options) => handleForbidden(flatMap17(from(i, options), (a) => to(a, options)), ast, i, options);
        }
      }
      case "Transformation": {
        const transform2 = getFinalTransformation(ast.transformation, isDecoding);
        const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
        const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
        return (i, options) => handleForbidden(flatMap17(mapError7(from(i, options), (e) => new Transformation2(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap17(mapError7(transform2(a, options ?? defaultParseOption, ast, i), (e) => new Transformation2(ast, i, "Transformation", e)), (i2) => mapError7(to(i2, options), (e) => new Transformation2(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options);
      }
      case "Declaration": {
        const parse = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
        return (i, options) => handleForbidden(parse(i, options ?? defaultParseOption, ast), ast, i, options);
      }
      case "Literal":
        return fromRefinement(ast, (u) => u === ast.literal);
      case "UniqueSymbol":
        return fromRefinement(ast, (u) => u === ast.symbol);
      case "UndefinedKeyword":
        return fromRefinement(ast, isUndefined);
      case "NeverKeyword":
        return fromRefinement(ast, isNever);
      case "UnknownKeyword":
      case "AnyKeyword":
      case "VoidKeyword":
        return right2;
      case "StringKeyword":
        return fromRefinement(ast, isString);
      case "NumberKeyword":
        return fromRefinement(ast, isNumber);
      case "BooleanKeyword":
        return fromRefinement(ast, isBoolean);
      case "BigIntKeyword":
        return fromRefinement(ast, isBigInt);
      case "SymbolKeyword":
        return fromRefinement(ast, isSymbol);
      case "ObjectKeyword":
        return fromRefinement(ast, isObject);
      case "Enums":
        return fromRefinement(ast, (u) => ast.enums.some(([_, value]) => value === u));
      case "TemplateLiteral": {
        const regex = getTemplateLiteralRegExp(ast);
        return fromRefinement(ast, (u) => isString(u) && regex.test(u));
      }
      case "TupleType": {
        const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
        const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
        let requiredTypes = ast.elements.filter((e) => !e.isOptional);
        if (ast.rest.length > 0) {
          requiredTypes = requiredTypes.concat(ast.rest.slice(1));
        }
        const requiredLen = requiredTypes.length;
        const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
        const concurrency = getConcurrency(ast);
        const batching = getBatching(ast);
        return (input, options) => {
          if (!isArray(input)) {
            return left2(new Type2(ast, input));
          }
          const allErrors = options?.errors === "all";
          const es = [];
          let stepKey = 0;
          const output = [];
          const len = input.length;
          for (let i2 = len;i2 <= requiredLen - 1; i2++) {
            const e = new Pointer(i2, input, new Missing(requiredTypes[i2 - len]));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite2(ast, input, e, output));
            }
          }
          if (ast.rest.length === 0) {
            for (let i2 = ast.elements.length;i2 <= len - 1; i2++) {
              const e = new Pointer(i2, input, new Unexpected(input[i2], `is unexpected, expected: ${expectedIndexes}`));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
          }
          let i = 0;
          let queue = undefined;
          for (;i < elements.length; i++) {
            if (len < i + 1) {
              if (ast.elements[i].isOptional) {
                continue;
              }
            } else {
              const parser = elements[i];
              const te = parser(input[i], options);
              if (isEither4(te)) {
                if (isLeft2(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output)));
                  }
                }
                output.push([stepKey++, te.right]);
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap11(either3(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                    }
                  }
                  output2.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
          if (isNonEmptyReadonlyArray(rest)) {
            const [head6, ...tail] = rest;
            for (;i < len - tail.length; i++) {
              const te = head6(input[i], options);
              if (isEither4(te)) {
                if (isLeft2(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output)));
                  }
                } else {
                  output.push([stepKey++, te.right]);
                }
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap11(either3(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                    }
                  } else {
                    output2.push([nk, t.right]);
                    return _void;
                  }
                }));
              }
            }
            for (let j = 0;j < tail.length; j++) {
              i += j;
              if (len < i + 1) {
                continue;
              } else {
                const te = tail[j](input[i], options);
                if (isEither4(te)) {
                  if (isLeft2(te)) {
                    const e = new Pointer(i, input, te.left);
                    if (allErrors) {
                      es.push([stepKey++, e]);
                      continue;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output)));
                    }
                  }
                  output.push([stepKey++, te.right]);
                } else {
                  const nk = stepKey++;
                  const index = i;
                  if (!queue) {
                    queue = [];
                  }
                  queue.push(({
                    es: es2,
                    output: output2
                  }) => flatMap11(either3(te), (t) => {
                    if (isLeft2(t)) {
                      const e = new Pointer(index, input, t.left);
                      if (allErrors) {
                        es2.push([nk, e]);
                        return _void;
                      } else {
                        return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                      }
                    }
                    output2.push([nk, t.right]);
                    return _void;
                  }));
                }
              }
            }
          }
          const computeResult = ({
            es: es2,
            output: output2
          }) => isNonEmptyArray2(es2) ? left2(new Composite2(ast, input, sortByIndex(es2), sortByIndex(output2))) : right2(sortByIndex(output2));
          if (queue && queue.length > 0) {
            const cqueue = queue;
            return suspend3(() => {
              const state = {
                es: copy(es),
                output: copy(output)
              };
              return flatMap11(forEach6(cqueue, (f) => f(state), {
                concurrency,
                batching,
                discard: true
              }), () => computeResult(state));
            });
          }
          return computeResult({
            output,
            es
          });
        };
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          return fromRefinement(ast, isNotNullable);
        }
        const propertySignatures = [];
        const expectedKeysMap = {};
        const expectedKeys = [];
        for (const ps of ast.propertySignatures) {
          propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
          expectedKeysMap[ps.name] = null;
          expectedKeys.push(ps.name);
        }
        const indexSignatures = ast.indexSignatures.map((is) => [goMemo(is.parameter, isDecoding), goMemo(is.type, isDecoding), is.parameter]);
        const expectedAST = Union.make(ast.indexSignatures.map((is) => is.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal(key))));
        const expected = goMemo(expectedAST, isDecoding);
        const concurrency = getConcurrency(ast);
        const batching = getBatching(ast);
        return (input, options) => {
          if (!isRecord(input)) {
            return left2(new Type2(ast, input));
          }
          const allErrors = options?.errors === "all";
          const es = [];
          let stepKey = 0;
          const onExcessPropertyError = options?.onExcessProperty === "error";
          const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
          const output = {};
          let inputKeys;
          if (onExcessPropertyError || onExcessPropertyPreserve) {
            inputKeys = Reflect.ownKeys(input);
            for (const key of inputKeys) {
              const te = expected(key, options);
              if (isEither4(te) && isLeft2(te)) {
                if (onExcessPropertyError) {
                  const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, output));
                  }
                } else {
                  output[key] = input[key];
                }
              }
            }
          }
          let queue = undefined;
          const isExact = options?.exact === true;
          for (let i = 0;i < propertySignatures.length; i++) {
            const ps = propertySignatures[i][1];
            const name = ps.name;
            const hasKey = Object.prototype.hasOwnProperty.call(input, name);
            if (!hasKey) {
              if (ps.isOptional) {
                continue;
              } else if (isExact) {
                const e = new Pointer(name, input, new Missing(ps));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output));
                }
              }
            }
            const parser = propertySignatures[i][0];
            const te = parser(input[name], options);
            if (isEither4(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output));
                }
              }
              output[name] = te.right;
            } else {
              const nk = stepKey++;
              const index = name;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap11(either3(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps));
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, output2));
                  }
                }
                output2[index] = t.right;
                return _void;
              }));
            }
          }
          for (let i = 0;i < indexSignatures.length; i++) {
            const indexSignature = indexSignatures[i];
            const parameter = indexSignature[0];
            const type = indexSignature[1];
            const keys3 = getKeysForIndexSignature(input, indexSignature[2]);
            for (const key of keys3) {
              const keu = parameter(key, options);
              if (isEither4(keu) && isRight2(keu)) {
                const vpr = type(input[key], options);
                if (isEither4(vpr)) {
                  if (isLeft2(vpr)) {
                    const e = new Pointer(key, input, vpr.left);
                    if (allErrors) {
                      es.push([stepKey++, e]);
                      continue;
                    } else {
                      return left2(new Composite2(ast, input, e, output));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output[key] = vpr.right;
                    }
                  }
                } else {
                  const nk = stepKey++;
                  const index = key;
                  if (!queue) {
                    queue = [];
                  }
                  queue.push(({
                    es: es2,
                    output: output2
                  }) => flatMap11(either3(vpr), (tv) => {
                    if (isLeft2(tv)) {
                      const e = new Pointer(index, input, tv.left);
                      if (allErrors) {
                        es2.push([nk, e]);
                        return _void;
                      } else {
                        return left2(new Composite2(ast, input, e, output2));
                      }
                    } else {
                      if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                        output2[key] = tv.right;
                      }
                      return _void;
                    }
                  }));
                }
              }
            }
          }
          const computeResult = ({
            es: es2,
            output: output2
          }) => {
            if (isNonEmptyArray2(es2)) {
              return left2(new Composite2(ast, input, sortByIndex(es2), output2));
            }
            if (options?.propertyOrder === "original") {
              const keys3 = inputKeys || Reflect.ownKeys(input);
              for (const name of expectedKeys) {
                if (keys3.indexOf(name) === -1) {
                  keys3.push(name);
                }
              }
              const out = {};
              for (const key of keys3) {
                if (Object.prototype.hasOwnProperty.call(output2, key)) {
                  out[key] = output2[key];
                }
              }
              return right2(out);
            }
            return right2(output2);
          };
          if (queue && queue.length > 0) {
            const cqueue = queue;
            return suspend3(() => {
              const state = {
                es: copy(es),
                output: Object.assign({}, output)
              };
              return flatMap11(forEach6(cqueue, (f) => f(state), {
                concurrency,
                batching,
                discard: true
              }), () => computeResult(state));
            });
          }
          return computeResult({
            es,
            output
          });
        };
      }
      case "Union": {
        const searchTree = getSearchTree(ast.types, isDecoding);
        const ownKeys = Reflect.ownKeys(searchTree.keys);
        const ownKeysLen = ownKeys.length;
        const astTypesLen = ast.types.length;
        const map23 = new Map;
        for (let i = 0;i < astTypesLen; i++) {
          map23.set(ast.types[i], goMemo(ast.types[i], isDecoding));
        }
        const concurrency = getConcurrency(ast) ?? 1;
        const batching = getBatching(ast);
        return (input, options) => {
          const es = [];
          let stepKey = 0;
          let candidates = [];
          if (ownKeysLen > 0) {
            if (isRecordOrArray(input)) {
              for (let i = 0;i < ownKeysLen; i++) {
                const name = ownKeys[i];
                const buckets = searchTree.keys[name].buckets;
                if (Object.prototype.hasOwnProperty.call(input, name)) {
                  const literal = String(input[name]);
                  if (Object.prototype.hasOwnProperty.call(buckets, literal)) {
                    candidates = candidates.concat(buckets[literal]);
                  } else {
                    const {
                      candidates: candidates2,
                      literals
                    } = searchTree.keys[name];
                    const literalsUnion = Union.make(literals);
                    const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([new PropertySignature(name, literalsUnion, false, true)], []) : Union.make(candidates2);
                    es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Type2(literalsUnion, input[name])))]);
                  }
                } else {
                  const {
                    candidates: candidates2,
                    literals
                  } = searchTree.keys[name];
                  const fakePropertySignature = new PropertySignature(name, Union.make(literals), false, true);
                  const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates2);
                  es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
                }
              }
            } else {
              const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
              es.push([stepKey++, new Type2(errorAst, input)]);
            }
          }
          if (searchTree.otherwise.length > 0) {
            candidates = candidates.concat(searchTree.otherwise);
          }
          let queue = undefined;
          for (let i = 0;i < candidates.length; i++) {
            const candidate = candidates[i];
            const pr = map23.get(candidate)(input, options);
            if (isEither4(pr) && (!queue || queue.length === 0)) {
              if (isRight2(pr)) {
                return pr;
              } else {
                es.push([stepKey++, pr.left]);
              }
            } else {
              const nk = stepKey++;
              if (!queue) {
                queue = [];
              }
              queue.push((state) => suspend3(() => {
                if ("finalResult" in state) {
                  return _void;
                } else {
                  return flatMap11(either3(pr), (t) => {
                    if (isRight2(t)) {
                      state.finalResult = t;
                    } else {
                      state.es.push([nk, t.left]);
                    }
                    return _void;
                  });
                }
              }));
            }
          }
          const computeResult = (es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite2(ast, input, sortByIndex(es2))) : left2(new Type2(ast, input));
          if (queue && queue.length > 0) {
            const cqueue = queue;
            return suspend3(() => {
              const state = {
                es: copy(es)
              };
              return flatMap11(forEach6(cqueue, (f) => f(state), {
                concurrency,
                batching,
                discard: true
              }), () => {
                if ("finalResult" in state) {
                  return state.finalResult;
                }
                return computeResult(state.es);
              });
            });
          }
          return computeResult(es);
        };
      }
      case "Suspend": {
        const get17 = memoizeThunk(() => goMemo(ast.f(), isDecoding));
        return (a, options) => get17()(a, options);
      }
    }
  };
  var fromRefinement = (ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type2(ast, u));
  var getLiterals = (ast, isDecoding) => {
    switch (ast._tag) {
      case "Declaration": {
        const annotation = getSurrogateAnnotation(ast);
        if (isSome2(annotation)) {
          return getLiterals(annotation.value, isDecoding);
        }
        break;
      }
      case "TypeLiteral": {
        const out = [];
        for (let i = 0;i < ast.propertySignatures.length; i++) {
          const propertySignature = ast.propertySignatures[i];
          const type = isDecoding ? encodedAST(propertySignature.type) : typeAST(propertySignature.type);
          if (isLiteral(type) && !propertySignature.isOptional) {
            out.push([propertySignature.name, type]);
          }
        }
        return out;
      }
      case "TupleType": {
        const out = [];
        for (let i = 0;i < ast.elements.length; i++) {
          const element = ast.elements[i];
          const type = isDecoding ? encodedAST(element.type) : typeAST(element.type);
          if (isLiteral(type) && !element.isOptional) {
            out.push([i, type]);
          }
        }
        return out;
      }
      case "Refinement":
        return getLiterals(ast.from, isDecoding);
      case "Suspend":
        return getLiterals(ast.f(), isDecoding);
      case "Transformation":
        return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
    }
    return [];
  };
  var getSearchTree = (members, isDecoding) => {
    const keys3 = {};
    const otherwise = [];
    const candidates = [];
    for (let i = 0;i < members.length; i++) {
      const member = members[i];
      const tags = getLiterals(member, isDecoding);
      if (tags.length > 0) {
        candidates.push(member);
        for (let j = 0;j < tags.length; j++) {
          const [key, literal] = tags[j];
          const hash2 = String(literal.literal);
          keys3[key] = keys3[key] || {
            buckets: {},
            literals: [],
            candidates: []
          };
          const buckets = keys3[key].buckets;
          if (Object.prototype.hasOwnProperty.call(buckets, hash2)) {
            if (j < tags.length - 1) {
              continue;
            }
            buckets[hash2].push(member);
            keys3[key].literals.push(literal);
            keys3[key].candidates.push(member);
          } else {
            buckets[hash2] = [member];
            keys3[key].literals.push(literal);
            keys3[key].candidates.push(member);
            break;
          }
        }
      } else {
        otherwise.push(member);
      }
    }
    return {
      keys: keys3,
      otherwise,
      candidates
    };
  };
  var dropRightRefinement = (ast) => isRefinement(ast) ? dropRightRefinement(ast.from) : ast;
  var handleForbidden = (effect4, ast, actual, options) => {
    if (options?.isEffectAllowed === true) {
      return effect4;
    }
    if (isEither4(effect4)) {
      return effect4;
    }
    const scheduler = new SyncScheduler;
    const fiber = runFork2(effect4, {
      scheduler
    });
    scheduler.flush();
    const exit3 = fiber.unsafePoll();
    if (exit3) {
      if (isSuccess(exit3)) {
        return right2(exit3.value);
      }
      const cause3 = exit3.cause;
      if (isFailType2(cause3)) {
        return left2(cause3.error);
      }
      return left2(new Forbidden(ast, actual, pretty2(cause3)));
    }
    return left2(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
  };
  var compare = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0;
  function sortByIndex(es) {
    return es.sort(compare).map((t) => t[1]);
  }
  var getFinalTransformation = (transformation, isDecoding) => {
    switch (transformation._tag) {
      case "FinalTransformation":
        return isDecoding ? transformation.decode : transformation.encode;
      case "ComposeTransformation":
        return right2;
      case "TypeLiteralTransformation":
        return (input) => {
          let out = right2(input);
          for (const pst of transformation.propertySignatureTransformations) {
            const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
            const transformation2 = isDecoding ? pst.decode : pst.encode;
            const f = (input2) => {
              const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some2(input2[from]) : none2());
              delete input2[from];
              if (isSome2(o)) {
                input2[to] = o.value;
              }
              return input2;
            };
            out = map22(out, f);
          }
          return out;
        };
    }
  };
  var makeTree = (value, forest = []) => ({
    value,
    forest
  });
  var TreeFormatter = {
    formatIssue: (issue) => map22(formatTree(issue), drawTree),
    formatIssueSync: (issue) => {
      const e = TreeFormatter.formatIssue(issue);
      return isEither4(e) ? getOrThrow(e) : runSync(e);
    },
    formatError: (error) => TreeFormatter.formatIssue(error.issue),
    formatErrorSync: (error) => TreeFormatter.formatIssueSync(error.issue)
  };
  var drawTree = (tree) => tree.value + draw(`
`, tree.forest);
  var draw = (indentation, forest) => {
    let r = "";
    const len = forest.length;
    let tree;
    for (let i = 0;i < len; i++) {
      tree = forest[i];
      const isLast = i === len - 1;
      r += indentation + (isLast ? "" : "") + " " + tree.value;
      r += draw(indentation + (len > 1 && !isLast ? "  " : "   "), tree.forest);
    }
    return r;
  };
  var formatTransformationKind = (kind) => {
    switch (kind) {
      case "Encoded":
        return "Encoded side transformation failure";
      case "Transformation":
        return "Transformation process failure";
      case "Type":
        return "Type side transformation failure";
    }
  };
  var formatRefinementKind = (kind) => {
    switch (kind) {
      case "From":
        return "From side refinement failure";
      case "Predicate":
        return "Predicate refinement failure";
    }
  };
  var getAnnotated = (issue) => ("ast" in issue) ? some2(issue.ast) : none2();
  var Either_void = /* @__PURE__ */ right2(undefined);
  var getCurrentMessage = (issue) => getAnnotated(issue).pipe(flatMap(getMessageAnnotation), match2({
    onNone: () => Either_void,
    onSome: (messageAnnotation) => {
      const union9 = messageAnnotation(issue);
      if (isString(union9)) {
        return right2({
          message: union9,
          override: false
        });
      }
      if (isEffect2(union9)) {
        return map16(union9, (message) => ({
          message,
          override: false
        }));
      }
      if (isString(union9.message)) {
        return right2({
          message: union9.message,
          override: union9.override
        });
      }
      return map16(union9.message, (message) => ({
        message,
        override: union9.override
      }));
    }
  }));
  var createParseIssueGuard = (tag) => (issue) => issue._tag === tag;
  var isComposite2 = /* @__PURE__ */ createParseIssueGuard("Composite");
  var isRefinement2 = /* @__PURE__ */ createParseIssueGuard("Refinement");
  var isTransformation = /* @__PURE__ */ createParseIssueGuard("Transformation");
  var getMessage = (issue) => flatMap17(getCurrentMessage(issue), (currentMessage) => {
    if (currentMessage !== undefined) {
      const useInnerMessage = !currentMessage.override && (isComposite2(issue) || isRefinement2(issue) && issue.kind === "From" || isTransformation(issue) && issue.kind !== "Transformation");
      return useInnerMessage ? isTransformation(issue) || isRefinement2(issue) ? getMessage(issue.issue) : Either_void : right2(currentMessage.message);
    }
    return Either_void;
  });
  var getParseIssueTitleAnnotation2 = (issue) => getAnnotated(issue).pipe(flatMap(getParseIssueTitleAnnotation), flatMapNullable((annotation) => annotation(issue)), getOrUndefined);
  function getRefinementExpected(ast) {
    return getDescriptionAnnotation(ast).pipe(orElse(() => getTitleAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), orElse(() => getIdentifierAnnotation(ast)), getOrElse(() => `{ ${ast.from} | filter }`));
  }
  function getDefaultTypeMessage(issue) {
    if (issue.message !== undefined) {
      return issue.message;
    }
    const expected = isRefinement(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast);
    return `Expected ${expected}, actual ${formatUnknown(issue.actual)}`;
  }
  var formatTypeMessage = (issue) => map22(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation2(issue) ?? getDefaultTypeMessage(issue));
  var getParseIssueTitle = (issue) => getParseIssueTitleAnnotation2(issue) ?? String(issue.ast);
  var formatForbiddenMessage = (issue) => issue.message ?? "is forbidden";
  var formatUnexpectedMessage = (issue) => issue.message ?? "is unexpected";
  var formatMissingMessage = (issue) => {
    const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
    if (isSome2(missingMessageAnnotation)) {
      const annotation = missingMessageAnnotation.value();
      return isString(annotation) ? right2(annotation) : annotation;
    }
    return right2(issue.message ?? "is missing");
  };
  var formatTree = (issue) => {
    switch (issue._tag) {
      case "Type":
        return map22(formatTypeMessage(issue), makeTree);
      case "Forbidden":
        return right2(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
      case "Unexpected":
        return right2(makeTree(formatUnexpectedMessage(issue)));
      case "Missing":
        return map22(formatMissingMessage(issue), makeTree);
      case "Transformation":
        return flatMap17(getMessage(issue), (message) => {
          if (message !== undefined) {
            return right2(makeTree(message));
          }
          return map22(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
        });
      case "Refinement":
        return flatMap17(getMessage(issue), (message) => {
          if (message !== undefined) {
            return right2(makeTree(message));
          }
          return map22(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
        });
      case "Pointer":
        return map22(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
      case "Composite":
        return flatMap17(getMessage(issue), (message) => {
          if (message !== undefined) {
            return right2(makeTree(message));
          }
          const parseIssueTitle = getParseIssueTitle(issue);
          return isNonEmpty(issue.issues) ? map22(forEach6(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map22(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
        });
    }
  };
  // node_modules/effect/dist/esm/Struct.js
  var pick3 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys3) => {
    const out = {};
    for (const k of keys3) {
      if (k in s) {
        out[k] = s[k];
      }
    }
    return out;
  });
  var omit3 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys3) => {
    const out = {
      ...s
    };
    for (const k of keys3) {
      delete out[k];
    }
    return out;
  });

  // node_modules/effect/dist/esm/Schema.js
  var TypeId16 = /* @__PURE__ */ Symbol.for("effect/Schema");
  function make52(ast) {
    return class SchemaClass {
      [TypeId16] = variance7;
      static ast = ast;
      static annotations(annotations2) {
        return make52(mergeSchemaAnnotations(this.ast, annotations2));
      }
      static pipe() {
        return pipeArguments(this, arguments);
      }
      static toString() {
        return String(ast);
      }
      static Type;
      static Encoded;
      static Context;
      static [TypeId16] = variance7;
    };
  }
  var variance7 = {
    _A: (_) => _,
    _I: (_) => _,
    _R: (_) => _
  };
  var builtInAnnotations = {
    schemaId: SchemaIdAnnotationId,
    message: MessageAnnotationId,
    missingMessage: MissingMessageAnnotationId,
    identifier: IdentifierAnnotationId,
    title: TitleAnnotationId,
    description: DescriptionAnnotationId,
    examples: ExamplesAnnotationId,
    default: DefaultAnnotationId,
    documentation: DocumentationAnnotationId,
    jsonSchema: JSONSchemaAnnotationId,
    arbitrary: ArbitraryAnnotationId,
    pretty: PrettyAnnotationId,
    equivalence: EquivalenceAnnotationId,
    concurrency: ConcurrencyAnnotationId,
    batching: BatchingAnnotationId,
    parseIssueTitle: ParseIssueTitleAnnotationId,
    parseOptions: ParseOptionsAnnotationId,
    decodingFallback: DecodingFallbackAnnotationId
  };
  var toASTAnnotations = (annotations2) => {
    if (!annotations2) {
      return {};
    }
    const out = {
      ...annotations2
    };
    for (const key in builtInAnnotations) {
      if (key in annotations2) {
        const id2 = builtInAnnotations[key];
        out[id2] = annotations2[key];
        delete out[key];
      }
    }
    return out;
  };
  var mergeSchemaAnnotations = (ast, annotations2) => annotations(ast, toASTAnnotations(annotations2));
  var isSchema = (u) => hasProperty(u, TypeId16) && isObject(u[TypeId16]);
  function getDefaultLiteralAST(literals) {
    return isMembers(literals) ? Union.make(mapMembers(literals, (literal) => new Literal(literal))) : new Literal(literals[0]);
  }
  function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
    return class LiteralClass extends make52(ast) {
      static annotations(annotations2) {
        return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations2));
      }
      static literals = [...literals];
    };
  }
  function Literal2(...literals) {
    return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
  }
  var declareConstructor = (typeParameters, options, annotations2) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options.decode(...typeParameters2.map(make52)), (...typeParameters2) => options.encode(...typeParameters2.map(make52)), toASTAnnotations(annotations2)));
  var declarePrimitive = (is2, annotations2) => {
    const decodeUnknown2 = () => (input, _, ast) => is2(input) ? succeed15(input) : fail16(new Type2(ast, input));
    const encodeUnknown2 = decodeUnknown2;
    return makeDeclareClass([], new Declaration([], decodeUnknown2, encodeUnknown2, toASTAnnotations(annotations2)));
  };
  function makeDeclareClass(typeParameters, ast) {
    return class DeclareClass extends make52(ast) {
      static annotations(annotations2) {
        return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations2));
      }
      static typeParameters = [...typeParameters];
    };
  }
  var declare = function() {
    if (Array.isArray(arguments[0])) {
      const typeParameters = arguments[0];
      const options = arguments[1];
      const annotations3 = arguments[2];
      return declareConstructor(typeParameters, options, annotations3);
    }
    const is2 = arguments[0];
    const annotations2 = arguments[1];
    return declarePrimitive(is2, annotations2);
  };
  class Undefined extends (/* @__PURE__ */ make52(undefinedKeyword)) {
  }
  class Never extends (/* @__PURE__ */ make52(neverKeyword)) {
  }

  class Unknown extends (/* @__PURE__ */ make52(unknownKeyword)) {
  }
  class String$ extends (/* @__PURE__ */ make52(stringKeyword)) {
  }

  class Number$ extends (/* @__PURE__ */ make52(numberKeyword)) {
  }

  class Boolean$ extends (/* @__PURE__ */ make52(booleanKeyword)) {
  }
  var getDefaultUnionAST = (members) => Union.make(members.map((m) => m.ast));
  function makeUnionClass(members, ast = getDefaultUnionAST(members)) {
    return class UnionClass extends make52(ast) {
      static annotations(annotations2) {
        return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations2));
      }
      static members = [...members];
    };
  }
  function Union2(...members) {
    return isMembers(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never;
  }
  var UndefinedOr = (self) => Union2(self, Undefined);
  var getDefaultTupleTypeAST = (elements, rest) => new TupleType(elements.map((el) => isSchema(el) ? new OptionalType(el.ast, false) : el.ast), rest.map((el) => isSchema(el) ? new Type(el.ast) : el.ast), true);
  function makeTupleTypeClass(elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) {
    return class TupleTypeClass extends make52(ast) {
      static annotations(annotations2) {
        return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations2));
      }
      static elements = [...elements];
      static rest = [...rest];
    };
  }
  function makeArrayClass(value, ast) {
    return class ArrayClass extends makeTupleTypeClass([], [value], ast) {
      static annotations(annotations2) {
        return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations2));
      }
      static value = value;
    };
  }
  var Array$ = (value) => makeArrayClass(value);
  var formatPropertySignatureToken = (isOptional) => isOptional ? '"?:"' : '":"';

  class PropertySignatureDeclaration extends OptionalType {
    isReadonly;
    defaultValue;
    _tag = "PropertySignatureDeclaration";
    constructor(type, isOptional, isReadonly, annotations2, defaultValue) {
      super(type, isOptional, annotations2);
      this.isReadonly = isReadonly;
      this.defaultValue = defaultValue;
    }
    toString() {
      const token = formatPropertySignatureToken(this.isOptional);
      const type = String(this.type);
      return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`;
    }
  }
  class ToPropertySignature extends OptionalType {
    isReadonly;
    defaultValue;
    constructor(type, isOptional, isReadonly, annotations2, defaultValue) {
      super(type, isOptional, annotations2);
      this.isReadonly = isReadonly;
      this.defaultValue = defaultValue;
    }
  }
  var formatPropertyKey2 = (p) => {
    if (p === undefined) {
      return "never";
    }
    if (isString(p)) {
      return JSON.stringify(p);
    }
    return String(p);
  };

  class PropertySignatureTransformation2 {
    from;
    to;
    decode;
    encode;
    _tag = "PropertySignatureTransformation";
    constructor(from, to, decode2, encode) {
      this.from = from;
      this.to = to;
      this.decode = decode2;
      this.encode = encode;
    }
    toString() {
      return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey2(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
    }
  }
  var mergeSignatureAnnotations = (ast, annotations2) => {
    switch (ast._tag) {
      case "PropertySignatureDeclaration": {
        return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
          ...ast.annotations,
          ...annotations2
        }, ast.defaultValue);
      }
      case "PropertySignatureTransformation": {
        return new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
          ...ast.to.annotations,
          ...annotations2
        }, ast.to.defaultValue), ast.decode, ast.encode);
      }
    }
  };
  var PropertySignatureTypeId = /* @__PURE__ */ Symbol.for("effect/PropertySignature");
  var isPropertySignature = (u) => hasProperty(u, PropertySignatureTypeId);

  class PropertySignatureImpl {
    ast;
    [TypeId16];
    [PropertySignatureTypeId] = null;
    _TypeToken;
    _Key;
    _EncodedToken;
    _HasDefault;
    constructor(ast) {
      this.ast = ast;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    annotations(annotations2) {
      return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations2)));
    }
    toString() {
      return String(this.ast);
    }
  }
  class PropertySignatureWithFromImpl extends PropertySignatureImpl {
    from;
    constructor(ast, from) {
      super(ast);
      this.from = from;
    }
    annotations(annotations2) {
      return new PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations2)), this.from);
    }
  }
  var optional = (self) => {
    const ast = self.ast === undefinedKeyword || self.ast === neverKeyword ? undefinedKeyword : UndefinedOr(self).ast;
    return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, undefined), self);
  };
  var preserveMissingMessageAnnotation = /* @__PURE__ */ pickAnnotations([MissingMessageAnnotationId]);
  var getDefaultTypeLiteralAST = (fields, records) => {
    const ownKeys = Reflect.ownKeys(fields);
    const pss = [];
    if (ownKeys.length > 0) {
      const from = [];
      const to = [];
      const transformations = [];
      for (let i = 0;i < ownKeys.length; i++) {
        const key = ownKeys[i];
        const field = fields[key];
        if (isPropertySignature(field)) {
          const ast = field.ast;
          switch (ast._tag) {
            case "PropertySignatureDeclaration": {
              const type = ast.type;
              const isOptional = ast.isOptional;
              const toAnnotations = ast.annotations;
              from.push(new PropertySignature(key, type, isOptional, true, preserveMissingMessageAnnotation(ast)));
              to.push(new PropertySignature(key, typeAST(type), isOptional, true, toAnnotations));
              pss.push(new PropertySignature(key, type, isOptional, true, toAnnotations));
              break;
            }
            case "PropertySignatureTransformation": {
              const fromKey = ast.from.fromKey ?? key;
              from.push(new PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
              to.push(new PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
              transformations.push(new PropertySignatureTransformation(fromKey, key, ast.decode, ast.encode));
              break;
            }
          }
        } else {
          from.push(new PropertySignature(key, field.ast, false, true));
          to.push(new PropertySignature(key, typeAST(field.ast), false, true));
          pss.push(new PropertySignature(key, field.ast, false, true));
        }
      }
      if (isNonEmptyReadonlyArray(transformations)) {
        const issFrom = [];
        const issTo = [];
        for (const r of records) {
          const {
            indexSignatures,
            propertySignatures
          } = record(r.key.ast, r.value.ast);
          propertySignatures.forEach((ps) => {
            from.push(ps);
            to.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
          });
          indexSignatures.forEach((is2) => {
            issFrom.push(is2);
            issTo.push(new IndexSignature(is2.parameter, typeAST(is2.type), is2.isReadonly));
          });
        }
        return new Transformation(new TypeLiteral(from, issFrom, {
          [AutoTitleAnnotationId]: "Struct (Encoded side)"
        }), new TypeLiteral(to, issTo, {
          [AutoTitleAnnotationId]: "Struct (Type side)"
        }), new TypeLiteralTransformation(transformations));
      }
    }
    const iss = [];
    for (const r of records) {
      const {
        indexSignatures,
        propertySignatures
      } = record(r.key.ast, r.value.ast);
      propertySignatures.forEach((ps) => pss.push(ps));
      indexSignatures.forEach((is2) => iss.push(is2));
    }
    return new TypeLiteral(pss, iss);
  };
  var lazilyMergeDefaults = (fields, out) => {
    const ownKeys = Reflect.ownKeys(fields);
    for (const key of ownKeys) {
      const field = fields[key];
      if (out[key] === undefined && isPropertySignature(field)) {
        const ast = field.ast;
        const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
        if (defaultValue !== undefined) {
          out[key] = defaultValue();
        }
      }
    }
    return out;
  };
  function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
    return class TypeLiteralClass extends make52(ast) {
      static annotations(annotations2) {
        return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations2));
      }
      static fields = {
        ...fields
      };
      static records = [...records];
      static make = (props, options) => {
        const propsWithDefaults = lazilyMergeDefaults(fields, {
          ...props
        });
        return getDisableValidationMakeOption(options) ? propsWithDefaults : validateSync(this)(propsWithDefaults);
      };
      static pick(...keys3) {
        return Struct(pick3(fields, ...keys3));
      }
      static omit(...keys3) {
        return Struct(omit3(fields, ...keys3));
      }
    };
  }
  function Struct(fields, ...records) {
    return makeTypeLiteralClass(fields, records);
  }
  function makeRecordClass(key, value, ast) {
    return class RecordClass extends makeTypeLiteralClass({}, [{
      key,
      value
    }], ast) {
      static annotations(annotations2) {
        return makeRecordClass(key, value, mergeSchemaAnnotations(this.ast, annotations2));
      }
      static key = key;
      static value = value;
    };
  }
  var Record = (options) => makeRecordClass(options.key, options.value);
  var RefineSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Refine");
  function makeRefineClass(from, filter10, ast) {
    return class RefineClass extends make52(ast) {
      static annotations(annotations2) {
        return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations2));
      }
      static [RefineSchemaId] = from;
      static from = from;
      static filter = filter10;
      static make = (a, options) => {
        return getDisableValidationMakeOption(options) ? a : validateSync(this)(a);
      };
    };
  }
  var fromFilterPredicateReturnTypeItem = (item, ast, input) => {
    if (isBoolean(item)) {
      return item ? none2() : some2(new Type2(ast, input));
    }
    if (isString(item)) {
      return some2(new Type2(ast, input, item));
    }
    if (item !== undefined) {
      if ("_tag" in item) {
        return some2(item);
      }
      const issue = new Type2(ast, input, item.message);
      return some2(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
    }
    return none2();
  };
  var toFilterParseIssue = (out, ast, input) => {
    if (isSingle(out)) {
      return fromFilterPredicateReturnTypeItem(out, ast, input);
    }
    if (isNonEmptyReadonlyArray(out)) {
      const issues = filterMap(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
      if (isNonEmptyReadonlyArray(issues)) {
        return some2(issues.length === 1 ? issues[0] : new Composite2(ast, input, issues));
      }
    }
    return none2();
  };
  function filter10(predicate, annotations2) {
    return (self) => {
      function filter11(input, options, ast2) {
        return toFilterParseIssue(predicate(input, options, ast2), ast2, input);
      }
      const ast = new Refinement(self.ast, filter11, toASTAnnotations(annotations2));
      return makeRefineClass(self, filter11, ast);
    };
  }
  var PatternSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Pattern");
  var pattern = (regex, annotations2) => (self) => {
    const source = regex.source;
    return self.pipe(filter10((a) => {
      regex.lastIndex = 0;
      return regex.test(a);
    }, {
      schemaId: PatternSchemaId,
      [PatternSchemaId]: {
        regex
      },
      description: `a string matching the pattern ${source}`,
      jsonSchema: {
        pattern: source
      },
      ...annotations2
    }));
  };
  var UUIDSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/UUID");
  var uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;

  class UUID extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ pattern(uuidRegexp, {
    schemaId: UUIDSchemaId,
    identifier: "UUID",
    jsonSchema: {
      format: "uuid",
      pattern: uuidRegexp.source
    },
    description: "a Universally Unique Identifier",
    arbitrary: () => (fc) => fc.uuid()
  }))) {
  }
  var GreaterThanSchemaId2 = GreaterThanSchemaId;
  var greaterThan4 = (exclusiveMinimum, annotations2) => (self) => self.pipe(filter10((a) => a > exclusiveMinimum, {
    schemaId: GreaterThanSchemaId2,
    title: `greaterThan(${exclusiveMinimum})`,
    description: exclusiveMinimum === 0 ? "a positive number" : `a number greater than ${exclusiveMinimum}`,
    jsonSchema: {
      exclusiveMinimum
    },
    ...annotations2
  }));
  var IntSchemaId2 = IntSchemaId;
  var int = (annotations2) => (self) => self.pipe(filter10((a) => Number.isSafeInteger(a), {
    schemaId: IntSchemaId2,
    title: "int",
    description: "an integer",
    jsonSchema: {
      type: "integer"
    },
    ...annotations2
  }));
  var positive = (annotations2) => greaterThan4(0, {
    title: "positive",
    ...annotations2
  });
  var DateFromSelfSchemaId2 = DateFromSelfSchemaId;

  class DateFromSelf extends (/* @__PURE__ */ declare(isDate, {
    identifier: "DateFromSelf",
    schemaId: DateFromSelfSchemaId2,
    [DateFromSelfSchemaId2]: {
      noInvalidDate: false
    },
    description: "a potentially invalid Date instance",
    pretty: () => (date) => `new Date(${JSON.stringify(date)})`,
    arbitrary: () => (fc) => fc.date({
      noInvalidDate: false
    }),
    equivalence: () => Date2
  })) {
  }
  function getDisableValidationMakeOption(options) {
    return isBoolean(options) ? options : options?.disableValidation ?? false;
  }
  // node_modules/effect/dist/esm/Stream.js
  var exports_Stream = {};
  __export(exports_Stream, {
    zipWithPreviousAndNext: () => zipWithPreviousAndNext2,
    zipWithPrevious: () => zipWithPrevious2,
    zipWithNext: () => zipWithNext2,
    zipWithIndex: () => zipWithIndex2,
    zipWithChunks: () => zipWithChunks2,
    zipWith: () => zipWith11,
    zipRight: () => zipRight9,
    zipLeft: () => zipLeft6,
    zipLatestWith: () => zipLatestWith2,
    zipLatestAll: () => zipLatestAll2,
    zipLatest: () => zipLatest2,
    zipFlatten: () => zipFlatten2,
    zipAllWith: () => zipAllWith2,
    zipAllSortedByKeyWith: () => zipAllSortedByKeyWith2,
    zipAllSortedByKeyRight: () => zipAllSortedByKeyRight2,
    zipAllSortedByKeyLeft: () => zipAllSortedByKeyLeft2,
    zipAllSortedByKey: () => zipAllSortedByKey2,
    zipAllRight: () => zipAllRight2,
    zipAllLeft: () => zipAllLeft2,
    zipAll: () => zipAll2,
    zip: () => zip8,
    withSpan: () => withSpan7,
    withExecutionPlan: () => withExecutionPlan4,
    whenEffect: () => whenEffect4,
    whenCaseEffect: () => whenCaseEffect2,
    whenCase: () => whenCase2,
    when: () => when4,
    void: () => void_8,
    updateService: () => updateService5,
    unwrapScopedWith: () => unwrapScopedWith4,
    unwrapScoped: () => unwrapScoped5,
    unwrap: () => unwrap3,
    unfoldEffect: () => unfoldEffect2,
    unfoldChunkEffect: () => unfoldChunkEffect2,
    unfoldChunk: () => unfoldChunk2,
    unfold: () => unfold4,
    transduce: () => transduce2,
    toReadableStreamRuntime: () => toReadableStreamRuntime2,
    toReadableStreamEffect: () => toReadableStreamEffect2,
    toReadableStream: () => toReadableStream2,
    toQueueOfElements: () => toQueueOfElements2,
    toQueue: () => toQueue3,
    toPull: () => toPull3,
    toPubSub: () => toPubSub3,
    toChannel: () => toChannel3,
    toAsyncIterableRuntime: () => toAsyncIterableRuntime2,
    toAsyncIterableEffect: () => toAsyncIterableEffect2,
    toAsyncIterable: () => toAsyncIterable2,
    timeoutTo: () => timeoutTo4,
    timeoutFailCause: () => timeoutFailCause4,
    timeoutFail: () => timeoutFail4,
    timeout: () => timeout4,
    tick: () => tick2,
    throttleEffect: () => throttleEffect2,
    throttle: () => throttle2,
    tapSink: () => tapSink2,
    tapErrorCause: () => tapErrorCause6,
    tapError: () => tapError6,
    tapBoth: () => tapBoth4,
    tap: () => tap7,
    takeWhile: () => takeWhile5,
    takeUntilEffect: () => takeUntilEffect2,
    takeUntil: () => takeUntil4,
    takeRight: () => takeRight3,
    take: () => take8,
    sync: () => sync9,
    suspend: () => suspend10,
    succeed: () => succeed16,
    splitOnChunk: () => splitOnChunk2,
    splitLines: () => splitLines3,
    split: () => split2,
    someOrFail: () => someOrFail2,
    someOrElse: () => someOrElse2,
    some: () => some6,
    slidingSize: () => slidingSize2,
    sliding: () => sliding8,
    share: () => share2,
    scopedWith: () => scopedWith5,
    scoped: () => scoped6,
    scheduleWith: () => scheduleWith2,
    schedule: () => schedule3,
    scanReduceEffect: () => scanReduceEffect2,
    scanReduce: () => scanReduce2,
    scanEffect: () => scanEffect2,
    scan: () => scan2,
    runSum: () => runSum2,
    runScoped: () => runScoped3,
    runLast: () => runLast2,
    runIntoQueueScoped: () => runIntoQueueScoped2,
    runIntoQueueElementsScoped: () => runIntoQueueElementsScoped2,
    runIntoQueue: () => runIntoQueue2,
    runIntoPubSubScoped: () => runIntoPubSubScoped2,
    runIntoPubSub: () => runIntoPubSub2,
    runHead: () => runHead2,
    runForEachWhileScoped: () => runForEachWhileScoped2,
    runForEachWhile: () => runForEachWhile2,
    runForEachScoped: () => runForEachScoped2,
    runForEachChunkScoped: () => runForEachChunkScoped2,
    runForEachChunk: () => runForEachChunk2,
    runForEach: () => runForEach2,
    runFoldWhileScopedEffect: () => runFoldWhileScopedEffect2,
    runFoldWhileScoped: () => runFoldWhileScoped2,
    runFoldWhileEffect: () => runFoldWhileEffect2,
    runFoldWhile: () => runFoldWhile2,
    runFoldScopedEffect: () => runFoldScopedEffect2,
    runFoldScoped: () => runFoldScoped2,
    runFoldEffect: () => runFoldEffect2,
    runFold: () => runFold2,
    runDrain: () => runDrain3,
    runCount: () => runCount2,
    runCollect: () => runCollect2,
    run: () => run4,
    retry: () => retry7,
    repeatWith: () => repeatWith2,
    repeatValue: () => repeatValue2,
    repeatElementsWith: () => repeatElementsWith2,
    repeatElements: () => repeatElements2,
    repeatEither: () => repeatEither2,
    repeatEffectWithSchedule: () => repeatEffectWithSchedule2,
    repeatEffectOption: () => repeatEffectOption2,
    repeatEffectChunkOption: () => repeatEffectChunkOption2,
    repeatEffectChunk: () => repeatEffectChunk2,
    repeatEffect: () => repeatEffect2,
    repeat: () => repeat3,
    refineOrDieWith: () => refineOrDieWith2,
    refineOrDie: () => refineOrDie2,
    rechunk: () => rechunk2,
    range: () => range3,
    raceAll: () => raceAll4,
    race: () => race4,
    provideSomeLayer: () => provideSomeLayer3,
    provideSomeContext: () => provideSomeContext3,
    provideServiceStream: () => provideServiceStream2,
    provideServiceEffect: () => provideServiceEffect4,
    provideService: () => provideService6,
    provideLayer: () => provideLayer2,
    provideContext: () => provideContext6,
    prepend: () => prepend5,
    pipeThroughChannelOrFail: () => pipeThroughChannelOrFail2,
    pipeThroughChannel: () => pipeThroughChannel2,
    pipeThrough: () => pipeThrough2,
    peel: () => peel2,
    partitionEither: () => partitionEither2,
    partition: () => partition6,
    paginateEffect: () => paginateEffect2,
    paginateChunkEffect: () => paginateChunkEffect2,
    paginateChunk: () => paginateChunk2,
    paginate: () => paginate2,
    orElseSucceed: () => orElseSucceed4,
    orElseIfEmptyStream: () => orElseIfEmptyStream2,
    orElseIfEmptyChunk: () => orElseIfEmptyChunk2,
    orElseIfEmpty: () => orElseIfEmpty2,
    orElseFail: () => orElseFail4,
    orElseEither: () => orElseEither4,
    orElse: () => orElse10,
    orDieWith: () => orDieWith5,
    orDie: () => orDie6,
    onStart: () => onStart2,
    onError: () => onError4,
    onEnd: () => onEnd2,
    onDone: () => onDone2,
    never: () => never5,
    mkString: () => mkString3,
    mergeWithTag: () => mergeWithTag2,
    mergeWith: () => mergeWith4,
    mergeRight: () => mergeRight2,
    mergeLeft: () => mergeLeft2,
    mergeEither: () => mergeEither2,
    mergeAll: () => mergeAll9,
    merge: () => merge10,
    mapInputContext: () => mapInputContext6,
    mapErrorCause: () => mapErrorCause5,
    mapError: () => mapError8,
    mapEffect: () => mapEffect4,
    mapConcatEffect: () => mapConcatEffect2,
    mapConcatChunkEffect: () => mapConcatChunkEffect2,
    mapConcatChunk: () => mapConcatChunk2,
    mapConcat: () => mapConcat2,
    mapChunksEffect: () => mapChunksEffect2,
    mapChunks: () => mapChunks2,
    mapBoth: () => mapBoth8,
    mapAccumEffect: () => mapAccumEffect2,
    mapAccum: () => mapAccum6,
    map: () => map23,
    make: () => make53,
    let: () => let_5,
    iterate: () => iterate4,
    intersperseAffixes: () => intersperseAffixes2,
    intersperse: () => intersperse2,
    interruptWhenDeferred: () => interruptWhenDeferred3,
    interruptWhen: () => interruptWhen3,
    interruptAfter: () => interruptAfter2,
    interleaveWith: () => interleaveWith2,
    interleave: () => interleave2,
    identity: () => identity3,
    haltWhenDeferred: () => haltWhenDeferred2,
    haltWhen: () => haltWhen2,
    haltAfter: () => haltAfter2,
    groupedWithin: () => groupedWithin2,
    grouped: () => grouped2,
    groupByKey: () => groupByKey2,
    groupBy: () => groupBy2,
    groupAdjacentBy: () => groupAdjacentBy2,
    fromTQueue: () => fromTQueue2,
    fromTPubSub: () => fromTPubSub2,
    fromSchedule: () => fromSchedule2,
    fromReadableStreamByob: () => fromReadableStreamByob2,
    fromReadableStream: () => fromReadableStream2,
    fromQueue: () => fromQueue3,
    fromPull: () => fromPull3,
    fromPubSub: () => fromPubSub2,
    fromIteratorSucceed: () => fromIteratorSucceed2,
    fromIterableEffect: () => fromIterableEffect2,
    fromIterable: () => fromIterable10,
    fromEventListener: () => fromEventListener2,
    fromEffectOption: () => fromEffectOption2,
    fromEffect: () => fromEffect8,
    fromChunks: () => fromChunks2,
    fromChunkQueue: () => fromChunkQueue2,
    fromChunkPubSub: () => fromChunkPubSub2,
    fromChunk: () => fromChunk2,
    fromChannel: () => fromChannel3,
    fromAsyncIterable: () => fromAsyncIterable2,
    forever: () => forever6,
    flattenTake: () => flattenTake2,
    flattenIterables: () => flattenIterables2,
    flattenExitOption: () => flattenExitOption2,
    flattenEffect: () => flattenEffect2,
    flattenChunks: () => flattenChunks2,
    flatten: () => flatten14,
    flatMap: () => flatMap18,
    findEffect: () => findEffect2,
    find: () => find3,
    finalizer: () => finalizer2,
    filterMapWhileEffect: () => filterMapWhileEffect2,
    filterMapWhile: () => filterMapWhile4,
    filterMapEffect: () => filterMapEffect2,
    filterMap: () => filterMap7,
    filterEffect: () => filterEffect2,
    filter: () => filter11,
    failSync: () => failSync8,
    failCauseSync: () => failCauseSync7,
    failCause: () => failCause14,
    fail: () => fail17,
    execute: () => execute2,
    ensuringWith: () => ensuringWith3,
    ensuring: () => ensuring7,
    encodeText: () => encodeText2,
    empty: () => empty30,
    either: () => either6,
    dropWhileEffect: () => dropWhileEffect2,
    dropWhile: () => dropWhile5,
    dropUntilEffect: () => dropUntilEffect2,
    dropUntil: () => dropUntil4,
    dropRight: () => dropRight2,
    drop: () => drop4,
    drainFork: () => drainFork2,
    drain: () => drain4,
    distributedWithDynamic: () => distributedWithDynamic2,
    distributedWith: () => distributedWith2,
    dieSync: () => dieSync7,
    dieMessage: () => dieMessage5,
    die: () => die11,
    decodeText: () => decodeText2,
    debounce: () => debounce2,
    crossWith: () => crossWith2,
    crossRight: () => crossRight2,
    crossLeft: () => crossLeft2,
    cross: () => cross2,
    contextWithStream: () => contextWithStream2,
    contextWithEffect: () => contextWithEffect4,
    contextWith: () => contextWith4,
    context: () => context6,
    concatAll: () => concatAll3,
    concat: () => concat3,
    combineChunks: () => combineChunks2,
    combine: () => combine10,
    chunksWith: () => chunksWith2,
    chunks: () => chunks2,
    changesWithEffect: () => changesWithEffect2,
    changesWith: () => changesWith2,
    changes: () => changes2,
    catchTags: () => catchTags4,
    catchTag: () => catchTag4,
    catchSomeCause: () => catchSomeCause4,
    catchSome: () => catchSome4,
    catchAllCause: () => catchAllCause7,
    catchAll: () => catchAll8,
    bufferChunks: () => bufferChunks2,
    buffer: () => buffer2,
    broadcastedQueuesDynamic: () => broadcastedQueuesDynamic2,
    broadcastedQueues: () => broadcastedQueues2,
    broadcastDynamic: () => broadcastDynamic2,
    broadcast: () => broadcast2,
    branchAfter: () => branchAfter2,
    bindTo: () => bindTo5,
    bindEffect: () => bindEffect2,
    bind: () => bind5,
    asyncScoped: () => asyncScoped2,
    asyncPush: () => asyncPush2,
    asyncEffect: () => asyncEffect4,
    async: () => _async2,
    as: () => as8,
    aggregateWithinEither: () => aggregateWithinEither2,
    aggregateWithin: () => aggregateWithin2,
    aggregate: () => aggregate2,
    acquireRelease: () => acquireRelease4,
    accumulateChunks: () => accumulateChunks2,
    accumulate: () => accumulate2,
    StreamTypeId: () => StreamTypeId3,
    Do: () => Do4,
    DefaultChunkSize: () => DefaultChunkSize2
  });
  var StreamTypeId3 = StreamTypeId2;
  var DefaultChunkSize2 = DefaultChunkSize;
  var accumulate2 = accumulate;
  var accumulateChunks2 = accumulateChunks;
  var acquireRelease4 = acquireRelease3;
  var aggregate2 = aggregate;
  var aggregateWithin2 = aggregateWithin;
  var aggregateWithinEither2 = aggregateWithinEither;
  var as8 = as7;
  var _async2 = _async;
  var asyncEffect4 = asyncEffect3;
  var asyncPush2 = asyncPush;
  var asyncScoped2 = asyncScoped;
  var branchAfter2 = branchAfter;
  var broadcast2 = broadcast;
  var share2 = share;
  var broadcastDynamic2 = broadcastDynamic;
  var broadcastedQueues2 = broadcastedQueues;
  var broadcastedQueuesDynamic2 = broadcastedQueuesDynamic;
  var buffer2 = buffer;
  var bufferChunks2 = bufferChunks;
  var catchAll8 = catchAll7;
  var catchAllCause7 = catchAllCause6;
  var catchSome4 = catchSome3;
  var catchTag4 = catchTag3;
  var catchTags4 = catchTags3;
  var catchSomeCause4 = catchSomeCause3;
  var changes2 = changes;
  var changesWith2 = changesWith;
  var changesWithEffect2 = changesWithEffect;
  var chunks2 = chunks;
  var chunksWith2 = chunksWith;
  var combine10 = combine9;
  var combineChunks2 = combineChunks;
  var concat3 = concat2;
  var concatAll3 = concatAll2;
  var cross2 = cross;
  var crossLeft2 = crossLeft;
  var crossRight2 = crossRight;
  var crossWith2 = crossWith;
  var debounce2 = debounce;
  var die11 = die10;
  var dieSync7 = dieSync6;
  var dieMessage5 = dieMessage4;
  var distributedWith2 = distributedWith;
  var distributedWithDynamic2 = distributedWithDynamic;
  var drain4 = drain3;
  var drainFork2 = drainFork;
  var drop4 = drop3;
  var dropRight2 = dropRight;
  var dropUntil4 = dropUntil3;
  var dropUntilEffect2 = dropUntilEffect;
  var dropWhile5 = dropWhile4;
  var dropWhileEffect2 = dropWhileEffect;
  var either6 = either5;
  var empty30 = empty29;
  var ensuring7 = ensuring6;
  var ensuringWith3 = ensuringWith2;
  var context6 = context5;
  var contextWith4 = contextWith3;
  var contextWithEffect4 = contextWithEffect3;
  var contextWithStream2 = contextWithStream;
  var execute2 = execute;
  var fail17 = fail15;
  var failSync8 = failSync7;
  var failCause14 = failCause13;
  var failCauseSync7 = failCauseSync6;
  var filter11 = filter8;
  var filterEffect2 = filterEffect;
  var filterMap7 = filterMap6;
  var filterMapEffect2 = filterMapEffect;
  var filterMapWhile4 = filterMapWhile3;
  var filterMapWhileEffect2 = filterMapWhileEffect;
  var finalizer2 = finalizer;
  var find3 = find2;
  var findEffect2 = findEffect;
  var flatMap18 = flatMap16;
  var flatten14 = flatten13;
  var flattenChunks2 = flattenChunks;
  var flattenEffect2 = flattenEffect;
  var flattenExitOption2 = flattenExitOption;
  var flattenIterables2 = flattenIterables;
  var flattenTake2 = flattenTake;
  var forever6 = forever5;
  var fromAsyncIterable2 = fromAsyncIterable;
  var fromChannel3 = fromChannel2;
  var toChannel3 = toChannel2;
  var fromChunk2 = fromChunk;
  var fromChunkPubSub2 = fromChunkPubSub;
  var fromChunkQueue2 = fromChunkQueue;
  var fromChunks2 = fromChunks;
  var fromEffect8 = fromEffect7;
  var fromEffectOption2 = fromEffectOption;
  var fromPubSub2 = fromPubSub;
  var fromTPubSub2 = fromTPubSub;
  var fromIterable10 = fromIterable9;
  var fromIterableEffect2 = fromIterableEffect;
  var fromIteratorSucceed2 = fromIteratorSucceed;
  var fromPull3 = fromPull2;
  var fromQueue3 = fromQueue2;
  var fromTQueue2 = fromTQueue;
  var fromReadableStream2 = fromReadableStream;
  var fromReadableStreamByob2 = fromReadableStreamByob;
  var fromSchedule2 = fromSchedule;
  var groupAdjacentBy2 = groupAdjacentBy;
  var groupBy2 = groupBy;
  var groupByKey2 = groupByKey;
  var grouped2 = grouped;
  var groupedWithin2 = groupedWithin;
  var haltAfter2 = haltAfter;
  var haltWhen2 = haltWhen;
  var haltWhenDeferred2 = haltWhenDeferred;
  var identity3 = identityStream;
  var interleave2 = interleave;
  var interleaveWith2 = interleaveWith;
  var intersperse2 = intersperse;
  var intersperseAffixes2 = intersperseAffixes;
  var interruptAfter2 = interruptAfter;
  var interruptWhen3 = interruptWhen2;
  var interruptWhenDeferred3 = interruptWhenDeferred2;
  var iterate4 = iterate3;
  var make53 = make50;
  var map23 = map21;
  var mapAccum6 = mapAccum5;
  var mapAccumEffect2 = mapAccumEffect;
  var mapBoth8 = mapBoth5;
  var mapChunks2 = mapChunks;
  var mapChunksEffect2 = mapChunksEffect;
  var mapConcat2 = mapConcat;
  var mapConcatChunk2 = mapConcatChunk;
  var mapConcatChunkEffect2 = mapConcatChunkEffect;
  var mapConcatEffect2 = mapConcatEffect;
  var mapEffect4 = mapEffectOptions;
  var mapError8 = mapError6;
  var mapErrorCause5 = mapErrorCause4;
  var merge10 = merge9;
  var mergeAll9 = mergeAll8;
  var mergeWithTag2 = mergeWithTag;
  var mergeWith4 = mergeWith3;
  var mergeEither2 = mergeEither;
  var mergeLeft2 = mergeLeft;
  var mergeRight2 = mergeRight;
  var mkString3 = mkString2;
  var never5 = never4;
  var onEnd2 = onEnd;
  var onError4 = onError3;
  var onDone2 = onDone;
  var onStart2 = onStart;
  var orDie6 = orDie5;
  var orDieWith5 = orDieWith4;
  var orElse10 = orElse8;
  var orElseEither4 = orElseEither3;
  var orElseFail4 = orElseFail3;
  var orElseIfEmpty2 = orElseIfEmpty;
  var orElseIfEmptyChunk2 = orElseIfEmptyChunk;
  var orElseIfEmptyStream2 = orElseIfEmptyStream;
  var orElseSucceed4 = orElseSucceed3;
  var paginate2 = paginate;
  var paginateChunk2 = paginateChunk;
  var paginateChunkEffect2 = paginateChunkEffect;
  var paginateEffect2 = paginateEffect;
  var partition6 = partition5;
  var partitionEither2 = partitionEither;
  var peel2 = peel;
  var pipeThrough2 = pipeThrough;
  var pipeThroughChannel2 = pipeThroughChannel;
  var pipeThroughChannelOrFail2 = pipeThroughChannelOrFail;
  var prepend5 = prepend4;
  var provideContext6 = provideContext5;
  var provideSomeContext3 = provideSomeContext2;
  var provideLayer2 = provideLayer;
  var provideService6 = provideService5;
  var provideServiceEffect4 = provideServiceEffect3;
  var provideServiceStream2 = provideServiceStream;
  var mapInputContext6 = mapInputContext5;
  var provideSomeLayer3 = provideSomeLayer2;
  var race4 = race3;
  var raceAll4 = raceAll3;
  var range3 = range2;
  var rechunk2 = rechunk;
  var refineOrDie2 = refineOrDie;
  var refineOrDieWith2 = refineOrDieWith;
  var repeat3 = repeat2;
  var repeatEffect2 = repeatEffect;
  var repeatEffectChunk2 = repeatEffectChunk;
  var repeatEffectChunkOption2 = repeatEffectChunkOption;
  var repeatEffectOption2 = repeatEffectOption;
  var repeatEffectWithSchedule2 = repeatEffectWithSchedule;
  var repeatEither2 = repeatEither;
  var repeatElements2 = repeatElements;
  var repeatElementsWith2 = repeatElementsWith;
  var repeatValue2 = repeatValue;
  var repeatWith2 = repeatWith;
  var retry7 = retry6;
  var withExecutionPlan4 = withExecutionPlan3;
  var run4 = run3;
  var runCollect2 = runCollect;
  var runCount2 = runCount;
  var runDrain3 = runDrain2;
  var runFold2 = runFold;
  var runFoldEffect2 = runFoldEffect;
  var runFoldScoped2 = runFoldScoped;
  var runFoldScopedEffect2 = runFoldScopedEffect;
  var runFoldWhile2 = runFoldWhile;
  var runFoldWhileEffect2 = runFoldWhileEffect;
  var runFoldWhileScoped2 = runFoldWhileScoped;
  var runFoldWhileScopedEffect2 = runFoldWhileScopedEffect;
  var runForEach2 = runForEach;
  var runForEachChunk2 = runForEachChunk;
  var runForEachChunkScoped2 = runForEachChunkScoped;
  var runForEachScoped2 = runForEachScoped;
  var runForEachWhile2 = runForEachWhile;
  var runForEachWhileScoped2 = runForEachWhileScoped;
  var runHead2 = runHead;
  var runIntoPubSub2 = runIntoPubSub;
  var runIntoPubSubScoped2 = runIntoPubSubScoped;
  var runIntoQueue2 = runIntoQueue;
  var runIntoQueueElementsScoped2 = runIntoQueueElementsScoped;
  var runIntoQueueScoped2 = runIntoQueueScoped;
  var runLast2 = runLast;
  var runScoped3 = runScoped2;
  var runSum2 = runSum;
  var scan2 = scan;
  var scanEffect2 = scanEffect;
  var scanReduce2 = scanReduce;
  var scanReduceEffect2 = scanReduceEffect;
  var schedule3 = schedule2;
  var scheduleWith2 = scheduleWith;
  var scoped6 = scoped5;
  var scopedWith5 = scopedWith4;
  var sliding8 = sliding7;
  var slidingSize2 = slidingSize;
  var some6 = some5;
  var someOrElse2 = someOrElse;
  var someOrFail2 = someOrFail;
  var split2 = split;
  var splitOnChunk2 = splitOnChunk;
  var splitLines3 = splitLines2;
  var succeed16 = succeed14;
  var sync9 = sync8;
  var suspend10 = suspend9;
  var take8 = take7;
  var takeRight3 = takeRight2;
  var takeUntil4 = takeUntil3;
  var takeUntilEffect2 = takeUntilEffect;
  var takeWhile5 = takeWhile4;
  var tap7 = tap6;
  var tapBoth4 = tapBoth3;
  var tapError6 = tapError5;
  var tapErrorCause6 = tapErrorCause5;
  var tapSink2 = tapSink;
  var throttle2 = throttle;
  var throttleEffect2 = throttleEffect;
  var tick2 = tick;
  var timeout4 = timeout3;
  var timeoutFail4 = timeoutFail3;
  var timeoutFailCause4 = timeoutFailCause3;
  var timeoutTo4 = timeoutTo3;
  var toPubSub3 = toPubSub2;
  var toPull3 = toPull2;
  var toQueue3 = toQueue2;
  var toQueueOfElements2 = toQueueOfElements;
  var toReadableStream2 = toReadableStream;
  var toReadableStreamEffect2 = toReadableStreamEffect;
  var toReadableStreamRuntime2 = toReadableStreamRuntime;
  var toAsyncIterableRuntime2 = toAsyncIterableRuntime;
  var toAsyncIterableEffect2 = toAsyncIterableEffect;
  var toAsyncIterable2 = toAsyncIterable;
  var transduce2 = transduce;
  var unfold4 = unfold3;
  var unfoldChunk2 = unfoldChunk;
  var unfoldChunkEffect2 = unfoldChunkEffect;
  var unfoldEffect2 = unfoldEffect;
  var void_8 = void_7;
  var unwrap3 = unwrap2;
  var unwrapScoped5 = unwrapScoped4;
  var unwrapScopedWith4 = unwrapScopedWith3;
  var updateService5 = updateService4;
  var when4 = when3;
  var whenCase2 = whenCase;
  var whenCaseEffect2 = whenCaseEffect;
  var whenEffect4 = whenEffect3;
  var withSpan7 = withSpan6;
  var zip8 = zip7;
  var zipFlatten2 = zipFlatten;
  var zipAll2 = zipAll;
  var zipAllLeft2 = zipAllLeft;
  var zipAllRight2 = zipAllRight;
  var zipAllSortedByKey2 = zipAllSortedByKey;
  var zipAllSortedByKeyLeft2 = zipAllSortedByKeyLeft;
  var zipAllSortedByKeyRight2 = zipAllSortedByKeyRight;
  var zipAllSortedByKeyWith2 = zipAllSortedByKeyWith;
  var zipAllWith2 = zipAllWith;
  var zipLatest2 = zipLatest;
  var zipLatestAll2 = zipLatestAll;
  var zipLatestWith2 = zipLatestWith;
  var zipLeft6 = zipLeft5;
  var zipRight9 = zipRight8;
  var zipWith11 = zipWith10;
  var zipWithChunks2 = zipWithChunks;
  var zipWithNext2 = zipWithNext;
  var zipWithPrevious2 = zipWithPrevious;
  var zipWithPreviousAndNext2 = zipWithPreviousAndNext;
  var zipWithIndex2 = zipWithIndex;
  var Do4 = Do3;
  var bind5 = bind4;
  var bindEffect2 = bindEffect;
  var bindTo5 = bindTo4;
  var let_5 = let_4;
  var decodeText2 = decodeText;
  var encodeText2 = encodeText;
  var fromEventListener2 = fromEventListener;
  // src/desktop/protocol.ts
  function generateCorrelationId() {
    return `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  }
  var isSocketResponse = (msg) => {
    if (typeof msg !== "object" || msg === null)
      return false;
    const obj = msg;
    return typeof obj.type === "string" && obj.type.startsWith("response:");
  };
  var isHudEvent = (msg) => {
    if (typeof msg !== "object" || msg === null)
      return false;
    const obj = msg;
    if (typeof obj.type !== "string")
      return false;
    return !obj.type.startsWith("request:") && !obj.type.startsWith("response:");
  };
  var serializeSocketMessage = (msg) => JSON.stringify(msg);
  var parseSocketMessage = (data) => {
    try {
      const parsed = JSON.parse(data);
      if (typeof parsed !== "object" || parsed === null)
        return null;
      if (typeof parsed.type !== "string")
        return null;
      return parsed;
    } catch {
      return null;
    }
  };
  var DESKTOP_HTTP_PORT = 8080;
  var DESKTOP_WS_PATH = "/ws";
  var DESKTOP_WS_URL = `ws://localhost:${DESKTOP_HTTP_PORT}${DESKTOP_WS_PATH}`;

  // src/mainview/socket-client.ts
  class SocketClient {
    ws = null;
    url;
    requestTimeout;
    autoReconnect;
    maxReconnectAttempts;
    verbose;
    pendingRequests = new Map;
    messageQueue = [];
    messageHandlers = [];
    connectHandlers = [];
    disconnectHandlers = [];
    reconnectAttempts = 0;
    reconnectTimer = null;
    isConnecting = false;
    constructor(options = {}) {
      this.url = options.url ?? `ws://localhost:${DESKTOP_HTTP_PORT}${DESKTOP_WS_PATH}`;
      this.requestTimeout = options.requestTimeout ?? 1e4;
      this.autoReconnect = options.autoReconnect ?? true;
      this.maxReconnectAttempts = options.maxReconnectAttempts ?? 10;
      this.verbose = options.verbose ?? false;
    }
    connect() {
      return new Promise((resolve, reject) => {
        if (this.ws?.readyState === WebSocket.OPEN) {
          resolve();
          return;
        }
        if (this.isConnecting) {
          const checkInterval = setInterval(() => {
            if (this.ws?.readyState === WebSocket.OPEN) {
              clearInterval(checkInterval);
              resolve();
            }
          }, 100);
          return;
        }
        this.isConnecting = true;
        this.log(`Connecting to ${this.url}`);
        if (window.bunLog) {
          window.bunLog(`[SocketClient] Connecting to ${this.url}`);
        }
        try {
          this.ws = new WebSocket(this.url);
          if (window.bunLog) {
            window.bunLog(`[SocketClient] WebSocket created, waiting for open...`);
          }
          this.ws.onopen = () => {
            this.isConnecting = false;
            this.reconnectAttempts = 0;
            this.log("Connected");
            if (window.bunLog) {
              window.bunLog(`[SocketClient] WebSocket OPEN!`);
            }
            while (this.messageQueue.length > 0) {
              const msg = this.messageQueue.shift();
              this.ws?.send(msg);
            }
            for (const handler of this.connectHandlers) {
              try {
                handler();
              } catch (e) {
                console.error("[SocketClient] Connect handler error:", e);
              }
            }
            resolve();
          };
          this.ws.onmessage = (event) => {
            this.handleMessage(event.data);
          };
          this.ws.onclose = () => {
            this.isConnecting = false;
            this.log("Disconnected");
            for (const handler of this.disconnectHandlers) {
              try {
                handler();
              } catch (e) {
                console.error("[SocketClient] Disconnect handler error:", e);
              }
            }
            if (this.autoReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {
              this.scheduleReconnect();
            }
          };
          this.ws.onerror = (error) => {
            this.isConnecting = false;
            this.log(`Connection error: ${error}`);
            if (window.bunLog) {
              window.bunLog(`[SocketClient] WebSocket ERROR:`, String(error));
            }
            reject(new Error("WebSocket connection failed"));
          };
        } catch (e) {
          this.isConnecting = false;
          reject(e);
        }
      });
    }
    disconnect() {
      if (this.reconnectTimer) {
        clearTimeout(this.reconnectTimer);
        this.reconnectTimer = null;
      }
      this.reconnectAttempts = this.maxReconnectAttempts;
      if (this.ws) {
        this.ws.close();
        this.ws = null;
      }
      for (const [_id, pending3] of this.pendingRequests) {
        clearTimeout(pending3.timeout);
        pending3.reject(new Error("Client disconnected"));
      }
      this.pendingRequests.clear();
    }
    isConnected() {
      return this.ws?.readyState === WebSocket.OPEN;
    }
    async request(type, params) {
      const correlationId = generateCorrelationId();
      const request2 = { type, correlationId, ...params };
      return new Promise((resolve, reject) => {
        const timeout5 = setTimeout(() => {
          this.pendingRequests.delete(correlationId);
          reject(new Error(`Request timeout: ${type}`));
        }, this.requestTimeout);
        this.pendingRequests.set(correlationId, {
          resolve,
          reject,
          timeout: timeout5
        });
        const msg = serializeSocketMessage(request2);
        if (this.ws?.readyState === WebSocket.OPEN) {
          this.ws.send(msg);
        } else {
          this.messageQueue.push(msg);
          if (!this.isConnecting && this.autoReconnect) {
            this.connect().catch(() => {});
          }
        }
      });
    }
    onMessage(handler) {
      this.messageHandlers.push(handler);
      return () => {
        const idx = this.messageHandlers.indexOf(handler);
        if (idx >= 0)
          this.messageHandlers.splice(idx, 1);
      };
    }
    onConnect(handler) {
      this.connectHandlers.push(handler);
      return () => {
        const idx = this.connectHandlers.indexOf(handler);
        if (idx >= 0)
          this.connectHandlers.splice(idx, 1);
      };
    }
    onDisconnect(handler) {
      this.disconnectHandlers.push(handler);
      return () => {
        const idx = this.disconnectHandlers.indexOf(handler);
        if (idx >= 0)
          this.disconnectHandlers.splice(idx, 1);
      };
    }
    async loadTBSuite(suitePath) {
      const response = await this.request("request:loadTBSuite", { suitePath });
      if (!response.success) {
        throw new Error(response.error ?? "Failed to load suite");
      }
      return response.data;
    }
    async startTBRun(options) {
      const response = await this.request("request:startTBRun", options);
      if (!response.success) {
        throw new Error(response.error ?? "Failed to start run");
      }
      return response.data;
    }
    async stopTBRun() {
      const response = await this.request("request:stopTBRun", {});
      if (!response.success) {
        throw new Error(response.error ?? "Failed to stop run");
      }
      return response.data;
    }
    async loadRecentTBRuns(count3) {
      const response = await this.request("request:loadRecentTBRuns", { count: count3 });
      if (!response.success) {
        throw new Error(response.error ?? "Failed to load runs");
      }
      return response.data;
    }
    async loadTBRunDetails(runId) {
      const response = await this.request("request:loadTBRunDetails", { runId });
      if (!response.success) {
        throw new Error(response.error ?? "Failed to load run details");
      }
      return response.data ?? null;
    }
    async loadReadyTasks(limit) {
      const response = await this.request("request:loadReadyTasks", { limit });
      if (!response.success) {
        throw new Error(response.error ?? "Failed to load ready tasks");
      }
      return response.data ?? [];
    }
    async assignTaskToMC(taskId, options) {
      const response = await this.request("request:assignTaskToMC", { taskId, options });
      if (!response.success) {
        throw new Error(response.error ?? "Failed to assign task");
      }
      return response.data ?? { assigned: false };
    }
    async loadUnifiedTrajectories(limit) {
      const response = await this.request("request:loadUnifiedTrajectories", { limit });
      if (!response.success) {
        throw new Error(response.error ?? "Failed to load trajectories");
      }
      return response.data ?? [];
    }
    async getHFTrajectoryCount() {
      const response = await this.request("request:getHFTrajectoryCount", {});
      if (!response.success) {
        throw new Error(response.error ?? "Failed to get trajectory count");
      }
      return response.data?.count ?? 0;
    }
    async getHFTrajectories(offset, limit) {
      const response = await this.request("request:getHFTrajectories", { offset, limit });
      if (!response.success) {
        throw new Error(response.error ?? "Failed to load trajectories");
      }
      return response.data ?? [];
    }
    async getHFTrajectory(index) {
      const response = await this.request("request:getHFTrajectory", { index });
      if (!response.success) {
        throw new Error(response.error ?? "Failed to load trajectory");
      }
      return response.data ?? null;
    }
    async startTestGen(suitePath, taskId, model) {
      const response = await this.request("request:startTestGen", { suitePath, taskId, model });
      if (!response.success) {
        throw new Error(response.error ?? "Failed to start test generation");
      }
      return response.data;
    }
    handleMessage(data) {
      const parsed = parseSocketMessage(data);
      if (!parsed) {
        this.log(`Invalid message: ${data.slice(0, 100)}`);
        return;
      }
      if (isSocketResponse(parsed)) {
        const pending3 = this.pendingRequests.get(parsed.correlationId);
        if (pending3) {
          clearTimeout(pending3.timeout);
          this.pendingRequests.delete(parsed.correlationId);
          pending3.resolve(parsed);
        }
        return;
      }
      if (isHudEvent(parsed)) {
        for (const handler of this.messageHandlers) {
          try {
            handler(parsed);
          } catch (e) {
            console.error("[SocketClient] Message handler error:", e);
          }
        }
      }
    }
    scheduleReconnect() {
      if (this.reconnectTimer)
        return;
      const delay3 = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
      this.log(`Reconnecting in ${delay3}ms (attempt ${this.reconnectAttempts + 1})`);
      this.reconnectTimer = setTimeout(() => {
        this.reconnectTimer = null;
        this.reconnectAttempts++;
        this.connect().catch(() => {});
      }, delay3);
    }
    log(msg) {
      if (this.verbose) {
        console.log(`[SocketClient] ${msg}`);
      }
    }
  }
  var defaultClient = null;
  function getSocketClient(options) {
    if (!defaultClient) {
      defaultClient = new SocketClient(options);
    }
    return defaultClient;
  }

  // src/effuse/template/types.ts
  var isTemplateResult = (value) => typeof value === "object" && value !== null && ("_tag" in value) && value._tag === "TemplateResult";

  // src/effuse/template/escape.ts
  var ESCAPE_MAP = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  var escapeHtml = (str) => str.replace(/[&<>"']/g, (char) => ESCAPE_MAP[char] ?? char);

  // src/effuse/template/html.ts
  var renderValue = (value) => {
    if (value === null || value === undefined) {
      return "";
    }
    if (typeof value === "string") {
      return escapeHtml(value);
    }
    if (typeof value === "number" || typeof value === "boolean") {
      return String(value);
    }
    if (isTemplateResult(value)) {
      return value.toString();
    }
    if (Array.isArray(value)) {
      return value.map(renderValue).join("");
    }
    return escapeHtml(String(value));
  };
  function html(strings, ...values3) {
    return {
      _tag: "TemplateResult",
      strings,
      values: values3,
      toString() {
        let result = "";
        for (let i = 0;i < strings.length; i++) {
          result += strings[i];
          if (i < values3.length) {
            result += renderValue(values3[i]);
          }
        }
        return result;
      }
    };
  }
  function rawHtml(content) {
    return {
      _tag: "TemplateResult",
      strings: [content],
      values: [],
      toString() {
        return content;
      }
    };
  }
  function joinTemplates(templates, separator = "") {
    const joined = templates.map((t) => t.toString()).join(separator);
    return rawHtml(joined);
  }
  // src/effuse/state/cell.ts
  var makeCell = (initial) => exports_Effect.gen(function* () {
    const ref = yield* exports_Ref.make(initial);
    const queue = yield* exports_Queue.unbounded();
    yield* exports_Effect.addFinalizer(() => exports_Queue.shutdown(queue));
    const cell = {
      get: exports_Ref.get(ref),
      set: (value) => exports_Effect.gen(function* () {
        yield* exports_Ref.set(ref, value);
        yield* exports_Queue.offer(queue, value);
      }),
      update: (f) => exports_Effect.gen(function* () {
        const newValue = yield* exports_Ref.updateAndGet(ref, f);
        yield* exports_Queue.offer(queue, newValue);
      }),
      changes: exports_Stream.fromQueue(queue)
    };
    return cell;
  });
  // src/effuse/services/dom.ts
  class DomError extends Error {
    reason;
    _tag = "DomError";
    constructor(reason, message) {
      super(message);
      this.reason = reason;
      this.name = "DomError";
    }
  }

  class DomServiceTag extends exports_Context.Tag("effuse/DomService")() {
  }
  // src/effuse/services/state.ts
  class StateServiceTag extends exports_Context.Tag("effuse/StateService")() {
  }
  // src/effuse/services/socket.ts
  class SocketError extends Error {
    reason;
    _tag = "SocketError";
    constructor(reason, message) {
      super(message);
      this.reason = reason;
      this.name = "SocketError";
    }
  }

  class SocketServiceTag extends exports_Context.Tag("effuse/SocketService")() {
  }
  // src/effuse/services/dom-live.ts
  var makeDomService = (root = document) => ({
    query: (selector) => exports_Effect.gen(function* () {
      const element = root.querySelector(selector);
      if (!element) {
        return yield* exports_Effect.fail(new DomError("element_not_found", `Element not found: ${selector}`));
      }
      return element;
    }),
    queryOption: (selector) => exports_Effect.succeed(root.querySelector(selector)),
    queryId: (id2) => exports_Effect.gen(function* () {
      const element = document.getElementById(id2);
      if (!element) {
        return yield* exports_Effect.fail(new DomError("element_not_found", `Element not found: #${id2}`));
      }
      return element;
    }),
    render: (element, content) => exports_Effect.gen(function* () {
      try {
        element.innerHTML = content.toString();
      } catch (error) {
        return yield* exports_Effect.fail(new DomError("render_failed", `Failed to render: ${error instanceof Error ? error.message : String(error)}`));
      }
    }),
    listen: (element, event, handler, options) => exports_Effect.sync(() => {
      const listener = handler;
      element.addEventListener(event, listener, options);
      return () => element.removeEventListener(event, listener, options);
    }),
    delegate: (container, selector, event, handler) => exports_Effect.sync(() => {
      const bunLog = typeof window !== "undefined" ? window.bunLog : null;
      if (bunLog) {
        bunLog(`[DomService] Setting up delegate for "${event}" on container "${container.id || container.className || container.tagName}", selector="${selector}"`);
      }
      const listener = (e) => {
        if (bunLog && selector.includes("runFullBenchmark")) {
          bunLog(`[DomService] ${event} event received, target:`, e.target);
        }
        let element = null;
        if (e.target instanceof Element) {
          element = e.target;
        } else if (e.target instanceof Node && e.target.parentElement) {
          element = e.target.parentElement;
        }
        if (bunLog && selector.includes("runFullBenchmark") && element) {
          bunLog(`[DomService] Resolved element:`, element.tagName, element.className);
        }
        const target = element?.closest(selector);
        if (bunLog && selector.includes("runFullBenchmark")) {
          bunLog(`[DomService] closest("${selector}") result:`, target, `container.contains:`, target ? container.contains(target) : false);
        }
        if (target && container.contains(target)) {
          if (bunLog && selector.includes("runFullBenchmark")) {
            bunLog(`[DomService] Calling handler for ${event}`);
          }
          handler(e, target);
        }
      };
      container.addEventListener(event, listener);
      return () => container.removeEventListener(event, listener);
    }),
    createFragment: (content) => exports_Effect.gen(function* () {
      try {
        const template = document.createElement("template");
        template.innerHTML = content.toString();
        return template.content;
      } catch (error) {
        return yield* exports_Effect.fail(new DomError("render_failed", `Failed to create fragment: ${error instanceof Error ? error.message : String(error)}`));
      }
    })
  });
  var DomServiceLive = exports_Layer.effect(DomServiceTag, exports_Effect.sync(() => makeDomService()));
  // src/effuse/services/state-live.ts
  var makeStateService = () => ({
    cell: makeCell
  });
  var StateServiceLive = exports_Layer.succeed(StateServiceTag, makeStateService());
  // src/effuse/services/socket-live.ts
  var wrapRequest = (fn2, errorReason = "request_failed") => exports_Effect.tryPromise({
    try: fn2,
    catch: (error) => new SocketError(errorReason, error instanceof Error ? error.message : String(error))
  });
  var makeSocketService = (client) => {
    let messageStream = null;
    return {
      connect: () => exports_Effect.tryPromise({
        try: () => client.connect(),
        catch: (error) => new SocketError("connection_failed", error instanceof Error ? error.message : String(error))
      }),
      disconnect: () => exports_Effect.sync(() => client.disconnect()),
      isConnected: () => exports_Effect.sync(() => client.isConnected()),
      getMessages: () => {
        if (!messageStream) {
          messageStream = exports_Stream.async((emit2) => {
            const unsubscribe = client.onMessage((message) => {
              emit2.single(message).catch(() => {});
            });
            return exports_Effect.sync(unsubscribe);
          });
        }
        return messageStream;
      },
      loadTBSuite: (suitePath) => wrapRequest(() => client.loadTBSuite(suitePath)),
      startTBRun: (options) => wrapRequest(() => client.startTBRun(options)),
      stopTBRun: () => wrapRequest(() => client.stopTBRun()),
      loadRecentTBRuns: (count3) => wrapRequest(() => client.loadRecentTBRuns(count3)),
      loadTBRunDetails: (runId) => wrapRequest(() => client.loadTBRunDetails(runId)),
      loadReadyTasks: (limit) => wrapRequest(() => client.loadReadyTasks(limit)),
      assignTaskToMC: (taskId, options) => wrapRequest(() => client.assignTaskToMC(taskId, options)),
      loadUnifiedTrajectories: (limit) => wrapRequest(() => client.loadUnifiedTrajectories(limit)),
      getHFTrajectoryCount: () => wrapRequest(() => client.getHFTrajectoryCount()),
      getHFTrajectories: (offset, limit) => wrapRequest(() => client.getHFTrajectories(offset, limit)),
      startTestGen: (suitePath, taskId, model) => wrapRequest(() => client.startTestGen(suitePath, taskId, model))
    };
  };
  var SocketServiceLive = (options) => exports_Layer.succeed(SocketServiceTag, makeSocketService(new SocketClient(options)));
  var SocketServiceFromClient = (client) => exports_Layer.succeed(SocketServiceTag, makeSocketService(client));
  var SocketServiceDefault = SocketServiceLive();
  // src/effuse/hmr/registry.ts
  var isBrowser = typeof window !== "undefined";
  var getRegistry = () => {
    if (!isBrowser)
      return null;
    if (!window.__EFFUSE_HMR__) {
      window.__EFFUSE_HMR__ = {
        widgets: new Map,
        version: 0
      };
    }
    return window.__EFFUSE_HMR__;
  };
  var saveWidgetState = (widgetId, state) => {
    const registry = getRegistry();
    if (!registry)
      return;
    try {
      registry.widgets.set(widgetId, structuredClone(state));
    } catch (e) {
      console.warn(`[Effuse HMR] Could not save state for "${widgetId}":`, e);
    }
  };
  var loadWidgetState = (widgetId) => {
    const registry = getRegistry();
    if (!registry)
      return;
    const state = registry.widgets.get(widgetId);
    if (state !== undefined) {
      registry.widgets.delete(widgetId);
      console.log(`[Effuse HMR] Restored state for "${widgetId}"`);
    }
    return state;
  };

  // src/effuse/widget/mount.ts
  var mountWidget = (widget, container) => exports_Effect.gen(function* () {
    const dom = yield* DomServiceTag;
    const stateService = yield* StateServiceTag;
    const preservedState = loadWidgetState(widget.id);
    const initialState = preservedState ?? widget.initialState();
    const state = yield* stateService.cell(initialState);
    const eventQueue = yield* exports_Effect.acquireRelease(exports_Queue.unbounded(), (queue) => exports_Queue.shutdown(queue));
    const emit2 = (event) => exports_Queue.offer(eventQueue, event).pipe(exports_Effect.catchAll(() => exports_Effect.void));
    const ctx = {
      state,
      emit: emit2,
      dom,
      container
    };
    const initialContent = yield* widget.render(ctx);
    yield* dom.render(container, initialContent).pipe(exports_Effect.catchAll((error) => {
      console.error(`[Effuse] Initial render error for "${widget.id}":`, error);
      return exports_Effect.void;
    }));
    if (widget.setupEvents) {
      yield* widget.setupEvents(ctx);
    }
    yield* pipe(state.changes, exports_Stream.tap((s) => exports_Effect.sync(() => saveWidgetState(widget.id, s))), exports_Stream.runDrain, exports_Effect.forkScoped);
    yield* pipe(state.changes, exports_Stream.tap(() => exports_Effect.gen(function* () {
      const content = yield* widget.render(ctx);
      yield* dom.render(container, content).pipe(exports_Effect.catchAll((error) => {
        console.error(`[Effuse] Re-render error for "${widget.id}":`, error);
        return exports_Effect.void;
      }));
    })), exports_Stream.runDrain, exports_Effect.forkScoped);
    if (widget.handleEvent) {
      yield* pipe(exports_Stream.fromQueue(eventQueue), exports_Stream.tap((event) => widget.handleEvent(event, ctx)), exports_Stream.runDrain, exports_Effect.forkScoped);
    }
    if (widget.subscriptions) {
      const subs = widget.subscriptions(ctx);
      for (const sub of subs) {
        yield* pipe(sub, exports_Stream.tap((effect4) => effect4), exports_Stream.runDrain, exports_Effect.forkScoped);
      }
    }
    const mounted = {
      unmount: exports_Effect.void,
      events: exports_Stream.fromQueue(eventQueue),
      emit: emit2
    };
    return mounted;
  });
  var mountWidgetById = (widget, containerId) => exports_Effect.gen(function* () {
    const dom = yield* DomServiceTag;
    const container = yield* dom.queryId(containerId);
    return yield* mountWidget(widget, container);
  }).pipe(exports_Effect.catchAll((error) => {
    console.error(`[Effuse] Failed to mount widget "${widget.id}":`, error);
    return exports_Effect.succeed({
      unmount: exports_Effect.void,
      events: exports_Stream.empty,
      emit: () => exports_Effect.void
    });
  }));
  // src/effuse/layers/live.ts
  var EffuseLive = exports_Layer.mergeAll(DomServiceLive, StateServiceLive, SocketServiceDefault);
  var EffuseLiveNoSocket = exports_Layer.mergeAll(DomServiceLive, StateServiceLive);
  // src/effuse/widgets/apm-widget.ts
  var getAPMColorClass = (apm) => {
    if (apm >= 30)
      return "text-emerald-400";
    if (apm >= 15)
      return "text-zinc-200";
    if (apm >= 5)
      return "text-zinc-400";
    return "text-zinc-500";
  };
  var getAPMBgClass = (apm) => {
    if (apm >= 30)
      return "bg-emerald-950/20 border-emerald-800/40";
    if (apm >= 15)
      return "bg-zinc-900/60 border-zinc-700/50";
    if (apm >= 5)
      return "bg-zinc-900/40 border-zinc-700/40";
    return "bg-zinc-950/40 border-zinc-800/30";
  };
  var formatDuration = (minutes2) => {
    if (minutes2 < 60)
      return `${minutes2.toFixed(0)}m`;
    const hours2 = Math.floor(minutes2 / 60);
    const mins = Math.round(minutes2 % 60);
    return mins > 0 ? `${hours2}h ${mins}m` : `${hours2}h`;
  };
  var isAPMUpdate = (msg) => msg.type === "apm_update";
  var isAPMSnapshot = (msg) => msg.type === "apm_snapshot";
  var APMWidget = {
    id: "apm-widget",
    initialState: () => ({
      sessionAPM: 0,
      recentAPM: 0,
      totalActions: 0,
      durationMinutes: 0,
      apm1h: 0,
      apm6h: 0,
      apm1d: 0,
      apmLifetime: 0,
      claudeCodeAPM: 0,
      mechaCoderAPM: 0,
      efficiencyRatio: 0,
      expanded: false
    }),
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      const colorClass = getAPMColorClass(state.sessionAPM);
      const bgClass = getAPMBgClass(state.sessionAPM);
      if (!state.expanded) {
        return html`
          <div
            class="fixed bottom-4 right-4 rounded-xl border ${bgClass} px-4 py-3 shadow-lg backdrop-blur-sm cursor-pointer transition-all hover:scale-105"
            data-action="toggleExpand"
          >
            <div class="flex items-center gap-3">
              <div class="text-2xl font-bold ${colorClass} font-mono">
                ${state.sessionAPM.toFixed(1)}
              </div>
              <div class="text-xs text-zinc-500 uppercase tracking-wide">APM</div>
            </div>
            ${state.totalActions > 0 ? html`
                  <div class="text-xs text-zinc-500 mt-1">
                    ${state.totalActions} actions in ${formatDuration(state.durationMinutes)}
                  </div>
                ` : ""}
          </div>
        `;
      }
      return html`
        <div
          class="fixed bottom-4 right-4 w-72 rounded-xl border ${bgClass} shadow-xl backdrop-blur-sm"
        >
          <!-- Header -->
          <div
            class="flex items-center justify-between px-4 py-3 border-b border-zinc-800/50 cursor-pointer"
            data-action="toggleExpand"
          >
            <div class="flex items-center gap-2">
              <div class="text-xl font-bold ${colorClass} font-mono">
                ${state.sessionAPM.toFixed(1)}
              </div>
              <div class="text-xs text-zinc-500 uppercase">APM</div>
            </div>
            <div class="text-zinc-500 text-sm">-</div>
          </div>

          <!-- Current Session -->
          <div class="px-4 py-3 border-b border-zinc-800/30">
            <div class="text-xs text-zinc-500 uppercase tracking-wide mb-2">Session</div>
            <div class="grid grid-cols-2 gap-2 text-sm">
              <div>
                <span class="text-zinc-500">Recent:</span>
                <span class="text-zinc-300 font-mono ml-1">${state.recentAPM.toFixed(1)}</span>
              </div>
              <div>
                <span class="text-zinc-500">Actions:</span>
                <span class="text-zinc-300 font-mono ml-1">${state.totalActions}</span>
              </div>
              <div class="col-span-2">
                <span class="text-zinc-500">Duration:</span>
                <span class="text-zinc-300 ml-1">${formatDuration(state.durationMinutes)}</span>
              </div>
            </div>
          </div>

          <!-- Historical -->
          ${state.apm1h > 0 || state.apmLifetime > 0 ? html`
                <div class="px-4 py-3 border-b border-zinc-800/30">
                  <div class="text-xs text-zinc-500 uppercase tracking-wide mb-2">Historical</div>
                  <div class="grid grid-cols-2 gap-2 text-sm">
                    <div>
                      <span class="text-zinc-500">1h:</span>
                      <span class="text-zinc-300 font-mono ml-1">${state.apm1h.toFixed(1)}</span>
                    </div>
                    <div>
                      <span class="text-zinc-500">6h:</span>
                      <span class="text-zinc-300 font-mono ml-1">${state.apm6h.toFixed(1)}</span>
                    </div>
                    <div>
                      <span class="text-zinc-500">1d:</span>
                      <span class="text-zinc-300 font-mono ml-1">${state.apm1d.toFixed(1)}</span>
                    </div>
                    <div>
                      <span class="text-zinc-500">All:</span>
                      <span class="text-zinc-300 font-mono ml-1">${state.apmLifetime.toFixed(1)}</span>
                    </div>
                  </div>
                </div>
              ` : ""}

          <!-- Comparison -->
          ${state.efficiencyRatio > 0 ? html`
                <div class="px-4 py-3">
                  <div class="text-xs text-zinc-500 uppercase tracking-wide mb-2">Comparison</div>
                  <div class="grid grid-cols-2 gap-2 text-sm">
                    <div>
                      <span class="text-zinc-500">Claude:</span>
                      <span class="text-zinc-300 font-mono ml-1">${state.claudeCodeAPM.toFixed(1)}</span>
                    </div>
                    <div>
                      <span class="text-zinc-500">MC:</span>
                      <span class="text-zinc-300 font-mono ml-1">${state.mechaCoderAPM.toFixed(1)}</span>
                    </div>
                  </div>
                  <div class="mt-2 text-sm">
                    <span class="text-emerald-400 font-medium">
                      ${state.efficiencyRatio.toFixed(1)}x
                    </span>
                    <span class="text-zinc-500 ml-1">efficiency boost</span>
                  </div>
                </div>
              ` : ""}
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (_e, target) => {
        const action = target.dataset.action;
        if (action === "toggleExpand") {
          exports_Effect.runFork(ctx.emit({ type: "toggleExpand" }));
        }
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      switch (event.type) {
        case "toggleExpand":
          yield* ctx.state.update((s) => ({ ...s, expanded: !s.expanded }));
          break;
        case "refresh":
          break;
      }
    }),
    subscriptions: (ctx) => {
      const socket = exports_Effect.map(SocketServiceTag, (s) => s);
      return [
        pipe(exports_Stream.unwrap(exports_Effect.map(socket, (s) => s.getMessages())), exports_Stream.filter((msg) => isAPMUpdate(msg) || isAPMSnapshot(msg)), exports_Stream.map((msg) => exports_Effect.gen(function* () {
          if (isAPMUpdate(msg)) {
            yield* ctx.state.update((s) => ({
              ...s,
              sessionAPM: msg.sessionAPM,
              recentAPM: msg.recentAPM,
              totalActions: msg.totalActions,
              durationMinutes: msg.durationMinutes
            }));
          }
          if (isAPMSnapshot(msg)) {
            yield* ctx.state.update((s) => ({
              ...s,
              apm1h: msg.combined.apm1h,
              apm6h: msg.combined.apm6h,
              apm1d: msg.combined.apm1d,
              apmLifetime: msg.combined.apmLifetime,
              claudeCodeAPM: msg.comparison.claudeCodeAPM,
              mechaCoderAPM: msg.comparison.mechaCoderAPM,
              efficiencyRatio: msg.comparison.efficiencyRatio
            }));
          }
        })))
      ];
    }
  };
  var initialAPMState = APMWidget.initialState();
  // src/effuse/widgets/trajectory-pane.ts
  var formatTimestamp = (iso) => {
    try {
      return new Date(iso).toLocaleString(undefined, {
        month: "short",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      });
    } catch {
      return iso;
    }
  };
  var shortId = (id2) => id2.slice(-8);
  var getTypeClass = (type) => {
    return type === "tb-run" ? "bg-emerald-900/40 text-emerald-300 border-emerald-700/50" : "bg-violet-900/40 text-violet-300 border-violet-700/50";
  };
  var getTypeLabel = (type) => {
    return type === "tb-run" ? "TB" : "ATIF";
  };
  var TrajectoryPaneWidget = {
    id: "trajectory-pane",
    initialState: () => ({
      trajectories: [],
      selectedId: null,
      loading: false,
      error: null,
      collapsed: false
    }),
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      const header = html`
        <div class="flex items-center justify-between px-3 py-2 border-b border-zinc-800/60">
          <button
            class="text-sm font-medium text-zinc-300 hover:text-zinc-100 transition-colors"
            data-action="toggleCollapse"
          >
            ${state.collapsed ? "+" : "-"} Trajectories
          </button>
          <div class="flex items-center gap-2">
            <span class="text-xs text-zinc-500">${state.trajectories.length}</span>
            <button
              class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
              data-action="load"
            >
              ${state.loading ? "Loading..." : "Refresh"}
            </button>
          </div>
        </div>
      `;
      if (state.collapsed) {
        return html`
          <div class="h-full flex flex-col bg-zinc-950/80 border-r border-zinc-800/60">
            ${header}
          </div>
        `;
      }
      if (state.loading && state.trajectories.length === 0) {
        return html`
          <div class="h-full flex flex-col bg-zinc-950/80 border-r border-zinc-800/60">
            ${header}
            <div class="flex-1 flex items-center justify-center">
              <div class="text-sm text-zinc-500">Loading trajectories...</div>
            </div>
          </div>
        `;
      }
      if (state.error && state.trajectories.length === 0) {
        return html`
          <div class="h-full flex flex-col bg-zinc-950/80 border-r border-zinc-800/60">
            ${header}
            <div class="flex-1 flex items-center justify-center p-4">
              <div class="text-sm text-red-400 text-center">${state.error}</div>
            </div>
          </div>
        `;
      }
      if (state.trajectories.length === 0) {
        return html`
          <div class="h-full flex flex-col bg-zinc-950/80 border-r border-zinc-800/60">
            ${header}
            <div class="flex-1 flex items-center justify-center p-4">
              <div class="text-sm text-zinc-500 text-center">
                No trajectories found.<br />
                <button class="text-zinc-400 hover:text-zinc-200 underline mt-2" data-action="load">
                  Load trajectories
                </button>
              </div>
            </div>
          </div>
        `;
      }
      const trajectoryCards = state.trajectories.map((traj) => {
        const isSelected = traj.id === state.selectedId;
        const typeClass = getTypeClass(traj.type);
        return html`
          <div
            class="px-3 py-2 border-b border-zinc-800/40 cursor-pointer transition-colors
                   ${isSelected ? "bg-zinc-800/60" : "hover:bg-zinc-900/40"}"
            data-action="select"
            data-trajectory-id="${traj.id}"
          >
            <div class="flex items-center justify-between mb-1">
              <code class="text-xs font-mono text-zinc-400">${shortId(traj.id)}</code>
              <span class="text-xs px-1.5 py-0.5 rounded border ${typeClass}">
                ${getTypeLabel(traj.type)}
              </span>
            </div>
            <div class="text-sm text-zinc-300 truncate" title="${traj.label}">
              ${traj.label}
            </div>
            <div class="text-xs text-zinc-500 mt-1">
              ${formatTimestamp(traj.timestamp)}
            </div>
          </div>
        `;
      });
      return html`
        <div class="h-full flex flex-col bg-zinc-950/80 border-r border-zinc-800/60">
          ${header}
          <div class="flex-1 overflow-y-auto">
            ${trajectoryCards}
          </div>
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (_e, target) => {
        const action = target.dataset.action;
        const trajectoryId = target.dataset.trajectoryId;
        if (action === "load") {
          exports_Effect.runFork(ctx.emit({ type: "load" }));
        } else if (action === "select" && trajectoryId) {
          exports_Effect.runFork(ctx.emit({ type: "select", trajectoryId }));
        } else if (action === "toggleCollapse") {
          exports_Effect.runFork(ctx.emit({ type: "toggleCollapse" }));
        }
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      const socket = yield* SocketServiceTag;
      switch (event.type) {
        case "load":
          yield* ctx.state.update((s) => ({ ...s, loading: true, error: null }));
          const result = yield* socket.loadUnifiedTrajectories(50).pipe(exports_Effect.map((trajectories) => ({ trajectories, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ trajectories: [], error: e.message })));
          yield* ctx.state.update((s) => ({
            ...s,
            loading: false,
            trajectories: result.trajectories,
            error: result.error
          }));
          break;
        case "select":
          yield* ctx.state.update((s) => ({ ...s, selectedId: event.trajectoryId }));
          break;
        case "toggleCollapse":
          yield* ctx.state.update((s) => ({ ...s, collapsed: !s.collapsed }));
          break;
        case "clear":
          yield* ctx.state.update((s) => ({
            ...s,
            trajectories: [],
            selectedId: null,
            error: null
          }));
          break;
      }
    })
  };
  var initialTrajectoryPaneState = TrajectoryPaneWidget.initialState();
  // src/effuse/widgets/container-panes.ts
  var MAX_VISIBLE_PANES = 10;
  var MAX_LINES_PER_PANE = 500;
  var getStatusIcon = (pane) => {
    if (pane.status === "running")
      return "";
    if (pane.status === "completed" && pane.exitCode === 0)
      return "";
    return "";
  };
  var getStatusColorClass = (pane) => {
    if (pane.status === "running")
      return "text-zinc-300";
    if (pane.exitCode === 0)
      return "text-emerald-400";
    return "text-red-400";
  };
  var formatDuration2 = (ms) => {
    if (ms === undefined)
      return "";
    return `${(ms / 1000).toFixed(1)}s`;
  };
  var truncateCommand = (command, maxLen = 60) => {
    const full = command.join(" ");
    if (full.length <= maxLen)
      return full;
    return full.slice(0, maxLen) + "...";
  };
  var isContainerStart = (msg) => msg.type === "container_start";
  var isContainerOutput = (msg) => msg.type === "container_output";
  var isContainerComplete = (msg) => msg.type === "container_complete";
  var isContainerError = (msg) => msg.type === "container_error";
  var isContainerMessage = (msg) => isContainerStart(msg) || isContainerOutput(msg) || isContainerComplete(msg) || isContainerError(msg);
  var ContainerPanesWidget = {
    id: "container-panes",
    initialState: () => ({
      panes: new Map,
      maxVisible: MAX_VISIBLE_PANES,
      maxLinesPerPane: MAX_LINES_PER_PANE,
      collapsed: false
    }),
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      const panes = Array.from(state.panes.values()).sort((a, b) => b.startedAt.localeCompare(a.startedAt)).slice(0, state.maxVisible);
      const header = html`
        <div class="flex items-center justify-between px-3 py-2 border-b border-zinc-800/60">
          <button
            class="text-sm font-medium text-zinc-300 hover:text-zinc-100 transition-colors"
            data-action="toggleCollapse"
          >
            ${state.collapsed ? "+" : "-"} Containers
          </button>
          <div class="flex items-center gap-2">
            <span class="text-xs text-zinc-500">${panes.length} active</span>
            ${panes.length > 0 ? html`
                  <button
                    class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
                    data-action="clear"
                  >
                    Clear
                  </button>
                ` : ""}
          </div>
        </div>
      `;
      if (state.collapsed) {
        return html`
          <div class="flex flex-col bg-zinc-950/80 border border-zinc-800/60 rounded-lg">
            ${header}
          </div>
        `;
      }
      if (panes.length === 0) {
        return html`
          <div class="flex flex-col bg-zinc-950/80 border border-zinc-800/60 rounded-lg">
            ${header}
            <div class="flex items-center justify-center py-8">
              <div class="text-sm text-zinc-500">No container executions</div>
            </div>
          </div>
        `;
      }
      const paneCards = panes.map((pane) => {
        const statusIcon = getStatusIcon(pane);
        const statusColor = getStatusColorClass(pane);
        const duration2 = formatDuration2(pane.durationMs);
        const cmdDisplay = truncateCommand(pane.command);
        const badge = pane.sandboxed ? html`<span class="text-xs px-1.5 py-0.5 rounded bg-violet-900/40 text-violet-300 border border-violet-700/50">sandbox</span>` : html`<span class="text-xs px-1.5 py-0.5 rounded bg-amber-900/40 text-amber-300 border border-amber-700/50">host</span>`;
        const exitCodeBadge = pane.exitCode !== undefined ? html`
                <span
                  class="text-xs px-1.5 py-0.5 rounded font-mono ${pane.exitCode === 0 ? "bg-emerald-900/40 text-emerald-300" : "bg-red-900/40 text-red-300"}"
                >
                  ${pane.exitCode}
                </span>
              ` : "";
        const outputLines = pane.outputLines.slice(-100).map((line) => html`
            <div class="font-mono text-xs ${line.stream === "stderr" ? "text-red-400" : "text-zinc-300"}">
              ${line.text}
            </div>
          `);
        return html`
          <div
            class="border border-zinc-800/50 rounded-lg overflow-hidden ${pane.status === "running" ? "border-l-2 border-l-blue-500" : ""}"
            data-execution-id="${pane.executionId}"
          >
            <div class="flex items-center justify-between px-3 py-2 bg-zinc-900/60">
              <div class="flex items-center gap-2">
                <span class="${statusColor}">${statusIcon}</span>
                <span class="text-sm text-zinc-300">${pane.image}</span>
                ${badge}
              </div>
              <div class="flex items-center gap-2">
                ${duration2 ? html`<span class="text-xs text-zinc-500">${duration2}</span>` : ""}
                ${exitCodeBadge}
                <button
                  class="text-zinc-500 hover:text-zinc-300 transition-colors"
                  data-action="dismiss"
                  data-execution-id="${pane.executionId}"
                >
                  
                </button>
              </div>
            </div>
            <div class="px-3 py-1 border-b border-zinc-800/40 bg-zinc-900/40">
              <code class="text-xs text-zinc-400 font-mono" title="${pane.command.join(" ")}">
                ${cmdDisplay}
              </code>
            </div>
            <div class="px-3 py-2 max-h-40 overflow-y-auto bg-zinc-950/60">
              ${outputLines.length > 0 ? joinTemplates(outputLines) : html`<div class="text-xs text-zinc-600">No output yet</div>`}
            </div>
          </div>
        `;
      });
      return html`
        <div class="flex flex-col bg-zinc-950/80 border border-zinc-800/60 rounded-lg">
          ${header}
          <div class="p-3 grid gap-3">
            ${joinTemplates(paneCards)}
          </div>
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (_e, target) => {
        const el = target;
        const action = el.dataset.action;
        const executionId = el.dataset.executionId;
        if (action === "clear") {
          exports_Effect.runFork(ctx.emit({ type: "clear" }));
        } else if (action === "toggleCollapse") {
          exports_Effect.runFork(ctx.emit({ type: "toggleCollapse" }));
        } else if (action === "dismiss" && executionId) {
          exports_Effect.runFork(ctx.emit({ type: "dismiss", executionId }));
        }
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      switch (event.type) {
        case "clear":
          yield* ctx.state.update((s) => ({
            ...s,
            panes: new Map
          }));
          break;
        case "toggleCollapse":
          yield* ctx.state.update((s) => ({ ...s, collapsed: !s.collapsed }));
          break;
        case "dismiss":
          yield* ctx.state.update((s) => {
            const newPanes = new Map(s.panes);
            newPanes.delete(event.executionId);
            return { ...s, panes: newPanes };
          });
          break;
      }
    }),
    subscriptions: (ctx) => {
      const socket = exports_Effect.map(SocketServiceTag, (s) => s);
      return [
        pipe(exports_Stream.unwrap(exports_Effect.map(socket, (s) => s.getMessages())), exports_Stream.filter((msg) => isContainerMessage(msg)), exports_Stream.map((msg) => exports_Effect.gen(function* () {
          if (isContainerStart(msg)) {
            yield* ctx.state.update((s) => {
              const newPanes = new Map(s.panes);
              newPanes.set(msg.executionId, {
                executionId: msg.executionId,
                image: msg.image,
                command: msg.command,
                context: msg.context,
                sandboxed: msg.sandboxed,
                workdir: msg.workdir,
                status: "running",
                outputLines: [],
                startedAt: msg.timestamp
              });
              return { ...s, panes: newPanes };
            });
          }
          if (isContainerOutput(msg)) {
            yield* ctx.state.update((s) => {
              const pane = s.panes.get(msg.executionId);
              if (!pane)
                return s;
              const newPanes = new Map(s.panes);
              const updatedLines = [
                ...pane.outputLines,
                { text: msg.text, stream: msg.stream, sequence: msg.sequence }
              ].slice(-s.maxLinesPerPane);
              newPanes.set(msg.executionId, {
                ...pane,
                outputLines: updatedLines
              });
              return { ...s, panes: newPanes };
            });
          }
          if (isContainerComplete(msg)) {
            yield* ctx.state.update((s) => {
              const pane = s.panes.get(msg.executionId);
              if (!pane)
                return s;
              const newPanes = new Map(s.panes);
              newPanes.set(msg.executionId, {
                ...pane,
                status: "completed",
                exitCode: msg.exitCode,
                durationMs: msg.durationMs
              });
              return { ...s, panes: newPanes };
            });
          }
          if (isContainerError(msg)) {
            yield* ctx.state.update((s) => {
              const pane = s.panes.get(msg.executionId);
              if (!pane)
                return s;
              const newPanes = new Map(s.panes);
              newPanes.set(msg.executionId, {
                ...pane,
                status: "error",
                outputLines: [
                  ...pane.outputLines,
                  { text: `Error: ${msg.error}`, stream: "stderr", sequence: Date.now() }
                ]
              });
              return { ...s, panes: newPanes };
            });
          }
        })))
      ];
    }
  };
  var initialContainerPanesState = ContainerPanesWidget.initialState();
  // src/hud/protocol.ts
  var HUD_WS_PORT = 8080;
  var HUD_WS_URL = `ws://localhost:${HUD_WS_PORT}/ws`;
  var isATIFStep = (msg) => msg.type === "atif_step";

  // src/effuse/widgets/tb-output.ts
  var MAX_OUTPUT_LINES = 500;
  var getSourceColorClass = (source) => {
    switch (source) {
      case "agent":
        return "text-blue-300";
      case "verification":
        return "text-emerald-300";
      case "system":
        return "text-zinc-400";
      case "tool":
        return "text-amber-300";
    }
  };
  var getSourceLabel = (source) => {
    switch (source) {
      case "agent":
        return "AGT";
      case "verification":
        return "VRF";
      case "system":
        return "SYS";
      case "tool":
        return "TL";
    }
  };
  var formatToolCall = (toolCall) => {
    const args2 = toolCall.arguments;
    let argsStr = "";
    if (args2 && typeof args2 === "object") {
      const truncated = Object.entries(args2).slice(0, 3).map(([k, v]) => {
        const val = typeof v === "string" && v.length > 50 ? v.slice(0, 47) + "..." : v;
        return `${k}=${JSON.stringify(val)}`;
      }).join(", ");
      argsStr = truncated + (Object.keys(args2).length > 3 ? ", ..." : "");
    }
    return ` ${toolCall.function_name}(${argsStr})`;
  };
  var formatObservationResult = (result) => {
    const content = result.content;
    if (typeof content === "string") {
      const truncated = content.length > 100 ? content.slice(0, 97) + "..." : content;
      return ` ${truncated}`;
    }
    if (content && typeof content === "object") {
      const str = JSON.stringify(content);
      return ` ${str.length > 100 ? str.slice(0, 97) + "..." : str}`;
    }
    return ` (result)`;
  };
  var isTBTaskOutput = (msg) => msg.type === "tb_task_output";
  var isTBRunStart = (msg) => msg.type === "tb_run_start";
  var isTBRunComplete = (msg) => msg.type === "tb_run_complete";
  var isTBMessage = (msg) => isTBTaskOutput(msg) || isTBRunStart(msg) || isTBRunComplete(msg) || isATIFStep(msg);
  var TBOutputWidget = {
    id: "tb-output",
    initialState: () => ({
      outputLines: [],
      maxLines: MAX_OUTPUT_LINES,
      visible: false,
      runId: null,
      taskId: null,
      autoScroll: true,
      showLineNumbers: true,
      selectedLine: null,
      visibleSources: {
        agent: true,
        verification: true,
        system: true,
        tool: true
      }
    }),
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      if (!state.visible) {
        return html`<div class="hidden"></div>`;
      }
      const header = html`
        <div class="flex items-center justify-between px-3 py-2 border-b border-zinc-800/60 bg-zinc-900/80">
          <div class="flex items-center gap-2">
            <span class="text-sm font-medium text-zinc-300">TB Output</span>
            ${state.runId ? html`<code class="text-xs text-zinc-500 font-mono">${state.runId.slice(-8)}</code>` : ""}
            ${state.taskId ? html`<span class="text-xs text-zinc-400"> ${state.taskId}</span>` : ""}
          </div>
          <div class="flex items-center gap-2">
            <button
              class="text-xs px-2 py-1 rounded border transition-colors ${state.autoScroll ? "bg-blue-900/40 text-blue-300 border-blue-700/50" : "text-zinc-400 border-zinc-700/50 hover:border-zinc-600/60"}"
              data-action="toggleAutoScroll"
              title="Auto-scroll"
            >
              
            </button>
            <div class="flex items-center gap-1">
              ${["agent", "verification", "system", "tool"].map((source) => {
        const active2 = state.visibleSources[source];
        const label = getSourceLabel(source);
        const base = "text-xs px-2 py-1 rounded border transition-colors";
        const activeClasses = "bg-zinc-800/80 text-zinc-100 border-zinc-600/60";
        const inactiveClasses = "text-zinc-400 border-zinc-700/50 hover:border-zinc-600/60";
        return html`
                  <button
                    class="${base} ${active2 ? activeClasses : inactiveClasses}"
                    data-action="toggleSource"
                    data-source="${source}"
                    title="Toggle ${source} output"
                  >
                    ${label}
                  </button>
                `;
      })}
            </div>
            <button
              class="text-xs px-2 py-1 rounded border transition-colors ${state.showLineNumbers ? "bg-zinc-800/80 text-zinc-100 border-zinc-600/60" : "text-zinc-400 border-zinc-700/50 hover:border-zinc-600/60"}"
              data-action="toggleLineNumbers"
              title="Toggle line numbers"
            >
              #
            </button>
            <button
              class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
              data-action="copy"
            >
              Copy
            </button>
            <button
              class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
              data-action="clear"
            >
              Clear
            </button>
            <button
              class="text-zinc-500 hover:text-zinc-300 transition-colors"
              data-action="close"
            >
              
            </button>
          </div>
        </div>
      `;
      const visibleLines = state.outputLines.filter((line) => state.visibleSources[line.source]);
      const lines = visibleLines.length > 0 ? joinTemplates(visibleLines.slice(-100).map((line, index, arr) => {
        const lineNumber = state.outputLines.length - arr.length + index + 1;
        const lineNumberStyles = state.selectedLine === lineNumber ? "bg-zinc-800/80 text-zinc-100 border-zinc-700/60" : "text-zinc-500 border-transparent";
        return html`
                  <div class="flex gap-2 font-mono text-xs leading-relaxed">
                    ${state.showLineNumbers ? html`
                          <button
                            class="w-10 text-right pr-2 rounded border ${lineNumberStyles}"
                            data-action="selectLine"
                            data-line="${lineNumber}"
                            title="Line ${lineNumber}"
                          >
                            ${lineNumber}
                          </button>
                        ` : ""}
                    <span class="w-8 flex-shrink-0 ${getSourceColorClass(line.source)}">
                      ${getSourceLabel(line.source)}
                    </span>
                    <span class="text-zinc-300 whitespace-pre-wrap break-all">${line.text}</span>
                  </div>
                `;
      })) : html`<div class="text-xs text-zinc-600 italic">No output yet</div>`;
      return html`
        <div class="fixed right-4 bottom-20 w-[600px] max-h-[400px] flex flex-col bg-zinc-950/95 border border-zinc-800/60 rounded-lg shadow-xl backdrop-blur-sm overflow-hidden">
          ${header}
          <div
            class="flex-1 p-3 overflow-y-auto space-y-1"
            id="tb-output-scroll"
            data-autoscroll="${state.autoScroll ? "true" : "false"}"
          >
            ${lines}
          </div>
          <div class="px-3 py-1 border-t border-zinc-800/40 bg-zinc-900/60 text-xs text-zinc-500">
            ${visibleLines.length} lines
          </div>
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (_e, target) => {
        const action = target.dataset.action;
        if (action === "clear") {
          exports_Effect.runFork(ctx.emit({ type: "clear" }));
        } else if (action === "copy") {
          exports_Effect.runFork(ctx.emit({ type: "copy" }));
        } else if (action === "close") {
          exports_Effect.runFork(ctx.emit({ type: "close" }));
        } else if (action === "toggleAutoScroll") {
          exports_Effect.runFork(ctx.emit({ type: "toggleAutoScroll" }));
        } else if (action === "toggleLineNumbers") {
          exports_Effect.runFork(ctx.emit({ type: "toggleLineNumbers" }));
        } else if (action === "selectLine") {
          const lineValue = target.dataset.line;
          if (lineValue) {
            exports_Effect.runFork(ctx.emit({ type: "selectLine", lineNumber: Number(lineValue) }));
          }
        } else if (action === "toggleSource") {
          const source = target.dataset.source;
          if (source) {
            exports_Effect.runFork(ctx.emit({ type: "toggleSource", source }));
          }
        }
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      switch (event.type) {
        case "clear":
          yield* ctx.state.update((s) => ({
            ...s,
            outputLines: [],
            selectedLine: null
          }));
          break;
        case "copy": {
          const state = yield* ctx.state.get;
          const linesToCopy = state.outputLines.filter((line) => state.visibleSources[line.source]);
          const total = state.outputLines.length;
          const start3 = total - linesToCopy.length;
          const text = linesToCopy.map((l, index) => {
            const lineNumber = start3 + index + 1;
            const prefix = state.showLineNumbers ? `${lineNumber}: ` : "";
            return `${prefix}[${l.source}] ${l.text}`;
          }).join(`
`);
          if (typeof navigator !== "undefined" && navigator.clipboard) {
            try {
              yield* exports_Effect.promise(() => navigator.clipboard.writeText(text));
            } catch {}
          }
          break;
        }
        case "close":
          yield* ctx.state.update((s) => ({ ...s, visible: false }));
          break;
        case "open":
          yield* ctx.state.update((s) => ({ ...s, visible: true }));
          break;
        case "toggleAutoScroll":
          yield* ctx.state.update((s) => ({ ...s, autoScroll: !s.autoScroll }));
          break;
        case "toggleLineNumbers":
          yield* ctx.state.update((s) => ({
            ...s,
            showLineNumbers: !s.showLineNumbers,
            selectedLine: s.showLineNumbers ? null : s.selectedLine
          }));
          break;
        case "selectLine":
          yield* ctx.state.update((s) => ({
            ...s,
            selectedLine: s.selectedLine === event.lineNumber ? null : event.lineNumber
          }));
          break;
        case "toggleSource":
          yield* ctx.state.update((s) => ({
            ...s,
            visibleSources: {
              ...s.visibleSources,
              [event.source]: !s.visibleSources[event.source]
            },
            selectedLine: s.showLineNumbers ? s.selectedLine : null
          }));
          break;
      }
    }),
    subscriptions: (ctx) => {
      const socket = exports_Effect.map(SocketServiceTag, (s) => s);
      return [
        pipe(exports_Stream.unwrap(exports_Effect.map(socket, (s) => s.getMessages())), exports_Stream.filter((msg) => isTBMessage(msg)), exports_Stream.map((msg) => exports_Effect.gen(function* () {
          if (isTBRunStart(msg)) {
            yield* ctx.state.update((s) => ({
              ...s,
              runId: msg.runId,
              taskId: null,
              outputLines: [],
              visible: true,
              selectedLine: null,
              visibleSources: {
                agent: true,
                verification: true,
                system: true,
                tool: true
              }
            }));
          }
          if (isTBTaskOutput(msg)) {
            yield* ctx.state.update((s) => {
              if (s.runId && s.runId !== msg.runId)
                return s;
              const newLines = [
                ...s.outputLines,
                {
                  text: msg.text,
                  source: msg.source,
                  timestamp: Date.now()
                }
              ].slice(-s.maxLines);
              return {
                ...s,
                taskId: msg.taskId,
                outputLines: newLines
              };
            });
          }
          if (isATIFStep(msg)) {
            yield* ctx.state.update((s) => {
              if (s.runId && s.runId !== msg.runId)
                return s;
              const newLines = [...s.outputLines];
              const timestamp = Date.now();
              if (msg.step.tool_calls && msg.step.tool_calls.length > 0) {
                for (const toolCall of msg.step.tool_calls) {
                  newLines.push({
                    text: formatToolCall(toolCall),
                    source: "tool",
                    timestamp
                  });
                }
              }
              if (msg.step.observation?.results && msg.step.observation.results.length > 0) {
                for (const result of msg.step.observation.results) {
                  newLines.push({
                    text: formatObservationResult(result),
                    source: "tool",
                    timestamp
                  });
                }
              }
              return {
                ...s,
                outputLines: newLines.slice(-s.maxLines)
              };
            });
          }
          if (isTBRunComplete(msg)) {
            yield* ctx.state.update((s) => {
              if (s.runId !== msg.runId)
                return s;
              return {
                ...s,
                runId: null
              };
            });
          }
        })))
      ];
    }
  };
  var initialTBOutputState = TBOutputWidget.initialState();
  // src/effuse/widgets/mc-tasks.ts
  var getPriorityLabel = (priority) => {
    return `P${priority}`;
  };
  var getPriorityClasses = (priority) => {
    switch (priority) {
      case 0:
        return "bg-red-900/40 text-red-300 border-red-700/50";
      case 1:
        return "bg-orange-900/40 text-orange-300 border-orange-700/50";
      case 2:
        return "bg-zinc-800/50 text-zinc-200 border-zinc-600/50";
      case 3:
        return "bg-zinc-800/30 text-zinc-300 border-zinc-700/40";
      case 4:
        return "bg-zinc-900/30 text-zinc-400 border-zinc-700/30";
      default:
        return "bg-zinc-800/40 text-zinc-300 border-zinc-600/40";
    }
  };
  var getTypeBadgeClass = (type) => {
    switch (type) {
      case "bug":
        return "text-red-400";
      case "feature":
        return "text-emerald-400";
      case "task":
        return "text-blue-400";
      case "epic":
        return "text-violet-400";
      case "chore":
        return "text-zinc-400";
      default:
        return "text-zinc-400";
    }
  };
  var MCTasksWidget = {
    id: "mc-tasks",
    initialState: () => ({
      tasks: [],
      loading: false,
      error: null,
      collapsed: false,
      maxDisplay: 20,
      assigningId: null
    }),
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      const header = html`
        <div
          class="flex items-center justify-between px-4 py-3 border-b border-zinc-800/60 cursor-pointer"
          data-action="toggleCollapse"
        >
          <h2 class="text-zinc-100 font-bold font-mono text-lg">
            Ready Tasks (${state.tasks.length})
          </h2>
          <div class="flex items-center gap-3">
            <button
              class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
              data-action="load"
            >
              ${state.loading ? "Loading..." : "Refresh"}
            </button>
            <span class="text-zinc-500">${state.collapsed ? "" : ""}</span>
          </div>
        </div>
      `;
      if (state.loading && state.tasks.length === 0) {
        return html`
          <div class="rounded-2xl border border-zinc-800/60 bg-zinc-950/80 shadow-2xl backdrop-blur-xl">
            ${header}
            <div class="flex items-center justify-center py-8">
              <div class="text-zinc-400 font-mono text-sm">Loading ready tasks...</div>
            </div>
          </div>
        `;
      }
      if (state.error && state.tasks.length === 0) {
        return html`
          <div class="rounded-2xl border border-zinc-800/60 bg-zinc-950/80 shadow-2xl backdrop-blur-xl">
            ${header}
            <div class="flex items-center justify-center py-8">
              <div class="text-red-400 font-mono text-sm">${state.error}</div>
            </div>
          </div>
        `;
      }
      if (state.tasks.length === 0) {
        return html`
          <div class="rounded-2xl border border-zinc-800/60 bg-zinc-950/80 shadow-2xl backdrop-blur-xl">
            ${header}
            <div class="flex items-center justify-center py-8">
              <div class="text-zinc-500 font-mono text-sm">No ready tasks found</div>
            </div>
          </div>
        `;
      }
      if (state.collapsed) {
        return html`
          <div class="rounded-2xl border border-zinc-800/60 bg-zinc-950/80 shadow-2xl backdrop-blur-xl">
            ${header}
          </div>
        `;
      }
      const taskRows = state.tasks.slice(0, state.maxDisplay).map((task) => {
        const prioClasses = getPriorityClasses(task.priority);
        const prioLabel = getPriorityLabel(task.priority);
        const typeClass = getTypeBadgeClass(task.type);
        const labelsStr = task.labels.slice(0, 2).join(", ");
        const isAssigning = state.assigningId === task.id;
        return html`
          <tr class="border-b border-zinc-800/40 last:border-0 hover:bg-zinc-900/30">
            <td class="py-2 px-3">
              <span class="inline-flex items-center px-1.5 py-0.5 text-[10px] font-bold rounded border ${prioClasses}">
                ${prioLabel}
              </span>
            </td>
            <td class="py-2 px-3">
              <code class="text-zinc-500 font-mono text-[10px]">${task.id}</code>
            </td>
            <td class="py-2 px-3">
              <span class="font-medium font-mono text-zinc-100 text-sm" title="${task.title}">
                ${task.title.length > 50 ? task.title.slice(0, 50) + "..." : task.title}
              </span>
            </td>
            <td class="py-2 px-3">
              <span class="${typeClass} font-mono text-xs">${task.type}</span>
            </td>
            <td class="py-2 px-3">
              <span class="text-zinc-400 font-mono text-xs">${labelsStr}</span>
            </td>
            <td class="py-2 px-3">
              <button
                class="inline-flex items-center justify-center border px-3 py-1 text-[10px] font-mono font-semibold uppercase rounded transition-colors
                       ${isAssigning ? "border-zinc-600 text-zinc-500 bg-zinc-800/40 cursor-not-allowed" : "border-zinc-700 text-zinc-50 bg-zinc-900/80 hover:bg-zinc-900/95"}"
                data-action="assign"
                data-task-id="${task.id}"
                ${isAssigning ? "disabled" : ""}
              >
                ${isAssigning ? "Starting..." : "Assign"}
              </button>
            </td>
          </tr>
        `;
      });
      const moreIndicator = state.tasks.length > state.maxDisplay ? html`
              <div class="px-4 py-2 border-t border-zinc-800/60 text-center text-xs font-mono text-zinc-500">
                + ${state.tasks.length - state.maxDisplay} more tasks...
              </div>
            ` : "";
      return html`
        <div class="rounded-2xl border border-zinc-800/60 bg-zinc-950/80 shadow-2xl backdrop-blur-xl max-h-[70vh] overflow-hidden">
          ${header}
          <div class="overflow-x-auto max-h-[calc(70vh-60px)] overflow-y-auto">
            <table class="min-w-full table-auto text-xs font-mono text-zinc-200">
              <thead>
                <tr class="text-zinc-500 uppercase text-[9px] tracking-[0.4em] bg-zinc-900/40">
                  <th class="w-12 px-3 py-2 text-left">Pri</th>
                  <th class="w-24 px-3 py-2 text-left">ID</th>
                  <th class="px-3 py-2 text-left">Title</th>
                  <th class="w-20 px-3 py-2 text-left">Type</th>
                  <th class="w-32 px-3 py-2 text-left">Labels</th>
                  <th class="w-24 px-3 py-2 text-left">Action</th>
                </tr>
              </thead>
              <tbody>
                ${joinTemplates(taskRows)}
              </tbody>
            </table>
          </div>
          ${moreIndicator}
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (e, target) => {
        const el = target;
        const action = el.dataset.action;
        const taskId = el.dataset.taskId;
        if (action === "load") {
          e.stopPropagation();
          exports_Effect.runFork(ctx.emit({ type: "load" }));
        } else if (action === "toggleCollapse") {
          exports_Effect.runFork(ctx.emit({ type: "toggleCollapse" }));
        } else if (action === "assign" && taskId) {
          e.stopPropagation();
          exports_Effect.runFork(ctx.emit({ type: "assign", taskId }));
        }
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      const socket = yield* SocketServiceTag;
      switch (event.type) {
        case "load":
          yield* ctx.state.update((s) => ({ ...s, loading: true, error: null }));
          const result = yield* socket.loadReadyTasks(50).pipe(exports_Effect.map((tasks) => ({ tasks, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ tasks: [], error: e.message })));
          yield* ctx.state.update((s) => ({
            ...s,
            loading: false,
            tasks: result.tasks,
            error: result.error
          }));
          break;
        case "toggleCollapse":
          yield* ctx.state.update((s) => ({ ...s, collapsed: !s.collapsed }));
          break;
        case "assign":
          yield* ctx.state.update((s) => ({ ...s, assigningId: event.taskId }));
          const assignResult = yield* socket.assignTaskToMC(event.taskId, { sandbox: true }).pipe(exports_Effect.map(() => ({ success: true, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ success: false, error: e.message })));
          if (assignResult.success) {
            yield* ctx.state.update((s) => ({
              ...s,
              assigningId: null,
              tasks: s.tasks.filter((t) => t.id !== event.taskId)
            }));
          } else {
            yield* ctx.state.update((s) => ({
              ...s,
              assigningId: null,
              error: assignResult.error
            }));
          }
          break;
      }
    })
  };
  var initialMCTasksState = MCTasksWidget.initialState();
  // src/effuse/widgets/tb-controls.ts
  var getDifficultyClass = (difficulty) => {
    switch (difficulty.toLowerCase()) {
      case "easy":
        return "bg-emerald-900/40 text-emerald-300 border-emerald-700/50";
      case "medium":
        return "bg-amber-900/40 text-amber-300 border-amber-700/50";
      case "hard":
        return "bg-red-900/40 text-red-300 border-red-700/50";
      default:
        return "bg-zinc-800/40 text-zinc-300 border-zinc-700/50";
    }
  };
  var getStatusColorClass2 = (statusType) => {
    switch (statusType) {
      case "running":
        return "text-blue-400";
      case "error":
        return "text-red-400";
      case "success":
        return "text-emerald-400";
      case "loading":
        return "text-zinc-400";
      default:
        return "text-zinc-500";
    }
  };
  var formatDuration3 = (ms) => {
    const totalSeconds = Math.floor(ms / 1000);
    const hours2 = Math.floor(totalSeconds / 3600);
    const minutes2 = Math.floor(totalSeconds % 3600 / 60);
    const seconds2 = totalSeconds % 60;
    return `${String(hours2).padStart(2, "0")}:${String(minutes2).padStart(2, "0")}:${String(seconds2).padStart(2, "0")}`;
  };
  var isTBRunStart2 = (msg) => msg.type === "tb_run_start";
  var isTBRunComplete2 = (msg) => msg.type === "tb_run_complete";
  var isTBTaskComplete = (msg) => msg.type === "tb_task_complete";
  var isTBMessage2 = (msg) => isTBRunStart2(msg) || isTBRunComplete2(msg) || isTBTaskComplete(msg);
  var TBControlsWidget = {
    id: "tb-controls",
    initialState: () => ({
      suitePath: "./tasks/terminal-bench-2.json",
      suite: null,
      selectedTaskIds: new Set,
      loading: false,
      status: "Ready",
      statusType: "idle",
      isRunning: false,
      runId: null,
      collapsed: false,
      totalTasks: 0,
      completedTasks: 0,
      passedTasks: 0,
      failedTasks: 0,
      startedAt: null,
      duration: null,
      difficultyFilter: null,
      searchFilter: ""
    }),
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      const statusColor = getStatusColorClass2(state.statusType);
      const header = html`
        <div
          class="flex items-center justify-between px-4 py-3 border-b border-zinc-800/60 cursor-pointer"
          data-action="toggleCollapse"
        >
          <div class="flex items-center gap-3">
            <h2 class="text-zinc-100 font-bold font-mono text-lg">Terminal-Bench</h2>
            <span class="text-xs ${statusColor}">${state.status}</span>
          </div>
          <span class="text-zinc-500">${state.collapsed ? "" : ""}</span>
        </div>
      `;
      if (state.collapsed) {
        return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header}
          </div>
        `;
      }
      const pathInput = html`
        <div class="flex items-center gap-2 px-4 py-3 border-b border-zinc-800/40">
          <input
            type="text"
            class="flex-1 bg-zinc-900/60 border border-zinc-700/50 rounded px-3 py-2 text-sm font-mono text-zinc-200 placeholder-zinc-500 focus:border-zinc-600/60 focus:outline-none"
            placeholder="Path to suite..."
            value="${state.suitePath}"
            data-input="suitePath"
            ${state.isRunning ? "disabled" : ""}
          />
          <button
            class="px-3 py-2 text-xs font-mono uppercase rounded border transition-colors
                   ${state.isRunning ? "border-zinc-700 text-zinc-500 bg-zinc-800/40 cursor-not-allowed" : "border-zinc-700 text-zinc-200 bg-zinc-900/80 hover:bg-zinc-900/95"}"
            data-action="loadSuite"
            ${state.isRunning ? "disabled" : ""}
          >
            ${state.loading ? "Loading..." : "Load"}
          </button>
        </div>
      `;
      const controls = html`
        <div class="flex items-center gap-2 px-4 py-3 border-b border-zinc-800/40">
          <button
            class="px-4 py-2 text-xs font-mono uppercase rounded border transition-colors
                   ${state.isRunning || !state.suite ? "border-zinc-700 text-zinc-500 bg-zinc-800/40 cursor-not-allowed" : "border-emerald-700 text-emerald-300 bg-emerald-900/40 hover:bg-emerald-900/60"}"
            data-action="startRun"
            ${state.isRunning || !state.suite ? "disabled" : ""}
          >
            Start
          </button>
          <button
            class="px-4 py-2 text-xs font-mono uppercase rounded border transition-colors
                   ${state.isRunning || !state.suite ? "border-zinc-700 text-zinc-500 bg-zinc-800/40 cursor-not-allowed" : "border-violet-700 text-violet-300 bg-violet-900/40 hover:bg-violet-900/60"}"
            data-action="startRandomTask"
            ${state.isRunning || !state.suite ? "disabled" : ""}
          >
            Random
          </button>
          <button
            class="px-4 py-2 text-xs font-mono uppercase rounded border transition-colors
                   ${!state.isRunning ? "border-zinc-700 text-zinc-500 bg-zinc-800/40 cursor-not-allowed" : "border-red-700 text-red-300 bg-red-900/40 hover:bg-red-900/60"}"
            data-action="stopRun"
            ${!state.isRunning ? "disabled" : ""}
          >
            Stop
          </button>
          <span class="flex-1"></span>
          <span class="text-xs text-zinc-500 font-mono">
            ${state.selectedTaskIds.size}/${state.suite?.tasks.length ?? 0} selected
          </span>
        </div>
      `;
      const progressPercent = state.totalTasks > 0 ? Math.round(state.completedTasks / state.totalTasks * 100) : 0;
      const passPercent = state.totalTasks > 0 ? Math.round(state.passedTasks / state.totalTasks * 100) : 0;
      const failPercent = state.totalTasks > 0 ? Math.round(state.failedTasks / state.totalTasks * 100) : 0;
      const elapsedMs = state.startedAt ? state.duration ?? Date.now() - state.startedAt : state.duration ?? 0;
      const durationDisplay = elapsedMs > 0 ? formatDuration3(elapsedMs) : null;
      const progressBar = state.isRunning || state.completedTasks > 0 ? html`
        <div class="px-4 py-2 border-b border-zinc-800/40" data-testid="progress-bar">
          <div class="flex items-center justify-between mb-1">
            <div class="flex items-center gap-3">
              <span class="text-xs font-mono text-zinc-400">
                Progress: ${state.completedTasks}/${state.totalTasks} (${progressPercent}%)
              </span>
              ${durationDisplay ? html`<span class="text-xs font-mono text-zinc-500" data-testid="run-duration"> ${durationDisplay}</span>` : ""}
            </div>
            <span class="text-xs font-mono">
              <span class="text-emerald-400">${state.passedTasks}</span>
              <span class="text-zinc-500 mx-1">|</span>
              <span class="text-red-400">${state.failedTasks}</span>
            </span>
          </div>
          <div class="h-2 bg-zinc-800 rounded-full overflow-hidden">
            <div class="h-full flex">
              <div
                class="bg-emerald-500 transition-all duration-300"
                style="width: ${passPercent}%"
                data-testid="progress-passed"
              ></div>
              <div
                class="bg-red-500 transition-all duration-300"
                style="width: ${failPercent}%"
                data-testid="progress-failed"
              ></div>
            </div>
          </div>
        </div>
      ` : "";
      const taskList = state.suite ? html`
            <div class="border-b border-zinc-800/40">
              <div class="flex items-center justify-between px-4 py-2 bg-zinc-900/40">
                <span class="text-xs text-zinc-400 font-mono">
                  ${state.suite.name} v${state.suite.version}
                </span>
                <div class="flex items-center gap-2">
                  <button
                    class="text-xs text-zinc-400 hover:text-zinc-200 transition-colors"
                    data-action="selectAll"
                  >
                    All
                  </button>
                  <span class="text-zinc-600">|</span>
                  <button
                    class="text-xs text-zinc-400 hover:text-zinc-200 transition-colors"
                    data-action="selectNone"
                  >
                    None
                  </button>
                </div>
              </div>
              <div class="flex items-center gap-2 px-4 py-2 border-b border-zinc-800/40 bg-zinc-900/20">
                <input
                  type="text"
                  class="flex-1 bg-zinc-900/60 border border-zinc-700/50 rounded px-2 py-1 text-xs font-mono text-zinc-200 placeholder-zinc-500 focus:border-zinc-600/60 focus:outline-none"
                  placeholder="Search tasks..."
                  value="${state.searchFilter}"
                  data-input="searchFilter"
                />
                <select
                  class="bg-zinc-900/60 border border-zinc-700/50 rounded px-2 py-1 text-xs font-mono text-zinc-200 focus:border-zinc-600/60 focus:outline-none"
                  data-input="difficultyFilter"
                >
                  <option value="" ${!state.difficultyFilter ? "selected" : ""}>All Difficulties</option>
                  <option value="easy" ${state.difficultyFilter === "easy" ? "selected" : ""}>Easy</option>
                  <option value="medium" ${state.difficultyFilter === "medium" ? "selected" : ""}>Medium</option>
                  <option value="hard" ${state.difficultyFilter === "hard" ? "selected" : ""}>Hard</option>
                </select>
              </div>
              <div class="max-h-60 overflow-y-auto">
                ${joinTemplates(state.suite.tasks.filter((task) => {
        if (state.difficultyFilter && task.difficulty.toLowerCase() !== state.difficultyFilter.toLowerCase()) {
          return false;
        }
        if (state.searchFilter) {
          const search = state.searchFilter.toLowerCase();
          return task.name.toLowerCase().includes(search) || task.id.toLowerCase().includes(search);
        }
        return true;
      }).map((task) => {
        const isSelected = state.selectedTaskIds.has(task.id);
        const diffClass = getDifficultyClass(task.difficulty);
        return html`
                      <label
                        class="flex items-center gap-3 px-4 py-2 hover:bg-zinc-900/40 cursor-pointer transition-colors"
                      >
                        <input
                          type="checkbox"
                          class="form-checkbox rounded border-zinc-600 bg-zinc-800 text-blue-500 focus:ring-blue-500/20"
                          data-action="toggleTask"
                          data-task-id="${task.id}"
                          ${isSelected ? "checked" : ""}
                        />
                        <span class="flex-1 text-sm font-mono text-zinc-200 truncate" title="${task.name}">
                          ${task.name}
                        </span>
                        <span class="text-xs px-1.5 py-0.5 rounded border ${diffClass}">
                          ${task.difficulty}
                        </span>
                      </label>
                    `;
      }))}
              </div>
            </div>
          ` : "";
      return html`
        <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm overflow-hidden">
          ${header}
          ${pathInput}
          ${controls}
          ${progressBar}
          ${taskList}
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (e, target) => {
        const el = target;
        const action = el.dataset.action;
        const taskId = el.dataset.taskId;
        if (action === "toggleCollapse") {
          exports_Effect.runFork(ctx.emit({ type: "toggleCollapse" }));
        } else if (action === "loadSuite") {
          e.stopPropagation();
          exports_Effect.runFork(ctx.emit({ type: "loadSuite" }));
        } else if (action === "startRun") {
          e.stopPropagation();
          exports_Effect.runFork(ctx.emit({ type: "startRun" }));
        } else if (action === "startRandomTask") {
          e.stopPropagation();
          exports_Effect.runFork(ctx.emit({ type: "startRandomTask" }));
        } else if (action === "stopRun") {
          e.stopPropagation();
          exports_Effect.runFork(ctx.emit({ type: "stopRun" }));
        } else if (action === "selectAll") {
          e.stopPropagation();
          exports_Effect.runFork(ctx.emit({ type: "selectAll" }));
        } else if (action === "selectNone") {
          e.stopPropagation();
          exports_Effect.runFork(ctx.emit({ type: "selectNone" }));
        } else if (action === "toggleTask" && taskId) {
          exports_Effect.runFork(ctx.emit({ type: "toggleTask", taskId }));
        }
      });
      yield* ctx.dom.delegate(ctx.container, "[data-input]", "input", (_e, target) => {
        const el = target;
        const inputType = el.dataset.input;
        if (inputType === "suitePath") {
          exports_Effect.runFork(ctx.emit({ type: "setSuitePath", path: el.value }));
        } else if (inputType === "searchFilter") {
          exports_Effect.runFork(ctx.emit({ type: "setSearchFilter", search: el.value }));
        } else if (inputType === "difficultyFilter") {
          exports_Effect.runFork(ctx.emit({ type: "setDifficultyFilter", difficulty: el.value || null }));
        }
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      const socket = yield* SocketServiceTag;
      switch (event.type) {
        case "setSuitePath":
          yield* ctx.state.update((s) => ({ ...s, suitePath: event.path }));
          break;
        case "loadSuite": {
          const state = yield* ctx.state.get;
          if (!state.suitePath.trim()) {
            yield* ctx.state.update((s) => ({ ...s, status: "No path", statusType: "error" }));
            return;
          }
          yield* ctx.state.update((s) => ({ ...s, loading: true, status: "Loading...", statusType: "loading" }));
          const result = yield* socket.loadTBSuite(state.suitePath).pipe(exports_Effect.map((suite) => ({ suite, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ suite: null, error: e.message })));
          if (result.error) {
            yield* ctx.state.update((s) => ({
              ...s,
              loading: false,
              suite: null,
              selectedTaskIds: new Set,
              status: "Load failed",
              statusType: "error"
            }));
          } else if (result.suite) {
            const allIds = new Set(result.suite.tasks.map((t) => t.id));
            yield* ctx.state.update((s) => ({
              ...s,
              loading: false,
              suite: result.suite,
              selectedTaskIds: allIds,
              status: "Ready",
              statusType: "idle"
            }));
          }
          break;
        }
        case "startRun": {
          const state = yield* ctx.state.get;
          if (!state.suite || state.selectedTaskIds.size === 0)
            return;
          yield* ctx.state.update((s) => ({
            ...s,
            isRunning: true,
            status: "Starting...",
            statusType: "running",
            totalTasks: s.selectedTaskIds.size,
            completedTasks: 0,
            passedTasks: 0,
            failedTasks: 0,
            startedAt: Date.now(),
            duration: null
          }));
          const result = yield* socket.startTBRun({
            suitePath: state.suitePath,
            taskIds: Array.from(state.selectedTaskIds),
            timeout: 300000,
            maxTurns: 10
          }).pipe(exports_Effect.map((res) => ({ runId: res.runId, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ runId: null, error: e.message })));
          if (result.error) {
            yield* ctx.state.update((s) => ({
              ...s,
              isRunning: false,
              status: "Start failed",
              statusType: "error"
            }));
          } else {
            yield* ctx.state.update((s) => ({
              ...s,
              runId: result.runId,
              status: "Running...",
              statusType: "running"
            }));
          }
          break;
        }
        case "startRandomTask": {
          const state = yield* ctx.state.get;
          if (!state.suite || state.suite.tasks.length === 0)
            return;
          const randomIndex = Math.floor(Math.random() * state.suite.tasks.length);
          const randomTask = state.suite.tasks[randomIndex];
          yield* ctx.state.update((s) => ({
            ...s,
            isRunning: true,
            status: `Random: ${randomTask.name}`,
            statusType: "running",
            totalTasks: 1,
            completedTasks: 0,
            passedTasks: 0,
            failedTasks: 0,
            startedAt: Date.now(),
            duration: null
          }));
          const result = yield* socket.startTBRun({
            suitePath: state.suitePath,
            taskIds: [randomTask.id],
            timeout: 300000,
            maxTurns: 10
          }).pipe(exports_Effect.map((res) => ({ runId: res.runId, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ runId: null, error: e.message })));
          if (result.error) {
            yield* ctx.state.update((s) => ({
              ...s,
              isRunning: false,
              status: "Start failed",
              statusType: "error"
            }));
          } else {
            yield* ctx.state.update((s) => ({
              ...s,
              runId: result.runId,
              status: "Running...",
              statusType: "running"
            }));
          }
          break;
        }
        case "stopRun": {
          yield* ctx.state.update((s) => ({ ...s, status: "Stopping...", statusType: "loading" }));
          const result = yield* socket.stopTBRun().pipe(exports_Effect.map((res) => ({ stopped: res.stopped, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ stopped: false, error: e.message })));
          yield* ctx.state.update((s) => ({
            ...s,
            isRunning: false,
            runId: null,
            status: result.stopped ? "Stopped" : "No active run",
            statusType: result.error ? "error" : "idle"
          }));
          break;
        }
        case "selectAll": {
          const state = yield* ctx.state.get;
          if (!state.suite)
            return;
          const allIds = new Set(state.suite.tasks.map((t) => t.id));
          yield* ctx.state.update((s) => ({ ...s, selectedTaskIds: allIds }));
          break;
        }
        case "selectNone":
          yield* ctx.state.update((s) => ({ ...s, selectedTaskIds: new Set }));
          break;
        case "toggleTask": {
          yield* ctx.state.update((s) => {
            const newSelected = new Set(s.selectedTaskIds);
            if (newSelected.has(event.taskId)) {
              newSelected.delete(event.taskId);
            } else {
              newSelected.add(event.taskId);
            }
            return { ...s, selectedTaskIds: newSelected };
          });
          break;
        }
        case "setDifficultyFilter":
          yield* ctx.state.update((s) => ({ ...s, difficultyFilter: event.difficulty }));
          break;
        case "setSearchFilter":
          yield* ctx.state.update((s) => ({ ...s, searchFilter: event.search }));
          break;
        case "toggleCollapse":
          yield* ctx.state.update((s) => ({ ...s, collapsed: !s.collapsed }));
          break;
      }
    }),
    subscriptions: (ctx) => {
      const socket = exports_Effect.map(SocketServiceTag, (s) => s);
      return [
        pipe(exports_Stream.unwrap(exports_Effect.map(socket, (s) => s.getMessages())), exports_Stream.filter((msg) => isTBMessage2(msg)), exports_Stream.map((msg) => exports_Effect.gen(function* () {
          if (isTBRunStart2(msg)) {
            yield* ctx.state.update((s) => ({
              ...s,
              isRunning: true,
              runId: msg.runId,
              status: "Running...",
              statusType: "running"
            }));
          }
          if (isTBTaskComplete(msg)) {
            yield* ctx.state.update((s) => {
              if (s.runId !== msg.runId)
                return s;
              const isPassed = msg.outcome === "success";
              return {
                ...s,
                completedTasks: s.completedTasks + 1,
                passedTasks: s.passedTasks + (isPassed ? 1 : 0),
                failedTasks: s.failedTasks + (isPassed ? 0 : 1),
                status: `${s.completedTasks + 1}/${s.totalTasks} tasks`
              };
            });
          }
          if (isTBRunComplete2(msg)) {
            yield* ctx.state.update((s) => {
              if (s.runId !== msg.runId)
                return s;
              const passRate = s.totalTasks > 0 ? Math.round(s.passedTasks / s.totalTasks * 100) : 0;
              const duration2 = s.startedAt ? Date.now() - s.startedAt : 0;
              return {
                ...s,
                isRunning: false,
                runId: null,
                status: `Complete: ${passRate}% (${s.passedTasks}/${s.totalTasks})`,
                statusType: "success",
                duration: duration2,
                startedAt: null
              };
            });
          }
        })))
      ];
    }
  };
  var initialTBControlsState = TBControlsWidget.initialState();
  // src/effuse/widgets/category-tree.ts
  var getStatusIcon2 = (status2) => {
    switch (status2) {
      case "passed":
        return "";
      case "failed":
        return "";
      case "error":
        return "";
      case "timeout":
        return "";
      case "running":
        return "";
      default:
        return "";
    }
  };
  var getStatusColorClass3 = (status2) => {
    switch (status2) {
      case "passed":
        return "text-emerald-400";
      case "failed":
        return "text-red-400";
      case "error":
        return "text-orange-400";
      case "timeout":
        return "text-amber-400";
      case "running":
        return "text-blue-400";
      default:
        return "text-zinc-500";
    }
  };
  var getDifficultyClass2 = (difficulty) => {
    switch (difficulty.toLowerCase()) {
      case "easy":
        return "bg-emerald-900/40 text-emerald-300";
      case "medium":
        return "bg-amber-900/40 text-amber-300";
      case "hard":
        return "bg-red-900/40 text-red-300";
      default:
        return "bg-zinc-800/40 text-zinc-300";
    }
  };
  var groupTasksByCategory = (tasks) => {
    const categories = new Map;
    for (const task of tasks.values()) {
      const cat = task.category || "uncategorized";
      if (!categories.has(cat)) {
        categories.set(cat, { category: cat, tasks: [], passed: 0, failed: 0, pending: 0, total: 0 });
      }
      const catData = categories.get(cat);
      catData.tasks.push(task);
      catData.total++;
      if (task.status === "passed")
        catData.passed++;
      if (task.status === "failed" || task.status === "error" || task.status === "timeout") {
        catData.failed++;
      }
      if (task.status === "pending")
        catData.pending++;
    }
    return categories;
  };
  var isTBTaskStart = (msg) => msg.type === "tb_task_start";
  var isTBTaskComplete2 = (msg) => msg.type === "tb_task_complete";
  var isTBSuiteInfo = (msg) => msg.type === "tb_suite_info";
  var isTBMessage3 = (msg) => isTBTaskStart(msg) || isTBTaskComplete2(msg) || isTBSuiteInfo(msg);
  var CategoryTreeWidget = {
    id: "category-tree",
    initialState: () => ({
      tasks: new Map,
      collapsedCategories: new Set,
      visible: false,
      selectedTaskId: null
    }),
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      if (!state.visible) {
        return html`<div class="hidden"></div>`;
      }
      const categories = groupTasksByCategory(state.tasks);
      const header = html`
        <div class="flex items-center justify-between px-3 py-2 border-b border-zinc-800/60 bg-zinc-900/80">
          <span class="text-sm font-medium text-zinc-300">Categories</span>
          <div class="flex items-center gap-2">
            <button
              class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
              data-action="expandAll"
            >
              Expand
            </button>
            <button
              class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
              data-action="collapseAll"
            >
              Collapse
            </button>
            <button
              class="text-zinc-500 hover:text-zinc-300 transition-colors"
              data-action="hide"
            >
              
            </button>
          </div>
        </div>
      `;
      if (categories.size === 0) {
        return html`
          <div class="fixed right-4 top-20 w-72 rounded-lg border border-zinc-800/60 bg-zinc-950/95 shadow-xl backdrop-blur-sm overflow-hidden">
            ${header}
            <div class="p-4 text-center">
              <span class="text-sm text-zinc-500">No tasks loaded</span>
            </div>
          </div>
        `;
      }
      const categoryList = Array.from(categories.entries()).sort(([a], [b]) => a.localeCompare(b)).map(([catName, catData]) => {
        const isCollapsed = state.collapsedCategories.has(catName);
        const statsHtml = catData.passed > 0 || catData.failed > 0 ? html`
                  <span class="text-xs text-emerald-400">${catData.passed}</span>
                  <span class="text-xs text-red-400">${catData.failed}</span>
                ` : "";
        const taskItems = catData.tasks.map((task) => {
          const icon = getStatusIcon2(task.status);
          const statusColor = getStatusColorClass3(task.status);
          const diffClass = getDifficultyClass2(task.difficulty);
          const isSelected = state.selectedTaskId === task.id;
          const isRunning3 = task.status === "running";
          return html`
              <div
                class="flex items-center gap-2 px-3 py-1.5 hover:bg-zinc-900/40 cursor-pointer transition-colors
                       ${isSelected ? "bg-zinc-800/60" : ""} ${isRunning3 ? "animate-pulse" : ""}"
                data-action="selectTask"
                data-task-id="${task.id}"
              >
                <span class="${statusColor}">${icon}</span>
                <span class="flex-1 text-xs text-zinc-300 truncate" title="${task.name}">
                  ${task.name}
                </span>
                ${task.difficulty ? html`<span class="text-[9px] px-1 py-0.5 rounded ${diffClass}">${task.difficulty.slice(0, 1).toUpperCase()}</span>` : ""}
              </div>
            `;
        });
        return html`
            <div class="border-b border-zinc-800/40 last:border-0">
              <div
                class="flex items-center gap-2 px-3 py-2 hover:bg-zinc-900/40 cursor-pointer transition-colors"
                data-action="toggleCategory"
                data-category="${catName}"
              >
                <span class="text-zinc-500 text-xs">${isCollapsed ? "" : ""}</span>
                <span class="flex-1 text-sm font-medium text-zinc-200">${catName}</span>
                <div class="flex items-center gap-2">
                  ${statsHtml}
                  <span class="text-xs text-zinc-500">${catData.total}</span>
                </div>
              </div>
              ${isCollapsed ? "" : html`<div class="pb-1">${joinTemplates(taskItems)}</div>`}
            </div>
          `;
      });
      return html`
        <div class="fixed right-4 top-20 w-72 max-h-[70vh] flex flex-col rounded-lg border border-zinc-800/60 bg-zinc-950/95 shadow-xl backdrop-blur-sm overflow-hidden">
          ${header}
          <div class="flex-1 overflow-y-auto">
            ${joinTemplates(categoryList)}
          </div>
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (_e, target) => {
        const el = target;
        const action = el.dataset.action;
        const category = el.dataset.category;
        const taskId = el.dataset.taskId;
        if (action === "hide") {
          exports_Effect.runFork(ctx.emit({ type: "hide" }));
        } else if (action === "expandAll") {
          exports_Effect.runFork(ctx.emit({ type: "expandAll" }));
        } else if (action === "collapseAll") {
          exports_Effect.runFork(ctx.emit({ type: "collapseAll" }));
        } else if (action === "toggleCategory" && category) {
          exports_Effect.runFork(ctx.emit({ type: "toggleCategory", category }));
        } else if (action === "selectTask" && taskId) {
          exports_Effect.runFork(ctx.emit({ type: "selectTask", taskId }));
        }
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      switch (event.type) {
        case "show":
          yield* ctx.state.update((s) => ({ ...s, visible: true }));
          break;
        case "hide":
          yield* ctx.state.update((s) => ({ ...s, visible: false }));
          break;
        case "toggleCategory":
          yield* ctx.state.update((s) => {
            const newCollapsed = new Set(s.collapsedCategories);
            if (newCollapsed.has(event.category)) {
              newCollapsed.delete(event.category);
            } else {
              newCollapsed.add(event.category);
            }
            return { ...s, collapsedCategories: newCollapsed };
          });
          break;
        case "expandAll":
          yield* ctx.state.update((s) => ({ ...s, collapsedCategories: new Set }));
          break;
        case "collapseAll": {
          const state = yield* ctx.state.get;
          const categories = groupTasksByCategory(state.tasks);
          const allCategories = new Set(categories.keys());
          yield* ctx.state.update((s) => ({ ...s, collapsedCategories: allCategories }));
          break;
        }
        case "selectTask":
          yield* ctx.state.update((s) => ({ ...s, selectedTaskId: event.taskId }));
          break;
      }
    }),
    subscriptions: (ctx) => {
      const socket = exports_Effect.map(SocketServiceTag, (s) => s);
      return [
        pipe(exports_Stream.unwrap(exports_Effect.map(socket, (s) => s.getMessages())), exports_Stream.filter((msg) => isTBMessage3(msg)), exports_Stream.map((msg) => exports_Effect.gen(function* () {
          if (isTBSuiteInfo(msg)) {
            const newTasks = new Map;
            for (const task of msg.tasks) {
              newTasks.set(task.id, {
                id: task.id,
                name: task.name,
                difficulty: task.difficulty,
                category: task.category,
                status: "pending"
              });
            }
            yield* ctx.state.update((s) => ({
              ...s,
              tasks: newTasks,
              visible: true
            }));
          }
          if (isTBTaskStart(msg)) {
            yield* ctx.state.update((s) => {
              const task = s.tasks.get(msg.taskId);
              if (!task)
                return s;
              const newTasks = new Map(s.tasks);
              newTasks.set(msg.taskId, { ...task, status: "running" });
              return { ...s, tasks: newTasks };
            });
          }
          if (isTBTaskComplete2(msg)) {
            yield* ctx.state.update((s) => {
              const task = s.tasks.get(msg.taskId);
              if (!task)
                return s;
              const newTasks = new Map(s.tasks);
              const status2 = msg.outcome;
              newTasks.set(msg.taskId, { ...task, status: status2 });
              return { ...s, tasks: newTasks };
            });
          }
        })))
      ];
    }
  };
  var initialCategoryTreeState = CategoryTreeWidget.initialState();
  // src/effuse/widgets/hf-trajectory-list.ts
  var extractMetadata = (trajectory, index) => {
    const agent = trajectory.agent;
    const extra = trajectory.extra;
    return {
      sessionId: trajectory.session_id,
      agentName: agent?.name ?? "unknown",
      modelName: agent?.model_name ?? "unknown",
      task: extra?.task ?? "unknown",
      episode: extra?.episode ?? "unknown",
      date: extra?.date ?? trajectory.steps[0]?.timestamp ?? new Date().toISOString(),
      stepCount: trajectory.steps.length,
      index
    };
  };
  var filterTrajectories = (trajectories, query) => {
    if (!query.trim())
      return trajectories;
    const lowercaseQuery = query.toLowerCase();
    return trajectories.filter((t) => t.agentName.toLowerCase().includes(lowercaseQuery) || t.task.toLowerCase().includes(lowercaseQuery) || t.episode.toLowerCase().includes(lowercaseQuery) || t.sessionId.toLowerCase().includes(lowercaseQuery));
  };
  var formatDate2 = (iso) => {
    try {
      return new Date(iso).toLocaleDateString(undefined, {
        month: "short",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      });
    } catch {
      return iso.slice(0, 10);
    }
  };
  var HFTrajectoryListWidget = {
    id: "hf-trajectory-list",
    initialState: () => {
      if (typeof window !== "undefined" && window.bunLog) {
        window.bunLog("[HFTrajectoryList] Creating initial state");
      }
      return {
        trajectories: [],
        filteredTrajectories: [],
        selectedSessionId: null,
        searchQuery: "",
        currentPage: 0,
        pageSize: 100,
        totalCount: 0,
        loading: true,
        error: null,
        collapsed: false
      };
    },
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      if (typeof window !== "undefined" && window.bunLog) {
        window.bunLog(`[HFTrajectoryList] Rendering, loading=${state.loading}, totalCount=${state.totalCount}, trajectories=${state.trajectories.length}, error=${state.error}`);
      }
      const header = html`
        <div
          class="flex items-center justify-between px-4 py-3 border-b border-zinc-800/60 cursor-pointer bg-zinc-900/40"
          data-action="toggleCollapse"
        >
          <div class="flex items-center gap-2">
            <h3 class="text-sm font-bold font-mono text-zinc-100">Trajectories</h3>
            ${state.totalCount > 0 ? html`<span class="text-xs text-zinc-400">(${state.totalCount})</span>` : ""}
          </div>
          <span class="text-zinc-500">${state.collapsed ? "" : ""}</span>
        </div>
      `;
      if (state.collapsed) {
        return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header}
          </div>
        `;
      }
      const searchInput = html`
        <div class="px-4 pt-3 pb-2">
          <input
            type="text"
            placeholder="Search by agent, task, episode..."
            class="w-full px-3 py-2 bg-zinc-900 border border-zinc-800 rounded text-zinc-100 text-sm placeholder:text-zinc-500 focus:border-zinc-700 focus:outline-none"
            data-action="search"
            value="${state.searchQuery}"
          />
        </div>
      `;
      const startIndex = state.currentPage * state.pageSize + 1;
      const endIndex = Math.min((state.currentPage + 1) * state.pageSize, state.totalCount);
      const pageInfo = html`
        <div class="px-4 py-2 border-b border-zinc-800/40 text-xs text-zinc-400">
          Showing ${startIndex}-${endIndex} of ${state.totalCount}
        </div>
      `;
      if (state.loading) {
        return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header} ${searchInput} ${pageInfo}
            <div class="px-4 py-8 text-center text-sm text-zinc-500">Loading trajectories...</div>
          </div>
        `;
      }
      if (state.error) {
        return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header} ${searchInput} ${pageInfo}
            <div class="px-4 py-8">
              <div class="text-sm text-red-400 mb-2">Error loading trajectories</div>
              <div class="text-xs text-zinc-500">${state.error}</div>
              <button
                class="mt-3 px-3 py-1.5 rounded bg-zinc-800 hover:bg-zinc-700 text-zinc-200 text-xs transition-colors"
                data-action="refresh"
              >
                Retry
              </button>
            </div>
          </div>
        `;
      }
      if (state.filteredTrajectories.length === 0) {
        const message = state.searchQuery ? `No trajectories match "${state.searchQuery}"` : "No trajectories found";
        return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header} ${searchInput} ${pageInfo}
            <div class="px-4 py-8 text-center text-sm text-zinc-500">${message}</div>
          </div>
        `;
      }
      const trajectoryItems = joinTemplates(state.filteredTrajectories.map((traj) => {
        const isSelected = traj.sessionId === state.selectedSessionId;
        const baseClasses = "bg-zinc-900/40 border border-zinc-800/40 rounded-lg p-3 mb-2 cursor-pointer transition-colors";
        const selectedClasses = isSelected ? "bg-zinc-800/60 border-zinc-700/50" : "hover:bg-zinc-900/60";
        return html`
            <div
              class="${baseClasses} ${selectedClasses}"
              data-action="select"
              data-session-id="${traj.sessionId}"
              data-index="${traj.index}"
            >
              <div class="flex items-center justify-between mb-1">
                <span class="text-sm font-mono text-zinc-200">${traj.agentName}</span>
                <span class="text-xs text-zinc-500">${formatDate2(traj.date)}</span>
              </div>
              <div class="text-xs text-zinc-400 mb-0.5">task: ${traj.task}</div>
              <div class="flex items-center gap-2 text-xs text-zinc-500">
                <span>${traj.episode}</span>
                <span></span>
                <span>${traj.stepCount} steps</span>
              </div>
            </div>
          `;
      }));
      const hasPrev = state.currentPage > 0;
      const hasNext = (state.currentPage + 1) * state.pageSize < state.totalCount;
      const pagination = html`
        <div class="px-4 py-3 border-t border-zinc-800/40 flex items-center justify-between">
          <button
            class="px-3 py-1.5 rounded bg-zinc-800 text-zinc-200 text-xs transition-colors ${hasPrev ? "hover:bg-zinc-700" : "opacity-50 cursor-not-allowed"}"
            data-action="prevPage"
            ${hasPrev ? "" : "disabled"}
          >
             Prev
          </button>
          <span class="text-xs text-zinc-500">Page ${state.currentPage + 1}</span>
          <button
            class="px-3 py-1.5 rounded bg-zinc-800 text-zinc-200 text-xs transition-colors ${hasNext ? "hover:bg-zinc-700" : "opacity-50 cursor-not-allowed"}"
            data-action="nextPage"
            ${hasNext ? "" : "disabled"}
          >
            Next 
          </button>
        </div>
      `;
      return html`
        <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm overflow-hidden">
          ${header} ${searchInput} ${pageInfo}
          <div class="max-h-[calc(100vh-16rem)] overflow-y-auto px-4 py-2">${trajectoryItems}</div>
          ${pagination}
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (e, target) => {
        const el = target;
        const action = el.dataset.action;
        if (action === "toggleCollapse") {
          exports_Effect.runFork(ctx.emit({ type: "toggleCollapse" }));
        } else if (action === "select") {
          const sessionId = el.dataset.sessionId;
          const index = el.dataset.index;
          if (sessionId && index) {
            exports_Effect.runFork(ctx.emit({ type: "select", sessionId, index: parseInt(index, 10) }));
          }
        } else if (action === "prevPage") {
          exports_Effect.runFork(ctx.emit({ type: "loadPage", page: -1 }));
        } else if (action === "nextPage") {
          exports_Effect.runFork(ctx.emit({ type: "loadPage", page: -2 }));
        } else if (action === "refresh") {
          exports_Effect.runFork(ctx.emit({ type: "refresh" }));
        }
      });
      yield* ctx.dom.delegate(ctx.container, "[data-action='search']", "input", (e) => {
        const input = e.target;
        exports_Effect.runFork(ctx.emit({ type: "search", query: input.value }));
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      const socket = yield* SocketServiceTag;
      switch (event.type) {
        case "loadPage": {
          const state = yield* ctx.state.get;
          let newPage = event.page;
          if (newPage === -1) {
            newPage = Math.max(0, state.currentPage - 1);
          } else if (newPage === -2) {
            newPage = state.currentPage + 1;
          }
          const maxPage = Math.ceil(state.totalCount / state.pageSize) - 1;
          if (newPage < 0 || newPage > maxPage)
            break;
          yield* ctx.state.update((s) => ({ ...s, loading: true, error: null }));
          try {
            const offset = newPage * state.pageSize;
            const trajectories = yield* socket.getHFTrajectories(offset, state.pageSize);
            const metadata = trajectories.map((t, i) => extractMetadata(t, offset + i));
            yield* ctx.state.update((s) => ({
              ...s,
              trajectories: metadata,
              filteredTrajectories: filterTrajectories(metadata, s.searchQuery),
              currentPage: newPage,
              loading: false
            }));
          } catch (error) {
            yield* ctx.state.update((s) => ({
              ...s,
              loading: false,
              error: error instanceof Error ? error.message : String(error)
            }));
          }
          break;
        }
        case "search": {
          yield* ctx.state.update((s) => ({
            ...s,
            searchQuery: event.query,
            filteredTrajectories: filterTrajectories(s.trajectories, event.query)
          }));
          break;
        }
        case "select": {
          yield* ctx.state.update((s) => ({
            ...s,
            selectedSessionId: event.sessionId
          }));
          break;
        }
        case "toggleCollapse": {
          yield* ctx.state.update((s) => ({ ...s, collapsed: !s.collapsed }));
          break;
        }
        case "refresh": {
          yield* ctx.emit({ type: "loadPage", page: 0 });
          break;
        }
      }
    }).pipe(exports_Effect.catchAll(exports_Effect.die)),
    subscriptions: (ctx) => {
      const initialLoad = exports_Effect.gen(function* () {
        if (typeof window !== "undefined" && window.bunLog) {
          window.bunLog("[HFTrajectoryList] Starting initial load...");
        }
        const socket = yield* SocketServiceTag;
        try {
          if (typeof window !== "undefined" && window.bunLog) {
            window.bunLog("[HFTrajectoryList] Getting trajectory count...");
          }
          const totalCount = yield* socket.getHFTrajectoryCount();
          if (typeof window !== "undefined" && window.bunLog) {
            window.bunLog(`[HFTrajectoryList] Total count: ${totalCount}`);
          }
          if (typeof window !== "undefined" && window.bunLog) {
            window.bunLog("[HFTrajectoryList] Loading first page...");
          }
          const trajectories = yield* socket.getHFTrajectories(0, 100);
          if (typeof window !== "undefined" && window.bunLog) {
            window.bunLog(`[HFTrajectoryList] Loaded trajectories: ${trajectories.length}`);
          }
          const metadata = trajectories.map((t, i) => extractMetadata(t, i));
          yield* ctx.state.update((s) => ({
            ...s,
            trajectories: metadata,
            filteredTrajectories: metadata,
            totalCount,
            loading: false
          }));
          if (typeof window !== "undefined" && window.bunLog) {
            window.bunLog("[HFTrajectoryList] Initial load complete");
          }
        } catch (error) {
          if (typeof window !== "undefined" && window.bunLog) {
            window.bunLog(`[HFTrajectoryList] Initial load failed: ${error}`);
          }
          yield* ctx.state.update((s) => ({
            ...s,
            loading: false,
            error: error instanceof Error ? error.message : String(error)
          }));
        }
      }).pipe(exports_Effect.catchAll(exports_Effect.die));
      return [exports_Stream.make(initialLoad)];
    }
  };
  var initialHFTrajectoryListState = HFTrajectoryListWidget.initialState();
  // src/atif/schema.ts
  var ATIF_SCHEMA_VERSION = "ATIF-v1.4";
  var StepSource = Literal2("user", "agent", "system");
  var Agent = Struct({
    name: String$,
    version: String$,
    model_name: String$,
    extra: optional(Record({ key: String$, value: Unknown }))
  });
  var ToolCall = Struct({
    tool_call_id: String$,
    function_name: String$,
    arguments: Unknown
  });
  var SubagentTrajectoryRef = Struct({
    session_id: String$,
    trajectory_path: optional(String$),
    extra: optional(Record({ key: String$, value: Unknown }))
  });
  var ObservationResult = Struct({
    source_call_id: optional(String$),
    content: optional(Unknown),
    subagent_trajectory_ref: optional(Array$(SubagentTrajectoryRef))
  });
  var Observation = Struct({
    results: Array$(ObservationResult)
  });
  var Metrics = Struct({
    prompt_tokens: optional(Number$),
    completion_tokens: optional(Number$),
    cached_tokens: optional(Number$),
    cost_usd: optional(Number$),
    logprobs: optional(Array$(Number$)),
    completion_token_ids: optional(Array$(Number$)),
    prompt_token_ids: optional(Array$(Number$)),
    extra: optional(Record({ key: String$, value: Unknown }))
  });
  var FinalMetrics = Struct({
    total_prompt_tokens: Number$,
    total_completion_tokens: Number$,
    total_cached_tokens: optional(Number$),
    total_cost_usd: optional(Number$),
    total_steps: Number$,
    extra: optional(Record({ key: String$, value: Unknown }))
  });
  var StepStatus = Literal2("pending", "executing", "completed", "failed", "replayed");
  var Step = Struct({
    step_id: Number$.pipe(int(), positive()),
    timestamp: String$,
    source: StepSource,
    message: Unknown,
    reasoning_content: optional(String$),
    model_name: optional(String$),
    tool_calls: optional(Array$(ToolCall)),
    observation: optional(Observation),
    metrics: optional(Metrics),
    status: optional(StepStatus),
    completed_at: optional(String$),
    error: optional(String$),
    extra: optional(Record({ key: String$, value: Unknown }))
  });
  var Checkpoint = Struct({
    checkpoint_id: String$,
    phase: String$,
    timestamp: String$,
    resumable: Boolean$,
    step_id: optional(Number$.pipe(int(), positive())),
    extra: optional(Record({ key: String$, value: Unknown }))
  });
  var RecoveryInfo = Struct({
    recovered_from_session: optional(String$),
    recovered_at_step: optional(Number$.pipe(int(), positive())),
    recovery_timestamp: optional(String$),
    notes: optional(String$),
    extra: optional(Record({ key: String$, value: Unknown }))
  });
  var Trajectory = Struct({
    schema_version: Literal2(ATIF_SCHEMA_VERSION),
    session_id: String$,
    agent: Agent,
    steps: Array$(Step),
    notes: optional(String$),
    final_metrics: optional(FinalMetrics),
    checkpoints: optional(Array$(Checkpoint)),
    recovery_info: optional(RecoveryInfo),
    extra: optional(Record({ key: String$, value: Unknown }))
  });
  var decodeTrajectory = decodeUnknownSync(Trajectory);
  var encodeTrajectory = encodeSync(Trajectory);
  var decodeStep = decodeUnknownSync(Step);
  var encodeStep = encodeSync(Step);
  var decodeAgent = decodeUnknownSync(Agent);
  var encodeAgent = encodeSync(Agent);
  var hasToolCalls = (step4) => (step4.tool_calls?.length ?? 0) > 0;
  var hasObservation = (step4) => step4.observation !== undefined && step4.observation.results.length > 0;
  var extractStepText = (step4) => {
    if (typeof step4.message === "string")
      return step4.message;
    if (typeof step4.message === "object" && step4.message !== null) {
      const msg = step4.message;
      if (typeof msg.content === "string")
        return msg.content;
      if (typeof msg.text === "string")
        return msg.text;
    }
    return "";
  };

  // src/effuse/widgets/hf-trajectory-detail.ts
  var formatTimestamp2 = (iso) => {
    try {
      return new Date(iso).toLocaleTimeString(undefined, {
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      });
    } catch {
      return iso.slice(0, 19).replace("T", " ");
    }
  };
  var formatDate3 = (iso) => {
    try {
      return new Date(iso).toLocaleDateString(undefined, {
        month: "short",
        day: "numeric",
        year: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      });
    } catch {
      return iso.slice(0, 16).replace("T", " ");
    }
  };
  var getSourceClass = (source) => {
    switch (source) {
      case "user":
        return "bg-blue-900/40 text-blue-300 border-blue-700/50";
      case "agent":
        return "bg-emerald-900/40 text-emerald-300 border-emerald-700/50";
      case "system":
        return "bg-zinc-800/40 text-zinc-300 border-zinc-700/50";
      default:
        return "bg-zinc-800/40 text-zinc-300 border-zinc-700/50";
    }
  };
  var formatJSON = (obj) => {
    try {
      if (typeof obj === "string")
        return obj;
      return JSON.stringify(obj, null, 2);
    } catch {
      return String(obj);
    }
  };
  var collapseWhitespace = (text) => {
    return text.replace(/\n{3,}/g, `

`).trim();
  };
  var getMessageText = (step4) => {
    return collapseWhitespace(extractStepText(step4));
  };
  var HFTrajectoryDetailWidget = {
    id: "hf-trajectory-detail",
    initialState: () => {
      if (typeof window !== "undefined" && window.bunLog) {
        window.bunLog("[HFTrajectoryDetail] Creating initial state");
      }
      return {
        trajectory: null,
        sessionId: null,
        loading: false,
        error: null,
        collapsed: false,
        expandedStepIds: new Set,
        viewMode: "formatted"
      };
    },
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      const header = html`
        <div
          class="flex items-center justify-between px-4 py-3 border-b border-zinc-800/60 cursor-pointer bg-zinc-900/40"
          data-action="toggleCollapse"
        >
          <h3 class="text-sm font-bold font-mono text-zinc-100">Trajectory Details</h3>
          <span class="text-zinc-500">${state.collapsed ? "" : ""}</span>
        </div>
      `;
      if (state.collapsed) {
        return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header}
          </div>
        `;
      }
      if (state.loading) {
        return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header}
            <div class="px-4 py-8 text-center text-sm text-zinc-500">Loading trajectory...</div>
          </div>
        `;
      }
      if (state.error) {
        return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header}
            <div class="px-4 py-8">
              <div class="text-sm text-red-400 mb-2">Error loading trajectory</div>
              <div class="text-xs text-zinc-500">${state.error}</div>
            </div>
          </div>
        `;
      }
      if (!state.trajectory) {
        return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header}
            <div class="px-4 py-8 text-center text-sm text-zinc-500">
              No trajectory selected. Click a trajectory in the sidebar to view details.
            </div>
          </div>
        `;
      }
      const traj = state.trajectory;
      const agent = traj.agent;
      const extra = traj.extra;
      const task = extra?.task ?? "unknown";
      const episode = extra?.episode ?? "unknown";
      const date = extra?.date ?? traj.steps[0]?.timestamp ?? "unknown";
      const metadata = html`
        <div class="px-4 py-3 bg-zinc-900/20 border-b border-zinc-800/40 space-y-1.5">
          <div class="flex items-center gap-2 text-xs">
            <span class="text-zinc-500">Session:</span>
            <span class="text-zinc-300 font-mono">${traj.session_id}</span>
          </div>
          <div class="flex items-center gap-2 text-xs">
            <span class="text-zinc-500">Agent:</span>
            <span class="text-zinc-300">${agent?.name ?? "unknown"}</span>
            ${agent?.model_name ? html`<span class="text-zinc-500">(${agent.model_name})</span>` : ""}
          </div>
          <div class="flex items-center gap-2 text-xs">
            <span class="text-zinc-500">Task:</span>
            <span class="text-zinc-300">${task}</span>
            <span class="text-zinc-500"></span>
            <span class="text-zinc-500">Episode:</span>
            <span class="text-zinc-300">${episode}</span>
          </div>
          <div class="flex items-center gap-2 text-xs">
            <span class="text-zinc-500">Steps:</span>
            <span class="text-zinc-300">${traj.steps.length}</span>
            <span class="text-zinc-500"></span>
            <span class="text-zinc-500">Date:</span>
            <span class="text-zinc-300">${formatDate3(date)}</span>
          </div>
        </div>
      `;
      const stepsList = html`
        <div class="max-h-[calc(100vh-20rem)] overflow-y-auto">
          ${joinTemplates(traj.steps.map((step4) => {
        const isExpanded = state.expandedStepIds.has(step4.step_id);
        const source = step4.source ?? "system";
        const sourceClass = getSourceClass(source);
        const toolCallCount = hasToolCalls(step4) ? step4.tool_calls.length : 0;
        const hasObs = hasObservation(step4);
        const stepHeader = html`
                <div
                  class="flex items-center justify-between px-4 py-2 hover:bg-zinc-900/40 cursor-pointer transition-colors border-b border-zinc-800/40"
                  data-action="toggleStep"
                  data-step-id="${step4.step_id}"
                >
                  <div class="flex items-center gap-3 flex-1">
                    <span class="text-xs font-mono text-zinc-500">#${step4.step_id}</span>
                    <span class="text-xs px-1.5 py-0.5 rounded border ${sourceClass} uppercase font-mono">
                      ${source}
                    </span>
                    <span class="text-xs text-zinc-400 font-mono">${formatTimestamp2(step4.timestamp)}</span>
                    ${toolCallCount > 0 ? html`<span class="text-xs text-violet-400"> ${toolCallCount} tool${toolCallCount > 1 ? "s" : ""}</span>` : ""}
                    ${hasObs ? html`<span class="text-xs text-emerald-400"> obs</span>` : ""}
                  </div>
                  <span class="text-zinc-500">${isExpanded ? "" : ""}</span>
                </div>
              `;
        if (!isExpanded) {
          return stepHeader;
        }
        const expandedContent = html`
                <div class="px-4 py-2 bg-zinc-900/20 space-y-2">
                  ${step4.message ? html`
                        <div>
                          <div class="text-xs font-mono text-zinc-400 mb-1">Message:</div>
                          <pre
                            class="text-xs font-mono text-zinc-200 bg-zinc-950/60 p-2 rounded border border-zinc-800/40 overflow-x-auto whitespace-pre-wrap"
                          >${getMessageText(step4)}</pre>
                        </div>
                      ` : ""}
                  ${step4.reasoning_content ? html`
                        <div>
                          <div class="text-xs font-mono text-zinc-400 mb-1">Reasoning:</div>
                          <pre
                            class="text-xs font-mono text-zinc-300 bg-zinc-950/60 p-2 rounded border border-zinc-800/40 overflow-x-auto whitespace-pre-wrap"
                          >${collapseWhitespace(step4.reasoning_content)}</pre>
                        </div>
                      ` : ""}
                  ${hasToolCalls(step4) ? html`
                        <div>
                          <div class="text-xs font-mono text-zinc-400 mb-1">Tool Calls:</div>
                          ${joinTemplates(step4.tool_calls.map((tc) => html`
                                <div class="bg-zinc-950/60 p-2 rounded border border-zinc-800/40 mb-2">
                                  <div class="text-xs font-mono text-violet-300 mb-1">${tc.function_name}</div>
                                  <pre
                                    class="text-xs font-mono text-zinc-400 overflow-x-auto whitespace-pre-wrap"
                                  >${formatJSON(tc.arguments)}</pre>
                                </div>
                              `))}
                        </div>
                      ` : ""}
                  ${hasObservation(step4) ? html`
                        <div>
                          <div class="text-xs font-mono text-zinc-400 mb-1">Observation:</div>
                          ${joinTemplates(step4.observation.results.map((result) => {
          const content = result.content;
          const contentStr = typeof content === "string" ? collapseWhitespace(content) : formatJSON(content);
          return html`
                                <pre
                                  class="text-xs font-mono text-emerald-300 bg-zinc-950/60 p-2 rounded border border-zinc-800/40 overflow-x-auto mb-2 whitespace-pre-wrap"
                                >${contentStr}</pre>
                              `;
        }))}
                        </div>
                      ` : ""}
                  ${step4.metrics ? html`
                        <div>
                          <div class="text-xs font-mono text-zinc-400 mb-1">Metrics:</div>
                          <div class="text-xs text-zinc-300 space-x-3">
                            ${step4.metrics.prompt_tokens ? html`<span>${step4.metrics.prompt_tokens} prompt tokens</span>` : ""}
                            ${step4.metrics.completion_tokens ? html`<span> ${step4.metrics.completion_tokens} completion tokens</span>` : ""}
                            ${step4.metrics.cost_usd ? html`<span> $${step4.metrics.cost_usd.toFixed(4)}</span>` : ""}
                          </div>
                        </div>
                      ` : ""}
                  ${step4.error ? html`
                        <div>
                          <div class="text-xs font-mono text-red-400 mb-1">Error:</div>
                          <pre
                            class="text-xs font-mono text-red-300 bg-red-950/20 p-2 rounded border border-red-800/40 overflow-x-auto whitespace-pre-wrap"
                          >${step4.error}</pre>
                        </div>
                      ` : ""}
                </div>
              `;
        return html`
                <div class="border-b border-zinc-800/40">
                  ${stepHeader}
                  ${expandedContent}
                </div>
              `;
      }))}
        </div>
      `;
      return html`
        <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm overflow-hidden">
          ${header} ${metadata} ${stepsList}
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (e, target) => {
        const el = target;
        const action = el.dataset.action;
        const stepId = el.dataset.stepId;
        if (action === "toggleCollapse") {
          exports_Effect.runFork(ctx.emit({ type: "toggleCollapse" }));
        } else if (action === "toggleStep" && stepId) {
          exports_Effect.runFork(ctx.emit({ type: "toggleStep", stepId: parseInt(stepId, 10) }));
        }
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      switch (event.type) {
        case "load": {
          yield* ctx.state.update((s) => ({
            ...s,
            trajectory: event.trajectory,
            sessionId: event.sessionId,
            loading: false,
            error: null,
            expandedStepIds: new Set(event.trajectory.steps.map((step4) => step4.step_id))
          }));
          break;
        }
        case "toggleCollapse":
          yield* ctx.state.update((s) => ({ ...s, collapsed: !s.collapsed }));
          break;
        case "toggleStep": {
          yield* ctx.state.update((s) => {
            const newExpanded = new Set(s.expandedStepIds);
            if (newExpanded.has(event.stepId)) {
              newExpanded.delete(event.stepId);
            } else {
              newExpanded.add(event.stepId);
            }
            return { ...s, expandedStepIds: newExpanded };
          });
          break;
        }
        case "clear":
          yield* ctx.state.update(() => HFTrajectoryDetailWidget.initialState());
          break;
        case "toggleViewMode": {
          yield* ctx.state.update((s) => ({
            ...s,
            viewMode: s.viewMode === "formatted" ? "json" : "formatted"
          }));
          break;
        }
      }
    }),
    subscriptions: () => []
  };
  var initialHFTrajectoryDetailState = HFTrajectoryDetailWidget.initialState();
  // src/effuse/widgets/tb-command-center/types.ts
  var TABS = [
    { id: "dashboard", label: "Dashboard", icon: "layout-dashboard" },
    { id: "tasks", label: "Tasks", icon: "list-checks" },
    { id: "runs", label: "Runs", icon: "play-circle" },
    { id: "testgen", label: "TestGen", icon: "flask-conical" },
    { id: "settings", label: "Settings", icon: "settings" }
  ];
  var DEFAULT_EXECUTION_SETTINGS = {
    maxAttempts: 5,
    maxStepsPerRun: 50,
    timeoutSeconds: 300,
    deepComputeEnabled: false,
    recursionLimitN: 3,
    innerIterationsT: 5,
    earlyStopOnHighConfidence: true,
    model: "fm"
  };
  var DEFAULT_LOGGING_SETTINGS = {
    saveTrajectories: true,
    saveTerminalOutput: true,
    saveAtifTraces: true,
    autoPruneDays: 30
  };
  var DIFFICULTY_COLORS = {
    easy: { bg: "bg-emerald-900/40", text: "text-emerald-300", border: "border-emerald-700/50" },
    medium: { bg: "bg-yellow-900/40", text: "text-yellow-300", border: "border-yellow-700/50" },
    hard: { bg: "bg-orange-900/40", text: "text-orange-300", border: "border-orange-700/50" },
    expert: { bg: "bg-red-900/40", text: "text-red-300", border: "border-red-700/50" },
    unknown: { bg: "bg-zinc-800/40", text: "text-zinc-400", border: "border-zinc-700/50" }
  };
  var OUTCOME_COLORS = {
    success: { bg: "bg-emerald-900/40", text: "text-emerald-300", border: "border-emerald-700/50" },
    failure: { bg: "bg-red-900/40", text: "text-red-300", border: "border-red-700/50" },
    timeout: { bg: "bg-yellow-900/40", text: "text-yellow-300", border: "border-yellow-700/50" },
    error: { bg: "bg-red-900/40", text: "text-red-300", border: "border-red-700/50" },
    aborted: { bg: "bg-zinc-800/40", text: "text-zinc-400", border: "border-zinc-700/50" }
  };
  // src/effuse/widgets/tb-command-center/tbcc-shell.ts
  var TBCCShellWidget = {
    id: "tbcc-shell",
    initialState: () => ({
      activeTab: "dashboard",
      sidebarCollapsed: false,
      currentRun: null,
      connected: false
    }),
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      if (window.bunLog) {
        window.bunLog(`[TBCCShell] render called, activeTab=${state.activeTab}`);
      }
      const tabItems = joinTemplates(TABS.map((tab) => {
        const isActive2 = tab.id === state.activeTab;
        const baseClasses = "flex items-center gap-3 px-4 py-3 text-sm font-mono transition-colors cursor-pointer";
        const activeClasses = isActive2 ? "bg-zinc-800/60 text-zinc-100 border-l-2 border-emerald-500" : "text-zinc-400 hover:text-zinc-200 hover:bg-zinc-900/40 border-l-2 border-transparent";
        return html`
            <button class="${baseClasses} ${activeClasses}" data-action="changeTab" data-tab="${tab.id}">
              ${state.sidebarCollapsed ? "" : html`<span>${tab.label}</span>`}
            </button>
          `;
      }));
      const statusDot = state.currentRun ? html`<span class="w-2 h-2 rounded-full bg-blue-500 animate-pulse"></span>` : state.connected ? html`<span class="w-2 h-2 rounded-full bg-emerald-500"></span>` : html`<span class="w-2 h-2 rounded-full bg-zinc-600"></span>`;
      const statusText = state.currentRun ? html`<span class="text-xs text-blue-300 truncate">${state.currentRun.taskName}</span>` : state.connected ? html`<span class="text-xs text-zinc-500">Ready</span>` : html`<span class="text-xs text-zinc-600">Disconnected</span>`;
      const sidebarWidth = state.sidebarCollapsed ? "w-16" : "w-[260px]";
      return html`
        <div class="flex h-full">
          <!-- Sidebar -->
          <aside class="${sidebarWidth} flex-shrink-0 bg-zinc-950 border-r border-zinc-800/60 flex flex-col transition-all duration-200">
            <!-- Header -->
            <div class="px-4 py-4 border-b border-zinc-800/60">
              ${state.sidebarCollapsed ? html`<span class="text-lg font-bold font-mono text-zinc-100">TB</span>` : html`
                    <h1 class="text-lg font-bold font-mono text-zinc-100">TerminalBench</h1>
                    <span class="text-xs text-zinc-500">Command Center</span>
                  `}
            </div>

            <!-- Tab Navigation -->
            <nav class="flex-1 py-2 flex flex-col">${tabItems}</nav>

            <!-- Collapse Toggle -->
            <button
              class="px-4 py-2 text-xs text-zinc-500 hover:text-zinc-300 border-t border-zinc-800/60 transition-colors"
              data-action="toggleSidebar"
            >
              ${state.sidebarCollapsed ? "" : " Collapse"}
            </button>

            <!-- Status Bar -->
            <div class="px-4 py-3 border-t border-zinc-800/60 flex items-center gap-2">
              ${statusDot} ${state.sidebarCollapsed ? "" : statusText}
            </div>
          </aside>

          <!-- Main Content Area -->
          <main class="flex-1 bg-zinc-950 overflow-hidden">
            <!-- Tab Content Containers -->
            <div id="tbcc-tab-dashboard" class="${state.activeTab === "dashboard" ? "" : "hidden"} h-full"></div>
            <div id="tbcc-tab-tasks" class="${state.activeTab === "tasks" ? "" : "hidden"} h-full"></div>
            <div id="tbcc-tab-runs" class="${state.activeTab === "runs" ? "" : "hidden"} h-full"></div>
            <div id="tbcc-tab-testgen" class="${state.activeTab === "testgen" ? "" : "hidden"} h-full"></div>
            <div id="tbcc-tab-settings" class="${state.activeTab === "settings" ? "" : "hidden"} h-full"></div>
          </main>
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action='changeTab']", "click", (_e, target) => {
        const tab = target.dataset.tab;
        if (tab) {
          exports_Effect.runFork(ctx.emit({ type: "changeTab", tab }));
        }
      });
      yield* ctx.dom.delegate(ctx.container, "[data-action='toggleSidebar']", "click", () => {
        exports_Effect.runFork(ctx.emit({ type: "toggleSidebar" }));
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      if (window.bunLog) {
        window.bunLog(`[TBCCShell] handleEvent: ${event.type}`);
      }
      switch (event.type) {
        case "changeTab": {
          if (window.bunLog) {
            window.bunLog(`[TBCCShell] Changing tab to: ${event.tab}`);
          }
          const TABS2 = ["dashboard", "tasks", "runs", "testgen", "settings"];
          for (const tabId of TABS2) {
            const container = yield* ctx.dom.queryOption(`#tbcc-tab-${tabId}`);
            if (container) {
              if (tabId === event.tab) {
                container.classList.remove("hidden");
                if (window.bunLog) {
                  window.bunLog(`[TBCCShell] Showing tab: ${tabId}, container.innerHTML.length=${container.innerHTML.length}`);
                }
              } else {
                container.classList.add("hidden");
              }
            } else {
              if (window.bunLog) {
                window.bunLog(`[TBCCShell] WARNING: Tab container #tbcc-tab-${tabId} not found!`);
              }
            }
          }
          const allButtons = ctx.container.querySelectorAll(`[data-action='changeTab']`);
          for (const btn of Array.from(allButtons)) {
            const btnTab = btn.dataset.tab;
            if (btnTab === event.tab) {
              btn.classList.remove("text-zinc-400", "hover:text-zinc-200", "hover:bg-zinc-900/40", "border-transparent");
              btn.classList.add("bg-zinc-800/60", "text-zinc-100", "border-emerald-500");
            } else {
              btn.classList.remove("bg-zinc-800/60", "text-zinc-100", "border-emerald-500");
              btn.classList.add("text-zinc-400", "hover:text-zinc-200", "hover:bg-zinc-900/40", "border-transparent");
            }
          }
          break;
        }
        case "toggleSidebar": {
          yield* ctx.state.update((s) => ({ ...s, sidebarCollapsed: !s.sidebarCollapsed }));
          break;
        }
        case "runStarted": {
          yield* ctx.state.update((s) => ({
            ...s,
            currentRun: {
              runId: event.runId,
              taskId: event.taskId,
              taskName: event.taskName,
              attempt: 1,
              maxAttempts: 5,
              status: "running",
              startedAt: Date.now(),
              currentStep: 0,
              totalSteps: null
            }
          }));
          break;
        }
        case "runCompleted": {
          yield* ctx.state.update((s) => ({
            ...s,
            currentRun: null
          }));
          break;
        }
        case "connectionChange": {
          yield* ctx.state.update((s) => ({ ...s, connected: event.connected }));
          break;
        }
      }
    }),
    subscriptions: (ctx) => {
      const socketSub = exports_Effect.gen(function* () {
        const socket = yield* SocketServiceTag;
        yield* ctx.emit({ type: "connectionChange", connected: true });
        yield* exports_Stream.runForEach(socket.getMessages(), (msg) => exports_Effect.gen(function* () {
          if (msg.type === "tb_run_start") {
            const data = msg;
            yield* ctx.emit({
              type: "runStarted",
              runId: data.runId,
              taskId: data.taskIds[0] ?? "unknown",
              taskName: data.taskIds[0] ?? "Task"
            });
          } else if (msg.type === "tb_run_complete") {
            const data = msg;
            yield* ctx.emit({
              type: "runCompleted",
              runId: data.runId,
              outcome: data.passRate >= 0.5 ? "success" : "failure"
            });
          }
        }));
      });
      return [exports_Stream.make(socketSub)];
    }
  };
  // src/effuse/widgets/tb-command-center/tbcc-dashboard.ts
  var STORAGE_KEY = "tbcc_settings";
  var DEFAULT_SUITE_PATH = "tasks/terminal-bench-2.json";
  var getSettings = () => {
    if (typeof localStorage === "undefined") {
      return { model: DEFAULT_EXECUTION_SETTINGS.model };
    }
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        const parsed = JSON.parse(saved);
        return { model: parsed.execution?.model ?? DEFAULT_EXECUTION_SETTINGS.model };
      }
    } catch {}
    return { model: DEFAULT_EXECUTION_SETTINGS.model };
  };
  var formatDuration4 = (ms) => {
    if (ms === null)
      return "-";
    const seconds2 = Math.floor(ms / 1000);
    if (seconds2 < 60)
      return `${seconds2}s`;
    const minutes2 = Math.floor(seconds2 / 60);
    const remainingSeconds = seconds2 % 60;
    return `${minutes2}m ${remainingSeconds}s`;
  };
  var formatDate4 = (iso) => {
    try {
      return new Date(iso).toLocaleDateString(undefined, {
        month: "short",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      });
    } catch {
      return iso.slice(0, 10);
    }
  };
  var formatPercent = (value) => {
    return `${(value * 100).toFixed(1)}%`;
  };
  var TBCCDashboardWidget = {
    id: "tbcc-dashboard",
    initialState: () => {
      const bunLog = typeof window !== "undefined" ? window.bunLog : null;
      if (bunLog) {
        bunLog("[TBCCDashboard] Creating initial state");
      }
      return {
        stats: null,
        recentRuns: [],
        currentRun: null,
        loading: true,
        error: null
      };
    },
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      const currentRunCard = state.currentRun ? html`
            <div class="bg-blue-900/20 border border-blue-800/50 rounded-xl p-4 mb-4">
              <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                  <span class="w-3 h-3 rounded-full bg-blue-500 animate-pulse"></span>
                  <div>
                    <div class="text-sm font-mono text-blue-200">${state.currentRun.taskName}</div>
                    <div class="text-xs text-blue-400">
                      Step ${state.currentRun.currentStep}${state.currentRun.totalSteps ? ` / ${state.currentRun.totalSteps}` : ""}  Attempt
                      ${state.currentRun.attempt}/${state.currentRun.maxAttempts}
                    </div>
                  </div>
                </div>
                <button
                  class="px-3 py-1.5 text-xs font-mono rounded border border-red-700 text-red-300 bg-red-900/40 hover:bg-red-900/60 transition-colors"
                  data-action="stopRun"
                >
                  Stop
                </button>
              </div>
            </div>
          ` : "";
      const kpiCards = state.stats ? html`
            <div class="grid grid-cols-2 lg:grid-cols-4 gap-3 mb-6">
              <!-- Overall Success Rate -->
              <div class="bg-zinc-900/60 border border-zinc-800/40 rounded-lg p-4">
                <div class="text-xs text-zinc-500 mb-1">Success Rate</div>
                <div class="text-2xl font-mono font-bold text-emerald-400">${formatPercent(state.stats.overallSuccessRate)}</div>
                <div class="text-xs text-zinc-500 mt-1">Last 50: ${formatPercent(state.stats.last50SuccessRate)}</div>
              </div>

              <!-- Average Steps -->
              <div class="bg-zinc-900/60 border border-zinc-800/40 rounded-lg p-4">
                <div class="text-xs text-zinc-500 mb-1">Avg Steps</div>
                <div class="text-2xl font-mono font-bold text-zinc-200">${state.stats.avgStepsPerRun.toFixed(1)}</div>
                <div class="text-xs text-zinc-500 mt-1">per run</div>
              </div>

              <!-- Average Duration -->
              <div class="bg-zinc-900/60 border border-zinc-800/40 rounded-lg p-4">
                <div class="text-xs text-zinc-500 mb-1">Avg Duration</div>
                <div class="text-2xl font-mono font-bold text-zinc-200">${formatDuration4(state.stats.avgDurationSeconds * 1000)}</div>
                <div class="text-xs text-zinc-500 mt-1">per run</div>
              </div>

              <!-- Total Runs -->
              <div class="bg-zinc-900/60 border border-zinc-800/40 rounded-lg p-4">
                <div class="text-xs text-zinc-500 mb-1">Total Runs</div>
                <div class="text-2xl font-mono font-bold text-zinc-200">${state.stats.totalRuns}</div>
                <div class="text-xs text-zinc-500 mt-1">all time</div>
              </div>
            </div>
          ` : html`
            <div class="grid grid-cols-2 lg:grid-cols-4 gap-3 mb-6">
              ${joinTemplates([1, 2, 3, 4].map(() => html`
                    <div class="bg-zinc-900/60 border border-zinc-800/40 rounded-lg p-4 animate-pulse">
                      <div class="h-3 bg-zinc-800 rounded w-16 mb-2"></div>
                      <div class="h-6 bg-zinc-800 rounded w-12"></div>
                    </div>
                  `))}
            </div>
          `;
      const quickActions = html`
        <div class="flex gap-3 mb-6">
          <button
            type="button"
            class="px-4 py-2 text-xs font-mono uppercase rounded border border-emerald-700 text-emerald-300 bg-emerald-900/40 hover:bg-emerald-900/60 transition-colors"
            data-action="runFullBenchmark"
            ${state.currentRun ? "disabled" : ""}
          >
             Run Full Benchmark
          </button>
          <button
            class="px-4 py-2 text-xs font-mono uppercase rounded border border-zinc-700 text-zinc-200 bg-zinc-900/80 hover:bg-zinc-900/95 transition-colors"
            data-action="runRandomTask"
            ${state.currentRun ? "disabled" : ""}
          >
             Random Task
          </button>
          <button
            class="px-4 py-2 text-xs font-mono uppercase rounded border border-zinc-700 text-zinc-200 bg-zinc-900/80 hover:bg-zinc-900/95 transition-colors"
            data-action="refresh"
          >
             Refresh
          </button>
        </div>
      `;
      const recentRunsTable = state.recentRuns.length > 0 ? html`
              <div class="bg-zinc-900/60 border border-zinc-800/40 rounded-lg overflow-hidden">
                <div class="px-4 py-3 border-b border-zinc-800/40">
                  <h3 class="text-sm font-bold font-mono text-zinc-200">Recent Runs</h3>
                </div>
                <div class="max-h-80 overflow-y-auto">
                  <table class="w-full text-sm">
                    <thead class="sticky top-0 bg-zinc-900/80 border-b border-zinc-800/40 text-left text-zinc-400 text-xs font-mono">
                      <tr>
                        <th class="px-4 py-2">Task</th>
                        <th class="px-4 py-2">Outcome</th>
                        <th class="px-4 py-2">Steps</th>
                        <th class="px-4 py-2">Duration</th>
                        <th class="px-4 py-2">Date</th>
                        <th class="px-4 py-2"></th>
                      </tr>
                    </thead>
                    <tbody>
                      ${joinTemplates(state.recentRuns.slice(0, 10).map((run5) => {
        const outcomeColors = run5.outcome ? OUTCOME_COLORS[run5.outcome] : OUTCOME_COLORS.error;
        return html`
                            <tr class="border-b border-zinc-800/20 hover:bg-zinc-800/30 transition-colors">
                              <td class="px-4 py-2 font-mono text-zinc-200">${run5.taskName}</td>
                              <td class="px-4 py-2">
                                <span
                                  class="px-2 py-0.5 rounded text-xs font-mono ${outcomeColors.bg} ${outcomeColors.text} border ${outcomeColors.border}"
                                >
                                  ${run5.outcome ?? "running"}
                                </span>
                              </td>
                              <td class="px-4 py-2 text-zinc-400">${run5.stepsCount}</td>
                              <td class="px-4 py-2 text-zinc-400">${formatDuration4(run5.durationMs)}</td>
                              <td class="px-4 py-2 text-zinc-500 text-xs">${formatDate4(run5.startedAt)}</td>
                              <td class="px-4 py-2">
                                <button
                                  class="text-zinc-400 hover:text-zinc-200 text-xs transition-colors"
                                  data-action="viewRun"
                                  data-run-id="${run5.id}"
                                >
                                  View 
                                </button>
                              </td>
                            </tr>
                          `;
      }))}
                    </tbody>
                  </table>
                </div>
              </div>
            ` : state.loading ? html`
                <div class="bg-zinc-900/60 border border-zinc-800/40 rounded-lg p-8 text-center">
                  <div class="text-zinc-500">Loading recent runs...</div>
                </div>
              ` : html`
                <div class="bg-zinc-900/60 border border-zinc-800/40 rounded-lg p-8 text-center">
                  <div class="text-zinc-500 mb-2">No runs yet</div>
                  <div class="text-xs text-zinc-600">Run a benchmark to see results here</div>
                </div>
              `;
      const errorBanner = state.error ? html`
            <div class="bg-red-900/20 border border-red-800/50 rounded-lg p-4 mb-4">
              <div class="text-sm text-red-300">${state.error}</div>
              <button
                class="mt-2 text-xs text-red-400 hover:text-red-300 transition-colors"
                data-action="refresh"
              >
                Retry
              </button>
            </div>
          ` : "";
      return html`
        <div class="h-full overflow-y-auto p-6">
          <h2 class="text-xl font-bold font-mono text-zinc-100 mb-6">Dashboard</h2>
          ${errorBanner} ${currentRunCard} ${kpiCards} ${quickActions} ${recentRunsTable}
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      const bunLog = typeof window !== "undefined" ? window.bunLog : null;
      if (bunLog) {
        bunLog("[TBCCDashboard] setupEvents called");
        bunLog(`[TBCCDashboard] Container:`, ctx.container.id || ctx.container.className || "no id/class");
        bunLog(`[TBCCDashboard] Container element:`, ctx.container.tagName);
      }
      const setupClickHandler = (eventType) => {
        return ctx.dom.delegate(ctx.container, "button[data-action]", eventType, (e, target) => {
          const button = target;
          const action = button.dataset.action;
          if (bunLog) {
            bunLog(`[TBCCDashboard] ${eventType} event on button, action="${action}", disabled=${button.disabled}, target=`, button);
          }
          if (button.disabled) {
            if (bunLog) {
              bunLog(`[TBCCDashboard] Button is disabled, ignoring ${eventType}`);
            }
            return;
          }
          if (eventType !== "click") {
            e.preventDefault();
          }
          const runId = button.dataset.runId;
          if (bunLog) {
            bunLog(`[TBCCDashboard] Processing ${eventType} for action="${action}"`);
          }
          if (action === "refresh") {
            exports_Effect.runFork(ctx.emit({ type: "refresh" }));
          } else if (action === "runFullBenchmark") {
            if (bunLog) {
              bunLog(`[TBCCDashboard] Emitting runFullBenchmark event from ${eventType}`);
            }
            exports_Effect.runFork(ctx.emit({ type: "runFullBenchmark" }));
          } else if (action === "runRandomTask") {
            exports_Effect.runFork(ctx.emit({ type: "runRandomTask" }));
          } else if (action === "viewRun" && runId) {
            exports_Effect.runFork(ctx.emit({ type: "viewRun", runId }));
          }
        });
      };
      yield* setupClickHandler("click");
      yield* setupClickHandler("mousedown");
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      const socket = yield* SocketServiceTag;
      switch (event.type) {
        case "refresh": {
          yield* ctx.state.update((s) => ({ ...s, loading: true, error: null }));
          try {
            const runs = yield* socket.loadRecentTBRuns(20);
            const recentRuns = runs.map((r) => ({
              id: r.runId,
              source: "local",
              taskId: r.taskIds?.[0] ?? "unknown",
              taskName: r.taskNames?.[0] ?? r.runId,
              outcome: r.outcome,
              status: r.status,
              startedAt: r.startedAt,
              finishedAt: r.finishedAt ?? null,
              durationMs: r.durationMs ?? null,
              stepsCount: r.stepsCount ?? 0,
              tokensUsed: r.tokensUsed ?? null
            }));
            const stats = computeStats(recentRuns);
            yield* ctx.state.update((s) => ({
              ...s,
              recentRuns,
              stats,
              loading: false
            }));
          } catch (error) {
            yield* ctx.state.update((s) => ({
              ...s,
              loading: false,
              error: error instanceof Error ? error.message : String(error)
            }));
          }
          break;
        }
        case "runFullBenchmark": {
          if (typeof window !== "undefined" && window.bunLog) {
            window.bunLog(`[TBCCDashboard] handleEvent: runFullBenchmark received`);
          }
          const settings = getSettings();
          if (typeof window !== "undefined" && window.bunLog) {
            window.bunLog(`[TBCCDashboard] Settings:`, JSON.stringify(settings));
          }
          const runOptions = {
            suitePath: DEFAULT_SUITE_PATH,
            model: settings.model
          };
          if (typeof window !== "undefined" && window.bunLog) {
            window.bunLog(`[TBCCDashboard] Starting run with options:`, JSON.stringify(runOptions));
          }
          yield* exports_Effect.tryPromise({
            try: async () => {
              const result = await exports_Effect.runPromise(socket.startTBRun(runOptions));
              return result;
            },
            catch: (e) => e
          }).pipe(exports_Effect.flatMap((result) => ctx.state.update((s) => ({
            ...s,
            currentRun: {
              runId: result.runId,
              taskId: "all",
              taskName: `Full Benchmark (${settings.model})`,
              attempt: 1,
              maxAttempts: 1,
              status: "running",
              startedAt: Date.now(),
              currentStep: 0,
              totalSteps: null
            }
          }))), exports_Effect.catchAll((error) => ctx.state.update((s) => ({
            ...s,
            error: `Failed to start benchmark: ${error instanceof Error ? error.message : String(error)}`
          }))));
          break;
        }
        case "runRandomTask": {
          const settings = getSettings();
          yield* exports_Effect.tryPromise({
            try: async () => {
              const result = await exports_Effect.runPromise(socket.startTBRun({
                suitePath: DEFAULT_SUITE_PATH,
                model: settings.model,
                random: true
              }));
              return result;
            },
            catch: (e) => e
          }).pipe(exports_Effect.flatMap((result) => ctx.state.update((s) => ({
            ...s,
            currentRun: {
              runId: result.runId,
              taskId: "random",
              taskName: `Random Task (${settings.model})`,
              attempt: 1,
              maxAttempts: 5,
              status: "running",
              startedAt: Date.now(),
              currentStep: 0,
              totalSteps: null
            }
          }))), exports_Effect.catchAll((error) => ctx.state.update((s) => ({
            ...s,
            error: `Failed to start task: ${error instanceof Error ? error.message : String(error)}`
          }))));
          break;
        }
        case "runStarted": {
          yield* ctx.state.update((s) => ({
            ...s,
            currentRun: {
              runId: event.runId,
              taskId: "unknown",
              taskName: event.taskName,
              attempt: 1,
              maxAttempts: 5,
              status: "running",
              startedAt: Date.now(),
              currentStep: 0,
              totalSteps: null
            }
          }));
          break;
        }
        case "runCompleted": {
          yield* ctx.state.update((s) => ({ ...s, currentRun: null }));
          yield* ctx.emit({ type: "refresh" });
          break;
        }
        case "viewRun": {
          console.log("[Dashboard] View run:", event.runId);
          break;
        }
      }
    }).pipe(exports_Effect.catchAll((error) => ctx.state.update((s) => ({
      ...s,
      error: `Unexpected error: ${error instanceof Error ? error.message : String(error)}`
    })))),
    subscriptions: (ctx) => {
      const initialLoad = exports_Stream.make(ctx.emit({ type: "refresh" }));
      const runEvents = exports_Stream.unwrap(exports_Effect.gen(function* () {
        const socket = yield* SocketServiceTag;
        return socket.getMessages().pipe(exports_Stream.map((msg) => exports_Effect.gen(function* () {
          if (msg.type === "tb_run_start") {
            const data = msg;
            yield* ctx.emit({
              type: "runStarted",
              runId: data.runId,
              taskName: data.taskNames?.[0] ?? "Task"
            });
          } else if (msg.type === "tb_run_complete") {
            const data = msg;
            yield* ctx.emit({ type: "runCompleted", runId: data.runId });
          } else if (msg.type === "tb_task_complete") {
            const data = msg;
            yield* ctx.emit({ type: "taskCompleted", outcome: data.outcome });
          }
        })));
      }));
      return [initialLoad, runEvents];
    }
  };
  function computeStats(runs) {
    if (runs.length === 0) {
      return {
        overallSuccessRate: 0,
        last50SuccessRate: 0,
        avgStepsPerRun: 0,
        avgDurationSeconds: 0,
        totalRuns: 0,
        byDifficulty: {
          easy: { passed: 0, total: 0 },
          medium: { passed: 0, total: 0 },
          hard: { passed: 0, total: 0 },
          expert: { passed: 0, total: 0 },
          unknown: { passed: 0, total: 0 }
        }
      };
    }
    const completedRuns = runs.filter((r) => r.outcome !== null);
    const passedRuns = completedRuns.filter((r) => r.outcome === "success");
    const last50 = completedRuns.slice(0, 50);
    const last50Passed = last50.filter((r) => r.outcome === "success");
    const totalSteps = completedRuns.reduce((sum3, r) => sum3 + r.stepsCount, 0);
    const totalDuration = completedRuns.reduce((sum3, r) => sum3 + (r.durationMs ?? 0), 0);
    return {
      overallSuccessRate: completedRuns.length > 0 ? passedRuns.length / completedRuns.length : 0,
      last50SuccessRate: last50.length > 0 ? last50Passed.length / last50.length : 0,
      avgStepsPerRun: completedRuns.length > 0 ? totalSteps / completedRuns.length : 0,
      avgDurationSeconds: completedRuns.length > 0 ? totalDuration / completedRuns.length / 1000 : 0,
      totalRuns: runs.length,
      byDifficulty: {
        easy: { passed: 0, total: 0 },
        medium: { passed: 0, total: 0 },
        hard: { passed: 0, total: 0 },
        expert: { passed: 0, total: 0 },
        unknown: { passed: 0, total: 0 }
      }
    };
  }
  // src/effuse/widgets/tb-command-center/tbcc-task-browser.ts
  var TBCCTaskBrowserWidget = {
    id: "tbcc-task-browser",
    initialState: () => ({
      tasks: [],
      selectedTaskId: null,
      searchQuery: "",
      difficultyFilter: "all",
      loading: true,
      error: null
    }),
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      const filteredTasks = state.tasks.filter((task) => {
        const matchesSearch = state.searchQuery === "" || task.name.toLowerCase().includes(state.searchQuery.toLowerCase()) || task.category.toLowerCase().includes(state.searchQuery.toLowerCase());
        const matchesDifficulty = state.difficultyFilter === "all" || task.difficulty === state.difficultyFilter;
        return matchesSearch && matchesDifficulty;
      });
      const selectedTask = state.selectedTaskId ? state.tasks.find((t) => t.id === state.selectedTaskId) : null;
      const taskList = html`
        <div class="flex flex-col h-full border-r border-zinc-800/60 bg-zinc-900/20 w-1/3 min-w-[300px]">
          <!-- Filters -->
          <div class="p-4 border-b border-zinc-800/60 space-y-3">
            <input
              type="text"
              placeholder="Search tasks..."
              class="w-full bg-zinc-900 border border-zinc-700 rounded px-3 py-2 text-sm text-zinc-200 focus:border-emerald-500 focus:outline-none"
              value="${state.searchQuery}"
              data-action="search"
            />
            <div class="flex gap-2 overflow-x-auto pb-1 no-scrollbar">
              ${joinTemplates(["all", "easy", "medium", "hard", "expert"].map((diff8) => {
        const isActive2 = state.difficultyFilter === diff8;
        const classes = isActive2 ? "bg-zinc-700 text-zinc-100 border-zinc-600" : "bg-zinc-900 text-zinc-400 border-zinc-800 hover:border-zinc-700";
        return html`
                    <button
                      class="px-2.5 py-1 text-xs rounded border ${classes} whitespace-nowrap capitalize transition-colors"
                      data-action="filter"
                      data-difficulty="${diff8}"
                    >
                      ${diff8}
                    </button>
                  `;
      }))}
            </div>
          </div>

          <!-- List -->
          <div class="flex-1 overflow-y-auto">
            ${state.loading ? html`<div class="p-8 text-center text-zinc-500 text-sm">Loading tasks...</div>` : filteredTasks.length === 0 ? html`<div class="p-8 text-center text-zinc-500 text-sm">No tasks found</div>` : html`
                    <div class="divide-y divide-zinc-800/40">
                      ${joinTemplates(filteredTasks.map((task) => {
        const isSelected = task.id === state.selectedTaskId;
        const diffColor = DIFFICULTY_COLORS[task.difficulty];
        const bgClass = isSelected ? "bg-zinc-800/60" : "hover:bg-zinc-800/30";
        return html`
                            <div
                              class="p-4 cursor-pointer transition-colors ${bgClass}"
                              data-action="selectTask"
                              data-task-id="${task.id}"
                            >
                              <div class="flex items-start justify-between gap-2 mb-1">
                                <div class="font-mono text-sm text-zinc-200 truncate" title="${task.name}">
                                  ${task.name}
                                </div>
                                <span
                                  class="px-1.5 py-0.5 text-[10px] uppercase rounded border ${diffColor.bg} ${diffColor.text} ${diffColor.border}"
                                >
                                  ${task.difficulty}
                                </span>
                              </div>
                              <div class="text-xs text-zinc-500 truncate">${task.category}</div>
                            </div>
                          `;
      }))}
                    </div>
                  `}
          </div>
        </div>
      `;
      const taskDetail = selectedTask ? html`
            <div class="flex-1 h-full overflow-y-auto p-6">
              <div class="max-w-3xl mx-auto">
                <div class="flex items-start justify-between mb-6">
                  <div>
                    <h2 class="text-xl font-bold font-mono text-zinc-100 mb-2">${selectedTask.name}</h2>
                    <div class="flex items-center gap-3 text-sm">
                      <span class="text-zinc-400">${selectedTask.category}</span>
                      <span class="text-zinc-600"></span>
                      <span class="${DIFFICULTY_COLORS[selectedTask.difficulty].text} capitalize">
                        ${selectedTask.difficulty}
                      </span>
                    </div>
                  </div>
                  <button
                    class="px-4 py-2 bg-emerald-600 hover:bg-emerald-500 text-white text-sm font-medium rounded transition-colors flex items-center gap-2"
                    data-action="runTask"
                    data-task-id="${selectedTask.id}"
                  >
                    <span> Run Task</span>
                  </button>
                </div>

                <div class="bg-zinc-900/40 border border-zinc-800/60 rounded-lg p-6 mb-6">
                  <h3 class="text-sm font-bold text-zinc-300 mb-3">Description</h3>
                  <div class="prose prose-invert prose-sm max-w-none text-zinc-400">
                    ${selectedTask.description}
                  </div>
                </div>

                <div class="grid grid-cols-2 gap-4 mb-6">
                  <div class="bg-zinc-900/40 border border-zinc-800/60 rounded-lg p-4">
                    <div class="text-xs text-zinc-500 mb-1">Timeout</div>
                    <div class="text-lg font-mono text-zinc-200">${selectedTask.timeoutSeconds}s</div>
                  </div>
                  <div class="bg-zinc-900/40 border border-zinc-800/60 rounded-lg p-4">
                    <div class="text-xs text-zinc-500 mb-1">Max Turns</div>
                    <div class="text-lg font-mono text-zinc-200">${selectedTask.maxTurns}</div>
                  </div>
                </div>

                ${selectedTask.tags.length > 0 ? html`
                      <div class="mb-6">
                        <h3 class="text-xs font-bold text-zinc-500 uppercase mb-2">Tags</h3>
                        <div class="flex flex-wrap gap-2">
                          ${joinTemplates(selectedTask.tags.map((tag) => html`
                                <span class="px-2 py-1 bg-zinc-800 text-zinc-300 text-xs rounded border border-zinc-700">
                                  ${tag}
                                </span>
                              `))}
                        </div>
                      </div>
                    ` : ""}
              </div>
            </div>
          ` : html`
            <div class="flex-1 h-full flex items-center justify-center text-zinc-500 bg-zinc-950/50">
              <div class="text-center">
                <div class="text-4xl mb-4 opacity-20"></div>
                <div>Select a task to view details</div>
              </div>
            </div>
          `;
      return html`
        <div class="flex h-full overflow-hidden">
          ${taskList} ${taskDetail}
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action='search']", "input", (_e, target) => {
        const query = target.value;
        exports_Effect.runFork(ctx.emit({ type: "updateSearch", query }));
      });
      yield* ctx.dom.delegate(ctx.container, "[data-action='filter']", "click", (_e, target) => {
        const difficulty = target.dataset.difficulty;
        if (difficulty) {
          exports_Effect.runFork(ctx.emit({ type: "updateFilter", difficulty }));
        }
      });
      yield* ctx.dom.delegate(ctx.container, "[data-action='selectTask']", "click", (_e, target) => {
        const taskId = target.dataset.taskId;
        if (taskId) {
          exports_Effect.runFork(ctx.emit({ type: "selectTask", taskId }));
        }
      });
      yield* ctx.dom.delegate(ctx.container, "[data-action='runTask']", "click", (_e, target) => {
        const taskId = target.dataset.taskId;
        if (taskId) {
          exports_Effect.runFork(ctx.emit({ type: "runTask", taskId }));
        }
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      const socket = yield* SocketServiceTag;
      switch (event.type) {
        case "loadTasks": {
          yield* ctx.state.update((s) => ({ ...s, loading: true, error: null }));
          try {
            const suite = yield* socket.loadTBSuite("tasks/terminal-bench-2.json");
            const tasks = suite.tasks.map((t) => ({
              id: t.id,
              name: t.name,
              slug: t.name.toLowerCase().replace(/\s+/g, "-"),
              description: t.description,
              difficulty: t.difficulty || "unknown",
              category: t.category || "General",
              tags: t.tags || [],
              timeoutSeconds: t.timeout || 300,
              maxTurns: t.max_turns || 50,
              status: "unattempted",
              lastRunId: null,
              attemptCount: 0,
              passCount: 0
            }));
            yield* ctx.state.update((s) => ({
              ...s,
              tasks,
              loading: false
            }));
          } catch (error) {
            yield* ctx.state.update((s) => ({
              ...s,
              loading: false,
              error: error instanceof Error ? error.message : String(error)
            }));
          }
          break;
        }
        case "selectTask": {
          yield* ctx.state.update((s) => ({ ...s, selectedTaskId: event.taskId }));
          break;
        }
        case "updateSearch": {
          yield* ctx.state.update((s) => ({ ...s, searchQuery: event.query }));
          break;
        }
        case "updateFilter": {
          yield* ctx.state.update((s) => ({ ...s, difficultyFilter: event.difficulty }));
          break;
        }
        case "runTask": {
          yield* socket.startTBRun({
            suitePath: "tasks/terminal-bench-2.json",
            taskIds: [event.taskId]
          }).pipe(exports_Effect.catchAll((error) => ctx.state.update((s) => ({
            ...s,
            error: `Failed to start run: ${error instanceof Error ? error.message : String(error)}`
          }))));
          break;
        }
      }
    }).pipe(exports_Effect.catchAll((error) => ctx.state.update((s) => ({
      ...s,
      error: `Unexpected error: ${error instanceof Error ? error.message : String(error)}`
    })))),
    subscriptions: (ctx) => {
      return [exports_Stream.make(ctx.emit({ type: "loadTasks" }))];
    }
  };
  // src/effuse/widgets/tb-command-center/tbcc-run-browser.ts
  var formatDate5 = (iso) => {
    try {
      return new Date(iso).toLocaleDateString(undefined, {
        month: "short",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      });
    } catch {
      return iso.slice(0, 10);
    }
  };
  var formatDuration5 = (ms) => {
    if (ms === null)
      return "-";
    const seconds2 = Math.floor(ms / 1000);
    if (seconds2 < 60)
      return `${seconds2}s`;
    const minutes2 = Math.floor(seconds2 / 60);
    const remainingSeconds = seconds2 % 60;
    return `${minutes2}m ${remainingSeconds}s`;
  };
  var TBCCRunBrowserWidget = {
    id: "tbcc-run-browser",
    initialState: () => ({
      runs: [],
      selectedRunId: null,
      selectedRunDetail: null,
      dataSource: "all",
      loading: true,
      loadingDetail: false,
      error: null,
      page: 0,
      pageSize: 50,
      hasMore: true
    }),
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      const filteredRuns = state.runs.filter((run5) => {
        if (state.dataSource === "all")
          return true;
        return run5.source === state.dataSource;
      });
      const runList = html`
        <div class="flex flex-col h-full border-r border-zinc-800/60 bg-zinc-900/20 w-1/3 min-w-[350px]">
          <!-- Controls -->
          <div class="p-4 border-b border-zinc-800/60 space-y-3">
            <div class="flex items-center justify-between">
              <h3 class="text-sm font-bold font-mono text-zinc-200">Run History</h3>
              <button
                class="text-xs text-zinc-500 hover:text-zinc-300 transition-colors"
                data-action="refresh"
              >
                 Refresh
              </button>
            </div>

            <!-- Source Filter -->
            <div class="flex bg-zinc-900 rounded-lg p-1 border border-zinc-800">
              ${joinTemplates(["all", "local", "hf"].map((source) => {
        const isActive2 = state.dataSource === source;
        const classes = isActive2 ? "bg-zinc-700 text-zinc-100 shadow-sm" : "text-zinc-500 hover:text-zinc-300";
        const labels = { all: "All", local: "Local", hf: "HuggingFace" };
        return html`
                    <button
                      class="flex-1 py-1 text-xs font-medium rounded transition-all ${classes}"
                      data-action="changeSource"
                      data-source="${source}"
                    >
                      ${labels[source]}
                    </button>
                  `;
      }))}
            </div>
          </div>

          <!-- List -->
          <div class="flex-1 overflow-y-auto">
            ${state.loading && state.page === 0 ? html`<div class="p-8 text-center text-zinc-500 text-sm">Loading runs...</div>` : filteredRuns.length === 0 ? html`<div class="p-8 text-center text-zinc-500 text-sm">No runs found</div>` : html`
                    <div class="divide-y divide-zinc-800/40">
                      ${joinTemplates(filteredRuns.map((run5) => {
        const isSelected = run5.id === state.selectedRunId;
        const outcomeColors = run5.outcome ? OUTCOME_COLORS[run5.outcome] : OUTCOME_COLORS.aborted;
        const bgClass = isSelected ? "bg-zinc-800/60" : "hover:bg-zinc-800/30";
        return html`
                            <div
                              class="p-4 cursor-pointer transition-colors ${bgClass}"
                              data-action="selectRun"
                              data-run-id="${run5.id}"
                              data-source="${run5.source}"
                            >
                              <div class="flex items-start justify-between gap-2 mb-1">
                                <div class="font-mono text-sm text-zinc-200 truncate" title="${run5.taskName}">
                                  ${run5.taskName}
                                </div>
                                <span
                                  class="px-1.5 py-0.5 text-[10px] uppercase rounded border ${outcomeColors.bg} ${outcomeColors.text} ${outcomeColors.border}"
                                >
                                  ${run5.outcome ?? "running"}
                                </span>
                              </div>
                              <div class="flex items-center justify-between text-xs text-zinc-500">
                                <span>${formatDate5(run5.startedAt)}</span>
                                <div class="flex gap-3">
                                  <span>${run5.stepsCount} steps</span>
                                  <span>${formatDuration5(run5.durationMs)}</span>
                                </div>
                              </div>
                              ${run5.source === "hf" ? html`
                                    <div class="mt-1 text-[10px] text-zinc-600 flex items-center gap-1">
                                      <span class="w-1.5 h-1.5 rounded-full bg-yellow-600/50"></span>
                                      HF: ${run5.agentName}
                                    </div>
                                  ` : html`
                                    <div class="mt-1 text-[10px] text-zinc-600 flex items-center gap-1">
                                      <span class="w-1.5 h-1.5 rounded-full bg-blue-600/50"></span>
                                      Local Run
                                    </div>
                                  `}
                            </div>
                          `;
      }))}
                      ${state.hasMore ? html`
                            <div class="p-4 text-center">
                              <button
                                class="text-xs text-zinc-400 hover:text-zinc-200"
                                data-action="loadMore"
                              >
                                Load More 
                              </button>
                            </div>
                          ` : ""}
                    </div>
                  `}
          </div>
        </div>
      `;
      const detailPanel = state.selectedRunDetail ? html`
            <div class="flex-1 h-full overflow-y-auto bg-zinc-950">
              <!-- Header -->
              <div class="px-6 py-4 border-b border-zinc-800/60 bg-zinc-900/20">
                <div class="flex items-center justify-between mb-2">
                  <h2 class="text-lg font-bold font-mono text-zinc-100">${state.selectedRunDetail.taskName}</h2>
                  <div class="flex items-center gap-2">
                    <span class="text-xs text-zinc-500 font-mono">${state.selectedRunDetail.id}</span>
                    ${state.selectedRunDetail.source === "hf" ? html`<span class="px-2 py-0.5 rounded text-xs bg-yellow-900/30 text-yellow-500 border border-yellow-800/50">HuggingFace</span>` : html`<span class="px-2 py-0.5 rounded text-xs bg-blue-900/30 text-blue-400 border border-blue-800/50">Local</span>`}
                  </div>
                </div>

                <div class="flex items-center gap-6 text-sm text-zinc-400">
                  <div>
                    <span class="text-zinc-600">Status:</span>
                    <span class="${state.selectedRunDetail.outcome === "success" ? "text-emerald-400" : "text-red-400"} capitalize">
                      ${state.selectedRunDetail.outcome ?? "Unknown"}
                    </span>
                  </div>
                  <div>
                    <span class="text-zinc-600">Steps:</span>
                    <span class="text-zinc-200">${state.selectedRunDetail.stepsCount}</span>
                  </div>
                  <div>
                    <span class="text-zinc-600">Duration:</span>
                    <span class="text-zinc-200">${formatDuration5(state.selectedRunDetail.durationMs)}</span>
                  </div>
                </div>
              </div>

              <!-- Steps -->
              <div class="p-6">
                <h3 class="text-sm font-bold text-zinc-500 uppercase mb-4">Execution Steps</h3>
                <div class="space-y-4">
                  ${joinTemplates(state.selectedRunDetail.steps.map((step4) => {
        const statusColor = step4.success ? "border-emerald-900/30" : "border-red-900/30";
        return html`
                        <div class="bg-zinc-900/40 border ${statusColor} rounded-lg overflow-hidden">
                          <div class="px-4 py-2 bg-zinc-900/60 border-b border-zinc-800/40 flex items-center justify-between">
                            <div class="flex items-center gap-3">
                              <span class="text-xs font-mono text-zinc-500">#${step4.index}</span>
                              <span class="text-sm font-mono text-zinc-200">${step4.actionLabel}</span>
                            </div>
                            <span class="text-xs text-zinc-500">${formatDuration5(step4.durationMs)}</span>
                          </div>

                          <div class="p-4 space-y-3">
                            ${step4.shortReason ? html`
                                  <div class="text-sm text-zinc-400 italic">
                                    "${step4.shortReason}"
                                  </div>
                                ` : ""}

                            ${step4.toolCall ? html`
                                  <div class="bg-zinc-950/50 rounded border border-zinc-800/40 p-3">
                                    <div class="text-xs text-violet-400 font-mono mb-1">Tool Call: ${step4.toolCall.functionName}</div>
                                    <pre class="text-xs text-zinc-400 overflow-x-auto whitespace-pre-wrap font-mono">${JSON.stringify(step4.toolCall.arguments, null, 2)}</pre>
                                  </div>
                                ` : ""}

                            ${step4.observation ? html`
                                  <div class="bg-zinc-950/50 rounded border border-zinc-800/40 p-3">
                                    <div class="text-xs text-emerald-400 font-mono mb-1">Observation</div>
                                    <pre class="text-xs text-zinc-400 overflow-x-auto whitespace-pre-wrap font-mono">${typeof step4.observation.content === "string" ? step4.observation.content : JSON.stringify(step4.observation.content, null, 2)}</pre>
                                  </div>
                                ` : ""}
                          </div>
                        </div>
                      `;
      }))}
                </div>
              </div>
            </div>
          ` : state.loadingDetail ? html`
              <div class="flex-1 h-full flex items-center justify-center text-zinc-500">
                Loading details...
              </div>
            ` : html`
              <div class="flex-1 h-full flex items-center justify-center text-zinc-500 bg-zinc-950/50">
                <div class="text-center">
                  <div class="text-4xl mb-4 opacity-20"></div>
                  <div>Select a run to view details</div>
                </div>
              </div>
            `;
      return html`
        <div class="flex h-full overflow-hidden">
          ${runList} ${detailPanel}
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action='changeSource']", "click", (_e, target) => {
        const source = target.dataset.source;
        if (source) {
          exports_Effect.runFork(ctx.emit({ type: "changeSource", source }));
        }
      });
      yield* ctx.dom.delegate(ctx.container, "[data-action='selectRun']", "click", (_e, target) => {
        const runId = target.dataset.runId;
        const source = target.dataset.source;
        if (runId && source) {
          exports_Effect.runFork(ctx.emit({ type: "selectRun", runId, source }));
        }
      });
      yield* ctx.dom.delegate(ctx.container, "[data-action='refresh']", "click", () => {
        exports_Effect.runFork(ctx.emit({ type: "refresh" }));
      });
      yield* ctx.dom.delegate(ctx.container, "[data-action='loadMore']", "click", () => {
        exports_Effect.runFork(ctx.state.update((s) => ({ ...s, page: s.page + 1 })).pipe(exports_Effect.flatMap(() => ctx.emit({ type: "loadRuns", page: -1 }))));
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      const socket = yield* SocketServiceTag;
      switch (event.type) {
        case "loadRuns": {
          yield* ctx.state.update((s) => ({ ...s, loading: true, error: null }));
          try {
            const localRunsRaw = yield* socket.loadRecentTBRuns(20);
            const localRuns = localRunsRaw.map((r) => ({
              id: r.runId,
              source: "local",
              taskId: r.taskIds?.[0] ?? "unknown",
              taskName: r.taskNames?.[0] ?? r.runId,
              outcome: r.outcome,
              status: r.status,
              startedAt: r.startedAt,
              finishedAt: r.finishedAt ?? null,
              durationMs: r.durationMs ?? null,
              stepsCount: r.stepsCount ?? 0,
              tokensUsed: r.tokensUsed ?? null
            }));
            const hfRunsRaw = yield* socket.getHFTrajectories(0, 20);
            const hfRuns = hfRunsRaw.map((t) => {
              const extra = t.extra;
              return {
                id: t.session_id,
                source: "hf",
                taskId: extra?.task ?? "unknown",
                taskName: extra?.task ?? "unknown",
                outcome: "success",
                status: "completed",
                startedAt: extra?.date ?? t.steps[0]?.timestamp ?? new Date().toISOString(),
                finishedAt: null,
                durationMs: null,
                stepsCount: t.steps.length,
                tokensUsed: null,
                agentName: t.agent?.name,
                modelName: t.agent?.model_name,
                episode: extra?.episode
              };
            });
            const allRuns = [...localRuns, ...hfRuns].sort((a, b) => new Date(b.startedAt).getTime() - new Date(a.startedAt).getTime());
            yield* ctx.state.update((s) => ({
              ...s,
              runs: allRuns,
              loading: false
            }));
          } catch (error) {
            yield* ctx.state.update((s) => ({
              ...s,
              loading: false,
              error: error instanceof Error ? error.message : String(error)
            }));
          }
          break;
        }
        case "changeSource": {
          yield* ctx.state.update((s) => ({ ...s, dataSource: event.source }));
          break;
        }
        case "selectRun": {
          yield* ctx.state.update((s) => ({
            ...s,
            selectedRunId: event.runId,
            loadingDetail: true,
            selectedRunDetail: null
          }));
          try {
            let detail = null;
            if (event.source === "local") {
              const runData = yield* socket.loadTBRunDetails(event.runId);
              if (runData) {
                const firstTask = runData.tasks[0];
                detail = {
                  id: runData.meta.runId,
                  source: "local",
                  taskId: firstTask?.id ?? "unknown",
                  taskName: firstTask?.name ?? runData.meta.suiteName,
                  outcome: firstTask?.outcome ?? "unknown",
                  status: "completed",
                  startedAt: runData.meta.timestamp,
                  finishedAt: null,
                  durationMs: runData.meta.totalDurationMs,
                  stepsCount: firstTask?.turns ?? 0,
                  tokensUsed: runData.meta.totalTokens,
                  steps: [],
                  terminalOutput: { stdout: [], stderr: [] }
                };
              }
            } else {
              const hfRunsRaw = yield* socket.getHFTrajectories(0, 100);
              const t = hfRunsRaw.find((t2) => t2.session_id === event.runId);
              if (t) {
                const extra = t.extra;
                detail = {
                  id: t.session_id,
                  source: "hf",
                  taskId: extra?.task ?? "unknown",
                  taskName: extra?.task ?? "unknown",
                  outcome: "success",
                  status: "completed",
                  startedAt: extra?.date ?? t.steps[0]?.timestamp ?? new Date().toISOString(),
                  finishedAt: null,
                  durationMs: null,
                  stepsCount: t.steps.length,
                  tokensUsed: null,
                  agentName: t.agent?.name,
                  modelName: t.agent?.model_name,
                  episode: extra?.episode,
                  steps: (t.steps || []).map((s, idx) => ({
                    id: `step-${idx}`,
                    index: idx,
                    actionType: "CUSTOM",
                    actionLabel: s.action || "Unknown",
                    shortReason: s.observation?.slice(0, 100) || "",
                    details: null,
                    timestamp: new Date().toISOString(),
                    success: true,
                    durationMs: null,
                    ...s.tool_call ? {
                      toolCall: {
                        functionName: s.tool_call.function || "unknown",
                        arguments: s.tool_call.arguments || {}
                      }
                    } : {},
                    ...s.observation ? {
                      observation: {
                        content: s.observation,
                        truncated: false
                      }
                    } : {}
                  })),
                  terminalOutput: { stdout: [], stderr: [] }
                };
              }
            }
            yield* ctx.state.update((s) => ({
              ...s,
              selectedRunDetail: detail,
              loadingDetail: false
            }));
          } catch (error) {
            yield* ctx.state.update((s) => ({
              ...s,
              loadingDetail: false,
              error: error instanceof Error ? error.message : String(error)
            }));
          }
          break;
        }
        case "refresh": {
          yield* ctx.emit({ type: "loadRuns", page: 0 });
          break;
        }
      }
    }).pipe(exports_Effect.catchAll((error) => ctx.state.update((s) => ({
      ...s,
      loading: false,
      loadingDetail: false,
      error: error instanceof Error ? error.message : String(error)
    })))),
    subscriptions: (ctx) => {
      return [exports_Stream.make(ctx.emit({ type: "loadRuns", page: 0 }))];
    }
  };
  // src/effuse/widgets/tb-command-center/tbcc-testgen.ts
  var TBTestGenWidget = {
    id: "tbcc-testgen",
    initialState: () => {
      console.log("[TBTestGen] Creating initial state");
      return {
        status: "idle",
        taskIds: [],
        selectedTaskId: null,
        sessionId: null,
        taskId: null,
        taskDescription: null,
        environment: null,
        tests: [],
        totalTests: 0,
        durationMs: 0,
        uncertainties: [],
        error: null
      };
    },
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      if (window.bunLog) {
        window.bunLog(`[TBTestGen] render called, status=${state.status}`);
      }
      const header = html`
        <div class="border-b border-zinc-800/60 p-4">
          <h2 class="text-xl font-bold font-mono text-zinc-100">Test Generation</h2>
          <p class="text-sm text-zinc-500 mt-1">Environment-aware test generation for TB tasks</p>
        </div>
      `;
      const controls = html`
        <div class="p-4 border-b border-zinc-800/60 space-y-4">
          <div class="flex items-center gap-4">
            <label class="text-sm font-mono text-zinc-400 flex-shrink-0">Task:</label>
            <select
              class="flex-1 px-3 py-2 bg-zinc-900 border border-zinc-700 rounded text-sm font-mono text-zinc-200 focus:outline-none focus:border-emerald-500"
              data-action="selectTask"
              ${state.status !== "idle" && state.status !== "complete" && state.status !== "error" ? "disabled" : ""}
            >
              <option value="">Random task</option>
              ${state.taskIds.length > 0 ? joinTemplates(state.taskIds.map((id2) => html`
                        <option value="${id2}" ${state.selectedTaskId === id2 ? "selected" : ""}>${id2}</option>
                      `)) : html`<option disabled>No tasks loaded</option>`}
            </select>
            <button
              class="px-4 py-2 bg-emerald-600 hover:bg-emerald-700 text-white text-sm font-mono rounded transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
              data-action="generate"
              ${state.status !== "idle" && state.status !== "complete" && state.status !== "error" ? "disabled" : ""}
            >
              ${state.status === "generating" ? "Generating..." : " Generate"}
            </button>
            ${state.status === "complete" || state.status === "error" ? html`
                  <button
                    class="px-4 py-2 bg-zinc-700 hover:bg-zinc-600 text-white text-sm font-mono rounded transition-colors"
                    data-action="clear"
                  >
                    Clear
                  </button>
                ` : ""}
          </div>
        </div>
      `;
      const environmentPanel = state.environment ? html`
              <div class="p-4 bg-zinc-900/40 border-b border-zinc-800/60">
                <div class="flex items-start gap-6">
                  <div>
                    <span class="text-xs text-zinc-500 font-mono">Platform:</span>
                    <span class="ml-2 text-sm text-zinc-200 font-mono">${state.environment.platform}</span>
                  </div>
                  <div>
                    <span class="text-xs text-zinc-500 font-mono">Files:</span>
                    <span class="ml-2 text-sm text-zinc-200 font-mono">${state.environment.fileCount} (${state.environment.filePreviews} previews)</span>
                  </div>
                </div>
                ${state.environment.prohibitedTools.length > 0 ? html`
                      <div class="mt-2">
                        <span class="text-xs text-zinc-500 font-mono">Prohibited Tools:</span>
                        <div class="mt-1 flex flex-wrap gap-2">
                          ${joinTemplates(state.environment.prohibitedTools.map((tool) => html`
                                  <span class="px-2 py-1 bg-red-900/30 border border-red-700/50 rounded text-xs text-red-300 font-mono">
                                    ${tool}
                                  </span>
                                `))}
                        </div>
                      </div>
                    ` : ""}
                ${state.environment.languages.length > 0 ? html`
                      <div class="mt-2">
                        <span class="text-xs text-zinc-500 font-mono">Languages:</span>
                        <div class="mt-1 flex flex-wrap gap-2">
                          ${joinTemplates(state.environment.languages.map((lang) => html`
                                  <span class="px-2 py-1 bg-blue-900/30 border border-blue-700/50 rounded text-xs text-blue-300 font-mono">
                                    ${lang}
                                  </span>
                                `))}
                        </div>
                      </div>
                    ` : ""}
              </div>
            ` : "";
      const taskDescPanel = state.taskDescription ? html`
              <div class="p-4 bg-zinc-900/40 border-b border-zinc-800/60">
                <span class="text-xs text-zinc-500 font-mono">Task: ${state.taskId ?? ""}</span>
                <p class="mt-1 text-sm text-zinc-300 font-mono leading-relaxed">${state.taskDescription.slice(0, 300)}${state.taskDescription.length > 300 ? "..." : ""}</p>
              </div>
            ` : "";
      const testCards = state.tests.length > 0 ? html`
              <div class="p-4 space-y-3 overflow-y-auto flex-1">
                <div class="flex items-center justify-between mb-2">
                  <h3 class="text-sm font-mono text-zinc-400">Generated Tests (${state.tests.length})</h3>
                  ${state.status === "complete" ? html`<span class="text-xs text-emerald-400 font-mono">${(state.durationMs / 1000).toFixed(1)}s</span>` : ""}
                </div>
                ${joinTemplates(state.tests.map((test) => {
        const categoryColors = {
          anti_cheat: { bg: "bg-red-900/30", text: "text-red-300", border: "border-red-700/50" },
          existence: { bg: "bg-blue-900/30", text: "text-blue-300", border: "border-blue-700/50" },
          correctness: { bg: "bg-emerald-900/30", text: "text-emerald-300", border: "border-emerald-700/50" },
          boundary: { bg: "bg-yellow-900/30", text: "text-yellow-300", border: "border-yellow-700/50" },
          integration: { bg: "bg-purple-900/30", text: "text-purple-300", border: "border-purple-700/50" }
        };
        const colors2 = categoryColors[test.category] ?? { bg: "bg-zinc-800/30", text: "text-zinc-300", border: "border-zinc-700/50" };
        return html`
                        <div class="p-3 bg-zinc-900 border ${colors2.border} rounded">
                          <div class="flex items-start justify-between mb-2">
                            <span class="px-2 py-1 ${colors2.bg} ${colors2.text} text-xs font-mono rounded uppercase">${test.category}</span>
                            <div class="flex items-center gap-2">
                              <span class="text-xs text-zinc-500 font-mono">${(test.confidence * 100).toFixed(0)}%</span>
                              <div class="w-16 h-1.5 bg-zinc-800 rounded overflow-hidden">
                                <div class="h-full ${colors2.bg}" style="width: ${test.confidence * 100}%"></div>
                              </div>
                            </div>
                          </div>
                          <div class="space-y-2">
                            <div>
                              <span class="text-xs text-zinc-500 font-mono">Input:</span>
                              <pre class="mt-1 px-2 py-1 bg-zinc-950 border border-zinc-800 rounded text-xs text-zinc-300 font-mono overflow-x-auto">${test.input}</pre>
                            </div>
                            ${test.expectedOutput ? html`
                                  <div>
                                    <span class="text-xs text-zinc-500 font-mono">Expected:</span>
                                    <pre class="mt-1 px-2 py-1 bg-zinc-950 border border-zinc-800 rounded text-xs text-zinc-300 font-mono overflow-x-auto">${test.expectedOutput}</pre>
                                  </div>
                                ` : ""}
                            <div>
                              <span class="text-xs text-zinc-500 font-mono">Reasoning:</span>
                              <p class="mt-1 text-xs text-zinc-400 leading-relaxed">${test.reasoning}</p>
                            </div>
                          </div>
                        </div>
                      `;
      }))}
              </div>
            ` : "";
      const completionSummary = state.status === "complete" && state.uncertainties.length > 0 ? html`
              <div class="p-4 bg-yellow-900/20 border-t border-yellow-700/50">
                <h4 class="text-sm font-mono text-yellow-300 mb-2">Uncertainties:</h4>
                <ul class="space-y-1">
                  ${joinTemplates(state.uncertainties.map((u) => html`
                        <li class="text-xs text-yellow-200 font-mono"> ${u}</li>
                      `))}
                </ul>
              </div>
            ` : "";
      const errorPanel = state.error ? html`
            <div class="p-4 bg-red-900/20 border border-red-700/50 rounded m-4">
              <h4 class="text-sm font-mono text-red-300 mb-1">Error:</h4>
              <p class="text-xs text-red-200 font-mono">${state.error}</p>
            </div>
          ` : "";
      const emptyState = state.status === "idle" && state.tests.length === 0 ? html`
              <div class="flex-1 flex items-center justify-center text-center p-8">
                <div>
                  <div class="text-6xl mb-4"></div>
                  <h3 class="text-lg font-mono text-zinc-400 mb-2">No tests generated yet</h3>
                  <p class="text-sm text-zinc-600">Select a task and click Generate to start</p>
                </div>
              </div>
            ` : "";
      const loadingState = state.status === "generating" && state.tests.length === 0 ? html`
              <div class="flex-1 flex items-center justify-center text-center p-8">
                <div>
                  <div class="animate-spin text-4xl mb-4"></div>
                  <h3 class="text-lg font-mono text-zinc-400">Generating tests...</h3>
                  <p class="text-sm text-zinc-600 mt-2">This may take 10-30 seconds</p>
                </div>
              </div>
            ` : "";
      const result = html`
        <div class="h-full flex flex-col bg-zinc-950">
          ${header} ${controls} ${environmentPanel} ${taskDescPanel} ${errorPanel} ${emptyState} ${loadingState} ${testCards} ${completionSummary}
        </div>
      `;
      if (window.bunLog) {
        const emptyStateStr = emptyState.toString();
        const controlsStr = controls.toString();
        window.bunLog(`[TBTestGen] render output length=${result.toString().length}, hasEmptyState=${emptyStateStr !== ""}, hasControls=${controlsStr !== ""}`);
      }
      return result;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action='selectTask']", "change", (_e, target) => {
        const value = target.value;
        exports_Effect.runFork(ctx.emit({ type: "selectTask", taskId: value || null }));
      });
      yield* ctx.dom.delegate(ctx.container, "[data-action='generate']", "click", () => {
        exports_Effect.runFork(ctx.emit({ type: "generate" }));
      });
      yield* ctx.dom.delegate(ctx.container, "[data-action='clear']", "click", () => {
        exports_Effect.runFork(ctx.emit({ type: "clear" }));
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      const socket = yield* SocketServiceTag;
      switch (event.type) {
        case "loadSuite": {
          yield* ctx.state.update((s) => ({ ...s, status: "loading_suite" }));
          const suiteInfo = yield* socket.loadTBSuite("tasks/terminal-bench-2.json").pipe(exports_Effect.catchAll((error) => exports_Effect.gen(function* () {
            yield* ctx.state.update((s) => ({
              ...s,
              status: "error",
              error: error.message
            }));
            return null;
          })));
          if (suiteInfo) {
            const taskIds = suiteInfo.tasks.map((t) => t.id);
            yield* ctx.state.update((s) => ({
              ...s,
              status: "idle",
              taskIds
            }));
          }
          break;
        }
        case "selectTask": {
          yield* ctx.state.update((s) => ({ ...s, selectedTaskId: event.taskId }));
          break;
        }
        case "generate": {
          const state = yield* ctx.state.get;
          yield* ctx.state.update((s) => ({
            ...s,
            status: "generating",
            sessionId: null,
            taskId: null,
            taskDescription: null,
            environment: null,
            tests: [],
            totalTests: 0,
            durationMs: 0,
            uncertainties: [],
            error: null
          }));
          const result = yield* socket.startTestGen("tasks/terminal-bench-2.json", state.selectedTaskId ?? undefined, "local").pipe(exports_Effect.catchAll((error) => exports_Effect.gen(function* () {
            yield* ctx.state.update((s) => ({
              ...s,
              status: "error",
              error: error.message
            }));
            return null;
          })));
          if (result) {
            yield* ctx.state.update((s) => ({ ...s, sessionId: result.sessionId }));
          }
          break;
        }
        case "clear": {
          yield* ctx.state.update((s) => ({
            ...s,
            status: "idle",
            sessionId: null,
            taskId: null,
            taskDescription: null,
            environment: null,
            tests: [],
            totalTests: 0,
            durationMs: 0,
            uncertainties: [],
            error: null
          }));
          break;
        }
      }
    }),
    subscriptions: (ctx) => {
      const testgenSub = exports_Effect.gen(function* () {
        const socket = yield* SocketServiceTag;
        yield* ctx.emit({ type: "loadSuite" });
        yield* exports_Stream.runForEach(socket.getMessages(), (msg) => exports_Effect.gen(function* () {
          const state = yield* ctx.state.get;
          if ("sessionId" in msg && msg.sessionId !== state.sessionId) {
            return;
          }
          if (msg.type === "testgen_start") {
            const data = msg;
            yield* ctx.state.update((s) => ({
              ...s,
              taskId: data.taskId,
              taskDescription: data.taskDescription,
              environment: data.environment
            }));
          } else if (msg.type === "testgen_test") {
            const data = msg;
            yield* ctx.state.update((s) => ({
              ...s,
              tests: [...s.tests, data.test]
            }));
          } else if (msg.type === "testgen_complete") {
            const data = msg;
            yield* ctx.state.update((s) => ({
              ...s,
              status: "complete",
              totalTests: data.totalTests,
              durationMs: data.durationMs,
              uncertainties: data.uncertainties
            }));
          } else if (msg.type === "testgen_error") {
            const data = msg;
            yield* ctx.state.update((s) => ({
              ...s,
              status: "error",
              error: data.error
            }));
          }
        }));
      });
      return [exports_Stream.make(testgenSub)];
    }
  };
  // src/effuse/widgets/tb-command-center/tbcc-settings.ts
  var STORAGE_KEY2 = "tbcc_settings";
  var loadSettings = () => {
    if (typeof localStorage === "undefined") {
      return { execution: DEFAULT_EXECUTION_SETTINGS, logging: DEFAULT_LOGGING_SETTINGS };
    }
    try {
      const saved = localStorage.getItem(STORAGE_KEY2);
      if (saved) {
        return JSON.parse(saved);
      }
    } catch (e) {
      console.error("Failed to load settings", e);
    }
    return { execution: DEFAULT_EXECUTION_SETTINGS, logging: DEFAULT_LOGGING_SETTINGS };
  };
  var saveSettings = (execution, logging) => {
    if (typeof localStorage === "undefined")
      return;
    try {
      localStorage.setItem(STORAGE_KEY2, JSON.stringify({ execution, logging }));
    } catch (e) {
      console.error("Failed to save settings", e);
    }
  };
  var TBCCSettingsWidget = {
    id: "tbcc-settings",
    initialState: () => {
      const { execution, logging } = loadSettings();
      return {
        execution,
        logging,
        saved: false
      };
    },
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      const inputClass = "w-full bg-zinc-900 border border-zinc-700 rounded px-3 py-2 text-sm text-zinc-200 focus:border-emerald-500 focus:outline-none";
      const checkboxClass = "w-4 h-4 rounded border-zinc-700 bg-zinc-900 text-emerald-500 focus:ring-emerald-500 focus:ring-offset-zinc-900";
      const labelClass = "block text-xs font-medium text-zinc-400 mb-1";
      return html`
        <div class="h-full overflow-y-auto p-8">
          <div class="max-w-2xl mx-auto">
            <div class="flex items-center justify-between mb-8">
              <h2 class="text-xl font-bold font-mono text-zinc-100">Settings</h2>
              ${state.saved ? html`<span class="text-sm text-emerald-400 animate-fade-out">Settings saved!</span>` : ""}
            </div>

            <!-- Model Selection -->
            <div class="bg-zinc-900/40 border border-zinc-800/60 rounded-lg p-6 mb-6">
              <h3 class="text-sm font-bold text-zinc-200 mb-4 flex items-center gap-2">
                <span class="text-lg"></span> Model
              </h3>
              <div class="flex gap-4">
                <label class="flex items-center gap-3 p-3 rounded-lg border cursor-pointer transition-colors
                  ${state.execution.model === "fm" ? "bg-emerald-900/30 border-emerald-600/50 text-emerald-200" : "border-zinc-700/50 text-zinc-400 hover:border-zinc-600/60"}">
                  <input
                    type="radio"
                    name="model"
                    value="fm"
                    ${state.execution.model === "fm" ? "checked" : ""}
                    data-action="updateExecution"
                    data-key="model"
                    class="hidden"
                  />
                  <div>
                    <div class="font-medium">Foundation Model</div>
                    <div class="text-xs opacity-70">Apple on-device (default)</div>
                  </div>
                </label>
                <label class="flex items-center gap-3 p-3 rounded-lg border cursor-pointer transition-colors
                  ${state.execution.model === "claude-code" ? "bg-blue-900/30 border-blue-600/50 text-blue-200" : "border-zinc-700/50 text-zinc-400 hover:border-zinc-600/60"}">
                  <input
                    type="radio"
                    name="model"
                    value="claude-code"
                    ${state.execution.model === "claude-code" ? "checked" : ""}
                    data-action="updateExecution"
                    data-key="model"
                    class="hidden"
                  />
                  <div>
                    <div class="font-medium">Claude Code</div>
                    <div class="text-xs opacity-70">Cloud-based</div>
                  </div>
                </label>
              </div>
            </div>

            <!-- Execution Settings -->
            <div class="bg-zinc-900/40 border border-zinc-800/60 rounded-lg p-6 mb-6">
              <h3 class="text-sm font-bold text-zinc-200 mb-4 flex items-center gap-2">
                <span class="text-lg"></span> Execution
              </h3>

              <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div>
                  <label class="${labelClass}">Max Attempts</label>
                  <input
                    type="number"
                    class="${inputClass}"
                    value="${state.execution.maxAttempts}"
                    data-action="updateExecution"
                    data-key="maxAttempts"
                  />
                  <p class="text-[10px] text-zinc-500 mt-1">Retries per task</p>
                </div>

                <div>
                  <label class="${labelClass}">Max Steps per Run</label>
                  <input
                    type="number"
                    class="${inputClass}"
                    value="${state.execution.maxStepsPerRun}"
                    data-action="updateExecution"
                    data-key="maxStepsPerRun"
                  />
                  <p class="text-[10px] text-zinc-500 mt-1">Limit to prevent infinite loops</p>
                </div>

                <div>
                  <label class="${labelClass}">Timeout (seconds)</label>
                  <input
                    type="number"
                    class="${inputClass}"
                    value="${state.execution.timeoutSeconds}"
                    data-action="updateExecution"
                    data-key="timeoutSeconds"
                  />
                </div>

                <div>
                  <label class="${labelClass}">Recursion Limit</label>
                  <input
                    type="number"
                    class="${inputClass}"
                    value="${state.execution.recursionLimitN}"
                    data-action="updateExecution"
                    data-key="recursionLimitN"
                  />
                </div>
              </div>

              <div class="mt-6 space-y-3">
                <label class="flex items-center gap-3">
                  <input
                    type="checkbox"
                    class="${checkboxClass}"
                    ${state.execution.deepComputeEnabled ? "checked" : ""}
                    data-action="updateExecution"
                    data-key="deepComputeEnabled"
                  />
                  <span class="text-sm text-zinc-300">Enable Deep Compute (Tree Search)</span>
                </label>

                <label class="flex items-center gap-3">
                  <input
                    type="checkbox"
                    class="${checkboxClass}"
                    ${state.execution.earlyStopOnHighConfidence ? "checked" : ""}
                    data-action="updateExecution"
                    data-key="earlyStopOnHighConfidence"
                  />
                  <span class="text-sm text-zinc-300">Early stop on high confidence</span>
                </label>
              </div>
            </div>

            <!-- Logging Settings -->
            <div class="bg-zinc-900/40 border border-zinc-800/60 rounded-lg p-6 mb-8">
              <h3 class="text-sm font-bold text-zinc-200 mb-4 flex items-center gap-2">
                <span class="text-lg"></span> Logging & Storage
              </h3>

              <div class="space-y-3">
                <label class="flex items-center gap-3">
                  <input
                    type="checkbox"
                    class="${checkboxClass}"
                    ${state.logging.saveTrajectories ? "checked" : ""}
                    data-action="updateLogging"
                    data-key="saveTrajectories"
                  />
                  <span class="text-sm text-zinc-300">Save full trajectories (JSON)</span>
                </label>

                <label class="flex items-center gap-3">
                  <input
                    type="checkbox"
                    class="${checkboxClass}"
                    ${state.logging.saveTerminalOutput ? "checked" : ""}
                    data-action="updateLogging"
                    data-key="saveTerminalOutput"
                  />
                  <span class="text-sm text-zinc-300">Save terminal output logs</span>
                </label>

                <label class="flex items-center gap-3">
                  <input
                    type="checkbox"
                    class="${checkboxClass}"
                    ${state.logging.saveAtifTraces ? "checked" : ""}
                    data-action="updateLogging"
                    data-key="saveAtifTraces"
                  />
                  <span class="text-sm text-zinc-300">Save ATIF traces</span>
                </label>
              </div>

              <div class="mt-6">
                <label class="${labelClass}">Auto-prune logs older than (days)</label>
                <input
                  type="number"
                  class="${inputClass} w-32"
                  value="${state.logging.autoPruneDays ?? ""}"
                  placeholder="Never"
                  data-action="updateLogging"
                  data-key="autoPruneDays"
                />
              </div>
            </div>

            <!-- Actions -->
            <div class="flex items-center justify-end gap-4">
              <button
                class="px-4 py-2 text-sm text-zinc-400 hover:text-zinc-200 transition-colors"
                data-action="reset"
              >
                Reset to Defaults
              </button>
              <button
                class="px-6 py-2 bg-emerald-600 hover:bg-emerald-500 text-white text-sm font-medium rounded transition-colors shadow-lg shadow-emerald-900/20"
                data-action="save"
              >
                Save Changes
              </button>
            </div>
          </div>
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "input", "change", (_e, target) => {
        const el = target;
        const action = el.dataset.action;
        const key = el.dataset.key;
        if (!action || !key)
          return;
        let value;
        if (el.type === "checkbox") {
          value = el.checked;
        } else if (el.type === "number") {
          value = el.value === "" ? null : Number(el.value);
        } else if (el.type === "radio") {
          value = el.value;
        } else {
          value = el.value;
        }
        if (action === "updateExecution") {
          exports_Effect.runFork(ctx.emit({ type: "updateExecution", key, value }));
        } else if (action === "updateLogging") {
          exports_Effect.runFork(ctx.emit({ type: "updateLogging", key, value }));
        }
      });
      yield* ctx.dom.delegate(ctx.container, "label:has(input[name='model'])", "click", (_e, target) => {
        const label = target;
        const radio = label.querySelector("input[type='radio']");
        if (radio && !radio.checked) {
          exports_Effect.runFork(ctx.emit({
            type: "updateExecution",
            key: "model",
            value: radio.value
          }));
        }
      });
      yield* ctx.dom.delegate(ctx.container, "button[data-action='save']", "click", () => {
        exports_Effect.runFork(ctx.emit({ type: "save" }));
      });
      yield* ctx.dom.delegate(ctx.container, "button[data-action='reset']", "click", () => {
        exports_Effect.runFork(ctx.emit({ type: "reset" }));
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      switch (event.type) {
        case "updateExecution": {
          yield* ctx.state.update((s) => ({
            ...s,
            execution: { ...s.execution, [event.key]: event.value },
            saved: false
          }));
          break;
        }
        case "updateLogging": {
          yield* ctx.state.update((s) => ({
            ...s,
            logging: { ...s.logging, [event.key]: event.value },
            saved: false
          }));
          break;
        }
        case "save": {
          const state = yield* ctx.state.get;
          saveSettings(state.execution, state.logging);
          yield* ctx.state.update((s) => ({ ...s, saved: true }));
          yield* exports_Effect.sleep("2 seconds");
          yield* ctx.state.update((s) => ({ ...s, saved: false }));
          break;
        }
        case "reset": {
          yield* ctx.state.update((s) => ({
            ...s,
            execution: DEFAULT_EXECUTION_SETTINGS,
            logging: DEFAULT_LOGGING_SETTINGS,
            saved: false
          }));
          break;
        }
      }
    })
  };
  // src/mainview/effuse-main.ts
  console.log("[Effuse] Loading mainview...");
  if (window.bunLog) {
    window.bunLog("[Effuse] ========== EFFUSE-MAIN.TS IS EXECUTING ==========");
  }
  var showError = (msg) => {
    document.body.innerHTML = `<div style="padding:20px;color:red;font-family:monospace;background:#1a1a1a;">
    <h2>Effuse Error</h2>
    <pre>${msg}</pre>
  </div>`;
  };
  window.onerror = (msg, src, line, col, error) => {
    console.error("[Effuse] Global error:", msg, src, line, col, error);
    showError(`${msg}

Source: ${src}:${line}:${col}

${error?.stack || ""}`);
    return false;
  };
  window.onunhandledrejection = (event) => {
    if (event.reason && event.reason.constructor?.name === "Error" && Object.keys(event.reason).length === 0) {
      event.preventDefault();
      return;
    }
    console.error("[Effuse] Unhandled rejection:", event.reason);
    showError(`Unhandled Promise rejection:

${event.reason?.stack || event.reason}`);
  };
  var createEffuseLayer = () => {
    const socketClient = getSocketClient();
    return exports_Layer.mergeAll(DomServiceLive, StateServiceLive, SocketServiceFromClient(socketClient));
  };
  var mountAllWidgets = exports_Effect.gen(function* () {
    console.log("[Effuse] Mounting TB Command Center...");
    if (window.bunLog) {
      window.bunLog("[Effuse] ========== MOUNTING TBCC WIDGETS ==========");
    }
    const shellWidget = yield* mountWidgetById(TBCCShellWidget, "tbcc-shell-widget").pipe(exports_Effect.tap(() => console.log("[Effuse] Shell mounted")), exports_Effect.catchAll((e) => {
      console.error("[Effuse] Failed to mount Shell widget:", e);
      return exports_Effect.die(e);
    }));
    const dashboardWidget = yield* mountWidgetById(TBCCDashboardWidget, "tbcc-tab-dashboard");
    const taskBrowserWidget = yield* mountWidgetById(TBCCTaskBrowserWidget, "tbcc-tab-tasks");
    const runBrowserWidget = yield* mountWidgetById(TBCCRunBrowserWidget, "tbcc-tab-runs");
    const testGenWidget = yield* mountWidgetById(TBTestGenWidget, "tbcc-tab-testgen");
    const settingsWidget = yield* mountWidgetById(TBCCSettingsWidget, "tbcc-tab-settings");
    let outputContainer = document.getElementById("tb-output-widget");
    if (!outputContainer) {
      outputContainer = document.createElement("div");
      outputContainer.id = "tb-output-widget";
      document.body.appendChild(outputContainer);
    }
    const tbOutputWidget = yield* mountWidgetById(TBOutputWidget, "tb-output-widget");
    console.log("[Effuse] Child widgets mounted");
    yield* exports_Stream.runForEach(dashboardWidget.events, (event) => exports_Effect.gen(function* () {
      if (event.type === "viewRun") {
        yield* shellWidget.emit({ type: "changeTab", tab: "runs" });
        yield* runBrowserWidget.emit({ type: "selectRun", runId: event.runId, source: "local" });
      }
    })).pipe(exports_Effect.forkScoped);
    console.log("[Effuse] TB Command Center ready");
  });
  var initEffuse = () => {
    console.log("[Effuse] Creating layer...");
    if (window.bunLog) {
      window.bunLog("[Effuse] ========== INIT EFFUSE CALLED ==========");
    }
    const socketClient = getSocketClient();
    socketClient.onMessage((message) => {
      if (message.type === "dev_reload") {
        console.log("[Effuse] HMR: Reload triggered by", message.changedFile);
        if (window.bunLog) {
          window.bunLog(`[Effuse] HMR: Reloading due to ${message.changedFile}`);
        }
        location.reload();
      }
    });
    console.log("[Effuse] HMR handler registered");
    let layer;
    try {
      layer = createEffuseLayer();
      console.log("[Effuse] Layer created");
    } catch (e) {
      console.error("[Effuse] Failed to create layer:", e);
      return;
    }
    const program = exports_Effect.gen(function* () {
      yield* mountAllWidgets;
      console.log("[Effuse] Widgets mounted, keeping scope alive...");
      yield* exports_Effect.never;
    });
    console.log("[Effuse] Starting Effect runtime...");
    exports_Effect.runFork(program.pipe(exports_Effect.provide(layer), exports_Effect.scoped, exports_Effect.catchAllDefect((defect) => {
      console.error("[Effuse] Defect caught:", defect);
      console.error("[Effuse] Defect type:", typeof defect);
      console.error("[Effuse] Defect constructor:", defect?.constructor?.name);
      if (defect instanceof Error) {
        console.error("[Effuse] Error message:", defect.message);
        console.error("[Effuse] Error stack:", defect.stack);
      }
      try {
        console.error("[Effuse] Defect stringified:", JSON.stringify(defect, null, 2));
      } catch {
        console.error("[Effuse] Could not stringify defect");
      }
      return exports_Effect.void;
    })));
    console.log("[Effuse] Mainview initialized");
  };
  if (window.bunLog) {
    window.bunLog(`[Effuse] document.readyState = ${document.readyState}`);
  }
  if (document.readyState === "loading") {
    if (window.bunLog) {
      window.bunLog("[Effuse] Waiting for DOMContentLoaded...");
    }
    document.addEventListener("DOMContentLoaded", () => {
      if (window.bunLog) {
        window.bunLog("[Effuse] DOMContentLoaded fired!");
      }
      try {
        initEffuse();
      } catch (e) {
        console.error("[Effuse] Init error:", e);
        if (window.bunLog) {
          window.bunLog(`[Effuse] Init error: ${e}`);
        }
      }
    });
  } else {
    if (window.bunLog) {
      window.bunLog("[Effuse] DOM already ready, initializing immediately");
    }
    try {
      initEffuse();
    } catch (e) {
      console.error("[Effuse] Init error:", e);
      if (window.bunLog) {
        window.bunLog(`[Effuse] Init error: ${e}`);
      }
    }
  }
})();
