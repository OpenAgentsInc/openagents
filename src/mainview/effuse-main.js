(() => {
  var __create = Object.create;
  var __getProtoOf = Object.getPrototypeOf;
  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __toESM = (mod, isNodeMode, target) => {
    target = mod != null ? __create(__getProtoOf(mod)) : {};
    const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
    for (let key of __getOwnPropNames(mod))
      if (!__hasOwnProp.call(to, key))
        __defProp(to, key, {
          get: () => mod[key],
          enumerable: true
        });
    return to;
  };
  var __moduleCache = /* @__PURE__ */ new WeakMap;
  var __toCommonJS = (from) => {
    var entry = __moduleCache.get(from), desc;
    if (entry)
      return entry;
    entry = __defProp({}, "__esModule", { value: true });
    if (from && typeof from === "object" || typeof from === "function")
      __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
        get: () => from[key],
        enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
      }));
    __moduleCache.set(from, entry);
    return entry;
  };
  var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, {
        get: all[name],
        enumerable: true,
        configurable: true,
        set: (newValue) => all[name] = () => newValue
      });
  };
  var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });

  // node:buffer
  var exports_buffer = {};
  __export(exports_buffer, {
    transcode: () => transcode,
    resolveObjectURL: () => resolveObjectURL,
    kStringMaxLength: () => kStringMaxLength,
    kMaxLength: () => kMaxLength,
    isUtf8: () => isUtf8,
    isAscii: () => isAscii,
    default: () => buffer_default,
    constants: () => constants,
    btoa: () => btoa,
    atob: () => atob,
    INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,
    File: () => File2,
    Buffer: () => Buffer2,
    Blob: () => Blob2
  });
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function _byteLength(validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp, lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1], arr = new Uint8Array(_byteLength(validLen, placeHoldersLen)), curByte = 0, len2 = placeHoldersLen > 0 ? validLen - 4 : validLen, i2;
    for (i2 = 0;i2 < len2; i2 += 4)
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)], arr[curByte++] = tmp >> 16 & 255, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255;
    if (placeHoldersLen === 2)
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4, arr[curByte++] = tmp & 255;
    if (placeHoldersLen === 1)
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = tmp & 255;
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start4, end6) {
    var tmp, output = [];
    for (var i2 = start4;i2 < end6; i2 += 3)
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255), output.push(tripletToBase64(tmp));
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp, len2 = uint8.length, extraBytes = len2 % 3, parts2 = [], maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes;i2 < len22; i2 += maxChunkLength)
      parts2.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    if (extraBytes === 1)
      tmp = uint8[len2 - 1], parts2.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    else if (extraBytes === 2)
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1], parts2.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    return parts2.join("");
  }
  function read2(buffer4, offset, isLE, mLen, nBytes) {
    var e, m, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i2 = isLE ? nBytes - 1 : 0, d = isLE ? -1 : 1, s = buffer4[offset + i2];
    i2 += d, e = s & (1 << -nBits) - 1, s >>= -nBits, nBits += eLen;
    for (;nBits > 0; e = e * 256 + buffer4[offset + i2], i2 += d, nBits -= 8)
      ;
    m = e & (1 << -nBits) - 1, e >>= -nBits, nBits += mLen;
    for (;nBits > 0; m = m * 256 + buffer4[offset + i2], i2 += d, nBits -= 8)
      ;
    if (e === 0)
      e = 1 - eBias;
    else if (e === eMax)
      return m ? NaN : (s ? -1 : 1) * (1 / 0);
    else
      m = m + Math.pow(2, mLen), e = e - eBias;
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  }
  function write3(buffer4, value, offset, isLE, mLen, nBytes) {
    var e, m, c, eLen = nBytes * 8 - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i2 = isLE ? 0 : nBytes - 1, d = isLE ? 1 : -1, s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    if (value = Math.abs(value), isNaN(value) || value === 1 / 0)
      m = isNaN(value) ? 1 : 0, e = eMax;
    else {
      if (e = Math.floor(Math.log(value) / Math.LN2), value * (c = Math.pow(2, -e)) < 1)
        e--, c *= 2;
      if (e + eBias >= 1)
        value += rt / c;
      else
        value += rt * Math.pow(2, 1 - eBias);
      if (value * c >= 2)
        e++, c /= 2;
      if (e + eBias >= eMax)
        m = 0, e = eMax;
      else if (e + eBias >= 1)
        m = (value * c - 1) * Math.pow(2, mLen), e = e + eBias;
      else
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen), e = 0;
    }
    for (;mLen >= 8; buffer4[offset + i2] = m & 255, i2 += d, m /= 256, mLen -= 8)
      ;
    e = e << mLen | m, eLen += mLen;
    for (;eLen > 0; buffer4[offset + i2] = e & 255, i2 += d, e /= 256, eLen -= 8)
      ;
    buffer4[offset + i2 - d] |= s * 128;
  }
  function createBuffer(length3) {
    if (length3 > kMaxLength)
      throw new RangeError('The value "' + length3 + '" is invalid for option "size"');
    let buf = new Uint8Array(length3);
    return Object.setPrototypeOf(buf, Buffer2.prototype), buf;
  }
  function E(sym, getMessage2, Base3) {
    return class NodeError extends Base3 {
      constructor() {
        super();
        Object.defineProperty(this, "message", { value: getMessage2.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${sym}]`, this.stack, delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", { configurable: true, enumerable: true, value, writable: true });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  function Buffer2(arg, encodingOrOffset, length3) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length3);
  }
  function from(value, encodingOrOffset, length3) {
    if (typeof value === "string")
      return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value))
      return fromArrayView(value);
    if (value == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer))
      return fromArrayBuffer(value, encodingOrOffset, length3);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer)))
      return fromArrayBuffer(value, encodingOrOffset, length3);
    if (typeof value === "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    let valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value)
      return Buffer2.from(valueOf, encodingOrOffset, length3);
    let b = fromObject(value);
    if (b)
      return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function")
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length3);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  function assertSize(size13) {
    if (typeof size13 !== "number")
      throw new TypeError('"size" argument must be of type number');
    else if (size13 < 0)
      throw new RangeError('The value "' + size13 + '" is invalid for option "size"');
  }
  function alloc(size13, fill, encoding) {
    if (assertSize(size13), size13 <= 0)
      return createBuffer(size13);
    if (fill !== undefined)
      return typeof encoding === "string" ? createBuffer(size13).fill(fill, encoding) : createBuffer(size13).fill(fill);
    return createBuffer(size13);
  }
  function allocUnsafe(size13) {
    return assertSize(size13), createBuffer(size13 < 0 ? 0 : checked(size13) | 0);
  }
  function fromString(string3, encoding) {
    if (typeof encoding !== "string" || encoding === "")
      encoding = "utf8";
    if (!Buffer2.isEncoding(encoding))
      throw new TypeError("Unknown encoding: " + encoding);
    let length3 = byteLength(string3, encoding) | 0, buf = createBuffer(length3), actual = buf.write(string3, encoding);
    if (actual !== length3)
      buf = buf.slice(0, actual);
    return buf;
  }
  function fromArrayLike(array4) {
    let length3 = array4.length < 0 ? 0 : checked(array4.length) | 0, buf = createBuffer(length3);
    for (let i2 = 0;i2 < length3; i2 += 1)
      buf[i2] = array4[i2] & 255;
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      let copy4 = new Uint8Array(arrayView);
      return fromArrayBuffer(copy4.buffer, copy4.byteOffset, copy4.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array4, byteOffset, length3) {
    if (byteOffset < 0 || array4.byteLength < byteOffset)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (array4.byteLength < byteOffset + (length3 || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length3 === undefined)
      buf = new Uint8Array(array4);
    else if (length3 === undefined)
      buf = new Uint8Array(array4, byteOffset);
    else
      buf = new Uint8Array(array4, byteOffset, length3);
    return Object.setPrototypeOf(buf, Buffer2.prototype), buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      let len2 = checked(obj.length) | 0, buf = createBuffer(len2);
      if (buf.length === 0)
        return buf;
      return obj.copy(buf, 0, 0, len2), buf;
    }
    if (obj.length !== undefined) {
      if (typeof obj.length !== "number" || Number.isNaN(obj.length))
        return createBuffer(0);
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data))
      return fromArrayLike(obj.data);
  }
  function checked(length3) {
    if (length3 >= kMaxLength)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength.toString(16) + " bytes");
    return length3 | 0;
  }
  function byteLength(string3, encoding) {
    if (Buffer2.isBuffer(string3))
      return string3.length;
    if (ArrayBuffer.isView(string3) || isInstance(string3, ArrayBuffer))
      return string3.byteLength;
    if (typeof string3 !== "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string3);
    let len2 = string3.length, mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    let loweredCase = false;
    for (;; )
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string3).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string3).length;
        default:
          if (loweredCase)
            return mustMatch ? -1 : utf8ToBytes(string3).length;
          encoding = ("" + encoding).toLowerCase(), loweredCase = true;
      }
  }
  function slowToString(encoding, start4, end6) {
    let loweredCase = false;
    if (start4 === undefined || start4 < 0)
      start4 = 0;
    if (start4 > this.length)
      return "";
    if (end6 === undefined || end6 > this.length)
      end6 = this.length;
    if (end6 <= 0)
      return "";
    if (end6 >>>= 0, start4 >>>= 0, end6 <= start4)
      return "";
    if (!encoding)
      encoding = "utf8";
    while (true)
      switch (encoding) {
        case "hex":
          return hexSlice(this, start4, end6);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start4, end6);
        case "ascii":
          return asciiSlice(this, start4, end6);
        case "latin1":
        case "binary":
          return latin1Slice(this, start4, end6);
        case "base64":
          return base64Slice(this, start4, end6);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start4, end6);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase(), loweredCase = true;
      }
  }
  function swap2(b, n, m) {
    let i2 = b[n];
    b[n] = b[m], b[m] = i2;
  }
  function bidirectionalIndexOf(buffer4, val, byteOffset, encoding, dir) {
    if (buffer4.length === 0)
      return -1;
    if (typeof byteOffset === "string")
      encoding = byteOffset, byteOffset = 0;
    else if (byteOffset > 2147483647)
      byteOffset = 2147483647;
    else if (byteOffset < -2147483648)
      byteOffset = -2147483648;
    if (byteOffset = +byteOffset, Number.isNaN(byteOffset))
      byteOffset = dir ? 0 : buffer4.length - 1;
    if (byteOffset < 0)
      byteOffset = buffer4.length + byteOffset;
    if (byteOffset >= buffer4.length)
      if (dir)
        return -1;
      else
        byteOffset = buffer4.length - 1;
    else if (byteOffset < 0)
      if (dir)
        byteOffset = 0;
      else
        return -1;
    if (typeof val === "string")
      val = Buffer2.from(val, encoding);
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0)
        return -1;
      return arrayIndexOf(buffer4, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      if (val = val & 255, typeof Uint8Array.prototype.indexOf === "function")
        if (dir)
          return Uint8Array.prototype.indexOf.call(buffer4, val, byteOffset);
        else
          return Uint8Array.prototype.lastIndexOf.call(buffer4, val, byteOffset);
      return arrayIndexOf(buffer4, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1, arrLength = arr.length, valLength = val.length;
    if (encoding !== undefined) {
      if (encoding = String(encoding).toLowerCase(), encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2)
          return -1;
        indexSize = 2, arrLength /= 2, valLength /= 2, byteOffset /= 2;
      }
    }
    function read22(buf, i3) {
      if (indexSize === 1)
        return buf[i3];
      else
        return buf.readUInt16BE(i3 * indexSize);
    }
    let i2;
    if (dir) {
      let foundIndex = -1;
      for (i2 = byteOffset;i2 < arrLength; i2++)
        if (read22(arr, i2) === read22(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset;i2 >= 0; i2--) {
        let found = true;
        for (let j = 0;j < valLength; j++)
          if (read22(arr, i2 + j) !== read22(val, j)) {
            found = false;
            break;
          }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  function hexWrite(buf, string3, offset, length3) {
    offset = Number(offset) || 0;
    let remaining = buf.length - offset;
    if (!length3)
      length3 = remaining;
    else if (length3 = Number(length3), length3 > remaining)
      length3 = remaining;
    let strLen = string3.length;
    if (length3 > strLen / 2)
      length3 = strLen / 2;
    let i2;
    for (i2 = 0;i2 < length3; ++i2) {
      let parsed = parseInt(string3.substr(i2 * 2, 2), 16);
      if (Number.isNaN(parsed))
        return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string3, offset, length3) {
    return blitBuffer(utf8ToBytes(string3, buf.length - offset), buf, offset, length3);
  }
  function asciiWrite(buf, string3, offset, length3) {
    return blitBuffer(asciiToBytes(string3), buf, offset, length3);
  }
  function base64Write(buf, string3, offset, length3) {
    return blitBuffer(base64ToBytes(string3), buf, offset, length3);
  }
  function ucs2Write(buf, string3, offset, length3) {
    return blitBuffer(utf16leToBytes(string3, buf.length - offset), buf, offset, length3);
  }
  function base64Slice(buf, start4, end6) {
    if (start4 === 0 && end6 === buf.length)
      return fromByteArray(buf);
    else
      return fromByteArray(buf.slice(start4, end6));
  }
  function utf8Slice(buf, start4, end6) {
    end6 = Math.min(buf.length, end6);
    let res = [], i2 = start4;
    while (i2 < end6) {
      let firstByte = buf[i2], codePoint = null, bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end6) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128)
              codePoint = firstByte;
            break;
          case 2:
            if (secondByte = buf[i2 + 1], (secondByte & 192) === 128) {
              if (tempCodePoint = (firstByte & 31) << 6 | secondByte & 63, tempCodePoint > 127)
                codePoint = tempCodePoint;
            }
            break;
          case 3:
            if (secondByte = buf[i2 + 1], thirdByte = buf[i2 + 2], (secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              if (tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63, tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343))
                codePoint = tempCodePoint;
            }
            break;
          case 4:
            if (secondByte = buf[i2 + 1], thirdByte = buf[i2 + 2], fourthByte = buf[i2 + 3], (secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              if (tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63, tempCodePoint > 65535 && tempCodePoint < 1114112)
                codePoint = tempCodePoint;
            }
        }
      }
      if (codePoint === null)
        codePoint = 65533, bytesPerSequence = 1;
      else if (codePoint > 65535)
        codePoint -= 65536, res.push(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | codePoint & 1023;
      res.push(codePoint), i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  function decodeCodePointsArray(codePoints) {
    let len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH)
      return String.fromCharCode.apply(String, codePoints);
    let res = "", i2 = 0;
    while (i2 < len2)
      res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
    return res;
  }
  function asciiSlice(buf, start4, end6) {
    let ret = "";
    end6 = Math.min(buf.length, end6);
    for (let i2 = start4;i2 < end6; ++i2)
      ret += String.fromCharCode(buf[i2] & 127);
    return ret;
  }
  function latin1Slice(buf, start4, end6) {
    let ret = "";
    end6 = Math.min(buf.length, end6);
    for (let i2 = start4;i2 < end6; ++i2)
      ret += String.fromCharCode(buf[i2]);
    return ret;
  }
  function hexSlice(buf, start4, end6) {
    let len2 = buf.length;
    if (!start4 || start4 < 0)
      start4 = 0;
    if (!end6 || end6 < 0 || end6 > len2)
      end6 = len2;
    let out = "";
    for (let i2 = start4;i2 < end6; ++i2)
      out += hexSliceLookupTable[buf[i2]];
    return out;
  }
  function utf16leSlice(buf, start4, end6) {
    let bytes = buf.slice(start4, end6), res = "";
    for (let i2 = 0;i2 < bytes.length - 1; i2 += 2)
      res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
    return res;
  }
  function checkOffset(offset, ext, length3) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length3)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function checkInt(buf, value, offset, ext, max5, min3) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max5 || value < min3)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  function wrtBigUInt64LE(buf, value, offset, min3, max5) {
    checkIntBI(value, min3, max5, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo, lo = lo >> 8, buf[offset++] = lo, lo = lo >> 8, buf[offset++] = lo, lo = lo >> 8, buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    return buf[offset++] = hi, hi = hi >> 8, buf[offset++] = hi, hi = hi >> 8, buf[offset++] = hi, hi = hi >> 8, buf[offset++] = hi, offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min3, max5) {
    checkIntBI(value, min3, max5, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo, lo = lo >> 8, buf[offset + 6] = lo, lo = lo >> 8, buf[offset + 5] = lo, lo = lo >> 8, buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    return buf[offset + 3] = hi, hi = hi >> 8, buf[offset + 2] = hi, hi = hi >> 8, buf[offset + 1] = hi, hi = hi >> 8, buf[offset] = hi, offset + 8;
  }
  function checkIEEE754(buf, value, offset, ext, max5, min3) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkIEEE754(buf, value, offset, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000);
    return write3(buf, value, offset, littleEndian, 23, 4), offset + 4;
  }
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (value = +value, offset = offset >>> 0, !noAssert)
      checkIEEE754(buf, value, offset, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    return write3(buf, value, offset, littleEndian, 52, 8), offset + 8;
  }
  function addNumericalSeparator(val) {
    let res = "", i2 = val.length, start4 = val[0] === "-" ? 1 : 0;
    for (;i2 >= start4 + 4; i2 -= 3)
      res = `_${val.slice(i2 - 3, i2)}${res}`;
    return `${val.slice(0, i2)}${res}`;
  }
  function checkBounds(buf, offset, byteLength2) {
    if (validateNumber(offset, "offset"), buf[offset] === undefined || buf[offset + byteLength2] === undefined)
      boundsError(offset, buf.length - (byteLength2 + 1));
  }
  function checkIntBI(value, min3, max5, buf, offset, byteLength2) {
    if (value > max5 || value < min3) {
      let n = typeof min3 === "bigint" ? "n" : "", range4;
      if (byteLength2 > 3)
        if (min3 === 0 || min3 === BigInt(0))
          range4 = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
        else
          range4 = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
      else
        range4 = `>= ${min3}${n} and <= ${max5}${n}`;
      throw new ERR_OUT_OF_RANGE("value", range4, value);
    }
    checkBounds(buf, offset, byteLength2);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number")
      throw new ERR_INVALID_ARG_TYPE(name, "number", value);
  }
  function boundsError(value, length3, type) {
    if (Math.floor(value) !== value)
      throw validateNumber(value, type), new ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    if (length3 < 0)
      throw new ERR_BUFFER_OUT_OF_BOUNDS;
    throw new ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length3}`, value);
  }
  function base64clean(str) {
    if (str = str.split("=")[0], str = str.trim().replace(INVALID_BASE64_RE, ""), str.length < 2)
      return "";
    while (str.length % 4 !== 0)
      str = str + "=";
    return str;
  }
  function utf8ToBytes(string3, units) {
    units = units || 1 / 0;
    let codePoint, length3 = string3.length, leadSurrogate = null, bytes = [];
    for (let i2 = 0;i2 < length3; ++i2) {
      if (codePoint = string3.charCodeAt(i2), codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length3) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      if (leadSurrogate = null, codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else
        throw new Error("Invalid code point");
    }
    return bytes;
  }
  function asciiToBytes(str) {
    let byteArray = [];
    for (let i2 = 0;i2 < str.length; ++i2)
      byteArray.push(str.charCodeAt(i2) & 255);
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi, lo, byteArray = [];
    for (let i2 = 0;i2 < str.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i2), hi = c >> 8, lo = c % 256, byteArray.push(lo), byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length3) {
    let i2;
    for (i2 = 0;i2 < length3; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src.length)
        break;
      dst[i2 + offset] = src[i2];
    }
    return i2;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function defineBigIntMethod(fn2) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
  function notimpl(name) {
    return () => {
      throw new Error(name + " is not implemented for node:buffer browser polyfill");
    };
  }
  var lookup, revLookup, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i, len, customInspectSymbol, INSPECT_MAX_BYTES = 50, kMaxLength = 2147483647, kStringMaxLength = 536870888, btoa, atob, File2, Blob2, constants, ERR_BUFFER_OUT_OF_BOUNDS, ERR_INVALID_ARG_TYPE, ERR_OUT_OF_RANGE, MAX_ARGUMENTS_LENGTH = 4096, INVALID_BASE64_RE, hexSliceLookupTable, resolveObjectURL, isUtf8, isAscii = (str) => {
    for (let char of str)
      if (char.charCodeAt(0) > 127)
        return false;
    return true;
  }, transcode, buffer_default;
  var init_buffer = __esm(() => {
    lookup = [];
    revLookup = [];
    for (i = 0, len = code.length;i < len; ++i)
      lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i;
    revLookup[45] = 62;
    revLookup[95] = 63;
    customInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    btoa = globalThis.btoa;
    atob = globalThis.atob;
    File2 = globalThis.File;
    Blob2 = globalThis.Blob;
    constants = { MAX_LENGTH: kMaxLength, MAX_STRING_LENGTH: kStringMaxLength };
    ERR_BUFFER_OUT_OF_BOUNDS = E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
      if (name)
        return `${name} is outside of buffer bounds`;
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    ERR_INVALID_ARG_TYPE = E("ERR_INVALID_ARG_TYPE", function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    ERR_OUT_OF_RANGE = E("ERR_OUT_OF_RANGE", function(str, range4, input) {
      let msg = `The value of "${str}" is out of range.`, received = input;
      if (Number.isInteger(input) && Math.abs(input) > 4294967296)
        received = addNumericalSeparator(String(input));
      else if (typeof input === "bigint") {
        if (received = String(input), input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32)))
          received = addNumericalSeparator(received);
        received += "n";
      }
      return msg += ` It must be ${range4}. Received ${received}`, msg;
    }, RangeError);
    Object.defineProperty(Buffer2.prototype, "parent", { enumerable: true, get: function() {
      if (!Buffer2.isBuffer(this))
        return;
      return this.buffer;
    } });
    Object.defineProperty(Buffer2.prototype, "offset", { enumerable: true, get: function() {
      if (!Buffer2.isBuffer(this))
        return;
      return this.byteOffset;
    } });
    Buffer2.poolSize = 8192;
    Buffer2.from = function(value, encodingOrOffset, length3) {
      return from(value, encodingOrOffset, length3);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    Buffer2.alloc = function(size13, fill, encoding) {
      return alloc(size13, fill, encoding);
    };
    Buffer2.allocUnsafe = function(size13) {
      return allocUnsafe(size13);
    };
    Buffer2.allocUnsafeSlow = function(size13) {
      return allocUnsafe(size13);
    };
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare2(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (a === b)
        return 0;
      let x = a.length, y = b.length;
      for (let i2 = 0, len2 = Math.min(x, y);i2 < len2; ++i2)
        if (a[i2] !== b[i2]) {
          x = a[i2], y = b[i2];
          break;
        }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat4(list, length3) {
      if (!Array.isArray(list))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (list.length === 0)
        return Buffer2.alloc(0);
      let i2;
      if (length3 === undefined) {
        length3 = 0;
        for (i2 = 0;i2 < list.length; ++i2)
          length3 += list[i2].length;
      }
      let buffer4 = Buffer2.allocUnsafe(length3), pos = 0;
      for (i2 = 0;i2 < list.length; ++i2) {
        let buf = list[i2];
        if (isInstance(buf, Uint8Array))
          if (pos + buf.length > buffer4.length) {
            if (!Buffer2.isBuffer(buf))
              buf = Buffer2.from(buf);
            buf.copy(buffer4, pos);
          } else
            Uint8Array.prototype.set.call(buffer4, buf, pos);
        else if (!Buffer2.isBuffer(buf))
          throw new TypeError('"list" argument must be an Array of Buffers');
        else
          buf.copy(buffer4, pos);
        pos += buf.length;
      }
      return buffer4;
    };
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = true;
    Buffer2.prototype.swap16 = function swap16() {
      let len2 = this.length;
      if (len2 % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let i2 = 0;i2 < len2; i2 += 2)
        swap2(this, i2, i2 + 1);
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      let len2 = this.length;
      if (len2 % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let i2 = 0;i2 < len2; i2 += 4)
        swap2(this, i2, i2 + 3), swap2(this, i2 + 1, i2 + 2);
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      let len2 = this.length;
      if (len2 % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let i2 = 0;i2 < len2; i2 += 8)
        swap2(this, i2, i2 + 7), swap2(this, i2 + 1, i2 + 6), swap2(this, i2 + 2, i2 + 5), swap2(this, i2 + 3, i2 + 4);
      return this;
    };
    Buffer2.prototype.toString = function toString2() {
      let length3 = this.length;
      if (length3 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length3);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals3(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "", max5 = INSPECT_MAX_BYTES;
      if (str = this.toString("hex", 0, max5).replace(/(.{2})/g, "$1 ").trim(), this.length > max5)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol)
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    Buffer2.prototype.compare = function compare22(target, start4, end6, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array))
        target = Buffer2.from(target, target.offset, target.byteLength);
      if (!Buffer2.isBuffer(target))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      if (start4 === undefined)
        start4 = 0;
      if (end6 === undefined)
        end6 = target ? target.length : 0;
      if (thisStart === undefined)
        thisStart = 0;
      if (thisEnd === undefined)
        thisEnd = this.length;
      if (start4 < 0 || end6 > target.length || thisStart < 0 || thisEnd > this.length)
        throw new RangeError("out of range index");
      if (thisStart >= thisEnd && start4 >= end6)
        return 0;
      if (thisStart >= thisEnd)
        return -1;
      if (start4 >= end6)
        return 1;
      if (start4 >>>= 0, end6 >>>= 0, thisStart >>>= 0, thisEnd >>>= 0, this === target)
        return 0;
      let x = thisEnd - thisStart, y = end6 - start4, len2 = Math.min(x, y), thisCopy = this.slice(thisStart, thisEnd), targetCopy = target.slice(start4, end6);
      for (let i2 = 0;i2 < len2; ++i2)
        if (thisCopy[i2] !== targetCopy[i2]) {
          x = thisCopy[i2], y = targetCopy[i2];
          break;
        }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    Buffer2.prototype.write = function write22(string3, offset, length3, encoding) {
      if (offset === undefined)
        encoding = "utf8", length3 = this.length, offset = 0;
      else if (length3 === undefined && typeof offset === "string")
        encoding = offset, length3 = this.length, offset = 0;
      else if (isFinite(offset))
        if (offset = offset >>> 0, isFinite(length3)) {
          if (length3 = length3 >>> 0, encoding === undefined)
            encoding = "utf8";
        } else
          encoding = length3, length3 = undefined;
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let remaining = this.length - offset;
      if (length3 === undefined || length3 > remaining)
        length3 = remaining;
      if (string3.length > 0 && (length3 < 0 || offset < 0) || offset > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (;; )
        switch (encoding) {
          case "hex":
            return hexWrite(this, string3, offset, length3);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string3, offset, length3);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string3, offset, length3);
          case "base64":
            return base64Write(this, string3, offset, length3);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string3, offset, length3);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase(), loweredCase = true;
        }
    };
    Buffer2.prototype.toJSON = function toJSON2() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    Buffer2.prototype.slice = function slice(start4, end6) {
      let len2 = this.length;
      if (start4 = ~~start4, end6 = end6 === undefined ? len2 : ~~end6, start4 < 0) {
        if (start4 += len2, start4 < 0)
          start4 = 0;
      } else if (start4 > len2)
        start4 = len2;
      if (end6 < 0) {
        if (end6 += len2, end6 < 0)
          end6 = 0;
      } else if (end6 > len2)
        end6 = len2;
      if (end6 < start4)
        end6 = start4;
      let newBuf = this.subarray(start4, end6);
      return Object.setPrototypeOf(newBuf, Buffer2.prototype), newBuf;
    };
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset], mul = 1, i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256))
        val += this[offset + i2] * mul;
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset + --byteLength2], mul = 1;
      while (byteLength2 > 0 && (mul *= 256))
        val += this[offset + --byteLength2] * mul;
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (offset = offset >>> 0, !noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (offset = offset >>> 0, !noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (offset = offset >>> 0, !noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (offset = offset >>> 0, !noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (offset = offset >>> 0, !noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0, validateNumber(offset, "offset");
      let first = this[offset], last4 = this[offset + 7];
      if (first === undefined || last4 === undefined)
        boundsError(offset, this.length - 8);
      let lo = first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 16777216, hi = this[++offset] + this[++offset] * 256 + this[++offset] * 65536 + last4 * 16777216;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0, validateNumber(offset, "offset");
      let first = this[offset], last4 = this[offset + 7];
      if (first === undefined || last4 === undefined)
        boundsError(offset, this.length - 8);
      let hi = first * 16777216 + this[++offset] * 65536 + this[++offset] * 256 + this[++offset], lo = this[++offset] * 16777216 + this[++offset] * 65536 + this[++offset] * 256 + last4;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset], mul = 1, i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256))
        val += this[offset + i2] * mul;
      if (mul *= 128, val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      if (offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i2 = byteLength2, mul = 1, val = this[offset + --i2];
      while (i2 > 0 && (mul *= 256))
        val += this[offset + --i2] * mul;
      if (mul *= 128, val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (offset = offset >>> 0, !noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (offset = offset >>> 0, !noAssert)
        checkOffset(offset, 2, this.length);
      let val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (offset = offset >>> 0, !noAssert)
        checkOffset(offset, 2, this.length);
      let val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (offset = offset >>> 0, !noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (offset = offset >>> 0, !noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0, validateNumber(offset, "offset");
      let first = this[offset], last4 = this[offset + 7];
      if (first === undefined || last4 === undefined)
        boundsError(offset, this.length - 8);
      let val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 65536 + (last4 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 16777216);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0, validateNumber(offset, "offset");
      let first = this[offset], last4 = this[offset + 7];
      if (first === undefined || last4 === undefined)
        boundsError(offset, this.length - 8);
      let val = (first << 24) + this[++offset] * 65536 + this[++offset] * 256 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 16777216 + this[++offset] * 65536 + this[++offset] * 256 + last4);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (offset = offset >>> 0, !noAssert)
        checkOffset(offset, 4, this.length);
      return read2(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (offset = offset >>> 0, !noAssert)
        checkOffset(offset, 4, this.length);
      return read2(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (offset = offset >>> 0, !noAssert)
        checkOffset(offset, 8, this.length);
      return read2(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (offset = offset >>> 0, !noAssert)
        checkOffset(offset, 8, this.length);
      return read2(this, offset, false, 52, 8);
    };
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      if (value = +value, offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert) {
        let maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1, i2 = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256))
        this[offset + i2] = value / mul & 255;
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      if (value = +value, offset = offset >>> 0, byteLength2 = byteLength2 >>> 0, !noAssert) {
        let maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i2 = byteLength2 - 1, mul = 1;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256))
        this[offset + i2] = value / mul & 255;
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      if (value = +value, offset = offset >>> 0, !noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      return this[offset] = value & 255, offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      if (value = +value, offset = offset >>> 0, !noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      return this[offset] = value & 255, this[offset + 1] = value >>> 8, offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      if (value = +value, offset = offset >>> 0, !noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      return this[offset] = value >>> 8, this[offset + 1] = value & 255, offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      if (value = +value, offset = offset >>> 0, !noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      return this[offset + 3] = value >>> 24, this[offset + 2] = value >>> 16, this[offset + 1] = value >>> 8, this[offset] = value & 255, offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      if (value = +value, offset = offset >>> 0, !noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      return this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = value & 255, offset + 4;
    };
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      if (value = +value, offset = offset >>> 0, !noAssert) {
        let limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i2 = 0, mul = 1, sub = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0)
          sub = 1;
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      if (value = +value, offset = offset >>> 0, !noAssert) {
        let limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i2 = byteLength2 - 1, mul = 1, sub = 0;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0)
          sub = 1;
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      if (value = +value, offset = offset >>> 0, !noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      return this[offset] = value & 255, offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      if (value = +value, offset = offset >>> 0, !noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      return this[offset] = value & 255, this[offset + 1] = value >>> 8, offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      if (value = +value, offset = offset >>> 0, !noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      return this[offset] = value >>> 8, this[offset + 1] = value & 255, offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      if (value = +value, offset = offset >>> 0, !noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      return this[offset] = value & 255, this[offset + 1] = value >>> 8, this[offset + 2] = value >>> 16, this[offset + 3] = value >>> 24, offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      if (value = +value, offset = offset >>> 0, !noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      return this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = value & 255, offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy4(target, targetStart, start4, end6) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start4)
        start4 = 0;
      if (!end6 && end6 !== 0)
        end6 = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end6 > 0 && end6 < start4)
        end6 = start4;
      if (end6 === start4)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0)
        throw new RangeError("targetStart out of bounds");
      if (start4 < 0 || start4 >= this.length)
        throw new RangeError("Index out of range");
      if (end6 < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end6 > this.length)
        end6 = this.length;
      if (target.length - targetStart < end6 - start4)
        end6 = target.length - targetStart + start4;
      let len2 = end6 - start4;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function")
        this.copyWithin(targetStart, start4, end6);
      else
        Uint8Array.prototype.set.call(target, this.subarray(start4, end6), targetStart);
      return len2;
    };
    Buffer2.prototype.fill = function fill(val, start4, end6, encoding) {
      if (typeof val === "string") {
        if (typeof start4 === "string")
          encoding = start4, start4 = 0, end6 = this.length;
        else if (typeof end6 === "string")
          encoding = end6, end6 = this.length;
        if (encoding !== undefined && typeof encoding !== "string")
          throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding))
          throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
          let code2 = val.charCodeAt(0);
          if (encoding === "utf8" && code2 < 128 || encoding === "latin1")
            val = code2;
        }
      } else if (typeof val === "number")
        val = val & 255;
      else if (typeof val === "boolean")
        val = Number(val);
      if (start4 < 0 || this.length < start4 || this.length < end6)
        throw new RangeError("Out of range index");
      if (end6 <= start4)
        return this;
      if (start4 = start4 >>> 0, end6 = end6 === undefined ? this.length : end6 >>> 0, !val)
        val = 0;
      let i2;
      if (typeof val === "number")
        for (i2 = start4;i2 < end6; ++i2)
          this[i2] = val;
      else {
        let bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding), len2 = bytes.length;
        if (len2 === 0)
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for (i2 = 0;i2 < end6 - start4; ++i2)
          this[i2 + start4] = bytes[i2 % len2];
      }
      return this;
    };
    INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    hexSliceLookupTable = function() {
      let table = new Array(256);
      for (let i2 = 0;i2 < 16; ++i2) {
        let i16 = i2 * 16;
        for (let j = 0;j < 16; ++j)
          table[i16 + j] = "0123456789abcdef"[i2] + "0123456789abcdef"[j];
      }
      return table;
    }();
    resolveObjectURL = notimpl("resolveObjectURL");
    isUtf8 = notimpl("isUtf8");
    transcode = notimpl("transcode");
    buffer_default = Buffer2;
  });

  // node:events
  var exports_events = {};
  __export(exports_events, {
    setMaxListeners: () => setMaxListeners2,
    once: () => once22,
    listenerCount: () => listenerCount2,
    init: () => EventEmitter,
    getMaxListeners: () => getMaxListeners2,
    getEventListeners: () => getEventListeners,
    default: () => events_default,
    captureRejectionSymbol: () => captureRejectionSymbol,
    addAbortListener: () => addAbortListener,
    EventEmitter: () => EventEmitter
  });
  function emitError(emitter, args2) {
    var { _events: events } = emitter;
    if (args2[0] ??= new Error("Unhandled error."), !events)
      throw args2[0];
    var errorMonitor = events[kErrorMonitor];
    if (errorMonitor)
      for (var handler of ArrayPrototypeSlice.call(errorMonitor))
        handler.apply(emitter, args2);
    var handlers = events.error;
    if (!handlers)
      throw args2[0];
    for (var handler of ArrayPrototypeSlice.call(handlers))
      handler.apply(emitter, args2);
    return true;
  }
  function addCatch(emitter, promise3, type, args2) {
    promise3.then(undefined, function(err) {
      queueMicrotask(() => emitUnhandledRejectionOrErr(emitter, err, type, args2));
    });
  }
  function emitUnhandledRejectionOrErr(emitter, err, type, args2) {
    if (typeof emitter[kRejection] === "function")
      emitter[kRejection](err, type, ...args2);
    else
      try {
        emitter[kCapture] = false, emitter.emit("error", err);
      } finally {
        emitter[kCapture] = true;
      }
  }
  function overflowWarning(emitter, type, handlers) {
    handlers.warned = true;
    let warn = new Error(`Possible EventEmitter memory leak detected. ${handlers.length} ${String(type)} listeners added to [${emitter.constructor.name}]. Use emitter.setMaxListeners() to increase limit`);
    warn.name = "MaxListenersExceededWarning", warn.emitter = emitter, warn.type = type, warn.count = handlers.length, console.warn(warn);
  }
  function onceWrapper(type, listener, ...args2) {
    this.removeListener(type, listener), listener.apply(this, args2);
  }
  function once22(emitter, type, options) {
    var signal = options?.signal;
    if (validateAbortSignal(signal, "options.signal"), signal?.aborted)
      throw new AbortError(undefined, { cause: signal?.reason });
    let { resolve: resolve3, reject, promise: promise3 } = $newPromiseCapability(Promise), errorListener = (err) => {
      if (emitter.removeListener(type, resolver), signal != null)
        eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
      reject(err);
    }, resolver = (...args2) => {
      if (typeof emitter.removeListener === "function")
        emitter.removeListener("error", errorListener);
      if (signal != null)
        eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
      resolve3(args2);
    };
    if (eventTargetAgnosticAddListener(emitter, type, resolver, { once: true }), type !== "error" && typeof emitter.once === "function")
      emitter.once("error", errorListener);
    function abortListener() {
      eventTargetAgnosticRemoveListener(emitter, type, resolver), eventTargetAgnosticRemoveListener(emitter, "error", errorListener), reject(new AbortError(undefined, { cause: signal?.reason }));
    }
    if (signal != null)
      eventTargetAgnosticAddListener(signal, "abort", abortListener, { once: true });
    return promise3;
  }
  function getEventListeners(emitter, type) {
    return emitter.listeners(type);
  }
  function setMaxListeners2(n, ...eventTargets) {
    validateNumber2(n, "setMaxListeners", 0);
    var length3;
    if (eventTargets && (length3 = eventTargets.length))
      for (let i2 = 0;i2 < length3; i2++)
        eventTargets[i2].setMaxListeners(n);
    else
      defaultMaxListeners = n;
  }
  function listenerCount2(emitter, type) {
    return emitter.listenerCount(type);
  }
  function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
    if (typeof emitter.removeListener === "function")
      emitter.removeListener(name, listener);
    else
      emitter.removeEventListener(name, listener, flags);
  }
  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function")
      if (flags.once)
        emitter.once(name, listener);
      else
        emitter.on(name, listener);
    else
      emitter.addEventListener(name, listener, flags);
  }
  function ERR_INVALID_ARG_TYPE2(name, type, value) {
    let err = new TypeError(`The "${name}" argument must be of type ${type}. Received ${value}`);
    return err.code = "ERR_INVALID_ARG_TYPE", err;
  }
  function ERR_OUT_OF_RANGE2(name, range4, value) {
    let err = new RangeError(`The "${name}" argument is out of range. It must be ${range4}. Received ${value}`);
    return err.code = "ERR_OUT_OF_RANGE", err;
  }
  function validateAbortSignal(signal, name) {
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal)))
      throw ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
  }
  function validateNumber2(value, name, min3, max5) {
    if (typeof value !== "number")
      throw ERR_INVALID_ARG_TYPE2(name, "number", value);
    if (min3 != null && value < min3 || max5 != null && value > max5 || (min3 != null || max5 != null) && Number.isNaN(value))
      throw ERR_OUT_OF_RANGE2(name, `${min3 != null ? `>= ${min3}` : ""}${min3 != null && max5 != null ? " && " : ""}${max5 != null ? `<= ${max5}` : ""}`, value);
  }
  function checkListener(listener) {
    if (typeof listener !== "function")
      throw new TypeError("The listener must be a function");
  }
  function validateBoolean(value, name) {
    if (typeof value !== "boolean")
      throw ERR_INVALID_ARG_TYPE2(name, "boolean", value);
  }
  function getMaxListeners2(emitterOrTarget) {
    return emitterOrTarget?._maxListeners ?? defaultMaxListeners;
  }
  function addAbortListener(signal, listener) {
    if (signal === undefined)
      throw ERR_INVALID_ARG_TYPE2("signal", "AbortSignal", signal);
    if (validateAbortSignal(signal, "signal"), typeof listener !== "function")
      throw ERR_INVALID_ARG_TYPE2("listener", "function", listener);
    let removeEventListener;
    if (signal.aborted)
      queueMicrotask(() => listener());
    else
      signal.addEventListener("abort", listener, { __proto__: null, once: true }), removeEventListener = () => {
        signal.removeEventListener("abort", listener);
      };
    return { __proto__: null, [Symbol.dispose]() {
      removeEventListener?.();
    } };
  }
  var SymbolFor, kCapture, kErrorMonitor, kMaxEventTargetListeners, kMaxEventTargetListenersWarned, kRejection, captureRejectionSymbol, ArrayPrototypeSlice, defaultMaxListeners = 10, EventEmitter = function EventEmitter2(opts) {
    if (this._events === undefined || this._events === this.__proto__._events)
      this._events = { __proto__: null }, this._eventsCount = 0;
    if (this._maxListeners ??= undefined, this[kCapture] = opts?.captureRejections ? Boolean(opts?.captureRejections) : EventEmitterPrototype[kCapture])
      this.emit = emitWithRejectionCapture;
  }, EventEmitterPrototype, emitWithoutRejectionCapture = function emit2(type, ...args2) {
    if (type === "error")
      return emitError(this, args2);
    var { _events: events } = this;
    if (events === undefined)
      return false;
    var handlers = events[type];
    if (handlers === undefined)
      return false;
    let maybeClonedHandlers = handlers.length > 1 ? handlers.slice() : handlers;
    for (let i2 = 0, { length: length3 } = maybeClonedHandlers;i2 < length3; i2++) {
      let handler = maybeClonedHandlers[i2];
      switch (args2.length) {
        case 0:
          handler.call(this);
          break;
        case 1:
          handler.call(this, args2[0]);
          break;
        case 2:
          handler.call(this, args2[0], args2[1]);
          break;
        case 3:
          handler.call(this, args2[0], args2[1], args2[2]);
          break;
        default:
          handler.apply(this, args2);
          break;
      }
    }
    return true;
  }, emitWithRejectionCapture = function emit22(type, ...args2) {
    if (type === "error")
      return emitError(this, args2);
    var { _events: events } = this;
    if (events === undefined)
      return false;
    var handlers = events[type];
    if (handlers === undefined)
      return false;
    let maybeClonedHandlers = handlers.length > 1 ? handlers.slice() : handlers;
    for (let i2 = 0, { length: length3 } = maybeClonedHandlers;i2 < length3; i2++) {
      let handler = maybeClonedHandlers[i2], result;
      switch (args2.length) {
        case 0:
          result = handler.call(this);
          break;
        case 1:
          result = handler.call(this, args2[0]);
          break;
        case 2:
          result = handler.call(this, args2[0], args2[1]);
          break;
        case 3:
          result = handler.call(this, args2[0], args2[1], args2[2]);
          break;
        default:
          result = handler.apply(this, args2);
          break;
      }
      if (result !== undefined && typeof result?.then === "function" && result.then === Promise.prototype.then)
        addCatch(this, result, type, args2);
    }
    return true;
  }, AbortError, events_default;
  var init_events = __esm(() => {
    SymbolFor = Symbol.for;
    kCapture = Symbol("kCapture");
    kErrorMonitor = SymbolFor("events.errorMonitor");
    kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
    kMaxEventTargetListenersWarned = Symbol("events.maxEventTargetListenersWarned");
    kRejection = SymbolFor("nodejs.rejection");
    captureRejectionSymbol = SymbolFor("nodejs.rejection");
    ArrayPrototypeSlice = Array.prototype.slice;
    EventEmitterPrototype = EventEmitter.prototype = {};
    EventEmitterPrototype._events = undefined;
    EventEmitterPrototype._eventsCount = 0;
    EventEmitterPrototype._maxListeners = undefined;
    EventEmitterPrototype.setMaxListeners = function setMaxListeners(n) {
      return validateNumber2(n, "setMaxListeners", 0), this._maxListeners = n, this;
    };
    EventEmitterPrototype.constructor = EventEmitter;
    EventEmitterPrototype.getMaxListeners = function getMaxListeners() {
      return this?._maxListeners ?? defaultMaxListeners;
    };
    EventEmitterPrototype.emit = emitWithoutRejectionCapture;
    EventEmitterPrototype.addListener = function addListener(type, fn2) {
      checkListener(fn2);
      var events = this._events;
      if (!events)
        events = this._events = { __proto__: null }, this._eventsCount = 0;
      else if (events.newListener)
        this.emit("newListener", type, fn2.listener ?? fn2);
      var handlers = events[type];
      if (!handlers)
        events[type] = [fn2], this._eventsCount++;
      else {
        handlers.push(fn2);
        var m = this._maxListeners ?? defaultMaxListeners;
        if (m > 0 && handlers.length > m && !handlers.warned)
          overflowWarning(this, type, handlers);
      }
      return this;
    };
    EventEmitterPrototype.on = EventEmitterPrototype.addListener;
    EventEmitterPrototype.prependListener = function prependListener(type, fn2) {
      checkListener(fn2);
      var events = this._events;
      if (!events)
        events = this._events = { __proto__: null }, this._eventsCount = 0;
      else if (events.newListener)
        this.emit("newListener", type, fn2.listener ?? fn2);
      var handlers = events[type];
      if (!handlers)
        events[type] = [fn2], this._eventsCount++;
      else {
        handlers.unshift(fn2);
        var m = this._maxListeners ?? defaultMaxListeners;
        if (m > 0 && handlers.length > m && !handlers.warned)
          overflowWarning(this, type, handlers);
      }
      return this;
    };
    EventEmitterPrototype.once = function once4(type, fn2) {
      checkListener(fn2);
      let bound = onceWrapper.bind(this, type, fn2);
      return bound.listener = fn2, this.addListener(type, bound), this;
    };
    EventEmitterPrototype.prependOnceListener = function prependOnceListener(type, fn2) {
      checkListener(fn2);
      let bound = onceWrapper.bind(this, type, fn2);
      return bound.listener = fn2, this.prependListener(type, bound), this;
    };
    EventEmitterPrototype.removeListener = function removeListener(type, fn2) {
      checkListener(fn2);
      var { _events: events } = this;
      if (!events)
        return this;
      var handlers = events[type];
      if (!handlers)
        return this;
      var length3 = handlers.length;
      let position = -1;
      for (let i2 = length3 - 1;i2 >= 0; i2--)
        if (handlers[i2] === fn2 || handlers[i2].listener === fn2) {
          position = i2;
          break;
        }
      if (position < 0)
        return this;
      if (position === 0)
        handlers.shift();
      else
        handlers.splice(position, 1);
      if (handlers.length === 0)
        delete events[type], this._eventsCount--;
      return this;
    };
    EventEmitterPrototype.off = EventEmitterPrototype.removeListener;
    EventEmitterPrototype.removeAllListeners = function removeAllListeners(type) {
      var { _events: events } = this;
      if (type && events) {
        if (events[type])
          delete events[type], this._eventsCount--;
      } else
        this._events = { __proto__: null };
      return this;
    };
    EventEmitterPrototype.listeners = function listeners(type) {
      var { _events: events } = this;
      if (!events)
        return [];
      var handlers = events[type];
      if (!handlers)
        return [];
      return handlers.map((x) => x.listener ?? x);
    };
    EventEmitterPrototype.rawListeners = function rawListeners(type) {
      var { _events } = this;
      if (!_events)
        return [];
      var handlers = _events[type];
      if (!handlers)
        return [];
      return handlers.slice();
    };
    EventEmitterPrototype.listenerCount = function listenerCount(type) {
      var { _events: events } = this;
      if (!events)
        return 0;
      return events[type]?.length ?? 0;
    };
    EventEmitterPrototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
    EventEmitterPrototype[kCapture] = false;
    AbortError = class AbortError extends Error {
      constructor(message = "The operation was aborted", options = undefined) {
        if (options !== undefined && typeof options !== "object")
          throw ERR_INVALID_ARG_TYPE2("options", "Object", options);
        super(message, options);
        this.code = "ABORT_ERR", this.name = "AbortError";
      }
    };
    Object.defineProperties(EventEmitter, { captureRejections: { get() {
      return EventEmitterPrototype[kCapture];
    }, set(value) {
      validateBoolean(value, "EventEmitter.captureRejections"), EventEmitterPrototype[kCapture] = value;
    }, enumerable: true }, defaultMaxListeners: { enumerable: true, get: () => {
      return defaultMaxListeners;
    }, set: (arg) => {
      validateNumber2(arg, "defaultMaxListeners", 0), defaultMaxListeners = arg;
    } }, kMaxEventTargetListeners: { value: kMaxEventTargetListeners, enumerable: false, configurable: false, writable: false }, kMaxEventTargetListenersWarned: { value: kMaxEventTargetListenersWarned, enumerable: false, configurable: false, writable: false } });
    Object.assign(EventEmitter, { once: once22, getEventListeners, getMaxListeners: getMaxListeners2, setMaxListeners: setMaxListeners2, EventEmitter, usingDomains: false, captureRejectionSymbol, errorMonitor: kErrorMonitor, addAbortListener, init: EventEmitter, listenerCount: listenerCount2 });
    events_default = EventEmitter;
  });

  // node:stream
  var require_stream = __commonJS((exports, module) => {
    var __commonJS2 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
    var require_primordials = __commonJS2((exports2, module2) => {

      class AggregateError extends Error {
        constructor(errors) {
          if (!Array.isArray(errors))
            throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
          let message = "";
          for (let i2 = 0;i2 < errors.length; i2++)
            message += `    ${errors[i2].stack}
`;
          super(message);
          this.name = "AggregateError", this.errors = errors;
        }
      }
      module2.exports = { AggregateError, ArrayIsArray(self2) {
        return Array.isArray(self2);
      }, ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      }, ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      }, ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      }, ArrayPrototypeMap(self2, fn2) {
        return self2.map(fn2);
      }, ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      }, ArrayPrototypePush(self2, el) {
        return self2.push(el);
      }, ArrayPrototypeSlice(self2, start4, end6) {
        return self2.slice(start4, end6);
      }, Error, FunctionPrototypeCall(fn2, thisArgs, ...args2) {
        return fn2.call(thisArgs, ...args2);
      }, FunctionPrototypeSymbolHasInstance(self2, instance) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance);
      }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      }, ObjectDefineProperty(self2, name, prop) {
        return Object.defineProperty(self2, name, prop);
      }, ObjectGetOwnPropertyDescriptor(self2, name) {
        return Object.getOwnPropertyDescriptor(self2, name);
      }, ObjectKeys(obj) {
        return Object.keys(obj);
      }, ObjectSetPrototypeOf(target, proto12) {
        return Object.setPrototypeOf(target, proto12);
      }, Promise, PromisePrototypeCatch(self2, fn2) {
        return self2.catch(fn2);
      }, PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      }, PromiseReject(err) {
        return Promise.reject(err);
      }, PromiseResolve(val) {
        return Promise.resolve(val);
      }, ReflectApply: Reflect.apply, RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      }, SafeSet: Set, String, StringPrototypeSlice(self2, start4, end6) {
        return self2.slice(start4, end6);
      }, StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      }, StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      }, StringPrototypeTrim(self2) {
        return self2.trim();
      }, Symbol, SymbolFor: Symbol.for, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"), SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"), TypedArrayPrototypeSet(self2, buf, len2) {
        return self2.set(buf, len2);
      }, Boolean, Uint8Array };
    });
    var require_inspect = __commonJS2((exports2, module2) => {
      module2.exports = { format(format6, ...args2) {
        return format6.replace(/%([sdifj])/g, function(...[_unused, type]) {
          let replacement = args2.shift();
          if (type === "f")
            return replacement.toFixed(6);
          else if (type === "j")
            return JSON.stringify(replacement);
          else if (type === "s" && typeof replacement === "object")
            return `${replacement.constructor !== Object ? replacement.constructor.name : ""} {}`.trim();
          else
            return replacement.toString();
        });
      }, inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"'))
                return `"${value}"`;
              else if (!value.includes("`") && !value.includes("${"))
                return `\`${value}\``;
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value))
              return "NaN";
            else if (Object.is(value, -0))
              return String(value);
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      } };
    });
    var require_errors = __commonJS2((exports2, module2) => {
      var { format: format6, inspect: inspect2 } = require_inspect(), { AggregateError: CustomAggregateError } = require_primordials(), AggregateError = globalThis.AggregateError || CustomAggregateError, kIsNodeError = Symbol("kIsNodeError"), kTypes = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], classRegExp = /^([A-Z][a-z0-9]*)+$/, codes = {};
      function assert(value, message) {
        if (!value)
          throw new codes.ERR_INTERNAL_ASSERTION(message);
      }
      function addNumericalSeparator2(val) {
        let res = "", i2 = val.length, start4 = val[0] === "-" ? 1 : 0;
        for (;i2 >= start4 + 4; i2 -= 3)
          res = `_${val.slice(i2 - 3, i2)}${res}`;
        return `${val.slice(0, i2)}${res}`;
      }
      function getMessage2(key, msg, args2) {
        if (typeof msg === "function")
          return assert(msg.length <= args2.length, `Code: ${key}; The provided arguments length (${args2.length}) does not match the required ones (${msg.length}).`), msg(...args2);
        let expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
        if (assert(expectedLength === args2.length, `Code: ${key}; The provided arguments length (${args2.length}) does not match the required ones (${expectedLength}).`), args2.length === 0)
          return msg;
        return format6(msg, ...args2);
      }
      function E2(code2, message, Base3) {
        if (!Base3)
          Base3 = Error;

        class NodeError extends Base3 {
          constructor(...args2) {
            super(getMessage2(code2, message, args2));
          }
          toString() {
            return `${this.name} [${code2}]: ${this.message}`;
          }
        }
        Object.defineProperties(NodeError.prototype, { name: { value: Base3.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
          return `${this.name} [${code2}]: ${this.message}`;
        }, writable: true, enumerable: false, configurable: true } }), NodeError.prototype.code = code2, NodeError.prototype[kIsNodeError] = true, codes[code2] = NodeError;
      }
      function hideStackFrames(fn2) {
        let hidden = "__node_internal_" + fn2.name;
        return Object.defineProperty(fn2, "name", { value: hidden }), fn2;
      }
      function aggregateTwoErrors(innerError, outerError) {
        if (innerError && outerError && innerError !== outerError) {
          if (Array.isArray(outerError.errors))
            return outerError.errors.push(innerError), outerError;
          let err = new AggregateError([outerError, innerError], outerError.message);
          return err.code = outerError.code, err;
        }
        return innerError || outerError;
      }

      class AbortError2 extends Error {
        constructor(message = "The operation was aborted", options = undefined) {
          if (options !== undefined && typeof options !== "object")
            throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
          super(message, options);
          this.code = "ABORT_ERR", this.name = "AbortError";
        }
      }
      E2("ERR_ASSERTION", "%s", Error);
      E2("ERR_INVALID_ARG_TYPE", (name, expected, actual) => {
        if (assert(typeof name === "string", "'name' must be a string"), !Array.isArray(expected))
          expected = [expected];
        let msg = "The ";
        if (name.endsWith(" argument"))
          msg += `${name} `;
        else
          msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
        msg += "must be ";
        let types = [], instances = [], other = [];
        for (let value of expected)
          if (assert(typeof value === "string", "All expected entries have to be of type string"), kTypes.includes(value))
            types.push(value.toLowerCase());
          else if (classRegExp.test(value))
            instances.push(value);
          else
            assert(value !== "object", 'The value "object" should be written as "Object"'), other.push(value);
        if (instances.length > 0) {
          let pos = types.indexOf("object");
          if (pos !== -1)
            types.splice(types, pos, 1), instances.push("Object");
        }
        if (types.length > 0) {
          switch (types.length) {
            case 1:
              msg += `of type ${types[0]}`;
              break;
            case 2:
              msg += `one of type ${types[0]} or ${types[1]}`;
              break;
            default: {
              let last4 = types.pop();
              msg += `one of type ${types.join(", ")}, or ${last4}`;
            }
          }
          if (instances.length > 0 || other.length > 0)
            msg += " or ";
        }
        if (instances.length > 0) {
          switch (instances.length) {
            case 1:
              msg += `an instance of ${instances[0]}`;
              break;
            case 2:
              msg += `an instance of ${instances[0]} or ${instances[1]}`;
              break;
            default: {
              let last4 = instances.pop();
              msg += `an instance of ${instances.join(", ")}, or ${last4}`;
            }
          }
          if (other.length > 0)
            msg += " or ";
        }
        switch (other.length) {
          case 0:
            break;
          case 1:
            if (other[0].toLowerCase() !== other[0])
              msg += "an ";
            msg += `${other[0]}`;
            break;
          case 2:
            msg += `one of ${other[0]} or ${other[1]}`;
            break;
          default: {
            let last4 = other.pop();
            msg += `one of ${other.join(", ")}, or ${last4}`;
          }
        }
        if (actual == null)
          msg += `. Received ${actual}`;
        else if (typeof actual === "function" && actual.name)
          msg += `. Received function ${actual.name}`;
        else if (typeof actual === "object") {
          var _actual$constructor;
          if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== undefined && _actual$constructor.name)
            msg += `. Received an instance of ${actual.constructor.name}`;
          else {
            let inspected = inspect2(actual, { depth: -1 });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = inspect2(actual, { colors: false });
          if (inspected.length > 25)
            inspected = `${inspected.slice(0, 25)}...`;
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        return msg;
      }, TypeError);
      E2("ERR_INVALID_ARG_VALUE", (name, value, reason = "is invalid") => {
        let inspected = inspect2(value);
        if (inspected.length > 128)
          inspected = inspected.slice(0, 128) + "...";
        return `The ${name.includes(".") ? "property" : "argument"} '${name}' ${reason}. Received ${inspected}`;
      }, TypeError);
      E2("ERR_INVALID_RETURN_VALUE", (input, name, value) => {
        var _value$constructor;
        let type = value !== null && value !== undefined && (_value$constructor = value.constructor) !== null && _value$constructor !== undefined && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
        return `Expected ${input} to be returned from the "${name}" function but got ${type}.`;
      }, TypeError);
      E2("ERR_MISSING_ARGS", (...args2) => {
        assert(args2.length > 0, "At least one arg needs to be specified");
        let msg, len2 = args2.length;
        switch (args2 = (Array.isArray(args2) ? args2 : [args2]).map((a) => `"${a}"`).join(" or "), len2) {
          case 1:
            msg += `The ${args2[0]} argument`;
            break;
          case 2:
            msg += `The ${args2[0]} and ${args2[1]} arguments`;
            break;
          default:
            {
              let last4 = args2.pop();
              msg += `The ${args2.join(", ")}, and ${last4} arguments`;
            }
            break;
        }
        return `${msg} must be specified`;
      }, TypeError);
      E2("ERR_OUT_OF_RANGE", (str, range4, input) => {
        assert(range4, 'Missing "range" argument');
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 4294967296)
          received = addNumericalSeparator2(String(input));
        else if (typeof input === "bigint") {
          received = String(input);
          let limit = BigInt(2) ** BigInt(32);
          if (input > limit || input < -limit)
            received = addNumericalSeparator2(received);
          received += "n";
        } else
          received = inspect2(input);
        return `The value of "${str}" is out of range. It must be ${range4}. Received ${received}`;
      }, RangeError);
      E2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
      E2("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
      E2("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
      E2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
      E2("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
      E2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      E2("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
      E2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
      E2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
      E2("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
      E2("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
      module2.exports = { AbortError: AbortError2, aggregateTwoErrors: hideStackFrames(aggregateTwoErrors), hideStackFrames, codes };
    });
    var require_event_target_shim = __commonJS2((exports2, module2) => {
      Object.defineProperty(exports2, "__esModule", { value: true });
      var privateData = new WeakMap, wrappers = new WeakMap;
      function pd(event) {
        let retv = privateData.get(event);
        return console.assert(retv != null, "'this' is expected an Event object, but got", event), retv;
      }
      function setCancelFlag(data) {
        if (data.passiveListener != null) {
          if (typeof console !== "undefined" && typeof console.error === "function")
            console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
          return;
        }
        if (!data.event.cancelable)
          return;
        if (data.canceled = true, typeof data.event.preventDefault === "function")
          data.event.preventDefault();
      }
      function Event(eventTarget, event) {
        privateData.set(this, { eventTarget, event, eventPhase: 2, currentTarget: eventTarget, canceled: false, stopped: false, immediateStopped: false, passiveListener: null, timeStamp: event.timeStamp || Date.now() }), Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });
        let keys3 = Object.keys(event);
        for (let i2 = 0;i2 < keys3.length; ++i2) {
          let key = keys3[i2];
          if (!(key in this))
            Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
      }
      Event.prototype = { get type() {
        return pd(this).event.type;
      }, get target() {
        return pd(this).eventTarget;
      }, get currentTarget() {
        return pd(this).currentTarget;
      }, composedPath() {
        let currentTarget = pd(this).currentTarget;
        if (currentTarget == null)
          return [];
        return [currentTarget];
      }, get NONE() {
        return 0;
      }, get CAPTURING_PHASE() {
        return 1;
      }, get AT_TARGET() {
        return 2;
      }, get BUBBLING_PHASE() {
        return 3;
      }, get eventPhase() {
        return pd(this).eventPhase;
      }, stopPropagation() {
        let data = pd(this);
        if (data.stopped = true, typeof data.event.stopPropagation === "function")
          data.event.stopPropagation();
      }, stopImmediatePropagation() {
        let data = pd(this);
        if (data.stopped = true, data.immediateStopped = true, typeof data.event.stopImmediatePropagation === "function")
          data.event.stopImmediatePropagation();
      }, get bubbles() {
        return Boolean(pd(this).event.bubbles);
      }, get cancelable() {
        return Boolean(pd(this).event.cancelable);
      }, preventDefault() {
        setCancelFlag(pd(this));
      }, get defaultPrevented() {
        return pd(this).canceled;
      }, get composed() {
        return Boolean(pd(this).event.composed);
      }, get timeStamp() {
        return pd(this).timeStamp;
      }, get srcElement() {
        return pd(this).eventTarget;
      }, get cancelBubble() {
        return pd(this).stopped;
      }, set cancelBubble(value) {
        if (!value)
          return;
        let data = pd(this);
        if (data.stopped = true, typeof data.event.cancelBubble === "boolean")
          data.event.cancelBubble = true;
      }, get returnValue() {
        return !pd(this).canceled;
      }, set returnValue(value) {
        if (!value)
          setCancelFlag(pd(this));
      }, initEvent() {} };
      Object.defineProperty(Event.prototype, "constructor", { value: Event, configurable: true, writable: true });
      if (typeof window !== "undefined" && typeof window.Event !== "undefined")
        Object.setPrototypeOf(Event.prototype, window.Event.prototype), wrappers.set(window.Event.prototype, Event);
      function defineRedirectDescriptor(key) {
        return { get() {
          return pd(this).event[key];
        }, set(value) {
          pd(this).event[key] = value;
        }, configurable: true, enumerable: true };
      }
      function defineCallDescriptor(key) {
        return { value() {
          let event = pd(this).event;
          return event[key].apply(event, arguments);
        }, configurable: true, enumerable: true };
      }
      function defineWrapper(BaseEvent, proto12) {
        let keys3 = Object.keys(proto12);
        if (keys3.length === 0)
          return BaseEvent;
        function CustomEvent(eventTarget, event) {
          BaseEvent.call(this, eventTarget, event);
        }
        CustomEvent.prototype = Object.create(BaseEvent.prototype, { constructor: { value: CustomEvent, configurable: true, writable: true } });
        for (let i2 = 0;i2 < keys3.length; ++i2) {
          let key = keys3[i2];
          if (!(key in BaseEvent.prototype)) {
            let isFunc = typeof Object.getOwnPropertyDescriptor(proto12, key).value === "function";
            Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
          }
        }
        return CustomEvent;
      }
      function getWrapper(proto12) {
        if (proto12 == null || proto12 === Object.prototype)
          return Event;
        let wrapper = wrappers.get(proto12);
        if (wrapper == null)
          wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto12)), proto12), wrappers.set(proto12, wrapper);
        return wrapper;
      }
      function wrapEvent(eventTarget, event) {
        return new (getWrapper(Object.getPrototypeOf(event)))(eventTarget, event);
      }
      function isStopped(event) {
        return pd(event).immediateStopped;
      }
      function setEventPhase(event, eventPhase) {
        pd(event).eventPhase = eventPhase;
      }
      function setCurrentTarget(event, currentTarget) {
        pd(event).currentTarget = currentTarget;
      }
      function setPassiveListener(event, passiveListener) {
        pd(event).passiveListener = passiveListener;
      }
      var listenersMap = new WeakMap, CAPTURE = 1, BUBBLE = 2, ATTRIBUTE = 3;
      function isObject2(x) {
        return x !== null && typeof x === "object";
      }
      function getListeners(eventTarget) {
        let listeners2 = listenersMap.get(eventTarget);
        if (listeners2 == null)
          throw new TypeError("'this' is expected an EventTarget object, but got another value.");
        return listeners2;
      }
      function defineEventAttributeDescriptor(eventName) {
        return { get() {
          let node = getListeners(this).get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE)
              return node.listener;
            node = node.next;
          }
          return null;
        }, set(listener) {
          if (typeof listener !== "function" && !isObject2(listener))
            listener = null;
          let listeners2 = getListeners(this), prev = null, node = listeners2.get(eventName);
          while (node != null) {
            if (node.listenerType === ATTRIBUTE)
              if (prev !== null)
                prev.next = node.next;
              else if (node.next !== null)
                listeners2.set(eventName, node.next);
              else
                listeners2.delete(eventName);
            else
              prev = node;
            node = node.next;
          }
          if (listener !== null) {
            let newNode = { listener, listenerType: ATTRIBUTE, passive: false, once: false, next: null };
            if (prev === null)
              listeners2.set(eventName, newNode);
            else
              prev.next = newNode;
          }
        }, configurable: true, enumerable: true };
      }
      function defineEventAttribute(eventTargetPrototype, eventName) {
        Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
      }
      function defineCustomEventTarget(eventNames2) {
        function CustomEventTarget() {
          EventTarget.call(this);
        }
        CustomEventTarget.prototype = Object.create(EventTarget.prototype, { constructor: { value: CustomEventTarget, configurable: true, writable: true } });
        for (let i2 = 0;i2 < eventNames2.length; ++i2)
          defineEventAttribute(CustomEventTarget.prototype, eventNames2[i2]);
        return CustomEventTarget;
      }
      function EventTarget() {
        if (this instanceof EventTarget) {
          listenersMap.set(this, new Map);
          return;
        }
        if (arguments.length === 1 && Array.isArray(arguments[0]))
          return defineCustomEventTarget(arguments[0]);
        if (arguments.length > 0) {
          let types = new Array(arguments.length);
          for (let i2 = 0;i2 < arguments.length; ++i2)
            types[i2] = arguments[i2];
          return defineCustomEventTarget(types);
        }
        throw new TypeError("Cannot call a class as a function");
      }
      EventTarget.prototype = { addEventListener(eventName, listener, options) {
        if (listener == null)
          return;
        if (typeof listener !== "function" && !isObject2(listener))
          throw new TypeError("'listener' should be a function or an object.");
        let listeners2 = getListeners(this), optionsIsObj = isObject2(options), listenerType = (optionsIsObj ? Boolean(options.capture) : Boolean(options)) ? CAPTURE : BUBBLE, newNode = { listener, listenerType, passive: optionsIsObj && Boolean(options.passive), once: optionsIsObj && Boolean(options.once), next: null }, node = listeners2.get(eventName);
        if (node === undefined) {
          listeners2.set(eventName, newNode);
          return;
        }
        let prev = null;
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType)
            return;
          prev = node, node = node.next;
        }
        prev.next = newNode;
      }, removeEventListener(eventName, listener, options) {
        if (listener == null)
          return;
        let listeners2 = getListeners(this), listenerType = (isObject2(options) ? Boolean(options.capture) : Boolean(options)) ? CAPTURE : BUBBLE, prev = null, node = listeners2.get(eventName);
        while (node != null) {
          if (node.listener === listener && node.listenerType === listenerType) {
            if (prev !== null)
              prev.next = node.next;
            else if (node.next !== null)
              listeners2.set(eventName, node.next);
            else
              listeners2.delete(eventName);
            return;
          }
          prev = node, node = node.next;
        }
      }, dispatchEvent(event) {
        if (event == null || typeof event.type !== "string")
          throw new TypeError('"event.type" should be a string.');
        let listeners2 = getListeners(this), eventName = event.type, node = listeners2.get(eventName);
        if (node == null)
          return true;
        let wrappedEvent = wrapEvent(this, event), prev = null;
        while (node != null) {
          if (node.once)
            if (prev !== null)
              prev.next = node.next;
            else if (node.next !== null)
              listeners2.set(eventName, node.next);
            else
              listeners2.delete(eventName);
          else
            prev = node;
          if (setPassiveListener(wrappedEvent, node.passive ? node.listener : null), typeof node.listener === "function")
            try {
              node.listener.call(this, wrappedEvent);
            } catch (err) {
              if (typeof console !== "undefined" && typeof console.error === "function")
                console.error(err);
            }
          else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function")
            node.listener.handleEvent(wrappedEvent);
          if (isStopped(wrappedEvent))
            break;
          node = node.next;
        }
        return setPassiveListener(wrappedEvent, null), setEventPhase(wrappedEvent, 0), setCurrentTarget(wrappedEvent, null), !wrappedEvent.defaultPrevented;
      } };
      Object.defineProperty(EventTarget.prototype, "constructor", { value: EventTarget, configurable: true, writable: true });
      if (typeof window !== "undefined" && typeof window.EventTarget !== "undefined")
        Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
      exports2.defineEventAttribute = defineEventAttribute;
      exports2.EventTarget = EventTarget;
      exports2.default = EventTarget;
      module2.exports = EventTarget;
      module2.exports.EventTarget = module2.exports.default = EventTarget;
      module2.exports.defineEventAttribute = defineEventAttribute;
    });
    var require_abort_controller = __commonJS2((exports2, module2) => {
      Object.defineProperty(exports2, "__esModule", { value: true });
      var eventTargetShim = require_event_target_shim();

      class AbortSignal extends eventTargetShim.EventTarget {
        constructor() {
          super();
          throw new TypeError("AbortSignal cannot be constructed directly");
        }
        get aborted() {
          let aborted = abortedFlags.get(this);
          if (typeof aborted !== "boolean")
            throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
          return aborted;
        }
      }
      eventTargetShim.defineEventAttribute(AbortSignal.prototype, "abort");
      function createAbortSignal() {
        let signal = Object.create(AbortSignal.prototype);
        return eventTargetShim.EventTarget.call(signal), abortedFlags.set(signal, false), signal;
      }
      function abortSignal(signal) {
        if (abortedFlags.get(signal) !== false)
          return;
        abortedFlags.set(signal, true), signal.dispatchEvent({ type: "abort" });
      }
      var abortedFlags = new WeakMap;
      Object.defineProperties(AbortSignal.prototype, { aborted: { enumerable: true } });
      if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol")
        Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, { configurable: true, value: "AbortSignal" });

      class AbortController2 {
        constructor() {
          signals.set(this, createAbortSignal());
        }
        get signal() {
          return getSignal(this);
        }
        abort() {
          abortSignal(getSignal(this));
        }
      }
      var signals = new WeakMap;
      function getSignal(controller) {
        let signal = signals.get(controller);
        if (signal == null)
          throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
        return signal;
      }
      Object.defineProperties(AbortController2.prototype, { signal: { enumerable: true }, abort: { enumerable: true } });
      if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol")
        Object.defineProperty(AbortController2.prototype, Symbol.toStringTag, { configurable: true, value: "AbortController" });
      exports2.AbortController = AbortController2;
      exports2.AbortSignal = AbortSignal;
      exports2.default = AbortController2;
      module2.exports = AbortController2;
      module2.exports.AbortController = module2.exports.default = AbortController2;
      module2.exports.AbortSignal = AbortSignal;
    });
    var require_util = __commonJS2((exports2, module2) => {
      var bufferModule = (init_buffer(), __toCommonJS(exports_buffer)), { format: format6, inspect: inspect2 } = require_inspect(), { codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3 } } = require_errors(), { kResistStopPropagation, AggregateError, SymbolDispose } = require_primordials(), AbortSignal = globalThis.AbortSignal || require_abort_controller().AbortSignal, AbortController2 = globalThis.AbortController || require_abort_controller().AbortController, AsyncFunction = Object.getPrototypeOf(async function() {}).constructor, Blob3 = globalThis.Blob || bufferModule.Blob, isBlob = typeof Blob3 !== "undefined" ? function isBlob(b) {
        return b instanceof Blob3;
      } : function isBlob(b) {
        return false;
      }, validateAbortSignal2 = (signal, name) => {
        if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal)))
          throw new ERR_INVALID_ARG_TYPE3(name, "AbortSignal", signal);
      }, validateFunction = (value, name) => {
        if (typeof value !== "function")
          throw new ERR_INVALID_ARG_TYPE3(name, "Function", value);
      };
      module2.exports = { AggregateError, kEmptyObject: Object.freeze({}), once(callback) {
        let called = false;
        return function(...args2) {
          if (called)
            return;
          called = true, callback.apply(this, args2);
        };
      }, createDeferredPromise: function() {
        let resolve3, reject;
        return { promise: new Promise((res, rej) => {
          resolve3 = res, reject = rej;
        }), resolve: resolve3, reject };
      }, promisify(fn2) {
        return new Promise((resolve3, reject) => {
          fn2((err, ...args2) => {
            if (err)
              return reject(err);
            return resolve3(...args2);
          });
        });
      }, debuglog() {
        return function() {};
      }, format: format6, inspect: inspect2, types: { isAsyncFunction(fn2) {
        return fn2 instanceof AsyncFunction;
      }, isArrayBufferView(arr) {
        return ArrayBuffer.isView(arr);
      } }, isBlob, deprecate(fn2, message) {
        return fn2;
      }, addAbortListener: (init_events(), __toCommonJS(exports_events)).addAbortListener || function addAbortListener(signal, listener) {
        if (signal === undefined)
          throw new ERR_INVALID_ARG_TYPE3("signal", "AbortSignal", signal);
        validateAbortSignal2(signal, "signal"), validateFunction(listener, "listener");
        let removeEventListener;
        if (signal.aborted)
          queueMicrotask(() => listener());
        else
          signal.addEventListener("abort", listener, { __proto__: null, once: true, [kResistStopPropagation]: true }), removeEventListener = () => {
            signal.removeEventListener("abort", listener);
          };
        return { __proto__: null, [SymbolDispose]() {
          var _removeEventListener;
          (_removeEventListener = removeEventListener) === null || _removeEventListener === undefined || _removeEventListener();
        } };
      }, AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {
        if (signals.length === 1)
          return signals[0];
        let ac = new AbortController2, abort = () => ac.abort();
        return signals.forEach((signal) => {
          validateAbortSignal2(signal, "signals"), signal.addEventListener("abort", abort, { once: true });
        }), ac.signal.addEventListener("abort", () => {
          signals.forEach((signal) => signal.removeEventListener("abort", abort));
        }, { once: true }), ac.signal;
      } };
      module2.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
    });
    var require_validators = __commonJS2((exports2, module2) => {
      var { ArrayIsArray, ArrayPrototypeIncludes, ArrayPrototypeJoin, ArrayPrototypeMap, NumberIsInteger, NumberIsNaN, NumberMAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER, NumberParseInt, ObjectPrototypeHasOwnProperty, RegExpPrototypeExec, String: String2, StringPrototypeToUpperCase, StringPrototypeTrim } = require_primordials(), { hideStackFrames, codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE3, ERR_UNKNOWN_SIGNAL } } = require_errors(), { normalizeEncoding } = require_util(), { isAsyncFunction, isArrayBufferView } = require_util().types, signals = {};
      function isInt32(value) {
        return value === (value | 0);
      }
      function isUint32(value) {
        return value === value >>> 0;
      }
      var octalReg = /^[0-7]+$/, modeDesc = "must be a 32-bit unsigned integer or an octal string";
      function parseFileMode(value, name, def) {
        if (typeof value === "undefined")
          value = def;
        if (typeof value === "string") {
          if (RegExpPrototypeExec(octalReg, value) === null)
            throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
          value = NumberParseInt(value, 8);
        }
        return validateUint32(value, name), value;
      }
      var validateInteger = hideStackFrames((value, name, min3 = NumberMIN_SAFE_INTEGER, max5 = NumberMAX_SAFE_INTEGER) => {
        if (typeof value !== "number")
          throw new ERR_INVALID_ARG_TYPE3(name, "number", value);
        if (!NumberIsInteger(value))
          throw new ERR_OUT_OF_RANGE3(name, "an integer", value);
        if (value < min3 || value > max5)
          throw new ERR_OUT_OF_RANGE3(name, `>= ${min3} && <= ${max5}`, value);
      }), validateInt32 = hideStackFrames((value, name, min3 = -2147483648, max5 = 2147483647) => {
        if (typeof value !== "number")
          throw new ERR_INVALID_ARG_TYPE3(name, "number", value);
        if (!NumberIsInteger(value))
          throw new ERR_OUT_OF_RANGE3(name, "an integer", value);
        if (value < min3 || value > max5)
          throw new ERR_OUT_OF_RANGE3(name, `>= ${min3} && <= ${max5}`, value);
      }), validateUint32 = hideStackFrames((value, name, positive2 = false) => {
        if (typeof value !== "number")
          throw new ERR_INVALID_ARG_TYPE3(name, "number", value);
        if (!NumberIsInteger(value))
          throw new ERR_OUT_OF_RANGE3(name, "an integer", value);
        let min3 = positive2 ? 1 : 0, max5 = 4294967295;
        if (value < min3 || value > max5)
          throw new ERR_OUT_OF_RANGE3(name, `>= ${min3} && <= ${max5}`, value);
      });
      function validateString(value, name) {
        if (typeof value !== "string")
          throw new ERR_INVALID_ARG_TYPE3(name, "string", value);
      }
      function validateNumber3(value, name, min3 = undefined, max5) {
        if (typeof value !== "number")
          throw new ERR_INVALID_ARG_TYPE3(name, "number", value);
        if (min3 != null && value < min3 || max5 != null && value > max5 || (min3 != null || max5 != null) && NumberIsNaN(value))
          throw new ERR_OUT_OF_RANGE3(name, `${min3 != null ? `>= ${min3}` : ""}${min3 != null && max5 != null ? " && " : ""}${max5 != null ? `<= ${max5}` : ""}`, value);
      }
      var validateOneOf = hideStackFrames((value, name, oneOf) => {
        if (!ArrayPrototypeIncludes(oneOf, value)) {
          let reason = "must be one of: " + ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)), ", ");
          throw new ERR_INVALID_ARG_VALUE(name, value, reason);
        }
      });
      function validateBoolean2(value, name) {
        if (typeof value !== "boolean")
          throw new ERR_INVALID_ARG_TYPE3(name, "boolean", value);
      }
      function getOwnPropertyValueOrDefault(options, key, defaultValue) {
        return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
      }
      var validateObject = hideStackFrames((value, name, options = null) => {
        let allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false), allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
        if (!getOwnPropertyValueOrDefault(options, "nullable", false) && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function"))
          throw new ERR_INVALID_ARG_TYPE3(name, "Object", value);
      }), validateDictionary = hideStackFrames((value, name) => {
        if (value != null && typeof value !== "object" && typeof value !== "function")
          throw new ERR_INVALID_ARG_TYPE3(name, "a dictionary", value);
      }), validateArray = hideStackFrames((value, name, minLength = 0) => {
        if (!ArrayIsArray(value))
          throw new ERR_INVALID_ARG_TYPE3(name, "Array", value);
        if (value.length < minLength) {
          let reason = `must be longer than ${minLength}`;
          throw new ERR_INVALID_ARG_VALUE(name, value, reason);
        }
      });
      function validateStringArray(value, name) {
        validateArray(value, name);
        for (let i2 = 0;i2 < value.length; i2++)
          validateString(value[i2], `${name}[${i2}]`);
      }
      function validateBooleanArray(value, name) {
        validateArray(value, name);
        for (let i2 = 0;i2 < value.length; i2++)
          validateBoolean2(value[i2], `${name}[${i2}]`);
      }
      function validateAbortSignalArray(value, name) {
        validateArray(value, name);
        for (let i2 = 0;i2 < value.length; i2++) {
          let signal = value[i2], indexedName = `${name}[${i2}]`;
          if (signal == null)
            throw new ERR_INVALID_ARG_TYPE3(indexedName, "AbortSignal", signal);
          validateAbortSignal2(signal, indexedName);
        }
      }
      function validateSignalName(signal, name = "signal") {
        if (validateString(signal, name), signals[signal] === undefined) {
          if (signals[StringPrototypeToUpperCase(signal)] !== undefined)
            throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
          throw new ERR_UNKNOWN_SIGNAL(signal);
        }
      }
      var validateBuffer = hideStackFrames((buffer4, name = "buffer") => {
        if (!isArrayBufferView(buffer4))
          throw new ERR_INVALID_ARG_TYPE3(name, ["Buffer", "TypedArray", "DataView"], buffer4);
      });
      function validateEncoding(data, encoding) {
        let normalizedEncoding = normalizeEncoding(encoding), length3 = data.length;
        if (normalizedEncoding === "hex" && length3 % 2 !== 0)
          throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length3}`);
      }
      function validatePort(port, name = "Port", allowZero = true) {
        if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero)
          throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
        return port | 0;
      }
      var validateAbortSignal2 = hideStackFrames((signal, name) => {
        if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal)))
          throw new ERR_INVALID_ARG_TYPE3(name, "AbortSignal", signal);
      }), validateFunction = hideStackFrames((value, name) => {
        if (typeof value !== "function")
          throw new ERR_INVALID_ARG_TYPE3(name, "Function", value);
      }), validatePlainFunction = hideStackFrames((value, name) => {
        if (typeof value !== "function" || isAsyncFunction(value))
          throw new ERR_INVALID_ARG_TYPE3(name, "Function", value);
      }), validateUndefined = hideStackFrames((value, name) => {
        if (value !== undefined)
          throw new ERR_INVALID_ARG_TYPE3(name, "undefined", value);
      });
      function validateUnion(value, name, union9) {
        if (!ArrayPrototypeIncludes(union9, value))
          throw new ERR_INVALID_ARG_TYPE3(name, `('${ArrayPrototypeJoin(union9, "|")}')`, value);
      }
      var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
      function validateLinkHeaderFormat(value, name) {
        if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value))
          throw new ERR_INVALID_ARG_VALUE(name, value, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
      }
      function validateLinkHeaderValue(hints) {
        if (typeof hints === "string")
          return validateLinkHeaderFormat(hints, "hints"), hints;
        else if (ArrayIsArray(hints)) {
          let hintsLength = hints.length, result = "";
          if (hintsLength === 0)
            return result;
          for (let i2 = 0;i2 < hintsLength; i2++) {
            let link = hints[i2];
            if (validateLinkHeaderFormat(link, "hints"), result += link, i2 !== hintsLength - 1)
              result += ", ";
          }
          return result;
        }
        throw new ERR_INVALID_ARG_VALUE("hints", hints, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
      }
      module2.exports = { isInt32, isUint32, parseFileMode, validateArray, validateStringArray, validateBooleanArray, validateAbortSignalArray, validateBoolean: validateBoolean2, validateBuffer, validateDictionary, validateEncoding, validateFunction, validateInt32, validateInteger, validateNumber: validateNumber3, validateObject, validateOneOf, validatePlainFunction, validatePort, validateSignalName, validateString, validateUint32, validateUndefined, validateUnion, validateAbortSignal: validateAbortSignal2, validateLinkHeaderValue };
    });
    var require_process = __commonJS2((exports2, module2) => {
      module2.exports = globalThis.process;
    });
    var require_utils = __commonJS2((exports2, module2) => {
      var { SymbolAsyncIterator, SymbolIterator, SymbolFor: SymbolFor2 } = require_primordials(), kIsDestroyed = SymbolFor2("nodejs.stream.destroyed"), kIsErrored = SymbolFor2("nodejs.stream.errored"), kIsReadable = SymbolFor2("nodejs.stream.readable"), kIsWritable = SymbolFor2("nodejs.stream.writable"), kIsDisturbed = SymbolFor2("nodejs.stream.disturbed"), kIsClosedPromise = SymbolFor2("nodejs.webstream.isClosedPromise"), kControllerErrorFunction = SymbolFor2("nodejs.webstream.controllerErrorFunction");
      function isReadableNodeStream(obj, strict2 = false) {
        var _obj$_readableState;
        return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict2 || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined ? undefined : _obj$_readableState.readable) !== false) && (!obj._writableState || obj._readableState));
      }
      function isWritableNodeStream(obj) {
        var _obj$_writableState;
        return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined ? undefined : _obj$_writableState.writable) !== false));
      }
      function isDuplexNodeStream(obj) {
        return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
      }
      function isNodeStream(obj) {
        return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
      }
      function isReadableStream(obj) {
        return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
      }
      function isWritableStream(obj) {
        return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
      }
      function isTransformStream(obj) {
        return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
      }
      function isWebStream(obj) {
        return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
      }
      function isIterable2(obj, isAsync) {
        if (obj == null)
          return false;
        if (isAsync === true)
          return typeof obj[SymbolAsyncIterator] === "function";
        if (isAsync === false)
          return typeof obj[SymbolIterator] === "function";
        return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
      }
      function isDestroyed(stream3) {
        if (!isNodeStream(stream3))
          return null;
        let { _writableState: wState, _readableState: rState } = stream3, state = wState || rState;
        return !!(stream3.destroyed || stream3[kIsDestroyed] || state !== null && state !== undefined && state.destroyed);
      }
      function isWritableEnded(stream3) {
        if (!isWritableNodeStream(stream3))
          return null;
        if (stream3.writableEnded === true)
          return true;
        let wState = stream3._writableState;
        if (wState !== null && wState !== undefined && wState.errored)
          return false;
        if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== "boolean")
          return null;
        return wState.ended;
      }
      function isWritableFinished(stream3, strict2) {
        if (!isWritableNodeStream(stream3))
          return null;
        if (stream3.writableFinished === true)
          return true;
        let wState = stream3._writableState;
        if (wState !== null && wState !== undefined && wState.errored)
          return false;
        if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== "boolean")
          return null;
        return !!(wState.finished || strict2 === false && wState.ended === true && wState.length === 0);
      }
      function isReadableEnded(stream3) {
        if (!isReadableNodeStream(stream3))
          return null;
        if (stream3.readableEnded === true)
          return true;
        let rState = stream3._readableState;
        if (!rState || rState.errored)
          return false;
        if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== "boolean")
          return null;
        return rState.ended;
      }
      function isReadableFinished(stream3, strict2) {
        if (!isReadableNodeStream(stream3))
          return null;
        let rState = stream3._readableState;
        if (rState !== null && rState !== undefined && rState.errored)
          return false;
        if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== "boolean")
          return null;
        return !!(rState.endEmitted || strict2 === false && rState.ended === true && rState.length === 0);
      }
      function isReadable(stream3) {
        if (stream3 && stream3[kIsReadable] != null)
          return stream3[kIsReadable];
        if (typeof (stream3 === null || stream3 === undefined ? undefined : stream3.readable) !== "boolean")
          return null;
        if (isDestroyed(stream3))
          return false;
        return isReadableNodeStream(stream3) && stream3.readable && !isReadableFinished(stream3);
      }
      function isWritable(stream3) {
        if (stream3 && stream3[kIsWritable] != null)
          return stream3[kIsWritable];
        if (typeof (stream3 === null || stream3 === undefined ? undefined : stream3.writable) !== "boolean")
          return null;
        if (isDestroyed(stream3))
          return false;
        return isWritableNodeStream(stream3) && stream3.writable && !isWritableEnded(stream3);
      }
      function isFinished(stream3, opts) {
        if (!isNodeStream(stream3))
          return null;
        if (isDestroyed(stream3))
          return true;
        if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream3))
          return false;
        if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream3))
          return false;
        return true;
      }
      function isWritableErrored(stream3) {
        var _stream$_writableStat, _stream$_writableStat2;
        if (!isNodeStream(stream3))
          return null;
        if (stream3.writableErrored)
          return stream3.writableErrored;
        return (_stream$_writableStat = (_stream$_writableStat2 = stream3._writableState) === null || _stream$_writableStat2 === undefined ? undefined : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined ? _stream$_writableStat : null;
      }
      function isReadableErrored(stream3) {
        var _stream$_readableStat, _stream$_readableStat2;
        if (!isNodeStream(stream3))
          return null;
        if (stream3.readableErrored)
          return stream3.readableErrored;
        return (_stream$_readableStat = (_stream$_readableStat2 = stream3._readableState) === null || _stream$_readableStat2 === undefined ? undefined : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined ? _stream$_readableStat : null;
      }
      function isClosed(stream3) {
        if (!isNodeStream(stream3))
          return null;
        if (typeof stream3.closed === "boolean")
          return stream3.closed;
        let { _writableState: wState, _readableState: rState } = stream3;
        if (typeof (wState === null || wState === undefined ? undefined : wState.closed) === "boolean" || typeof (rState === null || rState === undefined ? undefined : rState.closed) === "boolean")
          return (wState === null || wState === undefined ? undefined : wState.closed) || (rState === null || rState === undefined ? undefined : rState.closed);
        if (typeof stream3._closed === "boolean" && isOutgoingMessage(stream3))
          return stream3._closed;
        return null;
      }
      function isOutgoingMessage(stream3) {
        return typeof stream3._closed === "boolean" && typeof stream3._defaultKeepAlive === "boolean" && typeof stream3._removedConnection === "boolean" && typeof stream3._removedContLen === "boolean";
      }
      function isServerResponse(stream3) {
        return typeof stream3._sent100 === "boolean" && isOutgoingMessage(stream3);
      }
      function isServerRequest(stream3) {
        var _stream$req;
        return typeof stream3._consuming === "boolean" && typeof stream3._dumped === "boolean" && ((_stream$req = stream3.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) === undefined;
      }
      function willEmitClose(stream3) {
        if (!isNodeStream(stream3))
          return null;
        let { _writableState: wState, _readableState: rState } = stream3, state = wState || rState;
        return !state && isServerResponse(stream3) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
      }
      function isDisturbed(stream3) {
        var _stream$kIsDisturbed;
        return !!(stream3 && ((_stream$kIsDisturbed = stream3[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined ? _stream$kIsDisturbed : stream3.readableDidRead || stream3.readableAborted));
      }
      function isErrored(stream3) {
        var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
        return !!(stream3 && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream3[kIsErrored]) !== null && _stream$kIsErrored !== undefined ? _stream$kIsErrored : stream3.readableErrored) !== null && _ref5 !== undefined ? _ref5 : stream3.writableErrored) !== null && _ref4 !== undefined ? _ref4 : (_stream$_readableStat3 = stream3._readableState) === null || _stream$_readableStat3 === undefined ? undefined : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined ? _ref3 : (_stream$_writableStat3 = stream3._writableState) === null || _stream$_writableStat3 === undefined ? undefined : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined ? _ref2 : (_stream$_readableStat4 = stream3._readableState) === null || _stream$_readableStat4 === undefined ? undefined : _stream$_readableStat4.errored) !== null && _ref !== undefined ? _ref : (_stream$_writableStat4 = stream3._writableState) === null || _stream$_writableStat4 === undefined ? undefined : _stream$_writableStat4.errored));
      }
      module2.exports = { isDestroyed, kIsDestroyed, isDisturbed, kIsDisturbed, isErrored, kIsErrored, isReadable, kIsReadable, kIsClosedPromise, kControllerErrorFunction, kIsWritable, isClosed, isDuplexNodeStream, isFinished, isIterable: isIterable2, isReadableNodeStream, isReadableStream, isReadableEnded, isReadableFinished, isReadableErrored, isNodeStream, isWebStream, isWritable, isWritableNodeStream, isWritableStream, isWritableEnded, isWritableFinished, isWritableErrored, isServerRequest, isServerResponse, willEmitClose, isTransformStream };
    });
    var require_end_of_stream = __commonJS2((exports2, module2) => {
      var process2 = require_process(), { AbortError: AbortError2, codes } = require_errors(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_STREAM_PREMATURE_CLOSE } = codes, { kEmptyObject, once: once5 } = require_util(), { validateAbortSignal: validateAbortSignal2, validateFunction, validateObject, validateBoolean: validateBoolean2 } = require_validators(), { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials(), { isClosed, isReadable, isReadableNodeStream, isReadableStream, isReadableFinished, isReadableErrored, isWritable, isWritableNodeStream, isWritableStream, isWritableFinished, isWritableErrored, isNodeStream, willEmitClose: _willEmitClose, kIsClosedPromise } = require_utils(), addAbortListener2;
      function isRequest3(stream3) {
        return stream3.setHeader && typeof stream3.abort === "function";
      }
      var nop = () => {};
      function eos(stream3, options, callback) {
        var _options$readable, _options$writable;
        if (arguments.length === 2)
          callback = options, options = kEmptyObject;
        else if (options == null)
          options = kEmptyObject;
        else
          validateObject(options, "options");
        if (validateFunction(callback, "callback"), validateAbortSignal2(options.signal, "options.signal"), callback = once5(callback), isReadableStream(stream3) || isWritableStream(stream3))
          return eosWeb(stream3, options, callback);
        if (!isNodeStream(stream3))
          throw new ERR_INVALID_ARG_TYPE3("stream", ["ReadableStream", "WritableStream", "Stream"], stream3);
        let readable = (_options$readable = options.readable) !== null && _options$readable !== undefined ? _options$readable : isReadableNodeStream(stream3), writable = (_options$writable = options.writable) !== null && _options$writable !== undefined ? _options$writable : isWritableNodeStream(stream3), wState = stream3._writableState, rState = stream3._readableState, onlegacyfinish = () => {
          if (!stream3.writable)
            onfinish();
        }, willEmitClose = _willEmitClose(stream3) && isReadableNodeStream(stream3) === readable && isWritableNodeStream(stream3) === writable, writableFinished = isWritableFinished(stream3, false), onfinish = () => {
          if (writableFinished = true, stream3.destroyed)
            willEmitClose = false;
          if (willEmitClose && (!stream3.readable || readable))
            return;
          if (!readable || readableFinished)
            callback.call(stream3);
        }, readableFinished = isReadableFinished(stream3, false), onend = () => {
          if (readableFinished = true, stream3.destroyed)
            willEmitClose = false;
          if (willEmitClose && (!stream3.writable || writable))
            return;
          if (!writable || writableFinished)
            callback.call(stream3);
        }, onerror = (err) => {
          callback.call(stream3, err);
        }, closed = isClosed(stream3), onclose = () => {
          closed = true;
          let errored = isWritableErrored(stream3) || isReadableErrored(stream3);
          if (errored && typeof errored !== "boolean")
            return callback.call(stream3, errored);
          if (readable && !readableFinished && isReadableNodeStream(stream3, true)) {
            if (!isReadableFinished(stream3, false))
              return callback.call(stream3, new ERR_STREAM_PREMATURE_CLOSE);
          }
          if (writable && !writableFinished) {
            if (!isWritableFinished(stream3, false))
              return callback.call(stream3, new ERR_STREAM_PREMATURE_CLOSE);
          }
          callback.call(stream3);
        }, onclosed = () => {
          closed = true;
          let errored = isWritableErrored(stream3) || isReadableErrored(stream3);
          if (errored && typeof errored !== "boolean")
            return callback.call(stream3, errored);
          callback.call(stream3);
        }, onrequest = () => {
          stream3.req.on("finish", onfinish);
        };
        if (isRequest3(stream3)) {
          if (stream3.on("complete", onfinish), !willEmitClose)
            stream3.on("abort", onclose);
          if (stream3.req)
            onrequest();
          else
            stream3.on("request", onrequest);
        } else if (writable && !wState)
          stream3.on("end", onlegacyfinish), stream3.on("close", onlegacyfinish);
        if (!willEmitClose && typeof stream3.aborted === "boolean")
          stream3.on("aborted", onclose);
        if (stream3.on("end", onend), stream3.on("finish", onfinish), options.error !== false)
          stream3.on("error", onerror);
        if (stream3.on("close", onclose), closed)
          process2.nextTick(onclose);
        else if (wState !== null && wState !== undefined && wState.errorEmitted || rState !== null && rState !== undefined && rState.errorEmitted) {
          if (!willEmitClose)
            process2.nextTick(onclosed);
        } else if (!readable && (!willEmitClose || isReadable(stream3)) && (writableFinished || isWritable(stream3) === false))
          process2.nextTick(onclosed);
        else if (!writable && (!willEmitClose || isWritable(stream3)) && (readableFinished || isReadable(stream3) === false))
          process2.nextTick(onclosed);
        else if (rState && stream3.req && stream3.aborted)
          process2.nextTick(onclosed);
        let cleanup = () => {
          if (callback = nop, stream3.removeListener("aborted", onclose), stream3.removeListener("complete", onfinish), stream3.removeListener("abort", onclose), stream3.removeListener("request", onrequest), stream3.req)
            stream3.req.removeListener("finish", onfinish);
          stream3.removeListener("end", onlegacyfinish), stream3.removeListener("close", onlegacyfinish), stream3.removeListener("finish", onfinish), stream3.removeListener("end", onend), stream3.removeListener("error", onerror), stream3.removeListener("close", onclose);
        };
        if (options.signal && !closed) {
          let abort = () => {
            let endCallback = callback;
            cleanup(), endCallback.call(stream3, new AbortError2(undefined, { cause: options.signal.reason }));
          };
          if (options.signal.aborted)
            process2.nextTick(abort);
          else {
            addAbortListener2 = addAbortListener2 || require_util().addAbortListener;
            let disposable = addAbortListener2(options.signal, abort), originalCallback = callback;
            callback = once5((...args2) => {
              disposable[SymbolDispose](), originalCallback.apply(stream3, args2);
            });
          }
        }
        return cleanup;
      }
      function eosWeb(stream3, options, callback) {
        let isAborted = false, abort = nop;
        if (options.signal)
          if (abort = () => {
            isAborted = true, callback.call(stream3, new AbortError2(undefined, { cause: options.signal.reason }));
          }, options.signal.aborted)
            process2.nextTick(abort);
          else {
            addAbortListener2 = addAbortListener2 || require_util().addAbortListener;
            let disposable = addAbortListener2(options.signal, abort), originalCallback = callback;
            callback = once5((...args2) => {
              disposable[SymbolDispose](), originalCallback.apply(stream3, args2);
            });
          }
        let resolverFn = (...args2) => {
          if (!isAborted)
            process2.nextTick(() => callback.apply(stream3, args2));
        };
        return PromisePrototypeThen(stream3[kIsClosedPromise].promise, resolverFn, resolverFn), nop;
      }
      function finished(stream3, opts) {
        var _opts;
        let autoCleanup = false;
        if (opts === null)
          opts = kEmptyObject;
        if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup)
          validateBoolean2(opts.cleanup, "cleanup"), autoCleanup = opts.cleanup;
        return new Promise2((resolve3, reject) => {
          let cleanup = eos(stream3, opts, (err) => {
            if (autoCleanup)
              cleanup();
            if (err)
              reject(err);
            else
              resolve3();
          });
        });
      }
      module2.exports = eos;
      module2.exports.finished = finished;
    });
    var require_destroy = __commonJS2((exports2, module2) => {
      var process2 = require_process(), { aggregateTwoErrors, codes: { ERR_MULTIPLE_CALLBACK }, AbortError: AbortError2 } = require_errors(), { Symbol: Symbol2 } = require_primordials(), { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils(), kDestroy = Symbol2("kDestroy"), kConstruct = Symbol2("kConstruct");
      function checkError(err, w, r) {
        if (err) {
          if (err.stack, w && !w.errored)
            w.errored = err;
          if (r && !r.errored)
            r.errored = err;
        }
      }
      function destroy(err, cb) {
        let r = this._readableState, w = this._writableState, s = w || r;
        if (w !== null && w !== undefined && w.destroyed || r !== null && r !== undefined && r.destroyed) {
          if (typeof cb === "function")
            cb();
          return this;
        }
        if (checkError(err, w, r), w)
          w.destroyed = true;
        if (r)
          r.destroyed = true;
        if (!s.constructed)
          this.once(kDestroy, function(er) {
            _destroy(this, aggregateTwoErrors(er, err), cb);
          });
        else
          _destroy(this, err, cb);
        return this;
      }
      function _destroy(self2, err, cb) {
        let called = false;
        function onDestroy(err2) {
          if (called)
            return;
          called = true;
          let { _readableState: r, _writableState: w } = self2;
          if (checkError(err2, w, r), w)
            w.closed = true;
          if (r)
            r.closed = true;
          if (typeof cb === "function")
            cb(err2);
          if (err2)
            process2.nextTick(emitErrorCloseNT, self2, err2);
          else
            process2.nextTick(emitCloseNT, self2);
        }
        try {
          self2._destroy(err || null, onDestroy);
        } catch (err2) {
          onDestroy(err2);
        }
      }
      function emitErrorCloseNT(self2, err) {
        emitErrorNT(self2, err), emitCloseNT(self2);
      }
      function emitCloseNT(self2) {
        let { _readableState: r, _writableState: w } = self2;
        if (w)
          w.closeEmitted = true;
        if (r)
          r.closeEmitted = true;
        if (w !== null && w !== undefined && w.emitClose || r !== null && r !== undefined && r.emitClose)
          self2.emit("close");
      }
      function emitErrorNT(self2, err) {
        let { _readableState: r, _writableState: w } = self2;
        if (w !== null && w !== undefined && w.errorEmitted || r !== null && r !== undefined && r.errorEmitted)
          return;
        if (w)
          w.errorEmitted = true;
        if (r)
          r.errorEmitted = true;
        self2.emit("error", err);
      }
      function undestroy() {
        let r = this._readableState, w = this._writableState;
        if (r)
          r.constructed = true, r.closed = false, r.closeEmitted = false, r.destroyed = false, r.errored = null, r.errorEmitted = false, r.reading = false, r.ended = r.readable === false, r.endEmitted = r.readable === false;
        if (w)
          w.constructed = true, w.destroyed = false, w.closed = false, w.closeEmitted = false, w.errored = null, w.errorEmitted = false, w.finalCalled = false, w.prefinished = false, w.ended = w.writable === false, w.ending = w.writable === false, w.finished = w.writable === false;
      }
      function errorOrDestroy(stream3, err, sync11) {
        let { _readableState: r, _writableState: w } = stream3;
        if (w !== null && w !== undefined && w.destroyed || r !== null && r !== undefined && r.destroyed)
          return this;
        if (r !== null && r !== undefined && r.autoDestroy || w !== null && w !== undefined && w.autoDestroy)
          stream3.destroy(err);
        else if (err) {
          if (err.stack, w && !w.errored)
            w.errored = err;
          if (r && !r.errored)
            r.errored = err;
          if (sync11)
            process2.nextTick(emitErrorNT, stream3, err);
          else
            emitErrorNT(stream3, err);
        }
      }
      function construct(stream3, cb) {
        if (typeof stream3._construct !== "function")
          return;
        let { _readableState: r, _writableState: w } = stream3;
        if (r)
          r.constructed = false;
        if (w)
          w.constructed = false;
        if (stream3.once(kConstruct, cb), stream3.listenerCount(kConstruct) > 1)
          return;
        process2.nextTick(constructNT, stream3);
      }
      function constructNT(stream3) {
        let called = false;
        function onConstruct(err) {
          if (called) {
            errorOrDestroy(stream3, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK);
            return;
          }
          called = true;
          let { _readableState: r, _writableState: w } = stream3, s = w || r;
          if (r)
            r.constructed = true;
          if (w)
            w.constructed = true;
          if (s.destroyed)
            stream3.emit(kDestroy, err);
          else if (err)
            errorOrDestroy(stream3, err, true);
          else
            process2.nextTick(emitConstructNT, stream3);
        }
        try {
          stream3._construct((err) => {
            process2.nextTick(onConstruct, err);
          });
        } catch (err) {
          process2.nextTick(onConstruct, err);
        }
      }
      function emitConstructNT(stream3) {
        stream3.emit(kConstruct);
      }
      function isRequest3(stream3) {
        return (stream3 === null || stream3 === undefined ? undefined : stream3.setHeader) && typeof stream3.abort === "function";
      }
      function emitCloseLegacy(stream3) {
        stream3.emit("close");
      }
      function emitErrorCloseLegacy(stream3, err) {
        stream3.emit("error", err), process2.nextTick(emitCloseLegacy, stream3);
      }
      function destroyer(stream3, err) {
        if (!stream3 || isDestroyed(stream3))
          return;
        if (!err && !isFinished(stream3))
          err = new AbortError2;
        if (isServerRequest(stream3))
          stream3.socket = null, stream3.destroy(err);
        else if (isRequest3(stream3))
          stream3.abort();
        else if (isRequest3(stream3.req))
          stream3.req.abort();
        else if (typeof stream3.destroy === "function")
          stream3.destroy(err);
        else if (typeof stream3.close === "function")
          stream3.close();
        else if (err)
          process2.nextTick(emitErrorCloseLegacy, stream3, err);
        else
          process2.nextTick(emitCloseLegacy, stream3);
        if (!stream3.destroyed)
          stream3[kIsDestroyed] = true;
      }
      module2.exports = { construct, destroyer, destroy, undestroy, errorOrDestroy };
    });
    var require_legacy = __commonJS2((exports2, module2) => {
      var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials(), { EventEmitter: EE } = (init_events(), __toCommonJS(exports_events));
      function Stream(opts) {
        EE.call(this, opts);
      }
      ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
      ObjectSetPrototypeOf(Stream, EE);
      Stream.prototype.pipe = function(dest, options) {
        let source = this;
        function ondata(chunk3) {
          if (dest.writable && dest.write(chunk3) === false && source.pause)
            source.pause();
        }
        source.on("data", ondata);
        function ondrain() {
          if (source.readable && source.resume)
            source.resume();
        }
        if (dest.on("drain", ondrain), !dest._isStdio && (!options || options.end !== false))
          source.on("end", onend), source.on("close", onclose);
        let didOnEnd = false;
        function onend() {
          if (didOnEnd)
            return;
          didOnEnd = true, dest.end();
        }
        function onclose() {
          if (didOnEnd)
            return;
          if (didOnEnd = true, typeof dest.destroy === "function")
            dest.destroy();
        }
        function onerror(er) {
          if (cleanup(), EE.listenerCount(this, "error") === 0)
            this.emit("error", er);
        }
        prependListener2(source, "error", onerror), prependListener2(dest, "error", onerror);
        function cleanup() {
          source.removeListener("data", ondata), dest.removeListener("drain", ondrain), source.removeListener("end", onend), source.removeListener("close", onclose), source.removeListener("error", onerror), dest.removeListener("error", onerror), source.removeListener("end", cleanup), source.removeListener("close", cleanup), dest.removeListener("close", cleanup);
        }
        return source.on("end", cleanup), source.on("close", cleanup), dest.on("close", cleanup), dest.emit("pipe", source), dest;
      };
      function prependListener2(emitter, event, fn2) {
        if (typeof emitter.prependListener === "function")
          return emitter.prependListener(event, fn2);
        if (!emitter._events || !emitter._events[event])
          emitter.on(event, fn2);
        else if (ArrayIsArray(emitter._events[event]))
          emitter._events[event].unshift(fn2);
        else
          emitter._events[event] = [fn2, emitter._events[event]];
      }
      module2.exports = { Stream, prependListener: prependListener2 };
    });
    var require_add_abort_signal = __commonJS2((exports2, module2) => {
      var { SymbolDispose } = require_primordials(), { AbortError: AbortError2, codes } = require_errors(), { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils(), eos = require_end_of_stream(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3 } = codes, addAbortListener2, validateAbortSignal2 = (signal, name) => {
        if (typeof signal !== "object" || !("aborted" in signal))
          throw new ERR_INVALID_ARG_TYPE3(name, "AbortSignal", signal);
      };
      module2.exports.addAbortSignal = function addAbortSignal(signal, stream3) {
        if (validateAbortSignal2(signal, "signal"), !isNodeStream(stream3) && !isWebStream(stream3))
          throw new ERR_INVALID_ARG_TYPE3("stream", ["ReadableStream", "WritableStream", "Stream"], stream3);
        return module2.exports.addAbortSignalNoValidate(signal, stream3);
      };
      module2.exports.addAbortSignalNoValidate = function(signal, stream3) {
        if (typeof signal !== "object" || !("aborted" in signal))
          return stream3;
        let onAbort = isNodeStream(stream3) ? () => {
          stream3.destroy(new AbortError2(undefined, { cause: signal.reason }));
        } : () => {
          stream3[kControllerErrorFunction](new AbortError2(undefined, { cause: signal.reason }));
        };
        if (signal.aborted)
          onAbort();
        else {
          addAbortListener2 = addAbortListener2 || require_util().addAbortListener;
          let disposable = addAbortListener2(signal, onAbort);
          eos(stream3, disposable[SymbolDispose]);
        }
        return stream3;
      };
    });
    var require_buffer_list = __commonJS2((exports2, module2) => {
      var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials(), { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer)), { inspect: inspect2 } = require_util();
      module2.exports = class BufferList {
        constructor() {
          this.head = null, this.tail = null, this.length = 0;
        }
        push(v) {
          let entry = { data: v, next: null };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry, ++this.length;
        }
        unshift(v) {
          let entry = { data: v, next: this.head };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry, ++this.length;
        }
        shift() {
          if (this.length === 0)
            return;
          let ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          return --this.length, ret;
        }
        clear() {
          this.head = this.tail = null, this.length = 0;
        }
        join(s) {
          if (this.length === 0)
            return "";
          let p = this.head, ret = "" + p.data;
          while ((p = p.next) !== null)
            ret += s + p.data;
          return ret;
        }
        concat(n) {
          if (this.length === 0)
            return Buffer3.alloc(0);
          let ret = Buffer3.allocUnsafe(n >>> 0), p = this.head, i2 = 0;
          while (p)
            TypedArrayPrototypeSet(ret, p.data, i2), i2 += p.data.length, p = p.next;
          return ret;
        }
        consume(n, hasStrings) {
          let data = this.head.data;
          if (n < data.length) {
            let slice2 = data.slice(0, n);
            return this.head.data = data.slice(n), slice2;
          }
          if (n === data.length)
            return this.shift();
          return hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        first() {
          return this.head.data;
        }
        *[SymbolIterator]() {
          for (let p = this.head;p; p = p.next)
            yield p.data;
        }
        _getString(n) {
          let ret = "", p = this.head, c = 0;
          do {
            let str = p.data;
            if (n > str.length)
              ret += str, n -= str.length;
            else {
              if (n === str.length)
                if (ret += str, ++c, p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              else
                ret += StringPrototypeSlice(str, 0, n), this.head = p, p.data = StringPrototypeSlice(str, n);
              break;
            }
            ++c;
          } while ((p = p.next) !== null);
          return this.length -= c, ret;
        }
        _getBuffer(n) {
          let ret = Buffer3.allocUnsafe(n), retLen = n, p = this.head, c = 0;
          do {
            let buf = p.data;
            if (n > buf.length)
              TypedArrayPrototypeSet(ret, buf, retLen - n), n -= buf.length;
            else {
              if (n === buf.length)
                if (TypedArrayPrototypeSet(ret, buf, retLen - n), ++c, p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              else
                TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n), this.head = p, p.data = buf.slice(n);
              break;
            }
            ++c;
          } while ((p = p.next) !== null);
          return this.length -= c, ret;
        }
        [Symbol.for("nodejs.util.inspect.custom")](_, options) {
          return inspect2(this, { ...options, depth: 0, customInspect: false });
        }
      };
    });
    var require_state = __commonJS2((exports2, module2) => {
      var { MathFloor, NumberIsInteger } = require_primordials(), { validateInteger } = require_validators(), { ERR_INVALID_ARG_VALUE } = require_errors().codes, defaultHighWaterMarkBytes = 16384, defaultHighWaterMarkObjectMode = 16;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getDefaultHighWaterMark(objectMode) {
        return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
      }
      function setDefaultHighWaterMark(objectMode, value) {
        if (validateInteger(value, "value", 0), objectMode)
          defaultHighWaterMarkObjectMode = value;
        else
          defaultHighWaterMarkBytes = value;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        let hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!NumberIsInteger(hwm) || hwm < 0) {
            let name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
            throw new ERR_INVALID_ARG_VALUE(name, hwm);
          }
          return MathFloor(hwm);
        }
        return getDefaultHighWaterMark(state.objectMode);
      }
      module2.exports = { getHighWaterMark, getDefaultHighWaterMark, setDefaultHighWaterMark };
    });
    var require_safe_buffer = __commonJS2((exports2, module2) => {
      /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
      var buffer4 = (init_buffer(), __toCommonJS(exports_buffer)), Buffer3 = buffer4.Buffer;
      function copyProps(src, dst) {
        for (var key in src)
          dst[key] = src[key];
      }
      if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow)
        module2.exports = buffer4;
      else
        copyProps(buffer4, exports2), exports2.Buffer = SafeBuffer;
      function SafeBuffer(arg, encodingOrOffset, length3) {
        return Buffer3(arg, encodingOrOffset, length3);
      }
      SafeBuffer.prototype = Object.create(Buffer3.prototype);
      copyProps(Buffer3, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length3) {
        if (typeof arg === "number")
          throw new TypeError("Argument must not be a number");
        return Buffer3(arg, encodingOrOffset, length3);
      };
      SafeBuffer.alloc = function(size13, fill2, encoding) {
        if (typeof size13 !== "number")
          throw new TypeError("Argument must be a number");
        var buf = Buffer3(size13);
        if (fill2 !== undefined)
          if (typeof encoding === "string")
            buf.fill(fill2, encoding);
          else
            buf.fill(fill2);
        else
          buf.fill(0);
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size13) {
        if (typeof size13 !== "number")
          throw new TypeError("Argument must be a number");
        return Buffer3(size13);
      };
      SafeBuffer.allocUnsafeSlow = function(size13) {
        if (typeof size13 !== "number")
          throw new TypeError("Argument must be a number");
        return buffer4.SlowBuffer(size13);
      };
    });
    var require_string_decoder = __commonJS2((exports2) => {
      var Buffer3 = require_safe_buffer().Buffer, isEncoding2 = Buffer3.isEncoding || function(encoding) {
        switch (encoding = "" + encoding, encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function _normalizeEncoding(enc) {
        if (!enc)
          return "utf8";
        var retried;
        while (true)
          switch (enc) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return enc;
            default:
              if (retried)
                return;
              enc = ("" + enc).toLowerCase(), retried = true;
          }
      }
      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding2 || !isEncoding2(enc)))
          throw new Error("Unknown encoding: " + enc);
        return nenc || enc;
      }
      exports2.StringDecoder = StringDecoder;
      function StringDecoder(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb;
        switch (this.encoding) {
          case "utf16le":
            this.text = utf16Text, this.end = utf16End, nb = 4;
            break;
          case "utf8":
            this.fillLast = utf8FillLast, nb = 4;
            break;
          case "base64":
            this.text = base64Text, this.end = base64End, nb = 3;
            break;
          default:
            this.write = simpleWrite, this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer3.allocUnsafe(nb);
      }
      StringDecoder.prototype.write = function(buf) {
        if (buf.length === 0)
          return "";
        var r, i2;
        if (this.lastNeed) {
          if (r = this.fillLast(buf), r === undefined)
            return "";
          i2 = this.lastNeed, this.lastNeed = 0;
        } else
          i2 = 0;
        if (i2 < buf.length)
          return r ? r + this.text(buf, i2) : this.text(buf, i2);
        return r || "";
      };
      StringDecoder.prototype.end = utf8End;
      StringDecoder.prototype.text = utf8Text;
      StringDecoder.prototype.fillLast = function(buf) {
        if (this.lastNeed <= buf.length)
          return buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length), this.lastNeed -= buf.length;
      };
      function utf8CheckByte(byte) {
        if (byte <= 127)
          return 0;
        else if (byte >> 5 === 6)
          return 2;
        else if (byte >> 4 === 14)
          return 3;
        else if (byte >> 3 === 30)
          return 4;
        return byte >> 6 === 2 ? -1 : -2;
      }
      function utf8CheckIncomplete(self2, buf, i2) {
        var j = buf.length - 1;
        if (j < i2)
          return 0;
        var nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0)
            self2.lastNeed = nb - 1;
          return nb;
        }
        if (--j < i2 || nb === -2)
          return 0;
        if (nb = utf8CheckByte(buf[j]), nb >= 0) {
          if (nb > 0)
            self2.lastNeed = nb - 2;
          return nb;
        }
        if (--j < i2 || nb === -2)
          return 0;
        if (nb = utf8CheckByte(buf[j]), nb >= 0) {
          if (nb > 0)
            if (nb === 2)
              nb = 0;
            else
              self2.lastNeed = nb - 3;
          return nb;
        }
        return 0;
      }
      function utf8CheckExtraBytes(self2, buf, p) {
        if ((buf[0] & 192) !== 128)
          return self2.lastNeed = 0, "";
        if (self2.lastNeed > 1 && buf.length > 1) {
          if ((buf[1] & 192) !== 128)
            return self2.lastNeed = 1, "";
          if (self2.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128)
              return self2.lastNeed = 2, "";
          }
        }
      }
      function utf8FillLast(buf) {
        var p = this.lastTotal - this.lastNeed, r = utf8CheckExtraBytes(this, buf, p);
        if (r !== undefined)
          return r;
        if (this.lastNeed <= buf.length)
          return buf.copy(this.lastChar, p, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        buf.copy(this.lastChar, p, 0, buf.length), this.lastNeed -= buf.length;
      }
      function utf8Text(buf, i2) {
        var total = utf8CheckIncomplete(this, buf, i2);
        if (!this.lastNeed)
          return buf.toString("utf8", i2);
        this.lastTotal = total;
        var end6 = buf.length - (total - this.lastNeed);
        return buf.copy(this.lastChar, 0, end6), buf.toString("utf8", i2, end6);
      }
      function utf8End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed)
          return r + "";
        return r;
      }
      function utf16Text(buf, i2) {
        if ((buf.length - i2) % 2 === 0) {
          var r = buf.toString("utf16le", i2);
          if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 55296 && c <= 56319)
              return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1], r.slice(0, -1);
          }
          return r;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = buf[buf.length - 1], buf.toString("utf16le", i2, buf.length - 1);
      }
      function utf16End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) {
          var end6 = this.lastTotal - this.lastNeed;
          return r + this.lastChar.toString("utf16le", 0, end6);
        }
        return r;
      }
      function base64Text(buf, i2) {
        var n = (buf.length - i2) % 3;
        if (n === 0)
          return buf.toString("base64", i2);
        if (this.lastNeed = 3 - n, this.lastTotal = 3, n === 1)
          this.lastChar[0] = buf[buf.length - 1];
        else
          this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1];
        return buf.toString("base64", i2, buf.length - n);
      }
      function base64End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed)
          return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
        return r;
      }
      function simpleWrite(buf) {
        return buf.toString(this.encoding);
      }
      function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : "";
      }
    });
    var require_from = __commonJS2((exports2, module2) => {
      var process2 = require_process(), { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials(), { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer)), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_STREAM_NULL_VALUES } = require_errors().codes;
      function from2(Readable, iterable, opts) {
        let iterator;
        if (typeof iterable === "string" || iterable instanceof Buffer3)
          return new Readable({ objectMode: true, ...opts, read() {
            this.push(iterable), this.push(null);
          } });
        let isAsync;
        if (iterable && iterable[SymbolAsyncIterator])
          isAsync = true, iterator = iterable[SymbolAsyncIterator]();
        else if (iterable && iterable[SymbolIterator])
          isAsync = false, iterator = iterable[SymbolIterator]();
        else
          throw new ERR_INVALID_ARG_TYPE3("iterable", ["Iterable"], iterable);
        let readable = new Readable({ objectMode: true, highWaterMark: 1, ...opts }), reading = false;
        readable._read = function() {
          if (!reading)
            reading = true, next();
        }, readable._destroy = function(error, cb) {
          PromisePrototypeThen(close2(error), () => process2.nextTick(cb, error), (e) => process2.nextTick(cb, e || error));
        };
        async function close2(error) {
          let hadError = error !== undefined && error !== null, hasThrow = typeof iterator.throw === "function";
          if (hadError && hasThrow) {
            let { value, done: done11 } = await iterator.throw(error);
            if (await value, done11)
              return;
          }
          if (typeof iterator.return === "function") {
            let { value } = await iterator.return();
            await value;
          }
        }
        async function next() {
          for (;; ) {
            try {
              let { value, done: done11 } = isAsync ? await iterator.next() : iterator.next();
              if (done11)
                readable.push(null);
              else {
                let res = value && typeof value.then === "function" ? await value : value;
                if (res === null)
                  throw reading = false, new ERR_STREAM_NULL_VALUES;
                else if (readable.push(res))
                  continue;
                else
                  reading = false;
              }
            } catch (err) {
              readable.destroy(err);
            }
            break;
          }
        }
        return readable;
      }
      module2.exports = from2;
    });
    var require_readable = __commonJS2((exports2, module2) => {
      var process2 = require_process(), { ArrayPrototypeIndexOf, NumberIsInteger, NumberIsNaN, NumberParseInt, ObjectDefineProperties, ObjectKeys, ObjectSetPrototypeOf, Promise: Promise2, SafeSet, SymbolAsyncDispose, SymbolAsyncIterator, Symbol: Symbol2 } = require_primordials();
      module2.exports = Readable;
      Readable.ReadableState = ReadableState;
      var { EventEmitter: EE } = (init_events(), __toCommonJS(exports_events)), { Stream, prependListener: prependListener2 } = require_legacy(), { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer)), { addAbortSignal } = require_add_abort_signal(), eos = require_end_of_stream(), debug = require_util().debuglog("stream", (fn2) => {
        debug = fn2;
      }), BufferList = require_buffer_list(), destroyImpl = require_destroy(), { getHighWaterMark, getDefaultHighWaterMark } = require_state(), { aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_METHOD_NOT_IMPLEMENTED, ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE3, ERR_STREAM_PUSH_AFTER_EOF, ERR_STREAM_UNSHIFT_AFTER_END_EVENT }, AbortError: AbortError2 } = require_errors(), { validateObject } = require_validators(), kPaused = Symbol2("kPaused"), { StringDecoder } = require_string_decoder(), from2 = require_from();
      ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
      ObjectSetPrototypeOf(Readable, Stream);
      var nop = () => {}, { errorOrDestroy } = destroyImpl, kObjectMode = 1, kEnded = 2, kEndEmitted = 4, kReading = 8, kConstructed = 16, kSync = 32, kNeedReadable = 64, kEmittedReadable = 128, kReadableListening = 256, kResumeScheduled = 512, kErrorEmitted = 1024, kEmitClose = 2048, kAutoDestroy = 4096, kDestroyed = 8192, kClosed = 16384, kCloseEmitted = 32768, kMultiAwaitDrain = 65536, kReadingMore = 131072, kDataEmitted = 262144;
      function makeBitMapDescriptor(bit) {
        return { enumerable: false, get() {
          return (this.state & bit) !== 0;
        }, set(value) {
          if (value)
            this.state |= bit;
          else
            this.state &= ~bit;
        } };
      }
      ObjectDefineProperties(ReadableState.prototype, { objectMode: makeBitMapDescriptor(kObjectMode), ended: makeBitMapDescriptor(kEnded), endEmitted: makeBitMapDescriptor(kEndEmitted), reading: makeBitMapDescriptor(kReading), constructed: makeBitMapDescriptor(kConstructed), sync: makeBitMapDescriptor(kSync), needReadable: makeBitMapDescriptor(kNeedReadable), emittedReadable: makeBitMapDescriptor(kEmittedReadable), readableListening: makeBitMapDescriptor(kReadableListening), resumeScheduled: makeBitMapDescriptor(kResumeScheduled), errorEmitted: makeBitMapDescriptor(kErrorEmitted), emitClose: makeBitMapDescriptor(kEmitClose), autoDestroy: makeBitMapDescriptor(kAutoDestroy), destroyed: makeBitMapDescriptor(kDestroyed), closed: makeBitMapDescriptor(kClosed), closeEmitted: makeBitMapDescriptor(kCloseEmitted), multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain), readingMore: makeBitMapDescriptor(kReadingMore), dataEmitted: makeBitMapDescriptor(kDataEmitted) });
      function ReadableState(options, stream3, isDuplex) {
        if (typeof isDuplex !== "boolean")
          isDuplex = stream3 instanceof require_duplex();
        if (this.state = kEmitClose | kAutoDestroy | kConstructed | kSync, options && options.objectMode)
          this.state |= kObjectMode;
        if (isDuplex && options && options.readableObjectMode)
          this.state |= kObjectMode;
        if (this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false), this.buffer = new BufferList, this.length = 0, this.pipes = [], this.flowing = null, this[kPaused] = null, options && options.emitClose === false)
          this.state &= ~kEmitClose;
        if (options && options.autoDestroy === false)
          this.state &= ~kAutoDestroy;
        if (this.errored = null, this.defaultEncoding = options && options.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, options && options.encoding)
          this.decoder = new StringDecoder(options.encoding), this.encoding = options.encoding;
      }
      function Readable(options) {
        if (!(this instanceof Readable))
          return new Readable(options);
        let isDuplex = this instanceof require_duplex();
        if (this._readableState = new ReadableState(options, this, isDuplex), options) {
          if (typeof options.read === "function")
            this._read = options.read;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.construct === "function")
            this._construct = options.construct;
          if (options.signal && !isDuplex)
            addAbortSignal(options.signal, this);
        }
        Stream.call(this, options), destroyImpl.construct(this, () => {
          if (this._readableState.needReadable)
            maybeReadMore(this, this._readableState);
        });
      }
      Readable.prototype.destroy = destroyImpl.destroy;
      Readable.prototype._undestroy = destroyImpl.undestroy;
      Readable.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Readable.prototype[EE.captureRejectionSymbol] = function(err) {
        this.destroy(err);
      };
      Readable.prototype[SymbolAsyncDispose] = function() {
        let error;
        if (!this.destroyed)
          error = this.readableEnded ? null : new AbortError2, this.destroy(error);
        return new Promise2((resolve3, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve3(null)));
      };
      Readable.prototype.push = function(chunk3, encoding) {
        return readableAddChunk(this, chunk3, encoding, false);
      };
      Readable.prototype.unshift = function(chunk3, encoding) {
        return readableAddChunk(this, chunk3, encoding, true);
      };
      function readableAddChunk(stream3, chunk3, encoding, addToFront) {
        debug("readableAddChunk", chunk3);
        let state = stream3._readableState, err;
        if ((state.state & kObjectMode) === 0) {
          if (typeof chunk3 === "string") {
            if (encoding = encoding || state.defaultEncoding, state.encoding !== encoding)
              if (addToFront && state.encoding)
                chunk3 = Buffer3.from(chunk3, encoding).toString(state.encoding);
              else
                chunk3 = Buffer3.from(chunk3, encoding), encoding = "";
          } else if (chunk3 instanceof Buffer3)
            encoding = "";
          else if (Stream._isUint8Array(chunk3))
            chunk3 = Stream._uint8ArrayToBuffer(chunk3), encoding = "";
          else if (chunk3 != null)
            err = new ERR_INVALID_ARG_TYPE3("chunk", ["string", "Buffer", "Uint8Array"], chunk3);
        }
        if (err)
          errorOrDestroy(stream3, err);
        else if (chunk3 === null)
          state.state &= ~kReading, onEofChunk(stream3, state);
        else if ((state.state & kObjectMode) !== 0 || chunk3 && chunk3.length > 0)
          if (addToFront)
            if ((state.state & kEndEmitted) !== 0)
              errorOrDestroy(stream3, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
            else if (state.destroyed || state.errored)
              return false;
            else
              addChunk(stream3, state, chunk3, true);
          else if (state.ended)
            errorOrDestroy(stream3, new ERR_STREAM_PUSH_AFTER_EOF);
          else if (state.destroyed || state.errored)
            return false;
          else if (state.state &= ~kReading, state.decoder && !encoding)
            if (chunk3 = state.decoder.write(chunk3), state.objectMode || chunk3.length !== 0)
              addChunk(stream3, state, chunk3, false);
            else
              maybeReadMore(stream3, state);
          else
            addChunk(stream3, state, chunk3, false);
        else if (!addToFront)
          state.state &= ~kReading, maybeReadMore(stream3, state);
        return !state.ended && (state.length < state.highWaterMark || state.length === 0);
      }
      function addChunk(stream3, state, chunk3, addToFront) {
        if (state.flowing && state.length === 0 && !state.sync && stream3.listenerCount("data") > 0) {
          if ((state.state & kMultiAwaitDrain) !== 0)
            state.awaitDrainWriters.clear();
          else
            state.awaitDrainWriters = null;
          state.dataEmitted = true, stream3.emit("data", chunk3);
        } else {
          if (state.length += state.objectMode ? 1 : chunk3.length, addToFront)
            state.buffer.unshift(chunk3);
          else
            state.buffer.push(chunk3);
          if ((state.state & kNeedReadable) !== 0)
            emitReadable(stream3);
        }
        maybeReadMore(stream3, state);
      }
      Readable.prototype.isPaused = function() {
        let state = this._readableState;
        return state[kPaused] === true || state.flowing === false;
      };
      Readable.prototype.setEncoding = function(enc) {
        let decoder = new StringDecoder(enc);
        this._readableState.decoder = decoder, this._readableState.encoding = this._readableState.decoder.encoding;
        let buffer4 = this._readableState.buffer, content = "";
        for (let data of buffer4)
          content += decoder.write(data);
        if (buffer4.clear(), content !== "")
          buffer4.push(content);
        return this._readableState.length = content.length, this;
      };
      var MAX_HWM = 1073741824;
      function computeNewHighWaterMark(n) {
        if (n > MAX_HWM)
          throw new ERR_OUT_OF_RANGE3("size", "<= 1GiB", n);
        else
          n--, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, n |= n >>> 8, n |= n >>> 16, n++;
        return n;
      }
      function howMuchToRead(n, state) {
        if (n <= 0 || state.length === 0 && state.ended)
          return 0;
        if ((state.state & kObjectMode) !== 0)
          return 1;
        if (NumberIsNaN(n)) {
          if (state.flowing && state.length)
            return state.buffer.first().length;
          return state.length;
        }
        if (n <= state.length)
          return n;
        return state.ended ? state.length : 0;
      }
      Readable.prototype.read = function(n) {
        if (debug("read", n), n === undefined)
          n = NaN;
        else if (!NumberIsInteger(n))
          n = NumberParseInt(n, 10);
        let state = this._readableState, nOrig = n;
        if (n > state.highWaterMark)
          state.highWaterMark = computeNewHighWaterMark(n);
        if (n !== 0)
          state.state &= ~kEmittedReadable;
        if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
          if (debug("read: emitReadable", state.length, state.ended), state.length === 0 && state.ended)
            endReadable(this);
          else
            emitReadable(this);
          return null;
        }
        if (n = howMuchToRead(n, state), n === 0 && state.ended) {
          if (state.length === 0)
            endReadable(this);
          return null;
        }
        let doRead = (state.state & kNeedReadable) !== 0;
        if (debug("need readable", doRead), state.length === 0 || state.length - n < state.highWaterMark)
          doRead = true, debug("length less than watermark", doRead);
        if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed)
          doRead = false, debug("reading, ended or constructing", doRead);
        else if (doRead) {
          if (debug("do read"), state.state |= kReading | kSync, state.length === 0)
            state.state |= kNeedReadable;
          try {
            this._read(state.highWaterMark);
          } catch (err) {
            errorOrDestroy(this, err);
          }
          if (state.state &= ~kSync, !state.reading)
            n = howMuchToRead(nOrig, state);
        }
        let ret;
        if (n > 0)
          ret = fromList(n, state);
        else
          ret = null;
        if (ret === null)
          state.needReadable = state.length <= state.highWaterMark, n = 0;
        else if (state.length -= n, state.multiAwaitDrain)
          state.awaitDrainWriters.clear();
        else
          state.awaitDrainWriters = null;
        if (state.length === 0) {
          if (!state.ended)
            state.needReadable = true;
          if (nOrig !== n && state.ended)
            endReadable(this);
        }
        if (ret !== null && !state.errorEmitted && !state.closeEmitted)
          state.dataEmitted = true, this.emit("data", ret);
        return ret;
      };
      function onEofChunk(stream3, state) {
        if (debug("onEofChunk"), state.ended)
          return;
        if (state.decoder) {
          let chunk3 = state.decoder.end();
          if (chunk3 && chunk3.length)
            state.buffer.push(chunk3), state.length += state.objectMode ? 1 : chunk3.length;
        }
        if (state.ended = true, state.sync)
          emitReadable(stream3);
        else
          state.needReadable = false, state.emittedReadable = true, emitReadable_(stream3);
      }
      function emitReadable(stream3) {
        let state = stream3._readableState;
        if (debug("emitReadable", state.needReadable, state.emittedReadable), state.needReadable = false, !state.emittedReadable)
          debug("emitReadable", state.flowing), state.emittedReadable = true, process2.nextTick(emitReadable_, stream3);
      }
      function emitReadable_(stream3) {
        let state = stream3._readableState;
        if (debug("emitReadable_", state.destroyed, state.length, state.ended), !state.destroyed && !state.errored && (state.length || state.ended))
          stream3.emit("readable"), state.emittedReadable = false;
        state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark, flow2(stream3);
      }
      function maybeReadMore(stream3, state) {
        if (!state.readingMore && state.constructed)
          state.readingMore = true, process2.nextTick(maybeReadMore_, stream3, state);
      }
      function maybeReadMore_(stream3, state) {
        while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
          let len2 = state.length;
          if (debug("maybeReadMore read 0"), stream3.read(0), len2 === state.length)
            break;
        }
        state.readingMore = false;
      }
      Readable.prototype._read = function(n) {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
      };
      Readable.prototype.pipe = function(dest, pipeOpts) {
        let src = this, state = this._readableState;
        if (state.pipes.length === 1) {
          if (!state.multiAwaitDrain)
            state.multiAwaitDrain = true, state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
        }
        state.pipes.push(dest), debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
        let endFn = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr ? onend : unpipe;
        if (state.endEmitted)
          process2.nextTick(endFn);
        else
          src.once("end", endFn);
        dest.on("unpipe", onunpipe);
        function onunpipe(readable, unpipeInfo) {
          if (debug("onunpipe"), readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false)
              unpipeInfo.hasUnpiped = true, cleanup();
          }
        }
        function onend() {
          debug("onend"), dest.end();
        }
        let ondrain, cleanedUp = false;
        function cleanup() {
          if (debug("cleanup"), dest.removeListener("close", onclose), dest.removeListener("finish", onfinish), ondrain)
            dest.removeListener("drain", ondrain);
          if (dest.removeListener("error", onerror), dest.removeListener("unpipe", onunpipe), src.removeListener("end", onend), src.removeListener("end", unpipe), src.removeListener("data", ondata), cleanedUp = true, ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
        }
        function pause() {
          if (!cleanedUp) {
            if (state.pipes.length === 1 && state.pipes[0] === dest)
              debug("false write response, pause", 0), state.awaitDrainWriters = dest, state.multiAwaitDrain = false;
            else if (state.pipes.length > 1 && state.pipes.includes(dest))
              debug("false write response, pause", state.awaitDrainWriters.size), state.awaitDrainWriters.add(dest);
            src.pause();
          }
          if (!ondrain)
            ondrain = pipeOnDrain(src, dest), dest.on("drain", ondrain);
        }
        src.on("data", ondata);
        function ondata(chunk3) {
          debug("ondata");
          let ret = dest.write(chunk3);
          if (debug("dest.write", ret), ret === false)
            pause();
        }
        function onerror(er) {
          if (debug("onerror", er), unpipe(), dest.removeListener("error", onerror), dest.listenerCount("error") === 0) {
            let s = dest._writableState || dest._readableState;
            if (s && !s.errorEmitted)
              errorOrDestroy(dest, er);
            else
              dest.emit("error", er);
          }
        }
        prependListener2(dest, "error", onerror);
        function onclose() {
          dest.removeListener("finish", onfinish), unpipe();
        }
        dest.once("close", onclose);
        function onfinish() {
          debug("onfinish"), dest.removeListener("close", onclose), unpipe();
        }
        dest.once("finish", onfinish);
        function unpipe() {
          debug("unpipe"), src.unpipe(dest);
        }
        if (dest.emit("pipe", src), dest.writableNeedDrain === true)
          pause();
        else if (!state.flowing)
          debug("pipe resume"), src.resume();
        return dest;
      };
      function pipeOnDrain(src, dest) {
        return function pipeOnDrainFunctionResult() {
          let state = src._readableState;
          if (state.awaitDrainWriters === dest)
            debug("pipeOnDrain", 1), state.awaitDrainWriters = null;
          else if (state.multiAwaitDrain)
            debug("pipeOnDrain", state.awaitDrainWriters.size), state.awaitDrainWriters.delete(dest);
          if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data"))
            src.resume();
        };
      }
      Readable.prototype.unpipe = function(dest) {
        let state = this._readableState, unpipeInfo = { hasUnpiped: false };
        if (state.pipes.length === 0)
          return this;
        if (!dest) {
          let dests = state.pipes;
          state.pipes = [], this.pause();
          for (let i2 = 0;i2 < dests.length; i2++)
            dests[i2].emit("unpipe", this, { hasUnpiped: false });
          return this;
        }
        let index = ArrayPrototypeIndexOf(state.pipes, dest);
        if (index === -1)
          return this;
        if (state.pipes.splice(index, 1), state.pipes.length === 0)
          this.pause();
        return dest.emit("unpipe", this, unpipeInfo), this;
      };
      Readable.prototype.on = function(ev, fn2) {
        let res = Stream.prototype.on.call(this, ev, fn2), state = this._readableState;
        if (ev === "data") {
          if (state.readableListening = this.listenerCount("readable") > 0, state.flowing !== false)
            this.resume();
        } else if (ev === "readable") {
          if (!state.endEmitted && !state.readableListening) {
            if (state.readableListening = state.needReadable = true, state.flowing = false, state.emittedReadable = false, debug("on readable", state.length, state.reading), state.length)
              emitReadable(this);
            else if (!state.reading)
              process2.nextTick(nReadingNextTick, this);
          }
        }
        return res;
      };
      Readable.prototype.addListener = Readable.prototype.on;
      Readable.prototype.removeListener = function(ev, fn2) {
        let res = Stream.prototype.removeListener.call(this, ev, fn2);
        if (ev === "readable")
          process2.nextTick(updateReadableListening, this);
        return res;
      };
      Readable.prototype.off = Readable.prototype.removeListener;
      Readable.prototype.removeAllListeners = function(ev) {
        let res = Stream.prototype.removeAllListeners.apply(this, arguments);
        if (ev === "readable" || ev === undefined)
          process2.nextTick(updateReadableListening, this);
        return res;
      };
      function updateReadableListening(self2) {
        let state = self2._readableState;
        if (state.readableListening = self2.listenerCount("readable") > 0, state.resumeScheduled && state[kPaused] === false)
          state.flowing = true;
        else if (self2.listenerCount("data") > 0)
          self2.resume();
        else if (!state.readableListening)
          state.flowing = null;
      }
      function nReadingNextTick(self2) {
        debug("readable nexttick read 0"), self2.read(0);
      }
      Readable.prototype.resume = function() {
        let state = this._readableState;
        if (!state.flowing)
          debug("resume"), state.flowing = !state.readableListening, resume2(this, state);
        return state[kPaused] = false, this;
      };
      function resume2(stream3, state) {
        if (!state.resumeScheduled)
          state.resumeScheduled = true, process2.nextTick(resume_, stream3, state);
      }
      function resume_(stream3, state) {
        if (debug("resume", state.reading), !state.reading)
          stream3.read(0);
        if (state.resumeScheduled = false, stream3.emit("resume"), flow2(stream3), state.flowing && !state.reading)
          stream3.read(0);
      }
      Readable.prototype.pause = function() {
        if (debug("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false)
          debug("pause"), this._readableState.flowing = false, this.emit("pause");
        return this._readableState[kPaused] = true, this;
      };
      function flow2(stream3) {
        let state = stream3._readableState;
        debug("flow", state.flowing);
        while (state.flowing && stream3.read() !== null)
          ;
      }
      Readable.prototype.wrap = function(stream3) {
        let paused = false;
        stream3.on("data", (chunk3) => {
          if (!this.push(chunk3) && stream3.pause)
            paused = true, stream3.pause();
        }), stream3.on("end", () => {
          this.push(null);
        }), stream3.on("error", (err) => {
          errorOrDestroy(this, err);
        }), stream3.on("close", () => {
          this.destroy();
        }), stream3.on("destroy", () => {
          this.destroy();
        }), this._read = () => {
          if (paused && stream3.resume)
            paused = false, stream3.resume();
        };
        let streamKeys = ObjectKeys(stream3);
        for (let j = 1;j < streamKeys.length; j++) {
          let i2 = streamKeys[j];
          if (this[i2] === undefined && typeof stream3[i2] === "function")
            this[i2] = stream3[i2].bind(stream3);
        }
        return this;
      };
      Readable.prototype[SymbolAsyncIterator] = function() {
        return streamToAsyncIterator(this);
      };
      Readable.prototype.iterator = function(options) {
        if (options !== undefined)
          validateObject(options, "options");
        return streamToAsyncIterator(this, options);
      };
      function streamToAsyncIterator(stream3, options) {
        if (typeof stream3.read !== "function")
          stream3 = Readable.wrap(stream3, { objectMode: true });
        let iter = createAsyncIterator(stream3, options);
        return iter.stream = stream3, iter;
      }
      async function* createAsyncIterator(stream3, options) {
        let callback = nop;
        function next(resolve3) {
          if (this === stream3)
            callback(), callback = nop;
          else
            callback = resolve3;
        }
        stream3.on("readable", next);
        let error, cleanup = eos(stream3, { writable: false }, (err) => {
          error = err ? aggregateTwoErrors(error, err) : null, callback(), callback = nop;
        });
        try {
          while (true) {
            let chunk3 = stream3.destroyed ? null : stream3.read();
            if (chunk3 !== null)
              yield chunk3;
            else if (error)
              throw error;
            else if (error === null)
              return;
            else
              await new Promise2(next);
          }
        } catch (err) {
          throw error = aggregateTwoErrors(error, err), error;
        } finally {
          if ((error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) && (error === undefined || stream3._readableState.autoDestroy))
            destroyImpl.destroyer(stream3, null);
          else
            stream3.off("readable", next), cleanup();
        }
      }
      ObjectDefineProperties(Readable.prototype, { readable: { __proto__: null, get() {
        let r = this._readableState;
        return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
      }, set(val) {
        if (this._readableState)
          this._readableState.readable = !!val;
      } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
        return this._readableState.dataEmitted;
      } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
        return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
        return this._readableState.highWaterMark;
      } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
        return this._readableState && this._readableState.buffer;
      } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
        return this._readableState.flowing;
      }, set: function(state) {
        if (this._readableState)
          this._readableState.flowing = state;
      } }, readableLength: { __proto__: null, enumerable: false, get() {
        return this._readableState.length;
      } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
        return this._readableState ? this._readableState.objectMode : false;
      } }, readableEncoding: { __proto__: null, enumerable: false, get() {
        return this._readableState ? this._readableState.encoding : null;
      } }, errored: { __proto__: null, enumerable: false, get() {
        return this._readableState ? this._readableState.errored : null;
      } }, closed: { __proto__: null, get() {
        return this._readableState ? this._readableState.closed : false;
      } }, destroyed: { __proto__: null, enumerable: false, get() {
        return this._readableState ? this._readableState.destroyed : false;
      }, set(value) {
        if (!this._readableState)
          return;
        this._readableState.destroyed = value;
      } }, readableEnded: { __proto__: null, enumerable: false, get() {
        return this._readableState ? this._readableState.endEmitted : false;
      } } });
      ObjectDefineProperties(ReadableState.prototype, { pipesCount: { __proto__: null, get() {
        return this.pipes.length;
      } }, paused: { __proto__: null, get() {
        return this[kPaused] !== false;
      }, set(value) {
        this[kPaused] = !!value;
      } } });
      Readable._fromList = fromList;
      function fromList(n, state) {
        if (state.length === 0)
          return null;
        let ret;
        if (state.objectMode)
          ret = state.buffer.shift();
        else if (!n || n >= state.length) {
          if (state.decoder)
            ret = state.buffer.join("");
          else if (state.buffer.length === 1)
            ret = state.buffer.first();
          else
            ret = state.buffer.concat(state.length);
          state.buffer.clear();
        } else
          ret = state.buffer.consume(n, state.decoder);
        return ret;
      }
      function endReadable(stream3) {
        let state = stream3._readableState;
        if (debug("endReadable", state.endEmitted), !state.endEmitted)
          state.ended = true, process2.nextTick(endReadableNT, state, stream3);
      }
      function endReadableNT(state, stream3) {
        if (debug("endReadableNT", state.endEmitted, state.length), !state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
          if (state.endEmitted = true, stream3.emit("end"), stream3.writable && stream3.allowHalfOpen === false)
            process2.nextTick(endWritableNT, stream3);
          else if (state.autoDestroy) {
            let wState = stream3._writableState;
            if (!wState || wState.autoDestroy && (wState.finished || wState.writable === false))
              stream3.destroy();
          }
        }
      }
      function endWritableNT(stream3) {
        if (stream3.writable && !stream3.writableEnded && !stream3.destroyed)
          stream3.end();
      }
      Readable.from = function(iterable, opts) {
        return from2(Readable, iterable, opts);
      };
      var webStreamsAdapters;
      function lazyWebStreams() {
        if (webStreamsAdapters === undefined)
          webStreamsAdapters = {};
        return webStreamsAdapters;
      }
      Readable.fromWeb = function(readableStream, options) {
        return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
      };
      Readable.toWeb = function(streamReadable, options) {
        return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
      };
      Readable.wrap = function(src, options) {
        var _ref, _src$readableObjectMo;
        return new Readable({ objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined ? _src$readableObjectMo : src.objectMode) !== null && _ref !== undefined ? _ref : true, ...options, destroy(err, callback) {
          destroyImpl.destroyer(src, err), callback(err);
        } }).wrap(src);
      };
    });
    var require_writable = __commonJS2((exports2, module2) => {
      var process2 = require_process(), { ArrayPrototypeSlice: ArrayPrototypeSlice2, Error: Error22, FunctionPrototypeSymbolHasInstance, ObjectDefineProperty, ObjectDefineProperties, ObjectSetPrototypeOf, StringPrototypeToLowerCase, Symbol: Symbol2, SymbolHasInstance } = require_primordials();
      module2.exports = Writable;
      Writable.WritableState = WritableState;
      var { EventEmitter: EE } = (init_events(), __toCommonJS(exports_events)), Stream = require_legacy().Stream, { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer)), destroyImpl = require_destroy(), { addAbortSignal } = require_add_abort_signal(), { getHighWaterMark, getDefaultHighWaterMark } = require_state(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED, ERR_STREAM_ALREADY_FINISHED, ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING } = require_errors().codes, { errorOrDestroy } = destroyImpl;
      ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
      ObjectSetPrototypeOf(Writable, Stream);
      function nop() {}
      var kOnFinished = Symbol2("kOnFinished");
      function WritableState(options, stream3, isDuplex) {
        if (typeof isDuplex !== "boolean")
          isDuplex = stream3 instanceof require_duplex();
        if (this.objectMode = !!(options && options.objectMode), isDuplex)
          this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
        this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
        let noDecode = !!(options && options.decodeStrings === false);
        this.decodeStrings = !noDecode, this.defaultEncoding = options && options.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = onwrite.bind(undefined, stream3), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, resetBuffer(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !options || options.emitClose !== false, this.autoDestroy = !options || options.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[kOnFinished] = [];
      }
      function resetBuffer(state) {
        state.buffered = [], state.bufferedIndex = 0, state.allBuffers = true, state.allNoop = true;
      }
      WritableState.prototype.getBuffer = function getBuffer() {
        return ArrayPrototypeSlice2(this.buffered, this.bufferedIndex);
      };
      ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", { __proto__: null, get() {
        return this.buffered.length - this.bufferedIndex;
      } });
      function Writable(options) {
        let isDuplex = this instanceof require_duplex();
        if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
          return new Writable(options);
        if (this._writableState = new WritableState(options, this, isDuplex), options) {
          if (typeof options.write === "function")
            this._write = options.write;
          if (typeof options.writev === "function")
            this._writev = options.writev;
          if (typeof options.destroy === "function")
            this._destroy = options.destroy;
          if (typeof options.final === "function")
            this._final = options.final;
          if (typeof options.construct === "function")
            this._construct = options.construct;
          if (options.signal)
            addAbortSignal(options.signal, this);
        }
        Stream.call(this, options), destroyImpl.construct(this, () => {
          let state = this._writableState;
          if (!state.writing)
            clearBuffer(this, state);
          finishMaybe(this, state);
        });
      }
      ObjectDefineProperty(Writable, SymbolHasInstance, { __proto__: null, value: function(object) {
        if (FunctionPrototypeSymbolHasInstance(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      } });
      Writable.prototype.pipe = function() {
        errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
      };
      function _write(stream3, chunk3, encoding, cb) {
        let state = stream3._writableState;
        if (typeof encoding === "function")
          cb = encoding, encoding = state.defaultEncoding;
        else {
          if (!encoding)
            encoding = state.defaultEncoding;
          else if (encoding !== "buffer" && !Buffer3.isEncoding(encoding))
            throw new ERR_UNKNOWN_ENCODING(encoding);
          if (typeof cb !== "function")
            cb = nop;
        }
        if (chunk3 === null)
          throw new ERR_STREAM_NULL_VALUES;
        else if (!state.objectMode)
          if (typeof chunk3 === "string") {
            if (state.decodeStrings !== false)
              chunk3 = Buffer3.from(chunk3, encoding), encoding = "buffer";
          } else if (chunk3 instanceof Buffer3)
            encoding = "buffer";
          else if (Stream._isUint8Array(chunk3))
            chunk3 = Stream._uint8ArrayToBuffer(chunk3), encoding = "buffer";
          else
            throw new ERR_INVALID_ARG_TYPE3("chunk", ["string", "Buffer", "Uint8Array"], chunk3);
        let err;
        if (state.ending)
          err = new ERR_STREAM_WRITE_AFTER_END;
        else if (state.destroyed)
          err = new ERR_STREAM_DESTROYED("write");
        if (err)
          return process2.nextTick(cb, err), errorOrDestroy(stream3, err, true), err;
        return state.pendingcb++, writeOrBuffer(stream3, state, chunk3, encoding, cb);
      }
      Writable.prototype.write = function(chunk3, encoding, cb) {
        return _write(this, chunk3, encoding, cb) === true;
      };
      Writable.prototype.cork = function() {
        this._writableState.corked++;
      };
      Writable.prototype.uncork = function() {
        let state = this._writableState;
        if (state.corked) {
          if (state.corked--, !state.writing)
            clearBuffer(this, state);
        }
      };
      Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
        if (typeof encoding === "string")
          encoding = StringPrototypeToLowerCase(encoding);
        if (!Buffer3.isEncoding(encoding))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        return this._writableState.defaultEncoding = encoding, this;
      };
      function writeOrBuffer(stream3, state, chunk3, encoding, callback) {
        let len2 = state.objectMode ? 1 : chunk3.length;
        state.length += len2;
        let ret = state.length < state.highWaterMark;
        if (!ret)
          state.needDrain = true;
        if (state.writing || state.corked || state.errored || !state.constructed) {
          if (state.buffered.push({ chunk: chunk3, encoding, callback }), state.allBuffers && encoding !== "buffer")
            state.allBuffers = false;
          if (state.allNoop && callback !== nop)
            state.allNoop = false;
        } else
          state.writelen = len2, state.writecb = callback, state.writing = true, state.sync = true, stream3._write(chunk3, encoding, state.onwrite), state.sync = false;
        return ret && !state.errored && !state.destroyed;
      }
      function doWrite(stream3, state, writev, len2, chunk3, encoding, cb) {
        if (state.writelen = len2, state.writecb = cb, state.writing = true, state.sync = true, state.destroyed)
          state.onwrite(new ERR_STREAM_DESTROYED("write"));
        else if (writev)
          stream3._writev(chunk3, state.onwrite);
        else
          stream3._write(chunk3, encoding, state.onwrite);
        state.sync = false;
      }
      function onwriteError(stream3, state, er, cb) {
        --state.pendingcb, cb(er), errorBuffer(state), errorOrDestroy(stream3, er);
      }
      function onwrite(stream3, er) {
        let state = stream3._writableState, sync11 = state.sync, cb = state.writecb;
        if (typeof cb !== "function") {
          errorOrDestroy(stream3, new ERR_MULTIPLE_CALLBACK);
          return;
        }
        if (state.writing = false, state.writecb = null, state.length -= state.writelen, state.writelen = 0, er) {
          if (er.stack, !state.errored)
            state.errored = er;
          if (stream3._readableState && !stream3._readableState.errored)
            stream3._readableState.errored = er;
          if (sync11)
            process2.nextTick(onwriteError, stream3, state, er, cb);
          else
            onwriteError(stream3, state, er, cb);
        } else {
          if (state.buffered.length > state.bufferedIndex)
            clearBuffer(stream3, state);
          if (sync11)
            if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb)
              state.afterWriteTickInfo.count++;
            else
              state.afterWriteTickInfo = { count: 1, cb, stream: stream3, state }, process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
          else
            afterWrite(stream3, state, 1, cb);
        }
      }
      function afterWriteTick({ stream: stream3, state, count: count3, cb }) {
        return state.afterWriteTickInfo = null, afterWrite(stream3, state, count3, cb);
      }
      function afterWrite(stream3, state, count3, cb) {
        if (!state.ending && !stream3.destroyed && state.length === 0 && state.needDrain)
          state.needDrain = false, stream3.emit("drain");
        while (count3-- > 0)
          state.pendingcb--, cb();
        if (state.destroyed)
          errorBuffer(state);
        finishMaybe(stream3, state);
      }
      function errorBuffer(state) {
        if (state.writing)
          return;
        for (let n = state.bufferedIndex;n < state.buffered.length; ++n) {
          var _state$errored;
          let { chunk: chunk3, callback } = state.buffered[n], len2 = state.objectMode ? 1 : chunk3.length;
          state.length -= len2, callback((_state$errored = state.errored) !== null && _state$errored !== undefined ? _state$errored : new ERR_STREAM_DESTROYED("write"));
        }
        let onfinishCallbacks = state[kOnFinished].splice(0);
        for (let i2 = 0;i2 < onfinishCallbacks.length; i2++) {
          var _state$errored2;
          onfinishCallbacks[i2]((_state$errored2 = state.errored) !== null && _state$errored2 !== undefined ? _state$errored2 : new ERR_STREAM_DESTROYED("end"));
        }
        resetBuffer(state);
      }
      function clearBuffer(stream3, state) {
        if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed)
          return;
        let { buffered, bufferedIndex, objectMode } = state, bufferedLength = buffered.length - bufferedIndex;
        if (!bufferedLength)
          return;
        let i2 = bufferedIndex;
        if (state.bufferProcessing = true, bufferedLength > 1 && stream3._writev) {
          state.pendingcb -= bufferedLength - 1;
          let callback = state.allNoop ? nop : (err) => {
            for (let n = i2;n < buffered.length; ++n)
              buffered[n].callback(err);
          }, chunks3 = state.allNoop && i2 === 0 ? buffered : ArrayPrototypeSlice2(buffered, i2);
          chunks3.allBuffers = state.allBuffers, doWrite(stream3, state, true, state.length, chunks3, "", callback), resetBuffer(state);
        } else {
          do {
            let { chunk: chunk3, encoding, callback } = buffered[i2];
            buffered[i2++] = null;
            let len2 = objectMode ? 1 : chunk3.length;
            doWrite(stream3, state, false, len2, chunk3, encoding, callback);
          } while (i2 < buffered.length && !state.writing);
          if (i2 === buffered.length)
            resetBuffer(state);
          else if (i2 > 256)
            buffered.splice(0, i2), state.bufferedIndex = 0;
          else
            state.bufferedIndex = i2;
        }
        state.bufferProcessing = false;
      }
      Writable.prototype._write = function(chunk3, encoding, cb) {
        if (this._writev)
          this._writev([{ chunk: chunk3, encoding }], cb);
        else
          throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      };
      Writable.prototype._writev = null;
      Writable.prototype.end = function(chunk3, encoding, cb) {
        let state = this._writableState;
        if (typeof chunk3 === "function")
          cb = chunk3, chunk3 = null, encoding = null;
        else if (typeof encoding === "function")
          cb = encoding, encoding = null;
        let err;
        if (chunk3 !== null && chunk3 !== undefined) {
          let ret = _write(this, chunk3, encoding);
          if (ret instanceof Error22)
            err = ret;
        }
        if (state.corked)
          state.corked = 1, this.uncork();
        if (err)
          ;
        else if (!state.errored && !state.ending)
          state.ending = true, finishMaybe(this, state, true), state.ended = true;
        else if (state.finished)
          err = new ERR_STREAM_ALREADY_FINISHED("end");
        else if (state.destroyed)
          err = new ERR_STREAM_DESTROYED("end");
        if (typeof cb === "function")
          if (err || state.finished)
            process2.nextTick(cb, err);
          else
            state[kOnFinished].push(cb);
        return this;
      };
      function needFinish(state) {
        return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
      }
      function callFinal(stream3, state) {
        let called = false;
        function onFinish(err) {
          if (called) {
            errorOrDestroy(stream3, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK());
            return;
          }
          if (called = true, state.pendingcb--, err) {
            let onfinishCallbacks = state[kOnFinished].splice(0);
            for (let i2 = 0;i2 < onfinishCallbacks.length; i2++)
              onfinishCallbacks[i2](err);
            errorOrDestroy(stream3, err, state.sync);
          } else if (needFinish(state))
            state.prefinished = true, stream3.emit("prefinish"), state.pendingcb++, process2.nextTick(finish, stream3, state);
        }
        state.sync = true, state.pendingcb++;
        try {
          stream3._final(onFinish);
        } catch (err) {
          onFinish(err);
        }
        state.sync = false;
      }
      function prefinish(stream3, state) {
        if (!state.prefinished && !state.finalCalled)
          if (typeof stream3._final === "function" && !state.destroyed)
            state.finalCalled = true, callFinal(stream3, state);
          else
            state.prefinished = true, stream3.emit("prefinish");
      }
      function finishMaybe(stream3, state, sync11) {
        if (needFinish(state)) {
          if (prefinish(stream3, state), state.pendingcb === 0) {
            if (sync11)
              state.pendingcb++, process2.nextTick((stream22, state2) => {
                if (needFinish(state2))
                  finish(stream22, state2);
                else
                  state2.pendingcb--;
              }, stream3, state);
            else if (needFinish(state))
              state.pendingcb++, finish(stream3, state);
          }
        }
      }
      function finish(stream3, state) {
        state.pendingcb--, state.finished = true;
        let onfinishCallbacks = state[kOnFinished].splice(0);
        for (let i2 = 0;i2 < onfinishCallbacks.length; i2++)
          onfinishCallbacks[i2]();
        if (stream3.emit("finish"), state.autoDestroy) {
          let rState = stream3._readableState;
          if (!rState || rState.autoDestroy && (rState.endEmitted || rState.readable === false))
            stream3.destroy();
        }
      }
      ObjectDefineProperties(Writable.prototype, { closed: { __proto__: null, get() {
        return this._writableState ? this._writableState.closed : false;
      } }, destroyed: { __proto__: null, get() {
        return this._writableState ? this._writableState.destroyed : false;
      }, set(value) {
        if (this._writableState)
          this._writableState.destroyed = value;
      } }, writable: { __proto__: null, get() {
        let w = this._writableState;
        return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
      }, set(val) {
        if (this._writableState)
          this._writableState.writable = !!val;
      } }, writableFinished: { __proto__: null, get() {
        return this._writableState ? this._writableState.finished : false;
      } }, writableObjectMode: { __proto__: null, get() {
        return this._writableState ? this._writableState.objectMode : false;
      } }, writableBuffer: { __proto__: null, get() {
        return this._writableState && this._writableState.getBuffer();
      } }, writableEnded: { __proto__: null, get() {
        return this._writableState ? this._writableState.ending : false;
      } }, writableNeedDrain: { __proto__: null, get() {
        let wState = this._writableState;
        if (!wState)
          return false;
        return !wState.destroyed && !wState.ending && wState.needDrain;
      } }, writableHighWaterMark: { __proto__: null, get() {
        return this._writableState && this._writableState.highWaterMark;
      } }, writableCorked: { __proto__: null, get() {
        return this._writableState ? this._writableState.corked : 0;
      } }, writableLength: { __proto__: null, get() {
        return this._writableState && this._writableState.length;
      } }, errored: { __proto__: null, enumerable: false, get() {
        return this._writableState ? this._writableState.errored : null;
      } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
        return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      } } });
      var destroy = destroyImpl.destroy;
      Writable.prototype.destroy = function(err, cb) {
        let state = this._writableState;
        if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length))
          process2.nextTick(errorBuffer, state);
        return destroy.call(this, err, cb), this;
      };
      Writable.prototype._undestroy = destroyImpl.undestroy;
      Writable.prototype._destroy = function(err, cb) {
        cb(err);
      };
      Writable.prototype[EE.captureRejectionSymbol] = function(err) {
        this.destroy(err);
      };
      var webStreamsAdapters;
      function lazyWebStreams() {
        if (webStreamsAdapters === undefined)
          webStreamsAdapters = {};
        return webStreamsAdapters;
      }
      Writable.fromWeb = function(writableStream, options) {
        return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
      };
      Writable.toWeb = function(streamWritable) {
        return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
      };
    });
    var require_duplexify = __commonJS2((exports2, module2) => {
      var process2 = require_process(), bufferModule = (init_buffer(), __toCommonJS(exports_buffer)), { isReadable, isWritable, isIterable: isIterable2, isNodeStream, isReadableNodeStream, isWritableNodeStream, isDuplexNodeStream, isReadableStream, isWritableStream } = require_utils(), eos = require_end_of_stream(), { AbortError: AbortError2, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_INVALID_RETURN_VALUE } } = require_errors(), { destroyer } = require_destroy(), Duplex = require_duplex(), Readable = require_readable(), Writable = require_writable(), { createDeferredPromise } = require_util(), from2 = require_from(), Blob3 = globalThis.Blob || bufferModule.Blob, isBlob = typeof Blob3 !== "undefined" ? function isBlob(b) {
        return b instanceof Blob3;
      } : function isBlob(b) {
        return false;
      }, AbortController2 = globalThis.AbortController || require_abort_controller().AbortController, { FunctionPrototypeCall } = require_primordials();

      class Duplexify extends Duplex {
        constructor(options) {
          super(options);
          if ((options === null || options === undefined ? undefined : options.readable) === false)
            this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true;
          if ((options === null || options === undefined ? undefined : options.writable) === false)
            this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true;
        }
      }
      module2.exports = function duplexify(body, name) {
        if (isDuplexNodeStream(body))
          return body;
        if (isReadableNodeStream(body))
          return _duplexify({ readable: body });
        if (isWritableNodeStream(body))
          return _duplexify({ writable: body });
        if (isNodeStream(body))
          return _duplexify({ writable: false, readable: false });
        if (isReadableStream(body))
          return _duplexify({ readable: Readable.fromWeb(body) });
        if (isWritableStream(body))
          return _duplexify({ writable: Writable.fromWeb(body) });
        if (typeof body === "function") {
          let { value, write: write4, final, destroy } = fromAsyncGen(body);
          if (isIterable2(value))
            return from2(Duplexify, value, { objectMode: true, write: write4, final, destroy });
          let then2 = value === null || value === undefined ? undefined : value.then;
          if (typeof then2 === "function") {
            let d, promise3 = FunctionPrototypeCall(then2, value, (val) => {
              if (val != null)
                throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
            }, (err) => {
              destroyer(d, err);
            });
            return d = new Duplexify({ objectMode: true, readable: false, write: write4, final(cb) {
              final(async () => {
                try {
                  await promise3, process2.nextTick(cb, null);
                } catch (err) {
                  process2.nextTick(cb, err);
                }
              });
            }, destroy });
          }
          throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
        }
        if (isBlob(body))
          return duplexify(body.arrayBuffer());
        if (isIterable2(body))
          return from2(Duplexify, body, { objectMode: true, writable: false });
        if (isReadableStream(body === null || body === undefined ? undefined : body.readable) && isWritableStream(body === null || body === undefined ? undefined : body.writable))
          return Duplexify.fromWeb(body);
        if (typeof (body === null || body === undefined ? undefined : body.writable) === "object" || typeof (body === null || body === undefined ? undefined : body.readable) === "object") {
          let readable = body !== null && body !== undefined && body.readable ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable) ? body === null || body === undefined ? undefined : body.readable : duplexify(body.readable) : undefined, writable = body !== null && body !== undefined && body.writable ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable) ? body === null || body === undefined ? undefined : body.writable : duplexify(body.writable) : undefined;
          return _duplexify({ readable, writable });
        }
        let then = body === null || body === undefined ? undefined : body.then;
        if (typeof then === "function") {
          let d;
          return FunctionPrototypeCall(then, body, (val) => {
            if (val != null)
              d.push(val);
            d.push(null);
          }, (err) => {
            destroyer(d, err);
          }), d = new Duplexify({ objectMode: true, writable: false, read() {} });
        }
        throw new ERR_INVALID_ARG_TYPE3(name, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], body);
      };
      function fromAsyncGen(fn2) {
        let { promise: promise3, resolve: resolve3 } = createDeferredPromise(), ac = new AbortController2, signal = ac.signal;
        return { value: fn2(async function* () {
          while (true) {
            let _promise = promise3;
            promise3 = null;
            let { chunk: chunk3, done: done11, cb } = await _promise;
            if (process2.nextTick(cb), done11)
              return;
            if (signal.aborted)
              throw new AbortError2(undefined, { cause: signal.reason });
            ({ promise: promise3, resolve: resolve3 } = createDeferredPromise()), yield chunk3;
          }
        }(), { signal }), write(chunk3, encoding, cb) {
          let _resolve = resolve3;
          resolve3 = null, _resolve({ chunk: chunk3, done: false, cb });
        }, final(cb) {
          let _resolve = resolve3;
          resolve3 = null, _resolve({ done: true, cb });
        }, destroy(err, cb) {
          ac.abort(), cb(err);
        } };
      }
      function _duplexify(pair) {
        let r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable, w = pair.writable, readable = !!isReadable(r), writable = !!isWritable(w), ondrain, onfinish, onreadable, onclose, d;
        function onfinished(err) {
          let cb = onclose;
          if (onclose = null, cb)
            cb(err);
          else if (err)
            d.destroy(err);
        }
        if (d = new Duplexify({ readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode), writableObjectMode: !!(w !== null && w !== undefined && w.writableObjectMode), readable, writable }), writable)
          eos(w, (err) => {
            if (writable = false, err)
              destroyer(r, err);
            onfinished(err);
          }), d._write = function(chunk3, encoding, callback) {
            if (w.write(chunk3, encoding))
              callback();
            else
              ondrain = callback;
          }, d._final = function(callback) {
            w.end(), onfinish = callback;
          }, w.on("drain", function() {
            if (ondrain) {
              let cb = ondrain;
              ondrain = null, cb();
            }
          }), w.on("finish", function() {
            if (onfinish) {
              let cb = onfinish;
              onfinish = null, cb();
            }
          });
        if (readable)
          eos(r, (err) => {
            if (readable = false, err)
              destroyer(r, err);
            onfinished(err);
          }), r.on("readable", function() {
            if (onreadable) {
              let cb = onreadable;
              onreadable = null, cb();
            }
          }), r.on("end", function() {
            d.push(null);
          }), d._read = function() {
            while (true) {
              let buf = r.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf))
                return;
            }
          };
        return d._destroy = function(err, callback) {
          if (!err && onclose !== null)
            err = new AbortError2;
          if (onreadable = null, ondrain = null, onfinish = null, onclose === null)
            callback(err);
          else
            onclose = callback, destroyer(w, err), destroyer(r, err);
        }, d;
      }
    });
    var require_duplex = __commonJS2((exports2, module2) => {
      var { ObjectDefineProperties, ObjectGetOwnPropertyDescriptor, ObjectKeys, ObjectSetPrototypeOf } = require_primordials();
      module2.exports = Duplex;
      var Readable = require_readable(), Writable = require_writable();
      ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
      ObjectSetPrototypeOf(Duplex, Readable);
      {
        let keys3 = ObjectKeys(Writable.prototype);
        for (let i2 = 0;i2 < keys3.length; i2++) {
          let method = keys3[i2];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        if (Readable.call(this, options), Writable.call(this, options), options) {
          if (this.allowHalfOpen = options.allowHalfOpen !== false, options.readable === false)
            this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true;
          if (options.writable === false)
            this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true;
        } else
          this.allowHalfOpen = true;
      }
      ObjectDefineProperties(Duplex.prototype, { writable: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength") }, writableFinished: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
        if (this._readableState === undefined || this._writableState === undefined)
          return false;
        return this._readableState.destroyed && this._writableState.destroyed;
      }, set(value) {
        if (this._readableState && this._writableState)
          this._readableState.destroyed = value, this._writableState.destroyed = value;
      } } });
      var webStreamsAdapters;
      function lazyWebStreams() {
        if (webStreamsAdapters === undefined)
          webStreamsAdapters = {};
        return webStreamsAdapters;
      }
      Duplex.fromWeb = function(pair, options) {
        return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
      };
      Duplex.toWeb = function(duplex) {
        return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
      };
      var duplexify;
      Duplex.from = function(body) {
        if (!duplexify)
          duplexify = require_duplexify();
        return duplexify(body, "body");
      };
    });
    var require_transform = __commonJS2((exports2, module2) => {
      var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
      module2.exports = Transform;
      var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes, Duplex = require_duplex(), { getHighWaterMark } = require_state();
      ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
      ObjectSetPrototypeOf(Transform, Duplex);
      var kCallback = Symbol2("kCallback");
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        let readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
        if (readableHighWaterMark === 0)
          options = { ...options, highWaterMark: null, readableHighWaterMark, writableHighWaterMark: options.writableHighWaterMark || 0 };
        if (Duplex.call(this, options), this._readableState.sync = false, this[kCallback] = null, options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function final(cb) {
        if (typeof this._flush === "function" && !this.destroyed)
          this._flush((er, data) => {
            if (er) {
              if (cb)
                cb(er);
              else
                this.destroy(er);
              return;
            }
            if (data != null)
              this.push(data);
            if (this.push(null), cb)
              cb();
          });
        else if (this.push(null), cb)
          cb();
      }
      function prefinish() {
        if (this._final !== final)
          final.call(this);
      }
      Transform.prototype._final = final;
      Transform.prototype._transform = function(chunk3, encoding, callback) {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
      };
      Transform.prototype._write = function(chunk3, encoding, callback) {
        let rState = this._readableState, wState = this._writableState, length3 = rState.length;
        this._transform(chunk3, encoding, (err, val) => {
          if (err) {
            callback(err);
            return;
          }
          if (val != null)
            this.push(val);
          if (wState.ended || length3 === rState.length || rState.length < rState.highWaterMark)
            callback();
          else
            this[kCallback] = callback;
        });
      };
      Transform.prototype._read = function() {
        if (this[kCallback]) {
          let callback = this[kCallback];
          this[kCallback] = null, callback();
        }
      };
    });
    var require_passthrough = __commonJS2((exports2, module2) => {
      var { ObjectSetPrototypeOf } = require_primordials();
      module2.exports = PassThrough;
      var Transform = require_transform();
      ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
      ObjectSetPrototypeOf(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk3, encoding, cb) {
        cb(null, chunk3);
      };
    });
    var require_pipeline = __commonJS2((exports2, module2) => {
      var process2 = require_process(), { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials(), eos = require_end_of_stream(), { once: once5 } = require_util(), destroyImpl = require_destroy(), Duplex = require_duplex(), { aggregateTwoErrors, codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_INVALID_RETURN_VALUE, ERR_MISSING_ARGS, ERR_STREAM_DESTROYED, ERR_STREAM_PREMATURE_CLOSE }, AbortError: AbortError2 } = require_errors(), { validateFunction, validateAbortSignal: validateAbortSignal2 } = require_validators(), { isIterable: isIterable2, isReadable, isReadableNodeStream, isNodeStream, isTransformStream, isWebStream, isReadableStream, isReadableFinished } = require_utils(), AbortController2 = globalThis.AbortController || require_abort_controller().AbortController, PassThrough, Readable, addAbortListener2;
      function destroyer(stream3, reading, writing) {
        let finished = false;
        stream3.on("close", () => {
          finished = true;
        });
        let cleanup = eos(stream3, { readable: reading, writable: writing }, (err) => {
          finished = !err;
        });
        return { destroy: (err) => {
          if (finished)
            return;
          finished = true, destroyImpl.destroyer(stream3, err || new ERR_STREAM_DESTROYED("pipe"));
        }, cleanup };
      }
      function popCallback(streams) {
        return validateFunction(streams[streams.length - 1], "streams[stream.length - 1]"), streams.pop();
      }
      function makeAsyncIterable(val) {
        if (isIterable2(val))
          return val;
        else if (isReadableNodeStream(val))
          return fromReadable(val);
        throw new ERR_INVALID_ARG_TYPE3("val", ["Readable", "Iterable", "AsyncIterable"], val);
      }
      async function* fromReadable(val) {
        if (!Readable)
          Readable = require_readable();
        yield* Readable.prototype[SymbolAsyncIterator].call(val);
      }
      async function pumpToNode(iterable, writable, finish, { end: end6 }) {
        let error, onresolve = null, resume2 = (err) => {
          if (err)
            error = err;
          if (onresolve) {
            let callback = onresolve;
            onresolve = null, callback();
          }
        }, wait = () => new Promise2((resolve3, reject) => {
          if (error)
            reject(error);
          else
            onresolve = () => {
              if (error)
                reject(error);
              else
                resolve3();
            };
        });
        writable.on("drain", resume2);
        let cleanup = eos(writable, { readable: false }, resume2);
        try {
          if (writable.writableNeedDrain)
            await wait();
          for await (let chunk3 of iterable)
            if (!writable.write(chunk3))
              await wait();
          if (end6)
            writable.end(), await wait();
          finish();
        } catch (err) {
          finish(error !== err ? aggregateTwoErrors(error, err) : err);
        } finally {
          cleanup(), writable.off("drain", resume2);
        }
      }
      async function pumpToWeb(readable, writable, finish, { end: end6 }) {
        if (isTransformStream(writable))
          writable = writable.writable;
        let writer = writable.getWriter();
        try {
          for await (let chunk3 of readable)
            await writer.ready, writer.write(chunk3).catch(() => {});
          if (await writer.ready, end6)
            await writer.close();
          finish();
        } catch (err) {
          try {
            await writer.abort(err), finish(err);
          } catch (err2) {
            finish(err2);
          }
        }
      }
      function pipeline(...streams) {
        return pipelineImpl(streams, once5(popCallback(streams)));
      }
      function pipelineImpl(streams, callback, opts) {
        if (streams.length === 1 && ArrayIsArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2)
          throw new ERR_MISSING_ARGS("streams");
        let ac = new AbortController2, signal = ac.signal, outerSignal = opts === null || opts === undefined ? undefined : opts.signal, lastStreamCleanup = [];
        validateAbortSignal2(outerSignal, "options.signal");
        function abort() {
          finishImpl(new AbortError2);
        }
        addAbortListener2 = addAbortListener2 || require_util().addAbortListener;
        let disposable;
        if (outerSignal)
          disposable = addAbortListener2(outerSignal, abort);
        let error, value, destroys = [], finishCount = 0;
        function finish(err) {
          finishImpl(err, --finishCount === 0);
        }
        function finishImpl(err, final) {
          var _disposable;
          if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE"))
            error = err;
          if (!error && !final)
            return;
          while (destroys.length)
            destroys.shift()(error);
          if ((_disposable = disposable) === null || _disposable === undefined || _disposable[SymbolDispose](), ac.abort(), final) {
            if (!error)
              lastStreamCleanup.forEach((fn2) => fn2());
            process2.nextTick(callback, error, value);
          }
        }
        let ret;
        for (let i2 = 0;i2 < streams.length; i2++) {
          let stream3 = streams[i2], reading = i2 < streams.length - 1, writing = i2 > 0, end6 = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false, isLastStream = i2 === streams.length - 1;
          if (isNodeStream(stream3)) {
            let onError22 = function(err) {
              if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE")
                finish(err);
            };
            var onError5 = onError22;
            if (end6) {
              let { destroy, cleanup } = destroyer(stream3, reading, writing);
              if (destroys.push(destroy), isReadable(stream3) && isLastStream)
                lastStreamCleanup.push(cleanup);
            }
            if (stream3.on("error", onError22), isReadable(stream3) && isLastStream)
              lastStreamCleanup.push(() => {
                stream3.removeListener("error", onError22);
              });
          }
          if (i2 === 0)
            if (typeof stream3 === "function") {
              if (ret = stream3({ signal }), !isIterable2(ret))
                throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            } else if (isIterable2(stream3) || isReadableNodeStream(stream3) || isTransformStream(stream3))
              ret = stream3;
            else
              ret = Duplex.from(stream3);
          else if (typeof stream3 === "function") {
            if (isTransformStream(ret)) {
              var _ret;
              ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable);
            } else
              ret = makeAsyncIterable(ret);
            if (ret = stream3(ret, { signal }), reading) {
              if (!isIterable2(ret, true))
                throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i2 - 1}]`, ret);
            } else {
              var _ret2;
              if (!PassThrough)
                PassThrough = require_passthrough();
              let pt = new PassThrough({ objectMode: true }), then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then;
              if (typeof then === "function")
                finishCount++, then.call(ret, (val) => {
                  if (value = val, val != null)
                    pt.write(val);
                  if (end6)
                    pt.end();
                  process2.nextTick(finish);
                }, (err) => {
                  pt.destroy(err), process2.nextTick(finish, err);
                });
              else if (isIterable2(ret, true))
                finishCount++, pumpToNode(ret, pt, finish, { end: end6 });
              else if (isReadableStream(ret) || isTransformStream(ret)) {
                let toRead = ret.readable || ret;
                finishCount++, pumpToNode(toRead, pt, finish, { end: end6 });
              } else
                throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
              ret = pt;
              let { destroy, cleanup } = destroyer(ret, false, true);
              if (destroys.push(destroy), isLastStream)
                lastStreamCleanup.push(cleanup);
            }
          } else if (isNodeStream(stream3)) {
            if (isReadableNodeStream(ret)) {
              finishCount += 2;
              let cleanup = pipe2(ret, stream3, finish, { end: end6 });
              if (isReadable(stream3) && isLastStream)
                lastStreamCleanup.push(cleanup);
            } else if (isTransformStream(ret) || isReadableStream(ret)) {
              let toRead = ret.readable || ret;
              finishCount++, pumpToNode(toRead, stream3, finish, { end: end6 });
            } else if (isIterable2(ret))
              finishCount++, pumpToNode(ret, stream3, finish, { end: end6 });
            else
              throw new ERR_INVALID_ARG_TYPE3("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
            ret = stream3;
          } else if (isWebStream(stream3)) {
            if (isReadableNodeStream(ret))
              finishCount++, pumpToWeb(makeAsyncIterable(ret), stream3, finish, { end: end6 });
            else if (isReadableStream(ret) || isIterable2(ret))
              finishCount++, pumpToWeb(ret, stream3, finish, { end: end6 });
            else if (isTransformStream(ret))
              finishCount++, pumpToWeb(ret.readable, stream3, finish, { end: end6 });
            else
              throw new ERR_INVALID_ARG_TYPE3("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
            ret = stream3;
          } else
            ret = Duplex.from(stream3);
        }
        if (signal !== null && signal !== undefined && signal.aborted || outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)
          process2.nextTick(abort);
        return ret;
      }
      function pipe2(src, dst, finish, { end: end6 }) {
        let ended = false;
        if (dst.on("close", () => {
          if (!ended)
            finish(new ERR_STREAM_PREMATURE_CLOSE);
        }), src.pipe(dst, { end: false }), end6) {
          let endFn2 = function() {
            ended = true, dst.end();
          };
          var endFn = endFn2;
          if (isReadableFinished(src))
            process2.nextTick(endFn2);
          else
            src.once("end", endFn2);
        } else
          finish();
        return eos(src, { readable: true, writable: false }, (err) => {
          let rState = src._readableState;
          if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted)
            src.once("end", finish).once("error", finish);
          else
            finish(err);
        }), eos(dst, { readable: false, writable: true }, finish);
      }
      module2.exports = { pipelineImpl, pipeline };
    });
    var require_compose = __commonJS2((exports2, module2) => {
      var { pipeline } = require_pipeline(), Duplex = require_duplex(), { destroyer } = require_destroy(), { isNodeStream, isReadable, isWritable, isWebStream, isTransformStream, isWritableStream, isReadableStream } = require_utils(), { AbortError: AbortError2, codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS } } = require_errors(), eos = require_end_of_stream();
      module2.exports = function compose(...streams) {
        if (streams.length === 0)
          throw new ERR_MISSING_ARGS("streams");
        if (streams.length === 1)
          return Duplex.from(streams[0]);
        let orgStreams = [...streams];
        if (typeof streams[0] === "function")
          streams[0] = Duplex.from(streams[0]);
        if (typeof streams[streams.length - 1] === "function") {
          let idx = streams.length - 1;
          streams[idx] = Duplex.from(streams[idx]);
        }
        for (let n = 0;n < streams.length; ++n) {
          if (!isNodeStream(streams[n]) && !isWebStream(streams[n]))
            continue;
          if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n])))
            throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
          if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n])))
            throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
        let ondrain, onfinish, onreadable, onclose, d;
        function onfinished(err) {
          let cb = onclose;
          if (onclose = null, cb)
            cb(err);
          else if (err)
            d.destroy(err);
          else if (!readable && !writable)
            d.destroy();
        }
        let head6 = streams[0], tail = pipeline(streams, onfinished), writable = !!(isWritable(head6) || isWritableStream(head6) || isTransformStream(head6)), readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
        if (d = new Duplex({ writableObjectMode: !!(head6 !== null && head6 !== undefined && head6.writableObjectMode), readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode), writable, readable }), writable) {
          if (isNodeStream(head6))
            d._write = function(chunk3, encoding, callback) {
              if (head6.write(chunk3, encoding))
                callback();
              else
                ondrain = callback;
            }, d._final = function(callback) {
              head6.end(), onfinish = callback;
            }, head6.on("drain", function() {
              if (ondrain) {
                let cb = ondrain;
                ondrain = null, cb();
              }
            });
          else if (isWebStream(head6)) {
            let writer = (isTransformStream(head6) ? head6.writable : head6).getWriter();
            d._write = async function(chunk3, encoding, callback) {
              try {
                await writer.ready, writer.write(chunk3).catch(() => {}), callback();
              } catch (err) {
                callback(err);
              }
            }, d._final = async function(callback) {
              try {
                await writer.ready, writer.close().catch(() => {}), onfinish = callback;
              } catch (err) {
                callback(err);
              }
            };
          }
          let toRead = isTransformStream(tail) ? tail.readable : tail;
          eos(toRead, () => {
            if (onfinish) {
              let cb = onfinish;
              onfinish = null, cb();
            }
          });
        }
        if (readable) {
          if (isNodeStream(tail))
            tail.on("readable", function() {
              if (onreadable) {
                let cb = onreadable;
                onreadable = null, cb();
              }
            }), tail.on("end", function() {
              d.push(null);
            }), d._read = function() {
              while (true) {
                let buf = tail.read();
                if (buf === null) {
                  onreadable = d._read;
                  return;
                }
                if (!d.push(buf))
                  return;
              }
            };
          else if (isWebStream(tail)) {
            let reader = (isTransformStream(tail) ? tail.readable : tail).getReader();
            d._read = async function() {
              while (true)
                try {
                  let { value, done: done11 } = await reader.read();
                  if (!d.push(value))
                    return;
                  if (done11) {
                    d.push(null);
                    return;
                  }
                } catch {
                  return;
                }
            };
          }
        }
        return d._destroy = function(err, callback) {
          if (!err && onclose !== null)
            err = new AbortError2;
          if (onreadable = null, ondrain = null, onfinish = null, onclose === null)
            callback(err);
          else if (onclose = callback, isNodeStream(tail))
            destroyer(tail, err);
        }, d;
      };
    });
    var require_operators = __commonJS2((exports2, module2) => {
      var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController, { codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE3, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE: ERR_OUT_OF_RANGE3 }, AbortError: AbortError2 } = require_errors(), { validateAbortSignal: validateAbortSignal2, validateInteger, validateObject } = require_validators(), kWeakHandler = require_primordials().Symbol("kWeak"), kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation"), { finished } = require_end_of_stream(), staticCompose = require_compose(), { addAbortSignalNoValidate } = require_add_abort_signal(), { isWritable, isNodeStream } = require_utils(), { deprecate } = require_util(), { ArrayPrototypePush, Boolean: Boolean2, MathFloor, Number: Number2, NumberIsNaN, Promise: Promise2, PromiseReject, PromiseResolve, PromisePrototypeThen, Symbol: Symbol2 } = require_primordials(), kEmpty = Symbol2("kEmpty"), kEof = Symbol2("kEof");
      function compose3(stream3, options) {
        if (options != null)
          validateObject(options, "options");
        if ((options === null || options === undefined ? undefined : options.signal) != null)
          validateAbortSignal2(options.signal, "options.signal");
        if (isNodeStream(stream3) && !isWritable(stream3))
          throw new ERR_INVALID_ARG_VALUE("stream", stream3, "must be writable");
        let composedStream = staticCompose(this, stream3);
        if (options !== null && options !== undefined && options.signal)
          addAbortSignalNoValidate(options.signal, composedStream);
        return composedStream;
      }
      function map24(fn2, options) {
        if (typeof fn2 !== "function")
          throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn2);
        if (options != null)
          validateObject(options, "options");
        if ((options === null || options === undefined ? undefined : options.signal) != null)
          validateAbortSignal2(options.signal, "options.signal");
        let concurrency = 1;
        if ((options === null || options === undefined ? undefined : options.concurrency) != null)
          concurrency = MathFloor(options.concurrency);
        let highWaterMark = concurrency - 1;
        if ((options === null || options === undefined ? undefined : options.highWaterMark) != null)
          highWaterMark = MathFloor(options.highWaterMark);
        return validateInteger(concurrency, "options.concurrency", 1), validateInteger(highWaterMark, "options.highWaterMark", 0), highWaterMark += concurrency, async function* map() {
          let signal = require_util().AbortSignalAny([options === null || options === undefined ? undefined : options.signal].filter(Boolean2)), stream3 = this, queue = [], signalOpt = { signal }, next, resume2, done11 = false, cnt = 0;
          function onCatch() {
            done11 = true, afterItemProcessed();
          }
          function afterItemProcessed() {
            cnt -= 1, maybeResume();
          }
          function maybeResume() {
            if (resume2 && !done11 && cnt < concurrency && queue.length < highWaterMark)
              resume2(), resume2 = null;
          }
          async function pump() {
            try {
              for await (let val of stream3) {
                if (done11)
                  return;
                if (signal.aborted)
                  throw new AbortError2;
                try {
                  if (val = fn2(val, signalOpt), val === kEmpty)
                    continue;
                  val = PromiseResolve(val);
                } catch (err) {
                  val = PromiseReject(err);
                }
                if (cnt += 1, PromisePrototypeThen(val, afterItemProcessed, onCatch), queue.push(val), next)
                  next(), next = null;
                if (!done11 && (queue.length >= highWaterMark || cnt >= concurrency))
                  await new Promise2((resolve3) => {
                    resume2 = resolve3;
                  });
              }
              queue.push(kEof);
            } catch (err) {
              let val = PromiseReject(err);
              PromisePrototypeThen(val, afterItemProcessed, onCatch), queue.push(val);
            } finally {
              if (done11 = true, next)
                next(), next = null;
            }
          }
          pump();
          try {
            while (true) {
              while (queue.length > 0) {
                let val = await queue[0];
                if (val === kEof)
                  return;
                if (signal.aborted)
                  throw new AbortError2;
                if (val !== kEmpty)
                  yield val;
                queue.shift(), maybeResume();
              }
              await new Promise2((resolve3) => {
                next = resolve3;
              });
            }
          } finally {
            if (done11 = true, resume2)
              resume2(), resume2 = null;
          }
        }.call(this);
      }
      function asIndexedPairs(options = undefined) {
        if (options != null)
          validateObject(options, "options");
        if ((options === null || options === undefined ? undefined : options.signal) != null)
          validateAbortSignal2(options.signal, "options.signal");
        return async function* asIndexedPairs() {
          let index = 0;
          for await (let val of this) {
            var _options$signal;
            if (options !== null && options !== undefined && (_options$signal = options.signal) !== null && _options$signal !== undefined && _options$signal.aborted)
              throw new AbortError2({ cause: options.signal.reason });
            yield [index++, val];
          }
        }.call(this);
      }
      async function some8(fn2, options = undefined) {
        for await (let unused of filter12.call(this, fn2, options))
          return true;
        return false;
      }
      async function every8(fn2, options = undefined) {
        if (typeof fn2 !== "function")
          throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn2);
        return !await some8.call(this, async (...args2) => {
          return !await fn2(...args2);
        }, options);
      }
      async function find4(fn2, options) {
        for await (let result of filter12.call(this, fn2, options))
          return result;
        return;
      }
      async function forEach10(fn2, options) {
        if (typeof fn2 !== "function")
          throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn2);
        async function forEachFn(value, options2) {
          return await fn2(value, options2), kEmpty;
        }
        for await (let unused of map24.call(this, forEachFn, options))
          ;
      }
      function filter12(fn2, options) {
        if (typeof fn2 !== "function")
          throw new ERR_INVALID_ARG_TYPE3("fn", ["Function", "AsyncFunction"], fn2);
        async function filterFn(value, options2) {
          if (await fn2(value, options2))
            return value;
          return kEmpty;
        }
        return map24.call(this, filterFn, options);
      }

      class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
        constructor() {
          super("reduce");
          this.message = "Reduce of an empty stream requires an initial value";
        }
      }
      async function reduce12(reducer, initialValue, options) {
        var _options$signal2;
        if (typeof reducer !== "function")
          throw new ERR_INVALID_ARG_TYPE3("reducer", ["Function", "AsyncFunction"], reducer);
        if (options != null)
          validateObject(options, "options");
        if ((options === null || options === undefined ? undefined : options.signal) != null)
          validateAbortSignal2(options.signal, "options.signal");
        let hasInitialValue = arguments.length > 1;
        if (options !== null && options !== undefined && (_options$signal2 = options.signal) !== null && _options$signal2 !== undefined && _options$signal2.aborted) {
          let err = new AbortError2(undefined, { cause: options.signal.reason });
          throw this.once("error", () => {}), await finished(this.destroy(err)), err;
        }
        let ac = new AbortController2, signal = ac.signal;
        if (options !== null && options !== undefined && options.signal) {
          let opts = { once: true, [kWeakHandler]: this, [kResistStopPropagation]: true };
          options.signal.addEventListener("abort", () => ac.abort(), opts);
        }
        let gotAnyItemFromStream = false;
        try {
          for await (let value of this) {
            var _options$signal3;
            if (gotAnyItemFromStream = true, options !== null && options !== undefined && (_options$signal3 = options.signal) !== null && _options$signal3 !== undefined && _options$signal3.aborted)
              throw new AbortError2;
            if (!hasInitialValue)
              initialValue = value, hasInitialValue = true;
            else
              initialValue = await reducer(initialValue, value, { signal });
          }
          if (!gotAnyItemFromStream && !hasInitialValue)
            throw new ReduceAwareErrMissingArgs;
        } finally {
          ac.abort();
        }
        return initialValue;
      }
      async function toArray4(options) {
        if (options != null)
          validateObject(options, "options");
        if ((options === null || options === undefined ? undefined : options.signal) != null)
          validateAbortSignal2(options.signal, "options.signal");
        let result = [];
        for await (let val of this) {
          var _options$signal4;
          if (options !== null && options !== undefined && (_options$signal4 = options.signal) !== null && _options$signal4 !== undefined && _options$signal4.aborted)
            throw new AbortError2(undefined, { cause: options.signal.reason });
          ArrayPrototypePush(result, val);
        }
        return result;
      }
      function flatMap20(fn2, options) {
        let values3 = map24.call(this, fn2, options);
        return async function* flatMap() {
          for await (let val of values3)
            yield* val;
        }.call(this);
      }
      function toIntegerOrInfinity(number4) {
        if (number4 = Number2(number4), NumberIsNaN(number4))
          return 0;
        if (number4 < 0)
          throw new ERR_OUT_OF_RANGE3("number", ">= 0", number4);
        return number4;
      }
      function drop6(number4, options = undefined) {
        if (options != null)
          validateObject(options, "options");
        if ((options === null || options === undefined ? undefined : options.signal) != null)
          validateAbortSignal2(options.signal, "options.signal");
        return number4 = toIntegerOrInfinity(number4), async function* drop() {
          var _options$signal5;
          if (options !== null && options !== undefined && (_options$signal5 = options.signal) !== null && _options$signal5 !== undefined && _options$signal5.aborted)
            throw new AbortError2;
          for await (let val of this) {
            var _options$signal6;
            if (options !== null && options !== undefined && (_options$signal6 = options.signal) !== null && _options$signal6 !== undefined && _options$signal6.aborted)
              throw new AbortError2;
            if (number4-- <= 0)
              yield val;
          }
        }.call(this);
      }
      function take10(number4, options = undefined) {
        if (options != null)
          validateObject(options, "options");
        if ((options === null || options === undefined ? undefined : options.signal) != null)
          validateAbortSignal2(options.signal, "options.signal");
        return number4 = toIntegerOrInfinity(number4), async function* take() {
          var _options$signal7;
          if (options !== null && options !== undefined && (_options$signal7 = options.signal) !== null && _options$signal7 !== undefined && _options$signal7.aborted)
            throw new AbortError2;
          for await (let val of this) {
            var _options$signal8;
            if (options !== null && options !== undefined && (_options$signal8 = options.signal) !== null && _options$signal8 !== undefined && _options$signal8.aborted)
              throw new AbortError2;
            if (number4-- > 0)
              yield val;
            if (number4 <= 0)
              return;
          }
        }.call(this);
      }
      module2.exports.streamReturningOperators = { asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."), drop: drop6, filter: filter12, flatMap: flatMap20, map: map24, take: take10, compose: compose3 };
      module2.exports.promiseReturningOperators = { every: every8, forEach: forEach10, reduce: reduce12, toArray: toArray4, some: some8, find: find4 };
    });
    var require_promises = __commonJS2((exports2, module2) => {
      var { ArrayPrototypePop, Promise: Promise2 } = require_primordials(), { isIterable: isIterable2, isNodeStream, isWebStream } = require_utils(), { pipelineImpl: pl } = require_pipeline(), { finished } = require_end_of_stream();
      require_stream2();
      function pipeline(...streams) {
        return new Promise2((resolve3, reject) => {
          let signal, end6, lastArg = streams[streams.length - 1];
          if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable2(lastArg) && !isWebStream(lastArg)) {
            let options = ArrayPrototypePop(streams);
            signal = options.signal, end6 = options.end;
          }
          pl(streams, (err, value) => {
            if (err)
              reject(err);
            else
              resolve3(value);
          }, { signal, end: end6 });
        });
      }
      module2.exports = { finished, pipeline };
    });
    var require_stream2 = __commonJS2((exports2, module2) => {
      var { Buffer: Buffer3 } = (init_buffer(), __toCommonJS(exports_buffer)), { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials(), { promisify: { custom: customPromisify } } = require_util(), { streamReturningOperators, promiseReturningOperators } = require_operators(), { codes: { ERR_ILLEGAL_CONSTRUCTOR } } = require_errors(), compose3 = require_compose(), { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state(), { pipeline } = require_pipeline(), { destroyer } = require_destroy(), eos = require_end_of_stream(), promises = require_promises(), utils = require_utils(), Stream = module2.exports = require_legacy().Stream;
      Stream.isDestroyed = utils.isDestroyed;
      Stream.isDisturbed = utils.isDisturbed;
      Stream.isErrored = utils.isErrored;
      Stream.isReadable = utils.isReadable;
      Stream.isWritable = utils.isWritable;
      Stream.Readable = require_readable();
      for (let key of ObjectKeys(streamReturningOperators)) {
        let fn2 = function(...args2) {
          if (new.target)
            throw ERR_ILLEGAL_CONSTRUCTOR();
          return Stream.Readable.from(ReflectApply(op, this, args2));
        }, op = streamReturningOperators[key];
        ObjectDefineProperty(fn2, "name", { __proto__: null, value: op.name }), ObjectDefineProperty(fn2, "length", { __proto__: null, value: op.length }), ObjectDefineProperty(Stream.Readable.prototype, key, { __proto__: null, value: fn2, enumerable: false, configurable: true, writable: true });
      }
      for (let key of ObjectKeys(promiseReturningOperators)) {
        let fn2 = function(...args2) {
          if (new.target)
            throw ERR_ILLEGAL_CONSTRUCTOR();
          return ReflectApply(op, this, args2);
        }, op = promiseReturningOperators[key];
        ObjectDefineProperty(fn2, "name", { __proto__: null, value: op.name }), ObjectDefineProperty(fn2, "length", { __proto__: null, value: op.length }), ObjectDefineProperty(Stream.Readable.prototype, key, { __proto__: null, value: fn2, enumerable: false, configurable: true, writable: true });
      }
      Stream.Writable = require_writable();
      Stream.Duplex = require_duplex();
      Stream.Transform = require_transform();
      Stream.PassThrough = require_passthrough();
      Stream.pipeline = pipeline;
      var { addAbortSignal } = require_add_abort_signal();
      Stream.addAbortSignal = addAbortSignal;
      Stream.finished = eos;
      Stream.destroy = destroyer;
      Stream.compose = compose3;
      Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
      Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
      ObjectDefineProperty(Stream, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
        return promises;
      } });
      ObjectDefineProperty(pipeline, customPromisify, { __proto__: null, enumerable: true, get() {
        return promises.pipeline;
      } });
      ObjectDefineProperty(eos, customPromisify, { __proto__: null, enumerable: true, get() {
        return promises.finished;
      } });
      Stream.Stream = Stream;
      Stream._isUint8Array = function isUint8Array(value) {
        return value instanceof Uint8Array;
      };
      Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk3) {
        return Buffer3.from(chunk3.buffer, chunk3.byteOffset, chunk3.byteLength);
      };
    });
    var require_ours = __commonJS2((exports2, module2) => {
      var Stream = require_stream();
      {
        let CustomStream = require_stream2(), promises = require_promises(), originalDestroy = CustomStream.Readable.destroy;
        module2.exports = CustomStream.Readable, module2.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer, module2.exports._isUint8Array = CustomStream._isUint8Array, module2.exports.isDisturbed = CustomStream.isDisturbed, module2.exports.isErrored = CustomStream.isErrored, module2.exports.isReadable = CustomStream.isReadable, module2.exports.Readable = CustomStream.Readable, module2.exports.Writable = CustomStream.Writable, module2.exports.Duplex = CustomStream.Duplex, module2.exports.Transform = CustomStream.Transform, module2.exports.PassThrough = CustomStream.PassThrough, module2.exports.addAbortSignal = CustomStream.addAbortSignal, module2.exports.finished = CustomStream.finished, module2.exports.destroy = CustomStream.destroy, module2.exports.destroy = originalDestroy, module2.exports.pipeline = CustomStream.pipeline, module2.exports.compose = CustomStream.compose, Object.defineProperty(CustomStream, "promises", { configurable: true, enumerable: true, get() {
          return promises;
        } }), module2.exports.Stream = CustomStream.Stream;
      }
      module2.exports.default = module2.exports;
    });
    module.exports = require_ours();
  });

  // node:util
  var exports_util2 = {};
  __export(exports_util2, {
    types: () => types,
    promisify: () => promisify,
    log: () => log3,
    isUndefined: () => isUndefined2,
    isSymbol: () => isSymbol2,
    isString: () => isString2,
    isRegExp: () => isRegExp,
    isPrimitive: () => isPrimitive,
    isObject: () => isObject2,
    isNumber: () => isNumber2,
    isNullOrUndefined: () => isNullOrUndefined,
    isNull: () => isNull,
    isFunction: () => isFunction3,
    isError: () => isError,
    isDate: () => isDate2,
    isBuffer: () => isBuffer2,
    isBoolean: () => isBoolean2,
    isArray: () => isArray2,
    inspect: () => inspect2,
    inherits: () => inherits,
    format: () => format6,
    deprecate: () => deprecate,
    default: () => util_default,
    debuglog: () => debuglog,
    callbackifyOnRejected: () => callbackifyOnRejected,
    callbackify: () => callbackify,
    _extend: () => _extend,
    TextEncoder: () => TextEncoder2,
    TextDecoder: () => TextDecoder2
  });
  function format6(f, ...args2) {
    if (!isString2(f)) {
      var objects = [f];
      for (var i2 = 0;i2 < args2.length; i2++)
        objects.push(inspect2(args2[i2]));
      return objects.join(" ");
    }
    var i2 = 0, len2 = args2.length, str = String(f).replace(formatRegExp, function(x2) {
      if (x2 === "%%")
        return "%";
      if (i2 >= len2)
        return x2;
      switch (x2) {
        case "%s":
          return String(args2[i2++]);
        case "%d":
          return Number(args2[i2++]);
        case "%j":
          try {
            return JSON.stringify(args2[i2++]);
          } catch (_) {
            return "[Circular]";
          }
        default:
          return x2;
      }
    });
    for (var x = args2[i2];i2 < len2; x = args2[++i2])
      if (isNull(x) || !isObject2(x))
        str += " " + x;
      else
        str += " " + inspect2(x);
    return str;
  }
  function deprecate(fn2, msg) {
    if (typeof process === "undefined" || process?.noDeprecation === true)
      return fn2;
    var warned = false;
    function deprecated(...args2) {
      if (!warned) {
        if (process.throwDeprecation)
          throw new Error(msg);
        else if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
        warned = true;
      }
      return fn2.apply(this, ...args2);
    }
    return deprecated;
  }
  function stylizeWithColor(str, styleType) {
    var style = inspect2.styles[styleType];
    if (style)
      return "\x1B[" + inspect2.colors[style][0] + "m" + str + "\x1B[" + inspect2.colors[style][1] + "m";
    else
      return str;
  }
  function stylizeNoColor(str, styleType) {
    return str;
  }
  function arrayToHash(array4) {
    var hash2 = {};
    return array4.forEach(function(val, idx) {
      hash2[val] = true;
    }), hash2;
  }
  function formatValue(ctx, value, recurseTimes) {
    if (ctx.customInspect && value && isFunction3(value.inspect) && value.inspect !== inspect2 && !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString2(ret))
        ret = formatValue(ctx, ret, recurseTimes);
      return ret;
    }
    var primitive = formatPrimitive(ctx, value);
    if (primitive)
      return primitive;
    var keys3 = Object.keys(value), visibleKeys = arrayToHash(keys3);
    if (ctx.showHidden)
      keys3 = Object.getOwnPropertyNames(value);
    if (isError(value) && (keys3.indexOf("message") >= 0 || keys3.indexOf("description") >= 0))
      return formatError(value);
    if (keys3.length === 0) {
      if (isFunction3(value)) {
        var name = value.name ? ": " + value.name : "";
        return ctx.stylize("[Function" + name + "]", "special");
      }
      if (isRegExp(value))
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      if (isDate2(value))
        return ctx.stylize(Date.prototype.toString.call(value), "date");
      if (isError(value))
        return formatError(value);
    }
    var base = "", array4 = false, braces = ["{", "}"];
    if (isArray2(value))
      array4 = true, braces = ["[", "]"];
    if (isFunction3(value)) {
      var n = value.name ? ": " + value.name : "";
      base = " [Function" + n + "]";
    }
    if (isRegExp(value))
      base = " " + RegExp.prototype.toString.call(value);
    if (isDate2(value))
      base = " " + Date.prototype.toUTCString.call(value);
    if (isError(value))
      base = " " + formatError(value);
    if (keys3.length === 0 && (!array4 || value.length == 0))
      return braces[0] + base + braces[1];
    if (recurseTimes < 0)
      if (isRegExp(value))
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      else
        return ctx.stylize("[Object]", "special");
    ctx.seen.push(value);
    var output;
    if (array4)
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys3);
    else
      output = keys3.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array4);
      });
    return ctx.seen.pop(), reduceToSingleString(output, base, braces);
  }
  function formatPrimitive(ctx, value) {
    if (isUndefined2(value))
      return ctx.stylize("undefined", "undefined");
    if (isString2(value)) {
      var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ctx.stylize(simple, "string");
    }
    if (isNumber2(value))
      return ctx.stylize("" + value, "number");
    if (isBoolean2(value))
      return ctx.stylize("" + value, "boolean");
    if (isNull(value))
      return ctx.stylize("null", "null");
  }
  function formatError(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
  }
  function formatArray(ctx, value, recurseTimes, visibleKeys, keys3) {
    var output = [];
    for (var i2 = 0, l = value.length;i2 < l; ++i2)
      if (hasOwnProperty(value, String(i2)))
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i2), true));
      else
        output.push("");
    return keys3.forEach(function(key) {
      if (!key.match(/^\d+$/))
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }), output;
  }
  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array4) {
    var name, str, desc;
    if (desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] }, desc.get)
      if (desc.set)
        str = ctx.stylize("[Getter/Setter]", "special");
      else
        str = ctx.stylize("[Getter]", "special");
    else if (desc.set)
      str = ctx.stylize("[Setter]", "special");
    if (!hasOwnProperty(visibleKeys, key))
      name = "[" + key + "]";
    if (!str)
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes))
          str = formatValue(ctx, desc.value, null);
        else
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        if (str.indexOf(`
`) > -1)
          if (array4)
            str = str.split(`
`).map(function(line) {
              return "  " + line;
            }).join(`
`).slice(2);
          else
            str = `
` + str.split(`
`).map(function(line) {
              return "   " + line;
            }).join(`
`);
      } else
        str = ctx.stylize("[Circular]", "special");
    if (isUndefined2(name)) {
      if (array4 && key.match(/^\d+$/))
        return str;
      if (name = JSON.stringify("" + key), name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/))
        name = name.slice(1, -1), name = ctx.stylize(name, "name");
      else
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), name = ctx.stylize(name, "string");
    }
    return name + ": " + str;
  }
  function reduceToSingleString(output, base, braces) {
    var numLinesEst = 0, length3 = output.reduce(function(prev, cur) {
      if (numLinesEst++, cur.indexOf(`
`) >= 0)
        numLinesEst++;
      return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length3 > 60)
      return braces[0] + (base === "" ? "" : base + `
 `) + " " + output.join(`,
  `) + " " + braces[1];
    return braces[0] + base + " " + output.join(", ") + " " + braces[1];
  }
  function isArray2(ar) {
    return Array.isArray(ar);
  }
  function isBoolean2(arg) {
    return typeof arg === "boolean";
  }
  function isNull(arg) {
    return arg === null;
  }
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  function isNumber2(arg) {
    return typeof arg === "number";
  }
  function isString2(arg) {
    return typeof arg === "string";
  }
  function isSymbol2(arg) {
    return typeof arg === "symbol";
  }
  function isUndefined2(arg) {
    return arg === undefined;
  }
  function isRegExp(re) {
    return isObject2(re) && objectToString(re) === "[object RegExp]";
  }
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  function isDate2(d) {
    return isObject2(d) && objectToString(d) === "[object Date]";
  }
  function isError(e) {
    return isObject2(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
  }
  function isFunction3(arg) {
    return typeof arg === "function";
  }
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  function isBuffer2(arg) {
    return arg instanceof Buffer;
  }
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  function pad(n) {
    return n < 10 ? "0" + n.toString(10) : n.toString(10);
  }
  function timestamp() {
    var d = new Date, time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(":");
    return [d.getDate(), months[d.getMonth()], time].join(" ");
  }
  function log3(...args2) {
    console.log("%s - %s", timestamp(), format6.apply(null, args2));
  }
  function inherits(ctor, superCtor) {
    if (superCtor)
      ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
  }
  function _extend(origin, add5) {
    if (!add5 || !isObject2(add5))
      return origin;
    var keys3 = Object.keys(add5), i2 = keys3.length;
    while (i2--)
      origin[keys3[i2]] = add5[keys3[i2]];
    return origin;
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  function callbackifyOnRejected(reason, cb) {
    if (!reason) {
      var newReason = new Error("Promise was rejected with a falsy value");
      newReason.reason = reason, reason = newReason;
    }
    return cb(reason);
  }
  function callbackify(original) {
    if (typeof original !== "function")
      throw new TypeError('The "original" argument must be of type Function');
    function callbackified(...args2) {
      var maybeCb = args2.pop();
      if (typeof maybeCb !== "function")
        throw new TypeError("The last argument must be of type Function");
      var self2 = this, cb = function(...args22) {
        return maybeCb.apply(self2, ...args22);
      };
      original.apply(this, args2).then(function(ret) {
        process.nextTick(cb.bind(null, null, ret));
      }, function(rej) {
        process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
      });
    }
    return Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original)), Object.defineProperties(callbackified, Object.getOwnPropertyDescriptors(original)), callbackified;
  }
  var formatRegExp, debuglog, inspect2, types = () => {}, months, promisify, TextEncoder2, TextDecoder2, util_default;
  var init_util = __esm(() => {
    formatRegExp = /%[sdj%]/g;
    debuglog = ((debugs = {}, debugEnvRegex = {}, debugEnv) => ((debugEnv = typeof process !== "undefined" && false) && (debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase()), debugEnvRegex = new RegExp("^" + debugEnv + "$", "i"), (set8) => {
      if (set8 = set8.toUpperCase(), !debugs[set8])
        if (debugEnvRegex.test(set8))
          debugs[set8] = function(...args2) {
            console.error("%s: %s", set8, pid, format6.apply(null, ...args2));
          };
        else
          debugs[set8] = function() {};
      return debugs[set8];
    }))();
    inspect2 = ((i2) => (i2.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, i2.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, i2.custom = Symbol.for("nodejs.util.inspect.custom"), i2))(function inspect22(obj, opts, ...rest) {
      var ctx = { seen: [], stylize: stylizeNoColor };
      if (rest.length >= 1)
        ctx.depth = rest[0];
      if (rest.length >= 2)
        ctx.colors = rest[1];
      if (isBoolean2(opts))
        ctx.showHidden = opts;
      else if (opts)
        _extend(ctx, opts);
      if (isUndefined2(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined2(ctx.depth))
        ctx.depth = 2;
      if (isUndefined2(ctx.colors))
        ctx.colors = false;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    });
    months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    promisify = ((x) => (x.custom = Symbol.for("nodejs.util.promisify.custom"), x))(function promisify2(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn2 = original[kCustomPromisifiedSymbol];
        if (typeof fn2 !== "function")
          throw new TypeError('The "nodejs.util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(fn2, kCustomPromisifiedSymbol, { value: fn2, enumerable: false, writable: false, configurable: true }), fn2;
      }
      function fn2(...args2) {
        var promiseResolve, promiseReject, promise3 = new Promise(function(resolve3, reject) {
          promiseResolve = resolve3, promiseReject = reject;
        });
        args2.push(function(err, value) {
          if (err)
            promiseReject(err);
          else
            promiseResolve(value);
        });
        try {
          original.apply(this, args2);
        } catch (err) {
          promiseReject(err);
        }
        return promise3;
      }
      if (Object.setPrototypeOf(fn2, Object.getPrototypeOf(original)), kCustomPromisifiedSymbol)
        Object.defineProperty(fn2, kCustomPromisifiedSymbol, { value: fn2, enumerable: false, writable: false, configurable: true });
      return Object.defineProperties(fn2, Object.getOwnPropertyDescriptors(original));
    });
    ({ TextEncoder: TextEncoder2, TextDecoder: TextDecoder2 } = globalThis);
    util_default = { TextEncoder: TextEncoder2, TextDecoder: TextDecoder2, promisify, log: log3, inherits, _extend, callbackifyOnRejected, callbackify };
  });

  // node:crypto
  var exports_crypto = {};
  __export(exports_crypto, {
    webcrypto: () => webcrypto,
    rng: () => rng2,
    randomUUID: () => randomUUID,
    randomFillSync: () => randomFillSync2,
    randomFill: () => randomFill2,
    randomBytes: () => randomBytes2,
    publicEncrypt: () => publicEncrypt2,
    publicDecrypt: () => publicDecrypt2,
    pseudoRandomBytes: () => pseudoRandomBytes2,
    prng: () => prng2,
    privateEncrypt: () => privateEncrypt2,
    privateDecrypt: () => privateDecrypt2,
    pbkdf2Sync: () => pbkdf2Sync2,
    pbkdf2: () => pbkdf22,
    listCiphers: () => listCiphers2,
    getRandomValues: () => getRandomValues,
    getHashes: () => getHashes2,
    getDiffieHellman: () => getDiffieHellman2,
    getCurves: () => getCurves,
    getCiphers: () => getCiphers2,
    default: () => crypto_default,
    createVerify: () => createVerify2,
    createSign: () => createSign2,
    createHmac: () => createHmac2,
    createHash: () => createHash2,
    createECDH: () => createECDH2,
    createDiffieHellmanGroup: () => createDiffieHellmanGroup2,
    createDiffieHellman: () => createDiffieHellman2,
    createDecipheriv: () => createDecipheriv2,
    createDecipher: () => createDecipher2,
    createCredentials: () => createCredentials2,
    createCipheriv: () => createCipheriv2,
    createCipher: () => createCipher2,
    constants: () => constants2,
    Verify: () => Verify2,
    Sign: () => Sign2,
    Hmac: () => Hmac2,
    Hash: () => Hash2,
    DiffieHellmanGroup: () => DiffieHellmanGroup2,
    DiffieHellman: () => DiffieHellman2,
    Decipheriv: () => Decipheriv2,
    Decipher: () => Decipher2,
    DEFAULT_ENCODING: () => DEFAULT_ENCODING,
    Cipheriv: () => Cipheriv2,
    Cipher: () => Cipher2
  });
  function getCurves() {
    return hardcoded_curves;
  }
  var __create2, __getProtoOf2, __defProp2, __getOwnPropNames2, __hasOwnProp2, __toESM2 = (mod, isNodeMode, target) => {
    target = mod != null ? __create2(__getProtoOf2(mod)) : {};
    let to = isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target;
    for (let key of __getOwnPropNames2(mod))
      if (!__hasOwnProp2.call(to, key))
        __defProp2(to, key, { get: () => mod[key], enumerable: true });
    return to;
  }, __commonJS2 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports), require_randombytes, require_create_hash, require_create_hmac, require_algorithms, require_precondition, require_default_encoding, require_safe_buffer, require_to_buffer, require_sync, require_async, require_pbkdf2, require_browserify_cipher, require_diffie_hellman, require_browserify_sign, require_package, require_bn, require_minimalistic_assert, require_utils, require_utils2, require_brorand, require_base, require_inherits_browser, require_inherits, require_short, require_mont, require_edwards, require_curve, require_utils3, require_common, require_common2, require_1, require_256, require_224, require_512, require_384, require_sha, require_ripemd, require_hmac, require_hash, require_secp256k1, require_curves, require_hmac_drbg, require_key, require_signature, require_ec, require_key2, require_signature2, require_eddsa, require_elliptic, require_bn2, require_browser, require_create_ecdh, require_bn3, require_api, require_reporter, require_buffer, require_node, require_base2, require_der, require_constants, require_der2, require_pem, require_decoders, require_der3, require_pem2, require_encoders, require_asn1, require_certificate, require_asn12, require_aesid, require_hash_base, require_md5, require_evp_bytestokey, require_browserify_aes, require_fixProc, require_parse_asn1, require_mgf, require_xor, require_bn4, require_withPublic, require_bn5, require_browserify_rsa, require_publicEncrypt, require_privateDecrypt, require_browser2, require_public_encrypt, require_browser3, require_randomfill, require_crypto_browserify, cryptoBrowserify, prng2, pseudoRandomBytes2, rng2, randomBytes2, Hash2, createHash2, Hmac2, createHmac2, getHashes2, pbkdf22, pbkdf2Sync2, Cipher2, createCipher2, Cipheriv2, createCipheriv2, Decipher2, createDecipher2, Decipheriv2, createDecipheriv2, getCiphers2, listCiphers2, DiffieHellmanGroup2, createDiffieHellmanGroup2, getDiffieHellman2, createDiffieHellman2, DiffieHellman2, createSign2, Sign2, createVerify2, Verify2, createECDH2, publicEncrypt2, privateEncrypt2, publicDecrypt2, privateDecrypt2, randomFill2, randomFillSync2, createCredentials2, constants2, DEFAULT_ENCODING = "buffer", getRandomValues = (array4) => {
    return crypto.getRandomValues(array4);
  }, randomUUID = () => {
    return crypto.randomUUID();
  }, hardcoded_curves, webcrypto, crypto_default;
  var init_crypto = __esm(() => {
    __create2 = Object.create;
    ({ getPrototypeOf: __getProtoOf2, defineProperty: __defProp2, getOwnPropertyNames: __getOwnPropNames2 } = Object);
    __hasOwnProp2 = Object.prototype.hasOwnProperty;
    require_randombytes = __commonJS2((exports, module) => {
      module.exports = (init_crypto(), __toCommonJS(exports_crypto)).randomBytes;
    });
    require_create_hash = __commonJS2((exports, module) => {
      module.exports = (init_crypto(), __toCommonJS(exports_crypto)).createHash;
    });
    require_create_hmac = __commonJS2((exports, module) => {
      module.exports = (init_crypto(), __toCommonJS(exports_crypto)).createHmac;
    });
    require_algorithms = __commonJS2((exports, module) => {
      module.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
    });
    require_precondition = __commonJS2((exports, module) => {
      var MAX_ALLOC = Math.pow(2, 30) - 1;
      module.exports = function(iterations, keylen) {
        if (typeof iterations !== "number")
          throw new TypeError("Iterations not a number");
        if (iterations < 0)
          throw new TypeError("Bad iterations");
        if (typeof keylen !== "number")
          throw new TypeError("Key length not a number");
        if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen)
          throw new TypeError("Bad key length");
      };
    });
    require_default_encoding = __commonJS2((exports, module) => {
      var defaultEncoding;
      if (globalThis.process && globalThis.process.browser)
        defaultEncoding = "utf-8";
      else if (globalThis.process && globalThis.process.version)
        pVersionMajor = parseInt(process.version.split(".")[0].slice(1), 10), defaultEncoding = pVersionMajor >= 6 ? "utf-8" : "binary";
      else
        defaultEncoding = "utf-8";
      var pVersionMajor;
      module.exports = defaultEncoding;
    });
    require_safe_buffer = __commonJS2((exports, module) => {
      /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
      var buffer4 = (init_buffer(), __toCommonJS(exports_buffer)), Buffer22 = buffer4.Buffer;
      function copyProps(src, dst) {
        for (var key in src)
          dst[key] = src[key];
      }
      if (Buffer22.from && Buffer22.alloc && Buffer22.allocUnsafe && Buffer22.allocUnsafeSlow)
        module.exports = buffer4;
      else
        copyProps(buffer4, exports), exports.Buffer = SafeBuffer;
      function SafeBuffer(arg, encodingOrOffset, length3) {
        return Buffer22(arg, encodingOrOffset, length3);
      }
      SafeBuffer.prototype = Object.create(Buffer22.prototype);
      copyProps(Buffer22, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length3) {
        if (typeof arg === "number")
          throw new TypeError("Argument must not be a number");
        return Buffer22(arg, encodingOrOffset, length3);
      };
      SafeBuffer.alloc = function(size13, fill2, encoding) {
        if (typeof size13 !== "number")
          throw new TypeError("Argument must be a number");
        var buf = Buffer22(size13);
        if (fill2 !== undefined)
          if (typeof encoding === "string")
            buf.fill(fill2, encoding);
          else
            buf.fill(fill2);
        else
          buf.fill(0);
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size13) {
        if (typeof size13 !== "number")
          throw new TypeError("Argument must be a number");
        return Buffer22(size13);
      };
      SafeBuffer.allocUnsafeSlow = function(size13) {
        if (typeof size13 !== "number")
          throw new TypeError("Argument must be a number");
        return buffer4.SlowBuffer(size13);
      };
    });
    require_to_buffer = __commonJS2((exports, module) => {
      var Buffer22 = require_safe_buffer().Buffer;
      module.exports = function(thing, encoding, name) {
        if (Buffer22.isBuffer(thing))
          return thing;
        else if (typeof thing === "string")
          return Buffer22.from(thing, encoding);
        else if (ArrayBuffer.isView(thing))
          return Buffer22.from(thing.buffer);
        else
          throw new TypeError(name + " must be a string, a Buffer, a typed array or a DataView");
      };
    });
    require_sync = __commonJS2((exports, module) => {
      var sizes = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 }, createHmac = require_create_hmac(), Buffer22 = require_safe_buffer().Buffer, checkParameters = require_precondition(), defaultEncoding = require_default_encoding(), toBuffer = require_to_buffer();
      function pbkdf2(password, salt, iterations, keylen, digest) {
        checkParameters(iterations, keylen), password = toBuffer(password, defaultEncoding, "Password"), salt = toBuffer(salt, defaultEncoding, "Salt"), digest = digest || "sha1";
        var DK = Buffer22.allocUnsafe(keylen), block1 = Buffer22.allocUnsafe(salt.length + 4);
        salt.copy(block1, 0, 0, salt.length);
        var destPos = 0, hLen = sizes[digest], l = Math.ceil(keylen / hLen);
        for (var i2 = 1;i2 <= l; i2++) {
          block1.writeUInt32BE(i2, salt.length);
          var T = createHmac(digest, password).update(block1).digest(), U = T;
          for (var j = 1;j < iterations; j++) {
            U = createHmac(digest, password).update(U).digest();
            for (var k = 0;k < hLen; k++)
              T[k] ^= U[k];
          }
          T.copy(DK, destPos), destPos += hLen;
        }
        return DK;
      }
      module.exports = pbkdf2;
    });
    require_async = __commonJS2((exports, module) => {
      var Buffer22 = require_safe_buffer().Buffer, checkParameters = require_precondition(), defaultEncoding = require_default_encoding(), sync11 = require_sync(), toBuffer = require_to_buffer(), ZERO_BUF, subtle = globalThis.crypto && globalThis.crypto.subtle, toBrowser = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, checks = [];
      function checkNative(algo) {
        if (globalThis.process && !globalThis.process.browser)
          return Promise.resolve(false);
        if (!subtle || !subtle.importKey || !subtle.deriveBits)
          return Promise.resolve(false);
        if (checks[algo] !== undefined)
          return checks[algo];
        ZERO_BUF = ZERO_BUF || Buffer22.alloc(8);
        var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function() {
          return true;
        }).catch(function() {
          return false;
        });
        return checks[algo] = prom, prom;
      }
      var nextTick;
      function getNextTick() {
        if (nextTick)
          return nextTick;
        if (globalThis.process && globalThis.process.nextTick)
          nextTick = globalThis.process.nextTick;
        else if (globalThis.queueMicrotask)
          nextTick = globalThis.queueMicrotask;
        else if (globalThis.setImmediate)
          nextTick = globalThis.setImmediate;
        else
          nextTick = globalThis.setTimeout;
        return nextTick;
      }
      function browserPbkdf2(password, salt, iterations, length3, algo) {
        return subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(key) {
          return subtle.deriveBits({ name: "PBKDF2", salt, iterations, hash: { name: algo } }, key, length3 << 3);
        }).then(function(res) {
          return Buffer22.from(res);
        });
      }
      function resolvePromise(promise3, callback) {
        promise3.then(function(out) {
          getNextTick()(function() {
            callback(null, out);
          });
        }, function(e) {
          getNextTick()(function() {
            callback(e);
          });
        });
      }
      module.exports = function(password, salt, iterations, keylen, digest, callback) {
        if (typeof digest === "function")
          callback = digest, digest = undefined;
        digest = digest || "sha1";
        var algo = toBrowser[digest.toLowerCase()];
        if (!algo || typeof globalThis.Promise !== "function") {
          getNextTick()(function() {
            var out;
            try {
              out = sync11(password, salt, iterations, keylen, digest);
            } catch (e) {
              return callback(e);
            }
            callback(null, out);
          });
          return;
        }
        if (checkParameters(iterations, keylen), password = toBuffer(password, defaultEncoding, "Password"), salt = toBuffer(salt, defaultEncoding, "Salt"), typeof callback !== "function")
          throw new Error("No callback provided to pbkdf2");
        resolvePromise(checkNative(algo).then(function(resp) {
          if (resp)
            return browserPbkdf2(password, salt, iterations, keylen, algo);
          return sync11(password, salt, iterations, keylen, digest);
        }), callback);
      };
    });
    require_pbkdf2 = __commonJS2((exports) => {
      var native = (init_crypto(), __toCommonJS(exports_crypto)), checkParameters = require_precondition(), defaultEncoding = require_default_encoding(), toBuffer = require_to_buffer();
      function nativePBKDF2(password, salt, iterations, keylen, digest, callback) {
        if (checkParameters(iterations, keylen), password = toBuffer(password, defaultEncoding, "Password"), salt = toBuffer(salt, defaultEncoding, "Salt"), typeof digest === "function")
          callback = digest, digest = "sha1";
        if (typeof callback !== "function")
          throw new Error("No callback provided to pbkdf2");
        return native.pbkdf2(password, salt, iterations, keylen, digest, callback);
      }
      function nativePBKDF2Sync(password, salt, iterations, keylen, digest) {
        return checkParameters(iterations, keylen), password = toBuffer(password, defaultEncoding, "Password"), salt = toBuffer(salt, defaultEncoding, "Salt"), digest = digest || "sha1", native.pbkdf2Sync(password, salt, iterations, keylen, digest);
      }
      if (!native.pbkdf2Sync || native.pbkdf2Sync.toString().indexOf("keylen, digest") === -1)
        exports.pbkdf2Sync = require_sync(), exports.pbkdf2 = require_async();
      else
        exports.pbkdf2Sync = nativePBKDF2Sync, exports.pbkdf2 = nativePBKDF2;
    });
    require_browserify_cipher = __commonJS2((exports) => {
      var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
      exports.createCipher = exports.Cipher = crypto2.createCipher;
      exports.createCipheriv = exports.Cipheriv = crypto2.createCipheriv;
      exports.createDecipher = exports.Decipher = crypto2.createDecipher;
      exports.createDecipheriv = exports.Decipheriv = crypto2.createDecipheriv;
      exports.listCiphers = exports.getCiphers = crypto2.getCiphers;
    });
    require_diffie_hellman = __commonJS2((exports) => {
      var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
      exports.DiffieHellmanGroup = crypto2.DiffieHellmanGroup;
      exports.createDiffieHellmanGroup = crypto2.createDiffieHellmanGroup;
      exports.getDiffieHellman = crypto2.getDiffieHellman;
      exports.createDiffieHellman = crypto2.createDiffieHellman;
      exports.DiffieHellman = crypto2.DiffieHellman;
    });
    require_browserify_sign = __commonJS2((exports) => {
      var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
      exports.createSign = crypto2.createSign;
      exports.Sign = crypto2.Sign;
      exports.createVerify = crypto2.createVerify;
      exports.Verify = crypto2.Verify;
    });
    require_package = __commonJS2((exports, module) => {
      module.exports = { name: "elliptic", version: "6.6.1", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
    });
    require_bn = __commonJS2((exports, module) => {
      (function(module2, exports2) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {};
          TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
        }
        function BN(number4, base, endian) {
          if (BN.isBN(number4))
            return number4;
          if (this.negative = 0, this.words = null, this.length = 0, this.red = null, number4 !== null) {
            if (base === "le" || base === "be")
              endian = base, base = 10;
            this._init(number4 || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object")
          module2.exports = BN;
        else
          exports2.BN = BN;
        BN.BN = BN, BN.wordSize = 26;
        var Buffer22;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined")
            Buffer22 = window.Buffer;
          else
            Buffer22 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
        } catch (e) {}
        BN.isBN = function isBN(num) {
          if (num instanceof BN)
            return true;
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        }, BN.max = function max(left3, right3) {
          if (left3.cmp(right3) > 0)
            return left3;
          return right3;
        }, BN.min = function min(left3, right3) {
          if (left3.cmp(right3) < 0)
            return left3;
          return right3;
        }, BN.prototype._init = function init(number4, base, endian) {
          if (typeof number4 === "number")
            return this._initNumber(number4, base, endian);
          if (typeof number4 === "object")
            return this._initArray(number4, base, endian);
          if (base === "hex")
            base = 16;
          assert(base === (base | 0) && base >= 2 && base <= 36), number4 = number4.toString().replace(/\s+/g, "");
          var start4 = 0;
          if (number4[0] === "-")
            start4++, this.negative = 1;
          if (start4 < number4.length) {
            if (base === 16)
              this._parseHex(number4, start4, endian);
            else if (this._parseBase(number4, base, start4), endian === "le")
              this._initArray(this.toArray(), base, endian);
          }
        }, BN.prototype._initNumber = function _initNumber(number4, base, endian) {
          if (number4 < 0)
            this.negative = 1, number4 = -number4;
          if (number4 < 67108864)
            this.words = [number4 & 67108863], this.length = 1;
          else if (number4 < 4503599627370496)
            this.words = [number4 & 67108863, number4 / 67108864 & 67108863], this.length = 2;
          else
            assert(number4 < 9007199254740992), this.words = [number4 & 67108863, number4 / 67108864 & 67108863, 1], this.length = 3;
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        }, BN.prototype._initArray = function _initArray(number4, base, endian) {
          if (assert(typeof number4.length === "number"), number4.length <= 0)
            return this.words = [0], this.length = 1, this;
          this.length = Math.ceil(number4.length / 3), this.words = new Array(this.length);
          for (var i2 = 0;i2 < this.length; i2++)
            this.words[i2] = 0;
          var j, w, off = 0;
          if (endian === "be") {
            for (i2 = number4.length - 1, j = 0;i2 >= 0; i2 -= 3)
              if (w = number4[i2] | number4[i2 - 1] << 8 | number4[i2 - 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
                off -= 26, j++;
          } else if (endian === "le") {
            for (i2 = 0, j = 0;i2 < number4.length; i2 += 3)
              if (w = number4[i2] | number4[i2 + 1] << 8 | number4[i2 + 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
                off -= 26, j++;
          }
          return this.strip();
        };
        function parseHex4Bits(string3, index) {
          var c = string3.charCodeAt(index);
          if (c >= 65 && c <= 70)
            return c - 55;
          else if (c >= 97 && c <= 102)
            return c - 87;
          else
            return c - 48 & 15;
        }
        function parseHexByte(string3, lowerBound, index) {
          var r = parseHex4Bits(string3, index);
          if (index - 1 >= lowerBound)
            r |= parseHex4Bits(string3, index - 1) << 4;
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number4, start4, endian) {
          this.length = Math.ceil((number4.length - start4) / 6), this.words = new Array(this.length);
          for (var i2 = 0;i2 < this.length; i2++)
            this.words[i2] = 0;
          var off = 0, j = 0, w;
          if (endian === "be")
            for (i2 = number4.length - 1;i2 >= start4; i2 -= 2)
              if (w = parseHexByte(number4, start4, i2) << off, this.words[j] |= w & 67108863, off >= 18)
                off -= 18, j += 1, this.words[j] |= w >>> 26;
              else
                off += 8;
          else {
            var parseLength = number4.length - start4;
            for (i2 = parseLength % 2 === 0 ? start4 + 1 : start4;i2 < number4.length; i2 += 2)
              if (w = parseHexByte(number4, start4, i2) << off, this.words[j] |= w & 67108863, off >= 18)
                off -= 18, j += 1, this.words[j] |= w >>> 26;
              else
                off += 8;
          }
          this.strip();
        };
        function parseBase(str, start4, end6, mul) {
          var r = 0, len2 = Math.min(str.length, end6);
          for (var i2 = start4;i2 < len2; i2++) {
            var c = str.charCodeAt(i2) - 48;
            if (r *= mul, c >= 49)
              r += c - 49 + 10;
            else if (c >= 17)
              r += c - 17 + 10;
            else
              r += c;
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number4, base, start4) {
          this.words = [0], this.length = 1;
          for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base)
            limbLen++;
          limbLen--, limbPow = limbPow / base | 0;
          var total = number4.length - start4, mod = total % limbLen, end6 = Math.min(total, total - mod) + start4, word = 0;
          for (var i2 = start4;i2 < end6; i2 += limbLen)
            if (word = parseBase(number4, i2, i2 + limbLen, base), this.imuln(limbPow), this.words[0] + word < 67108864)
              this.words[0] += word;
            else
              this._iaddn(word);
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number4, i2, number4.length, base);
            for (i2 = 0;i2 < mod; i2++)
              pow *= base;
            if (this.imuln(pow), this.words[0] + word < 67108864)
              this.words[0] += word;
            else
              this._iaddn(word);
          }
          this.strip();
        }, BN.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i2 = 0;i2 < this.length; i2++)
            dest.words[i2] = this.words[i2];
          dest.length = this.length, dest.negative = this.negative, dest.red = this.red;
        }, BN.prototype.clone = function clone() {
          var r = new BN(null);
          return this.copy(r), r;
        }, BN.prototype._expand = function _expand(size13) {
          while (this.length < size13)
            this.words[this.length++] = 0;
          return this;
        }, BN.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0)
            this.length--;
          return this._normSign();
        }, BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0)
            this.negative = 0;
          return this;
        }, BN.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        if (BN.prototype.toString = function toString(base, padding) {
          base = base || 10, padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0, carry = 0;
            for (var i2 = 0;i2 < this.length; i2++) {
              var w = this.words[i2], word = ((w << off | carry) & 16777215).toString(16);
              if (carry = w >>> 24 - off & 16777215, off += 2, off >= 26)
                off -= 26, i2--;
              if (carry !== 0 || i2 !== this.length - 1)
                out = zeros[6 - word.length] + word + out;
              else
                out = word + out;
            }
            if (carry !== 0)
              out = carry.toString(16) + out;
            while (out.length % padding !== 0)
              out = "0" + out;
            if (this.negative !== 0)
              out = "-" + out;
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base], groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modn(groupBase).toString(base);
              if (c = c.idivn(groupBase), !c.isZero())
                out = zeros[groupSize - r.length] + r + out;
              else
                out = r + out;
            }
            if (this.isZero())
              out = "0" + out;
            while (out.length % padding !== 0)
              out = "0" + out;
            if (this.negative !== 0)
              out = "-" + out;
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        }, BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2)
            ret += this.words[1] * 67108864;
          else if (this.length === 3 && this.words[2] === 1)
            ret += 4503599627370496 + this.words[1] * 67108864;
          else if (this.length > 2)
            assert(false, "Number can only safely store up to 53 bits");
          return this.negative !== 0 ? -ret : ret;
        }, BN.prototype.toJSON = function toJSON() {
          return this.toString(16);
        }, BN.prototype.toBuffer = function toBuffer(endian, length3) {
          return assert(typeof Buffer22 !== "undefined"), this.toArrayLike(Buffer22, endian, length3);
        }, BN.prototype.toArray = function toArray(endian, length3) {
          return this.toArrayLike(Array, endian, length3);
        }, BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length3) {
          var byteLength2 = this.byteLength(), reqLength = length3 || Math.max(1, byteLength2);
          assert(byteLength2 <= reqLength, "byte array longer than desired length"), assert(reqLength > 0, "Requested array length <= 0"), this.strip();
          var littleEndian = endian === "le", res = new ArrayType(reqLength), b, i2, q = this.clone();
          if (!littleEndian) {
            for (i2 = 0;i2 < reqLength - byteLength2; i2++)
              res[i2] = 0;
            for (i2 = 0;!q.isZero(); i2++)
              b = q.andln(255), q.iushrn(8), res[reqLength - i2 - 1] = b;
          } else {
            for (i2 = 0;!q.isZero(); i2++)
              b = q.andln(255), q.iushrn(8), res[i2] = b;
            for (;i2 < reqLength; i2++)
              res[i2] = 0;
          }
          return res;
        }, Math.clz32)
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        else
          BN.prototype._countBits = function _countBits(w) {
            var t = w, r = 0;
            if (t >= 4096)
              r += 13, t >>>= 13;
            if (t >= 64)
              r += 7, t >>>= 7;
            if (t >= 8)
              r += 4, t >>>= 4;
            if (t >= 2)
              r += 2, t >>>= 2;
            return r + t;
          };
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w, r = 0;
          if ((t & 8191) === 0)
            r += 13, t >>>= 13;
          if ((t & 127) === 0)
            r += 7, t >>>= 7;
          if ((t & 15) === 0)
            r += 4, t >>>= 4;
          if ((t & 3) === 0)
            r += 2, t >>>= 2;
          if ((t & 1) === 0)
            r++;
          return r;
        }, BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1], hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0;bit < w.length; bit++) {
            var off = bit / 26 | 0, wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var b = this._zeroBits(this.words[i2]);
            if (r += b, b !== 26)
              break;
          }
          return r;
        }, BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        }, BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0)
            return this.abs().inotn(width).iaddn(1);
          return this.clone();
        }, BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1))
            return this.notn(width).iaddn(1).ineg();
          return this.clone();
        }, BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        }, BN.prototype.neg = function neg() {
          return this.clone().ineg();
        }, BN.prototype.ineg = function ineg() {
          if (!this.isZero())
            this.negative ^= 1;
          return this;
        }, BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length)
            this.words[this.length++] = 0;
          for (var i2 = 0;i2 < num.length; i2++)
            this.words[i2] = this.words[i2] | num.words[i2];
          return this.strip();
        }, BN.prototype.ior = function ior(num) {
          return assert((this.negative | num.negative) === 0), this.iuor(num);
        }, BN.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        }, BN.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        }, BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length)
            b = num;
          else
            b = this;
          for (var i2 = 0;i2 < b.length; i2++)
            this.words[i2] = this.words[i2] & num.words[i2];
          return this.length = b.length, this.strip();
        }, BN.prototype.iand = function iand(num) {
          return assert((this.negative | num.negative) === 0), this.iuand(num);
        }, BN.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        }, BN.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        }, BN.prototype.iuxor = function iuxor(num) {
          var a, b;
          if (this.length > num.length)
            a = this, b = num;
          else
            a = num, b = this;
          for (var i2 = 0;i2 < b.length; i2++)
            this.words[i2] = a.words[i2] ^ b.words[i2];
          if (this !== a)
            for (;i2 < a.length; i2++)
              this.words[i2] = a.words[i2];
          return this.length = a.length, this.strip();
        }, BN.prototype.ixor = function ixor(num) {
          return assert((this.negative | num.negative) === 0), this.iuxor(num);
        }, BN.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        }, BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        }, BN.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0, bitsLeft = width % 26;
          if (this._expand(bytesNeeded), bitsLeft > 0)
            bytesNeeded--;
          for (var i2 = 0;i2 < bytesNeeded; i2++)
            this.words[i2] = ~this.words[i2] & 67108863;
          if (bitsLeft > 0)
            this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
          return this.strip();
        }, BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        }, BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0, wbit = bit % 26;
          if (this._expand(off + 1), val)
            this.words[off] = this.words[off] | 1 << wbit;
          else
            this.words[off] = this.words[off] & ~(1 << wbit);
          return this.strip();
        }, BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0)
            return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();
          else if (this.negative === 0 && num.negative !== 0)
            return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();
          var a, b;
          if (this.length > num.length)
            a = this, b = num;
          else
            a = num, b = this;
          var carry = 0;
          for (var i2 = 0;i2 < b.length; i2++)
            r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
          for (;carry !== 0 && i2 < a.length; i2++)
            r = (a.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
          if (this.length = a.length, carry !== 0)
            this.words[this.length] = carry, this.length++;
          else if (a !== this)
            for (;i2 < a.length; i2++)
              this.words[i2] = a.words[i2];
          return this;
        }, BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0)
            return num.negative = 0, res = this.sub(num), num.negative ^= 1, res;
          else if (num.negative === 0 && this.negative !== 0)
            return this.negative = 0, res = num.sub(this), this.negative = 1, res;
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        }, BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            return num.negative = 1, r._normSign();
          } else if (this.negative !== 0)
            return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();
          var cmp = this.cmp(num);
          if (cmp === 0)
            return this.negative = 0, this.length = 1, this.words[0] = 0, this;
          var a, b;
          if (cmp > 0)
            a = this, b = num;
          else
            a = num, b = this;
          var carry = 0;
          for (var i2 = 0;i2 < b.length; i2++)
            r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
          for (;carry !== 0 && i2 < a.length; i2++)
            r = (a.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
          if (carry === 0 && i2 < a.length && a !== this)
            for (;i2 < a.length; i2++)
              this.words[i2] = a.words[i2];
          if (this.length = Math.max(this.length, i2), a !== this)
            this.negative = 1;
          return this.strip();
        }, BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len2 = self2.length + num.length | 0;
          out.length = len2, len2 = len2 - 1 | 0;
          var a = self2.words[0] | 0, b = num.words[0] | 0, r = a * b, lo = r & 67108863, carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1;k < len2; k++) {
            var ncarry = carry >>> 26, rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
              var i2 = k - j | 0;
              a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b + rword, ncarry += r / 67108864 | 0, rword = r & 67108863;
            }
            out.words[k] = rword | 0, carry = ncarry | 0;
          }
          if (carry !== 0)
            out.words[k] = carry | 0;
          else
            out.length--;
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo(self2, num, out) {
          var a = self2.words, b = num.words, o = out.words, c = 0, lo, mid, hi, a0 = a[0] | 0, al0 = a0 & 8191, ah0 = a0 >>> 13, a1 = a[1] | 0, al1 = a1 & 8191, ah1 = a1 >>> 13, a2 = a[2] | 0, al2 = a2 & 8191, ah2 = a2 >>> 13, a3 = a[3] | 0, al3 = a3 & 8191, ah3 = a3 >>> 13, a4 = a[4] | 0, al4 = a4 & 8191, ah4 = a4 >>> 13, a5 = a[5] | 0, al5 = a5 & 8191, ah5 = a5 >>> 13, a6 = a[6] | 0, al6 = a6 & 8191, ah6 = a6 >>> 13, a7 = a[7] | 0, al7 = a7 & 8191, ah7 = a7 >>> 13, a8 = a[8] | 0, al8 = a8 & 8191, ah8 = a8 >>> 13, a9 = a[9] | 0, al9 = a9 & 8191, ah9 = a9 >>> 13, b0 = b[0] | 0, bl0 = b0 & 8191, bh0 = b0 >>> 13, b1 = b[1] | 0, bl1 = b1 & 8191, bh1 = b1 >>> 13, b2 = b[2] | 0, bl2 = b2 & 8191, bh2 = b2 >>> 13, b3 = b[3] | 0, bl3 = b3 & 8191, bh3 = b3 >>> 13, b4 = b[4] | 0, bl4 = b4 & 8191, bh4 = b4 >>> 13, b5 = b[5] | 0, bl5 = b5 & 8191, bh5 = b5 >>> 13, b6 = b[6] | 0, bl6 = b6 & 8191, bh6 = b6 >>> 13, b7 = b[7] | 0, bl7 = b7 & 8191, bh7 = b7 >>> 13, b8 = b[8] | 0, bl8 = b8 & 8191, bh8 = b8 >>> 13, b9 = b[9] | 0, bl9 = b9 & 8191, bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative, out.length = 19, lo = Math.imul(al0, bl0), mid = Math.imul(al0, bh0), mid = mid + Math.imul(ah0, bl0) | 0, hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, lo = Math.imul(al1, bl0), mid = Math.imul(al1, bh0), mid = mid + Math.imul(ah1, bl0) | 0, hi = Math.imul(ah1, bh0), lo = lo + Math.imul(al0, bl1) | 0, mid = mid + Math.imul(al0, bh1) | 0, mid = mid + Math.imul(ah0, bl1) | 0, hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 67108863, lo = Math.imul(al2, bl0), mid = Math.imul(al2, bh0), mid = mid + Math.imul(ah2, bl0) | 0, hi = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = mid + Math.imul(al1, bh1) | 0, mid = mid + Math.imul(ah1, bl1) | 0, hi = hi + Math.imul(ah1, bh1) | 0, lo = lo + Math.imul(al0, bl2) | 0, mid = mid + Math.imul(al0, bh2) | 0, mid = mid + Math.imul(ah0, bl2) | 0, hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 67108863, lo = Math.imul(al3, bl0), mid = Math.imul(al3, bh0), mid = mid + Math.imul(ah3, bl0) | 0, hi = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = mid + Math.imul(al2, bh1) | 0, mid = mid + Math.imul(ah2, bl1) | 0, hi = hi + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = mid + Math.imul(al1, bh2) | 0, mid = mid + Math.imul(ah1, bl2) | 0, hi = hi + Math.imul(ah1, bh2) | 0, lo = lo + Math.imul(al0, bl3) | 0, mid = mid + Math.imul(al0, bh3) | 0, mid = mid + Math.imul(ah0, bl3) | 0, hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 67108863, lo = Math.imul(al4, bl0), mid = Math.imul(al4, bh0), mid = mid + Math.imul(ah4, bl0) | 0, hi = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = mid + Math.imul(al3, bh1) | 0, mid = mid + Math.imul(ah3, bl1) | 0, hi = hi + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = mid + Math.imul(al2, bh2) | 0, mid = mid + Math.imul(ah2, bl2) | 0, hi = hi + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = mid + Math.imul(al1, bh3) | 0, mid = mid + Math.imul(ah1, bl3) | 0, hi = hi + Math.imul(ah1, bh3) | 0, lo = lo + Math.imul(al0, bl4) | 0, mid = mid + Math.imul(al0, bh4) | 0, mid = mid + Math.imul(ah0, bl4) | 0, hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 67108863, lo = Math.imul(al5, bl0), mid = Math.imul(al5, bh0), mid = mid + Math.imul(ah5, bl0) | 0, hi = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = mid + Math.imul(al4, bh1) | 0, mid = mid + Math.imul(ah4, bl1) | 0, hi = hi + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = mid + Math.imul(al3, bh2) | 0, mid = mid + Math.imul(ah3, bl2) | 0, hi = hi + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = mid + Math.imul(al2, bh3) | 0, mid = mid + Math.imul(ah2, bl3) | 0, hi = hi + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = mid + Math.imul(al1, bh4) | 0, mid = mid + Math.imul(ah1, bl4) | 0, hi = hi + Math.imul(ah1, bh4) | 0, lo = lo + Math.imul(al0, bl5) | 0, mid = mid + Math.imul(al0, bh5) | 0, mid = mid + Math.imul(ah0, bl5) | 0, hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 67108863, lo = Math.imul(al6, bl0), mid = Math.imul(al6, bh0), mid = mid + Math.imul(ah6, bl0) | 0, hi = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = mid + Math.imul(al5, bh1) | 0, mid = mid + Math.imul(ah5, bl1) | 0, hi = hi + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = mid + Math.imul(al4, bh2) | 0, mid = mid + Math.imul(ah4, bl2) | 0, hi = hi + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = mid + Math.imul(al3, bh3) | 0, mid = mid + Math.imul(ah3, bl3) | 0, hi = hi + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = mid + Math.imul(al2, bh4) | 0, mid = mid + Math.imul(ah2, bl4) | 0, hi = hi + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = mid + Math.imul(al1, bh5) | 0, mid = mid + Math.imul(ah1, bl5) | 0, hi = hi + Math.imul(ah1, bh5) | 0, lo = lo + Math.imul(al0, bl6) | 0, mid = mid + Math.imul(al0, bh6) | 0, mid = mid + Math.imul(ah0, bl6) | 0, hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 67108863, lo = Math.imul(al7, bl0), mid = Math.imul(al7, bh0), mid = mid + Math.imul(ah7, bl0) | 0, hi = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = mid + Math.imul(al6, bh1) | 0, mid = mid + Math.imul(ah6, bl1) | 0, hi = hi + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = mid + Math.imul(al5, bh2) | 0, mid = mid + Math.imul(ah5, bl2) | 0, hi = hi + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = mid + Math.imul(al4, bh3) | 0, mid = mid + Math.imul(ah4, bl3) | 0, hi = hi + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = mid + Math.imul(al3, bh4) | 0, mid = mid + Math.imul(ah3, bl4) | 0, hi = hi + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = mid + Math.imul(al2, bh5) | 0, mid = mid + Math.imul(ah2, bl5) | 0, hi = hi + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = mid + Math.imul(al1, bh6) | 0, mid = mid + Math.imul(ah1, bl6) | 0, hi = hi + Math.imul(ah1, bh6) | 0, lo = lo + Math.imul(al0, bl7) | 0, mid = mid + Math.imul(al0, bh7) | 0, mid = mid + Math.imul(ah0, bl7) | 0, hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 67108863, lo = Math.imul(al8, bl0), mid = Math.imul(al8, bh0), mid = mid + Math.imul(ah8, bl0) | 0, hi = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = mid + Math.imul(al7, bh1) | 0, mid = mid + Math.imul(ah7, bl1) | 0, hi = hi + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = mid + Math.imul(al6, bh2) | 0, mid = mid + Math.imul(ah6, bl2) | 0, hi = hi + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = mid + Math.imul(al5, bh3) | 0, mid = mid + Math.imul(ah5, bl3) | 0, hi = hi + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = mid + Math.imul(al4, bh4) | 0, mid = mid + Math.imul(ah4, bl4) | 0, hi = hi + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = mid + Math.imul(al3, bh5) | 0, mid = mid + Math.imul(ah3, bl5) | 0, hi = hi + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = mid + Math.imul(al2, bh6) | 0, mid = mid + Math.imul(ah2, bl6) | 0, hi = hi + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = mid + Math.imul(al1, bh7) | 0, mid = mid + Math.imul(ah1, bl7) | 0, hi = hi + Math.imul(ah1, bh7) | 0, lo = lo + Math.imul(al0, bl8) | 0, mid = mid + Math.imul(al0, bh8) | 0, mid = mid + Math.imul(ah0, bl8) | 0, hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, lo = Math.imul(al9, bl0), mid = Math.imul(al9, bh0), mid = mid + Math.imul(ah9, bl0) | 0, hi = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = mid + Math.imul(al8, bh1) | 0, mid = mid + Math.imul(ah8, bl1) | 0, hi = hi + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = mid + Math.imul(al7, bh2) | 0, mid = mid + Math.imul(ah7, bl2) | 0, hi = hi + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = mid + Math.imul(al6, bh3) | 0, mid = mid + Math.imul(ah6, bl3) | 0, hi = hi + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = mid + Math.imul(al5, bh4) | 0, mid = mid + Math.imul(ah5, bl4) | 0, hi = hi + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = mid + Math.imul(al4, bh5) | 0, mid = mid + Math.imul(ah4, bl5) | 0, hi = hi + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = mid + Math.imul(al3, bh6) | 0, mid = mid + Math.imul(ah3, bl6) | 0, hi = hi + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = mid + Math.imul(al2, bh7) | 0, mid = mid + Math.imul(ah2, bl7) | 0, hi = hi + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = mid + Math.imul(al1, bh8) | 0, mid = mid + Math.imul(ah1, bl8) | 0, hi = hi + Math.imul(ah1, bh8) | 0, lo = lo + Math.imul(al0, bl9) | 0, mid = mid + Math.imul(al0, bh9) | 0, mid = mid + Math.imul(ah0, bl9) | 0, hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 67108863, lo = Math.imul(al9, bl1), mid = Math.imul(al9, bh1), mid = mid + Math.imul(ah9, bl1) | 0, hi = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = mid + Math.imul(al8, bh2) | 0, mid = mid + Math.imul(ah8, bl2) | 0, hi = hi + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = mid + Math.imul(al7, bh3) | 0, mid = mid + Math.imul(ah7, bl3) | 0, hi = hi + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = mid + Math.imul(al6, bh4) | 0, mid = mid + Math.imul(ah6, bl4) | 0, hi = hi + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = mid + Math.imul(al5, bh5) | 0, mid = mid + Math.imul(ah5, bl5) | 0, hi = hi + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = mid + Math.imul(al4, bh6) | 0, mid = mid + Math.imul(ah4, bl6) | 0, hi = hi + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = mid + Math.imul(al3, bh7) | 0, mid = mid + Math.imul(ah3, bl7) | 0, hi = hi + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = mid + Math.imul(al2, bh8) | 0, mid = mid + Math.imul(ah2, bl8) | 0, hi = hi + Math.imul(ah2, bh8) | 0, lo = lo + Math.imul(al1, bl9) | 0, mid = mid + Math.imul(al1, bh9) | 0, mid = mid + Math.imul(ah1, bl9) | 0, hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 67108863, lo = Math.imul(al9, bl2), mid = Math.imul(al9, bh2), mid = mid + Math.imul(ah9, bl2) | 0, hi = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = mid + Math.imul(al8, bh3) | 0, mid = mid + Math.imul(ah8, bl3) | 0, hi = hi + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = mid + Math.imul(al7, bh4) | 0, mid = mid + Math.imul(ah7, bl4) | 0, hi = hi + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = mid + Math.imul(al6, bh5) | 0, mid = mid + Math.imul(ah6, bl5) | 0, hi = hi + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = mid + Math.imul(al5, bh6) | 0, mid = mid + Math.imul(ah5, bl6) | 0, hi = hi + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = mid + Math.imul(al4, bh7) | 0, mid = mid + Math.imul(ah4, bl7) | 0, hi = hi + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = mid + Math.imul(al3, bh8) | 0, mid = mid + Math.imul(ah3, bl8) | 0, hi = hi + Math.imul(ah3, bh8) | 0, lo = lo + Math.imul(al2, bl9) | 0, mid = mid + Math.imul(al2, bh9) | 0, mid = mid + Math.imul(ah2, bl9) | 0, hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 67108863, lo = Math.imul(al9, bl3), mid = Math.imul(al9, bh3), mid = mid + Math.imul(ah9, bl3) | 0, hi = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = mid + Math.imul(al8, bh4) | 0, mid = mid + Math.imul(ah8, bl4) | 0, hi = hi + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = mid + Math.imul(al7, bh5) | 0, mid = mid + Math.imul(ah7, bl5) | 0, hi = hi + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = mid + Math.imul(al6, bh6) | 0, mid = mid + Math.imul(ah6, bl6) | 0, hi = hi + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = mid + Math.imul(al5, bh7) | 0, mid = mid + Math.imul(ah5, bl7) | 0, hi = hi + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = mid + Math.imul(al4, bh8) | 0, mid = mid + Math.imul(ah4, bl8) | 0, hi = hi + Math.imul(ah4, bh8) | 0, lo = lo + Math.imul(al3, bl9) | 0, mid = mid + Math.imul(al3, bh9) | 0, mid = mid + Math.imul(ah3, bl9) | 0, hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 67108863, lo = Math.imul(al9, bl4), mid = Math.imul(al9, bh4), mid = mid + Math.imul(ah9, bl4) | 0, hi = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = mid + Math.imul(al8, bh5) | 0, mid = mid + Math.imul(ah8, bl5) | 0, hi = hi + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = mid + Math.imul(al7, bh6) | 0, mid = mid + Math.imul(ah7, bl6) | 0, hi = hi + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = mid + Math.imul(al6, bh7) | 0, mid = mid + Math.imul(ah6, bl7) | 0, hi = hi + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = mid + Math.imul(al5, bh8) | 0, mid = mid + Math.imul(ah5, bl8) | 0, hi = hi + Math.imul(ah5, bh8) | 0, lo = lo + Math.imul(al4, bl9) | 0, mid = mid + Math.imul(al4, bh9) | 0, mid = mid + Math.imul(ah4, bl9) | 0, hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 67108863, lo = Math.imul(al9, bl5), mid = Math.imul(al9, bh5), mid = mid + Math.imul(ah9, bl5) | 0, hi = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = mid + Math.imul(al8, bh6) | 0, mid = mid + Math.imul(ah8, bl6) | 0, hi = hi + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = mid + Math.imul(al7, bh7) | 0, mid = mid + Math.imul(ah7, bl7) | 0, hi = hi + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = mid + Math.imul(al6, bh8) | 0, mid = mid + Math.imul(ah6, bl8) | 0, hi = hi + Math.imul(ah6, bh8) | 0, lo = lo + Math.imul(al5, bl9) | 0, mid = mid + Math.imul(al5, bh9) | 0, mid = mid + Math.imul(ah5, bl9) | 0, hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 67108863, lo = Math.imul(al9, bl6), mid = Math.imul(al9, bh6), mid = mid + Math.imul(ah9, bl6) | 0, hi = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = mid + Math.imul(al8, bh7) | 0, mid = mid + Math.imul(ah8, bl7) | 0, hi = hi + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = mid + Math.imul(al7, bh8) | 0, mid = mid + Math.imul(ah7, bl8) | 0, hi = hi + Math.imul(ah7, bh8) | 0, lo = lo + Math.imul(al6, bl9) | 0, mid = mid + Math.imul(al6, bh9) | 0, mid = mid + Math.imul(ah6, bl9) | 0, hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 67108863, lo = Math.imul(al9, bl7), mid = Math.imul(al9, bh7), mid = mid + Math.imul(ah9, bl7) | 0, hi = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = mid + Math.imul(al8, bh8) | 0, mid = mid + Math.imul(ah8, bl8) | 0, hi = hi + Math.imul(ah8, bh8) | 0, lo = lo + Math.imul(al7, bl9) | 0, mid = mid + Math.imul(al7, bh9) | 0, mid = mid + Math.imul(ah7, bl9) | 0, hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 67108863, lo = Math.imul(al9, bl8), mid = Math.imul(al9, bh8), mid = mid + Math.imul(ah9, bl8) | 0, hi = Math.imul(ah9, bh8), lo = lo + Math.imul(al8, bl9) | 0, mid = mid + Math.imul(al8, bh9) | 0, mid = mid + Math.imul(ah8, bl9) | 0, hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 67108863, lo = Math.imul(al9, bl9), mid = Math.imul(al9, bh9), mid = mid + Math.imul(ah9, bl9) | 0, hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          if (c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, c !== 0)
            o[19] = c, out.length++;
          return out;
        };
        if (!Math.imul)
          comb10MulTo = smallMulTo;
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative, out.length = self2.length + num.length;
          var carry = 0, hncarry = 0;
          for (var k = 0;k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
              var i2 = k - j, a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b, lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0, lo = lo + rword | 0, rword = lo & 67108863, ncarry = ncarry + (lo >>> 26) | 0, hncarry += ncarry >>> 26, ncarry &= 67108863;
            }
            out.words[k] = rword, carry = ncarry, ncarry = hncarry;
          }
          if (carry !== 0)
            out.words[k] = carry;
          else
            out.length--;
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM;
          return fftm.mulp(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res, len2 = this.length + num.length;
          if (this.length === 10 && num.length === 10)
            res = comb10MulTo(this, num, out);
          else if (len2 < 63)
            res = smallMulTo(this, num, out);
          else if (len2 < 1024)
            res = bigMulTo(this, num, out);
          else
            res = jumboMulTo(this, num, out);
          return res;
        };
        function FFTM(x, y) {
          this.x = x, this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N), l = BN.prototype._countBits(N) - 1;
          for (var i2 = 0;i2 < N; i2++)
            t[i2] = this.revBin(i2, l, N);
          return t;
        }, FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i2 = 0;i2 < l; i2++)
            rb |= (x & 1) << l - i2 - 1, x >>= 1;
          return rb;
        }, FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i2 = 0;i2 < N; i2++)
            rtws[i2] = rws[rbt[i2]], itws[i2] = iws[rbt[i2]];
        }, FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1;s < N; s <<= 1) {
            var l = s << 1, rtwdf = Math.cos(2 * Math.PI / l), itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0;p < N; p += l) {
              var rtwdf_ = rtwdf, itwdf_ = itwdf;
              for (var j = 0;j < s; j++) {
                var re = rtws[p + j], ie = itws[p + j], ro = rtws[p + j + s], io = itws[p + j + s], rx = rtwdf_ * ro - itwdf_ * io;
                if (io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p + j] = re + ro, itws[p + j] = ie + io, rtws[p + j + s] = re - ro, itws[p + j + s] = ie - io, j !== l)
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx;
              }
            }
          }
        }, FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1, odd = N & 1, i2 = 0;
          for (N = N / 2 | 0;N; N = N >>> 1)
            i2++;
          return 1 << i2 + 1 + odd;
        }, FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i2 = 0;i2 < N / 2; i2++) {
            var t = rws[i2];
            rws[i2] = rws[N - i2 - 1], rws[N - i2 - 1] = t, t = iws[i2], iws[i2] = -iws[N - i2 - 1], iws[N - i2 - 1] = -t;
          }
        }, FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i2 = 0;i2 < N / 2; i2++) {
            var w = Math.round(ws[2 * i2 + 1] / N) * 8192 + Math.round(ws[2 * i2] / N) + carry;
            if (ws[i2] = w & 67108863, w < 67108864)
              carry = 0;
            else
              carry = w / 67108864 | 0;
          }
          return ws;
        }, FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N) {
          var carry = 0;
          for (var i2 = 0;i2 < len2; i2++)
            carry = carry + (ws[i2] | 0), rws[2 * i2] = carry & 8191, carry = carry >>> 13, rws[2 * i2 + 1] = carry & 8191, carry = carry >>> 13;
          for (i2 = 2 * len2;i2 < N; ++i2)
            rws[i2] = 0;
          assert(carry === 0), assert((carry & -8192) === 0);
        }, FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i2 = 0;i2 < N; i2++)
            ph[i2] = 0;
          return ph;
        }, FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length), rbt = this.makeRBT(N), _ = this.stub(N), rws = new Array(N), rwst = new Array(N), iwst = new Array(N), nrws = new Array(N), nrwst = new Array(N), niwst = new Array(N), rmws = out.words;
          rmws.length = N, this.convert13b(x.words, x.length, rws, N), this.convert13b(y.words, y.length, nrws, N), this.transform(rws, _, rwst, iwst, N, rbt), this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i2 = 0;i2 < N; i2++) {
            var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
            iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2], rwst[i2] = rx;
          }
          return this.conjugate(rwst, iwst, N), this.transform(rwst, iwst, rmws, _, N, rbt), this.conjugate(rmws, _, N), this.normalize13b(rmws, N), out.negative = x.negative ^ y.negative, out.length = x.length + y.length, out.strip();
        }, BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          return out.words = new Array(this.length + num.length), this.mulTo(num, out);
        }, BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);
        }, BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        }, BN.prototype.imuln = function imuln(num) {
          assert(typeof num === "number"), assert(num < 67108864);
          var carry = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var w = (this.words[i2] | 0) * num, lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i2] = lo & 67108863;
          }
          if (carry !== 0)
            this.words[i2] = carry, this.length++;
          return this.length = num === 0 ? 1 : this.length, this;
        }, BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        }, BN.prototype.sqr = function sqr() {
          return this.mul(this);
        }, BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        }, BN.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN(1);
          var res = this;
          for (var i2 = 0;i2 < w.length; i2++, res = res.sqr())
            if (w[i2] !== 0)
              break;
          if (++i2 < w.length)
            for (var q = res.sqr();i2 < w.length; i2++, q = q.sqr()) {
              if (w[i2] === 0)
                continue;
              res = res.mul(q);
            }
          return res;
        }, BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26, s = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r, i2;
          if (r !== 0) {
            var carry = 0;
            for (i2 = 0;i2 < this.length; i2++) {
              var newCarry = this.words[i2] & carryMask, c = (this.words[i2] | 0) - newCarry << r;
              this.words[i2] = c | carry, carry = newCarry >>> 26 - r;
            }
            if (carry)
              this.words[i2] = carry, this.length++;
          }
          if (s !== 0) {
            for (i2 = this.length - 1;i2 >= 0; i2--)
              this.words[i2 + s] = this.words[i2];
            for (i2 = 0;i2 < s; i2++)
              this.words[i2] = 0;
            this.length += s;
          }
          return this.strip();
        }, BN.prototype.ishln = function ishln(bits) {
          return assert(this.negative === 0), this.iushln(bits);
        }, BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint)
            h = (hint - hint % 26) / 26;
          else
            h = 0;
          var r = bits % 26, s = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;
          if (h -= s, h = Math.max(0, h), maskedWords) {
            for (var i2 = 0;i2 < s; i2++)
              maskedWords.words[i2] = this.words[i2];
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i2 = 0;i2 < this.length; i2++)
              this.words[i2] = this.words[i2 + s];
          } else
            this.words[0] = 0, this.length = 1;
          var carry = 0;
          for (i2 = this.length - 1;i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
            var word = this.words[i2] | 0;
            this.words[i2] = carry << 26 - r | word >>> r, carry = word & mask;
          }
          if (maskedWords && carry !== 0)
            maskedWords.words[maskedWords.length++] = carry;
          if (this.length === 0)
            this.words[0] = 0, this.length = 1;
          return this.strip();
        }, BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          return assert(this.negative === 0), this.iushrn(bits, hint, extended);
        }, BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        }, BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        }, BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        }, BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        }, BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        }, BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26, s = (bits - r) / 26;
          if (assert(this.negative === 0, "imaskn works only with positive numbers"), this.length <= s)
            return this;
          if (r !== 0)
            s++;
          if (this.length = Math.min(s, this.length), r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        }, BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        }, BN.prototype.iaddn = function iaddn(num) {
          if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num)
              return this.words[0] = num - (this.words[0] | 0), this.negative = 0, this;
            return this.negative = 0, this.isubn(num), this.negative = 1, this;
          }
          return this._iaddn(num);
        }, BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i2 = 0;i2 < this.length && this.words[i2] >= 67108864; i2++)
            if (this.words[i2] -= 67108864, i2 === this.length - 1)
              this.words[i2 + 1] = 1;
            else
              this.words[i2 + 1]++;
          return this.length = Math.max(this.length, i2 + 1), this;
        }, BN.prototype.isubn = function isubn(num) {
          if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0)
            return this.negative = 0, this.iaddn(num), this.negative = 1, this;
          if (this.words[0] -= num, this.length === 1 && this.words[0] < 0)
            this.words[0] = -this.words[0], this.negative = 1;
          else
            for (var i2 = 0;i2 < this.length && this.words[i2] < 0; i2++)
              this.words[i2] += 67108864, this.words[i2 + 1] -= 1;
          return this.strip();
        }, BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        }, BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        }, BN.prototype.iabs = function iabs() {
          return this.negative = 0, this;
        }, BN.prototype.abs = function abs() {
          return this.clone().iabs();
        }, BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift2) {
          var len2 = num.length + shift2, i2;
          this._expand(len2);
          var w, carry = 0;
          for (i2 = 0;i2 < num.length; i2++) {
            w = (this.words[i2 + shift2] | 0) + carry;
            var right3 = (num.words[i2] | 0) * mul;
            w -= right3 & 67108863, carry = (w >> 26) - (right3 / 67108864 | 0), this.words[i2 + shift2] = w & 67108863;
          }
          for (;i2 < this.length - shift2; i2++)
            w = (this.words[i2 + shift2] | 0) + carry, carry = w >> 26, this.words[i2 + shift2] = w & 67108863;
          if (carry === 0)
            return this.strip();
          assert(carry === -1), carry = 0;
          for (i2 = 0;i2 < this.length; i2++)
            w = -(this.words[i2] | 0) + carry, carry = w >> 26, this.words[i2] = w & 67108863;
          return this.negative = 1, this.strip();
        }, BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift2 = this.length - num.length, a = this.clone(), b = num, bhi = b.words[b.length - 1] | 0, bhiBits = this._countBits(bhi);
          if (shift2 = 26 - bhiBits, shift2 !== 0)
            b = b.ushln(shift2), a.iushln(shift2), bhi = b.words[b.length - 1] | 0;
          var m = a.length - b.length, q;
          if (mode !== "mod") {
            q = new BN(null), q.length = m + 1, q.words = new Array(q.length);
            for (var i2 = 0;i2 < q.length; i2++)
              q.words[i2] = 0;
          }
          var diff8 = a.clone()._ishlnsubmul(b, 1, m);
          if (diff8.negative === 0) {
            if (a = diff8, q)
              q.words[m] = 1;
          }
          for (var j = m - 1;j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0)
              if (qj--, a.negative = 0, a._ishlnsubmul(b, 1, j), !a.isZero())
                a.negative ^= 1;
            if (q)
              q.words[j] = qj;
          }
          if (q)
            q.strip();
          if (a.strip(), mode !== "div" && shift2 !== 0)
            a.iushrn(shift2);
          return { div: q || null, mod: a };
        }, BN.prototype.divmod = function divmod(num, mode, positive2) {
          if (assert(!num.isZero()), this.isZero())
            return { div: new BN(0), mod: new BN(0) };
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            if (res = this.neg().divmod(num, mode), mode !== "mod")
              div = res.div.neg();
            if (mode !== "div") {
              if (mod = res.mod.neg(), positive2 && mod.negative !== 0)
                mod.iadd(num);
            }
            return { div, mod };
          }
          if (this.negative === 0 && num.negative !== 0) {
            if (res = this.divmod(num.neg(), mode), mode !== "mod")
              div = res.div.neg();
            return { div, mod: res.mod };
          }
          if ((this.negative & num.negative) !== 0) {
            if (res = this.neg().divmod(num.neg(), mode), mode !== "div") {
              if (mod = res.mod.neg(), positive2 && mod.negative !== 0)
                mod.isub(num);
            }
            return { div: res.div, mod };
          }
          if (num.length > this.length || this.cmp(num) < 0)
            return { div: new BN(0), mod: this };
          if (num.length === 1) {
            if (mode === "div")
              return { div: this.divn(num.words[0]), mod: null };
            if (mode === "mod")
              return { div: null, mod: new BN(this.modn(num.words[0])) };
            return { div: this.divn(num.words[0]), mod: new BN(this.modn(num.words[0])) };
          }
          return this._wordDiv(num, mode);
        }, BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        }, BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        }, BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        }, BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        }, BN.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = 67108864 % num, acc = 0;
          for (var i2 = this.length - 1;i2 >= 0; i2--)
            acc = (p * acc + (this.words[i2] | 0)) % num;
          return acc;
        }, BN.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i2 = this.length - 1;i2 >= 0; i2--) {
            var w = (this.words[i2] | 0) + carry * 67108864;
            this.words[i2] = w / num | 0, carry = w % num;
          }
          return this.strip();
        }, BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        }, BN.prototype.egcd = function egcd(p) {
          assert(p.negative === 0), assert(!p.isZero());
          var x = this, y = p.clone();
          if (x.negative !== 0)
            x = x.umod(p);
          else
            x = x.clone();
          var A = new BN(1), B = new BN(0), C = new BN(0), D = new BN(1), g = 0;
          while (x.isEven() && y.isEven())
            x.iushrn(1), y.iushrn(1), ++g;
          var yp = y.clone(), xp = x.clone();
          while (!x.isZero()) {
            for (var i2 = 0, im = 1;(x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
              ;
            if (i2 > 0) {
              x.iushrn(i2);
              while (i2-- > 0) {
                if (A.isOdd() || B.isOdd())
                  A.iadd(yp), B.isub(xp);
                A.iushrn(1), B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd())
                  C.iadd(yp), D.isub(xp);
                C.iushrn(1), D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0)
              x.isub(y), A.isub(C), B.isub(D);
            else
              y.isub(x), C.isub(A), D.isub(B);
          }
          return { a: C, b: D, gcd: y.iushln(g) };
        }, BN.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0), assert(!p.isZero());
          var a = this, b = p.clone();
          if (a.negative !== 0)
            a = a.umod(p);
          else
            a = a.clone();
          var x1 = new BN(1), x2 = new BN(0), delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i2 = 0, im = 1;(a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
              ;
            if (i2 > 0) {
              a.iushrn(i2);
              while (i2-- > 0) {
                if (x1.isOdd())
                  x1.iadd(delta);
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1;(b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd())
                  x2.iadd(delta);
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0)
              a.isub(b), x1.isub(x2);
            else
              b.isub(a), x2.isub(x1);
          }
          var res;
          if (a.cmpn(1) === 0)
            res = x1;
          else
            res = x2;
          if (res.cmpn(0) < 0)
            res.iadd(p);
          return res;
        }, BN.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone(), b = num.clone();
          a.negative = 0, b.negative = 0;
          for (var shift2 = 0;a.isEven() && b.isEven(); shift2++)
            a.iushrn(1), b.iushrn(1);
          do {
            while (a.isEven())
              a.iushrn(1);
            while (b.isEven())
              b.iushrn(1);
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b, b = t;
            } else if (r === 0 || b.cmpn(1) === 0)
              break;
            a.isub(b);
          } while (true);
          return b.iushln(shift2);
        }, BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        }, BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        }, BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        }, BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        }, BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
          if (this.length <= s)
            return this._expand(s + 1), this.words[s] |= q, this;
          var carry = q;
          for (var i2 = s;carry !== 0 && i2 < this.length; i2++) {
            var w = this.words[i2] | 0;
            w += carry, carry = w >>> 26, w &= 67108863, this.words[i2] = w;
          }
          if (carry !== 0)
            this.words[i2] = carry, this.length++;
          return this;
        }, BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        }, BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1)
            res = 1;
          else {
            if (negative)
              num = -num;
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        }, BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        }, BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i2 = this.length - 1;i2 >= 0; i2--) {
            var a = this.words[i2] | 0, b = num.words[i2] | 0;
            if (a === b)
              continue;
            if (a < b)
              res = -1;
            else if (a > b)
              res = 1;
            break;
          }
          return res;
        }, BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        }, BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        }, BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        }, BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        }, BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        }, BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        }, BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        }, BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        }, BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        }, BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        }, BN.red = function red(num) {
          return new Red(num);
        }, BN.prototype.toRed = function toRed(ctx) {
          return assert(!this.red, "Already a number in reduction context"), assert(this.negative === 0, "red works only with positives"), ctx.convertTo(this)._forceRed(ctx);
        }, BN.prototype.fromRed = function fromRed() {
          return assert(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
        }, BN.prototype._forceRed = function _forceRed(ctx) {
          return this.red = ctx, this;
        }, BN.prototype.forceRed = function forceRed(ctx) {
          return assert(!this.red, "Already a number in reduction context"), this._forceRed(ctx);
        }, BN.prototype.redAdd = function redAdd(num) {
          return assert(this.red, "redAdd works only with red numbers"), this.red.add(this, num);
        }, BN.prototype.redIAdd = function redIAdd(num) {
          return assert(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, num);
        }, BN.prototype.redSub = function redSub(num) {
          return assert(this.red, "redSub works only with red numbers"), this.red.sub(this, num);
        }, BN.prototype.redISub = function redISub(num) {
          return assert(this.red, "redISub works only with red numbers"), this.red.isub(this, num);
        }, BN.prototype.redShl = function redShl(num) {
          return assert(this.red, "redShl works only with red numbers"), this.red.shl(this, num);
        }, BN.prototype.redMul = function redMul(num) {
          return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.mul(this, num);
        }, BN.prototype.redIMul = function redIMul(num) {
          return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.imul(this, num);
        }, BN.prototype.redSqr = function redSqr() {
          return assert(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
        }, BN.prototype.redISqr = function redISqr() {
          return assert(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
        }, BN.prototype.redSqrt = function redSqrt() {
          return assert(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
        }, BN.prototype.redInvm = function redInvm() {
          return assert(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
        }, BN.prototype.redNeg = function redNeg() {
          return assert(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
        }, BN.prototype.redPow = function redPow(num) {
          return assert(this.red && !num.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, num);
        };
        var primes = { k256: null, p224: null, p192: null, p25519: null };
        function MPrime(name, p) {
          this.name = name, this.p = new BN(p, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;
        }, MPrime.prototype.ireduce = function ireduce(num) {
          var r = num, rlen;
          do
            this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), rlen = r.bitLength();
          while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0)
            r.words[0] = 0, r.length = 1;
          else if (cmp > 0)
            r.isub(this.p);
          else if (r.strip !== undefined)
            r.strip();
          else
            r._strip();
          return r;
        }, MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        }, MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        inherits2(K256, MPrime), K256.prototype.split = function split(input, output) {
          var mask = 4194303, outLen = Math.min(input.length, 9);
          for (var i2 = 0;i2 < outLen; i2++)
            output.words[i2] = input.words[i2];
          if (output.length = outLen, input.length <= 9) {
            input.words[0] = 0, input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i2 = 10;i2 < input.length; i2++) {
            var next = input.words[i2] | 0;
            input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22, prev = next;
          }
          if (prev >>>= 22, input.words[i2 - 10] = prev, prev === 0 && input.length > 10)
            input.length -= 10;
          else
            input.length -= 9;
        }, K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;
          var lo = 0;
          for (var i2 = 0;i2 < num.length; i2++) {
            var w = num.words[i2] | 0;
            lo += w * 977, num.words[i2] = lo & 67108863, lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            if (num.length--, num.words[num.length - 1] === 0)
              num.length--;
          }
          return num;
        };
        function P224() {
          MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        inherits2(P224, MPrime);
        function P192() {
          MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        inherits2(P192, MPrime);
        function P25519() {
          MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        inherits2(P25519, MPrime), P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i2 = 0;i2 < num.length; i2++) {
            var hi = (num.words[i2] | 0) * 19 + carry, lo = hi & 67108863;
            hi >>>= 26, num.words[i2] = lo, carry = hi;
          }
          if (carry !== 0)
            num.words[num.length++] = carry;
          return num;
        }, BN._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime;
          if (name === "k256")
            prime = new K256;
          else if (name === "p224")
            prime = new P224;
          else if (name === "p192")
            prime = new P192;
          else if (name === "p25519")
            prime = new P25519;
          else
            throw new Error("Unknown prime " + name);
          return primes[name] = prime, prime;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p, this.prime = prime;
          } else
            assert(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives"), assert(a.red, "red works only with red numbers");
        }, Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives"), assert(a.red && a.red === b.red, "red works only with red numbers");
        }, Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        }, Red.prototype.neg = function neg(a) {
          if (a.isZero())
            return a.clone();
          return this.m.sub(a)._forceRed(this);
        }, Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0)
            res.isub(this.m);
          return res._forceRed(this);
        }, Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0)
            res.isub(this.m);
          return res;
        }, Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0)
            res.iadd(this.m);
          return res._forceRed(this);
        }, Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0)
            res.iadd(this.m);
          return res;
        }, Red.prototype.shl = function shl(a, num) {
          return this._verify1(a), this.imod(a.ushln(num));
        }, Red.prototype.imul = function imul(a, b) {
          return this._verify2(a, b), this.imod(a.imul(b));
        }, Red.prototype.mul = function mul(a, b) {
          return this._verify2(a, b), this.imod(a.mul(b));
        }, Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        }, Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        }, Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          if (assert(mod3 % 2 === 1), mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1), s = 0;
          while (!q.isZero() && q.andln(1) === 0)
            s++, q.iushrn(1);
          assert(!q.isZero());
          var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0)
            z.redIAdd(nOne);
          var c = this.pow(z, q), r = this.pow(a, q.addn(1).iushrn(1)), t = this.pow(a, q), m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i2 = 0;tmp.cmp(one) !== 0; i2++)
              tmp = tmp.redSqr();
            assert(i2 < m);
            var b = this.pow(c, new BN(1).iushln(m - i2 - 1));
            r = r.redMul(b), c = b.redSqr(), t = t.redMul(c), m = i2;
          }
          return r;
        }, Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0)
            return inv.negative = 0, this.imod(inv).redNeg();
          else
            return this.imod(inv);
        }, Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4, wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this), wnd[1] = a;
          for (var i2 = 2;i2 < wnd.length; i2++)
            wnd[i2] = this.mul(wnd[i2 - 1], a);
          var res = wnd[0], current2 = 0, currentLen = 0, start4 = num.bitLength() % 26;
          if (start4 === 0)
            start4 = 26;
          for (i2 = num.length - 1;i2 >= 0; i2--) {
            var word = num.words[i2];
            for (var j = start4 - 1;j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0])
                res = this.sqr(res);
              if (bit === 0 && current2 === 0) {
                currentLen = 0;
                continue;
              }
              if (current2 <<= 1, current2 |= bit, currentLen++, currentLen !== windowSize && (i2 !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current2]), currentLen = 0, current2 = 0;
            }
            start4 = 26;
          }
          return res;
        }, Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        }, Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          return res.red = null, res;
        }, BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          if (Red.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 !== 0)
            this.shift += 26 - this.shift % 26;
          this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
        }
        inherits2(Mont, Red), Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        }, Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          return r.red = null, r;
        }, Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero())
            return a.words[0] = 0, a.length = 1, a;
          var t = a.imul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;
          if (u.cmp(this.m) >= 0)
            res = u.isub(this.m);
          else if (u.cmpn(0) < 0)
            res = u.iadd(this.m);
          return res._forceRed(this);
        }, Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN(0)._forceRed(this);
          var t = a.mul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;
          if (u.cmp(this.m) >= 0)
            res = u.isub(this.m);
          else if (u.cmpn(0) < 0)
            res = u.iadd(this.m);
          return res._forceRed(this);
        }, Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    });
    require_minimalistic_assert = __commonJS2((exports, module) => {
      module.exports = assert;
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      assert.equal = function assertEqual(l, r, msg) {
        if (l != r)
          throw new Error(msg || "Assertion failed: " + l + " != " + r);
      };
    });
    require_utils = __commonJS2((exports) => {
      var utils = exports;
      function toArray4(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg !== "string") {
          for (var i2 = 0;i2 < msg.length; i2++)
            res[i2] = msg[i2] | 0;
          return res;
        }
        if (enc === "hex") {
          if (msg = msg.replace(/[^a-z0-9]+/ig, ""), msg.length % 2 !== 0)
            msg = "0" + msg;
          for (var i2 = 0;i2 < msg.length; i2 += 2)
            res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
        } else
          for (var i2 = 0;i2 < msg.length; i2++) {
            var c = msg.charCodeAt(i2), hi = c >> 8, lo = c & 255;
            if (hi)
              res.push(hi, lo);
            else
              res.push(lo);
          }
        return res;
      }
      utils.toArray = toArray4;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      utils.zero2 = zero2;
      function toHex(msg) {
        var res = "";
        for (var i2 = 0;i2 < msg.length; i2++)
          res += zero2(msg[i2].toString(16));
        return res;
      }
      utils.toHex = toHex;
      utils.encode = function encode(arr, enc) {
        if (enc === "hex")
          return toHex(arr);
        else
          return arr;
      };
    });
    require_utils2 = __commonJS2((exports) => {
      var utils = exports, BN = require_bn(), minAssert = require_minimalistic_assert(), minUtils = require_utils();
      utils.assert = minAssert;
      utils.toArray = minUtils.toArray;
      utils.zero2 = minUtils.zero2;
      utils.toHex = minUtils.toHex;
      utils.encode = minUtils.encode;
      function getNAF(num, w, bits) {
        var naf = new Array(Math.max(num.bitLength(), bits) + 1), i2;
        for (i2 = 0;i2 < naf.length; i2 += 1)
          naf[i2] = 0;
        var ws = 1 << w + 1, k = num.clone();
        for (i2 = 0;i2 < naf.length; i2++) {
          var z, mod = k.andln(ws - 1);
          if (k.isOdd()) {
            if (mod > (ws >> 1) - 1)
              z = (ws >> 1) - mod;
            else
              z = mod;
            k.isubn(z);
          } else
            z = 0;
          naf[i2] = z, k.iushrn(1);
        }
        return naf;
      }
      utils.getNAF = getNAF;
      function getJSF(k1, k2) {
        var jsf = [[], []];
        k1 = k1.clone(), k2 = k2.clone();
        var d1 = 0, d2 = 0, m8;
        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
          var m14 = k1.andln(3) + d1 & 3, m24 = k2.andln(3) + d2 & 3;
          if (m14 === 3)
            m14 = -1;
          if (m24 === 3)
            m24 = -1;
          var u1;
          if ((m14 & 1) === 0)
            u1 = 0;
          else if (m8 = k1.andln(7) + d1 & 7, (m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
          jsf[0].push(u1);
          var u2;
          if ((m24 & 1) === 0)
            u2 = 0;
          else if (m8 = k2.andln(7) + d2 & 7, (m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
          if (jsf[1].push(u2), 2 * d1 === u1 + 1)
            d1 = 1 - d1;
          if (2 * d2 === u2 + 1)
            d2 = 1 - d2;
          k1.iushrn(1), k2.iushrn(1);
        }
        return jsf;
      }
      utils.getJSF = getJSF;
      function cachedProperty(obj, name, computer) {
        var key = "_" + name;
        obj.prototype[name] = function cachedProperty() {
          return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
        };
      }
      utils.cachedProperty = cachedProperty;
      function parseBytes(bytes) {
        return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
      }
      utils.parseBytes = parseBytes;
      function intFromLE(bytes) {
        return new BN(bytes, "hex", "le");
      }
      utils.intFromLE = intFromLE;
    });
    require_brorand = __commonJS2((exports, module) => {
      var r;
      module.exports = function rand(len2) {
        if (!r)
          r = new Rand(null);
        return r.generate(len2);
      };
      function Rand(rand) {
        this.rand = rand;
      }
      module.exports.Rand = Rand;
      Rand.prototype.generate = function generate(len2) {
        return this._rand(len2);
      };
      Rand.prototype._rand = function _rand(n) {
        if (this.rand.getBytes)
          return this.rand.getBytes(n);
        var res = new Uint8Array(n);
        for (var i2 = 0;i2 < res.length; i2++)
          res[i2] = this.rand.getByte();
        return res;
      };
      if (typeof self === "object") {
        if (self.crypto && self.crypto.getRandomValues)
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            return self.crypto.getRandomValues(arr), arr;
          };
        else if (self.msCrypto && self.msCrypto.getRandomValues)
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            return self.msCrypto.getRandomValues(arr), arr;
          };
        else if (typeof window === "object")
          Rand.prototype._rand = function() {
            throw new Error("Not implemented yet");
          };
      } else
        try {
          if (crypto2 = (init_crypto(), __toCommonJS(exports_crypto)), typeof crypto2.randomBytes !== "function")
            throw new Error("Not supported");
          Rand.prototype._rand = function _rand(n) {
            return crypto2.randomBytes(n);
          };
        } catch (e) {}
      var crypto2;
    });
    require_base = __commonJS2((exports, module) => {
      var BN = require_bn(), utils = require_utils2(), getNAF = utils.getNAF, getJSF = utils.getJSF, assert = utils.assert;
      function BaseCurve(type, conf) {
        this.type = type, this.p = new BN(conf.p, 16), this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p), this.zero = new BN(0).toRed(this.red), this.one = new BN(1).toRed(this.red), this.two = new BN(2).toRed(this.red), this.n = conf.n && new BN(conf.n, 16), this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
        var adjustCount = this.n && this.p.div(this.n);
        if (!adjustCount || adjustCount.cmpn(100) > 0)
          this.redN = null;
        else
          this._maxwellTrick = true, this.redN = this.n.toRed(this.red);
      }
      module.exports = BaseCurve;
      BaseCurve.prototype.point = function point() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype.validate = function validate() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
        assert(p.precomputed);
        var doubles = p._getDoubles(), naf = getNAF(k, 1, this._bitLength), I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
        I /= 3;
        var repr = [], j, nafW;
        for (j = 0;j < naf.length; j += doubles.step) {
          nafW = 0;
          for (var l = j + doubles.step - 1;l >= j; l--)
            nafW = (nafW << 1) + naf[l];
          repr.push(nafW);
        }
        var a = this.jpoint(null, null, null), b = this.jpoint(null, null, null);
        for (var i2 = I;i2 > 0; i2--) {
          for (j = 0;j < repr.length; j++)
            if (nafW = repr[j], nafW === i2)
              b = b.mixedAdd(doubles.points[j]);
            else if (nafW === -i2)
              b = b.mixedAdd(doubles.points[j].neg());
          a = a.add(b);
        }
        return a.toP();
      };
      BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
        var w = 4, nafPoints = p._getNAFPoints(w);
        w = nafPoints.wnd;
        var wnd = nafPoints.points, naf = getNAF(k, w, this._bitLength), acc = this.jpoint(null, null, null);
        for (var i2 = naf.length - 1;i2 >= 0; i2--) {
          for (var l = 0;i2 >= 0 && naf[i2] === 0; i2--)
            l++;
          if (i2 >= 0)
            l++;
          if (acc = acc.dblp(l), i2 < 0)
            break;
          var z = naf[i2];
          if (assert(z !== 0), p.type === "affine")
            if (z > 0)
              acc = acc.mixedAdd(wnd[z - 1 >> 1]);
            else
              acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
          else if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
        return p.type === "affine" ? acc.toP() : acc;
      };
      BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len2, jacobianResult) {
        var wndWidth = this._wnafT1, wnd = this._wnafT2, naf = this._wnafT3, max5 = 0, i2, j, p;
        for (i2 = 0;i2 < len2; i2++) {
          p = points[i2];
          var nafPoints = p._getNAFPoints(defW);
          wndWidth[i2] = nafPoints.wnd, wnd[i2] = nafPoints.points;
        }
        for (i2 = len2 - 1;i2 >= 1; i2 -= 2) {
          var a = i2 - 1, b = i2;
          if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
            naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength), naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength), max5 = Math.max(naf[a].length, max5), max5 = Math.max(naf[b].length, max5);
            continue;
          }
          var comb = [points[a], null, null, points[b]];
          if (points[a].y.cmp(points[b].y) === 0)
            comb[1] = points[a].add(points[b]), comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          else if (points[a].y.cmp(points[b].y.redNeg()) === 0)
            comb[1] = points[a].toJ().mixedAdd(points[b]), comb[2] = points[a].add(points[b].neg());
          else
            comb[1] = points[a].toJ().mixedAdd(points[b]), comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          var index = [-3, -1, -5, -7, 0, 7, 5, 1, 3], jsf = getJSF(coeffs[a], coeffs[b]);
          max5 = Math.max(jsf[0].length, max5), naf[a] = new Array(max5), naf[b] = new Array(max5);
          for (j = 0;j < max5; j++) {
            var ja = jsf[0][j] | 0, jb = jsf[1][j] | 0;
            naf[a][j] = index[(ja + 1) * 3 + (jb + 1)], naf[b][j] = 0, wnd[a] = comb;
          }
        }
        var acc = this.jpoint(null, null, null), tmp = this._wnafT4;
        for (i2 = max5;i2 >= 0; i2--) {
          var k = 0;
          while (i2 >= 0) {
            var zero2 = true;
            for (j = 0;j < len2; j++)
              if (tmp[j] = naf[j][i2] | 0, tmp[j] !== 0)
                zero2 = false;
            if (!zero2)
              break;
            k++, i2--;
          }
          if (i2 >= 0)
            k++;
          if (acc = acc.dblp(k), i2 < 0)
            break;
          for (j = 0;j < len2; j++) {
            var z = tmp[j];
            if (z === 0)
              continue;
            else if (z > 0)
              p = wnd[j][z - 1 >> 1];
            else if (z < 0)
              p = wnd[j][-z - 1 >> 1].neg();
            if (p.type === "affine")
              acc = acc.mixedAdd(p);
            else
              acc = acc.add(p);
          }
        }
        for (i2 = 0;i2 < len2; i2++)
          wnd[i2] = null;
        if (jacobianResult)
          return acc;
        else
          return acc.toP();
      };
      function BasePoint(curve, type) {
        this.curve = curve, this.type = type, this.precomputed = null;
      }
      BaseCurve.BasePoint = BasePoint;
      BasePoint.prototype.eq = function eq() {
        throw new Error("Not implemented");
      };
      BasePoint.prototype.validate = function validate() {
        return this.curve.validate(this);
      };
      BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        bytes = utils.toArray(bytes, enc);
        var len2 = this.p.byteLength();
        if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len2) {
          if (bytes[0] === 6)
            assert(bytes[bytes.length - 1] % 2 === 0);
          else if (bytes[0] === 7)
            assert(bytes[bytes.length - 1] % 2 === 1);
          var res = this.point(bytes.slice(1, 1 + len2), bytes.slice(1 + len2, 1 + 2 * len2));
          return res;
        } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len2)
          return this.pointFromX(bytes.slice(1, 1 + len2), bytes[0] === 3);
        throw new Error("Unknown point format");
      };
      BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
        return this.encode(enc, true);
      };
      BasePoint.prototype._encode = function _encode(compact2) {
        var len2 = this.curve.p.byteLength(), x = this.getX().toArray("be", len2);
        if (compact2)
          return [this.getY().isEven() ? 2 : 3].concat(x);
        return [4].concat(x, this.getY().toArray("be", len2));
      };
      BasePoint.prototype.encode = function encode(enc, compact2) {
        return utils.encode(this._encode(compact2), enc);
      };
      BasePoint.prototype.precompute = function precompute(power) {
        if (this.precomputed)
          return this;
        var precomputed = { doubles: null, naf: null, beta: null };
        return precomputed.naf = this._getNAFPoints(8), precomputed.doubles = this._getDoubles(4, power), precomputed.beta = this._getBeta(), this.precomputed = precomputed, this;
      };
      BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
        if (!this.precomputed)
          return false;
        var doubles = this.precomputed.doubles;
        if (!doubles)
          return false;
        return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
      };
      BasePoint.prototype._getDoubles = function _getDoubles(step4, power) {
        if (this.precomputed && this.precomputed.doubles)
          return this.precomputed.doubles;
        var doubles = [this], acc = this;
        for (var i2 = 0;i2 < power; i2 += step4) {
          for (var j = 0;j < step4; j++)
            acc = acc.dbl();
          doubles.push(acc);
        }
        return { step: step4, points: doubles };
      };
      BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
        if (this.precomputed && this.precomputed.naf)
          return this.precomputed.naf;
        var res = [this], max5 = (1 << wnd) - 1, dbl = max5 === 1 ? null : this.dbl();
        for (var i2 = 1;i2 < max5; i2++)
          res[i2] = res[i2 - 1].add(dbl);
        return { wnd, points: res };
      };
      BasePoint.prototype._getBeta = function _getBeta() {
        return null;
      };
      BasePoint.prototype.dblp = function dblp(k) {
        var r = this;
        for (var i2 = 0;i2 < k; i2++)
          r = r.dbl();
        return r;
      };
    });
    require_inherits_browser = __commonJS2((exports, module) => {
      if (typeof Object.create === "function")
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor)
            ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
        };
      else
        module.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
          }
        };
    });
    require_inherits = __commonJS2((exports, module) => {
      try {
        if (util = (init_util(), __toCommonJS(exports_util2)), typeof util.inherits !== "function")
          throw "";
        module.exports = util.inherits;
      } catch (e) {
        module.exports = require_inherits_browser();
      }
      var util;
    });
    require_short = __commonJS2((exports, module) => {
      var utils = require_utils2(), BN = require_bn(), inherits2 = require_inherits(), Base3 = require_base(), assert = utils.assert;
      function ShortCurve(conf) {
        Base3.call(this, "short", conf), this.a = new BN(conf.a, 16).toRed(this.red), this.b = new BN(conf.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(conf), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
      }
      inherits2(ShortCurve, Base3);
      module.exports = ShortCurve;
      ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
        if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
          return;
        var beta, lambda;
        if (conf.beta)
          beta = new BN(conf.beta, 16).toRed(this.red);
        else {
          var betas = this._getEndoRoots(this.p);
          beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1], beta = beta.toRed(this.red);
        }
        if (conf.lambda)
          lambda = new BN(conf.lambda, 16);
        else {
          var lambdas = this._getEndoRoots(this.n);
          if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0)
            lambda = lambdas[0];
          else
            lambda = lambdas[1], assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
        var basis;
        if (conf.basis)
          basis = conf.basis.map(function(vec) {
            return { a: new BN(vec.a, 16), b: new BN(vec.b, 16) };
          });
        else
          basis = this._getEndoBasis(lambda);
        return { beta, lambda, basis };
      };
      ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
        var red = num === this.p ? this.red : BN.mont(num), tinv = new BN(2).toRed(red).redInvm(), ntinv = tinv.redNeg(), s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv), l1 = ntinv.redAdd(s).fromRed(), l2 = ntinv.redSub(s).fromRed();
        return [l1, l2];
      };
      ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
        var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), u = lambda, v = this.n.clone(), x1 = new BN(1), y1 = new BN(0), x2 = new BN(0), y2 = new BN(1), a0, b0, a1, b1, a2, b2, prevR, i2 = 0, r, x;
        while (u.cmpn(0) !== 0) {
          var q = v.div(u);
          r = v.sub(q.mul(u)), x = x2.sub(q.mul(x1));
          var y = y2.sub(q.mul(y1));
          if (!a1 && r.cmp(aprxSqrt) < 0)
            a0 = prevR.neg(), b0 = x1, a1 = r.neg(), b1 = x;
          else if (a1 && ++i2 === 2)
            break;
          prevR = r, v = u, u = r, x2 = x1, x1 = x, y2 = y1, y1 = y;
        }
        a2 = r.neg(), b2 = x;
        var len1 = a1.sqr().add(b1.sqr()), len2 = a2.sqr().add(b2.sqr());
        if (len2.cmp(len1) >= 0)
          a2 = a0, b2 = b0;
        if (a1.negative)
          a1 = a1.neg(), b1 = b1.neg();
        if (a2.negative)
          a2 = a2.neg(), b2 = b2.neg();
        return [{ a: a1, b: b1 }, { a: a2, b: b2 }];
      };
      ShortCurve.prototype._endoSplit = function _endoSplit(k) {
        var basis = this.endo.basis, v1 = basis[0], v2 = basis[1], c1 = v2.b.mul(k).divRound(this.n), c2 = v1.b.neg().mul(k).divRound(this.n), p1 = c1.mul(v1.a), p2 = c2.mul(v2.a), q1 = c1.mul(v1.b), q2 = c2.mul(v2.b), k1 = k.sub(p1).sub(p2), k2 = q1.add(q2).neg();
        return { k1, k2 };
      };
      ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
        if (x = new BN(x, 16), !x.red)
          x = x.toRed(this.red);
        var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b), y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      ShortCurve.prototype.validate = function validate(point) {
        if (point.inf)
          return true;
        var { x, y } = point, ax = this.a.redMul(x), rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
        return y.redSqr().redISub(rhs).cmpn(0) === 0;
      };
      ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
        var npoints = this._endoWnafT1, ncoeffs = this._endoWnafT2;
        for (var i2 = 0;i2 < points.length; i2++) {
          var split3 = this._endoSplit(coeffs[i2]), p = points[i2], beta = p._getBeta();
          if (split3.k1.negative)
            split3.k1.ineg(), p = p.neg(true);
          if (split3.k2.negative)
            split3.k2.ineg(), beta = beta.neg(true);
          npoints[i2 * 2] = p, npoints[i2 * 2 + 1] = beta, ncoeffs[i2 * 2] = split3.k1, ncoeffs[i2 * 2 + 1] = split3.k2;
        }
        var res = this._wnafMulAdd(1, npoints, ncoeffs, i2 * 2, jacobianResult);
        for (var j = 0;j < i2 * 2; j++)
          npoints[j] = null, ncoeffs[j] = null;
        return res;
      };
      function Point(curve, x, y, isRed) {
        if (Base3.BasePoint.call(this, curve, "affine"), x === null && y === null)
          this.x = null, this.y = null, this.inf = true;
        else {
          if (this.x = new BN(x, 16), this.y = new BN(y, 16), isRed)
            this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          this.inf = false;
        }
      }
      inherits2(Point, Base3.BasePoint);
      ShortCurve.prototype.point = function point(x, y, isRed) {
        return new Point(this, x, y, isRed);
      };
      ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
        return Point.fromJSON(this, obj, red);
      };
      Point.prototype._getBeta = function _getBeta() {
        if (!this.curve.endo)
          return;
        var pre = this.precomputed;
        if (pre && pre.beta)
          return pre.beta;
        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (pre) {
          var curve = this.curve, endoMul = function(p) {
            return curve.point(p.x.redMul(curve.endo.beta), p.y);
          };
          pre.beta = beta, beta.precomputed = { beta: null, naf: pre.naf && { wnd: pre.naf.wnd, points: pre.naf.points.map(endoMul) }, doubles: pre.doubles && { step: pre.doubles.step, points: pre.doubles.points.map(endoMul) } };
        }
        return beta;
      };
      Point.prototype.toJSON = function toJSON() {
        if (!this.precomputed)
          return [this.x, this.y];
        return [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }];
      };
      Point.fromJSON = function fromJSON(curve, obj, red) {
        if (typeof obj === "string")
          obj = JSON.parse(obj);
        var res = curve.point(obj[0], obj[1], red);
        if (!obj[2])
          return res;
        function obj2point(obj2) {
          return curve.point(obj2[0], obj2[1], red);
        }
        var pre = obj[2];
        return res.precomputed = { beta: null, doubles: pre.doubles && { step: pre.doubles.step, points: [res].concat(pre.doubles.points.map(obj2point)) }, naf: pre.naf && { wnd: pre.naf.wnd, points: [res].concat(pre.naf.points.map(obj2point)) } }, res;
      };
      Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.inf;
      };
      Point.prototype.add = function add(p) {
        if (this.inf)
          return p;
        if (p.inf)
          return this;
        if (this.eq(p))
          return this.dbl();
        if (this.neg().eq(p))
          return this.curve.point(null, null);
        if (this.x.cmp(p.x) === 0)
          return this.curve.point(null, null);
        var c = this.y.redSub(p.y);
        if (c.cmpn(0) !== 0)
          c = c.redMul(this.x.redSub(p.x).redInvm());
        var nx = c.redSqr().redISub(this.x).redISub(p.x), ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.dbl = function dbl() {
        if (this.inf)
          return this;
        var ys1 = this.y.redAdd(this.y);
        if (ys1.cmpn(0) === 0)
          return this.curve.point(null, null);
        var a = this.curve.a, x2 = this.x.redSqr(), dyinv = ys1.redInvm(), c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv), nx = c.redSqr().redISub(this.x.redAdd(this.x)), ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.getX = function getX() {
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        return this.y.fromRed();
      };
      Point.prototype.mul = function mul(k) {
        if (k = new BN(k, 16), this.isInfinity())
          return this;
        else if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else if (this.curve.endo)
          return this.curve._endoWnafMulAdd([this], [k]);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
        var points = [this, p2], coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
        var points = [this, p2], coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs, true);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
      };
      Point.prototype.eq = function eq(p) {
        return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
      };
      Point.prototype.neg = function neg(_precompute) {
        if (this.inf)
          return this;
        var res = this.curve.point(this.x, this.y.redNeg());
        if (_precompute && this.precomputed) {
          var pre = this.precomputed, negate3 = function(p) {
            return p.neg();
          };
          res.precomputed = { naf: pre.naf && { wnd: pre.naf.wnd, points: pre.naf.points.map(negate3) }, doubles: pre.doubles && { step: pre.doubles.step, points: pre.doubles.points.map(negate3) } };
        }
        return res;
      };
      Point.prototype.toJ = function toJ() {
        if (this.inf)
          return this.curve.jpoint(null, null, null);
        var res = this.curve.jpoint(this.x, this.y, this.curve.one);
        return res;
      };
      function JPoint(curve, x, y, z) {
        if (Base3.BasePoint.call(this, curve, "jacobian"), x === null && y === null && z === null)
          this.x = this.curve.one, this.y = this.curve.one, this.z = new BN(0);
        else
          this.x = new BN(x, 16), this.y = new BN(y, 16), this.z = new BN(z, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
      }
      inherits2(JPoint, Base3.BasePoint);
      ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
        return new JPoint(this, x, y, z);
      };
      JPoint.prototype.toP = function toP() {
        if (this.isInfinity())
          return this.curve.point(null, null);
        var zinv = this.z.redInvm(), zinv2 = zinv.redSqr(), ax = this.x.redMul(zinv2), ay = this.y.redMul(zinv2).redMul(zinv);
        return this.curve.point(ax, ay);
      };
      JPoint.prototype.neg = function neg() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
      };
      JPoint.prototype.add = function add(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        var pz2 = p.z.redSqr(), z2 = this.z.redSqr(), u1 = this.x.redMul(pz2), u2 = p.x.redMul(z2), s1 = this.y.redMul(pz2.redMul(p.z)), s2 = p.y.redMul(z2.redMul(this.z)), h = u1.redSub(u2), r = s1.redSub(s2);
        if (h.cmpn(0) === 0)
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        var h2 = h.redSqr(), h3 = h2.redMul(h), v = u1.redMul(h2), nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v), ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3)), nz = this.z.redMul(p.z).redMul(h);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mixedAdd = function mixedAdd(p) {
        if (this.isInfinity())
          return p.toJ();
        if (p.isInfinity())
          return this;
        var z2 = this.z.redSqr(), u1 = this.x, u2 = p.x.redMul(z2), s1 = this.y, s2 = p.y.redMul(z2).redMul(this.z), h = u1.redSub(u2), r = s1.redSub(s2);
        if (h.cmpn(0) === 0)
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        var h2 = h.redSqr(), h3 = h2.redMul(h), v = u1.redMul(h2), nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v), ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3)), nz = this.z.redMul(h);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.dblp = function dblp(pow) {
        if (pow === 0)
          return this;
        if (this.isInfinity())
          return this;
        if (!pow)
          return this.dbl();
        var i2;
        if (this.curve.zeroA || this.curve.threeA) {
          var r = this;
          for (i2 = 0;i2 < pow; i2++)
            r = r.dbl();
          return r;
        }
        var a = this.curve.a, tinv = this.curve.tinv, jx = this.x, jy = this.y, jz = this.z, jz4 = jz.redSqr().redSqr(), jyd = jy.redAdd(jy);
        for (i2 = 0;i2 < pow; i2++) {
          var jx2 = jx.redSqr(), jyd2 = jyd.redSqr(), jyd4 = jyd2.redSqr(), c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4)), t1 = jx.redMul(jyd2), nx = c.redSqr().redISub(t1.redAdd(t1)), t2 = t1.redISub(nx), dny = c.redMul(t2);
          dny = dny.redIAdd(dny).redISub(jyd4);
          var nz = jyd.redMul(jz);
          if (i2 + 1 < pow)
            jz4 = jz4.redMul(jyd4);
          jx = nx, jz = nz, jyd = dny;
        }
        return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
      };
      JPoint.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.zeroA)
          return this._zeroDbl();
        else if (this.curve.threeA)
          return this._threeDbl();
        else
          return this._dbl();
      };
      JPoint.prototype._zeroDbl = function _zeroDbl() {
        var nx, ny, nz;
        if (this.zOne) {
          var xx = this.x.redSqr(), yy = this.y.redSqr(), yyyy = yy.redSqr(), s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx), t = m.redSqr().redISub(s).redISub(s), yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8), yyyy8 = yyyy8.redIAdd(yyyy8), nx = t, ny = m.redMul(s.redISub(t)).redISub(yyyy8), nz = this.y.redAdd(this.y);
        } else {
          var a = this.x.redSqr(), b = this.y.redSqr(), c = b.redSqr(), d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
          d = d.redIAdd(d);
          var e = a.redAdd(a).redIAdd(a), f = e.redSqr(), c8 = c.redIAdd(c);
          c8 = c8.redIAdd(c8), c8 = c8.redIAdd(c8), nx = f.redISub(d).redISub(d), ny = e.redMul(d.redISub(nx)).redISub(c8), nz = this.y.redMul(this.z), nz = nz.redIAdd(nz);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._threeDbl = function _threeDbl() {
        var nx, ny, nz;
        if (this.zOne) {
          var xx = this.x.redSqr(), yy = this.y.redSqr(), yyyy = yy.redSqr(), s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a), t = m.redSqr().redISub(s).redISub(s);
          nx = t;
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8), yyyy8 = yyyy8.redIAdd(yyyy8), ny = m.redMul(s.redISub(t)).redISub(yyyy8), nz = this.y.redAdd(this.y);
        } else {
          var delta = this.z.redSqr(), gamma = this.y.redSqr(), beta = this.x.redMul(gamma), alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
          alpha = alpha.redAdd(alpha).redIAdd(alpha);
          var beta4 = beta.redIAdd(beta);
          beta4 = beta4.redIAdd(beta4);
          var beta8 = beta4.redAdd(beta4);
          nx = alpha.redSqr().redISub(beta8), nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
          var ggamma8 = gamma.redSqr();
          ggamma8 = ggamma8.redIAdd(ggamma8), ggamma8 = ggamma8.redIAdd(ggamma8), ggamma8 = ggamma8.redIAdd(ggamma8), ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._dbl = function _dbl() {
        var a = this.curve.a, jx = this.x, jy = this.y, jz = this.z, jz4 = jz.redSqr().redSqr(), jx2 = jx.redSqr(), jy2 = jy.redSqr(), c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4)), jxd4 = jx.redAdd(jx);
        jxd4 = jxd4.redIAdd(jxd4);
        var t1 = jxd4.redMul(jy2), nx = c.redSqr().redISub(t1.redAdd(t1)), t2 = t1.redISub(nx), jyd8 = jy2.redSqr();
        jyd8 = jyd8.redIAdd(jyd8), jyd8 = jyd8.redIAdd(jyd8), jyd8 = jyd8.redIAdd(jyd8);
        var ny = c.redMul(t2).redISub(jyd8), nz = jy.redAdd(jy).redMul(jz);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.trpl = function trpl() {
        if (!this.curve.zeroA)
          return this.dbl().add(this);
        var xx = this.x.redSqr(), yy = this.y.redSqr(), zz = this.z.redSqr(), yyyy = yy.redSqr(), m = xx.redAdd(xx).redIAdd(xx), mm = m.redSqr(), e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        e = e.redIAdd(e), e = e.redAdd(e).redIAdd(e), e = e.redISub(mm);
        var ee = e.redSqr(), t = yyyy.redIAdd(yyyy);
        t = t.redIAdd(t), t = t.redIAdd(t), t = t.redIAdd(t);
        var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t), yyu4 = yy.redMul(u);
        yyu4 = yyu4.redIAdd(yyu4), yyu4 = yyu4.redIAdd(yyu4);
        var nx = this.x.redMul(ee).redISub(yyu4);
        nx = nx.redIAdd(nx), nx = nx.redIAdd(nx);
        var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
        ny = ny.redIAdd(ny), ny = ny.redIAdd(ny), ny = ny.redIAdd(ny);
        var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mul = function mul(k, kbase) {
        return k = new BN(k, kbase), this.curve._wnafMul(this, k);
      };
      JPoint.prototype.eq = function eq(p) {
        if (p.type === "affine")
          return this.eq(p.toJ());
        if (this === p)
          return true;
        var z2 = this.z.redSqr(), pz2 = p.z.redSqr();
        if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
          return false;
        var z3 = z2.redMul(this.z), pz3 = pz2.redMul(p.z);
        return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
      };
      JPoint.prototype.eqXToP = function eqXToP(x) {
        var zs = this.z.redSqr(), rx = x.toRed(this.curve.red).redMul(zs);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone(), t = this.curve.redN.redMul(zs);
        for (;; ) {
          if (xc.iadd(this.curve.n), xc.cmp(this.curve.p) >= 0)
            return false;
          if (rx.redIAdd(t), this.x.cmp(rx) === 0)
            return true;
        }
      };
      JPoint.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC JPoint Infinity>";
        return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
      };
      JPoint.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
    });
    require_mont = __commonJS2((exports, module) => {
      var BN = require_bn(), inherits2 = require_inherits(), Base3 = require_base(), utils = require_utils2();
      function MontCurve(conf) {
        Base3.call(this, "mont", conf), this.a = new BN(conf.a, 16).toRed(this.red), this.b = new BN(conf.b, 16).toRed(this.red), this.i4 = new BN(4).toRed(this.red).redInvm(), this.two = new BN(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
      }
      inherits2(MontCurve, Base3);
      module.exports = MontCurve;
      MontCurve.prototype.validate = function validate(point) {
        var x = point.normalize().x, x2 = x.redSqr(), rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x), y = rhs.redSqrt();
        return y.redSqr().cmp(rhs) === 0;
      };
      function Point(curve, x, z) {
        if (Base3.BasePoint.call(this, curve, "projective"), x === null && z === null)
          this.x = this.curve.one, this.z = this.curve.zero;
        else {
          if (this.x = new BN(x, 16), this.z = new BN(z, 16), !this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
        }
      }
      inherits2(Point, Base3.BasePoint);
      MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        return this.point(utils.toArray(bytes, enc), 1);
      };
      MontCurve.prototype.point = function point(x, z) {
        return new Point(this, x, z);
      };
      MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      Point.prototype.precompute = function precompute() {};
      Point.prototype._encode = function _encode() {
        return this.getX().toArray("be", this.curve.p.byteLength());
      };
      Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1] || curve.one);
      };
      Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
      Point.prototype.dbl = function dbl() {
        var a = this.x.redAdd(this.z), aa = a.redSqr(), b = this.x.redSub(this.z), bb = b.redSqr(), c = aa.redSub(bb), nx = aa.redMul(bb), nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
        return this.curve.point(nx, nz);
      };
      Point.prototype.add = function add() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.diffAdd = function diffAdd(p, diff8) {
        var a = this.x.redAdd(this.z), b = this.x.redSub(this.z), c = p.x.redAdd(p.z), d = p.x.redSub(p.z), da = d.redMul(a), cb = c.redMul(b), nx = diff8.z.redMul(da.redAdd(cb).redSqr()), nz = diff8.x.redMul(da.redISub(cb).redSqr());
        return this.curve.point(nx, nz);
      };
      Point.prototype.mul = function mul(k) {
        var t = k.clone(), a = this, b = this.curve.point(null, null), c = this;
        for (var bits = [];t.cmpn(0) !== 0; t.iushrn(1))
          bits.push(t.andln(1));
        for (var i2 = bits.length - 1;i2 >= 0; i2--)
          if (bits[i2] === 0)
            a = a.diffAdd(b, c), b = b.dbl();
          else
            b = a.diffAdd(b, c), a = a.dbl();
        return b;
      };
      Point.prototype.mulAdd = function mulAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.jumlAdd = function jumlAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.eq = function eq(other) {
        return this.getX().cmp(other.getX()) === 0;
      };
      Point.prototype.normalize = function normalize() {
        return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
      };
      Point.prototype.getX = function getX() {
        return this.normalize(), this.x.fromRed();
      };
    });
    require_edwards = __commonJS2((exports, module) => {
      var utils = require_utils2(), BN = require_bn(), inherits2 = require_inherits(), Base3 = require_base(), assert = utils.assert;
      function EdwardsCurve(conf) {
        this.twisted = (conf.a | 0) !== 1, this.mOneA = this.twisted && (conf.a | 0) === -1, this.extended = this.mOneA, Base3.call(this, "edwards", conf), this.a = new BN(conf.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN(conf.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN(conf.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (conf.c | 0) === 1;
      }
      inherits2(EdwardsCurve, Base3);
      module.exports = EdwardsCurve;
      EdwardsCurve.prototype._mulA = function _mulA(num) {
        if (this.mOneA)
          return num.redNeg();
        else
          return this.a.redMul(num);
      };
      EdwardsCurve.prototype._mulC = function _mulC(num) {
        if (this.oneC)
          return num;
        else
          return this.c.redMul(num);
      };
      EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
        return this.point(x, y, z, t);
      };
      EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
        if (x = new BN(x, 16), !x.red)
          x = x.toRed(this.red);
        var x2 = x.redSqr(), rhs = this.c2.redSub(this.a.redMul(x2)), lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2)), y2 = rhs.redMul(lhs.redInvm()), y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
        if (y = new BN(y, 16), !y.red)
          y = y.toRed(this.red);
        var y2 = y.redSqr(), lhs = y2.redSub(this.c2), rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a), x2 = lhs.redMul(rhs.redInvm());
        if (x2.cmp(this.zero) === 0)
          if (odd)
            throw new Error("invalid point");
          else
            return this.point(this.zero, y);
        var x = x2.redSqrt();
        if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        if (x.fromRed().isOdd() !== odd)
          x = x.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.validate = function validate(point) {
        if (point.isInfinity())
          return true;
        point.normalize();
        var x2 = point.x.redSqr(), y2 = point.y.redSqr(), lhs = x2.redMul(this.a).redAdd(y2), rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
        return lhs.cmp(rhs) === 0;
      };
      function Point(curve, x, y, z, t) {
        if (Base3.BasePoint.call(this, curve, "projective"), x === null && y === null && z === null)
          this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true;
        else {
          if (this.x = new BN(x, 16), this.y = new BN(y, 16), this.z = z ? new BN(z, 16) : this.curve.one, this.t = t && new BN(t, 16), !this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
          if (this.t && !this.t.red)
            this.t = this.t.toRed(this.curve.red);
          if (this.zOne = this.z === this.curve.one, this.curve.extended && !this.t) {
            if (this.t = this.x.redMul(this.y), !this.zOne)
              this.t = this.t.redMul(this.z.redInvm());
          }
        }
      }
      inherits2(Point, Base3.BasePoint);
      EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      EdwardsCurve.prototype.point = function point(x, y, z, t) {
        return new Point(this, x, y, z, t);
      };
      Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1], obj[2]);
      };
      Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
      };
      Point.prototype._extDbl = function _extDbl() {
        var a = this.x.redSqr(), b = this.y.redSqr(), c = this.z.redSqr();
        c = c.redIAdd(c);
        var d = this.curve._mulA(a), e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b), g = d.redAdd(b), f = g.redSub(c), h = d.redSub(b), nx = e.redMul(f), ny = g.redMul(h), nt = e.redMul(h), nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projDbl = function _projDbl() {
        var b = this.x.redAdd(this.y).redSqr(), c = this.x.redSqr(), d = this.y.redSqr(), nx, ny, nz, e, h, j;
        if (this.curve.twisted) {
          e = this.curve._mulA(c);
          var f = e.redAdd(d);
          if (this.zOne)
            nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two)), ny = f.redMul(e.redSub(d)), nz = f.redSqr().redSub(f).redSub(f);
          else
            h = this.z.redSqr(), j = f.redSub(h).redISub(h), nx = b.redSub(c).redISub(d).redMul(j), ny = f.redMul(e.redSub(d)), nz = f.redMul(j);
        } else
          e = c.redAdd(d), h = this.curve._mulC(this.z).redSqr(), j = e.redSub(h).redSub(h), nx = this.curve._mulC(b.redISub(e)).redMul(j), ny = this.curve._mulC(e).redMul(c.redISub(d)), nz = e.redMul(j);
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extDbl();
        else
          return this._projDbl();
      };
      Point.prototype._extAdd = function _extAdd(p) {
        var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x)), b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x)), c = this.t.redMul(this.curve.dd).redMul(p.t), d = this.z.redMul(p.z.redAdd(p.z)), e = b.redSub(a), f = d.redSub(c), g = d.redAdd(c), h = b.redAdd(a), nx = e.redMul(f), ny = g.redMul(h), nt = e.redMul(h), nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projAdd = function _projAdd(p) {
        var a = this.z.redMul(p.z), b = a.redSqr(), c = this.x.redMul(p.x), d = this.y.redMul(p.y), e = this.curve.d.redMul(c).redMul(d), f = b.redSub(e), g = b.redAdd(e), tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d), nx = a.redMul(f).redMul(tmp), ny, nz;
        if (this.curve.twisted)
          ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c))), nz = f.redMul(g);
        else
          ny = a.redMul(g).redMul(d.redSub(c)), nz = this.curve._mulC(f).redMul(g);
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.add = function add(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extAdd(p);
        else
          return this._projAdd(p);
      };
      Point.prototype.mul = function mul(k) {
        if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
      };
      Point.prototype.normalize = function normalize() {
        if (this.zOne)
          return this;
        var zi = this.z.redInvm();
        if (this.x = this.x.redMul(zi), this.y = this.y.redMul(zi), this.t)
          this.t = this.t.redMul(zi);
        return this.z = this.curve.one, this.zOne = true, this;
      };
      Point.prototype.neg = function neg() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
      };
      Point.prototype.getX = function getX() {
        return this.normalize(), this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        return this.normalize(), this.y.fromRed();
      };
      Point.prototype.eq = function eq(other) {
        return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
      };
      Point.prototype.eqXToP = function eqXToP(x) {
        var rx = x.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone(), t = this.curve.redN.redMul(this.z);
        for (;; ) {
          if (xc.iadd(this.curve.n), xc.cmp(this.curve.p) >= 0)
            return false;
          if (rx.redIAdd(t), this.x.cmp(rx) === 0)
            return true;
        }
      };
      Point.prototype.toP = Point.prototype.normalize;
      Point.prototype.mixedAdd = Point.prototype.add;
    });
    require_curve = __commonJS2((exports) => {
      var curve = exports;
      curve.base = require_base();
      curve.short = require_short();
      curve.mont = require_mont();
      curve.edwards = require_edwards();
    });
    require_utils3 = __commonJS2((exports) => {
      var assert = require_minimalistic_assert(), inherits2 = require_inherits();
      exports.inherits = inherits2;
      function isSurrogatePair(msg, i2) {
        if ((msg.charCodeAt(i2) & 64512) !== 55296)
          return false;
        if (i2 < 0 || i2 + 1 >= msg.length)
          return false;
        return (msg.charCodeAt(i2 + 1) & 64512) === 56320;
      }
      function toArray4(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg === "string") {
          if (!enc) {
            var p = 0;
            for (var i2 = 0;i2 < msg.length; i2++) {
              var c = msg.charCodeAt(i2);
              if (c < 128)
                res[p++] = c;
              else if (c < 2048)
                res[p++] = c >> 6 | 192, res[p++] = c & 63 | 128;
              else if (isSurrogatePair(msg, i2))
                c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i2) & 1023), res[p++] = c >> 18 | 240, res[p++] = c >> 12 & 63 | 128, res[p++] = c >> 6 & 63 | 128, res[p++] = c & 63 | 128;
              else
                res[p++] = c >> 12 | 224, res[p++] = c >> 6 & 63 | 128, res[p++] = c & 63 | 128;
            }
          } else if (enc === "hex") {
            if (msg = msg.replace(/[^a-z0-9]+/ig, ""), msg.length % 2 !== 0)
              msg = "0" + msg;
            for (i2 = 0;i2 < msg.length; i2 += 2)
              res.push(parseInt(msg[i2] + msg[i2 + 1], 16));
          }
        } else
          for (i2 = 0;i2 < msg.length; i2++)
            res[i2] = msg[i2] | 0;
        return res;
      }
      exports.toArray = toArray4;
      function toHex(msg) {
        var res = "";
        for (var i2 = 0;i2 < msg.length; i2++)
          res += zero2(msg[i2].toString(16));
        return res;
      }
      exports.toHex = toHex;
      function htonl(w) {
        var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
        return res >>> 0;
      }
      exports.htonl = htonl;
      function toHex32(msg, endian) {
        var res = "";
        for (var i2 = 0;i2 < msg.length; i2++) {
          var w = msg[i2];
          if (endian === "little")
            w = htonl(w);
          res += zero8(w.toString(16));
        }
        return res;
      }
      exports.toHex32 = toHex32;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      exports.zero2 = zero2;
      function zero8(word) {
        if (word.length === 7)
          return "0" + word;
        else if (word.length === 6)
          return "00" + word;
        else if (word.length === 5)
          return "000" + word;
        else if (word.length === 4)
          return "0000" + word;
        else if (word.length === 3)
          return "00000" + word;
        else if (word.length === 2)
          return "000000" + word;
        else if (word.length === 1)
          return "0000000" + word;
        else
          return word;
      }
      exports.zero8 = zero8;
      function join32(msg, start4, end6, endian) {
        var len2 = end6 - start4;
        assert(len2 % 4 === 0);
        var res = new Array(len2 / 4);
        for (var i2 = 0, k = start4;i2 < res.length; i2++, k += 4) {
          var w;
          if (endian === "big")
            w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
          else
            w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
          res[i2] = w >>> 0;
        }
        return res;
      }
      exports.join32 = join32;
      function split32(msg, endian) {
        var res = new Array(msg.length * 4);
        for (var i2 = 0, k = 0;i2 < msg.length; i2++, k += 4) {
          var m = msg[i2];
          if (endian === "big")
            res[k] = m >>> 24, res[k + 1] = m >>> 16 & 255, res[k + 2] = m >>> 8 & 255, res[k + 3] = m & 255;
          else
            res[k + 3] = m >>> 24, res[k + 2] = m >>> 16 & 255, res[k + 1] = m >>> 8 & 255, res[k] = m & 255;
        }
        return res;
      }
      exports.split32 = split32;
      function rotr32(w, b) {
        return w >>> b | w << 32 - b;
      }
      exports.rotr32 = rotr32;
      function rotl32(w, b) {
        return w << b | w >>> 32 - b;
      }
      exports.rotl32 = rotl32;
      function sum32(a, b) {
        return a + b >>> 0;
      }
      exports.sum32 = sum32;
      function sum32_3(a, b, c) {
        return a + b + c >>> 0;
      }
      exports.sum32_3 = sum32_3;
      function sum32_4(a, b, c, d) {
        return a + b + c + d >>> 0;
      }
      exports.sum32_4 = sum32_4;
      function sum32_5(a, b, c, d, e) {
        return a + b + c + d + e >>> 0;
      }
      exports.sum32_5 = sum32_5;
      function sum64(buf, pos, ah, al) {
        var bh = buf[pos], bl = buf[pos + 1], lo = al + bl >>> 0, hi = (lo < al ? 1 : 0) + ah + bh;
        buf[pos] = hi >>> 0, buf[pos + 1] = lo;
      }
      exports.sum64 = sum64;
      function sum64_hi(ah, al, bh, bl) {
        var lo = al + bl >>> 0, hi = (lo < al ? 1 : 0) + ah + bh;
        return hi >>> 0;
      }
      exports.sum64_hi = sum64_hi;
      function sum64_lo(ah, al, bh, bl) {
        var lo = al + bl;
        return lo >>> 0;
      }
      exports.sum64_lo = sum64_lo;
      function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
        var carry = 0, lo = al;
        lo = lo + bl >>> 0, carry += lo < al ? 1 : 0, lo = lo + cl >>> 0, carry += lo < cl ? 1 : 0, lo = lo + dl >>> 0, carry += lo < dl ? 1 : 0;
        var hi = ah + bh + ch + dh + carry;
        return hi >>> 0;
      }
      exports.sum64_4_hi = sum64_4_hi;
      function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
        var lo = al + bl + cl + dl;
        return lo >>> 0;
      }
      exports.sum64_4_lo = sum64_4_lo;
      function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var carry = 0, lo = al;
        lo = lo + bl >>> 0, carry += lo < al ? 1 : 0, lo = lo + cl >>> 0, carry += lo < cl ? 1 : 0, lo = lo + dl >>> 0, carry += lo < dl ? 1 : 0, lo = lo + el >>> 0, carry += lo < el ? 1 : 0;
        var hi = ah + bh + ch + dh + eh + carry;
        return hi >>> 0;
      }
      exports.sum64_5_hi = sum64_5_hi;
      function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var lo = al + bl + cl + dl + el;
        return lo >>> 0;
      }
      exports.sum64_5_lo = sum64_5_lo;
      function rotr64_hi(ah, al, num) {
        var r = al << 32 - num | ah >>> num;
        return r >>> 0;
      }
      exports.rotr64_hi = rotr64_hi;
      function rotr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      exports.rotr64_lo = rotr64_lo;
      function shr64_hi(ah, al, num) {
        return ah >>> num;
      }
      exports.shr64_hi = shr64_hi;
      function shr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      exports.shr64_lo = shr64_lo;
    });
    require_common = __commonJS2((exports) => {
      var utils = require_utils3(), assert = require_minimalistic_assert();
      function BlockHash() {
        this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
      }
      exports.BlockHash = BlockHash;
      BlockHash.prototype.update = function update(msg, enc) {
        if (msg = utils.toArray(msg, enc), !this.pending)
          this.pending = msg;
        else
          this.pending = this.pending.concat(msg);
        if (this.pendingTotal += msg.length, this.pending.length >= this._delta8) {
          msg = this.pending;
          var r = msg.length % this._delta8;
          if (this.pending = msg.slice(msg.length - r, msg.length), this.pending.length === 0)
            this.pending = null;
          msg = utils.join32(msg, 0, msg.length - r, this.endian);
          for (var i2 = 0;i2 < msg.length; i2 += this._delta32)
            this._update(msg, i2, i2 + this._delta32);
        }
        return this;
      };
      BlockHash.prototype.digest = function digest(enc) {
        return this.update(this._pad()), assert(this.pending === null), this._digest(enc);
      };
      BlockHash.prototype._pad = function pad() {
        var len2 = this.pendingTotal, bytes = this._delta8, k = bytes - (len2 + this.padLength) % bytes, res = new Array(k + this.padLength);
        res[0] = 128;
        for (var i2 = 1;i2 < k; i2++)
          res[i2] = 0;
        if (len2 <<= 3, this.endian === "big") {
          for (var t = 8;t < this.padLength; t++)
            res[i2++] = 0;
          res[i2++] = 0, res[i2++] = 0, res[i2++] = 0, res[i2++] = 0, res[i2++] = len2 >>> 24 & 255, res[i2++] = len2 >>> 16 & 255, res[i2++] = len2 >>> 8 & 255, res[i2++] = len2 & 255;
        } else {
          res[i2++] = len2 & 255, res[i2++] = len2 >>> 8 & 255, res[i2++] = len2 >>> 16 & 255, res[i2++] = len2 >>> 24 & 255, res[i2++] = 0, res[i2++] = 0, res[i2++] = 0, res[i2++] = 0;
          for (t = 8;t < this.padLength; t++)
            res[i2++] = 0;
        }
        return res;
      };
    });
    require_common2 = __commonJS2((exports) => {
      var utils = require_utils3(), rotr32 = utils.rotr32;
      function ft_1(s, x, y, z) {
        if (s === 0)
          return ch32(x, y, z);
        if (s === 1 || s === 3)
          return p32(x, y, z);
        if (s === 2)
          return maj32(x, y, z);
      }
      exports.ft_1 = ft_1;
      function ch32(x, y, z) {
        return x & y ^ ~x & z;
      }
      exports.ch32 = ch32;
      function maj32(x, y, z) {
        return x & y ^ x & z ^ y & z;
      }
      exports.maj32 = maj32;
      function p32(x, y, z) {
        return x ^ y ^ z;
      }
      exports.p32 = p32;
      function s0_256(x) {
        return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
      }
      exports.s0_256 = s0_256;
      function s1_256(x) {
        return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
      }
      exports.s1_256 = s1_256;
      function g0_256(x) {
        return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
      }
      exports.g0_256 = g0_256;
      function g1_256(x) {
        return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
      }
      exports.g1_256 = g1_256;
    });
    require_1 = __commonJS2((exports, module) => {
      var utils = require_utils3(), common = require_common(), shaCommon = require_common2(), rotl32 = utils.rotl32, sum32 = utils.sum32, sum32_5 = utils.sum32_5, ft_1 = shaCommon.ft_1, BlockHash = common.BlockHash, sha1_K = [1518500249, 1859775393, 2400959708, 3395469782];
      function SHA1() {
        if (!(this instanceof SHA1))
          return new SHA1;
        BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
      }
      utils.inherits(SHA1, BlockHash);
      module.exports = SHA1;
      SHA1.blockSize = 512;
      SHA1.outSize = 160;
      SHA1.hmacStrength = 80;
      SHA1.padLength = 64;
      SHA1.prototype._update = function _update(msg, start4) {
        var W = this.W;
        for (var i2 = 0;i2 < 16; i2++)
          W[i2] = msg[start4 + i2];
        for (;i2 < W.length; i2++)
          W[i2] = rotl32(W[i2 - 3] ^ W[i2 - 8] ^ W[i2 - 14] ^ W[i2 - 16], 1);
        var a = this.h[0], b = this.h[1], c = this.h[2], d = this.h[3], e = this.h[4];
        for (i2 = 0;i2 < W.length; i2++) {
          var s = ~~(i2 / 20), t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i2], sha1_K[s]);
          e = d, d = c, c = rotl32(b, 30), b = a, a = t;
        }
        this.h[0] = sum32(this.h[0], a), this.h[1] = sum32(this.h[1], b), this.h[2] = sum32(this.h[2], c), this.h[3] = sum32(this.h[3], d), this.h[4] = sum32(this.h[4], e);
      };
      SHA1.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    });
    require_256 = __commonJS2((exports, module) => {
      var utils = require_utils3(), common = require_common(), shaCommon = require_common2(), assert = require_minimalistic_assert(), sum32 = utils.sum32, sum32_4 = utils.sum32_4, sum32_5 = utils.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash = common.BlockHash, sha256_K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
      function SHA256() {
        if (!(this instanceof SHA256))
          return new SHA256;
        BlockHash.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = sha256_K, this.W = new Array(64);
      }
      utils.inherits(SHA256, BlockHash);
      module.exports = SHA256;
      SHA256.blockSize = 512;
      SHA256.outSize = 256;
      SHA256.hmacStrength = 192;
      SHA256.padLength = 64;
      SHA256.prototype._update = function _update(msg, start4) {
        var W = this.W;
        for (var i2 = 0;i2 < 16; i2++)
          W[i2] = msg[start4 + i2];
        for (;i2 < W.length; i2++)
          W[i2] = sum32_4(g1_256(W[i2 - 2]), W[i2 - 7], g0_256(W[i2 - 15]), W[i2 - 16]);
        var a = this.h[0], b = this.h[1], c = this.h[2], d = this.h[3], e = this.h[4], f = this.h[5], g = this.h[6], h = this.h[7];
        assert(this.k.length === W.length);
        for (i2 = 0;i2 < W.length; i2++) {
          var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i2], W[i2]), T2 = sum32(s0_256(a), maj32(a, b, c));
          h = g, g = f, f = e, e = sum32(d, T1), d = c, c = b, b = a, a = sum32(T1, T2);
        }
        this.h[0] = sum32(this.h[0], a), this.h[1] = sum32(this.h[1], b), this.h[2] = sum32(this.h[2], c), this.h[3] = sum32(this.h[3], d), this.h[4] = sum32(this.h[4], e), this.h[5] = sum32(this.h[5], f), this.h[6] = sum32(this.h[6], g), this.h[7] = sum32(this.h[7], h);
      };
      SHA256.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    });
    require_224 = __commonJS2((exports, module) => {
      var utils = require_utils3(), SHA256 = require_256();
      function SHA224() {
        if (!(this instanceof SHA224))
          return new SHA224;
        SHA256.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
      }
      utils.inherits(SHA224, SHA256);
      module.exports = SHA224;
      SHA224.blockSize = 512;
      SHA224.outSize = 224;
      SHA224.hmacStrength = 192;
      SHA224.padLength = 64;
      SHA224.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 7), "big");
        else
          return utils.split32(this.h.slice(0, 7), "big");
      };
    });
    require_512 = __commonJS2((exports, module) => {
      var utils = require_utils3(), common = require_common(), assert = require_minimalistic_assert(), rotr64_hi = utils.rotr64_hi, rotr64_lo = utils.rotr64_lo, shr64_hi = utils.shr64_hi, shr64_lo = utils.shr64_lo, sum64 = utils.sum64, sum64_hi = utils.sum64_hi, sum64_lo = utils.sum64_lo, sum64_4_hi = utils.sum64_4_hi, sum64_4_lo = utils.sum64_4_lo, sum64_5_hi = utils.sum64_5_hi, sum64_5_lo = utils.sum64_5_lo, BlockHash = common.BlockHash, sha512_K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
      function SHA512() {
        if (!(this instanceof SHA512))
          return new SHA512;
        BlockHash.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = sha512_K, this.W = new Array(160);
      }
      utils.inherits(SHA512, BlockHash);
      module.exports = SHA512;
      SHA512.blockSize = 1024;
      SHA512.outSize = 512;
      SHA512.hmacStrength = 192;
      SHA512.padLength = 128;
      SHA512.prototype._prepareBlock = function _prepareBlock(msg, start4) {
        var W = this.W;
        for (var i2 = 0;i2 < 32; i2++)
          W[i2] = msg[start4 + i2];
        for (;i2 < W.length; i2 += 2) {
          var c0_hi = g1_512_hi(W[i2 - 4], W[i2 - 3]), c0_lo = g1_512_lo(W[i2 - 4], W[i2 - 3]), c1_hi = W[i2 - 14], c1_lo = W[i2 - 13], c2_hi = g0_512_hi(W[i2 - 30], W[i2 - 29]), c2_lo = g0_512_lo(W[i2 - 30], W[i2 - 29]), c3_hi = W[i2 - 32], c3_lo = W[i2 - 31];
          W[i2] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo), W[i2 + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        }
      };
      SHA512.prototype._update = function _update(msg, start4) {
        this._prepareBlock(msg, start4);
        var W = this.W, ah = this.h[0], al = this.h[1], bh = this.h[2], bl = this.h[3], ch = this.h[4], cl = this.h[5], dh = this.h[6], dl = this.h[7], eh = this.h[8], el = this.h[9], fh = this.h[10], fl = this.h[11], gh = this.h[12], gl = this.h[13], hh = this.h[14], hl = this.h[15];
        assert(this.k.length === W.length);
        for (var i2 = 0;i2 < W.length; i2 += 2) {
          var c0_hi = hh, c0_lo = hl, c1_hi = s1_512_hi(eh, el), c1_lo = s1_512_lo(eh, el), c2_hi = ch64_hi(eh, el, fh, fl, gh, gl), c2_lo = ch64_lo(eh, el, fh, fl, gh, gl), c3_hi = this.k[i2], c3_lo = this.k[i2 + 1], c4_hi = W[i2], c4_lo = W[i2 + 1], T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo), T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
          c0_hi = s0_512_hi(ah, al), c0_lo = s0_512_lo(ah, al), c1_hi = maj64_hi(ah, al, bh, bl, ch, cl), c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
          var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo), T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
          hh = gh, hl = gl, gh = fh, gl = fl, fh = eh, fl = el, eh = sum64_hi(dh, dl, T1_hi, T1_lo), el = sum64_lo(dl, dl, T1_hi, T1_lo), dh = ch, dl = cl, ch = bh, cl = bl, bh = ah, bl = al, ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo), al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
        }
        sum64(this.h, 0, ah, al), sum64(this.h, 2, bh, bl), sum64(this.h, 4, ch, cl), sum64(this.h, 6, dh, dl), sum64(this.h, 8, eh, el), sum64(this.h, 10, fh, fl), sum64(this.h, 12, gh, gl), sum64(this.h, 14, hh, hl);
      };
      SHA512.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
      function ch64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ ~xh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function ch64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ ~xl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ xh & zh ^ yh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ xl & zl ^ yl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 28), c1_hi = rotr64_hi(xl, xh, 2), c2_hi = rotr64_hi(xl, xh, 7), r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 28), c1_lo = rotr64_lo(xl, xh, 2), c2_lo = rotr64_lo(xl, xh, 7), r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 14), c1_hi = rotr64_hi(xh, xl, 18), c2_hi = rotr64_hi(xl, xh, 9), r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 14), c1_lo = rotr64_lo(xh, xl, 18), c2_lo = rotr64_lo(xl, xh, 9), r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 1), c1_hi = rotr64_hi(xh, xl, 8), c2_hi = shr64_hi(xh, xl, 7), r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 1), c1_lo = rotr64_lo(xh, xl, 8), c2_lo = shr64_lo(xh, xl, 7), r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 19), c1_hi = rotr64_hi(xl, xh, 29), c2_hi = shr64_hi(xh, xl, 6), r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 19), c1_lo = rotr64_lo(xl, xh, 29), c2_lo = shr64_lo(xh, xl, 6), r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
    });
    require_384 = __commonJS2((exports, module) => {
      var utils = require_utils3(), SHA512 = require_512();
      function SHA384() {
        if (!(this instanceof SHA384))
          return new SHA384;
        SHA512.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
      }
      utils.inherits(SHA384, SHA512);
      module.exports = SHA384;
      SHA384.blockSize = 1024;
      SHA384.outSize = 384;
      SHA384.hmacStrength = 192;
      SHA384.padLength = 128;
      SHA384.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 12), "big");
        else
          return utils.split32(this.h.slice(0, 12), "big");
      };
    });
    require_sha = __commonJS2((exports) => {
      exports.sha1 = require_1();
      exports.sha224 = require_224();
      exports.sha256 = require_256();
      exports.sha384 = require_384();
      exports.sha512 = require_512();
    });
    require_ripemd = __commonJS2((exports) => {
      var utils = require_utils3(), common = require_common(), rotl32 = utils.rotl32, sum32 = utils.sum32, sum32_3 = utils.sum32_3, sum32_4 = utils.sum32_4, BlockHash = common.BlockHash;
      function RIPEMD160() {
        if (!(this instanceof RIPEMD160))
          return new RIPEMD160;
        BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
      }
      utils.inherits(RIPEMD160, BlockHash);
      exports.ripemd160 = RIPEMD160;
      RIPEMD160.blockSize = 512;
      RIPEMD160.outSize = 160;
      RIPEMD160.hmacStrength = 192;
      RIPEMD160.padLength = 64;
      RIPEMD160.prototype._update = function update(msg, start4) {
        var A = this.h[0], B = this.h[1], C = this.h[2], D = this.h[3], E2 = this.h[4], Ah = A, Bh = B, Ch = C, Dh = D, Eh = E2;
        for (var j = 0;j < 80; j++) {
          var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start4], K(j)), s[j]), E2);
          A = E2, E2 = D, D = rotl32(C, 10), C = B, B = T, T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start4], Kh(j)), sh[j]), Eh), Ah = Eh, Eh = Dh, Dh = rotl32(Ch, 10), Ch = Bh, Bh = T;
        }
        T = sum32_3(this.h[1], C, Dh), this.h[1] = sum32_3(this.h[2], D, Eh), this.h[2] = sum32_3(this.h[3], E2, Ah), this.h[3] = sum32_3(this.h[4], A, Bh), this.h[4] = sum32_3(this.h[0], B, Ch), this.h[0] = T;
      };
      RIPEMD160.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "little");
        else
          return utils.split32(this.h, "little");
      };
      function f(j, x, y, z) {
        if (j <= 15)
          return x ^ y ^ z;
        else if (j <= 31)
          return x & y | ~x & z;
        else if (j <= 47)
          return (x | ~y) ^ z;
        else if (j <= 63)
          return x & z | y & ~z;
        else
          return x ^ (y | ~z);
      }
      function K(j) {
        if (j <= 15)
          return 0;
        else if (j <= 31)
          return 1518500249;
        else if (j <= 47)
          return 1859775393;
        else if (j <= 63)
          return 2400959708;
        else
          return 2840853838;
      }
      function Kh(j) {
        if (j <= 15)
          return 1352829926;
        else if (j <= 31)
          return 1548603684;
        else if (j <= 47)
          return 1836072691;
        else if (j <= 63)
          return 2053994217;
        else
          return 0;
      }
      var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
    });
    require_hmac = __commonJS2((exports, module) => {
      var utils = require_utils3(), assert = require_minimalistic_assert();
      function Hmac(hash2, key, enc) {
        if (!(this instanceof Hmac))
          return new Hmac(hash2, key, enc);
        this.Hash = hash2, this.blockSize = hash2.blockSize / 8, this.outSize = hash2.outSize / 8, this.inner = null, this.outer = null, this._init(utils.toArray(key, enc));
      }
      module.exports = Hmac;
      Hmac.prototype._init = function init(key) {
        if (key.length > this.blockSize)
          key = new this.Hash().update(key).digest();
        assert(key.length <= this.blockSize);
        for (var i2 = key.length;i2 < this.blockSize; i2++)
          key.push(0);
        for (i2 = 0;i2 < key.length; i2++)
          key[i2] ^= 54;
        this.inner = new this.Hash().update(key);
        for (i2 = 0;i2 < key.length; i2++)
          key[i2] ^= 106;
        this.outer = new this.Hash().update(key);
      };
      Hmac.prototype.update = function update(msg, enc) {
        return this.inner.update(msg, enc), this;
      };
      Hmac.prototype.digest = function digest(enc) {
        return this.outer.update(this.inner.digest()), this.outer.digest(enc);
      };
    });
    require_hash = __commonJS2((exports) => {
      var hash2 = exports;
      hash2.utils = require_utils3();
      hash2.common = require_common();
      hash2.sha = require_sha();
      hash2.ripemd = require_ripemd();
      hash2.hmac = require_hmac();
      hash2.sha1 = hash2.sha.sha1;
      hash2.sha256 = hash2.sha.sha256;
      hash2.sha224 = hash2.sha.sha224;
      hash2.sha384 = hash2.sha.sha384;
      hash2.sha512 = hash2.sha.sha512;
      hash2.ripemd160 = hash2.ripemd.ripemd160;
    });
    require_secp256k1 = __commonJS2((exports, module) => {
      module.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
    });
    require_curves = __commonJS2((exports) => {
      var curves = exports, hash2 = require_hash(), curve = require_curve(), utils = require_utils2(), assert = utils.assert;
      function PresetCurve(options) {
        if (options.type === "short")
          this.curve = new curve.short(options);
        else if (options.type === "edwards")
          this.curve = new curve.edwards(options);
        else
          this.curve = new curve.mont(options);
        this.g = this.curve.g, this.n = this.curve.n, this.hash = options.hash, assert(this.g.validate(), "Invalid curve"), assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      curves.PresetCurve = PresetCurve;
      function defineCurve(name, options) {
        Object.defineProperty(curves, name, { configurable: true, enumerable: true, get: function() {
          var curve2 = new PresetCurve(options);
          return Object.defineProperty(curves, name, { configurable: true, enumerable: true, value: curve2 }), curve2;
        } });
      }
      defineCurve("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: hash2.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
      defineCurve("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: hash2.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
      defineCurve("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: hash2.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
      defineCurve("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: hash2.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
      defineCurve("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: hash2.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
      defineCurve("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: hash2.sha256, gRed: false, g: ["9"] });
      defineCurve("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: hash2.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
      var pre;
      try {
        pre = require_secp256k1();
      } catch (e) {
        pre = undefined;
      }
      defineCurve("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: hash2.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", pre] });
    });
    require_hmac_drbg = __commonJS2((exports, module) => {
      var hash2 = require_hash(), utils = require_utils(), assert = require_minimalistic_assert();
      function HmacDRBG(options) {
        if (!(this instanceof HmacDRBG))
          return new HmacDRBG(options);
        this.hash = options.hash, this.predResist = !!options.predResist, this.outLen = this.hash.outSize, this.minEntropy = options.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
        var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex"), nonce = utils.toArray(options.nonce, options.nonceEnc || "hex"), pers = utils.toArray(options.pers, options.persEnc || "hex");
        assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(entropy, nonce, pers);
      }
      module.exports = HmacDRBG;
      HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
        var seed = entropy.concat(nonce).concat(pers);
        this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
        for (var i2 = 0;i2 < this.V.length; i2++)
          this.K[i2] = 0, this.V[i2] = 1;
        this._update(seed), this._reseed = 1, this.reseedInterval = 281474976710656;
      };
      HmacDRBG.prototype._hmac = function hmac() {
        return new hash2.hmac(this.hash, this.K);
      };
      HmacDRBG.prototype._update = function update(seed) {
        var kmac = this._hmac().update(this.V).update([0]);
        if (seed)
          kmac = kmac.update(seed);
        if (this.K = kmac.digest(), this.V = this._hmac().update(this.V).digest(), !seed)
          return;
        this.K = this._hmac().update(this.V).update([1]).update(seed).digest(), this.V = this._hmac().update(this.V).digest();
      };
      HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add5, addEnc) {
        if (typeof entropyEnc !== "string")
          addEnc = add5, add5 = entropyEnc, entropyEnc = null;
        entropy = utils.toArray(entropy, entropyEnc), add5 = utils.toArray(add5, addEnc), assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(entropy.concat(add5 || [])), this._reseed = 1;
      };
      HmacDRBG.prototype.generate = function generate(len2, enc, add5, addEnc) {
        if (this._reseed > this.reseedInterval)
          throw new Error("Reseed is required");
        if (typeof enc !== "string")
          addEnc = add5, add5 = enc, enc = null;
        if (add5)
          add5 = utils.toArray(add5, addEnc || "hex"), this._update(add5);
        var temp = [];
        while (temp.length < len2)
          this.V = this._hmac().update(this.V).digest(), temp = temp.concat(this.V);
        var res = temp.slice(0, len2);
        return this._update(add5), this._reseed++, utils.encode(res, enc);
      };
    });
    require_key = __commonJS2((exports, module) => {
      var BN = require_bn(), utils = require_utils2(), assert = utils.assert;
      function KeyPair(ec, options) {
        if (this.ec = ec, this.priv = null, this.pub = null, options.priv)
          this._importPrivate(options.priv, options.privEnc);
        if (options.pub)
          this._importPublic(options.pub, options.pubEnc);
      }
      module.exports = KeyPair;
      KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(ec, { pub, pubEnc: enc });
      };
      KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
        if (priv instanceof KeyPair)
          return priv;
        return new KeyPair(ec, { priv, privEnc: enc });
      };
      KeyPair.prototype.validate = function validate() {
        var pub = this.getPublic();
        if (pub.isInfinity())
          return { result: false, reason: "Invalid public key" };
        if (!pub.validate())
          return { result: false, reason: "Public key is not a point" };
        if (!pub.mul(this.ec.curve.n).isInfinity())
          return { result: false, reason: "Public key * N != O" };
        return { result: true, reason: null };
      };
      KeyPair.prototype.getPublic = function getPublic(compact2, enc) {
        if (typeof compact2 === "string")
          enc = compact2, compact2 = null;
        if (!this.pub)
          this.pub = this.ec.g.mul(this.priv);
        if (!enc)
          return this.pub;
        return this.pub.encode(enc, compact2);
      };
      KeyPair.prototype.getPrivate = function getPrivate(enc) {
        if (enc === "hex")
          return this.priv.toString(16, 2);
        else
          return this.priv;
      };
      KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
        this.priv = new BN(key, enc || 16), this.priv = this.priv.umod(this.ec.curve.n);
      };
      KeyPair.prototype._importPublic = function _importPublic(key, enc) {
        if (key.x || key.y) {
          if (this.ec.curve.type === "mont")
            assert(key.x, "Need x coordinate");
          else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards")
            assert(key.x && key.y, "Need both x and y coordinate");
          this.pub = this.ec.curve.point(key.x, key.y);
          return;
        }
        this.pub = this.ec.curve.decodePoint(key, enc);
      };
      KeyPair.prototype.derive = function derive(pub) {
        if (!pub.validate())
          assert(pub.validate(), "public point not validated");
        return pub.mul(this.priv).getX();
      };
      KeyPair.prototype.sign = function sign(msg, enc, options) {
        return this.ec.sign(msg, this, enc, options);
      };
      KeyPair.prototype.verify = function verify(msg, signature, options) {
        return this.ec.verify(msg, signature, this, undefined, options);
      };
      KeyPair.prototype.inspect = function inspect() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
      };
    });
    require_signature = __commonJS2((exports, module) => {
      var BN = require_bn(), utils = require_utils2(), assert = utils.assert;
      function Signature(options, enc) {
        if (options instanceof Signature)
          return options;
        if (this._importDER(options, enc))
          return;
        if (assert(options.r && options.s, "Signature without r or s"), this.r = new BN(options.r, 16), this.s = new BN(options.s, 16), options.recoveryParam === undefined)
          this.recoveryParam = null;
        else
          this.recoveryParam = options.recoveryParam;
      }
      module.exports = Signature;
      function Position() {
        this.place = 0;
      }
      function getLength(buf, p) {
        var initial = buf[p.place++];
        if (!(initial & 128))
          return initial;
        var octetLen = initial & 15;
        if (octetLen === 0 || octetLen > 4)
          return false;
        if (buf[p.place] === 0)
          return false;
        var val = 0;
        for (var i2 = 0, off = p.place;i2 < octetLen; i2++, off++)
          val <<= 8, val |= buf[off], val >>>= 0;
        if (val <= 127)
          return false;
        return p.place = off, val;
      }
      function rmPadding(buf) {
        var i2 = 0, len2 = buf.length - 1;
        while (!buf[i2] && !(buf[i2 + 1] & 128) && i2 < len2)
          i2++;
        if (i2 === 0)
          return buf;
        return buf.slice(i2);
      }
      Signature.prototype._importDER = function _importDER(data, enc) {
        data = utils.toArray(data, enc);
        var p = new Position;
        if (data[p.place++] !== 48)
          return false;
        var len2 = getLength(data, p);
        if (len2 === false)
          return false;
        if (len2 + p.place !== data.length)
          return false;
        if (data[p.place++] !== 2)
          return false;
        var rlen = getLength(data, p);
        if (rlen === false)
          return false;
        if ((data[p.place] & 128) !== 0)
          return false;
        var r = data.slice(p.place, rlen + p.place);
        if (p.place += rlen, data[p.place++] !== 2)
          return false;
        var slen = getLength(data, p);
        if (slen === false)
          return false;
        if (data.length !== slen + p.place)
          return false;
        if ((data[p.place] & 128) !== 0)
          return false;
        var s = data.slice(p.place, slen + p.place);
        if (r[0] === 0)
          if (r[1] & 128)
            r = r.slice(1);
          else
            return false;
        if (s[0] === 0)
          if (s[1] & 128)
            s = s.slice(1);
          else
            return false;
        return this.r = new BN(r), this.s = new BN(s), this.recoveryParam = null, true;
      };
      function constructLength(arr, len2) {
        if (len2 < 128) {
          arr.push(len2);
          return;
        }
        var octets = 1 + (Math.log(len2) / Math.LN2 >>> 3);
        arr.push(octets | 128);
        while (--octets)
          arr.push(len2 >>> (octets << 3) & 255);
        arr.push(len2);
      }
      Signature.prototype.toDER = function toDER(enc) {
        var r = this.r.toArray(), s = this.s.toArray();
        if (r[0] & 128)
          r = [0].concat(r);
        if (s[0] & 128)
          s = [0].concat(s);
        r = rmPadding(r), s = rmPadding(s);
        while (!s[0] && !(s[1] & 128))
          s = s.slice(1);
        var arr = [2];
        constructLength(arr, r.length), arr = arr.concat(r), arr.push(2), constructLength(arr, s.length);
        var backHalf = arr.concat(s), res = [48];
        return constructLength(res, backHalf.length), res = res.concat(backHalf), utils.encode(res, enc);
      };
    });
    require_ec = __commonJS2((exports, module) => {
      var BN = require_bn(), HmacDRBG = require_hmac_drbg(), utils = require_utils2(), curves = require_curves(), rand = require_brorand(), assert = utils.assert, KeyPair = require_key(), Signature = require_signature();
      function EC(options) {
        if (!(this instanceof EC))
          return new EC(options);
        if (typeof options === "string")
          assert(Object.prototype.hasOwnProperty.call(curves, options), "Unknown curve " + options), options = curves[options];
        if (options instanceof curves.PresetCurve)
          options = { curve: options };
        this.curve = options.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = options.curve.g, this.g.precompute(options.curve.n.bitLength() + 1), this.hash = options.hash || options.curve.hash;
      }
      module.exports = EC;
      EC.prototype.keyPair = function keyPair(options) {
        return new KeyPair(this, options);
      };
      EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
        return KeyPair.fromPrivate(this, priv, enc);
      };
      EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
        return KeyPair.fromPublic(this, pub, enc);
      };
      EC.prototype.genKeyPair = function genKeyPair(options) {
        if (!options)
          options = {};
        var drbg = new HmacDRBG({ hash: this.hash, pers: options.pers, persEnc: options.persEnc || "utf8", entropy: options.entropy || rand(this.hash.hmacStrength), entropyEnc: options.entropy && options.entropyEnc || "utf8", nonce: this.n.toArray() }), bytes = this.n.byteLength(), ns2 = this.n.sub(new BN(2));
        for (;; ) {
          var priv = new BN(drbg.generate(bytes));
          if (priv.cmp(ns2) > 0)
            continue;
          return priv.iaddn(1), this.keyFromPrivate(priv);
        }
      };
      EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
        var byteLength2;
        if (BN.isBN(msg) || typeof msg === "number")
          msg = new BN(msg, 16), byteLength2 = msg.byteLength();
        else if (typeof msg === "object")
          byteLength2 = msg.length, msg = new BN(msg, 16);
        else {
          var str = msg.toString();
          byteLength2 = str.length + 1 >>> 1, msg = new BN(str, 16);
        }
        if (typeof bitLength !== "number")
          bitLength = byteLength2 * 8;
        var delta = bitLength - this.n.bitLength();
        if (delta > 0)
          msg = msg.ushrn(delta);
        if (!truncOnly && msg.cmp(this.n) >= 0)
          return msg.sub(this.n);
        else
          return msg;
      };
      EC.prototype.sign = function sign(msg, key, enc, options) {
        if (typeof enc === "object")
          options = enc, enc = null;
        if (!options)
          options = {};
        if (typeof msg !== "string" && typeof msg !== "number" && !BN.isBN(msg)) {
          assert(typeof msg === "object" && msg && typeof msg.length === "number", "Expected message to be an array-like, a hex string, or a BN instance"), assert(msg.length >>> 0 === msg.length);
          for (var i2 = 0;i2 < msg.length; i2++)
            assert((msg[i2] & 255) === msg[i2]);
        }
        key = this.keyFromPrivate(key, enc), msg = this._truncateToN(msg, false, options.msgBitLength), assert(!msg.isNeg(), "Can not sign a negative message");
        var bytes = this.n.byteLength(), bkey = key.getPrivate().toArray("be", bytes), nonce = msg.toArray("be", bytes);
        assert(new BN(nonce).eq(msg), "Can not sign message");
        var drbg = new HmacDRBG({ hash: this.hash, entropy: bkey, nonce, pers: options.pers, persEnc: options.persEnc || "utf8" }), ns1 = this.n.sub(new BN(1));
        for (var iter = 0;; iter++) {
          var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
          if (k = this._truncateToN(k, true), k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
            continue;
          var kp = this.g.mul(k);
          if (kp.isInfinity())
            continue;
          var kpX = kp.getX(), r = kpX.umod(this.n);
          if (r.cmpn(0) === 0)
            continue;
          var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
          if (s = s.umod(this.n), s.cmpn(0) === 0)
            continue;
          var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
          if (options.canonical && s.cmp(this.nh) > 0)
            s = this.n.sub(s), recoveryParam ^= 1;
          return new Signature({ r, s, recoveryParam });
        }
      };
      EC.prototype.verify = function verify(msg, signature, key, enc, options) {
        if (!options)
          options = {};
        msg = this._truncateToN(msg, false, options.msgBitLength), key = this.keyFromPublic(key, enc), signature = new Signature(signature, "hex");
        var { r, s } = signature;
        if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
          return false;
        if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
          return false;
        var sinv = s.invm(this.n), u1 = sinv.mul(msg).umod(this.n), u2 = sinv.mul(r).umod(this.n), p;
        if (!this.curve._maxwellTrick) {
          if (p = this.g.mulAdd(u1, key.getPublic(), u2), p.isInfinity())
            return false;
          return p.getX().umod(this.n).cmp(r) === 0;
        }
        if (p = this.g.jmulAdd(u1, key.getPublic(), u2), p.isInfinity())
          return false;
        return p.eqXToP(r);
      };
      EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
        assert((3 & j) === j, "The recovery param is more than two bits"), signature = new Signature(signature, enc);
        var n = this.n, e = new BN(msg), r = signature.r, s = signature.s, isYOdd = j & 1, isSecondKey = j >> 1;
        if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
          throw new Error("Unable to find sencond key candinate");
        if (isSecondKey)
          r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
        else
          r = this.curve.pointFromX(r, isYOdd);
        var rInv = signature.r.invm(n), s1 = n.sub(e).mul(rInv).umod(n), s2 = s.mul(rInv).umod(n);
        return this.g.mulAdd(s1, r, s2);
      };
      EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
        if (signature = new Signature(signature, enc), signature.recoveryParam !== null)
          return signature.recoveryParam;
        for (var i2 = 0;i2 < 4; i2++) {
          var Qprime;
          try {
            Qprime = this.recoverPubKey(e, signature, i2);
          } catch (e2) {
            continue;
          }
          if (Qprime.eq(Q))
            return i2;
        }
        throw new Error("Unable to find valid recovery factor");
      };
    });
    require_key2 = __commonJS2((exports, module) => {
      var utils = require_utils2(), assert = utils.assert, parseBytes = utils.parseBytes, cachedProperty = utils.cachedProperty;
      function KeyPair(eddsa, params) {
        if (this.eddsa = eddsa, this._secret = parseBytes(params.secret), eddsa.isPoint(params.pub))
          this._pub = params.pub;
        else
          this._pubBytes = parseBytes(params.pub);
      }
      KeyPair.fromPublic = function fromPublic(eddsa, pub) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(eddsa, { pub });
      };
      KeyPair.fromSecret = function fromSecret(eddsa, secret) {
        if (secret instanceof KeyPair)
          return secret;
        return new KeyPair(eddsa, { secret });
      };
      KeyPair.prototype.secret = function secret() {
        return this._secret;
      };
      cachedProperty(KeyPair, "pubBytes", function pubBytes() {
        return this.eddsa.encodePoint(this.pub());
      });
      cachedProperty(KeyPair, "pub", function pub() {
        if (this._pubBytes)
          return this.eddsa.decodePoint(this._pubBytes);
        return this.eddsa.g.mul(this.priv());
      });
      cachedProperty(KeyPair, "privBytes", function privBytes() {
        var eddsa = this.eddsa, hash2 = this.hash(), lastIx = eddsa.encodingLength - 1, a = hash2.slice(0, eddsa.encodingLength);
        return a[0] &= 248, a[lastIx] &= 127, a[lastIx] |= 64, a;
      });
      cachedProperty(KeyPair, "priv", function priv() {
        return this.eddsa.decodeInt(this.privBytes());
      });
      cachedProperty(KeyPair, "hash", function hash() {
        return this.eddsa.hash().update(this.secret()).digest();
      });
      cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
        return this.hash().slice(this.eddsa.encodingLength);
      });
      KeyPair.prototype.sign = function sign(message) {
        return assert(this._secret, "KeyPair can only verify"), this.eddsa.sign(message, this);
      };
      KeyPair.prototype.verify = function verify(message, sig) {
        return this.eddsa.verify(message, sig, this);
      };
      KeyPair.prototype.getSecret = function getSecret(enc) {
        return assert(this._secret, "KeyPair is public only"), utils.encode(this.secret(), enc);
      };
      KeyPair.prototype.getPublic = function getPublic(enc) {
        return utils.encode(this.pubBytes(), enc);
      };
      module.exports = KeyPair;
    });
    require_signature2 = __commonJS2((exports, module) => {
      var BN = require_bn(), utils = require_utils2(), assert = utils.assert, cachedProperty = utils.cachedProperty, parseBytes = utils.parseBytes;
      function Signature(eddsa, sig) {
        if (this.eddsa = eddsa, typeof sig !== "object")
          sig = parseBytes(sig);
        if (Array.isArray(sig))
          assert(sig.length === eddsa.encodingLength * 2, "Signature has invalid size"), sig = { R: sig.slice(0, eddsa.encodingLength), S: sig.slice(eddsa.encodingLength) };
        if (assert(sig.R && sig.S, "Signature without R or S"), eddsa.isPoint(sig.R))
          this._R = sig.R;
        if (sig.S instanceof BN)
          this._S = sig.S;
        this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded, this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
      }
      cachedProperty(Signature, "S", function S() {
        return this.eddsa.decodeInt(this.Sencoded());
      });
      cachedProperty(Signature, "R", function R() {
        return this.eddsa.decodePoint(this.Rencoded());
      });
      cachedProperty(Signature, "Rencoded", function Rencoded() {
        return this.eddsa.encodePoint(this.R());
      });
      cachedProperty(Signature, "Sencoded", function Sencoded() {
        return this.eddsa.encodeInt(this.S());
      });
      Signature.prototype.toBytes = function toBytes() {
        return this.Rencoded().concat(this.Sencoded());
      };
      Signature.prototype.toHex = function toHex() {
        return utils.encode(this.toBytes(), "hex").toUpperCase();
      };
      module.exports = Signature;
    });
    require_eddsa = __commonJS2((exports, module) => {
      var hash2 = require_hash(), curves = require_curves(), utils = require_utils2(), assert = utils.assert, parseBytes = utils.parseBytes, KeyPair = require_key2(), Signature = require_signature2();
      function EDDSA(curve) {
        if (assert(curve === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
          return new EDDSA(curve);
        curve = curves[curve].curve, this.curve = curve, this.g = curve.g, this.g.precompute(curve.n.bitLength() + 1), this.pointClass = curve.point().constructor, this.encodingLength = Math.ceil(curve.n.bitLength() / 8), this.hash = hash2.sha512;
      }
      module.exports = EDDSA;
      EDDSA.prototype.sign = function sign(message, secret) {
        message = parseBytes(message);
        var key = this.keyFromSecret(secret), r = this.hashInt(key.messagePrefix(), message), R = this.g.mul(r), Rencoded = this.encodePoint(R), s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv()), S = r.add(s_).umod(this.curve.n);
        return this.makeSignature({ R, S, Rencoded });
      };
      EDDSA.prototype.verify = function verify(message, sig, pub) {
        if (message = parseBytes(message), sig = this.makeSignature(sig), sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg())
          return false;
        var key = this.keyFromPublic(pub), h = this.hashInt(sig.Rencoded(), key.pubBytes(), message), SG = this.g.mul(sig.S()), RplusAh = sig.R().add(key.pub().mul(h));
        return RplusAh.eq(SG);
      };
      EDDSA.prototype.hashInt = function hashInt() {
        var hash22 = this.hash();
        for (var i2 = 0;i2 < arguments.length; i2++)
          hash22.update(arguments[i2]);
        return utils.intFromLE(hash22.digest()).umod(this.curve.n);
      };
      EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
        return KeyPair.fromPublic(this, pub);
      };
      EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
        return KeyPair.fromSecret(this, secret);
      };
      EDDSA.prototype.makeSignature = function makeSignature(sig) {
        if (sig instanceof Signature)
          return sig;
        return new Signature(this, sig);
      };
      EDDSA.prototype.encodePoint = function encodePoint(point) {
        var enc = point.getY().toArray("le", this.encodingLength);
        return enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0, enc;
      };
      EDDSA.prototype.decodePoint = function decodePoint(bytes) {
        bytes = utils.parseBytes(bytes);
        var lastIx = bytes.length - 1, normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & -129), xIsOdd = (bytes[lastIx] & 128) !== 0, y = utils.intFromLE(normed);
        return this.curve.pointFromY(y, xIsOdd);
      };
      EDDSA.prototype.encodeInt = function encodeInt(num) {
        return num.toArray("le", this.encodingLength);
      };
      EDDSA.prototype.decodeInt = function decodeInt(bytes) {
        return utils.intFromLE(bytes);
      };
      EDDSA.prototype.isPoint = function isPoint(val) {
        return val instanceof this.pointClass;
      };
    });
    require_elliptic = __commonJS2((exports) => {
      var elliptic = exports;
      elliptic.version = require_package().version;
      elliptic.utils = require_utils2();
      elliptic.rand = require_brorand();
      elliptic.curve = require_curve();
      elliptic.curves = require_curves();
      elliptic.ec = require_ec();
      elliptic.eddsa = require_eddsa();
    });
    require_bn2 = __commonJS2((exports, module) => {
      (function(module2, exports2) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {};
          TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
        }
        function BN(number4, base, endian) {
          if (BN.isBN(number4))
            return number4;
          if (this.negative = 0, this.words = null, this.length = 0, this.red = null, number4 !== null) {
            if (base === "le" || base === "be")
              endian = base, base = 10;
            this._init(number4 || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object")
          module2.exports = BN;
        else
          exports2.BN = BN;
        BN.BN = BN, BN.wordSize = 26;
        var Buffer22;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined")
            Buffer22 = window.Buffer;
          else
            Buffer22 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
        } catch (e) {}
        BN.isBN = function isBN(num) {
          if (num instanceof BN)
            return true;
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        }, BN.max = function max(left3, right3) {
          if (left3.cmp(right3) > 0)
            return left3;
          return right3;
        }, BN.min = function min(left3, right3) {
          if (left3.cmp(right3) < 0)
            return left3;
          return right3;
        }, BN.prototype._init = function init(number4, base, endian) {
          if (typeof number4 === "number")
            return this._initNumber(number4, base, endian);
          if (typeof number4 === "object")
            return this._initArray(number4, base, endian);
          if (base === "hex")
            base = 16;
          assert(base === (base | 0) && base >= 2 && base <= 36), number4 = number4.toString().replace(/\s+/g, "");
          var start4 = 0;
          if (number4[0] === "-")
            start4++, this.negative = 1;
          if (start4 < number4.length) {
            if (base === 16)
              this._parseHex(number4, start4, endian);
            else if (this._parseBase(number4, base, start4), endian === "le")
              this._initArray(this.toArray(), base, endian);
          }
        }, BN.prototype._initNumber = function _initNumber(number4, base, endian) {
          if (number4 < 0)
            this.negative = 1, number4 = -number4;
          if (number4 < 67108864)
            this.words = [number4 & 67108863], this.length = 1;
          else if (number4 < 4503599627370496)
            this.words = [number4 & 67108863, number4 / 67108864 & 67108863], this.length = 2;
          else
            assert(number4 < 9007199254740992), this.words = [number4 & 67108863, number4 / 67108864 & 67108863, 1], this.length = 3;
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        }, BN.prototype._initArray = function _initArray(number4, base, endian) {
          if (assert(typeof number4.length === "number"), number4.length <= 0)
            return this.words = [0], this.length = 1, this;
          this.length = Math.ceil(number4.length / 3), this.words = new Array(this.length);
          for (var i2 = 0;i2 < this.length; i2++)
            this.words[i2] = 0;
          var j, w, off = 0;
          if (endian === "be") {
            for (i2 = number4.length - 1, j = 0;i2 >= 0; i2 -= 3)
              if (w = number4[i2] | number4[i2 - 1] << 8 | number4[i2 - 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
                off -= 26, j++;
          } else if (endian === "le") {
            for (i2 = 0, j = 0;i2 < number4.length; i2 += 3)
              if (w = number4[i2] | number4[i2 + 1] << 8 | number4[i2 + 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
                off -= 26, j++;
          }
          return this.strip();
        };
        function parseHex4Bits(string3, index) {
          var c = string3.charCodeAt(index);
          if (c >= 65 && c <= 70)
            return c - 55;
          else if (c >= 97 && c <= 102)
            return c - 87;
          else
            return c - 48 & 15;
        }
        function parseHexByte(string3, lowerBound, index) {
          var r = parseHex4Bits(string3, index);
          if (index - 1 >= lowerBound)
            r |= parseHex4Bits(string3, index - 1) << 4;
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number4, start4, endian) {
          this.length = Math.ceil((number4.length - start4) / 6), this.words = new Array(this.length);
          for (var i2 = 0;i2 < this.length; i2++)
            this.words[i2] = 0;
          var off = 0, j = 0, w;
          if (endian === "be")
            for (i2 = number4.length - 1;i2 >= start4; i2 -= 2)
              if (w = parseHexByte(number4, start4, i2) << off, this.words[j] |= w & 67108863, off >= 18)
                off -= 18, j += 1, this.words[j] |= w >>> 26;
              else
                off += 8;
          else {
            var parseLength = number4.length - start4;
            for (i2 = parseLength % 2 === 0 ? start4 + 1 : start4;i2 < number4.length; i2 += 2)
              if (w = parseHexByte(number4, start4, i2) << off, this.words[j] |= w & 67108863, off >= 18)
                off -= 18, j += 1, this.words[j] |= w >>> 26;
              else
                off += 8;
          }
          this.strip();
        };
        function parseBase(str, start4, end6, mul) {
          var r = 0, len2 = Math.min(str.length, end6);
          for (var i2 = start4;i2 < len2; i2++) {
            var c = str.charCodeAt(i2) - 48;
            if (r *= mul, c >= 49)
              r += c - 49 + 10;
            else if (c >= 17)
              r += c - 17 + 10;
            else
              r += c;
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number4, base, start4) {
          this.words = [0], this.length = 1;
          for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base)
            limbLen++;
          limbLen--, limbPow = limbPow / base | 0;
          var total = number4.length - start4, mod = total % limbLen, end6 = Math.min(total, total - mod) + start4, word = 0;
          for (var i2 = start4;i2 < end6; i2 += limbLen)
            if (word = parseBase(number4, i2, i2 + limbLen, base), this.imuln(limbPow), this.words[0] + word < 67108864)
              this.words[0] += word;
            else
              this._iaddn(word);
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number4, i2, number4.length, base);
            for (i2 = 0;i2 < mod; i2++)
              pow *= base;
            if (this.imuln(pow), this.words[0] + word < 67108864)
              this.words[0] += word;
            else
              this._iaddn(word);
          }
          this.strip();
        }, BN.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i2 = 0;i2 < this.length; i2++)
            dest.words[i2] = this.words[i2];
          dest.length = this.length, dest.negative = this.negative, dest.red = this.red;
        }, BN.prototype.clone = function clone() {
          var r = new BN(null);
          return this.copy(r), r;
        }, BN.prototype._expand = function _expand(size13) {
          while (this.length < size13)
            this.words[this.length++] = 0;
          return this;
        }, BN.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0)
            this.length--;
          return this._normSign();
        }, BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0)
            this.negative = 0;
          return this;
        }, BN.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        if (BN.prototype.toString = function toString(base, padding) {
          base = base || 10, padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0, carry = 0;
            for (var i2 = 0;i2 < this.length; i2++) {
              var w = this.words[i2], word = ((w << off | carry) & 16777215).toString(16);
              if (carry = w >>> 24 - off & 16777215, off += 2, off >= 26)
                off -= 26, i2--;
              if (carry !== 0 || i2 !== this.length - 1)
                out = zeros[6 - word.length] + word + out;
              else
                out = word + out;
            }
            if (carry !== 0)
              out = carry.toString(16) + out;
            while (out.length % padding !== 0)
              out = "0" + out;
            if (this.negative !== 0)
              out = "-" + out;
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base], groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modn(groupBase).toString(base);
              if (c = c.idivn(groupBase), !c.isZero())
                out = zeros[groupSize - r.length] + r + out;
              else
                out = r + out;
            }
            if (this.isZero())
              out = "0" + out;
            while (out.length % padding !== 0)
              out = "0" + out;
            if (this.negative !== 0)
              out = "-" + out;
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        }, BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2)
            ret += this.words[1] * 67108864;
          else if (this.length === 3 && this.words[2] === 1)
            ret += 4503599627370496 + this.words[1] * 67108864;
          else if (this.length > 2)
            assert(false, "Number can only safely store up to 53 bits");
          return this.negative !== 0 ? -ret : ret;
        }, BN.prototype.toJSON = function toJSON() {
          return this.toString(16);
        }, BN.prototype.toBuffer = function toBuffer(endian, length3) {
          return assert(typeof Buffer22 !== "undefined"), this.toArrayLike(Buffer22, endian, length3);
        }, BN.prototype.toArray = function toArray(endian, length3) {
          return this.toArrayLike(Array, endian, length3);
        }, BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length3) {
          var byteLength2 = this.byteLength(), reqLength = length3 || Math.max(1, byteLength2);
          assert(byteLength2 <= reqLength, "byte array longer than desired length"), assert(reqLength > 0, "Requested array length <= 0"), this.strip();
          var littleEndian = endian === "le", res = new ArrayType(reqLength), b, i2, q = this.clone();
          if (!littleEndian) {
            for (i2 = 0;i2 < reqLength - byteLength2; i2++)
              res[i2] = 0;
            for (i2 = 0;!q.isZero(); i2++)
              b = q.andln(255), q.iushrn(8), res[reqLength - i2 - 1] = b;
          } else {
            for (i2 = 0;!q.isZero(); i2++)
              b = q.andln(255), q.iushrn(8), res[i2] = b;
            for (;i2 < reqLength; i2++)
              res[i2] = 0;
          }
          return res;
        }, Math.clz32)
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        else
          BN.prototype._countBits = function _countBits(w) {
            var t = w, r = 0;
            if (t >= 4096)
              r += 13, t >>>= 13;
            if (t >= 64)
              r += 7, t >>>= 7;
            if (t >= 8)
              r += 4, t >>>= 4;
            if (t >= 2)
              r += 2, t >>>= 2;
            return r + t;
          };
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w, r = 0;
          if ((t & 8191) === 0)
            r += 13, t >>>= 13;
          if ((t & 127) === 0)
            r += 7, t >>>= 7;
          if ((t & 15) === 0)
            r += 4, t >>>= 4;
          if ((t & 3) === 0)
            r += 2, t >>>= 2;
          if ((t & 1) === 0)
            r++;
          return r;
        }, BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1], hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0;bit < w.length; bit++) {
            var off = bit / 26 | 0, wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var b = this._zeroBits(this.words[i2]);
            if (r += b, b !== 26)
              break;
          }
          return r;
        }, BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        }, BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0)
            return this.abs().inotn(width).iaddn(1);
          return this.clone();
        }, BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1))
            return this.notn(width).iaddn(1).ineg();
          return this.clone();
        }, BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        }, BN.prototype.neg = function neg() {
          return this.clone().ineg();
        }, BN.prototype.ineg = function ineg() {
          if (!this.isZero())
            this.negative ^= 1;
          return this;
        }, BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length)
            this.words[this.length++] = 0;
          for (var i2 = 0;i2 < num.length; i2++)
            this.words[i2] = this.words[i2] | num.words[i2];
          return this.strip();
        }, BN.prototype.ior = function ior(num) {
          return assert((this.negative | num.negative) === 0), this.iuor(num);
        }, BN.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        }, BN.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        }, BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length)
            b = num;
          else
            b = this;
          for (var i2 = 0;i2 < b.length; i2++)
            this.words[i2] = this.words[i2] & num.words[i2];
          return this.length = b.length, this.strip();
        }, BN.prototype.iand = function iand(num) {
          return assert((this.negative | num.negative) === 0), this.iuand(num);
        }, BN.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        }, BN.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        }, BN.prototype.iuxor = function iuxor(num) {
          var a, b;
          if (this.length > num.length)
            a = this, b = num;
          else
            a = num, b = this;
          for (var i2 = 0;i2 < b.length; i2++)
            this.words[i2] = a.words[i2] ^ b.words[i2];
          if (this !== a)
            for (;i2 < a.length; i2++)
              this.words[i2] = a.words[i2];
          return this.length = a.length, this.strip();
        }, BN.prototype.ixor = function ixor(num) {
          return assert((this.negative | num.negative) === 0), this.iuxor(num);
        }, BN.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        }, BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        }, BN.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0, bitsLeft = width % 26;
          if (this._expand(bytesNeeded), bitsLeft > 0)
            bytesNeeded--;
          for (var i2 = 0;i2 < bytesNeeded; i2++)
            this.words[i2] = ~this.words[i2] & 67108863;
          if (bitsLeft > 0)
            this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
          return this.strip();
        }, BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        }, BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0, wbit = bit % 26;
          if (this._expand(off + 1), val)
            this.words[off] = this.words[off] | 1 << wbit;
          else
            this.words[off] = this.words[off] & ~(1 << wbit);
          return this.strip();
        }, BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0)
            return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();
          else if (this.negative === 0 && num.negative !== 0)
            return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();
          var a, b;
          if (this.length > num.length)
            a = this, b = num;
          else
            a = num, b = this;
          var carry = 0;
          for (var i2 = 0;i2 < b.length; i2++)
            r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
          for (;carry !== 0 && i2 < a.length; i2++)
            r = (a.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
          if (this.length = a.length, carry !== 0)
            this.words[this.length] = carry, this.length++;
          else if (a !== this)
            for (;i2 < a.length; i2++)
              this.words[i2] = a.words[i2];
          return this;
        }, BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0)
            return num.negative = 0, res = this.sub(num), num.negative ^= 1, res;
          else if (num.negative === 0 && this.negative !== 0)
            return this.negative = 0, res = num.sub(this), this.negative = 1, res;
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        }, BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            return num.negative = 1, r._normSign();
          } else if (this.negative !== 0)
            return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();
          var cmp = this.cmp(num);
          if (cmp === 0)
            return this.negative = 0, this.length = 1, this.words[0] = 0, this;
          var a, b;
          if (cmp > 0)
            a = this, b = num;
          else
            a = num, b = this;
          var carry = 0;
          for (var i2 = 0;i2 < b.length; i2++)
            r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
          for (;carry !== 0 && i2 < a.length; i2++)
            r = (a.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
          if (carry === 0 && i2 < a.length && a !== this)
            for (;i2 < a.length; i2++)
              this.words[i2] = a.words[i2];
          if (this.length = Math.max(this.length, i2), a !== this)
            this.negative = 1;
          return this.strip();
        }, BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len2 = self2.length + num.length | 0;
          out.length = len2, len2 = len2 - 1 | 0;
          var a = self2.words[0] | 0, b = num.words[0] | 0, r = a * b, lo = r & 67108863, carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1;k < len2; k++) {
            var ncarry = carry >>> 26, rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
              var i2 = k - j | 0;
              a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b + rword, ncarry += r / 67108864 | 0, rword = r & 67108863;
            }
            out.words[k] = rword | 0, carry = ncarry | 0;
          }
          if (carry !== 0)
            out.words[k] = carry | 0;
          else
            out.length--;
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo(self2, num, out) {
          var a = self2.words, b = num.words, o = out.words, c = 0, lo, mid, hi, a0 = a[0] | 0, al0 = a0 & 8191, ah0 = a0 >>> 13, a1 = a[1] | 0, al1 = a1 & 8191, ah1 = a1 >>> 13, a2 = a[2] | 0, al2 = a2 & 8191, ah2 = a2 >>> 13, a3 = a[3] | 0, al3 = a3 & 8191, ah3 = a3 >>> 13, a4 = a[4] | 0, al4 = a4 & 8191, ah4 = a4 >>> 13, a5 = a[5] | 0, al5 = a5 & 8191, ah5 = a5 >>> 13, a6 = a[6] | 0, al6 = a6 & 8191, ah6 = a6 >>> 13, a7 = a[7] | 0, al7 = a7 & 8191, ah7 = a7 >>> 13, a8 = a[8] | 0, al8 = a8 & 8191, ah8 = a8 >>> 13, a9 = a[9] | 0, al9 = a9 & 8191, ah9 = a9 >>> 13, b0 = b[0] | 0, bl0 = b0 & 8191, bh0 = b0 >>> 13, b1 = b[1] | 0, bl1 = b1 & 8191, bh1 = b1 >>> 13, b2 = b[2] | 0, bl2 = b2 & 8191, bh2 = b2 >>> 13, b3 = b[3] | 0, bl3 = b3 & 8191, bh3 = b3 >>> 13, b4 = b[4] | 0, bl4 = b4 & 8191, bh4 = b4 >>> 13, b5 = b[5] | 0, bl5 = b5 & 8191, bh5 = b5 >>> 13, b6 = b[6] | 0, bl6 = b6 & 8191, bh6 = b6 >>> 13, b7 = b[7] | 0, bl7 = b7 & 8191, bh7 = b7 >>> 13, b8 = b[8] | 0, bl8 = b8 & 8191, bh8 = b8 >>> 13, b9 = b[9] | 0, bl9 = b9 & 8191, bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative, out.length = 19, lo = Math.imul(al0, bl0), mid = Math.imul(al0, bh0), mid = mid + Math.imul(ah0, bl0) | 0, hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, lo = Math.imul(al1, bl0), mid = Math.imul(al1, bh0), mid = mid + Math.imul(ah1, bl0) | 0, hi = Math.imul(ah1, bh0), lo = lo + Math.imul(al0, bl1) | 0, mid = mid + Math.imul(al0, bh1) | 0, mid = mid + Math.imul(ah0, bl1) | 0, hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 67108863, lo = Math.imul(al2, bl0), mid = Math.imul(al2, bh0), mid = mid + Math.imul(ah2, bl0) | 0, hi = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = mid + Math.imul(al1, bh1) | 0, mid = mid + Math.imul(ah1, bl1) | 0, hi = hi + Math.imul(ah1, bh1) | 0, lo = lo + Math.imul(al0, bl2) | 0, mid = mid + Math.imul(al0, bh2) | 0, mid = mid + Math.imul(ah0, bl2) | 0, hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 67108863, lo = Math.imul(al3, bl0), mid = Math.imul(al3, bh0), mid = mid + Math.imul(ah3, bl0) | 0, hi = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = mid + Math.imul(al2, bh1) | 0, mid = mid + Math.imul(ah2, bl1) | 0, hi = hi + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = mid + Math.imul(al1, bh2) | 0, mid = mid + Math.imul(ah1, bl2) | 0, hi = hi + Math.imul(ah1, bh2) | 0, lo = lo + Math.imul(al0, bl3) | 0, mid = mid + Math.imul(al0, bh3) | 0, mid = mid + Math.imul(ah0, bl3) | 0, hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 67108863, lo = Math.imul(al4, bl0), mid = Math.imul(al4, bh0), mid = mid + Math.imul(ah4, bl0) | 0, hi = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = mid + Math.imul(al3, bh1) | 0, mid = mid + Math.imul(ah3, bl1) | 0, hi = hi + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = mid + Math.imul(al2, bh2) | 0, mid = mid + Math.imul(ah2, bl2) | 0, hi = hi + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = mid + Math.imul(al1, bh3) | 0, mid = mid + Math.imul(ah1, bl3) | 0, hi = hi + Math.imul(ah1, bh3) | 0, lo = lo + Math.imul(al0, bl4) | 0, mid = mid + Math.imul(al0, bh4) | 0, mid = mid + Math.imul(ah0, bl4) | 0, hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 67108863, lo = Math.imul(al5, bl0), mid = Math.imul(al5, bh0), mid = mid + Math.imul(ah5, bl0) | 0, hi = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = mid + Math.imul(al4, bh1) | 0, mid = mid + Math.imul(ah4, bl1) | 0, hi = hi + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = mid + Math.imul(al3, bh2) | 0, mid = mid + Math.imul(ah3, bl2) | 0, hi = hi + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = mid + Math.imul(al2, bh3) | 0, mid = mid + Math.imul(ah2, bl3) | 0, hi = hi + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = mid + Math.imul(al1, bh4) | 0, mid = mid + Math.imul(ah1, bl4) | 0, hi = hi + Math.imul(ah1, bh4) | 0, lo = lo + Math.imul(al0, bl5) | 0, mid = mid + Math.imul(al0, bh5) | 0, mid = mid + Math.imul(ah0, bl5) | 0, hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 67108863, lo = Math.imul(al6, bl0), mid = Math.imul(al6, bh0), mid = mid + Math.imul(ah6, bl0) | 0, hi = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = mid + Math.imul(al5, bh1) | 0, mid = mid + Math.imul(ah5, bl1) | 0, hi = hi + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = mid + Math.imul(al4, bh2) | 0, mid = mid + Math.imul(ah4, bl2) | 0, hi = hi + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = mid + Math.imul(al3, bh3) | 0, mid = mid + Math.imul(ah3, bl3) | 0, hi = hi + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = mid + Math.imul(al2, bh4) | 0, mid = mid + Math.imul(ah2, bl4) | 0, hi = hi + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = mid + Math.imul(al1, bh5) | 0, mid = mid + Math.imul(ah1, bl5) | 0, hi = hi + Math.imul(ah1, bh5) | 0, lo = lo + Math.imul(al0, bl6) | 0, mid = mid + Math.imul(al0, bh6) | 0, mid = mid + Math.imul(ah0, bl6) | 0, hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 67108863, lo = Math.imul(al7, bl0), mid = Math.imul(al7, bh0), mid = mid + Math.imul(ah7, bl0) | 0, hi = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = mid + Math.imul(al6, bh1) | 0, mid = mid + Math.imul(ah6, bl1) | 0, hi = hi + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = mid + Math.imul(al5, bh2) | 0, mid = mid + Math.imul(ah5, bl2) | 0, hi = hi + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = mid + Math.imul(al4, bh3) | 0, mid = mid + Math.imul(ah4, bl3) | 0, hi = hi + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = mid + Math.imul(al3, bh4) | 0, mid = mid + Math.imul(ah3, bl4) | 0, hi = hi + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = mid + Math.imul(al2, bh5) | 0, mid = mid + Math.imul(ah2, bl5) | 0, hi = hi + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = mid + Math.imul(al1, bh6) | 0, mid = mid + Math.imul(ah1, bl6) | 0, hi = hi + Math.imul(ah1, bh6) | 0, lo = lo + Math.imul(al0, bl7) | 0, mid = mid + Math.imul(al0, bh7) | 0, mid = mid + Math.imul(ah0, bl7) | 0, hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 67108863, lo = Math.imul(al8, bl0), mid = Math.imul(al8, bh0), mid = mid + Math.imul(ah8, bl0) | 0, hi = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = mid + Math.imul(al7, bh1) | 0, mid = mid + Math.imul(ah7, bl1) | 0, hi = hi + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = mid + Math.imul(al6, bh2) | 0, mid = mid + Math.imul(ah6, bl2) | 0, hi = hi + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = mid + Math.imul(al5, bh3) | 0, mid = mid + Math.imul(ah5, bl3) | 0, hi = hi + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = mid + Math.imul(al4, bh4) | 0, mid = mid + Math.imul(ah4, bl4) | 0, hi = hi + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = mid + Math.imul(al3, bh5) | 0, mid = mid + Math.imul(ah3, bl5) | 0, hi = hi + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = mid + Math.imul(al2, bh6) | 0, mid = mid + Math.imul(ah2, bl6) | 0, hi = hi + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = mid + Math.imul(al1, bh7) | 0, mid = mid + Math.imul(ah1, bl7) | 0, hi = hi + Math.imul(ah1, bh7) | 0, lo = lo + Math.imul(al0, bl8) | 0, mid = mid + Math.imul(al0, bh8) | 0, mid = mid + Math.imul(ah0, bl8) | 0, hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, lo = Math.imul(al9, bl0), mid = Math.imul(al9, bh0), mid = mid + Math.imul(ah9, bl0) | 0, hi = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = mid + Math.imul(al8, bh1) | 0, mid = mid + Math.imul(ah8, bl1) | 0, hi = hi + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = mid + Math.imul(al7, bh2) | 0, mid = mid + Math.imul(ah7, bl2) | 0, hi = hi + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = mid + Math.imul(al6, bh3) | 0, mid = mid + Math.imul(ah6, bl3) | 0, hi = hi + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = mid + Math.imul(al5, bh4) | 0, mid = mid + Math.imul(ah5, bl4) | 0, hi = hi + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = mid + Math.imul(al4, bh5) | 0, mid = mid + Math.imul(ah4, bl5) | 0, hi = hi + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = mid + Math.imul(al3, bh6) | 0, mid = mid + Math.imul(ah3, bl6) | 0, hi = hi + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = mid + Math.imul(al2, bh7) | 0, mid = mid + Math.imul(ah2, bl7) | 0, hi = hi + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = mid + Math.imul(al1, bh8) | 0, mid = mid + Math.imul(ah1, bl8) | 0, hi = hi + Math.imul(ah1, bh8) | 0, lo = lo + Math.imul(al0, bl9) | 0, mid = mid + Math.imul(al0, bh9) | 0, mid = mid + Math.imul(ah0, bl9) | 0, hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 67108863, lo = Math.imul(al9, bl1), mid = Math.imul(al9, bh1), mid = mid + Math.imul(ah9, bl1) | 0, hi = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = mid + Math.imul(al8, bh2) | 0, mid = mid + Math.imul(ah8, bl2) | 0, hi = hi + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = mid + Math.imul(al7, bh3) | 0, mid = mid + Math.imul(ah7, bl3) | 0, hi = hi + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = mid + Math.imul(al6, bh4) | 0, mid = mid + Math.imul(ah6, bl4) | 0, hi = hi + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = mid + Math.imul(al5, bh5) | 0, mid = mid + Math.imul(ah5, bl5) | 0, hi = hi + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = mid + Math.imul(al4, bh6) | 0, mid = mid + Math.imul(ah4, bl6) | 0, hi = hi + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = mid + Math.imul(al3, bh7) | 0, mid = mid + Math.imul(ah3, bl7) | 0, hi = hi + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = mid + Math.imul(al2, bh8) | 0, mid = mid + Math.imul(ah2, bl8) | 0, hi = hi + Math.imul(ah2, bh8) | 0, lo = lo + Math.imul(al1, bl9) | 0, mid = mid + Math.imul(al1, bh9) | 0, mid = mid + Math.imul(ah1, bl9) | 0, hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 67108863, lo = Math.imul(al9, bl2), mid = Math.imul(al9, bh2), mid = mid + Math.imul(ah9, bl2) | 0, hi = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = mid + Math.imul(al8, bh3) | 0, mid = mid + Math.imul(ah8, bl3) | 0, hi = hi + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = mid + Math.imul(al7, bh4) | 0, mid = mid + Math.imul(ah7, bl4) | 0, hi = hi + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = mid + Math.imul(al6, bh5) | 0, mid = mid + Math.imul(ah6, bl5) | 0, hi = hi + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = mid + Math.imul(al5, bh6) | 0, mid = mid + Math.imul(ah5, bl6) | 0, hi = hi + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = mid + Math.imul(al4, bh7) | 0, mid = mid + Math.imul(ah4, bl7) | 0, hi = hi + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = mid + Math.imul(al3, bh8) | 0, mid = mid + Math.imul(ah3, bl8) | 0, hi = hi + Math.imul(ah3, bh8) | 0, lo = lo + Math.imul(al2, bl9) | 0, mid = mid + Math.imul(al2, bh9) | 0, mid = mid + Math.imul(ah2, bl9) | 0, hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 67108863, lo = Math.imul(al9, bl3), mid = Math.imul(al9, bh3), mid = mid + Math.imul(ah9, bl3) | 0, hi = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = mid + Math.imul(al8, bh4) | 0, mid = mid + Math.imul(ah8, bl4) | 0, hi = hi + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = mid + Math.imul(al7, bh5) | 0, mid = mid + Math.imul(ah7, bl5) | 0, hi = hi + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = mid + Math.imul(al6, bh6) | 0, mid = mid + Math.imul(ah6, bl6) | 0, hi = hi + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = mid + Math.imul(al5, bh7) | 0, mid = mid + Math.imul(ah5, bl7) | 0, hi = hi + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = mid + Math.imul(al4, bh8) | 0, mid = mid + Math.imul(ah4, bl8) | 0, hi = hi + Math.imul(ah4, bh8) | 0, lo = lo + Math.imul(al3, bl9) | 0, mid = mid + Math.imul(al3, bh9) | 0, mid = mid + Math.imul(ah3, bl9) | 0, hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 67108863, lo = Math.imul(al9, bl4), mid = Math.imul(al9, bh4), mid = mid + Math.imul(ah9, bl4) | 0, hi = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = mid + Math.imul(al8, bh5) | 0, mid = mid + Math.imul(ah8, bl5) | 0, hi = hi + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = mid + Math.imul(al7, bh6) | 0, mid = mid + Math.imul(ah7, bl6) | 0, hi = hi + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = mid + Math.imul(al6, bh7) | 0, mid = mid + Math.imul(ah6, bl7) | 0, hi = hi + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = mid + Math.imul(al5, bh8) | 0, mid = mid + Math.imul(ah5, bl8) | 0, hi = hi + Math.imul(ah5, bh8) | 0, lo = lo + Math.imul(al4, bl9) | 0, mid = mid + Math.imul(al4, bh9) | 0, mid = mid + Math.imul(ah4, bl9) | 0, hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 67108863, lo = Math.imul(al9, bl5), mid = Math.imul(al9, bh5), mid = mid + Math.imul(ah9, bl5) | 0, hi = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = mid + Math.imul(al8, bh6) | 0, mid = mid + Math.imul(ah8, bl6) | 0, hi = hi + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = mid + Math.imul(al7, bh7) | 0, mid = mid + Math.imul(ah7, bl7) | 0, hi = hi + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = mid + Math.imul(al6, bh8) | 0, mid = mid + Math.imul(ah6, bl8) | 0, hi = hi + Math.imul(ah6, bh8) | 0, lo = lo + Math.imul(al5, bl9) | 0, mid = mid + Math.imul(al5, bh9) | 0, mid = mid + Math.imul(ah5, bl9) | 0, hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 67108863, lo = Math.imul(al9, bl6), mid = Math.imul(al9, bh6), mid = mid + Math.imul(ah9, bl6) | 0, hi = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = mid + Math.imul(al8, bh7) | 0, mid = mid + Math.imul(ah8, bl7) | 0, hi = hi + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = mid + Math.imul(al7, bh8) | 0, mid = mid + Math.imul(ah7, bl8) | 0, hi = hi + Math.imul(ah7, bh8) | 0, lo = lo + Math.imul(al6, bl9) | 0, mid = mid + Math.imul(al6, bh9) | 0, mid = mid + Math.imul(ah6, bl9) | 0, hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 67108863, lo = Math.imul(al9, bl7), mid = Math.imul(al9, bh7), mid = mid + Math.imul(ah9, bl7) | 0, hi = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = mid + Math.imul(al8, bh8) | 0, mid = mid + Math.imul(ah8, bl8) | 0, hi = hi + Math.imul(ah8, bh8) | 0, lo = lo + Math.imul(al7, bl9) | 0, mid = mid + Math.imul(al7, bh9) | 0, mid = mid + Math.imul(ah7, bl9) | 0, hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 67108863, lo = Math.imul(al9, bl8), mid = Math.imul(al9, bh8), mid = mid + Math.imul(ah9, bl8) | 0, hi = Math.imul(ah9, bh8), lo = lo + Math.imul(al8, bl9) | 0, mid = mid + Math.imul(al8, bh9) | 0, mid = mid + Math.imul(ah8, bl9) | 0, hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 67108863, lo = Math.imul(al9, bl9), mid = Math.imul(al9, bh9), mid = mid + Math.imul(ah9, bl9) | 0, hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          if (c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, c !== 0)
            o[19] = c, out.length++;
          return out;
        };
        if (!Math.imul)
          comb10MulTo = smallMulTo;
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative, out.length = self2.length + num.length;
          var carry = 0, hncarry = 0;
          for (var k = 0;k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
              var i2 = k - j, a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b, lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0, lo = lo + rword | 0, rword = lo & 67108863, ncarry = ncarry + (lo >>> 26) | 0, hncarry += ncarry >>> 26, ncarry &= 67108863;
            }
            out.words[k] = rword, carry = ncarry, ncarry = hncarry;
          }
          if (carry !== 0)
            out.words[k] = carry;
          else
            out.length--;
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM;
          return fftm.mulp(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res, len2 = this.length + num.length;
          if (this.length === 10 && num.length === 10)
            res = comb10MulTo(this, num, out);
          else if (len2 < 63)
            res = smallMulTo(this, num, out);
          else if (len2 < 1024)
            res = bigMulTo(this, num, out);
          else
            res = jumboMulTo(this, num, out);
          return res;
        };
        function FFTM(x, y) {
          this.x = x, this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N), l = BN.prototype._countBits(N) - 1;
          for (var i2 = 0;i2 < N; i2++)
            t[i2] = this.revBin(i2, l, N);
          return t;
        }, FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i2 = 0;i2 < l; i2++)
            rb |= (x & 1) << l - i2 - 1, x >>= 1;
          return rb;
        }, FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i2 = 0;i2 < N; i2++)
            rtws[i2] = rws[rbt[i2]], itws[i2] = iws[rbt[i2]];
        }, FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1;s < N; s <<= 1) {
            var l = s << 1, rtwdf = Math.cos(2 * Math.PI / l), itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0;p < N; p += l) {
              var rtwdf_ = rtwdf, itwdf_ = itwdf;
              for (var j = 0;j < s; j++) {
                var re = rtws[p + j], ie = itws[p + j], ro = rtws[p + j + s], io = itws[p + j + s], rx = rtwdf_ * ro - itwdf_ * io;
                if (io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p + j] = re + ro, itws[p + j] = ie + io, rtws[p + j + s] = re - ro, itws[p + j + s] = ie - io, j !== l)
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx;
              }
            }
          }
        }, FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1, odd = N & 1, i2 = 0;
          for (N = N / 2 | 0;N; N = N >>> 1)
            i2++;
          return 1 << i2 + 1 + odd;
        }, FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i2 = 0;i2 < N / 2; i2++) {
            var t = rws[i2];
            rws[i2] = rws[N - i2 - 1], rws[N - i2 - 1] = t, t = iws[i2], iws[i2] = -iws[N - i2 - 1], iws[N - i2 - 1] = -t;
          }
        }, FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i2 = 0;i2 < N / 2; i2++) {
            var w = Math.round(ws[2 * i2 + 1] / N) * 8192 + Math.round(ws[2 * i2] / N) + carry;
            if (ws[i2] = w & 67108863, w < 67108864)
              carry = 0;
            else
              carry = w / 67108864 | 0;
          }
          return ws;
        }, FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N) {
          var carry = 0;
          for (var i2 = 0;i2 < len2; i2++)
            carry = carry + (ws[i2] | 0), rws[2 * i2] = carry & 8191, carry = carry >>> 13, rws[2 * i2 + 1] = carry & 8191, carry = carry >>> 13;
          for (i2 = 2 * len2;i2 < N; ++i2)
            rws[i2] = 0;
          assert(carry === 0), assert((carry & -8192) === 0);
        }, FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i2 = 0;i2 < N; i2++)
            ph[i2] = 0;
          return ph;
        }, FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length), rbt = this.makeRBT(N), _ = this.stub(N), rws = new Array(N), rwst = new Array(N), iwst = new Array(N), nrws = new Array(N), nrwst = new Array(N), niwst = new Array(N), rmws = out.words;
          rmws.length = N, this.convert13b(x.words, x.length, rws, N), this.convert13b(y.words, y.length, nrws, N), this.transform(rws, _, rwst, iwst, N, rbt), this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i2 = 0;i2 < N; i2++) {
            var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
            iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2], rwst[i2] = rx;
          }
          return this.conjugate(rwst, iwst, N), this.transform(rwst, iwst, rmws, _, N, rbt), this.conjugate(rmws, _, N), this.normalize13b(rmws, N), out.negative = x.negative ^ y.negative, out.length = x.length + y.length, out.strip();
        }, BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          return out.words = new Array(this.length + num.length), this.mulTo(num, out);
        }, BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);
        }, BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        }, BN.prototype.imuln = function imuln(num) {
          assert(typeof num === "number"), assert(num < 67108864);
          var carry = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var w = (this.words[i2] | 0) * num, lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i2] = lo & 67108863;
          }
          if (carry !== 0)
            this.words[i2] = carry, this.length++;
          return this.length = num === 0 ? 1 : this.length, this;
        }, BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        }, BN.prototype.sqr = function sqr() {
          return this.mul(this);
        }, BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        }, BN.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN(1);
          var res = this;
          for (var i2 = 0;i2 < w.length; i2++, res = res.sqr())
            if (w[i2] !== 0)
              break;
          if (++i2 < w.length)
            for (var q = res.sqr();i2 < w.length; i2++, q = q.sqr()) {
              if (w[i2] === 0)
                continue;
              res = res.mul(q);
            }
          return res;
        }, BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26, s = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r, i2;
          if (r !== 0) {
            var carry = 0;
            for (i2 = 0;i2 < this.length; i2++) {
              var newCarry = this.words[i2] & carryMask, c = (this.words[i2] | 0) - newCarry << r;
              this.words[i2] = c | carry, carry = newCarry >>> 26 - r;
            }
            if (carry)
              this.words[i2] = carry, this.length++;
          }
          if (s !== 0) {
            for (i2 = this.length - 1;i2 >= 0; i2--)
              this.words[i2 + s] = this.words[i2];
            for (i2 = 0;i2 < s; i2++)
              this.words[i2] = 0;
            this.length += s;
          }
          return this.strip();
        }, BN.prototype.ishln = function ishln(bits) {
          return assert(this.negative === 0), this.iushln(bits);
        }, BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint)
            h = (hint - hint % 26) / 26;
          else
            h = 0;
          var r = bits % 26, s = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;
          if (h -= s, h = Math.max(0, h), maskedWords) {
            for (var i2 = 0;i2 < s; i2++)
              maskedWords.words[i2] = this.words[i2];
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i2 = 0;i2 < this.length; i2++)
              this.words[i2] = this.words[i2 + s];
          } else
            this.words[0] = 0, this.length = 1;
          var carry = 0;
          for (i2 = this.length - 1;i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
            var word = this.words[i2] | 0;
            this.words[i2] = carry << 26 - r | word >>> r, carry = word & mask;
          }
          if (maskedWords && carry !== 0)
            maskedWords.words[maskedWords.length++] = carry;
          if (this.length === 0)
            this.words[0] = 0, this.length = 1;
          return this.strip();
        }, BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          return assert(this.negative === 0), this.iushrn(bits, hint, extended);
        }, BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        }, BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        }, BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        }, BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        }, BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        }, BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26, s = (bits - r) / 26;
          if (assert(this.negative === 0, "imaskn works only with positive numbers"), this.length <= s)
            return this;
          if (r !== 0)
            s++;
          if (this.length = Math.min(s, this.length), r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        }, BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        }, BN.prototype.iaddn = function iaddn(num) {
          if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num)
              return this.words[0] = num - (this.words[0] | 0), this.negative = 0, this;
            return this.negative = 0, this.isubn(num), this.negative = 1, this;
          }
          return this._iaddn(num);
        }, BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i2 = 0;i2 < this.length && this.words[i2] >= 67108864; i2++)
            if (this.words[i2] -= 67108864, i2 === this.length - 1)
              this.words[i2 + 1] = 1;
            else
              this.words[i2 + 1]++;
          return this.length = Math.max(this.length, i2 + 1), this;
        }, BN.prototype.isubn = function isubn(num) {
          if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0)
            return this.negative = 0, this.iaddn(num), this.negative = 1, this;
          if (this.words[0] -= num, this.length === 1 && this.words[0] < 0)
            this.words[0] = -this.words[0], this.negative = 1;
          else
            for (var i2 = 0;i2 < this.length && this.words[i2] < 0; i2++)
              this.words[i2] += 67108864, this.words[i2 + 1] -= 1;
          return this.strip();
        }, BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        }, BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        }, BN.prototype.iabs = function iabs() {
          return this.negative = 0, this;
        }, BN.prototype.abs = function abs() {
          return this.clone().iabs();
        }, BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift2) {
          var len2 = num.length + shift2, i2;
          this._expand(len2);
          var w, carry = 0;
          for (i2 = 0;i2 < num.length; i2++) {
            w = (this.words[i2 + shift2] | 0) + carry;
            var right3 = (num.words[i2] | 0) * mul;
            w -= right3 & 67108863, carry = (w >> 26) - (right3 / 67108864 | 0), this.words[i2 + shift2] = w & 67108863;
          }
          for (;i2 < this.length - shift2; i2++)
            w = (this.words[i2 + shift2] | 0) + carry, carry = w >> 26, this.words[i2 + shift2] = w & 67108863;
          if (carry === 0)
            return this.strip();
          assert(carry === -1), carry = 0;
          for (i2 = 0;i2 < this.length; i2++)
            w = -(this.words[i2] | 0) + carry, carry = w >> 26, this.words[i2] = w & 67108863;
          return this.negative = 1, this.strip();
        }, BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift2 = this.length - num.length, a = this.clone(), b = num, bhi = b.words[b.length - 1] | 0, bhiBits = this._countBits(bhi);
          if (shift2 = 26 - bhiBits, shift2 !== 0)
            b = b.ushln(shift2), a.iushln(shift2), bhi = b.words[b.length - 1] | 0;
          var m = a.length - b.length, q;
          if (mode !== "mod") {
            q = new BN(null), q.length = m + 1, q.words = new Array(q.length);
            for (var i2 = 0;i2 < q.length; i2++)
              q.words[i2] = 0;
          }
          var diff8 = a.clone()._ishlnsubmul(b, 1, m);
          if (diff8.negative === 0) {
            if (a = diff8, q)
              q.words[m] = 1;
          }
          for (var j = m - 1;j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0)
              if (qj--, a.negative = 0, a._ishlnsubmul(b, 1, j), !a.isZero())
                a.negative ^= 1;
            if (q)
              q.words[j] = qj;
          }
          if (q)
            q.strip();
          if (a.strip(), mode !== "div" && shift2 !== 0)
            a.iushrn(shift2);
          return { div: q || null, mod: a };
        }, BN.prototype.divmod = function divmod(num, mode, positive2) {
          if (assert(!num.isZero()), this.isZero())
            return { div: new BN(0), mod: new BN(0) };
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            if (res = this.neg().divmod(num, mode), mode !== "mod")
              div = res.div.neg();
            if (mode !== "div") {
              if (mod = res.mod.neg(), positive2 && mod.negative !== 0)
                mod.iadd(num);
            }
            return { div, mod };
          }
          if (this.negative === 0 && num.negative !== 0) {
            if (res = this.divmod(num.neg(), mode), mode !== "mod")
              div = res.div.neg();
            return { div, mod: res.mod };
          }
          if ((this.negative & num.negative) !== 0) {
            if (res = this.neg().divmod(num.neg(), mode), mode !== "div") {
              if (mod = res.mod.neg(), positive2 && mod.negative !== 0)
                mod.isub(num);
            }
            return { div: res.div, mod };
          }
          if (num.length > this.length || this.cmp(num) < 0)
            return { div: new BN(0), mod: this };
          if (num.length === 1) {
            if (mode === "div")
              return { div: this.divn(num.words[0]), mod: null };
            if (mode === "mod")
              return { div: null, mod: new BN(this.modn(num.words[0])) };
            return { div: this.divn(num.words[0]), mod: new BN(this.modn(num.words[0])) };
          }
          return this._wordDiv(num, mode);
        }, BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        }, BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        }, BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        }, BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        }, BN.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = 67108864 % num, acc = 0;
          for (var i2 = this.length - 1;i2 >= 0; i2--)
            acc = (p * acc + (this.words[i2] | 0)) % num;
          return acc;
        }, BN.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i2 = this.length - 1;i2 >= 0; i2--) {
            var w = (this.words[i2] | 0) + carry * 67108864;
            this.words[i2] = w / num | 0, carry = w % num;
          }
          return this.strip();
        }, BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        }, BN.prototype.egcd = function egcd(p) {
          assert(p.negative === 0), assert(!p.isZero());
          var x = this, y = p.clone();
          if (x.negative !== 0)
            x = x.umod(p);
          else
            x = x.clone();
          var A = new BN(1), B = new BN(0), C = new BN(0), D = new BN(1), g = 0;
          while (x.isEven() && y.isEven())
            x.iushrn(1), y.iushrn(1), ++g;
          var yp = y.clone(), xp = x.clone();
          while (!x.isZero()) {
            for (var i2 = 0, im = 1;(x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
              ;
            if (i2 > 0) {
              x.iushrn(i2);
              while (i2-- > 0) {
                if (A.isOdd() || B.isOdd())
                  A.iadd(yp), B.isub(xp);
                A.iushrn(1), B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd())
                  C.iadd(yp), D.isub(xp);
                C.iushrn(1), D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0)
              x.isub(y), A.isub(C), B.isub(D);
            else
              y.isub(x), C.isub(A), D.isub(B);
          }
          return { a: C, b: D, gcd: y.iushln(g) };
        }, BN.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0), assert(!p.isZero());
          var a = this, b = p.clone();
          if (a.negative !== 0)
            a = a.umod(p);
          else
            a = a.clone();
          var x1 = new BN(1), x2 = new BN(0), delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i2 = 0, im = 1;(a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
              ;
            if (i2 > 0) {
              a.iushrn(i2);
              while (i2-- > 0) {
                if (x1.isOdd())
                  x1.iadd(delta);
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1;(b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd())
                  x2.iadd(delta);
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0)
              a.isub(b), x1.isub(x2);
            else
              b.isub(a), x2.isub(x1);
          }
          var res;
          if (a.cmpn(1) === 0)
            res = x1;
          else
            res = x2;
          if (res.cmpn(0) < 0)
            res.iadd(p);
          return res;
        }, BN.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone(), b = num.clone();
          a.negative = 0, b.negative = 0;
          for (var shift2 = 0;a.isEven() && b.isEven(); shift2++)
            a.iushrn(1), b.iushrn(1);
          do {
            while (a.isEven())
              a.iushrn(1);
            while (b.isEven())
              b.iushrn(1);
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b, b = t;
            } else if (r === 0 || b.cmpn(1) === 0)
              break;
            a.isub(b);
          } while (true);
          return b.iushln(shift2);
        }, BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        }, BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        }, BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        }, BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        }, BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
          if (this.length <= s)
            return this._expand(s + 1), this.words[s] |= q, this;
          var carry = q;
          for (var i2 = s;carry !== 0 && i2 < this.length; i2++) {
            var w = this.words[i2] | 0;
            w += carry, carry = w >>> 26, w &= 67108863, this.words[i2] = w;
          }
          if (carry !== 0)
            this.words[i2] = carry, this.length++;
          return this;
        }, BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        }, BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1)
            res = 1;
          else {
            if (negative)
              num = -num;
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        }, BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        }, BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i2 = this.length - 1;i2 >= 0; i2--) {
            var a = this.words[i2] | 0, b = num.words[i2] | 0;
            if (a === b)
              continue;
            if (a < b)
              res = -1;
            else if (a > b)
              res = 1;
            break;
          }
          return res;
        }, BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        }, BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        }, BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        }, BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        }, BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        }, BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        }, BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        }, BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        }, BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        }, BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        }, BN.red = function red(num) {
          return new Red(num);
        }, BN.prototype.toRed = function toRed(ctx) {
          return assert(!this.red, "Already a number in reduction context"), assert(this.negative === 0, "red works only with positives"), ctx.convertTo(this)._forceRed(ctx);
        }, BN.prototype.fromRed = function fromRed() {
          return assert(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
        }, BN.prototype._forceRed = function _forceRed(ctx) {
          return this.red = ctx, this;
        }, BN.prototype.forceRed = function forceRed(ctx) {
          return assert(!this.red, "Already a number in reduction context"), this._forceRed(ctx);
        }, BN.prototype.redAdd = function redAdd(num) {
          return assert(this.red, "redAdd works only with red numbers"), this.red.add(this, num);
        }, BN.prototype.redIAdd = function redIAdd(num) {
          return assert(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, num);
        }, BN.prototype.redSub = function redSub(num) {
          return assert(this.red, "redSub works only with red numbers"), this.red.sub(this, num);
        }, BN.prototype.redISub = function redISub(num) {
          return assert(this.red, "redISub works only with red numbers"), this.red.isub(this, num);
        }, BN.prototype.redShl = function redShl(num) {
          return assert(this.red, "redShl works only with red numbers"), this.red.shl(this, num);
        }, BN.prototype.redMul = function redMul(num) {
          return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.mul(this, num);
        }, BN.prototype.redIMul = function redIMul(num) {
          return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.imul(this, num);
        }, BN.prototype.redSqr = function redSqr() {
          return assert(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
        }, BN.prototype.redISqr = function redISqr() {
          return assert(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
        }, BN.prototype.redSqrt = function redSqrt() {
          return assert(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
        }, BN.prototype.redInvm = function redInvm() {
          return assert(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
        }, BN.prototype.redNeg = function redNeg() {
          return assert(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
        }, BN.prototype.redPow = function redPow(num) {
          return assert(this.red && !num.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, num);
        };
        var primes = { k256: null, p224: null, p192: null, p25519: null };
        function MPrime(name, p) {
          this.name = name, this.p = new BN(p, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;
        }, MPrime.prototype.ireduce = function ireduce(num) {
          var r = num, rlen;
          do
            this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), rlen = r.bitLength();
          while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0)
            r.words[0] = 0, r.length = 1;
          else if (cmp > 0)
            r.isub(this.p);
          else if (r.strip !== undefined)
            r.strip();
          else
            r._strip();
          return r;
        }, MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        }, MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        inherits2(K256, MPrime), K256.prototype.split = function split(input, output) {
          var mask = 4194303, outLen = Math.min(input.length, 9);
          for (var i2 = 0;i2 < outLen; i2++)
            output.words[i2] = input.words[i2];
          if (output.length = outLen, input.length <= 9) {
            input.words[0] = 0, input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i2 = 10;i2 < input.length; i2++) {
            var next = input.words[i2] | 0;
            input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22, prev = next;
          }
          if (prev >>>= 22, input.words[i2 - 10] = prev, prev === 0 && input.length > 10)
            input.length -= 10;
          else
            input.length -= 9;
        }, K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;
          var lo = 0;
          for (var i2 = 0;i2 < num.length; i2++) {
            var w = num.words[i2] | 0;
            lo += w * 977, num.words[i2] = lo & 67108863, lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            if (num.length--, num.words[num.length - 1] === 0)
              num.length--;
          }
          return num;
        };
        function P224() {
          MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        inherits2(P224, MPrime);
        function P192() {
          MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        inherits2(P192, MPrime);
        function P25519() {
          MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        inherits2(P25519, MPrime), P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i2 = 0;i2 < num.length; i2++) {
            var hi = (num.words[i2] | 0) * 19 + carry, lo = hi & 67108863;
            hi >>>= 26, num.words[i2] = lo, carry = hi;
          }
          if (carry !== 0)
            num.words[num.length++] = carry;
          return num;
        }, BN._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime;
          if (name === "k256")
            prime = new K256;
          else if (name === "p224")
            prime = new P224;
          else if (name === "p192")
            prime = new P192;
          else if (name === "p25519")
            prime = new P25519;
          else
            throw new Error("Unknown prime " + name);
          return primes[name] = prime, prime;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p, this.prime = prime;
          } else
            assert(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives"), assert(a.red, "red works only with red numbers");
        }, Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives"), assert(a.red && a.red === b.red, "red works only with red numbers");
        }, Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        }, Red.prototype.neg = function neg(a) {
          if (a.isZero())
            return a.clone();
          return this.m.sub(a)._forceRed(this);
        }, Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0)
            res.isub(this.m);
          return res._forceRed(this);
        }, Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0)
            res.isub(this.m);
          return res;
        }, Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0)
            res.iadd(this.m);
          return res._forceRed(this);
        }, Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0)
            res.iadd(this.m);
          return res;
        }, Red.prototype.shl = function shl(a, num) {
          return this._verify1(a), this.imod(a.ushln(num));
        }, Red.prototype.imul = function imul(a, b) {
          return this._verify2(a, b), this.imod(a.imul(b));
        }, Red.prototype.mul = function mul(a, b) {
          return this._verify2(a, b), this.imod(a.mul(b));
        }, Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        }, Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        }, Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          if (assert(mod3 % 2 === 1), mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1), s = 0;
          while (!q.isZero() && q.andln(1) === 0)
            s++, q.iushrn(1);
          assert(!q.isZero());
          var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0)
            z.redIAdd(nOne);
          var c = this.pow(z, q), r = this.pow(a, q.addn(1).iushrn(1)), t = this.pow(a, q), m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i2 = 0;tmp.cmp(one) !== 0; i2++)
              tmp = tmp.redSqr();
            assert(i2 < m);
            var b = this.pow(c, new BN(1).iushln(m - i2 - 1));
            r = r.redMul(b), c = b.redSqr(), t = t.redMul(c), m = i2;
          }
          return r;
        }, Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0)
            return inv.negative = 0, this.imod(inv).redNeg();
          else
            return this.imod(inv);
        }, Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4, wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this), wnd[1] = a;
          for (var i2 = 2;i2 < wnd.length; i2++)
            wnd[i2] = this.mul(wnd[i2 - 1], a);
          var res = wnd[0], current2 = 0, currentLen = 0, start4 = num.bitLength() % 26;
          if (start4 === 0)
            start4 = 26;
          for (i2 = num.length - 1;i2 >= 0; i2--) {
            var word = num.words[i2];
            for (var j = start4 - 1;j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0])
                res = this.sqr(res);
              if (bit === 0 && current2 === 0) {
                currentLen = 0;
                continue;
              }
              if (current2 <<= 1, current2 |= bit, currentLen++, currentLen !== windowSize && (i2 !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current2]), currentLen = 0, current2 = 0;
            }
            start4 = 26;
          }
          return res;
        }, Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        }, Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          return res.red = null, res;
        }, BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          if (Red.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 !== 0)
            this.shift += 26 - this.shift % 26;
          this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
        }
        inherits2(Mont, Red), Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        }, Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          return r.red = null, r;
        }, Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero())
            return a.words[0] = 0, a.length = 1, a;
          var t = a.imul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;
          if (u.cmp(this.m) >= 0)
            res = u.isub(this.m);
          else if (u.cmpn(0) < 0)
            res = u.iadd(this.m);
          return res._forceRed(this);
        }, Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN(0)._forceRed(this);
          var t = a.mul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;
          if (u.cmp(this.m) >= 0)
            res = u.isub(this.m);
          else if (u.cmpn(0) < 0)
            res = u.iadd(this.m);
          return res._forceRed(this);
        }, Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    });
    require_browser = __commonJS2((exports, module) => {
      var elliptic = require_elliptic(), BN = require_bn2();
      module.exports = function createECDH(curve) {
        return new ECDH(curve);
      };
      var aliases = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
      aliases.p224 = aliases.secp224r1;
      aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
      aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
      aliases.p384 = aliases.secp384r1;
      aliases.p521 = aliases.secp521r1;
      function ECDH(curve) {
        if (this.curveType = aliases[curve], !this.curveType)
          this.curveType = { name: curve };
        this.curve = new elliptic.ec(this.curveType.name), this.keys = undefined;
      }
      ECDH.prototype.generateKeys = function(enc, format7) {
        return this.keys = this.curve.genKeyPair(), this.getPublicKey(enc, format7);
      };
      ECDH.prototype.computeSecret = function(other, inenc, enc) {
        if (inenc = inenc || "utf8", !Buffer.isBuffer(other))
          other = new Buffer(other, inenc);
        var otherPub = this.curve.keyFromPublic(other).getPublic(), out = otherPub.mul(this.keys.getPrivate()).getX();
        return formatReturnValue(out, enc, this.curveType.byteLength);
      };
      ECDH.prototype.getPublicKey = function(enc, format7) {
        var key = this.keys.getPublic(format7 === "compressed", true);
        if (format7 === "hybrid")
          if (key[key.length - 1] % 2)
            key[0] = 7;
          else
            key[0] = 6;
        return formatReturnValue(key, enc);
      };
      ECDH.prototype.getPrivateKey = function(enc) {
        return formatReturnValue(this.keys.getPrivate(), enc);
      };
      ECDH.prototype.setPublicKey = function(pub, enc) {
        if (enc = enc || "utf8", !Buffer.isBuffer(pub))
          pub = new Buffer(pub, enc);
        return this.keys._importPublic(pub), this;
      };
      ECDH.prototype.setPrivateKey = function(priv, enc) {
        if (enc = enc || "utf8", !Buffer.isBuffer(priv))
          priv = new Buffer(priv, enc);
        var _priv = new BN(priv);
        return _priv = _priv.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(_priv), this;
      };
      function formatReturnValue(bn, enc, len2) {
        if (!Array.isArray(bn))
          bn = bn.toArray();
        var buf = new Buffer(bn);
        if (len2 && buf.length < len2) {
          var zeros = new Buffer(len2 - buf.length);
          zeros.fill(0), buf = Buffer.concat([zeros, buf]);
        }
        if (!enc)
          return buf;
        else
          return buf.toString(enc);
      }
    });
    require_create_ecdh = __commonJS2((exports, module) => {
      var createECDH = (init_crypto(), __toCommonJS(exports_crypto)).createECDH;
      module.exports = createECDH || require_browser();
    });
    require_bn3 = __commonJS2((exports, module) => {
      (function(module2, exports2) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {};
          TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
        }
        function BN(number4, base, endian) {
          if (BN.isBN(number4))
            return number4;
          if (this.negative = 0, this.words = null, this.length = 0, this.red = null, number4 !== null) {
            if (base === "le" || base === "be")
              endian = base, base = 10;
            this._init(number4 || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object")
          module2.exports = BN;
        else
          exports2.BN = BN;
        BN.BN = BN, BN.wordSize = 26;
        var Buffer22;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined")
            Buffer22 = window.Buffer;
          else
            Buffer22 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
        } catch (e) {}
        BN.isBN = function isBN(num) {
          if (num instanceof BN)
            return true;
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        }, BN.max = function max(left3, right3) {
          if (left3.cmp(right3) > 0)
            return left3;
          return right3;
        }, BN.min = function min(left3, right3) {
          if (left3.cmp(right3) < 0)
            return left3;
          return right3;
        }, BN.prototype._init = function init(number4, base, endian) {
          if (typeof number4 === "number")
            return this._initNumber(number4, base, endian);
          if (typeof number4 === "object")
            return this._initArray(number4, base, endian);
          if (base === "hex")
            base = 16;
          assert(base === (base | 0) && base >= 2 && base <= 36), number4 = number4.toString().replace(/\s+/g, "");
          var start4 = 0;
          if (number4[0] === "-")
            start4++, this.negative = 1;
          if (start4 < number4.length) {
            if (base === 16)
              this._parseHex(number4, start4, endian);
            else if (this._parseBase(number4, base, start4), endian === "le")
              this._initArray(this.toArray(), base, endian);
          }
        }, BN.prototype._initNumber = function _initNumber(number4, base, endian) {
          if (number4 < 0)
            this.negative = 1, number4 = -number4;
          if (number4 < 67108864)
            this.words = [number4 & 67108863], this.length = 1;
          else if (number4 < 4503599627370496)
            this.words = [number4 & 67108863, number4 / 67108864 & 67108863], this.length = 2;
          else
            assert(number4 < 9007199254740992), this.words = [number4 & 67108863, number4 / 67108864 & 67108863, 1], this.length = 3;
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        }, BN.prototype._initArray = function _initArray(number4, base, endian) {
          if (assert(typeof number4.length === "number"), number4.length <= 0)
            return this.words = [0], this.length = 1, this;
          this.length = Math.ceil(number4.length / 3), this.words = new Array(this.length);
          for (var i2 = 0;i2 < this.length; i2++)
            this.words[i2] = 0;
          var j, w, off = 0;
          if (endian === "be") {
            for (i2 = number4.length - 1, j = 0;i2 >= 0; i2 -= 3)
              if (w = number4[i2] | number4[i2 - 1] << 8 | number4[i2 - 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
                off -= 26, j++;
          } else if (endian === "le") {
            for (i2 = 0, j = 0;i2 < number4.length; i2 += 3)
              if (w = number4[i2] | number4[i2 + 1] << 8 | number4[i2 + 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
                off -= 26, j++;
          }
          return this.strip();
        };
        function parseHex4Bits(string3, index) {
          var c = string3.charCodeAt(index);
          if (c >= 65 && c <= 70)
            return c - 55;
          else if (c >= 97 && c <= 102)
            return c - 87;
          else
            return c - 48 & 15;
        }
        function parseHexByte(string3, lowerBound, index) {
          var r = parseHex4Bits(string3, index);
          if (index - 1 >= lowerBound)
            r |= parseHex4Bits(string3, index - 1) << 4;
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number4, start4, endian) {
          this.length = Math.ceil((number4.length - start4) / 6), this.words = new Array(this.length);
          for (var i2 = 0;i2 < this.length; i2++)
            this.words[i2] = 0;
          var off = 0, j = 0, w;
          if (endian === "be")
            for (i2 = number4.length - 1;i2 >= start4; i2 -= 2)
              if (w = parseHexByte(number4, start4, i2) << off, this.words[j] |= w & 67108863, off >= 18)
                off -= 18, j += 1, this.words[j] |= w >>> 26;
              else
                off += 8;
          else {
            var parseLength = number4.length - start4;
            for (i2 = parseLength % 2 === 0 ? start4 + 1 : start4;i2 < number4.length; i2 += 2)
              if (w = parseHexByte(number4, start4, i2) << off, this.words[j] |= w & 67108863, off >= 18)
                off -= 18, j += 1, this.words[j] |= w >>> 26;
              else
                off += 8;
          }
          this.strip();
        };
        function parseBase(str, start4, end6, mul) {
          var r = 0, len2 = Math.min(str.length, end6);
          for (var i2 = start4;i2 < len2; i2++) {
            var c = str.charCodeAt(i2) - 48;
            if (r *= mul, c >= 49)
              r += c - 49 + 10;
            else if (c >= 17)
              r += c - 17 + 10;
            else
              r += c;
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number4, base, start4) {
          this.words = [0], this.length = 1;
          for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base)
            limbLen++;
          limbLen--, limbPow = limbPow / base | 0;
          var total = number4.length - start4, mod = total % limbLen, end6 = Math.min(total, total - mod) + start4, word = 0;
          for (var i2 = start4;i2 < end6; i2 += limbLen)
            if (word = parseBase(number4, i2, i2 + limbLen, base), this.imuln(limbPow), this.words[0] + word < 67108864)
              this.words[0] += word;
            else
              this._iaddn(word);
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number4, i2, number4.length, base);
            for (i2 = 0;i2 < mod; i2++)
              pow *= base;
            if (this.imuln(pow), this.words[0] + word < 67108864)
              this.words[0] += word;
            else
              this._iaddn(word);
          }
          this.strip();
        }, BN.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i2 = 0;i2 < this.length; i2++)
            dest.words[i2] = this.words[i2];
          dest.length = this.length, dest.negative = this.negative, dest.red = this.red;
        }, BN.prototype.clone = function clone() {
          var r = new BN(null);
          return this.copy(r), r;
        }, BN.prototype._expand = function _expand(size13) {
          while (this.length < size13)
            this.words[this.length++] = 0;
          return this;
        }, BN.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0)
            this.length--;
          return this._normSign();
        }, BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0)
            this.negative = 0;
          return this;
        }, BN.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        if (BN.prototype.toString = function toString(base, padding) {
          base = base || 10, padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0, carry = 0;
            for (var i2 = 0;i2 < this.length; i2++) {
              var w = this.words[i2], word = ((w << off | carry) & 16777215).toString(16);
              if (carry = w >>> 24 - off & 16777215, off += 2, off >= 26)
                off -= 26, i2--;
              if (carry !== 0 || i2 !== this.length - 1)
                out = zeros[6 - word.length] + word + out;
              else
                out = word + out;
            }
            if (carry !== 0)
              out = carry.toString(16) + out;
            while (out.length % padding !== 0)
              out = "0" + out;
            if (this.negative !== 0)
              out = "-" + out;
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base], groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modn(groupBase).toString(base);
              if (c = c.idivn(groupBase), !c.isZero())
                out = zeros[groupSize - r.length] + r + out;
              else
                out = r + out;
            }
            if (this.isZero())
              out = "0" + out;
            while (out.length % padding !== 0)
              out = "0" + out;
            if (this.negative !== 0)
              out = "-" + out;
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        }, BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2)
            ret += this.words[1] * 67108864;
          else if (this.length === 3 && this.words[2] === 1)
            ret += 4503599627370496 + this.words[1] * 67108864;
          else if (this.length > 2)
            assert(false, "Number can only safely store up to 53 bits");
          return this.negative !== 0 ? -ret : ret;
        }, BN.prototype.toJSON = function toJSON() {
          return this.toString(16);
        }, BN.prototype.toBuffer = function toBuffer(endian, length3) {
          return assert(typeof Buffer22 !== "undefined"), this.toArrayLike(Buffer22, endian, length3);
        }, BN.prototype.toArray = function toArray(endian, length3) {
          return this.toArrayLike(Array, endian, length3);
        }, BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length3) {
          var byteLength2 = this.byteLength(), reqLength = length3 || Math.max(1, byteLength2);
          assert(byteLength2 <= reqLength, "byte array longer than desired length"), assert(reqLength > 0, "Requested array length <= 0"), this.strip();
          var littleEndian = endian === "le", res = new ArrayType(reqLength), b, i2, q = this.clone();
          if (!littleEndian) {
            for (i2 = 0;i2 < reqLength - byteLength2; i2++)
              res[i2] = 0;
            for (i2 = 0;!q.isZero(); i2++)
              b = q.andln(255), q.iushrn(8), res[reqLength - i2 - 1] = b;
          } else {
            for (i2 = 0;!q.isZero(); i2++)
              b = q.andln(255), q.iushrn(8), res[i2] = b;
            for (;i2 < reqLength; i2++)
              res[i2] = 0;
          }
          return res;
        }, Math.clz32)
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        else
          BN.prototype._countBits = function _countBits(w) {
            var t = w, r = 0;
            if (t >= 4096)
              r += 13, t >>>= 13;
            if (t >= 64)
              r += 7, t >>>= 7;
            if (t >= 8)
              r += 4, t >>>= 4;
            if (t >= 2)
              r += 2, t >>>= 2;
            return r + t;
          };
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w, r = 0;
          if ((t & 8191) === 0)
            r += 13, t >>>= 13;
          if ((t & 127) === 0)
            r += 7, t >>>= 7;
          if ((t & 15) === 0)
            r += 4, t >>>= 4;
          if ((t & 3) === 0)
            r += 2, t >>>= 2;
          if ((t & 1) === 0)
            r++;
          return r;
        }, BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1], hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0;bit < w.length; bit++) {
            var off = bit / 26 | 0, wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var b = this._zeroBits(this.words[i2]);
            if (r += b, b !== 26)
              break;
          }
          return r;
        }, BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        }, BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0)
            return this.abs().inotn(width).iaddn(1);
          return this.clone();
        }, BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1))
            return this.notn(width).iaddn(1).ineg();
          return this.clone();
        }, BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        }, BN.prototype.neg = function neg() {
          return this.clone().ineg();
        }, BN.prototype.ineg = function ineg() {
          if (!this.isZero())
            this.negative ^= 1;
          return this;
        }, BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length)
            this.words[this.length++] = 0;
          for (var i2 = 0;i2 < num.length; i2++)
            this.words[i2] = this.words[i2] | num.words[i2];
          return this.strip();
        }, BN.prototype.ior = function ior(num) {
          return assert((this.negative | num.negative) === 0), this.iuor(num);
        }, BN.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        }, BN.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        }, BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length)
            b = num;
          else
            b = this;
          for (var i2 = 0;i2 < b.length; i2++)
            this.words[i2] = this.words[i2] & num.words[i2];
          return this.length = b.length, this.strip();
        }, BN.prototype.iand = function iand(num) {
          return assert((this.negative | num.negative) === 0), this.iuand(num);
        }, BN.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        }, BN.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        }, BN.prototype.iuxor = function iuxor(num) {
          var a, b;
          if (this.length > num.length)
            a = this, b = num;
          else
            a = num, b = this;
          for (var i2 = 0;i2 < b.length; i2++)
            this.words[i2] = a.words[i2] ^ b.words[i2];
          if (this !== a)
            for (;i2 < a.length; i2++)
              this.words[i2] = a.words[i2];
          return this.length = a.length, this.strip();
        }, BN.prototype.ixor = function ixor(num) {
          return assert((this.negative | num.negative) === 0), this.iuxor(num);
        }, BN.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        }, BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        }, BN.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0, bitsLeft = width % 26;
          if (this._expand(bytesNeeded), bitsLeft > 0)
            bytesNeeded--;
          for (var i2 = 0;i2 < bytesNeeded; i2++)
            this.words[i2] = ~this.words[i2] & 67108863;
          if (bitsLeft > 0)
            this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
          return this.strip();
        }, BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        }, BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0, wbit = bit % 26;
          if (this._expand(off + 1), val)
            this.words[off] = this.words[off] | 1 << wbit;
          else
            this.words[off] = this.words[off] & ~(1 << wbit);
          return this.strip();
        }, BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0)
            return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();
          else if (this.negative === 0 && num.negative !== 0)
            return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();
          var a, b;
          if (this.length > num.length)
            a = this, b = num;
          else
            a = num, b = this;
          var carry = 0;
          for (var i2 = 0;i2 < b.length; i2++)
            r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
          for (;carry !== 0 && i2 < a.length; i2++)
            r = (a.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
          if (this.length = a.length, carry !== 0)
            this.words[this.length] = carry, this.length++;
          else if (a !== this)
            for (;i2 < a.length; i2++)
              this.words[i2] = a.words[i2];
          return this;
        }, BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0)
            return num.negative = 0, res = this.sub(num), num.negative ^= 1, res;
          else if (num.negative === 0 && this.negative !== 0)
            return this.negative = 0, res = num.sub(this), this.negative = 1, res;
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        }, BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            return num.negative = 1, r._normSign();
          } else if (this.negative !== 0)
            return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();
          var cmp = this.cmp(num);
          if (cmp === 0)
            return this.negative = 0, this.length = 1, this.words[0] = 0, this;
          var a, b;
          if (cmp > 0)
            a = this, b = num;
          else
            a = num, b = this;
          var carry = 0;
          for (var i2 = 0;i2 < b.length; i2++)
            r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
          for (;carry !== 0 && i2 < a.length; i2++)
            r = (a.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
          if (carry === 0 && i2 < a.length && a !== this)
            for (;i2 < a.length; i2++)
              this.words[i2] = a.words[i2];
          if (this.length = Math.max(this.length, i2), a !== this)
            this.negative = 1;
          return this.strip();
        }, BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len2 = self2.length + num.length | 0;
          out.length = len2, len2 = len2 - 1 | 0;
          var a = self2.words[0] | 0, b = num.words[0] | 0, r = a * b, lo = r & 67108863, carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1;k < len2; k++) {
            var ncarry = carry >>> 26, rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
              var i2 = k - j | 0;
              a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b + rword, ncarry += r / 67108864 | 0, rword = r & 67108863;
            }
            out.words[k] = rword | 0, carry = ncarry | 0;
          }
          if (carry !== 0)
            out.words[k] = carry | 0;
          else
            out.length--;
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo(self2, num, out) {
          var a = self2.words, b = num.words, o = out.words, c = 0, lo, mid, hi, a0 = a[0] | 0, al0 = a0 & 8191, ah0 = a0 >>> 13, a1 = a[1] | 0, al1 = a1 & 8191, ah1 = a1 >>> 13, a2 = a[2] | 0, al2 = a2 & 8191, ah2 = a2 >>> 13, a3 = a[3] | 0, al3 = a3 & 8191, ah3 = a3 >>> 13, a4 = a[4] | 0, al4 = a4 & 8191, ah4 = a4 >>> 13, a5 = a[5] | 0, al5 = a5 & 8191, ah5 = a5 >>> 13, a6 = a[6] | 0, al6 = a6 & 8191, ah6 = a6 >>> 13, a7 = a[7] | 0, al7 = a7 & 8191, ah7 = a7 >>> 13, a8 = a[8] | 0, al8 = a8 & 8191, ah8 = a8 >>> 13, a9 = a[9] | 0, al9 = a9 & 8191, ah9 = a9 >>> 13, b0 = b[0] | 0, bl0 = b0 & 8191, bh0 = b0 >>> 13, b1 = b[1] | 0, bl1 = b1 & 8191, bh1 = b1 >>> 13, b2 = b[2] | 0, bl2 = b2 & 8191, bh2 = b2 >>> 13, b3 = b[3] | 0, bl3 = b3 & 8191, bh3 = b3 >>> 13, b4 = b[4] | 0, bl4 = b4 & 8191, bh4 = b4 >>> 13, b5 = b[5] | 0, bl5 = b5 & 8191, bh5 = b5 >>> 13, b6 = b[6] | 0, bl6 = b6 & 8191, bh6 = b6 >>> 13, b7 = b[7] | 0, bl7 = b7 & 8191, bh7 = b7 >>> 13, b8 = b[8] | 0, bl8 = b8 & 8191, bh8 = b8 >>> 13, b9 = b[9] | 0, bl9 = b9 & 8191, bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative, out.length = 19, lo = Math.imul(al0, bl0), mid = Math.imul(al0, bh0), mid = mid + Math.imul(ah0, bl0) | 0, hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, lo = Math.imul(al1, bl0), mid = Math.imul(al1, bh0), mid = mid + Math.imul(ah1, bl0) | 0, hi = Math.imul(ah1, bh0), lo = lo + Math.imul(al0, bl1) | 0, mid = mid + Math.imul(al0, bh1) | 0, mid = mid + Math.imul(ah0, bl1) | 0, hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 67108863, lo = Math.imul(al2, bl0), mid = Math.imul(al2, bh0), mid = mid + Math.imul(ah2, bl0) | 0, hi = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = mid + Math.imul(al1, bh1) | 0, mid = mid + Math.imul(ah1, bl1) | 0, hi = hi + Math.imul(ah1, bh1) | 0, lo = lo + Math.imul(al0, bl2) | 0, mid = mid + Math.imul(al0, bh2) | 0, mid = mid + Math.imul(ah0, bl2) | 0, hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 67108863, lo = Math.imul(al3, bl0), mid = Math.imul(al3, bh0), mid = mid + Math.imul(ah3, bl0) | 0, hi = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = mid + Math.imul(al2, bh1) | 0, mid = mid + Math.imul(ah2, bl1) | 0, hi = hi + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = mid + Math.imul(al1, bh2) | 0, mid = mid + Math.imul(ah1, bl2) | 0, hi = hi + Math.imul(ah1, bh2) | 0, lo = lo + Math.imul(al0, bl3) | 0, mid = mid + Math.imul(al0, bh3) | 0, mid = mid + Math.imul(ah0, bl3) | 0, hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 67108863, lo = Math.imul(al4, bl0), mid = Math.imul(al4, bh0), mid = mid + Math.imul(ah4, bl0) | 0, hi = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = mid + Math.imul(al3, bh1) | 0, mid = mid + Math.imul(ah3, bl1) | 0, hi = hi + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = mid + Math.imul(al2, bh2) | 0, mid = mid + Math.imul(ah2, bl2) | 0, hi = hi + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = mid + Math.imul(al1, bh3) | 0, mid = mid + Math.imul(ah1, bl3) | 0, hi = hi + Math.imul(ah1, bh3) | 0, lo = lo + Math.imul(al0, bl4) | 0, mid = mid + Math.imul(al0, bh4) | 0, mid = mid + Math.imul(ah0, bl4) | 0, hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 67108863, lo = Math.imul(al5, bl0), mid = Math.imul(al5, bh0), mid = mid + Math.imul(ah5, bl0) | 0, hi = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = mid + Math.imul(al4, bh1) | 0, mid = mid + Math.imul(ah4, bl1) | 0, hi = hi + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = mid + Math.imul(al3, bh2) | 0, mid = mid + Math.imul(ah3, bl2) | 0, hi = hi + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = mid + Math.imul(al2, bh3) | 0, mid = mid + Math.imul(ah2, bl3) | 0, hi = hi + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = mid + Math.imul(al1, bh4) | 0, mid = mid + Math.imul(ah1, bl4) | 0, hi = hi + Math.imul(ah1, bh4) | 0, lo = lo + Math.imul(al0, bl5) | 0, mid = mid + Math.imul(al0, bh5) | 0, mid = mid + Math.imul(ah0, bl5) | 0, hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 67108863, lo = Math.imul(al6, bl0), mid = Math.imul(al6, bh0), mid = mid + Math.imul(ah6, bl0) | 0, hi = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = mid + Math.imul(al5, bh1) | 0, mid = mid + Math.imul(ah5, bl1) | 0, hi = hi + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = mid + Math.imul(al4, bh2) | 0, mid = mid + Math.imul(ah4, bl2) | 0, hi = hi + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = mid + Math.imul(al3, bh3) | 0, mid = mid + Math.imul(ah3, bl3) | 0, hi = hi + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = mid + Math.imul(al2, bh4) | 0, mid = mid + Math.imul(ah2, bl4) | 0, hi = hi + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = mid + Math.imul(al1, bh5) | 0, mid = mid + Math.imul(ah1, bl5) | 0, hi = hi + Math.imul(ah1, bh5) | 0, lo = lo + Math.imul(al0, bl6) | 0, mid = mid + Math.imul(al0, bh6) | 0, mid = mid + Math.imul(ah0, bl6) | 0, hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 67108863, lo = Math.imul(al7, bl0), mid = Math.imul(al7, bh0), mid = mid + Math.imul(ah7, bl0) | 0, hi = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = mid + Math.imul(al6, bh1) | 0, mid = mid + Math.imul(ah6, bl1) | 0, hi = hi + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = mid + Math.imul(al5, bh2) | 0, mid = mid + Math.imul(ah5, bl2) | 0, hi = hi + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = mid + Math.imul(al4, bh3) | 0, mid = mid + Math.imul(ah4, bl3) | 0, hi = hi + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = mid + Math.imul(al3, bh4) | 0, mid = mid + Math.imul(ah3, bl4) | 0, hi = hi + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = mid + Math.imul(al2, bh5) | 0, mid = mid + Math.imul(ah2, bl5) | 0, hi = hi + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = mid + Math.imul(al1, bh6) | 0, mid = mid + Math.imul(ah1, bl6) | 0, hi = hi + Math.imul(ah1, bh6) | 0, lo = lo + Math.imul(al0, bl7) | 0, mid = mid + Math.imul(al0, bh7) | 0, mid = mid + Math.imul(ah0, bl7) | 0, hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 67108863, lo = Math.imul(al8, bl0), mid = Math.imul(al8, bh0), mid = mid + Math.imul(ah8, bl0) | 0, hi = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = mid + Math.imul(al7, bh1) | 0, mid = mid + Math.imul(ah7, bl1) | 0, hi = hi + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = mid + Math.imul(al6, bh2) | 0, mid = mid + Math.imul(ah6, bl2) | 0, hi = hi + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = mid + Math.imul(al5, bh3) | 0, mid = mid + Math.imul(ah5, bl3) | 0, hi = hi + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = mid + Math.imul(al4, bh4) | 0, mid = mid + Math.imul(ah4, bl4) | 0, hi = hi + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = mid + Math.imul(al3, bh5) | 0, mid = mid + Math.imul(ah3, bl5) | 0, hi = hi + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = mid + Math.imul(al2, bh6) | 0, mid = mid + Math.imul(ah2, bl6) | 0, hi = hi + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = mid + Math.imul(al1, bh7) | 0, mid = mid + Math.imul(ah1, bl7) | 0, hi = hi + Math.imul(ah1, bh7) | 0, lo = lo + Math.imul(al0, bl8) | 0, mid = mid + Math.imul(al0, bh8) | 0, mid = mid + Math.imul(ah0, bl8) | 0, hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, lo = Math.imul(al9, bl0), mid = Math.imul(al9, bh0), mid = mid + Math.imul(ah9, bl0) | 0, hi = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = mid + Math.imul(al8, bh1) | 0, mid = mid + Math.imul(ah8, bl1) | 0, hi = hi + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = mid + Math.imul(al7, bh2) | 0, mid = mid + Math.imul(ah7, bl2) | 0, hi = hi + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = mid + Math.imul(al6, bh3) | 0, mid = mid + Math.imul(ah6, bl3) | 0, hi = hi + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = mid + Math.imul(al5, bh4) | 0, mid = mid + Math.imul(ah5, bl4) | 0, hi = hi + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = mid + Math.imul(al4, bh5) | 0, mid = mid + Math.imul(ah4, bl5) | 0, hi = hi + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = mid + Math.imul(al3, bh6) | 0, mid = mid + Math.imul(ah3, bl6) | 0, hi = hi + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = mid + Math.imul(al2, bh7) | 0, mid = mid + Math.imul(ah2, bl7) | 0, hi = hi + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = mid + Math.imul(al1, bh8) | 0, mid = mid + Math.imul(ah1, bl8) | 0, hi = hi + Math.imul(ah1, bh8) | 0, lo = lo + Math.imul(al0, bl9) | 0, mid = mid + Math.imul(al0, bh9) | 0, mid = mid + Math.imul(ah0, bl9) | 0, hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 67108863, lo = Math.imul(al9, bl1), mid = Math.imul(al9, bh1), mid = mid + Math.imul(ah9, bl1) | 0, hi = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = mid + Math.imul(al8, bh2) | 0, mid = mid + Math.imul(ah8, bl2) | 0, hi = hi + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = mid + Math.imul(al7, bh3) | 0, mid = mid + Math.imul(ah7, bl3) | 0, hi = hi + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = mid + Math.imul(al6, bh4) | 0, mid = mid + Math.imul(ah6, bl4) | 0, hi = hi + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = mid + Math.imul(al5, bh5) | 0, mid = mid + Math.imul(ah5, bl5) | 0, hi = hi + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = mid + Math.imul(al4, bh6) | 0, mid = mid + Math.imul(ah4, bl6) | 0, hi = hi + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = mid + Math.imul(al3, bh7) | 0, mid = mid + Math.imul(ah3, bl7) | 0, hi = hi + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = mid + Math.imul(al2, bh8) | 0, mid = mid + Math.imul(ah2, bl8) | 0, hi = hi + Math.imul(ah2, bh8) | 0, lo = lo + Math.imul(al1, bl9) | 0, mid = mid + Math.imul(al1, bh9) | 0, mid = mid + Math.imul(ah1, bl9) | 0, hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 67108863, lo = Math.imul(al9, bl2), mid = Math.imul(al9, bh2), mid = mid + Math.imul(ah9, bl2) | 0, hi = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = mid + Math.imul(al8, bh3) | 0, mid = mid + Math.imul(ah8, bl3) | 0, hi = hi + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = mid + Math.imul(al7, bh4) | 0, mid = mid + Math.imul(ah7, bl4) | 0, hi = hi + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = mid + Math.imul(al6, bh5) | 0, mid = mid + Math.imul(ah6, bl5) | 0, hi = hi + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = mid + Math.imul(al5, bh6) | 0, mid = mid + Math.imul(ah5, bl6) | 0, hi = hi + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = mid + Math.imul(al4, bh7) | 0, mid = mid + Math.imul(ah4, bl7) | 0, hi = hi + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = mid + Math.imul(al3, bh8) | 0, mid = mid + Math.imul(ah3, bl8) | 0, hi = hi + Math.imul(ah3, bh8) | 0, lo = lo + Math.imul(al2, bl9) | 0, mid = mid + Math.imul(al2, bh9) | 0, mid = mid + Math.imul(ah2, bl9) | 0, hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 67108863, lo = Math.imul(al9, bl3), mid = Math.imul(al9, bh3), mid = mid + Math.imul(ah9, bl3) | 0, hi = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = mid + Math.imul(al8, bh4) | 0, mid = mid + Math.imul(ah8, bl4) | 0, hi = hi + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = mid + Math.imul(al7, bh5) | 0, mid = mid + Math.imul(ah7, bl5) | 0, hi = hi + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = mid + Math.imul(al6, bh6) | 0, mid = mid + Math.imul(ah6, bl6) | 0, hi = hi + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = mid + Math.imul(al5, bh7) | 0, mid = mid + Math.imul(ah5, bl7) | 0, hi = hi + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = mid + Math.imul(al4, bh8) | 0, mid = mid + Math.imul(ah4, bl8) | 0, hi = hi + Math.imul(ah4, bh8) | 0, lo = lo + Math.imul(al3, bl9) | 0, mid = mid + Math.imul(al3, bh9) | 0, mid = mid + Math.imul(ah3, bl9) | 0, hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 67108863, lo = Math.imul(al9, bl4), mid = Math.imul(al9, bh4), mid = mid + Math.imul(ah9, bl4) | 0, hi = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = mid + Math.imul(al8, bh5) | 0, mid = mid + Math.imul(ah8, bl5) | 0, hi = hi + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = mid + Math.imul(al7, bh6) | 0, mid = mid + Math.imul(ah7, bl6) | 0, hi = hi + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = mid + Math.imul(al6, bh7) | 0, mid = mid + Math.imul(ah6, bl7) | 0, hi = hi + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = mid + Math.imul(al5, bh8) | 0, mid = mid + Math.imul(ah5, bl8) | 0, hi = hi + Math.imul(ah5, bh8) | 0, lo = lo + Math.imul(al4, bl9) | 0, mid = mid + Math.imul(al4, bh9) | 0, mid = mid + Math.imul(ah4, bl9) | 0, hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 67108863, lo = Math.imul(al9, bl5), mid = Math.imul(al9, bh5), mid = mid + Math.imul(ah9, bl5) | 0, hi = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = mid + Math.imul(al8, bh6) | 0, mid = mid + Math.imul(ah8, bl6) | 0, hi = hi + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = mid + Math.imul(al7, bh7) | 0, mid = mid + Math.imul(ah7, bl7) | 0, hi = hi + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = mid + Math.imul(al6, bh8) | 0, mid = mid + Math.imul(ah6, bl8) | 0, hi = hi + Math.imul(ah6, bh8) | 0, lo = lo + Math.imul(al5, bl9) | 0, mid = mid + Math.imul(al5, bh9) | 0, mid = mid + Math.imul(ah5, bl9) | 0, hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 67108863, lo = Math.imul(al9, bl6), mid = Math.imul(al9, bh6), mid = mid + Math.imul(ah9, bl6) | 0, hi = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = mid + Math.imul(al8, bh7) | 0, mid = mid + Math.imul(ah8, bl7) | 0, hi = hi + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = mid + Math.imul(al7, bh8) | 0, mid = mid + Math.imul(ah7, bl8) | 0, hi = hi + Math.imul(ah7, bh8) | 0, lo = lo + Math.imul(al6, bl9) | 0, mid = mid + Math.imul(al6, bh9) | 0, mid = mid + Math.imul(ah6, bl9) | 0, hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 67108863, lo = Math.imul(al9, bl7), mid = Math.imul(al9, bh7), mid = mid + Math.imul(ah9, bl7) | 0, hi = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = mid + Math.imul(al8, bh8) | 0, mid = mid + Math.imul(ah8, bl8) | 0, hi = hi + Math.imul(ah8, bh8) | 0, lo = lo + Math.imul(al7, bl9) | 0, mid = mid + Math.imul(al7, bh9) | 0, mid = mid + Math.imul(ah7, bl9) | 0, hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 67108863, lo = Math.imul(al9, bl8), mid = Math.imul(al9, bh8), mid = mid + Math.imul(ah9, bl8) | 0, hi = Math.imul(ah9, bh8), lo = lo + Math.imul(al8, bl9) | 0, mid = mid + Math.imul(al8, bh9) | 0, mid = mid + Math.imul(ah8, bl9) | 0, hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 67108863, lo = Math.imul(al9, bl9), mid = Math.imul(al9, bh9), mid = mid + Math.imul(ah9, bl9) | 0, hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          if (c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, c !== 0)
            o[19] = c, out.length++;
          return out;
        };
        if (!Math.imul)
          comb10MulTo = smallMulTo;
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative, out.length = self2.length + num.length;
          var carry = 0, hncarry = 0;
          for (var k = 0;k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
              var i2 = k - j, a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b, lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0, lo = lo + rword | 0, rword = lo & 67108863, ncarry = ncarry + (lo >>> 26) | 0, hncarry += ncarry >>> 26, ncarry &= 67108863;
            }
            out.words[k] = rword, carry = ncarry, ncarry = hncarry;
          }
          if (carry !== 0)
            out.words[k] = carry;
          else
            out.length--;
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM;
          return fftm.mulp(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res, len2 = this.length + num.length;
          if (this.length === 10 && num.length === 10)
            res = comb10MulTo(this, num, out);
          else if (len2 < 63)
            res = smallMulTo(this, num, out);
          else if (len2 < 1024)
            res = bigMulTo(this, num, out);
          else
            res = jumboMulTo(this, num, out);
          return res;
        };
        function FFTM(x, y) {
          this.x = x, this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N), l = BN.prototype._countBits(N) - 1;
          for (var i2 = 0;i2 < N; i2++)
            t[i2] = this.revBin(i2, l, N);
          return t;
        }, FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i2 = 0;i2 < l; i2++)
            rb |= (x & 1) << l - i2 - 1, x >>= 1;
          return rb;
        }, FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i2 = 0;i2 < N; i2++)
            rtws[i2] = rws[rbt[i2]], itws[i2] = iws[rbt[i2]];
        }, FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1;s < N; s <<= 1) {
            var l = s << 1, rtwdf = Math.cos(2 * Math.PI / l), itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0;p < N; p += l) {
              var rtwdf_ = rtwdf, itwdf_ = itwdf;
              for (var j = 0;j < s; j++) {
                var re = rtws[p + j], ie = itws[p + j], ro = rtws[p + j + s], io = itws[p + j + s], rx = rtwdf_ * ro - itwdf_ * io;
                if (io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p + j] = re + ro, itws[p + j] = ie + io, rtws[p + j + s] = re - ro, itws[p + j + s] = ie - io, j !== l)
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx;
              }
            }
          }
        }, FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1, odd = N & 1, i2 = 0;
          for (N = N / 2 | 0;N; N = N >>> 1)
            i2++;
          return 1 << i2 + 1 + odd;
        }, FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i2 = 0;i2 < N / 2; i2++) {
            var t = rws[i2];
            rws[i2] = rws[N - i2 - 1], rws[N - i2 - 1] = t, t = iws[i2], iws[i2] = -iws[N - i2 - 1], iws[N - i2 - 1] = -t;
          }
        }, FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i2 = 0;i2 < N / 2; i2++) {
            var w = Math.round(ws[2 * i2 + 1] / N) * 8192 + Math.round(ws[2 * i2] / N) + carry;
            if (ws[i2] = w & 67108863, w < 67108864)
              carry = 0;
            else
              carry = w / 67108864 | 0;
          }
          return ws;
        }, FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N) {
          var carry = 0;
          for (var i2 = 0;i2 < len2; i2++)
            carry = carry + (ws[i2] | 0), rws[2 * i2] = carry & 8191, carry = carry >>> 13, rws[2 * i2 + 1] = carry & 8191, carry = carry >>> 13;
          for (i2 = 2 * len2;i2 < N; ++i2)
            rws[i2] = 0;
          assert(carry === 0), assert((carry & -8192) === 0);
        }, FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i2 = 0;i2 < N; i2++)
            ph[i2] = 0;
          return ph;
        }, FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length), rbt = this.makeRBT(N), _ = this.stub(N), rws = new Array(N), rwst = new Array(N), iwst = new Array(N), nrws = new Array(N), nrwst = new Array(N), niwst = new Array(N), rmws = out.words;
          rmws.length = N, this.convert13b(x.words, x.length, rws, N), this.convert13b(y.words, y.length, nrws, N), this.transform(rws, _, rwst, iwst, N, rbt), this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i2 = 0;i2 < N; i2++) {
            var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
            iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2], rwst[i2] = rx;
          }
          return this.conjugate(rwst, iwst, N), this.transform(rwst, iwst, rmws, _, N, rbt), this.conjugate(rmws, _, N), this.normalize13b(rmws, N), out.negative = x.negative ^ y.negative, out.length = x.length + y.length, out.strip();
        }, BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          return out.words = new Array(this.length + num.length), this.mulTo(num, out);
        }, BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);
        }, BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        }, BN.prototype.imuln = function imuln(num) {
          assert(typeof num === "number"), assert(num < 67108864);
          var carry = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var w = (this.words[i2] | 0) * num, lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i2] = lo & 67108863;
          }
          if (carry !== 0)
            this.words[i2] = carry, this.length++;
          return this.length = num === 0 ? 1 : this.length, this;
        }, BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        }, BN.prototype.sqr = function sqr() {
          return this.mul(this);
        }, BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        }, BN.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN(1);
          var res = this;
          for (var i2 = 0;i2 < w.length; i2++, res = res.sqr())
            if (w[i2] !== 0)
              break;
          if (++i2 < w.length)
            for (var q = res.sqr();i2 < w.length; i2++, q = q.sqr()) {
              if (w[i2] === 0)
                continue;
              res = res.mul(q);
            }
          return res;
        }, BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26, s = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r, i2;
          if (r !== 0) {
            var carry = 0;
            for (i2 = 0;i2 < this.length; i2++) {
              var newCarry = this.words[i2] & carryMask, c = (this.words[i2] | 0) - newCarry << r;
              this.words[i2] = c | carry, carry = newCarry >>> 26 - r;
            }
            if (carry)
              this.words[i2] = carry, this.length++;
          }
          if (s !== 0) {
            for (i2 = this.length - 1;i2 >= 0; i2--)
              this.words[i2 + s] = this.words[i2];
            for (i2 = 0;i2 < s; i2++)
              this.words[i2] = 0;
            this.length += s;
          }
          return this.strip();
        }, BN.prototype.ishln = function ishln(bits) {
          return assert(this.negative === 0), this.iushln(bits);
        }, BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint)
            h = (hint - hint % 26) / 26;
          else
            h = 0;
          var r = bits % 26, s = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;
          if (h -= s, h = Math.max(0, h), maskedWords) {
            for (var i2 = 0;i2 < s; i2++)
              maskedWords.words[i2] = this.words[i2];
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i2 = 0;i2 < this.length; i2++)
              this.words[i2] = this.words[i2 + s];
          } else
            this.words[0] = 0, this.length = 1;
          var carry = 0;
          for (i2 = this.length - 1;i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
            var word = this.words[i2] | 0;
            this.words[i2] = carry << 26 - r | word >>> r, carry = word & mask;
          }
          if (maskedWords && carry !== 0)
            maskedWords.words[maskedWords.length++] = carry;
          if (this.length === 0)
            this.words[0] = 0, this.length = 1;
          return this.strip();
        }, BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          return assert(this.negative === 0), this.iushrn(bits, hint, extended);
        }, BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        }, BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        }, BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        }, BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        }, BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        }, BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26, s = (bits - r) / 26;
          if (assert(this.negative === 0, "imaskn works only with positive numbers"), this.length <= s)
            return this;
          if (r !== 0)
            s++;
          if (this.length = Math.min(s, this.length), r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        }, BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        }, BN.prototype.iaddn = function iaddn(num) {
          if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num)
              return this.words[0] = num - (this.words[0] | 0), this.negative = 0, this;
            return this.negative = 0, this.isubn(num), this.negative = 1, this;
          }
          return this._iaddn(num);
        }, BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i2 = 0;i2 < this.length && this.words[i2] >= 67108864; i2++)
            if (this.words[i2] -= 67108864, i2 === this.length - 1)
              this.words[i2 + 1] = 1;
            else
              this.words[i2 + 1]++;
          return this.length = Math.max(this.length, i2 + 1), this;
        }, BN.prototype.isubn = function isubn(num) {
          if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0)
            return this.negative = 0, this.iaddn(num), this.negative = 1, this;
          if (this.words[0] -= num, this.length === 1 && this.words[0] < 0)
            this.words[0] = -this.words[0], this.negative = 1;
          else
            for (var i2 = 0;i2 < this.length && this.words[i2] < 0; i2++)
              this.words[i2] += 67108864, this.words[i2 + 1] -= 1;
          return this.strip();
        }, BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        }, BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        }, BN.prototype.iabs = function iabs() {
          return this.negative = 0, this;
        }, BN.prototype.abs = function abs() {
          return this.clone().iabs();
        }, BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift2) {
          var len2 = num.length + shift2, i2;
          this._expand(len2);
          var w, carry = 0;
          for (i2 = 0;i2 < num.length; i2++) {
            w = (this.words[i2 + shift2] | 0) + carry;
            var right3 = (num.words[i2] | 0) * mul;
            w -= right3 & 67108863, carry = (w >> 26) - (right3 / 67108864 | 0), this.words[i2 + shift2] = w & 67108863;
          }
          for (;i2 < this.length - shift2; i2++)
            w = (this.words[i2 + shift2] | 0) + carry, carry = w >> 26, this.words[i2 + shift2] = w & 67108863;
          if (carry === 0)
            return this.strip();
          assert(carry === -1), carry = 0;
          for (i2 = 0;i2 < this.length; i2++)
            w = -(this.words[i2] | 0) + carry, carry = w >> 26, this.words[i2] = w & 67108863;
          return this.negative = 1, this.strip();
        }, BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift2 = this.length - num.length, a = this.clone(), b = num, bhi = b.words[b.length - 1] | 0, bhiBits = this._countBits(bhi);
          if (shift2 = 26 - bhiBits, shift2 !== 0)
            b = b.ushln(shift2), a.iushln(shift2), bhi = b.words[b.length - 1] | 0;
          var m = a.length - b.length, q;
          if (mode !== "mod") {
            q = new BN(null), q.length = m + 1, q.words = new Array(q.length);
            for (var i2 = 0;i2 < q.length; i2++)
              q.words[i2] = 0;
          }
          var diff8 = a.clone()._ishlnsubmul(b, 1, m);
          if (diff8.negative === 0) {
            if (a = diff8, q)
              q.words[m] = 1;
          }
          for (var j = m - 1;j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0)
              if (qj--, a.negative = 0, a._ishlnsubmul(b, 1, j), !a.isZero())
                a.negative ^= 1;
            if (q)
              q.words[j] = qj;
          }
          if (q)
            q.strip();
          if (a.strip(), mode !== "div" && shift2 !== 0)
            a.iushrn(shift2);
          return { div: q || null, mod: a };
        }, BN.prototype.divmod = function divmod(num, mode, positive2) {
          if (assert(!num.isZero()), this.isZero())
            return { div: new BN(0), mod: new BN(0) };
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            if (res = this.neg().divmod(num, mode), mode !== "mod")
              div = res.div.neg();
            if (mode !== "div") {
              if (mod = res.mod.neg(), positive2 && mod.negative !== 0)
                mod.iadd(num);
            }
            return { div, mod };
          }
          if (this.negative === 0 && num.negative !== 0) {
            if (res = this.divmod(num.neg(), mode), mode !== "mod")
              div = res.div.neg();
            return { div, mod: res.mod };
          }
          if ((this.negative & num.negative) !== 0) {
            if (res = this.neg().divmod(num.neg(), mode), mode !== "div") {
              if (mod = res.mod.neg(), positive2 && mod.negative !== 0)
                mod.isub(num);
            }
            return { div: res.div, mod };
          }
          if (num.length > this.length || this.cmp(num) < 0)
            return { div: new BN(0), mod: this };
          if (num.length === 1) {
            if (mode === "div")
              return { div: this.divn(num.words[0]), mod: null };
            if (mode === "mod")
              return { div: null, mod: new BN(this.modn(num.words[0])) };
            return { div: this.divn(num.words[0]), mod: new BN(this.modn(num.words[0])) };
          }
          return this._wordDiv(num, mode);
        }, BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        }, BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        }, BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        }, BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        }, BN.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = 67108864 % num, acc = 0;
          for (var i2 = this.length - 1;i2 >= 0; i2--)
            acc = (p * acc + (this.words[i2] | 0)) % num;
          return acc;
        }, BN.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i2 = this.length - 1;i2 >= 0; i2--) {
            var w = (this.words[i2] | 0) + carry * 67108864;
            this.words[i2] = w / num | 0, carry = w % num;
          }
          return this.strip();
        }, BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        }, BN.prototype.egcd = function egcd(p) {
          assert(p.negative === 0), assert(!p.isZero());
          var x = this, y = p.clone();
          if (x.negative !== 0)
            x = x.umod(p);
          else
            x = x.clone();
          var A = new BN(1), B = new BN(0), C = new BN(0), D = new BN(1), g = 0;
          while (x.isEven() && y.isEven())
            x.iushrn(1), y.iushrn(1), ++g;
          var yp = y.clone(), xp = x.clone();
          while (!x.isZero()) {
            for (var i2 = 0, im = 1;(x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
              ;
            if (i2 > 0) {
              x.iushrn(i2);
              while (i2-- > 0) {
                if (A.isOdd() || B.isOdd())
                  A.iadd(yp), B.isub(xp);
                A.iushrn(1), B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd())
                  C.iadd(yp), D.isub(xp);
                C.iushrn(1), D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0)
              x.isub(y), A.isub(C), B.isub(D);
            else
              y.isub(x), C.isub(A), D.isub(B);
          }
          return { a: C, b: D, gcd: y.iushln(g) };
        }, BN.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0), assert(!p.isZero());
          var a = this, b = p.clone();
          if (a.negative !== 0)
            a = a.umod(p);
          else
            a = a.clone();
          var x1 = new BN(1), x2 = new BN(0), delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i2 = 0, im = 1;(a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
              ;
            if (i2 > 0) {
              a.iushrn(i2);
              while (i2-- > 0) {
                if (x1.isOdd())
                  x1.iadd(delta);
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1;(b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd())
                  x2.iadd(delta);
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0)
              a.isub(b), x1.isub(x2);
            else
              b.isub(a), x2.isub(x1);
          }
          var res;
          if (a.cmpn(1) === 0)
            res = x1;
          else
            res = x2;
          if (res.cmpn(0) < 0)
            res.iadd(p);
          return res;
        }, BN.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone(), b = num.clone();
          a.negative = 0, b.negative = 0;
          for (var shift2 = 0;a.isEven() && b.isEven(); shift2++)
            a.iushrn(1), b.iushrn(1);
          do {
            while (a.isEven())
              a.iushrn(1);
            while (b.isEven())
              b.iushrn(1);
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b, b = t;
            } else if (r === 0 || b.cmpn(1) === 0)
              break;
            a.isub(b);
          } while (true);
          return b.iushln(shift2);
        }, BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        }, BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        }, BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        }, BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        }, BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
          if (this.length <= s)
            return this._expand(s + 1), this.words[s] |= q, this;
          var carry = q;
          for (var i2 = s;carry !== 0 && i2 < this.length; i2++) {
            var w = this.words[i2] | 0;
            w += carry, carry = w >>> 26, w &= 67108863, this.words[i2] = w;
          }
          if (carry !== 0)
            this.words[i2] = carry, this.length++;
          return this;
        }, BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        }, BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1)
            res = 1;
          else {
            if (negative)
              num = -num;
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        }, BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        }, BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i2 = this.length - 1;i2 >= 0; i2--) {
            var a = this.words[i2] | 0, b = num.words[i2] | 0;
            if (a === b)
              continue;
            if (a < b)
              res = -1;
            else if (a > b)
              res = 1;
            break;
          }
          return res;
        }, BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        }, BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        }, BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        }, BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        }, BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        }, BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        }, BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        }, BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        }, BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        }, BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        }, BN.red = function red(num) {
          return new Red(num);
        }, BN.prototype.toRed = function toRed(ctx) {
          return assert(!this.red, "Already a number in reduction context"), assert(this.negative === 0, "red works only with positives"), ctx.convertTo(this)._forceRed(ctx);
        }, BN.prototype.fromRed = function fromRed() {
          return assert(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
        }, BN.prototype._forceRed = function _forceRed(ctx) {
          return this.red = ctx, this;
        }, BN.prototype.forceRed = function forceRed(ctx) {
          return assert(!this.red, "Already a number in reduction context"), this._forceRed(ctx);
        }, BN.prototype.redAdd = function redAdd(num) {
          return assert(this.red, "redAdd works only with red numbers"), this.red.add(this, num);
        }, BN.prototype.redIAdd = function redIAdd(num) {
          return assert(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, num);
        }, BN.prototype.redSub = function redSub(num) {
          return assert(this.red, "redSub works only with red numbers"), this.red.sub(this, num);
        }, BN.prototype.redISub = function redISub(num) {
          return assert(this.red, "redISub works only with red numbers"), this.red.isub(this, num);
        }, BN.prototype.redShl = function redShl(num) {
          return assert(this.red, "redShl works only with red numbers"), this.red.shl(this, num);
        }, BN.prototype.redMul = function redMul(num) {
          return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.mul(this, num);
        }, BN.prototype.redIMul = function redIMul(num) {
          return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.imul(this, num);
        }, BN.prototype.redSqr = function redSqr() {
          return assert(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
        }, BN.prototype.redISqr = function redISqr() {
          return assert(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
        }, BN.prototype.redSqrt = function redSqrt() {
          return assert(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
        }, BN.prototype.redInvm = function redInvm() {
          return assert(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
        }, BN.prototype.redNeg = function redNeg() {
          return assert(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
        }, BN.prototype.redPow = function redPow(num) {
          return assert(this.red && !num.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, num);
        };
        var primes = { k256: null, p224: null, p192: null, p25519: null };
        function MPrime(name, p) {
          this.name = name, this.p = new BN(p, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;
        }, MPrime.prototype.ireduce = function ireduce(num) {
          var r = num, rlen;
          do
            this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), rlen = r.bitLength();
          while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0)
            r.words[0] = 0, r.length = 1;
          else if (cmp > 0)
            r.isub(this.p);
          else if (r.strip !== undefined)
            r.strip();
          else
            r._strip();
          return r;
        }, MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        }, MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        inherits2(K256, MPrime), K256.prototype.split = function split(input, output) {
          var mask = 4194303, outLen = Math.min(input.length, 9);
          for (var i2 = 0;i2 < outLen; i2++)
            output.words[i2] = input.words[i2];
          if (output.length = outLen, input.length <= 9) {
            input.words[0] = 0, input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i2 = 10;i2 < input.length; i2++) {
            var next = input.words[i2] | 0;
            input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22, prev = next;
          }
          if (prev >>>= 22, input.words[i2 - 10] = prev, prev === 0 && input.length > 10)
            input.length -= 10;
          else
            input.length -= 9;
        }, K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;
          var lo = 0;
          for (var i2 = 0;i2 < num.length; i2++) {
            var w = num.words[i2] | 0;
            lo += w * 977, num.words[i2] = lo & 67108863, lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            if (num.length--, num.words[num.length - 1] === 0)
              num.length--;
          }
          return num;
        };
        function P224() {
          MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        inherits2(P224, MPrime);
        function P192() {
          MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        inherits2(P192, MPrime);
        function P25519() {
          MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        inherits2(P25519, MPrime), P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i2 = 0;i2 < num.length; i2++) {
            var hi = (num.words[i2] | 0) * 19 + carry, lo = hi & 67108863;
            hi >>>= 26, num.words[i2] = lo, carry = hi;
          }
          if (carry !== 0)
            num.words[num.length++] = carry;
          return num;
        }, BN._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime;
          if (name === "k256")
            prime = new K256;
          else if (name === "p224")
            prime = new P224;
          else if (name === "p192")
            prime = new P192;
          else if (name === "p25519")
            prime = new P25519;
          else
            throw new Error("Unknown prime " + name);
          return primes[name] = prime, prime;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p, this.prime = prime;
          } else
            assert(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives"), assert(a.red, "red works only with red numbers");
        }, Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives"), assert(a.red && a.red === b.red, "red works only with red numbers");
        }, Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        }, Red.prototype.neg = function neg(a) {
          if (a.isZero())
            return a.clone();
          return this.m.sub(a)._forceRed(this);
        }, Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0)
            res.isub(this.m);
          return res._forceRed(this);
        }, Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0)
            res.isub(this.m);
          return res;
        }, Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0)
            res.iadd(this.m);
          return res._forceRed(this);
        }, Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0)
            res.iadd(this.m);
          return res;
        }, Red.prototype.shl = function shl(a, num) {
          return this._verify1(a), this.imod(a.ushln(num));
        }, Red.prototype.imul = function imul(a, b) {
          return this._verify2(a, b), this.imod(a.imul(b));
        }, Red.prototype.mul = function mul(a, b) {
          return this._verify2(a, b), this.imod(a.mul(b));
        }, Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        }, Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        }, Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          if (assert(mod3 % 2 === 1), mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1), s = 0;
          while (!q.isZero() && q.andln(1) === 0)
            s++, q.iushrn(1);
          assert(!q.isZero());
          var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0)
            z.redIAdd(nOne);
          var c = this.pow(z, q), r = this.pow(a, q.addn(1).iushrn(1)), t = this.pow(a, q), m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i2 = 0;tmp.cmp(one) !== 0; i2++)
              tmp = tmp.redSqr();
            assert(i2 < m);
            var b = this.pow(c, new BN(1).iushln(m - i2 - 1));
            r = r.redMul(b), c = b.redSqr(), t = t.redMul(c), m = i2;
          }
          return r;
        }, Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0)
            return inv.negative = 0, this.imod(inv).redNeg();
          else
            return this.imod(inv);
        }, Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4, wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this), wnd[1] = a;
          for (var i2 = 2;i2 < wnd.length; i2++)
            wnd[i2] = this.mul(wnd[i2 - 1], a);
          var res = wnd[0], current2 = 0, currentLen = 0, start4 = num.bitLength() % 26;
          if (start4 === 0)
            start4 = 26;
          for (i2 = num.length - 1;i2 >= 0; i2--) {
            var word = num.words[i2];
            for (var j = start4 - 1;j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0])
                res = this.sqr(res);
              if (bit === 0 && current2 === 0) {
                currentLen = 0;
                continue;
              }
              if (current2 <<= 1, current2 |= bit, currentLen++, currentLen !== windowSize && (i2 !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current2]), currentLen = 0, current2 = 0;
            }
            start4 = 26;
          }
          return res;
        }, Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        }, Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          return res.red = null, res;
        }, BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          if (Red.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 !== 0)
            this.shift += 26 - this.shift % 26;
          this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
        }
        inherits2(Mont, Red), Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        }, Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          return r.red = null, r;
        }, Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero())
            return a.words[0] = 0, a.length = 1, a;
          var t = a.imul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;
          if (u.cmp(this.m) >= 0)
            res = u.isub(this.m);
          else if (u.cmpn(0) < 0)
            res = u.iadd(this.m);
          return res._forceRed(this);
        }, Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN(0)._forceRed(this);
          var t = a.mul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;
          if (u.cmp(this.m) >= 0)
            res = u.isub(this.m);
          else if (u.cmpn(0) < 0)
            res = u.iadd(this.m);
          return res._forceRed(this);
        }, Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    });
    require_api = __commonJS2((exports) => {
      var asn1 = require_asn1(), inherits2 = require_inherits(), api = exports;
      api.define = function define(name, body) {
        return new Entity(name, body);
      };
      function Entity(name, body) {
        this.name = name, this.body = body, this.decoders = {}, this.encoders = {};
      }
      Entity.prototype._createNamed = function createNamed(base) {
        var named;
        try {
          named = (()=>{throw new Error("Cannot require module "+"vm");})().runInThisContext("(function " + this.name + `(entity) {
  this._initNamed(entity);
})`);
        } catch (e) {
          named = function(entity) {
            this._initNamed(entity);
          };
        }
        return inherits2(named, base), named.prototype._initNamed = function initnamed(entity) {
          base.call(this, entity);
        }, new named(this);
      };
      Entity.prototype._getDecoder = function _getDecoder(enc) {
        if (enc = enc || "der", !this.decoders.hasOwnProperty(enc))
          this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
        return this.decoders[enc];
      };
      Entity.prototype.decode = function decode(data, enc, options) {
        return this._getDecoder(enc).decode(data, options);
      };
      Entity.prototype._getEncoder = function _getEncoder(enc) {
        if (enc = enc || "der", !this.encoders.hasOwnProperty(enc))
          this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
        return this.encoders[enc];
      };
      Entity.prototype.encode = function encode(data, enc, reporter) {
        return this._getEncoder(enc).encode(data, reporter);
      };
    });
    require_reporter = __commonJS2((exports) => {
      var inherits2 = require_inherits();
      function Reporter(options) {
        this._reporterState = { obj: null, path: [], options: options || {}, errors: [] };
      }
      exports.Reporter = Reporter;
      Reporter.prototype.isError = function isError(obj) {
        return obj instanceof ReporterError;
      };
      Reporter.prototype.save = function save() {
        var state = this._reporterState;
        return { obj: state.obj, pathLen: state.path.length };
      };
      Reporter.prototype.restore = function restore(data) {
        var state = this._reporterState;
        state.obj = data.obj, state.path = state.path.slice(0, data.pathLen);
      };
      Reporter.prototype.enterKey = function enterKey(key) {
        return this._reporterState.path.push(key);
      };
      Reporter.prototype.exitKey = function exitKey(index) {
        var state = this._reporterState;
        state.path = state.path.slice(0, index - 1);
      };
      Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
        var state = this._reporterState;
        if (this.exitKey(index), state.obj !== null)
          state.obj[key] = value;
      };
      Reporter.prototype.path = function path() {
        return this._reporterState.path.join("/");
      };
      Reporter.prototype.enterObject = function enterObject() {
        var state = this._reporterState, prev = state.obj;
        return state.obj = {}, prev;
      };
      Reporter.prototype.leaveObject = function leaveObject(prev) {
        var state = this._reporterState, now = state.obj;
        return state.obj = prev, now;
      };
      Reporter.prototype.error = function error(msg) {
        var err, state = this._reporterState, inherited = msg instanceof ReporterError;
        if (inherited)
          err = msg;
        else
          err = new ReporterError(state.path.map(function(elem) {
            return "[" + JSON.stringify(elem) + "]";
          }).join(""), msg.message || msg, msg.stack);
        if (!state.options.partial)
          throw err;
        if (!inherited)
          state.errors.push(err);
        return err;
      };
      Reporter.prototype.wrapResult = function wrapResult(result) {
        var state = this._reporterState;
        if (!state.options.partial)
          return result;
        return { result: this.isError(result) ? null : result, errors: state.errors };
      };
      function ReporterError(path, msg) {
        this.path = path, this.rethrow(msg);
      }
      inherits2(ReporterError, Error);
      ReporterError.prototype.rethrow = function rethrow(msg) {
        if (this.message = msg + " at: " + (this.path || "(shallow)"), Error.captureStackTrace)
          Error.captureStackTrace(this, ReporterError);
        if (!this.stack)
          try {
            throw new Error(this.message);
          } catch (e) {
            this.stack = e.stack;
          }
        return this;
      };
    });
    require_buffer = __commonJS2((exports) => {
      var inherits2 = require_inherits(), Reporter = require_base2().Reporter, Buffer22 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
      function DecoderBuffer(base, options) {
        if (Reporter.call(this, options), !Buffer22.isBuffer(base)) {
          this.error("Input not Buffer");
          return;
        }
        this.base = base, this.offset = 0, this.length = base.length;
      }
      inherits2(DecoderBuffer, Reporter);
      exports.DecoderBuffer = DecoderBuffer;
      DecoderBuffer.prototype.save = function save() {
        return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
      };
      DecoderBuffer.prototype.restore = function restore(save) {
        var res = new DecoderBuffer(this.base);
        return res.offset = save.offset, res.length = this.offset, this.offset = save.offset, Reporter.prototype.restore.call(this, save.reporter), res;
      };
      DecoderBuffer.prototype.isEmpty = function isEmpty() {
        return this.offset === this.length;
      };
      DecoderBuffer.prototype.readUInt8 = function readUInt8(fail19) {
        if (this.offset + 1 <= this.length)
          return this.base.readUInt8(this.offset++, true);
        else
          return this.error(fail19 || "DecoderBuffer overrun");
      };
      DecoderBuffer.prototype.skip = function skip(bytes, fail19) {
        if (!(this.offset + bytes <= this.length))
          return this.error(fail19 || "DecoderBuffer overrun");
        var res = new DecoderBuffer(this.base);
        return res._reporterState = this._reporterState, res.offset = this.offset, res.length = this.offset + bytes, this.offset += bytes, res;
      };
      DecoderBuffer.prototype.raw = function raw(save) {
        return this.base.slice(save ? save.offset : this.offset, this.length);
      };
      function EncoderBuffer(value, reporter) {
        if (Array.isArray(value))
          this.length = 0, this.value = value.map(function(item) {
            if (!(item instanceof EncoderBuffer))
              item = new EncoderBuffer(item, reporter);
            return this.length += item.length, item;
          }, this);
        else if (typeof value === "number") {
          if (!(0 <= value && value <= 255))
            return reporter.error("non-byte EncoderBuffer value");
          this.value = value, this.length = 1;
        } else if (typeof value === "string")
          this.value = value, this.length = Buffer22.byteLength(value);
        else if (Buffer22.isBuffer(value))
          this.value = value, this.length = value.length;
        else
          return reporter.error("Unsupported type: " + typeof value);
      }
      exports.EncoderBuffer = EncoderBuffer;
      EncoderBuffer.prototype.join = function join(out, offset) {
        if (!out)
          out = new Buffer22(this.length);
        if (!offset)
          offset = 0;
        if (this.length === 0)
          return out;
        if (Array.isArray(this.value))
          this.value.forEach(function(item) {
            item.join(out, offset), offset += item.length;
          });
        else {
          if (typeof this.value === "number")
            out[offset] = this.value;
          else if (typeof this.value === "string")
            out.write(this.value, offset);
          else if (Buffer22.isBuffer(this.value))
            this.value.copy(out, offset);
          offset += this.length;
        }
        return out;
      };
    });
    require_node = __commonJS2((exports, module) => {
      var Reporter = require_base2().Reporter, EncoderBuffer = require_base2().EncoderBuffer, DecoderBuffer = require_base2().DecoderBuffer, assert = require_minimalistic_assert(), tags = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], methods = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(tags), overrided = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
      function Node(enc, parent) {
        var state = {};
        if (this._baseState = state, state.enc = enc, state.parent = parent || null, state.children = null, state.tag = null, state.args = null, state.reverseArgs = null, state.choice = null, state.optional = false, state.any = false, state.obj = false, state.use = null, state.useDecoder = null, state.key = null, state.default = null, state.explicit = null, state.implicit = null, state.contains = null, !state.parent)
          state.children = [], this._wrap();
      }
      module.exports = Node;
      var stateProps = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
      Node.prototype.clone = function clone() {
        var state = this._baseState, cstate = {};
        stateProps.forEach(function(prop) {
          cstate[prop] = state[prop];
        });
        var res = new this.constructor(cstate.parent);
        return res._baseState = cstate, res;
      };
      Node.prototype._wrap = function wrap() {
        var state = this._baseState;
        methods.forEach(function(method) {
          this[method] = function _wrappedMethod() {
            var clone = new this.constructor(this);
            return state.children.push(clone), clone[method].apply(clone, arguments);
          };
        }, this);
      };
      Node.prototype._init = function init(body) {
        var state = this._baseState;
        assert(state.parent === null), body.call(this), state.children = state.children.filter(function(child) {
          return child._baseState.parent === this;
        }, this), assert.equal(state.children.length, 1, "Root node can have only one child");
      };
      Node.prototype._useArgs = function useArgs(args2) {
        var state = this._baseState, children2 = args2.filter(function(arg) {
          return arg instanceof this.constructor;
        }, this);
        if (args2 = args2.filter(function(arg) {
          return !(arg instanceof this.constructor);
        }, this), children2.length !== 0)
          assert(state.children === null), state.children = children2, children2.forEach(function(child) {
            child._baseState.parent = this;
          }, this);
        if (args2.length !== 0)
          assert(state.args === null), state.args = args2, state.reverseArgs = args2.map(function(arg) {
            if (typeof arg !== "object" || arg.constructor !== Object)
              return arg;
            var res = {};
            return Object.keys(arg).forEach(function(key) {
              if (key == (key | 0))
                key |= 0;
              var value = arg[key];
              res[value] = key;
            }), res;
          });
      };
      overrided.forEach(function(method) {
        Node.prototype[method] = function _overrided() {
          var state = this._baseState;
          throw new Error(method + " not implemented for encoding: " + state.enc);
        };
      });
      tags.forEach(function(tag2) {
        Node.prototype[tag2] = function _tagMethod() {
          var state = this._baseState, args2 = Array.prototype.slice.call(arguments);
          return assert(state.tag === null), state.tag = tag2, this._useArgs(args2), this;
        };
      });
      Node.prototype.use = function use(item) {
        assert(item);
        var state = this._baseState;
        return assert(state.use === null), state.use = item, this;
      };
      Node.prototype.optional = function optional() {
        var state = this._baseState;
        return state.optional = true, this;
      };
      Node.prototype.def = function def(val) {
        var state = this._baseState;
        return assert(state.default === null), state.default = val, state.optional = true, this;
      };
      Node.prototype.explicit = function explicit(num) {
        var state = this._baseState;
        return assert(state.explicit === null && state.implicit === null), state.explicit = num, this;
      };
      Node.prototype.implicit = function implicit(num) {
        var state = this._baseState;
        return assert(state.explicit === null && state.implicit === null), state.implicit = num, this;
      };
      Node.prototype.obj = function obj() {
        var state = this._baseState, args2 = Array.prototype.slice.call(arguments);
        if (state.obj = true, args2.length !== 0)
          this._useArgs(args2);
        return this;
      };
      Node.prototype.key = function key(newKey) {
        var state = this._baseState;
        return assert(state.key === null), state.key = newKey, this;
      };
      Node.prototype.any = function any() {
        var state = this._baseState;
        return state.any = true, this;
      };
      Node.prototype.choice = function choice(obj) {
        var state = this._baseState;
        return assert(state.choice === null), state.choice = obj, this._useArgs(Object.keys(obj).map(function(key) {
          return obj[key];
        })), this;
      };
      Node.prototype.contains = function contains(item) {
        var state = this._baseState;
        return assert(state.use === null), state.contains = item, this;
      };
      Node.prototype._decode = function decode(input, options) {
        var state = this._baseState;
        if (state.parent === null)
          return input.wrapResult(state.children[0]._decode(input, options));
        var result = state.default, present = true, prevKey = null;
        if (state.key !== null)
          prevKey = input.enterKey(state.key);
        if (state.optional) {
          var tag2 = null;
          if (state.explicit !== null)
            tag2 = state.explicit;
          else if (state.implicit !== null)
            tag2 = state.implicit;
          else if (state.tag !== null)
            tag2 = state.tag;
          if (tag2 === null && !state.any) {
            var save = input.save();
            try {
              if (state.choice === null)
                this._decodeGeneric(state.tag, input, options);
              else
                this._decodeChoice(input, options);
              present = true;
            } catch (e) {
              present = false;
            }
            input.restore(save);
          } else if (present = this._peekTag(input, tag2, state.any), input.isError(present))
            return present;
        }
        var prevObj;
        if (state.obj && present)
          prevObj = input.enterObject();
        if (present) {
          if (state.explicit !== null) {
            var explicit = this._decodeTag(input, state.explicit);
            if (input.isError(explicit))
              return explicit;
            input = explicit;
          }
          var start4 = input.offset;
          if (state.use === null && state.choice === null) {
            if (state.any)
              var save = input.save();
            var body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
            if (input.isError(body))
              return body;
            if (state.any)
              result = input.raw(save);
            else
              input = body;
          }
          if (options && options.track && state.tag !== null)
            options.track(input.path(), start4, input.length, "tagged");
          if (options && options.track && state.tag !== null)
            options.track(input.path(), input.offset, input.length, "content");
          if (state.any)
            result = result;
          else if (state.choice === null)
            result = this._decodeGeneric(state.tag, input, options);
          else
            result = this._decodeChoice(input, options);
          if (input.isError(result))
            return result;
          if (!state.any && state.choice === null && state.children !== null)
            state.children.forEach(function decodeChildren(child) {
              child._decode(input, options);
            });
          if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
            var data = new DecoderBuffer(result);
            result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
          }
        }
        if (state.obj && present)
          result = input.leaveObject(prevObj);
        if (state.key !== null && (result !== null || present === true))
          input.leaveKey(prevKey, state.key, result);
        else if (prevKey !== null)
          input.exitKey(prevKey);
        return result;
      };
      Node.prototype._decodeGeneric = function decodeGeneric(tag2, input, options) {
        var state = this._baseState;
        if (tag2 === "seq" || tag2 === "set")
          return null;
        if (tag2 === "seqof" || tag2 === "setof")
          return this._decodeList(input, tag2, state.args[0], options);
        else if (/str$/.test(tag2))
          return this._decodeStr(input, tag2, options);
        else if (tag2 === "objid" && state.args)
          return this._decodeObjid(input, state.args[0], state.args[1], options);
        else if (tag2 === "objid")
          return this._decodeObjid(input, null, null, options);
        else if (tag2 === "gentime" || tag2 === "utctime")
          return this._decodeTime(input, tag2, options);
        else if (tag2 === "null_")
          return this._decodeNull(input, options);
        else if (tag2 === "bool")
          return this._decodeBool(input, options);
        else if (tag2 === "objDesc")
          return this._decodeStr(input, tag2, options);
        else if (tag2 === "int" || tag2 === "enum")
          return this._decodeInt(input, state.args && state.args[0], options);
        if (state.use !== null)
          return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
        else
          return input.error("unknown tag: " + tag2);
      };
      Node.prototype._getUse = function _getUse(entity, obj) {
        var state = this._baseState;
        if (state.useDecoder = this._use(entity, obj), assert(state.useDecoder._baseState.parent === null), state.useDecoder = state.useDecoder._baseState.children[0], state.implicit !== state.useDecoder._baseState.implicit)
          state.useDecoder = state.useDecoder.clone(), state.useDecoder._baseState.implicit = state.implicit;
        return state.useDecoder;
      };
      Node.prototype._decodeChoice = function decodeChoice(input, options) {
        var state = this._baseState, result = null, match18 = false;
        if (Object.keys(state.choice).some(function(key) {
          var save = input.save(), node = state.choice[key];
          try {
            var value = node._decode(input, options);
            if (input.isError(value))
              return false;
            result = { type: key, value }, match18 = true;
          } catch (e) {
            return input.restore(save), false;
          }
          return true;
        }, this), !match18)
          return input.error("Choice not matched");
        return result;
      };
      Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
        return new EncoderBuffer(data, this.reporter);
      };
      Node.prototype._encode = function encode(data, reporter, parent) {
        var state = this._baseState;
        if (state.default !== null && state.default === data)
          return;
        var result = this._encodeValue(data, reporter, parent);
        if (result === undefined)
          return;
        if (this._skipDefault(result, reporter, parent))
          return;
        return result;
      };
      Node.prototype._encodeValue = function encode(data, reporter, parent) {
        var state = this._baseState;
        if (state.parent === null)
          return state.children[0]._encode(data, reporter || new Reporter);
        var result = null;
        if (this.reporter = reporter, state.optional && data === undefined)
          if (state.default !== null)
            data = state.default;
          else
            return;
        var content = null, primitive = false;
        if (state.any)
          result = this._createEncoderBuffer(data);
        else if (state.choice)
          result = this._encodeChoice(data, reporter);
        else if (state.contains)
          content = this._getUse(state.contains, parent)._encode(data, reporter), primitive = true;
        else if (state.children)
          content = state.children.map(function(child2) {
            if (child2._baseState.tag === "null_")
              return child2._encode(null, reporter, data);
            if (child2._baseState.key === null)
              return reporter.error("Child should have a key");
            var prevKey = reporter.enterKey(child2._baseState.key);
            if (typeof data !== "object")
              return reporter.error("Child expected, but input is not object");
            var res = child2._encode(data[child2._baseState.key], reporter, data);
            return reporter.leaveKey(prevKey), res;
          }, this).filter(function(child2) {
            return child2;
          }), content = this._createEncoderBuffer(content);
        else if (state.tag === "seqof" || state.tag === "setof") {
          if (!(state.args && state.args.length === 1))
            return reporter.error("Too many args for : " + state.tag);
          if (!Array.isArray(data))
            return reporter.error("seqof/setof, but data is not Array");
          var child = this.clone();
          child._baseState.implicit = null, content = this._createEncoderBuffer(data.map(function(item) {
            var state2 = this._baseState;
            return this._getUse(state2.args[0], data)._encode(item, reporter);
          }, child));
        } else if (state.use !== null)
          result = this._getUse(state.use, parent)._encode(data, reporter);
        else
          content = this._encodePrimitive(state.tag, data), primitive = true;
        var result;
        if (!state.any && state.choice === null) {
          var tag2 = state.implicit !== null ? state.implicit : state.tag, cls = state.implicit === null ? "universal" : "context";
          if (tag2 === null) {
            if (state.use === null)
              reporter.error("Tag could be omitted only for .use()");
          } else if (state.use === null)
            result = this._encodeComposite(tag2, primitive, cls, content);
        }
        if (state.explicit !== null)
          result = this._encodeComposite(state.explicit, false, "context", result);
        return result;
      };
      Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
        var state = this._baseState, node = state.choice[data.type];
        if (!node)
          assert(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice)));
        return node._encode(data.value, reporter);
      };
      Node.prototype._encodePrimitive = function encodePrimitive(tag2, data) {
        var state = this._baseState;
        if (/str$/.test(tag2))
          return this._encodeStr(data, tag2);
        else if (tag2 === "objid" && state.args)
          return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
        else if (tag2 === "objid")
          return this._encodeObjid(data, null, null);
        else if (tag2 === "gentime" || tag2 === "utctime")
          return this._encodeTime(data, tag2);
        else if (tag2 === "null_")
          return this._encodeNull();
        else if (tag2 === "int" || tag2 === "enum")
          return this._encodeInt(data, state.args && state.reverseArgs[0]);
        else if (tag2 === "bool")
          return this._encodeBool(data);
        else if (tag2 === "objDesc")
          return this._encodeStr(data, tag2);
        else
          throw new Error("Unsupported tag: " + tag2);
      };
      Node.prototype._isNumstr = function isNumstr(str) {
        return /^[0-9 ]*$/.test(str);
      };
      Node.prototype._isPrintstr = function isPrintstr(str) {
        return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
      };
    });
    require_base2 = __commonJS2((exports) => {
      var base = exports;
      base.Reporter = require_reporter().Reporter;
      base.DecoderBuffer = require_buffer().DecoderBuffer;
      base.EncoderBuffer = require_buffer().EncoderBuffer;
      base.Node = require_node();
    });
    require_der = __commonJS2((exports) => {
      var constants2 = require_constants();
      exports.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
      exports.tagClassByName = constants2._reverse(exports.tagClass);
      exports.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
      exports.tagByName = constants2._reverse(exports.tag);
    });
    require_constants = __commonJS2((exports) => {
      var constants2 = exports;
      constants2._reverse = function reverse(map24) {
        var res = {};
        return Object.keys(map24).forEach(function(key) {
          if ((key | 0) == key)
            key = key | 0;
          var value = map24[key];
          res[value] = key;
        }), res;
      };
      constants2.der = require_der();
    });
    require_der2 = __commonJS2((exports, module) => {
      var inherits2 = require_inherits(), asn1 = require_asn1(), base = asn1.base, bignum = asn1.bignum, der = asn1.constants.der;
      function DERDecoder(entity) {
        this.enc = "der", this.name = entity.name, this.entity = entity, this.tree = new DERNode, this.tree._init(entity.body);
      }
      module.exports = DERDecoder;
      DERDecoder.prototype.decode = function decode(data, options) {
        if (!(data instanceof base.DecoderBuffer))
          data = new base.DecoderBuffer(data, options);
        return this.tree._decode(data, options);
      };
      function DERNode(parent) {
        base.Node.call(this, "der", parent);
      }
      inherits2(DERNode, base.Node);
      DERNode.prototype._peekTag = function peekTag(buffer4, tag2, any) {
        if (buffer4.isEmpty())
          return false;
        var state = buffer4.save(), decodedTag = derDecodeTag(buffer4, 'Failed to peek tag: "' + tag2 + '"');
        if (buffer4.isError(decodedTag))
          return decodedTag;
        return buffer4.restore(state), decodedTag.tag === tag2 || decodedTag.tagStr === tag2 || decodedTag.tagStr + "of" === tag2 || any;
      };
      DERNode.prototype._decodeTag = function decodeTag(buffer4, tag2, any) {
        var decodedTag = derDecodeTag(buffer4, 'Failed to decode tag of "' + tag2 + '"');
        if (buffer4.isError(decodedTag))
          return decodedTag;
        var len2 = derDecodeLen(buffer4, decodedTag.primitive, 'Failed to get length of "' + tag2 + '"');
        if (buffer4.isError(len2))
          return len2;
        if (!any && decodedTag.tag !== tag2 && decodedTag.tagStr !== tag2 && decodedTag.tagStr + "of" !== tag2)
          return buffer4.error('Failed to match tag: "' + tag2 + '"');
        if (decodedTag.primitive || len2 !== null)
          return buffer4.skip(len2, 'Failed to match body of: "' + tag2 + '"');
        var state = buffer4.save(), res = this._skipUntilEnd(buffer4, 'Failed to skip indefinite length body: "' + this.tag + '"');
        if (buffer4.isError(res))
          return res;
        return len2 = buffer4.offset - state.offset, buffer4.restore(state), buffer4.skip(len2, 'Failed to match body of: "' + tag2 + '"');
      };
      DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer4, fail19) {
        while (true) {
          var tag2 = derDecodeTag(buffer4, fail19);
          if (buffer4.isError(tag2))
            return tag2;
          var len2 = derDecodeLen(buffer4, tag2.primitive, fail19);
          if (buffer4.isError(len2))
            return len2;
          var res;
          if (tag2.primitive || len2 !== null)
            res = buffer4.skip(len2);
          else
            res = this._skipUntilEnd(buffer4, fail19);
          if (buffer4.isError(res))
            return res;
          if (tag2.tagStr === "end")
            break;
        }
      };
      DERNode.prototype._decodeList = function decodeList(buffer4, tag2, decoder, options) {
        var result = [];
        while (!buffer4.isEmpty()) {
          var possibleEnd = this._peekTag(buffer4, "end");
          if (buffer4.isError(possibleEnd))
            return possibleEnd;
          var res = decoder.decode(buffer4, "der", options);
          if (buffer4.isError(res) && possibleEnd)
            break;
          result.push(res);
        }
        return result;
      };
      DERNode.prototype._decodeStr = function decodeStr(buffer4, tag2) {
        if (tag2 === "bitstr") {
          var unused = buffer4.readUInt8();
          if (buffer4.isError(unused))
            return unused;
          return { unused, data: buffer4.raw() };
        } else if (tag2 === "bmpstr") {
          var raw = buffer4.raw();
          if (raw.length % 2 === 1)
            return buffer4.error("Decoding of string type: bmpstr length mismatch");
          var str = "";
          for (var i2 = 0;i2 < raw.length / 2; i2++)
            str += String.fromCharCode(raw.readUInt16BE(i2 * 2));
          return str;
        } else if (tag2 === "numstr") {
          var numstr = buffer4.raw().toString("ascii");
          if (!this._isNumstr(numstr))
            return buffer4.error("Decoding of string type: numstr unsupported characters");
          return numstr;
        } else if (tag2 === "octstr")
          return buffer4.raw();
        else if (tag2 === "objDesc")
          return buffer4.raw();
        else if (tag2 === "printstr") {
          var printstr = buffer4.raw().toString("ascii");
          if (!this._isPrintstr(printstr))
            return buffer4.error("Decoding of string type: printstr unsupported characters");
          return printstr;
        } else if (/str$/.test(tag2))
          return buffer4.raw().toString();
        else
          return buffer4.error("Decoding of string type: " + tag2 + " unsupported");
      };
      DERNode.prototype._decodeObjid = function decodeObjid(buffer4, values3, relative) {
        var result, identifiers = [], ident = 0;
        while (!buffer4.isEmpty()) {
          var subident = buffer4.readUInt8();
          if (ident <<= 7, ident |= subident & 127, (subident & 128) === 0)
            identifiers.push(ident), ident = 0;
        }
        if (subident & 128)
          identifiers.push(ident);
        var first = identifiers[0] / 40 | 0, second = identifiers[0] % 40;
        if (relative)
          result = identifiers;
        else
          result = [first, second].concat(identifiers.slice(1));
        if (values3) {
          var tmp = values3[result.join(" ")];
          if (tmp === undefined)
            tmp = values3[result.join(".")];
          if (tmp !== undefined)
            result = tmp;
        }
        return result;
      };
      DERNode.prototype._decodeTime = function decodeTime(buffer4, tag2) {
        var str = buffer4.raw().toString();
        if (tag2 === "gentime")
          var year = str.slice(0, 4) | 0, mon = str.slice(4, 6) | 0, day = str.slice(6, 8) | 0, hour = str.slice(8, 10) | 0, min3 = str.slice(10, 12) | 0, sec = str.slice(12, 14) | 0;
        else if (tag2 === "utctime") {
          var year = str.slice(0, 2) | 0, mon = str.slice(2, 4) | 0, day = str.slice(4, 6) | 0, hour = str.slice(6, 8) | 0, min3 = str.slice(8, 10) | 0, sec = str.slice(10, 12) | 0;
          if (year < 70)
            year = 2000 + year;
          else
            year = 1900 + year;
        } else
          return buffer4.error("Decoding " + tag2 + " time is not supported yet");
        return Date.UTC(year, mon - 1, day, hour, min3, sec, 0);
      };
      DERNode.prototype._decodeNull = function decodeNull(buffer4) {
        return null;
      };
      DERNode.prototype._decodeBool = function decodeBool(buffer4) {
        var res = buffer4.readUInt8();
        if (buffer4.isError(res))
          return res;
        else
          return res !== 0;
      };
      DERNode.prototype._decodeInt = function decodeInt(buffer4, values3) {
        var raw = buffer4.raw(), res = new bignum(raw);
        if (values3)
          res = values3[res.toString(10)] || res;
        return res;
      };
      DERNode.prototype._use = function use(entity, obj) {
        if (typeof entity === "function")
          entity = entity(obj);
        return entity._getDecoder("der").tree;
      };
      function derDecodeTag(buf, fail19) {
        var tag2 = buf.readUInt8(fail19);
        if (buf.isError(tag2))
          return tag2;
        var cls = der.tagClass[tag2 >> 6], primitive = (tag2 & 32) === 0;
        if ((tag2 & 31) === 31) {
          var oct = tag2;
          tag2 = 0;
          while ((oct & 128) === 128) {
            if (oct = buf.readUInt8(fail19), buf.isError(oct))
              return oct;
            tag2 <<= 7, tag2 |= oct & 127;
          }
        } else
          tag2 &= 31;
        var tagStr = der.tag[tag2];
        return { cls, primitive, tag: tag2, tagStr };
      }
      function derDecodeLen(buf, primitive, fail19) {
        var len2 = buf.readUInt8(fail19);
        if (buf.isError(len2))
          return len2;
        if (!primitive && len2 === 128)
          return null;
        if ((len2 & 128) === 0)
          return len2;
        var num = len2 & 127;
        if (num > 4)
          return buf.error("length octect is too long");
        len2 = 0;
        for (var i2 = 0;i2 < num; i2++) {
          len2 <<= 8;
          var j = buf.readUInt8(fail19);
          if (buf.isError(j))
            return j;
          len2 |= j;
        }
        return len2;
      }
    });
    require_pem = __commonJS2((exports, module) => {
      var inherits2 = require_inherits(), Buffer22 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer, DERDecoder = require_der2();
      function PEMDecoder(entity) {
        DERDecoder.call(this, entity), this.enc = "pem";
      }
      inherits2(PEMDecoder, DERDecoder);
      module.exports = PEMDecoder;
      PEMDecoder.prototype.decode = function decode(data, options) {
        var lines2 = data.toString().split(/[\r\n]+/g), label = options.label.toUpperCase(), re = /^-----(BEGIN|END) ([^-]+)-----$/, start4 = -1, end6 = -1;
        for (var i2 = 0;i2 < lines2.length; i2++) {
          var match18 = lines2[i2].match(re);
          if (match18 === null)
            continue;
          if (match18[2] !== label)
            continue;
          if (start4 === -1) {
            if (match18[1] !== "BEGIN")
              break;
            start4 = i2;
          } else {
            if (match18[1] !== "END")
              break;
            end6 = i2;
            break;
          }
        }
        if (start4 === -1 || end6 === -1)
          throw new Error("PEM section not found for: " + label);
        var base64 = lines2.slice(start4 + 1, end6).join("");
        base64.replace(/[^a-z0-9\+\/=]+/gi, "");
        var input = new Buffer22(base64, "base64");
        return DERDecoder.prototype.decode.call(this, input, options);
      };
    });
    require_decoders = __commonJS2((exports) => {
      var decoders = exports;
      decoders.der = require_der2();
      decoders.pem = require_pem();
    });
    require_der3 = __commonJS2((exports, module) => {
      var inherits2 = require_inherits(), Buffer22 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer, asn1 = require_asn1(), base = asn1.base, der = asn1.constants.der;
      function DEREncoder(entity) {
        this.enc = "der", this.name = entity.name, this.entity = entity, this.tree = new DERNode, this.tree._init(entity.body);
      }
      module.exports = DEREncoder;
      DEREncoder.prototype.encode = function encode(data, reporter) {
        return this.tree._encode(data, reporter).join();
      };
      function DERNode(parent) {
        base.Node.call(this, "der", parent);
      }
      inherits2(DERNode, base.Node);
      DERNode.prototype._encodeComposite = function encodeComposite(tag2, primitive, cls, content) {
        var encodedTag = encodeTag(tag2, primitive, cls, this.reporter);
        if (content.length < 128) {
          var header = new Buffer22(2);
          return header[0] = encodedTag, header[1] = content.length, this._createEncoderBuffer([header, content]);
        }
        var lenOctets = 1;
        for (var i2 = content.length;i2 >= 256; i2 >>= 8)
          lenOctets++;
        var header = new Buffer22(2 + lenOctets);
        header[0] = encodedTag, header[1] = 128 | lenOctets;
        for (var i2 = 1 + lenOctets, j = content.length;j > 0; i2--, j >>= 8)
          header[i2] = j & 255;
        return this._createEncoderBuffer([header, content]);
      };
      DERNode.prototype._encodeStr = function encodeStr(str, tag2) {
        if (tag2 === "bitstr")
          return this._createEncoderBuffer([str.unused | 0, str.data]);
        else if (tag2 === "bmpstr") {
          var buf = new Buffer22(str.length * 2);
          for (var i2 = 0;i2 < str.length; i2++)
            buf.writeUInt16BE(str.charCodeAt(i2), i2 * 2);
          return this._createEncoderBuffer(buf);
        } else if (tag2 === "numstr") {
          if (!this._isNumstr(str))
            return this.reporter.error("Encoding of string type: numstr supports only digits and space");
          return this._createEncoderBuffer(str);
        } else if (tag2 === "printstr") {
          if (!this._isPrintstr(str))
            return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
          return this._createEncoderBuffer(str);
        } else if (/str$/.test(tag2))
          return this._createEncoderBuffer(str);
        else if (tag2 === "objDesc")
          return this._createEncoderBuffer(str);
        else
          return this.reporter.error("Encoding of string type: " + tag2 + " unsupported");
      };
      DERNode.prototype._encodeObjid = function encodeObjid(id2, values3, relative) {
        if (typeof id2 === "string") {
          if (!values3)
            return this.reporter.error("string objid given, but no values map found");
          if (!values3.hasOwnProperty(id2))
            return this.reporter.error("objid not found in values map");
          id2 = values3[id2].split(/[\s\.]+/g);
          for (var i2 = 0;i2 < id2.length; i2++)
            id2[i2] |= 0;
        } else if (Array.isArray(id2)) {
          id2 = id2.slice();
          for (var i2 = 0;i2 < id2.length; i2++)
            id2[i2] |= 0;
        }
        if (!Array.isArray(id2))
          return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id2));
        if (!relative) {
          if (id2[1] >= 40)
            return this.reporter.error("Second objid identifier OOB");
          id2.splice(0, 2, id2[0] * 40 + id2[1]);
        }
        var size13 = 0;
        for (var i2 = 0;i2 < id2.length; i2++) {
          var ident = id2[i2];
          for (size13++;ident >= 128; ident >>= 7)
            size13++;
        }
        var objid = new Buffer22(size13), offset = objid.length - 1;
        for (var i2 = id2.length - 1;i2 >= 0; i2--) {
          var ident = id2[i2];
          objid[offset--] = ident & 127;
          while ((ident >>= 7) > 0)
            objid[offset--] = 128 | ident & 127;
        }
        return this._createEncoderBuffer(objid);
      };
      function two(num) {
        if (num < 10)
          return "0" + num;
        else
          return num;
      }
      DERNode.prototype._encodeTime = function encodeTime(time, tag2) {
        var str, date = new Date(time);
        if (tag2 === "gentime")
          str = [two(date.getFullYear()), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), "Z"].join("");
        else if (tag2 === "utctime")
          str = [two(date.getFullYear() % 100), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), "Z"].join("");
        else
          this.reporter.error("Encoding " + tag2 + " time is not supported yet");
        return this._encodeStr(str, "octstr");
      };
      DERNode.prototype._encodeNull = function encodeNull() {
        return this._createEncoderBuffer("");
      };
      DERNode.prototype._encodeInt = function encodeInt(num, values3) {
        if (typeof num === "string") {
          if (!values3)
            return this.reporter.error("String int or enum given, but no values map");
          if (!values3.hasOwnProperty(num))
            return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
          num = values3[num];
        }
        if (typeof num !== "number" && !Buffer22.isBuffer(num)) {
          var numArray = num.toArray();
          if (!num.sign && numArray[0] & 128)
            numArray.unshift(0);
          num = new Buffer22(numArray);
        }
        if (Buffer22.isBuffer(num)) {
          var size13 = num.length;
          if (num.length === 0)
            size13++;
          var out = new Buffer22(size13);
          if (num.copy(out), num.length === 0)
            out[0] = 0;
          return this._createEncoderBuffer(out);
        }
        if (num < 128)
          return this._createEncoderBuffer(num);
        if (num < 256)
          return this._createEncoderBuffer([0, num]);
        var size13 = 1;
        for (var i2 = num;i2 >= 256; i2 >>= 8)
          size13++;
        var out = new Array(size13);
        for (var i2 = out.length - 1;i2 >= 0; i2--)
          out[i2] = num & 255, num >>= 8;
        if (out[0] & 128)
          out.unshift(0);
        return this._createEncoderBuffer(new Buffer22(out));
      };
      DERNode.prototype._encodeBool = function encodeBool(value) {
        return this._createEncoderBuffer(value ? 255 : 0);
      };
      DERNode.prototype._use = function use(entity, obj) {
        if (typeof entity === "function")
          entity = entity(obj);
        return entity._getEncoder("der").tree;
      };
      DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
        var state = this._baseState, i2;
        if (state.default === null)
          return false;
        var data = dataBuffer.join();
        if (state.defaultBuffer === undefined)
          state.defaultBuffer = this._encodeValue(state.default, reporter, parent).join();
        if (data.length !== state.defaultBuffer.length)
          return false;
        for (i2 = 0;i2 < data.length; i2++)
          if (data[i2] !== state.defaultBuffer[i2])
            return false;
        return true;
      };
      function encodeTag(tag2, primitive, cls, reporter) {
        var res;
        if (tag2 === "seqof")
          tag2 = "seq";
        else if (tag2 === "setof")
          tag2 = "set";
        if (der.tagByName.hasOwnProperty(tag2))
          res = der.tagByName[tag2];
        else if (typeof tag2 === "number" && (tag2 | 0) === tag2)
          res = tag2;
        else
          return reporter.error("Unknown tag: " + tag2);
        if (res >= 31)
          return reporter.error("Multi-octet tag encoding unsupported");
        if (!primitive)
          res |= 32;
        return res |= der.tagClassByName[cls || "universal"] << 6, res;
      }
    });
    require_pem2 = __commonJS2((exports, module) => {
      var inherits2 = require_inherits(), DEREncoder = require_der3();
      function PEMEncoder(entity) {
        DEREncoder.call(this, entity), this.enc = "pem";
      }
      inherits2(PEMEncoder, DEREncoder);
      module.exports = PEMEncoder;
      PEMEncoder.prototype.encode = function encode(data, options) {
        var buf = DEREncoder.prototype.encode.call(this, data), p = buf.toString("base64"), out = ["-----BEGIN " + options.label + "-----"];
        for (var i2 = 0;i2 < p.length; i2 += 64)
          out.push(p.slice(i2, i2 + 64));
        return out.push("-----END " + options.label + "-----"), out.join(`
`);
      };
    });
    require_encoders = __commonJS2((exports) => {
      var encoders = exports;
      encoders.der = require_der3();
      encoders.pem = require_pem2();
    });
    require_asn1 = __commonJS2((exports) => {
      var asn1 = exports;
      asn1.bignum = require_bn3();
      asn1.define = require_api().define;
      asn1.base = require_base2();
      asn1.constants = require_constants();
      asn1.decoders = require_decoders();
      asn1.encoders = require_encoders();
    });
    require_certificate = __commonJS2((exports, module) => {
      var asn = require_asn1(), Time = asn.define("Time", function() {
        this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
      }), AttributeTypeValue = asn.define("AttributeTypeValue", function() {
        this.seq().obj(this.key("type").objid(), this.key("value").any());
      }), AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
      }), SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
      }), RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
        this.setof(AttributeTypeValue);
      }), RDNSequence = asn.define("RDNSequence", function() {
        this.seqof(RelativeDistinguishedName);
      }), Name = asn.define("Name", function() {
        this.choice({ rdnSequence: this.use(RDNSequence) });
      }), Validity = asn.define("Validity", function() {
        this.seq().obj(this.key("notBefore").use(Time), this.key("notAfter").use(Time));
      }), Extension = asn.define("Extension", function() {
        this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
      }), TBSCertificate = asn.define("TBSCertificate", function() {
        this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(AlgorithmIdentifier), this.key("issuer").use(Name), this.key("validity").use(Validity), this.key("subject").use(Name), this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Extension).optional());
      }), X509Certificate = asn.define("X509Certificate", function() {
        this.seq().obj(this.key("tbsCertificate").use(TBSCertificate), this.key("signatureAlgorithm").use(AlgorithmIdentifier), this.key("signatureValue").bitstr());
      });
      module.exports = X509Certificate;
    });
    require_asn12 = __commonJS2((exports) => {
      var asn1 = require_asn1();
      exports.certificate = require_certificate();
      var RSAPrivateKey = asn1.define("RSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
      });
      exports.RSAPrivateKey = RSAPrivateKey;
      var RSAPublicKey = asn1.define("RSAPublicKey", function() {
        this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
      });
      exports.RSAPublicKey = RSAPublicKey;
      var AlgorithmIdentifier = asn1.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
      }), PublicKey = asn1.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
      });
      exports.PublicKey = PublicKey;
      var PrivateKeyInfo = asn1.define("PrivateKeyInfo", function() {
        this.seq().obj(this.key("version").int(), this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPrivateKey").octstr());
      });
      exports.PrivateKey = PrivateKeyInfo;
      var EncryptedPrivateKeyInfo = asn1.define("EncryptedPrivateKeyInfo", function() {
        this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
      });
      exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
      var DSAPrivateKey = asn1.define("DSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
      });
      exports.DSAPrivateKey = DSAPrivateKey;
      exports.DSAparam = asn1.define("DSAparam", function() {
        this.int();
      });
      var ECParameters = asn1.define("ECParameters", function() {
        this.choice({ namedCurve: this.objid() });
      }), ECPrivateKey = asn1.define("ECPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ECParameters), this.key("publicKey").optional().explicit(1).bitstr());
      });
      exports.ECPrivateKey = ECPrivateKey;
      exports.signature = asn1.define("signature", function() {
        this.seq().obj(this.key("r").int(), this.key("s").int());
      });
    });
    require_aesid = __commonJS2((exports, module) => {
      module.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
    });
    require_hash_base = __commonJS2((exports, module) => {
      var Buffer22 = require_safe_buffer().Buffer, Transform = require_stream().Transform, inherits2 = require_inherits();
      function HashBase(blockSize) {
        Transform.call(this), this._block = Buffer22.allocUnsafe(blockSize), this._blockSize = blockSize, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
      }
      inherits2(HashBase, Transform);
      HashBase.prototype._transform = function(chunk3, encoding, callback) {
        var error = null;
        try {
          this.update(chunk3, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      HashBase.prototype._flush = function(callback) {
        var error = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      var useUint8Array = typeof Uint8Array !== "undefined", useArrayBuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && ArrayBuffer.isView && (Buffer22.prototype instanceof Uint8Array || Buffer22.TYPED_ARRAY_SUPPORT);
      function toBuffer(data, encoding) {
        if (data instanceof Buffer22)
          return data;
        if (typeof data === "string")
          return Buffer22.from(data, encoding);
        if (useArrayBuffer && ArrayBuffer.isView(data)) {
          if (data.byteLength === 0)
            return Buffer22.alloc(0);
          var res = Buffer22.from(data.buffer, data.byteOffset, data.byteLength);
          if (res.byteLength === data.byteLength)
            return res;
        }
        if (useUint8Array && data instanceof Uint8Array)
          return Buffer22.from(data);
        if (Buffer22.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === "function" && data.constructor.isBuffer(data))
          return Buffer22.from(data);
        throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
      }
      HashBase.prototype.update = function(data, encoding) {
        if (this._finalized)
          throw new Error("Digest already called");
        data = toBuffer(data, encoding);
        var block = this._block, offset = 0;
        while (this._blockOffset + data.length - offset >= this._blockSize) {
          for (var i2 = this._blockOffset;i2 < this._blockSize; )
            block[i2++] = data[offset++];
          this._update(), this._blockOffset = 0;
        }
        while (offset < data.length)
          block[this._blockOffset++] = data[offset++];
        for (var j = 0, carry = data.length * 8;carry > 0; ++j)
          if (this._length[j] += carry, carry = this._length[j] / 4294967296 | 0, carry > 0)
            this._length[j] -= 4294967296 * carry;
        return this;
      };
      HashBase.prototype._update = function() {
        throw new Error("_update is not implemented");
      };
      HashBase.prototype.digest = function(encoding) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        var digest = this._digest();
        if (encoding !== undefined)
          digest = digest.toString(encoding);
        this._block.fill(0), this._blockOffset = 0;
        for (var i2 = 0;i2 < 4; ++i2)
          this._length[i2] = 0;
        return digest;
      };
      HashBase.prototype._digest = function() {
        throw new Error("_digest is not implemented");
      };
      module.exports = HashBase;
    });
    require_md5 = __commonJS2((exports, module) => {
      var inherits2 = require_inherits(), HashBase = require_hash_base(), Buffer22 = require_safe_buffer().Buffer, ARRAY16 = new Array(16);
      function MD5() {
        HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
      }
      inherits2(MD5, HashBase);
      MD5.prototype._update = function() {
        var M = ARRAY16;
        for (var i2 = 0;i2 < 16; ++i2)
          M[i2] = this._block.readInt32LE(i2 * 4);
        var a = this._a, b = this._b, c = this._c, d = this._d;
        a = fnF(a, b, c, d, M[0], 3614090360, 7), d = fnF(d, a, b, c, M[1], 3905402710, 12), c = fnF(c, d, a, b, M[2], 606105819, 17), b = fnF(b, c, d, a, M[3], 3250441966, 22), a = fnF(a, b, c, d, M[4], 4118548399, 7), d = fnF(d, a, b, c, M[5], 1200080426, 12), c = fnF(c, d, a, b, M[6], 2821735955, 17), b = fnF(b, c, d, a, M[7], 4249261313, 22), a = fnF(a, b, c, d, M[8], 1770035416, 7), d = fnF(d, a, b, c, M[9], 2336552879, 12), c = fnF(c, d, a, b, M[10], 4294925233, 17), b = fnF(b, c, d, a, M[11], 2304563134, 22), a = fnF(a, b, c, d, M[12], 1804603682, 7), d = fnF(d, a, b, c, M[13], 4254626195, 12), c = fnF(c, d, a, b, M[14], 2792965006, 17), b = fnF(b, c, d, a, M[15], 1236535329, 22), a = fnG(a, b, c, d, M[1], 4129170786, 5), d = fnG(d, a, b, c, M[6], 3225465664, 9), c = fnG(c, d, a, b, M[11], 643717713, 14), b = fnG(b, c, d, a, M[0], 3921069994, 20), a = fnG(a, b, c, d, M[5], 3593408605, 5), d = fnG(d, a, b, c, M[10], 38016083, 9), c = fnG(c, d, a, b, M[15], 3634488961, 14), b = fnG(b, c, d, a, M[4], 3889429448, 20), a = fnG(a, b, c, d, M[9], 568446438, 5), d = fnG(d, a, b, c, M[14], 3275163606, 9), c = fnG(c, d, a, b, M[3], 4107603335, 14), b = fnG(b, c, d, a, M[8], 1163531501, 20), a = fnG(a, b, c, d, M[13], 2850285829, 5), d = fnG(d, a, b, c, M[2], 4243563512, 9), c = fnG(c, d, a, b, M[7], 1735328473, 14), b = fnG(b, c, d, a, M[12], 2368359562, 20), a = fnH(a, b, c, d, M[5], 4294588738, 4), d = fnH(d, a, b, c, M[8], 2272392833, 11), c = fnH(c, d, a, b, M[11], 1839030562, 16), b = fnH(b, c, d, a, M[14], 4259657740, 23), a = fnH(a, b, c, d, M[1], 2763975236, 4), d = fnH(d, a, b, c, M[4], 1272893353, 11), c = fnH(c, d, a, b, M[7], 4139469664, 16), b = fnH(b, c, d, a, M[10], 3200236656, 23), a = fnH(a, b, c, d, M[13], 681279174, 4), d = fnH(d, a, b, c, M[0], 3936430074, 11), c = fnH(c, d, a, b, M[3], 3572445317, 16), b = fnH(b, c, d, a, M[6], 76029189, 23), a = fnH(a, b, c, d, M[9], 3654602809, 4), d = fnH(d, a, b, c, M[12], 3873151461, 11), c = fnH(c, d, a, b, M[15], 530742520, 16), b = fnH(b, c, d, a, M[2], 3299628645, 23), a = fnI(a, b, c, d, M[0], 4096336452, 6), d = fnI(d, a, b, c, M[7], 1126891415, 10), c = fnI(c, d, a, b, M[14], 2878612391, 15), b = fnI(b, c, d, a, M[5], 4237533241, 21), a = fnI(a, b, c, d, M[12], 1700485571, 6), d = fnI(d, a, b, c, M[3], 2399980690, 10), c = fnI(c, d, a, b, M[10], 4293915773, 15), b = fnI(b, c, d, a, M[1], 2240044497, 21), a = fnI(a, b, c, d, M[8], 1873313359, 6), d = fnI(d, a, b, c, M[15], 4264355552, 10), c = fnI(c, d, a, b, M[6], 2734768916, 15), b = fnI(b, c, d, a, M[13], 1309151649, 21), a = fnI(a, b, c, d, M[4], 4149444226, 6), d = fnI(d, a, b, c, M[11], 3174756917, 10), c = fnI(c, d, a, b, M[2], 718787259, 15), b = fnI(b, c, d, a, M[9], 3951481745, 21), this._a = this._a + a | 0, this._b = this._b + b | 0, this._c = this._c + c | 0, this._d = this._d + d | 0;
      };
      MD5.prototype._digest = function() {
        if (this._block[this._blockOffset++] = 128, this._blockOffset > 56)
          this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0;
        this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
        var buffer4 = Buffer22.allocUnsafe(16);
        return buffer4.writeInt32LE(this._a, 0), buffer4.writeInt32LE(this._b, 4), buffer4.writeInt32LE(this._c, 8), buffer4.writeInt32LE(this._d, 12), buffer4;
      };
      function rotl(x, n) {
        return x << n | x >>> 32 - n;
      }
      function fnF(a, b, c, d, m, k, s) {
        return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
      }
      function fnG(a, b, c, d, m, k, s) {
        return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
      }
      function fnH(a, b, c, d, m, k, s) {
        return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
      }
      function fnI(a, b, c, d, m, k, s) {
        return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
      }
      module.exports = MD5;
    });
    require_evp_bytestokey = __commonJS2((exports, module) => {
      var Buffer22 = require_safe_buffer().Buffer, MD5 = require_md5();
      function EVP_BytesToKey(password, salt, keyBits, ivLen) {
        if (!Buffer22.isBuffer(password))
          password = Buffer22.from(password, "binary");
        if (salt) {
          if (!Buffer22.isBuffer(salt))
            salt = Buffer22.from(salt, "binary");
          if (salt.length !== 8)
            throw new RangeError("salt should be Buffer with 8 byte length");
        }
        var keyLen = keyBits / 8, key = Buffer22.alloc(keyLen), iv = Buffer22.alloc(ivLen || 0), tmp = Buffer22.alloc(0);
        while (keyLen > 0 || ivLen > 0) {
          var hash2 = new MD5;
          if (hash2.update(tmp), hash2.update(password), salt)
            hash2.update(salt);
          tmp = hash2.digest();
          var used = 0;
          if (keyLen > 0) {
            var keyStart = key.length - keyLen;
            used = Math.min(keyLen, tmp.length), tmp.copy(key, keyStart, 0, used), keyLen -= used;
          }
          if (used < tmp.length && ivLen > 0) {
            var ivStart = iv.length - ivLen, length3 = Math.min(ivLen, tmp.length - used);
            tmp.copy(iv, ivStart, used, used + length3), ivLen -= length3;
          }
        }
        return tmp.fill(0), { key, iv };
      }
      module.exports = EVP_BytesToKey;
    });
    require_browserify_aes = __commonJS2((exports) => {
      var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
      exports.createCipher = exports.Cipher = crypto2.createCipher;
      exports.createCipheriv = exports.Cipheriv = crypto2.createCipheriv;
      exports.createDecipher = exports.Decipher = crypto2.createDecipher;
      exports.createDecipheriv = exports.Decipheriv = crypto2.createDecipheriv;
      exports.listCiphers = exports.getCiphers = crypto2.getCiphers;
    });
    require_fixProc = __commonJS2((exports, module) => {
      var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, evp = require_evp_bytestokey(), ciphers = require_browserify_aes(), Buffer22 = require_safe_buffer().Buffer;
      module.exports = function(okey, password) {
        var key = okey.toString(), match18 = key.match(findProc), decrypted;
        if (!match18) {
          var match22 = key.match(fullRegex);
          decrypted = Buffer22.from(match22[2].replace(/[\r\n]/g, ""), "base64");
        } else {
          var suite = "aes" + match18[1], iv = Buffer22.from(match18[2], "hex"), cipherText = Buffer22.from(match18[3].replace(/[\r\n]/g, ""), "base64"), cipherKey = evp(password, iv.slice(0, 8), parseInt(match18[1], 10)).key, out = [], cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
          out.push(cipher.update(cipherText)), out.push(cipher.final()), decrypted = Buffer22.concat(out);
        }
        var tag2 = key.match(startRegex)[1];
        return { tag: tag2, data: decrypted };
      };
    });
    require_parse_asn1 = __commonJS2((exports, module) => {
      var asn1 = require_asn12(), aesid = require_aesid(), fixProc = require_fixProc(), ciphers = require_browserify_aes(), compat = require_pbkdf2(), Buffer22 = require_safe_buffer().Buffer;
      function decrypt(data, password) {
        var salt = data.algorithm.decrypt.kde.kdeparams.salt, iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")], iv = data.algorithm.decrypt.cipher.iv, cipherText = data.subjectPrivateKey, keylen = parseInt(algo.split("-")[1], 10) / 8, key = compat.pbkdf2Sync(password, salt, iters, keylen, "sha1"), cipher = ciphers.createDecipheriv(algo, key, iv), out = [];
        return out.push(cipher.update(cipherText)), out.push(cipher.final()), Buffer22.concat(out);
      }
      function parseKeys(buffer4) {
        var password;
        if (typeof buffer4 === "object" && !Buffer22.isBuffer(buffer4))
          password = buffer4.passphrase, buffer4 = buffer4.key;
        if (typeof buffer4 === "string")
          buffer4 = Buffer22.from(buffer4);
        var stripped = fixProc(buffer4, password), type = stripped.tag, data = stripped.data, subtype, ndata;
        switch (type) {
          case "CERTIFICATE":
            ndata = asn1.certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
          case "PUBLIC KEY":
            if (!ndata)
              ndata = asn1.PublicKey.decode(data, "der");
            switch (subtype = ndata.algorithm.algorithm.join("."), subtype) {
              case "1.2.840.113549.1.1.1":
                return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
              case "1.2.840.10045.2.1":
                return ndata.subjectPrivateKey = ndata.subjectPublicKey, { type: "ec", data: ndata };
              case "1.2.840.10040.4.1":
                return ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, "der"), { type: "dsa", data: ndata.algorithm.params };
              default:
                throw new Error("unknown key id " + subtype);
            }
          case "ENCRYPTED PRIVATE KEY":
            data = asn1.EncryptedPrivateKey.decode(data, "der"), data = decrypt(data, password);
          case "PRIVATE KEY":
            switch (ndata = asn1.PrivateKey.decode(data, "der"), subtype = ndata.algorithm.algorithm.join("."), subtype) {
              case "1.2.840.113549.1.1.1":
                return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
              case "1.2.840.10045.2.1":
                return { curve: ndata.algorithm.curve, privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey };
              case "1.2.840.10040.4.1":
                return ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, "der"), { type: "dsa", params: ndata.algorithm.params };
              default:
                throw new Error("unknown key id " + subtype);
            }
          case "RSA PUBLIC KEY":
            return asn1.RSAPublicKey.decode(data, "der");
          case "RSA PRIVATE KEY":
            return asn1.RSAPrivateKey.decode(data, "der");
          case "DSA PRIVATE KEY":
            return { type: "dsa", params: asn1.DSAPrivateKey.decode(data, "der") };
          case "EC PRIVATE KEY":
            return data = asn1.ECPrivateKey.decode(data, "der"), { curve: data.parameters.value, privateKey: data.privateKey };
          default:
            throw new Error("unknown key type " + type);
        }
      }
      parseKeys.signature = asn1.signature;
      module.exports = parseKeys;
    });
    require_mgf = __commonJS2((exports, module) => {
      var createHash = require_create_hash(), Buffer22 = require_safe_buffer().Buffer;
      module.exports = function(seed, len2) {
        var t = Buffer22.alloc(0), i2 = 0, c;
        while (t.length < len2)
          c = i2ops(i2++), t = Buffer22.concat([t, createHash("sha1").update(seed).update(c).digest()]);
        return t.slice(0, len2);
      };
      function i2ops(c) {
        var out = Buffer22.allocUnsafe(4);
        return out.writeUInt32BE(c, 0), out;
      }
    });
    require_xor = __commonJS2((exports, module) => {
      module.exports = function xor(a, b) {
        var len2 = a.length, i2 = -1;
        while (++i2 < len2)
          a[i2] ^= b[i2];
        return a;
      };
    });
    require_bn4 = __commonJS2((exports, module) => {
      (function(module2, exports2) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {};
          TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
        }
        function BN(number4, base, endian) {
          if (BN.isBN(number4))
            return number4;
          if (this.negative = 0, this.words = null, this.length = 0, this.red = null, number4 !== null) {
            if (base === "le" || base === "be")
              endian = base, base = 10;
            this._init(number4 || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object")
          module2.exports = BN;
        else
          exports2.BN = BN;
        BN.BN = BN, BN.wordSize = 26;
        var Buffer22;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined")
            Buffer22 = window.Buffer;
          else
            Buffer22 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
        } catch (e) {}
        BN.isBN = function isBN(num) {
          if (num instanceof BN)
            return true;
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        }, BN.max = function max(left3, right3) {
          if (left3.cmp(right3) > 0)
            return left3;
          return right3;
        }, BN.min = function min(left3, right3) {
          if (left3.cmp(right3) < 0)
            return left3;
          return right3;
        }, BN.prototype._init = function init(number4, base, endian) {
          if (typeof number4 === "number")
            return this._initNumber(number4, base, endian);
          if (typeof number4 === "object")
            return this._initArray(number4, base, endian);
          if (base === "hex")
            base = 16;
          assert(base === (base | 0) && base >= 2 && base <= 36), number4 = number4.toString().replace(/\s+/g, "");
          var start4 = 0;
          if (number4[0] === "-")
            start4++, this.negative = 1;
          if (start4 < number4.length) {
            if (base === 16)
              this._parseHex(number4, start4, endian);
            else if (this._parseBase(number4, base, start4), endian === "le")
              this._initArray(this.toArray(), base, endian);
          }
        }, BN.prototype._initNumber = function _initNumber(number4, base, endian) {
          if (number4 < 0)
            this.negative = 1, number4 = -number4;
          if (number4 < 67108864)
            this.words = [number4 & 67108863], this.length = 1;
          else if (number4 < 4503599627370496)
            this.words = [number4 & 67108863, number4 / 67108864 & 67108863], this.length = 2;
          else
            assert(number4 < 9007199254740992), this.words = [number4 & 67108863, number4 / 67108864 & 67108863, 1], this.length = 3;
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        }, BN.prototype._initArray = function _initArray(number4, base, endian) {
          if (assert(typeof number4.length === "number"), number4.length <= 0)
            return this.words = [0], this.length = 1, this;
          this.length = Math.ceil(number4.length / 3), this.words = new Array(this.length);
          for (var i2 = 0;i2 < this.length; i2++)
            this.words[i2] = 0;
          var j, w, off = 0;
          if (endian === "be") {
            for (i2 = number4.length - 1, j = 0;i2 >= 0; i2 -= 3)
              if (w = number4[i2] | number4[i2 - 1] << 8 | number4[i2 - 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
                off -= 26, j++;
          } else if (endian === "le") {
            for (i2 = 0, j = 0;i2 < number4.length; i2 += 3)
              if (w = number4[i2] | number4[i2 + 1] << 8 | number4[i2 + 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
                off -= 26, j++;
          }
          return this.strip();
        };
        function parseHex4Bits(string3, index) {
          var c = string3.charCodeAt(index);
          if (c >= 65 && c <= 70)
            return c - 55;
          else if (c >= 97 && c <= 102)
            return c - 87;
          else
            return c - 48 & 15;
        }
        function parseHexByte(string3, lowerBound, index) {
          var r = parseHex4Bits(string3, index);
          if (index - 1 >= lowerBound)
            r |= parseHex4Bits(string3, index - 1) << 4;
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number4, start4, endian) {
          this.length = Math.ceil((number4.length - start4) / 6), this.words = new Array(this.length);
          for (var i2 = 0;i2 < this.length; i2++)
            this.words[i2] = 0;
          var off = 0, j = 0, w;
          if (endian === "be")
            for (i2 = number4.length - 1;i2 >= start4; i2 -= 2)
              if (w = parseHexByte(number4, start4, i2) << off, this.words[j] |= w & 67108863, off >= 18)
                off -= 18, j += 1, this.words[j] |= w >>> 26;
              else
                off += 8;
          else {
            var parseLength = number4.length - start4;
            for (i2 = parseLength % 2 === 0 ? start4 + 1 : start4;i2 < number4.length; i2 += 2)
              if (w = parseHexByte(number4, start4, i2) << off, this.words[j] |= w & 67108863, off >= 18)
                off -= 18, j += 1, this.words[j] |= w >>> 26;
              else
                off += 8;
          }
          this.strip();
        };
        function parseBase(str, start4, end6, mul) {
          var r = 0, len2 = Math.min(str.length, end6);
          for (var i2 = start4;i2 < len2; i2++) {
            var c = str.charCodeAt(i2) - 48;
            if (r *= mul, c >= 49)
              r += c - 49 + 10;
            else if (c >= 17)
              r += c - 17 + 10;
            else
              r += c;
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number4, base, start4) {
          this.words = [0], this.length = 1;
          for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base)
            limbLen++;
          limbLen--, limbPow = limbPow / base | 0;
          var total = number4.length - start4, mod = total % limbLen, end6 = Math.min(total, total - mod) + start4, word = 0;
          for (var i2 = start4;i2 < end6; i2 += limbLen)
            if (word = parseBase(number4, i2, i2 + limbLen, base), this.imuln(limbPow), this.words[0] + word < 67108864)
              this.words[0] += word;
            else
              this._iaddn(word);
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number4, i2, number4.length, base);
            for (i2 = 0;i2 < mod; i2++)
              pow *= base;
            if (this.imuln(pow), this.words[0] + word < 67108864)
              this.words[0] += word;
            else
              this._iaddn(word);
          }
          this.strip();
        }, BN.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i2 = 0;i2 < this.length; i2++)
            dest.words[i2] = this.words[i2];
          dest.length = this.length, dest.negative = this.negative, dest.red = this.red;
        }, BN.prototype.clone = function clone() {
          var r = new BN(null);
          return this.copy(r), r;
        }, BN.prototype._expand = function _expand(size13) {
          while (this.length < size13)
            this.words[this.length++] = 0;
          return this;
        }, BN.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0)
            this.length--;
          return this._normSign();
        }, BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0)
            this.negative = 0;
          return this;
        }, BN.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        if (BN.prototype.toString = function toString(base, padding) {
          base = base || 10, padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0, carry = 0;
            for (var i2 = 0;i2 < this.length; i2++) {
              var w = this.words[i2], word = ((w << off | carry) & 16777215).toString(16);
              if (carry = w >>> 24 - off & 16777215, off += 2, off >= 26)
                off -= 26, i2--;
              if (carry !== 0 || i2 !== this.length - 1)
                out = zeros[6 - word.length] + word + out;
              else
                out = word + out;
            }
            if (carry !== 0)
              out = carry.toString(16) + out;
            while (out.length % padding !== 0)
              out = "0" + out;
            if (this.negative !== 0)
              out = "-" + out;
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base], groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modn(groupBase).toString(base);
              if (c = c.idivn(groupBase), !c.isZero())
                out = zeros[groupSize - r.length] + r + out;
              else
                out = r + out;
            }
            if (this.isZero())
              out = "0" + out;
            while (out.length % padding !== 0)
              out = "0" + out;
            if (this.negative !== 0)
              out = "-" + out;
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        }, BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2)
            ret += this.words[1] * 67108864;
          else if (this.length === 3 && this.words[2] === 1)
            ret += 4503599627370496 + this.words[1] * 67108864;
          else if (this.length > 2)
            assert(false, "Number can only safely store up to 53 bits");
          return this.negative !== 0 ? -ret : ret;
        }, BN.prototype.toJSON = function toJSON() {
          return this.toString(16);
        }, BN.prototype.toBuffer = function toBuffer(endian, length3) {
          return assert(typeof Buffer22 !== "undefined"), this.toArrayLike(Buffer22, endian, length3);
        }, BN.prototype.toArray = function toArray(endian, length3) {
          return this.toArrayLike(Array, endian, length3);
        }, BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length3) {
          var byteLength2 = this.byteLength(), reqLength = length3 || Math.max(1, byteLength2);
          assert(byteLength2 <= reqLength, "byte array longer than desired length"), assert(reqLength > 0, "Requested array length <= 0"), this.strip();
          var littleEndian = endian === "le", res = new ArrayType(reqLength), b, i2, q = this.clone();
          if (!littleEndian) {
            for (i2 = 0;i2 < reqLength - byteLength2; i2++)
              res[i2] = 0;
            for (i2 = 0;!q.isZero(); i2++)
              b = q.andln(255), q.iushrn(8), res[reqLength - i2 - 1] = b;
          } else {
            for (i2 = 0;!q.isZero(); i2++)
              b = q.andln(255), q.iushrn(8), res[i2] = b;
            for (;i2 < reqLength; i2++)
              res[i2] = 0;
          }
          return res;
        }, Math.clz32)
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        else
          BN.prototype._countBits = function _countBits(w) {
            var t = w, r = 0;
            if (t >= 4096)
              r += 13, t >>>= 13;
            if (t >= 64)
              r += 7, t >>>= 7;
            if (t >= 8)
              r += 4, t >>>= 4;
            if (t >= 2)
              r += 2, t >>>= 2;
            return r + t;
          };
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w, r = 0;
          if ((t & 8191) === 0)
            r += 13, t >>>= 13;
          if ((t & 127) === 0)
            r += 7, t >>>= 7;
          if ((t & 15) === 0)
            r += 4, t >>>= 4;
          if ((t & 3) === 0)
            r += 2, t >>>= 2;
          if ((t & 1) === 0)
            r++;
          return r;
        }, BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1], hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0;bit < w.length; bit++) {
            var off = bit / 26 | 0, wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var b = this._zeroBits(this.words[i2]);
            if (r += b, b !== 26)
              break;
          }
          return r;
        }, BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        }, BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0)
            return this.abs().inotn(width).iaddn(1);
          return this.clone();
        }, BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1))
            return this.notn(width).iaddn(1).ineg();
          return this.clone();
        }, BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        }, BN.prototype.neg = function neg() {
          return this.clone().ineg();
        }, BN.prototype.ineg = function ineg() {
          if (!this.isZero())
            this.negative ^= 1;
          return this;
        }, BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length)
            this.words[this.length++] = 0;
          for (var i2 = 0;i2 < num.length; i2++)
            this.words[i2] = this.words[i2] | num.words[i2];
          return this.strip();
        }, BN.prototype.ior = function ior(num) {
          return assert((this.negative | num.negative) === 0), this.iuor(num);
        }, BN.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        }, BN.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        }, BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length)
            b = num;
          else
            b = this;
          for (var i2 = 0;i2 < b.length; i2++)
            this.words[i2] = this.words[i2] & num.words[i2];
          return this.length = b.length, this.strip();
        }, BN.prototype.iand = function iand(num) {
          return assert((this.negative | num.negative) === 0), this.iuand(num);
        }, BN.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        }, BN.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        }, BN.prototype.iuxor = function iuxor(num) {
          var a, b;
          if (this.length > num.length)
            a = this, b = num;
          else
            a = num, b = this;
          for (var i2 = 0;i2 < b.length; i2++)
            this.words[i2] = a.words[i2] ^ b.words[i2];
          if (this !== a)
            for (;i2 < a.length; i2++)
              this.words[i2] = a.words[i2];
          return this.length = a.length, this.strip();
        }, BN.prototype.ixor = function ixor(num) {
          return assert((this.negative | num.negative) === 0), this.iuxor(num);
        }, BN.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        }, BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        }, BN.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0, bitsLeft = width % 26;
          if (this._expand(bytesNeeded), bitsLeft > 0)
            bytesNeeded--;
          for (var i2 = 0;i2 < bytesNeeded; i2++)
            this.words[i2] = ~this.words[i2] & 67108863;
          if (bitsLeft > 0)
            this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
          return this.strip();
        }, BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        }, BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0, wbit = bit % 26;
          if (this._expand(off + 1), val)
            this.words[off] = this.words[off] | 1 << wbit;
          else
            this.words[off] = this.words[off] & ~(1 << wbit);
          return this.strip();
        }, BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0)
            return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();
          else if (this.negative === 0 && num.negative !== 0)
            return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();
          var a, b;
          if (this.length > num.length)
            a = this, b = num;
          else
            a = num, b = this;
          var carry = 0;
          for (var i2 = 0;i2 < b.length; i2++)
            r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
          for (;carry !== 0 && i2 < a.length; i2++)
            r = (a.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
          if (this.length = a.length, carry !== 0)
            this.words[this.length] = carry, this.length++;
          else if (a !== this)
            for (;i2 < a.length; i2++)
              this.words[i2] = a.words[i2];
          return this;
        }, BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0)
            return num.negative = 0, res = this.sub(num), num.negative ^= 1, res;
          else if (num.negative === 0 && this.negative !== 0)
            return this.negative = 0, res = num.sub(this), this.negative = 1, res;
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        }, BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            return num.negative = 1, r._normSign();
          } else if (this.negative !== 0)
            return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();
          var cmp = this.cmp(num);
          if (cmp === 0)
            return this.negative = 0, this.length = 1, this.words[0] = 0, this;
          var a, b;
          if (cmp > 0)
            a = this, b = num;
          else
            a = num, b = this;
          var carry = 0;
          for (var i2 = 0;i2 < b.length; i2++)
            r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
          for (;carry !== 0 && i2 < a.length; i2++)
            r = (a.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
          if (carry === 0 && i2 < a.length && a !== this)
            for (;i2 < a.length; i2++)
              this.words[i2] = a.words[i2];
          if (this.length = Math.max(this.length, i2), a !== this)
            this.negative = 1;
          return this.strip();
        }, BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len2 = self2.length + num.length | 0;
          out.length = len2, len2 = len2 - 1 | 0;
          var a = self2.words[0] | 0, b = num.words[0] | 0, r = a * b, lo = r & 67108863, carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1;k < len2; k++) {
            var ncarry = carry >>> 26, rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
              var i2 = k - j | 0;
              a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b + rword, ncarry += r / 67108864 | 0, rword = r & 67108863;
            }
            out.words[k] = rword | 0, carry = ncarry | 0;
          }
          if (carry !== 0)
            out.words[k] = carry | 0;
          else
            out.length--;
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo(self2, num, out) {
          var a = self2.words, b = num.words, o = out.words, c = 0, lo, mid, hi, a0 = a[0] | 0, al0 = a0 & 8191, ah0 = a0 >>> 13, a1 = a[1] | 0, al1 = a1 & 8191, ah1 = a1 >>> 13, a2 = a[2] | 0, al2 = a2 & 8191, ah2 = a2 >>> 13, a3 = a[3] | 0, al3 = a3 & 8191, ah3 = a3 >>> 13, a4 = a[4] | 0, al4 = a4 & 8191, ah4 = a4 >>> 13, a5 = a[5] | 0, al5 = a5 & 8191, ah5 = a5 >>> 13, a6 = a[6] | 0, al6 = a6 & 8191, ah6 = a6 >>> 13, a7 = a[7] | 0, al7 = a7 & 8191, ah7 = a7 >>> 13, a8 = a[8] | 0, al8 = a8 & 8191, ah8 = a8 >>> 13, a9 = a[9] | 0, al9 = a9 & 8191, ah9 = a9 >>> 13, b0 = b[0] | 0, bl0 = b0 & 8191, bh0 = b0 >>> 13, b1 = b[1] | 0, bl1 = b1 & 8191, bh1 = b1 >>> 13, b2 = b[2] | 0, bl2 = b2 & 8191, bh2 = b2 >>> 13, b3 = b[3] | 0, bl3 = b3 & 8191, bh3 = b3 >>> 13, b4 = b[4] | 0, bl4 = b4 & 8191, bh4 = b4 >>> 13, b5 = b[5] | 0, bl5 = b5 & 8191, bh5 = b5 >>> 13, b6 = b[6] | 0, bl6 = b6 & 8191, bh6 = b6 >>> 13, b7 = b[7] | 0, bl7 = b7 & 8191, bh7 = b7 >>> 13, b8 = b[8] | 0, bl8 = b8 & 8191, bh8 = b8 >>> 13, b9 = b[9] | 0, bl9 = b9 & 8191, bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative, out.length = 19, lo = Math.imul(al0, bl0), mid = Math.imul(al0, bh0), mid = mid + Math.imul(ah0, bl0) | 0, hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, lo = Math.imul(al1, bl0), mid = Math.imul(al1, bh0), mid = mid + Math.imul(ah1, bl0) | 0, hi = Math.imul(ah1, bh0), lo = lo + Math.imul(al0, bl1) | 0, mid = mid + Math.imul(al0, bh1) | 0, mid = mid + Math.imul(ah0, bl1) | 0, hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 67108863, lo = Math.imul(al2, bl0), mid = Math.imul(al2, bh0), mid = mid + Math.imul(ah2, bl0) | 0, hi = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = mid + Math.imul(al1, bh1) | 0, mid = mid + Math.imul(ah1, bl1) | 0, hi = hi + Math.imul(ah1, bh1) | 0, lo = lo + Math.imul(al0, bl2) | 0, mid = mid + Math.imul(al0, bh2) | 0, mid = mid + Math.imul(ah0, bl2) | 0, hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 67108863, lo = Math.imul(al3, bl0), mid = Math.imul(al3, bh0), mid = mid + Math.imul(ah3, bl0) | 0, hi = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = mid + Math.imul(al2, bh1) | 0, mid = mid + Math.imul(ah2, bl1) | 0, hi = hi + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = mid + Math.imul(al1, bh2) | 0, mid = mid + Math.imul(ah1, bl2) | 0, hi = hi + Math.imul(ah1, bh2) | 0, lo = lo + Math.imul(al0, bl3) | 0, mid = mid + Math.imul(al0, bh3) | 0, mid = mid + Math.imul(ah0, bl3) | 0, hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 67108863, lo = Math.imul(al4, bl0), mid = Math.imul(al4, bh0), mid = mid + Math.imul(ah4, bl0) | 0, hi = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = mid + Math.imul(al3, bh1) | 0, mid = mid + Math.imul(ah3, bl1) | 0, hi = hi + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = mid + Math.imul(al2, bh2) | 0, mid = mid + Math.imul(ah2, bl2) | 0, hi = hi + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = mid + Math.imul(al1, bh3) | 0, mid = mid + Math.imul(ah1, bl3) | 0, hi = hi + Math.imul(ah1, bh3) | 0, lo = lo + Math.imul(al0, bl4) | 0, mid = mid + Math.imul(al0, bh4) | 0, mid = mid + Math.imul(ah0, bl4) | 0, hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 67108863, lo = Math.imul(al5, bl0), mid = Math.imul(al5, bh0), mid = mid + Math.imul(ah5, bl0) | 0, hi = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = mid + Math.imul(al4, bh1) | 0, mid = mid + Math.imul(ah4, bl1) | 0, hi = hi + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = mid + Math.imul(al3, bh2) | 0, mid = mid + Math.imul(ah3, bl2) | 0, hi = hi + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = mid + Math.imul(al2, bh3) | 0, mid = mid + Math.imul(ah2, bl3) | 0, hi = hi + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = mid + Math.imul(al1, bh4) | 0, mid = mid + Math.imul(ah1, bl4) | 0, hi = hi + Math.imul(ah1, bh4) | 0, lo = lo + Math.imul(al0, bl5) | 0, mid = mid + Math.imul(al0, bh5) | 0, mid = mid + Math.imul(ah0, bl5) | 0, hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 67108863, lo = Math.imul(al6, bl0), mid = Math.imul(al6, bh0), mid = mid + Math.imul(ah6, bl0) | 0, hi = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = mid + Math.imul(al5, bh1) | 0, mid = mid + Math.imul(ah5, bl1) | 0, hi = hi + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = mid + Math.imul(al4, bh2) | 0, mid = mid + Math.imul(ah4, bl2) | 0, hi = hi + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = mid + Math.imul(al3, bh3) | 0, mid = mid + Math.imul(ah3, bl3) | 0, hi = hi + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = mid + Math.imul(al2, bh4) | 0, mid = mid + Math.imul(ah2, bl4) | 0, hi = hi + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = mid + Math.imul(al1, bh5) | 0, mid = mid + Math.imul(ah1, bl5) | 0, hi = hi + Math.imul(ah1, bh5) | 0, lo = lo + Math.imul(al0, bl6) | 0, mid = mid + Math.imul(al0, bh6) | 0, mid = mid + Math.imul(ah0, bl6) | 0, hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 67108863, lo = Math.imul(al7, bl0), mid = Math.imul(al7, bh0), mid = mid + Math.imul(ah7, bl0) | 0, hi = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = mid + Math.imul(al6, bh1) | 0, mid = mid + Math.imul(ah6, bl1) | 0, hi = hi + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = mid + Math.imul(al5, bh2) | 0, mid = mid + Math.imul(ah5, bl2) | 0, hi = hi + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = mid + Math.imul(al4, bh3) | 0, mid = mid + Math.imul(ah4, bl3) | 0, hi = hi + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = mid + Math.imul(al3, bh4) | 0, mid = mid + Math.imul(ah3, bl4) | 0, hi = hi + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = mid + Math.imul(al2, bh5) | 0, mid = mid + Math.imul(ah2, bl5) | 0, hi = hi + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = mid + Math.imul(al1, bh6) | 0, mid = mid + Math.imul(ah1, bl6) | 0, hi = hi + Math.imul(ah1, bh6) | 0, lo = lo + Math.imul(al0, bl7) | 0, mid = mid + Math.imul(al0, bh7) | 0, mid = mid + Math.imul(ah0, bl7) | 0, hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 67108863, lo = Math.imul(al8, bl0), mid = Math.imul(al8, bh0), mid = mid + Math.imul(ah8, bl0) | 0, hi = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = mid + Math.imul(al7, bh1) | 0, mid = mid + Math.imul(ah7, bl1) | 0, hi = hi + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = mid + Math.imul(al6, bh2) | 0, mid = mid + Math.imul(ah6, bl2) | 0, hi = hi + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = mid + Math.imul(al5, bh3) | 0, mid = mid + Math.imul(ah5, bl3) | 0, hi = hi + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = mid + Math.imul(al4, bh4) | 0, mid = mid + Math.imul(ah4, bl4) | 0, hi = hi + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = mid + Math.imul(al3, bh5) | 0, mid = mid + Math.imul(ah3, bl5) | 0, hi = hi + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = mid + Math.imul(al2, bh6) | 0, mid = mid + Math.imul(ah2, bl6) | 0, hi = hi + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = mid + Math.imul(al1, bh7) | 0, mid = mid + Math.imul(ah1, bl7) | 0, hi = hi + Math.imul(ah1, bh7) | 0, lo = lo + Math.imul(al0, bl8) | 0, mid = mid + Math.imul(al0, bh8) | 0, mid = mid + Math.imul(ah0, bl8) | 0, hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, lo = Math.imul(al9, bl0), mid = Math.imul(al9, bh0), mid = mid + Math.imul(ah9, bl0) | 0, hi = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = mid + Math.imul(al8, bh1) | 0, mid = mid + Math.imul(ah8, bl1) | 0, hi = hi + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = mid + Math.imul(al7, bh2) | 0, mid = mid + Math.imul(ah7, bl2) | 0, hi = hi + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = mid + Math.imul(al6, bh3) | 0, mid = mid + Math.imul(ah6, bl3) | 0, hi = hi + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = mid + Math.imul(al5, bh4) | 0, mid = mid + Math.imul(ah5, bl4) | 0, hi = hi + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = mid + Math.imul(al4, bh5) | 0, mid = mid + Math.imul(ah4, bl5) | 0, hi = hi + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = mid + Math.imul(al3, bh6) | 0, mid = mid + Math.imul(ah3, bl6) | 0, hi = hi + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = mid + Math.imul(al2, bh7) | 0, mid = mid + Math.imul(ah2, bl7) | 0, hi = hi + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = mid + Math.imul(al1, bh8) | 0, mid = mid + Math.imul(ah1, bl8) | 0, hi = hi + Math.imul(ah1, bh8) | 0, lo = lo + Math.imul(al0, bl9) | 0, mid = mid + Math.imul(al0, bh9) | 0, mid = mid + Math.imul(ah0, bl9) | 0, hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 67108863, lo = Math.imul(al9, bl1), mid = Math.imul(al9, bh1), mid = mid + Math.imul(ah9, bl1) | 0, hi = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = mid + Math.imul(al8, bh2) | 0, mid = mid + Math.imul(ah8, bl2) | 0, hi = hi + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = mid + Math.imul(al7, bh3) | 0, mid = mid + Math.imul(ah7, bl3) | 0, hi = hi + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = mid + Math.imul(al6, bh4) | 0, mid = mid + Math.imul(ah6, bl4) | 0, hi = hi + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = mid + Math.imul(al5, bh5) | 0, mid = mid + Math.imul(ah5, bl5) | 0, hi = hi + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = mid + Math.imul(al4, bh6) | 0, mid = mid + Math.imul(ah4, bl6) | 0, hi = hi + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = mid + Math.imul(al3, bh7) | 0, mid = mid + Math.imul(ah3, bl7) | 0, hi = hi + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = mid + Math.imul(al2, bh8) | 0, mid = mid + Math.imul(ah2, bl8) | 0, hi = hi + Math.imul(ah2, bh8) | 0, lo = lo + Math.imul(al1, bl9) | 0, mid = mid + Math.imul(al1, bh9) | 0, mid = mid + Math.imul(ah1, bl9) | 0, hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 67108863, lo = Math.imul(al9, bl2), mid = Math.imul(al9, bh2), mid = mid + Math.imul(ah9, bl2) | 0, hi = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = mid + Math.imul(al8, bh3) | 0, mid = mid + Math.imul(ah8, bl3) | 0, hi = hi + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = mid + Math.imul(al7, bh4) | 0, mid = mid + Math.imul(ah7, bl4) | 0, hi = hi + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = mid + Math.imul(al6, bh5) | 0, mid = mid + Math.imul(ah6, bl5) | 0, hi = hi + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = mid + Math.imul(al5, bh6) | 0, mid = mid + Math.imul(ah5, bl6) | 0, hi = hi + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = mid + Math.imul(al4, bh7) | 0, mid = mid + Math.imul(ah4, bl7) | 0, hi = hi + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = mid + Math.imul(al3, bh8) | 0, mid = mid + Math.imul(ah3, bl8) | 0, hi = hi + Math.imul(ah3, bh8) | 0, lo = lo + Math.imul(al2, bl9) | 0, mid = mid + Math.imul(al2, bh9) | 0, mid = mid + Math.imul(ah2, bl9) | 0, hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 67108863, lo = Math.imul(al9, bl3), mid = Math.imul(al9, bh3), mid = mid + Math.imul(ah9, bl3) | 0, hi = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = mid + Math.imul(al8, bh4) | 0, mid = mid + Math.imul(ah8, bl4) | 0, hi = hi + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = mid + Math.imul(al7, bh5) | 0, mid = mid + Math.imul(ah7, bl5) | 0, hi = hi + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = mid + Math.imul(al6, bh6) | 0, mid = mid + Math.imul(ah6, bl6) | 0, hi = hi + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = mid + Math.imul(al5, bh7) | 0, mid = mid + Math.imul(ah5, bl7) | 0, hi = hi + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = mid + Math.imul(al4, bh8) | 0, mid = mid + Math.imul(ah4, bl8) | 0, hi = hi + Math.imul(ah4, bh8) | 0, lo = lo + Math.imul(al3, bl9) | 0, mid = mid + Math.imul(al3, bh9) | 0, mid = mid + Math.imul(ah3, bl9) | 0, hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 67108863, lo = Math.imul(al9, bl4), mid = Math.imul(al9, bh4), mid = mid + Math.imul(ah9, bl4) | 0, hi = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = mid + Math.imul(al8, bh5) | 0, mid = mid + Math.imul(ah8, bl5) | 0, hi = hi + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = mid + Math.imul(al7, bh6) | 0, mid = mid + Math.imul(ah7, bl6) | 0, hi = hi + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = mid + Math.imul(al6, bh7) | 0, mid = mid + Math.imul(ah6, bl7) | 0, hi = hi + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = mid + Math.imul(al5, bh8) | 0, mid = mid + Math.imul(ah5, bl8) | 0, hi = hi + Math.imul(ah5, bh8) | 0, lo = lo + Math.imul(al4, bl9) | 0, mid = mid + Math.imul(al4, bh9) | 0, mid = mid + Math.imul(ah4, bl9) | 0, hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 67108863, lo = Math.imul(al9, bl5), mid = Math.imul(al9, bh5), mid = mid + Math.imul(ah9, bl5) | 0, hi = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = mid + Math.imul(al8, bh6) | 0, mid = mid + Math.imul(ah8, bl6) | 0, hi = hi + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = mid + Math.imul(al7, bh7) | 0, mid = mid + Math.imul(ah7, bl7) | 0, hi = hi + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = mid + Math.imul(al6, bh8) | 0, mid = mid + Math.imul(ah6, bl8) | 0, hi = hi + Math.imul(ah6, bh8) | 0, lo = lo + Math.imul(al5, bl9) | 0, mid = mid + Math.imul(al5, bh9) | 0, mid = mid + Math.imul(ah5, bl9) | 0, hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 67108863, lo = Math.imul(al9, bl6), mid = Math.imul(al9, bh6), mid = mid + Math.imul(ah9, bl6) | 0, hi = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = mid + Math.imul(al8, bh7) | 0, mid = mid + Math.imul(ah8, bl7) | 0, hi = hi + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = mid + Math.imul(al7, bh8) | 0, mid = mid + Math.imul(ah7, bl8) | 0, hi = hi + Math.imul(ah7, bh8) | 0, lo = lo + Math.imul(al6, bl9) | 0, mid = mid + Math.imul(al6, bh9) | 0, mid = mid + Math.imul(ah6, bl9) | 0, hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 67108863, lo = Math.imul(al9, bl7), mid = Math.imul(al9, bh7), mid = mid + Math.imul(ah9, bl7) | 0, hi = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = mid + Math.imul(al8, bh8) | 0, mid = mid + Math.imul(ah8, bl8) | 0, hi = hi + Math.imul(ah8, bh8) | 0, lo = lo + Math.imul(al7, bl9) | 0, mid = mid + Math.imul(al7, bh9) | 0, mid = mid + Math.imul(ah7, bl9) | 0, hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 67108863, lo = Math.imul(al9, bl8), mid = Math.imul(al9, bh8), mid = mid + Math.imul(ah9, bl8) | 0, hi = Math.imul(ah9, bh8), lo = lo + Math.imul(al8, bl9) | 0, mid = mid + Math.imul(al8, bh9) | 0, mid = mid + Math.imul(ah8, bl9) | 0, hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 67108863, lo = Math.imul(al9, bl9), mid = Math.imul(al9, bh9), mid = mid + Math.imul(ah9, bl9) | 0, hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          if (c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, c !== 0)
            o[19] = c, out.length++;
          return out;
        };
        if (!Math.imul)
          comb10MulTo = smallMulTo;
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative, out.length = self2.length + num.length;
          var carry = 0, hncarry = 0;
          for (var k = 0;k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
              var i2 = k - j, a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b, lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0, lo = lo + rword | 0, rword = lo & 67108863, ncarry = ncarry + (lo >>> 26) | 0, hncarry += ncarry >>> 26, ncarry &= 67108863;
            }
            out.words[k] = rword, carry = ncarry, ncarry = hncarry;
          }
          if (carry !== 0)
            out.words[k] = carry;
          else
            out.length--;
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM;
          return fftm.mulp(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res, len2 = this.length + num.length;
          if (this.length === 10 && num.length === 10)
            res = comb10MulTo(this, num, out);
          else if (len2 < 63)
            res = smallMulTo(this, num, out);
          else if (len2 < 1024)
            res = bigMulTo(this, num, out);
          else
            res = jumboMulTo(this, num, out);
          return res;
        };
        function FFTM(x, y) {
          this.x = x, this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N), l = BN.prototype._countBits(N) - 1;
          for (var i2 = 0;i2 < N; i2++)
            t[i2] = this.revBin(i2, l, N);
          return t;
        }, FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i2 = 0;i2 < l; i2++)
            rb |= (x & 1) << l - i2 - 1, x >>= 1;
          return rb;
        }, FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i2 = 0;i2 < N; i2++)
            rtws[i2] = rws[rbt[i2]], itws[i2] = iws[rbt[i2]];
        }, FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1;s < N; s <<= 1) {
            var l = s << 1, rtwdf = Math.cos(2 * Math.PI / l), itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0;p < N; p += l) {
              var rtwdf_ = rtwdf, itwdf_ = itwdf;
              for (var j = 0;j < s; j++) {
                var re = rtws[p + j], ie = itws[p + j], ro = rtws[p + j + s], io = itws[p + j + s], rx = rtwdf_ * ro - itwdf_ * io;
                if (io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p + j] = re + ro, itws[p + j] = ie + io, rtws[p + j + s] = re - ro, itws[p + j + s] = ie - io, j !== l)
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx;
              }
            }
          }
        }, FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1, odd = N & 1, i2 = 0;
          for (N = N / 2 | 0;N; N = N >>> 1)
            i2++;
          return 1 << i2 + 1 + odd;
        }, FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i2 = 0;i2 < N / 2; i2++) {
            var t = rws[i2];
            rws[i2] = rws[N - i2 - 1], rws[N - i2 - 1] = t, t = iws[i2], iws[i2] = -iws[N - i2 - 1], iws[N - i2 - 1] = -t;
          }
        }, FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i2 = 0;i2 < N / 2; i2++) {
            var w = Math.round(ws[2 * i2 + 1] / N) * 8192 + Math.round(ws[2 * i2] / N) + carry;
            if (ws[i2] = w & 67108863, w < 67108864)
              carry = 0;
            else
              carry = w / 67108864 | 0;
          }
          return ws;
        }, FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N) {
          var carry = 0;
          for (var i2 = 0;i2 < len2; i2++)
            carry = carry + (ws[i2] | 0), rws[2 * i2] = carry & 8191, carry = carry >>> 13, rws[2 * i2 + 1] = carry & 8191, carry = carry >>> 13;
          for (i2 = 2 * len2;i2 < N; ++i2)
            rws[i2] = 0;
          assert(carry === 0), assert((carry & -8192) === 0);
        }, FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i2 = 0;i2 < N; i2++)
            ph[i2] = 0;
          return ph;
        }, FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length), rbt = this.makeRBT(N), _ = this.stub(N), rws = new Array(N), rwst = new Array(N), iwst = new Array(N), nrws = new Array(N), nrwst = new Array(N), niwst = new Array(N), rmws = out.words;
          rmws.length = N, this.convert13b(x.words, x.length, rws, N), this.convert13b(y.words, y.length, nrws, N), this.transform(rws, _, rwst, iwst, N, rbt), this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i2 = 0;i2 < N; i2++) {
            var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
            iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2], rwst[i2] = rx;
          }
          return this.conjugate(rwst, iwst, N), this.transform(rwst, iwst, rmws, _, N, rbt), this.conjugate(rmws, _, N), this.normalize13b(rmws, N), out.negative = x.negative ^ y.negative, out.length = x.length + y.length, out.strip();
        }, BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          return out.words = new Array(this.length + num.length), this.mulTo(num, out);
        }, BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);
        }, BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        }, BN.prototype.imuln = function imuln(num) {
          assert(typeof num === "number"), assert(num < 67108864);
          var carry = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var w = (this.words[i2] | 0) * num, lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i2] = lo & 67108863;
          }
          if (carry !== 0)
            this.words[i2] = carry, this.length++;
          return this.length = num === 0 ? 1 : this.length, this;
        }, BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        }, BN.prototype.sqr = function sqr() {
          return this.mul(this);
        }, BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        }, BN.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN(1);
          var res = this;
          for (var i2 = 0;i2 < w.length; i2++, res = res.sqr())
            if (w[i2] !== 0)
              break;
          if (++i2 < w.length)
            for (var q = res.sqr();i2 < w.length; i2++, q = q.sqr()) {
              if (w[i2] === 0)
                continue;
              res = res.mul(q);
            }
          return res;
        }, BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26, s = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r, i2;
          if (r !== 0) {
            var carry = 0;
            for (i2 = 0;i2 < this.length; i2++) {
              var newCarry = this.words[i2] & carryMask, c = (this.words[i2] | 0) - newCarry << r;
              this.words[i2] = c | carry, carry = newCarry >>> 26 - r;
            }
            if (carry)
              this.words[i2] = carry, this.length++;
          }
          if (s !== 0) {
            for (i2 = this.length - 1;i2 >= 0; i2--)
              this.words[i2 + s] = this.words[i2];
            for (i2 = 0;i2 < s; i2++)
              this.words[i2] = 0;
            this.length += s;
          }
          return this.strip();
        }, BN.prototype.ishln = function ishln(bits) {
          return assert(this.negative === 0), this.iushln(bits);
        }, BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint)
            h = (hint - hint % 26) / 26;
          else
            h = 0;
          var r = bits % 26, s = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;
          if (h -= s, h = Math.max(0, h), maskedWords) {
            for (var i2 = 0;i2 < s; i2++)
              maskedWords.words[i2] = this.words[i2];
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i2 = 0;i2 < this.length; i2++)
              this.words[i2] = this.words[i2 + s];
          } else
            this.words[0] = 0, this.length = 1;
          var carry = 0;
          for (i2 = this.length - 1;i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
            var word = this.words[i2] | 0;
            this.words[i2] = carry << 26 - r | word >>> r, carry = word & mask;
          }
          if (maskedWords && carry !== 0)
            maskedWords.words[maskedWords.length++] = carry;
          if (this.length === 0)
            this.words[0] = 0, this.length = 1;
          return this.strip();
        }, BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          return assert(this.negative === 0), this.iushrn(bits, hint, extended);
        }, BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        }, BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        }, BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        }, BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        }, BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        }, BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26, s = (bits - r) / 26;
          if (assert(this.negative === 0, "imaskn works only with positive numbers"), this.length <= s)
            return this;
          if (r !== 0)
            s++;
          if (this.length = Math.min(s, this.length), r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        }, BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        }, BN.prototype.iaddn = function iaddn(num) {
          if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num)
              return this.words[0] = num - (this.words[0] | 0), this.negative = 0, this;
            return this.negative = 0, this.isubn(num), this.negative = 1, this;
          }
          return this._iaddn(num);
        }, BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i2 = 0;i2 < this.length && this.words[i2] >= 67108864; i2++)
            if (this.words[i2] -= 67108864, i2 === this.length - 1)
              this.words[i2 + 1] = 1;
            else
              this.words[i2 + 1]++;
          return this.length = Math.max(this.length, i2 + 1), this;
        }, BN.prototype.isubn = function isubn(num) {
          if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0)
            return this.negative = 0, this.iaddn(num), this.negative = 1, this;
          if (this.words[0] -= num, this.length === 1 && this.words[0] < 0)
            this.words[0] = -this.words[0], this.negative = 1;
          else
            for (var i2 = 0;i2 < this.length && this.words[i2] < 0; i2++)
              this.words[i2] += 67108864, this.words[i2 + 1] -= 1;
          return this.strip();
        }, BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        }, BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        }, BN.prototype.iabs = function iabs() {
          return this.negative = 0, this;
        }, BN.prototype.abs = function abs() {
          return this.clone().iabs();
        }, BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift2) {
          var len2 = num.length + shift2, i2;
          this._expand(len2);
          var w, carry = 0;
          for (i2 = 0;i2 < num.length; i2++) {
            w = (this.words[i2 + shift2] | 0) + carry;
            var right3 = (num.words[i2] | 0) * mul;
            w -= right3 & 67108863, carry = (w >> 26) - (right3 / 67108864 | 0), this.words[i2 + shift2] = w & 67108863;
          }
          for (;i2 < this.length - shift2; i2++)
            w = (this.words[i2 + shift2] | 0) + carry, carry = w >> 26, this.words[i2 + shift2] = w & 67108863;
          if (carry === 0)
            return this.strip();
          assert(carry === -1), carry = 0;
          for (i2 = 0;i2 < this.length; i2++)
            w = -(this.words[i2] | 0) + carry, carry = w >> 26, this.words[i2] = w & 67108863;
          return this.negative = 1, this.strip();
        }, BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift2 = this.length - num.length, a = this.clone(), b = num, bhi = b.words[b.length - 1] | 0, bhiBits = this._countBits(bhi);
          if (shift2 = 26 - bhiBits, shift2 !== 0)
            b = b.ushln(shift2), a.iushln(shift2), bhi = b.words[b.length - 1] | 0;
          var m = a.length - b.length, q;
          if (mode !== "mod") {
            q = new BN(null), q.length = m + 1, q.words = new Array(q.length);
            for (var i2 = 0;i2 < q.length; i2++)
              q.words[i2] = 0;
          }
          var diff8 = a.clone()._ishlnsubmul(b, 1, m);
          if (diff8.negative === 0) {
            if (a = diff8, q)
              q.words[m] = 1;
          }
          for (var j = m - 1;j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0)
              if (qj--, a.negative = 0, a._ishlnsubmul(b, 1, j), !a.isZero())
                a.negative ^= 1;
            if (q)
              q.words[j] = qj;
          }
          if (q)
            q.strip();
          if (a.strip(), mode !== "div" && shift2 !== 0)
            a.iushrn(shift2);
          return { div: q || null, mod: a };
        }, BN.prototype.divmod = function divmod(num, mode, positive2) {
          if (assert(!num.isZero()), this.isZero())
            return { div: new BN(0), mod: new BN(0) };
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            if (res = this.neg().divmod(num, mode), mode !== "mod")
              div = res.div.neg();
            if (mode !== "div") {
              if (mod = res.mod.neg(), positive2 && mod.negative !== 0)
                mod.iadd(num);
            }
            return { div, mod };
          }
          if (this.negative === 0 && num.negative !== 0) {
            if (res = this.divmod(num.neg(), mode), mode !== "mod")
              div = res.div.neg();
            return { div, mod: res.mod };
          }
          if ((this.negative & num.negative) !== 0) {
            if (res = this.neg().divmod(num.neg(), mode), mode !== "div") {
              if (mod = res.mod.neg(), positive2 && mod.negative !== 0)
                mod.isub(num);
            }
            return { div: res.div, mod };
          }
          if (num.length > this.length || this.cmp(num) < 0)
            return { div: new BN(0), mod: this };
          if (num.length === 1) {
            if (mode === "div")
              return { div: this.divn(num.words[0]), mod: null };
            if (mode === "mod")
              return { div: null, mod: new BN(this.modn(num.words[0])) };
            return { div: this.divn(num.words[0]), mod: new BN(this.modn(num.words[0])) };
          }
          return this._wordDiv(num, mode);
        }, BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        }, BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        }, BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        }, BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        }, BN.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = 67108864 % num, acc = 0;
          for (var i2 = this.length - 1;i2 >= 0; i2--)
            acc = (p * acc + (this.words[i2] | 0)) % num;
          return acc;
        }, BN.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i2 = this.length - 1;i2 >= 0; i2--) {
            var w = (this.words[i2] | 0) + carry * 67108864;
            this.words[i2] = w / num | 0, carry = w % num;
          }
          return this.strip();
        }, BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        }, BN.prototype.egcd = function egcd(p) {
          assert(p.negative === 0), assert(!p.isZero());
          var x = this, y = p.clone();
          if (x.negative !== 0)
            x = x.umod(p);
          else
            x = x.clone();
          var A = new BN(1), B = new BN(0), C = new BN(0), D = new BN(1), g = 0;
          while (x.isEven() && y.isEven())
            x.iushrn(1), y.iushrn(1), ++g;
          var yp = y.clone(), xp = x.clone();
          while (!x.isZero()) {
            for (var i2 = 0, im = 1;(x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
              ;
            if (i2 > 0) {
              x.iushrn(i2);
              while (i2-- > 0) {
                if (A.isOdd() || B.isOdd())
                  A.iadd(yp), B.isub(xp);
                A.iushrn(1), B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd())
                  C.iadd(yp), D.isub(xp);
                C.iushrn(1), D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0)
              x.isub(y), A.isub(C), B.isub(D);
            else
              y.isub(x), C.isub(A), D.isub(B);
          }
          return { a: C, b: D, gcd: y.iushln(g) };
        }, BN.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0), assert(!p.isZero());
          var a = this, b = p.clone();
          if (a.negative !== 0)
            a = a.umod(p);
          else
            a = a.clone();
          var x1 = new BN(1), x2 = new BN(0), delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i2 = 0, im = 1;(a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
              ;
            if (i2 > 0) {
              a.iushrn(i2);
              while (i2-- > 0) {
                if (x1.isOdd())
                  x1.iadd(delta);
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1;(b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd())
                  x2.iadd(delta);
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0)
              a.isub(b), x1.isub(x2);
            else
              b.isub(a), x2.isub(x1);
          }
          var res;
          if (a.cmpn(1) === 0)
            res = x1;
          else
            res = x2;
          if (res.cmpn(0) < 0)
            res.iadd(p);
          return res;
        }, BN.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone(), b = num.clone();
          a.negative = 0, b.negative = 0;
          for (var shift2 = 0;a.isEven() && b.isEven(); shift2++)
            a.iushrn(1), b.iushrn(1);
          do {
            while (a.isEven())
              a.iushrn(1);
            while (b.isEven())
              b.iushrn(1);
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b, b = t;
            } else if (r === 0 || b.cmpn(1) === 0)
              break;
            a.isub(b);
          } while (true);
          return b.iushln(shift2);
        }, BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        }, BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        }, BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        }, BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        }, BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
          if (this.length <= s)
            return this._expand(s + 1), this.words[s] |= q, this;
          var carry = q;
          for (var i2 = s;carry !== 0 && i2 < this.length; i2++) {
            var w = this.words[i2] | 0;
            w += carry, carry = w >>> 26, w &= 67108863, this.words[i2] = w;
          }
          if (carry !== 0)
            this.words[i2] = carry, this.length++;
          return this;
        }, BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        }, BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1)
            res = 1;
          else {
            if (negative)
              num = -num;
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        }, BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        }, BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i2 = this.length - 1;i2 >= 0; i2--) {
            var a = this.words[i2] | 0, b = num.words[i2] | 0;
            if (a === b)
              continue;
            if (a < b)
              res = -1;
            else if (a > b)
              res = 1;
            break;
          }
          return res;
        }, BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        }, BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        }, BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        }, BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        }, BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        }, BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        }, BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        }, BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        }, BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        }, BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        }, BN.red = function red(num) {
          return new Red(num);
        }, BN.prototype.toRed = function toRed(ctx) {
          return assert(!this.red, "Already a number in reduction context"), assert(this.negative === 0, "red works only with positives"), ctx.convertTo(this)._forceRed(ctx);
        }, BN.prototype.fromRed = function fromRed() {
          return assert(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
        }, BN.prototype._forceRed = function _forceRed(ctx) {
          return this.red = ctx, this;
        }, BN.prototype.forceRed = function forceRed(ctx) {
          return assert(!this.red, "Already a number in reduction context"), this._forceRed(ctx);
        }, BN.prototype.redAdd = function redAdd(num) {
          return assert(this.red, "redAdd works only with red numbers"), this.red.add(this, num);
        }, BN.prototype.redIAdd = function redIAdd(num) {
          return assert(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, num);
        }, BN.prototype.redSub = function redSub(num) {
          return assert(this.red, "redSub works only with red numbers"), this.red.sub(this, num);
        }, BN.prototype.redISub = function redISub(num) {
          return assert(this.red, "redISub works only with red numbers"), this.red.isub(this, num);
        }, BN.prototype.redShl = function redShl(num) {
          return assert(this.red, "redShl works only with red numbers"), this.red.shl(this, num);
        }, BN.prototype.redMul = function redMul(num) {
          return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.mul(this, num);
        }, BN.prototype.redIMul = function redIMul(num) {
          return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.imul(this, num);
        }, BN.prototype.redSqr = function redSqr() {
          return assert(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
        }, BN.prototype.redISqr = function redISqr() {
          return assert(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
        }, BN.prototype.redSqrt = function redSqrt() {
          return assert(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
        }, BN.prototype.redInvm = function redInvm() {
          return assert(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
        }, BN.prototype.redNeg = function redNeg() {
          return assert(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
        }, BN.prototype.redPow = function redPow(num) {
          return assert(this.red && !num.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, num);
        };
        var primes = { k256: null, p224: null, p192: null, p25519: null };
        function MPrime(name, p) {
          this.name = name, this.p = new BN(p, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;
        }, MPrime.prototype.ireduce = function ireduce(num) {
          var r = num, rlen;
          do
            this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), rlen = r.bitLength();
          while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0)
            r.words[0] = 0, r.length = 1;
          else if (cmp > 0)
            r.isub(this.p);
          else if (r.strip !== undefined)
            r.strip();
          else
            r._strip();
          return r;
        }, MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        }, MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        inherits2(K256, MPrime), K256.prototype.split = function split(input, output) {
          var mask = 4194303, outLen = Math.min(input.length, 9);
          for (var i2 = 0;i2 < outLen; i2++)
            output.words[i2] = input.words[i2];
          if (output.length = outLen, input.length <= 9) {
            input.words[0] = 0, input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i2 = 10;i2 < input.length; i2++) {
            var next = input.words[i2] | 0;
            input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22, prev = next;
          }
          if (prev >>>= 22, input.words[i2 - 10] = prev, prev === 0 && input.length > 10)
            input.length -= 10;
          else
            input.length -= 9;
        }, K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;
          var lo = 0;
          for (var i2 = 0;i2 < num.length; i2++) {
            var w = num.words[i2] | 0;
            lo += w * 977, num.words[i2] = lo & 67108863, lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            if (num.length--, num.words[num.length - 1] === 0)
              num.length--;
          }
          return num;
        };
        function P224() {
          MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        inherits2(P224, MPrime);
        function P192() {
          MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        inherits2(P192, MPrime);
        function P25519() {
          MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        inherits2(P25519, MPrime), P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i2 = 0;i2 < num.length; i2++) {
            var hi = (num.words[i2] | 0) * 19 + carry, lo = hi & 67108863;
            hi >>>= 26, num.words[i2] = lo, carry = hi;
          }
          if (carry !== 0)
            num.words[num.length++] = carry;
          return num;
        }, BN._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime;
          if (name === "k256")
            prime = new K256;
          else if (name === "p224")
            prime = new P224;
          else if (name === "p192")
            prime = new P192;
          else if (name === "p25519")
            prime = new P25519;
          else
            throw new Error("Unknown prime " + name);
          return primes[name] = prime, prime;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p, this.prime = prime;
          } else
            assert(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives"), assert(a.red, "red works only with red numbers");
        }, Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives"), assert(a.red && a.red === b.red, "red works only with red numbers");
        }, Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        }, Red.prototype.neg = function neg(a) {
          if (a.isZero())
            return a.clone();
          return this.m.sub(a)._forceRed(this);
        }, Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0)
            res.isub(this.m);
          return res._forceRed(this);
        }, Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0)
            res.isub(this.m);
          return res;
        }, Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0)
            res.iadd(this.m);
          return res._forceRed(this);
        }, Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0)
            res.iadd(this.m);
          return res;
        }, Red.prototype.shl = function shl(a, num) {
          return this._verify1(a), this.imod(a.ushln(num));
        }, Red.prototype.imul = function imul(a, b) {
          return this._verify2(a, b), this.imod(a.imul(b));
        }, Red.prototype.mul = function mul(a, b) {
          return this._verify2(a, b), this.imod(a.mul(b));
        }, Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        }, Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        }, Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          if (assert(mod3 % 2 === 1), mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1), s = 0;
          while (!q.isZero() && q.andln(1) === 0)
            s++, q.iushrn(1);
          assert(!q.isZero());
          var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0)
            z.redIAdd(nOne);
          var c = this.pow(z, q), r = this.pow(a, q.addn(1).iushrn(1)), t = this.pow(a, q), m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i2 = 0;tmp.cmp(one) !== 0; i2++)
              tmp = tmp.redSqr();
            assert(i2 < m);
            var b = this.pow(c, new BN(1).iushln(m - i2 - 1));
            r = r.redMul(b), c = b.redSqr(), t = t.redMul(c), m = i2;
          }
          return r;
        }, Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0)
            return inv.negative = 0, this.imod(inv).redNeg();
          else
            return this.imod(inv);
        }, Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4, wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this), wnd[1] = a;
          for (var i2 = 2;i2 < wnd.length; i2++)
            wnd[i2] = this.mul(wnd[i2 - 1], a);
          var res = wnd[0], current2 = 0, currentLen = 0, start4 = num.bitLength() % 26;
          if (start4 === 0)
            start4 = 26;
          for (i2 = num.length - 1;i2 >= 0; i2--) {
            var word = num.words[i2];
            for (var j = start4 - 1;j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0])
                res = this.sqr(res);
              if (bit === 0 && current2 === 0) {
                currentLen = 0;
                continue;
              }
              if (current2 <<= 1, current2 |= bit, currentLen++, currentLen !== windowSize && (i2 !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current2]), currentLen = 0, current2 = 0;
            }
            start4 = 26;
          }
          return res;
        }, Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        }, Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          return res.red = null, res;
        }, BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          if (Red.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 !== 0)
            this.shift += 26 - this.shift % 26;
          this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
        }
        inherits2(Mont, Red), Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        }, Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          return r.red = null, r;
        }, Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero())
            return a.words[0] = 0, a.length = 1, a;
          var t = a.imul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;
          if (u.cmp(this.m) >= 0)
            res = u.isub(this.m);
          else if (u.cmpn(0) < 0)
            res = u.iadd(this.m);
          return res._forceRed(this);
        }, Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN(0)._forceRed(this);
          var t = a.mul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;
          if (u.cmp(this.m) >= 0)
            res = u.isub(this.m);
          else if (u.cmpn(0) < 0)
            res = u.iadd(this.m);
          return res._forceRed(this);
        }, Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    });
    require_withPublic = __commonJS2((exports, module) => {
      var BN = require_bn4(), Buffer22 = require_safe_buffer().Buffer;
      function withPublic(paddedMsg, key) {
        return Buffer22.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());
      }
      module.exports = withPublic;
    });
    require_bn5 = __commonJS2((exports, module) => {
      (function(module2, exports2) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {};
          TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
        }
        function BN(number4, base, endian) {
          if (BN.isBN(number4))
            return number4;
          if (this.negative = 0, this.words = null, this.length = 0, this.red = null, number4 !== null) {
            if (base === "le" || base === "be")
              endian = base, base = 10;
            this._init(number4 || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object")
          module2.exports = BN;
        else
          exports2.BN = BN;
        BN.BN = BN, BN.wordSize = 26;
        var Buffer22;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined")
            Buffer22 = window.Buffer;
          else
            Buffer22 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
        } catch (e) {}
        BN.isBN = function isBN(num) {
          if (num instanceof BN)
            return true;
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        }, BN.max = function max(left3, right3) {
          if (left3.cmp(right3) > 0)
            return left3;
          return right3;
        }, BN.min = function min(left3, right3) {
          if (left3.cmp(right3) < 0)
            return left3;
          return right3;
        }, BN.prototype._init = function init(number4, base, endian) {
          if (typeof number4 === "number")
            return this._initNumber(number4, base, endian);
          if (typeof number4 === "object")
            return this._initArray(number4, base, endian);
          if (base === "hex")
            base = 16;
          assert(base === (base | 0) && base >= 2 && base <= 36), number4 = number4.toString().replace(/\s+/g, "");
          var start4 = 0;
          if (number4[0] === "-")
            start4++, this.negative = 1;
          if (start4 < number4.length) {
            if (base === 16)
              this._parseHex(number4, start4, endian);
            else if (this._parseBase(number4, base, start4), endian === "le")
              this._initArray(this.toArray(), base, endian);
          }
        }, BN.prototype._initNumber = function _initNumber(number4, base, endian) {
          if (number4 < 0)
            this.negative = 1, number4 = -number4;
          if (number4 < 67108864)
            this.words = [number4 & 67108863], this.length = 1;
          else if (number4 < 4503599627370496)
            this.words = [number4 & 67108863, number4 / 67108864 & 67108863], this.length = 2;
          else
            assert(number4 < 9007199254740992), this.words = [number4 & 67108863, number4 / 67108864 & 67108863, 1], this.length = 3;
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        }, BN.prototype._initArray = function _initArray(number4, base, endian) {
          if (assert(typeof number4.length === "number"), number4.length <= 0)
            return this.words = [0], this.length = 1, this;
          this.length = Math.ceil(number4.length / 3), this.words = new Array(this.length);
          for (var i2 = 0;i2 < this.length; i2++)
            this.words[i2] = 0;
          var j, w, off = 0;
          if (endian === "be") {
            for (i2 = number4.length - 1, j = 0;i2 >= 0; i2 -= 3)
              if (w = number4[i2] | number4[i2 - 1] << 8 | number4[i2 - 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
                off -= 26, j++;
          } else if (endian === "le") {
            for (i2 = 0, j = 0;i2 < number4.length; i2 += 3)
              if (w = number4[i2] | number4[i2 + 1] << 8 | number4[i2 + 2] << 16, this.words[j] |= w << off & 67108863, this.words[j + 1] = w >>> 26 - off & 67108863, off += 24, off >= 26)
                off -= 26, j++;
          }
          return this._strip();
        };
        function parseHex4Bits(string3, index) {
          var c = string3.charCodeAt(index);
          if (c >= 48 && c <= 57)
            return c - 48;
          else if (c >= 65 && c <= 70)
            return c - 55;
          else if (c >= 97 && c <= 102)
            return c - 87;
          else
            assert(false, "Invalid character in " + string3);
        }
        function parseHexByte(string3, lowerBound, index) {
          var r = parseHex4Bits(string3, index);
          if (index - 1 >= lowerBound)
            r |= parseHex4Bits(string3, index - 1) << 4;
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number4, start4, endian) {
          this.length = Math.ceil((number4.length - start4) / 6), this.words = new Array(this.length);
          for (var i2 = 0;i2 < this.length; i2++)
            this.words[i2] = 0;
          var off = 0, j = 0, w;
          if (endian === "be")
            for (i2 = number4.length - 1;i2 >= start4; i2 -= 2)
              if (w = parseHexByte(number4, start4, i2) << off, this.words[j] |= w & 67108863, off >= 18)
                off -= 18, j += 1, this.words[j] |= w >>> 26;
              else
                off += 8;
          else {
            var parseLength = number4.length - start4;
            for (i2 = parseLength % 2 === 0 ? start4 + 1 : start4;i2 < number4.length; i2 += 2)
              if (w = parseHexByte(number4, start4, i2) << off, this.words[j] |= w & 67108863, off >= 18)
                off -= 18, j += 1, this.words[j] |= w >>> 26;
              else
                off += 8;
          }
          this._strip();
        };
        function parseBase(str, start4, end6, mul) {
          var r = 0, b = 0, len2 = Math.min(str.length, end6);
          for (var i2 = start4;i2 < len2; i2++) {
            var c = str.charCodeAt(i2) - 48;
            if (r *= mul, c >= 49)
              b = c - 49 + 10;
            else if (c >= 17)
              b = c - 17 + 10;
            else
              b = c;
            assert(c >= 0 && b < mul, "Invalid character"), r += b;
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number4, base, start4) {
          this.words = [0], this.length = 1;
          for (var limbLen = 0, limbPow = 1;limbPow <= 67108863; limbPow *= base)
            limbLen++;
          limbLen--, limbPow = limbPow / base | 0;
          var total = number4.length - start4, mod = total % limbLen, end6 = Math.min(total, total - mod) + start4, word = 0;
          for (var i2 = start4;i2 < end6; i2 += limbLen)
            if (word = parseBase(number4, i2, i2 + limbLen, base), this.imuln(limbPow), this.words[0] + word < 67108864)
              this.words[0] += word;
            else
              this._iaddn(word);
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number4, i2, number4.length, base);
            for (i2 = 0;i2 < mod; i2++)
              pow *= base;
            if (this.imuln(pow), this.words[0] + word < 67108864)
              this.words[0] += word;
            else
              this._iaddn(word);
          }
          this._strip();
        }, BN.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i2 = 0;i2 < this.length; i2++)
            dest.words[i2] = this.words[i2];
          dest.length = this.length, dest.negative = this.negative, dest.red = this.red;
        };
        function move(dest, src) {
          dest.words = src.words, dest.length = src.length, dest.negative = src.negative, dest.red = src.red;
        }
        if (BN.prototype._move = function _move(dest) {
          move(dest, this);
        }, BN.prototype.clone = function clone() {
          var r = new BN(null);
          return this.copy(r), r;
        }, BN.prototype._expand = function _expand(size13) {
          while (this.length < size13)
            this.words[this.length++] = 0;
          return this;
        }, BN.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0)
            this.length--;
          return this._normSign();
        }, BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0)
            this.negative = 0;
          return this;
        }, typeof Symbol !== "undefined" && typeof Symbol.for === "function")
          try {
            BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect3;
          } catch (e) {
            BN.prototype.inspect = inspect3;
          }
        else
          BN.prototype.inspect = inspect3;
        function inspect3() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        if (BN.prototype.toString = function toString(base, padding) {
          base = base || 10, padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0, carry = 0;
            for (var i2 = 0;i2 < this.length; i2++) {
              var w = this.words[i2], word = ((w << off | carry) & 16777215).toString(16);
              if (carry = w >>> 24 - off & 16777215, off += 2, off >= 26)
                off -= 26, i2--;
              if (carry !== 0 || i2 !== this.length - 1)
                out = zeros[6 - word.length] + word + out;
              else
                out = word + out;
            }
            if (carry !== 0)
              out = carry.toString(16) + out;
            while (out.length % padding !== 0)
              out = "0" + out;
            if (this.negative !== 0)
              out = "-" + out;
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base], groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modrn(groupBase).toString(base);
              if (c = c.idivn(groupBase), !c.isZero())
                out = zeros[groupSize - r.length] + r + out;
              else
                out = r + out;
            }
            if (this.isZero())
              out = "0" + out;
            while (out.length % padding !== 0)
              out = "0" + out;
            if (this.negative !== 0)
              out = "-" + out;
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        }, BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2)
            ret += this.words[1] * 67108864;
          else if (this.length === 3 && this.words[2] === 1)
            ret += 4503599627370496 + this.words[1] * 67108864;
          else if (this.length > 2)
            assert(false, "Number can only safely store up to 53 bits");
          return this.negative !== 0 ? -ret : ret;
        }, BN.prototype.toJSON = function toJSON() {
          return this.toString(16, 2);
        }, Buffer22)
          BN.prototype.toBuffer = function toBuffer(endian, length3) {
            return this.toArrayLike(Buffer22, endian, length3);
          };
        BN.prototype.toArray = function toArray(endian, length3) {
          return this.toArrayLike(Array, endian, length3);
        };
        var allocate2 = function allocate(ArrayType, size13) {
          if (ArrayType.allocUnsafe)
            return ArrayType.allocUnsafe(size13);
          return new ArrayType(size13);
        };
        if (BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length3) {
          this._strip();
          var byteLength2 = this.byteLength(), reqLength = length3 || Math.max(1, byteLength2);
          assert(byteLength2 <= reqLength, "byte array longer than desired length"), assert(reqLength > 0, "Requested array length <= 0");
          var res = allocate2(ArrayType, reqLength), postfix = endian === "le" ? "LE" : "BE";
          return this["_toArrayLike" + postfix](res, byteLength2), res;
        }, BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
          var position = 0, carry = 0;
          for (var i2 = 0, shift2 = 0;i2 < this.length; i2++) {
            var word = this.words[i2] << shift2 | carry;
            if (res[position++] = word & 255, position < res.length)
              res[position++] = word >> 8 & 255;
            if (position < res.length)
              res[position++] = word >> 16 & 255;
            if (shift2 === 6) {
              if (position < res.length)
                res[position++] = word >> 24 & 255;
              carry = 0, shift2 = 0;
            } else
              carry = word >>> 24, shift2 += 2;
          }
          if (position < res.length) {
            res[position++] = carry;
            while (position < res.length)
              res[position++] = 0;
          }
        }, BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
          var position = res.length - 1, carry = 0;
          for (var i2 = 0, shift2 = 0;i2 < this.length; i2++) {
            var word = this.words[i2] << shift2 | carry;
            if (res[position--] = word & 255, position >= 0)
              res[position--] = word >> 8 & 255;
            if (position >= 0)
              res[position--] = word >> 16 & 255;
            if (shift2 === 6) {
              if (position >= 0)
                res[position--] = word >> 24 & 255;
              carry = 0, shift2 = 0;
            } else
              carry = word >>> 24, shift2 += 2;
          }
          if (position >= 0) {
            res[position--] = carry;
            while (position >= 0)
              res[position--] = 0;
          }
        }, Math.clz32)
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        else
          BN.prototype._countBits = function _countBits(w) {
            var t = w, r = 0;
            if (t >= 4096)
              r += 13, t >>>= 13;
            if (t >= 64)
              r += 7, t >>>= 7;
            if (t >= 8)
              r += 4, t >>>= 4;
            if (t >= 2)
              r += 2, t >>>= 2;
            return r + t;
          };
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w, r = 0;
          if ((t & 8191) === 0)
            r += 13, t >>>= 13;
          if ((t & 127) === 0)
            r += 7, t >>>= 7;
          if ((t & 15) === 0)
            r += 4, t >>>= 4;
          if ((t & 3) === 0)
            r += 2, t >>>= 2;
          if ((t & 1) === 0)
            r++;
          return r;
        }, BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1], hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0;bit < w.length; bit++) {
            var off = bit / 26 | 0, wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 1;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var b = this._zeroBits(this.words[i2]);
            if (r += b, b !== 26)
              break;
          }
          return r;
        }, BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        }, BN.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0)
            return this.abs().inotn(width).iaddn(1);
          return this.clone();
        }, BN.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1))
            return this.notn(width).iaddn(1).ineg();
          return this.clone();
        }, BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        }, BN.prototype.neg = function neg() {
          return this.clone().ineg();
        }, BN.prototype.ineg = function ineg() {
          if (!this.isZero())
            this.negative ^= 1;
          return this;
        }, BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length)
            this.words[this.length++] = 0;
          for (var i2 = 0;i2 < num.length; i2++)
            this.words[i2] = this.words[i2] | num.words[i2];
          return this._strip();
        }, BN.prototype.ior = function ior(num) {
          return assert((this.negative | num.negative) === 0), this.iuor(num);
        }, BN.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        }, BN.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        }, BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length)
            b = num;
          else
            b = this;
          for (var i2 = 0;i2 < b.length; i2++)
            this.words[i2] = this.words[i2] & num.words[i2];
          return this.length = b.length, this._strip();
        }, BN.prototype.iand = function iand(num) {
          return assert((this.negative | num.negative) === 0), this.iuand(num);
        }, BN.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        }, BN.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        }, BN.prototype.iuxor = function iuxor(num) {
          var a, b;
          if (this.length > num.length)
            a = this, b = num;
          else
            a = num, b = this;
          for (var i2 = 0;i2 < b.length; i2++)
            this.words[i2] = a.words[i2] ^ b.words[i2];
          if (this !== a)
            for (;i2 < a.length; i2++)
              this.words[i2] = a.words[i2];
          return this.length = a.length, this._strip();
        }, BN.prototype.ixor = function ixor(num) {
          return assert((this.negative | num.negative) === 0), this.iuxor(num);
        }, BN.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        }, BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        }, BN.prototype.inotn = function inotn(width) {
          assert(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0, bitsLeft = width % 26;
          if (this._expand(bytesNeeded), bitsLeft > 0)
            bytesNeeded--;
          for (var i2 = 0;i2 < bytesNeeded; i2++)
            this.words[i2] = ~this.words[i2] & 67108863;
          if (bitsLeft > 0)
            this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
          return this._strip();
        }, BN.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        }, BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0, wbit = bit % 26;
          if (this._expand(off + 1), val)
            this.words[off] = this.words[off] | 1 << wbit;
          else
            this.words[off] = this.words[off] & ~(1 << wbit);
          return this._strip();
        }, BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0)
            return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();
          else if (this.negative === 0 && num.negative !== 0)
            return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();
          var a, b;
          if (this.length > num.length)
            a = this, b = num;
          else
            a = num, b = this;
          var carry = 0;
          for (var i2 = 0;i2 < b.length; i2++)
            r = (a.words[i2] | 0) + (b.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
          for (;carry !== 0 && i2 < a.length; i2++)
            r = (a.words[i2] | 0) + carry, this.words[i2] = r & 67108863, carry = r >>> 26;
          if (this.length = a.length, carry !== 0)
            this.words[this.length] = carry, this.length++;
          else if (a !== this)
            for (;i2 < a.length; i2++)
              this.words[i2] = a.words[i2];
          return this;
        }, BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0)
            return num.negative = 0, res = this.sub(num), num.negative ^= 1, res;
          else if (num.negative === 0 && this.negative !== 0)
            return this.negative = 0, res = num.sub(this), this.negative = 1, res;
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        }, BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            return num.negative = 1, r._normSign();
          } else if (this.negative !== 0)
            return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();
          var cmp = this.cmp(num);
          if (cmp === 0)
            return this.negative = 0, this.length = 1, this.words[0] = 0, this;
          var a, b;
          if (cmp > 0)
            a = this, b = num;
          else
            a = num, b = this;
          var carry = 0;
          for (var i2 = 0;i2 < b.length; i2++)
            r = (a.words[i2] | 0) - (b.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
          for (;carry !== 0 && i2 < a.length; i2++)
            r = (a.words[i2] | 0) + carry, carry = r >> 26, this.words[i2] = r & 67108863;
          if (carry === 0 && i2 < a.length && a !== this)
            for (;i2 < a.length; i2++)
              this.words[i2] = a.words[i2];
          if (this.length = Math.max(this.length, i2), a !== this)
            this.negative = 1;
          return this._strip();
        }, BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len2 = self2.length + num.length | 0;
          out.length = len2, len2 = len2 - 1 | 0;
          var a = self2.words[0] | 0, b = num.words[0] | 0, r = a * b, lo = r & 67108863, carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1;k < len2; k++) {
            var ncarry = carry >>> 26, rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
              var i2 = k - j | 0;
              a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b + rword, ncarry += r / 67108864 | 0, rword = r & 67108863;
            }
            out.words[k] = rword | 0, carry = ncarry | 0;
          }
          if (carry !== 0)
            out.words[k] = carry | 0;
          else
            out.length--;
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo(self2, num, out) {
          var a = self2.words, b = num.words, o = out.words, c = 0, lo, mid, hi, a0 = a[0] | 0, al0 = a0 & 8191, ah0 = a0 >>> 13, a1 = a[1] | 0, al1 = a1 & 8191, ah1 = a1 >>> 13, a2 = a[2] | 0, al2 = a2 & 8191, ah2 = a2 >>> 13, a3 = a[3] | 0, al3 = a3 & 8191, ah3 = a3 >>> 13, a4 = a[4] | 0, al4 = a4 & 8191, ah4 = a4 >>> 13, a5 = a[5] | 0, al5 = a5 & 8191, ah5 = a5 >>> 13, a6 = a[6] | 0, al6 = a6 & 8191, ah6 = a6 >>> 13, a7 = a[7] | 0, al7 = a7 & 8191, ah7 = a7 >>> 13, a8 = a[8] | 0, al8 = a8 & 8191, ah8 = a8 >>> 13, a9 = a[9] | 0, al9 = a9 & 8191, ah9 = a9 >>> 13, b0 = b[0] | 0, bl0 = b0 & 8191, bh0 = b0 >>> 13, b1 = b[1] | 0, bl1 = b1 & 8191, bh1 = b1 >>> 13, b2 = b[2] | 0, bl2 = b2 & 8191, bh2 = b2 >>> 13, b3 = b[3] | 0, bl3 = b3 & 8191, bh3 = b3 >>> 13, b4 = b[4] | 0, bl4 = b4 & 8191, bh4 = b4 >>> 13, b5 = b[5] | 0, bl5 = b5 & 8191, bh5 = b5 >>> 13, b6 = b[6] | 0, bl6 = b6 & 8191, bh6 = b6 >>> 13, b7 = b[7] | 0, bl7 = b7 & 8191, bh7 = b7 >>> 13, b8 = b[8] | 0, bl8 = b8 & 8191, bh8 = b8 >>> 13, b9 = b[9] | 0, bl9 = b9 & 8191, bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative, out.length = 19, lo = Math.imul(al0, bl0), mid = Math.imul(al0, bh0), mid = mid + Math.imul(ah0, bl0) | 0, hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0, w0 &= 67108863, lo = Math.imul(al1, bl0), mid = Math.imul(al1, bh0), mid = mid + Math.imul(ah1, bl0) | 0, hi = Math.imul(ah1, bh0), lo = lo + Math.imul(al0, bl1) | 0, mid = mid + Math.imul(al0, bh1) | 0, mid = mid + Math.imul(ah0, bl1) | 0, hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0, w1 &= 67108863, lo = Math.imul(al2, bl0), mid = Math.imul(al2, bh0), mid = mid + Math.imul(ah2, bl0) | 0, hi = Math.imul(ah2, bh0), lo = lo + Math.imul(al1, bl1) | 0, mid = mid + Math.imul(al1, bh1) | 0, mid = mid + Math.imul(ah1, bl1) | 0, hi = hi + Math.imul(ah1, bh1) | 0, lo = lo + Math.imul(al0, bl2) | 0, mid = mid + Math.imul(al0, bh2) | 0, mid = mid + Math.imul(ah0, bl2) | 0, hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0, w2 &= 67108863, lo = Math.imul(al3, bl0), mid = Math.imul(al3, bh0), mid = mid + Math.imul(ah3, bl0) | 0, hi = Math.imul(ah3, bh0), lo = lo + Math.imul(al2, bl1) | 0, mid = mid + Math.imul(al2, bh1) | 0, mid = mid + Math.imul(ah2, bl1) | 0, hi = hi + Math.imul(ah2, bh1) | 0, lo = lo + Math.imul(al1, bl2) | 0, mid = mid + Math.imul(al1, bh2) | 0, mid = mid + Math.imul(ah1, bl2) | 0, hi = hi + Math.imul(ah1, bh2) | 0, lo = lo + Math.imul(al0, bl3) | 0, mid = mid + Math.imul(al0, bh3) | 0, mid = mid + Math.imul(ah0, bl3) | 0, hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0, w3 &= 67108863, lo = Math.imul(al4, bl0), mid = Math.imul(al4, bh0), mid = mid + Math.imul(ah4, bl0) | 0, hi = Math.imul(ah4, bh0), lo = lo + Math.imul(al3, bl1) | 0, mid = mid + Math.imul(al3, bh1) | 0, mid = mid + Math.imul(ah3, bl1) | 0, hi = hi + Math.imul(ah3, bh1) | 0, lo = lo + Math.imul(al2, bl2) | 0, mid = mid + Math.imul(al2, bh2) | 0, mid = mid + Math.imul(ah2, bl2) | 0, hi = hi + Math.imul(ah2, bh2) | 0, lo = lo + Math.imul(al1, bl3) | 0, mid = mid + Math.imul(al1, bh3) | 0, mid = mid + Math.imul(ah1, bl3) | 0, hi = hi + Math.imul(ah1, bh3) | 0, lo = lo + Math.imul(al0, bl4) | 0, mid = mid + Math.imul(al0, bh4) | 0, mid = mid + Math.imul(ah0, bl4) | 0, hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0, w4 &= 67108863, lo = Math.imul(al5, bl0), mid = Math.imul(al5, bh0), mid = mid + Math.imul(ah5, bl0) | 0, hi = Math.imul(ah5, bh0), lo = lo + Math.imul(al4, bl1) | 0, mid = mid + Math.imul(al4, bh1) | 0, mid = mid + Math.imul(ah4, bl1) | 0, hi = hi + Math.imul(ah4, bh1) | 0, lo = lo + Math.imul(al3, bl2) | 0, mid = mid + Math.imul(al3, bh2) | 0, mid = mid + Math.imul(ah3, bl2) | 0, hi = hi + Math.imul(ah3, bh2) | 0, lo = lo + Math.imul(al2, bl3) | 0, mid = mid + Math.imul(al2, bh3) | 0, mid = mid + Math.imul(ah2, bl3) | 0, hi = hi + Math.imul(ah2, bh3) | 0, lo = lo + Math.imul(al1, bl4) | 0, mid = mid + Math.imul(al1, bh4) | 0, mid = mid + Math.imul(ah1, bl4) | 0, hi = hi + Math.imul(ah1, bh4) | 0, lo = lo + Math.imul(al0, bl5) | 0, mid = mid + Math.imul(al0, bh5) | 0, mid = mid + Math.imul(ah0, bl5) | 0, hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0, w5 &= 67108863, lo = Math.imul(al6, bl0), mid = Math.imul(al6, bh0), mid = mid + Math.imul(ah6, bl0) | 0, hi = Math.imul(ah6, bh0), lo = lo + Math.imul(al5, bl1) | 0, mid = mid + Math.imul(al5, bh1) | 0, mid = mid + Math.imul(ah5, bl1) | 0, hi = hi + Math.imul(ah5, bh1) | 0, lo = lo + Math.imul(al4, bl2) | 0, mid = mid + Math.imul(al4, bh2) | 0, mid = mid + Math.imul(ah4, bl2) | 0, hi = hi + Math.imul(ah4, bh2) | 0, lo = lo + Math.imul(al3, bl3) | 0, mid = mid + Math.imul(al3, bh3) | 0, mid = mid + Math.imul(ah3, bl3) | 0, hi = hi + Math.imul(ah3, bh3) | 0, lo = lo + Math.imul(al2, bl4) | 0, mid = mid + Math.imul(al2, bh4) | 0, mid = mid + Math.imul(ah2, bl4) | 0, hi = hi + Math.imul(ah2, bh4) | 0, lo = lo + Math.imul(al1, bl5) | 0, mid = mid + Math.imul(al1, bh5) | 0, mid = mid + Math.imul(ah1, bl5) | 0, hi = hi + Math.imul(ah1, bh5) | 0, lo = lo + Math.imul(al0, bl6) | 0, mid = mid + Math.imul(al0, bh6) | 0, mid = mid + Math.imul(ah0, bl6) | 0, hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0, w6 &= 67108863, lo = Math.imul(al7, bl0), mid = Math.imul(al7, bh0), mid = mid + Math.imul(ah7, bl0) | 0, hi = Math.imul(ah7, bh0), lo = lo + Math.imul(al6, bl1) | 0, mid = mid + Math.imul(al6, bh1) | 0, mid = mid + Math.imul(ah6, bl1) | 0, hi = hi + Math.imul(ah6, bh1) | 0, lo = lo + Math.imul(al5, bl2) | 0, mid = mid + Math.imul(al5, bh2) | 0, mid = mid + Math.imul(ah5, bl2) | 0, hi = hi + Math.imul(ah5, bh2) | 0, lo = lo + Math.imul(al4, bl3) | 0, mid = mid + Math.imul(al4, bh3) | 0, mid = mid + Math.imul(ah4, bl3) | 0, hi = hi + Math.imul(ah4, bh3) | 0, lo = lo + Math.imul(al3, bl4) | 0, mid = mid + Math.imul(al3, bh4) | 0, mid = mid + Math.imul(ah3, bl4) | 0, hi = hi + Math.imul(ah3, bh4) | 0, lo = lo + Math.imul(al2, bl5) | 0, mid = mid + Math.imul(al2, bh5) | 0, mid = mid + Math.imul(ah2, bl5) | 0, hi = hi + Math.imul(ah2, bh5) | 0, lo = lo + Math.imul(al1, bl6) | 0, mid = mid + Math.imul(al1, bh6) | 0, mid = mid + Math.imul(ah1, bl6) | 0, hi = hi + Math.imul(ah1, bh6) | 0, lo = lo + Math.imul(al0, bl7) | 0, mid = mid + Math.imul(al0, bh7) | 0, mid = mid + Math.imul(ah0, bl7) | 0, hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0, w7 &= 67108863, lo = Math.imul(al8, bl0), mid = Math.imul(al8, bh0), mid = mid + Math.imul(ah8, bl0) | 0, hi = Math.imul(ah8, bh0), lo = lo + Math.imul(al7, bl1) | 0, mid = mid + Math.imul(al7, bh1) | 0, mid = mid + Math.imul(ah7, bl1) | 0, hi = hi + Math.imul(ah7, bh1) | 0, lo = lo + Math.imul(al6, bl2) | 0, mid = mid + Math.imul(al6, bh2) | 0, mid = mid + Math.imul(ah6, bl2) | 0, hi = hi + Math.imul(ah6, bh2) | 0, lo = lo + Math.imul(al5, bl3) | 0, mid = mid + Math.imul(al5, bh3) | 0, mid = mid + Math.imul(ah5, bl3) | 0, hi = hi + Math.imul(ah5, bh3) | 0, lo = lo + Math.imul(al4, bl4) | 0, mid = mid + Math.imul(al4, bh4) | 0, mid = mid + Math.imul(ah4, bl4) | 0, hi = hi + Math.imul(ah4, bh4) | 0, lo = lo + Math.imul(al3, bl5) | 0, mid = mid + Math.imul(al3, bh5) | 0, mid = mid + Math.imul(ah3, bl5) | 0, hi = hi + Math.imul(ah3, bh5) | 0, lo = lo + Math.imul(al2, bl6) | 0, mid = mid + Math.imul(al2, bh6) | 0, mid = mid + Math.imul(ah2, bl6) | 0, hi = hi + Math.imul(ah2, bh6) | 0, lo = lo + Math.imul(al1, bl7) | 0, mid = mid + Math.imul(al1, bh7) | 0, mid = mid + Math.imul(ah1, bl7) | 0, hi = hi + Math.imul(ah1, bh7) | 0, lo = lo + Math.imul(al0, bl8) | 0, mid = mid + Math.imul(al0, bh8) | 0, mid = mid + Math.imul(ah0, bl8) | 0, hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0, w8 &= 67108863, lo = Math.imul(al9, bl0), mid = Math.imul(al9, bh0), mid = mid + Math.imul(ah9, bl0) | 0, hi = Math.imul(ah9, bh0), lo = lo + Math.imul(al8, bl1) | 0, mid = mid + Math.imul(al8, bh1) | 0, mid = mid + Math.imul(ah8, bl1) | 0, hi = hi + Math.imul(ah8, bh1) | 0, lo = lo + Math.imul(al7, bl2) | 0, mid = mid + Math.imul(al7, bh2) | 0, mid = mid + Math.imul(ah7, bl2) | 0, hi = hi + Math.imul(ah7, bh2) | 0, lo = lo + Math.imul(al6, bl3) | 0, mid = mid + Math.imul(al6, bh3) | 0, mid = mid + Math.imul(ah6, bl3) | 0, hi = hi + Math.imul(ah6, bh3) | 0, lo = lo + Math.imul(al5, bl4) | 0, mid = mid + Math.imul(al5, bh4) | 0, mid = mid + Math.imul(ah5, bl4) | 0, hi = hi + Math.imul(ah5, bh4) | 0, lo = lo + Math.imul(al4, bl5) | 0, mid = mid + Math.imul(al4, bh5) | 0, mid = mid + Math.imul(ah4, bl5) | 0, hi = hi + Math.imul(ah4, bh5) | 0, lo = lo + Math.imul(al3, bl6) | 0, mid = mid + Math.imul(al3, bh6) | 0, mid = mid + Math.imul(ah3, bl6) | 0, hi = hi + Math.imul(ah3, bh6) | 0, lo = lo + Math.imul(al2, bl7) | 0, mid = mid + Math.imul(al2, bh7) | 0, mid = mid + Math.imul(ah2, bl7) | 0, hi = hi + Math.imul(ah2, bh7) | 0, lo = lo + Math.imul(al1, bl8) | 0, mid = mid + Math.imul(al1, bh8) | 0, mid = mid + Math.imul(ah1, bl8) | 0, hi = hi + Math.imul(ah1, bh8) | 0, lo = lo + Math.imul(al0, bl9) | 0, mid = mid + Math.imul(al0, bh9) | 0, mid = mid + Math.imul(ah0, bl9) | 0, hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0, w9 &= 67108863, lo = Math.imul(al9, bl1), mid = Math.imul(al9, bh1), mid = mid + Math.imul(ah9, bl1) | 0, hi = Math.imul(ah9, bh1), lo = lo + Math.imul(al8, bl2) | 0, mid = mid + Math.imul(al8, bh2) | 0, mid = mid + Math.imul(ah8, bl2) | 0, hi = hi + Math.imul(ah8, bh2) | 0, lo = lo + Math.imul(al7, bl3) | 0, mid = mid + Math.imul(al7, bh3) | 0, mid = mid + Math.imul(ah7, bl3) | 0, hi = hi + Math.imul(ah7, bh3) | 0, lo = lo + Math.imul(al6, bl4) | 0, mid = mid + Math.imul(al6, bh4) | 0, mid = mid + Math.imul(ah6, bl4) | 0, hi = hi + Math.imul(ah6, bh4) | 0, lo = lo + Math.imul(al5, bl5) | 0, mid = mid + Math.imul(al5, bh5) | 0, mid = mid + Math.imul(ah5, bl5) | 0, hi = hi + Math.imul(ah5, bh5) | 0, lo = lo + Math.imul(al4, bl6) | 0, mid = mid + Math.imul(al4, bh6) | 0, mid = mid + Math.imul(ah4, bl6) | 0, hi = hi + Math.imul(ah4, bh6) | 0, lo = lo + Math.imul(al3, bl7) | 0, mid = mid + Math.imul(al3, bh7) | 0, mid = mid + Math.imul(ah3, bl7) | 0, hi = hi + Math.imul(ah3, bh7) | 0, lo = lo + Math.imul(al2, bl8) | 0, mid = mid + Math.imul(al2, bh8) | 0, mid = mid + Math.imul(ah2, bl8) | 0, hi = hi + Math.imul(ah2, bh8) | 0, lo = lo + Math.imul(al1, bl9) | 0, mid = mid + Math.imul(al1, bh9) | 0, mid = mid + Math.imul(ah1, bl9) | 0, hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0, w10 &= 67108863, lo = Math.imul(al9, bl2), mid = Math.imul(al9, bh2), mid = mid + Math.imul(ah9, bl2) | 0, hi = Math.imul(ah9, bh2), lo = lo + Math.imul(al8, bl3) | 0, mid = mid + Math.imul(al8, bh3) | 0, mid = mid + Math.imul(ah8, bl3) | 0, hi = hi + Math.imul(ah8, bh3) | 0, lo = lo + Math.imul(al7, bl4) | 0, mid = mid + Math.imul(al7, bh4) | 0, mid = mid + Math.imul(ah7, bl4) | 0, hi = hi + Math.imul(ah7, bh4) | 0, lo = lo + Math.imul(al6, bl5) | 0, mid = mid + Math.imul(al6, bh5) | 0, mid = mid + Math.imul(ah6, bl5) | 0, hi = hi + Math.imul(ah6, bh5) | 0, lo = lo + Math.imul(al5, bl6) | 0, mid = mid + Math.imul(al5, bh6) | 0, mid = mid + Math.imul(ah5, bl6) | 0, hi = hi + Math.imul(ah5, bh6) | 0, lo = lo + Math.imul(al4, bl7) | 0, mid = mid + Math.imul(al4, bh7) | 0, mid = mid + Math.imul(ah4, bl7) | 0, hi = hi + Math.imul(ah4, bh7) | 0, lo = lo + Math.imul(al3, bl8) | 0, mid = mid + Math.imul(al3, bh8) | 0, mid = mid + Math.imul(ah3, bl8) | 0, hi = hi + Math.imul(ah3, bh8) | 0, lo = lo + Math.imul(al2, bl9) | 0, mid = mid + Math.imul(al2, bh9) | 0, mid = mid + Math.imul(ah2, bl9) | 0, hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0, w11 &= 67108863, lo = Math.imul(al9, bl3), mid = Math.imul(al9, bh3), mid = mid + Math.imul(ah9, bl3) | 0, hi = Math.imul(ah9, bh3), lo = lo + Math.imul(al8, bl4) | 0, mid = mid + Math.imul(al8, bh4) | 0, mid = mid + Math.imul(ah8, bl4) | 0, hi = hi + Math.imul(ah8, bh4) | 0, lo = lo + Math.imul(al7, bl5) | 0, mid = mid + Math.imul(al7, bh5) | 0, mid = mid + Math.imul(ah7, bl5) | 0, hi = hi + Math.imul(ah7, bh5) | 0, lo = lo + Math.imul(al6, bl6) | 0, mid = mid + Math.imul(al6, bh6) | 0, mid = mid + Math.imul(ah6, bl6) | 0, hi = hi + Math.imul(ah6, bh6) | 0, lo = lo + Math.imul(al5, bl7) | 0, mid = mid + Math.imul(al5, bh7) | 0, mid = mid + Math.imul(ah5, bl7) | 0, hi = hi + Math.imul(ah5, bh7) | 0, lo = lo + Math.imul(al4, bl8) | 0, mid = mid + Math.imul(al4, bh8) | 0, mid = mid + Math.imul(ah4, bl8) | 0, hi = hi + Math.imul(ah4, bh8) | 0, lo = lo + Math.imul(al3, bl9) | 0, mid = mid + Math.imul(al3, bh9) | 0, mid = mid + Math.imul(ah3, bl9) | 0, hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0, w12 &= 67108863, lo = Math.imul(al9, bl4), mid = Math.imul(al9, bh4), mid = mid + Math.imul(ah9, bl4) | 0, hi = Math.imul(ah9, bh4), lo = lo + Math.imul(al8, bl5) | 0, mid = mid + Math.imul(al8, bh5) | 0, mid = mid + Math.imul(ah8, bl5) | 0, hi = hi + Math.imul(ah8, bh5) | 0, lo = lo + Math.imul(al7, bl6) | 0, mid = mid + Math.imul(al7, bh6) | 0, mid = mid + Math.imul(ah7, bl6) | 0, hi = hi + Math.imul(ah7, bh6) | 0, lo = lo + Math.imul(al6, bl7) | 0, mid = mid + Math.imul(al6, bh7) | 0, mid = mid + Math.imul(ah6, bl7) | 0, hi = hi + Math.imul(ah6, bh7) | 0, lo = lo + Math.imul(al5, bl8) | 0, mid = mid + Math.imul(al5, bh8) | 0, mid = mid + Math.imul(ah5, bl8) | 0, hi = hi + Math.imul(ah5, bh8) | 0, lo = lo + Math.imul(al4, bl9) | 0, mid = mid + Math.imul(al4, bh9) | 0, mid = mid + Math.imul(ah4, bl9) | 0, hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0, w13 &= 67108863, lo = Math.imul(al9, bl5), mid = Math.imul(al9, bh5), mid = mid + Math.imul(ah9, bl5) | 0, hi = Math.imul(ah9, bh5), lo = lo + Math.imul(al8, bl6) | 0, mid = mid + Math.imul(al8, bh6) | 0, mid = mid + Math.imul(ah8, bl6) | 0, hi = hi + Math.imul(ah8, bh6) | 0, lo = lo + Math.imul(al7, bl7) | 0, mid = mid + Math.imul(al7, bh7) | 0, mid = mid + Math.imul(ah7, bl7) | 0, hi = hi + Math.imul(ah7, bh7) | 0, lo = lo + Math.imul(al6, bl8) | 0, mid = mid + Math.imul(al6, bh8) | 0, mid = mid + Math.imul(ah6, bl8) | 0, hi = hi + Math.imul(ah6, bh8) | 0, lo = lo + Math.imul(al5, bl9) | 0, mid = mid + Math.imul(al5, bh9) | 0, mid = mid + Math.imul(ah5, bl9) | 0, hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0, w14 &= 67108863, lo = Math.imul(al9, bl6), mid = Math.imul(al9, bh6), mid = mid + Math.imul(ah9, bl6) | 0, hi = Math.imul(ah9, bh6), lo = lo + Math.imul(al8, bl7) | 0, mid = mid + Math.imul(al8, bh7) | 0, mid = mid + Math.imul(ah8, bl7) | 0, hi = hi + Math.imul(ah8, bh7) | 0, lo = lo + Math.imul(al7, bl8) | 0, mid = mid + Math.imul(al7, bh8) | 0, mid = mid + Math.imul(ah7, bl8) | 0, hi = hi + Math.imul(ah7, bh8) | 0, lo = lo + Math.imul(al6, bl9) | 0, mid = mid + Math.imul(al6, bh9) | 0, mid = mid + Math.imul(ah6, bl9) | 0, hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0, w15 &= 67108863, lo = Math.imul(al9, bl7), mid = Math.imul(al9, bh7), mid = mid + Math.imul(ah9, bl7) | 0, hi = Math.imul(ah9, bh7), lo = lo + Math.imul(al8, bl8) | 0, mid = mid + Math.imul(al8, bh8) | 0, mid = mid + Math.imul(ah8, bl8) | 0, hi = hi + Math.imul(ah8, bh8) | 0, lo = lo + Math.imul(al7, bl9) | 0, mid = mid + Math.imul(al7, bh9) | 0, mid = mid + Math.imul(ah7, bl9) | 0, hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0, w16 &= 67108863, lo = Math.imul(al9, bl8), mid = Math.imul(al9, bh8), mid = mid + Math.imul(ah9, bl8) | 0, hi = Math.imul(ah9, bh8), lo = lo + Math.imul(al8, bl9) | 0, mid = mid + Math.imul(al8, bh9) | 0, mid = mid + Math.imul(ah8, bl9) | 0, hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0, w17 &= 67108863, lo = Math.imul(al9, bl9), mid = Math.imul(al9, bh9), mid = mid + Math.imul(ah9, bl9) | 0, hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          if (c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0, w18 &= 67108863, o[0] = w0, o[1] = w1, o[2] = w2, o[3] = w3, o[4] = w4, o[5] = w5, o[6] = w6, o[7] = w7, o[8] = w8, o[9] = w9, o[10] = w10, o[11] = w11, o[12] = w12, o[13] = w13, o[14] = w14, o[15] = w15, o[16] = w16, o[17] = w17, o[18] = w18, c !== 0)
            o[19] = c, out.length++;
          return out;
        };
        if (!Math.imul)
          comb10MulTo = smallMulTo;
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative, out.length = self2.length + num.length;
          var carry = 0, hncarry = 0;
          for (var k = 0;k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863, maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1);j <= maxJ; j++) {
              var i2 = k - j, a = self2.words[i2] | 0, b = num.words[j] | 0, r = a * b, lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0, lo = lo + rword | 0, rword = lo & 67108863, ncarry = ncarry + (lo >>> 26) | 0, hncarry += ncarry >>> 26, ncarry &= 67108863;
            }
            out.words[k] = rword, carry = ncarry, ncarry = hncarry;
          }
          if (carry !== 0)
            out.words[k] = carry;
          else
            out.length--;
          return out._strip();
        }
        function jumboMulTo(self2, num, out) {
          return bigMulTo(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res, len2 = this.length + num.length;
          if (this.length === 10 && num.length === 10)
            res = comb10MulTo(this, num, out);
          else if (len2 < 63)
            res = smallMulTo(this, num, out);
          else if (len2 < 1024)
            res = bigMulTo(this, num, out);
          else
            res = jumboMulTo(this, num, out);
          return res;
        };
        function FFTM(x, y) {
          this.x = x, this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N), l = BN.prototype._countBits(N) - 1;
          for (var i2 = 0;i2 < N; i2++)
            t[i2] = this.revBin(i2, l, N);
          return t;
        }, FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i2 = 0;i2 < l; i2++)
            rb |= (x & 1) << l - i2 - 1, x >>= 1;
          return rb;
        }, FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i2 = 0;i2 < N; i2++)
            rtws[i2] = rws[rbt[i2]], itws[i2] = iws[rbt[i2]];
        }, FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1;s < N; s <<= 1) {
            var l = s << 1, rtwdf = Math.cos(2 * Math.PI / l), itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0;p < N; p += l) {
              var rtwdf_ = rtwdf, itwdf_ = itwdf;
              for (var j = 0;j < s; j++) {
                var re = rtws[p + j], ie = itws[p + j], ro = rtws[p + j + s], io = itws[p + j + s], rx = rtwdf_ * ro - itwdf_ * io;
                if (io = rtwdf_ * io + itwdf_ * ro, ro = rx, rtws[p + j] = re + ro, itws[p + j] = ie + io, rtws[p + j + s] = re - ro, itws[p + j + s] = ie - io, j !== l)
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_, itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_, rtwdf_ = rx;
              }
            }
          }
        }, FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1, odd = N & 1, i2 = 0;
          for (N = N / 2 | 0;N; N = N >>> 1)
            i2++;
          return 1 << i2 + 1 + odd;
        }, FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i2 = 0;i2 < N / 2; i2++) {
            var t = rws[i2];
            rws[i2] = rws[N - i2 - 1], rws[N - i2 - 1] = t, t = iws[i2], iws[i2] = -iws[N - i2 - 1], iws[N - i2 - 1] = -t;
          }
        }, FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i2 = 0;i2 < N / 2; i2++) {
            var w = Math.round(ws[2 * i2 + 1] / N) * 8192 + Math.round(ws[2 * i2] / N) + carry;
            if (ws[i2] = w & 67108863, w < 67108864)
              carry = 0;
            else
              carry = w / 67108864 | 0;
          }
          return ws;
        }, FFTM.prototype.convert13b = function convert13b(ws, len2, rws, N) {
          var carry = 0;
          for (var i2 = 0;i2 < len2; i2++)
            carry = carry + (ws[i2] | 0), rws[2 * i2] = carry & 8191, carry = carry >>> 13, rws[2 * i2 + 1] = carry & 8191, carry = carry >>> 13;
          for (i2 = 2 * len2;i2 < N; ++i2)
            rws[i2] = 0;
          assert(carry === 0), assert((carry & -8192) === 0);
        }, FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i2 = 0;i2 < N; i2++)
            ph[i2] = 0;
          return ph;
        }, FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length), rbt = this.makeRBT(N), _ = this.stub(N), rws = new Array(N), rwst = new Array(N), iwst = new Array(N), nrws = new Array(N), nrwst = new Array(N), niwst = new Array(N), rmws = out.words;
          rmws.length = N, this.convert13b(x.words, x.length, rws, N), this.convert13b(y.words, y.length, nrws, N), this.transform(rws, _, rwst, iwst, N, rbt), this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i2 = 0;i2 < N; i2++) {
            var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
            iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2], rwst[i2] = rx;
          }
          return this.conjugate(rwst, iwst, N), this.transform(rwst, iwst, rmws, _, N, rbt), this.conjugate(rmws, _, N), this.normalize13b(rmws, N), out.negative = x.negative ^ y.negative, out.length = x.length + y.length, out._strip();
        }, BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          return out.words = new Array(this.length + num.length), this.mulTo(num, out);
        }, BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);
        }, BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        }, BN.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(typeof num === "number"), assert(num < 67108864);
          var carry = 0;
          for (var i2 = 0;i2 < this.length; i2++) {
            var w = (this.words[i2] | 0) * num, lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26, carry += w / 67108864 | 0, carry += lo >>> 26, this.words[i2] = lo & 67108863;
          }
          if (carry !== 0)
            this.words[i2] = carry, this.length++;
          return this.length = num === 0 ? 1 : this.length, isNegNum ? this.ineg() : this;
        }, BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        }, BN.prototype.sqr = function sqr() {
          return this.mul(this);
        }, BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        }, BN.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN(1);
          var res = this;
          for (var i2 = 0;i2 < w.length; i2++, res = res.sqr())
            if (w[i2] !== 0)
              break;
          if (++i2 < w.length)
            for (var q = res.sqr();i2 < w.length; i2++, q = q.sqr()) {
              if (w[i2] === 0)
                continue;
              res = res.mul(q);
            }
          return res;
        }, BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26, s = (bits - r) / 26, carryMask = 67108863 >>> 26 - r << 26 - r, i2;
          if (r !== 0) {
            var carry = 0;
            for (i2 = 0;i2 < this.length; i2++) {
              var newCarry = this.words[i2] & carryMask, c = (this.words[i2] | 0) - newCarry << r;
              this.words[i2] = c | carry, carry = newCarry >>> 26 - r;
            }
            if (carry)
              this.words[i2] = carry, this.length++;
          }
          if (s !== 0) {
            for (i2 = this.length - 1;i2 >= 0; i2--)
              this.words[i2 + s] = this.words[i2];
            for (i2 = 0;i2 < s; i2++)
              this.words[i2] = 0;
            this.length += s;
          }
          return this._strip();
        }, BN.prototype.ishln = function ishln(bits) {
          return assert(this.negative === 0), this.iushln(bits);
        }, BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h;
          if (hint)
            h = (hint - hint % 26) / 26;
          else
            h = 0;
          var r = bits % 26, s = Math.min((bits - r) / 26, this.length), mask = 67108863 ^ 67108863 >>> r << r, maskedWords = extended;
          if (h -= s, h = Math.max(0, h), maskedWords) {
            for (var i2 = 0;i2 < s; i2++)
              maskedWords.words[i2] = this.words[i2];
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i2 = 0;i2 < this.length; i2++)
              this.words[i2] = this.words[i2 + s];
          } else
            this.words[0] = 0, this.length = 1;
          var carry = 0;
          for (i2 = this.length - 1;i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
            var word = this.words[i2] | 0;
            this.words[i2] = carry << 26 - r | word >>> r, carry = word & mask;
          }
          if (maskedWords && carry !== 0)
            maskedWords.words[maskedWords.length++] = carry;
          if (this.length === 0)
            this.words[0] = 0, this.length = 1;
          return this._strip();
        }, BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          return assert(this.negative === 0), this.iushrn(bits, hint, extended);
        }, BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        }, BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        }, BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        }, BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        }, BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        }, BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26, s = (bits - r) / 26;
          if (assert(this.negative === 0, "imaskn works only with positive numbers"), this.length <= s)
            return this;
          if (r !== 0)
            s++;
          if (this.length = Math.min(s, this.length), r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this._strip();
        }, BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        }, BN.prototype.iaddn = function iaddn(num) {
          if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num)
              return this.words[0] = num - (this.words[0] | 0), this.negative = 0, this;
            return this.negative = 0, this.isubn(num), this.negative = 1, this;
          }
          return this._iaddn(num);
        }, BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i2 = 0;i2 < this.length && this.words[i2] >= 67108864; i2++)
            if (this.words[i2] -= 67108864, i2 === this.length - 1)
              this.words[i2 + 1] = 1;
            else
              this.words[i2 + 1]++;
          return this.length = Math.max(this.length, i2 + 1), this;
        }, BN.prototype.isubn = function isubn(num) {
          if (assert(typeof num === "number"), assert(num < 67108864), num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0)
            return this.negative = 0, this.iaddn(num), this.negative = 1, this;
          if (this.words[0] -= num, this.length === 1 && this.words[0] < 0)
            this.words[0] = -this.words[0], this.negative = 1;
          else
            for (var i2 = 0;i2 < this.length && this.words[i2] < 0; i2++)
              this.words[i2] += 67108864, this.words[i2 + 1] -= 1;
          return this._strip();
        }, BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        }, BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        }, BN.prototype.iabs = function iabs() {
          return this.negative = 0, this;
        }, BN.prototype.abs = function abs() {
          return this.clone().iabs();
        }, BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift2) {
          var len2 = num.length + shift2, i2;
          this._expand(len2);
          var w, carry = 0;
          for (i2 = 0;i2 < num.length; i2++) {
            w = (this.words[i2 + shift2] | 0) + carry;
            var right3 = (num.words[i2] | 0) * mul;
            w -= right3 & 67108863, carry = (w >> 26) - (right3 / 67108864 | 0), this.words[i2 + shift2] = w & 67108863;
          }
          for (;i2 < this.length - shift2; i2++)
            w = (this.words[i2 + shift2] | 0) + carry, carry = w >> 26, this.words[i2 + shift2] = w & 67108863;
          if (carry === 0)
            return this._strip();
          assert(carry === -1), carry = 0;
          for (i2 = 0;i2 < this.length; i2++)
            w = -(this.words[i2] | 0) + carry, carry = w >> 26, this.words[i2] = w & 67108863;
          return this.negative = 1, this._strip();
        }, BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift2 = this.length - num.length, a = this.clone(), b = num, bhi = b.words[b.length - 1] | 0, bhiBits = this._countBits(bhi);
          if (shift2 = 26 - bhiBits, shift2 !== 0)
            b = b.ushln(shift2), a.iushln(shift2), bhi = b.words[b.length - 1] | 0;
          var m = a.length - b.length, q;
          if (mode !== "mod") {
            q = new BN(null), q.length = m + 1, q.words = new Array(q.length);
            for (var i2 = 0;i2 < q.length; i2++)
              q.words[i2] = 0;
          }
          var diff8 = a.clone()._ishlnsubmul(b, 1, m);
          if (diff8.negative === 0) {
            if (a = diff8, q)
              q.words[m] = 1;
          }
          for (var j = m - 1;j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863), a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0)
              if (qj--, a.negative = 0, a._ishlnsubmul(b, 1, j), !a.isZero())
                a.negative ^= 1;
            if (q)
              q.words[j] = qj;
          }
          if (q)
            q._strip();
          if (a._strip(), mode !== "div" && shift2 !== 0)
            a.iushrn(shift2);
          return { div: q || null, mod: a };
        }, BN.prototype.divmod = function divmod(num, mode, positive2) {
          if (assert(!num.isZero()), this.isZero())
            return { div: new BN(0), mod: new BN(0) };
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            if (res = this.neg().divmod(num, mode), mode !== "mod")
              div = res.div.neg();
            if (mode !== "div") {
              if (mod = res.mod.neg(), positive2 && mod.negative !== 0)
                mod.iadd(num);
            }
            return { div, mod };
          }
          if (this.negative === 0 && num.negative !== 0) {
            if (res = this.divmod(num.neg(), mode), mode !== "mod")
              div = res.div.neg();
            return { div, mod: res.mod };
          }
          if ((this.negative & num.negative) !== 0) {
            if (res = this.neg().divmod(num.neg(), mode), mode !== "div") {
              if (mod = res.mod.neg(), positive2 && mod.negative !== 0)
                mod.isub(num);
            }
            return { div: res.div, mod };
          }
          if (num.length > this.length || this.cmp(num) < 0)
            return { div: new BN(0), mod: this };
          if (num.length === 1) {
            if (mode === "div")
              return { div: this.divn(num.words[0]), mod: null };
            if (mode === "mod")
              return { div: null, mod: new BN(this.modrn(num.words[0])) };
            return { div: this.divn(num.words[0]), mod: new BN(this.modrn(num.words[0])) };
          }
          return this._wordDiv(num, mode);
        }, BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        }, BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        }, BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        }, BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod, half = num.ushrn(1), r2 = num.andln(1), cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        }, BN.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var p = 67108864 % num, acc = 0;
          for (var i2 = this.length - 1;i2 >= 0; i2--)
            acc = (p * acc + (this.words[i2] | 0)) % num;
          return isNegNum ? -acc : acc;
        }, BN.prototype.modn = function modn(num) {
          return this.modrn(num);
        }, BN.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var carry = 0;
          for (var i2 = this.length - 1;i2 >= 0; i2--) {
            var w = (this.words[i2] | 0) + carry * 67108864;
            this.words[i2] = w / num | 0, carry = w % num;
          }
          return this._strip(), isNegNum ? this.ineg() : this;
        }, BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        }, BN.prototype.egcd = function egcd(p) {
          assert(p.negative === 0), assert(!p.isZero());
          var x = this, y = p.clone();
          if (x.negative !== 0)
            x = x.umod(p);
          else
            x = x.clone();
          var A = new BN(1), B = new BN(0), C = new BN(0), D = new BN(1), g = 0;
          while (x.isEven() && y.isEven())
            x.iushrn(1), y.iushrn(1), ++g;
          var yp = y.clone(), xp = x.clone();
          while (!x.isZero()) {
            for (var i2 = 0, im = 1;(x.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
              ;
            if (i2 > 0) {
              x.iushrn(i2);
              while (i2-- > 0) {
                if (A.isOdd() || B.isOdd())
                  A.iadd(yp), B.isub(xp);
                A.iushrn(1), B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1;(y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd())
                  C.iadd(yp), D.isub(xp);
                C.iushrn(1), D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0)
              x.isub(y), A.isub(C), B.isub(D);
            else
              y.isub(x), C.isub(A), D.isub(B);
          }
          return { a: C, b: D, gcd: y.iushln(g) };
        }, BN.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0), assert(!p.isZero());
          var a = this, b = p.clone();
          if (a.negative !== 0)
            a = a.umod(p);
          else
            a = a.clone();
          var x1 = new BN(1), x2 = new BN(0), delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i2 = 0, im = 1;(a.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
              ;
            if (i2 > 0) {
              a.iushrn(i2);
              while (i2-- > 0) {
                if (x1.isOdd())
                  x1.iadd(delta);
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1;(b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd())
                  x2.iadd(delta);
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0)
              a.isub(b), x1.isub(x2);
            else
              b.isub(a), x2.isub(x1);
          }
          var res;
          if (a.cmpn(1) === 0)
            res = x1;
          else
            res = x2;
          if (res.cmpn(0) < 0)
            res.iadd(p);
          return res;
        }, BN.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone(), b = num.clone();
          a.negative = 0, b.negative = 0;
          for (var shift2 = 0;a.isEven() && b.isEven(); shift2++)
            a.iushrn(1), b.iushrn(1);
          do {
            while (a.isEven())
              a.iushrn(1);
            while (b.isEven())
              b.iushrn(1);
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b, b = t;
            } else if (r === 0 || b.cmpn(1) === 0)
              break;
            a.isub(b);
          } while (true);
          return b.iushln(shift2);
        }, BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        }, BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        }, BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        }, BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        }, BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26, s = (bit - r) / 26, q = 1 << r;
          if (this.length <= s)
            return this._expand(s + 1), this.words[s] |= q, this;
          var carry = q;
          for (var i2 = s;carry !== 0 && i2 < this.length; i2++) {
            var w = this.words[i2] | 0;
            w += carry, carry = w >>> 26, w &= 67108863, this.words[i2] = w;
          }
          if (carry !== 0)
            this.words[i2] = carry, this.length++;
          return this;
        }, BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        }, BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this._strip();
          var res;
          if (this.length > 1)
            res = 1;
          else {
            if (negative)
              num = -num;
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        }, BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        }, BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i2 = this.length - 1;i2 >= 0; i2--) {
            var a = this.words[i2] | 0, b = num.words[i2] | 0;
            if (a === b)
              continue;
            if (a < b)
              res = -1;
            else if (a > b)
              res = 1;
            break;
          }
          return res;
        }, BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        }, BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        }, BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        }, BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        }, BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        }, BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        }, BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        }, BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        }, BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        }, BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        }, BN.red = function red(num) {
          return new Red(num);
        }, BN.prototype.toRed = function toRed(ctx) {
          return assert(!this.red, "Already a number in reduction context"), assert(this.negative === 0, "red works only with positives"), ctx.convertTo(this)._forceRed(ctx);
        }, BN.prototype.fromRed = function fromRed() {
          return assert(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
        }, BN.prototype._forceRed = function _forceRed(ctx) {
          return this.red = ctx, this;
        }, BN.prototype.forceRed = function forceRed(ctx) {
          return assert(!this.red, "Already a number in reduction context"), this._forceRed(ctx);
        }, BN.prototype.redAdd = function redAdd(num) {
          return assert(this.red, "redAdd works only with red numbers"), this.red.add(this, num);
        }, BN.prototype.redIAdd = function redIAdd(num) {
          return assert(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, num);
        }, BN.prototype.redSub = function redSub(num) {
          return assert(this.red, "redSub works only with red numbers"), this.red.sub(this, num);
        }, BN.prototype.redISub = function redISub(num) {
          return assert(this.red, "redISub works only with red numbers"), this.red.isub(this, num);
        }, BN.prototype.redShl = function redShl(num) {
          return assert(this.red, "redShl works only with red numbers"), this.red.shl(this, num);
        }, BN.prototype.redMul = function redMul(num) {
          return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.mul(this, num);
        }, BN.prototype.redIMul = function redIMul(num) {
          return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.imul(this, num);
        }, BN.prototype.redSqr = function redSqr() {
          return assert(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
        }, BN.prototype.redISqr = function redISqr() {
          return assert(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
        }, BN.prototype.redSqrt = function redSqrt() {
          return assert(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
        }, BN.prototype.redInvm = function redInvm() {
          return assert(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
        }, BN.prototype.redNeg = function redNeg() {
          return assert(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
        }, BN.prototype.redPow = function redPow(num) {
          return assert(this.red && !num.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, num);
        };
        var primes = { k256: null, p224: null, p192: null, p25519: null };
        function MPrime(name, p) {
          this.name = name, this.p = new BN(p, 16), this.n = this.p.bitLength(), this.k = new BN(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          return tmp.words = new Array(Math.ceil(this.n / 13)), tmp;
        }, MPrime.prototype.ireduce = function ireduce(num) {
          var r = num, rlen;
          do
            this.split(r, this.tmp), r = this.imulK(r), r = r.iadd(this.tmp), rlen = r.bitLength();
          while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0)
            r.words[0] = 0, r.length = 1;
          else if (cmp > 0)
            r.isub(this.p);
          else if (r.strip !== undefined)
            r.strip();
          else
            r._strip();
          return r;
        }, MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        }, MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        inherits2(K256, MPrime), K256.prototype.split = function split(input, output) {
          var mask = 4194303, outLen = Math.min(input.length, 9);
          for (var i2 = 0;i2 < outLen; i2++)
            output.words[i2] = input.words[i2];
          if (output.length = outLen, input.length <= 9) {
            input.words[0] = 0, input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i2 = 10;i2 < input.length; i2++) {
            var next = input.words[i2] | 0;
            input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22, prev = next;
          }
          if (prev >>>= 22, input.words[i2 - 10] = prev, prev === 0 && input.length > 10)
            input.length -= 10;
          else
            input.length -= 9;
        }, K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0, num.words[num.length + 1] = 0, num.length += 2;
          var lo = 0;
          for (var i2 = 0;i2 < num.length; i2++) {
            var w = num.words[i2] | 0;
            lo += w * 977, num.words[i2] = lo & 67108863, lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            if (num.length--, num.words[num.length - 1] === 0)
              num.length--;
          }
          return num;
        };
        function P224() {
          MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        inherits2(P224, MPrime);
        function P192() {
          MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        inherits2(P192, MPrime);
        function P25519() {
          MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        inherits2(P25519, MPrime), P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i2 = 0;i2 < num.length; i2++) {
            var hi = (num.words[i2] | 0) * 19 + carry, lo = hi & 67108863;
            hi >>>= 26, num.words[i2] = lo, carry = hi;
          }
          if (carry !== 0)
            num.words[num.length++] = carry;
          return num;
        }, BN._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime;
          if (name === "k256")
            prime = new K256;
          else if (name === "p224")
            prime = new P224;
          else if (name === "p192")
            prime = new P192;
          else if (name === "p25519")
            prime = new P25519;
          else
            throw new Error("Unknown prime " + name);
          return primes[name] = prime, prime;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p, this.prime = prime;
          } else
            assert(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives"), assert(a.red, "red works only with red numbers");
        }, Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives"), assert(a.red && a.red === b.red, "red works only with red numbers");
        }, Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return move(a, a.umod(this.m)._forceRed(this)), a;
        }, Red.prototype.neg = function neg(a) {
          if (a.isZero())
            return a.clone();
          return this.m.sub(a)._forceRed(this);
        }, Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0)
            res.isub(this.m);
          return res._forceRed(this);
        }, Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0)
            res.isub(this.m);
          return res;
        }, Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0)
            res.iadd(this.m);
          return res._forceRed(this);
        }, Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0)
            res.iadd(this.m);
          return res;
        }, Red.prototype.shl = function shl(a, num) {
          return this._verify1(a), this.imod(a.ushln(num));
        }, Red.prototype.imul = function imul(a, b) {
          return this._verify2(a, b), this.imod(a.imul(b));
        }, Red.prototype.mul = function mul(a, b) {
          return this._verify2(a, b), this.imod(a.mul(b));
        }, Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        }, Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        }, Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          if (assert(mod3 % 2 === 1), mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1), s = 0;
          while (!q.isZero() && q.andln(1) === 0)
            s++, q.iushrn(1);
          assert(!q.isZero());
          var one = new BN(1).toRed(this), nOne = one.redNeg(), lpow = this.m.subn(1).iushrn(1), z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0)
            z.redIAdd(nOne);
          var c = this.pow(z, q), r = this.pow(a, q.addn(1).iushrn(1)), t = this.pow(a, q), m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i2 = 0;tmp.cmp(one) !== 0; i2++)
              tmp = tmp.redSqr();
            assert(i2 < m);
            var b = this.pow(c, new BN(1).iushln(m - i2 - 1));
            r = r.redMul(b), c = b.redSqr(), t = t.redMul(c), m = i2;
          }
          return r;
        }, Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0)
            return inv.negative = 0, this.imod(inv).redNeg();
          else
            return this.imod(inv);
        }, Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4, wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this), wnd[1] = a;
          for (var i2 = 2;i2 < wnd.length; i2++)
            wnd[i2] = this.mul(wnd[i2 - 1], a);
          var res = wnd[0], current2 = 0, currentLen = 0, start4 = num.bitLength() % 26;
          if (start4 === 0)
            start4 = 26;
          for (i2 = num.length - 1;i2 >= 0; i2--) {
            var word = num.words[i2];
            for (var j = start4 - 1;j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0])
                res = this.sqr(res);
              if (bit === 0 && current2 === 0) {
                currentLen = 0;
                continue;
              }
              if (current2 <<= 1, current2 |= bit, currentLen++, currentLen !== windowSize && (i2 !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current2]), currentLen = 0, current2 = 0;
            }
            start4 = 26;
          }
          return res;
        }, Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        }, Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          return res.red = null, res;
        }, BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          if (Red.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 !== 0)
            this.shift += 26 - this.shift % 26;
          this.r = new BN(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
        }
        inherits2(Mont, Red), Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        }, Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          return r.red = null, r;
        }, Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero())
            return a.words[0] = 0, a.length = 1, a;
          var t = a.imul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;
          if (u.cmp(this.m) >= 0)
            res = u.isub(this.m);
          else if (u.cmpn(0) < 0)
            res = u.iadd(this.m);
          return res._forceRed(this);
        }, Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN(0)._forceRed(this);
          var t = a.mul(b), c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u = t.isub(c).iushrn(this.shift), res = u;
          if (u.cmp(this.m) >= 0)
            res = u.isub(this.m);
          else if (u.cmpn(0) < 0)
            res = u.iadd(this.m);
          return res._forceRed(this);
        }, Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    });
    require_browserify_rsa = __commonJS2((exports, module) => {
      var BN = require_bn5(), randomBytes = require_randombytes(), Buffer22 = require_safe_buffer().Buffer;
      function getr(priv) {
        var len2 = priv.modulus.byteLength(), r;
        do
          r = new BN(randomBytes(len2));
        while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));
        return r;
      }
      function blind(priv) {
        var r = getr(priv), blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
        return { blinder, unblinder: r.invm(priv.modulus) };
      }
      function crt(msg, priv) {
        var blinds = blind(priv), len2 = priv.modulus.byteLength(), blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus), c1 = blinded.toRed(BN.mont(priv.prime1)), c2 = blinded.toRed(BN.mont(priv.prime2)), qinv = priv.coefficient, p = priv.prime1, q = priv.prime2, m1 = c1.redPow(priv.exponent1).fromRed(), m2 = c2.redPow(priv.exponent2).fromRed(), h = m1.isub(m2).imul(qinv).umod(p).imul(q);
        return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer22, "be", len2);
      }
      crt.getr = getr;
      module.exports = crt;
    });
    require_publicEncrypt = __commonJS2((exports, module) => {
      var parseKeys = require_parse_asn1(), randomBytes = require_randombytes(), createHash = require_create_hash(), mgf = require_mgf(), xor = require_xor(), BN = require_bn4(), withPublic = require_withPublic(), crt = require_browserify_rsa(), Buffer22 = require_safe_buffer().Buffer;
      module.exports = function publicEncrypt(publicKey, msg, reverse4) {
        var padding;
        if (publicKey.padding)
          padding = publicKey.padding;
        else if (reverse4)
          padding = 1;
        else
          padding = 4;
        var key = parseKeys(publicKey), paddedMsg;
        if (padding === 4)
          paddedMsg = oaep(key, msg);
        else if (padding === 1)
          paddedMsg = pkcs1(key, msg, reverse4);
        else if (padding === 3) {
          if (paddedMsg = new BN(msg), paddedMsg.cmp(key.modulus) >= 0)
            throw new Error("data too long for modulus");
        } else
          throw new Error("unknown padding");
        if (reverse4)
          return crt(paddedMsg, key);
        else
          return withPublic(paddedMsg, key);
      };
      function oaep(key, msg) {
        var k = key.modulus.byteLength(), mLen = msg.length, iHash = createHash("sha1").update(Buffer22.alloc(0)).digest(), hLen = iHash.length, hLen2 = 2 * hLen;
        if (mLen > k - hLen2 - 2)
          throw new Error("message too long");
        var ps = Buffer22.alloc(k - mLen - hLen2 - 2), dblen = k - hLen - 1, seed = randomBytes(hLen), maskedDb = xor(Buffer22.concat([iHash, ps, Buffer22.alloc(1, 1), msg], dblen), mgf(seed, dblen)), maskedSeed = xor(seed, mgf(maskedDb, hLen));
        return new BN(Buffer22.concat([Buffer22.alloc(1), maskedSeed, maskedDb], k));
      }
      function pkcs1(key, msg, reverse4) {
        var mLen = msg.length, k = key.modulus.byteLength();
        if (mLen > k - 11)
          throw new Error("message too long");
        var ps;
        if (reverse4)
          ps = Buffer22.alloc(k - mLen - 3, 255);
        else
          ps = nonZero(k - mLen - 3);
        return new BN(Buffer22.concat([Buffer22.from([0, reverse4 ? 1 : 2]), ps, Buffer22.alloc(1), msg], k));
      }
      function nonZero(len2) {
        var out = Buffer22.allocUnsafe(len2), i2 = 0, cache = randomBytes(len2 * 2), cur = 0, num;
        while (i2 < len2) {
          if (cur === cache.length)
            cache = randomBytes(len2 * 2), cur = 0;
          if (num = cache[cur++], num)
            out[i2++] = num;
        }
        return out;
      }
    });
    require_privateDecrypt = __commonJS2((exports, module) => {
      var parseKeys = require_parse_asn1(), mgf = require_mgf(), xor = require_xor(), BN = require_bn4(), crt = require_browserify_rsa(), createHash = require_create_hash(), withPublic = require_withPublic(), Buffer22 = require_safe_buffer().Buffer;
      module.exports = function privateDecrypt(privateKey, enc, reverse4) {
        var padding;
        if (privateKey.padding)
          padding = privateKey.padding;
        else if (reverse4)
          padding = 1;
        else
          padding = 4;
        var key = parseKeys(privateKey), k = key.modulus.byteLength();
        if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0)
          throw new Error("decryption error");
        var msg;
        if (reverse4)
          msg = withPublic(new BN(enc), key);
        else
          msg = crt(enc, key);
        var zBuffer = Buffer22.alloc(k - msg.length);
        if (msg = Buffer22.concat([zBuffer, msg], k), padding === 4)
          return oaep(key, msg);
        else if (padding === 1)
          return pkcs1(key, msg, reverse4);
        else if (padding === 3)
          return msg;
        else
          throw new Error("unknown padding");
      };
      function oaep(key, msg) {
        var k = key.modulus.byteLength(), iHash = createHash("sha1").update(Buffer22.alloc(0)).digest(), hLen = iHash.length;
        if (msg[0] !== 0)
          throw new Error("decryption error");
        var maskedSeed = msg.slice(1, hLen + 1), maskedDb = msg.slice(hLen + 1), seed = xor(maskedSeed, mgf(maskedDb, hLen)), db = xor(maskedDb, mgf(seed, k - hLen - 1));
        if (compare3(iHash, db.slice(0, hLen)))
          throw new Error("decryption error");
        var i2 = hLen;
        while (db[i2] === 0)
          i2++;
        if (db[i2++] !== 1)
          throw new Error("decryption error");
        return db.slice(i2);
      }
      function pkcs1(key, msg, reverse4) {
        var p1 = msg.slice(0, 2), i2 = 2, status2 = 0;
        while (msg[i2++] !== 0)
          if (i2 >= msg.length) {
            status2++;
            break;
          }
        var ps = msg.slice(2, i2 - 1);
        if (p1.toString("hex") !== "0002" && !reverse4 || p1.toString("hex") !== "0001" && reverse4)
          status2++;
        if (ps.length < 8)
          status2++;
        if (status2)
          throw new Error("decryption error");
        return msg.slice(i2);
      }
      function compare3(a, b) {
        a = Buffer22.from(a), b = Buffer22.from(b);
        var dif = 0, len2 = a.length;
        if (a.length !== b.length)
          dif++, len2 = Math.min(a.length, b.length);
        var i2 = -1;
        while (++i2 < len2)
          dif += a[i2] ^ b[i2];
        return dif;
      }
    });
    require_browser2 = __commonJS2((exports) => {
      exports.publicEncrypt = require_publicEncrypt();
      exports.privateDecrypt = require_privateDecrypt();
      exports.privateEncrypt = function privateEncrypt(key, buf) {
        return exports.publicEncrypt(key, buf, true);
      };
      exports.publicDecrypt = function publicDecrypt(key, buf) {
        return exports.privateDecrypt(key, buf, true);
      };
    });
    require_public_encrypt = __commonJS2((exports) => {
      var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
      if (typeof crypto2.publicEncrypt !== "function")
        crypto2 = require_browser2();
      exports.publicEncrypt = crypto2.publicEncrypt;
      exports.privateDecrypt = crypto2.privateDecrypt;
      if (typeof crypto2.privateEncrypt !== "function")
        exports.privateEncrypt = require_browser2().privateEncrypt;
      else
        exports.privateEncrypt = crypto2.privateEncrypt;
      if (typeof crypto2.publicDecrypt !== "function")
        exports.publicDecrypt = require_browser2().publicDecrypt;
      else
        exports.publicDecrypt = crypto2.publicDecrypt;
    });
    require_browser3 = __commonJS2((exports) => {
      var safeBuffer = require_safe_buffer(), randombytes = require_randombytes(), Buffer22 = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, crypto2 = globalThis.crypto || globalThis.msCrypto, kMaxUint32 = Math.pow(2, 32) - 1;
      function assertOffset(offset, length3) {
        if (typeof offset !== "number" || offset !== offset)
          throw new TypeError("offset must be a number");
        if (offset > kMaxUint32 || offset < 0)
          throw new TypeError("offset must be a uint32");
        if (offset > kBufferMaxLength || offset > length3)
          throw new RangeError("offset out of range");
      }
      function assertSize2(size13, offset, length3) {
        if (typeof size13 !== "number" || size13 !== size13)
          throw new TypeError("size must be a number");
        if (size13 > kMaxUint32 || size13 < 0)
          throw new TypeError("size must be a uint32");
        if (size13 + offset > length3 || size13 > kBufferMaxLength)
          throw new RangeError("buffer too small");
      }
      crypto2 && crypto2.getRandomValues, exports.randomFill = randomFill, exports.randomFillSync = randomFillSync;
      function randomFill(buf, offset, size13, cb) {
        if (!Buffer22.isBuffer(buf) && !(buf instanceof globalThis.Uint8Array))
          throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        if (typeof offset === "function")
          cb = offset, offset = 0, size13 = buf.length;
        else if (typeof size13 === "function")
          cb = size13, size13 = buf.length - offset;
        else if (typeof cb !== "function")
          throw new TypeError('"cb" argument must be a function');
        return assertOffset(offset, buf.length), assertSize2(size13, offset, buf.length), actualFill(buf, offset, size13, cb);
      }
      function actualFill(buf, offset, size13, cb) {
        if (false)
          var ourBuf, uint;
        if (cb) {
          randombytes(size13, function(err, bytes2) {
            if (err)
              return cb(err);
            bytes2.copy(buf, offset), cb(null, buf);
          });
          return;
        }
        var bytes = randombytes(size13);
        return bytes.copy(buf, offset), buf;
      }
      function randomFillSync(buf, offset, size13) {
        if (typeof offset === "undefined")
          offset = 0;
        if (!Buffer22.isBuffer(buf) && !(buf instanceof globalThis.Uint8Array))
          throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        if (assertOffset(offset, buf.length), size13 === undefined)
          size13 = buf.length - offset;
        return assertSize2(size13, offset, buf.length), actualFill(buf, offset, size13);
      }
    });
    require_randomfill = __commonJS2((exports, module) => {
      var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
      if (typeof crypto2.randomFill === "function" && typeof crypto2.randomFillSync === "function")
        exports.randomFill = crypto2.randomFill, exports.randomFillSync = crypto2.randomFillSync;
      else
        module.exports = require_browser3();
    });
    require_crypto_browserify = __commonJS2((exports) => {
      exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require_randombytes();
      exports.createHash = exports.Hash = require_create_hash();
      exports.createHmac = exports.Hmac = require_create_hmac();
      var algos = require_algorithms(), algoKeys = Object.keys(algos), hashes = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(algoKeys);
      exports.getHashes = function() {
        return hashes;
      };
      var p = require_pbkdf2();
      exports.pbkdf2 = p.pbkdf2;
      exports.pbkdf2Sync = p.pbkdf2Sync;
      var aes = require_browserify_cipher();
      exports.Cipher = aes.Cipher;
      exports.createCipher = aes.createCipher;
      exports.Cipheriv = aes.Cipheriv;
      exports.createCipheriv = aes.createCipheriv;
      exports.Decipher = aes.Decipher;
      exports.createDecipher = aes.createDecipher;
      exports.Decipheriv = aes.Decipheriv;
      exports.createDecipheriv = aes.createDecipheriv;
      exports.getCiphers = aes.getCiphers;
      exports.listCiphers = aes.listCiphers;
      var dh = require_diffie_hellman();
      exports.DiffieHellmanGroup = dh.DiffieHellmanGroup;
      exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
      exports.getDiffieHellman = dh.getDiffieHellman;
      exports.createDiffieHellman = dh.createDiffieHellman;
      exports.DiffieHellman = dh.DiffieHellman;
      var sign = require_browserify_sign();
      exports.createSign = sign.createSign;
      exports.Sign = sign.Sign;
      exports.createVerify = sign.createVerify;
      exports.Verify = sign.Verify;
      exports.createECDH = require_create_ecdh();
      var publicEncrypt = require_public_encrypt();
      exports.publicEncrypt = publicEncrypt.publicEncrypt;
      exports.privateEncrypt = publicEncrypt.privateEncrypt;
      exports.publicDecrypt = publicEncrypt.publicDecrypt;
      exports.privateDecrypt = publicEncrypt.privateDecrypt;
      var rf = require_randomfill();
      exports.randomFill = rf.randomFill;
      exports.randomFillSync = rf.randomFillSync;
      exports.createCredentials = function() {
        throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
      };
      exports.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
    });
    cryptoBrowserify = __toESM2(require_crypto_browserify(), 1);
    prng2 = cryptoBrowserify.prng;
    pseudoRandomBytes2 = cryptoBrowserify.pseudoRandomBytes;
    rng2 = cryptoBrowserify.rng;
    randomBytes2 = cryptoBrowserify.randomBytes;
    Hash2 = cryptoBrowserify.Hash;
    createHash2 = cryptoBrowserify.createHash;
    Hmac2 = cryptoBrowserify.Hmac;
    createHmac2 = cryptoBrowserify.createHmac;
    getHashes2 = cryptoBrowserify.getHashes;
    pbkdf22 = cryptoBrowserify.pbkdf2;
    pbkdf2Sync2 = cryptoBrowserify.pbkdf2Sync;
    Cipher2 = cryptoBrowserify.Cipher;
    createCipher2 = cryptoBrowserify.createCipher;
    Cipheriv2 = cryptoBrowserify.Cipheriv;
    createCipheriv2 = cryptoBrowserify.createCipheriv;
    Decipher2 = cryptoBrowserify.Decipher;
    createDecipher2 = cryptoBrowserify.createDecipher;
    Decipheriv2 = cryptoBrowserify.Decipheriv;
    createDecipheriv2 = cryptoBrowserify.createDecipheriv;
    getCiphers2 = cryptoBrowserify.getCiphers;
    listCiphers2 = cryptoBrowserify.listCiphers;
    DiffieHellmanGroup2 = cryptoBrowserify.DiffieHellmanGroup;
    createDiffieHellmanGroup2 = cryptoBrowserify.createDiffieHellmanGroup;
    getDiffieHellman2 = cryptoBrowserify.getDiffieHellman;
    createDiffieHellman2 = cryptoBrowserify.createDiffieHellman;
    DiffieHellman2 = cryptoBrowserify.DiffieHellman;
    createSign2 = cryptoBrowserify.createSign;
    Sign2 = cryptoBrowserify.Sign;
    createVerify2 = cryptoBrowserify.createVerify;
    Verify2 = cryptoBrowserify.Verify;
    createECDH2 = cryptoBrowserify.createECDH;
    publicEncrypt2 = cryptoBrowserify.publicEncrypt;
    privateEncrypt2 = cryptoBrowserify.privateEncrypt;
    publicDecrypt2 = cryptoBrowserify.publicDecrypt;
    privateDecrypt2 = cryptoBrowserify.privateDecrypt;
    randomFill2 = cryptoBrowserify.randomFill;
    randomFillSync2 = cryptoBrowserify.randomFillSync;
    createCredentials2 = cryptoBrowserify.createCredentials;
    constants2 = cryptoBrowserify.constants;
    hardcoded_curves = ["p192", "p224", "p256", "p384", "p521", "curve25519", "ed25519", "secp256k1", "secp224r1", "prime256v1", "prime192v1", "ed25519", "secp384r1", "secp521r1"];
    webcrypto = crypto;
    crypto_default = crypto;
  });

  // node_modules/@huggingface/hub/dist/browser/chunk-QXAXOUZS.mjs
  var init_chunk_QXAXOUZS = () => {};

  // src/mainview/effuse-main.ts
  var exports_effuse_main = {};
  __export(exports_effuse_main, {
    initEffuse: () => initEffuse
  });

  // node_modules/effect/dist/esm/Function.js
  var isFunction = (input) => typeof input === "function";
  var dual = function(arity, body) {
    if (typeof arity === "function") {
      return function() {
        if (arity(arguments)) {
          return body.apply(this, arguments);
        }
        return (self2) => body(self2, ...arguments);
      };
    }
    switch (arity) {
      case 0:
      case 1:
        throw new RangeError(`Invalid arity ${arity}`);
      case 2:
        return function(a, b) {
          if (arguments.length >= 2) {
            return body(a, b);
          }
          return function(self2) {
            return body(self2, a);
          };
        };
      case 3:
        return function(a, b, c) {
          if (arguments.length >= 3) {
            return body(a, b, c);
          }
          return function(self2) {
            return body(self2, a, b);
          };
        };
      case 4:
        return function(a, b, c, d) {
          if (arguments.length >= 4) {
            return body(a, b, c, d);
          }
          return function(self2) {
            return body(self2, a, b, c);
          };
        };
      case 5:
        return function(a, b, c, d, e) {
          if (arguments.length >= 5) {
            return body(a, b, c, d, e);
          }
          return function(self2) {
            return body(self2, a, b, c, d);
          };
        };
      default:
        return function() {
          if (arguments.length >= arity) {
            return body.apply(this, arguments);
          }
          const args = arguments;
          return function(self2) {
            return body(self2, ...args);
          };
        };
    }
  };
  var identity = (a) => a;
  var constant = (value) => () => value;
  var constTrue = /* @__PURE__ */ constant(true);
  var constFalse = /* @__PURE__ */ constant(false);
  var constUndefined = /* @__PURE__ */ constant(undefined);
  var constVoid = constUndefined;
  function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
    switch (arguments.length) {
      case 1:
        return a;
      case 2:
        return ab(a);
      case 3:
        return bc(ab(a));
      case 4:
        return cd(bc(ab(a)));
      case 5:
        return de(cd(bc(ab(a))));
      case 6:
        return ef(de(cd(bc(ab(a)))));
      case 7:
        return fg(ef(de(cd(bc(ab(a))))));
      case 8:
        return gh(fg(ef(de(cd(bc(ab(a)))))));
      case 9:
        return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
      default: {
        let ret = arguments[0];
        for (let i = 1;i < arguments.length; i++) {
          ret = arguments[i](ret);
        }
        return ret;
      }
    }
  }
  // node_modules/effect/dist/esm/Equivalence.js
  var make = (isEquivalent) => (self2, that) => self2 === that || isEquivalent(self2, that);
  var isStrictEquivalent = (x, y) => x === y;
  var strict = () => isStrictEquivalent;
  var number = /* @__PURE__ */ strict();
  var mapInput = /* @__PURE__ */ dual(2, (self2, f) => make((x, y) => self2(f(x), f(y))));
  var Date2 = /* @__PURE__ */ mapInput(number, (date) => date.getTime());
  var array = (item) => make((self2, that) => {
    if (self2.length !== that.length) {
      return false;
    }
    for (let i = 0;i < self2.length; i++) {
      const isEq = item(self2[i], that[i]);
      if (!isEq) {
        return false;
      }
    }
    return true;
  });

  // node_modules/effect/dist/esm/internal/doNotation.js
  var let_ = (map) => dual(3, (self2, name, f) => map(self2, (a) => ({
    ...a,
    [name]: f(a)
  })));
  var bindTo = (map) => dual(2, (self2, name) => map(self2, (a) => ({
    [name]: a
  })));
  var bind = (map, flatMap) => dual(3, (self2, name, f) => flatMap(self2, (a) => map(f(a), (b) => ({
    ...a,
    [name]: b
  }))));

  // node_modules/effect/dist/esm/GlobalValue.js
  var globalStoreId = `effect/GlobalValue`;
  var globalStore;
  var globalValue = (id, compute) => {
    if (!globalStore) {
      globalThis[globalStoreId] ??= new Map;
      globalStore = globalThis[globalStoreId];
    }
    if (!globalStore.has(id)) {
      globalStore.set(id, compute());
    }
    return globalStore.get(id);
  };

  // node_modules/effect/dist/esm/Predicate.js
  var isString = (input) => typeof input === "string";
  var isNumber = (input) => typeof input === "number";
  var isBoolean = (input) => typeof input === "boolean";
  var isBigInt = (input) => typeof input === "bigint";
  var isSymbol = (input) => typeof input === "symbol";
  var isFunction2 = isFunction;
  var isUndefined = (input) => input === undefined;
  var isNever = (_) => false;
  var isRecordOrArray = (input) => typeof input === "object" && input !== null;
  var isObject = (input) => isRecordOrArray(input) || isFunction2(input);
  var hasProperty = /* @__PURE__ */ dual(2, (self2, property) => isObject(self2) && (property in self2));
  var isTagged = /* @__PURE__ */ dual(2, (self2, tag) => hasProperty(self2, "_tag") && self2["_tag"] === tag);
  var isNullable = (input) => input === null || input === undefined;
  var isNotNullable = (input) => input !== null && input !== undefined;
  var isDate = (input) => input instanceof Date;
  var isIterable = (input) => typeof input === "string" || hasProperty(input, Symbol.iterator);
  var isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);
  var isPromiseLike = (input) => hasProperty(input, "then") && isFunction2(input.then);

  // node_modules/effect/dist/esm/internal/errors.js
  var getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

  // node_modules/effect/dist/esm/Utils.js
  class SingleShotGen {
    self;
    called = false;
    constructor(self2) {
      this.self = self2;
    }
    next(a) {
      return this.called ? {
        value: a,
        done: true
      } : (this.called = true, {
        value: this.self,
        done: false
      });
    }
    return(a) {
      return {
        value: a,
        done: true
      };
    }
    throw(e) {
      throw e;
    }
    [Symbol.iterator]() {
      return new SingleShotGen(this.self);
    }
  }
  var defaultIncHi = 335903614;
  var defaultIncLo = 4150755663;
  var MUL_HI = 1481765933 >>> 0;
  var MUL_LO = 1284865837 >>> 0;
  var BIT_53 = 9007199254740992;
  var BIT_27 = 134217728;

  class PCGRandom {
    _state;
    constructor(seedHi, seedLo, incHi, incLo) {
      if (isNullable(seedLo) && isNullable(seedHi)) {
        seedLo = Math.random() * 4294967295 >>> 0;
        seedHi = 0;
      } else if (isNullable(seedLo)) {
        seedLo = seedHi;
        seedHi = 0;
      }
      if (isNullable(incLo) && isNullable(incHi)) {
        incLo = this._state ? this._state[3] : defaultIncLo;
        incHi = this._state ? this._state[2] : defaultIncHi;
      } else if (isNullable(incLo)) {
        incLo = incHi;
        incHi = 0;
      }
      this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
      this._next();
      add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
      this._next();
      return this;
    }
    getState() {
      return [this._state[0], this._state[1], this._state[2], this._state[3]];
    }
    setState(state) {
      this._state[0] = state[0];
      this._state[1] = state[1];
      this._state[2] = state[2];
      this._state[3] = state[3] | 1;
    }
    integer(max) {
      return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max;
    }
    number() {
      const hi = (this._next() & 67108863) * 1;
      const lo = (this._next() & 134217727) * 1;
      return (hi * BIT_27 + lo) / BIT_53;
    }
    _next() {
      const oldHi = this._state[0] >>> 0;
      const oldLo = this._state[1] >>> 0;
      mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
      add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
      let xsHi = oldHi >>> 18;
      let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
      xsHi = (xsHi ^ oldHi) >>> 0;
      xsLo = (xsLo ^ oldLo) >>> 0;
      const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
      const rot = oldHi >>> 27;
      const rot2 = (-rot >>> 0 & 31) >>> 0;
      return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
    }
  }
  function mul64(out, aHi, aLo, bHi, bLo) {
    let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
    let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
    let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
    let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
    c0 = c0 << 16 >>> 0;
    lo = lo + c0 >>> 0;
    if (lo >>> 0 < c0 >>> 0) {
      hi = hi + 1 >>> 0;
    }
    c1 = c1 << 16 >>> 0;
    lo = lo + c1 >>> 0;
    if (lo >>> 0 < c1 >>> 0) {
      hi = hi + 1 >>> 0;
    }
    hi = hi + Math.imul(aLo, bHi) >>> 0;
    hi = hi + Math.imul(aHi, bLo) >>> 0;
    out[0] = hi;
    out[1] = lo;
  }
  function add64(out, aHi, aLo, bHi, bLo) {
    let hi = aHi + bHi >>> 0;
    const lo = aLo + bLo >>> 0;
    if (lo >>> 0 < aLo >>> 0) {
      hi = hi + 1 | 0;
    }
    out[0] = hi;
    out[1] = lo;
  }
  var YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");

  class YieldWrap {
    #value;
    constructor(value) {
      this.#value = value;
    }
    [YieldWrapTypeId]() {
      return this.#value;
    }
  }
  function yieldWrapGet(self2) {
    if (typeof self2 === "object" && self2 !== null && YieldWrapTypeId in self2) {
      return self2[YieldWrapTypeId]();
    }
    throw new Error(getBugErrorMessage("yieldWrapGet"));
  }
  var structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
    enabled: false,
    tester: undefined
  }));
  var standard = {
    effect_internal_function: (body) => {
      return body();
    }
  };
  var forced = {
    effect_internal_function: (body) => {
      try {
        return body();
      } finally {}
    }
  };
  var isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
  var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
  var genConstructor = function* () {}.constructor;
  var isGeneratorFunction = (u) => isObject(u) && u.constructor === genConstructor;

  // node_modules/effect/dist/esm/Hash.js
  var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => new WeakMap);
  var symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
  var hash = (self2) => {
    if (structuralRegionState.enabled === true) {
      return 0;
    }
    switch (typeof self2) {
      case "number":
        return number2(self2);
      case "bigint":
        return string(self2.toString(10));
      case "boolean":
        return string(String(self2));
      case "symbol":
        return string(String(self2));
      case "string":
        return string(self2);
      case "undefined":
        return string("undefined");
      case "function":
      case "object": {
        if (self2 === null) {
          return string("null");
        } else if (self2 instanceof Date) {
          return hash(self2.toISOString());
        } else if (self2 instanceof URL) {
          return hash(self2.href);
        } else if (isHash(self2)) {
          return self2[symbol]();
        } else {
          return random(self2);
        }
      }
      default:
        throw new Error(`BUG: unhandled typeof ${typeof self2} - please report an issue at https://github.com/Effect-TS/effect/issues`);
    }
  };
  var random = (self2) => {
    if (!randomHashCache.has(self2)) {
      randomHashCache.set(self2, number2(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
    }
    return randomHashCache.get(self2);
  };
  var combine = (b) => (self2) => self2 * 53 ^ b;
  var optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
  var isHash = (u) => hasProperty(u, symbol);
  var number2 = (n) => {
    if (n !== n || n === Infinity) {
      return 0;
    }
    let h = n | 0;
    if (h !== n) {
      h ^= n * 4294967295;
    }
    while (n > 4294967295) {
      h ^= n /= 4294967295;
    }
    return optimize(h);
  };
  var string = (str) => {
    let h = 5381, i = str.length;
    while (i) {
      h = h * 33 ^ str.charCodeAt(--i);
    }
    return optimize(h);
  };
  var structureKeys = (o, keys) => {
    let h = 12289;
    for (let i = 0;i < keys.length; i++) {
      h ^= pipe(string(keys[i]), combine(hash(o[keys[i]])));
    }
    return optimize(h);
  };
  var structure = (o) => structureKeys(o, Object.keys(o));
  var array2 = (arr) => {
    let h = 6151;
    for (let i = 0;i < arr.length; i++) {
      h = pipe(h, combine(hash(arr[i])));
    }
    return optimize(h);
  };
  var cached = function() {
    if (arguments.length === 1) {
      const self3 = arguments[0];
      return function(hash3) {
        Object.defineProperty(self3, symbol, {
          value() {
            return hash3;
          },
          enumerable: false
        });
        return hash3;
      };
    }
    const self2 = arguments[0];
    const hash2 = arguments[1];
    Object.defineProperty(self2, symbol, {
      value() {
        return hash2;
      },
      enumerable: false
    });
    return hash2;
  };

  // node_modules/effect/dist/esm/Equal.js
  var symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
  function equals() {
    if (arguments.length === 1) {
      return (self2) => compareBoth(self2, arguments[0]);
    }
    return compareBoth(arguments[0], arguments[1]);
  }
  function compareBoth(self2, that) {
    if (self2 === that) {
      return true;
    }
    const selfType = typeof self2;
    if (selfType !== typeof that) {
      return false;
    }
    if (selfType === "object" || selfType === "function") {
      if (self2 !== null && that !== null) {
        if (isEqual(self2) && isEqual(that)) {
          if (hash(self2) === hash(that) && self2[symbol2](that)) {
            return true;
          } else {
            return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
          }
        } else if (self2 instanceof Date && that instanceof Date) {
          return self2.toISOString() === that.toISOString();
        } else if (self2 instanceof URL && that instanceof URL) {
          return self2.href === that.href;
        }
      }
      if (structuralRegionState.enabled) {
        if (Array.isArray(self2) && Array.isArray(that)) {
          return self2.length === that.length && self2.every((v, i) => compareBoth(v, that[i]));
        }
        if (Object.getPrototypeOf(self2) === Object.prototype && Object.getPrototypeOf(self2) === Object.prototype) {
          const keysSelf = Object.keys(self2);
          const keysThat = Object.keys(that);
          if (keysSelf.length === keysThat.length) {
            for (const key of keysSelf) {
              if (!((key in that) && compareBoth(self2[key], that[key]))) {
                return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
              }
            }
            return true;
          }
        }
        return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
      }
    }
    return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
  }
  var isEqual = (u) => hasProperty(u, symbol2);
  var equivalence = () => equals;

  // node_modules/effect/dist/esm/Inspectable.js
  var NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
  var toJSON = (x) => {
    try {
      if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
        return x.toJSON();
      } else if (Array.isArray(x)) {
        return x.map(toJSON);
      }
    } catch {
      return {};
    }
    return redact(x);
  };
  var CIRCULAR = "[Circular]";
  function formatDate(date) {
    try {
      return date.toISOString();
    } catch {
      return "Invalid Date";
    }
  }
  function safeToString(input) {
    try {
      const s = input.toString();
      return typeof s === "string" ? s : String(s);
    } catch {
      return "[toString threw]";
    }
  }
  function formatPropertyKey(name) {
    return isString(name) ? JSON.stringify(name) : String(name);
  }
  function formatUnknown(input, options) {
    const space = options?.space ?? 0;
    const seen = new WeakSet;
    const gap = !space ? "" : isNumber(space) ? " ".repeat(space) : space;
    const ind = (d) => gap.repeat(d);
    const wrap = (v, body) => {
      const ctor = v?.constructor;
      return ctor && ctor !== Object.prototype.constructor && ctor.name ? `${ctor.name}(${body})` : body;
    };
    const ownKeys = (o) => {
      try {
        return Reflect.ownKeys(o);
      } catch {
        return ["[ownKeys threw]"];
      }
    };
    function go(v, d = 0) {
      if (Array.isArray(v)) {
        if (seen.has(v))
          return CIRCULAR;
        seen.add(v);
        if (!gap || v.length <= 1)
          return `[${v.map((x) => go(x, d)).join(",")}]`;
        const inner = v.map((x) => go(x, d + 1)).join(`,
` + ind(d + 1));
        return `[
${ind(d + 1)}${inner}
${ind(d)}]`;
      }
      if (isDate(v))
        return formatDate(v);
      if (!options?.ignoreToString && hasProperty(v, "toString") && isFunction2(v["toString"]) && v["toString"] !== Object.prototype.toString && v["toString"] !== Array.prototype.toString) {
        const s = safeToString(v);
        if (v instanceof Error && v.cause) {
          return `${s} (cause: ${go(v.cause, d)})`;
        }
        return s;
      }
      if (isString(v))
        return JSON.stringify(v);
      if (isNumber(v) || v == null || isBoolean(v) || isSymbol(v))
        return String(v);
      if (isBigInt(v))
        return String(v) + "n";
      if (v instanceof Set || v instanceof Map) {
        if (seen.has(v))
          return CIRCULAR;
        seen.add(v);
        return `${v.constructor.name}(${go(Array.from(v), d)})`;
      }
      if (isObject(v)) {
        if (seen.has(v))
          return CIRCULAR;
        seen.add(v);
        const keys = ownKeys(v);
        if (!gap || keys.length <= 1) {
          const body2 = `{${keys.map((k) => `${formatPropertyKey(k)}:${go(v[k], d)}`).join(",")}}`;
          return wrap(v, body2);
        }
        const body = `{
${keys.map((k) => `${ind(d + 1)}${formatPropertyKey(k)}: ${go(v[k], d + 1)}`).join(`,
`)}
${ind(d)}}`;
        return wrap(v, body);
      }
      return String(v);
    }
    return go(input, 0);
  }
  var format = (x) => JSON.stringify(x, null, 2);
  var BaseProto = {
    toJSON() {
      return toJSON(this);
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    toString() {
      return format(this.toJSON());
    }
  };
  var toStringUnknown = (u, whitespace = 2) => {
    if (typeof u === "string") {
      return u;
    }
    try {
      return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
    } catch {
      return String(u);
    }
  };
  var stringifyCircular = (obj, whitespace) => {
    let cache = [];
    const retVal = JSON.stringify(obj, (_key, value) => typeof value === "object" && value !== null ? cache.includes(value) ? undefined : cache.push(value) && (redactableState.fiberRefs !== undefined && isRedactable(value) ? value[symbolRedactable](redactableState.fiberRefs) : value) : value, whitespace);
    cache = undefined;
    return retVal;
  };
  var symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
  var isRedactable = (u) => typeof u === "object" && u !== null && (symbolRedactable in u);
  var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
    fiberRefs: undefined
  }));
  var withRedactableContext = (context, f) => {
    const prev = redactableState.fiberRefs;
    redactableState.fiberRefs = context;
    try {
      return f();
    } finally {
      redactableState.fiberRefs = prev;
    }
  };
  var redact = (u) => {
    if (isRedactable(u) && redactableState.fiberRefs !== undefined) {
      return u[symbolRedactable](redactableState.fiberRefs);
    }
    return u;
  };

  // node_modules/effect/dist/esm/Pipeable.js
  var pipeArguments = (self2, args) => {
    switch (args.length) {
      case 0:
        return self2;
      case 1:
        return args[0](self2);
      case 2:
        return args[1](args[0](self2));
      case 3:
        return args[2](args[1](args[0](self2)));
      case 4:
        return args[3](args[2](args[1](args[0](self2))));
      case 5:
        return args[4](args[3](args[2](args[1](args[0](self2)))));
      case 6:
        return args[5](args[4](args[3](args[2](args[1](args[0](self2))))));
      case 7:
        return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self2)))))));
      case 8:
        return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self2))))))));
      case 9:
        return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self2)))))))));
      default: {
        let ret = self2;
        for (let i = 0, len = args.length;i < len; i++) {
          ret = args[i](ret);
        }
        return ret;
      }
    }
  };

  // node_modules/effect/dist/esm/internal/opCodes/effect.js
  var OP_ASYNC = "Async";
  var OP_COMMIT = "Commit";
  var OP_FAILURE = "Failure";
  var OP_ON_FAILURE = "OnFailure";
  var OP_ON_SUCCESS = "OnSuccess";
  var OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
  var OP_SUCCESS = "Success";
  var OP_SYNC = "Sync";
  var OP_TAG = "Tag";
  var OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
  var OP_WHILE = "While";
  var OP_ITERATOR = "Iterator";
  var OP_WITH_RUNTIME = "WithRuntime";
  var OP_YIELD = "Yield";
  var OP_REVERT_FLAGS = "RevertFlags";

  // node_modules/effect/dist/esm/internal/version.js
  var moduleVersion = "3.19.8";
  var getCurrentVersion = () => moduleVersion;

  // node_modules/effect/dist/esm/internal/effectable.js
  var EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
  var StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
  var SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
  var ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
  var effectVariance = {
    _R: (_) => _,
    _E: (_) => _,
    _A: (_) => _,
    _V: /* @__PURE__ */ getCurrentVersion()
  };
  var sinkVariance = {
    _A: (_) => _,
    _In: (_) => _,
    _L: (_) => _,
    _E: (_) => _,
    _R: (_) => _
  };
  var channelVariance = {
    _Env: (_) => _,
    _InErr: (_) => _,
    _InElem: (_) => _,
    _InDone: (_) => _,
    _OutErr: (_) => _,
    _OutElem: (_) => _,
    _OutDone: (_) => _
  };
  var EffectPrototype = {
    [EffectTypeId]: effectVariance,
    [StreamTypeId]: effectVariance,
    [SinkTypeId]: sinkVariance,
    [ChannelTypeId]: channelVariance,
    [symbol2](that) {
      return this === that;
    },
    [symbol]() {
      return cached(this, random(this));
    },
    [Symbol.iterator]() {
      return new SingleShotGen(new YieldWrap(this));
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var StructuralPrototype = {
    [symbol]() {
      return cached(this, structure(this));
    },
    [symbol2](that) {
      const selfKeys = Object.keys(this);
      const thatKeys = Object.keys(that);
      if (selfKeys.length !== thatKeys.length) {
        return false;
      }
      for (const key of selfKeys) {
        if (!((key in that) && equals(this[key], that[key]))) {
          return false;
        }
      }
      return true;
    }
  };
  var CommitPrototype = {
    ...EffectPrototype,
    _op: OP_COMMIT
  };
  var StructuralCommitPrototype = {
    ...CommitPrototype,
    ...StructuralPrototype
  };
  var Base = /* @__PURE__ */ function() {
    function Base2() {}
    Base2.prototype = CommitPrototype;
    return Base2;
  }();

  // node_modules/effect/dist/esm/internal/option.js
  var TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
  var CommonProto = {
    ...EffectPrototype,
    [TypeId]: {
      _A: (_) => _
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    toString() {
      return format(this.toJSON());
    }
  };
  var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
    _tag: "Some",
    _op: "Some",
    [symbol2](that) {
      return isOption(that) && isSome(that) && equals(this.value, that.value);
    },
    [symbol]() {
      return cached(this, combine(hash(this._tag))(hash(this.value)));
    },
    toJSON() {
      return {
        _id: "Option",
        _tag: this._tag,
        value: toJSON(this.value)
      };
    }
  });
  var NoneHash = /* @__PURE__ */ hash("None");
  var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
    _tag: "None",
    _op: "None",
    [symbol2](that) {
      return isOption(that) && isNone(that);
    },
    [symbol]() {
      return NoneHash;
    },
    toJSON() {
      return {
        _id: "Option",
        _tag: this._tag
      };
    }
  });
  var isOption = (input) => hasProperty(input, TypeId);
  var isNone = (fa) => fa._tag === "None";
  var isSome = (fa) => fa._tag === "Some";
  var none = /* @__PURE__ */ Object.create(NoneProto);
  var some = (value) => {
    const a = Object.create(SomeProto);
    a.value = value;
    return a;
  };

  // node_modules/effect/dist/esm/internal/either.js
  var TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
  var CommonProto2 = {
    ...EffectPrototype,
    [TypeId2]: {
      _R: (_) => _
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    toString() {
      return format(this.toJSON());
    }
  };
  var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
    _tag: "Right",
    _op: "Right",
    [symbol2](that) {
      return isEither(that) && isRight(that) && equals(this.right, that.right);
    },
    [symbol]() {
      return combine(hash(this._tag))(hash(this.right));
    },
    toJSON() {
      return {
        _id: "Either",
        _tag: this._tag,
        right: toJSON(this.right)
      };
    }
  });
  var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
    _tag: "Left",
    _op: "Left",
    [symbol2](that) {
      return isEither(that) && isLeft(that) && equals(this.left, that.left);
    },
    [symbol]() {
      return combine(hash(this._tag))(hash(this.left));
    },
    toJSON() {
      return {
        _id: "Either",
        _tag: this._tag,
        left: toJSON(this.left)
      };
    }
  });
  var isEither = (input) => hasProperty(input, TypeId2);
  var isLeft = (ma) => ma._tag === "Left";
  var isRight = (ma) => ma._tag === "Right";
  var left = (left2) => {
    const a = Object.create(LeftProto);
    a.left = left2;
    return a;
  };
  var right = (right2) => {
    const a = Object.create(RightProto);
    a.right = right2;
    return a;
  };

  // node_modules/effect/dist/esm/Either.js
  var right2 = right;
  var left2 = left;
  var isEither2 = isEither;
  var isLeft2 = isLeft;
  var isRight2 = isRight;
  var mapBoth = /* @__PURE__ */ dual(2, (self2, {
    onLeft,
    onRight
  }) => isLeft2(self2) ? left2(onLeft(self2.left)) : right2(onRight(self2.right)));
  var mapLeft = /* @__PURE__ */ dual(2, (self2, f) => isLeft2(self2) ? left2(f(self2.left)) : right2(self2.right));
  var map = /* @__PURE__ */ dual(2, (self2, f) => isRight2(self2) ? right2(f(self2.right)) : left2(self2.left));
  var match = /* @__PURE__ */ dual(2, (self2, {
    onLeft,
    onRight
  }) => isLeft2(self2) ? onLeft(self2.left) : onRight(self2.right));
  var merge = /* @__PURE__ */ match({
    onLeft: identity,
    onRight: identity
  });
  var getOrThrowWith = /* @__PURE__ */ dual(2, (self2, onLeft) => {
    if (isRight2(self2)) {
      return self2.right;
    }
    throw onLeft(self2.left);
  });
  var getOrThrow = /* @__PURE__ */ getOrThrowWith(() => new Error("getOrThrow called on a Left"));

  // node_modules/effect/dist/esm/internal/array.js
  var isNonEmptyArray = (self2) => self2.length > 0;

  // node_modules/effect/dist/esm/Order.js
  var make2 = (compare) => (self2, that) => self2 === that ? 0 : compare(self2, that);
  var number3 = /* @__PURE__ */ make2((self2, that) => self2 < that ? -1 : 1);
  var mapInput2 = /* @__PURE__ */ dual(2, (self2, f) => make2((b1, b2) => self2(f(b1), f(b2))));
  var greaterThan = (O) => dual(2, (self2, that) => O(self2, that) === 1);

  // node_modules/effect/dist/esm/Option.js
  var none2 = () => none;
  var some2 = some;
  var isNone2 = isNone;
  var isSome2 = isSome;
  var match2 = /* @__PURE__ */ dual(2, (self2, {
    onNone,
    onSome
  }) => isNone2(self2) ? onNone() : onSome(self2.value));
  var getOrElse = /* @__PURE__ */ dual(2, (self2, onNone) => isNone2(self2) ? onNone() : self2.value);
  var orElse = /* @__PURE__ */ dual(2, (self2, that) => isNone2(self2) ? that() : self2);
  var orElseSome = /* @__PURE__ */ dual(2, (self2, onNone) => isNone2(self2) ? some2(onNone()) : self2);
  var fromNullable = (nullableValue) => nullableValue == null ? none2() : some2(nullableValue);
  var getOrUndefined = /* @__PURE__ */ getOrElse(constUndefined);
  var liftThrowable = (f) => (...a) => {
    try {
      return some2(f(...a));
    } catch {
      return none2();
    }
  };
  var getOrThrowWith2 = /* @__PURE__ */ dual(2, (self2, onNone) => {
    if (isSome2(self2)) {
      return self2.value;
    }
    throw onNone();
  });
  var getOrThrow2 = /* @__PURE__ */ getOrThrowWith2(() => new Error("getOrThrow called on a None"));
  var map2 = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : some2(f(self2.value)));
  var flatMap = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : f(self2.value));
  var flatMapNullable = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : fromNullable(f(self2.value)));
  var filterMap = flatMap;
  var filter = /* @__PURE__ */ dual(2, (self2, predicate) => filterMap(self2, (b) => predicate(b) ? some(b) : none));
  var containsWith = (isEquivalent) => dual(2, (self2, a) => isNone2(self2) ? false : isEquivalent(self2.value, a));
  var _equivalence = /* @__PURE__ */ equivalence();
  var contains = /* @__PURE__ */ containsWith(_equivalence);
  var exists = /* @__PURE__ */ dual(2, (self2, refinement) => isNone2(self2) ? false : refinement(self2.value));
  var mergeWith = (f) => (o1, o2) => {
    if (isNone2(o1)) {
      return o2;
    } else if (isNone2(o2)) {
      return o1;
    }
    return some2(f(o1.value, o2.value));
  };

  // node_modules/effect/dist/esm/Tuple.js
  var make3 = (...elements) => elements;

  // node_modules/effect/dist/esm/Iterable.js
  var findFirst = /* @__PURE__ */ dual(2, (self2, f) => {
    let i = 0;
    for (const a of self2) {
      const o = f(a, i);
      if (isBoolean(o)) {
        if (o) {
          return some2(a);
        }
      } else {
        if (isSome2(o)) {
          return o;
        }
      }
      i++;
    }
    return none2();
  });
  var constEmpty = {
    [Symbol.iterator]() {
      return constEmptyIterator;
    }
  };
  var constEmptyIterator = {
    next() {
      return {
        done: true,
        value: undefined
      };
    }
  };
  var empty = () => constEmpty;

  // node_modules/effect/dist/esm/Array.js
  var allocate = (n) => new Array(n);
  var makeBy = /* @__PURE__ */ dual(2, (n, f) => {
    const max = Math.max(1, Math.floor(n));
    const out = new Array(max);
    for (let i = 0;i < max; i++) {
      out[i] = f(i);
    }
    return out;
  });
  var fromIterable = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
  var ensure = (self2) => Array.isArray(self2) ? self2 : [self2];
  var matchLeft = /* @__PURE__ */ dual(2, (self2, {
    onEmpty,
    onNonEmpty
  }) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(headNonEmpty(self2), tailNonEmpty(self2)) : onEmpty());
  var prepend = /* @__PURE__ */ dual(2, (self2, head) => [head, ...self2]);
  var append = /* @__PURE__ */ dual(2, (self2, last) => [...self2, last]);
  var appendAll = /* @__PURE__ */ dual(2, (self2, that) => fromIterable(self2).concat(fromIterable(that)));
  var isArray = Array.isArray;
  var isEmptyArray = (self2) => self2.length === 0;
  var isEmptyReadonlyArray = isEmptyArray;
  var isNonEmptyArray2 = isNonEmptyArray;
  var isNonEmptyReadonlyArray = isNonEmptyArray;
  var isOutOfBounds = (i, as) => i < 0 || i >= as.length;
  var clamp = (i, as) => Math.floor(Math.min(Math.max(0, i), as.length));
  var get = /* @__PURE__ */ dual(2, (self2, index) => {
    const i = Math.floor(index);
    return isOutOfBounds(i, self2) ? none2() : some2(self2[i]);
  });
  var unsafeGet = /* @__PURE__ */ dual(2, (self2, index) => {
    const i = Math.floor(index);
    if (isOutOfBounds(i, self2)) {
      throw new Error(`Index ${i} out of bounds`);
    }
    return self2[i];
  });
  var head = /* @__PURE__ */ get(0);
  var headNonEmpty = /* @__PURE__ */ unsafeGet(0);
  var last = (self2) => isNonEmptyReadonlyArray(self2) ? some2(lastNonEmpty(self2)) : none2();
  var lastNonEmpty = (self2) => self2[self2.length - 1];
  var tailNonEmpty = (self2) => self2.slice(1);
  var spanIndex = (self2, predicate) => {
    let i = 0;
    for (const a of self2) {
      if (!predicate(a, i)) {
        break;
      }
      i++;
    }
    return i;
  };
  var span = /* @__PURE__ */ dual(2, (self2, predicate) => splitAt(self2, spanIndex(self2, predicate)));
  var drop = /* @__PURE__ */ dual(2, (self2, n) => {
    const input = fromIterable(self2);
    return input.slice(clamp(n, input), input.length);
  });
  var findFirst2 = findFirst;
  var reverse = (self2) => Array.from(self2).reverse();
  var sort = /* @__PURE__ */ dual(2, (self2, O) => {
    const out = Array.from(self2);
    out.sort(O);
    return out;
  });
  var zip = /* @__PURE__ */ dual(2, (self2, that) => zipWith(self2, that, make3));
  var zipWith = /* @__PURE__ */ dual(3, (self2, that, f) => {
    const as = fromIterable(self2);
    const bs = fromIterable(that);
    if (isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs)) {
      const out = [f(headNonEmpty(as), headNonEmpty(bs))];
      const len = Math.min(as.length, bs.length);
      for (let i = 1;i < len; i++) {
        out[i] = f(as[i], bs[i]);
      }
      return out;
    }
    return [];
  });
  var _equivalence2 = /* @__PURE__ */ equivalence();
  var splitAt = /* @__PURE__ */ dual(2, (self2, n) => {
    const input = Array.from(self2);
    const _n = Math.floor(n);
    if (isNonEmptyReadonlyArray(input)) {
      if (_n >= 1) {
        return splitNonEmptyAt(input, _n);
      }
      return [[], input];
    }
    return [input, []];
  });
  var splitNonEmptyAt = /* @__PURE__ */ dual(2, (self2, n) => {
    const _n = Math.max(1, Math.floor(n));
    return _n >= self2.length ? [copy(self2), []] : [prepend(self2.slice(1, _n), headNonEmpty(self2)), self2.slice(_n)];
  });
  var copy = (self2) => self2.slice();
  var unionWith = /* @__PURE__ */ dual(3, (self2, that, isEquivalent) => {
    const a = fromIterable(self2);
    const b = fromIterable(that);
    if (isNonEmptyReadonlyArray(a)) {
      if (isNonEmptyReadonlyArray(b)) {
        const dedupe = dedupeWith(isEquivalent);
        return dedupe(appendAll(a, b));
      }
      return a;
    }
    return b;
  });
  var union = /* @__PURE__ */ dual(2, (self2, that) => unionWith(self2, that, _equivalence2));
  var empty2 = () => [];
  var of = (a) => [a];
  var map3 = /* @__PURE__ */ dual(2, (self2, f) => self2.map(f));
  var flatMap2 = /* @__PURE__ */ dual(2, (self2, f) => {
    if (isEmptyReadonlyArray(self2)) {
      return [];
    }
    const out = [];
    for (let i = 0;i < self2.length; i++) {
      const inner = f(self2[i], i);
      for (let j = 0;j < inner.length; j++) {
        out.push(inner[j]);
      }
    }
    return out;
  });
  var flatten = /* @__PURE__ */ flatMap2(identity);
  var filterMap2 = /* @__PURE__ */ dual(2, (self2, f) => {
    const as = fromIterable(self2);
    const out = [];
    for (let i = 0;i < as.length; i++) {
      const o = f(as[i], i);
      if (isSome2(o)) {
        out.push(o.value);
      }
    }
    return out;
  });
  var filterMapWhile = /* @__PURE__ */ dual(2, (self2, f) => {
    let i = 0;
    const out = [];
    for (const a of self2) {
      const b = f(a, i);
      if (isSome2(b)) {
        out.push(b.value);
      } else {
        break;
      }
      i++;
    }
    return out;
  });
  var partitionMap = /* @__PURE__ */ dual(2, (self2, f) => {
    const left3 = [];
    const right3 = [];
    const as = fromIterable(self2);
    for (let i = 0;i < as.length; i++) {
      const e = f(as[i], i);
      if (isLeft2(e)) {
        left3.push(e.left);
      } else {
        right3.push(e.right);
      }
    }
    return [left3, right3];
  });
  var getSomes = /* @__PURE__ */ filterMap2(identity);
  var filter2 = /* @__PURE__ */ dual(2, (self2, predicate) => {
    const as = fromIterable(self2);
    const out = [];
    for (let i = 0;i < as.length; i++) {
      if (predicate(as[i], i)) {
        out.push(as[i]);
      }
    }
    return out;
  });
  var reduce = /* @__PURE__ */ dual(3, (self2, b, f) => fromIterable(self2).reduce((b2, a, i) => f(b2, a, i), b));
  var reduceRight = /* @__PURE__ */ dual(3, (self2, b, f) => fromIterable(self2).reduceRight((b2, a, i) => f(b2, a, i), b));
  var every = /* @__PURE__ */ dual(2, (self2, refinement) => self2.every(refinement));
  var unfold = (b, f) => {
    const out = [];
    let next = b;
    let o;
    while (isSome2(o = f(next))) {
      const [a, b2] = o.value;
      out.push(a);
      next = b2;
    }
    return out;
  };
  var getEquivalence = array;
  var dedupeWith = /* @__PURE__ */ dual(2, (self2, isEquivalent) => {
    const input = fromIterable(self2);
    if (isNonEmptyReadonlyArray(input)) {
      const out = [headNonEmpty(input)];
      const rest = tailNonEmpty(input);
      for (const r of rest) {
        if (out.every((a) => !isEquivalent(r, a))) {
          out.push(r);
        }
      }
      return out;
    }
    return [];
  });
  var dedupe = (self2) => dedupeWith(self2, equivalence());
  var join = /* @__PURE__ */ dual(2, (self2, sep) => fromIterable(self2).join(sep));
  var mapAccum = /* @__PURE__ */ dual(3, (self2, s, f) => {
    let i = 0;
    let s1 = s;
    const out = [];
    for (const a of self2) {
      const r = f(s1, a, i);
      s1 = r[0];
      out.push(r[1]);
      i++;
    }
    return [s1, out];
  });

  // node_modules/effect/dist/esm/internal/schema/util.js
  var getKeysForIndexSignature = (input, parameter) => {
    switch (parameter._tag) {
      case "StringKeyword":
      case "TemplateLiteral":
        return Object.keys(input);
      case "SymbolKeyword":
        return Object.getOwnPropertySymbols(input);
      case "Refinement":
        return getKeysForIndexSignature(input, parameter.from);
    }
  };
  var memoizeThunk = (f) => {
    let done = false;
    let a;
    return () => {
      if (done) {
        return a;
      }
      a = f();
      done = true;
      return a;
    };
  };
  var isNonEmpty = (x) => Array.isArray(x);
  var isSingle = (x) => !Array.isArray(x);
  var formatPathKey = (key) => `[${formatPropertyKey(key)}]`;
  var formatPath = (path) => isNonEmpty(path) ? path.map(formatPathKey).join("") : formatPathKey(path);

  // node_modules/effect/dist/esm/internal/schema/errors.js
  var getErrorMessage = (reason, details, path, ast) => {
    let out = reason;
    if (path && isNonEmptyReadonlyArray(path)) {
      out += `
at path: ${formatPath(path)}`;
    }
    if (details !== undefined) {
      out += `
details: ${details}`;
    }
    if (ast) {
      out += `
schema (${ast._tag}): ${ast}`;
    }
    return out;
  };
  var getSchemaExtendErrorMessage = (x, y, path) => getErrorMessage("Unsupported schema or overlapping types", `cannot extend ${x} with ${y}`, path);
  var getASTUnsupportedKeySchemaErrorMessage = (ast) => getErrorMessage("Unsupported key schema", undefined, undefined, ast);
  var getASTUnsupportedLiteralErrorMessage = (literal) => getErrorMessage("Unsupported literal", `literal value: ${formatUnknown(literal)}`);
  var getASTDuplicateIndexSignatureErrorMessage = (type) => getErrorMessage("Duplicate index signature", `${type} index signature`);
  var getASTIndexSignatureParameterErrorMessage = /* @__PURE__ */ getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
  var getASTRequiredElementFollowinAnOptionalElementErrorMessage = /* @__PURE__ */ getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
  var getASTDuplicatePropertySignatureTransformationErrorMessage = (key) => getErrorMessage("Duplicate property signature transformation", `Duplicate key ${formatUnknown(key)}`);
  var getASTDuplicatePropertySignatureErrorMessage = (key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`);

  // node_modules/effect/dist/esm/internal/schema/schemaId.js
  var DateFromSelfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/DateFromSelf");
  var GreaterThanSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThan");
  var IntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Int");

  // node_modules/effect/dist/esm/Number.js
  var Order = number3;
  var nextPow2 = (n) => {
    const nextPow = Math.ceil(Math.log(n) / Math.log(2));
    return Math.max(Math.pow(2, nextPow), 2);
  };

  // node_modules/effect/dist/esm/RegExp.js
  var escape2 = (string2) => string2.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

  // node_modules/effect/dist/esm/SchemaAST.js
  var BrandAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Brand");
  var SchemaIdAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/SchemaId");
  var MessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Message");
  var MissingMessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/MissingMessage");
  var IdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Identifier");
  var TitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Title");
  var AutoTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/AutoTitle");
  var DescriptionAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Description");
  var ExamplesAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Examples");
  var DefaultAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Default");
  var JSONSchemaAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONSchema");
  var ArbitraryAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Arbitrary");
  var PrettyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Pretty");
  var EquivalenceAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Equivalence");
  var DocumentationAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Documentation");
  var ConcurrencyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Concurrency");
  var BatchingAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Batching");
  var ParseIssueTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseIssueTitle");
  var ParseOptionsAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseOptions");
  var DecodingFallbackAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/DecodingFallback");
  var SurrogateAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Surrogate");
  var StableFilterAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/StableFilter");
  var getAnnotation = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some2(annotated.annotations[key]) : none2());
  var getBrandAnnotation = /* @__PURE__ */ getAnnotation(BrandAnnotationId);
  var getMessageAnnotation = /* @__PURE__ */ getAnnotation(MessageAnnotationId);
  var getMissingMessageAnnotation = /* @__PURE__ */ getAnnotation(MissingMessageAnnotationId);
  var getTitleAnnotation = /* @__PURE__ */ getAnnotation(TitleAnnotationId);
  var getAutoTitleAnnotation = /* @__PURE__ */ getAnnotation(AutoTitleAnnotationId);
  var getIdentifierAnnotation = /* @__PURE__ */ getAnnotation(IdentifierAnnotationId);
  var getDescriptionAnnotation = /* @__PURE__ */ getAnnotation(DescriptionAnnotationId);
  var getConcurrencyAnnotation = /* @__PURE__ */ getAnnotation(ConcurrencyAnnotationId);
  var getBatchingAnnotation = /* @__PURE__ */ getAnnotation(BatchingAnnotationId);
  var getParseIssueTitleAnnotation = /* @__PURE__ */ getAnnotation(ParseIssueTitleAnnotationId);
  var getParseOptionsAnnotation = /* @__PURE__ */ getAnnotation(ParseOptionsAnnotationId);
  var getDecodingFallbackAnnotation = /* @__PURE__ */ getAnnotation(DecodingFallbackAnnotationId);
  var getSurrogateAnnotation = /* @__PURE__ */ getAnnotation(SurrogateAnnotationId);
  var getStableFilterAnnotation = /* @__PURE__ */ getAnnotation(StableFilterAnnotationId);
  var hasStableFilter = (annotated) => exists(getStableFilterAnnotation(annotated), (b) => b === true);
  var JSONIdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONIdentifier");
  var getJSONIdentifierAnnotation = /* @__PURE__ */ getAnnotation(JSONIdentifierAnnotationId);
  var getJSONIdentifier = (annotated) => orElse(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
  class Declaration {
    typeParameters;
    decodeUnknown;
    encodeUnknown;
    annotations;
    _tag = "Declaration";
    constructor(typeParameters, decodeUnknown, encodeUnknown, annotations = {}) {
      this.typeParameters = typeParameters;
      this.decodeUnknown = decodeUnknown;
      this.encodeUnknown = encodeUnknown;
      this.annotations = annotations;
    }
    toString() {
      return getOrElse(getExpected(this), () => "<declaration schema>");
    }
    toJSON() {
      return {
        _tag: this._tag,
        typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var createASTGuard = (tag) => (ast) => ast._tag === tag;
  class Literal {
    literal;
    annotations;
    _tag = "Literal";
    constructor(literal, annotations = {}) {
      this.literal = literal;
      this.annotations = annotations;
    }
    toString() {
      return getOrElse(getExpected(this), () => formatUnknown(this.literal));
    }
    toJSON() {
      return {
        _tag: this._tag,
        literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var isLiteral = /* @__PURE__ */ createASTGuard("Literal");
  class UniqueSymbol {
    symbol;
    annotations;
    _tag = "UniqueSymbol";
    constructor(symbol3, annotations = {}) {
      this.symbol = symbol3;
      this.annotations = annotations;
    }
    toString() {
      return getOrElse(getExpected(this), () => formatUnknown(this.symbol));
    }
    toJSON() {
      return {
        _tag: this._tag,
        symbol: String(this.symbol),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  class UndefinedKeyword {
    annotations;
    _tag = "UndefinedKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var undefinedKeyword = /* @__PURE__ */ new UndefinedKeyword({
    [TitleAnnotationId]: "undefined"
  });
  class VoidKeyword {
    annotations;
    _tag = "VoidKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var voidKeyword = /* @__PURE__ */ new VoidKeyword({
    [TitleAnnotationId]: "void"
  });
  class NeverKeyword {
    annotations;
    _tag = "NeverKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var neverKeyword = /* @__PURE__ */ new NeverKeyword({
    [TitleAnnotationId]: "never"
  });
  class UnknownKeyword {
    annotations;
    _tag = "UnknownKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var unknownKeyword = /* @__PURE__ */ new UnknownKeyword({
    [TitleAnnotationId]: "unknown"
  });
  class AnyKeyword {
    annotations;
    _tag = "AnyKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var anyKeyword = /* @__PURE__ */ new AnyKeyword({
    [TitleAnnotationId]: "any"
  });
  class StringKeyword {
    annotations;
    _tag = "StringKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var stringKeyword = /* @__PURE__ */ new StringKeyword({
    [TitleAnnotationId]: "string",
    [DescriptionAnnotationId]: "a string"
  });
  var isStringKeyword = /* @__PURE__ */ createASTGuard("StringKeyword");

  class NumberKeyword {
    annotations;
    _tag = "NumberKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var numberKeyword = /* @__PURE__ */ new NumberKeyword({
    [TitleAnnotationId]: "number",
    [DescriptionAnnotationId]: "a number"
  });
  var isNumberKeyword = /* @__PURE__ */ createASTGuard("NumberKeyword");

  class BooleanKeyword {
    annotations;
    _tag = "BooleanKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var booleanKeyword = /* @__PURE__ */ new BooleanKeyword({
    [TitleAnnotationId]: "boolean",
    [DescriptionAnnotationId]: "a boolean"
  });
  var isBooleanKeyword = /* @__PURE__ */ createASTGuard("BooleanKeyword");

  class BigIntKeyword {
    annotations;
    _tag = "BigIntKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var bigIntKeyword = /* @__PURE__ */ new BigIntKeyword({
    [TitleAnnotationId]: "bigint",
    [DescriptionAnnotationId]: "a bigint"
  });
  class SymbolKeyword {
    annotations;
    _tag = "SymbolKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var symbolKeyword = /* @__PURE__ */ new SymbolKeyword({
    [TitleAnnotationId]: "symbol",
    [DescriptionAnnotationId]: "a symbol"
  });
  var isSymbolKeyword = /* @__PURE__ */ createASTGuard("SymbolKeyword");

  class ObjectKeyword {
    annotations;
    _tag = "ObjectKeyword";
    constructor(annotations = {}) {
      this.annotations = annotations;
    }
    toString() {
      return formatKeyword(this);
    }
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var objectKeyword = /* @__PURE__ */ new ObjectKeyword({
    [TitleAnnotationId]: "object",
    [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
  });
  class Type {
    type;
    annotations;
    constructor(type, annotations = {}) {
      this.type = type;
      this.annotations = annotations;
    }
    toJSON() {
      return {
        type: this.type.toJSON(),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
    toString() {
      return String(this.type);
    }
  }

  class OptionalType extends Type {
    isOptional;
    constructor(type, isOptional, annotations = {}) {
      super(type, annotations);
      this.isOptional = isOptional;
    }
    toJSON() {
      return {
        type: this.type.toJSON(),
        isOptional: this.isOptional,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
    toString() {
      return String(this.type) + (this.isOptional ? "?" : "");
    }
  }
  var getRestASTs = (rest) => rest.map((annotatedAST) => annotatedAST.type);

  class TupleType {
    elements;
    rest;
    isReadonly;
    annotations;
    _tag = "TupleType";
    constructor(elements, rest, isReadonly, annotations = {}) {
      this.elements = elements;
      this.rest = rest;
      this.isReadonly = isReadonly;
      this.annotations = annotations;
      let hasOptionalElement = false;
      let hasIllegalRequiredElement = false;
      for (const e of elements) {
        if (e.isOptional) {
          hasOptionalElement = true;
        } else if (hasOptionalElement) {
          hasIllegalRequiredElement = true;
          break;
        }
      }
      if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
        throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
      }
    }
    toString() {
      return getOrElse(getExpected(this), () => formatTuple(this));
    }
    toJSON() {
      return {
        _tag: this._tag,
        elements: this.elements.map((e) => e.toJSON()),
        rest: this.rest.map((ast) => ast.toJSON()),
        isReadonly: this.isReadonly,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var formatTuple = (ast) => {
    const formattedElements = ast.elements.map(String).join(", ");
    return matchLeft(ast.rest, {
      onEmpty: () => `readonly [${formattedElements}]`,
      onNonEmpty: (head2, tail) => {
        const formattedHead = String(head2);
        const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
        if (tail.length > 0) {
          const formattedTail = tail.map(String).join(", ");
          if (ast.elements.length > 0) {
            return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
          } else {
            return `readonly [...${wrappedHead}[], ${formattedTail}]`;
          }
        } else {
          if (ast.elements.length > 0) {
            return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
          } else {
            return `ReadonlyArray<${formattedHead}>`;
          }
        }
      }
    });
  };
  class PropertySignature extends OptionalType {
    name;
    isReadonly;
    constructor(name, type, isOptional, isReadonly, annotations) {
      super(type, isOptional, annotations);
      this.name = name;
      this.isReadonly = isReadonly;
    }
    toString() {
      return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
    }
    toJSON() {
      return {
        name: String(this.name),
        type: this.type.toJSON(),
        isOptional: this.isOptional,
        isReadonly: this.isReadonly,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var isParameter = (ast) => {
    switch (ast._tag) {
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
        return true;
      case "Refinement":
        return isParameter(ast.from);
    }
    return false;
  };

  class IndexSignature {
    type;
    isReadonly;
    parameter;
    constructor(parameter, type, isReadonly) {
      this.type = type;
      this.isReadonly = isReadonly;
      if (isParameter(parameter)) {
        this.parameter = parameter;
      } else {
        throw new Error(getASTIndexSignatureParameterErrorMessage);
      }
    }
    toString() {
      return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
    }
    toJSON() {
      return {
        parameter: this.parameter.toJSON(),
        type: this.type.toJSON(),
        isReadonly: this.isReadonly
      };
    }
  }

  class TypeLiteral {
    annotations;
    _tag = "TypeLiteral";
    propertySignatures;
    indexSignatures;
    constructor(propertySignatures, indexSignatures, annotations = {}) {
      this.annotations = annotations;
      const keys = {};
      for (let i = 0;i < propertySignatures.length; i++) {
        const name = propertySignatures[i].name;
        if (Object.prototype.hasOwnProperty.call(keys, name)) {
          throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
        }
        keys[name] = null;
      }
      const parameters = {
        string: false,
        symbol: false
      };
      for (let i = 0;i < indexSignatures.length; i++) {
        const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
        if (isStringKeyword(encodedParameter)) {
          if (parameters.string) {
            throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
          }
          parameters.string = true;
        } else if (isSymbolKeyword(encodedParameter)) {
          if (parameters.symbol) {
            throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
          }
          parameters.symbol = true;
        }
      }
      this.propertySignatures = propertySignatures;
      this.indexSignatures = indexSignatures;
    }
    toString() {
      return getOrElse(getExpected(this), () => formatTypeLiteral(this));
    }
    toJSON() {
      return {
        _tag: this._tag,
        propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
        indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var formatIndexSignatures = (iss) => iss.map(String).join("; ");
  var formatTypeLiteral = (ast) => {
    if (ast.propertySignatures.length > 0) {
      const pss = ast.propertySignatures.map(String).join("; ");
      if (ast.indexSignatures.length > 0) {
        return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
      } else {
        return `{ ${pss} }`;
      }
    } else {
      if (ast.indexSignatures.length > 0) {
        return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
      } else {
        return "{}";
      }
    }
  };
  var isTypeLiteral = /* @__PURE__ */ createASTGuard("TypeLiteral");
  var sortCandidates = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput2(Order, (ast) => {
    switch (ast._tag) {
      case "AnyKeyword":
        return 0;
      case "UnknownKeyword":
        return 1;
      case "ObjectKeyword":
        return 2;
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword":
        return 3;
    }
    return 4;
  }));
  var literalMap = {
    string: "StringKeyword",
    number: "NumberKeyword",
    boolean: "BooleanKeyword",
    bigint: "BigIntKeyword"
  };
  var flatten2 = (candidates) => flatMap2(candidates, (ast) => isUnion(ast) ? flatten2(ast.types) : [ast]);
  var unify = (candidates) => {
    const cs = sortCandidates(candidates);
    const out = [];
    const uniques = {};
    const literals = [];
    for (const ast of cs) {
      switch (ast._tag) {
        case "NeverKeyword":
          break;
        case "AnyKeyword":
          return [anyKeyword];
        case "UnknownKeyword":
          return [unknownKeyword];
        case "ObjectKeyword":
        case "UndefinedKeyword":
        case "VoidKeyword":
        case "StringKeyword":
        case "NumberKeyword":
        case "BooleanKeyword":
        case "BigIntKeyword":
        case "SymbolKeyword": {
          if (!uniques[ast._tag]) {
            uniques[ast._tag] = ast;
            out.push(ast);
          }
          break;
        }
        case "Literal": {
          const type = typeof ast.literal;
          switch (type) {
            case "string":
            case "number":
            case "bigint":
            case "boolean": {
              const _tag = literalMap[type];
              if (!uniques[_tag] && !literals.includes(ast.literal)) {
                literals.push(ast.literal);
                out.push(ast);
              }
              break;
            }
            case "object": {
              if (!literals.includes(ast.literal)) {
                literals.push(ast.literal);
                out.push(ast);
              }
              break;
            }
          }
          break;
        }
        case "UniqueSymbol": {
          if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
            literals.push(ast.symbol);
            out.push(ast);
          }
          break;
        }
        case "TupleType": {
          if (!uniques["ObjectKeyword"]) {
            out.push(ast);
          }
          break;
        }
        case "TypeLiteral": {
          if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
            if (!uniques["{}"]) {
              uniques["{}"] = ast;
              out.push(ast);
            }
          } else if (!uniques["ObjectKeyword"]) {
            out.push(ast);
          }
          break;
        }
        default:
          out.push(ast);
      }
    }
    return out;
  };

  class Union {
    types;
    annotations;
    static make = (types, annotations) => {
      return isMembers(types) ? new Union(types, annotations) : types.length === 1 ? types[0] : neverKeyword;
    };
    static unify = (candidates, annotations) => {
      return Union.make(unify(flatten2(candidates)), annotations);
    };
    _tag = "Union";
    constructor(types, annotations = {}) {
      this.types = types;
      this.annotations = annotations;
    }
    toString() {
      return getOrElse(getExpected(this), () => this.types.map(String).join(" | "));
    }
    toJSON() {
      return {
        _tag: this._tag,
        types: this.types.map((ast) => ast.toJSON()),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var mapMembers = (members, f) => members.map(f);
  var isMembers = (as) => as.length > 1;
  var isUnion = /* @__PURE__ */ createASTGuard("Union");
  var toJSONMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => new WeakMap);

  class Suspend {
    f;
    annotations;
    _tag = "Suspend";
    constructor(f, annotations = {}) {
      this.f = f;
      this.annotations = annotations;
      this.f = memoizeThunk(f);
    }
    toString() {
      return getExpected(this).pipe(orElse(() => flatMap(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse(() => "<suspended schema>"));
    }
    toJSON() {
      const ast = this.f();
      let out = toJSONMemoMap.get(ast);
      if (out) {
        return out;
      }
      toJSONMemoMap.set(ast, {
        _tag: this._tag
      });
      out = {
        _tag: this._tag,
        ast: ast.toJSON(),
        annotations: toJSONAnnotations(this.annotations)
      };
      toJSONMemoMap.set(ast, out);
      return out;
    }
  }
  class Refinement {
    from;
    filter;
    annotations;
    _tag = "Refinement";
    constructor(from, filter3, annotations = {}) {
      this.from = from;
      this.filter = filter3;
      this.annotations = annotations;
    }
    toString() {
      return getIdentifierAnnotation(this).pipe(getOrElse(() => match2(getOrElseExpected(this), {
        onNone: () => `{ ${this.from} | filter }`,
        onSome: (expected) => isRefinement(this.from) ? String(this.from) + " & " + expected : expected
      })));
    }
    toJSON() {
      return {
        _tag: this._tag,
        from: this.from.toJSON(),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var isRefinement = /* @__PURE__ */ createASTGuard("Refinement");
  var defaultParseOption = {};

  class Transformation {
    from;
    to;
    transformation;
    annotations;
    _tag = "Transformation";
    constructor(from, to, transformation, annotations = {}) {
      this.from = from;
      this.to = to;
      this.transformation = transformation;
      this.annotations = annotations;
    }
    toString() {
      return getOrElse(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
    }
    toJSON() {
      return {
        _tag: this._tag,
        from: this.from.toJSON(),
        to: this.to.toJSON(),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  var isTransformation = /* @__PURE__ */ createASTGuard("Transformation");

  class FinalTransformation {
    decode;
    encode;
    _tag = "FinalTransformation";
    constructor(decode, encode) {
      this.decode = decode;
      this.encode = encode;
    }
  }
  var createTransformationGuard = (tag) => (ast) => ast._tag === tag;
  class ComposeTransformation {
    _tag = "ComposeTransformation";
  }
  var composeTransformation = /* @__PURE__ */ new ComposeTransformation;
  class PropertySignatureTransformation {
    from;
    to;
    decode;
    encode;
    constructor(from, to, decode, encode) {
      this.from = from;
      this.to = to;
      this.decode = decode;
      this.encode = encode;
    }
  }
  class TypeLiteralTransformation {
    propertySignatureTransformations;
    _tag = "TypeLiteralTransformation";
    constructor(propertySignatureTransformations) {
      this.propertySignatureTransformations = propertySignatureTransformations;
      const fromKeys = {};
      const toKeys = {};
      for (const pst of propertySignatureTransformations) {
        const from = pst.from;
        if (fromKeys[from]) {
          throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(from));
        }
        fromKeys[from] = true;
        const to = pst.to;
        if (toKeys[to]) {
          throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(to));
        }
        toKeys[to] = true;
      }
    }
  }
  var isTypeLiteralTransformation = /* @__PURE__ */ createTransformationGuard("TypeLiteralTransformation");
  var annotations = (ast, overrides) => {
    const d = Object.getOwnPropertyDescriptors(ast);
    const base = {
      ...ast.annotations
    };
    delete base[IdentifierAnnotationId];
    const value = {
      ...base,
      ...overrides
    };
    const surrogate = getSurrogateAnnotation(ast);
    if (isSome2(surrogate)) {
      value[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
    }
    d.annotations.value = value;
    return Object.create(Object.getPrototypeOf(ast), d);
  };
  var STRING_KEYWORD_PATTERN = "[\\s\\S]*?";
  var NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
  var getTemplateLiteralSpanTypePattern = (type, capture) => {
    switch (type._tag) {
      case "Literal":
        return escape2(String(type.literal));
      case "StringKeyword":
        return STRING_KEYWORD_PATTERN;
      case "NumberKeyword":
        return NUMBER_KEYWORD_PATTERN;
      case "TemplateLiteral":
        return getTemplateLiteralPattern(type, capture, false);
      case "Union":
        return type.types.map((type2) => getTemplateLiteralSpanTypePattern(type2, capture)).join("|");
    }
  };
  var handleTemplateLiteralSpanTypeParens = (type, s, capture, top) => {
    if (isUnion(type)) {
      if (capture && !top) {
        return `(?:${s})`;
      }
    } else if (!capture || !top) {
      return s;
    }
    return `(${s})`;
  };
  var getTemplateLiteralPattern = (ast, capture, top) => {
    let pattern = ``;
    if (ast.head !== "") {
      const head2 = escape2(ast.head);
      pattern += capture && top ? `(${head2})` : head2;
    }
    for (const span2 of ast.spans) {
      const spanPattern = getTemplateLiteralSpanTypePattern(span2.type, capture);
      pattern += handleTemplateLiteralSpanTypeParens(span2.type, spanPattern, capture, top);
      if (span2.literal !== "") {
        const literal = escape2(span2.literal);
        pattern += capture && top ? `(${literal})` : literal;
      }
    }
    return pattern;
  };
  var getTemplateLiteralRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`);
  var record = (key, value) => {
    const propertySignatures = [];
    const indexSignatures = [];
    const go = (key2) => {
      switch (key2._tag) {
        case "NeverKeyword":
          break;
        case "StringKeyword":
        case "SymbolKeyword":
        case "TemplateLiteral":
        case "Refinement":
          indexSignatures.push(new IndexSignature(key2, value, true));
          break;
        case "Literal":
          if (isString(key2.literal) || isNumber(key2.literal)) {
            propertySignatures.push(new PropertySignature(key2.literal, value, false, true));
          } else {
            throw new Error(getASTUnsupportedLiteralErrorMessage(key2.literal));
          }
          break;
        case "Enums": {
          for (const [_, name] of key2.enums) {
            propertySignatures.push(new PropertySignature(name, value, false, true));
          }
          break;
        }
        case "UniqueSymbol":
          propertySignatures.push(new PropertySignature(key2.symbol, value, false, true));
          break;
        case "Union":
          key2.types.forEach(go);
          break;
        default:
          throw new Error(getASTUnsupportedKeySchemaErrorMessage(key2));
      }
    };
    go(key);
    return {
      propertySignatures,
      indexSignatures
    };
  };
  var pickAnnotations = (annotationIds) => (annotated) => {
    let out = undefined;
    for (const id of annotationIds) {
      if (Object.prototype.hasOwnProperty.call(annotated.annotations, id)) {
        if (out === undefined) {
          out = {};
        }
        out[id] = annotated.annotations[id];
      }
    }
    return out;
  };
  var omitAnnotations = (annotationIds) => (annotated) => {
    const out = {
      ...annotated.annotations
    };
    for (const id of annotationIds) {
      delete out[id];
    }
    return out;
  };
  var preserveTransformationAnnotations = /* @__PURE__ */ pickAnnotations([ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId]);
  var typeAST = (ast) => {
    switch (ast._tag) {
      case "Declaration": {
        const typeParameters = changeMap(ast.typeParameters, typeAST);
        return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
      }
      case "TupleType": {
        const elements = changeMap(ast.elements, (e) => {
          const type = typeAST(e.type);
          return type === e.type ? e : new OptionalType(type, e.isOptional);
        });
        const restASTs = getRestASTs(ast.rest);
        const rest = changeMap(restASTs, typeAST);
        return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type) => new Type(type)), ast.isReadonly, ast.annotations);
      }
      case "TypeLiteral": {
        const propertySignatures = changeMap(ast.propertySignatures, (p) => {
          const type = typeAST(p.type);
          return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly);
        });
        const indexSignatures = changeMap(ast.indexSignatures, (is) => {
          const type = typeAST(is.type);
          return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
        });
        return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
      }
      case "Union": {
        const types = changeMap(ast.types, typeAST);
        return types === ast.types ? ast : Union.make(types, ast.annotations);
      }
      case "Suspend":
        return new Suspend(() => typeAST(ast.f()), ast.annotations);
      case "Refinement": {
        const from = typeAST(ast.from);
        return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
      }
      case "Transformation": {
        const preserve = preserveTransformationAnnotations(ast);
        return typeAST(preserve !== undefined ? annotations(ast.to, preserve) : ast.to);
      }
    }
    return ast;
  };
  function changeMap(as, f) {
    let changed = false;
    const out = allocate(as.length);
    for (let i = 0;i < as.length; i++) {
      const a = as[i];
      const fa = f(a);
      if (fa !== a) {
        changed = true;
      }
      out[i] = fa;
    }
    return changed ? out : as;
  }
  var getTransformationFrom = (ast) => {
    switch (ast._tag) {
      case "Transformation":
        return ast.from;
      case "Refinement":
        return getTransformationFrom(ast.from);
      case "Suspend":
        return getTransformationFrom(ast.f());
    }
  };
  var encodedAST_ = (ast, isBound) => {
    switch (ast._tag) {
      case "Declaration": {
        const typeParameters = changeMap(ast.typeParameters, (ast2) => encodedAST_(ast2, isBound));
        return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown);
      }
      case "TupleType": {
        const elements = changeMap(ast.elements, (e) => {
          const type = encodedAST_(e.type, isBound);
          return type === e.type ? e : new OptionalType(type, e.isOptional);
        });
        const restASTs = getRestASTs(ast.rest);
        const rest = changeMap(restASTs, (ast2) => encodedAST_(ast2, isBound));
        return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast2) => new Type(ast2)), ast.isReadonly);
      }
      case "TypeLiteral": {
        const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
          const type = encodedAST_(ps.type, isBound);
          return type === ps.type ? ps : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly);
        });
        const indexSignatures = changeMap(ast.indexSignatures, (is) => {
          const type = encodedAST_(is.type, isBound);
          return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
        });
        return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures);
      }
      case "Union": {
        const types = changeMap(ast.types, (ast2) => encodedAST_(ast2, isBound));
        return types === ast.types ? ast : Union.make(types);
      }
      case "Suspend": {
        let borrowedAnnotations = undefined;
        const identifier = getJSONIdentifier(ast);
        if (isSome2(identifier)) {
          const suffix = isBound ? "Bound" : "";
          borrowedAnnotations = {
            [JSONIdentifierAnnotationId]: `${identifier.value}Encoded${suffix}`
          };
        }
        return new Suspend(() => encodedAST_(ast.f(), isBound), borrowedAnnotations);
      }
      case "Refinement": {
        const from = encodedAST_(ast.from, isBound);
        if (isBound) {
          if (from === ast.from)
            return ast;
          if (getTransformationFrom(ast.from) === undefined && hasStableFilter(ast)) {
            return new Refinement(from, ast.filter, ast.annotations);
          }
          return from;
        } else {
          return from;
        }
      }
      case "Transformation":
        return encodedAST_(ast.from, isBound);
    }
    return ast;
  };
  var encodedAST = (ast) => encodedAST_(ast, false);
  var toJSONAnnotations = (annotations2) => {
    const out = {};
    for (const k of Object.getOwnPropertySymbols(annotations2)) {
      out[String(k)] = annotations2[k];
    }
    return out;
  };
  var getEncodedParameter = (ast) => {
    switch (ast._tag) {
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
        return ast;
      case "Refinement":
        return getEncodedParameter(ast.from);
    }
  };
  var formatKeyword = (ast) => getOrElse(getExpected(ast), () => ast._tag);
  function getBrands(ast) {
    return match2(getBrandAnnotation(ast), {
      onNone: () => "",
      onSome: (brands) => brands.map((brand) => ` & Brand<${formatUnknown(brand)}>`).join("")
    });
  }
  var getOrElseExpected = (ast) => getTitleAnnotation(ast).pipe(orElse(() => getDescriptionAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), map2((s) => s + getBrands(ast)));
  var getExpected = (ast) => orElse(getIdentifierAnnotation(ast), () => getOrElseExpected(ast));
  // node_modules/effect/dist/esm/Boolean.js
  var not = (self2) => !self2;
  // node_modules/effect/dist/esm/Brand.js
  var RefinedConstructorsTypeId = /* @__PURE__ */ Symbol.for("effect/Brand/Refined");
  var nominal = () => {
    return Object.assign((args) => args, {
      [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
      option: (args) => some2(args),
      either: (args) => right2(args),
      is: (_args) => true
    });
  };
  // node_modules/effect/dist/esm/Context.js
  var exports_Context = {};
  __export(exports_Context, {
    unsafeMake: () => unsafeMake,
    unsafeGet: () => unsafeGet3,
    pick: () => pick2,
    omit: () => omit2,
    mergeAll: () => mergeAll2,
    merge: () => merge3,
    make: () => make5,
    isTag: () => isTag2,
    isReference: () => isReference2,
    isContext: () => isContext2,
    getOrElse: () => getOrElse3,
    getOption: () => getOption2,
    get: () => get3,
    empty: () => empty4,
    add: () => add2,
    TagTypeId: () => TagTypeId2,
    Tag: () => Tag2,
    ReferenceTypeId: () => ReferenceTypeId2,
    Reference: () => Reference2,
    GenericTag: () => GenericTag
  });

  // node_modules/effect/dist/esm/internal/context.js
  var TagTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
  var ReferenceTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
  var STMSymbolKey = "effect/STM";
  var STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
  var TagProto = {
    ...EffectPrototype,
    _op: "Tag",
    [STMTypeId]: effectVariance,
    [TagTypeId]: {
      _Service: (_) => _,
      _Identifier: (_) => _
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "Tag",
        key: this.key,
        stack: this.stack
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    of(self2) {
      return self2;
    },
    context(self2) {
      return make4(this, self2);
    }
  };
  var ReferenceProto = {
    ...TagProto,
    [ReferenceTypeId]: ReferenceTypeId
  };
  var makeGenericTag = (key) => {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error;
    Error.stackTraceLimit = limit;
    const tag = Object.create(TagProto);
    Object.defineProperty(tag, "stack", {
      get() {
        return creationError.stack;
      }
    });
    tag.key = key;
    return tag;
  };
  var Tag = (id) => () => {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error;
    Error.stackTraceLimit = limit;
    function TagClass() {}
    Object.setPrototypeOf(TagClass, TagProto);
    TagClass.key = id;
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    return TagClass;
  };
  var Reference = () => (id, options) => {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error;
    Error.stackTraceLimit = limit;
    function ReferenceClass() {}
    Object.setPrototypeOf(ReferenceClass, ReferenceProto);
    ReferenceClass.key = id;
    ReferenceClass.defaultValue = options.defaultValue;
    Object.defineProperty(ReferenceClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    return ReferenceClass;
  };
  var TypeId3 = /* @__PURE__ */ Symbol.for("effect/Context");
  var ContextProto = {
    [TypeId3]: {
      _Services: (_) => _
    },
    [symbol2](that) {
      if (isContext(that)) {
        if (this.unsafeMap.size === that.unsafeMap.size) {
          for (const k of this.unsafeMap.keys()) {
            if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
              return false;
            }
          }
          return true;
        }
      }
      return false;
    },
    [symbol]() {
      return cached(this, number2(this.unsafeMap.size));
    },
    pipe() {
      return pipeArguments(this, arguments);
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "Context",
        services: Array.from(this.unsafeMap).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  };
  var makeContext = (unsafeMap) => {
    const context = Object.create(ContextProto);
    context.unsafeMap = unsafeMap;
    return context;
  };
  var serviceNotFoundError = (tag) => {
    const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : ""}`);
    if (tag.stack) {
      const lines = tag.stack.split(`
`);
      if (lines.length > 2) {
        const afterAt = lines[2].match(/at (.*)/);
        if (afterAt) {
          error.message = error.message + ` (defined at ${afterAt[1]})`;
        }
      }
    }
    if (error.stack) {
      const lines = error.stack.split(`
`);
      lines.splice(1, 3);
      error.stack = lines.join(`
`);
    }
    return error;
  };
  var isContext = (u) => hasProperty(u, TypeId3);
  var isTag = (u) => hasProperty(u, TagTypeId);
  var isReference = (u) => hasProperty(u, ReferenceTypeId);
  var _empty = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map);
  var empty3 = () => _empty;
  var make4 = (tag, service) => makeContext(new Map([[tag.key, service]]));
  var add = /* @__PURE__ */ dual(3, (self2, tag, service) => {
    const map4 = new Map(self2.unsafeMap);
    map4.set(tag.key, service);
    return makeContext(map4);
  });
  var defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => new Map);
  var getDefaultValue = (tag) => {
    if (defaultValueCache.has(tag.key)) {
      return defaultValueCache.get(tag.key);
    }
    const value = tag.defaultValue();
    defaultValueCache.set(tag.key, value);
    return value;
  };
  var unsafeGetReference = (self2, tag) => {
    return self2.unsafeMap.has(tag.key) ? self2.unsafeMap.get(tag.key) : getDefaultValue(tag);
  };
  var unsafeGet2 = /* @__PURE__ */ dual(2, (self2, tag) => {
    if (!self2.unsafeMap.has(tag.key)) {
      if (ReferenceTypeId in tag)
        return getDefaultValue(tag);
      throw serviceNotFoundError(tag);
    }
    return self2.unsafeMap.get(tag.key);
  });
  var get2 = unsafeGet2;
  var getOrElse2 = /* @__PURE__ */ dual(3, (self2, tag, orElse2) => {
    if (!self2.unsafeMap.has(tag.key)) {
      return isReference(tag) ? getDefaultValue(tag) : orElse2();
    }
    return self2.unsafeMap.get(tag.key);
  });
  var getOption = /* @__PURE__ */ dual(2, (self2, tag) => {
    if (!self2.unsafeMap.has(tag.key)) {
      return isReference(tag) ? some(getDefaultValue(tag)) : none;
    }
    return some(self2.unsafeMap.get(tag.key));
  });
  var merge2 = /* @__PURE__ */ dual(2, (self2, that) => {
    const map4 = new Map(self2.unsafeMap);
    for (const [tag, s] of that.unsafeMap) {
      map4.set(tag, s);
    }
    return makeContext(map4);
  });
  var mergeAll = (...ctxs) => {
    const map4 = new Map;
    for (let i = 0;i < ctxs.length; i++) {
      ctxs[i].unsafeMap.forEach((value, key) => {
        map4.set(key, value);
      });
    }
    return makeContext(map4);
  };
  var pick = (...tags) => (self2) => {
    const tagSet = new Set(tags.map((_) => _.key));
    const newEnv = new Map;
    for (const [tag, s] of self2.unsafeMap.entries()) {
      if (tagSet.has(tag)) {
        newEnv.set(tag, s);
      }
    }
    return makeContext(newEnv);
  };
  var omit = (...tags) => (self2) => {
    const newEnv = new Map(self2.unsafeMap);
    for (const tag of tags) {
      newEnv.delete(tag.key);
    }
    return makeContext(newEnv);
  };

  // node_modules/effect/dist/esm/Context.js
  var TagTypeId2 = TagTypeId;
  var ReferenceTypeId2 = ReferenceTypeId;
  var GenericTag = makeGenericTag;
  var unsafeMake = makeContext;
  var isContext2 = isContext;
  var isTag2 = isTag;
  var isReference2 = isReference;
  var empty4 = empty3;
  var make5 = make4;
  var add2 = add;
  var get3 = get2;
  var getOrElse3 = getOrElse2;
  var unsafeGet3 = unsafeGet2;
  var getOption2 = getOption;
  var merge3 = merge2;
  var mergeAll2 = mergeAll;
  var pick2 = pick;
  var omit2 = omit;
  var Tag2 = Tag;
  var Reference2 = Reference;

  // node_modules/effect/dist/esm/Chunk.js
  var TypeId4 = /* @__PURE__ */ Symbol.for("effect/Chunk");
  function copy2(src, srcPos, dest, destPos, len) {
    for (let i = srcPos;i < Math.min(src.length, srcPos + len); i++) {
      dest[destPos + i - srcPos] = src[i];
    }
    return dest;
  }
  var emptyArray = [];
  var getEquivalence2 = (isEquivalent) => make((self2, that) => self2.length === that.length && toReadonlyArray(self2).every((value, i) => isEquivalent(value, unsafeGet4(that, i))));
  var _equivalence3 = /* @__PURE__ */ getEquivalence2(equals);
  var ChunkProto = {
    [TypeId4]: {
      _A: (_) => _
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "Chunk",
        values: toReadonlyArray(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    [symbol2](that) {
      return isChunk(that) && _equivalence3(this, that);
    },
    [symbol]() {
      return cached(this, array2(toReadonlyArray(this)));
    },
    [Symbol.iterator]() {
      switch (this.backing._tag) {
        case "IArray": {
          return this.backing.array[Symbol.iterator]();
        }
        case "IEmpty": {
          return emptyArray[Symbol.iterator]();
        }
        default: {
          return toReadonlyArray(this)[Symbol.iterator]();
        }
      }
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var makeChunk = (backing) => {
    const chunk = Object.create(ChunkProto);
    chunk.backing = backing;
    switch (backing._tag) {
      case "IEmpty": {
        chunk.length = 0;
        chunk.depth = 0;
        chunk.left = chunk;
        chunk.right = chunk;
        break;
      }
      case "IConcat": {
        chunk.length = backing.left.length + backing.right.length;
        chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
        chunk.left = backing.left;
        chunk.right = backing.right;
        break;
      }
      case "IArray": {
        chunk.length = backing.array.length;
        chunk.depth = 0;
        chunk.left = _empty2;
        chunk.right = _empty2;
        break;
      }
      case "ISingleton": {
        chunk.length = 1;
        chunk.depth = 0;
        chunk.left = _empty2;
        chunk.right = _empty2;
        break;
      }
      case "ISlice": {
        chunk.length = backing.length;
        chunk.depth = backing.chunk.depth + 1;
        chunk.left = _empty2;
        chunk.right = _empty2;
        break;
      }
    }
    return chunk;
  };
  var isChunk = (u) => hasProperty(u, TypeId4);
  var _empty2 = /* @__PURE__ */ makeChunk({
    _tag: "IEmpty"
  });
  var empty5 = () => _empty2;
  var make6 = (...as) => unsafeFromNonEmptyArray(as);
  var of2 = (a) => makeChunk({
    _tag: "ISingleton",
    a
  });
  var fromIterable2 = (self2) => isChunk(self2) ? self2 : unsafeFromArray(fromIterable(self2));
  var copyToArray = (self2, array3, initial) => {
    switch (self2.backing._tag) {
      case "IArray": {
        copy2(self2.backing.array, 0, array3, initial, self2.length);
        break;
      }
      case "IConcat": {
        copyToArray(self2.left, array3, initial);
        copyToArray(self2.right, array3, initial + self2.left.length);
        break;
      }
      case "ISingleton": {
        array3[initial] = self2.backing.a;
        break;
      }
      case "ISlice": {
        let i = 0;
        let j = initial;
        while (i < self2.length) {
          array3[j] = unsafeGet4(self2, i);
          i += 1;
          j += 1;
        }
        break;
      }
    }
  };
  var toArray_ = (self2) => toReadonlyArray(self2).slice();
  var toArray2 = toArray_;
  var toReadonlyArray_ = (self2) => {
    switch (self2.backing._tag) {
      case "IEmpty": {
        return emptyArray;
      }
      case "IArray": {
        return self2.backing.array;
      }
      default: {
        const arr = new Array(self2.length);
        copyToArray(self2, arr, 0);
        self2.backing = {
          _tag: "IArray",
          array: arr
        };
        self2.left = _empty2;
        self2.right = _empty2;
        self2.depth = 0;
        return arr;
      }
    }
  };
  var toReadonlyArray = toReadonlyArray_;
  var reverseChunk = (self2) => {
    switch (self2.backing._tag) {
      case "IEmpty":
      case "ISingleton":
        return self2;
      case "IArray": {
        return makeChunk({
          _tag: "IArray",
          array: reverse(self2.backing.array)
        });
      }
      case "IConcat": {
        return makeChunk({
          _tag: "IConcat",
          left: reverse2(self2.backing.right),
          right: reverse2(self2.backing.left)
        });
      }
      case "ISlice":
        return unsafeFromArray(reverse(toReadonlyArray(self2)));
    }
  };
  var reverse2 = reverseChunk;
  var get4 = /* @__PURE__ */ dual(2, (self2, index) => index < 0 || index >= self2.length ? none2() : some2(unsafeGet4(self2, index)));
  var unsafeFromArray = (self2) => self2.length === 0 ? empty5() : self2.length === 1 ? of2(self2[0]) : makeChunk({
    _tag: "IArray",
    array: self2
  });
  var unsafeFromNonEmptyArray = (self2) => unsafeFromArray(self2);
  var unsafeGet4 = /* @__PURE__ */ dual(2, (self2, index) => {
    switch (self2.backing._tag) {
      case "IEmpty": {
        throw new Error(`Index out of bounds`);
      }
      case "ISingleton": {
        if (index !== 0) {
          throw new Error(`Index out of bounds`);
        }
        return self2.backing.a;
      }
      case "IArray": {
        if (index >= self2.length || index < 0) {
          throw new Error(`Index out of bounds`);
        }
        return self2.backing.array[index];
      }
      case "IConcat": {
        return index < self2.left.length ? unsafeGet4(self2.left, index) : unsafeGet4(self2.right, index - self2.left.length);
      }
      case "ISlice": {
        return unsafeGet4(self2.backing.chunk, index + self2.backing.offset);
      }
    }
  });
  var append2 = /* @__PURE__ */ dual(2, (self2, a) => appendAll2(self2, of2(a)));
  var prepend2 = /* @__PURE__ */ dual(2, (self2, elem) => appendAll2(of2(elem), self2));
  var take = /* @__PURE__ */ dual(2, (self2, n) => {
    if (n <= 0) {
      return _empty2;
    } else if (n >= self2.length) {
      return self2;
    } else {
      switch (self2.backing._tag) {
        case "ISlice": {
          return makeChunk({
            _tag: "ISlice",
            chunk: self2.backing.chunk,
            length: n,
            offset: self2.backing.offset
          });
        }
        case "IConcat": {
          if (n > self2.left.length) {
            return makeChunk({
              _tag: "IConcat",
              left: self2.left,
              right: take(self2.right, n - self2.left.length)
            });
          }
          return take(self2.left, n);
        }
        default: {
          return makeChunk({
            _tag: "ISlice",
            chunk: self2,
            offset: 0,
            length: n
          });
        }
      }
    }
  });
  var drop2 = /* @__PURE__ */ dual(2, (self2, n) => {
    if (n <= 0) {
      return self2;
    } else if (n >= self2.length) {
      return _empty2;
    } else {
      switch (self2.backing._tag) {
        case "ISlice": {
          return makeChunk({
            _tag: "ISlice",
            chunk: self2.backing.chunk,
            offset: self2.backing.offset + n,
            length: self2.backing.length - n
          });
        }
        case "IConcat": {
          if (n > self2.left.length) {
            return drop2(self2.right, n - self2.left.length);
          }
          return makeChunk({
            _tag: "IConcat",
            left: drop2(self2.left, n),
            right: self2.right
          });
        }
        default: {
          return makeChunk({
            _tag: "ISlice",
            chunk: self2,
            offset: n,
            length: self2.length - n
          });
        }
      }
    }
  });
  var dropWhile = /* @__PURE__ */ dual(2, (self2, predicate) => {
    const arr = toReadonlyArray(self2);
    const len = arr.length;
    let i = 0;
    while (i < len && predicate(arr[i])) {
      i++;
    }
    return drop2(self2, i);
  });
  var appendAll2 = /* @__PURE__ */ dual(2, (self2, that) => {
    if (self2.backing._tag === "IEmpty") {
      return that;
    }
    if (that.backing._tag === "IEmpty") {
      return self2;
    }
    const diff = that.depth - self2.depth;
    if (Math.abs(diff) <= 1) {
      return makeChunk({
        _tag: "IConcat",
        left: self2,
        right: that
      });
    } else if (diff < -1) {
      if (self2.left.depth >= self2.right.depth) {
        const nr = appendAll2(self2.right, that);
        return makeChunk({
          _tag: "IConcat",
          left: self2.left,
          right: nr
        });
      } else {
        const nrr = appendAll2(self2.right.right, that);
        if (nrr.depth === self2.depth - 3) {
          const nr = makeChunk({
            _tag: "IConcat",
            left: self2.right.left,
            right: nrr
          });
          return makeChunk({
            _tag: "IConcat",
            left: self2.left,
            right: nr
          });
        } else {
          const nl = makeChunk({
            _tag: "IConcat",
            left: self2.left,
            right: self2.right.left
          });
          return makeChunk({
            _tag: "IConcat",
            left: nl,
            right: nrr
          });
        }
      }
    } else {
      if (that.right.depth >= that.left.depth) {
        const nl = appendAll2(self2, that.left);
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nll = appendAll2(self2, that.left.left);
        if (nll.depth === that.depth - 3) {
          const nl = makeChunk({
            _tag: "IConcat",
            left: nll,
            right: that.left.right
          });
          return makeChunk({
            _tag: "IConcat",
            left: nl,
            right: that.right
          });
        } else {
          const nr = makeChunk({
            _tag: "IConcat",
            left: that.left.right,
            right: that.right
          });
          return makeChunk({
            _tag: "IConcat",
            left: nll,
            right: nr
          });
        }
      }
    }
  });
  var filterMap3 = /* @__PURE__ */ dual(2, (self2, f) => unsafeFromArray(filterMap2(self2, f)));
  var filter3 = /* @__PURE__ */ dual(2, (self2, predicate) => unsafeFromArray(filter2(self2, predicate)));
  var filterMapWhile2 = /* @__PURE__ */ dual(2, (self2, f) => unsafeFromArray(filterMapWhile(self2, f)));
  var flatMap3 = /* @__PURE__ */ dual(2, (self2, f) => {
    if (self2.backing._tag === "ISingleton") {
      return f(self2.backing.a, 0);
    }
    let out = _empty2;
    let i = 0;
    for (const k of self2) {
      out = appendAll2(out, f(k, i++));
    }
    return out;
  });
  var flatten3 = /* @__PURE__ */ flatMap3(identity);
  var isEmpty = (self2) => self2.length === 0;
  var isNonEmpty2 = (self2) => self2.length > 0;
  var head2 = /* @__PURE__ */ get4(0);
  var unsafeHead = (self2) => unsafeGet4(self2, 0);
  var headNonEmpty2 = unsafeHead;
  var last2 = (self2) => get4(self2, self2.length - 1);
  var unsafeLast = (self2) => unsafeGet4(self2, self2.length - 1);
  var map4 = /* @__PURE__ */ dual(2, (self2, f) => self2.backing._tag === "ISingleton" ? of2(f(self2.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self2), map3((a, i) => f(a, i)))));
  var mapAccum2 = /* @__PURE__ */ dual(3, (self2, s, f) => {
    const [s1, as] = mapAccum(self2, s, f);
    return [s1, unsafeFromArray(as)];
  });
  var splitAt2 = /* @__PURE__ */ dual(2, (self2, n) => [take(self2, n), drop2(self2, n)]);
  var splitWhere = /* @__PURE__ */ dual(2, (self2, predicate) => {
    let i = 0;
    for (const a of toReadonlyArray(self2)) {
      if (predicate(a)) {
        break;
      } else {
        i++;
      }
    }
    return splitAt2(self2, i);
  });
  var tailNonEmpty2 = (self2) => drop2(self2, 1);
  var takeRight = /* @__PURE__ */ dual(2, (self2, n) => drop2(self2, self2.length - n));
  var takeWhile = /* @__PURE__ */ dual(2, (self2, predicate) => {
    const out = [];
    for (const a of toReadonlyArray(self2)) {
      if (predicate(a)) {
        out.push(a);
      } else {
        break;
      }
    }
    return unsafeFromArray(out);
  });
  var zipWith2 = /* @__PURE__ */ dual(3, (self2, that, f) => unsafeFromArray(zipWith(self2, that, f)));
  var makeBy2 = /* @__PURE__ */ dual(2, (n, f) => fromIterable2(makeBy(n, f)));
  var range = (start, end) => start <= end ? makeBy2(end - start + 1, (i) => start + i) : of2(start);
  var findFirst3 = findFirst2;
  var reduce2 = reduce;
  var reduceRight2 = reduceRight;

  // node_modules/effect/dist/esm/Duration.js
  var TypeId5 = /* @__PURE__ */ Symbol.for("effect/Duration");
  var bigint0 = /* @__PURE__ */ BigInt(0);
  var bigint24 = /* @__PURE__ */ BigInt(24);
  var bigint60 = /* @__PURE__ */ BigInt(60);
  var bigint1e3 = /* @__PURE__ */ BigInt(1000);
  var bigint1e6 = /* @__PURE__ */ BigInt(1e6);
  var bigint1e9 = /* @__PURE__ */ BigInt(1e9);
  var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
  var decode = (input) => {
    if (isDuration(input)) {
      return input;
    } else if (isNumber(input)) {
      return millis(input);
    } else if (isBigInt(input)) {
      return nanos(input);
    } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
      if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
        return zero;
      }
      if (input[0] === Infinity || input[1] === Infinity) {
        return infinity;
      }
      return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
    } else if (isString(input)) {
      const match4 = DURATION_REGEX.exec(input);
      if (match4) {
        const [_, valueStr, unit] = match4;
        const value = Number(valueStr);
        switch (unit) {
          case "nano":
          case "nanos":
            return nanos(BigInt(valueStr));
          case "micro":
          case "micros":
            return micros(BigInt(valueStr));
          case "milli":
          case "millis":
            return millis(value);
          case "second":
          case "seconds":
            return seconds(value);
          case "minute":
          case "minutes":
            return minutes(value);
          case "hour":
          case "hours":
            return hours(value);
          case "day":
          case "days":
            return days(value);
          case "week":
          case "weeks":
            return weeks(value);
        }
      }
    }
    throw new Error("Invalid DurationInput");
  };
  var zeroValue = {
    _tag: "Millis",
    millis: 0
  };
  var infinityValue = {
    _tag: "Infinity"
  };
  var DurationProto = {
    [TypeId5]: TypeId5,
    [symbol]() {
      return cached(this, structure(this.value));
    },
    [symbol2](that) {
      return isDuration(that) && equals2(this, that);
    },
    toString() {
      return `Duration(${format2(this)})`;
    },
    toJSON() {
      switch (this.value._tag) {
        case "Millis":
          return {
            _id: "Duration",
            _tag: "Millis",
            millis: this.value.millis
          };
        case "Nanos":
          return {
            _id: "Duration",
            _tag: "Nanos",
            hrtime: toHrTime(this)
          };
        case "Infinity":
          return {
            _id: "Duration",
            _tag: "Infinity"
          };
      }
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var make7 = (input) => {
    const duration = Object.create(DurationProto);
    if (isNumber(input)) {
      if (isNaN(input) || input <= 0) {
        duration.value = zeroValue;
      } else if (!Number.isFinite(input)) {
        duration.value = infinityValue;
      } else if (!Number.isInteger(input)) {
        duration.value = {
          _tag: "Nanos",
          nanos: BigInt(Math.round(input * 1e6))
        };
      } else {
        duration.value = {
          _tag: "Millis",
          millis: input
        };
      }
    } else if (input <= bigint0) {
      duration.value = zeroValue;
    } else {
      duration.value = {
        _tag: "Nanos",
        nanos: input
      };
    }
    return duration;
  };
  var isDuration = (u) => hasProperty(u, TypeId5);
  var isFinite2 = (self2) => self2.value._tag !== "Infinity";
  var isZero = (self2) => {
    switch (self2.value._tag) {
      case "Millis": {
        return self2.value.millis === 0;
      }
      case "Nanos": {
        return self2.value.nanos === bigint0;
      }
      case "Infinity": {
        return false;
      }
    }
  };
  var zero = /* @__PURE__ */ make7(0);
  var infinity = /* @__PURE__ */ make7(Infinity);
  var nanos = (nanos2) => make7(nanos2);
  var micros = (micros2) => make7(micros2 * bigint1e3);
  var millis = (millis2) => make7(millis2);
  var seconds = (seconds2) => make7(seconds2 * 1000);
  var minutes = (minutes2) => make7(minutes2 * 60000);
  var hours = (hours2) => make7(hours2 * 3600000);
  var days = (days2) => make7(days2 * 86400000);
  var weeks = (weeks2) => make7(weeks2 * 604800000);
  var toMillis = (self2) => match4(self2, {
    onMillis: (millis2) => millis2,
    onNanos: (nanos2) => Number(nanos2) / 1e6
  });
  var unsafeToNanos = (self2) => {
    const _self = decode(self2);
    switch (_self.value._tag) {
      case "Infinity":
        throw new Error("Cannot convert infinite duration to nanos");
      case "Nanos":
        return _self.value.nanos;
      case "Millis":
        return BigInt(Math.round(_self.value.millis * 1e6));
    }
  };
  var toHrTime = (self2) => {
    const _self = decode(self2);
    switch (_self.value._tag) {
      case "Infinity":
        return [Infinity, 0];
      case "Nanos":
        return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
      case "Millis":
        return [Math.floor(_self.value.millis / 1000), Math.round(_self.value.millis % 1000 * 1e6)];
    }
  };
  var match4 = /* @__PURE__ */ dual(2, (self2, options) => {
    const _self = decode(self2);
    switch (_self.value._tag) {
      case "Nanos":
        return options.onNanos(_self.value.nanos);
      case "Infinity":
        return options.onMillis(Infinity);
      case "Millis":
        return options.onMillis(_self.value.millis);
    }
  });
  var matchWith = /* @__PURE__ */ dual(3, (self2, that, options) => {
    const _self = decode(self2);
    const _that = decode(that);
    if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
      return options.onMillis(toMillis(_self), toMillis(_that));
    } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
      const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
      const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
      return options.onNanos(selfNanos, thatNanos);
    }
    return options.onMillis(_self.value.millis, _that.value.millis);
  });
  var Equivalence = (self2, that) => matchWith(self2, that, {
    onMillis: (self3, that2) => self3 === that2,
    onNanos: (self3, that2) => self3 === that2
  });
  var sum = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
    onMillis: (self3, that2) => make7(self3 + that2),
    onNanos: (self3, that2) => make7(self3 + that2)
  }));
  var lessThanOrEqualTo2 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
    onMillis: (self3, that2) => self3 <= that2,
    onNanos: (self3, that2) => self3 <= that2
  }));
  var greaterThan2 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
    onMillis: (self3, that2) => self3 > that2,
    onNanos: (self3, that2) => self3 > that2
  }));
  var greaterThanOrEqualTo2 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
    onMillis: (self3, that2) => self3 >= that2,
    onNanos: (self3, that2) => self3 >= that2
  }));
  var equals2 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence(decode(self2), decode(that)));
  var parts = (self2) => {
    const duration = decode(self2);
    if (duration.value._tag === "Infinity") {
      return {
        days: Infinity,
        hours: Infinity,
        minutes: Infinity,
        seconds: Infinity,
        millis: Infinity,
        nanos: Infinity
      };
    }
    const nanos2 = unsafeToNanos(duration);
    const ms = nanos2 / bigint1e6;
    const sec = ms / bigint1e3;
    const min2 = sec / bigint60;
    const hr = min2 / bigint60;
    const days2 = hr / bigint24;
    return {
      days: Number(days2),
      hours: Number(hr % bigint24),
      minutes: Number(min2 % bigint60),
      seconds: Number(sec % bigint60),
      millis: Number(ms % bigint1e3),
      nanos: Number(nanos2 % bigint1e6)
    };
  };
  var format2 = (self2) => {
    const duration = decode(self2);
    if (duration.value._tag === "Infinity") {
      return "Infinity";
    }
    if (isZero(duration)) {
      return "0";
    }
    const fragments = parts(duration);
    const pieces = [];
    if (fragments.days !== 0) {
      pieces.push(`${fragments.days}d`);
    }
    if (fragments.hours !== 0) {
      pieces.push(`${fragments.hours}h`);
    }
    if (fragments.minutes !== 0) {
      pieces.push(`${fragments.minutes}m`);
    }
    if (fragments.seconds !== 0) {
      pieces.push(`${fragments.seconds}s`);
    }
    if (fragments.millis !== 0) {
      pieces.push(`${fragments.millis}ms`);
    }
    if (fragments.nanos !== 0) {
      pieces.push(`${fragments.nanos}ns`);
    }
    return pieces.join(" ");
  };

  // node_modules/effect/dist/esm/internal/hashMap/config.js
  var SIZE = 5;
  var BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
  var MASK = BUCKET_SIZE - 1;
  var MAX_INDEX_NODE = BUCKET_SIZE / 2;
  var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

  // node_modules/effect/dist/esm/internal/hashMap/bitwise.js
  function popcount(x) {
    x -= x >> 1 & 1431655765;
    x = (x & 858993459) + (x >> 2 & 858993459);
    x = x + (x >> 4) & 252645135;
    x += x >> 8;
    x += x >> 16;
    return x & 127;
  }
  function hashFragment(shift, h) {
    return h >>> shift & MASK;
  }
  function toBitmap(x) {
    return 1 << x;
  }
  function fromBitmap(bitmap, bit) {
    return popcount(bitmap & bit - 1);
  }

  // node_modules/effect/dist/esm/internal/stack.js
  var make8 = (value, previous) => ({
    value,
    previous
  });

  // node_modules/effect/dist/esm/internal/hashMap/array.js
  function arrayUpdate(mutate, at, v, arr) {
    let out = arr;
    if (!mutate) {
      const len = arr.length;
      out = new Array(len);
      for (let i = 0;i < len; ++i)
        out[i] = arr[i];
    }
    out[at] = v;
    return out;
  }
  function arraySpliceOut(mutate, at, arr) {
    const newLen = arr.length - 1;
    let i = 0;
    let g = 0;
    let out = arr;
    if (mutate) {
      i = g = at;
    } else {
      out = new Array(newLen);
      while (i < at)
        out[g++] = arr[i++];
    }
    ++i;
    while (i <= newLen)
      out[g++] = arr[i++];
    if (mutate) {
      out.length = newLen;
    }
    return out;
  }
  function arraySpliceIn(mutate, at, v, arr) {
    const len = arr.length;
    if (mutate) {
      let i2 = len;
      while (i2 >= at)
        arr[i2--] = arr[i2];
      arr[at] = v;
      return arr;
    }
    let i = 0, g = 0;
    const out = new Array(len + 1);
    while (i < at)
      out[g++] = arr[i++];
    out[at] = v;
    while (i < len)
      out[++g] = arr[i++];
    return out;
  }

  // node_modules/effect/dist/esm/internal/hashMap/node.js
  class EmptyNode {
    _tag = "EmptyNode";
    modify(edit, _shift, f, hash2, key, size) {
      const v = f(none2());
      if (isNone2(v))
        return new EmptyNode;
      ++size.value;
      return new LeafNode(edit, hash2, key, v);
    }
  }
  function isEmptyNode(a) {
    return isTagged(a, "EmptyNode");
  }
  function isLeafNode(node) {
    return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
  }
  function canEditNode(node, edit) {
    return isEmptyNode(node) ? false : edit === node.edit;
  }

  class LeafNode {
    edit;
    hash;
    key;
    value;
    _tag = "LeafNode";
    constructor(edit, hash2, key, value) {
      this.edit = edit;
      this.hash = hash2;
      this.key = key;
      this.value = value;
    }
    modify(edit, shift, f, hash2, key, size) {
      if (equals(key, this.key)) {
        const v2 = f(this.value);
        if (v2 === this.value)
          return this;
        else if (isNone2(v2)) {
          --size.value;
          return new EmptyNode;
        }
        if (canEditNode(this, edit)) {
          this.value = v2;
          return this;
        }
        return new LeafNode(edit, hash2, key, v2);
      }
      const v = f(none2());
      if (isNone2(v))
        return this;
      ++size.value;
      return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
    }
  }

  class CollisionNode {
    edit;
    hash;
    children;
    _tag = "CollisionNode";
    constructor(edit, hash2, children) {
      this.edit = edit;
      this.hash = hash2;
      this.children = children;
    }
    modify(edit, shift, f, hash2, key, size) {
      if (hash2 === this.hash) {
        const canEdit = canEditNode(this, edit);
        const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size);
        if (list === this.children)
          return this;
        return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0];
      }
      const v = f(none2());
      if (isNone2(v))
        return this;
      ++size.value;
      return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
    }
    updateCollisionList(mutate, edit, hash2, list, f, key, size) {
      const len = list.length;
      for (let i = 0;i < len; ++i) {
        const child = list[i];
        if ("key" in child && equals(key, child.key)) {
          const value = child.value;
          const newValue2 = f(value);
          if (newValue2 === value)
            return list;
          if (isNone2(newValue2)) {
            --size.value;
            return arraySpliceOut(mutate, i, list);
          }
          return arrayUpdate(mutate, i, new LeafNode(edit, hash2, key, newValue2), list);
        }
      }
      const newValue = f(none2());
      if (isNone2(newValue))
        return list;
      ++size.value;
      return arrayUpdate(mutate, len, new LeafNode(edit, hash2, key, newValue), list);
    }
  }

  class IndexedNode {
    edit;
    mask;
    children;
    _tag = "IndexedNode";
    constructor(edit, mask, children) {
      this.edit = edit;
      this.mask = mask;
      this.children = children;
    }
    modify(edit, shift, f, hash2, key, size) {
      const mask = this.mask;
      const children = this.children;
      const frag = hashFragment(shift, hash2);
      const bit = toBitmap(frag);
      const indx = fromBitmap(mask, bit);
      const exists2 = mask & bit;
      const canEdit = canEditNode(this, edit);
      if (!exists2) {
        const _newChild = new EmptyNode().modify(edit, shift + SIZE, f, hash2, key, size);
        if (!_newChild)
          return this;
        return children.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children) : new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children));
      }
      const current = children[indx];
      const child = current.modify(edit, shift + SIZE, f, hash2, key, size);
      if (current === child)
        return this;
      let bitmap = mask;
      let newChildren;
      if (isEmptyNode(child)) {
        bitmap &= ~bit;
        if (!bitmap)
          return new EmptyNode;
        if (children.length <= 2 && isLeafNode(children[indx ^ 1])) {
          return children[indx ^ 1];
        }
        newChildren = arraySpliceOut(canEdit, indx, children);
      } else {
        newChildren = arrayUpdate(canEdit, indx, child, children);
      }
      if (canEdit) {
        this.mask = bitmap;
        this.children = newChildren;
        return this;
      }
      return new IndexedNode(edit, bitmap, newChildren);
    }
  }

  class ArrayNode {
    edit;
    size;
    children;
    _tag = "ArrayNode";
    constructor(edit, size, children) {
      this.edit = edit;
      this.size = size;
      this.children = children;
    }
    modify(edit, shift, f, hash2, key, size) {
      let count = this.size;
      const children = this.children;
      const frag = hashFragment(shift, hash2);
      const child = children[frag];
      const newChild = (child || new EmptyNode).modify(edit, shift + SIZE, f, hash2, key, size);
      if (child === newChild)
        return this;
      const canEdit = canEditNode(this, edit);
      let newChildren;
      if (isEmptyNode(child) && !isEmptyNode(newChild)) {
        ++count;
        newChildren = arrayUpdate(canEdit, frag, newChild, children);
      } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
        --count;
        if (count <= MIN_ARRAY_NODE) {
          return pack(edit, count, frag, children);
        }
        newChildren = arrayUpdate(canEdit, frag, new EmptyNode, children);
      } else {
        newChildren = arrayUpdate(canEdit, frag, newChild, children);
      }
      if (canEdit) {
        this.size = count;
        this.children = newChildren;
        return this;
      }
      return new ArrayNode(edit, count, newChildren);
    }
  }
  function pack(edit, count, removed, elements) {
    const children = new Array(count - 1);
    let g = 0;
    let bitmap = 0;
    for (let i = 0, len = elements.length;i < len; ++i) {
      if (i !== removed) {
        const elem = elements[i];
        if (elem && !isEmptyNode(elem)) {
          children[g++] = elem;
          bitmap |= 1 << i;
        }
      }
    }
    return new IndexedNode(edit, bitmap, children);
  }
  function expand(edit, frag, child, bitmap, subNodes) {
    const arr = [];
    let bit = bitmap;
    let count = 0;
    for (let i = 0;bit; ++i) {
      if (bit & 1)
        arr[i] = subNodes[count++];
      bit >>>= 1;
    }
    arr[frag] = child;
    return new ArrayNode(edit, count + 1, arr);
  }
  function mergeLeavesInner(edit, shift, h1, n1, h2, n2) {
    if (h1 === h2)
      return new CollisionNode(edit, h1, [n2, n1]);
    const subH1 = hashFragment(shift, h1);
    const subH2 = hashFragment(shift, h2);
    if (subH1 === subH2) {
      return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
    } else {
      const children = subH1 < subH2 ? [n1, n2] : [n2, n1];
      return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children);
    }
  }
  function mergeLeaves(edit, shift, h1, n1, h2, n2) {
    let stack = undefined;
    let currentShift = shift;
    while (true) {
      const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
      if (typeof res === "function") {
        stack = make8(res, stack);
        currentShift = currentShift + SIZE;
      } else {
        let final = res;
        while (stack != null) {
          final = stack.value(final);
          stack = stack.previous;
        }
        return final;
      }
    }
  }

  // node_modules/effect/dist/esm/internal/hashMap.js
  var HashMapSymbolKey = "effect/HashMap";
  var HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
  var HashMapProto = {
    [HashMapTypeId]: HashMapTypeId,
    [Symbol.iterator]() {
      return new HashMapIterator(this, (k, v) => [k, v]);
    },
    [symbol]() {
      let hash2 = hash(HashMapSymbolKey);
      for (const item of this) {
        hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
      }
      return cached(this, hash2);
    },
    [symbol2](that) {
      if (isHashMap(that)) {
        if (that._size !== this._size) {
          return false;
        }
        for (const item of this) {
          const elem = pipe(that, getHash(item[0], hash(item[0])));
          if (isNone2(elem)) {
            return false;
          } else {
            if (!equals(item[1], elem.value)) {
              return false;
            }
          }
        }
        return true;
      }
      return false;
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "HashMap",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var makeImpl = (editable, edit, root, size) => {
    const map5 = Object.create(HashMapProto);
    map5._editable = editable;
    map5._edit = edit;
    map5._root = root;
    map5._size = size;
    return map5;
  };

  class HashMapIterator {
    map;
    f;
    v;
    constructor(map5, f) {
      this.map = map5;
      this.f = f;
      this.v = visitLazy(this.map._root, this.f, undefined);
    }
    next() {
      if (isNone2(this.v)) {
        return {
          done: true,
          value: undefined
        };
      }
      const v0 = this.v.value;
      this.v = applyCont(v0.cont);
      return {
        done: false,
        value: v0.value
      };
    }
    [Symbol.iterator]() {
      return new HashMapIterator(this.map, this.f);
    }
  }
  var applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2();
  var visitLazy = (node, f, cont = undefined) => {
    switch (node._tag) {
      case "LeafNode": {
        if (isSome2(node.value)) {
          return some2({
            value: f(node.key, node.value.value),
            cont
          });
        }
        return applyCont(cont);
      }
      case "CollisionNode":
      case "ArrayNode":
      case "IndexedNode": {
        const children = node.children;
        return visitLazyChildren(children.length, children, 0, f, cont);
      }
      default: {
        return applyCont(cont);
      }
    }
  };
  var visitLazyChildren = (len, children, i, f, cont) => {
    while (i < len) {
      const child = children[i++];
      if (child && !isEmptyNode(child)) {
        return visitLazy(child, f, [len, children, i, f, cont]);
      }
    }
    return applyCont(cont);
  };
  var _empty3 = /* @__PURE__ */ makeImpl(false, 0, /* @__PURE__ */ new EmptyNode, 0);
  var empty6 = () => _empty3;
  var fromIterable3 = (entries) => {
    const map5 = beginMutation(empty6());
    for (const entry of entries) {
      set(map5, entry[0], entry[1]);
    }
    return endMutation(map5);
  };
  var isHashMap = (u) => hasProperty(u, HashMapTypeId);
  var isEmpty2 = (self2) => self2 && isEmptyNode(self2._root);
  var get5 = /* @__PURE__ */ dual(2, (self2, key) => getHash(self2, key, hash(key)));
  var getHash = /* @__PURE__ */ dual(3, (self2, key, hash2) => {
    let node = self2._root;
    let shift = 0;
    while (true) {
      switch (node._tag) {
        case "LeafNode": {
          return equals(key, node.key) ? node.value : none2();
        }
        case "CollisionNode": {
          if (hash2 === node.hash) {
            const children = node.children;
            for (let i = 0, len = children.length;i < len; ++i) {
              const child = children[i];
              if ("key" in child && equals(key, child.key)) {
                return child.value;
              }
            }
          }
          return none2();
        }
        case "IndexedNode": {
          const frag = hashFragment(shift, hash2);
          const bit = toBitmap(frag);
          if (node.mask & bit) {
            node = node.children[fromBitmap(node.mask, bit)];
            shift += SIZE;
            break;
          }
          return none2();
        }
        case "ArrayNode": {
          node = node.children[hashFragment(shift, hash2)];
          if (node) {
            shift += SIZE;
            break;
          }
          return none2();
        }
        default:
          return none2();
      }
    }
  });
  var has = /* @__PURE__ */ dual(2, (self2, key) => isSome2(getHash(self2, key, hash(key))));
  var set = /* @__PURE__ */ dual(3, (self2, key, value) => modifyAt(self2, key, () => some2(value)));
  var setTree = /* @__PURE__ */ dual(3, (self2, newRoot, newSize) => {
    if (self2._editable) {
      self2._root = newRoot;
      self2._size = newSize;
      return self2;
    }
    return newRoot === self2._root ? self2 : makeImpl(self2._editable, self2._edit, newRoot, newSize);
  });
  var keys = (self2) => new HashMapIterator(self2, (key) => key);
  var size = (self2) => self2._size;
  var beginMutation = (self2) => makeImpl(true, self2._edit + 1, self2._root, self2._size);
  var endMutation = (self2) => {
    self2._editable = false;
    return self2;
  };
  var mutate = /* @__PURE__ */ dual(2, (self2, f) => {
    const transient = beginMutation(self2);
    f(transient);
    return endMutation(transient);
  });
  var modifyAt = /* @__PURE__ */ dual(3, (self2, key, f) => modifyHash(self2, key, hash(key), f));
  var modifyHash = /* @__PURE__ */ dual(4, (self2, key, hash2, f) => {
    const size2 = {
      value: self2._size
    };
    const newRoot = self2._root.modify(self2._editable ? self2._edit : NaN, 0, f, hash2, key, size2);
    return pipe(self2, setTree(newRoot, size2.value));
  });
  var remove2 = /* @__PURE__ */ dual(2, (self2, key) => modifyAt(self2, key, none2));
  var map5 = /* @__PURE__ */ dual(2, (self2, f) => reduce3(self2, empty6(), (map6, value, key) => set(map6, key, f(value, key))));
  var forEach = /* @__PURE__ */ dual(2, (self2, f) => reduce3(self2, undefined, (_, value, key) => f(value, key)));
  var reduce3 = /* @__PURE__ */ dual(3, (self2, zero2, f) => {
    const root = self2._root;
    if (root._tag === "LeafNode") {
      return isSome2(root.value) ? f(zero2, root.value.value, root.key) : zero2;
    }
    if (root._tag === "EmptyNode") {
      return zero2;
    }
    const toVisit = [root.children];
    let children;
    while (children = toVisit.pop()) {
      for (let i = 0, len = children.length;i < len; ) {
        const child = children[i++];
        if (child && !isEmptyNode(child)) {
          if (child._tag === "LeafNode") {
            if (isSome2(child.value)) {
              zero2 = f(zero2, child.value.value, child.key);
            }
          } else {
            toVisit.push(child.children);
          }
        }
      }
    }
    return zero2;
  });

  // node_modules/effect/dist/esm/internal/hashSet.js
  var HashSetSymbolKey = "effect/HashSet";
  var HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
  var HashSetProto = {
    [HashSetTypeId]: HashSetTypeId,
    [Symbol.iterator]() {
      return keys(this._keyMap);
    },
    [symbol]() {
      return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
    },
    [symbol2](that) {
      if (isHashSet(that)) {
        return size(this._keyMap) === size(that._keyMap) && equals(this._keyMap, that._keyMap);
      }
      return false;
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "HashSet",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var makeImpl2 = (keyMap) => {
    const set2 = Object.create(HashSetProto);
    set2._keyMap = keyMap;
    return set2;
  };
  var isHashSet = (u) => hasProperty(u, HashSetTypeId);
  var _empty4 = /* @__PURE__ */ makeImpl2(/* @__PURE__ */ empty6());
  var empty7 = () => _empty4;
  var fromIterable4 = (elements) => {
    const set2 = beginMutation2(empty7());
    for (const value of elements) {
      add3(set2, value);
    }
    return endMutation2(set2);
  };
  var make9 = (...elements) => {
    const set2 = beginMutation2(empty7());
    for (const value of elements) {
      add3(set2, value);
    }
    return endMutation2(set2);
  };
  var has2 = /* @__PURE__ */ dual(2, (self2, value) => has(self2._keyMap, value));
  var size2 = (self2) => size(self2._keyMap);
  var beginMutation2 = (self2) => makeImpl2(beginMutation(self2._keyMap));
  var endMutation2 = (self2) => {
    self2._keyMap._editable = false;
    return self2;
  };
  var mutate2 = /* @__PURE__ */ dual(2, (self2, f) => {
    const transient = beginMutation2(self2);
    f(transient);
    return endMutation2(transient);
  });
  var add3 = /* @__PURE__ */ dual(2, (self2, value) => self2._keyMap._editable ? (set(value, true)(self2._keyMap), self2) : makeImpl2(set(value, true)(self2._keyMap)));
  var remove3 = /* @__PURE__ */ dual(2, (self2, value) => self2._keyMap._editable ? (remove2(value)(self2._keyMap), self2) : makeImpl2(remove2(value)(self2._keyMap)));
  var difference2 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(self2, (set2) => {
    for (const value of that) {
      remove3(set2, value);
    }
  }));
  var union2 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(empty7(), (set2) => {
    forEach2(self2, (value) => add3(set2, value));
    for (const value of that) {
      add3(set2, value);
    }
  }));
  var forEach2 = /* @__PURE__ */ dual(2, (self2, f) => forEach(self2._keyMap, (_, k) => f(k)));
  var reduce4 = /* @__PURE__ */ dual(3, (self2, zero2, f) => reduce3(self2._keyMap, zero2, (z, _, a) => f(z, a)));

  // node_modules/effect/dist/esm/HashSet.js
  var empty8 = empty7;
  var fromIterable5 = fromIterable4;
  var make10 = make9;
  var has3 = has2;
  var size3 = size2;
  var add4 = add3;
  var remove4 = remove3;
  var difference3 = difference2;
  var union3 = union2;
  var forEach3 = forEach2;
  var reduce5 = reduce4;

  // node_modules/effect/dist/esm/MutableRef.js
  var TypeId6 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
  var MutableRefProto = {
    [TypeId6]: TypeId6,
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "MutableRef",
        current: toJSON(this.current)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var make11 = (value) => {
    const ref = Object.create(MutableRefProto);
    ref.current = value;
    return ref;
  };
  var compareAndSet = /* @__PURE__ */ dual(3, (self2, oldValue, newValue) => {
    if (equals(oldValue, self2.current)) {
      self2.current = newValue;
      return true;
    }
    return false;
  });
  var get6 = (self2) => self2.current;
  var set2 = /* @__PURE__ */ dual(2, (self2, value) => {
    self2.current = value;
    return self2;
  });

  // node_modules/effect/dist/esm/internal/fiberId.js
  var FiberIdSymbolKey = "effect/FiberId";
  var FiberIdTypeId = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
  var OP_NONE = "None";
  var OP_RUNTIME = "Runtime";
  var OP_COMPOSITE = "Composite";
  var emptyHash = /* @__PURE__ */ string(`${FiberIdSymbolKey}-${OP_NONE}`);

  class None {
    [FiberIdTypeId] = FiberIdTypeId;
    _tag = OP_NONE;
    id = -1;
    startTimeMillis = -1;
    [symbol]() {
      return emptyHash;
    }
    [symbol2](that) {
      return isFiberId(that) && that._tag === OP_NONE;
    }
    toString() {
      return format(this.toJSON());
    }
    toJSON() {
      return {
        _id: "FiberId",
        _tag: this._tag
      };
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  }

  class Runtime {
    id;
    startTimeMillis;
    [FiberIdTypeId] = FiberIdTypeId;
    _tag = OP_RUNTIME;
    constructor(id, startTimeMillis) {
      this.id = id;
      this.startTimeMillis = startTimeMillis;
    }
    [symbol]() {
      return cached(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
    }
    [symbol2](that) {
      return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
    }
    toString() {
      return format(this.toJSON());
    }
    toJSON() {
      return {
        _id: "FiberId",
        _tag: this._tag,
        id: this.id,
        startTimeMillis: this.startTimeMillis
      };
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  }

  class Composite {
    left;
    right;
    [FiberIdTypeId] = FiberIdTypeId;
    _tag = OP_COMPOSITE;
    constructor(left3, right3) {
      this.left = left3;
      this.right = right3;
    }
    _hash;
    [symbol]() {
      return pipe(string(`${FiberIdSymbolKey}-${this._tag}`), combine(hash(this.left)), combine(hash(this.right)), cached(this));
    }
    [symbol2](that) {
      return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
    }
    toString() {
      return format(this.toJSON());
    }
    toJSON() {
      return {
        _id: "FiberId",
        _tag: this._tag,
        left: toJSON(this.left),
        right: toJSON(this.right)
      };
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  }
  var none3 = /* @__PURE__ */ new None;
  var runtime = (id, startTimeMillis) => {
    return new Runtime(id, startTimeMillis);
  };
  var composite = (left3, right3) => {
    return new Composite(left3, right3);
  };
  var isFiberId = (self2) => hasProperty(self2, FiberIdTypeId);
  var combine2 = /* @__PURE__ */ dual(2, (self2, that) => {
    if (self2._tag === OP_NONE) {
      return that;
    }
    if (that._tag === OP_NONE) {
      return self2;
    }
    return new Composite(self2, that);
  });
  var combineAll = (fiberIds) => {
    return pipe(fiberIds, reduce5(none3, (a, b) => combine2(b)(a)));
  };
  var ids = (self2) => {
    switch (self2._tag) {
      case OP_NONE: {
        return empty8();
      }
      case OP_RUNTIME: {
        return make10(self2.id);
      }
      case OP_COMPOSITE: {
        return pipe(ids(self2.left), union3(ids(self2.right)));
      }
    }
  };
  var _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make11(0));
  var make12 = (id, startTimeSeconds) => {
    return new Runtime(id, startTimeSeconds);
  };
  var threadName = (self2) => {
    const identifiers = Array.from(ids(self2)).map((n) => `#${n}`).join(",");
    return identifiers;
  };
  var unsafeMake2 = () => {
    const id = get6(_fiberCounter);
    pipe(_fiberCounter, set2(id + 1));
    return new Runtime(id, Date.now());
  };

  // node_modules/effect/dist/esm/FiberId.js
  var none4 = none3;
  var runtime2 = runtime;
  var composite2 = composite;
  var combine3 = combine2;
  var combineAll2 = combineAll;
  var ids2 = ids;
  var make13 = make12;
  var threadName2 = threadName;
  var unsafeMake3 = unsafeMake2;

  // node_modules/effect/dist/esm/HashMap.js
  var empty9 = empty6;
  var fromIterable6 = fromIterable3;
  var isEmpty3 = isEmpty2;
  var get7 = get5;
  var set3 = set;
  var keys2 = keys;
  var mutate3 = mutate;
  var modifyAt2 = modifyAt;
  var map7 = map5;
  var forEach4 = forEach;
  var reduce6 = reduce3;

  // node_modules/effect/dist/esm/List.js
  var TypeId7 = /* @__PURE__ */ Symbol.for("effect/List");
  var toArray3 = (self2) => fromIterable(self2);
  var getEquivalence3 = (isEquivalent) => mapInput(getEquivalence(isEquivalent), toArray3);
  var _equivalence4 = /* @__PURE__ */ getEquivalence3(equals);
  var ConsProto = {
    [TypeId7]: TypeId7,
    _tag: "Cons",
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "List",
        _tag: "Cons",
        values: toArray3(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    [symbol2](that) {
      return isList(that) && this._tag === that._tag && _equivalence4(this, that);
    },
    [symbol]() {
      return cached(this, array2(toArray3(this)));
    },
    [Symbol.iterator]() {
      let done = false;
      let self2 = this;
      return {
        next() {
          if (done) {
            return this.return();
          }
          if (self2._tag === "Nil") {
            done = true;
            return this.return();
          }
          const value = self2.head;
          self2 = self2.tail;
          return {
            done,
            value
          };
        },
        return(value) {
          if (!done) {
            done = true;
          }
          return {
            done: true,
            value
          };
        }
      };
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var makeCons = (head3, tail) => {
    const cons = Object.create(ConsProto);
    cons.head = head3;
    cons.tail = tail;
    return cons;
  };
  var NilHash = /* @__PURE__ */ string("Nil");
  var NilProto = {
    [TypeId7]: TypeId7,
    _tag: "Nil",
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "List",
        _tag: "Nil"
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    [symbol]() {
      return NilHash;
    },
    [symbol2](that) {
      return isList(that) && this._tag === that._tag;
    },
    [Symbol.iterator]() {
      return {
        next() {
          return {
            done: true,
            value: undefined
          };
        }
      };
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var _Nil = /* @__PURE__ */ Object.create(NilProto);
  var isList = (u) => hasProperty(u, TypeId7);
  var isNil = (self2) => self2._tag === "Nil";
  var isCons = (self2) => self2._tag === "Cons";
  var nil = () => _Nil;
  var cons = (head3, tail) => makeCons(head3, tail);
  var empty10 = nil;
  var of3 = (value) => makeCons(value, _Nil);
  var appendAll3 = /* @__PURE__ */ dual(2, (self2, that) => prependAll(that, self2));
  var prepend3 = /* @__PURE__ */ dual(2, (self2, element) => cons(element, self2));
  var prependAll = /* @__PURE__ */ dual(2, (self2, prefix) => {
    if (isNil(self2)) {
      return prefix;
    } else if (isNil(prefix)) {
      return self2;
    } else {
      const result = makeCons(prefix.head, self2);
      let curr = result;
      let that = prefix.tail;
      while (!isNil(that)) {
        const temp = makeCons(that.head, self2);
        curr.tail = temp;
        curr = temp;
        that = that.tail;
      }
      return result;
    }
  });
  var reduce7 = /* @__PURE__ */ dual(3, (self2, zero2, f) => {
    let acc = zero2;
    let these = self2;
    while (!isNil(these)) {
      acc = f(acc, these.head);
      these = these.tail;
    }
    return acc;
  });
  var reverse3 = (self2) => {
    let result = empty10();
    let these = self2;
    while (!isNil(these)) {
      result = prepend3(result, these.head);
      these = these.tail;
    }
    return result;
  };

  // node_modules/effect/dist/esm/internal/data.js
  var ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
    [symbol]() {
      return cached(this, array2(this));
    },
    [symbol2](that) {
      if (Array.isArray(that) && this.length === that.length) {
        return this.every((v, i) => equals(v, that[i]));
      } else {
        return false;
      }
    }
  });
  var Structural = /* @__PURE__ */ function() {
    function Structural2(args) {
      if (args) {
        Object.assign(this, args);
      }
    }
    Structural2.prototype = StructuralPrototype;
    return Structural2;
  }();
  var struct = (as) => Object.assign(Object.create(StructuralPrototype), as);

  // node_modules/effect/dist/esm/internal/differ/contextPatch.js
  var ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
  function variance(a) {
    return a;
  }
  var PatchProto = {
    ...Structural.prototype,
    [ContextPatchTypeId]: {
      _Value: variance,
      _Patch: variance
    }
  };
  var EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
    _tag: "Empty"
  });
  var _empty5 = /* @__PURE__ */ Object.create(EmptyProto);
  var empty11 = () => _empty5;
  var AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
    _tag: "AndThen"
  });
  var makeAndThen = (first, second) => {
    const o = Object.create(AndThenProto);
    o.first = first;
    o.second = second;
    return o;
  };
  var AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
    _tag: "AddService"
  });
  var makeAddService = (key, service) => {
    const o = Object.create(AddServiceProto);
    o.key = key;
    o.service = service;
    return o;
  };
  var RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
    _tag: "RemoveService"
  });
  var makeRemoveService = (key) => {
    const o = Object.create(RemoveServiceProto);
    o.key = key;
    return o;
  };
  var UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
    _tag: "UpdateService"
  });
  var makeUpdateService = (key, update) => {
    const o = Object.create(UpdateServiceProto);
    o.key = key;
    o.update = update;
    return o;
  };
  var diff = (oldValue, newValue) => {
    const missingServices = new Map(oldValue.unsafeMap);
    let patch = empty11();
    for (const [tag, newService] of newValue.unsafeMap.entries()) {
      if (missingServices.has(tag)) {
        const old = missingServices.get(tag);
        missingServices.delete(tag);
        if (!equals(old, newService)) {
          patch = combine4(makeUpdateService(tag, () => newService))(patch);
        }
      } else {
        missingServices.delete(tag);
        patch = combine4(makeAddService(tag, newService))(patch);
      }
    }
    for (const [tag] of missingServices.entries()) {
      patch = combine4(makeRemoveService(tag))(patch);
    }
    return patch;
  };
  var combine4 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen(self2, that));
  var patch = /* @__PURE__ */ dual(2, (self2, context) => {
    if (self2._tag === "Empty") {
      return context;
    }
    let wasServiceUpdated = false;
    let patches = of2(self2);
    const updatedContext = new Map(context.unsafeMap);
    while (isNonEmpty2(patches)) {
      const head3 = headNonEmpty2(patches);
      const tail = tailNonEmpty2(patches);
      switch (head3._tag) {
        case "Empty": {
          patches = tail;
          break;
        }
        case "AddService": {
          updatedContext.set(head3.key, head3.service);
          patches = tail;
          break;
        }
        case "AndThen": {
          patches = prepend2(prepend2(tail, head3.second), head3.first);
          break;
        }
        case "RemoveService": {
          updatedContext.delete(head3.key);
          patches = tail;
          break;
        }
        case "UpdateService": {
          updatedContext.set(head3.key, head3.update(updatedContext.get(head3.key)));
          wasServiceUpdated = true;
          patches = tail;
          break;
        }
      }
    }
    if (!wasServiceUpdated) {
      return makeContext(updatedContext);
    }
    const map8 = new Map;
    for (const [tag] of context.unsafeMap) {
      if (updatedContext.has(tag)) {
        map8.set(tag, updatedContext.get(tag));
        updatedContext.delete(tag);
      }
    }
    for (const [tag, s] of updatedContext) {
      map8.set(tag, s);
    }
    return makeContext(map8);
  });

  // node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
  var HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
  function variance2(a) {
    return a;
  }
  var PatchProto2 = {
    ...Structural.prototype,
    [HashSetPatchTypeId]: {
      _Value: variance2,
      _Key: variance2,
      _Patch: variance2
    }
  };
  var EmptyProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
    _tag: "Empty"
  });
  var _empty6 = /* @__PURE__ */ Object.create(EmptyProto2);
  var empty12 = () => _empty6;
  var AndThenProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
    _tag: "AndThen"
  });
  var makeAndThen2 = (first, second) => {
    const o = Object.create(AndThenProto2);
    o.first = first;
    o.second = second;
    return o;
  };
  var AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
    _tag: "Add"
  });
  var makeAdd = (value) => {
    const o = Object.create(AddProto);
    o.value = value;
    return o;
  };
  var RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
    _tag: "Remove"
  });
  var makeRemove = (value) => {
    const o = Object.create(RemoveProto);
    o.value = value;
    return o;
  };
  var diff2 = (oldValue, newValue) => {
    const [removed, patch2] = reduce5([oldValue, empty12()], ([set4, patch3], value) => {
      if (has3(value)(set4)) {
        return [remove4(value)(set4), patch3];
      }
      return [set4, combine5(makeAdd(value))(patch3)];
    })(newValue);
    return reduce5(patch2, (patch3, value) => combine5(makeRemove(value))(patch3))(removed);
  };
  var combine5 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen2(self2, that));
  var patch2 = /* @__PURE__ */ dual(2, (self2, oldValue) => {
    if (self2._tag === "Empty") {
      return oldValue;
    }
    let set4 = oldValue;
    let patches = of2(self2);
    while (isNonEmpty2(patches)) {
      const head3 = headNonEmpty2(patches);
      const tail = tailNonEmpty2(patches);
      switch (head3._tag) {
        case "Empty": {
          patches = tail;
          break;
        }
        case "AndThen": {
          patches = prepend2(head3.first)(prepend2(head3.second)(tail));
          break;
        }
        case "Add": {
          set4 = add4(head3.value)(set4);
          patches = tail;
          break;
        }
        case "Remove": {
          set4 = remove4(head3.value)(set4);
          patches = tail;
        }
      }
    }
    return set4;
  });

  // node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
  var ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
  function variance3(a) {
    return a;
  }
  var PatchProto3 = {
    ...Structural.prototype,
    [ReadonlyArrayPatchTypeId]: {
      _Value: variance3,
      _Patch: variance3
    }
  };
  var EmptyProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
    _tag: "Empty"
  });
  var _empty7 = /* @__PURE__ */ Object.create(EmptyProto3);
  var empty13 = () => _empty7;
  var AndThenProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
    _tag: "AndThen"
  });
  var makeAndThen3 = (first, second) => {
    const o = Object.create(AndThenProto3);
    o.first = first;
    o.second = second;
    return o;
  };
  var AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
    _tag: "Append"
  });
  var makeAppend = (values3) => {
    const o = Object.create(AppendProto);
    o.values = values3;
    return o;
  };
  var SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
    _tag: "Slice"
  });
  var makeSlice = (from, until) => {
    const o = Object.create(SliceProto);
    o.from = from;
    o.until = until;
    return o;
  };
  var UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
    _tag: "Update"
  });
  var makeUpdate = (index, patch3) => {
    const o = Object.create(UpdateProto);
    o.index = index;
    o.patch = patch3;
    return o;
  };
  var diff3 = (options) => {
    let i = 0;
    let patch3 = empty13();
    while (i < options.oldValue.length && i < options.newValue.length) {
      const oldElement = options.oldValue[i];
      const newElement = options.newValue[i];
      const valuePatch = options.differ.diff(oldElement, newElement);
      if (!equals(valuePatch, options.differ.empty)) {
        patch3 = combine6(patch3, makeUpdate(i, valuePatch));
      }
      i = i + 1;
    }
    if (i < options.oldValue.length) {
      patch3 = combine6(patch3, makeSlice(0, i));
    }
    if (i < options.newValue.length) {
      patch3 = combine6(patch3, makeAppend(drop(i)(options.newValue)));
    }
    return patch3;
  };
  var combine6 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen3(self2, that));
  var patch3 = /* @__PURE__ */ dual(3, (self2, oldValue, differ) => {
    if (self2._tag === "Empty") {
      return oldValue;
    }
    let readonlyArray = oldValue.slice();
    let patches = of(self2);
    while (isNonEmptyArray2(patches)) {
      const head3 = headNonEmpty(patches);
      const tail = tailNonEmpty(patches);
      switch (head3._tag) {
        case "Empty": {
          patches = tail;
          break;
        }
        case "AndThen": {
          tail.unshift(head3.first, head3.second);
          patches = tail;
          break;
        }
        case "Append": {
          for (const value of head3.values) {
            readonlyArray.push(value);
          }
          patches = tail;
          break;
        }
        case "Slice": {
          readonlyArray = readonlyArray.slice(head3.from, head3.until);
          patches = tail;
          break;
        }
        case "Update": {
          readonlyArray[head3.index] = differ.patch(head3.patch, readonlyArray[head3.index]);
          patches = tail;
          break;
        }
      }
    }
    return readonlyArray;
  });

  // node_modules/effect/dist/esm/internal/differ.js
  var DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
  var DifferProto = {
    [DifferTypeId]: {
      _P: identity,
      _V: identity
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var make15 = (params) => {
    const differ = Object.create(DifferProto);
    differ.empty = params.empty;
    differ.diff = params.diff;
    differ.combine = params.combine;
    differ.patch = params.patch;
    return differ;
  };
  var environment = () => make15({
    empty: empty11(),
    combine: (first, second) => combine4(second)(first),
    diff: (oldValue, newValue) => diff(oldValue, newValue),
    patch: (patch4, oldValue) => patch(oldValue)(patch4)
  });
  var hashSet = () => make15({
    empty: empty12(),
    combine: (first, second) => combine5(second)(first),
    diff: (oldValue, newValue) => diff2(oldValue, newValue),
    patch: (patch4, oldValue) => patch2(oldValue)(patch4)
  });
  var readonlyArray = (differ) => make15({
    empty: empty13(),
    combine: (first, second) => combine6(first, second),
    diff: (oldValue, newValue) => diff3({
      oldValue,
      newValue,
      differ
    }),
    patch: (patch4, oldValue) => patch3(patch4, oldValue, differ)
  });
  var update = () => updateWith((_, a) => a);
  var updateWith = (f) => make15({
    empty: identity,
    combine: (first, second) => {
      if (first === identity) {
        return second;
      }
      if (second === identity) {
        return first;
      }
      return (a) => second(first(a));
    },
    diff: (oldValue, newValue) => {
      if (equals(oldValue, newValue)) {
        return identity;
      }
      return constant(newValue);
    },
    patch: (patch4, oldValue) => f(oldValue, patch4(oldValue))
  });

  // node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
  var BIT_MASK = 255;
  var BIT_SHIFT = 8;
  var active = (patch4) => patch4 & BIT_MASK;
  var enabled = (patch4) => patch4 >> BIT_SHIFT & BIT_MASK;
  var make16 = (active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT);
  var empty14 = /* @__PURE__ */ make16(0, 0);
  var enable = (flag) => make16(flag, flag);
  var disable = (flag) => make16(flag, 0);
  var exclude = /* @__PURE__ */ dual(2, (self2, flag) => make16(active(self2) & ~flag, enabled(self2)));
  var andThen = /* @__PURE__ */ dual(2, (self2, that) => self2 | that);
  var invert = (n) => ~n >>> 0 & BIT_MASK;

  // node_modules/effect/dist/esm/internal/runtimeFlags.js
  var None2 = 0;
  var Interruption = 1 << 0;
  var OpSupervision = 1 << 1;
  var RuntimeMetrics = 1 << 2;
  var WindDown = 1 << 4;
  var CooperativeYielding = 1 << 5;
  var cooperativeYielding = (self2) => isEnabled(self2, CooperativeYielding);
  var disable2 = /* @__PURE__ */ dual(2, (self2, flag) => self2 & ~flag);
  var enable2 = /* @__PURE__ */ dual(2, (self2, flag) => self2 | flag);
  var interruptible = (self2) => interruption(self2) && !windDown(self2);
  var interruption = (self2) => isEnabled(self2, Interruption);
  var isEnabled = /* @__PURE__ */ dual(2, (self2, flag) => (self2 & flag) !== 0);
  var make17 = (...flags) => flags.reduce((a, b) => a | b, 0);
  var none5 = /* @__PURE__ */ make17(None2);
  var runtimeMetrics = (self2) => isEnabled(self2, RuntimeMetrics);
  var windDown = (self2) => isEnabled(self2, WindDown);
  var diff4 = /* @__PURE__ */ dual(2, (self2, that) => make16(self2 ^ that, that));
  var patch4 = /* @__PURE__ */ dual(2, (self2, patch5) => self2 & (invert(active(patch5)) | enabled(patch5)) | active(patch5) & enabled(patch5));
  var differ = /* @__PURE__ */ make15({
    empty: empty14,
    diff: (oldValue, newValue) => diff4(oldValue, newValue),
    combine: (first, second) => andThen(second)(first),
    patch: (_patch, oldValue) => patch4(oldValue, _patch)
  });

  // node_modules/effect/dist/esm/RuntimeFlagsPatch.js
  var empty15 = empty14;
  var enable3 = enable;
  var disable3 = disable;
  var exclude2 = exclude;

  // node_modules/effect/dist/esm/internal/blockedRequests.js
  var empty16 = {
    _tag: "Empty"
  };
  var par = (self2, that) => ({
    _tag: "Par",
    left: self2,
    right: that
  });
  var seq = (self2, that) => ({
    _tag: "Seq",
    left: self2,
    right: that
  });
  var single = (dataSource, blockedRequest) => ({
    _tag: "Single",
    dataSource,
    blockedRequest
  });
  var flatten4 = (self2) => {
    let current = of3(self2);
    let updated = empty10();
    while (true) {
      const [parallel, sequential] = reduce7(current, [parallelCollectionEmpty(), empty10()], ([parallel2, sequential2], blockedRequest) => {
        const [par2, seq2] = step(blockedRequest);
        return [parallelCollectionCombine(parallel2, par2), appendAll3(sequential2, seq2)];
      });
      updated = merge4(updated, parallel);
      if (isNil(sequential)) {
        return reverse3(updated);
      }
      current = sequential;
    }
    throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
  };
  var step = (requests) => {
    let current = requests;
    let parallel = parallelCollectionEmpty();
    let stack = empty10();
    let sequential = empty10();
    while (true) {
      switch (current._tag) {
        case "Empty": {
          if (isNil(stack)) {
            return [parallel, sequential];
          }
          current = stack.head;
          stack = stack.tail;
          break;
        }
        case "Par": {
          stack = cons(current.right, stack);
          current = current.left;
          break;
        }
        case "Seq": {
          const left3 = current.left;
          const right3 = current.right;
          switch (left3._tag) {
            case "Empty": {
              current = right3;
              break;
            }
            case "Par": {
              const l = left3.left;
              const r = left3.right;
              current = par(seq(l, right3), seq(r, right3));
              break;
            }
            case "Seq": {
              const l = left3.left;
              const r = left3.right;
              current = seq(l, seq(r, right3));
              break;
            }
            case "Single": {
              current = left3;
              sequential = cons(right3, sequential);
              break;
            }
          }
          break;
        }
        case "Single": {
          parallel = parallelCollectionAdd(parallel, current);
          if (isNil(stack)) {
            return [parallel, sequential];
          }
          current = stack.head;
          stack = stack.tail;
          break;
        }
      }
    }
    throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
  };
  var merge4 = (sequential, parallel) => {
    if (isNil(sequential)) {
      return of3(parallelCollectionToSequentialCollection(parallel));
    }
    if (parallelCollectionIsEmpty(parallel)) {
      return sequential;
    }
    const seqHeadKeys = sequentialCollectionKeys(sequential.head);
    const parKeys = parallelCollectionKeys(parallel);
    if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
      return cons(sequentialCollectionCombine(sequential.head, parallelCollectionToSequentialCollection(parallel)), sequential.tail);
    }
    return cons(parallelCollectionToSequentialCollection(parallel), sequential);
  };
  var EntryTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/Entry");

  class EntryImpl {
    request;
    result;
    listeners;
    ownerId;
    state;
    [EntryTypeId] = blockedRequestVariance;
    constructor(request, result, listeners, ownerId, state) {
      this.request = request;
      this.result = result;
      this.listeners = listeners;
      this.ownerId = ownerId;
      this.state = state;
    }
  }
  var blockedRequestVariance = {
    _R: (_) => _
  };
  var makeEntry = (options) => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state);
  var RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
  var parallelVariance = {
    _R: (_) => _
  };

  class ParallelImpl {
    map;
    [RequestBlockParallelTypeId] = parallelVariance;
    constructor(map8) {
      this.map = map8;
    }
  }
  var parallelCollectionEmpty = () => new ParallelImpl(empty9());
  var parallelCollectionAdd = (self2, blockedRequest) => new ParallelImpl(modifyAt2(self2.map, blockedRequest.dataSource, (_) => orElseSome(map2(_, append2(blockedRequest.blockedRequest)), () => of2(blockedRequest.blockedRequest))));
  var parallelCollectionCombine = (self2, that) => new ParallelImpl(reduce6(self2.map, that.map, (map8, value, key) => set3(map8, key, match2(get7(map8, key), {
    onNone: () => value,
    onSome: (other) => appendAll2(value, other)
  }))));
  var parallelCollectionIsEmpty = (self2) => isEmpty3(self2.map);
  var parallelCollectionKeys = (self2) => Array.from(keys2(self2.map));
  var parallelCollectionToSequentialCollection = (self2) => sequentialCollectionMake(map7(self2.map, (x) => of2(x)));
  var SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
  var sequentialVariance = {
    _R: (_) => _
  };

  class SequentialImpl {
    map;
    [SequentialCollectionTypeId] = sequentialVariance;
    constructor(map8) {
      this.map = map8;
    }
  }
  var sequentialCollectionMake = (map8) => new SequentialImpl(map8);
  var sequentialCollectionCombine = (self2, that) => new SequentialImpl(reduce6(that.map, self2.map, (map8, value, key) => set3(map8, key, match2(get7(map8, key), {
    onNone: () => empty5(),
    onSome: (a) => appendAll2(a, value)
  }))));
  var sequentialCollectionKeys = (self2) => Array.from(keys2(self2.map));
  var sequentialCollectionToChunk = (self2) => Array.from(self2.map);

  // node_modules/effect/dist/esm/internal/opCodes/cause.js
  var OP_DIE = "Die";
  var OP_EMPTY = "Empty";
  var OP_FAIL = "Fail";
  var OP_INTERRUPT = "Interrupt";
  var OP_PARALLEL = "Parallel";
  var OP_SEQUENTIAL = "Sequential";

  // node_modules/effect/dist/esm/internal/cause.js
  var CauseSymbolKey = "effect/Cause";
  var CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
  var variance4 = {
    _E: (_) => _
  };
  var proto = {
    [CauseTypeId]: variance4,
    [symbol]() {
      return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
    },
    [symbol2](that) {
      return isCause(that) && causeEquals(this, that);
    },
    pipe() {
      return pipeArguments(this, arguments);
    },
    toJSON() {
      switch (this._tag) {
        case "Empty":
          return {
            _id: "Cause",
            _tag: this._tag
          };
        case "Die":
          return {
            _id: "Cause",
            _tag: this._tag,
            defect: toJSON(this.defect)
          };
        case "Interrupt":
          return {
            _id: "Cause",
            _tag: this._tag,
            fiberId: this.fiberId.toJSON()
          };
        case "Fail":
          return {
            _id: "Cause",
            _tag: this._tag,
            failure: toJSON(this.error)
          };
        case "Sequential":
        case "Parallel":
          return {
            _id: "Cause",
            _tag: this._tag,
            left: toJSON(this.left),
            right: toJSON(this.right)
          };
      }
    },
    toString() {
      return pretty(this);
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  };
  var empty17 = /* @__PURE__ */ (() => {
    const o = /* @__PURE__ */ Object.create(proto);
    o._tag = OP_EMPTY;
    return o;
  })();
  var fail = (error) => {
    const o = Object.create(proto);
    o._tag = OP_FAIL;
    o.error = error;
    return o;
  };
  var die = (defect) => {
    const o = Object.create(proto);
    o._tag = OP_DIE;
    o.defect = defect;
    return o;
  };
  var interrupt = (fiberId) => {
    const o = Object.create(proto);
    o._tag = OP_INTERRUPT;
    o.fiberId = fiberId;
    return o;
  };
  var parallel = (left3, right3) => {
    const o = Object.create(proto);
    o._tag = OP_PARALLEL;
    o.left = left3;
    o.right = right3;
    return o;
  };
  var sequential = (left3, right3) => {
    const o = Object.create(proto);
    o._tag = OP_SEQUENTIAL;
    o.left = left3;
    o.right = right3;
    return o;
  };
  var isCause = (u) => hasProperty(u, CauseTypeId);
  var isEmptyType = (self2) => self2._tag === OP_EMPTY;
  var isFailType = (self2) => self2._tag === OP_FAIL;
  var isDieType = (self2) => self2._tag === OP_DIE;
  var isEmpty5 = (self2) => {
    if (self2._tag === OP_EMPTY) {
      return true;
    }
    return reduce8(self2, true, (acc, cause) => {
      switch (cause._tag) {
        case OP_EMPTY: {
          return some2(acc);
        }
        case OP_DIE:
        case OP_FAIL:
        case OP_INTERRUPT: {
          return some2(false);
        }
        default: {
          return none2();
        }
      }
    });
  };
  var isInterrupted = (self2) => isSome2(interruptOption(self2));
  var isInterruptedOnly = (self2) => reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)(self2);
  var failures = (self2) => reverse2(reduce8(self2, empty5(), (list, cause) => cause._tag === OP_FAIL ? some2(pipe(list, prepend2(cause.error))) : none2()));
  var defects = (self2) => reverse2(reduce8(self2, empty5(), (list, cause) => cause._tag === OP_DIE ? some2(pipe(list, prepend2(cause.defect))) : none2()));
  var interruptors = (self2) => reduce8(self2, empty8(), (set4, cause) => cause._tag === OP_INTERRUPT ? some2(pipe(set4, add4(cause.fiberId))) : none2());
  var failureOption = (self2) => find(self2, (cause) => cause._tag === OP_FAIL ? some2(cause.error) : none2());
  var failureOrCause = (self2) => {
    const option = failureOption(self2);
    switch (option._tag) {
      case "None": {
        return right2(self2);
      }
      case "Some": {
        return left2(option.value);
      }
    }
  };
  var flipCauseOption = (self2) => match5(self2, {
    onEmpty: some2(empty17),
    onFail: map2(fail),
    onDie: (defect) => some2(die(defect)),
    onInterrupt: (fiberId) => some2(interrupt(fiberId)),
    onSequential: mergeWith(sequential),
    onParallel: mergeWith(parallel)
  });
  var interruptOption = (self2) => find(self2, (cause) => cause._tag === OP_INTERRUPT ? some2(cause.fiberId) : none2());
  var keepDefects = (self2) => match5(self2, {
    onEmpty: none2(),
    onFail: () => none2(),
    onDie: (defect) => some2(die(defect)),
    onInterrupt: () => none2(),
    onSequential: mergeWith(sequential),
    onParallel: mergeWith(parallel)
  });
  var keepDefectsAndElectFailures = (self2) => match5(self2, {
    onEmpty: none2(),
    onFail: (failure) => some2(die(failure)),
    onDie: (defect) => some2(die(defect)),
    onInterrupt: () => none2(),
    onSequential: mergeWith(sequential),
    onParallel: mergeWith(parallel)
  });
  var stripFailures = (self2) => match5(self2, {
    onEmpty: empty17,
    onFail: () => empty17,
    onDie: die,
    onInterrupt: interrupt,
    onSequential: sequential,
    onParallel: parallel
  });
  var electFailures = (self2) => match5(self2, {
    onEmpty: empty17,
    onFail: die,
    onDie: die,
    onInterrupt: interrupt,
    onSequential: sequential,
    onParallel: parallel
  });
  var map9 = /* @__PURE__ */ dual(2, (self2, f) => flatMap7(self2, (e) => fail(f(e))));
  var flatMap7 = /* @__PURE__ */ dual(2, (self2, f) => match5(self2, {
    onEmpty: empty17,
    onFail: (error) => f(error),
    onDie: (defect) => die(defect),
    onInterrupt: (fiberId) => interrupt(fiberId),
    onSequential: (left3, right3) => sequential(left3, right3),
    onParallel: (left3, right3) => parallel(left3, right3)
  }));
  var flatten5 = (self2) => flatMap7(self2, identity);
  var causeEquals = (left3, right3) => {
    let leftStack = of2(left3);
    let rightStack = of2(right3);
    while (isNonEmpty2(leftStack) && isNonEmpty2(rightStack)) {
      const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce8([empty8(), empty5()], ([parallel2, sequential2], cause) => {
        const [par2, seq2] = evaluateCause(cause);
        return some2([pipe(parallel2, union3(par2)), pipe(sequential2, appendAll2(seq2))]);
      }));
      const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce8([empty8(), empty5()], ([parallel2, sequential2], cause) => {
        const [par2, seq2] = evaluateCause(cause);
        return some2([pipe(parallel2, union3(par2)), pipe(sequential2, appendAll2(seq2))]);
      }));
      if (!equals(leftParallel, rightParallel)) {
        return false;
      }
      leftStack = leftSequential;
      rightStack = rightSequential;
    }
    return true;
  };
  var flattenCause = (cause) => {
    return flattenCauseLoop(of2(cause), empty5());
  };
  var flattenCauseLoop = (causes, flattened) => {
    while (true) {
      const [parallel2, sequential2] = pipe(causes, reduce([empty8(), empty5()], ([parallel3, sequential3], cause) => {
        const [par2, seq2] = evaluateCause(cause);
        return [pipe(parallel3, union3(par2)), pipe(sequential3, appendAll2(seq2))];
      }));
      const updated = size3(parallel2) > 0 ? pipe(flattened, prepend2(parallel2)) : flattened;
      if (isEmpty(sequential2)) {
        return reverse2(updated);
      }
      causes = sequential2;
      flattened = updated;
    }
    throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
  };
  var find = /* @__PURE__ */ dual(2, (self2, pf) => {
    const stack = [self2];
    while (stack.length > 0) {
      const item = stack.pop();
      const option = pf(item);
      switch (option._tag) {
        case "None": {
          switch (item._tag) {
            case OP_SEQUENTIAL:
            case OP_PARALLEL: {
              stack.push(item.right);
              stack.push(item.left);
              break;
            }
          }
          break;
        }
        case "Some": {
          return option;
        }
      }
    }
    return none2();
  });
  var evaluateCause = (self2) => {
    let cause = self2;
    const stack = [];
    let _parallel = empty8();
    let _sequential = empty5();
    while (cause !== undefined) {
      switch (cause._tag) {
        case OP_EMPTY: {
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
        case OP_FAIL: {
          _parallel = add4(_parallel, make6(cause._tag, cause.error));
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
        case OP_DIE: {
          _parallel = add4(_parallel, make6(cause._tag, cause.defect));
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
        case OP_INTERRUPT: {
          _parallel = add4(_parallel, make6(cause._tag, cause.fiberId));
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
        case OP_SEQUENTIAL: {
          switch (cause.left._tag) {
            case OP_EMPTY: {
              cause = cause.right;
              break;
            }
            case OP_SEQUENTIAL: {
              cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));
              break;
            }
            case OP_PARALLEL: {
              cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));
              break;
            }
            default: {
              _sequential = prepend2(_sequential, cause.right);
              cause = cause.left;
              break;
            }
          }
          break;
        }
        case OP_PARALLEL: {
          stack.push(cause.right);
          cause = cause.left;
          break;
        }
      }
    }
    throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
  };
  var IsInterruptedOnlyCauseReducer = {
    emptyCase: constTrue,
    failCase: constFalse,
    dieCase: constFalse,
    interruptCase: constTrue,
    sequentialCase: (_, left3, right3) => left3 && right3,
    parallelCase: (_, left3, right3) => left3 && right3
  };
  var OP_SEQUENTIAL_CASE = "SequentialCase";
  var OP_PARALLEL_CASE = "ParallelCase";
  var match5 = /* @__PURE__ */ dual(2, (self2, {
    onDie,
    onEmpty,
    onFail,
    onInterrupt,
    onParallel,
    onSequential
  }) => {
    return reduceWithContext(self2, undefined, {
      emptyCase: () => onEmpty,
      failCase: (_, error) => onFail(error),
      dieCase: (_, defect) => onDie(defect),
      interruptCase: (_, fiberId) => onInterrupt(fiberId),
      sequentialCase: (_, left3, right3) => onSequential(left3, right3),
      parallelCase: (_, left3, right3) => onParallel(left3, right3)
    });
  });
  var reduce8 = /* @__PURE__ */ dual(3, (self2, zero2, pf) => {
    let accumulator = zero2;
    let cause = self2;
    const causes = [];
    while (cause !== undefined) {
      const option = pf(accumulator, cause);
      accumulator = isSome2(option) ? option.value : accumulator;
      switch (cause._tag) {
        case OP_SEQUENTIAL: {
          causes.push(cause.right);
          cause = cause.left;
          break;
        }
        case OP_PARALLEL: {
          causes.push(cause.right);
          cause = cause.left;
          break;
        }
        default: {
          cause = undefined;
          break;
        }
      }
      if (cause === undefined && causes.length > 0) {
        cause = causes.pop();
      }
    }
    return accumulator;
  });
  var reduceWithContext = /* @__PURE__ */ dual(3, (self2, context, reducer) => {
    const input = [self2];
    const output = [];
    while (input.length > 0) {
      const cause = input.pop();
      switch (cause._tag) {
        case OP_EMPTY: {
          output.push(right2(reducer.emptyCase(context)));
          break;
        }
        case OP_FAIL: {
          output.push(right2(reducer.failCase(context, cause.error)));
          break;
        }
        case OP_DIE: {
          output.push(right2(reducer.dieCase(context, cause.defect)));
          break;
        }
        case OP_INTERRUPT: {
          output.push(right2(reducer.interruptCase(context, cause.fiberId)));
          break;
        }
        case OP_SEQUENTIAL: {
          input.push(cause.right);
          input.push(cause.left);
          output.push(left2({
            _tag: OP_SEQUENTIAL_CASE
          }));
          break;
        }
        case OP_PARALLEL: {
          input.push(cause.right);
          input.push(cause.left);
          output.push(left2({
            _tag: OP_PARALLEL_CASE
          }));
          break;
        }
      }
    }
    const accumulator = [];
    while (output.length > 0) {
      const either2 = output.pop();
      switch (either2._tag) {
        case "Left": {
          switch (either2.left._tag) {
            case OP_SEQUENTIAL_CASE: {
              const left3 = accumulator.pop();
              const right3 = accumulator.pop();
              const value = reducer.sequentialCase(context, left3, right3);
              accumulator.push(value);
              break;
            }
            case OP_PARALLEL_CASE: {
              const left3 = accumulator.pop();
              const right3 = accumulator.pop();
              const value = reducer.parallelCase(context, left3, right3);
              accumulator.push(value);
              break;
            }
          }
          break;
        }
        case "Right": {
          accumulator.push(either2.right);
          break;
        }
      }
    }
    if (accumulator.length === 0) {
      throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    return accumulator.pop();
  });
  var pretty = (cause, options) => {
    if (isInterruptedOnly(cause)) {
      return "All fibers interrupted without errors.";
    }
    return prettyErrors(cause).map(function(e) {
      if (options?.renderErrorCause !== true || e.cause === undefined) {
        return e.stack;
      }
      return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
    }).join(`
`);
  };
  var renderErrorCause = (cause, prefix) => {
    const lines = cause.stack.split(`
`);
    let stack = `${prefix}[cause]: ${lines[0]}`;
    for (let i = 1, len = lines.length;i < len; i++) {
      stack += `
${prefix}${lines[i]}`;
    }
    if (cause.cause) {
      stack += ` {
${renderErrorCause(cause.cause, `${prefix}  `)}
${prefix}}`;
    }
    return stack;
  };

  class PrettyError extends globalThis.Error {
    span = undefined;
    constructor(originalError) {
      const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
      const prevLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 1;
      super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
        cause: new PrettyError(originalError.cause)
      } : undefined);
      if (this.message === "") {
        this.message = "An error has occurred";
      }
      Error.stackTraceLimit = prevLimit;
      this.name = originalError instanceof Error ? originalError.name : "Error";
      if (originalErrorIsObject) {
        if (spanSymbol in originalError) {
          this.span = originalError[spanSymbol];
        }
        Object.keys(originalError).forEach((key) => {
          if (!(key in this)) {
            this[key] = originalError[key];
          }
        });
      }
      this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
    }
  }
  var prettyErrorMessage = (u) => {
    if (typeof u === "string") {
      return u;
    }
    if (typeof u === "object" && u !== null && u instanceof Error) {
      return u.message;
    }
    try {
      if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
        return u["toString"]();
      }
    } catch {}
    return stringifyCircular(u);
  };
  var locationRegex = /\((.*)\)/g;
  var spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => new WeakMap);
  var prettyErrorStack = (message, stack, span2) => {
    const out = [message];
    const lines = stack.startsWith(message) ? stack.slice(message.length).split(`
`) : stack.split(`
`);
    for (let i = 1;i < lines.length; i++) {
      if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
        i++;
        continue;
      }
      if (lines[i].includes("Generator.next")) {
        break;
      }
      if (lines[i].includes("effect_internal_function")) {
        break;
      }
      out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
    }
    if (span2) {
      let current = span2;
      let i = 0;
      while (current && current._tag === "Span" && i < 10) {
        const stackFn = spanToTrace.get(current);
        if (typeof stackFn === "function") {
          const stack2 = stackFn();
          if (typeof stack2 === "string") {
            const locationMatchAll = stack2.matchAll(locationRegex);
            let match6 = false;
            for (const [, location2] of locationMatchAll) {
              match6 = true;
              out.push(`    at ${current.name} (${location2})`);
            }
            if (!match6) {
              out.push(`    at ${current.name} (${stack2.replace(/^at /, "")})`);
            }
          } else {
            out.push(`    at ${current.name}`);
          }
        } else {
          out.push(`    at ${current.name}`);
        }
        current = getOrUndefined(current.parent);
        i++;
      }
    }
    return out.join(`
`);
  };
  var spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
  var prettyErrors = (cause) => reduceWithContext(cause, undefined, {
    emptyCase: () => [],
    dieCase: (_, unknownError) => {
      return [new PrettyError(unknownError)];
    },
    failCase: (_, error) => {
      return [new PrettyError(error)];
    },
    interruptCase: () => [],
    parallelCase: (_, l, r) => [...l, ...r],
    sequentialCase: (_, l, r) => [...l, ...r]
  });

  // node_modules/effect/dist/esm/internal/opCodes/deferred.js
  var OP_STATE_PENDING = "Pending";
  var OP_STATE_DONE = "Done";

  // node_modules/effect/dist/esm/internal/deferred.js
  var DeferredSymbolKey = "effect/Deferred";
  var DeferredTypeId = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
  var deferredVariance = {
    _E: (_) => _,
    _A: (_) => _
  };
  var pending = (joiners) => {
    return {
      _tag: OP_STATE_PENDING,
      joiners
    };
  };
  var done = (effect) => {
    return {
      _tag: OP_STATE_DONE,
      effect
    };
  };

  // node_modules/effect/dist/esm/internal/singleShotGen.js
  class SingleShotGen2 {
    self;
    called = false;
    constructor(self2) {
      this.self = self2;
    }
    next(a) {
      return this.called ? {
        value: a,
        done: true
      } : (this.called = true, {
        value: this.self,
        done: false
      });
    }
    return(a) {
      return {
        value: a,
        done: true
      };
    }
    throw(e) {
      throw e;
    }
    [Symbol.iterator]() {
      return new SingleShotGen2(this.self);
    }
  }

  // node_modules/effect/dist/esm/internal/core.js
  var blocked = (blockedRequests, _continue) => {
    const effect = new EffectPrimitive("Blocked");
    effect.effect_instruction_i0 = blockedRequests;
    effect.effect_instruction_i1 = _continue;
    return effect;
  };
  var runRequestBlock = (blockedRequests) => {
    const effect = new EffectPrimitive("RunBlocked");
    effect.effect_instruction_i0 = blockedRequests;
    return effect;
  };
  var EffectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Effect");

  class RevertFlags {
    patch;
    op;
    _op = OP_REVERT_FLAGS;
    constructor(patch5, op) {
      this.patch = patch5;
      this.op = op;
    }
  }

  class EffectPrimitive {
    _op;
    effect_instruction_i0 = undefined;
    effect_instruction_i1 = undefined;
    effect_instruction_i2 = undefined;
    trace = undefined;
    [EffectTypeId2] = effectVariance;
    constructor(_op) {
      this._op = _op;
    }
    [symbol2](that) {
      return this === that;
    }
    [symbol]() {
      return cached(this, random(this));
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    toJSON() {
      return {
        _id: "Effect",
        _op: this._op,
        effect_instruction_i0: toJSON(this.effect_instruction_i0),
        effect_instruction_i1: toJSON(this.effect_instruction_i1),
        effect_instruction_i2: toJSON(this.effect_instruction_i2)
      };
    }
    toString() {
      return format(this.toJSON());
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
    [Symbol.iterator]() {
      return new SingleShotGen2(new YieldWrap(this));
    }
  }

  class EffectPrimitiveFailure {
    _op;
    effect_instruction_i0 = undefined;
    effect_instruction_i1 = undefined;
    effect_instruction_i2 = undefined;
    trace = undefined;
    [EffectTypeId2] = effectVariance;
    constructor(_op) {
      this._op = _op;
      this._tag = _op;
    }
    [symbol2](that) {
      return exitIsExit(that) && that._op === "Failure" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
    }
    [symbol]() {
      return pipe(string(this._tag), combine(hash(this.effect_instruction_i0)), cached(this));
    }
    get cause() {
      return this.effect_instruction_i0;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    toJSON() {
      return {
        _id: "Exit",
        _tag: this._op,
        cause: this.cause.toJSON()
      };
    }
    toString() {
      return format(this.toJSON());
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
    [Symbol.iterator]() {
      return new SingleShotGen2(new YieldWrap(this));
    }
  }

  class EffectPrimitiveSuccess {
    _op;
    effect_instruction_i0 = undefined;
    effect_instruction_i1 = undefined;
    effect_instruction_i2 = undefined;
    trace = undefined;
    [EffectTypeId2] = effectVariance;
    constructor(_op) {
      this._op = _op;
      this._tag = _op;
    }
    [symbol2](that) {
      return exitIsExit(that) && that._op === "Success" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
    }
    [symbol]() {
      return pipe(string(this._tag), combine(hash(this.effect_instruction_i0)), cached(this));
    }
    get value() {
      return this.effect_instruction_i0;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    toJSON() {
      return {
        _id: "Exit",
        _tag: this._op,
        value: toJSON(this.value)
      };
    }
    toString() {
      return format(this.toJSON());
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
    [Symbol.iterator]() {
      return new SingleShotGen2(new YieldWrap(this));
    }
  }
  var isEffect = (u) => hasProperty(u, EffectTypeId2);
  var withFiberRuntime = (withRuntime) => {
    const effect = new EffectPrimitive(OP_WITH_RUNTIME);
    effect.effect_instruction_i0 = withRuntime;
    return effect;
  };
  var acquireUseRelease = /* @__PURE__ */ dual(3, (acquire, use, release) => uninterruptibleMask((restore) => flatMap8(acquire, (a) => flatMap8(exit(suspend(() => restore(use(a)))), (exit) => {
    return suspend(() => release(a, exit)).pipe(matchCauseEffect({
      onFailure: (cause) => {
        switch (exit._tag) {
          case OP_FAILURE:
            return failCause(sequential(exit.effect_instruction_i0, cause));
          case OP_SUCCESS:
            return failCause(cause);
        }
      },
      onSuccess: () => exit
    }));
  }))));
  var as = /* @__PURE__ */ dual(2, (self2, value) => flatMap8(self2, () => succeed(value)));
  var asVoid = (self2) => as(self2, undefined);
  var custom = function() {
    const wrapper = new EffectPrimitive(OP_COMMIT);
    switch (arguments.length) {
      case 2: {
        wrapper.effect_instruction_i0 = arguments[0];
        wrapper.commit = arguments[1];
        break;
      }
      case 3: {
        wrapper.effect_instruction_i0 = arguments[0];
        wrapper.effect_instruction_i1 = arguments[1];
        wrapper.commit = arguments[2];
        break;
      }
      case 4: {
        wrapper.effect_instruction_i0 = arguments[0];
        wrapper.effect_instruction_i1 = arguments[1];
        wrapper.effect_instruction_i2 = arguments[2];
        wrapper.commit = arguments[3];
        break;
      }
      default: {
        throw new Error(getBugErrorMessage("you're not supposed to end up here"));
      }
    }
    return wrapper;
  };
  var unsafeAsync = (register, blockingOn = none4) => {
    const effect = new EffectPrimitive(OP_ASYNC);
    let cancelerRef = undefined;
    effect.effect_instruction_i0 = (resume) => {
      cancelerRef = register(resume);
    };
    effect.effect_instruction_i1 = blockingOn;
    return onInterrupt(effect, (_) => isEffect(cancelerRef) ? cancelerRef : void_);
  };
  var asyncInterrupt = (register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn));
  var async_ = (resume, blockingOn = none4) => {
    return custom(resume, function() {
      let backingResume = undefined;
      let pendingEffect = undefined;
      function proxyResume(effect2) {
        if (backingResume) {
          backingResume(effect2);
        } else if (pendingEffect === undefined) {
          pendingEffect = effect2;
        }
      }
      const effect = new EffectPrimitive(OP_ASYNC);
      effect.effect_instruction_i0 = (resume2) => {
        backingResume = resume2;
        if (pendingEffect) {
          resume2(pendingEffect);
        }
      };
      effect.effect_instruction_i1 = blockingOn;
      let cancelerRef = undefined;
      let controllerRef = undefined;
      if (this.effect_instruction_i0.length !== 1) {
        controllerRef = new AbortController;
        cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
      } else {
        cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
      }
      return cancelerRef || controllerRef ? onInterrupt(effect, (_) => {
        if (controllerRef) {
          controllerRef.abort();
        }
        return cancelerRef ?? void_;
      }) : effect;
    });
  };
  var catchAllCause = /* @__PURE__ */ dual(2, (self2, f) => {
    const effect = new EffectPrimitive(OP_ON_FAILURE);
    effect.effect_instruction_i0 = self2;
    effect.effect_instruction_i1 = f;
    return effect;
  });
  var catchAll = /* @__PURE__ */ dual(2, (self2, f) => matchEffect(self2, {
    onFailure: f,
    onSuccess: succeed
  }));
  var catchIf = /* @__PURE__ */ dual(3, (self2, predicate, f) => catchAllCause(self2, (cause) => {
    const either2 = failureOrCause(cause);
    switch (either2._tag) {
      case "Left":
        return predicate(either2.left) ? f(either2.left) : failCause(cause);
      case "Right":
        return failCause(either2.right);
    }
  }));
  var catchSome = /* @__PURE__ */ dual(2, (self2, pf) => catchAllCause(self2, (cause) => {
    const either2 = failureOrCause(cause);
    switch (either2._tag) {
      case "Left":
        return pipe(pf(either2.left), getOrElse(() => failCause(cause)));
      case "Right":
        return failCause(either2.right);
    }
  }));
  var checkInterruptible = (f) => withFiberRuntime((_, status) => f(interruption(status.runtimeFlags)));
  var originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
  var capture = (obj, span2) => {
    if (isSome2(span2)) {
      return new Proxy(obj, {
        has(target, p) {
          return p === spanSymbol || p === originalSymbol || p in target;
        },
        get(target, p) {
          if (p === spanSymbol) {
            return span2.value;
          }
          if (p === originalSymbol) {
            return obj;
          }
          return target[p];
        }
      });
    }
    return obj;
  };
  var die2 = (defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect));
  var dieMessage = (message) => failCauseSync(() => die(new RuntimeException(message)));
  var dieSync = (evaluate) => flatMap8(sync(evaluate), die2);
  var either2 = (self2) => matchEffect(self2, {
    onFailure: (e) => succeed(left2(e)),
    onSuccess: (a) => succeed(right2(a))
  });
  var exit = (self2) => matchCause(self2, {
    onFailure: exitFailCause,
    onSuccess: exitSucceed
  });
  var fail2 = (error) => isObject(error) && !(spanSymbol in error) ? withFiberRuntime((fiber) => failCause(fail(capture(error, currentSpanFromFiber(fiber))))) : failCause(fail(error));
  var failSync = (evaluate) => flatMap8(sync(evaluate), fail2);
  var failCause = (cause) => {
    const effect = new EffectPrimitiveFailure(OP_FAILURE);
    effect.effect_instruction_i0 = cause;
    return effect;
  };
  var failCauseSync = (evaluate) => flatMap8(sync(evaluate), failCause);
  var fiberId = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.id()));
  var fiberIdWith = (f) => withFiberRuntime((state) => f(state.id()));
  var flatMap8 = /* @__PURE__ */ dual(2, (self2, f) => {
    const effect = new EffectPrimitive(OP_ON_SUCCESS);
    effect.effect_instruction_i0 = self2;
    effect.effect_instruction_i1 = f;
    return effect;
  });
  var andThen2 = /* @__PURE__ */ dual(2, (self2, f) => flatMap8(self2, (a) => {
    const b = typeof f === "function" ? f(a) : f;
    if (isEffect(b)) {
      return b;
    } else if (isPromiseLike(b)) {
      return unsafeAsync((resume) => {
        b.then((a2) => resume(succeed(a2)), (e) => resume(fail2(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
      });
    }
    return succeed(b);
  }));
  var step2 = (self2) => {
    const effect = new EffectPrimitive("OnStep");
    effect.effect_instruction_i0 = self2;
    return effect;
  };
  var flatten6 = (self2) => flatMap8(self2, identity);
  var flip = (self2) => matchEffect(self2, {
    onFailure: succeed,
    onSuccess: fail2
  });
  var matchCause = /* @__PURE__ */ dual(2, (self2, options) => matchCauseEffect(self2, {
    onFailure: (cause) => succeed(options.onFailure(cause)),
    onSuccess: (a) => succeed(options.onSuccess(a))
  }));
  var matchCauseEffect = /* @__PURE__ */ dual(2, (self2, options) => {
    const effect = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
    effect.effect_instruction_i0 = self2;
    effect.effect_instruction_i1 = options.onFailure;
    effect.effect_instruction_i2 = options.onSuccess;
    return effect;
  });
  var matchEffect = /* @__PURE__ */ dual(2, (self2, options) => matchCauseEffect(self2, {
    onFailure: (cause) => {
      const defects2 = defects(cause);
      if (defects2.length > 0) {
        return failCause(electFailures(cause));
      }
      const failures2 = failures(cause);
      if (failures2.length > 0) {
        return options.onFailure(unsafeHead(failures2));
      }
      return failCause(cause);
    },
    onSuccess: options.onSuccess
  }));
  var forEachSequential = /* @__PURE__ */ dual(2, (self2, f) => suspend(() => {
    const arr = fromIterable(self2);
    const ret = allocate(arr.length);
    let i = 0;
    return as(whileLoop({
      while: () => i < arr.length,
      body: () => f(arr[i], i),
      step: (b) => {
        ret[i++] = b;
      }
    }), ret);
  }));
  var forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self2, f) => suspend(() => {
    const arr = fromIterable(self2);
    let i = 0;
    return whileLoop({
      while: () => i < arr.length,
      body: () => f(arr[i], i),
      step: () => {
        i++;
      }
    });
  }));
  var if_ = /* @__PURE__ */ dual((args) => typeof args[0] === "boolean" || isEffect(args[0]), (self2, options) => isEffect(self2) ? flatMap8(self2, (b) => b ? options.onTrue() : options.onFalse()) : self2 ? options.onTrue() : options.onFalse());
  var interrupt2 = /* @__PURE__ */ flatMap8(fiberId, (fiberId2) => interruptWith(fiberId2));
  var interruptWith = (fiberId2) => failCause(interrupt(fiberId2));
  var interruptible2 = (self2) => {
    const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
    effect.effect_instruction_i0 = enable3(Interruption);
    effect.effect_instruction_i1 = () => self2;
    return effect;
  };
  var interruptibleMask = (f) => custom(f, function() {
    const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
    effect.effect_instruction_i0 = enable3(Interruption);
    effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
    return effect;
  });
  var intoDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => uninterruptibleMask((restore) => flatMap8(exit(restore(self2)), (exit2) => deferredDone(deferred, exit2))));
  var map10 = /* @__PURE__ */ dual(2, (self2, f) => flatMap8(self2, (a) => sync(() => f(a))));
  var mapBoth2 = /* @__PURE__ */ dual(2, (self2, options) => matchEffect(self2, {
    onFailure: (e) => failSync(() => options.onFailure(e)),
    onSuccess: (a) => sync(() => options.onSuccess(a))
  }));
  var mapError = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
    onFailure: (cause) => {
      const either3 = failureOrCause(cause);
      switch (either3._tag) {
        case "Left": {
          return failSync(() => f(either3.left));
        }
        case "Right": {
          return failCause(either3.right);
        }
      }
    },
    onSuccess: succeed
  }));
  var onError = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit(self2, (exit2) => exitIsSuccess(exit2) ? void_ : cleanup(exit2.effect_instruction_i0)));
  var onExit = /* @__PURE__ */ dual(2, (self2, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self2), {
    onFailure: (cause1) => {
      const result = exitFailCause(cause1);
      return matchCauseEffect(cleanup(result), {
        onFailure: (cause2) => exitFailCause(sequential(cause1, cause2)),
        onSuccess: () => result
      });
    },
    onSuccess: (success) => {
      const result = exitSucceed(success);
      return zipRight(cleanup(result), result);
    }
  })));
  var onInterrupt = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit(self2, exitMatch({
    onFailure: (cause) => isInterruptedOnly(cause) ? asVoid(cleanup(interruptors(cause))) : void_,
    onSuccess: () => void_
  })));
  var orElse2 = /* @__PURE__ */ dual(2, (self2, that) => attemptOrElse(self2, that, succeed));
  var orDie = (self2) => orDieWith(self2, identity);
  var orDieWith = /* @__PURE__ */ dual(2, (self2, f) => matchEffect(self2, {
    onFailure: (e) => die2(f(e)),
    onSuccess: succeed
  }));
  var partitionMap2 = partitionMap;
  var runtimeFlags = /* @__PURE__ */ withFiberRuntime((_, status) => succeed(status.runtimeFlags));
  var succeed = (value) => {
    const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
    effect.effect_instruction_i0 = value;
    return effect;
  };
  var suspend = (evaluate) => {
    const effect = new EffectPrimitive(OP_COMMIT);
    effect.commit = evaluate;
    return effect;
  };
  var sync = (thunk) => {
    const effect = new EffectPrimitive(OP_SYNC);
    effect.effect_instruction_i0 = thunk;
    return effect;
  };
  var tap = /* @__PURE__ */ dual((args) => args.length === 3 || args.length === 2 && !(isObject(args[1]) && ("onlyEffect" in args[1])), (self2, f) => flatMap8(self2, (a) => {
    const b = typeof f === "function" ? f(a) : f;
    if (isEffect(b)) {
      return as(b, a);
    } else if (isPromiseLike(b)) {
      return unsafeAsync((resume) => {
        b.then((_) => resume(succeed(a)), (e) => resume(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
      });
    }
    return succeed(a);
  }));
  var transplant = (f) => withFiberRuntime((state) => {
    const scopeOverride = state.getFiberRef(currentForkScopeOverride);
    const scope = pipe(scopeOverride, getOrElse(() => state.scope()));
    return f(fiberRefLocally(currentForkScopeOverride, some2(scope)));
  });
  var attemptOrElse = /* @__PURE__ */ dual(3, (self2, that, onSuccess) => matchCauseEffect(self2, {
    onFailure: (cause) => {
      const defects2 = defects(cause);
      if (defects2.length > 0) {
        return failCause(getOrThrow2(keepDefectsAndElectFailures(cause)));
      }
      return that();
    },
    onSuccess
  }));
  var uninterruptible = (self2) => {
    const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
    effect.effect_instruction_i0 = disable3(Interruption);
    effect.effect_instruction_i1 = () => self2;
    return effect;
  };
  var uninterruptibleMask = (f) => custom(f, function() {
    const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
    effect.effect_instruction_i0 = disable3(Interruption);
    effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
    return effect;
  });
  var void_ = /* @__PURE__ */ succeed(undefined);
  var updateRuntimeFlags = (patch5) => {
    const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
    effect.effect_instruction_i0 = patch5;
    effect.effect_instruction_i1 = undefined;
    return effect;
  };
  var whenEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap8(condition, (b) => {
    if (b) {
      return pipe(self2, map10(some2));
    }
    return succeed(none2());
  }));
  var whileLoop = (options) => {
    const effect = new EffectPrimitive(OP_WHILE);
    effect.effect_instruction_i0 = options.while;
    effect.effect_instruction_i1 = options.body;
    effect.effect_instruction_i2 = options.step;
    return effect;
  };
  var fromIterator = (iterator) => suspend(() => {
    const effect = new EffectPrimitive(OP_ITERATOR);
    effect.effect_instruction_i0 = iterator();
    return effect;
  });
  var gen = function() {
    const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
    return fromIterator(() => f(pipe));
  };
  var fnUntraced = (body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args) {
    return fromIterator(() => body.apply(this, args));
  } : function(...args) {
    let effect = fromIterator(() => body.apply(this, args));
    for (const x of pipeables) {
      effect = x(effect, ...args);
    }
    return effect;
  }, "length", {
    value: body.length,
    configurable: true
  });
  var withConcurrency = /* @__PURE__ */ dual(2, (self2, concurrency) => fiberRefLocally(self2, currentConcurrency, concurrency));
  var withRequestBatching = /* @__PURE__ */ dual(2, (self2, requestBatching) => fiberRefLocally(self2, currentRequestBatching, requestBatching));
  var withRuntimeFlags = /* @__PURE__ */ dual(2, (self2, update2) => {
    const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
    effect.effect_instruction_i0 = update2;
    effect.effect_instruction_i1 = () => self2;
    return effect;
  });
  var withTracerEnabled = /* @__PURE__ */ dual(2, (effect, enabled2) => fiberRefLocally(effect, currentTracerEnabled, enabled2));
  var withTracerTiming = /* @__PURE__ */ dual(2, (effect, enabled2) => fiberRefLocally(effect, currentTracerTimingEnabled, enabled2));
  var yieldNow = (options) => {
    const effect = new EffectPrimitive(OP_YIELD);
    return typeof options?.priority !== "undefined" ? withSchedulingPriority(effect, options.priority) : effect;
  };
  var zip2 = /* @__PURE__ */ dual(2, (self2, that) => flatMap8(self2, (a) => map10(that, (b) => [a, b])));
  var zipLeft = /* @__PURE__ */ dual(2, (self2, that) => flatMap8(self2, (a) => as(that, a)));
  var zipRight = /* @__PURE__ */ dual(2, (self2, that) => flatMap8(self2, () => that));
  var zipWith3 = /* @__PURE__ */ dual(3, (self2, that, f) => flatMap8(self2, (a) => map10(that, (b) => f(a, b))));
  var never = /* @__PURE__ */ asyncInterrupt(() => {
    const interval = setInterval(() => {}, 2 ** 31 - 1);
    return sync(() => clearInterval(interval));
  });
  var interruptFiber = (self2) => flatMap8(fiberId, (fiberId2) => pipe(self2, interruptAsFiber(fiberId2)));
  var interruptAsFiber = /* @__PURE__ */ dual(2, (self2, fiberId2) => flatMap8(self2.interruptAsFork(fiberId2), () => self2.await));
  var logLevelAll = {
    _tag: "All",
    syslog: 0,
    label: "ALL",
    ordinal: Number.MIN_SAFE_INTEGER,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var logLevelFatal = {
    _tag: "Fatal",
    syslog: 2,
    label: "FATAL",
    ordinal: 50000,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var logLevelError = {
    _tag: "Error",
    syslog: 3,
    label: "ERROR",
    ordinal: 40000,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var logLevelWarning = {
    _tag: "Warning",
    syslog: 4,
    label: "WARN",
    ordinal: 30000,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var logLevelInfo = {
    _tag: "Info",
    syslog: 6,
    label: "INFO",
    ordinal: 20000,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var logLevelDebug = {
    _tag: "Debug",
    syslog: 7,
    label: "DEBUG",
    ordinal: 1e4,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var logLevelTrace = {
    _tag: "Trace",
    syslog: 7,
    label: "TRACE",
    ordinal: 0,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var logLevelNone = {
    _tag: "None",
    syslog: 7,
    label: "OFF",
    ordinal: Number.MAX_SAFE_INTEGER,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var FiberRefSymbolKey = "effect/FiberRef";
  var FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
  var fiberRefVariance = {
    _A: (_) => _
  };
  var fiberRefGet = (self2) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self2)));
  var fiberRefGetWith = /* @__PURE__ */ dual(2, (self2, f) => flatMap8(fiberRefGet(self2), f));
  var fiberRefSet = /* @__PURE__ */ dual(2, (self2, value) => fiberRefModify(self2, () => [undefined, value]));
  var fiberRefModify = /* @__PURE__ */ dual(2, (self2, f) => withFiberRuntime((state) => {
    const [b, a] = f(state.getFiberRef(self2));
    state.setFiberRef(self2, a);
    return succeed(b);
  }));
  var fiberRefLocally = /* @__PURE__ */ dual(3, (use, self2, value) => acquireUseRelease(zipLeft(fiberRefGet(self2), fiberRefSet(self2, value)), () => use, (oldValue) => fiberRefSet(self2, oldValue)));
  var fiberRefLocallyWith = /* @__PURE__ */ dual(3, (use, self2, f) => fiberRefGetWith(self2, (a) => fiberRefLocally(use, self2, f(a))));
  var fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
    differ: update(),
    fork: options?.fork ?? identity,
    join: options?.join
  });
  var fiberRefUnsafeMakeHashSet = (initial) => {
    const differ2 = hashSet();
    return fiberRefUnsafeMakePatch(initial, {
      differ: differ2,
      fork: differ2.empty
    });
  };
  var fiberRefUnsafeMakeReadonlyArray = (initial) => {
    const differ2 = readonlyArray(update());
    return fiberRefUnsafeMakePatch(initial, {
      differ: differ2,
      fork: differ2.empty
    });
  };
  var fiberRefUnsafeMakeContext = (initial) => {
    const differ2 = environment();
    return fiberRefUnsafeMakePatch(initial, {
      differ: differ2,
      fork: differ2.empty
    });
  };
  var fiberRefUnsafeMakePatch = (initial, options) => {
    const _fiberRef = {
      ...CommitPrototype,
      [FiberRefTypeId]: fiberRefVariance,
      initial,
      commit() {
        return fiberRefGet(this);
      },
      diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
      combine: (first, second) => options.differ.combine(first, second),
      patch: (patch5) => (oldValue) => options.differ.patch(patch5, oldValue),
      fork: options.fork,
      join: options.join ?? ((_, n) => n)
    };
    return _fiberRef;
  };
  var fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
    differ,
    fork: differ.empty
  });
  var currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty4()));
  var currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
  var currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
  var currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty9()));
  var currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
  var currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty10()));
  var withSchedulingPriority = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentSchedulingPriority, scheduler));
  var withMaxOpsBeforeYield = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentMaxOpsBeforeYield, scheduler));
  var currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
  var currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
  var currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelDebug)));
  var currentVersionMismatchErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/versionMismatchErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelWarning)));
  var withUnhandledErrorLogLevel = /* @__PURE__ */ dual(2, (self2, level) => fiberRefLocally(self2, currentUnhandledErrorLogLevel, level));
  var currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty2()));
  var metricLabels = /* @__PURE__ */ fiberRefGet(currentMetricLabels);
  var currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
    fork: () => none2(),
    join: (parent, _) => parent
  }));
  var currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty17, {
    fork: () => empty17,
    join: (parent, _) => parent
  }));
  var currentTracerEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
  var currentTracerTimingEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
  var currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty9()));
  var currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty5()));
  var ScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Scope");
  var CloseableScopeTypeId = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
  var scopeAddFinalizer = (self2, finalizer) => self2.addFinalizer(() => asVoid(finalizer));
  var scopeAddFinalizerExit = (self2, finalizer) => self2.addFinalizer(finalizer);
  var scopeClose = (self2, exit2) => self2.close(exit2);
  var scopeFork = (self2, strategy) => self2.fork(strategy);
  var causeSquash = (self2) => {
    return causeSquashWith(identity)(self2);
  };
  var causeSquashWith = /* @__PURE__ */ dual(2, (self2, f) => {
    const option = pipe(self2, failureOption, map2(f));
    switch (option._tag) {
      case "None": {
        return pipe(defects(self2), head2, match2({
          onNone: () => {
            const interrupts = fromIterable(interruptors(self2)).flatMap((fiberId2) => fromIterable(ids2(fiberId2)).map((id) => `#${id}`));
            return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : undefined);
          },
          onSome: identity
        }));
      }
      case "Some": {
        return option.value;
      }
    }
  });
  var YieldableError = /* @__PURE__ */ function() {

    class YieldableError2 extends globalThis.Error {
      commit() {
        return fail2(this);
      }
      toJSON() {
        const obj = {
          ...this
        };
        if (this.message)
          obj.message = this.message;
        if (this.cause)
          obj.cause = this.cause;
        return obj;
      }
      [NodeInspectSymbol]() {
        if (this.toString !== globalThis.Error.prototype.toString) {
          return this.stack ? `${this.toString()}
${this.stack.split(`
`).slice(1).join(`
`)}` : this.toString();
        } else if ("Bun" in globalThis) {
          return pretty(fail(this), {
            renderErrorCause: true
          });
        }
        return this;
      }
    }
    Object.assign(YieldableError2.prototype, StructuralCommitPrototype);
    return YieldableError2;
  }();
  var makeException = (proto2, tag) => {

    class Base2 extends YieldableError {
      _tag = tag;
    }
    Object.assign(Base2.prototype, proto2);
    Base2.prototype.name = tag;
    return Base2;
  };
  var RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
  var RuntimeException = /* @__PURE__ */ makeException({
    [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
  }, "RuntimeException");
  var isRuntimeException = (u) => hasProperty(u, RuntimeExceptionTypeId);
  var InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
  var InterruptedException = /* @__PURE__ */ makeException({
    [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
  }, "InterruptedException");
  var isInterruptedException = (u) => hasProperty(u, InterruptedExceptionTypeId);
  var IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
  var IllegalArgumentException = /* @__PURE__ */ makeException({
    [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
  }, "IllegalArgumentException");
  var NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
  var NoSuchElementException = /* @__PURE__ */ makeException({
    [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
  }, "NoSuchElementException");
  var isNoSuchElementException = (u) => hasProperty(u, NoSuchElementExceptionTypeId);
  var InvalidPubSubCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
  var InvalidPubSubCapacityException = /* @__PURE__ */ makeException({
    [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
  }, "InvalidPubSubCapacityException");
  var ExceededCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
  var ExceededCapacityException = /* @__PURE__ */ makeException({
    [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
  }, "ExceededCapacityException");
  var TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
  var TimeoutException = /* @__PURE__ */ makeException({
    [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
  }, "TimeoutException");
  var timeoutExceptionFromDuration = (duration) => new TimeoutException(`Operation timed out after '${format2(duration)}'`);
  var UnknownExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
  var UnknownException = /* @__PURE__ */ function() {

    class UnknownException2 extends YieldableError {
      _tag = "UnknownException";
      error;
      constructor(cause, message) {
        super(message ?? "An unknown error occurred", {
          cause
        });
        this.error = cause;
      }
    }
    Object.assign(UnknownException2.prototype, {
      [UnknownExceptionTypeId]: UnknownExceptionTypeId,
      name: "UnknownException"
    });
    return UnknownException2;
  }();
  var exitIsExit = (u) => isEffect(u) && ("_tag" in u) && (u._tag === "Success" || u._tag === "Failure");
  var exitIsFailure = (self2) => self2._tag === "Failure";
  var exitIsSuccess = (self2) => self2._tag === "Success";
  var exitAs = /* @__PURE__ */ dual(2, (self2, value) => {
    switch (self2._tag) {
      case OP_FAILURE: {
        return exitFailCause(self2.effect_instruction_i0);
      }
      case OP_SUCCESS: {
        return exitSucceed(value);
      }
    }
  });
  var exitAsVoid = (self2) => exitAs(self2, undefined);
  var exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel : sequential);
  var exitDie = (defect) => exitFailCause(die(defect));
  var exitFail = (error) => exitFailCause(fail(error));
  var exitFailCause = (cause) => {
    const effect = new EffectPrimitiveFailure(OP_FAILURE);
    effect.effect_instruction_i0 = cause;
    return effect;
  };
  var exitFlatMap = /* @__PURE__ */ dual(2, (self2, f) => {
    switch (self2._tag) {
      case OP_FAILURE: {
        return exitFailCause(self2.effect_instruction_i0);
      }
      case OP_SUCCESS: {
        return f(self2.effect_instruction_i0);
      }
    }
  });
  var exitFlatten = (self2) => pipe(self2, exitFlatMap(identity));
  var exitInterrupt = (fiberId2) => exitFailCause(interrupt(fiberId2));
  var exitMap = /* @__PURE__ */ dual(2, (self2, f) => {
    switch (self2._tag) {
      case OP_FAILURE:
        return exitFailCause(self2.effect_instruction_i0);
      case OP_SUCCESS:
        return exitSucceed(f(self2.effect_instruction_i0));
    }
  });
  var exitMapBoth = /* @__PURE__ */ dual(2, (self2, {
    onFailure,
    onSuccess
  }) => {
    switch (self2._tag) {
      case OP_FAILURE:
        return exitFailCause(pipe(self2.effect_instruction_i0, map9(onFailure)));
      case OP_SUCCESS:
        return exitSucceed(onSuccess(self2.effect_instruction_i0));
    }
  });
  var exitMatch = /* @__PURE__ */ dual(2, (self2, {
    onFailure,
    onSuccess
  }) => {
    switch (self2._tag) {
      case OP_FAILURE:
        return onFailure(self2.effect_instruction_i0);
      case OP_SUCCESS:
        return onSuccess(self2.effect_instruction_i0);
    }
  });
  var exitMatchEffect = /* @__PURE__ */ dual(2, (self2, {
    onFailure,
    onSuccess
  }) => {
    switch (self2._tag) {
      case OP_FAILURE:
        return onFailure(self2.effect_instruction_i0);
      case OP_SUCCESS:
        return onSuccess(self2.effect_instruction_i0);
    }
  });
  var exitSucceed = (value) => {
    const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
    effect.effect_instruction_i0 = value;
    return effect;
  };
  var exitVoid = /* @__PURE__ */ exitSucceed(undefined);
  var exitZip = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
    onSuccess: (a, a2) => [a, a2],
    onFailure: sequential
  }));
  var exitZipRight = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
    onSuccess: (_, a2) => a2,
    onFailure: sequential
  }));
  var exitZipWith = /* @__PURE__ */ dual(3, (self2, that, {
    onFailure,
    onSuccess
  }) => {
    switch (self2._tag) {
      case OP_FAILURE: {
        switch (that._tag) {
          case OP_SUCCESS:
            return exitFailCause(self2.effect_instruction_i0);
          case OP_FAILURE: {
            return exitFailCause(onFailure(self2.effect_instruction_i0, that.effect_instruction_i0));
          }
        }
      }
      case OP_SUCCESS: {
        switch (that._tag) {
          case OP_SUCCESS:
            return exitSucceed(onSuccess(self2.effect_instruction_i0, that.effect_instruction_i0));
          case OP_FAILURE:
            return exitFailCause(that.effect_instruction_i0);
        }
      }
    }
  });
  var exitCollectAllInternal = (exits, combineCauses) => {
    const list = fromIterable2(exits);
    if (!isNonEmpty2(list)) {
      return none2();
    }
    return pipe(tailNonEmpty2(list), reduce(pipe(headNonEmpty2(list), exitMap(of2)), (accumulator, current) => pipe(accumulator, exitZipWith(current, {
      onSuccess: (list2, value) => pipe(list2, prepend2(value)),
      onFailure: combineCauses
    }))), exitMap(reverse2), exitMap((chunk) => toReadonlyArray(chunk)), some2);
  };
  var deferredUnsafeMake = (fiberId2) => {
    const _deferred = {
      ...CommitPrototype,
      [DeferredTypeId]: deferredVariance,
      state: make11(pending([])),
      commit() {
        return deferredAwait(this);
      },
      blockingOn: fiberId2
    };
    return _deferred;
  };
  var deferredMake = () => flatMap8(fiberId, (id) => deferredMakeAs(id));
  var deferredMakeAs = (fiberId2) => sync(() => deferredUnsafeMake(fiberId2));
  var deferredAwait = (self2) => asyncInterrupt((resume) => {
    const state = get6(self2.state);
    switch (state._tag) {
      case OP_STATE_DONE: {
        return resume(state.effect);
      }
      case OP_STATE_PENDING: {
        state.joiners.push(resume);
        return deferredInterruptJoiner(self2, resume);
      }
    }
  }, self2.blockingOn);
  var deferredComplete = /* @__PURE__ */ dual(2, (self2, effect) => intoDeferred(effect, self2));
  var deferredCompleteWith = /* @__PURE__ */ dual(2, (self2, effect) => sync(() => {
    const state = get6(self2.state);
    switch (state._tag) {
      case OP_STATE_DONE: {
        return false;
      }
      case OP_STATE_PENDING: {
        set2(self2.state, done(effect));
        for (let i = 0, len = state.joiners.length;i < len; i++) {
          state.joiners[i](effect);
        }
        return true;
      }
    }
  }));
  var deferredDone = /* @__PURE__ */ dual(2, (self2, exit2) => deferredCompleteWith(self2, exit2));
  var deferredFail = /* @__PURE__ */ dual(2, (self2, error) => deferredCompleteWith(self2, fail2(error)));
  var deferredFailCause = /* @__PURE__ */ dual(2, (self2, cause) => deferredCompleteWith(self2, failCause(cause)));
  var deferredInterrupt = (self2) => flatMap8(fiberId, (fiberId2) => deferredCompleteWith(self2, interruptWith(fiberId2)));
  var deferredInterruptWith = /* @__PURE__ */ dual(2, (self2, fiberId2) => deferredCompleteWith(self2, interruptWith(fiberId2)));
  var deferredIsDone = (self2) => sync(() => get6(self2.state)._tag === OP_STATE_DONE);
  var deferredPoll = (self2) => sync(() => {
    const state = get6(self2.state);
    switch (state._tag) {
      case OP_STATE_DONE: {
        return some2(state.effect);
      }
      case OP_STATE_PENDING: {
        return none2();
      }
    }
  });
  var deferredSucceed = /* @__PURE__ */ dual(2, (self2, value) => deferredCompleteWith(self2, succeed(value)));
  var deferredUnsafeDone = (self2, effect) => {
    const state = get6(self2.state);
    if (state._tag === OP_STATE_PENDING) {
      set2(self2.state, done(effect));
      for (let i = 0, len = state.joiners.length;i < len; i++) {
        state.joiners[i](effect);
      }
    }
  };
  var deferredInterruptJoiner = (self2, joiner) => sync(() => {
    const state = get6(self2.state);
    if (state._tag === OP_STATE_PENDING) {
      const index = state.joiners.indexOf(joiner);
      if (index >= 0) {
        state.joiners.splice(index, 1);
      }
    }
  });
  var constContext = /* @__PURE__ */ withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
  var context = () => constContext;
  var contextWithEffect = (f) => flatMap8(context(), f);
  var provideContext = /* @__PURE__ */ dual(2, (self2, context2) => fiberRefLocally(currentContext, context2)(self2));
  var provideSomeContext = /* @__PURE__ */ dual(2, (self2, context2) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context2))(self2));
  var mapInputContext = /* @__PURE__ */ dual(2, (self2, f) => contextWithEffect((context2) => provideContext(self2, f(context2))));
  var filterEffectOrElse = /* @__PURE__ */ dual(2, (self2, options) => flatMap8(self2, (a) => flatMap8(options.predicate(a), (pass) => pass ? succeed(a) : options.orElse(a))));
  var filterEffectOrFail = /* @__PURE__ */ dual(2, (self2, options) => filterEffectOrElse(self2, {
    predicate: options.predicate,
    orElse: (a) => fail2(options.orFailWith(a))
  }));
  var currentSpanFromFiber = (fiber) => {
    const span2 = fiber.currentSpan;
    return span2 !== undefined && span2._tag === "Span" ? some2(span2) : none2();
  };
  var NoopSpanProto = {
    _tag: "Span",
    spanId: "noop",
    traceId: "noop",
    sampled: false,
    status: {
      _tag: "Ended",
      startTime: /* @__PURE__ */ BigInt(0),
      endTime: /* @__PURE__ */ BigInt(0),
      exit: exitVoid
    },
    attributes: /* @__PURE__ */ new Map,
    links: [],
    kind: "internal",
    attribute() {},
    event() {},
    end() {},
    addLinks() {}
  };
  var noopSpan = (options) => Object.assign(Object.create(NoopSpanProto), options);

  // node_modules/effect/dist/esm/Deferred.js
  var DeferredTypeId2 = DeferredTypeId;
  var make19 = deferredMake;
  var _await = deferredAwait;
  var complete = deferredComplete;
  var done2 = deferredDone;
  var fail3 = deferredFail;
  var failCause2 = deferredFailCause;
  var interrupt3 = deferredInterrupt;
  var isDone = deferredIsDone;
  var poll = deferredPoll;
  var succeed2 = deferredSucceed;
  var unsafeMake4 = deferredUnsafeMake;
  var unsafeDone = deferredUnsafeDone;

  // node_modules/effect/dist/esm/Exit.js
  var isExit = exitIsExit;
  var isFailure = exitIsFailure;
  var isSuccess = exitIsSuccess;
  var all = exitCollectAll;
  var die3 = exitDie;
  var fail4 = exitFail;
  var failCause3 = exitFailCause;
  var flatten7 = exitFlatten;
  var interrupt4 = exitInterrupt;
  var map11 = exitMap;
  var mapBoth3 = exitMapBoth;
  var match6 = exitMatch;
  var succeed3 = exitSucceed;
  var void_2 = exitVoid;
  var zip3 = exitZip;
  var zipRight2 = exitZipRight;

  // node_modules/effect/dist/esm/MutableHashMap.js
  var TypeId8 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
  var MutableHashMapProto = {
    [TypeId8]: TypeId8,
    [Symbol.iterator]() {
      return new MutableHashMapIterator(this);
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "MutableHashMap",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };

  class MutableHashMapIterator {
    self;
    referentialIterator;
    bucketIterator;
    constructor(self2) {
      this.self = self2;
      this.referentialIterator = self2.referential[Symbol.iterator]();
    }
    next() {
      if (this.bucketIterator !== undefined) {
        return this.bucketIterator.next();
      }
      const result = this.referentialIterator.next();
      if (result.done) {
        this.bucketIterator = new BucketIterator(this.self.buckets.values());
        return this.next();
      }
      return result;
    }
    [Symbol.iterator]() {
      return new MutableHashMapIterator(this.self);
    }
  }

  class BucketIterator {
    backing;
    constructor(backing) {
      this.backing = backing;
    }
    currentBucket;
    next() {
      if (this.currentBucket === undefined) {
        const result2 = this.backing.next();
        if (result2.done) {
          return result2;
        }
        this.currentBucket = result2.value[Symbol.iterator]();
      }
      const result = this.currentBucket.next();
      if (result.done) {
        this.currentBucket = undefined;
        return this.next();
      }
      return result;
    }
  }
  var empty18 = () => {
    const self2 = Object.create(MutableHashMapProto);
    self2.referential = new Map;
    self2.buckets = new Map;
    self2.bucketsSize = 0;
    return self2;
  };
  var get8 = /* @__PURE__ */ dual(2, (self2, key) => {
    if (isEqual(key) === false) {
      return self2.referential.has(key) ? some2(self2.referential.get(key)) : none2();
    }
    const hash2 = key[symbol]();
    const bucket = self2.buckets.get(hash2);
    if (bucket === undefined) {
      return none2();
    }
    return getFromBucket(self2, bucket, key);
  });
  var getFromBucket = (self2, bucket, key, remove5 = false) => {
    for (let i = 0, len = bucket.length;i < len; i++) {
      if (key[symbol2](bucket[i][0])) {
        const value = bucket[i][1];
        if (remove5) {
          bucket.splice(i, 1);
          self2.bucketsSize--;
        }
        return some2(value);
      }
    }
    return none2();
  };
  var has4 = /* @__PURE__ */ dual(2, (self2, key) => isSome2(get8(self2, key)));
  var set4 = /* @__PURE__ */ dual(3, (self2, key, value) => {
    if (isEqual(key) === false) {
      self2.referential.set(key, value);
      return self2;
    }
    const hash2 = key[symbol]();
    const bucket = self2.buckets.get(hash2);
    if (bucket === undefined) {
      self2.buckets.set(hash2, [[key, value]]);
      self2.bucketsSize++;
      return self2;
    }
    removeFromBucket(self2, bucket, key);
    bucket.push([key, value]);
    self2.bucketsSize++;
    return self2;
  });
  var removeFromBucket = (self2, bucket, key) => {
    for (let i = 0, len = bucket.length;i < len; i++) {
      if (key[symbol2](bucket[i][0])) {
        bucket.splice(i, 1);
        self2.bucketsSize--;
        return;
      }
    }
  };
  var remove5 = /* @__PURE__ */ dual(2, (self2, key) => {
    if (isEqual(key) === false) {
      self2.referential.delete(key);
      return self2;
    }
    const hash2 = key[symbol]();
    const bucket = self2.buckets.get(hash2);
    if (bucket === undefined) {
      return self2;
    }
    removeFromBucket(self2, bucket, key);
    if (bucket.length === 0) {
      self2.buckets.delete(hash2);
    }
    return self2;
  });
  var size4 = (self2) => {
    return self2.referential.size + self2.bucketsSize;
  };

  // node_modules/effect/dist/esm/MutableList.js
  var TypeId9 = /* @__PURE__ */ Symbol.for("effect/MutableList");
  var MutableListProto = {
    [TypeId9]: TypeId9,
    [Symbol.iterator]() {
      let done3 = false;
      let head3 = this.head;
      return {
        next() {
          if (done3) {
            return this.return();
          }
          if (head3 == null) {
            done3 = true;
            return this.return();
          }
          const value = head3.value;
          head3 = head3.next;
          return {
            done: done3,
            value
          };
        },
        return(value) {
          if (!done3) {
            done3 = true;
          }
          return {
            done: true,
            value
          };
        }
      };
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "MutableList",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var makeNode = (value) => ({
    value,
    removed: false,
    prev: undefined,
    next: undefined
  });
  var empty19 = () => {
    const list = Object.create(MutableListProto);
    list.head = undefined;
    list.tail = undefined;
    list._length = 0;
    return list;
  };
  var isEmpty6 = (self2) => length(self2) === 0;
  var length = (self2) => self2._length;
  var append3 = /* @__PURE__ */ dual(2, (self2, value) => {
    const node = makeNode(value);
    if (self2.head === undefined) {
      self2.head = node;
    }
    if (self2.tail === undefined) {
      self2.tail = node;
    } else {
      self2.tail.next = node;
      node.prev = self2.tail;
      self2.tail = node;
    }
    self2._length += 1;
    return self2;
  });
  var shift = (self2) => {
    const head3 = self2.head;
    if (head3 !== undefined) {
      remove6(self2, head3);
      return head3.value;
    }
    return;
  };
  var remove6 = (self2, node) => {
    if (node.removed) {
      return;
    }
    node.removed = true;
    if (node.prev !== undefined && node.next !== undefined) {
      node.prev.next = node.next;
      node.next.prev = node.prev;
    } else if (node.prev !== undefined) {
      self2.tail = node.prev;
      node.prev.next = undefined;
    } else if (node.next !== undefined) {
      self2.head = node.next;
      node.next.prev = undefined;
    } else {
      self2.tail = undefined;
      self2.head = undefined;
    }
    if (self2._length > 0) {
      self2._length -= 1;
    }
  };

  // node_modules/effect/dist/esm/MutableQueue.js
  var TypeId10 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
  var EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
  var MutableQueueProto = {
    [TypeId10]: TypeId10,
    [Symbol.iterator]() {
      return Array.from(this.queue)[Symbol.iterator]();
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "MutableQueue",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var make20 = (capacity) => {
    const queue = Object.create(MutableQueueProto);
    queue.queue = empty19();
    queue.capacity = capacity;
    return queue;
  };
  var bounded = (capacity) => make20(capacity);
  var unbounded = () => make20(undefined);
  var length2 = (self2) => length(self2.queue);
  var isEmpty7 = (self2) => isEmpty6(self2.queue);
  var capacity = (self2) => self2.capacity === undefined ? Infinity : self2.capacity;
  var offer = /* @__PURE__ */ dual(2, (self2, value) => {
    const queueLength = length(self2.queue);
    if (self2.capacity !== undefined && queueLength === self2.capacity) {
      return false;
    }
    append3(value)(self2.queue);
    return true;
  });
  var offerAll = /* @__PURE__ */ dual(2, (self2, values3) => {
    const iterator = values3[Symbol.iterator]();
    let next;
    let remainder = empty5();
    let offering = true;
    while (offering && (next = iterator.next()) && !next.done) {
      offering = offer(next.value)(self2);
    }
    while (next != null && !next.done) {
      remainder = prepend2(next.value)(remainder);
      next = iterator.next();
    }
    return reverse2(remainder);
  });
  var poll2 = /* @__PURE__ */ dual(2, (self2, def) => {
    if (isEmpty6(self2.queue)) {
      return def;
    }
    return shift(self2.queue);
  });
  var pollUpTo = /* @__PURE__ */ dual(2, (self2, n) => {
    let result = empty5();
    let count = 0;
    while (count < n) {
      const element = poll2(EmptyMutableQueue)(self2);
      if (element === EmptyMutableQueue) {
        break;
      }
      result = prepend2(element)(result);
      count += 1;
    }
    return reverse2(result);
  });

  // node_modules/effect/dist/esm/internal/clock.js
  var ClockSymbolKey = "effect/Clock";
  var ClockTypeId = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
  var clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
  var MAX_TIMER_MILLIS = 2 ** 31 - 1;
  var globalClockScheduler = {
    unsafeSchedule(task, duration) {
      const millis2 = toMillis(duration);
      if (millis2 > MAX_TIMER_MILLIS) {
        return constFalse;
      }
      let completed = false;
      const handle = setTimeout(() => {
        completed = true;
        task();
      }, millis2);
      return () => {
        clearTimeout(handle);
        return !completed;
      };
    }
  };
  var performanceNowNanos = /* @__PURE__ */ function() {
    const bigint1e62 = /* @__PURE__ */ BigInt(1e6);
    if (typeof performance === "undefined") {
      return () => BigInt(Date.now()) * bigint1e62;
    }
    let origin;
    return () => {
      if (origin === undefined) {
        origin = BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
      }
      return origin + BigInt(Math.round(performance.now() * 1e6));
    };
  }();
  var processOrPerformanceNow = /* @__PURE__ */ function() {
    const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : undefined;
    if (!processHrtime) {
      return performanceNowNanos;
    }
    const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
    return () => origin + processHrtime.bigint();
  }();

  class ClockImpl {
    [ClockTypeId] = ClockTypeId;
    unsafeCurrentTimeMillis() {
      return Date.now();
    }
    unsafeCurrentTimeNanos() {
      return processOrPerformanceNow();
    }
    currentTimeMillis = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeMillis());
    currentTimeNanos = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeNanos());
    scheduler() {
      return succeed(globalClockScheduler);
    }
    sleep(duration) {
      return async_((resume) => {
        const canceler = globalClockScheduler.unsafeSchedule(() => resume(void_), duration);
        return asVoid(sync(canceler));
      });
    }
  }
  var make21 = () => new ClockImpl;

  // node_modules/effect/dist/esm/internal/opCodes/configError.js
  var OP_AND = "And";
  var OP_OR = "Or";
  var OP_INVALID_DATA = "InvalidData";
  var OP_MISSING_DATA = "MissingData";
  var OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
  var OP_UNSUPPORTED = "Unsupported";

  // node_modules/effect/dist/esm/internal/configError.js
  var ConfigErrorSymbolKey = "effect/ConfigError";
  var ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
  var proto2 = {
    _tag: "ConfigError",
    [ConfigErrorTypeId]: ConfigErrorTypeId
  };
  var And = (self2, that) => {
    const error = Object.create(proto2);
    error._op = OP_AND;
    error.left = self2;
    error.right = that;
    Object.defineProperty(error, "toString", {
      enumerable: false,
      value() {
        return `${this.left} and ${this.right}`;
      }
    });
    Object.defineProperty(error, "message", {
      enumerable: false,
      get() {
        return this.toString();
      }
    });
    return error;
  };
  var Or = (self2, that) => {
    const error = Object.create(proto2);
    error._op = OP_OR;
    error.left = self2;
    error.right = that;
    Object.defineProperty(error, "toString", {
      enumerable: false,
      value() {
        return `${this.left} or ${this.right}`;
      }
    });
    Object.defineProperty(error, "message", {
      enumerable: false,
      get() {
        return this.toString();
      }
    });
    return error;
  };
  var InvalidData = (path, message, options = {
    pathDelim: "."
  }) => {
    const error = Object.create(proto2);
    error._op = OP_INVALID_DATA;
    error.path = path;
    error.message = message;
    Object.defineProperty(error, "toString", {
      enumerable: false,
      value() {
        const path2 = pipe(this.path, join(options.pathDelim));
        return `(Invalid data at ${path2}: "${this.message}")`;
      }
    });
    return error;
  };
  var MissingData = (path, message, options = {
    pathDelim: "."
  }) => {
    const error = Object.create(proto2);
    error._op = OP_MISSING_DATA;
    error.path = path;
    error.message = message;
    Object.defineProperty(error, "toString", {
      enumerable: false,
      value() {
        const path2 = pipe(this.path, join(options.pathDelim));
        return `(Missing data at ${path2}: "${this.message}")`;
      }
    });
    return error;
  };
  var SourceUnavailable = (path, message, cause, options = {
    pathDelim: "."
  }) => {
    const error = Object.create(proto2);
    error._op = OP_SOURCE_UNAVAILABLE;
    error.path = path;
    error.message = message;
    error.cause = cause;
    Object.defineProperty(error, "toString", {
      enumerable: false,
      value() {
        const path2 = pipe(this.path, join(options.pathDelim));
        return `(Source unavailable at ${path2}: "${this.message}")`;
      }
    });
    return error;
  };
  var Unsupported = (path, message, options = {
    pathDelim: "."
  }) => {
    const error = Object.create(proto2);
    error._op = OP_UNSUPPORTED;
    error.path = path;
    error.message = message;
    Object.defineProperty(error, "toString", {
      enumerable: false,
      value() {
        const path2 = pipe(this.path, join(options.pathDelim));
        return `(Unsupported operation at ${path2}: "${this.message}")`;
      }
    });
    return error;
  };
  var prefixed = /* @__PURE__ */ dual(2, (self2, prefix) => {
    switch (self2._op) {
      case OP_AND: {
        return And(prefixed(self2.left, prefix), prefixed(self2.right, prefix));
      }
      case OP_OR: {
        return Or(prefixed(self2.left, prefix), prefixed(self2.right, prefix));
      }
      case OP_INVALID_DATA: {
        return InvalidData([...prefix, ...self2.path], self2.message);
      }
      case OP_MISSING_DATA: {
        return MissingData([...prefix, ...self2.path], self2.message);
      }
      case OP_SOURCE_UNAVAILABLE: {
        return SourceUnavailable([...prefix, ...self2.path], self2.message, self2.cause);
      }
      case OP_UNSUPPORTED: {
        return Unsupported([...prefix, ...self2.path], self2.message);
      }
    }
  });

  // node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
  var empty20 = {
    _tag: "Empty"
  };
  var patch5 = /* @__PURE__ */ dual(2, (path, patch6) => {
    let input = of3(patch6);
    let output = path;
    while (isCons(input)) {
      const patch7 = input.head;
      switch (patch7._tag) {
        case "Empty": {
          input = input.tail;
          break;
        }
        case "AndThen": {
          input = cons(patch7.first, cons(patch7.second, input.tail));
          break;
        }
        case "MapName": {
          output = map3(output, patch7.f);
          input = input.tail;
          break;
        }
        case "Nested": {
          output = prepend(output, patch7.name);
          input = input.tail;
          break;
        }
        case "Unnested": {
          const containsName = pipe(head(output), contains(patch7.name));
          if (containsName) {
            output = tailNonEmpty(output);
            input = input.tail;
          } else {
            return left2(MissingData(output, `Expected ${patch7.name} to be in path in ConfigProvider#unnested`));
          }
          break;
        }
      }
    }
    return right2(output);
  });

  // node_modules/effect/dist/esm/internal/opCodes/config.js
  var OP_CONSTANT = "Constant";
  var OP_FAIL2 = "Fail";
  var OP_FALLBACK = "Fallback";
  var OP_DESCRIBED = "Described";
  var OP_LAZY = "Lazy";
  var OP_MAP_OR_FAIL = "MapOrFail";
  var OP_NESTED = "Nested";
  var OP_PRIMITIVE = "Primitive";
  var OP_SEQUENCE = "Sequence";
  var OP_HASHMAP = "HashMap";
  var OP_ZIP_WITH = "ZipWith";

  // node_modules/effect/dist/esm/internal/configProvider.js
  var concat = (l, r) => [...l, ...r];
  var ConfigProviderSymbolKey = "effect/ConfigProvider";
  var ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
  var configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
  var FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
  var FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
  var make23 = (options) => ({
    [ConfigProviderTypeId]: ConfigProviderTypeId,
    pipe() {
      return pipeArguments(this, arguments);
    },
    ...options
  });
  var makeFlat = (options) => ({
    [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
    patch: options.patch,
    load: (path, config, split = true) => options.load(path, config, split),
    enumerateChildren: options.enumerateChildren
  });
  var fromFlat = (flat) => make23({
    load: (config) => flatMap8(fromFlatLoop(flat, empty2(), config, false), (chunk) => match2(head(chunk), {
      onNone: () => fail2(MissingData(empty2(), `Expected a single value having structure: ${config}`)),
      onSome: succeed
    })),
    flattened: flat
  });
  var fromEnv = (options) => {
    const {
      pathDelim,
      seqDelim
    } = Object.assign({}, {
      pathDelim: "_",
      seqDelim: ","
    }, options);
    const makePathString = (path) => pipe(path, join(pathDelim));
    const unmakePathString = (pathString) => pathString.split(pathDelim);
    const getEnv = () => typeof process !== "undefined" && ("env" in process) && typeof process.env === "object" ? process.env : {};
    const load = (path, primitive, split = true) => {
      const pathString = makePathString(path);
      const current = getEnv();
      const valueOpt = pathString in current ? some2(current[pathString]) : none2();
      return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap8((value) => parsePrimitive(value, path, primitive, seqDelim, split)));
    };
    const enumerateChildren = (path) => sync(() => {
      const current = getEnv();
      const keys3 = Object.keys(current);
      const keyPaths = keys3.map((value) => unmakePathString(value.toUpperCase()));
      const filteredKeyPaths = keyPaths.filter((keyPath) => {
        for (let i = 0;i < path.length; i++) {
          const pathComponent = pipe(path, unsafeGet(i));
          const currentElement = keyPath[i];
          if (currentElement === undefined || pathComponent !== currentElement) {
            return false;
          }
        }
        return true;
      }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
      return fromIterable5(filteredKeyPaths);
    });
    return fromFlat(makeFlat({
      load,
      enumerateChildren,
      patch: empty20
    }));
  };
  var extend = (leftDef, rightDef, left3, right3) => {
    const leftPad = unfold(left3.length, (index) => index >= right3.length ? none2() : some2([leftDef(index), index + 1]));
    const rightPad = unfold(right3.length, (index) => index >= left3.length ? none2() : some2([rightDef(index), index + 1]));
    const leftExtension = concat(left3, leftPad);
    const rightExtension = concat(right3, rightPad);
    return [leftExtension, rightExtension];
  };
  var appendConfigPath = (path, config) => {
    let op = config;
    if (op._tag === "Nested") {
      const out = path.slice();
      while (op._tag === "Nested") {
        out.push(op.name);
        op = op.config;
      }
      return out;
    }
    return path;
  };
  var fromFlatLoop = (flat, prefix, config, split) => {
    const op = config;
    switch (op._tag) {
      case OP_CONSTANT: {
        return succeed(of(op.value));
      }
      case OP_DESCRIBED: {
        return suspend(() => fromFlatLoop(flat, prefix, op.config, split));
      }
      case OP_FAIL2: {
        return fail2(MissingData(prefix, op.message));
      }
      case OP_FALLBACK: {
        return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split)), catchAll((error1) => {
          if (op.condition(error1)) {
            return pipe(fromFlatLoop(flat, prefix, op.second, split), catchAll((error2) => fail2(Or(error1, error2))));
          }
          return fail2(error1);
        }));
      }
      case OP_LAZY: {
        return suspend(() => fromFlatLoop(flat, prefix, op.config(), split));
      }
      case OP_MAP_OR_FAIL: {
        return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split), flatMap8(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
      }
      case OP_NESTED: {
        return suspend(() => fromFlatLoop(flat, concat(prefix, of(op.name)), op.config, split));
      }
      case OP_PRIMITIVE: {
        return pipe(patch5(prefix, flat.patch), flatMap8((prefix2) => pipe(flat.load(prefix2, op, split), flatMap8((values3) => {
          if (values3.length === 0) {
            const name = pipe(last(prefix2), getOrElse(() => "<n/a>"));
            return fail2(MissingData([], `Expected ${op.description} with name ${name}`));
          }
          return succeed(values3);
        }))));
      }
      case OP_SEQUENCE: {
        return pipe(patch5(prefix, flat.patch), flatMap8((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap8(indicesFrom), flatMap8((indices) => {
          if (indices.length === 0) {
            return suspend(() => map10(fromFlatLoop(flat, prefix, op.config, true), of));
          }
          return pipe(forEachSequential(indices, (index) => fromFlatLoop(flat, append(prefix, `[${index}]`), op.config, true)), map10((chunkChunk) => {
            const flattened = flatten(chunkChunk);
            if (flattened.length === 0) {
              return of(empty2());
            }
            return of(flattened);
          }));
        }))));
      }
      case OP_HASHMAP: {
        return suspend(() => pipe(patch5(prefix, flat.patch), flatMap8((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap8((keys3) => {
          return pipe(keys3, forEachSequential((key) => fromFlatLoop(flat, concat(prefix2, of(key)), op.valueConfig, split)), map10((matrix) => {
            if (matrix.length === 0) {
              return of(empty9());
            }
            return pipe(transpose(matrix), map3((values3) => fromIterable6(zip(fromIterable(keys3), values3))));
          }));
        })))));
      }
      case OP_ZIP_WITH: {
        return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split), either2, flatMap8((left3) => pipe(fromFlatLoop(flat, prefix, op.right, split), either2, flatMap8((right3) => {
          if (isLeft2(left3) && isLeft2(right3)) {
            return fail2(And(left3.left, right3.left));
          }
          if (isLeft2(left3) && isRight2(right3)) {
            return fail2(left3.left);
          }
          if (isRight2(left3) && isLeft2(right3)) {
            return fail2(right3.left);
          }
          if (isRight2(left3) && isRight2(right3)) {
            const path = pipe(prefix, join("."));
            const fail5 = fromFlatLoopFail(prefix, path);
            const [lefts, rights] = extend(fail5, fail5, pipe(left3.right, map3(right2)), pipe(right3.right, map3(right2)));
            return pipe(lefts, zip(rights), forEachSequential(([left4, right4]) => pipe(zip2(left4, right4), map10(([left5, right5]) => op.zip(left5, right5)))));
          }
          throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
        })))));
      }
    }
  };
  var fromFlatLoopFail = (prefix, path) => (index) => left2(MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`));
  var splitPathString = (text, delim) => {
    const split = text.split(new RegExp(`\\s*${escape2(delim)}\\s*`));
    return split;
  };
  var parsePrimitive = (text, path, primitive, delimiter, split) => {
    if (!split) {
      return pipe(primitive.parse(text), mapBoth2({
        onFailure: prefixed(path),
        onSuccess: of
      }));
    }
    return pipe(splitPathString(text, delimiter), forEachSequential((char) => primitive.parse(char.trim())), mapError(prefixed(path)));
  };
  var transpose = (array3) => {
    return Object.keys(array3[0]).map((column) => array3.map((row) => row[column]));
  };
  var indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth2({
    onFailure: () => empty2(),
    onSuccess: sort(Order)
  }), either2, map10(merge));
  var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
  var parseQuotedIndex = (str) => {
    const match7 = str.match(QUOTED_INDEX_REGEX);
    if (match7 !== null) {
      const matchedIndex = match7[2];
      return pipe(matchedIndex !== undefined && matchedIndex.length > 0 ? some2(matchedIndex) : none2(), flatMap(parseInteger));
    }
    return none2();
  };
  var parseInteger = (str) => {
    const parsedIndex = Number.parseInt(str);
    return Number.isNaN(parsedIndex) ? none2() : some2(parsedIndex);
  };

  // node_modules/effect/dist/esm/internal/defaultServices/console.js
  var TypeId11 = /* @__PURE__ */ Symbol.for("effect/Console");
  var consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
  var defaultConsole = {
    [TypeId11]: TypeId11,
    assert(condition, ...args) {
      return sync(() => {
        console.assert(condition, ...args);
      });
    },
    clear: /* @__PURE__ */ sync(() => {
      console.clear();
    }),
    count(label) {
      return sync(() => {
        console.count(label);
      });
    },
    countReset(label) {
      return sync(() => {
        console.countReset(label);
      });
    },
    debug(...args) {
      return sync(() => {
        console.debug(...args);
      });
    },
    dir(item, options) {
      return sync(() => {
        console.dir(item, options);
      });
    },
    dirxml(...args) {
      return sync(() => {
        console.dirxml(...args);
      });
    },
    error(...args) {
      return sync(() => {
        console.error(...args);
      });
    },
    group(options) {
      return options?.collapsed ? sync(() => console.groupCollapsed(options?.label)) : sync(() => console.group(options?.label));
    },
    groupEnd: /* @__PURE__ */ sync(() => {
      console.groupEnd();
    }),
    info(...args) {
      return sync(() => {
        console.info(...args);
      });
    },
    log(...args) {
      return sync(() => {
        console.log(...args);
      });
    },
    table(tabularData, properties) {
      return sync(() => {
        console.table(tabularData, properties);
      });
    },
    time(label) {
      return sync(() => console.time(label));
    },
    timeEnd(label) {
      return sync(() => console.timeEnd(label));
    },
    timeLog(label, ...args) {
      return sync(() => {
        console.timeLog(label, ...args);
      });
    },
    trace(...args) {
      return sync(() => {
        console.trace(...args);
      });
    },
    warn(...args) {
      return sync(() => {
        console.warn(...args);
      });
    },
    unsafe: console
  };

  // node_modules/effect/dist/esm/internal/random.js
  var RandomSymbolKey = "effect/Random";
  var RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
  var randomTag = /* @__PURE__ */ GenericTag("effect/Random");

  class RandomImpl {
    seed;
    [RandomTypeId] = RandomTypeId;
    PRNG;
    constructor(seed) {
      this.seed = seed;
      this.PRNG = new PCGRandom(seed);
    }
    get next() {
      return sync(() => this.PRNG.number());
    }
    get nextBoolean() {
      return map10(this.next, (n) => n > 0.5);
    }
    get nextInt() {
      return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
    }
    nextRange(min2, max2) {
      return map10(this.next, (n) => (max2 - min2) * n + min2);
    }
    nextIntBetween(min2, max2) {
      return sync(() => this.PRNG.integer(max2 - min2) + min2);
    }
    shuffle(elements) {
      return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
    }
  }
  var shuffleWith = (elements, nextIntBounded) => {
    return suspend(() => pipe(sync(() => Array.from(elements)), flatMap8((buffer) => {
      const numbers = [];
      for (let i = buffer.length;i >= 2; i = i - 1) {
        numbers.push(i);
      }
      return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map10((k) => swap(buffer, n - 1, k)))), as(fromIterable2(buffer)));
    })));
  };
  var swap = (buffer, index1, index2) => {
    const tmp = buffer[index1];
    buffer[index1] = buffer[index2];
    buffer[index2] = tmp;
    return buffer;
  };
  var make24 = (seed) => new RandomImpl(hash(seed));

  class FixedRandomImpl {
    values;
    [RandomTypeId] = RandomTypeId;
    index = 0;
    constructor(values3) {
      this.values = values3;
      if (values3.length === 0) {
        throw new Error("Requires at least one value");
      }
    }
    getNextValue() {
      const value = this.values[this.index];
      this.index = (this.index + 1) % this.values.length;
      return value;
    }
    get next() {
      return sync(() => {
        const value = this.getNextValue();
        if (typeof value === "number") {
          return Math.max(0, Math.min(1, value));
        }
        return hash(value) / 2147483647;
      });
    }
    get nextBoolean() {
      return sync(() => {
        const value = this.getNextValue();
        if (typeof value === "boolean") {
          return value;
        }
        return hash(value) % 2 === 0;
      });
    }
    get nextInt() {
      return sync(() => {
        const value = this.getNextValue();
        if (typeof value === "number" && Number.isFinite(value)) {
          return Math.round(value);
        }
        return Math.abs(hash(value));
      });
    }
    nextRange(min2, max2) {
      return map10(this.next, (n) => (max2 - min2) * n + min2);
    }
    nextIntBetween(min2, max2) {
      return sync(() => {
        const value = this.getNextValue();
        if (typeof value === "number" && Number.isFinite(value)) {
          return Math.max(min2, Math.min(max2 - 1, Math.round(value)));
        }
        const hash2 = Math.abs(hash(value));
        return min2 + hash2 % (max2 - min2);
      });
    }
    shuffle(elements) {
      return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
    }
  }
  var fixed = (values3) => new FixedRandomImpl(values3);

  // node_modules/effect/dist/esm/internal/tracer.js
  var TracerTypeId = /* @__PURE__ */ Symbol.for("effect/Tracer");
  var make25 = (options) => ({
    [TracerTypeId]: TracerTypeId,
    ...options
  });
  var tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
  var spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
  var randomHexString = /* @__PURE__ */ function() {
    const characters = "abcdef0123456789";
    const charactersLength = characters.length;
    return function(length3) {
      let result = "";
      for (let i = 0;i < length3; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
      }
      return result;
    };
  }();

  class NativeSpan {
    name;
    parent;
    context;
    startTime;
    kind;
    _tag = "Span";
    spanId;
    traceId = "native";
    sampled = true;
    status;
    attributes;
    events = [];
    links;
    constructor(name, parent, context2, links, startTime, kind) {
      this.name = name;
      this.parent = parent;
      this.context = context2;
      this.startTime = startTime;
      this.kind = kind;
      this.status = {
        _tag: "Started",
        startTime
      };
      this.attributes = new Map;
      this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
      this.spanId = randomHexString(16);
      this.links = Array.from(links);
    }
    end(endTime, exit2) {
      this.status = {
        _tag: "Ended",
        endTime,
        exit: exit2,
        startTime: this.status.startTime
      };
    }
    attribute(key, value) {
      this.attributes.set(key, value);
    }
    event(name, startTime, attributes) {
      this.events.push([name, startTime, attributes ?? {}]);
    }
    addLinks(links) {
      this.links.push(...links);
    }
  }
  var nativeTracer = /* @__PURE__ */ make25({
    span: (name, parent, context2, links, startTime, kind) => new NativeSpan(name, parent, context2, links, startTime, kind),
    context: (f) => f()
  });
  var addSpanStackTrace = (options) => {
    if (options?.captureStackTrace === false) {
      return options;
    } else if (options?.captureStackTrace !== undefined && typeof options.captureStackTrace !== "boolean") {
      return options;
    }
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 3;
    const traceError = new Error;
    Error.stackTraceLimit = limit;
    let cache = false;
    return {
      ...options,
      captureStackTrace: () => {
        if (cache !== false) {
          return cache;
        }
        if (traceError.stack !== undefined) {
          const stack = traceError.stack.split(`
`);
          if (stack[3] !== undefined) {
            cache = stack[3].trim();
            return cache;
          }
        }
      }
    };
  };
  var DisablePropagation = /* @__PURE__ */ Reference2()("effect/Tracer/DisablePropagation", {
    defaultValue: constFalse
  });

  // node_modules/effect/dist/esm/internal/defaultServices.js
  var liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty4(), /* @__PURE__ */ add2(clockTag, /* @__PURE__ */ make21()), /* @__PURE__ */ add2(consoleTag, defaultConsole), /* @__PURE__ */ add2(randomTag, /* @__PURE__ */ make24(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add2(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add2(tracerTag, nativeTracer));
  var currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
  var sleep = (duration) => {
    const decodedDuration = decode(duration);
    return clockWith((clock) => clock.sleep(decodedDuration));
  };
  var defaultServicesWith = (f) => withFiberRuntime((fiber) => f(fiber.currentDefaultServices));
  var clockWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key)));
  var currentTimeMillis = /* @__PURE__ */ clockWith((clock) => clock.currentTimeMillis);
  var currentTimeNanos = /* @__PURE__ */ clockWith((clock) => clock.currentTimeNanos);
  var withClock = /* @__PURE__ */ dual(2, (effect, c) => fiberRefLocallyWith(currentServices, add2(clockTag, c))(effect));
  var withConfigProvider = /* @__PURE__ */ dual(2, (self2, provider) => fiberRefLocallyWith(currentServices, add2(configProviderTag, provider))(self2));
  var configProviderWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(configProviderTag.key)));
  var randomWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(randomTag.key)));
  var withRandom = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add2(randomTag, value))(effect));
  var tracerWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(tracerTag.key)));
  var withTracer = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add2(tracerTag, value))(effect));

  // node_modules/effect/dist/esm/Clock.js
  var sleep2 = sleep;
  var currentTimeMillis2 = currentTimeMillis;
  var currentTimeNanos2 = currentTimeNanos;
  var clockWith2 = clockWith;
  var Clock = clockTag;

  // node_modules/effect/dist/esm/internal/fiberRefs.js
  function unsafeMake5(fiberRefLocals) {
    return new FiberRefsImpl(fiberRefLocals);
  }
  function empty21() {
    return unsafeMake5(new Map);
  }
  var FiberRefsSym = /* @__PURE__ */ Symbol.for("effect/FiberRefs");

  class FiberRefsImpl {
    locals;
    [FiberRefsSym] = FiberRefsSym;
    constructor(locals) {
      this.locals = locals;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
    const ref = _ref;
    let parentStack = _parentStack;
    let childStack = _childStack;
    let childModified = _childModified;
    let ret = undefined;
    while (ret === undefined) {
      if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
        const parentFiberId = headNonEmpty(parentStack)[0];
        const parentAncestors = tailNonEmpty(parentStack);
        const childFiberId = headNonEmpty(childStack)[0];
        const childRefValue = headNonEmpty(childStack)[1];
        const childAncestors = tailNonEmpty(childStack);
        if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
          parentStack = parentAncestors;
        } else {
          if (parentFiberId.id < childFiberId.id) {
            childStack = childAncestors;
            childModified = true;
          } else if (parentFiberId.id > childFiberId.id) {
            parentStack = parentAncestors;
          } else {
            ret = [childRefValue, childModified];
          }
        }
      } else {
        ret = [ref.initial, true];
      }
    }
    return ret;
  };
  var joinAs = /* @__PURE__ */ dual(3, (self2, fiberId2, that) => {
    const parentFiberRefs = new Map(self2.locals);
    that.locals.forEach((childStack, fiberRef) => {
      const childValue = childStack[0][1];
      if (!childStack[0][0][symbol2](fiberId2)) {
        if (!parentFiberRefs.has(fiberRef)) {
          if (equals(childValue, fiberRef.initial)) {
            return;
          }
          parentFiberRefs.set(fiberRef, [[fiberId2, fiberRef.join(fiberRef.initial, childValue)]]);
          return;
        }
        const parentStack = parentFiberRefs.get(fiberRef);
        const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
        if (wasModified) {
          const patch6 = fiberRef.diff(ancestor, childValue);
          const oldValue = parentStack[0][1];
          const newValue = fiberRef.join(oldValue, fiberRef.patch(patch6)(oldValue));
          if (!equals(oldValue, newValue)) {
            let newStack;
            const parentFiberId = parentStack[0][0];
            if (parentFiberId[symbol2](fiberId2)) {
              newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
            } else {
              newStack = [[fiberId2, newValue], ...parentStack];
            }
            parentFiberRefs.set(fiberRef, newStack);
          }
        }
      }
    });
    return new FiberRefsImpl(parentFiberRefs);
  });
  var forkAs = /* @__PURE__ */ dual(2, (self2, childId) => {
    const map12 = new Map;
    unsafeForkAs(self2, map12, childId);
    return new FiberRefsImpl(map12);
  });
  var unsafeForkAs = (self2, map12, fiberId2) => {
    self2.locals.forEach((stack, fiberRef) => {
      const oldValue = stack[0][1];
      const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
      if (equals(oldValue, newValue)) {
        map12.set(fiberRef, stack);
      } else {
        map12.set(fiberRef, [[fiberId2, newValue], ...stack]);
      }
    });
  };
  var fiberRefs = (self2) => fromIterable5(self2.locals.keys());
  var setAll = (self2) => forEachSequentialDiscard(fiberRefs(self2), (fiberRef) => fiberRefSet(fiberRef, getOrDefault(self2, fiberRef)));
  var delete_ = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
    const locals = new Map(self2.locals);
    locals.delete(fiberRef);
    return new FiberRefsImpl(locals);
  });
  var get9 = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
    if (!self2.locals.has(fiberRef)) {
      return none2();
    }
    return some2(headNonEmpty(self2.locals.get(fiberRef))[1]);
  });
  var getOrDefault = /* @__PURE__ */ dual(2, (self2, fiberRef) => pipe(get9(self2, fiberRef), getOrElse(() => fiberRef.initial)));
  var updateAs = /* @__PURE__ */ dual(2, (self2, {
    fiberId: fiberId2,
    fiberRef,
    value
  }) => {
    if (self2.locals.size === 0) {
      return new FiberRefsImpl(new Map([[fiberRef, [[fiberId2, value]]]]));
    }
    const locals = new Map(self2.locals);
    unsafeUpdateAs(locals, fiberId2, fiberRef, value);
    return new FiberRefsImpl(locals);
  });
  var unsafeUpdateAs = (locals, fiberId2, fiberRef, value) => {
    const oldStack = locals.get(fiberRef) ?? [];
    let newStack;
    if (isNonEmptyReadonlyArray(oldStack)) {
      const [currentId, currentValue] = headNonEmpty(oldStack);
      if (currentId[symbol2](fiberId2)) {
        if (equals(currentValue, value)) {
          return;
        } else {
          newStack = [[fiberId2, value], ...oldStack.slice(1)];
        }
      } else {
        newStack = [[fiberId2, value], ...oldStack];
      }
    } else {
      newStack = [[fiberId2, value]];
    }
    locals.set(fiberRef, newStack);
  };
  var updateManyAs = /* @__PURE__ */ dual(2, (self2, {
    entries: entries2,
    forkAs: forkAs2
  }) => {
    if (self2.locals.size === 0) {
      return new FiberRefsImpl(new Map(entries2));
    }
    const locals = new Map(self2.locals);
    if (forkAs2 !== undefined) {
      unsafeForkAs(self2, locals, forkAs2);
    }
    entries2.forEach(([fiberRef, values3]) => {
      if (values3.length === 1) {
        unsafeUpdateAs(locals, values3[0][0], fiberRef, values3[0][1]);
      } else {
        values3.forEach(([fiberId2, value]) => {
          unsafeUpdateAs(locals, fiberId2, fiberRef, value);
        });
      }
    });
    return new FiberRefsImpl(locals);
  });

  // node_modules/effect/dist/esm/FiberRefs.js
  var get10 = get9;
  var getOrDefault2 = getOrDefault;
  var joinAs2 = joinAs;
  var setAll2 = setAll;
  var updateManyAs2 = updateManyAs;
  var empty22 = empty21;

  // node_modules/effect/dist/esm/LogLevel.js
  var All = logLevelAll;
  var Fatal = logLevelFatal;
  var Error2 = logLevelError;
  var Warning = logLevelWarning;
  var Info = logLevelInfo;
  var Debug = logLevelDebug;
  var Trace = logLevelTrace;
  var None3 = logLevelNone;
  var Order2 = /* @__PURE__ */ pipe(Order, /* @__PURE__ */ mapInput2((level) => level.ordinal));
  var greaterThan3 = /* @__PURE__ */ greaterThan(Order2);
  var fromLiteral = (literal) => {
    switch (literal) {
      case "All":
        return All;
      case "Debug":
        return Debug;
      case "Error":
        return Error2;
      case "Fatal":
        return Fatal;
      case "Info":
        return Info;
      case "Trace":
        return Trace;
      case "None":
        return None3;
      case "Warning":
        return Warning;
    }
  };

  // node_modules/effect/dist/esm/internal/logSpan.js
  var make26 = (label, startTime) => ({
    label,
    startTime
  });
  var formatLabel = (key) => key.replace(/[\s="]/g, "_");
  var render = (now) => (self2) => {
    const label = formatLabel(self2.label);
    return `${label}=${now - self2.startTime}ms`;
  };

  // node_modules/effect/dist/esm/LogSpan.js
  var make27 = make26;

  // node_modules/effect/dist/esm/Ref.js
  var exports_Ref = {};
  __export(exports_Ref, {
    updateSomeAndGet: () => updateSomeAndGet2,
    updateSome: () => updateSome2,
    updateAndGet: () => updateAndGet2,
    update: () => update3,
    unsafeMake: () => unsafeMake7,
    setAndGet: () => setAndGet2,
    set: () => set6,
    modifySome: () => modifySome2,
    modify: () => modify4,
    make: () => make29,
    getAndUpdateSome: () => getAndUpdateSome2,
    getAndUpdate: () => getAndUpdate2,
    getAndSet: () => getAndSet2,
    get: () => get12,
    RefTypeId: () => RefTypeId2
  });

  // node_modules/effect/dist/esm/Effectable.js
  var EffectPrototype2 = EffectPrototype;
  var CommitPrototype2 = CommitPrototype;
  var Base2 = Base;
  class Class extends Base2 {
  }

  // node_modules/effect/dist/esm/Readable.js
  var TypeId12 = /* @__PURE__ */ Symbol.for("effect/Readable");
  var Proto = {
    [TypeId12]: TypeId12,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };

  // node_modules/effect/dist/esm/internal/ref.js
  var RefTypeId = /* @__PURE__ */ Symbol.for("effect/Ref");
  var refVariance = {
    _A: (_) => _
  };

  class RefImpl extends Class {
    ref;
    commit() {
      return this.get;
    }
    [RefTypeId] = refVariance;
    [TypeId12] = TypeId12;
    constructor(ref) {
      super();
      this.ref = ref;
      this.get = sync(() => get6(this.ref));
    }
    get;
    modify(f) {
      return sync(() => {
        const current = get6(this.ref);
        const [b, a] = f(current);
        if (current !== a) {
          set2(a)(this.ref);
        }
        return b;
      });
    }
  }
  var unsafeMake6 = (value) => new RefImpl(make11(value));
  var make28 = (value) => sync(() => unsafeMake6(value));
  var get11 = (self2) => self2.get;
  var set5 = /* @__PURE__ */ dual(2, (self2, value) => self2.modify(() => [undefined, value]));
  var getAndSet = /* @__PURE__ */ dual(2, (self2, value) => self2.modify((a) => [a, value]));
  var getAndUpdate = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [a, f(a)]));
  var getAndUpdateSome = /* @__PURE__ */ dual(2, (self2, pf) => self2.modify((value) => {
    const option = pf(value);
    switch (option._tag) {
      case "None": {
        return [value, value];
      }
      case "Some": {
        return [value, option.value];
      }
    }
  }));
  var setAndGet = /* @__PURE__ */ dual(2, (self2, value) => self2.modify(() => [value, value]));
  var modify3 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify(f));
  var modifySome = /* @__PURE__ */ dual(3, (self2, fallback, pf) => self2.modify((value) => {
    const option = pf(value);
    switch (option._tag) {
      case "None": {
        return [fallback, value];
      }
      case "Some": {
        return option.value;
      }
    }
  }));
  var update2 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [undefined, f(a)]));
  var updateAndGet = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => {
    const result = f(a);
    return [result, result];
  }));
  var updateSome = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [undefined, match2(f(a), {
    onNone: () => a,
    onSome: (b) => b
  })]));
  var updateSomeAndGet = /* @__PURE__ */ dual(2, (self2, pf) => self2.modify((value) => {
    const option = pf(value);
    switch (option._tag) {
      case "None": {
        return [value, value];
      }
      case "Some": {
        return [option.value, option.value];
      }
    }
  }));

  // node_modules/effect/dist/esm/Ref.js
  var RefTypeId2 = RefTypeId;
  var make29 = make28;
  var get12 = get11;
  var getAndSet2 = getAndSet;
  var getAndUpdate2 = getAndUpdate;
  var getAndUpdateSome2 = getAndUpdateSome;
  var modify4 = modify3;
  var modifySome2 = modifySome;
  var set6 = set5;
  var setAndGet2 = setAndGet;
  var update3 = update2;
  var updateAndGet2 = updateAndGet;
  var updateSome2 = updateSome;
  var updateSomeAndGet2 = updateSomeAndGet;
  var unsafeMake7 = unsafeMake6;

  // node_modules/effect/dist/esm/Tracer.js
  var ParentSpan = spanTag;
  var tracerWith2 = tracerWith;

  // node_modules/effect/dist/esm/internal/fiberRefs/patch.js
  var OP_EMPTY2 = "Empty";
  var OP_ADD = "Add";
  var OP_REMOVE = "Remove";
  var OP_UPDATE = "Update";
  var OP_AND_THEN = "AndThen";
  var empty23 = {
    _tag: OP_EMPTY2
  };
  var diff5 = (oldValue, newValue) => {
    const missingLocals = new Map(oldValue.locals);
    let patch6 = empty23;
    for (const [fiberRef, pairs] of newValue.locals.entries()) {
      const newValue2 = headNonEmpty(pairs)[1];
      const old = missingLocals.get(fiberRef);
      if (old !== undefined) {
        const oldValue2 = headNonEmpty(old)[1];
        if (!equals(oldValue2, newValue2)) {
          patch6 = combine7({
            _tag: OP_UPDATE,
            fiberRef,
            patch: fiberRef.diff(oldValue2, newValue2)
          })(patch6);
        }
      } else {
        patch6 = combine7({
          _tag: OP_ADD,
          fiberRef,
          value: newValue2
        })(patch6);
      }
      missingLocals.delete(fiberRef);
    }
    for (const [fiberRef] of missingLocals.entries()) {
      patch6 = combine7({
        _tag: OP_REMOVE,
        fiberRef
      })(patch6);
    }
    return patch6;
  };
  var combine7 = /* @__PURE__ */ dual(2, (self2, that) => ({
    _tag: OP_AND_THEN,
    first: self2,
    second: that
  }));
  var patch6 = /* @__PURE__ */ dual(3, (self2, fiberId2, oldValue) => {
    let fiberRefs2 = oldValue;
    let patches = of(self2);
    while (isNonEmptyReadonlyArray(patches)) {
      const head3 = headNonEmpty(patches);
      const tail = tailNonEmpty(patches);
      switch (head3._tag) {
        case OP_EMPTY2: {
          patches = tail;
          break;
        }
        case OP_ADD: {
          fiberRefs2 = updateAs(fiberRefs2, {
            fiberId: fiberId2,
            fiberRef: head3.fiberRef,
            value: head3.value
          });
          patches = tail;
          break;
        }
        case OP_REMOVE: {
          fiberRefs2 = delete_(fiberRefs2, head3.fiberRef);
          patches = tail;
          break;
        }
        case OP_UPDATE: {
          const value = getOrDefault(fiberRefs2, head3.fiberRef);
          fiberRefs2 = updateAs(fiberRefs2, {
            fiberId: fiberId2,
            fiberRef: head3.fiberRef,
            value: head3.fiberRef.patch(head3.patch)(value)
          });
          patches = tail;
          break;
        }
        case OP_AND_THEN: {
          patches = prepend(head3.first)(prepend(head3.second)(tail));
          break;
        }
      }
    }
    return fiberRefs2;
  });

  // node_modules/effect/dist/esm/internal/metric/label.js
  var MetricLabelSymbolKey = "effect/MetricLabel";
  var MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);

  class MetricLabelImpl {
    key;
    value;
    [MetricLabelTypeId] = MetricLabelTypeId;
    _hash;
    constructor(key, value) {
      this.key = key;
      this.value = value;
      this._hash = string(MetricLabelSymbolKey + this.key + this.value);
    }
    [symbol]() {
      return this._hash;
    }
    [symbol2](that) {
      return isMetricLabel(that) && this.key === that.key && this.value === that.value;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var make30 = (key, value) => {
    return new MetricLabelImpl(key, value);
  };
  var isMetricLabel = (u) => hasProperty(u, MetricLabelTypeId);

  // node_modules/effect/dist/esm/internal/core-effect.js
  var annotateLogs = /* @__PURE__ */ dual((args) => isEffect(args[0]), function() {
    const args = arguments;
    return fiberRefLocallyWith(args[0], currentLogAnnotations, typeof args[1] === "string" ? set3(args[1], args[2]) : (annotations2) => Object.entries(args[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
  });
  var asSome = (self2) => map10(self2, some2);
  var asSomeError = (self2) => mapError(self2, some2);
  var try_ = (arg) => {
    let evaluate;
    let onFailure = undefined;
    if (typeof arg === "function") {
      evaluate = arg;
    } else {
      evaluate = arg.try;
      onFailure = arg.catch;
    }
    return suspend(() => {
      try {
        return succeed(internalCall(evaluate));
      } catch (error) {
        return fail2(onFailure ? internalCall(() => onFailure(error)) : new UnknownException(error, "An unknown error occurred in Effect.try"));
      }
    });
  };
  var _catch = /* @__PURE__ */ dual(3, (self2, tag, options) => catchAll(self2, (e) => {
    if (hasProperty(e, tag) && e[tag] === options.failure) {
      return options.onFailure(e);
    }
    return fail2(e);
  }));
  var catchAllDefect = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause(self2, (cause) => {
    const option = find(cause, (_) => isDieType(_) ? some2(_) : none2());
    switch (option._tag) {
      case "None": {
        return failCause(cause);
      }
      case "Some": {
        return f(option.value.defect);
      }
    }
  }));
  var catchSomeCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
    onFailure: (cause) => {
      const option = f(cause);
      switch (option._tag) {
        case "None": {
          return failCause(cause);
        }
        case "Some": {
          return option.value;
        }
      }
    },
    onSuccess: succeed
  }));
  var catchSomeDefect = /* @__PURE__ */ dual(2, (self2, pf) => catchAllCause(self2, (cause) => {
    const option = find(cause, (_) => isDieType(_) ? some2(_) : none2());
    switch (option._tag) {
      case "None": {
        return failCause(cause);
      }
      case "Some": {
        const optionEffect = pf(option.value.defect);
        return optionEffect._tag === "Some" ? optionEffect.value : failCause(cause);
      }
    }
  }));
  var catchTag = /* @__PURE__ */ dual((args) => isEffect(args[0]), (self2, ...args) => {
    const f = args[args.length - 1];
    let predicate;
    if (args.length === 2) {
      predicate = isTagged(args[0]);
    } else {
      predicate = (e) => {
        const tag = hasProperty(e, "_tag") ? e["_tag"] : undefined;
        if (!tag)
          return false;
        for (let i = 0;i < args.length - 1; i++) {
          if (args[i] === tag)
            return true;
        }
        return false;
      };
    }
    return catchIf(self2, predicate, f);
  });
  var catchTags = /* @__PURE__ */ dual(2, (self2, cases) => {
    let keys3;
    return catchIf(self2, (e) => {
      keys3 ??= Object.keys(cases);
      return hasProperty(e, "_tag") && isString(e["_tag"]) && keys3.includes(e["_tag"]);
    }, (e) => cases[e["_tag"]](e));
  });
  var cause = (self2) => matchCause(self2, {
    onFailure: identity,
    onSuccess: () => empty17
  });
  var clockWith3 = clockWith2;
  var clock = /* @__PURE__ */ clockWith3(succeed);
  var delay = /* @__PURE__ */ dual(2, (self2, duration) => zipRight(sleep2(duration), self2));
  var descriptorWith = (f) => withFiberRuntime((state, status) => f({
    id: state.id(),
    status,
    interruptors: interruptors(state.getFiberRef(currentInterruptedCause))
  }));
  var allowInterrupt = /* @__PURE__ */ descriptorWith((descriptor) => size3(descriptor.interruptors) > 0 ? interrupt2 : void_);
  var descriptor = /* @__PURE__ */ descriptorWith(succeed);
  var diffFiberRefs = (self2) => summarized(self2, fiberRefs2, diff5);
  var diffFiberRefsAndRuntimeFlags = (self2) => summarized(self2, zip2(fiberRefs2, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff5(refs, refsNew), diff4(flags, flagsNew)]);
  var Do = /* @__PURE__ */ succeed({});
  var bind2 = /* @__PURE__ */ bind(map10, flatMap8);
  var bindTo2 = /* @__PURE__ */ bindTo(map10);
  var let_2 = /* @__PURE__ */ let_(map10);
  var dropUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
    const iterator = elements[Symbol.iterator]();
    const builder = [];
    let next;
    let dropping = succeed(false);
    let i = 0;
    while ((next = iterator.next()) && !next.done) {
      const a = next.value;
      const index = i++;
      dropping = flatMap8(dropping, (bool) => {
        if (bool) {
          builder.push(a);
          return succeed(true);
        }
        return predicate(a, index);
      });
    }
    return map10(dropping, () => builder);
  }));
  var dropWhile2 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
    const iterator = elements[Symbol.iterator]();
    const builder = [];
    let next;
    let dropping = succeed(true);
    let i = 0;
    while ((next = iterator.next()) && !next.done) {
      const a = next.value;
      const index = i++;
      dropping = flatMap8(dropping, (d) => map10(d ? predicate(a, index) : succeed(false), (b) => {
        if (!b) {
          builder.push(a);
        }
        return b;
      }));
    }
    return map10(dropping, () => builder);
  }));
  var contextWith = (f) => map10(context(), f);
  var eventually = (self2) => orElse2(self2, () => flatMap8(yieldNow(), () => eventually(self2)));
  var filterMap5 = /* @__PURE__ */ dual(2, (elements, pf) => map10(forEachSequential(elements, identity), filterMap2(pf)));
  var filterOrDie = /* @__PURE__ */ dual(3, (self2, predicate, orDieWith2) => filterOrElse(self2, predicate, (a) => dieSync(() => orDieWith2(a))));
  var filterOrDieMessage = /* @__PURE__ */ dual(3, (self2, predicate, message) => filterOrElse(self2, predicate, () => dieMessage(message)));
  var filterOrElse = /* @__PURE__ */ dual(3, (self2, predicate, orElse3) => flatMap8(self2, (a) => predicate(a) ? succeed(a) : orElse3(a)));
  var liftPredicate = /* @__PURE__ */ dual(3, (self2, predicate, orFailWith) => suspend(() => predicate(self2) ? succeed(self2) : fail2(orFailWith(self2))));
  var filterOrFail = /* @__PURE__ */ dual((args) => isEffect(args[0]), (self2, predicate, orFailWith) => filterOrElse(self2, predicate, (a) => orFailWith === undefined ? fail2(new NoSuchElementException) : failSync(() => orFailWith(a))));
  var findFirst5 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
    const iterator = elements[Symbol.iterator]();
    const next = iterator.next();
    if (!next.done) {
      return findLoop(iterator, 0, predicate, next.value);
    }
    return succeed(none2());
  }));
  var findLoop = (iterator, index, f, value) => flatMap8(f(value, index), (result) => {
    if (result) {
      return succeed(some2(value));
    }
    const next = iterator.next();
    if (!next.done) {
      return findLoop(iterator, index + 1, f, next.value);
    }
    return succeed(none2());
  });
  var firstSuccessOf = (effects) => suspend(() => {
    const list = fromIterable2(effects);
    if (!isNonEmpty2(list)) {
      return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
    }
    return pipe(tailNonEmpty2(list), reduce(headNonEmpty2(list), (left3, right3) => orElse2(left3, () => right3)));
  });
  var flipWith = /* @__PURE__ */ dual(2, (self2, f) => flip(f(flip(self2))));
  var match7 = /* @__PURE__ */ dual(2, (self2, options) => matchEffect(self2, {
    onFailure: (e) => succeed(options.onFailure(e)),
    onSuccess: (a) => succeed(options.onSuccess(a))
  }));
  var every5 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));
  var forAllLoop = (iterator, index, f) => {
    const next = iterator.next();
    return next.done ? succeed(true) : flatMap8(f(next.value, index), (b) => b ? forAllLoop(iterator, index + 1, f) : succeed(b));
  };
  var forever = (self2) => {
    const loop = flatMap8(flatMap8(self2, () => yieldNow()), () => loop);
    return loop;
  };
  var fiberRefs2 = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.getFiberRefs()));
  var head3 = (self2) => flatMap8(self2, (as2) => {
    const iterator = as2[Symbol.iterator]();
    const next = iterator.next();
    if (next.done) {
      return fail2(new NoSuchElementException);
    }
    return succeed(next.value);
  });
  var ignore = (self2) => match7(self2, {
    onFailure: constVoid,
    onSuccess: constVoid
  });
  var ignoreLogged = (self2) => matchCauseEffect(self2, {
    onFailure: (cause2) => logDebug(cause2, "An error was silently ignored because it is not anticipated to be useful"),
    onSuccess: () => void_
  });
  var inheritFiberRefs = (childFiberRefs) => updateFiberRefs((parentFiberId, parentFiberRefs) => joinAs2(parentFiberRefs, parentFiberId, childFiberRefs));
  var isFailure2 = (self2) => match7(self2, {
    onFailure: constTrue,
    onSuccess: constFalse
  });
  var isSuccess2 = (self2) => match7(self2, {
    onFailure: constFalse,
    onSuccess: constTrue
  });
  var iterate = (initial, options) => suspend(() => {
    if (options.while(initial)) {
      return flatMap8(options.body(initial), (z2) => iterate(z2, options));
    }
    return succeed(initial);
  });
  var logWithLevel = (level) => (...message) => {
    const levelOption = fromNullable(level);
    let cause2 = undefined;
    for (let i = 0, len = message.length;i < len; i++) {
      const msg = message[i];
      if (isCause(msg)) {
        if (cause2 !== undefined) {
          cause2 = sequential(cause2, msg);
        } else {
          cause2 = msg;
        }
        message = [...message.slice(0, i), ...message.slice(i + 1)];
        i--;
      }
    }
    if (cause2 === undefined) {
      cause2 = empty17;
    }
    return withFiberRuntime((fiberState) => {
      fiberState.log(message, cause2, levelOption);
      return void_;
    });
  };
  var log = /* @__PURE__ */ logWithLevel();
  var logTrace = /* @__PURE__ */ logWithLevel(Trace);
  var logDebug = /* @__PURE__ */ logWithLevel(Debug);
  var logInfo = /* @__PURE__ */ logWithLevel(Info);
  var logWarning = /* @__PURE__ */ logWithLevel(Warning);
  var logError = /* @__PURE__ */ logWithLevel(Error2);
  var logFatal = /* @__PURE__ */ logWithLevel(Fatal);
  var withLogSpan = /* @__PURE__ */ dual(2, (effect, label) => flatMap8(currentTimeMillis2, (now) => fiberRefLocallyWith(effect, currentLogSpan, prepend3(make27(label, now)))));
  var logAnnotations = /* @__PURE__ */ fiberRefGet(currentLogAnnotations);
  var loop = (initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : map10(loopInternal(initial, options.while, options.step, options.body), fromIterable);
  var loopInternal = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap8(body(initial), (a) => map10(loopInternal(inc(initial), cont, inc, body), prepend3(a))) : sync(() => empty10()));
  var loopDiscard = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap8(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : void_);
  var mapAccum3 = /* @__PURE__ */ dual(3, (elements, initial, f) => suspend(() => {
    const iterator = elements[Symbol.iterator]();
    const builder = [];
    let result = succeed(initial);
    let next;
    let i = 0;
    while (!(next = iterator.next()).done) {
      const index = i++;
      const value = next.value;
      result = flatMap8(result, (state) => map10(f(state, value, index), ([z, b]) => {
        builder.push(b);
        return z;
      }));
    }
    return map10(result, (z) => [z, builder]);
  }));
  var mapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
    onFailure: (c) => failCauseSync(() => f(c)),
    onSuccess: succeed
  }));
  var memoize = (self2) => pipe(deferredMake(), flatMap8((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self2), intoDeferred(deferred), once, map10((complete2) => zipRight(complete2, pipe(deferredAwait(deferred), flatMap8(([patch7, a]) => as(zip2(patchFiberRefs(patch7[0]), updateRuntimeFlags(patch7[1])), a))))))));
  var merge5 = (self2) => matchEffect(self2, {
    onFailure: (e) => succeed(e),
    onSuccess: succeed
  });
  var negate = (self2) => map10(self2, (b) => !b);
  var none6 = (self2) => flatMap8(self2, (option) => {
    switch (option._tag) {
      case "None":
        return void_;
      case "Some":
        return fail2(new NoSuchElementException);
    }
  });
  var once = (self2) => map10(make29(true), (ref) => asVoid(whenEffect(self2, getAndSet2(ref, false))));
  var option = (self2) => matchEffect(self2, {
    onFailure: () => succeed(none2()),
    onSuccess: (a) => succeed(some2(a))
  });
  var orElseFail = /* @__PURE__ */ dual(2, (self2, evaluate) => orElse2(self2, () => failSync(evaluate)));
  var orElseSucceed = /* @__PURE__ */ dual(2, (self2, evaluate) => orElse2(self2, () => sync(evaluate)));
  var parallelErrors = (self2) => matchCauseEffect(self2, {
    onFailure: (cause2) => {
      const errors = fromIterable(failures(cause2));
      return errors.length === 0 ? failCause(cause2) : fail2(errors);
    },
    onSuccess: succeed
  });
  var patchFiberRefs = (patch7) => updateFiberRefs((fiberId2, fiberRefs3) => pipe(patch7, patch6(fiberId2, fiberRefs3)));
  var promise = (evaluate) => evaluate.length >= 1 ? async_((resolve, signal) => {
    try {
      evaluate(signal).then((a) => resolve(succeed(a)), (e) => resolve(die2(e)));
    } catch (e) {
      resolve(die2(e));
    }
  }) : async_((resolve) => {
    try {
      evaluate().then((a) => resolve(succeed(a)), (e) => resolve(die2(e)));
    } catch (e) {
      resolve(die2(e));
    }
  });
  var provideService = /* @__PURE__ */ dual(3, (self2, tag, service) => contextWithEffect((env) => provideContext(self2, add2(env, tag, service))));
  var provideServiceEffect = /* @__PURE__ */ dual(3, (self2, tag, effect) => contextWithEffect((env) => flatMap8(effect, (service) => provideContext(self2, pipe(env, add2(tag, service))))));
  var random2 = /* @__PURE__ */ randomWith(succeed);
  var reduce9 = /* @__PURE__ */ dual(3, (elements, zero2, f) => fromIterable(elements).reduce((acc, el, i) => flatMap8(acc, (a) => f(a, el, i)), succeed(zero2)));
  var reduceRight3 = /* @__PURE__ */ dual(3, (elements, zero2, f) => fromIterable(elements).reduceRight((acc, el, i) => flatMap8(acc, (a) => f(el, a, i)), succeed(zero2)));
  var reduceWhile = /* @__PURE__ */ dual(3, (elements, zero2, options) => flatMap8(sync(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop(iterator, 0, zero2, options.while, options.body)));
  var reduceWhileLoop = (iterator, index, state, predicate, f) => {
    const next = iterator.next();
    if (!next.done && predicate(state)) {
      return flatMap8(f(state, next.value, index), (nextState) => reduceWhileLoop(iterator, index + 1, nextState, predicate, f));
    }
    return succeed(state);
  };
  var repeatN = /* @__PURE__ */ dual(2, (self2, n) => suspend(() => repeatNLoop(self2, n)));
  var repeatNLoop = (self2, n) => flatMap8(self2, (a) => n <= 0 ? succeed(a) : zipRight(yieldNow(), repeatNLoop(self2, n - 1)));
  var sandbox = (self2) => matchCauseEffect(self2, {
    onFailure: fail2,
    onSuccess: succeed
  });
  var setFiberRefs = (fiberRefs3) => suspend(() => setAll2(fiberRefs3));
  var sleep3 = sleep2;
  var succeedNone = /* @__PURE__ */ succeed(/* @__PURE__ */ none2());
  var succeedSome = (value) => succeed(some2(value));
  var summarized = /* @__PURE__ */ dual(3, (self2, summary, f) => flatMap8(summary, (start) => flatMap8(self2, (value) => map10(summary, (end) => [f(start, end), value]))));
  var tagMetrics = /* @__PURE__ */ dual((args) => isEffect(args[0]), function() {
    return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [make30(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => make30(k, v)));
  });
  var labelMetrics = /* @__PURE__ */ dual(2, (self2, labels) => fiberRefLocallyWith(self2, currentMetricLabels, (old) => union(old, labels)));
  var takeUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
    const iterator = elements[Symbol.iterator]();
    const builder = [];
    let next;
    let effect = succeed(false);
    let i = 0;
    while ((next = iterator.next()) && !next.done) {
      const a = next.value;
      const index = i++;
      effect = flatMap8(effect, (bool) => {
        if (bool) {
          return succeed(true);
        }
        builder.push(a);
        return predicate(a, index);
      });
    }
    return map10(effect, () => builder);
  }));
  var takeWhile2 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
    const iterator = elements[Symbol.iterator]();
    const builder = [];
    let next;
    let taking = succeed(true);
    let i = 0;
    while ((next = iterator.next()) && !next.done) {
      const a = next.value;
      const index = i++;
      taking = flatMap8(taking, (taking2) => pipe(taking2 ? predicate(a, index) : succeed(false), map10((bool) => {
        if (bool) {
          builder.push(a);
        }
        return bool;
      })));
    }
    return map10(taking, () => builder);
  }));
  var tapBoth = /* @__PURE__ */ dual(2, (self2, {
    onFailure,
    onSuccess
  }) => matchCauseEffect(self2, {
    onFailure: (cause2) => {
      const either3 = failureOrCause(cause2);
      switch (either3._tag) {
        case "Left": {
          return zipRight(onFailure(either3.left), failCause(cause2));
        }
        case "Right": {
          return failCause(cause2);
        }
      }
    },
    onSuccess: (a) => as(onSuccess(a), a)
  }));
  var tapDefect = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause(self2, (cause2) => match2(keepDefects(cause2), {
    onNone: () => failCause(cause2),
    onSome: (a) => zipRight(f(a), failCause(cause2))
  })));
  var tapError = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
    onFailure: (cause2) => {
      const either3 = failureOrCause(cause2);
      switch (either3._tag) {
        case "Left":
          return zipRight(f(either3.left), failCause(cause2));
        case "Right":
          return failCause(cause2);
      }
    },
    onSuccess: succeed
  }));
  var tapErrorTag = /* @__PURE__ */ dual(3, (self2, k, f) => tapError(self2, (e) => {
    if (isTagged(e, k)) {
      return f(e);
    }
    return void_;
  }));
  var tapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
    onFailure: (cause2) => zipRight(f(cause2), failCause(cause2)),
    onSuccess: succeed
  }));
  var timed = (self2) => timedWith(self2, currentTimeNanos2);
  var timedWith = /* @__PURE__ */ dual(2, (self2, nanos2) => summarized(self2, nanos2, (start, end) => nanos(end - start)));
  var tracerWith3 = tracerWith2;
  var tracer = /* @__PURE__ */ tracerWith3(succeed);
  var tryPromise = (arg) => {
    let evaluate;
    let catcher = undefined;
    if (typeof arg === "function") {
      evaluate = arg;
    } else {
      evaluate = arg.try;
      catcher = arg.catch;
    }
    const fail5 = (e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
    if (evaluate.length >= 1) {
      return async_((resolve, signal) => {
        try {
          evaluate(signal).then((a) => resolve(succeed(a)), (e) => resolve(fail5(e)));
        } catch (e) {
          resolve(fail5(e));
        }
      });
    }
    return async_((resolve) => {
      try {
        evaluate().then((a) => resolve(succeed(a)), (e) => resolve(fail5(e)));
      } catch (e) {
        resolve(fail5(e));
      }
    });
  };
  var tryMap = /* @__PURE__ */ dual(2, (self2, options) => flatMap8(self2, (a) => try_({
    try: () => options.try(a),
    catch: options.catch
  })));
  var tryMapPromise = /* @__PURE__ */ dual(2, (self2, options) => flatMap8(self2, (a) => tryPromise({
    try: options.try.length >= 1 ? (signal) => options.try(a, signal) : () => options.try(a),
    catch: options.catch
  })));
  var unless = /* @__PURE__ */ dual(2, (self2, condition) => suspend(() => condition() ? succeedNone : asSome(self2)));
  var unlessEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap8(condition, (b) => b ? succeedNone : asSome(self2)));
  var unsandbox = (self2) => mapErrorCause(self2, flatten5);
  var updateFiberRefs = (f) => withFiberRuntime((state) => {
    state.setFiberRefs(f(state.id(), state.getFiberRefs()));
    return void_;
  });
  var updateService = /* @__PURE__ */ dual(3, (self2, tag, f) => mapInputContext(self2, (context2) => add2(context2, tag, f(unsafeGet3(context2, tag)))));
  var when = /* @__PURE__ */ dual(2, (self2, condition) => suspend(() => condition() ? map10(self2, some2) : succeed(none2())));
  var whenFiberRef = /* @__PURE__ */ dual(3, (self2, fiberRef, predicate) => flatMap8(fiberRefGet(fiberRef), (s) => predicate(s) ? map10(self2, (a) => [s, some2(a)]) : succeed([s, none2()])));
  var whenRef = /* @__PURE__ */ dual(3, (self2, ref, predicate) => flatMap8(get12(ref), (s) => predicate(s) ? map10(self2, (a) => [s, some2(a)]) : succeed([s, none2()])));
  var withMetric = /* @__PURE__ */ dual(2, (self2, metric) => metric(self2));
  var serviceFunctionEffect = (getService, f) => (...args) => flatMap8(getService, (a) => f(a)(...args));
  var serviceFunction = (getService, f) => (...args) => map10(getService, (a) => f(a)(...args));
  var serviceFunctions = (getService) => new Proxy({}, {
    get(_target, prop, _receiver) {
      return (...args) => flatMap8(getService, (s) => s[prop](...args));
    }
  });
  var serviceConstants = (getService) => new Proxy({}, {
    get(_target, prop, _receiver) {
      return flatMap8(getService, (s) => isEffect(s[prop]) ? s[prop] : succeed(s[prop]));
    }
  });
  var serviceMembers = (getService) => ({
    functions: serviceFunctions(getService),
    constants: serviceConstants(getService)
  });
  var serviceOption = (tag) => map10(context(), getOption2(tag));
  var serviceOptional = (tag) => flatMap8(context(), getOption2(tag));
  var annotateCurrentSpan = function() {
    const args = arguments;
    return ignore(flatMap8(currentSpan, (span2) => sync(() => {
      if (typeof args[0] === "string") {
        span2.attribute(args[0], args[1]);
      } else {
        for (const key in args[0]) {
          span2.attribute(key, args[0][key]);
        }
      }
    })));
  };
  var linkSpanCurrent = function() {
    const args = arguments;
    const links = Array.isArray(args[0]) ? args[0] : [{
      _tag: "SpanLink",
      span: args[0],
      attributes: args[1] ?? {}
    }];
    return ignore(flatMap8(currentSpan, (span2) => sync(() => span2.addLinks(links))));
  };
  var annotateSpans = /* @__PURE__ */ dual((args) => isEffect(args[0]), function() {
    const args = arguments;
    return fiberRefLocallyWith(args[0], currentTracerSpanAnnotations, typeof args[1] === "string" ? set3(args[1], args[2]) : (annotations2) => Object.entries(args[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
  });
  var currentParentSpan = /* @__PURE__ */ serviceOptional(spanTag);
  var currentSpan = /* @__PURE__ */ flatMap8(/* @__PURE__ */ context(), (context2) => {
    const span2 = context2.unsafeMap.get(spanTag.key);
    return span2 !== undefined && span2._tag === "Span" ? succeed(span2) : fail2(new NoSuchElementException);
  });
  var linkSpans = /* @__PURE__ */ dual((args) => isEffect(args[0]), (self2, span2, attributes) => fiberRefLocallyWith(self2, currentTracerSpanLinks, append2({
    _tag: "SpanLink",
    span: span2,
    attributes: attributes ?? {}
  })));
  var bigint02 = /* @__PURE__ */ BigInt(0);
  var filterDisablePropagation = /* @__PURE__ */ flatMap((span2) => get3(span2.context, DisablePropagation) ? span2._tag === "Span" ? filterDisablePropagation(span2.parent) : none2() : some2(span2));
  var unsafeMakeSpan = (fiber, name, options) => {
    const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options.context && get3(options.context, DisablePropagation);
    const context2 = fiber.getFiberRef(currentContext);
    const parent = options.parent ? some2(options.parent) : options.root ? none2() : filterDisablePropagation(getOption2(context2, spanTag));
    let span2;
    if (disablePropagation) {
      span2 = noopSpan({
        name,
        parent,
        context: add2(options.context ?? empty4(), DisablePropagation, true)
      });
    } else {
      const services = fiber.getFiberRef(currentServices);
      const tracer2 = get3(services, tracerTag);
      const clock2 = get3(services, Clock);
      const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
      const fiberRefs3 = fiber.getFiberRefs();
      const annotationsFromEnv = get10(fiberRefs3, currentTracerSpanAnnotations);
      const linksFromEnv = get10(fiberRefs3, currentTracerSpanLinks);
      const links = linksFromEnv._tag === "Some" ? options.links !== undefined ? [...toReadonlyArray(linksFromEnv.value), ...options.links ?? []] : toReadonlyArray(linksFromEnv.value) : options.links ?? empty2();
      span2 = tracer2.span(name, parent, options.context ?? empty4(), links, timingEnabled ? clock2.unsafeCurrentTimeNanos() : bigint02, options.kind ?? "internal", options);
      if (annotationsFromEnv._tag === "Some") {
        forEach4(annotationsFromEnv.value, (value, key) => span2.attribute(key, value));
      }
      if (options.attributes !== undefined) {
        Object.entries(options.attributes).forEach(([k, v]) => span2.attribute(k, v));
      }
    }
    if (typeof options.captureStackTrace === "function") {
      spanToTrace.set(span2, options.captureStackTrace);
    }
    return span2;
  };
  var makeSpan = (name, options) => {
    options = addSpanStackTrace(options);
    return withFiberRuntime((fiber) => succeed(unsafeMakeSpan(fiber, name, options)));
  };
  var spanAnnotations = /* @__PURE__ */ fiberRefGet(currentTracerSpanAnnotations);
  var spanLinks = /* @__PURE__ */ fiberRefGet(currentTracerSpanLinks);
  var endSpan = (span2, exit2, clock2, timingEnabled) => sync(() => {
    if (span2.status._tag === "Ended") {
      return;
    }
    if (exitIsFailure(exit2) && spanToTrace.has(span2)) {
      span2.attribute("code.stacktrace", spanToTrace.get(span2)());
    }
    span2.end(timingEnabled ? clock2.unsafeCurrentTimeNanos() : bigint02, exit2);
  });
  var useSpan = (name, ...args) => {
    const options = addSpanStackTrace(args.length === 1 ? undefined : args[0]);
    const evaluate = args[args.length - 1];
    return withFiberRuntime((fiber) => {
      const span2 = unsafeMakeSpan(fiber, name, options);
      const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
      const clock2 = get3(fiber.getFiberRef(currentServices), clockTag);
      return onExit(evaluate(span2), (exit2) => endSpan(span2, exit2, clock2, timingEnabled));
    });
  };
  var withParentSpan = /* @__PURE__ */ dual(2, (self2, span2) => provideService(self2, spanTag, span2));
  var withSpan = function() {
    const dataFirst = typeof arguments[0] !== "string";
    const name = dataFirst ? arguments[1] : arguments[0];
    const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
    if (dataFirst) {
      const self2 = arguments[0];
      return useSpan(name, options, (span2) => withParentSpan(self2, span2));
    }
    return (self2) => useSpan(name, options, (span2) => withParentSpan(self2, span2));
  };
  var functionWithSpan = (options) => function() {
    let captureStackTrace = options.captureStackTrace ?? false;
    if (options.captureStackTrace !== false) {
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const error = new Error;
      Error.stackTraceLimit = limit;
      let cache = false;
      captureStackTrace = () => {
        if (cache !== false) {
          return cache;
        }
        if (error.stack) {
          const stack = error.stack.trim().split(`
`);
          cache = stack.slice(2).join(`
`).trim();
          return cache;
        }
      };
    }
    return suspend(() => {
      const opts = typeof options.options === "function" ? options.options.apply(null, arguments) : options.options;
      return withSpan(suspend(() => internalCall(() => options.body.apply(this, arguments))), opts.name, {
        ...opts,
        captureStackTrace
      });
    });
  };
  var fromNullable2 = (value) => value == null ? fail2(new NoSuchElementException) : succeed(value);
  var optionFromOptional = (self2) => catchAll(map10(self2, some2), (error) => isNoSuchElementException(error) ? succeedNone : fail2(error));

  // node_modules/effect/dist/esm/internal/executionStrategy.js
  var OP_SEQUENTIAL2 = "Sequential";
  var OP_PARALLEL2 = "Parallel";
  var OP_PARALLEL_N = "ParallelN";
  var sequential2 = {
    _tag: OP_SEQUENTIAL2
  };
  var parallel2 = {
    _tag: OP_PARALLEL2
  };
  var parallelN = (parallelism) => ({
    _tag: OP_PARALLEL_N,
    parallelism
  });
  var isSequential = (self2) => self2._tag === OP_SEQUENTIAL2;
  var isParallel = (self2) => self2._tag === OP_PARALLEL2;

  // node_modules/effect/dist/esm/ExecutionStrategy.js
  var sequential3 = sequential2;
  var parallel3 = parallel2;
  var parallelN2 = parallelN;

  // node_modules/effect/dist/esm/FiberRefsPatch.js
  var diff6 = diff5;
  var patch7 = patch6;

  // node_modules/effect/dist/esm/internal/fiberStatus.js
  var FiberStatusSymbolKey = "effect/FiberStatus";
  var FiberStatusTypeId = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
  var OP_DONE = "Done";
  var OP_RUNNING = "Running";
  var OP_SUSPENDED = "Suspended";
  var DoneHash = /* @__PURE__ */ string(`${FiberStatusSymbolKey}-${OP_DONE}`);

  class Done {
    [FiberStatusTypeId] = FiberStatusTypeId;
    _tag = OP_DONE;
    [symbol]() {
      return DoneHash;
    }
    [symbol2](that) {
      return isFiberStatus(that) && that._tag === OP_DONE;
    }
  }

  class Running {
    runtimeFlags;
    [FiberStatusTypeId] = FiberStatusTypeId;
    _tag = OP_RUNNING;
    constructor(runtimeFlags2) {
      this.runtimeFlags = runtimeFlags2;
    }
    [symbol]() {
      return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), cached(this));
    }
    [symbol2](that) {
      return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
    }
  }

  class Suspended {
    runtimeFlags;
    blockingOn;
    [FiberStatusTypeId] = FiberStatusTypeId;
    _tag = OP_SUSPENDED;
    constructor(runtimeFlags2, blockingOn) {
      this.runtimeFlags = runtimeFlags2;
      this.blockingOn = blockingOn;
    }
    [symbol]() {
      return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), combine(hash(this.blockingOn)), cached(this));
    }
    [symbol2](that) {
      return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
    }
  }
  var done3 = /* @__PURE__ */ new Done;
  var running = (runtimeFlags2) => new Running(runtimeFlags2);
  var suspended = (runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn);
  var isFiberStatus = (u) => hasProperty(u, FiberStatusTypeId);
  var isDone2 = (self2) => self2._tag === OP_DONE;

  // node_modules/effect/dist/esm/FiberStatus.js
  var done4 = done3;
  var running2 = running;
  var suspended2 = suspended;
  var isDone3 = isDone2;

  // node_modules/effect/dist/esm/Micro.js
  var TypeId13 = /* @__PURE__ */ Symbol.for("effect/Micro");
  var MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
  var MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
  var microCauseVariance = {
    _E: identity
  };

  class MicroCauseImpl extends globalThis.Error {
    _tag;
    traces;
    [MicroCauseTypeId];
    constructor(_tag, originalError, traces) {
      const causeName = `MicroCause.${_tag}`;
      let name;
      let message;
      let stack;
      if (originalError instanceof globalThis.Error) {
        name = `(${causeName}) ${originalError.name}`;
        message = originalError.message;
        const messageLines = message.split(`
`).length;
        stack = originalError.stack ? `(${causeName}) ${originalError.stack.split(`
`).slice(0, messageLines + 3).join(`
`)}` : `${name}: ${message}`;
      } else {
        name = causeName;
        message = toStringUnknown(originalError, 0);
        stack = `${name}: ${message}`;
      }
      if (traces.length > 0) {
        stack += `
    ${traces.join(`
    `)}`;
      }
      super(message);
      this._tag = _tag;
      this.traces = traces;
      this[MicroCauseTypeId] = microCauseVariance;
      this.name = name;
      this.stack = stack;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    toString() {
      return this.stack;
    }
    [NodeInspectSymbol]() {
      return this.stack;
    }
  }
  class Die extends MicroCauseImpl {
    defect;
    constructor(defect, traces = []) {
      super("Die", defect, traces);
      this.defect = defect;
    }
  }
  var causeDie = (defect, traces = []) => new Die(defect, traces);

  class Interrupt extends MicroCauseImpl {
    constructor(traces = []) {
      super("Interrupt", "interrupted", traces);
    }
  }
  var causeInterrupt = (traces = []) => new Interrupt(traces);
  var causeIsInterrupt = (self2) => self2._tag === "Interrupt";
  var MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
  var fiberVariance = {
    _A: identity,
    _E: identity
  };

  class MicroFiberImpl {
    context;
    interruptible;
    [MicroFiberTypeId];
    _stack = [];
    _observers = [];
    _exit;
    _children;
    currentOpCount = 0;
    constructor(context2, interruptible3 = true) {
      this.context = context2;
      this.interruptible = interruptible3;
      this[MicroFiberTypeId] = fiberVariance;
    }
    getRef(ref) {
      return unsafeGetReference(this.context, ref);
    }
    addObserver(cb) {
      if (this._exit) {
        cb(this._exit);
        return constVoid;
      }
      this._observers.push(cb);
      return () => {
        const index = this._observers.indexOf(cb);
        if (index >= 0) {
          this._observers.splice(index, 1);
        }
      };
    }
    _interrupted = false;
    unsafeInterrupt() {
      if (this._exit) {
        return;
      }
      this._interrupted = true;
      if (this.interruptible) {
        this.evaluate(exitInterrupt2);
      }
    }
    unsafePoll() {
      return this._exit;
    }
    evaluate(effect) {
      if (this._exit) {
        return;
      } else if (this._yielded !== undefined) {
        const yielded = this._yielded;
        this._yielded = undefined;
        yielded();
      }
      const exit2 = this.runLoop(effect);
      if (exit2 === Yield) {
        return;
      }
      const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
      if (interruptChildren !== undefined) {
        return this.evaluate(flatMap9(interruptChildren, () => exit2));
      }
      this._exit = exit2;
      for (let i = 0;i < this._observers.length; i++) {
        this._observers[i](exit2);
      }
      this._observers.length = 0;
    }
    runLoop(effect) {
      let yielding = false;
      let current = effect;
      this.currentOpCount = 0;
      try {
        while (true) {
          this.currentOpCount++;
          if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
            yielding = true;
            const prev = current;
            current = flatMap9(yieldNow2, () => prev);
          }
          current = current[evaluate](this);
          if (current === Yield) {
            const yielded = this._yielded;
            if (MicroExitTypeId in yielded) {
              this._yielded = undefined;
              return yielded;
            }
            return Yield;
          }
        }
      } catch (error) {
        if (!hasProperty(current, evaluate)) {
          return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
        }
        return exitDie2(error);
      }
    }
    getCont(symbol3) {
      while (true) {
        const op = this._stack.pop();
        if (!op)
          return;
        const cont = op[ensureCont] && op[ensureCont](this);
        if (cont)
          return {
            [symbol3]: cont
          };
        if (op[symbol3])
          return op;
      }
    }
    _yielded = undefined;
    yieldWith(value) {
      this._yielded = value;
      return Yield;
    }
    children() {
      return this._children ??= new Set;
    }
  }
  var fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({
    interruptChildren: undefined
  }));
  var identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
  var args = /* @__PURE__ */ Symbol.for("effect/Micro/args");
  var evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
  var successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
  var failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
  var ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
  var Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
  var microVariance = {
    _A: identity,
    _E: identity,
    _R: identity
  };
  var MicroProto = {
    ...EffectPrototype2,
    _op: "Micro",
    [TypeId13]: microVariance,
    pipe() {
      return pipeArguments(this, arguments);
    },
    [Symbol.iterator]() {
      return new SingleShotGen(new YieldWrap(this));
    },
    toJSON() {
      return {
        _id: "Micro",
        op: this[identifier],
        ...args in this ? {
          args: this[args]
        } : undefined
      };
    },
    toString() {
      return format(this);
    },
    [NodeInspectSymbol]() {
      return format(this);
    }
  };
  function defaultEvaluate(_fiber) {
    return exitDie2(`Micro.evaluate: Not implemented`);
  }
  var makePrimitiveProto = (options) => ({
    ...MicroProto,
    [identifier]: options.op,
    [evaluate]: options.eval ?? defaultEvaluate,
    [successCont]: options.contA,
    [failureCont]: options.contE,
    [ensureCont]: options.ensure
  });
  var makePrimitive = (options) => {
    const Proto2 = makePrimitiveProto(options);
    return function() {
      const self2 = Object.create(Proto2);
      self2[args] = options.single === false ? arguments : arguments[0];
      return self2;
    };
  };
  var makeExit = (options) => {
    const Proto2 = {
      ...makePrimitiveProto(options),
      [MicroExitTypeId]: MicroExitTypeId,
      _tag: options.op,
      get [options.prop]() {
        return this[args];
      },
      toJSON() {
        return {
          _id: "MicroExit",
          _tag: options.op,
          [options.prop]: this[args]
        };
      },
      [symbol2](that) {
        return isMicroExit(that) && that._tag === options.op && equals(this[args], that[args]);
      },
      [symbol]() {
        return cached(this, combine(string(options.op))(hash(this[args])));
      }
    };
    return function(value) {
      const self2 = Object.create(Proto2);
      self2[args] = value;
      self2[successCont] = undefined;
      self2[failureCont] = undefined;
      self2[ensureCont] = undefined;
      return self2;
    };
  };
  var succeed4 = /* @__PURE__ */ makeExit({
    op: "Success",
    prop: "value",
    eval(fiber) {
      const cont = fiber.getCont(successCont);
      return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
    }
  });
  var failCause4 = /* @__PURE__ */ makeExit({
    op: "Failure",
    prop: "cause",
    eval(fiber) {
      let cont = fiber.getCont(failureCont);
      while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
        cont = fiber.getCont(failureCont);
      }
      return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
    }
  });
  var yieldNowWith = /* @__PURE__ */ makePrimitive({
    op: "Yield",
    eval(fiber) {
      let resumed = false;
      fiber.getRef(CurrentScheduler).scheduleTask(() => {
        if (resumed)
          return;
        fiber.evaluate(exitVoid2);
      }, this[args] ?? 0);
      return fiber.yieldWith(() => {
        resumed = true;
      });
    }
  });
  var yieldNow2 = /* @__PURE__ */ yieldNowWith(0);
  var void_3 = /* @__PURE__ */ succeed4(undefined);
  var withMicroFiber = /* @__PURE__ */ makePrimitive({
    op: "WithMicroFiber",
    eval(fiber) {
      return this[args](fiber);
    }
  });
  var flatMap9 = /* @__PURE__ */ dual(2, (self2, f) => {
    const onSuccess = Object.create(OnSuccessProto);
    onSuccess[args] = self2;
    onSuccess[successCont] = f;
    return onSuccess;
  });
  var OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
    op: "OnSuccess",
    eval(fiber) {
      fiber._stack.push(this);
      return this[args];
    }
  });
  var isMicroExit = (u) => hasProperty(u, MicroExitTypeId);
  var exitSucceed2 = succeed4;
  var exitFailCause2 = failCause4;
  var exitInterrupt2 = /* @__PURE__ */ exitFailCause2(/* @__PURE__ */ causeInterrupt());
  var exitDie2 = (defect) => exitFailCause2(causeDie(defect));
  var exitVoid2 = /* @__PURE__ */ exitSucceed2(undefined);
  var setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);

  class MicroSchedulerDefault {
    tasks = [];
    running = false;
    scheduleTask(task, _priority) {
      this.tasks.push(task);
      if (!this.running) {
        this.running = true;
        setImmediate(this.afterScheduled);
      }
    }
    afterScheduled = () => {
      this.running = false;
      this.runTasks();
    };
    runTasks() {
      const tasks = this.tasks;
      this.tasks = [];
      for (let i = 0, len = tasks.length;i < len; i++) {
        tasks[i]();
      }
    }
    shouldYield(fiber) {
      return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
    }
    flush() {
      while (this.tasks.length > 0) {
        this.runTasks();
      }
    }
  }
  var updateContext = /* @__PURE__ */ dual(2, (self2, f) => withMicroFiber((fiber) => {
    const prev = fiber.context;
    fiber.context = f(prev);
    return onExit2(self2, () => {
      fiber.context = prev;
      return void_3;
    });
  }));
  var provideContext2 = /* @__PURE__ */ dual(2, (self2, provided) => updateContext(self2, merge3(provided)));
  class MaxOpsBeforeYield extends (/* @__PURE__ */ Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
    defaultValue: () => 2048
  })) {
  }
  class CurrentScheduler extends (/* @__PURE__ */ Reference2()("effect/Micro/currentScheduler", {
    defaultValue: () => new MicroSchedulerDefault
  })) {
  }
  var matchCauseEffect2 = /* @__PURE__ */ dual(2, (self2, options) => {
    const primitive = Object.create(OnSuccessAndFailureProto);
    primitive[args] = self2;
    primitive[successCont] = options.onSuccess;
    primitive[failureCont] = options.onFailure;
    return primitive;
  });
  var OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
    op: "OnSuccessAndFailure",
    eval(fiber) {
      fiber._stack.push(this);
      return this[args];
    }
  });
  var onExit2 = /* @__PURE__ */ dual(2, (self2, f) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self2), {
    onFailure: (cause2) => flatMap9(f(exitFailCause2(cause2)), () => failCause4(cause2)),
    onSuccess: (a) => flatMap9(f(exitSucceed2(a)), () => succeed4(a))
  })));
  var setInterruptible = /* @__PURE__ */ makePrimitive({
    op: "SetInterruptible",
    ensure(fiber) {
      fiber.interruptible = this[args];
      if (fiber._interrupted && fiber.interruptible) {
        return () => exitInterrupt2;
      }
    }
  });
  var interruptible3 = (self2) => withMicroFiber((fiber) => {
    if (fiber.interruptible)
      return self2;
    fiber.interruptible = true;
    fiber._stack.push(setInterruptible(false));
    if (fiber._interrupted)
      return exitInterrupt2;
    return self2;
  });
  var uninterruptibleMask2 = (f) => withMicroFiber((fiber) => {
    if (!fiber.interruptible)
      return f(identity);
    fiber.interruptible = false;
    fiber._stack.push(setInterruptible(true));
    return f(interruptible3);
  });
  var runFork = (effect, options) => {
    const fiber = new MicroFiberImpl(CurrentScheduler.context(options?.scheduler ?? new MicroSchedulerDefault));
    fiber.evaluate(effect);
    if (options?.signal) {
      if (options.signal.aborted) {
        fiber.unsafeInterrupt();
      } else {
        const abort = () => fiber.unsafeInterrupt();
        options.signal.addEventListener("abort", abort, {
          once: true
        });
        fiber.addObserver(() => options.signal.removeEventListener("abort", abort));
      }
    }
    return fiber;
  };

  // node_modules/effect/dist/esm/Scheduler.js
  class PriorityBuckets {
    buckets = [];
    scheduleTask(task, priority) {
      const length3 = this.buckets.length;
      let bucket = undefined;
      let index = 0;
      for (;index < length3; index++) {
        if (this.buckets[index][0] <= priority) {
          bucket = this.buckets[index];
        } else {
          break;
        }
      }
      if (bucket && bucket[0] === priority) {
        bucket[1].push(task);
      } else if (index === length3) {
        this.buckets.push([priority, [task]]);
      } else {
        this.buckets.splice(index, 0, [priority, [task]]);
      }
    }
  }

  class MixedScheduler {
    maxNextTickBeforeTimer;
    running = false;
    tasks = /* @__PURE__ */ new PriorityBuckets;
    constructor(maxNextTickBeforeTimer) {
      this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
    }
    starveInternal(depth) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0;i < toRun.length; i++) {
          toRun[i]();
        }
      }
      if (this.tasks.buckets.length === 0) {
        this.running = false;
      } else {
        this.starve(depth);
      }
    }
    starve(depth = 0) {
      if (depth >= this.maxNextTickBeforeTimer) {
        setTimeout(() => this.starveInternal(0), 0);
      } else {
        Promise.resolve(undefined).then(() => this.starveInternal(depth + 1));
      }
    }
    shouldYield(fiber) {
      return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
    }
    scheduleTask(task, priority) {
      this.tasks.scheduleTask(task, priority);
      if (!this.running) {
        this.running = true;
        this.starve();
      }
    }
  }
  var defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));

  class SyncScheduler {
    tasks = /* @__PURE__ */ new PriorityBuckets;
    deferred = false;
    scheduleTask(task, priority) {
      if (this.deferred) {
        defaultScheduler.scheduleTask(task, priority);
      } else {
        this.tasks.scheduleTask(task, priority);
      }
    }
    shouldYield(fiber) {
      return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
    }
    flush() {
      while (this.tasks.buckets.length > 0) {
        const tasks = this.tasks.buckets;
        this.tasks.buckets = [];
        for (const [_, toRun] of tasks) {
          for (let i = 0;i < toRun.length; i++) {
            toRun[i]();
          }
        }
      }
      this.deferred = true;
    }
  }
  var currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
  var withScheduler = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentScheduler, scheduler));

  // node_modules/effect/dist/esm/internal/completedRequestMap.js
  var currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(new Map));

  // node_modules/effect/dist/esm/internal/concurrency.js
  var match9 = (concurrency, sequential4, unbounded2, bounded2) => {
    switch (concurrency) {
      case undefined:
        return sequential4();
      case "unbounded":
        return unbounded2();
      case "inherit":
        return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded2() : concurrency2 > 1 ? bounded2(concurrency2) : sequential4());
      default:
        return concurrency > 1 ? bounded2(concurrency) : sequential4();
    }
  };
  var matchSimple = (concurrency, sequential4, concurrent) => {
    switch (concurrency) {
      case undefined:
        return sequential4();
      case "unbounded":
        return concurrent();
      case "inherit":
        return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential4());
      default:
        return concurrency > 1 ? concurrent() : sequential4();
    }
  };

  // node_modules/effect/dist/esm/internal/fiberMessage.js
  var OP_INTERRUPT_SIGNAL = "InterruptSignal";
  var OP_STATEFUL = "Stateful";
  var OP_RESUME = "Resume";
  var OP_YIELD_NOW = "YieldNow";
  var interruptSignal = (cause2) => ({
    _tag: OP_INTERRUPT_SIGNAL,
    cause: cause2
  });
  var stateful = (onFiber) => ({
    _tag: OP_STATEFUL,
    onFiber
  });
  var resume = (effect) => ({
    _tag: OP_RESUME,
    effect
  });
  var yieldNow3 = () => ({
    _tag: OP_YIELD_NOW
  });

  // node_modules/effect/dist/esm/internal/fiberScope.js
  var FiberScopeSymbolKey = "effect/FiberScope";
  var FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);

  class Global {
    [FiberScopeTypeId] = FiberScopeTypeId;
    fiberId = none4;
    roots = /* @__PURE__ */ new Set;
    add(_runtimeFlags, child) {
      this.roots.add(child);
      child.addObserver(() => {
        this.roots.delete(child);
      });
    }
  }

  class Local {
    fiberId;
    parent;
    [FiberScopeTypeId] = FiberScopeTypeId;
    constructor(fiberId2, parent) {
      this.fiberId = fiberId2;
      this.parent = parent;
    }
    add(_runtimeFlags, child) {
      this.parent.tell(stateful((parentFiber) => {
        parentFiber.addChild(child);
        child.addObserver(() => {
          parentFiber.removeChild(child);
        });
      }));
    }
  }
  var unsafeMake8 = (fiber) => {
    return new Local(fiber.id(), fiber);
  };
  var globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global);

  // node_modules/effect/dist/esm/internal/fiber.js
  var FiberSymbolKey = "effect/Fiber";
  var FiberTypeId = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
  var fiberVariance2 = {
    _E: (_) => _,
    _A: (_) => _
  };
  var fiberProto = {
    [FiberTypeId]: fiberVariance2,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var RuntimeFiberSymbolKey = "effect/Fiber";
  var RuntimeFiberTypeId = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
  var isRuntimeFiber = (self2) => (RuntimeFiberTypeId in self2);
  var _await2 = (self2) => self2.await;
  var inheritAll = (self2) => self2.inheritAll;
  var interruptAllAs = /* @__PURE__ */ dual(2, /* @__PURE__ */ fnUntraced(function* (fibers, fiberId2) {
    for (const fiber of fibers) {
      if (isRuntimeFiber(fiber)) {
        fiber.unsafeInterruptAsFork(fiberId2);
        continue;
      }
      yield* fiber.interruptAsFork(fiberId2);
    }
    for (const fiber of fibers) {
      if (isRuntimeFiber(fiber) && fiber.unsafePoll()) {
        continue;
      }
      yield* fiber.await;
    }
  }));
  var interruptAsFork = /* @__PURE__ */ dual(2, (self2, fiberId2) => self2.interruptAsFork(fiberId2));
  var join2 = (self2) => zipLeft(flatten6(self2.await), self2.inheritAll);
  var _never = {
    ...CommitPrototype,
    commit() {
      return join2(this);
    },
    ...fiberProto,
    id: () => none4,
    await: never,
    children: /* @__PURE__ */ succeed([]),
    inheritAll: never,
    poll: /* @__PURE__ */ succeed(/* @__PURE__ */ none2()),
    interruptAsFork: () => never
  };
  var poll3 = (self2) => self2.poll;
  var currentFiberURI = "effect/FiberCurrent";

  // node_modules/effect/dist/esm/internal/logger.js
  var LoggerSymbolKey = "effect/Logger";
  var LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
  var loggerVariance = {
    _Message: (_) => _,
    _Output: (_) => _
  };
  var makeLogger = (log2) => ({
    [LoggerTypeId]: loggerVariance,
    log: log2,
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  var none7 = {
    [LoggerTypeId]: loggerVariance,
    log: constVoid,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var textOnly = /^[^\s"=]*$/;
  var format3 = (quoteValue, whitespace) => ({
    annotations: annotations2,
    cause: cause2,
    date,
    fiberId: fiberId2,
    logLevel,
    message,
    spans
  }) => {
    const formatValue = (value) => value.match(textOnly) ? value : quoteValue(value);
    const format4 = (label, value) => `${formatLabel(label)}=${formatValue(value)}`;
    const append4 = (label, value) => " " + format4(label, value);
    let out = format4("timestamp", date.toISOString());
    out += append4("level", logLevel.label);
    out += append4("fiber", threadName(fiberId2));
    const messages = ensure(message);
    for (let i = 0;i < messages.length; i++) {
      out += append4("message", toStringUnknown(messages[i], whitespace));
    }
    if (!isEmptyType(cause2)) {
      out += append4("cause", pretty(cause2, {
        renderErrorCause: true
      }));
    }
    for (const span2 of spans) {
      out += " " + render(date.getTime())(span2);
    }
    for (const [label, value] of annotations2) {
      out += append4(label, toStringUnknown(value, whitespace));
    }
    return out;
  };
  var escapeDoubleQuotes = (s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
  var stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format3(escapeDoubleQuotes));
  var colors = {
    bold: "1",
    red: "31",
    green: "32",
    yellow: "33",
    blue: "34",
    cyan: "36",
    white: "37",
    gray: "90",
    black: "30",
    bgBrightRed: "101"
  };
  var logLevelColors = {
    None: [],
    All: [],
    Trace: [colors.gray],
    Debug: [colors.blue],
    Info: [colors.green],
    Warning: [colors.yellow],
    Error: [colors.red],
    Fatal: [colors.bgBrightRed, colors.black]
  };
  var hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
  var processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
  var hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;

  // node_modules/effect/dist/esm/internal/metric/boundaries.js
  var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
  var MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);

  class MetricBoundariesImpl {
    values;
    [MetricBoundariesTypeId] = MetricBoundariesTypeId;
    constructor(values3) {
      this.values = values3;
      this._hash = pipe(string(MetricBoundariesSymbolKey), combine(array2(this.values)));
    }
    _hash;
    [symbol]() {
      return this._hash;
    }
    [symbol2](u) {
      return isMetricBoundaries(u) && equals(this.values, u.values);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var isMetricBoundaries = (u) => hasProperty(u, MetricBoundariesTypeId);
  var fromIterable7 = (iterable) => {
    const values3 = pipe(iterable, appendAll(of2(Number.POSITIVE_INFINITY)), dedupe);
    return new MetricBoundariesImpl(values3);
  };
  var exponential = (options) => pipe(makeBy(options.count - 1, (i) => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromIterable7);

  // node_modules/effect/dist/esm/internal/metric/keyType.js
  var MetricKeyTypeSymbolKey = "effect/MetricKeyType";
  var MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
  var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
  var CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
  var FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
  var FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
  var GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
  var GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
  var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
  var HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
  var SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
  var SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
  var metricKeyTypeVariance = {
    _In: (_) => _,
    _Out: (_) => _
  };

  class CounterKeyType {
    incremental;
    bigint;
    [MetricKeyTypeTypeId] = metricKeyTypeVariance;
    [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
    constructor(incremental, bigint) {
      this.incremental = incremental;
      this.bigint = bigint;
      this._hash = string(CounterKeyTypeSymbolKey);
    }
    _hash;
    [symbol]() {
      return this._hash;
    }
    [symbol2](that) {
      return isCounterKey(that);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  class HistogramKeyType {
    boundaries;
    [MetricKeyTypeTypeId] = metricKeyTypeVariance;
    [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
    constructor(boundaries) {
      this.boundaries = boundaries;
      this._hash = pipe(string(HistogramKeyTypeSymbolKey), combine(hash(this.boundaries)));
    }
    _hash;
    [symbol]() {
      return this._hash;
    }
    [symbol2](that) {
      return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var counter = (options) => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);
  var histogram = (boundaries) => {
    return new HistogramKeyType(boundaries);
  };
  var isCounterKey = (u) => hasProperty(u, CounterKeyTypeTypeId);
  var isFrequencyKey = (u) => hasProperty(u, FrequencyKeyTypeTypeId);
  var isGaugeKey = (u) => hasProperty(u, GaugeKeyTypeTypeId);
  var isHistogramKey = (u) => hasProperty(u, HistogramKeyTypeTypeId);
  var isSummaryKey = (u) => hasProperty(u, SummaryKeyTypeTypeId);

  // node_modules/effect/dist/esm/internal/metric/key.js
  var MetricKeySymbolKey = "effect/MetricKey";
  var MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
  var metricKeyVariance = {
    _Type: (_) => _
  };
  var arrayEquivilence = /* @__PURE__ */ getEquivalence(equals);

  class MetricKeyImpl {
    name;
    keyType;
    description;
    tags;
    [MetricKeyTypeId] = metricKeyVariance;
    constructor(name, keyType, description, tags = []) {
      this.name = name;
      this.keyType = keyType;
      this.description = description;
      this.tags = tags;
      this._hash = pipe(string(this.name + this.description), combine(hash(this.keyType)), combine(array2(this.tags)));
    }
    _hash;
    [symbol]() {
      return this._hash;
    }
    [symbol2](u) {
      return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var isMetricKey = (u) => hasProperty(u, MetricKeyTypeId);
  var counter2 = (name, options) => new MetricKeyImpl(name, counter(options), fromNullable(options?.description));
  var histogram2 = (name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable(description));
  var taggedWithLabels = /* @__PURE__ */ dual(2, (self2, extraTags) => extraTags.length === 0 ? self2 : new MetricKeyImpl(self2.name, self2.keyType, self2.description, union(self2.tags, extraTags)));

  // node_modules/effect/dist/esm/internal/metric/state.js
  var MetricStateSymbolKey = "effect/MetricState";
  var MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
  var CounterStateSymbolKey = "effect/MetricState/Counter";
  var CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
  var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
  var FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
  var GaugeStateSymbolKey = "effect/MetricState/Gauge";
  var GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
  var HistogramStateSymbolKey = "effect/MetricState/Histogram";
  var HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
  var SummaryStateSymbolKey = "effect/MetricState/Summary";
  var SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
  var metricStateVariance = {
    _A: (_) => _
  };

  class CounterState {
    count;
    [MetricStateTypeId] = metricStateVariance;
    [CounterStateTypeId] = CounterStateTypeId;
    constructor(count) {
      this.count = count;
    }
    [symbol]() {
      return pipe(hash(CounterStateSymbolKey), combine(hash(this.count)), cached(this));
    }
    [symbol2](that) {
      return isCounterState(that) && this.count === that.count;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var arrayEquals = /* @__PURE__ */ getEquivalence(equals);

  class FrequencyState {
    occurrences;
    [MetricStateTypeId] = metricStateVariance;
    [FrequencyStateTypeId] = FrequencyStateTypeId;
    constructor(occurrences) {
      this.occurrences = occurrences;
    }
    _hash;
    [symbol]() {
      return pipe(string(FrequencyStateSymbolKey), combine(array2(fromIterable(this.occurrences.entries()))), cached(this));
    }
    [symbol2](that) {
      return isFrequencyState(that) && arrayEquals(fromIterable(this.occurrences.entries()), fromIterable(that.occurrences.entries()));
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }

  class GaugeState {
    value;
    [MetricStateTypeId] = metricStateVariance;
    [GaugeStateTypeId] = GaugeStateTypeId;
    constructor(value) {
      this.value = value;
    }
    [symbol]() {
      return pipe(hash(GaugeStateSymbolKey), combine(hash(this.value)), cached(this));
    }
    [symbol2](u) {
      return isGaugeState(u) && this.value === u.value;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }

  class HistogramState {
    buckets;
    count;
    min;
    max;
    sum;
    [MetricStateTypeId] = metricStateVariance;
    [HistogramStateTypeId] = HistogramStateTypeId;
    constructor(buckets, count, min2, max2, sum2) {
      this.buckets = buckets;
      this.count = count;
      this.min = min2;
      this.max = max2;
      this.sum = sum2;
    }
    [symbol]() {
      return pipe(hash(HistogramStateSymbolKey), combine(hash(this.buckets)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
    }
    [symbol2](that) {
      return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }

  class SummaryState {
    error;
    quantiles;
    count;
    min;
    max;
    sum;
    [MetricStateTypeId] = metricStateVariance;
    [SummaryStateTypeId] = SummaryStateTypeId;
    constructor(error, quantiles, count, min2, max2, sum2) {
      this.error = error;
      this.quantiles = quantiles;
      this.count = count;
      this.min = min2;
      this.max = max2;
      this.sum = sum2;
    }
    [symbol]() {
      return pipe(hash(SummaryStateSymbolKey), combine(hash(this.error)), combine(hash(this.quantiles)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
    }
    [symbol2](that) {
      return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var counter3 = (count) => new CounterState(count);
  var frequency2 = (occurrences) => {
    return new FrequencyState(occurrences);
  };
  var gauge2 = (count) => new GaugeState(count);
  var histogram3 = (options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
  var summary2 = (options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
  var isCounterState = (u) => hasProperty(u, CounterStateTypeId);
  var isFrequencyState = (u) => hasProperty(u, FrequencyStateTypeId);
  var isGaugeState = (u) => hasProperty(u, GaugeStateTypeId);
  var isHistogramState = (u) => hasProperty(u, HistogramStateTypeId);
  var isSummaryState = (u) => hasProperty(u, SummaryStateTypeId);

  // node_modules/effect/dist/esm/internal/metric/hook.js
  var MetricHookSymbolKey = "effect/MetricHook";
  var MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
  var metricHookVariance = {
    _In: (_) => _,
    _Out: (_) => _
  };
  var make31 = (options) => ({
    [MetricHookTypeId]: metricHookVariance,
    pipe() {
      return pipeArguments(this, arguments);
    },
    ...options
  });
  var bigint03 = /* @__PURE__ */ BigInt(0);
  var counter4 = (key) => {
    let sum2 = key.keyType.bigint ? bigint03 : 0;
    const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value) => value >= bigint03 : (value) => value >= 0 : (_value) => true;
    const update4 = (value) => {
      if (canUpdate(value)) {
        sum2 = sum2 + value;
      }
    };
    return make31({
      get: () => counter3(sum2),
      update: update4,
      modify: update4
    });
  };
  var frequency3 = (key) => {
    const values3 = new Map;
    for (const word of key.keyType.preregisteredWords) {
      values3.set(word, 0);
    }
    const update4 = (word) => {
      const slotCount = values3.get(word) ?? 0;
      values3.set(word, slotCount + 1);
    };
    return make31({
      get: () => frequency2(values3),
      update: update4,
      modify: update4
    });
  };
  var gauge3 = (_key, startAt) => {
    let value = startAt;
    return make31({
      get: () => gauge2(value),
      update: (v) => {
        value = v;
      },
      modify: (v) => {
        value = value + v;
      }
    });
  };
  var histogram4 = (key) => {
    const bounds = key.keyType.boundaries.values;
    const size5 = bounds.length;
    const values3 = new Uint32Array(size5 + 1);
    const boundaries = new Float64Array(size5);
    let count = 0;
    let sum2 = 0;
    let min2 = Number.MAX_VALUE;
    let max2 = Number.MIN_VALUE;
    pipe(bounds, sort(Order), map3((n, i) => {
      boundaries[i] = n;
    }));
    const update4 = (value) => {
      let from = 0;
      let to = size5;
      while (from !== to) {
        const mid = Math.floor(from + (to - from) / 2);
        const boundary = boundaries[mid];
        if (value <= boundary) {
          to = mid;
        } else {
          from = mid;
        }
        if (to === from + 1) {
          if (value <= boundaries[from]) {
            to = from;
          } else {
            from = to;
          }
        }
      }
      values3[from] = values3[from] + 1;
      count = count + 1;
      sum2 = sum2 + value;
      if (value < min2) {
        min2 = value;
      }
      if (value > max2) {
        max2 = value;
      }
    };
    const getBuckets = () => {
      const builder = allocate(size5);
      let cumulated = 0;
      for (let i = 0;i < size5; i++) {
        const boundary = boundaries[i];
        const value = values3[i];
        cumulated = cumulated + value;
        builder[i] = [boundary, cumulated];
      }
      return builder;
    };
    return make31({
      get: () => histogram3({
        buckets: getBuckets(),
        count,
        min: min2,
        max: max2,
        sum: sum2
      }),
      update: update4,
      modify: update4
    });
  };
  var summary3 = (key) => {
    const {
      error,
      maxAge,
      maxSize,
      quantiles
    } = key.keyType;
    const sortedQuantiles = pipe(quantiles, sort(Order));
    const values3 = allocate(maxSize);
    let head4 = 0;
    let count = 0;
    let sum2 = 0;
    let min2 = 0;
    let max2 = 0;
    const snapshot = (now) => {
      const builder = [];
      let i = 0;
      while (i !== maxSize - 1) {
        const item = values3[i];
        if (item != null) {
          const [t, v] = item;
          const age = millis(now - t);
          if (greaterThanOrEqualTo2(age, zero) && lessThanOrEqualTo2(age, maxAge)) {
            builder.push(v);
          }
        }
        i = i + 1;
      }
      return calculateQuantiles(error, sortedQuantiles, sort(builder, Order));
    };
    const observe = (value, timestamp) => {
      if (maxSize > 0) {
        head4 = head4 + 1;
        const target = head4 % maxSize;
        values3[target] = [timestamp, value];
      }
      min2 = count === 0 ? value : Math.min(min2, value);
      max2 = count === 0 ? value : Math.max(max2, value);
      count = count + 1;
      sum2 = sum2 + value;
    };
    return make31({
      get: () => summary2({
        error,
        quantiles: snapshot(Date.now()),
        count,
        min: min2,
        max: max2,
        sum: sum2
      }),
      update: ([value, timestamp]) => observe(value, timestamp),
      modify: ([value, timestamp]) => observe(value, timestamp)
    });
  };
  var calculateQuantiles = (error, sortedQuantiles, sortedSamples) => {
    const sampleCount = sortedSamples.length;
    if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
      return empty2();
    }
    const head4 = sortedQuantiles[0];
    const tail = sortedQuantiles.slice(1);
    const resolvedHead = resolveQuantile(error, sampleCount, none2(), 0, head4, sortedSamples);
    const resolved = of(resolvedHead);
    tail.forEach((quantile) => {
      resolved.push(resolveQuantile(error, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
    });
    return map3(resolved, (rq) => [rq.quantile, rq.value]);
  };
  var resolveQuantile = (error, sampleCount, current, consumed, quantile, rest) => {
    let error_1 = error;
    let sampleCount_1 = sampleCount;
    let current_1 = current;
    let consumed_1 = consumed;
    let quantile_1 = quantile;
    let rest_1 = rest;
    let error_2 = error;
    let sampleCount_2 = sampleCount;
    let current_2 = current;
    let consumed_2 = consumed;
    let quantile_2 = quantile;
    let rest_2 = rest;
    while (true) {
      if (!isNonEmptyReadonlyArray(rest_1)) {
        return {
          quantile: quantile_1,
          value: none2(),
          consumed: consumed_1,
          rest: []
        };
      }
      if (quantile_1 === 1) {
        return {
          quantile: quantile_1,
          value: some2(lastNonEmpty(rest_1)),
          consumed: consumed_1 + rest_1.length,
          rest: []
        };
      }
      const headValue = headNonEmpty(rest_1);
      const sameHead = span(rest_1, (n) => n === headValue);
      const desired = quantile_1 * sampleCount_1;
      const allowedError = error_1 / 2 * desired;
      const candConsumed = consumed_1 + sameHead[0].length;
      const candError = Math.abs(candConsumed - desired);
      if (candConsumed < desired - allowedError) {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      if (candConsumed > desired + allowedError) {
        const valueToReturn = isNone2(current_1) ? some2(headValue) : current_1;
        return {
          quantile: quantile_1,
          value: valueToReturn,
          consumed: consumed_1,
          rest: rest_1
        };
      }
      switch (current_1._tag) {
        case "None": {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        case "Some": {
          const prevError = Math.abs(desired - current_1.value);
          if (candError < prevError) {
            error_2 = error_1;
            sampleCount_2 = sampleCount_1;
            current_2 = head(rest_1);
            consumed_2 = candConsumed;
            quantile_2 = quantile_1;
            rest_2 = sameHead[1];
            error_1 = error_2;
            sampleCount_1 = sampleCount_2;
            current_1 = current_2;
            consumed_1 = consumed_2;
            quantile_1 = quantile_2;
            rest_1 = rest_2;
            continue;
          }
          return {
            quantile: quantile_1,
            value: some2(current_1.value),
            consumed: consumed_1,
            rest: rest_1
          };
        }
      }
    }
    throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
  };

  // node_modules/effect/dist/esm/internal/metric/pair.js
  var MetricPairSymbolKey = "effect/MetricPair";
  var MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
  var metricPairVariance = {
    _Type: (_) => _
  };
  var unsafeMake9 = (metricKey, metricState) => {
    return {
      [MetricPairTypeId]: metricPairVariance,
      metricKey,
      metricState,
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
  };

  // node_modules/effect/dist/esm/internal/metric/registry.js
  var MetricRegistrySymbolKey = "effect/MetricRegistry";
  var MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);

  class MetricRegistryImpl {
    [MetricRegistryTypeId] = MetricRegistryTypeId;
    map = /* @__PURE__ */ empty18();
    snapshot() {
      const result = [];
      for (const [key, hook] of this.map) {
        result.push(unsafeMake9(key, hook.get()));
      }
      return result;
    }
    get(key) {
      const hook = pipe(this.map, get8(key), getOrUndefined);
      if (hook == null) {
        if (isCounterKey(key.keyType)) {
          return this.getCounter(key);
        }
        if (isGaugeKey(key.keyType)) {
          return this.getGauge(key);
        }
        if (isFrequencyKey(key.keyType)) {
          return this.getFrequency(key);
        }
        if (isHistogramKey(key.keyType)) {
          return this.getHistogram(key);
        }
        if (isSummaryKey(key.keyType)) {
          return this.getSummary(key);
        }
        throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
      } else {
        return hook;
      }
    }
    getCounter(key) {
      let value = pipe(this.map, get8(key), getOrUndefined);
      if (value == null) {
        const counter5 = counter4(key);
        if (!pipe(this.map, has4(key))) {
          pipe(this.map, set4(key, counter5));
        }
        value = counter5;
      }
      return value;
    }
    getFrequency(key) {
      let value = pipe(this.map, get8(key), getOrUndefined);
      if (value == null) {
        const frequency4 = frequency3(key);
        if (!pipe(this.map, has4(key))) {
          pipe(this.map, set4(key, frequency4));
        }
        value = frequency4;
      }
      return value;
    }
    getGauge(key) {
      let value = pipe(this.map, get8(key), getOrUndefined);
      if (value == null) {
        const gauge4 = gauge3(key, key.keyType.bigint ? BigInt(0) : 0);
        if (!pipe(this.map, has4(key))) {
          pipe(this.map, set4(key, gauge4));
        }
        value = gauge4;
      }
      return value;
    }
    getHistogram(key) {
      let value = pipe(this.map, get8(key), getOrUndefined);
      if (value == null) {
        const histogram5 = histogram4(key);
        if (!pipe(this.map, has4(key))) {
          pipe(this.map, set4(key, histogram5));
        }
        value = histogram5;
      }
      return value;
    }
    getSummary(key) {
      let value = pipe(this.map, get8(key), getOrUndefined);
      if (value == null) {
        const summary4 = summary3(key);
        if (!pipe(this.map, has4(key))) {
          pipe(this.map, set4(key, summary4));
        }
        value = summary4;
      }
      return value;
    }
  }
  var make32 = () => {
    return new MetricRegistryImpl;
  };

  // node_modules/effect/dist/esm/internal/metric.js
  var MetricSymbolKey = "effect/Metric";
  var MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
  var metricVariance = {
    _Type: (_) => _,
    _In: (_) => _,
    _Out: (_) => _
  };
  var globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make32());
  var make33 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
    const metric = Object.assign((effect) => tap(effect, (a) => update4(metric, a)), {
      [MetricTypeId]: metricVariance,
      keyType,
      unsafeUpdate,
      unsafeValue,
      unsafeModify,
      register() {
        this.unsafeValue([]);
        return this;
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    });
    return metric;
  };
  var counter5 = (name, options) => fromMetricKey(counter2(name, options));
  var fromMetricKey = (key) => {
    let untaggedHook;
    const hookCache = new WeakMap;
    const hook = (extraTags) => {
      if (extraTags.length === 0) {
        if (untaggedHook !== undefined) {
          return untaggedHook;
        }
        untaggedHook = globalMetricRegistry.get(key);
        return untaggedHook;
      }
      let hook2 = hookCache.get(extraTags);
      if (hook2 !== undefined) {
        return hook2;
      }
      hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
      hookCache.set(extraTags, hook2);
      return hook2;
    };
    return make33(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
  };
  var histogram5 = (name, boundaries, description) => fromMetricKey(histogram2(name, boundaries, description));
  var tagged = /* @__PURE__ */ dual(3, (self2, key, value) => taggedWithLabels2(self2, [make30(key, value)]));
  var taggedWithLabels2 = /* @__PURE__ */ dual(2, (self2, extraTags) => {
    return make33(self2.keyType, (input, extraTags1) => self2.unsafeUpdate(input, union(extraTags, extraTags1)), (extraTags1) => self2.unsafeValue(union(extraTags, extraTags1)), (input, extraTags1) => self2.unsafeModify(input, union(extraTags, extraTags1)));
  });
  var update4 = /* @__PURE__ */ dual(2, (self2, input) => fiberRefGetWith(currentMetricLabels, (tags) => sync(() => self2.unsafeUpdate(input, tags))));

  // node_modules/effect/dist/esm/internal/request.js
  var RequestSymbolKey = "effect/Request";
  var RequestTypeId = /* @__PURE__ */ Symbol.for(RequestSymbolKey);
  var requestVariance = {
    _E: (_) => _,
    _A: (_) => _
  };
  var RequestPrototype = {
    ...StructuralPrototype,
    [RequestTypeId]: requestVariance
  };
  var isRequest = (u) => hasProperty(u, RequestTypeId);
  var complete2 = /* @__PURE__ */ dual(2, (self2, result) => fiberRefGetWith(currentRequestMap, (map12) => sync(() => {
    if (map12.has(self2)) {
      const entry = map12.get(self2);
      if (!entry.state.completed) {
        entry.state.completed = true;
        deferredUnsafeDone(entry.result, result);
      }
    }
  })));
  class Listeners {
    count = 0;
    observers = /* @__PURE__ */ new Set;
    interrupted = false;
    addObserver(f) {
      this.observers.add(f);
    }
    removeObserver(f) {
      this.observers.delete(f);
    }
    increment() {
      this.count++;
      this.observers.forEach((f) => f(this.count));
    }
    decrement() {
      this.count--;
      this.observers.forEach((f) => f(this.count));
    }
  }

  // node_modules/effect/dist/esm/internal/supervisor.js
  var SupervisorSymbolKey = "effect/Supervisor";
  var SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
  var supervisorVariance = {
    _T: (_) => _
  };

  class ProxySupervisor {
    underlying;
    value0;
    [SupervisorTypeId] = supervisorVariance;
    constructor(underlying, value0) {
      this.underlying = underlying;
      this.value0 = value0;
    }
    get value() {
      return this.value0;
    }
    onStart(context2, effect, parent, fiber) {
      this.underlying.onStart(context2, effect, parent, fiber);
    }
    onEnd(value, fiber) {
      this.underlying.onEnd(value, fiber);
    }
    onEffect(fiber, effect) {
      this.underlying.onEffect(fiber, effect);
    }
    onSuspend(fiber) {
      this.underlying.onSuspend(fiber);
    }
    onResume(fiber) {
      this.underlying.onResume(fiber);
    }
    map(f) {
      return new ProxySupervisor(this, pipe(this.value, map10(f)));
    }
    zip(right3) {
      return new Zip(this, right3);
    }
  }

  class Zip {
    left;
    right;
    _tag = "Zip";
    [SupervisorTypeId] = supervisorVariance;
    constructor(left3, right3) {
      this.left = left3;
      this.right = right3;
    }
    get value() {
      return zip2(this.left.value, this.right.value);
    }
    onStart(context2, effect, parent, fiber) {
      this.left.onStart(context2, effect, parent, fiber);
      this.right.onStart(context2, effect, parent, fiber);
    }
    onEnd(value, fiber) {
      this.left.onEnd(value, fiber);
      this.right.onEnd(value, fiber);
    }
    onEffect(fiber, effect) {
      this.left.onEffect(fiber, effect);
      this.right.onEffect(fiber, effect);
    }
    onSuspend(fiber) {
      this.left.onSuspend(fiber);
      this.right.onSuspend(fiber);
    }
    onResume(fiber) {
      this.left.onResume(fiber);
      this.right.onResume(fiber);
    }
    map(f) {
      return new ProxySupervisor(this, pipe(this.value, map10(f)));
    }
    zip(right3) {
      return new Zip(this, right3);
    }
  }
  var isZip = (self2) => hasProperty(self2, SupervisorTypeId) && isTagged(self2, "Zip");

  class Track {
    [SupervisorTypeId] = supervisorVariance;
    fibers = /* @__PURE__ */ new Set;
    get value() {
      return sync(() => Array.from(this.fibers));
    }
    onStart(_context, _effect, _parent, fiber) {
      this.fibers.add(fiber);
    }
    onEnd(_value, fiber) {
      this.fibers.delete(fiber);
    }
    onEffect(_fiber, _effect) {}
    onSuspend(_fiber) {}
    onResume(_fiber) {}
    map(f) {
      return new ProxySupervisor(this, pipe(this.value, map10(f)));
    }
    zip(right3) {
      return new Zip(this, right3);
    }
    onRun(execution, _fiber) {
      return execution();
    }
  }

  class Const {
    effect;
    [SupervisorTypeId] = supervisorVariance;
    constructor(effect) {
      this.effect = effect;
    }
    get value() {
      return this.effect;
    }
    onStart(_context, _effect, _parent, _fiber) {}
    onEnd(_value, _fiber) {}
    onEffect(_fiber, _effect) {}
    onSuspend(_fiber) {}
    onResume(_fiber) {}
    map(f) {
      return new ProxySupervisor(this, pipe(this.value, map10(f)));
    }
    zip(right3) {
      return new Zip(this, right3);
    }
    onRun(execution, _fiber) {
      return execution();
    }
  }
  var unsafeTrack = () => {
    return new Track;
  };
  var track = /* @__PURE__ */ sync(unsafeTrack);
  var fromEffect = (effect) => {
    return new Const(effect);
  };
  var none8 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect(void_));

  // node_modules/effect/dist/esm/Differ.js
  var make34 = make15;

  // node_modules/effect/dist/esm/internal/supervisor/patch.js
  var OP_EMPTY3 = "Empty";
  var OP_ADD_SUPERVISOR = "AddSupervisor";
  var OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
  var OP_AND_THEN2 = "AndThen";
  var empty24 = {
    _tag: OP_EMPTY3
  };
  var combine8 = (self2, that) => {
    return {
      _tag: OP_AND_THEN2,
      first: self2,
      second: that
    };
  };
  var patch8 = (self2, supervisor) => {
    return patchLoop(supervisor, of2(self2));
  };
  var patchLoop = (_supervisor, _patches) => {
    let supervisor = _supervisor;
    let patches = _patches;
    while (isNonEmpty2(patches)) {
      const head4 = headNonEmpty2(patches);
      switch (head4._tag) {
        case OP_EMPTY3: {
          patches = tailNonEmpty2(patches);
          break;
        }
        case OP_ADD_SUPERVISOR: {
          supervisor = supervisor.zip(head4.supervisor);
          patches = tailNonEmpty2(patches);
          break;
        }
        case OP_REMOVE_SUPERVISOR: {
          supervisor = removeSupervisor(supervisor, head4.supervisor);
          patches = tailNonEmpty2(patches);
          break;
        }
        case OP_AND_THEN2: {
          patches = prepend2(head4.first)(prepend2(head4.second)(tailNonEmpty2(patches)));
          break;
        }
      }
    }
    return supervisor;
  };
  var removeSupervisor = (self2, that) => {
    if (equals(self2, that)) {
      return none8;
    } else {
      if (isZip(self2)) {
        return removeSupervisor(self2.left, that).zip(removeSupervisor(self2.right, that));
      } else {
        return self2;
      }
    }
  };
  var toSet2 = (self2) => {
    if (equals(self2, none8)) {
      return empty8();
    } else {
      if (isZip(self2)) {
        return pipe(toSet2(self2.left), union3(toSet2(self2.right)));
      } else {
        return make10(self2);
      }
    }
  };
  var diff7 = (oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return empty24;
    }
    const oldSupervisors = toSet2(oldValue);
    const newSupervisors = toSet2(newValue);
    const added = pipe(newSupervisors, difference3(oldSupervisors), reduce5(empty24, (patch9, supervisor) => combine8(patch9, {
      _tag: OP_ADD_SUPERVISOR,
      supervisor
    })));
    const removed = pipe(oldSupervisors, difference3(newSupervisors), reduce5(empty24, (patch9, supervisor) => combine8(patch9, {
      _tag: OP_REMOVE_SUPERVISOR,
      supervisor
    })));
    return combine8(added, removed);
  };
  var differ2 = /* @__PURE__ */ make34({
    empty: empty24,
    patch: patch8,
    combine: combine8,
    diff: diff7
  });

  // node_modules/effect/dist/esm/internal/fiberRuntime.js
  var fiberStarted = /* @__PURE__ */ counter5("effect_fiber_started", {
    incremental: true
  });
  var fiberActive = /* @__PURE__ */ counter5("effect_fiber_active");
  var fiberSuccesses = /* @__PURE__ */ counter5("effect_fiber_successes", {
    incremental: true
  });
  var fiberFailures = /* @__PURE__ */ counter5("effect_fiber_failures", {
    incremental: true
  });
  var fiberLifetimes = /* @__PURE__ */ tagged(/* @__PURE__ */ histogram5("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
    start: 0.5,
    factor: 2,
    count: 35
  })), "time_unit", "milliseconds");
  var EvaluationSignalContinue = "Continue";
  var EvaluationSignalDone = "Done";
  var EvaluationSignalYieldNow = "Yield";
  var runtimeFiberVariance = {
    _E: (_) => _,
    _A: (_) => _
  };
  var absurd = (_) => {
    throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  };
  var YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
  var yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
    currentOp: null
  }));
  var contOpSuccess = {
    [OP_ON_SUCCESS]: (_, cont, value) => {
      return internalCall(() => cont.effect_instruction_i1(value));
    },
    ["OnStep"]: (_, _cont, value) => {
      return exitSucceed(exitSucceed(value));
    },
    [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value) => {
      return internalCall(() => cont.effect_instruction_i2(value));
    },
    [OP_REVERT_FLAGS]: (self2, cont, value) => {
      self2.patchRuntimeFlags(self2.currentRuntimeFlags, cont.patch);
      if (interruptible(self2.currentRuntimeFlags) && self2.isInterrupted()) {
        return exitFailCause(self2.getInterruptedCause());
      } else {
        return exitSucceed(value);
      }
    },
    [OP_WHILE]: (self2, cont, value) => {
      internalCall(() => cont.effect_instruction_i2(value));
      if (internalCall(() => cont.effect_instruction_i0())) {
        self2.pushStack(cont);
        return internalCall(() => cont.effect_instruction_i1());
      } else {
        return void_;
      }
    },
    [OP_ITERATOR]: (self2, cont, value) => {
      while (true) {
        const state = internalCall(() => cont.effect_instruction_i0.next(value));
        if (state.done) {
          return exitSucceed(state.value);
        }
        const primitive = yieldWrapGet(state.value);
        if (!exitIsExit(primitive)) {
          self2.pushStack(cont);
          return primitive;
        } else if (primitive._tag === "Failure") {
          return primitive;
        }
        value = primitive.value;
      }
    }
  };
  var drainQueueWhileRunningTable = {
    [OP_INTERRUPT_SIGNAL]: (self2, runtimeFlags2, cur, message) => {
      self2.processNewInterruptSignal(message.cause);
      return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
    },
    [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
      throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
    },
    [OP_STATEFUL]: (self2, runtimeFlags2, cur, message) => {
      message.onFiber(self2, running2(runtimeFlags2));
      return cur;
    },
    [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
      return flatMap8(yieldNow(), () => cur);
    }
  };
  var runBlockedRequests = (self2) => forEachSequentialDiscard(flatten4(self2), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential4]) => {
    const map12 = new Map;
    const arr = [];
    for (const block of sequential4) {
      arr.push(toReadonlyArray(block));
      for (const entry of block) {
        map12.set(entry.request, entry);
      }
    }
    const flat = arr.flat();
    return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
      entry.listeners.interrupted = true;
    })), currentRequestMap, map12);
  }, false, false));
  var _version = /* @__PURE__ */ getCurrentVersion();

  class FiberRuntime extends Class {
    [FiberTypeId] = fiberVariance2;
    [RuntimeFiberTypeId] = runtimeFiberVariance;
    _fiberRefs;
    _fiberId;
    _queue = /* @__PURE__ */ new Array;
    _children = null;
    _observers = /* @__PURE__ */ new Array;
    _running = false;
    _stack = [];
    _asyncInterruptor = null;
    _asyncBlockingOn = null;
    _exitValue = null;
    _steps = [];
    _isYielding = false;
    currentRuntimeFlags;
    currentOpCount = 0;
    currentSupervisor;
    currentScheduler;
    currentTracer;
    currentSpan;
    currentContext;
    currentDefaultServices;
    constructor(fiberId2, fiberRefs0, runtimeFlags0) {
      super();
      this.currentRuntimeFlags = runtimeFlags0;
      this._fiberId = fiberId2;
      this._fiberRefs = fiberRefs0;
      if (runtimeMetrics(runtimeFlags0)) {
        const tags = this.getFiberRef(currentMetricLabels);
        fiberStarted.unsafeUpdate(1, tags);
        fiberActive.unsafeUpdate(1, tags);
      }
      this.refreshRefCache();
    }
    commit() {
      return join2(this);
    }
    id() {
      return this._fiberId;
    }
    resume(effect) {
      this.tell(resume(effect));
    }
    get status() {
      return this.ask((_, status) => status);
    }
    get runtimeFlags() {
      return this.ask((state, status) => {
        if (isDone3(status)) {
          return state.currentRuntimeFlags;
        }
        return status.runtimeFlags;
      });
    }
    scope() {
      return unsafeMake8(this);
    }
    get children() {
      return this.ask((fiber) => Array.from(fiber.getChildren()));
    }
    getChildren() {
      if (this._children === null) {
        this._children = new Set;
      }
      return this._children;
    }
    getInterruptedCause() {
      return this.getFiberRef(currentInterruptedCause);
    }
    fiberRefs() {
      return this.ask((fiber) => fiber.getFiberRefs());
    }
    ask(f) {
      return suspend(() => {
        const deferred = deferredUnsafeMake(this._fiberId);
        this.tell(stateful((fiber, status) => {
          deferredUnsafeDone(deferred, sync(() => f(fiber, status)));
        }));
        return deferredAwait(deferred);
      });
    }
    tell(message) {
      this._queue.push(message);
      if (!this._running) {
        this._running = true;
        this.drainQueueLaterOnExecutor();
      }
    }
    get await() {
      return async_((resume2) => {
        const cb = (exit2) => resume2(succeed(exit2));
        this.tell(stateful((fiber, _) => {
          if (fiber._exitValue !== null) {
            cb(this._exitValue);
          } else {
            fiber.addObserver(cb);
          }
        }));
        return sync(() => this.tell(stateful((fiber, _) => {
          fiber.removeObserver(cb);
        })));
      }, this.id());
    }
    get inheritAll() {
      return withFiberRuntime((parentFiber, parentStatus) => {
        const parentFiberId = parentFiber.id();
        const parentFiberRefs = parentFiber.getFiberRefs();
        const parentRuntimeFlags = parentStatus.runtimeFlags;
        const childFiberRefs = this.getFiberRefs();
        const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
        parentFiber.setFiberRefs(updatedFiberRefs);
        const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
        const patch9 = pipe(diff4(parentRuntimeFlags, updatedRuntimeFlags), exclude2(Interruption), exclude2(WindDown));
        return updateRuntimeFlags(patch9);
      });
    }
    get poll() {
      return sync(() => fromNullable(this._exitValue));
    }
    unsafePoll() {
      return this._exitValue;
    }
    interruptAsFork(fiberId2) {
      return sync(() => this.tell(interruptSignal(interrupt(fiberId2))));
    }
    unsafeInterruptAsFork(fiberId2) {
      this.tell(interruptSignal(interrupt(fiberId2)));
    }
    addObserver(observer) {
      if (this._exitValue !== null) {
        observer(this._exitValue);
      } else {
        this._observers.push(observer);
      }
    }
    removeObserver(observer) {
      this._observers = this._observers.filter((o) => o !== observer);
    }
    getFiberRefs() {
      this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
      return this._fiberRefs;
    }
    unsafeDeleteFiberRef(fiberRef) {
      this._fiberRefs = delete_(this._fiberRefs, fiberRef);
    }
    getFiberRef(fiberRef) {
      if (this._fiberRefs.locals.has(fiberRef)) {
        return this._fiberRefs.locals.get(fiberRef)[0][1];
      }
      return fiberRef.initial;
    }
    setFiberRef(fiberRef, value) {
      this._fiberRefs = updateAs(this._fiberRefs, {
        fiberId: this._fiberId,
        fiberRef,
        value
      });
      this.refreshRefCache();
    }
    refreshRefCache() {
      this.currentDefaultServices = this.getFiberRef(currentServices);
      this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
      this.currentSupervisor = this.getFiberRef(currentSupervisor);
      this.currentScheduler = this.getFiberRef(currentScheduler);
      this.currentContext = this.getFiberRef(currentContext);
      this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
    }
    setFiberRefs(fiberRefs3) {
      this._fiberRefs = fiberRefs3;
      this.refreshRefCache();
    }
    addChild(child) {
      this.getChildren().add(child);
    }
    removeChild(child) {
      this.getChildren().delete(child);
    }
    transferChildren(scope) {
      const children = this._children;
      this._children = null;
      if (children !== null && children.size > 0) {
        for (const child of children) {
          if (child._exitValue === null) {
            scope.add(this.currentRuntimeFlags, child);
          }
        }
      }
    }
    drainQueueOnCurrentThread() {
      let recurse = true;
      while (recurse) {
        let evaluationSignal = EvaluationSignalContinue;
        const prev = globalThis[currentFiberURI];
        globalThis[currentFiberURI] = this;
        try {
          while (evaluationSignal === EvaluationSignalContinue) {
            evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
          }
        } finally {
          this._running = false;
          globalThis[currentFiberURI] = prev;
        }
        if (this._queue.length > 0 && !this._running) {
          this._running = true;
          if (evaluationSignal === EvaluationSignalYieldNow) {
            this.drainQueueLaterOnExecutor();
            recurse = false;
          } else {
            recurse = true;
          }
        } else {
          recurse = false;
        }
      }
    }
    drainQueueLaterOnExecutor() {
      this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
    }
    drainQueueWhileRunning(runtimeFlags2, cur0) {
      let cur = cur0;
      while (this._queue.length > 0) {
        const message = this._queue.splice(0, 1)[0];
        cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
      }
      return cur;
    }
    isInterrupted() {
      return !isEmpty5(this.getFiberRef(currentInterruptedCause));
    }
    addInterruptedCause(cause2) {
      const oldSC = this.getFiberRef(currentInterruptedCause);
      this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause2));
    }
    processNewInterruptSignal(cause2) {
      this.addInterruptedCause(cause2);
      this.sendInterruptSignalToAllChildren();
    }
    sendInterruptSignalToAllChildren() {
      if (this._children === null || this._children.size === 0) {
        return false;
      }
      let told = false;
      for (const child of this._children) {
        child.tell(interruptSignal(interrupt(this.id())));
        told = true;
      }
      return told;
    }
    interruptAllChildren() {
      if (this.sendInterruptSignalToAllChildren()) {
        const it = this._children.values();
        this._children = null;
        let isDone4 = false;
        const body = () => {
          const next = it.next();
          if (!next.done) {
            return asVoid(next.value.await);
          } else {
            return sync(() => {
              isDone4 = true;
            });
          }
        };
        return whileLoop({
          while: () => !isDone4,
          body,
          step: () => {}
        });
      }
      return null;
    }
    reportExitValue(exit2) {
      if (runtimeMetrics(this.currentRuntimeFlags)) {
        const tags = this.getFiberRef(currentMetricLabels);
        const startTimeMillis = this.id().startTimeMillis;
        const endTimeMillis = Date.now();
        fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
        fiberActive.unsafeUpdate(-1, tags);
        switch (exit2._tag) {
          case OP_SUCCESS: {
            fiberSuccesses.unsafeUpdate(1, tags);
            break;
          }
          case OP_FAILURE: {
            fiberFailures.unsafeUpdate(1, tags);
            break;
          }
        }
      }
      if (exit2._tag === "Failure") {
        const level = this.getFiberRef(currentUnhandledErrorLogLevel);
        if (!isInterruptedOnly(exit2.cause) && level._tag === "Some") {
          this.log("Fiber terminated with an unhandled error", exit2.cause, level);
        }
      }
    }
    setExitValue(exit2) {
      this._exitValue = exit2;
      this.reportExitValue(exit2);
      for (let i = this._observers.length - 1;i >= 0; i--) {
        this._observers[i](exit2);
      }
      this._observers = [];
    }
    getLoggers() {
      return this.getFiberRef(currentLoggers);
    }
    log(message, cause2, overrideLogLevel) {
      const logLevel = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
      const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
      if (greaterThan3(minimumLogLevel, logLevel)) {
        return;
      }
      const spans = this.getFiberRef(currentLogSpan);
      const annotations2 = this.getFiberRef(currentLogAnnotations);
      const loggers = this.getLoggers();
      const contextMap = this.getFiberRefs();
      if (size3(loggers) > 0) {
        const clockService = get3(this.getFiberRef(currentServices), clockTag);
        const date = new Date(clockService.unsafeCurrentTimeMillis());
        withRedactableContext(contextMap, () => {
          for (const logger of loggers) {
            logger.log({
              fiberId: this.id(),
              logLevel,
              message,
              cause: cause2,
              context: contextMap,
              spans,
              annotations: annotations2,
              date
            });
          }
        });
      }
    }
    evaluateMessageWhileSuspended(message) {
      switch (message._tag) {
        case OP_YIELD_NOW: {
          return EvaluationSignalYieldNow;
        }
        case OP_INTERRUPT_SIGNAL: {
          this.processNewInterruptSignal(message.cause);
          if (this._asyncInterruptor !== null) {
            this._asyncInterruptor(exitFailCause(message.cause));
            this._asyncInterruptor = null;
          }
          return EvaluationSignalContinue;
        }
        case OP_RESUME: {
          this._asyncInterruptor = null;
          this._asyncBlockingOn = null;
          this.evaluateEffect(message.effect);
          return EvaluationSignalContinue;
        }
        case OP_STATEFUL: {
          message.onFiber(this, this._exitValue !== null ? done4 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
          return EvaluationSignalContinue;
        }
        default: {
          return absurd(message);
        }
      }
    }
    evaluateEffect(effect0) {
      this.currentSupervisor.onResume(this);
      try {
        let effect = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
        while (effect !== null) {
          const eff = effect;
          const exit2 = this.runLoop(eff);
          if (exit2 === YieldedOp) {
            const op = yieldedOpChannel.currentOp;
            yieldedOpChannel.currentOp = null;
            if (op._op === OP_YIELD) {
              if (cooperativeYielding(this.currentRuntimeFlags)) {
                this.tell(yieldNow3());
                this.tell(resume(exitVoid));
                effect = null;
              } else {
                effect = exitVoid;
              }
            } else if (op._op === OP_ASYNC) {
              effect = null;
            }
          } else {
            this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
            const interruption2 = this.interruptAllChildren();
            if (interruption2 !== null) {
              effect = flatMap8(interruption2, () => exit2);
            } else {
              if (this._queue.length === 0) {
                this.setExitValue(exit2);
              } else {
                this.tell(resume(exit2));
              }
              effect = null;
            }
          }
        }
      } finally {
        this.currentSupervisor.onSuspend(this);
      }
    }
    start(effect) {
      if (!this._running) {
        this._running = true;
        const prev = globalThis[currentFiberURI];
        globalThis[currentFiberURI] = this;
        try {
          this.evaluateEffect(effect);
        } finally {
          this._running = false;
          globalThis[currentFiberURI] = prev;
          if (this._queue.length > 0) {
            this.drainQueueLaterOnExecutor();
          }
        }
      } else {
        this.tell(resume(effect));
      }
    }
    startFork(effect) {
      this.tell(resume(effect));
    }
    patchRuntimeFlags(oldRuntimeFlags, patch9) {
      const newRuntimeFlags = patch4(oldRuntimeFlags, patch9);
      globalThis[currentFiberURI] = this;
      this.currentRuntimeFlags = newRuntimeFlags;
      return newRuntimeFlags;
    }
    initiateAsync(runtimeFlags2, asyncRegister) {
      let alreadyCalled = false;
      const callback = (effect) => {
        if (!alreadyCalled) {
          alreadyCalled = true;
          this.tell(resume(effect));
        }
      };
      if (interruptible(runtimeFlags2)) {
        this._asyncInterruptor = callback;
      }
      try {
        asyncRegister(callback);
      } catch (e) {
        callback(failCause(die(e)));
      }
    }
    pushStack(cont) {
      this._stack.push(cont);
      if (cont._op === "OnStep") {
        this._steps.push({
          refs: this.getFiberRefs(),
          flags: this.currentRuntimeFlags
        });
      }
    }
    popStack() {
      const item = this._stack.pop();
      if (item) {
        if (item._op === "OnStep") {
          this._steps.pop();
        }
        return item;
      }
      return;
    }
    getNextSuccessCont() {
      let frame = this.popStack();
      while (frame) {
        if (frame._op !== OP_ON_FAILURE) {
          return frame;
        }
        frame = this.popStack();
      }
    }
    getNextFailCont() {
      let frame = this.popStack();
      while (frame) {
        if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
          return frame;
        }
        frame = this.popStack();
      }
    }
    [OP_TAG](op) {
      return sync(() => unsafeGet3(this.currentContext, op));
    }
    ["Left"](op) {
      return fail2(op.left);
    }
    ["None"](_) {
      return fail2(new NoSuchElementException);
    }
    ["Right"](op) {
      return exitSucceed(op.right);
    }
    ["Some"](op) {
      return exitSucceed(op.value);
    }
    ["Micro"](op) {
      return unsafeAsync((microResume) => {
        let resume2 = microResume;
        const fiber = runFork(provideContext2(op, this.currentContext));
        fiber.addObserver((exit2) => {
          if (exit2._tag === "Success") {
            return resume2(exitSucceed(exit2.value));
          }
          switch (exit2.cause._tag) {
            case "Interrupt": {
              return resume2(exitFailCause(interrupt(none4)));
            }
            case "Fail": {
              return resume2(fail2(exit2.cause.error));
            }
            case "Die": {
              return resume2(die2(exit2.cause.defect));
            }
          }
        });
        return unsafeAsync((abortResume) => {
          resume2 = (_) => {
            abortResume(void_);
          };
          fiber.unsafeInterrupt();
        });
      });
    }
    [OP_SYNC](op) {
      const value = internalCall(() => op.effect_instruction_i0());
      const cont = this.getNextSuccessCont();
      if (cont !== undefined) {
        if (!(cont._op in contOpSuccess)) {
          absurd(cont);
        }
        return contOpSuccess[cont._op](this, cont, value);
      } else {
        yieldedOpChannel.currentOp = exitSucceed(value);
        return YieldedOp;
      }
    }
    [OP_SUCCESS](op) {
      const oldCur = op;
      const cont = this.getNextSuccessCont();
      if (cont !== undefined) {
        if (!(cont._op in contOpSuccess)) {
          absurd(cont);
        }
        return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
      } else {
        yieldedOpChannel.currentOp = oldCur;
        return YieldedOp;
      }
    }
    [OP_FAILURE](op) {
      const cause2 = op.effect_instruction_i0;
      const cont = this.getNextFailCont();
      if (cont !== undefined) {
        switch (cont._op) {
          case OP_ON_FAILURE:
          case OP_ON_SUCCESS_AND_FAILURE: {
            if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
              return internalCall(() => cont.effect_instruction_i1(cause2));
            } else {
              return exitFailCause(stripFailures(cause2));
            }
          }
          case "OnStep": {
            if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
              return exitSucceed(exitFailCause(cause2));
            } else {
              return exitFailCause(stripFailures(cause2));
            }
          }
          case OP_REVERT_FLAGS: {
            this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
            if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
              return exitFailCause(sequential(cause2, this.getInterruptedCause()));
            } else {
              return exitFailCause(cause2);
            }
          }
          default: {
            absurd(cont);
          }
        }
      } else {
        yieldedOpChannel.currentOp = exitFailCause(cause2);
        return YieldedOp;
      }
    }
    [OP_WITH_RUNTIME](op) {
      return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
    }
    ["Blocked"](op) {
      const refs = this.getFiberRefs();
      const flags = this.currentRuntimeFlags;
      if (this._steps.length > 0) {
        const frames = [];
        const snap = this._steps[this._steps.length - 1];
        let frame = this.popStack();
        while (frame && frame._op !== "OnStep") {
          frames.push(frame);
          frame = this.popStack();
        }
        this.setFiberRefs(snap.refs);
        this.currentRuntimeFlags = snap.flags;
        const patchRefs = diff6(snap.refs, refs);
        const patchFlags = diff4(snap.flags, flags);
        return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
          while (frames.length > 0) {
            newFiber.pushStack(frames.pop());
          }
          newFiber.setFiberRefs(patch7(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
          newFiber.currentRuntimeFlags = patch4(patchFlags)(newFiber.currentRuntimeFlags);
          return op.effect_instruction_i1;
        })));
      }
      return uninterruptibleMask((restore) => flatMap8(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
    }
    ["RunBlocked"](op) {
      return runBlockedRequests(op.effect_instruction_i0);
    }
    [OP_UPDATE_RUNTIME_FLAGS](op) {
      const updateFlags = op.effect_instruction_i0;
      const oldRuntimeFlags = this.currentRuntimeFlags;
      const newRuntimeFlags = patch4(oldRuntimeFlags, updateFlags);
      if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
        return exitFailCause(this.getInterruptedCause());
      } else {
        this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
        if (op.effect_instruction_i1) {
          const revertFlags = diff4(newRuntimeFlags, oldRuntimeFlags);
          this.pushStack(new RevertFlags(revertFlags, op));
          return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
        } else {
          return exitVoid;
        }
      }
    }
    [OP_ON_SUCCESS](op) {
      this.pushStack(op);
      return op.effect_instruction_i0;
    }
    ["OnStep"](op) {
      this.pushStack(op);
      return op.effect_instruction_i0;
    }
    [OP_ON_FAILURE](op) {
      this.pushStack(op);
      return op.effect_instruction_i0;
    }
    [OP_ON_SUCCESS_AND_FAILURE](op) {
      this.pushStack(op);
      return op.effect_instruction_i0;
    }
    [OP_ASYNC](op) {
      this._asyncBlockingOn = op.effect_instruction_i1;
      this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
      yieldedOpChannel.currentOp = op;
      return YieldedOp;
    }
    [OP_YIELD](op) {
      this._isYielding = false;
      yieldedOpChannel.currentOp = op;
      return YieldedOp;
    }
    [OP_WHILE](op) {
      const check = op.effect_instruction_i0;
      const body = op.effect_instruction_i1;
      if (check()) {
        this.pushStack(op);
        return body();
      } else {
        return exitVoid;
      }
    }
    [OP_ITERATOR](op) {
      return contOpSuccess[OP_ITERATOR](this, op, undefined);
    }
    [OP_COMMIT](op) {
      return internalCall(() => op.commit());
    }
    runLoop(effect0) {
      let cur = effect0;
      this.currentOpCount = 0;
      while (true) {
        if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
          this.currentSupervisor.onEffect(this, cur);
        }
        if (this._queue.length > 0) {
          cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
        }
        if (!this._isYielding) {
          this.currentOpCount += 1;
          const shouldYield = this.currentScheduler.shouldYield(this);
          if (shouldYield !== false) {
            this._isYielding = true;
            this.currentOpCount = 0;
            const oldCur = cur;
            cur = flatMap8(yieldNow({
              priority: shouldYield
            }), () => oldCur);
          }
        }
        try {
          cur = this.currentTracer.context(() => {
            if (_version !== cur[EffectTypeId2]._V) {
              const level = this.getFiberRef(currentVersionMismatchErrorLogLevel);
              if (level._tag === "Some") {
                const effectVersion = cur[EffectTypeId2]._V;
                this.log(`Executing an Effect versioned ${effectVersion} with a Runtime of version ${getCurrentVersion()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`, empty17, level);
              }
            }
            return this[cur._op](cur);
          }, this);
          if (cur === YieldedOp) {
            const op = yieldedOpChannel.currentOp;
            if (op._op === OP_YIELD || op._op === OP_ASYNC) {
              return YieldedOp;
            }
            yieldedOpChannel.currentOp = null;
            return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
          }
        } catch (e) {
          if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
            cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
          } else if (isInterruptedException(e)) {
            cur = exitFailCause(sequential(die(e), interrupt(none4)));
          } else {
            cur = die2(e);
          }
        }
      }
    }
    run = () => {
      this.drainQueueOnCurrentThread();
    };
  }
  var currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
  var loggerWithConsoleLog = (self2) => makeLogger((opts) => {
    const services = getOrDefault2(opts.context, currentServices);
    get3(services, consoleTag).unsafe.log(self2.log(opts));
  });
  var defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
  var tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
    annotations: annotations2,
    cause: cause2,
    context: context2,
    fiberId: fiberId2,
    logLevel,
    message
  }) => {
    const span2 = getOption2(getOrDefault(context2, currentContext), spanTag);
    if (span2._tag === "None" || span2.value._tag === "ExternalSpan") {
      return;
    }
    const clockService = unsafeGet3(getOrDefault(context2, currentServices), clockTag);
    const attributes = {};
    for (const [key, value] of annotations2) {
      attributes[key] = value;
    }
    attributes["effect.fiberId"] = threadName2(fiberId2);
    attributes["effect.logLevel"] = logLevel.label;
    if (cause2 !== null && cause2._tag !== "Empty") {
      attributes["effect.cause"] = pretty(cause2, {
        renderErrorCause: true
      });
    }
    span2.value.event(toStringUnknown(Array.isArray(message) && message.length === 1 ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
  }));
  var currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make10(defaultLogger, tracerLogger)));
  var annotateLogsScoped = function() {
    if (typeof arguments[0] === "string") {
      return fiberRefLocallyScopedWith(currentLogAnnotations, set3(arguments[0], arguments[1]));
    }
    const entries2 = Object.entries(arguments[0]);
    return fiberRefLocallyScopedWith(currentLogAnnotations, mutate3((annotations2) => {
      for (let i = 0;i < entries2.length; i++) {
        const [key, value] = entries2[i];
        set3(annotations2, key, value);
      }
      return annotations2;
    }));
  };
  var whenLogLevel = /* @__PURE__ */ dual(2, (effect, level) => {
    const requiredLogLevel = typeof level === "string" ? fromLiteral(level) : level;
    return withFiberRuntime((fiberState) => {
      const minimumLogLevel = fiberState.getFiberRef(currentMinimumLogLevel);
      if (greaterThan3(minimumLogLevel, requiredLogLevel)) {
        return succeed(none2());
      }
      return map10(effect, some2);
    });
  });
  var acquireRelease = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => uninterruptible(tap(acquire, (a) => addFinalizer((exit2) => release(a, exit2)))));
  var acquireReleaseInterruptible = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => ensuring(acquire, addFinalizer((exit2) => release(exit2))));
  var addFinalizer = (finalizer) => withFiberRuntime((runtime3) => {
    const acquireRefs = runtime3.getFiberRefs();
    const acquireFlags = disable2(runtime3.currentRuntimeFlags, Interruption);
    return flatMap8(scope, (scope) => scopeAddFinalizerExit(scope, (exit2) => withFiberRuntime((runtimeFinalizer) => {
      const preRefs = runtimeFinalizer.getFiberRefs();
      const preFlags = runtimeFinalizer.currentRuntimeFlags;
      const patchRefs = diff6(preRefs, acquireRefs);
      const patchFlags = diff4(preFlags, acquireFlags);
      const inverseRefs = diff6(acquireRefs, preRefs);
      runtimeFinalizer.setFiberRefs(patch7(patchRefs, runtimeFinalizer.id(), acquireRefs));
      return ensuring(withRuntimeFlags(finalizer(exit2), patchFlags), sync(() => {
        runtimeFinalizer.setFiberRefs(patch7(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
      }));
    })));
  });
  var daemonChildren = (self2) => {
    const forkScope = fiberRefLocally(currentForkScopeOverride, some2(globalScope));
    return forkScope(self2);
  };
  var _existsParFound = /* @__PURE__ */ Symbol.for("effect/Effect/existsPar/found");
  var exists2 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => matchSimple(options?.concurrency, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => matchEffect(forEach5(elements, (a, i) => if_(predicate(a, i), {
    onTrue: () => fail2(_existsParFound),
    onFalse: () => void_
  }), options), {
    onFailure: (e) => e === _existsParFound ? succeed(true) : fail2(e),
    onSuccess: () => succeed(false)
  })));
  var existsLoop = (iterator, index, f) => {
    const next = iterator.next();
    if (next.done) {
      return succeed(false);
    }
    return flatMap8(f(next.value, index), (b) => b ? succeed(b) : existsLoop(iterator, index + 1, f));
  };
  var filter6 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => {
    const predicate_ = options?.negate ? (a, i) => map10(predicate(a, i), not) : predicate;
    return matchSimple(options?.concurrency, () => suspend(() => fromIterable(elements).reduceRight((effect, a, i) => zipWith3(effect, suspend(() => predicate_(a, i)), (list, b) => b ? [a, ...list] : list), sync(() => new Array))), () => map10(forEach5(elements, (a, i) => map10(predicate_(a, i), (b) => b ? some2(a) : none2()), options), getSomes));
  });
  var allResolveInput = (input) => {
    if (Array.isArray(input) || isIterable(input)) {
      return [input, none2()];
    }
    const keys3 = Object.keys(input);
    const size5 = keys3.length;
    return [keys3.map((k) => input[k]), some2((values3) => {
      const res = {};
      for (let i = 0;i < size5; i++) {
        res[keys3[i]] = values3[i];
      }
      return res;
    })];
  };
  var allValidate = (effects, reconcile, options) => {
    const eitherEffects = [];
    for (const effect of effects) {
      eitherEffects.push(either2(effect));
    }
    return flatMap8(forEach5(eitherEffects, identity, {
      concurrency: options?.concurrency,
      batching: options?.batching,
      concurrentFinalizers: options?.concurrentFinalizers
    }), (eithers) => {
      const none9 = none2();
      const size5 = eithers.length;
      const errors = new Array(size5);
      const successes = new Array(size5);
      let errored = false;
      for (let i = 0;i < size5; i++) {
        const either3 = eithers[i];
        if (either3._tag === "Left") {
          errors[i] = some2(either3.left);
          errored = true;
        } else {
          successes[i] = either3.right;
          errors[i] = none9;
        }
      }
      if (errored) {
        return reconcile._tag === "Some" ? fail2(reconcile.value(errors)) : fail2(errors);
      } else if (options?.discard) {
        return void_;
      }
      return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
    });
  };
  var allEither = (effects, reconcile, options) => {
    const eitherEffects = [];
    for (const effect of effects) {
      eitherEffects.push(either2(effect));
    }
    if (options?.discard) {
      return forEach5(eitherEffects, identity, {
        concurrency: options?.concurrency,
        batching: options?.batching,
        discard: true,
        concurrentFinalizers: options?.concurrentFinalizers
      });
    }
    return map10(forEach5(eitherEffects, identity, {
      concurrency: options?.concurrency,
      batching: options?.batching,
      concurrentFinalizers: options?.concurrentFinalizers
    }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
  };
  var all3 = (arg, options) => {
    const [effects, reconcile] = allResolveInput(arg);
    if (options?.mode === "validate") {
      return allValidate(effects, reconcile, options);
    } else if (options?.mode === "either") {
      return allEither(effects, reconcile, options);
    }
    return options?.discard !== true && reconcile._tag === "Some" ? map10(forEach5(effects, identity, options), reconcile.value) : forEach5(effects, identity, options);
  };
  var allWith = (options) => (arg) => all3(arg, options);
  var allSuccesses = (elements, options) => map10(all3(fromIterable(elements).map(exit), options), filterMap2((exit2) => exitIsSuccess(exit2) ? some2(exit2.effect_instruction_i0) : none2()));
  var replicate = /* @__PURE__ */ dual(2, (self2, n) => Array.from({
    length: n
  }, () => self2));
  var replicateEffect = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, n, options) => all3(replicate(self2, n), options));
  var forEach5 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (self2, f, options) => withFiberRuntime((r) => {
    const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
    if (options?.discard) {
      return match9(options.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self2, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
    }
    return match9(options?.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self2, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self2, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachParUnbounded(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachParN(self2, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
  }));
  var forEachParUnbounded = (self2, f, batching) => suspend(() => {
    const as2 = fromIterable(self2);
    const array3 = new Array(as2.length);
    const fn = (a, i) => flatMap8(f(a, i), (b) => sync(() => array3[i] = b));
    return zipRight(forEachConcurrentDiscard(as2, fn, batching, false), succeed(array3));
  });
  var forEachConcurrentDiscard = (self2, f, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
    let todos = Array.from(self2).reverse();
    let target = todos.length;
    if (target === 0) {
      return void_;
    }
    let counter6 = 0;
    let interrupted = false;
    const fibersCount = n ? Math.min(todos.length, n) : todos.length;
    const fibers = new Set;
    const results = new Array;
    const interruptAll = () => fibers.forEach((fiber) => {
      fiber.currentScheduler.scheduleTask(() => {
        fiber.unsafeInterruptAsFork(parent.id());
      }, 0);
    });
    const startOrder = new Array;
    const joinOrder = new Array;
    const residual = new Array;
    const collectExits = () => {
      const exits = results.filter(({
        exit: exit2
      }) => exit2._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
        exit: exit2
      }) => exit2);
      if (exits.length === 0) {
        exits.push(exitVoid);
      }
      return exits;
    };
    const runFiber = (eff, interruptImmediately = false) => {
      const runnable = uninterruptible(graft(eff));
      const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
      parent.currentScheduler.scheduleTask(() => {
        if (interruptImmediately) {
          fiber.unsafeInterruptAsFork(parent.id());
        }
        fiber.resume(runnable);
      }, 0);
      return fiber;
    };
    const onInterruptSignal = () => {
      if (!processAll) {
        target -= todos.length;
        todos = [];
      }
      interrupted = true;
      interruptAll();
    };
    const stepOrExit = batching ? step2 : exit;
    const processingFiber = runFiber(async_((resume2) => {
      const pushResult = (res, index) => {
        if (res._op === "Blocked") {
          residual.push(res);
        } else {
          results.push({
            index,
            exit: res
          });
          if (res._op === "Failure" && !interrupted) {
            onInterruptSignal();
          }
        }
      };
      const next = () => {
        if (todos.length > 0) {
          const a = todos.pop();
          let index = counter6++;
          const returnNextElement = () => {
            const a2 = todos.pop();
            index = counter6++;
            return flatMap8(yieldNow(), () => flatMap8(stepOrExit(restore(f(a2, index))), onRes));
          };
          const onRes = (res) => {
            if (todos.length > 0) {
              pushResult(res, index);
              if (todos.length > 0) {
                return returnNextElement();
              }
            }
            return succeed(res);
          };
          const todo = flatMap8(stepOrExit(restore(f(a, index))), onRes);
          const fiber = runFiber(todo);
          startOrder.push(fiber);
          fibers.add(fiber);
          if (interrupted) {
            fiber.currentScheduler.scheduleTask(() => {
              fiber.unsafeInterruptAsFork(parent.id());
            }, 0);
          }
          fiber.addObserver((wrapped) => {
            let exit2;
            if (wrapped._op === "Failure") {
              exit2 = wrapped;
            } else {
              exit2 = wrapped.effect_instruction_i0;
            }
            joinOrder.push(fiber);
            fibers.delete(fiber);
            pushResult(exit2, index);
            if (results.length === target) {
              resume2(succeed(getOrElse(exitCollectAll(collectExits(), {
                parallel: true
              }), () => exitVoid)));
            } else if (residual.length + results.length === target) {
              const exits = collectExits();
              const requests = residual.map((blocked2) => blocked2.effect_instruction_i0).reduce(par);
              resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse(exitCollectAll(exits, {
                parallel: true
              }), () => exitVoid), ...residual.map((blocked2) => blocked2.effect_instruction_i1)], (i) => i, batching, true, n))));
            } else {
              next();
            }
          });
        }
      };
      for (let i = 0;i < fibersCount; i++) {
        next();
      }
    }));
    return asVoid(onExit(flatten6(restore(join2(processingFiber))), exitMatch({
      onFailure: (cause2) => {
        onInterruptSignal();
        const target2 = residual.length + 1;
        const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
        const toPop = Array.from(residual);
        return async_((cb) => {
          const exits = [];
          let count = 0;
          let index = 0;
          const check = (index2, hitNext) => (exit2) => {
            exits[index2] = exit2;
            count++;
            if (count === target2) {
              cb(exitSucceed(exitFailCause(cause2)));
            }
            if (toPop.length > 0 && hitNext) {
              next();
            }
          };
          const next = () => {
            runFiber(toPop.pop(), true).addObserver(check(index, true));
            index++;
          };
          processingFiber.addObserver(check(index, false));
          index++;
          for (let i = 0;i < concurrency; i++) {
            next();
          }
        });
      },
      onSuccess: () => forEachSequential(joinOrder, (f2) => f2.inheritAll)
    })));
  })));
  var forEachParN = (self2, n, f, batching) => suspend(() => {
    const as2 = fromIterable(self2);
    const array3 = new Array(as2.length);
    const fn = (a, i) => map10(f(a, i), (b) => array3[i] = b);
    return zipRight(forEachConcurrentDiscard(as2, fn, batching, false, n), succeed(array3));
  });
  var fork = (self2) => withFiberRuntime((state, status) => succeed(unsafeFork(self2, state, status.runtimeFlags)));
  var forkDaemon = (self2) => forkWithScopeOverride(self2, globalScope);
  var forkWithErrorHandler = /* @__PURE__ */ dual(2, (self2, handler) => fork(onError(self2, (cause2) => {
    const either3 = failureOrCause(cause2);
    switch (either3._tag) {
      case "Left":
        return handler(either3.left);
      case "Right":
        return failCause(either3.right);
    }
  })));
  var unsafeFork = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
    const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
    childFiber.resume(effect);
    return childFiber;
  };
  var unsafeForkUnstarted = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
    const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
    return childFiber;
  };
  var unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
    const childId = unsafeMake3();
    const parentFiberRefs = parentFiber.getFiberRefs();
    const childFiberRefs = forkAs(parentFiberRefs, childId);
    const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
    const childContext = getOrDefault(childFiberRefs, currentContext);
    const supervisor = childFiber.currentSupervisor;
    supervisor.onStart(childContext, effect, some2(parentFiber), childFiber);
    childFiber.addObserver((exit2) => supervisor.onEnd(exit2, childFiber));
    const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse(() => parentFiber.scope()));
    parentScope.add(parentRuntimeFlags, childFiber);
    return childFiber;
  };
  var forkWithScopeOverride = (self2, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork(self2, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
  var mergeAll3 = /* @__PURE__ */ dual((args2) => isFunction2(args2[2]), (elements, zero2, f, options) => matchSimple(options?.concurrency, () => fromIterable(elements).reduce((acc, a, i) => zipWith3(acc, a, (acc2, a2) => f(acc2, a2, i)), succeed(zero2)), () => flatMap8(make29(zero2), (acc) => flatMap8(forEach5(elements, (effect, i) => flatMap8(effect, (a) => update3(acc, (b) => f(b, a, i))), options), () => get12(acc)))));
  var partition3 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => pipe(forEach5(elements, (a, i) => either2(f(a, i)), options), map10((chunk2) => partitionMap2(chunk2, identity))));
  var validateAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => flatMap8(partition3(elements, f, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), ([es, bs]) => isNonEmptyArray2(es) ? fail2(es) : options?.discard ? void_ : succeed(bs)));
  var raceAll = (all4) => withFiberRuntime((state, status) => async_((resume2) => {
    const fibers = new Set;
    let winner;
    let failures2 = empty17;
    const interruptAll = () => {
      for (const fiber of fibers) {
        fiber.unsafeInterruptAsFork(state.id());
      }
    };
    let latch = false;
    let empty25 = true;
    for (const self2 of all4) {
      empty25 = false;
      const fiber = unsafeFork(interruptible2(self2), state, status.runtimeFlags);
      fibers.add(fiber);
      fiber.addObserver((exit2) => {
        fibers.delete(fiber);
        if (!winner) {
          if (exit2._tag === "Success") {
            latch = true;
            winner = fiber;
            failures2 = empty17;
            interruptAll();
          } else {
            failures2 = parallel(exit2.cause, failures2);
          }
        }
        if (latch && fibers.size === 0) {
          resume2(winner ? zipRight(inheritAll(winner), winner.unsafePoll()) : failCause(failures2));
        }
      });
      if (winner)
        break;
    }
    if (empty25) {
      return resume2(dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`)));
    }
    latch = true;
    return interruptAllAs(fibers, state.id());
  }));
  var reduceEffect = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, zero2, f, options) => matchSimple(options?.concurrency, () => fromIterable(elements).reduce((acc, a, i) => zipWith3(acc, a, (acc2, a2) => f(acc2, a2, i)), zero2), () => suspend(() => pipe(mergeAll3([zero2, ...elements], none2(), (acc, elem, i) => {
    switch (acc._tag) {
      case "None": {
        return some2(elem);
      }
      case "Some": {
        return some2(f(acc.value, elem, i));
      }
    }
  }, options), map10((option2) => {
    switch (option2._tag) {
      case "None": {
        throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
      }
      case "Some": {
        return option2.value;
      }
    }
  })))));
  var parallelFinalizers = (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
    onNone: () => self2,
    onSome: (scope) => {
      switch (scope.strategy._tag) {
        case "Parallel":
          return self2;
        case "Sequential":
        case "ParallelN":
          return flatMap8(scopeFork(scope, parallel3), (inner) => scopeExtend(self2, inner));
      }
    }
  }));
  var parallelNFinalizers = (parallelism) => (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
    onNone: () => self2,
    onSome: (scope) => {
      if (scope.strategy._tag === "ParallelN" && scope.strategy.parallelism === parallelism) {
        return self2;
      }
      return flatMap8(scopeFork(scope, parallelN2(parallelism)), (inner) => scopeExtend(self2, inner));
    }
  }));
  var finalizersMask = (strategy) => (self2) => finalizersMaskInternal(strategy, true)(self2);
  var finalizersMaskInternal = (strategy, concurrentFinalizers) => (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
    onNone: () => self2(identity),
    onSome: (scope) => {
      if (concurrentFinalizers === true) {
        const patch9 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
        switch (scope.strategy._tag) {
          case "Parallel":
            return patch9(self2(parallelFinalizers));
          case "Sequential":
            return patch9(self2(sequentialFinalizers));
          case "ParallelN":
            return patch9(self2(parallelNFinalizers(scope.strategy.parallelism)));
        }
      } else {
        return self2(identity);
      }
    }
  }));
  var scopeWith = (f) => flatMap8(scopeTag, f);
  var scopedWith = (f) => flatMap8(scopeMake(), (scope) => onExit(f(scope), (exit2) => scope.close(exit2)));
  var scopedEffect = (effect) => flatMap8(scopeMake(), (scope) => scopeUse(effect, scope));
  var sequentialFinalizers = (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
    onNone: () => self2,
    onSome: (scope) => {
      switch (scope.strategy._tag) {
        case "Sequential":
          return self2;
        case "Parallel":
        case "ParallelN":
          return flatMap8(scopeFork(scope, sequential3), (inner) => scopeExtend(self2, inner));
      }
    }
  }));
  var tagMetricsScoped = (key, value) => labelMetricsScoped([make30(key, value)]);
  var labelMetricsScoped = (labels) => fiberRefLocallyScopedWith(currentMetricLabels, (old) => union(old, labels));
  var using = /* @__PURE__ */ dual(2, (self2, use) => scopedWith((scope) => flatMap8(scopeExtend(self2, scope), use)));
  var validate = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => validateWith(self2, that, (a, b) => [a, b], options));
  var validateWith = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, f, options) => flatten6(zipWithOptions(exit(self2), exit(that), (ea, eb) => exitZipWith(ea, eb, {
    onSuccess: f,
    onFailure: (ca, cb) => options?.concurrent ? parallel(ca, cb) : sequential(ca, cb)
  }), options)));
  var validateFirst = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => flip(forEach5(elements, (a, i) => flip(f(a, i)), options)));
  var withClockScoped = (c) => fiberRefLocallyScopedWith(currentServices, add2(clockTag, c));
  var withRandomScoped = (value) => fiberRefLocallyScopedWith(currentServices, add2(randomTag, value));
  var withConfigProviderScoped = (provider) => fiberRefLocallyScopedWith(currentServices, add2(configProviderTag, provider));
  var withEarlyRelease = (self2) => scopeWith((parent) => flatMap8(scopeFork(parent, sequential2), (child) => pipe(self2, scopeExtend(child), map10((value) => [fiberIdWith((fiberId2) => scopeClose(child, exitInterrupt(fiberId2))), value]))));
  var zipOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => zipWithOptions(self2, that, (a, b) => [a, b], options));
  var zipLeftOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => {
    if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
      return zipLeft(self2, that);
    }
    return zipWithOptions(self2, that, (a, _) => a, options);
  });
  var zipRightOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => {
    if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
      return zipRight(self2, that);
    }
    return zipWithOptions(self2, that, (_, b) => b, options);
  });
  var zipWithOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, f, options) => map10(all3([self2, that], {
    concurrency: options?.concurrent ? 2 : 1,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), ([a, a2]) => f(a, a2)));
  var withRuntimeFlagsScoped = (update5) => {
    if (update5 === empty15) {
      return void_;
    }
    return pipe(runtimeFlags, flatMap8((runtimeFlags2) => {
      const updatedRuntimeFlags = patch4(runtimeFlags2, update5);
      const revertRuntimeFlags = diff4(updatedRuntimeFlags, runtimeFlags2);
      return pipe(updateRuntimeFlags(update5), zipRight(addFinalizer(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid);
    }), uninterruptible);
  };
  var scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
  var scope = scopeTag;
  var scopeUnsafeAddFinalizer = (scope2, fin) => {
    if (scope2.state._tag === "Open") {
      scope2.state.finalizers.set({}, fin);
    }
  };
  var ScopeImplProto = {
    [ScopeTypeId]: ScopeTypeId,
    [CloseableScopeTypeId]: CloseableScopeTypeId,
    pipe() {
      return pipeArguments(this, arguments);
    },
    fork(strategy) {
      return sync(() => {
        const newScope = scopeUnsafeMake(strategy);
        if (this.state._tag === "Closed") {
          newScope.state = this.state;
          return newScope;
        }
        const key = {};
        const fin = (exit2) => newScope.close(exit2);
        this.state.finalizers.set(key, fin);
        scopeUnsafeAddFinalizer(newScope, (_) => sync(() => {
          if (this.state._tag === "Open") {
            this.state.finalizers.delete(key);
          }
        }));
        return newScope;
      });
    },
    close(exit2) {
      return suspend(() => {
        if (this.state._tag === "Closed") {
          return void_;
        }
        const finalizers = Array.from(this.state.finalizers.values()).reverse();
        this.state = {
          _tag: "Closed",
          exit: exit2
        };
        if (finalizers.length === 0) {
          return void_;
        }
        return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit(fin(exit2))), flatMap8((results) => pipe(exitCollectAll(results), map2(exitAsVoid), getOrElse(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit(fin(exit2)), false), flatMap8((results) => pipe(exitCollectAll(results, {
          parallel: true
        }), map2(exitAsVoid), getOrElse(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit(fin(exit2)), false), flatMap8((results) => pipe(exitCollectAll(results, {
          parallel: true
        }), map2(exitAsVoid), getOrElse(() => exitVoid))));
      });
    },
    addFinalizer(fin) {
      return suspend(() => {
        if (this.state._tag === "Closed") {
          return fin(this.state.exit);
        }
        this.state.finalizers.set({}, fin);
        return void_;
      });
    }
  };
  var scopeUnsafeMake = (strategy = sequential2) => {
    const scope2 = Object.create(ScopeImplProto);
    scope2.strategy = strategy;
    scope2.state = {
      _tag: "Open",
      finalizers: new Map
    };
    return scope2;
  };
  var scopeMake = (strategy = sequential2) => sync(() => scopeUnsafeMake(strategy));
  var scopeExtend = /* @__PURE__ */ dual(2, (effect, scope2) => mapInputContext(effect, merge3(make5(scopeTag, scope2))));
  var scopeUse = /* @__PURE__ */ dual(2, (effect, scope2) => pipe(effect, scopeExtend(scope2), onExit((exit2) => scope2.close(exit2))));
  var fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: empty24
  });
  var fiberRefLocallyScoped = /* @__PURE__ */ dual(2, (self2, value) => asVoid(acquireRelease(flatMap8(fiberRefGet(self2), (oldValue) => as(fiberRefSet(self2, value), oldValue)), (oldValue) => fiberRefSet(self2, oldValue))));
  var fiberRefLocallyScopedWith = /* @__PURE__ */ dual(2, (self2, f) => fiberRefGetWith(self2, (a) => fiberRefLocallyScoped(self2, f(a))));
  var currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none5);
  var currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none8);
  var fiberAwaitAll = (fibers) => forEach5(fibers, _await2);
  var fiberAll = (fibers) => {
    const _fiberAll = {
      ...CommitPrototype2,
      commit() {
        return join2(this);
      },
      [FiberTypeId]: fiberVariance2,
      id: () => fromIterable(fibers).reduce((id, fiber) => combine3(id, fiber.id()), none4),
      await: exit(forEachParUnbounded(fibers, (fiber) => flatten6(fiber.await), false)),
      children: map10(forEachParUnbounded(fibers, (fiber) => fiber.children, false), flatten),
      inheritAll: forEachSequentialDiscard(fibers, (fiber) => fiber.inheritAll),
      poll: map10(forEachSequential(fibers, (fiber) => fiber.poll), reduceRight(some2(exitSucceed(new Array)), (optionB, optionA) => {
        switch (optionA._tag) {
          case "None": {
            return none2();
          }
          case "Some": {
            switch (optionB._tag) {
              case "None": {
                return none2();
              }
              case "Some": {
                return some2(exitZipWith(optionA.value, optionB.value, {
                  onSuccess: (a, chunk2) => [a, ...chunk2],
                  onFailure: parallel
                }));
              }
            }
          }
        }
      })),
      interruptAsFork: (fiberId2) => forEachSequentialDiscard(fibers, (fiber) => fiber.interruptAsFork(fiberId2))
    };
    return _fiberAll;
  };
  var raceWith = /* @__PURE__ */ dual(3, (self2, other, options) => raceFibersWith(self2, other, {
    onSelfWin: (winner, loser) => flatMap8(winner.await, (exit2) => {
      switch (exit2._tag) {
        case OP_SUCCESS: {
          return flatMap8(winner.inheritAll, () => options.onSelfDone(exit2, loser));
        }
        case OP_FAILURE: {
          return options.onSelfDone(exit2, loser);
        }
      }
    }),
    onOtherWin: (winner, loser) => flatMap8(winner.await, (exit2) => {
      switch (exit2._tag) {
        case OP_SUCCESS: {
          return flatMap8(winner.inheritAll, () => options.onOtherDone(exit2, loser));
        }
        case OP_FAILURE: {
          return options.onOtherDone(exit2, loser);
        }
      }
    })
  }));
  var disconnect = (self2) => uninterruptibleMask((restore) => fiberIdWith((fiberId2) => flatMap8(forkDaemon(restore(self2)), (fiber) => pipe(restore(join2(fiber)), onInterrupt(() => pipe(fiber, interruptAsFork(fiberId2)))))));
  var race = /* @__PURE__ */ dual(2, (self2, that) => fiberIdWith((parentFiberId) => raceWith(self2, that, {
    onSelfDone: (exit2, right3) => exitMatchEffect(exit2, {
      onFailure: (cause2) => pipe(join2(right3), mapErrorCause((cause22) => parallel(cause2, cause22))),
      onSuccess: (value) => pipe(right3, interruptAsFiber(parentFiberId), as(value))
    }),
    onOtherDone: (exit2, left3) => exitMatchEffect(exit2, {
      onFailure: (cause2) => pipe(join2(left3), mapErrorCause((cause22) => parallel(cause22, cause2))),
      onSuccess: (value) => pipe(left3, interruptAsFiber(parentFiberId), as(value))
    })
  })));
  var raceFibersWith = /* @__PURE__ */ dual(3, (self2, other, options) => withFiberRuntime((parentFiber, parentStatus) => {
    const parentRuntimeFlags = parentStatus.runtimeFlags;
    const raceIndicator = make11(true);
    const leftFiber = unsafeMakeChildFiber(self2, parentFiber, parentRuntimeFlags, options.selfScope);
    const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
    return async_((cb) => {
      leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
      rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
      leftFiber.startFork(self2);
      rightFiber.startFork(other);
    }, combine3(leftFiber.id(), rightFiber.id()));
  }));
  var completeRace = (winner, loser, cont, ab, cb) => {
    if (compareAndSet(true, false)(ab)) {
      cb(cont(winner, loser));
    }
  };
  var ensuring = /* @__PURE__ */ dual(2, (self2, finalizer) => uninterruptibleMask((restore) => matchCauseEffect(restore(self2), {
    onFailure: (cause1) => matchCauseEffect(finalizer, {
      onFailure: (cause2) => failCause(sequential(cause1, cause2)),
      onSuccess: () => failCause(cause1)
    }),
    onSuccess: (a) => as(finalizer, a)
  })));
  var invokeWithInterrupt = (self2, entries2, onInterrupt2) => fiberIdWith((id) => flatMap8(flatMap8(forkDaemon(interruptible2(self2)), (processing) => async_((cb) => {
    const counts = entries2.map((_) => _.listeners.count);
    const checkDone = () => {
      if (counts.every((count) => count === 0)) {
        if (entries2.every((_) => {
          if (_.result.state.current._tag === "Pending") {
            return true;
          } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted(_.result.state.current.effect.cause)) {
            return true;
          } else {
            return false;
          }
        })) {
          cleanup.forEach((f) => f());
          onInterrupt2?.();
          cb(interruptFiber(processing));
        }
      }
    };
    processing.addObserver((exit2) => {
      cleanup.forEach((f) => f());
      cb(exit2);
    });
    const cleanup = entries2.map((r, i) => {
      const observer = (count) => {
        counts[i] = count;
        checkDone();
      };
      r.listeners.addObserver(observer);
      return () => r.listeners.removeObserver(observer);
    });
    checkDone();
    return sync(() => {
      cleanup.forEach((f) => f());
    });
  })), () => suspend(() => {
    const residual = entries2.flatMap((entry) => {
      if (!entry.state.completed) {
        return [entry];
      }
      return [];
    });
    return forEachSequentialDiscard(residual, (entry) => complete2(entry.request, exitInterrupt(id)));
  })));
  var makeSpanScoped = (name, options) => {
    options = addSpanStackTrace(options);
    return uninterruptible(withFiberRuntime((fiber) => {
      const scope2 = unsafeGet3(fiber.getFiberRef(currentContext), scopeTag);
      const span2 = unsafeMakeSpan(fiber, name, options);
      const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
      const clock_ = get3(fiber.getFiberRef(currentServices), clockTag);
      return as(scopeAddFinalizerExit(scope2, (exit2) => endSpan(span2, exit2, clock_, timingEnabled)), span2);
    }));
  };
  var withTracerScoped = (value) => fiberRefLocallyScopedWith(currentServices, add2(tracerTag, value));
  var withSpanScoped = function() {
    const dataFirst = typeof arguments[0] !== "string";
    const name = dataFirst ? arguments[1] : arguments[0];
    const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
    if (dataFirst) {
      const self2 = arguments[0];
      return flatMap8(makeSpanScoped(name, addSpanStackTrace(options)), (span2) => provideService(self2, spanTag, span2));
    }
    return (self2) => flatMap8(makeSpanScoped(name, addSpanStackTrace(options)), (span2) => provideService(self2, spanTag, span2));
  };

  // node_modules/effect/dist/esm/internal/cache.js
  var complete3 = (key, exit2, entryStats, timeToLiveMillis) => struct({
    _tag: "Complete",
    key,
    exit: exit2,
    entryStats,
    timeToLiveMillis
  });
  var pending2 = (key, deferred) => struct({
    _tag: "Pending",
    key,
    deferred
  });
  var refreshing = (deferred, complete4) => struct({
    _tag: "Refreshing",
    deferred,
    complete: complete4
  });
  var MapKeyTypeId = /* @__PURE__ */ Symbol.for("effect/Cache/MapKey");

  class MapKeyImpl {
    current;
    [MapKeyTypeId] = MapKeyTypeId;
    previous = undefined;
    next = undefined;
    constructor(current) {
      this.current = current;
    }
    [symbol]() {
      return pipe(hash(this.current), combine(hash(this.previous)), combine(hash(this.next)), cached(this));
    }
    [symbol2](that) {
      if (this === that) {
        return true;
      }
      return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
    }
  }
  var makeMapKey = (current) => new MapKeyImpl(current);
  var isMapKey = (u) => hasProperty(u, MapKeyTypeId);

  class KeySetImpl {
    head = undefined;
    tail = undefined;
    add(key) {
      if (key !== this.tail) {
        if (this.tail === undefined) {
          this.head = key;
          this.tail = key;
        } else {
          const previous = key.previous;
          const next = key.next;
          if (next !== undefined) {
            key.next = undefined;
            if (previous !== undefined) {
              previous.next = next;
              next.previous = previous;
            } else {
              this.head = next;
              this.head.previous = undefined;
            }
          }
          this.tail.next = key;
          key.previous = this.tail;
          this.tail = key;
        }
      }
    }
    remove() {
      const key = this.head;
      if (key !== undefined) {
        const next = key.next;
        if (next !== undefined) {
          key.next = undefined;
          this.head = next;
          this.head.previous = undefined;
        } else {
          this.head = undefined;
          this.tail = undefined;
        }
      }
      return key;
    }
  }
  var makeKeySet = () => new KeySetImpl;
  var makeCacheState = (map12, keys3, accesses, updating, hits, misses) => ({
    map: map12,
    keys: keys3,
    accesses,
    updating,
    hits,
    misses
  });
  var initialCacheState = () => makeCacheState(empty18(), makeKeySet(), unbounded(), make11(false), 0, 0);
  var CacheSymbolKey = "effect/Cache";
  var CacheTypeId = /* @__PURE__ */ Symbol.for(CacheSymbolKey);
  var cacheVariance = {
    _Key: (_) => _,
    _Error: (_) => _,
    _Value: (_) => _
  };
  var ConsumerCacheSymbolKey = "effect/ConsumerCache";
  var ConsumerCacheTypeId = /* @__PURE__ */ Symbol.for(ConsumerCacheSymbolKey);
  var consumerCacheVariance = {
    _Key: (_) => _,
    _Error: (_) => _,
    _Value: (_) => _
  };
  var makeCacheStats = (options) => options;
  var makeEntryStats = (loadedMillis) => ({
    loadedMillis
  });

  class CacheImpl {
    capacity;
    context;
    fiberId;
    lookup;
    timeToLive;
    [CacheTypeId] = cacheVariance;
    [ConsumerCacheTypeId] = consumerCacheVariance;
    cacheState;
    constructor(capacity2, context2, fiberId2, lookup, timeToLive) {
      this.capacity = capacity2;
      this.context = context2;
      this.fiberId = fiberId2;
      this.lookup = lookup;
      this.timeToLive = timeToLive;
      this.cacheState = initialCacheState();
    }
    get(key) {
      return map10(this.getEither(key), merge);
    }
    get cacheStats() {
      return sync(() => makeCacheStats({
        hits: this.cacheState.hits,
        misses: this.cacheState.misses,
        size: size4(this.cacheState.map)
      }));
    }
    getOption(key) {
      return suspend(() => match2(get8(this.cacheState.map, key), {
        onNone: () => {
          const mapKey = makeMapKey(key);
          this.trackAccess(mapKey);
          this.trackMiss();
          return succeed(none2());
        },
        onSome: (value) => this.resolveMapValue(value)
      }));
    }
    getOptionComplete(key) {
      return suspend(() => match2(get8(this.cacheState.map, key), {
        onNone: () => {
          const mapKey = makeMapKey(key);
          this.trackAccess(mapKey);
          this.trackMiss();
          return succeed(none2());
        },
        onSome: (value) => this.resolveMapValue(value, true)
      }));
    }
    contains(key) {
      return sync(() => has4(this.cacheState.map, key));
    }
    entryStats(key) {
      return sync(() => {
        const option2 = get8(this.cacheState.map, key);
        if (isSome2(option2)) {
          switch (option2.value._tag) {
            case "Complete": {
              const loaded = option2.value.entryStats.loadedMillis;
              return some2(makeEntryStats(loaded));
            }
            case "Pending": {
              return none2();
            }
            case "Refreshing": {
              const loaded = option2.value.complete.entryStats.loadedMillis;
              return some2(makeEntryStats(loaded));
            }
          }
        }
        return none2();
      });
    }
    getEither(key) {
      return suspend(() => {
        const k = key;
        let mapKey = undefined;
        let deferred = undefined;
        let value = getOrUndefined(get8(this.cacheState.map, k));
        if (value === undefined) {
          deferred = unsafeMake4(this.fiberId);
          mapKey = makeMapKey(k);
          if (has4(this.cacheState.map, k)) {
            value = getOrUndefined(get8(this.cacheState.map, k));
          } else {
            set4(this.cacheState.map, k, pending2(mapKey, deferred));
          }
        }
        if (value === undefined) {
          this.trackAccess(mapKey);
          this.trackMiss();
          return map10(this.lookupValueOf(key, deferred), right2);
        } else {
          return flatMap8(this.resolveMapValue(value), match2({
            onNone: () => this.getEither(key),
            onSome: (value2) => succeed(left2(value2))
          }));
        }
      });
    }
    invalidate(key) {
      return sync(() => {
        remove5(this.cacheState.map, key);
      });
    }
    invalidateWhen(key, when2) {
      return sync(() => {
        const value = get8(this.cacheState.map, key);
        if (isSome2(value) && value.value._tag === "Complete") {
          if (value.value.exit._tag === "Success") {
            if (when2(value.value.exit.value)) {
              remove5(this.cacheState.map, key);
            }
          }
        }
      });
    }
    get invalidateAll() {
      return sync(() => {
        this.cacheState.map = empty18();
      });
    }
    refresh(key) {
      return clockWith3((clock2) => suspend(() => {
        const k = key;
        const deferred = unsafeMake4(this.fiberId);
        let value = getOrUndefined(get8(this.cacheState.map, k));
        if (value === undefined) {
          if (has4(this.cacheState.map, k)) {
            value = getOrUndefined(get8(this.cacheState.map, k));
          } else {
            set4(this.cacheState.map, k, pending2(makeMapKey(k), deferred));
          }
        }
        if (value === undefined) {
          return asVoid(this.lookupValueOf(key, deferred));
        } else {
          switch (value._tag) {
            case "Complete": {
              if (this.hasExpired(clock2, value.timeToLiveMillis)) {
                const found = getOrUndefined(get8(this.cacheState.map, k));
                if (equals(found, value)) {
                  remove5(this.cacheState.map, k);
                }
                return asVoid(this.get(key));
              }
              return pipe(this.lookupValueOf(key, deferred), when(() => {
                const current = getOrUndefined(get8(this.cacheState.map, k));
                if (equals(current, value)) {
                  const mapValue = refreshing(deferred, value);
                  set4(this.cacheState.map, k, mapValue);
                  return true;
                }
                return false;
              }), asVoid);
            }
            case "Pending": {
              return _await(value.deferred);
            }
            case "Refreshing": {
              return _await(value.deferred);
            }
          }
        }
      }));
    }
    set(key, value) {
      return clockWith3((clock2) => sync(() => {
        const now = clock2.unsafeCurrentTimeMillis();
        const k = key;
        const lookupResult = succeed3(value);
        const mapValue = complete3(makeMapKey(k), lookupResult, makeEntryStats(now), now + toMillis(decode(this.timeToLive(lookupResult))));
        set4(this.cacheState.map, k, mapValue);
      }));
    }
    get size() {
      return sync(() => {
        return size4(this.cacheState.map);
      });
    }
    get values() {
      return sync(() => {
        const values3 = [];
        for (const entry of this.cacheState.map) {
          if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
            values3.push(entry[1].exit.value);
          }
        }
        return values3;
      });
    }
    get entries() {
      return sync(() => {
        const values3 = [];
        for (const entry of this.cacheState.map) {
          if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
            values3.push([entry[0], entry[1].exit.value]);
          }
        }
        return values3;
      });
    }
    get keys() {
      return sync(() => {
        const keys3 = [];
        for (const entry of this.cacheState.map) {
          if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
            keys3.push(entry[0]);
          }
        }
        return keys3;
      });
    }
    resolveMapValue(value, ignorePending = false) {
      return clockWith3((clock2) => {
        switch (value._tag) {
          case "Complete": {
            this.trackAccess(value.key);
            if (this.hasExpired(clock2, value.timeToLiveMillis)) {
              remove5(this.cacheState.map, value.key.current);
              return succeed(none2());
            }
            this.trackHit();
            return map10(value.exit, some2);
          }
          case "Pending": {
            this.trackAccess(value.key);
            this.trackHit();
            if (ignorePending) {
              return succeed(none2());
            }
            return map10(_await(value.deferred), some2);
          }
          case "Refreshing": {
            this.trackAccess(value.complete.key);
            this.trackHit();
            if (this.hasExpired(clock2, value.complete.timeToLiveMillis)) {
              if (ignorePending) {
                return succeed(none2());
              }
              return map10(_await(value.deferred), some2);
            }
            return map10(value.complete.exit, some2);
          }
        }
      });
    }
    trackHit() {
      this.cacheState.hits = this.cacheState.hits + 1;
    }
    trackMiss() {
      this.cacheState.misses = this.cacheState.misses + 1;
    }
    trackAccess(key) {
      offer(this.cacheState.accesses, key);
      if (compareAndSet(this.cacheState.updating, false, true)) {
        let loop2 = true;
        while (loop2) {
          const key2 = poll2(this.cacheState.accesses, EmptyMutableQueue);
          if (key2 === EmptyMutableQueue) {
            loop2 = false;
          } else {
            this.cacheState.keys.add(key2);
          }
        }
        let size5 = size4(this.cacheState.map);
        loop2 = size5 > this.capacity;
        while (loop2) {
          const key2 = this.cacheState.keys.remove();
          if (key2 !== undefined) {
            if (has4(this.cacheState.map, key2.current)) {
              remove5(this.cacheState.map, key2.current);
              size5 = size5 - 1;
              loop2 = size5 > this.capacity;
            }
          } else {
            loop2 = false;
          }
        }
        set2(this.cacheState.updating, false);
      }
    }
    hasExpired(clock2, timeToLiveMillis) {
      return clock2.unsafeCurrentTimeMillis() > timeToLiveMillis;
    }
    lookupValueOf(input, deferred) {
      return clockWith3((clock2) => suspend(() => {
        const key = input;
        return pipe(this.lookup(input), provideContext(this.context), exit, flatMap8((exit2) => {
          const now = clock2.unsafeCurrentTimeMillis();
          const stats = makeEntryStats(now);
          const value = complete3(makeMapKey(key), exit2, stats, now + toMillis(decode(this.timeToLive(exit2))));
          set4(this.cacheState.map, key, value);
          return zipRight(done2(deferred, exit2), exit2);
        }), onInterrupt(() => zipRight(interrupt3(deferred), sync(() => {
          remove5(this.cacheState.map, key);
        }))));
      }));
    }
  }
  var unsafeMakeWith = (capacity2, lookup, timeToLive) => new CacheImpl(capacity2, empty4(), none3, lookup, (exit2) => decode(timeToLive(exit2)));
  // node_modules/effect/dist/esm/Cause.js
  var empty25 = empty17;
  var fail5 = fail;
  var die4 = die;
  var interrupt5 = interrupt;
  var parallel4 = parallel;
  var sequential4 = sequential;
  var isCause2 = isCause;
  var isFailType2 = isFailType;
  var isDieType2 = isDieType;
  var isInterrupted2 = isInterrupted;
  var isInterruptedOnly2 = isInterruptedOnly;
  var interruptors2 = interruptors;
  var failureOrCause2 = failureOrCause;
  var flipCauseOption2 = flipCauseOption;
  var map12 = map9;
  var squash = causeSquash;
  var reduceWithContext2 = reduceWithContext;
  var IllegalArgumentException2 = IllegalArgumentException;
  var NoSuchElementException2 = NoSuchElementException;
  var RuntimeException2 = RuntimeException;
  var isRuntimeException2 = isRuntimeException;
  var pretty2 = pretty;
  // node_modules/effect/dist/esm/Effect.js
  var exports_Effect = {};
  __export(exports_Effect, {
    zipWith: () => zipWith5,
    zipRight: () => zipRight3,
    zipLeft: () => zipLeft2,
    zip: () => zip5,
    yieldNow: () => yieldNow4,
    withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel2,
    withTracerTiming: () => withTracerTiming2,
    withTracerScoped: () => withTracerScoped2,
    withTracerEnabled: () => withTracerEnabled2,
    withTracer: () => withTracer2,
    withSpanScoped: () => withSpanScoped2,
    withSpan: () => withSpan3,
    withSchedulingPriority: () => withSchedulingPriority2,
    withScheduler: () => withScheduler2,
    withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped,
    withRuntimeFlagsPatch: () => withRuntimeFlagsPatch,
    withRequestCaching: () => withRequestCaching2,
    withRequestCache: () => withRequestCache2,
    withRequestBatching: () => withRequestBatching2,
    withRandomScoped: () => withRandomScoped2,
    withRandomFixed: () => withRandomFixed,
    withRandom: () => withRandom2,
    withParentSpan: () => withParentSpan3,
    withMetric: () => withMetric2,
    withMaxOpsBeforeYield: () => withMaxOpsBeforeYield2,
    withLogSpan: () => withLogSpan2,
    withFiberRuntime: () => withFiberRuntime2,
    withExecutionPlan: () => withExecutionPlan2,
    withEarlyRelease: () => withEarlyRelease2,
    withConsoleScoped: () => withConsoleScoped2,
    withConsole: () => withConsole2,
    withConfigProviderScoped: () => withConfigProviderScoped2,
    withConfigProvider: () => withConfigProvider2,
    withConcurrency: () => withConcurrency2,
    withClockScoped: () => withClockScoped2,
    withClock: () => withClock2,
    whileLoop: () => whileLoop2,
    whenRef: () => whenRef2,
    whenLogLevel: () => whenLogLevel2,
    whenFiberRef: () => whenFiberRef2,
    whenEffect: () => whenEffect2,
    when: () => when2,
    void: () => _void,
    validateWith: () => validateWith2,
    validateFirst: () => validateFirst2,
    validateAll: () => validateAll2,
    validate: () => validate2,
    using: () => using2,
    useSpan: () => useSpan2,
    updateService: () => updateService2,
    updateFiberRefs: () => updateFiberRefs2,
    unsandbox: () => unsandbox2,
    unsafeMakeSemaphore: () => unsafeMakeSemaphore2,
    unsafeMakeLatch: () => unsafeMakeLatch2,
    unlessEffect: () => unlessEffect2,
    unless: () => unless2,
    uninterruptibleMask: () => uninterruptibleMask3,
    uninterruptible: () => uninterruptible2,
    tryPromise: () => tryPromise2,
    tryMapPromise: () => tryMapPromise2,
    tryMap: () => tryMap2,
    try: () => try_2,
    transposeOption: () => transposeOption,
    transposeMapOption: () => transposeMapOption,
    transplant: () => transplant2,
    tracerWith: () => tracerWith4,
    tracer: () => tracer2,
    timeoutTo: () => timeoutTo2,
    timeoutOption: () => timeoutOption2,
    timeoutFailCause: () => timeoutFailCause2,
    timeoutFail: () => timeoutFail2,
    timeout: () => timeout2,
    timedWith: () => timedWith2,
    timed: () => timed2,
    tapErrorTag: () => tapErrorTag2,
    tapErrorCause: () => tapErrorCause3,
    tapError: () => tapError3,
    tapDefect: () => tapDefect2,
    tapBoth: () => tapBoth2,
    tap: () => tap3,
    takeWhile: () => takeWhile3,
    takeUntil: () => takeUntil2,
    tagMetricsScoped: () => tagMetricsScoped2,
    tagMetrics: () => tagMetrics2,
    sync: () => sync3,
    suspend: () => suspend3,
    supervised: () => supervised2,
    summarized: () => summarized2,
    succeedSome: () => succeedSome2,
    succeedNone: () => succeedNone2,
    succeed: () => succeed8,
    step: () => step3,
    spanLinks: () => spanLinks2,
    spanAnnotations: () => spanAnnotations2,
    sleep: () => sleep4,
    setFiberRefs: () => setFiberRefs2,
    serviceOptional: () => serviceOptional2,
    serviceOption: () => serviceOption2,
    serviceMembers: () => serviceMembers2,
    serviceFunctions: () => serviceFunctions2,
    serviceFunctionEffect: () => serviceFunctionEffect2,
    serviceFunction: () => serviceFunction2,
    serviceConstants: () => serviceConstants2,
    sequentialFinalizers: () => sequentialFinalizers2,
    scopedWith: () => scopedWith2,
    scoped: () => scoped2,
    scopeWith: () => scopeWith2,
    scope: () => scope3,
    scheduleFrom: () => scheduleFrom,
    scheduleForked: () => scheduleForked2,
    schedule: () => schedule,
    sandbox: () => sandbox2,
    runtime: () => runtime4,
    runSyncExit: () => runSyncExit,
    runSync: () => runSync,
    runRequestBlock: () => runRequestBlock2,
    runPromiseExit: () => runPromiseExit,
    runPromise: () => runPromise,
    runFork: () => runFork2,
    runCallback: () => runCallback,
    retryOrElse: () => retryOrElse,
    retry: () => retry2,
    request: () => request,
    replicateEffect: () => replicateEffect2,
    replicate: () => replicate2,
    repeatOrElse: () => repeatOrElse,
    repeatN: () => repeatN2,
    repeat: () => repeat,
    reduceWhile: () => reduceWhile2,
    reduceRight: () => reduceRight4,
    reduceEffect: () => reduceEffect2,
    reduce: () => reduce10,
    randomWith: () => randomWith2,
    random: () => random3,
    raceWith: () => raceWith2,
    raceFirst: () => raceFirst2,
    raceAll: () => raceAll2,
    race: () => race2,
    provideServiceEffect: () => provideServiceEffect2,
    provideService: () => provideService2,
    provide: () => provide2,
    promise: () => promise2,
    patchRuntimeFlags: () => patchRuntimeFlags,
    patchFiberRefs: () => patchFiberRefs2,
    partition: () => partition4,
    parallelFinalizers: () => parallelFinalizers2,
    parallelErrors: () => parallelErrors2,
    orElseSucceed: () => orElseSucceed2,
    orElseFail: () => orElseFail2,
    orElse: () => orElse5,
    orDieWith: () => orDieWith2,
    orDie: () => orDie3,
    optionFromOptional: () => optionFromOptional2,
    option: () => option2,
    once: () => once3,
    onInterrupt: () => onInterrupt2,
    onExit: () => onExit3,
    onError: () => onError2,
    none: () => none9,
    never: () => never3,
    negate: () => negate2,
    metricLabels: () => metricLabels2,
    mergeAll: () => mergeAll5,
    merge: () => merge7,
    matchEffect: () => matchEffect2,
    matchCauseEffect: () => matchCauseEffect3,
    matchCause: () => matchCause3,
    match: () => match12,
    mapInputContext: () => mapInputContext2,
    mapErrorCause: () => mapErrorCause2,
    mapError: () => mapError3,
    mapBoth: () => mapBoth4,
    mapAccum: () => mapAccum4,
    map: () => map16,
    makeSpanScoped: () => makeSpanScoped2,
    makeSpan: () => makeSpan2,
    makeSemaphore: () => makeSemaphore2,
    makeLatch: () => makeLatch2,
    loop: () => loop2,
    logWithLevel: () => logWithLevel2,
    logWarning: () => logWarning2,
    logTrace: () => logTrace2,
    logInfo: () => logInfo2,
    logFatal: () => logFatal2,
    logError: () => logError2,
    logDebug: () => logDebug2,
    logAnnotations: () => logAnnotations2,
    log: () => log2,
    locallyWith: () => locallyWith,
    locallyScopedWith: () => locallyScopedWith,
    locallyScoped: () => locallyScoped,
    locally: () => locally,
    linkSpans: () => linkSpans2,
    linkSpanCurrent: () => linkSpanCurrent2,
    liftPredicate: () => liftPredicate2,
    let: () => let_3,
    labelMetricsScoped: () => labelMetricsScoped2,
    labelMetrics: () => labelMetrics2,
    iterate: () => iterate2,
    isSuccess: () => isSuccess3,
    isFailure: () => isFailure4,
    isEffect: () => isEffect2,
    intoDeferred: () => intoDeferred2,
    interruptibleMask: () => interruptibleMask2,
    interruptible: () => interruptible4,
    interruptWith: () => interruptWith2,
    interrupt: () => interrupt7,
    inheritFiberRefs: () => inheritFiberRefs2,
    ignoreLogged: () => ignoreLogged2,
    ignore: () => ignore2,
    if: () => if_2,
    head: () => head4,
    getRuntimeFlags: () => getRuntimeFlags,
    getFiberRefs: () => getFiberRefs,
    gen: () => gen2,
    functionWithSpan: () => functionWithSpan2,
    fromNullable: () => fromNullable3,
    fromFiberEffect: () => fromFiberEffect2,
    fromFiber: () => fromFiber2,
    forkWithErrorHandler: () => forkWithErrorHandler2,
    forkScoped: () => forkScoped2,
    forkIn: () => forkIn2,
    forkDaemon: () => forkDaemon2,
    forkAll: () => forkAll2,
    fork: () => fork3,
    forever: () => forever3,
    forEach: () => forEach6,
    fnUntraced: () => fnUntraced2,
    fn: () => fn,
    flipWith: () => flipWith2,
    flip: () => flip2,
    flatten: () => flatten9,
    flatMap: () => flatMap11,
    firstSuccessOf: () => firstSuccessOf2,
    findFirst: () => findFirst6,
    finalizersMask: () => finalizersMask2,
    filterOrFail: () => filterOrFail2,
    filterOrElse: () => filterOrElse2,
    filterOrDieMessage: () => filterOrDieMessage2,
    filterOrDie: () => filterOrDie2,
    filterMap: () => filterMap6,
    filterEffectOrFail: () => filterEffectOrFail2,
    filterEffectOrElse: () => filterEffectOrElse2,
    filter: () => filter8,
    fiberIdWith: () => fiberIdWith2,
    fiberId: () => fiberId2,
    failSync: () => failSync3,
    failCauseSync: () => failCauseSync3,
    failCause: () => failCause8,
    fail: () => fail9,
    exit: () => exit2,
    exists: () => exists3,
    every: () => every6,
    eventually: () => eventually2,
    ensuringChildren: () => ensuringChildren2,
    ensuringChild: () => ensuringChild2,
    ensuring: () => ensuring2,
    ensureSuccessType: () => ensureSuccessType,
    ensureRequirementsType: () => ensureRequirementsType,
    ensureErrorType: () => ensureErrorType,
    either: () => either3,
    dropWhile: () => dropWhile3,
    dropUntil: () => dropUntil2,
    disconnect: () => disconnect2,
    diffFiberRefs: () => diffFiberRefs2,
    dieSync: () => dieSync3,
    dieMessage: () => dieMessage2,
    die: () => die6,
    descriptorWith: () => descriptorWith2,
    descriptor: () => descriptor2,
    delay: () => delay2,
    daemonChildren: () => daemonChildren2,
    custom: () => custom2,
    currentSpan: () => currentSpan2,
    currentParentSpan: () => currentParentSpan2,
    contextWithEffect: () => contextWithEffect2,
    contextWith: () => contextWith2,
    context: () => context3,
    consoleWith: () => consoleWith2,
    console: () => console3,
    configProviderWith: () => configProviderWith2,
    clockWith: () => clockWith4,
    clock: () => clock2,
    checkInterruptible: () => checkInterruptible2,
    cause: () => cause2,
    catchTags: () => catchTags2,
    catchTag: () => catchTag2,
    catchSomeDefect: () => catchSomeDefect2,
    catchSomeCause: () => catchSomeCause2,
    catchSome: () => catchSome2,
    catchIf: () => catchIf2,
    catchAllDefect: () => catchAllDefect2,
    catchAllCause: () => catchAllCause3,
    catchAll: () => catchAll3,
    catch: () => _catch2,
    cachedWithTTL: () => cachedWithTTL,
    cachedInvalidateWithTTL: () => cachedInvalidateWithTTL2,
    cachedFunction: () => cachedFunction2,
    cached: () => cached3,
    cacheRequestResult: () => cacheRequestResult,
    blocked: () => blocked2,
    bindTo: () => bindTo3,
    bindAll: () => bindAll2,
    bind: () => bind3,
    awaitAllChildren: () => awaitAllChildren2,
    asyncEffect: () => asyncEffect2,
    async: () => async,
    asVoid: () => asVoid3,
    asSomeError: () => asSomeError2,
    asSome: () => asSome2,
    as: () => as3,
    ap: () => ap,
    annotateSpans: () => annotateSpans3,
    annotateLogsScoped: () => annotateLogsScoped2,
    annotateLogs: () => annotateLogs3,
    annotateCurrentSpan: () => annotateCurrentSpan2,
    andThen: () => andThen4,
    allowInterrupt: () => allowInterrupt2,
    allWith: () => allWith2,
    allSuccesses: () => allSuccesses2,
    all: () => all4,
    addFinalizer: () => addFinalizer3,
    acquireUseRelease: () => acquireUseRelease2,
    acquireReleaseInterruptible: () => acquireReleaseInterruptible2,
    acquireRelease: () => acquireRelease2,
    Tag: () => Tag3,
    Service: () => Service,
    EffectTypeId: () => EffectTypeId3,
    Do: () => Do2
  });

  // node_modules/effect/dist/esm/internal/schedule/interval.js
  var IntervalSymbolKey = "effect/ScheduleInterval";
  var IntervalTypeId = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
  var empty26 = {
    [IntervalTypeId]: IntervalTypeId,
    startMillis: 0,
    endMillis: 0
  };
  var make35 = (startMillis, endMillis) => {
    if (startMillis > endMillis) {
      return empty26;
    }
    return {
      [IntervalTypeId]: IntervalTypeId,
      startMillis,
      endMillis
    };
  };
  var lessThan2 = /* @__PURE__ */ dual(2, (self2, that) => min2(self2, that) === self2);
  var min2 = /* @__PURE__ */ dual(2, (self2, that) => {
    if (self2.endMillis <= that.startMillis)
      return self2;
    if (that.endMillis <= self2.startMillis)
      return that;
    if (self2.startMillis < that.startMillis)
      return self2;
    if (that.startMillis < self2.startMillis)
      return that;
    if (self2.endMillis <= that.endMillis)
      return self2;
    return that;
  });
  var isEmpty8 = (self2) => {
    return self2.startMillis >= self2.endMillis;
  };
  var intersect = /* @__PURE__ */ dual(2, (self2, that) => {
    const start = Math.max(self2.startMillis, that.startMillis);
    const end = Math.min(self2.endMillis, that.endMillis);
    return make35(start, end);
  });
  var size6 = (self2) => {
    return millis(self2.endMillis - self2.startMillis);
  };
  var after = (startMilliseconds) => {
    return make35(startMilliseconds, Number.POSITIVE_INFINITY);
  };

  // node_modules/effect/dist/esm/ScheduleInterval.js
  var make36 = make35;
  var empty27 = empty26;
  var lessThan3 = lessThan2;
  var isEmpty9 = isEmpty8;
  var intersect2 = intersect;
  var size7 = size6;
  var after2 = after;

  // node_modules/effect/dist/esm/internal/schedule/intervals.js
  var IntervalsSymbolKey = "effect/ScheduleIntervals";
  var IntervalsTypeId = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
  var make37 = (intervals) => {
    return {
      [IntervalsTypeId]: IntervalsTypeId,
      intervals
    };
  };
  var intersect3 = /* @__PURE__ */ dual(2, (self2, that) => intersectLoop(self2.intervals, that.intervals, empty5()));
  var intersectLoop = (_left, _right, _acc) => {
    let left3 = _left;
    let right3 = _right;
    let acc = _acc;
    while (isNonEmpty2(left3) && isNonEmpty2(right3)) {
      const interval = pipe(headNonEmpty2(left3), intersect2(headNonEmpty2(right3)));
      const intervals = isEmpty9(interval) ? acc : pipe(acc, prepend2(interval));
      if (pipe(headNonEmpty2(left3), lessThan3(headNonEmpty2(right3)))) {
        left3 = tailNonEmpty2(left3);
      } else {
        right3 = tailNonEmpty2(right3);
      }
      acc = intervals;
    }
    return make37(reverse2(acc));
  };
  var start = (self2) => {
    return pipe(self2.intervals, head2, getOrElse(() => empty27)).startMillis;
  };
  var end = (self2) => {
    return pipe(self2.intervals, head2, getOrElse(() => empty27)).endMillis;
  };
  var lessThan4 = /* @__PURE__ */ dual(2, (self2, that) => start(self2) < start(that));
  var isNonEmpty4 = (self2) => {
    return isNonEmpty2(self2.intervals);
  };

  // node_modules/effect/dist/esm/ScheduleIntervals.js
  var make38 = make37;
  var intersect4 = intersect3;
  var start2 = start;
  var end2 = end;
  var lessThan5 = lessThan4;
  var isNonEmpty5 = isNonEmpty4;

  // node_modules/effect/dist/esm/internal/schedule/decision.js
  var OP_CONTINUE = "Continue";
  var OP_DONE2 = "Done";
  var _continue = (intervals) => {
    return {
      _tag: OP_CONTINUE,
      intervals
    };
  };
  var continueWith = (interval) => {
    return {
      _tag: OP_CONTINUE,
      intervals: make38(of2(interval))
    };
  };
  var done5 = {
    _tag: OP_DONE2
  };
  var isContinue = (self2) => {
    return self2._tag === OP_CONTINUE;
  };
  var isDone4 = (self2) => {
    return self2._tag === OP_DONE2;
  };

  // node_modules/effect/dist/esm/ScheduleDecision.js
  var _continue2 = _continue;
  var continueWith2 = continueWith;
  var done6 = done5;
  var isContinue2 = isContinue;
  var isDone5 = isDone4;

  // node_modules/effect/dist/esm/Scope.js
  var Scope = scopeTag;
  var addFinalizer2 = scopeAddFinalizer;
  var addFinalizerExit = scopeAddFinalizerExit;
  var close = scopeClose;
  var extend2 = scopeExtend;
  var fork2 = scopeFork;
  var make39 = scopeMake;

  // node_modules/effect/dist/esm/internal/effect/circular.js
  class Semaphore {
    permits;
    waiters = /* @__PURE__ */ new Set;
    taken = 0;
    constructor(permits) {
      this.permits = permits;
    }
    get free() {
      return this.permits - this.taken;
    }
    take = (n) => asyncInterrupt((resume2) => {
      if (this.free < n) {
        const observer = () => {
          if (this.free < n) {
            return;
          }
          this.waiters.delete(observer);
          this.taken += n;
          resume2(succeed(n));
        };
        this.waiters.add(observer);
        return sync(() => {
          this.waiters.delete(observer);
        });
      }
      this.taken += n;
      return resume2(succeed(n));
    });
    updateTakenUnsafe(fiber, f) {
      this.taken = f(this.taken);
      if (this.waiters.size > 0) {
        fiber.getFiberRef(currentScheduler).scheduleTask(() => {
          const iter = this.waiters.values();
          let item = iter.next();
          while (item.done === false && this.free > 0) {
            item.value();
            item = iter.next();
          }
        }, fiber.getFiberRef(currentSchedulingPriority));
      }
      return succeed(this.free);
    }
    updateTaken(f) {
      return withFiberRuntime((fiber) => this.updateTakenUnsafe(fiber, f));
    }
    resize = (permits) => asVoid(withFiberRuntime((fiber) => {
      this.permits = permits;
      if (this.free < 0) {
        return void_;
      }
      return this.updateTakenUnsafe(fiber, (taken) => taken);
    }));
    release = (n) => this.updateTaken((taken) => taken - n);
    releaseAll = /* @__PURE__ */ this.updateTaken((_) => 0);
    withPermits = (n) => (self2) => uninterruptibleMask((restore) => flatMap8(restore(this.take(n)), (permits) => ensuring(restore(self2), this.release(permits))));
    withPermitsIfAvailable = (n) => (self2) => uninterruptibleMask((restore) => suspend(() => {
      if (this.free < n) {
        return succeedNone;
      }
      this.taken += n;
      return ensuring(restore(asSome(self2)), this.release(n));
    }));
  }
  var unsafeMakeSemaphore = (permits) => new Semaphore(permits);
  var makeSemaphore = (permits) => sync(() => unsafeMakeSemaphore(permits));

  class Latch extends Class {
    isOpen;
    waiters = [];
    scheduled = false;
    constructor(isOpen) {
      super();
      this.isOpen = isOpen;
    }
    commit() {
      return this.await;
    }
    unsafeSchedule(fiber) {
      if (this.scheduled || this.waiters.length === 0) {
        return void_;
      }
      this.scheduled = true;
      fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
      return void_;
    }
    flushWaiters = () => {
      this.scheduled = false;
      const waiters = this.waiters;
      this.waiters = [];
      for (let i = 0;i < waiters.length; i++) {
        waiters[i](exitVoid);
      }
    };
    open = /* @__PURE__ */ withFiberRuntime((fiber) => {
      if (this.isOpen) {
        return void_;
      }
      this.isOpen = true;
      return this.unsafeSchedule(fiber);
    });
    unsafeOpen() {
      if (this.isOpen)
        return;
      this.isOpen = true;
      this.flushWaiters();
    }
    release = /* @__PURE__ */ withFiberRuntime((fiber) => {
      if (this.isOpen) {
        return void_;
      }
      return this.unsafeSchedule(fiber);
    });
    await = /* @__PURE__ */ asyncInterrupt((resume2) => {
      if (this.isOpen) {
        return resume2(void_);
      }
      this.waiters.push(resume2);
      return sync(() => {
        const index = this.waiters.indexOf(resume2);
        if (index !== -1) {
          this.waiters.splice(index, 1);
        }
      });
    });
    unsafeClose() {
      this.isOpen = false;
    }
    close = /* @__PURE__ */ sync(() => {
      this.isOpen = false;
    });
    whenOpen = (self2) => {
      return zipRight(this.await, self2);
    };
  }
  var unsafeMakeLatch = (open) => new Latch(open ?? false);
  var makeLatch = (open) => sync(() => unsafeMakeLatch(open));
  var awaitAllChildren = (self2) => ensuringChildren(self2, fiberAwaitAll);
  var cached2 = /* @__PURE__ */ dual(2, (self2, timeToLive) => map10(cachedInvalidateWithTTL(self2, timeToLive), (tuple) => tuple[0]));
  var cachedInvalidateWithTTL = /* @__PURE__ */ dual(2, (self2, timeToLive) => {
    const duration = decode(timeToLive);
    return flatMap8(context(), (env) => map10(makeSynchronized(none2()), (cache) => [provideContext(getCachedValue(self2, duration, cache), env), invalidateCache(cache)]));
  });
  var computeCachedValue = (self2, timeToLive, start3) => {
    const timeToLiveMillis = toMillis(decode(timeToLive));
    return pipe(deferredMake(), tap((deferred) => intoDeferred(self2, deferred)), map10((deferred) => some2([start3 + timeToLiveMillis, deferred])));
  };
  var getCachedValue = (self2, timeToLive, cache) => uninterruptibleMask((restore) => pipe(clockWith3((clock2) => clock2.currentTimeMillis), flatMap8((time) => updateSomeAndGetEffectSynchronized(cache, (option2) => {
    switch (option2._tag) {
      case "None": {
        return some2(computeCachedValue(self2, timeToLive, time));
      }
      case "Some": {
        const [end3] = option2.value;
        return end3 - time <= 0 ? some2(computeCachedValue(self2, timeToLive, time)) : none2();
      }
    }
  })), flatMap8((option2) => isNone2(option2) ? dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option2.value[1])))));
  var invalidateCache = (cache) => set5(cache, none2());
  var ensuringChild = /* @__PURE__ */ dual(2, (self2, f) => ensuringChildren(self2, (children) => f(fiberAll(children))));
  var ensuringChildren = /* @__PURE__ */ dual(2, (self2, children) => flatMap8(track, (supervisor) => pipe(supervised(self2, supervisor), ensuring(flatMap8(supervisor.value, children)))));
  var forkAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (effects, options) => options?.discard ? forEachSequentialDiscard(effects, fork) : map10(forEachSequential(effects, fork), fiberAll));
  var forkIn = /* @__PURE__ */ dual(2, (self2, scope2) => withFiberRuntime((parent, parentStatus) => {
    const scopeImpl = scope2;
    const fiber = unsafeFork(self2, parent, parentStatus.runtimeFlags, globalScope);
    if (scopeImpl.state._tag === "Open") {
      const finalizer = () => fiberIdWith((fiberId2) => equals(fiberId2, fiber.id()) ? void_ : asVoid(interruptFiber(fiber)));
      const key = {};
      scopeImpl.state.finalizers.set(key, finalizer);
      fiber.addObserver(() => {
        if (scopeImpl.state._tag === "Closed")
          return;
        scopeImpl.state.finalizers.delete(key);
      });
    } else {
      fiber.unsafeInterruptAsFork(parent.id());
    }
    return succeed(fiber);
  }));
  var forkScoped = (self2) => scopeWith((scope2) => forkIn(self2, scope2));
  var fromFiber = (fiber) => join2(fiber);
  var fromFiberEffect = (fiber) => suspend(() => flatMap8(fiber, join2));
  var memoKeySymbol = /* @__PURE__ */ Symbol.for("effect/Effect/memoizeFunction.key");

  class Key {
    a;
    eq;
    [memoKeySymbol] = memoKeySymbol;
    constructor(a, eq) {
      this.a = a;
      this.eq = eq;
    }
    [symbol2](that) {
      if (hasProperty(that, memoKeySymbol)) {
        if (this.eq) {
          return this.eq(this.a, that.a);
        } else {
          return equals(this.a, that.a);
        }
      }
      return false;
    }
    [symbol]() {
      return this.eq ? 0 : cached(this, hash(this.a));
    }
  }
  var cachedFunction = (f, eq) => {
    return pipe(sync(() => empty18()), flatMap8(makeSynchronized), map10((ref) => (a) => pipe(ref.modifyEffect((map13) => {
      const result = pipe(map13, get8(new Key(a, eq)));
      if (isNone2(result)) {
        return pipe(deferredMake(), tap((deferred) => pipe(diffFiberRefs(f(a)), intoDeferred(deferred), fork)), map10((deferred) => [deferred, pipe(map13, set4(new Key(a, eq), deferred))]));
      }
      return succeed([result.value, map13]);
    }), flatMap8(deferredAwait), flatMap8(([patch9, b]) => pipe(patchFiberRefs(patch9), as(b))))));
  };
  var raceFirst = /* @__PURE__ */ dual(2, (self2, that) => pipe(exit(self2), race(exit(that)), (effect) => flatten6(effect)));
  var supervised = /* @__PURE__ */ dual(2, (self2, supervisor) => {
    const supervise = fiberRefLocallyWith(currentSupervisor, (s) => s.zip(supervisor));
    return supervise(self2);
  });
  var timeout = /* @__PURE__ */ dual(2, (self2, duration) => timeoutFail(self2, {
    onTimeout: () => timeoutExceptionFromDuration(duration),
    duration
  }));
  var timeoutFail = /* @__PURE__ */ dual(2, (self2, {
    duration,
    onTimeout
  }) => flatten6(timeoutTo(self2, {
    onTimeout: () => failSync(onTimeout),
    onSuccess: succeed,
    duration
  })));
  var timeoutFailCause = /* @__PURE__ */ dual(2, (self2, {
    duration,
    onTimeout
  }) => flatten6(timeoutTo(self2, {
    onTimeout: () => failCauseSync(onTimeout),
    onSuccess: succeed,
    duration
  })));
  var timeoutOption = /* @__PURE__ */ dual(2, (self2, duration) => timeoutTo(self2, {
    duration,
    onSuccess: some2,
    onTimeout: none2
  }));
  var timeoutTo = /* @__PURE__ */ dual(2, (self2, {
    duration,
    onSuccess,
    onTimeout
  }) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self2), interruptible2(sleep3(duration)), {
    onSelfWin: (winner, loser) => flatMap8(winner.await, (exit2) => {
      if (exit2._tag === "Success") {
        return flatMap8(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onSuccess(exit2.value)));
      } else {
        return flatMap8(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit2.cause));
      }
    }),
    onOtherWin: (winner, loser) => flatMap8(winner.await, (exit2) => {
      if (exit2._tag === "Success") {
        return flatMap8(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onTimeout()));
      } else {
        return flatMap8(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit2.cause));
      }
    }),
    otherScope: globalScope
  }))));
  var SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
  var SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
  var synchronizedVariance = {
    _A: (_) => _
  };

  class SynchronizedImpl extends Class {
    ref;
    withLock;
    [SynchronizedTypeId] = synchronizedVariance;
    [RefTypeId] = refVariance;
    [TypeId12] = TypeId12;
    constructor(ref, withLock) {
      super();
      this.ref = ref;
      this.withLock = withLock;
      this.get = get11(this.ref);
    }
    get;
    commit() {
      return this.get;
    }
    modify(f) {
      return this.modifyEffect((a) => succeed(f(a)));
    }
    modifyEffect(f) {
      return this.withLock(pipe(flatMap8(get11(this.ref), f), flatMap8(([b, a]) => as(set5(this.ref, a), b))));
    }
  }
  var makeSynchronized = (value) => sync(() => unsafeMakeSynchronized(value));
  var unsafeMakeSynchronized = (value) => {
    const ref = unsafeMake6(value);
    const sem = unsafeMakeSemaphore(1);
    return new SynchronizedImpl(ref, sem.withPermits(1));
  };
  var updateSomeAndGetEffectSynchronized = /* @__PURE__ */ dual(2, (self2, pf) => self2.modifyEffect((value) => {
    const result = pf(value);
    switch (result._tag) {
      case "None": {
        return succeed([value, value]);
      }
      case "Some": {
        return map10(result.value, (a) => [a, a]);
      }
    }
  }));
  var bindAll = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, f, options) => flatMap8(self2, (a) => all3(f(a), options).pipe(map10((record2) => Object.assign({}, a, record2)))));

  // node_modules/effect/dist/esm/internal/managedRuntime/circular.js
  var TypeId14 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");

  // node_modules/effect/dist/esm/internal/opCodes/layer.js
  var OP_EXTEND_SCOPE = "ExtendScope";
  var OP_FOLD = "Fold";
  var OP_FRESH = "Fresh";
  var OP_FROM_EFFECT = "FromEffect";
  var OP_SCOPED = "Scoped";
  var OP_SUSPEND = "Suspend";
  var OP_PROVIDE = "Provide";
  var OP_PROVIDE_MERGE = "ProvideMerge";
  var OP_MERGE_ALL = "MergeAll";
  var OP_ZIP_WITH2 = "ZipWith";

  // node_modules/effect/dist/esm/Fiber.js
  var _await3 = _await2;
  var inheritAll2 = inheritAll;
  var interrupt6 = interruptFiber;
  var interruptAs = interruptAsFiber;
  var interruptAllAs2 = interruptAllAs;
  var join3 = join2;
  var poll4 = poll3;

  // node_modules/effect/dist/esm/internal/runtime.js
  var makeDual = (f) => function() {
    if (arguments.length === 1) {
      const runtime3 = arguments[0];
      return (effect, ...args2) => f(runtime3, effect, ...args2);
    }
    return f.apply(this, arguments);
  };
  var unsafeFork2 = /* @__PURE__ */ makeDual((runtime3, self2, options) => {
    const fiberId2 = unsafeMake3();
    const fiberRefUpdates = [[currentContext, [[fiberId2, runtime3.context]]]];
    if (options?.scheduler) {
      fiberRefUpdates.push([currentScheduler, [[fiberId2, options.scheduler]]]);
    }
    let fiberRefs3 = updateManyAs2(runtime3.fiberRefs, {
      entries: fiberRefUpdates,
      forkAs: fiberId2
    });
    if (options?.updateRefs) {
      fiberRefs3 = options.updateRefs(fiberRefs3, fiberId2);
    }
    const fiberRuntime = new FiberRuntime(fiberId2, fiberRefs3, runtime3.runtimeFlags);
    let effect = self2;
    if (options?.scope) {
      effect = flatMap8(fork2(options.scope, sequential2), (closeableScope) => zipRight(scopeAddFinalizer(closeableScope, fiberIdWith((id2) => equals(id2, fiberRuntime.id()) ? void_ : interruptAsFiber(fiberRuntime, id2))), onExit(self2, (exit2) => close(closeableScope, exit2))));
    }
    const supervisor = fiberRuntime.currentSupervisor;
    if (supervisor !== none8) {
      supervisor.onStart(runtime3.context, effect, none2(), fiberRuntime);
      fiberRuntime.addObserver((exit2) => supervisor.onEnd(exit2, fiberRuntime));
    }
    globalScope.add(runtime3.runtimeFlags, fiberRuntime);
    if (options?.immediate === false) {
      fiberRuntime.resume(effect);
    } else {
      fiberRuntime.start(effect);
    }
    return fiberRuntime;
  });
  var unsafeRunCallback = /* @__PURE__ */ makeDual((runtime3, effect, options = {}) => {
    const fiberRuntime = unsafeFork2(runtime3, effect, options);
    if (options.onExit) {
      fiberRuntime.addObserver((exit2) => {
        options.onExit(exit2);
      });
    }
    return (id2, cancelOptions) => unsafeRunCallback(runtime3)(pipe(fiberRuntime, interruptAs(id2 ?? none4)), {
      ...cancelOptions,
      onExit: cancelOptions?.onExit ? (exit2) => cancelOptions.onExit(flatten7(exit2)) : undefined
    });
  });
  var unsafeRunSync = /* @__PURE__ */ makeDual((runtime3, effect) => {
    const result = unsafeRunSyncExit(runtime3)(effect);
    if (result._tag === "Failure") {
      throw fiberFailure(result.effect_instruction_i0);
    }
    return result.effect_instruction_i0;
  });

  class AsyncFiberExceptionImpl extends Error {
    fiber;
    _tag = "AsyncFiberException";
    constructor(fiber) {
      super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
      this.fiber = fiber;
      this.name = this._tag;
      this.stack = this.message;
    }
  }
  var asyncFiberException = (fiber) => {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    const error = new AsyncFiberExceptionImpl(fiber);
    Error.stackTraceLimit = limit;
    return error;
  };
  var FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
  var FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");

  class FiberFailureImpl extends Error {
    [FiberFailureId];
    [FiberFailureCauseId];
    constructor(cause2) {
      const head4 = prettyErrors(cause2)[0];
      super(head4?.message || "An error has occurred");
      this[FiberFailureId] = FiberFailureId;
      this[FiberFailureCauseId] = cause2;
      this.name = head4 ? `(FiberFailure) ${head4.name}` : "FiberFailure";
      if (head4?.stack) {
        this.stack = head4.stack;
      }
    }
    toJSON() {
      return {
        _id: "FiberFailure",
        cause: this[FiberFailureCauseId].toJSON()
      };
    }
    toString() {
      return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
        renderErrorCause: true
      });
    }
    [NodeInspectSymbol]() {
      return this.toString();
    }
  }
  var fiberFailure = (cause2) => {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    const error = new FiberFailureImpl(cause2);
    Error.stackTraceLimit = limit;
    return error;
  };
  var fastPath = (effect) => {
    const op = effect;
    switch (op._op) {
      case "Failure":
      case "Success": {
        return op;
      }
      case "Left": {
        return exitFail(op.left);
      }
      case "Right": {
        return exitSucceed(op.right);
      }
      case "Some": {
        return exitSucceed(op.value);
      }
      case "None": {
        return exitFail(NoSuchElementException());
      }
    }
  };
  var unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime3, effect) => {
    const op = fastPath(effect);
    if (op) {
      return op;
    }
    const scheduler = new SyncScheduler;
    const fiberRuntime = unsafeFork2(runtime3)(effect, {
      scheduler
    });
    scheduler.flush();
    const result = fiberRuntime.unsafePoll();
    if (result) {
      return result;
    }
    return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
  });
  var unsafeRunPromise = /* @__PURE__ */ makeDual((runtime3, effect, options) => unsafeRunPromiseExit(runtime3, effect, options).then((result) => {
    switch (result._tag) {
      case OP_SUCCESS: {
        return result.effect_instruction_i0;
      }
      case OP_FAILURE: {
        throw fiberFailure(result.effect_instruction_i0);
      }
    }
  }));
  var unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime3, effect, options) => new Promise((resolve) => {
    const op = fastPath(effect);
    if (op) {
      resolve(op);
    }
    const fiber = unsafeFork2(runtime3)(effect);
    fiber.addObserver((exit2) => {
      resolve(exit2);
    });
    if (options?.signal !== undefined) {
      if (options.signal.aborted) {
        fiber.unsafeInterruptAsFork(fiber.id());
      } else {
        options.signal.addEventListener("abort", () => {
          fiber.unsafeInterruptAsFork(fiber.id());
        }, {
          once: true
        });
      }
    }
  }));

  class RuntimeImpl {
    context;
    runtimeFlags;
    fiberRefs;
    constructor(context2, runtimeFlags2, fiberRefs3) {
      this.context = context2;
      this.runtimeFlags = runtimeFlags2;
      this.fiberRefs = fiberRefs3;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var make40 = (options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
  var runtime3 = () => withFiberRuntime((state, status2) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status2.runtimeFlags, state.getFiberRefs())));
  var defaultRuntimeFlags = /* @__PURE__ */ make17(Interruption, CooperativeYielding, RuntimeMetrics);
  var defaultRuntime = /* @__PURE__ */ make40({
    context: /* @__PURE__ */ empty4(),
    runtimeFlags: defaultRuntimeFlags,
    fiberRefs: /* @__PURE__ */ empty22()
  });
  var updateContext2 = /* @__PURE__ */ dual(2, (self2, f) => make40({
    context: f(self2.context),
    runtimeFlags: self2.runtimeFlags,
    fiberRefs: self2.fiberRefs
  }));
  var unsafeRunEffect = /* @__PURE__ */ unsafeRunCallback(defaultRuntime);
  var unsafeForkEffect = /* @__PURE__ */ unsafeFork2(defaultRuntime);
  var unsafeRunPromiseEffect = /* @__PURE__ */ unsafeRunPromise(defaultRuntime);
  var unsafeRunPromiseExitEffect = /* @__PURE__ */ unsafeRunPromiseExit(defaultRuntime);
  var unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);
  var unsafeRunSyncExitEffect = /* @__PURE__ */ unsafeRunSyncExit(defaultRuntime);
  var asyncEffect = (register) => suspend(() => {
    let cleanup = undefined;
    return flatMap8(deferredMake(), (deferred) => flatMap8(runtime3(), (runtime4) => uninterruptibleMask((restore) => zipRight(fork(restore(matchCauseEffect(register((cb) => unsafeRunCallback(runtime4)(intoDeferred(cb, deferred))), {
      onFailure: (cause2) => deferredFailCause(deferred, cause2),
      onSuccess: (cleanup_) => {
        cleanup = cleanup_;
        return void_;
      }
    }))), restore(onInterrupt(deferredAwait(deferred), () => cleanup ?? void_))))));
  });

  // node_modules/effect/dist/esm/internal/synchronizedRef.js
  var modifyEffect = /* @__PURE__ */ dual(2, (self2, f) => self2.modifyEffect(f));

  // node_modules/effect/dist/esm/internal/layer.js
  var LayerSymbolKey = "effect/Layer";
  var LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
  var layerVariance = {
    _RIn: (_) => _,
    _E: (_) => _,
    _ROut: (_) => _
  };
  var proto3 = {
    [LayerTypeId]: layerVariance,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var MemoMapTypeIdKey = "effect/Layer/MemoMap";
  var MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
  var CurrentMemoMap = /* @__PURE__ */ Reference2()("effect/Layer/CurrentMemoMap", {
    defaultValue: () => unsafeMakeMemoMap()
  });
  var isLayer = (u) => hasProperty(u, LayerTypeId);
  var isFresh = (self2) => {
    return self2._op_layer === OP_FRESH;
  };

  class MemoMapImpl {
    ref;
    [MemoMapTypeId];
    constructor(ref) {
      this.ref = ref;
      this[MemoMapTypeId] = MemoMapTypeId;
    }
    getOrElseMemoize(layer, scope2) {
      return pipe(modifyEffect(this.ref, (map14) => {
        const inMap = map14.get(layer);
        if (inMap !== undefined) {
          const [acquire, release] = inMap;
          const cached3 = pipe(acquire, flatMap8(([patch9, b]) => pipe(patchFiberRefs(patch9), as(b))), onExit(exitMatch({
            onFailure: () => void_,
            onSuccess: () => scopeAddFinalizerExit(scope2, release)
          })));
          return succeed([cached3, map14]);
        }
        return pipe(make28(0), flatMap8((observers) => pipe(deferredMake(), flatMap8((deferred) => pipe(make28(() => void_), map10((finalizerRef) => {
          const resource = uninterruptibleMask((restore) => pipe(scopeMake(), flatMap8((innerScope) => pipe(restore(flatMap8(makeBuilder(layer, innerScope, true), (f) => diffFiberRefs(f(this)))), exit, flatMap8((exit2) => {
            switch (exit2._tag) {
              case OP_FAILURE: {
                return pipe(deferredFailCause(deferred, exit2.effect_instruction_i0), zipRight(scopeClose(innerScope, exit2)), zipRight(failCause(exit2.effect_instruction_i0)));
              }
              case OP_SUCCESS: {
                return pipe(set5(finalizerRef, (exit3) => pipe(scopeClose(innerScope, exit3), whenEffect(modify3(observers, (n) => [n === 1, n - 1])), asVoid)), zipRight(update2(observers, (n) => n + 1)), zipRight(scopeAddFinalizerExit(scope2, (exit3) => pipe(sync(() => map14.delete(layer)), zipRight(get11(finalizerRef)), flatMap8((finalizer) => finalizer(exit3))))), zipRight(deferredSucceed(deferred, exit2.effect_instruction_i0)), as(exit2.effect_instruction_i0[1]));
              }
            }
          })))));
          const memoized = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
            onFailure: () => void_,
            onSuccess: () => update2(observers, (n) => n + 1)
          }))), (exit2) => pipe(get11(finalizerRef), flatMap8((finalizer) => finalizer(exit2)))];
          return [resource, isFresh(layer) ? map14 : map14.set(layer, memoized)];
        }))))));
      }), flatten6);
    }
  }
  var makeMemoMap = /* @__PURE__ */ suspend(() => map10(makeSynchronized(new Map), (ref) => new MemoMapImpl(ref)));
  var unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(new Map));
  var build = (self2) => scopeWith((scope2) => buildWithScope(self2, scope2));
  var buildWithScope = /* @__PURE__ */ dual(2, (self2, scope2) => flatMap8(makeMemoMap, (memoMap) => buildWithMemoMap(self2, memoMap, scope2)));
  var buildWithMemoMap = /* @__PURE__ */ dual(3, (self2, memoMap, scope2) => flatMap8(makeBuilder(self2, scope2), (run) => provideService(run(memoMap), CurrentMemoMap, memoMap)));
  var makeBuilder = (self2, scope2, inMemoMap = false) => {
    const op = self2;
    switch (op._op_layer) {
      case "Locally": {
        return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope2)));
      }
      case "ExtendScope": {
        return sync(() => (memoMap) => scopeWith((scope3) => memoMap.getOrElseMemoize(op.layer, scope3)));
      }
      case "Fold": {
        return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope2), matchCauseEffect({
          onFailure: (cause2) => memoMap.getOrElseMemoize(op.failureK(cause2), scope2),
          onSuccess: (value) => memoMap.getOrElseMemoize(op.successK(value), scope2)
        })));
      }
      case "Fresh": {
        return sync(() => (_) => pipe(op.layer, buildWithScope(scope2)));
      }
      case "FromEffect": {
        return inMemoMap ? sync(() => (_) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope2));
      }
      case "Provide": {
        return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), flatMap8((env) => pipe(memoMap.getOrElseMemoize(op.second, scope2), provideContext(env)))));
      }
      case "Scoped": {
        return inMemoMap ? sync(() => (_) => scopeExtend(op.effect, scope2)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope2));
      }
      case "Suspend": {
        return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope2));
      }
      case "ProvideMerge": {
        return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), zipWith3(memoMap.getOrElseMemoize(op.second, scope2), op.zipK)));
      }
      case "ZipWith": {
        return gen(function* () {
          const parallelScope = yield* scopeFork(scope2, parallel2);
          const firstScope = yield* scopeFork(parallelScope, sequential2);
          const secondScope = yield* scopeFork(parallelScope, sequential2);
          return (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, firstScope), zipWithOptions(memoMap.getOrElseMemoize(op.second, secondScope), op.zipK, {
            concurrent: true
          }));
        });
      }
      case "MergeAll": {
        const layers = op.layers;
        return map10(scopeFork(scope2, parallel2), (parallelScope) => (memoMap) => {
          const contexts = new Array(layers.length);
          return map10(forEachConcurrentDiscard(layers, fnUntraced(function* (layer, i) {
            const scope3 = yield* scopeFork(parallelScope, sequential2);
            const context2 = yield* memoMap.getOrElseMemoize(layer, scope3);
            contexts[i] = context2;
          }), false, false), () => mergeAll2(...contexts));
        });
      }
    }
  };
  var catchAll2 = /* @__PURE__ */ dual(2, (self2, onFailure) => match11(self2, {
    onFailure,
    onSuccess: succeedContext
  }));
  var catchAllCause2 = /* @__PURE__ */ dual(2, (self2, onFailure) => matchCause2(self2, {
    onFailure,
    onSuccess: succeedContext
  }));
  var die5 = (defect) => failCause6(die4(defect));
  var dieSync2 = (evaluate2) => failCauseSync2(() => die4(evaluate2()));
  var discard = (self2) => map14(self2, () => empty4());
  var context2 = () => fromEffectContext(context());
  var extendScope = (self2) => {
    const extendScope2 = Object.create(proto3);
    extendScope2._op_layer = OP_EXTEND_SCOPE;
    extendScope2.layer = self2;
    return extendScope2;
  };
  var fail7 = (error) => failCause6(fail5(error));
  var failSync2 = (evaluate2) => failCauseSync2(() => fail5(evaluate2()));
  var failCause6 = (cause2) => fromEffectContext(failCause(cause2));
  var failCauseSync2 = (evaluate2) => fromEffectContext(failCauseSync(evaluate2));
  var flatMap10 = /* @__PURE__ */ dual(2, (self2, f) => match11(self2, {
    onFailure: fail7,
    onSuccess: f
  }));
  var flatten8 = /* @__PURE__ */ dual(2, (self2, tag) => flatMap10(self2, get3(tag)));
  var fresh = (self2) => {
    const fresh2 = Object.create(proto3);
    fresh2._op_layer = OP_FRESH;
    fresh2.layer = self2;
    return fresh2;
  };
  var fromEffect3 = /* @__PURE__ */ dual(2, (a, b) => {
    const tagFirst = isTag2(a);
    const tag = tagFirst ? a : b;
    const effect = tagFirst ? b : a;
    return fromEffectContext(map10(effect, (service) => make5(tag, service)));
  });
  var fromEffectDiscard = (effect) => fromEffectContext(map10(effect, () => empty4()));
  function fromEffectContext(effect) {
    const fromEffect4 = Object.create(proto3);
    fromEffect4._op_layer = OP_FROM_EFFECT;
    fromEffect4.effect = effect;
    return fromEffect4;
  }
  var fiberRefLocally2 = /* @__PURE__ */ dual(3, (self2, ref, value) => locallyEffect(self2, fiberRefLocally(ref, value)));
  var locallyEffect = /* @__PURE__ */ dual(2, (self2, f) => {
    const locally = Object.create(proto3);
    locally._op_layer = "Locally";
    locally.self = self2;
    locally.f = f;
    return locally;
  });
  var fiberRefLocallyWith2 = /* @__PURE__ */ dual(3, (self2, ref, value) => locallyEffect(self2, fiberRefLocallyWith(ref, value)));
  var fiberRefLocallyScoped2 = (self2, value) => scopedDiscard(fiberRefLocallyScoped(self2, value));
  var fiberRefLocallyScopedWith2 = (self2, value) => scopedDiscard(fiberRefLocallyScopedWith(self2, value));
  var fromFunction = (tagA, tagB, f) => fromEffectContext(map10(tagA, (a) => make5(tagB, f(a))));
  var launch = (self2) => scopedEffect(zipRight(scopeWith((scope2) => pipe(self2, buildWithScope(scope2))), never));
  var mock = function() {
    if (arguments.length === 1) {
      return (service) => mockImpl(arguments[0], service);
    }
    return mockImpl(arguments[0], arguments[1]);
  };
  var mockImpl = (tag, service) => succeed6(tag, new Proxy({
    ...service
  }, {
    get(target, prop, _receiver) {
      if (prop in target) {
        return target[prop];
      }
      const prevLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const error = new Error(`${tag.key}: Unimplemented method "${prop.toString()}"`);
      Error.stackTraceLimit = prevLimit;
      error.name = "UnimplementedError";
      return makeUnimplemented(error);
    },
    has: constTrue
  }));
  var makeUnimplemented = (error) => {
    const dead = die2(error);
    function unimplemented() {
      return dead;
    }
    Object.assign(unimplemented, dead);
    Object.setPrototypeOf(unimplemented, Object.getPrototypeOf(dead));
    return unimplemented;
  };
  var map14 = /* @__PURE__ */ dual(2, (self2, f) => flatMap10(self2, (context3) => succeedContext(f(context3))));
  var mapError2 = /* @__PURE__ */ dual(2, (self2, f) => catchAll2(self2, (error) => failSync2(() => f(error))));
  var matchCause2 = /* @__PURE__ */ dual(2, (self2, {
    onFailure,
    onSuccess
  }) => {
    const fold = Object.create(proto3);
    fold._op_layer = OP_FOLD;
    fold.layer = self2;
    fold.failureK = onFailure;
    fold.successK = onSuccess;
    return fold;
  });
  var match11 = /* @__PURE__ */ dual(2, (self2, {
    onFailure,
    onSuccess
  }) => matchCause2(self2, {
    onFailure: (cause2) => {
      const failureOrCause3 = failureOrCause2(cause2);
      switch (failureOrCause3._tag) {
        case "Left": {
          return onFailure(failureOrCause3.left);
        }
        case "Right": {
          return failCause6(failureOrCause3.right);
        }
      }
    },
    onSuccess
  }));
  var memoize2 = (self2) => scopeWith((scope2) => map10(memoize(buildWithScope(self2, scope2)), fromEffectContext));
  var merge6 = /* @__PURE__ */ dual(2, (self2, that) => zipWith4(self2, that, (a, b) => merge3(a, b)));
  var mergeAll4 = (...layers) => {
    const mergeAll5 = Object.create(proto3);
    mergeAll5._op_layer = OP_MERGE_ALL;
    mergeAll5.layers = layers;
    return mergeAll5;
  };
  var orDie2 = (self2) => catchAll2(self2, (defect) => die5(defect));
  var orElse4 = /* @__PURE__ */ dual(2, (self2, that) => catchAll2(self2, that));
  var passthrough = (self2) => merge6(context2(), self2);
  var project = /* @__PURE__ */ dual(4, (self2, tagA, tagB, f) => map14(self2, (context3) => make5(tagB, f(unsafeGet3(context3, tagA)))));
  var retry = /* @__PURE__ */ dual(2, (self2, schedule) => suspend2(() => {
    const stateTag = GenericTag("effect/Layer/retry/{ state: unknown }");
    return pipe(succeed6(stateTag, {
      state: schedule.initial
    }), flatMap10((env) => retryLoop(self2, schedule, stateTag, pipe(env, get3(stateTag)).state)));
  }));
  var retryLoop = (self2, schedule, stateTag, state) => {
    return pipe(self2, catchAll2((error) => pipe(retryUpdate(schedule, stateTag, error, state), flatMap10((env) => fresh(retryLoop(self2, schedule, stateTag, pipe(env, get3(stateTag)).state))))));
  };
  var retryUpdate = (schedule, stateTag, error, state) => {
    return fromEffect3(stateTag, pipe(currentTimeMillis2, flatMap8((now) => pipe(schedule.step(now, error, state), flatMap8(([state2, _, decision]) => isDone5(decision) ? fail2(error) : pipe(sleep2(millis(start2(decision.intervals) - now)), as({
      state: state2
    })))))));
  };
  var scoped = /* @__PURE__ */ dual(2, (a, b) => {
    const tagFirst = isTag2(a);
    const tag = tagFirst ? a : b;
    const effect = tagFirst ? b : a;
    return scopedContext(map10(effect, (service) => make5(tag, service)));
  });
  var scopedDiscard = (effect) => scopedContext(pipe(effect, as(empty4())));
  var scopedContext = (effect) => {
    const scoped2 = Object.create(proto3);
    scoped2._op_layer = OP_SCOPED;
    scoped2.effect = effect;
    return scoped2;
  };
  var scope2 = /* @__PURE__ */ scopedContext(/* @__PURE__ */ map10(/* @__PURE__ */ acquireRelease(/* @__PURE__ */ scopeMake(), (scope3, exit2) => scope3.close(exit2)), (scope3) => make5(Scope, scope3)));
  var service = (tag) => fromEffect3(tag, tag);
  var succeed6 = /* @__PURE__ */ dual(2, (a, b) => {
    const tagFirst = isTag2(a);
    const tag = tagFirst ? a : b;
    const resource = tagFirst ? b : a;
    return fromEffectContext(succeed(make5(tag, resource)));
  });
  var succeedContext = (context3) => {
    return fromEffectContext(succeed(context3));
  };
  var empty29 = /* @__PURE__ */ succeedContext(/* @__PURE__ */ empty4());
  var suspend2 = (evaluate2) => {
    const suspend3 = Object.create(proto3);
    suspend3._op_layer = OP_SUSPEND;
    suspend3.evaluate = evaluate2;
    return suspend3;
  };
  var sync2 = /* @__PURE__ */ dual(2, (a, b) => {
    const tagFirst = isTag2(a);
    const tag = tagFirst ? a : b;
    const evaluate2 = tagFirst ? b : a;
    return fromEffectContext(sync(() => make5(tag, evaluate2())));
  });
  var syncContext = (evaluate2) => {
    return fromEffectContext(sync(evaluate2));
  };
  var tap2 = /* @__PURE__ */ dual(2, (self2, f) => flatMap10(self2, (context3) => fromEffectContext(as(f(context3), context3))));
  var tapError2 = /* @__PURE__ */ dual(2, (self2, f) => catchAll2(self2, (e) => fromEffectContext(flatMap8(f(e), () => fail2(e)))));
  var tapErrorCause2 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause2(self2, (cause2) => fromEffectContext(flatMap8(f(cause2), () => failCause(cause2)))));
  var toRuntime = (self2) => pipe(scopeWith((scope3) => buildWithScope(self2, scope3)), flatMap8((context3) => pipe(runtime3(), provideContext(context3))));
  var toRuntimeWithMemoMap = /* @__PURE__ */ dual(2, (self2, memoMap) => flatMap8(scopeWith((scope3) => buildWithMemoMap(self2, memoMap, scope3)), (context3) => pipe(runtime3(), provideContext(context3))));
  var provide = /* @__PURE__ */ dual(2, (self2, that) => suspend2(() => {
    const provideTo = Object.create(proto3);
    provideTo._op_layer = OP_PROVIDE;
    provideTo.first = Object.create(proto3, {
      _op_layer: {
        value: OP_PROVIDE_MERGE,
        enumerable: true
      },
      first: {
        value: context2(),
        enumerable: true
      },
      second: {
        value: Array.isArray(that) ? mergeAll4(...that) : that
      },
      zipK: {
        value: (a, b) => pipe(a, merge3(b))
      }
    });
    provideTo.second = self2;
    return provideTo;
  }));
  var provideMerge = /* @__PURE__ */ dual(2, (that, self2) => {
    const zipWith4 = Object.create(proto3);
    zipWith4._op_layer = OP_PROVIDE_MERGE;
    zipWith4.first = self2;
    zipWith4.second = provide(that, self2);
    zipWith4.zipK = (a, b) => {
      return pipe(a, merge3(b));
    };
    return zipWith4;
  });
  var zipWith4 = /* @__PURE__ */ dual(3, (self2, that, f) => suspend2(() => {
    const zipWith5 = Object.create(proto3);
    zipWith5._op_layer = OP_ZIP_WITH2;
    zipWith5.first = self2;
    zipWith5.second = that;
    zipWith5.zipK = f;
    return zipWith5;
  }));
  var unwrapEffect = (self2) => {
    const tag = GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
    return flatMap10(fromEffect3(tag, self2), (context3) => get3(context3, tag));
  };
  var unwrapScoped = (self2) => {
    const tag = GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
    return flatMap10(scoped(tag, self2), (context3) => get3(context3, tag));
  };
  var annotateLogs2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
    const args2 = arguments;
    return fiberRefLocallyWith2(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations2) => Object.entries(args2[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
  });
  var annotateSpans2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
    const args2 = arguments;
    return fiberRefLocallyWith2(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations2) => Object.entries(args2[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
  });
  var withSpan2 = function() {
    const dataFirst = typeof arguments[0] !== "string";
    const name = dataFirst ? arguments[1] : arguments[0];
    const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
    if (dataFirst) {
      const self2 = arguments[0];
      return unwrapScoped(map10(options?.onEnd ? tap(makeSpanScoped(name, options), (span2) => addFinalizer((exit2) => options.onEnd(span2, exit2))) : makeSpanScoped(name, options), (span2) => withParentSpan2(self2, span2)));
    }
    return (self2) => unwrapScoped(map10(options?.onEnd ? tap(makeSpanScoped(name, options), (span2) => addFinalizer((exit2) => options.onEnd(span2, exit2))) : makeSpanScoped(name, options), (span2) => withParentSpan2(self2, span2)));
  };
  var withParentSpan2 = /* @__PURE__ */ dual(2, (self2, span2) => provide(self2, succeedContext(make5(spanTag, span2))));
  var provideSomeLayer = /* @__PURE__ */ dual(2, (self2, layer) => scopedWith((scope3) => flatMap8(buildWithScope(layer, scope3), (context3) => provideSomeContext(self2, context3))));
  var provideSomeRuntime = /* @__PURE__ */ dual(2, (self2, rt) => {
    const patchRefs = diff6(defaultRuntime.fiberRefs, rt.fiberRefs);
    const patchFlags = diff4(defaultRuntime.runtimeFlags, rt.runtimeFlags);
    return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
      const oldContext = fiber.getFiberRef(currentContext);
      const oldRefs = fiber.getFiberRefs();
      const newRefs = patch7(fiber.id(), oldRefs)(patchRefs);
      const oldFlags = fiber.currentRuntimeFlags;
      const newFlags = patch4(patchFlags)(oldFlags);
      const rollbackRefs = diff6(newRefs, oldRefs);
      const rollbackFlags = diff4(newFlags, oldFlags);
      fiber.setFiberRefs(newRefs);
      fiber.currentRuntimeFlags = newFlags;
      return ensuring(provideSomeContext(restore(self2), merge3(oldContext, rt.context)), withFiberRuntime((fiber2) => {
        fiber2.setFiberRefs(patch7(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
        fiber2.currentRuntimeFlags = patch4(rollbackFlags)(fiber2.currentRuntimeFlags);
        return void_;
      }));
    }));
  });
  var effect_provide = /* @__PURE__ */ dual(2, (self2, source) => {
    if (Array.isArray(source)) {
      return provideSomeLayer(self2, mergeAll4(...source));
    } else if (isLayer(source)) {
      return provideSomeLayer(self2, source);
    } else if (isContext2(source)) {
      return provideSomeContext(self2, source);
    } else if (TypeId14 in source) {
      return flatMap8(source.runtimeEffect, (rt) => provideSomeRuntime(self2, rt));
    } else {
      return provideSomeRuntime(self2, source);
    }
  });

  // node_modules/effect/dist/esm/internal/console.js
  var console2 = /* @__PURE__ */ map10(/* @__PURE__ */ fiberRefGet(currentServices), /* @__PURE__ */ get3(consoleTag));
  var consoleWith = (f) => fiberRefGetWith(currentServices, (services) => f(get3(services, consoleTag)));
  var withConsole = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(effect, currentServices, add2(consoleTag, value)));
  var withConsoleScoped = (console3) => fiberRefLocallyScopedWith(currentServices, add2(consoleTag, console3));

  // node_modules/effect/dist/esm/Data.js
  var struct2 = struct;
  var tagged2 = (tag) => (args2) => {
    const value = args2 === undefined ? Object.create(StructuralPrototype) : struct2(args2);
    value._tag = tag;
    return value;
  };
  var Error3 = /* @__PURE__ */ function() {
    const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
    const O = {
      BaseEffectError: class extends YieldableError {
        constructor(args2) {
          super(args2?.message, args2?.cause ? {
            cause: args2.cause
          } : undefined);
          if (args2) {
            Object.assign(this, args2);
            Object.defineProperty(this, plainArgsSymbol, {
              value: args2,
              enumerable: false
            });
          }
        }
        toJSON() {
          return {
            ...this[plainArgsSymbol],
            ...this
          };
        }
      }
    };
    return O.BaseEffectError;
  }();
  var TaggedError = (tag) => {
    const O = {
      BaseEffectError: class extends Error3 {
        _tag = tag;
      }
    };
    O.BaseEffectError.prototype.name = tag;
    return O.BaseEffectError;
  };

  // node_modules/effect/dist/esm/Random.js
  var fixed2 = fixed;

  // node_modules/effect/dist/esm/internal/schedule.js
  var ScheduleSymbolKey = "effect/Schedule";
  var ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
  var isSchedule = (u) => hasProperty(u, ScheduleTypeId);
  var ScheduleDriverSymbolKey = "effect/ScheduleDriver";
  var ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
  var defaultIterationMetadata = {
    start: 0,
    now: 0,
    input: undefined,
    output: undefined,
    elapsed: zero,
    elapsedSincePrevious: zero,
    recurrence: 0
  };
  var CurrentIterationMetadata = /* @__PURE__ */ Reference2()("effect/Schedule/CurrentIterationMetadata", {
    defaultValue: () => defaultIterationMetadata
  });
  var scheduleVariance = {
    _Out: (_) => _,
    _In: (_) => _,
    _R: (_) => _
  };
  var scheduleDriverVariance = {
    _Out: (_) => _,
    _In: (_) => _,
    _R: (_) => _
  };

  class ScheduleImpl {
    initial;
    step;
    [ScheduleTypeId] = scheduleVariance;
    constructor(initial, step3) {
      this.initial = initial;
      this.step = step3;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var updateInfo = (iterationMetaRef, now, input, output) => update2(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
    now,
    input,
    output,
    recurrence: prev.recurrence + 1,
    elapsed: zero,
    elapsedSincePrevious: zero,
    start: now
  } : {
    now,
    input,
    output,
    recurrence: prev.recurrence + 1,
    elapsed: millis(now - prev.start),
    elapsedSincePrevious: millis(now - prev.now),
    start: prev.start
  });

  class ScheduleDriverImpl {
    schedule;
    ref;
    [ScheduleDriverTypeId] = scheduleDriverVariance;
    constructor(schedule, ref) {
      this.schedule = schedule;
      this.ref = ref;
    }
    get state() {
      return map10(get11(this.ref), (tuple) => tuple[1]);
    }
    get last() {
      return flatMap8(get11(this.ref), ([element, _]) => {
        switch (element._tag) {
          case "None": {
            return failSync(() => new NoSuchElementException);
          }
          case "Some": {
            return succeed(element.value);
          }
        }
      });
    }
    iterationMeta = /* @__PURE__ */ unsafeMake6(defaultIterationMetadata);
    get reset() {
      return set5(this.ref, [none2(), this.schedule.initial]).pipe(zipLeft(set5(this.iterationMeta, defaultIterationMetadata)));
    }
    next(input) {
      return pipe(map10(get11(this.ref), (tuple) => tuple[1]), flatMap8((state) => pipe(currentTimeMillis2, flatMap8((now) => pipe(suspend(() => this.schedule.step(now, input, state)), flatMap8(([state2, out, decision]) => {
        const setState = set5(this.ref, [some2(out), state2]);
        if (isDone5(decision)) {
          return setState.pipe(zipRight(fail2(none2())));
        }
        const millis2 = start2(decision.intervals) - now;
        if (millis2 <= 0) {
          return setState.pipe(zipRight(updateInfo(this.iterationMeta, now, input, out)), as(out));
        }
        const duration = millis(millis2);
        return pipe(setState, zipRight(updateInfo(this.iterationMeta, now, input, out)), zipRight(sleep3(duration)), as(out));
      }))))));
    }
  }
  var makeWithState = (initial, step3) => new ScheduleImpl(initial, step3);
  var addDelay = /* @__PURE__ */ dual(2, (self2, f) => addDelayEffect(self2, (out) => sync(() => f(out))));
  var addDelayEffect = /* @__PURE__ */ dual(2, (self2, f) => modifyDelayEffect(self2, (out, duration) => map10(f(out), (delay2) => sum(duration, decode(delay2)))));
  var asVoid2 = (self2) => map15(self2, constVoid);
  var check = /* @__PURE__ */ dual(2, (self2, test) => checkEffect(self2, (input, out) => sync(() => test(input, out))));
  var checkEffect = /* @__PURE__ */ dual(2, (self2, test) => makeWithState(self2.initial, (now, input, state) => flatMap8(self2.step(now, input, state), ([state2, out, decision]) => {
    if (isDone5(decision)) {
      return succeed([state2, out, done6]);
    }
    return map10(test(input, out), (cont) => cont ? [state2, out, decision] : [state2, out, done6]);
  })));
  var driver = (self2) => pipe(make28([none2(), self2.initial]), map10((ref) => new ScheduleDriverImpl(self2, ref)));
  var intersect5 = /* @__PURE__ */ dual(2, (self2, that) => intersectWith(self2, that, intersect4));
  var intersectWith = /* @__PURE__ */ dual(3, (self2, that, f) => makeWithState([self2.initial, that.initial], (now, input, state) => pipe(zipWith3(self2.step(now, input, state[0]), that.step(now, input, state[1]), (a, b) => [a, b]), flatMap8(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
    if (isContinue2(lDecision) && isContinue2(rDecision)) {
      return intersectWithLoop(self2, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
    }
    return succeed([[lState, rState], [out, out2], done6]);
  }))));
  var intersectWithLoop = (self2, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
    const combined = f(lInterval, rInterval);
    if (isNonEmpty5(combined)) {
      return succeed([[lState, rState], [out, out2], _continue2(combined)]);
    }
    if (pipe(lInterval, lessThan5(rInterval))) {
      return flatMap8(self2.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
        if (isDone5(decision)) {
          return succeed([[lState2, rState], [out3, out2], done6]);
        }
        return intersectWithLoop(self2, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f);
      });
    }
    return flatMap8(that.step(end2(rInterval), input, rState), ([rState2, out22, decision]) => {
      if (isDone5(decision)) {
        return succeed([[lState, rState2], [out, out22], done6]);
      }
      return intersectWithLoop(self2, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f);
    });
  };
  var map15 = /* @__PURE__ */ dual(2, (self2, f) => mapEffect2(self2, (out) => sync(() => f(out))));
  var mapEffect2 = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now, input, state) => flatMap8(self2.step(now, input, state), ([state2, out, decision]) => map10(f(out), (out2) => [state2, out2, decision]))));
  var modifyDelayEffect = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now, input, state) => flatMap8(self2.step(now, input, state), ([state2, out, decision]) => {
    if (isDone5(decision)) {
      return succeed([state2, out, decision]);
    }
    const intervals = decision.intervals;
    const delay2 = size7(make36(now, start2(intervals)));
    return map10(f(out, delay2), (durationInput) => {
      const duration = decode(durationInput);
      const oldStart = start2(intervals);
      const newStart = now + toMillis(duration);
      const delta = newStart - oldStart;
      const newEnd = Math.max(0, end2(intervals) + delta);
      const newInterval = make36(newStart, newEnd);
      return [state2, out, continueWith2(newInterval)];
    });
  })));
  var passthrough2 = (self2) => makeWithState(self2.initial, (now, input, state) => pipe(self2.step(now, input, state), map10(([state2, _, decision]) => [state2, input, decision])));
  var recurs = (n) => whileOutput(forever2, (out) => out < n);
  var spaced = (duration) => addDelay(forever2, () => duration);
  var unfold2 = (initial, f) => makeWithState(initial, (now, _, state) => sync(() => [f(state), state, continueWith2(after2(now))]));
  var untilInputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (input, _) => negate(f(input))));
  var whileInputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (input, _) => f(input)));
  var whileOutput = /* @__PURE__ */ dual(2, (self2, f) => check(self2, (_, out) => f(out)));
  var ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");

  class ScheduleDefect {
    error;
    [ScheduleDefectTypeId];
    constructor(error) {
      this.error = error;
      this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
    }
  }
  var isScheduleDefect = (u) => hasProperty(u, ScheduleDefectTypeId);
  var scheduleDefectWrap = (self2) => catchAll(self2, (e) => die2(new ScheduleDefect(e)));
  var scheduleDefectRefailCause = (cause2) => match2(find(cause2, (_) => isDieType(_) && isScheduleDefect(_.defect) ? some2(_.defect) : none2()), {
    onNone: () => cause2,
    onSome: (error) => fail(error.error)
  });
  var scheduleDefectRefail = (effect) => catchAllCause(effect, (cause2) => failCause(scheduleDefectRefailCause(cause2)));
  var repeat_Effect = /* @__PURE__ */ dual(2, (self2, schedule) => repeatOrElse_Effect(self2, schedule, (e, _) => fail2(e)));
  var repeat_combined = /* @__PURE__ */ dual(2, (self2, options) => {
    if (isSchedule(options)) {
      return repeat_Effect(self2, options);
    }
    const base = options.schedule ?? passthrough2(forever2);
    const withWhile = options.while ? whileInputEffect(base, (a) => {
      const applied = options.while(a);
      if (typeof applied === "boolean") {
        return succeed(applied);
      }
      return scheduleDefectWrap(applied);
    }) : base;
    const withUntil = options.until ? untilInputEffect(withWhile, (a) => {
      const applied = options.until(a);
      if (typeof applied === "boolean") {
        return succeed(applied);
      }
      return scheduleDefectWrap(applied);
    }) : withWhile;
    const withTimes = options.times ? intersect5(withUntil, recurs(options.times)).pipe(map15((intersectionPair) => intersectionPair[0])) : withUntil;
    return scheduleDefectRefail(repeat_Effect(self2, withTimes));
  });
  var repeatOrElse_Effect = /* @__PURE__ */ dual(3, (self2, schedule, orElse5) => flatMap8(driver(schedule), (driver2) => matchEffect(self2, {
    onFailure: (error) => orElse5(error, none2()),
    onSuccess: (value) => repeatOrElseEffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver2.iterationMeta)), driver2, (error, option2) => provideServiceEffect(orElse5(error, option2), CurrentIterationMetadata, get11(driver2.iterationMeta)), value)
  })));
  var repeatOrElseEffectLoop = (self2, driver2, orElse5, value) => matchEffect(driver2.next(value), {
    onFailure: () => orDie(driver2.last),
    onSuccess: (b) => matchEffect(self2, {
      onFailure: (error) => orElse5(error, some2(b)),
      onSuccess: (value2) => repeatOrElseEffectLoop(self2, driver2, orElse5, value2)
    })
  });
  var retry_Effect = /* @__PURE__ */ dual(2, (self2, policy) => retryOrElse_Effect(self2, policy, (e, _) => fail2(e)));
  var retry_combined = /* @__PURE__ */ dual(2, (self2, options) => {
    if (isSchedule(options)) {
      return retry_Effect(self2, options);
    }
    return scheduleDefectRefail(retry_Effect(self2, fromRetryOptions(options)));
  });
  var fromRetryOptions = (options) => {
    const base = options.schedule ?? forever2;
    const withWhile = options.while ? whileInputEffect(base, (e) => {
      const applied = options.while(e);
      if (typeof applied === "boolean") {
        return succeed(applied);
      }
      return scheduleDefectWrap(applied);
    }) : base;
    const withUntil = options.until ? untilInputEffect(withWhile, (e) => {
      const applied = options.until(e);
      if (typeof applied === "boolean") {
        return succeed(applied);
      }
      return scheduleDefectWrap(applied);
    }) : withWhile;
    return options.times ? intersect5(withUntil, recurs(options.times)) : withUntil;
  };
  var retryOrElse_Effect = /* @__PURE__ */ dual(3, (self2, policy, orElse5) => flatMap8(driver(policy), (driver2) => retryOrElse_EffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver2.iterationMeta)), driver2, (e, out) => provideServiceEffect(orElse5(e, out), CurrentIterationMetadata, get11(driver2.iterationMeta)))));
  var retryOrElse_EffectLoop = (self2, driver2, orElse5) => {
    return catchAll(self2, (e) => matchEffect(driver2.next(e), {
      onFailure: () => pipe(driver2.last, orDie, flatMap8((out) => orElse5(e, out))),
      onSuccess: () => retryOrElse_EffectLoop(self2, driver2, orElse5)
    }));
  };
  var schedule_Effect = /* @__PURE__ */ dual(2, (self2, schedule) => scheduleFrom_Effect(self2, undefined, schedule));
  var scheduleFrom_Effect = /* @__PURE__ */ dual(3, (self2, initial, schedule) => flatMap8(driver(schedule), (driver2) => scheduleFrom_EffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver2.iterationMeta)), initial, driver2)));
  var scheduleFrom_EffectLoop = (self2, initial, driver2) => matchEffect(driver2.next(initial), {
    onFailure: () => orDie(driver2.last),
    onSuccess: () => flatMap8(self2, (a) => scheduleFrom_EffectLoop(self2, a, driver2))
  });
  var forever2 = /* @__PURE__ */ unfold2(0, (n) => n + 1);
  var once2 = /* @__PURE__ */ asVoid2(/* @__PURE__ */ recurs(1));
  var scheduleForked = /* @__PURE__ */ dual(2, (self2, schedule) => forkScoped(schedule_Effect(self2, schedule)));

  // node_modules/effect/dist/esm/internal/executionPlan.js
  var withExecutionPlan = /* @__PURE__ */ dual(2, (effect, plan) => suspend(() => {
    let i = 0;
    let result;
    return flatMap8(whileLoop({
      while: () => i < plan.steps.length && (result === undefined || isLeft2(result)),
      body: () => {
        const step3 = plan.steps[i];
        let nextEffect = effect_provide(effect, step3.provide);
        if (result) {
          let attempted = false;
          const wrapped = nextEffect;
          nextEffect = suspend(() => {
            if (attempted)
              return wrapped;
            attempted = true;
            return result;
          });
          nextEffect = scheduleDefectRefail(retry_Effect(nextEffect, scheduleFromStep(step3, false)));
        } else {
          const schedule = scheduleFromStep(step3, true);
          nextEffect = schedule ? scheduleDefectRefail(retry_Effect(nextEffect, schedule)) : nextEffect;
        }
        return either2(nextEffect);
      },
      step: (either3) => {
        result = either3;
        i++;
      }
    }), () => result);
  }));
  var scheduleFromStep = (step3, first) => {
    if (!first) {
      return fromRetryOptions({
        schedule: step3.schedule ? step3.schedule : step3.attempts ? undefined : once2,
        times: step3.attempts,
        while: step3.while
      });
    } else if (step3.attempts === 1 || !(step3.schedule || step3.attempts)) {
      return;
    }
    return fromRetryOptions({
      schedule: step3.schedule,
      while: step3.while,
      times: step3.attempts ? step3.attempts - 1 : undefined
    });
  };

  // node_modules/effect/dist/esm/internal/query.js
  var currentCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map10(deferredMake(), (handle) => ({
    listeners: new Listeners,
    handle
  })), () => seconds(60))));
  var currentCacheEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
  var fromRequest = (request, dataSource) => flatMap8(isEffect(dataSource) ? dataSource : succeed(dataSource), (ds) => fiberIdWith((id2) => {
    const proxy = new Proxy(request, {});
    return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
      if (cacheEnabled) {
        const cached3 = fiberRefGetWith(currentCache, (cache) => flatMap8(cache.getEither(proxy), (orNew) => {
          switch (orNew._tag) {
            case "Left": {
              if (orNew.left.listeners.interrupted) {
                return flatMap8(cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached3);
              }
              orNew.left.listeners.increment();
              return uninterruptibleMask((restore) => flatMap8(exit(blocked(empty16, restore(deferredAwait(orNew.left.handle)))), (exit2) => {
                orNew.left.listeners.decrement();
                return exit2;
              }));
            }
            case "Right": {
              orNew.right.listeners.increment();
              return uninterruptibleMask((restore) => flatMap8(exit(blocked(single(ds, makeEntry({
                request: proxy,
                result: orNew.right.handle,
                listeners: orNew.right.listeners,
                ownerId: id2,
                state: {
                  completed: false
                }
              })), restore(deferredAwait(orNew.right.handle)))), () => {
                orNew.right.listeners.decrement();
                return deferredAwait(orNew.right.handle);
              }));
            }
          }
        }));
        return cached3;
      }
      const listeners = new Listeners;
      listeners.increment();
      return flatMap8(deferredMake(), (ref) => ensuring(blocked(single(ds, makeEntry({
        request: proxy,
        result: ref,
        listeners,
        ownerId: id2,
        state: {
          completed: false
        }
      })), deferredAwait(ref)), sync(() => listeners.decrement())));
    });
  }));
  var cacheRequest = (request, result) => {
    return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
      if (cacheEnabled) {
        return fiberRefGetWith(currentCache, (cache) => flatMap8(cache.getEither(request), (orNew) => {
          switch (orNew._tag) {
            case "Left": {
              return void_;
            }
            case "Right": {
              return deferredComplete(orNew.right.handle, result);
            }
          }
        }));
      }
      return void_;
    });
  };
  var withRequestCaching = /* @__PURE__ */ dual(2, (self2, strategy) => fiberRefLocally(self2, currentCacheEnabled, strategy));
  var withRequestCache = /* @__PURE__ */ dual(2, (self2, cache) => fiberRefLocally(self2, currentCache, cache));

  // node_modules/effect/dist/esm/Request.js
  var isRequest2 = isRequest;

  // node_modules/effect/dist/esm/Effect.js
  var EffectTypeId3 = EffectTypeId2;
  var isEffect2 = isEffect;
  var cachedWithTTL = cached2;
  var cachedInvalidateWithTTL2 = cachedInvalidateWithTTL;
  var cached3 = memoize;
  var cachedFunction2 = cachedFunction;
  var once3 = once;
  var all4 = all3;
  var allWith2 = allWith;
  var allSuccesses2 = allSuccesses;
  var dropUntil2 = dropUntil;
  var dropWhile3 = dropWhile2;
  var takeUntil2 = takeUntil;
  var takeWhile3 = takeWhile2;
  var every6 = every5;
  var exists3 = exists2;
  var filter8 = filter6;
  var filterMap6 = filterMap5;
  var findFirst6 = findFirst5;
  var forEach6 = forEach5;
  var head4 = head3;
  var mergeAll5 = mergeAll3;
  var partition4 = partition3;
  var reduce10 = reduce9;
  var reduceWhile2 = reduceWhile;
  var reduceRight4 = reduceRight3;
  var reduceEffect2 = reduceEffect;
  var replicate2 = replicate;
  var replicateEffect2 = replicateEffect;
  var validateAll2 = validateAll;
  var validateFirst2 = validateFirst;
  var async = async_;
  var asyncEffect2 = asyncEffect;
  var custom2 = custom;
  var withFiberRuntime2 = withFiberRuntime;
  var fail9 = fail2;
  var failSync3 = failSync;
  var failCause8 = failCause;
  var failCauseSync3 = failCauseSync;
  var die6 = die2;
  var dieMessage2 = dieMessage;
  var dieSync3 = dieSync;
  var gen2 = gen;
  var never3 = never;
  var none9 = none6;
  var promise2 = promise;
  var succeed8 = succeed;
  var succeedNone2 = succeedNone;
  var succeedSome2 = succeedSome;
  var suspend3 = suspend;
  var sync3 = sync;
  var _void = void_;
  var yieldNow4 = yieldNow;
  var _catch2 = _catch;
  var catchAll3 = catchAll;
  var catchAllCause3 = catchAllCause;
  var catchAllDefect2 = catchAllDefect;
  var catchIf2 = catchIf;
  var catchSome2 = catchSome;
  var catchSomeCause2 = catchSomeCause;
  var catchSomeDefect2 = catchSomeDefect;
  var catchTag2 = catchTag;
  var catchTags2 = catchTags;
  var cause2 = cause;
  var eventually2 = eventually;
  var ignore2 = ignore;
  var ignoreLogged2 = ignoreLogged;
  var parallelErrors2 = parallelErrors;
  var sandbox2 = sandbox;
  var retry2 = retry_combined;
  var withExecutionPlan2 = withExecutionPlan;
  var retryOrElse = retryOrElse_Effect;
  var try_2 = try_;
  var tryMap2 = tryMap;
  var tryMapPromise2 = tryMapPromise;
  var tryPromise2 = tryPromise;
  var unsandbox2 = unsandbox;
  var allowInterrupt2 = allowInterrupt;
  var checkInterruptible2 = checkInterruptible;
  var disconnect2 = disconnect;
  var interrupt7 = interrupt2;
  var interruptWith2 = interruptWith;
  var interruptible4 = interruptible2;
  var interruptibleMask2 = interruptibleMask;
  var onInterrupt2 = onInterrupt;
  var uninterruptible2 = uninterruptible;
  var uninterruptibleMask3 = uninterruptibleMask;
  var liftPredicate2 = liftPredicate;
  var as3 = as;
  var asSome2 = asSome;
  var asSomeError2 = asSomeError;
  var asVoid3 = asVoid;
  var flip2 = flip;
  var flipWith2 = flipWith;
  var map16 = map10;
  var mapAccum4 = mapAccum3;
  var mapBoth4 = mapBoth2;
  var mapError3 = mapError;
  var mapErrorCause2 = mapErrorCause;
  var merge7 = merge5;
  var negate2 = negate;
  var acquireRelease2 = acquireRelease;
  var acquireReleaseInterruptible2 = acquireReleaseInterruptible;
  var acquireUseRelease2 = acquireUseRelease;
  var addFinalizer3 = addFinalizer;
  var ensuring2 = ensuring;
  var onError2 = onError;
  var onExit3 = onExit;
  var parallelFinalizers2 = parallelFinalizers;
  var sequentialFinalizers2 = sequentialFinalizers;
  var finalizersMask2 = finalizersMask;
  var scope3 = scope;
  var scopeWith2 = scopeWith;
  var scopedWith2 = scopedWith;
  var scoped2 = scopedEffect;
  var using2 = using;
  var withEarlyRelease2 = withEarlyRelease;
  var awaitAllChildren2 = awaitAllChildren;
  var daemonChildren2 = daemonChildren;
  var descriptor2 = descriptor;
  var descriptorWith2 = descriptorWith;
  var diffFiberRefs2 = diffFiberRefs;
  var ensuringChild2 = ensuringChild;
  var ensuringChildren2 = ensuringChildren;
  var fiberId2 = fiberId;
  var fiberIdWith2 = fiberIdWith;
  var fork3 = fork;
  var forkDaemon2 = forkDaemon;
  var forkAll2 = forkAll;
  var forkIn2 = forkIn;
  var forkScoped2 = forkScoped;
  var forkWithErrorHandler2 = forkWithErrorHandler;
  var fromFiber2 = fromFiber;
  var fromFiberEffect2 = fromFiberEffect;
  var supervised2 = supervised;
  var transplant2 = transplant;
  var withConcurrency2 = withConcurrency;
  var withScheduler2 = withScheduler;
  var withSchedulingPriority2 = withSchedulingPriority;
  var withMaxOpsBeforeYield2 = withMaxOpsBeforeYield;
  var clock2 = clock;
  var clockWith4 = clockWith3;
  var withClockScoped2 = withClockScoped;
  var withClock2 = withClock;
  var console3 = console2;
  var consoleWith2 = consoleWith;
  var withConsoleScoped2 = withConsoleScoped;
  var withConsole2 = withConsole;
  var delay2 = delay;
  var sleep4 = sleep3;
  var timed2 = timed;
  var timedWith2 = timedWith;
  var timeout2 = timeout;
  var timeoutOption2 = timeoutOption;
  var timeoutFail2 = timeoutFail;
  var timeoutFailCause2 = timeoutFailCause;
  var timeoutTo2 = timeoutTo;
  var configProviderWith2 = configProviderWith;
  var withConfigProvider2 = withConfigProvider;
  var withConfigProviderScoped2 = withConfigProviderScoped;
  var context3 = context;
  var contextWith2 = contextWith;
  var contextWithEffect2 = contextWithEffect;
  var mapInputContext2 = mapInputContext;
  var provide2 = effect_provide;
  var provideService2 = provideService;
  var provideServiceEffect2 = provideServiceEffect;
  var serviceFunction2 = serviceFunction;
  var serviceFunctionEffect2 = serviceFunctionEffect;
  var serviceFunctions2 = serviceFunctions;
  var serviceConstants2 = serviceConstants;
  var serviceMembers2 = serviceMembers;
  var serviceOption2 = serviceOption;
  var serviceOptional2 = serviceOptional;
  var updateService2 = updateService;
  var Do2 = Do;
  var bind3 = bind2;
  var bindAll2 = bindAll;
  var bindTo3 = bindTo2;
  var let_3 = let_2;
  var option2 = option;
  var either3 = either2;
  var exit2 = exit;
  var intoDeferred2 = intoDeferred;
  var if_2 = if_;
  var filterOrDie2 = filterOrDie;
  var filterOrDieMessage2 = filterOrDieMessage;
  var filterOrElse2 = filterOrElse;
  var filterOrFail2 = filterOrFail;
  var filterEffectOrElse2 = filterEffectOrElse;
  var filterEffectOrFail2 = filterEffectOrFail;
  var unless2 = unless;
  var unlessEffect2 = unlessEffect;
  var when2 = when;
  var whenEffect2 = whenEffect;
  var whenFiberRef2 = whenFiberRef;
  var whenRef2 = whenRef;
  var flatMap11 = flatMap8;
  var andThen4 = andThen2;
  var flatten9 = flatten6;
  var race2 = race;
  var raceAll2 = raceAll;
  var raceFirst2 = raceFirst;
  var raceWith2 = raceWith;
  var summarized2 = summarized;
  var tap3 = tap;
  var tapBoth2 = tapBoth;
  var tapDefect2 = tapDefect;
  var tapError3 = tapError;
  var tapErrorTag2 = tapErrorTag;
  var tapErrorCause3 = tapErrorCause;
  var forever3 = forever;
  var iterate2 = iterate;
  var loop2 = loop;
  var repeat = repeat_combined;
  var repeatN2 = repeatN;
  var repeatOrElse = repeatOrElse_Effect;
  var schedule = schedule_Effect;
  var scheduleForked2 = scheduleForked;
  var scheduleFrom = scheduleFrom_Effect;
  var whileLoop2 = whileLoop;
  var getFiberRefs = fiberRefs2;
  var inheritFiberRefs2 = inheritFiberRefs;
  var locally = fiberRefLocally;
  var locallyWith = fiberRefLocallyWith;
  var locallyScoped = fiberRefLocallyScoped;
  var locallyScopedWith = fiberRefLocallyScopedWith;
  var patchFiberRefs2 = patchFiberRefs;
  var setFiberRefs2 = setFiberRefs;
  var updateFiberRefs2 = updateFiberRefs;
  var isFailure4 = isFailure2;
  var isSuccess3 = isSuccess2;
  var match12 = match7;
  var matchCause3 = matchCause;
  var matchCauseEffect3 = matchCauseEffect;
  var matchEffect2 = matchEffect;
  var log2 = log;
  var logWithLevel2 = (level, ...message) => logWithLevel(level)(...message);
  var logTrace2 = logTrace;
  var logDebug2 = logDebug;
  var logInfo2 = logInfo;
  var logWarning2 = logWarning;
  var logError2 = logError;
  var logFatal2 = logFatal;
  var withLogSpan2 = withLogSpan;
  var annotateLogs3 = annotateLogs;
  var annotateLogsScoped2 = annotateLogsScoped;
  var logAnnotations2 = logAnnotations;
  var withUnhandledErrorLogLevel2 = withUnhandledErrorLogLevel;
  var whenLogLevel2 = whenLogLevel;
  var orDie3 = orDie;
  var orDieWith2 = orDieWith;
  var orElse5 = orElse2;
  var orElseFail2 = orElseFail;
  var orElseSucceed2 = orElseSucceed;
  var firstSuccessOf2 = firstSuccessOf;
  var random3 = random2;
  var randomWith2 = randomWith;
  var withRandom2 = withRandom;
  var withRandomFixed = /* @__PURE__ */ dual(2, (effect, values3) => withRandom2(effect, fixed2(values3)));
  var withRandomScoped2 = withRandomScoped;
  var runtime4 = runtime3;
  var getRuntimeFlags = runtimeFlags;
  var patchRuntimeFlags = updateRuntimeFlags;
  var withRuntimeFlagsPatch = withRuntimeFlags;
  var withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
  var tagMetrics2 = tagMetrics;
  var labelMetrics2 = labelMetrics;
  var tagMetricsScoped2 = tagMetricsScoped;
  var labelMetricsScoped2 = labelMetricsScoped;
  var metricLabels2 = metricLabels;
  var withMetric2 = withMetric;
  var unsafeMakeSemaphore2 = unsafeMakeSemaphore;
  var makeSemaphore2 = makeSemaphore;
  var unsafeMakeLatch2 = unsafeMakeLatch;
  var makeLatch2 = makeLatch;
  var runFork2 = unsafeForkEffect;
  var runCallback = unsafeRunEffect;
  var runPromise = unsafeRunPromiseEffect;
  var runPromiseExit = unsafeRunPromiseExitEffect;
  var runSync = unsafeRunSyncEffect;
  var runSyncExit = unsafeRunSyncExitEffect;
  var validate2 = validate;
  var validateWith2 = validateWith;
  var zip5 = zipOptions;
  var zipLeft2 = zipLeftOptions;
  var zipRight3 = zipRightOptions;
  var zipWith5 = zipWithOptions;
  var ap = /* @__PURE__ */ dual(2, (self2, that) => zipWith5(self2, that, (f, a) => f(a)));
  var blocked2 = blocked;
  var runRequestBlock2 = runRequestBlock;
  var step3 = step2;
  var request = /* @__PURE__ */ dual((args2) => isRequest2(args2[0]), fromRequest);
  var cacheRequestResult = cacheRequest;
  var withRequestBatching2 = withRequestBatching;
  var withRequestCaching2 = withRequestCaching;
  var withRequestCache2 = withRequestCache;
  var tracer2 = tracer;
  var tracerWith4 = tracerWith;
  var withTracer2 = withTracer;
  var withTracerScoped2 = withTracerScoped;
  var withTracerEnabled2 = withTracerEnabled;
  var withTracerTiming2 = withTracerTiming;
  var annotateSpans3 = annotateSpans;
  var annotateCurrentSpan2 = annotateCurrentSpan;
  var currentSpan2 = currentSpan;
  var currentParentSpan2 = currentParentSpan;
  var spanAnnotations2 = spanAnnotations;
  var spanLinks2 = spanLinks;
  var linkSpans2 = linkSpans;
  var linkSpanCurrent2 = linkSpanCurrent;
  var makeSpan2 = makeSpan;
  var makeSpanScoped2 = makeSpanScoped;
  var useSpan2 = useSpan;
  var withSpan3 = withSpan;
  var functionWithSpan2 = functionWithSpan;
  var withSpanScoped2 = withSpanScoped;
  var withParentSpan3 = withParentSpan;
  var fromNullable3 = fromNullable2;
  var optionFromOptional2 = optionFromOptional;
  var transposeOption = (self2) => {
    return isNone(self2) ? succeedNone2 : map16(self2.value, some);
  };
  var transposeMapOption = /* @__PURE__ */ dual(2, (self2, f) => isNone(self2) ? succeedNone2 : map16(f(self2.value), some));
  var makeTagProxy = (TagClass) => {
    const cache = new Map;
    return new Proxy(TagClass, {
      get(target, prop, receiver) {
        if (prop in target) {
          return Reflect.get(target, prop, receiver);
        }
        if (cache.has(prop)) {
          return cache.get(prop);
        }
        const fn = (...args2) => andThen2(target, (s) => {
          if (typeof s[prop] === "function") {
            cache.set(prop, (...args3) => andThen2(target, (s2) => s2[prop](...args3)));
            return s[prop](...args2);
          }
          cache.set(prop, andThen2(target, (s2) => s2[prop]));
          return s[prop];
        });
        const cn = andThen2(target, (s) => s[prop]);
        Object.assign(fn, cn);
        const apply = fn.apply;
        const bind4 = fn.bind;
        const call = fn.call;
        const proto4 = Object.setPrototypeOf({}, Object.getPrototypeOf(cn));
        proto4.apply = apply;
        proto4.bind = bind4;
        proto4.call = call;
        Object.setPrototypeOf(fn, proto4);
        cache.set(prop, fn);
        return fn;
      }
    });
  };
  var Tag3 = (id2) => () => {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error;
    Error.stackTraceLimit = limit;
    function TagClass() {}
    Object.setPrototypeOf(TagClass, TagProto);
    TagClass.key = id2;
    Object.defineProperty(TagClass, "use", {
      get() {
        return (body) => andThen2(this, body);
      }
    });
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    return makeTagProxy(TagClass);
  };
  var Service = function() {
    return function() {
      const [id2, maker] = arguments;
      const proxy = "accessors" in maker ? maker["accessors"] : false;
      const limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const creationError = new Error;
      Error.stackTraceLimit = limit;
      let patchState = "unchecked";
      const TagClass = function(service2) {
        if (patchState === "unchecked") {
          const proto4 = Object.getPrototypeOf(service2);
          if (proto4 === Object.prototype || proto4 === null) {
            patchState = "plain";
          } else {
            const selfProto = Object.getPrototypeOf(this);
            Object.setPrototypeOf(selfProto, proto4);
            patchState = "patched";
          }
        }
        if (patchState === "plain") {
          Object.assign(this, service2);
        } else if (patchState === "patched") {
          Object.setPrototypeOf(service2, Object.getPrototypeOf(this));
          return service2;
        }
      };
      TagClass.prototype._tag = id2;
      Object.defineProperty(TagClass, "make", {
        get() {
          return (service2) => new this(service2);
        }
      });
      Object.defineProperty(TagClass, "use", {
        get() {
          return (body) => andThen2(this, body);
        }
      });
      TagClass.key = id2;
      Object.assign(TagClass, TagProto);
      Object.defineProperty(TagClass, "stack", {
        get() {
          return creationError.stack;
        }
      });
      const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
      const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
      let layerCache;
      let isFunction3 = false;
      if ("effect" in maker) {
        isFunction3 = typeof maker.effect === "function";
        Object.defineProperty(TagClass, layerName, {
          get() {
            if (isFunction3) {
              return function() {
                return fromEffect3(TagClass, map16(maker.effect.apply(null, arguments), (_) => new this(_)));
              }.bind(this);
            }
            return layerCache ??= fromEffect3(TagClass, map16(maker.effect, (_) => new this(_)));
          }
        });
      } else if ("scoped" in maker) {
        isFunction3 = typeof maker.scoped === "function";
        Object.defineProperty(TagClass, layerName, {
          get() {
            if (isFunction3) {
              return function() {
                return scoped(TagClass, map16(maker.scoped.apply(null, arguments), (_) => new this(_)));
              }.bind(this);
            }
            return layerCache ??= scoped(TagClass, map16(maker.scoped, (_) => new this(_)));
          }
        });
      } else if ("sync" in maker) {
        Object.defineProperty(TagClass, layerName, {
          get() {
            return layerCache ??= sync2(TagClass, () => new this(maker.sync()));
          }
        });
      } else {
        Object.defineProperty(TagClass, layerName, {
          get() {
            return layerCache ??= succeed6(TagClass, new this(maker.succeed));
          }
        });
      }
      if (hasDeps) {
        let layerWithDepsCache;
        Object.defineProperty(TagClass, "Default", {
          get() {
            if (isFunction3) {
              return function() {
                return provide(this.DefaultWithoutDependencies.apply(null, arguments), maker.dependencies);
              };
            }
            return layerWithDepsCache ??= provide(this.DefaultWithoutDependencies, maker.dependencies);
          }
        });
      }
      return proxy === true ? makeTagProxy(TagClass) : TagClass;
    };
  };
  var fn = function(nameOrBody, ...pipeables) {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const errorDef = new Error;
    Error.stackTraceLimit = limit;
    if (typeof nameOrBody !== "string") {
      return defineLength(nameOrBody.length, function(...args2) {
        const limit2 = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        const errorCall = new Error;
        Error.stackTraceLimit = limit2;
        return fnApply({
          self: this,
          body: nameOrBody,
          args: args2,
          pipeables,
          spanName: "<anonymous>",
          spanOptions: {
            context: DisablePropagation.context(true)
          },
          errorDef,
          errorCall
        });
      });
    }
    const name = nameOrBody;
    const options = pipeables[0];
    return (body, ...pipeables2) => defineLength(body.length, {
      [name](...args2) {
        const limit2 = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        const errorCall = new Error;
        Error.stackTraceLimit = limit2;
        return fnApply({
          self: this,
          body,
          args: args2,
          pipeables: pipeables2,
          spanName: name,
          spanOptions: options,
          errorDef,
          errorCall
        });
      }
    }[name]);
  };
  function defineLength(length3, fn2) {
    return Object.defineProperty(fn2, "length", {
      value: length3,
      configurable: true
    });
  }
  function fnApply(options) {
    let effect;
    let fnError = undefined;
    if (isGeneratorFunction(options.body)) {
      effect = fromIterator(() => options.body.apply(options.self, options.args));
    } else {
      try {
        effect = options.body.apply(options.self, options.args);
      } catch (error) {
        fnError = error;
        effect = die6(error);
      }
    }
    if (options.pipeables.length > 0) {
      try {
        for (const x of options.pipeables) {
          effect = x(effect, ...options.args);
        }
      } catch (error) {
        effect = fnError ? failCause8(sequential(die(fnError), die(error))) : die6(error);
      }
    }
    let cache = false;
    const captureStackTrace = () => {
      if (cache !== false) {
        return cache;
      }
      if (options.errorCall.stack) {
        const stackDef = options.errorDef.stack.trim().split(`
`);
        const stackCall = options.errorCall.stack.trim().split(`
`);
        let endStackDef = stackDef.slice(2).join(`
`).trim();
        if (!endStackDef.includes(`(`)) {
          endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
        }
        let endStackCall = stackCall.slice(2).join(`
`).trim();
        if (!endStackCall.includes(`(`)) {
          endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
        }
        cache = `${endStackDef}
${endStackCall}`;
        return cache;
      }
    };
    const opts = options.spanOptions && "captureStackTrace" in options.spanOptions ? options.spanOptions : {
      captureStackTrace,
      ...options.spanOptions
    };
    return withSpan3(effect, options.spanName, opts);
  }
  var fnUntraced2 = fnUntraced;
  var ensureSuccessType = () => (effect) => effect;
  var ensureErrorType = () => (effect) => effect;
  var ensureRequirementsType = () => (effect) => effect;

  // node_modules/effect/dist/esm/FiberRef.js
  var get13 = fiberRefGet;
  var getWith = fiberRefGetWith;
  var currentContext2 = currentContext;
  var currentSchedulingPriority2 = currentSchedulingPriority;
  var currentScheduler2 = currentScheduler;
  var currentTracerTimingEnabled2 = currentTracerTimingEnabled;

  // node_modules/effect/dist/esm/Layer.js
  var exports_Layer = {};
  __export(exports_Layer, {
    zipWith: () => zipWith6,
    withSpan: () => withSpan4,
    withParentSpan: () => withParentSpan4,
    updateService: () => updateService3,
    unwrapScoped: () => unwrapScoped2,
    unwrapEffect: () => unwrapEffect2,
    toRuntimeWithMemoMap: () => toRuntimeWithMemoMap2,
    toRuntime: () => toRuntime2,
    tapErrorCause: () => tapErrorCause4,
    tapError: () => tapError4,
    tap: () => tap4,
    syncContext: () => syncContext2,
    sync: () => sync4,
    suspend: () => suspend4,
    succeedContext: () => succeedContext2,
    succeed: () => succeed9,
    span: () => span3,
    setVersionMismatchErrorLogLevel: () => setVersionMismatchErrorLogLevel,
    setUnhandledErrorLogLevel: () => setUnhandledErrorLogLevel,
    setTracerTiming: () => setTracerTiming,
    setTracerEnabled: () => setTracerEnabled,
    setTracer: () => setTracer2,
    setScheduler: () => setScheduler,
    setRequestCaching: () => setRequestCaching,
    setRequestCache: () => setRequestCache,
    setRequestBatching: () => setRequestBatching,
    setRandom: () => setRandom,
    setConfigProvider: () => setConfigProvider2,
    setClock: () => setClock,
    service: () => service2,
    scopedDiscard: () => scopedDiscard2,
    scopedContext: () => scopedContext2,
    scoped: () => scoped3,
    scope: () => scope4,
    retry: () => retry3,
    provideMerge: () => provideMerge2,
    provide: () => provide3,
    project: () => project2,
    passthrough: () => passthrough3,
    parentSpan: () => parentSpan2,
    orElse: () => orElse6,
    orDie: () => orDie4,
    mock: () => mock2,
    mergeAll: () => mergeAll6,
    merge: () => merge8,
    memoize: () => memoize3,
    matchCause: () => matchCause4,
    match: () => match13,
    mapError: () => mapError4,
    map: () => map17,
    makeMemoMap: () => makeMemoMap2,
    locallyWith: () => locallyWith2,
    locallyScoped: () => locallyScoped2,
    locallyEffect: () => locallyEffect2,
    locally: () => locally2,
    launch: () => launch2,
    isLayer: () => isLayer2,
    isFresh: () => isFresh2,
    function: () => fromFunction2,
    fresh: () => fresh2,
    flatten: () => flatten10,
    flatMap: () => flatMap12,
    fiberRefLocallyScopedWith: () => fiberRefLocallyScopedWith3,
    failSync: () => failSync4,
    failCauseSync: () => failCauseSync4,
    failCause: () => failCause9,
    fail: () => fail10,
    extendScope: () => extendScope2,
    empty: () => empty30,
    effectDiscard: () => effectDiscard,
    effectContext: () => effectContext,
    effect: () => effect,
    discard: () => discard2,
    dieSync: () => dieSync4,
    die: () => die7,
    context: () => context4,
    catchAllCause: () => catchAllCause4,
    catchAll: () => catchAll4,
    buildWithScope: () => buildWithScope2,
    buildWithMemoMap: () => buildWithMemoMap2,
    build: () => build2,
    annotateSpans: () => annotateSpans4,
    annotateLogs: () => annotateLogs4,
    MemoMapTypeId: () => MemoMapTypeId2,
    LayerTypeId: () => LayerTypeId2,
    CurrentMemoMap: () => CurrentMemoMap2
  });

  // node_modules/effect/dist/esm/internal/layer/circular.js
  var setConfigProvider = (configProvider) => scopedDiscard(withConfigProviderScoped(configProvider));
  var parentSpan = (span2) => succeedContext(make5(spanTag, span2));
  var span2 = (name, options) => {
    options = addSpanStackTrace(options);
    return scoped(spanTag, options?.onEnd ? tap(makeSpanScoped(name, options), (span3) => addFinalizer((exit3) => options.onEnd(span3, exit3))) : makeSpanScoped(name, options));
  };
  var setTracer = (tracer3) => scopedDiscard(withTracerScoped(tracer3));

  // node_modules/effect/dist/esm/Layer.js
  var LayerTypeId2 = LayerTypeId;
  var MemoMapTypeId2 = MemoMapTypeId;
  var CurrentMemoMap2 = CurrentMemoMap;
  var isLayer2 = isLayer;
  var isFresh2 = isFresh;
  var annotateLogs4 = annotateLogs2;
  var annotateSpans4 = annotateSpans2;
  var build2 = build;
  var buildWithScope2 = buildWithScope;
  var catchAll4 = catchAll2;
  var catchAllCause4 = catchAllCause2;
  var context4 = context2;
  var die7 = die5;
  var dieSync4 = dieSync2;
  var discard2 = discard;
  var effect = fromEffect3;
  var effectDiscard = fromEffectDiscard;
  var effectContext = fromEffectContext;
  var empty30 = empty29;
  var extendScope2 = extendScope;
  var fail10 = fail7;
  var failSync4 = failSync2;
  var failCause9 = failCause6;
  var failCauseSync4 = failCauseSync2;
  var flatMap12 = flatMap10;
  var flatten10 = flatten8;
  var fresh2 = fresh;
  var mock2 = mock;
  var fromFunction2 = fromFunction;
  var launch2 = launch;
  var map17 = map14;
  var mapError4 = mapError2;
  var match13 = match11;
  var matchCause4 = matchCause2;
  var memoize3 = memoize2;
  var merge8 = merge6;
  var mergeAll6 = mergeAll4;
  var orDie4 = orDie2;
  var orElse6 = orElse4;
  var passthrough3 = passthrough;
  var project2 = project;
  var locallyEffect2 = locallyEffect;
  var locally2 = fiberRefLocally2;
  var locallyWith2 = fiberRefLocallyWith2;
  var locallyScoped2 = fiberRefLocallyScoped2;
  var fiberRefLocallyScopedWith3 = fiberRefLocallyScopedWith2;
  var retry3 = retry;
  var scope4 = scope2;
  var scoped3 = scoped;
  var scopedDiscard2 = scopedDiscard;
  var scopedContext2 = scopedContext;
  var service2 = service;
  var succeed9 = succeed6;
  var succeedContext2 = succeedContext;
  var suspend4 = suspend2;
  var sync4 = sync2;
  var syncContext2 = syncContext;
  var tap4 = tap2;
  var tapError4 = tapError2;
  var tapErrorCause4 = tapErrorCause2;
  var toRuntime2 = toRuntime;
  var toRuntimeWithMemoMap2 = toRuntimeWithMemoMap;
  var provide3 = provide;
  var provideMerge2 = provideMerge;
  var zipWith6 = zipWith4;
  var unwrapEffect2 = unwrapEffect;
  var unwrapScoped2 = unwrapScoped;
  var setClock = (clock3) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(clockTag, clock3)));
  var setConfigProvider2 = setConfigProvider;
  var parentSpan2 = parentSpan;
  var setRandom = (random4) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(randomTag, random4)));
  var setRequestBatching = (requestBatching) => scopedDiscard2(fiberRefLocallyScoped(currentRequestBatching, requestBatching));
  var setRequestCaching = (requestCaching) => scopedDiscard2(fiberRefLocallyScoped(currentCacheEnabled, requestCaching));
  var setRequestCache = (cache) => scopedDiscard2(isEffect(cache) ? flatMap8(cache, (x) => fiberRefLocallyScoped(currentCache, x)) : fiberRefLocallyScoped(currentCache, cache));
  var setScheduler = (scheduler) => scopedDiscard2(fiberRefLocallyScoped(currentScheduler, scheduler));
  var span3 = span2;
  var setTracer2 = setTracer;
  var setTracerEnabled = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerEnabled, enabled2));
  var setTracerTiming = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerTimingEnabled, enabled2));
  var setUnhandledErrorLogLevel = (level) => scopedDiscard2(fiberRefLocallyScoped(currentUnhandledErrorLogLevel, level));
  var setVersionMismatchErrorLogLevel = (level) => scopedDiscard2(fiberRefLocallyScoped(currentVersionMismatchErrorLogLevel, level));
  var withSpan4 = withSpan2;
  var withParentSpan4 = withParentSpan2;
  var makeMemoMap2 = makeMemoMap;
  var buildWithMemoMap2 = buildWithMemoMap;
  var updateService3 = /* @__PURE__ */ dual(3, (layer, tag, f) => provide3(layer, map17(context4(), (c) => add2(c, tag, f(unsafeGet3(c, tag))))));

  // node_modules/effect/dist/esm/internal/queue.js
  var EnqueueSymbolKey = "effect/QueueEnqueue";
  var EnqueueTypeId = /* @__PURE__ */ Symbol.for(EnqueueSymbolKey);
  var DequeueSymbolKey = "effect/QueueDequeue";
  var DequeueTypeId = /* @__PURE__ */ Symbol.for(DequeueSymbolKey);
  var QueueStrategySymbolKey = "effect/QueueStrategy";
  var QueueStrategyTypeId = /* @__PURE__ */ Symbol.for(QueueStrategySymbolKey);
  var BackingQueueSymbolKey = "effect/BackingQueue";
  var BackingQueueTypeId = /* @__PURE__ */ Symbol.for(BackingQueueSymbolKey);
  var queueStrategyVariance = {
    _A: (_) => _
  };
  var backingQueueVariance = {
    _A: (_) => _
  };
  var enqueueVariance = {
    _In: (_) => _
  };
  var dequeueVariance = {
    _Out: (_) => _
  };

  class QueueImpl extends Class {
    queue;
    takers;
    shutdownHook;
    shutdownFlag;
    strategy;
    [EnqueueTypeId] = enqueueVariance;
    [DequeueTypeId] = dequeueVariance;
    constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
      super();
      this.queue = queue;
      this.takers = takers;
      this.shutdownHook = shutdownHook;
      this.shutdownFlag = shutdownFlag;
      this.strategy = strategy;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    commit() {
      return this.take;
    }
    capacity() {
      return this.queue.capacity();
    }
    get size() {
      return suspend(() => catchAll(this.unsafeSize(), () => interrupt2));
    }
    unsafeSize() {
      if (get6(this.shutdownFlag)) {
        return none2();
      }
      return some2(this.queue.length() - length2(this.takers) + this.strategy.surplusSize());
    }
    get isEmpty() {
      return map10(this.size, (size8) => size8 <= 0);
    }
    get isFull() {
      return map10(this.size, (size8) => size8 >= this.capacity());
    }
    get shutdown() {
      return uninterruptible(withFiberRuntime((state) => {
        pipe(this.shutdownFlag, set2(true));
        return pipe(forEachConcurrentDiscard(unsafePollAll(this.takers), (d) => deferredInterruptWith(d, state.id()), false, false), zipRight(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, undefined)), asVoid);
      }));
    }
    get isShutdown() {
      return sync(() => get6(this.shutdownFlag));
    }
    get awaitShutdown() {
      return deferredAwait(this.shutdownHook);
    }
    isActive() {
      return !get6(this.shutdownFlag);
    }
    unsafeOffer(value) {
      if (get6(this.shutdownFlag)) {
        return false;
      }
      let noRemaining;
      if (this.queue.length() === 0) {
        const taker = pipe(this.takers, poll2(EmptyMutableQueue));
        if (taker !== EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, value);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return true;
      }
      const succeeded = this.queue.offer(value);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded;
    }
    offer(value) {
      return suspend(() => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        let noRemaining;
        if (this.queue.length() === 0) {
          const taker = pipe(this.takers, poll2(EmptyMutableQueue));
          if (taker !== EmptyMutableQueue) {
            unsafeCompleteDeferred(taker, value);
            noRemaining = true;
          } else {
            noRemaining = false;
          }
        } else {
          noRemaining = false;
        }
        if (noRemaining) {
          return succeed(true);
        }
        const succeeded = this.queue.offer(value);
        unsafeCompleteTakers(this.strategy, this.queue, this.takers);
        return succeeded ? succeed(true) : this.strategy.handleSurplus([value], this.queue, this.takers, this.shutdownFlag);
      });
    }
    offerAll(iterable) {
      return suspend(() => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        const values3 = fromIterable(iterable);
        const pTakers = this.queue.length() === 0 ? fromIterable(unsafePollN(this.takers, values3.length)) : empty2;
        const [forTakers, remaining] = pipe(values3, splitAt(pTakers.length));
        for (let i = 0;i < pTakers.length; i++) {
          const taker = pTakers[i];
          const item = forTakers[i];
          unsafeCompleteDeferred(taker, item);
        }
        if (remaining.length === 0) {
          return succeed(true);
        }
        const surplus = this.queue.offerAll(remaining);
        unsafeCompleteTakers(this.strategy, this.queue, this.takers);
        return isEmpty(surplus) ? succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
      });
    }
    get take() {
      return withFiberRuntime((state) => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        const item = this.queue.poll(EmptyMutableQueue);
        if (item !== EmptyMutableQueue) {
          this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
          return succeed(item);
        } else {
          const deferred = deferredUnsafeMake(state.id());
          return pipe(suspend(() => {
            pipe(this.takers, offer(deferred));
            unsafeCompleteTakers(this.strategy, this.queue, this.takers);
            return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
          }), onInterrupt(() => {
            return sync(() => unsafeRemove(this.takers, deferred));
          }));
        }
      });
    }
    get takeAll() {
      return suspend(() => {
        return get6(this.shutdownFlag) ? interrupt2 : sync(() => {
          const values3 = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
          this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
          return fromIterable2(values3);
        });
      });
    }
    takeUpTo(max5) {
      return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => {
        const values3 = this.queue.pollUpTo(max5);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return fromIterable2(values3);
      }));
    }
    takeBetween(min3, max5) {
      return suspend(() => takeRemainderLoop(this, min3, max5, empty5()));
    }
  }
  var takeRemainderLoop = (self2, min3, max5, acc) => {
    if (max5 < min3) {
      return succeed(acc);
    }
    return pipe(takeUpTo(self2, max5), flatMap8((bs) => {
      const remaining = min3 - bs.length;
      if (remaining === 1) {
        return pipe(take2(self2), map10((b) => pipe(acc, appendAll2(bs), append2(b))));
      }
      if (remaining > 1) {
        return pipe(take2(self2), flatMap8((b) => takeRemainderLoop(self2, remaining - 1, max5 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
      }
      return succeed(pipe(acc, appendAll2(bs)));
    }));
  };
  var isQueue = (u) => isEnqueue(u) && isDequeue(u);
  var isEnqueue = (u) => hasProperty(u, EnqueueTypeId);
  var isDequeue = (u) => hasProperty(u, DequeueTypeId);
  var bounded2 = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap8((queue) => make41(backingQueueFromMutableQueue(queue), backPressureStrategy())));
  var dropping = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap8((queue) => make41(backingQueueFromMutableQueue(queue), droppingStrategy())));
  var sliding = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap8((queue) => make41(backingQueueFromMutableQueue(queue), slidingStrategy())));
  var unbounded2 = () => pipe(sync(() => unbounded()), flatMap8((queue) => make41(backingQueueFromMutableQueue(queue), droppingStrategy())));
  var unsafeMake10 = (queue, takers, shutdownHook, shutdownFlag, strategy) => {
    return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
  };
  var make41 = (queue, strategy) => pipe(deferredMake(), map10((deferred) => unsafeMake10(queue, unbounded(), deferred, make11(false), strategy)));

  class BackingQueueFromMutableQueue {
    mutable;
    [BackingQueueTypeId] = backingQueueVariance;
    constructor(mutable) {
      this.mutable = mutable;
    }
    poll(def) {
      return poll2(this.mutable, def);
    }
    pollUpTo(limit) {
      return pollUpTo(this.mutable, limit);
    }
    offerAll(elements) {
      return offerAll(this.mutable, elements);
    }
    offer(element) {
      return offer(this.mutable, element);
    }
    capacity() {
      return capacity(this.mutable);
    }
    length() {
      return length2(this.mutable);
    }
  }
  var backingQueueFromMutableQueue = (mutable) => new BackingQueueFromMutableQueue(mutable);
  var capacity2 = (self2) => self2.capacity();
  var size8 = (self2) => self2.size;
  var isFull = (self2) => self2.isFull;
  var isEmpty10 = (self2) => self2.isEmpty;
  var isShutdown = (self2) => self2.isShutdown;
  var awaitShutdown = (self2) => self2.awaitShutdown;
  var shutdown = (self2) => self2.shutdown;
  var offer2 = /* @__PURE__ */ dual(2, (self2, value) => self2.offer(value));
  var unsafeOffer = /* @__PURE__ */ dual(2, (self2, value) => self2.unsafeOffer(value));
  var offerAll2 = /* @__PURE__ */ dual(2, (self2, iterable) => self2.offerAll(iterable));
  var poll5 = (self2) => map10(self2.takeUpTo(1), head2);
  var take2 = (self2) => self2.take;
  var takeAll = (self2) => self2.takeAll;
  var takeUpTo = /* @__PURE__ */ dual(2, (self2, max5) => self2.takeUpTo(max5));
  var takeBetween = /* @__PURE__ */ dual(3, (self2, min3, max5) => self2.takeBetween(min3, max5));
  var takeN = /* @__PURE__ */ dual(2, (self2, n) => self2.takeBetween(n, n));
  var backPressureStrategy = () => new BackPressureStrategy;
  var droppingStrategy = () => new DroppingStrategy;
  var slidingStrategy = () => new SlidingStrategy;

  class BackPressureStrategy {
    [QueueStrategyTypeId] = queueStrategyVariance;
    putters = /* @__PURE__ */ unbounded();
    surplusSize() {
      return length2(this.putters);
    }
    onCompleteTakersWithEmptyQueue(takers) {
      while (!isEmpty7(this.putters) && !isEmpty7(takers)) {
        const taker = poll2(takers, undefined);
        const putter = poll2(this.putters, undefined);
        if (putter[2]) {
          unsafeCompleteDeferred(putter[1], true);
        }
        unsafeCompleteDeferred(taker, putter[0]);
      }
    }
    get shutdown() {
      return pipe(fiberId, flatMap8((fiberId3) => pipe(sync(() => unsafePollAll(this.putters)), flatMap8((putters) => forEachConcurrentDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred, fiberId3), asVoid) : void_, false, false)))));
    }
    handleSurplus(iterable, queue, takers, isShutdown2) {
      return withFiberRuntime((state) => {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          this.unsafeOffer(iterable, deferred);
          this.unsafeOnQueueEmptySpace(queue, takers);
          unsafeCompleteTakers(this, queue, takers);
          return get6(isShutdown2) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
      });
    }
    unsafeOnQueueEmptySpace(queue, takers) {
      let keepPolling = true;
      while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {
        const putter = pipe(this.putters, poll2(EmptyMutableQueue));
        if (putter === EmptyMutableQueue) {
          keepPolling = false;
        } else {
          const offered = queue.offer(putter[0]);
          if (offered && putter[2]) {
            unsafeCompleteDeferred(putter[1], true);
          } else if (!offered) {
            unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), prepend2(putter)));
          }
          unsafeCompleteTakers(this, queue, takers);
        }
      }
    }
    unsafeOffer(iterable, deferred) {
      const stuff = fromIterable(iterable);
      for (let i = 0;i < stuff.length; i++) {
        const value = stuff[i];
        if (i === stuff.length - 1) {
          pipe(this.putters, offer([value, deferred, true]));
        } else {
          pipe(this.putters, offer([value, deferred, false]));
        }
      }
    }
    unsafeRemove(deferred) {
      unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), filter3(([, _]) => _ !== deferred)));
    }
  }

  class DroppingStrategy {
    [QueueStrategyTypeId] = queueStrategyVariance;
    surplusSize() {
      return 0;
    }
    get shutdown() {
      return void_;
    }
    onCompleteTakersWithEmptyQueue() {}
    handleSurplus(_iterable, _queue, _takers, _isShutdown) {
      return succeed(false);
    }
    unsafeOnQueueEmptySpace(_queue, _takers) {}
  }

  class SlidingStrategy {
    [QueueStrategyTypeId] = queueStrategyVariance;
    surplusSize() {
      return 0;
    }
    get shutdown() {
      return void_;
    }
    onCompleteTakersWithEmptyQueue() {}
    handleSurplus(iterable, queue, takers, _isShutdown) {
      return sync(() => {
        this.unsafeOffer(queue, iterable);
        unsafeCompleteTakers(this, queue, takers);
        return true;
      });
    }
    unsafeOnQueueEmptySpace(_queue, _takers) {}
    unsafeOffer(queue, iterable) {
      const iterator = iterable[Symbol.iterator]();
      let next;
      let offering = true;
      while (!(next = iterator.next()).done && offering) {
        if (queue.capacity() === 0) {
          return;
        }
        queue.poll(EmptyMutableQueue);
        offering = queue.offer(next.value);
      }
    }
  }
  var unsafeCompleteDeferred = (deferred, a) => {
    return deferredUnsafeDone(deferred, succeed(a));
  };
  var unsafeOfferAll = (queue, as4) => {
    return pipe(queue, offerAll(as4));
  };
  var unsafePollAll = (queue) => {
    return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
  };
  var unsafePollN = (queue, max5) => {
    return pipe(queue, pollUpTo(max5));
  };
  var unsafeRemove = (queue, a) => {
    unsafeOfferAll(queue, pipe(unsafePollAll(queue), filter3((b) => a !== b)));
  };
  var unsafeCompleteTakers = (strategy, queue, takers) => {
    let keepPolling = true;
    while (keepPolling && queue.length() !== 0) {
      const taker = pipe(takers, poll2(EmptyMutableQueue));
      if (taker !== EmptyMutableQueue) {
        const element = queue.poll(EmptyMutableQueue);
        if (element !== EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, element);
          strategy.unsafeOnQueueEmptySpace(queue, takers);
        } else {
          unsafeOfferAll(takers, pipe(unsafePollAll(takers), prepend2(taker)));
        }
        keepPolling = true;
      } else {
        keepPolling = false;
      }
    }
    if (keepPolling && queue.length() === 0 && !isEmpty7(takers)) {
      strategy.onCompleteTakersWithEmptyQueue(takers);
    }
  };

  // node_modules/effect/dist/esm/internal/pubsub.js
  var AbsentValue = /* @__PURE__ */ Symbol.for("effect/PubSub/AbsentValue");
  var addSubscribers = (subscription, pollers) => (subscribers) => {
    if (!subscribers.has(subscription)) {
      subscribers.set(subscription, new Set);
    }
    const set7 = subscribers.get(subscription);
    set7.add(pollers);
  };
  var removeSubscribers = (subscription, pollers) => (subscribers) => {
    if (!subscribers.has(subscription)) {
      return;
    }
    const set7 = subscribers.get(subscription);
    set7.delete(pollers);
    if (set7.size === 0) {
      subscribers.delete(subscription);
    }
  };
  var bounded3 = (capacity3) => suspend(() => {
    const pubsub = makeBoundedPubSub(capacity3);
    return makePubSub(pubsub, new BackPressureStrategy2);
  });
  var dropping2 = (capacity3) => suspend(() => {
    const pubsub = makeBoundedPubSub(capacity3);
    return makePubSub(pubsub, new DroppingStrategy2);
  });
  var sliding2 = (capacity3) => suspend(() => {
    const pubsub = makeBoundedPubSub(capacity3);
    return makePubSub(pubsub, new SlidingStrategy2);
  });
  var unbounded3 = (options) => suspend(() => {
    const pubsub = makeUnboundedPubSub(options);
    return makePubSub(pubsub, new DroppingStrategy2);
  });
  var shutdown2 = (self2) => self2.shutdown;
  var subscribe = (self2) => self2.subscribe;
  var makeBoundedPubSub = (capacity3) => {
    const options = typeof capacity3 === "number" ? {
      capacity: capacity3
    } : capacity3;
    ensureCapacity(options.capacity);
    const replayBuffer = options.replay && options.replay > 0 ? new ReplayBuffer(Math.ceil(options.replay)) : undefined;
    if (options.capacity === 1) {
      return new BoundedPubSubSingle(replayBuffer);
    } else if (nextPow2(options.capacity) === options.capacity) {
      return new BoundedPubSubPow2(options.capacity, replayBuffer);
    } else {
      return new BoundedPubSubArb(options.capacity, replayBuffer);
    }
  };
  var makeUnboundedPubSub = (options) => new UnboundedPubSub(options?.replay ? new ReplayBuffer(options.replay) : undefined);
  var makeSubscription = (pubsub, subscribers, strategy) => map10(deferredMake(), (deferred) => unsafeMakeSubscription(pubsub, subscribers, pubsub.subscribe(), unbounded(), deferred, make11(false), strategy));
  var unsafeMakeSubscription = (pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) => new SubscriptionImpl(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, pubsub.replayWindow());

  class BoundedPubSubArb {
    capacity;
    replayBuffer;
    array;
    publisherIndex = 0;
    subscribers;
    subscriberCount = 0;
    subscribersIndex = 0;
    constructor(capacity3, replayBuffer) {
      this.capacity = capacity3;
      this.replayBuffer = replayBuffer;
      this.array = Array.from({
        length: capacity3
      });
      this.subscribers = Array.from({
        length: capacity3
      });
    }
    replayWindow() {
      return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
    }
    isEmpty() {
      return this.publisherIndex === this.subscribersIndex;
    }
    isFull() {
      return this.publisherIndex === this.subscribersIndex + this.capacity;
    }
    size() {
      return this.publisherIndex - this.subscribersIndex;
    }
    publish(value) {
      if (this.isFull()) {
        return false;
      }
      if (this.subscriberCount !== 0) {
        const index = this.publisherIndex % this.capacity;
        this.array[index] = value;
        this.subscribers[index] = this.subscriberCount;
        this.publisherIndex += 1;
      }
      if (this.replayBuffer) {
        this.replayBuffer.offer(value);
      }
      return true;
    }
    publishAll(elements) {
      if (this.subscriberCount === 0) {
        if (this.replayBuffer) {
          this.replayBuffer.offerAll(elements);
        }
        return empty5();
      }
      const chunk2 = fromIterable2(elements);
      const n = chunk2.length;
      const size9 = this.publisherIndex - this.subscribersIndex;
      const available = this.capacity - size9;
      const forPubSub = Math.min(n, available);
      if (forPubSub === 0) {
        return chunk2;
      }
      let iteratorIndex = 0;
      const publishAllIndex = this.publisherIndex + forPubSub;
      while (this.publisherIndex !== publishAllIndex) {
        const a = unsafeGet4(chunk2, iteratorIndex++);
        const index = this.publisherIndex % this.capacity;
        this.array[index] = a;
        this.subscribers[index] = this.subscriberCount;
        this.publisherIndex += 1;
        if (this.replayBuffer) {
          this.replayBuffer.offer(a);
        }
      }
      return drop2(chunk2, iteratorIndex);
    }
    slide() {
      if (this.subscribersIndex !== this.publisherIndex) {
        const index = this.subscribersIndex % this.capacity;
        this.array[index] = AbsentValue;
        this.subscribers[index] = 0;
        this.subscribersIndex += 1;
      }
      if (this.replayBuffer) {
        this.replayBuffer.slide();
      }
    }
    subscribe() {
      this.subscriberCount += 1;
      return new BoundedPubSubArbSubscription(this, this.publisherIndex, false);
    }
  }

  class BoundedPubSubArbSubscription {
    self;
    subscriberIndex;
    unsubscribed;
    constructor(self2, subscriberIndex, unsubscribed) {
      this.self = self2;
      this.subscriberIndex = subscriberIndex;
      this.unsubscribed = unsubscribed;
    }
    isEmpty() {
      return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
    }
    size() {
      if (this.unsubscribed) {
        return 0;
      }
      return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
    }
    poll(default_) {
      if (this.unsubscribed) {
        return default_;
      }
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      if (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex % this.self.capacity;
        const elem = this.self.array[index];
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
        return elem;
      }
      return default_;
    }
    pollUpTo(n) {
      if (this.unsubscribed) {
        return empty5();
      }
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      const size9 = this.self.publisherIndex - this.subscriberIndex;
      const toPoll = Math.min(n, size9);
      if (toPoll <= 0) {
        return empty5();
      }
      const builder = [];
      const pollUpToIndex = this.subscriberIndex + toPoll;
      while (this.subscriberIndex !== pollUpToIndex) {
        const index = this.subscriberIndex % this.self.capacity;
        const a = this.self.array[index];
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        builder.push(a);
        this.subscriberIndex += 1;
      }
      return fromIterable2(builder);
    }
    unsubscribe() {
      if (!this.unsubscribed) {
        this.unsubscribed = true;
        this.self.subscriberCount -= 1;
        this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
        while (this.subscriberIndex !== this.self.publisherIndex) {
          const index = this.subscriberIndex % this.self.capacity;
          this.self.subscribers[index] -= 1;
          if (this.self.subscribers[index] === 0) {
            this.self.array[index] = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          this.subscriberIndex += 1;
        }
      }
    }
  }

  class BoundedPubSubPow2 {
    capacity;
    replayBuffer;
    array;
    mask;
    publisherIndex = 0;
    subscribers;
    subscriberCount = 0;
    subscribersIndex = 0;
    constructor(capacity3, replayBuffer) {
      this.capacity = capacity3;
      this.replayBuffer = replayBuffer;
      this.array = Array.from({
        length: capacity3
      });
      this.mask = capacity3 - 1;
      this.subscribers = Array.from({
        length: capacity3
      });
    }
    replayWindow() {
      return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
    }
    isEmpty() {
      return this.publisherIndex === this.subscribersIndex;
    }
    isFull() {
      return this.publisherIndex === this.subscribersIndex + this.capacity;
    }
    size() {
      return this.publisherIndex - this.subscribersIndex;
    }
    publish(value) {
      if (this.isFull()) {
        return false;
      }
      if (this.subscriberCount !== 0) {
        const index = this.publisherIndex & this.mask;
        this.array[index] = value;
        this.subscribers[index] = this.subscriberCount;
        this.publisherIndex += 1;
      }
      if (this.replayBuffer) {
        this.replayBuffer.offer(value);
      }
      return true;
    }
    publishAll(elements) {
      if (this.subscriberCount === 0) {
        if (this.replayBuffer) {
          this.replayBuffer.offerAll(elements);
        }
        return empty5();
      }
      const chunk2 = fromIterable2(elements);
      const n = chunk2.length;
      const size9 = this.publisherIndex - this.subscribersIndex;
      const available = this.capacity - size9;
      const forPubSub = Math.min(n, available);
      if (forPubSub === 0) {
        return chunk2;
      }
      let iteratorIndex = 0;
      const publishAllIndex = this.publisherIndex + forPubSub;
      while (this.publisherIndex !== publishAllIndex) {
        const elem = unsafeGet4(chunk2, iteratorIndex++);
        const index = this.publisherIndex & this.mask;
        this.array[index] = elem;
        this.subscribers[index] = this.subscriberCount;
        this.publisherIndex += 1;
        if (this.replayBuffer) {
          this.replayBuffer.offer(elem);
        }
      }
      return drop2(chunk2, iteratorIndex);
    }
    slide() {
      if (this.subscribersIndex !== this.publisherIndex) {
        const index = this.subscribersIndex & this.mask;
        this.array[index] = AbsentValue;
        this.subscribers[index] = 0;
        this.subscribersIndex += 1;
      }
      if (this.replayBuffer) {
        this.replayBuffer.slide();
      }
    }
    subscribe() {
      this.subscriberCount += 1;
      return new BoundedPubSubPow2Subscription(this, this.publisherIndex, false);
    }
  }

  class BoundedPubSubPow2Subscription {
    self;
    subscriberIndex;
    unsubscribed;
    constructor(self2, subscriberIndex, unsubscribed) {
      this.self = self2;
      this.subscriberIndex = subscriberIndex;
      this.unsubscribed = unsubscribed;
    }
    isEmpty() {
      return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
    }
    size() {
      if (this.unsubscribed) {
        return 0;
      }
      return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
    }
    poll(default_) {
      if (this.unsubscribed) {
        return default_;
      }
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      if (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex & this.self.mask;
        const elem = this.self.array[index];
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
        return elem;
      }
      return default_;
    }
    pollUpTo(n) {
      if (this.unsubscribed) {
        return empty5();
      }
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      const size9 = this.self.publisherIndex - this.subscriberIndex;
      const toPoll = Math.min(n, size9);
      if (toPoll <= 0) {
        return empty5();
      }
      const builder = [];
      const pollUpToIndex = this.subscriberIndex + toPoll;
      while (this.subscriberIndex !== pollUpToIndex) {
        const index = this.subscriberIndex & this.self.mask;
        const elem = this.self.array[index];
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        builder.push(elem);
        this.subscriberIndex += 1;
      }
      return fromIterable2(builder);
    }
    unsubscribe() {
      if (!this.unsubscribed) {
        this.unsubscribed = true;
        this.self.subscriberCount -= 1;
        this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
        while (this.subscriberIndex !== this.self.publisherIndex) {
          const index = this.subscriberIndex & this.self.mask;
          this.self.subscribers[index] -= 1;
          if (this.self.subscribers[index] === 0) {
            this.self.array[index] = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          this.subscriberIndex += 1;
        }
      }
    }
  }

  class BoundedPubSubSingle {
    replayBuffer;
    publisherIndex = 0;
    subscriberCount = 0;
    subscribers = 0;
    value = AbsentValue;
    capacity = 1;
    constructor(replayBuffer) {
      this.replayBuffer = replayBuffer;
    }
    replayWindow() {
      return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    isEmpty() {
      return this.subscribers === 0;
    }
    isFull() {
      return !this.isEmpty();
    }
    size() {
      return this.isEmpty() ? 0 : 1;
    }
    publish(value) {
      if (this.isFull()) {
        return false;
      }
      if (this.subscriberCount !== 0) {
        this.value = value;
        this.subscribers = this.subscriberCount;
        this.publisherIndex += 1;
      }
      if (this.replayBuffer) {
        this.replayBuffer.offer(value);
      }
      return true;
    }
    publishAll(elements) {
      if (this.subscriberCount === 0) {
        if (this.replayBuffer) {
          this.replayBuffer.offerAll(elements);
        }
        return empty5();
      }
      const chunk2 = fromIterable2(elements);
      if (isEmpty(chunk2)) {
        return chunk2;
      }
      if (this.publish(unsafeHead(chunk2))) {
        return drop2(chunk2, 1);
      } else {
        return chunk2;
      }
    }
    slide() {
      if (this.isFull()) {
        this.subscribers = 0;
        this.value = AbsentValue;
      }
      if (this.replayBuffer) {
        this.replayBuffer.slide();
      }
    }
    subscribe() {
      this.subscriberCount += 1;
      return new BoundedPubSubSingleSubscription(this, this.publisherIndex, false);
    }
  }

  class BoundedPubSubSingleSubscription {
    self;
    subscriberIndex;
    unsubscribed;
    constructor(self2, subscriberIndex, unsubscribed) {
      this.self = self2;
      this.subscriberIndex = subscriberIndex;
      this.unsubscribed = unsubscribed;
    }
    isEmpty() {
      return this.unsubscribed || this.self.subscribers === 0 || this.subscriberIndex === this.self.publisherIndex;
    }
    size() {
      return this.isEmpty() ? 0 : 1;
    }
    poll(default_) {
      if (this.isEmpty()) {
        return default_;
      }
      const elem = this.self.value;
      this.self.subscribers -= 1;
      if (this.self.subscribers === 0) {
        this.self.value = AbsentValue;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    pollUpTo(n) {
      if (this.isEmpty() || n < 1) {
        return empty5();
      }
      const a = this.self.value;
      this.self.subscribers -= 1;
      if (this.self.subscribers === 0) {
        this.self.value = AbsentValue;
      }
      this.subscriberIndex += 1;
      return of2(a);
    }
    unsubscribe() {
      if (!this.unsubscribed) {
        this.unsubscribed = true;
        this.self.subscriberCount -= 1;
        if (this.subscriberIndex !== this.self.publisherIndex) {
          this.self.subscribers -= 1;
          if (this.self.subscribers === 0) {
            this.self.value = AbsentValue;
          }
        }
      }
    }
  }

  class UnboundedPubSub {
    replayBuffer;
    publisherHead = {
      value: AbsentValue,
      subscribers: 0,
      next: null
    };
    publisherTail = this.publisherHead;
    publisherIndex = 0;
    subscribersIndex = 0;
    capacity = Number.MAX_SAFE_INTEGER;
    constructor(replayBuffer) {
      this.replayBuffer = replayBuffer;
    }
    replayWindow() {
      return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
    }
    isEmpty() {
      return this.publisherHead === this.publisherTail;
    }
    isFull() {
      return false;
    }
    size() {
      return this.publisherIndex - this.subscribersIndex;
    }
    publish(value) {
      const subscribers = this.publisherTail.subscribers;
      if (subscribers !== 0) {
        this.publisherTail.next = {
          value,
          subscribers,
          next: null
        };
        this.publisherTail = this.publisherTail.next;
        this.publisherIndex += 1;
      }
      if (this.replayBuffer) {
        this.replayBuffer.offer(value);
      }
      return true;
    }
    publishAll(elements) {
      if (this.publisherTail.subscribers !== 0) {
        for (const a of elements) {
          this.publish(a);
        }
      } else if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty5();
    }
    slide() {
      if (this.publisherHead !== this.publisherTail) {
        this.publisherHead = this.publisherHead.next;
        this.publisherHead.value = AbsentValue;
        this.subscribersIndex += 1;
      }
      if (this.replayBuffer) {
        this.replayBuffer.slide();
      }
    }
    subscribe() {
      this.publisherTail.subscribers += 1;
      return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
    }
  }

  class UnboundedPubSubSubscription {
    self;
    subscriberHead;
    subscriberIndex;
    unsubscribed;
    constructor(self2, subscriberHead, subscriberIndex, unsubscribed) {
      this.self = self2;
      this.subscriberHead = subscriberHead;
      this.subscriberIndex = subscriberIndex;
      this.unsubscribed = unsubscribed;
    }
    isEmpty() {
      if (this.unsubscribed) {
        return true;
      }
      let empty31 = true;
      let loop3 = true;
      while (loop3) {
        if (this.subscriberHead === this.self.publisherTail) {
          loop3 = false;
        } else {
          if (this.subscriberHead.next.value !== AbsentValue) {
            empty31 = false;
            loop3 = false;
          } else {
            this.subscriberHead = this.subscriberHead.next;
            this.subscriberIndex += 1;
          }
        }
      }
      return empty31;
    }
    size() {
      if (this.unsubscribed) {
        return 0;
      }
      return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
    }
    poll(default_) {
      if (this.unsubscribed) {
        return default_;
      }
      let loop3 = true;
      let polled = default_;
      while (loop3) {
        if (this.subscriberHead === this.self.publisherTail) {
          loop3 = false;
        } else {
          const elem = this.subscriberHead.next.value;
          if (elem !== AbsentValue) {
            polled = elem;
            this.subscriberHead.subscribers -= 1;
            if (this.subscriberHead.subscribers === 0) {
              this.self.publisherHead = this.self.publisherHead.next;
              this.self.publisherHead.value = AbsentValue;
              this.self.subscribersIndex += 1;
            }
            loop3 = false;
          }
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
      return polled;
    }
    pollUpTo(n) {
      const builder = [];
      const default_ = AbsentValue;
      let i = 0;
      while (i !== n) {
        const a = this.poll(default_);
        if (a === default_) {
          i = n;
        } else {
          builder.push(a);
          i += 1;
        }
      }
      return fromIterable2(builder);
    }
    unsubscribe() {
      if (!this.unsubscribed) {
        this.unsubscribed = true;
        this.self.publisherTail.subscribers -= 1;
        while (this.subscriberHead !== this.self.publisherTail) {
          if (this.subscriberHead.next.value !== AbsentValue) {
            this.subscriberHead.subscribers -= 1;
            if (this.subscriberHead.subscribers === 0) {
              this.self.publisherHead = this.self.publisherHead.next;
              this.self.publisherHead.value = AbsentValue;
              this.self.subscribersIndex += 1;
            }
          }
          this.subscriberHead = this.subscriberHead.next;
        }
      }
    }
  }

  class SubscriptionImpl extends Class {
    pubsub;
    subscribers;
    subscription;
    pollers;
    shutdownHook;
    shutdownFlag;
    strategy;
    replayWindow;
    [DequeueTypeId] = dequeueVariance;
    constructor(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, replayWindow) {
      super();
      this.pubsub = pubsub;
      this.subscribers = subscribers;
      this.subscription = subscription;
      this.pollers = pollers;
      this.shutdownHook = shutdownHook;
      this.shutdownFlag = shutdownFlag;
      this.strategy = strategy;
      this.replayWindow = replayWindow;
    }
    commit() {
      return this.take;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    capacity() {
      return this.pubsub.capacity;
    }
    isActive() {
      return !get6(this.shutdownFlag);
    }
    get size() {
      return suspend(() => get6(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() + this.replayWindow.remaining));
    }
    unsafeSize() {
      if (get6(this.shutdownFlag)) {
        return none2();
      }
      return some2(this.subscription.size() + this.replayWindow.remaining);
    }
    get isFull() {
      return suspend(() => get6(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() === this.capacity()));
    }
    get isEmpty() {
      return map10(this.size, (size9) => size9 === 0);
    }
    get shutdown() {
      return uninterruptible(withFiberRuntime((state) => {
        set2(this.shutdownFlag, true);
        return pipe(forEachParUnbounded(unsafePollAllQueue(this.pollers), (d) => deferredInterruptWith(d, state.id()), false), zipRight(sync(() => {
          this.subscribers.delete(this.subscription);
          this.subscription.unsubscribe();
          this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        })), whenEffect(deferredSucceed(this.shutdownHook, undefined)), asVoid);
      }));
    }
    get isShutdown() {
      return sync(() => get6(this.shutdownFlag));
    }
    get awaitShutdown() {
      return deferredAwait(this.shutdownHook);
    }
    get take() {
      return withFiberRuntime((state) => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        if (this.replayWindow.remaining > 0) {
          const message2 = this.replayWindow.take();
          return succeed(message2);
        }
        const message = isEmpty7(this.pollers) ? this.subscription.poll(EmptyMutableQueue) : EmptyMutableQueue;
        if (message === EmptyMutableQueue) {
          const deferred = deferredUnsafeMake(state.id());
          return pipe(suspend(() => {
            pipe(this.pollers, offer(deferred));
            pipe(this.subscribers, addSubscribers(this.subscription, this.pollers));
            this.strategy.unsafeCompletePollers(this.pubsub, this.subscribers, this.subscription, this.pollers);
            return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
          }), onInterrupt(() => sync(() => unsafeRemove2(this.pollers, deferred))));
        } else {
          this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
          return succeed(message);
        }
      });
    }
    get takeAll() {
      return suspend(() => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        const as4 = isEmpty7(this.pollers) ? unsafePollAllSubscription(this.subscription) : empty5();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        if (this.replayWindow.remaining > 0) {
          return succeed(appendAll2(this.replayWindow.takeAll(), as4));
        }
        return succeed(as4);
      });
    }
    takeUpTo(max5) {
      return suspend(() => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        let replay = undefined;
        if (this.replayWindow.remaining >= max5) {
          const as5 = this.replayWindow.takeN(max5);
          return succeed(as5);
        } else if (this.replayWindow.remaining > 0) {
          replay = this.replayWindow.takeAll();
          max5 = max5 - replay.length;
        }
        const as4 = isEmpty7(this.pollers) ? unsafePollN2(this.subscription, max5) : empty5();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        return replay ? succeed(appendAll2(replay, as4)) : succeed(as4);
      });
    }
    takeBetween(min3, max5) {
      return suspend(() => takeRemainderLoop2(this, min3, max5, empty5()));
    }
  }
  var takeRemainderLoop2 = (self2, min3, max5, acc) => {
    if (max5 < min3) {
      return succeed(acc);
    }
    return pipe(self2.takeUpTo(max5), flatMap8((bs) => {
      const remaining = min3 - bs.length;
      if (remaining === 1) {
        return pipe(self2.take, map10((b) => pipe(acc, appendAll2(bs), append2(b))));
      }
      if (remaining > 1) {
        return pipe(self2.take, flatMap8((b) => takeRemainderLoop2(self2, remaining - 1, max5 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
      }
      return succeed(pipe(acc, appendAll2(bs)));
    }));
  };

  class PubSubImpl {
    pubsub;
    subscribers;
    scope;
    shutdownHook;
    shutdownFlag;
    strategy;
    [EnqueueTypeId] = enqueueVariance;
    [DequeueTypeId] = dequeueVariance;
    constructor(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) {
      this.pubsub = pubsub;
      this.subscribers = subscribers;
      this.scope = scope5;
      this.shutdownHook = shutdownHook;
      this.shutdownFlag = shutdownFlag;
      this.strategy = strategy;
    }
    capacity() {
      return this.pubsub.capacity;
    }
    get size() {
      return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => this.pubsub.size()));
    }
    unsafeSize() {
      if (get6(this.shutdownFlag)) {
        return none2();
      }
      return some2(this.pubsub.size());
    }
    get isFull() {
      return map10(this.size, (size9) => size9 === this.capacity());
    }
    get isEmpty() {
      return map10(this.size, (size9) => size9 === 0);
    }
    get awaitShutdown() {
      return deferredAwait(this.shutdownHook);
    }
    get isShutdown() {
      return sync(() => get6(this.shutdownFlag));
    }
    get shutdown() {
      return uninterruptible(withFiberRuntime((state) => {
        pipe(this.shutdownFlag, set2(true));
        return pipe(this.scope.close(exitInterrupt(state.id())), zipRight(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, undefined)), asVoid);
      }));
    }
    publish(value) {
      return suspend(() => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        if (this.pubsub.publish(value)) {
          this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
          return succeed(true);
        }
        return this.strategy.handleSurplus(this.pubsub, this.subscribers, of2(value), this.shutdownFlag);
      });
    }
    isActive() {
      return !get6(this.shutdownFlag);
    }
    unsafeOffer(value) {
      if (get6(this.shutdownFlag)) {
        return false;
      }
      if (this.pubsub.publish(value)) {
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        return true;
      }
      return false;
    }
    publishAll(elements) {
      return suspend(() => {
        if (get6(this.shutdownFlag)) {
          return interrupt2;
        }
        const surplus = unsafePublishAll(this.pubsub, elements);
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        if (isEmpty(surplus)) {
          return succeed(true);
        }
        return this.strategy.handleSurplus(this.pubsub, this.subscribers, surplus, this.shutdownFlag);
      });
    }
    get subscribe() {
      const acquire = tap(all3([this.scope.fork(sequential2), makeSubscription(this.pubsub, this.subscribers, this.strategy)]), (tuple) => tuple[0].addFinalizer(() => tuple[1].shutdown));
      return map10(acquireRelease(acquire, (tuple, exit3) => tuple[0].close(exit3)), (tuple) => tuple[1]);
    }
    offer(value) {
      return this.publish(value);
    }
    offerAll(elements) {
      return this.publishAll(elements);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var makePubSub = (pubsub, strategy) => flatMap8(scopeMake(), (scope5) => map10(deferredMake(), (deferred) => unsafeMakePubSub(pubsub, new Map, scope5, deferred, make11(false), strategy)));
  var unsafeMakePubSub = (pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) => new PubSubImpl(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy);
  var ensureCapacity = (capacity3) => {
    if (capacity3 <= 0) {
      throw new InvalidPubSubCapacityException(`Cannot construct PubSub with capacity of ${capacity3}`);
    }
  };
  var unsafeCompleteDeferred2 = (deferred, a) => {
    deferredUnsafeDone(deferred, succeed(a));
  };
  var unsafeOfferAll2 = (queue, as4) => {
    return pipe(queue, offerAll(as4));
  };
  var unsafePollAllQueue = (queue) => {
    return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
  };
  var unsafePollAllSubscription = (subscription) => {
    return subscription.pollUpTo(Number.POSITIVE_INFINITY);
  };
  var unsafePollN2 = (subscription, max5) => {
    return subscription.pollUpTo(max5);
  };
  var unsafePublishAll = (pubsub, as4) => {
    return pubsub.publishAll(as4);
  };
  var unsafeRemove2 = (queue, value) => {
    unsafeOfferAll2(queue, pipe(unsafePollAllQueue(queue), filter3((elem) => elem !== value)));
  };

  class BackPressureStrategy2 {
    publishers = /* @__PURE__ */ unbounded();
    get shutdown() {
      return flatMap8(fiberId, (fiberId3) => flatMap8(sync(() => unsafePollAllQueue(this.publishers)), (publishers) => forEachConcurrentDiscard(publishers, ([_, deferred, last3]) => last3 ? pipe(deferredInterruptWith(deferred, fiberId3), asVoid) : void_, false, false)));
    }
    handleSurplus(pubsub, subscribers, elements, isShutdown2) {
      return withFiberRuntime((state) => {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          this.unsafeOffer(elements, deferred);
          this.unsafeOnPubSubEmptySpace(pubsub, subscribers);
          this.unsafeCompleteSubscribers(pubsub, subscribers);
          return get6(isShutdown2) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
      });
    }
    unsafeOnPubSubEmptySpace(pubsub, subscribers) {
      let keepPolling = true;
      while (keepPolling && !pubsub.isFull()) {
        const publisher = pipe(this.publishers, poll2(EmptyMutableQueue));
        if (publisher === EmptyMutableQueue) {
          keepPolling = false;
        } else {
          const published = pubsub.publish(publisher[0]);
          if (published && publisher[2]) {
            unsafeCompleteDeferred2(publisher[1], true);
          } else if (!published) {
            unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), prepend2(publisher)));
          }
          this.unsafeCompleteSubscribers(pubsub, subscribers);
        }
      }
    }
    unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
      return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
    }
    unsafeCompleteSubscribers(pubsub, subscribers) {
      return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
    }
    unsafeOffer(elements, deferred) {
      const iterator = elements[Symbol.iterator]();
      let next = iterator.next();
      if (!next.done) {
        while (true) {
          const value = next.value;
          next = iterator.next();
          if (next.done) {
            pipe(this.publishers, offer([value, deferred, true]));
            break;
          }
          pipe(this.publishers, offer([value, deferred, false]));
        }
      }
    }
    unsafeRemove(deferred) {
      unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), filter3(([_, a]) => a !== deferred)));
    }
  }

  class DroppingStrategy2 {
    get shutdown() {
      return void_;
    }
    handleSurplus(_pubsub, _subscribers, _elements, _isShutdown) {
      return succeed(false);
    }
    unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {}
    unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
      return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
    }
    unsafeCompleteSubscribers(pubsub, subscribers) {
      return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
    }
  }

  class SlidingStrategy2 {
    get shutdown() {
      return void_;
    }
    handleSurplus(pubsub, subscribers, elements, _isShutdown) {
      return sync(() => {
        this.unsafeSlidingPublish(pubsub, elements);
        this.unsafeCompleteSubscribers(pubsub, subscribers);
        return true;
      });
    }
    unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {}
    unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
      return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
    }
    unsafeCompleteSubscribers(pubsub, subscribers) {
      return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
    }
    unsafeSlidingPublish(pubsub, elements) {
      const it = elements[Symbol.iterator]();
      let next = it.next();
      if (!next.done && pubsub.capacity > 0) {
        let a = next.value;
        let loop3 = true;
        while (loop3) {
          pubsub.slide();
          const pub = pubsub.publish(a);
          if (pub && (next = it.next()) && !next.done) {
            a = next.value;
          } else if (pub) {
            loop3 = false;
          }
        }
      }
    }
  }
  var unsafeStrategyCompletePollers = (strategy, pubsub, subscribers, subscription, pollers) => {
    let keepPolling = true;
    while (keepPolling && !subscription.isEmpty()) {
      const poller = pipe(pollers, poll2(EmptyMutableQueue));
      if (poller === EmptyMutableQueue) {
        pipe(subscribers, removeSubscribers(subscription, pollers));
        if (isEmpty7(pollers)) {
          keepPolling = false;
        } else {
          pipe(subscribers, addSubscribers(subscription, pollers));
        }
      } else {
        const pollResult = subscription.poll(EmptyMutableQueue);
        if (pollResult === EmptyMutableQueue) {
          unsafeOfferAll2(pollers, pipe(unsafePollAllQueue(pollers), prepend2(poller)));
        } else {
          unsafeCompleteDeferred2(poller, pollResult);
          strategy.unsafeOnPubSubEmptySpace(pubsub, subscribers);
        }
      }
    }
  };
  var unsafeStrategyCompleteSubscribers = (strategy, pubsub, subscribers) => {
    for (const [subscription, pollersSet] of subscribers) {
      for (const pollers of pollersSet) {
        strategy.unsafeCompletePollers(pubsub, subscribers, subscription, pollers);
      }
    }
  };

  class ReplayBuffer {
    capacity;
    constructor(capacity3) {
      this.capacity = capacity3;
    }
    head = {
      value: AbsentValue,
      next: null
    };
    tail = this.head;
    size = 0;
    index = 0;
    slide() {
      this.index++;
    }
    offer(a) {
      this.tail.value = a;
      this.tail.next = {
        value: AbsentValue,
        next: null
      };
      this.tail = this.tail.next;
      if (this.size === this.capacity) {
        this.head = this.head.next;
      } else {
        this.size += 1;
      }
    }
    offerAll(as4) {
      for (const a of as4) {
        this.offer(a);
      }
    }
  }

  class ReplayWindowImpl {
    buffer;
    head;
    index;
    remaining;
    constructor(buffer) {
      this.buffer = buffer;
      this.index = buffer.index;
      this.remaining = buffer.size;
      this.head = buffer.head;
    }
    fastForward() {
      while (this.index < this.buffer.index) {
        this.head = this.head.next;
        this.index++;
      }
    }
    take() {
      if (this.remaining === 0) {
        return;
      } else if (this.index < this.buffer.index) {
        this.fastForward();
      }
      this.remaining--;
      const value = this.head.value;
      this.head = this.head.next;
      return value;
    }
    takeN(n) {
      if (this.remaining === 0) {
        return empty5();
      } else if (this.index < this.buffer.index) {
        this.fastForward();
      }
      const len = Math.min(n, this.remaining);
      const items = new Array(len);
      for (let i = 0;i < len; i++) {
        const value = this.head.value;
        this.head = this.head.next;
        items[i] = value;
      }
      this.remaining -= len;
      return unsafeFromArray(items);
    }
    takeAll() {
      return this.takeN(this.remaining);
    }
  }
  var emptyReplayWindow = {
    remaining: 0,
    take: () => {
      return;
    },
    takeN: () => empty5(),
    takeAll: () => empty5()
  };

  // node_modules/effect/dist/esm/PubSub.js
  var bounded4 = bounded3;
  var dropping3 = dropping2;
  var sliding3 = sliding2;
  var unbounded4 = unbounded3;
  var shutdown3 = shutdown2;
  var subscribe2 = subscribe;

  // node_modules/effect/dist/esm/Queue.js
  var exports_Queue = {};
  __export(exports_Queue, {
    unsafeOffer: () => unsafeOffer2,
    unbounded: () => unbounded5,
    takeUpTo: () => takeUpTo2,
    takeN: () => takeN2,
    takeBetween: () => takeBetween2,
    takeAll: () => takeAll2,
    take: () => take3,
    slidingStrategy: () => slidingStrategy2,
    sliding: () => sliding4,
    size: () => size10,
    shutdown: () => shutdown4,
    poll: () => poll6,
    offerAll: () => offerAll3,
    offer: () => offer3,
    make: () => make42,
    isShutdown: () => isShutdown3,
    isQueue: () => isQueue2,
    isFull: () => isFull3,
    isEnqueue: () => isEnqueue2,
    isEmpty: () => isEmpty12,
    isDequeue: () => isDequeue2,
    droppingStrategy: () => droppingStrategy2,
    dropping: () => dropping4,
    capacity: () => capacity4,
    bounded: () => bounded5,
    backPressureStrategy: () => backPressureStrategy2,
    awaitShutdown: () => awaitShutdown3,
    QueueStrategyTypeId: () => QueueStrategyTypeId2,
    EnqueueTypeId: () => EnqueueTypeId2,
    DequeueTypeId: () => DequeueTypeId2,
    BackingQueueTypeId: () => BackingQueueTypeId2
  });
  var EnqueueTypeId2 = EnqueueTypeId;
  var DequeueTypeId2 = DequeueTypeId;
  var QueueStrategyTypeId2 = QueueStrategyTypeId;
  var BackingQueueTypeId2 = BackingQueueTypeId;
  var isQueue2 = isQueue;
  var isDequeue2 = isDequeue;
  var isEnqueue2 = isEnqueue;
  var backPressureStrategy2 = backPressureStrategy;
  var droppingStrategy2 = droppingStrategy;
  var slidingStrategy2 = slidingStrategy;
  var make42 = make41;
  var bounded5 = bounded2;
  var dropping4 = dropping;
  var sliding4 = sliding;
  var unbounded5 = unbounded2;
  var capacity4 = capacity2;
  var size10 = size8;
  var isEmpty12 = isEmpty10;
  var isFull3 = isFull;
  var isShutdown3 = isShutdown;
  var awaitShutdown3 = awaitShutdown;
  var shutdown4 = shutdown;
  var offer3 = offer2;
  var unsafeOffer2 = unsafeOffer;
  var offerAll3 = offerAll2;
  var poll6 = poll5;
  var take3 = take2;
  var takeAll2 = takeAll;
  var takeUpTo2 = takeUpTo;
  var takeBetween2 = takeBetween;
  var takeN2 = takeN;

  // node_modules/effect/dist/esm/internal/opCodes/channelChildExecutorDecision.js
  var OP_CONTINUE2 = "Continue";
  var OP_CLOSE = "Close";
  var OP_YIELD2 = "Yield";

  // node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
  var ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
  var ChildExecutorDecisionTypeId = /* @__PURE__ */ Symbol.for(ChildExecutorDecisionSymbolKey);
  var proto4 = {
    [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
  };
  var Continue = (_) => {
    const op = Object.create(proto4);
    op._tag = OP_CONTINUE2;
    return op;
  };

  // node_modules/effect/dist/esm/internal/opCodes/continuation.js
  var OP_CONTINUATION_K = "ContinuationK";
  var OP_CONTINUATION_FINALIZER = "ContinuationFinalizer";

  // node_modules/effect/dist/esm/internal/channel/continuation.js
  var ContinuationTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelContinuation");
  var continuationVariance = {
    _Env: (_) => _,
    _InErr: (_) => _,
    _InElem: (_) => _,
    _InDone: (_) => _,
    _OutErr: (_) => _,
    _OutDone: (_) => _,
    _OutErr2: (_) => _,
    _OutElem: (_) => _,
    _OutDone2: (_) => _
  };

  class ContinuationKImpl {
    onSuccess;
    onHalt;
    _tag = OP_CONTINUATION_K;
    [ContinuationTypeId] = continuationVariance;
    constructor(onSuccess, onHalt) {
      this.onSuccess = onSuccess;
      this.onHalt = onHalt;
    }
    onExit(exit3) {
      return isFailure(exit3) ? this.onHalt(exit3.cause) : this.onSuccess(exit3.value);
    }
  }

  class ContinuationFinalizerImpl {
    finalizer;
    _tag = OP_CONTINUATION_FINALIZER;
    [ContinuationTypeId] = continuationVariance;
    constructor(finalizer) {
      this.finalizer = finalizer;
    }
  }

  // node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullStrategy.js
  var OP_PULL_AFTER_NEXT = "PullAfterNext";
  var OP_PULL_AFTER_ALL_ENQUEUED = "PullAfterAllEnqueued";

  // node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
  var UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
  var UpstreamPullStrategyTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullStrategySymbolKey);
  var upstreamPullStrategyVariance = {
    _A: (_) => _
  };
  var proto5 = {
    [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
  };
  var PullAfterNext = (emitSeparator) => {
    const op = Object.create(proto5);
    op._tag = OP_PULL_AFTER_NEXT;
    op.emitSeparator = emitSeparator;
    return op;
  };

  // node_modules/effect/dist/esm/internal/opCodes/channel.js
  var OP_BRACKET_OUT = "BracketOut";
  var OP_BRIDGE = "Bridge";
  var OP_CONCAT_ALL = "ConcatAll";
  var OP_EMIT = "Emit";
  var OP_ENSURING = "Ensuring";
  var OP_FAIL3 = "Fail";
  var OP_FOLD2 = "Fold";
  var OP_FROM_EFFECT2 = "FromEffect";
  var OP_PIPE_TO = "PipeTo";
  var OP_PROVIDE2 = "Provide";
  var OP_READ = "Read";
  var OP_SUCCEED = "Succeed";
  var OP_SUCCEED_NOW = "SucceedNow";
  var OP_SUSPEND2 = "Suspend";

  // node_modules/effect/dist/esm/internal/core-stream.js
  var ChannelSymbolKey = "effect/Channel";
  var ChannelTypeId2 = /* @__PURE__ */ Symbol.for(ChannelSymbolKey);
  var channelVariance2 = {
    _Env: (_) => _,
    _InErr: (_) => _,
    _InElem: (_) => _,
    _InDone: (_) => _,
    _OutErr: (_) => _,
    _OutElem: (_) => _,
    _OutDone: (_) => _
  };
  var proto6 = {
    [ChannelTypeId2]: channelVariance2,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var isChannel = (u) => hasProperty(u, ChannelTypeId2) || isEffect2(u);
  var acquireReleaseOut = /* @__PURE__ */ dual(2, (self2, release) => {
    const op = Object.create(proto6);
    op._tag = OP_BRACKET_OUT;
    op.acquire = () => self2;
    op.finalizer = release;
    return op;
  });
  var catchAllCause5 = /* @__PURE__ */ dual(2, (self2, f) => {
    const op = Object.create(proto6);
    op._tag = OP_FOLD2;
    op.channel = self2;
    op.k = new ContinuationKImpl(succeed10, f);
    return op;
  });
  var collectElements = (self2) => {
    return suspend5(() => {
      const builder = [];
      return flatMap13(pipeTo(self2, collectElementsReader(builder)), (value) => sync5(() => [fromIterable2(builder), value]));
    });
  };
  var collectElementsReader = (builder) => readWith({
    onInput: (outElem) => flatMap13(sync5(() => {
      builder.push(outElem);
    }), () => collectElementsReader(builder)),
    onFailure: fail11,
    onDone: succeedNow
  });
  var concatAllWith = (channels, f, g) => {
    const op = Object.create(proto6);
    op._tag = OP_CONCAT_ALL;
    op.combineInners = f;
    op.combineAll = g;
    op.onPull = () => PullAfterNext(none2());
    op.onEmit = () => Continue;
    op.value = () => channels;
    op.k = identity;
    return op;
  };
  var concatMapWith = /* @__PURE__ */ dual(4, (self2, f, g, h) => {
    const op = Object.create(proto6);
    op._tag = OP_CONCAT_ALL;
    op.combineInners = g;
    op.combineAll = h;
    op.onPull = () => PullAfterNext(none2());
    op.onEmit = () => Continue;
    op.value = () => self2;
    op.k = f;
    return op;
  });
  var embedInput = /* @__PURE__ */ dual(2, (self2, input) => {
    const op = Object.create(proto6);
    op._tag = OP_BRIDGE;
    op.input = input;
    op.channel = self2;
    return op;
  });
  var ensuringWith = /* @__PURE__ */ dual(2, (self2, finalizer) => {
    const op = Object.create(proto6);
    op._tag = OP_ENSURING;
    op.channel = self2;
    op.finalizer = finalizer;
    return op;
  });
  var fail11 = (error) => failCause10(fail5(error));
  var failCause10 = (cause3) => failCauseSync5(() => cause3);
  var failCauseSync5 = (evaluate2) => {
    const op = Object.create(proto6);
    op._tag = OP_FAIL3;
    op.error = evaluate2;
    return op;
  };
  var flatMap13 = /* @__PURE__ */ dual(2, (self2, f) => {
    const op = Object.create(proto6);
    op._tag = OP_FOLD2;
    op.channel = self2;
    op.k = new ContinuationKImpl(f, failCause10);
    return op;
  });
  var foldCauseChannel = /* @__PURE__ */ dual(2, (self2, options) => {
    const op = Object.create(proto6);
    op._tag = OP_FOLD2;
    op.channel = self2;
    op.k = new ContinuationKImpl(options.onSuccess, options.onFailure);
    return op;
  });
  var fromEffect4 = (effect2) => {
    const op = Object.create(proto6);
    op._tag = OP_FROM_EFFECT2;
    op.effect = () => effect2;
    return op;
  };
  var pipeTo = /* @__PURE__ */ dual(2, (self2, that) => {
    const op = Object.create(proto6);
    op._tag = OP_PIPE_TO;
    op.left = () => self2;
    op.right = () => that;
    return op;
  });
  var provideContext3 = /* @__PURE__ */ dual(2, (self2, env) => {
    const op = Object.create(proto6);
    op._tag = OP_PROVIDE2;
    op.context = () => env;
    op.inner = self2;
    return op;
  });
  var readWith = (options) => readWithCause({
    onInput: options.onInput,
    onFailure: (cause3) => match(failureOrCause2(cause3), {
      onLeft: options.onFailure,
      onRight: failCause10
    }),
    onDone: options.onDone
  });
  var readWithCause = (options) => {
    const op = Object.create(proto6);
    op._tag = OP_READ;
    op.more = options.onInput;
    op.done = new ContinuationKImpl(options.onDone, options.onFailure);
    return op;
  };
  var succeed10 = (value) => sync5(() => value);
  var succeedNow = (result) => {
    const op = Object.create(proto6);
    op._tag = OP_SUCCEED_NOW;
    op.terminal = result;
    return op;
  };
  var suspend5 = (evaluate2) => {
    const op = Object.create(proto6);
    op._tag = OP_SUSPEND2;
    op.channel = evaluate2;
    return op;
  };
  var sync5 = (evaluate2) => {
    const op = Object.create(proto6);
    op._tag = OP_SUCCEED;
    op.evaluate = evaluate2;
    return op;
  };
  var void_5 = /* @__PURE__ */ succeedNow(undefined);
  var write = (out) => {
    const op = Object.create(proto6);
    op._tag = OP_EMIT;
    op.out = out;
    return op;
  };

  // node_modules/effect/dist/esm/internal/opCodes/channelState.js
  var OP_DONE3 = "Done";
  var OP_EMIT2 = "Emit";
  var OP_FROM_EFFECT3 = "FromEffect";
  var OP_READ2 = "Read";

  // node_modules/effect/dist/esm/internal/channel/channelState.js
  var ChannelStateTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelState");
  var channelStateVariance = {
    _E: (_) => _,
    _R: (_) => _
  };
  var proto7 = {
    [ChannelStateTypeId]: channelStateVariance
  };
  var Done2 = () => {
    const op = Object.create(proto7);
    op._tag = OP_DONE3;
    return op;
  };
  var Emit = () => {
    const op = Object.create(proto7);
    op._tag = OP_EMIT2;
    return op;
  };
  var fromEffect5 = (effect2) => {
    const op = Object.create(proto7);
    op._tag = OP_FROM_EFFECT3;
    op.effect = effect2;
    return op;
  };
  var Read = (upstream, onEffect, onEmit, onDone) => {
    const op = Object.create(proto7);
    op._tag = OP_READ2;
    op.upstream = upstream;
    op.onEffect = onEffect;
    op.onEmit = onEmit;
    op.onDone = onDone;
    return op;
  };
  var isFromEffect = (self2) => self2._tag === OP_FROM_EFFECT3;
  var effect2 = (self2) => isFromEffect(self2) ? self2.effect : _void;
  var effectOrUndefinedIgnored = (self2) => isFromEffect(self2) ? ignore2(self2.effect) : undefined;

  // node_modules/effect/dist/esm/internal/channel/subexecutor.js
  var OP_PULL_FROM_CHILD = "PullFromChild";
  var OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
  var OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
  var OP_EMIT3 = "Emit";

  class PullFromChild {
    childExecutor;
    parentSubexecutor;
    onEmit;
    _tag = OP_PULL_FROM_CHILD;
    constructor(childExecutor, parentSubexecutor, onEmit) {
      this.childExecutor = childExecutor;
      this.parentSubexecutor = parentSubexecutor;
      this.onEmit = onEmit;
    }
    close(exit3) {
      const fin1 = this.childExecutor.close(exit3);
      const fin2 = this.parentSubexecutor.close(exit3);
      if (fin1 !== undefined && fin2 !== undefined) {
        return zipWith5(exit2(fin1), exit2(fin2), (exit1, exit22) => pipe(exit1, zipRight2(exit22)));
      } else if (fin1 !== undefined) {
        return fin1;
      } else if (fin2 !== undefined) {
        return fin2;
      } else {
        return;
      }
    }
    enqueuePullFromChild(_child) {
      return this;
    }
  }

  class PullFromUpstream {
    upstreamExecutor;
    createChild;
    lastDone;
    activeChildExecutors;
    combineChildResults;
    combineWithChildResult;
    onPull;
    onEmit;
    _tag = OP_PULL_FROM_UPSTREAM;
    constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
      this.upstreamExecutor = upstreamExecutor;
      this.createChild = createChild;
      this.lastDone = lastDone;
      this.activeChildExecutors = activeChildExecutors;
      this.combineChildResults = combineChildResults;
      this.combineWithChildResult = combineWithChildResult;
      this.onPull = onPull;
      this.onEmit = onEmit;
    }
    close(exit3) {
      const fin1 = this.upstreamExecutor.close(exit3);
      const fins = [...this.activeChildExecutors.map((child) => child !== undefined ? child.childExecutor.close(exit3) : undefined), fin1];
      const result = fins.reduce((acc, next) => {
        if (acc !== undefined && next !== undefined) {
          return zipWith5(acc, exit2(next), (exit1, exit22) => zipRight2(exit1, exit22));
        } else if (acc !== undefined) {
          return acc;
        } else if (next !== undefined) {
          return exit2(next);
        } else {
          return;
        }
      }, undefined);
      return result === undefined ? result : result;
    }
    enqueuePullFromChild(child) {
      return new PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
    }
  }

  class DrainChildExecutors {
    upstreamExecutor;
    lastDone;
    activeChildExecutors;
    upstreamDone;
    combineChildResults;
    combineWithChildResult;
    onPull;
    _tag = OP_DRAIN_CHILD_EXECUTORS;
    constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
      this.upstreamExecutor = upstreamExecutor;
      this.lastDone = lastDone;
      this.activeChildExecutors = activeChildExecutors;
      this.upstreamDone = upstreamDone;
      this.combineChildResults = combineChildResults;
      this.combineWithChildResult = combineWithChildResult;
      this.onPull = onPull;
    }
    close(exit3) {
      const fin1 = this.upstreamExecutor.close(exit3);
      const fins = [...this.activeChildExecutors.map((child) => child !== undefined ? child.childExecutor.close(exit3) : undefined), fin1];
      const result = fins.reduce((acc, next) => {
        if (acc !== undefined && next !== undefined) {
          return zipWith5(acc, exit2(next), (exit1, exit22) => zipRight2(exit1, exit22));
        } else if (acc !== undefined) {
          return acc;
        } else if (next !== undefined) {
          return exit2(next);
        } else {
          return;
        }
      }, undefined);
      return result === undefined ? result : result;
    }
    enqueuePullFromChild(child) {
      return new DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
    }
  }

  class Emit2 {
    value;
    next;
    _tag = OP_EMIT3;
    constructor(value, next) {
      this.value = value;
      this.next = next;
    }
    close(exit3) {
      const result = this.next.close(exit3);
      return result === undefined ? result : result;
    }
    enqueuePullFromChild(_child) {
      return this;
    }
  }

  // node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullRequest.js
  var OP_PULLED = "Pulled";
  var OP_NO_UPSTREAM = "NoUpstream";

  // node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
  var UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
  var UpstreamPullRequestTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullRequestSymbolKey);
  var upstreamPullRequestVariance = {
    _A: (_) => _
  };
  var proto8 = {
    [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
  };
  var Pulled = (value) => {
    const op = Object.create(proto8);
    op._tag = OP_PULLED;
    op.value = value;
    return op;
  };
  var NoUpstream = (activeDownstreamCount) => {
    const op = Object.create(proto8);
    op._tag = OP_NO_UPSTREAM;
    op.activeDownstreamCount = activeDownstreamCount;
    return op;
  };

  // node_modules/effect/dist/esm/internal/channel/channelExecutor.js
  class ChannelExecutor {
    _activeSubexecutor = undefined;
    _cancelled = undefined;
    _closeLastSubstream = undefined;
    _currentChannel;
    _done = undefined;
    _doneStack = [];
    _emitted = undefined;
    _executeCloseLastSubstream;
    _input = undefined;
    _inProgressFinalizer = undefined;
    _providedEnv;
    constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
      this._currentChannel = initialChannel;
      this._executeCloseLastSubstream = executeCloseLastSubstream;
      this._providedEnv = providedEnv;
    }
    run() {
      let result = undefined;
      while (result === undefined) {
        if (this._cancelled !== undefined) {
          result = this.processCancellation();
        } else if (this._activeSubexecutor !== undefined) {
          result = this.runSubexecutor();
        } else {
          try {
            if (this._currentChannel === undefined) {
              result = Done2();
            } else {
              if (isEffect2(this._currentChannel)) {
                this._currentChannel = fromEffect4(this._currentChannel);
              }
              switch (this._currentChannel._tag) {
                case OP_BRACKET_OUT: {
                  result = this.runBracketOut(this._currentChannel);
                  break;
                }
                case OP_BRIDGE: {
                  const bridgeInput = this._currentChannel.input;
                  this._currentChannel = this._currentChannel.channel;
                  if (this._input !== undefined) {
                    const inputExecutor = this._input;
                    this._input = undefined;
                    const drainer = () => flatMap11(bridgeInput.awaitRead(), () => suspend3(() => {
                      const state = inputExecutor.run();
                      switch (state._tag) {
                        case OP_DONE3: {
                          return match6(inputExecutor.getDone(), {
                            onFailure: (cause3) => bridgeInput.error(cause3),
                            onSuccess: (value) => bridgeInput.done(value)
                          });
                        }
                        case OP_EMIT2: {
                          return flatMap11(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                        }
                        case OP_FROM_EFFECT3: {
                          return matchCauseEffect3(state.effect, {
                            onFailure: (cause3) => bridgeInput.error(cause3),
                            onSuccess: () => drainer()
                          });
                        }
                        case OP_READ2: {
                          return readUpstream(state, () => drainer(), (cause3) => bridgeInput.error(cause3));
                        }
                      }
                    }));
                    result = fromEffect5(flatMap11(forkDaemon2(interruptible4(drainer())), (fiber) => sync3(() => this.addFinalizer((exit3) => flatMap11(interrupt6(fiber), () => suspend3(() => {
                      const effect3 = this.restorePipe(exit3, inputExecutor);
                      return effect3 !== undefined ? effect3 : _void;
                    }))))));
                  }
                  break;
                }
                case OP_CONCAT_ALL: {
                  const executor = new ChannelExecutor(this._currentChannel.value(), this._providedEnv, (effect3) => sync3(() => {
                    const prevLastClose = this._closeLastSubstream === undefined ? _void : this._closeLastSubstream;
                    this._closeLastSubstream = pipe(prevLastClose, zipRight3(effect3));
                  }));
                  executor._input = this._input;
                  const channel = this._currentChannel;
                  this._activeSubexecutor = new PullFromUpstream(executor, (value) => channel.k(value), undefined, [], (x, y) => channel.combineInners(x, y), (x, y) => channel.combineAll(x, y), (request2) => channel.onPull(request2), (value) => channel.onEmit(value));
                  this._closeLastSubstream = undefined;
                  this._currentChannel = undefined;
                  break;
                }
                case OP_EMIT: {
                  this._emitted = this._currentChannel.out;
                  this._currentChannel = this._activeSubexecutor !== undefined ? undefined : void_5;
                  result = Emit();
                  break;
                }
                case OP_ENSURING: {
                  this.runEnsuring(this._currentChannel);
                  break;
                }
                case OP_FAIL3: {
                  result = this.doneHalt(this._currentChannel.error());
                  break;
                }
                case OP_FOLD2: {
                  this._doneStack.push(this._currentChannel.k);
                  this._currentChannel = this._currentChannel.channel;
                  break;
                }
                case OP_FROM_EFFECT2: {
                  const effect3 = this._providedEnv === undefined ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide2(this._providedEnv));
                  result = fromEffect5(matchCauseEffect3(effect3, {
                    onFailure: (cause3) => {
                      const state = this.doneHalt(cause3);
                      return state !== undefined && isFromEffect(state) ? state.effect : _void;
                    },
                    onSuccess: (value) => {
                      const state = this.doneSucceed(value);
                      return state !== undefined && isFromEffect(state) ? state.effect : _void;
                    }
                  }));
                  break;
                }
                case OP_PIPE_TO: {
                  const previousInput = this._input;
                  const leftExec = new ChannelExecutor(this._currentChannel.left(), this._providedEnv, (effect3) => this._executeCloseLastSubstream(effect3));
                  leftExec._input = previousInput;
                  this._input = leftExec;
                  this.addFinalizer((exit3) => {
                    const effect3 = this.restorePipe(exit3, previousInput);
                    return effect3 !== undefined ? effect3 : _void;
                  });
                  this._currentChannel = this._currentChannel.right();
                  break;
                }
                case OP_PROVIDE2: {
                  const previousEnv = this._providedEnv;
                  this._providedEnv = this._currentChannel.context();
                  this._currentChannel = this._currentChannel.inner;
                  this.addFinalizer(() => sync3(() => {
                    this._providedEnv = previousEnv;
                  }));
                  break;
                }
                case OP_READ: {
                  const read = this._currentChannel;
                  result = Read(this._input, identity, (emitted) => {
                    try {
                      this._currentChannel = read.more(emitted);
                    } catch (error) {
                      this._currentChannel = read.done.onExit(die3(error));
                    }
                    return;
                  }, (exit3) => {
                    const onExit4 = (exit4) => {
                      return read.done.onExit(exit4);
                    };
                    this._currentChannel = onExit4(exit3);
                    return;
                  });
                  break;
                }
                case OP_SUCCEED: {
                  result = this.doneSucceed(this._currentChannel.evaluate());
                  break;
                }
                case OP_SUCCEED_NOW: {
                  result = this.doneSucceed(this._currentChannel.terminal);
                  break;
                }
                case OP_SUSPEND2: {
                  this._currentChannel = this._currentChannel.channel();
                  break;
                }
              }
            }
          } catch (error) {
            this._currentChannel = failCause10(die4(error));
          }
        }
      }
      return result;
    }
    getDone() {
      return this._done;
    }
    getEmit() {
      return this._emitted;
    }
    cancelWith(exit3) {
      this._cancelled = exit3;
    }
    clearInProgressFinalizer() {
      this._inProgressFinalizer = undefined;
    }
    storeInProgressFinalizer(finalizer) {
      this._inProgressFinalizer = finalizer;
    }
    popAllFinalizers(exit3) {
      const finalizers = [];
      let next = this._doneStack.pop();
      while (next) {
        if (next._tag === "ContinuationFinalizer") {
          finalizers.push(next.finalizer);
        }
        next = this._doneStack.pop();
      }
      const effect3 = finalizers.length === 0 ? _void : runFinalizers(finalizers, exit3);
      this.storeInProgressFinalizer(effect3);
      return effect3;
    }
    popNextFinalizers() {
      const builder = [];
      while (this._doneStack.length !== 0) {
        const cont = this._doneStack[this._doneStack.length - 1];
        if (cont._tag === OP_CONTINUATION_K) {
          return builder;
        }
        builder.push(cont);
        this._doneStack.pop();
      }
      return builder;
    }
    restorePipe(exit3, prev) {
      const currInput = this._input;
      this._input = prev;
      if (currInput !== undefined) {
        const effect3 = currInput.close(exit3);
        return effect3;
      }
      return _void;
    }
    close(exit3) {
      let runInProgressFinalizers = undefined;
      const finalizer = this._inProgressFinalizer;
      if (finalizer !== undefined) {
        runInProgressFinalizers = pipe(finalizer, ensuring2(sync3(() => this.clearInProgressFinalizer())));
      }
      let closeSelf = undefined;
      const selfFinalizers = this.popAllFinalizers(exit3);
      if (selfFinalizers !== undefined) {
        closeSelf = pipe(selfFinalizers, ensuring2(sync3(() => this.clearInProgressFinalizer())));
      }
      const closeSubexecutors = this._activeSubexecutor === undefined ? undefined : this._activeSubexecutor.close(exit3);
      if (closeSubexecutors === undefined && runInProgressFinalizers === undefined && closeSelf === undefined) {
        return;
      }
      return pipe(exit2(ifNotNull(closeSubexecutors)), zip5(exit2(ifNotNull(runInProgressFinalizers))), zip5(exit2(ifNotNull(closeSelf))), map16(([[exit1, exit22], exit32]) => pipe(exit1, zipRight2(exit22), zipRight2(exit32))), uninterruptible2, flatMap11((exit4) => suspend3(() => exit4)));
    }
    doneSucceed(value) {
      if (this._doneStack.length === 0) {
        this._done = succeed3(value);
        this._currentChannel = undefined;
        return Done2();
      }
      const head5 = this._doneStack[this._doneStack.length - 1];
      if (head5._tag === OP_CONTINUATION_K) {
        this._doneStack.pop();
        this._currentChannel = head5.onSuccess(value);
        return;
      }
      const finalizers = this.popNextFinalizers();
      if (this._doneStack.length === 0) {
        this._doneStack = finalizers.reverse();
        this._done = succeed3(value);
        this._currentChannel = undefined;
        return Done2();
      }
      const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), succeed3(value));
      this.storeInProgressFinalizer(finalizerEffect);
      const effect3 = pipe(finalizerEffect, ensuring2(sync3(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap11(() => sync3(() => this.doneSucceed(value))));
      return fromEffect5(effect3);
    }
    doneHalt(cause3) {
      if (this._doneStack.length === 0) {
        this._done = failCause3(cause3);
        this._currentChannel = undefined;
        return Done2();
      }
      const head5 = this._doneStack[this._doneStack.length - 1];
      if (head5._tag === OP_CONTINUATION_K) {
        this._doneStack.pop();
        try {
          this._currentChannel = head5.onHalt(cause3);
        } catch (error) {
          this._currentChannel = failCause10(die4(error));
        }
        return;
      }
      const finalizers = this.popNextFinalizers();
      if (this._doneStack.length === 0) {
        this._doneStack = finalizers.reverse();
        this._done = failCause3(cause3);
        this._currentChannel = undefined;
        return Done2();
      }
      const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), failCause3(cause3));
      this.storeInProgressFinalizer(finalizerEffect);
      const effect3 = pipe(finalizerEffect, ensuring2(sync3(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap11(() => sync3(() => this.doneHalt(cause3))));
      return fromEffect5(effect3);
    }
    processCancellation() {
      this._currentChannel = undefined;
      this._done = this._cancelled;
      this._cancelled = undefined;
      return Done2();
    }
    runBracketOut(bracketOut) {
      const effect3 = uninterruptible2(matchCauseEffect3(this.provide(bracketOut.acquire()), {
        onFailure: (cause3) => sync3(() => {
          this._currentChannel = failCause10(cause3);
        }),
        onSuccess: (out) => sync3(() => {
          this.addFinalizer((exit3) => this.provide(bracketOut.finalizer(out, exit3)));
          this._currentChannel = write(out);
        })
      }));
      return fromEffect5(effect3);
    }
    provide(effect3) {
      if (this._providedEnv === undefined) {
        return effect3;
      }
      return pipe(effect3, provide2(this._providedEnv));
    }
    runEnsuring(ensuring3) {
      this.addFinalizer(ensuring3.finalizer);
      this._currentChannel = ensuring3.channel;
    }
    addFinalizer(f) {
      this._doneStack.push(new ContinuationFinalizerImpl(f));
    }
    runSubexecutor() {
      const subexecutor = this._activeSubexecutor;
      switch (subexecutor._tag) {
        case OP_PULL_FROM_CHILD: {
          return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
        }
        case OP_PULL_FROM_UPSTREAM: {
          return this.pullFromUpstream(subexecutor);
        }
        case OP_DRAIN_CHILD_EXECUTORS: {
          return this.drainChildExecutors(subexecutor);
        }
        case OP_EMIT3: {
          this._emitted = subexecutor.value;
          this._activeSubexecutor = subexecutor.next;
          return Emit();
        }
      }
    }
    replaceSubexecutor(nextSubExec) {
      this._currentChannel = undefined;
      this._activeSubexecutor = nextSubExec;
    }
    finishWithExit(exit3) {
      const state = match6(exit3, {
        onFailure: (cause3) => this.doneHalt(cause3),
        onSuccess: (value) => this.doneSucceed(value)
      });
      this._activeSubexecutor = undefined;
      return state === undefined ? _void : effect2(state);
    }
    finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
      this.addFinalizer(() => pipe(closeFuncs, forEach6((closeFunc) => pipe(sync3(() => closeFunc(subexecutorDone)), flatMap11((closeEffect) => closeEffect !== undefined ? closeEffect : _void)), {
        discard: true
      })));
      const state = pipe(subexecutorDone, match6({
        onFailure: (cause3) => this.doneHalt(cause3),
        onSuccess: (value) => this.doneSucceed(value)
      }));
      this._activeSubexecutor = undefined;
      return state;
    }
    applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
      switch (strategy._tag) {
        case OP_PULL_AFTER_NEXT: {
          const shouldPrepend = !upstreamFinished || queue.some((subexecutor) => subexecutor !== undefined);
          return [strategy.emitSeparator, shouldPrepend ? [undefined, ...queue] : queue];
        }
        case OP_PULL_AFTER_ALL_ENQUEUED: {
          const shouldEnqueue = !upstreamFinished || queue.some((subexecutor) => subexecutor !== undefined);
          return [strategy.emitSeparator, shouldEnqueue ? [...queue, undefined] : queue];
        }
      }
    }
    pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
      return Read(childExecutor, identity, (emitted) => {
        const childExecutorDecision = onEmitted(emitted);
        switch (childExecutorDecision._tag) {
          case OP_CONTINUE2: {
            break;
          }
          case OP_CLOSE: {
            this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
            break;
          }
          case OP_YIELD2: {
            const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
            this.replaceSubexecutor(modifiedParent);
            break;
          }
        }
        this._activeSubexecutor = new Emit2(emitted, this._activeSubexecutor);
        return;
      }, match6({
        onFailure: (cause3) => {
          const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3);
          return state === undefined ? undefined : effectOrUndefinedIgnored(state);
        },
        onSuccess: (doneValue) => {
          this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
          return;
        }
      }));
    }
    finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
      const subexecutor = parentSubexecutor;
      switch (subexecutor._tag) {
        case OP_PULL_FROM_UPSTREAM: {
          const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
          this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
          this.replaceSubexecutor(modifiedParent);
          break;
        }
        case OP_DRAIN_CHILD_EXECUTORS: {
          const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
          this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
          this.replaceSubexecutor(modifiedParent);
          break;
        }
        default: {
          break;
        }
      }
    }
    handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3) {
      return this.finishSubexecutorWithCloseEffect(failCause3(cause3), (exit3) => parentSubexecutor.close(exit3), (exit3) => childExecutor.close(exit3));
    }
    pullFromUpstream(subexecutor) {
      if (subexecutor.activeChildExecutors.length === 0) {
        return this.performPullFromUpstream(subexecutor);
      }
      const activeChild = subexecutor.activeChildExecutors[0];
      const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
      if (activeChild === undefined) {
        return this.performPullFromUpstream(parentSubexecutor);
      }
      this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
      return;
    }
    performPullFromUpstream(subexecutor) {
      return Read(subexecutor.upstreamExecutor, (effect3) => {
        const closeLastSubstream = this._closeLastSubstream === undefined ? _void : this._closeLastSubstream;
        this._closeLastSubstream = undefined;
        return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight3(effect3));
      }, (emitted) => {
        if (this._closeLastSubstream !== undefined) {
          const closeLastSubstream = this._closeLastSubstream;
          this._closeLastSubstream = undefined;
          return pipe(this._executeCloseLastSubstream(closeLastSubstream), map16(() => {
            const childExecutor2 = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
            childExecutor2._input = this._input;
            const [emitSeparator2, updatedChildExecutors2] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
            this._activeSubexecutor = new PullFromChild(childExecutor2, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors2, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
            if (isSome2(emitSeparator2)) {
              this._activeSubexecutor = new Emit2(emitSeparator2.value, this._activeSubexecutor);
            }
            return;
          }));
        }
        const childExecutor = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
        childExecutor._input = this._input;
        const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
        this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
        if (isSome2(emitSeparator)) {
          this._activeSubexecutor = new Emit2(emitSeparator.value, this._activeSubexecutor);
        }
        return;
      }, (exit3) => {
        if (subexecutor.activeChildExecutors.some((subexecutor2) => subexecutor2 !== undefined)) {
          const drain = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [undefined, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
          if (this._closeLastSubstream !== undefined) {
            const closeLastSubstream2 = this._closeLastSubstream;
            this._closeLastSubstream = undefined;
            return pipe(this._executeCloseLastSubstream(closeLastSubstream2), map16(() => this.replaceSubexecutor(drain)));
          }
          this.replaceSubexecutor(drain);
          return;
        }
        const closeLastSubstream = this._closeLastSubstream;
        const state = this.finishSubexecutorWithCloseEffect(pipe(exit3, map11((a) => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, (exit4) => subexecutor.upstreamExecutor.close(exit4));
        return state === undefined ? undefined : effectOrUndefinedIgnored(state);
      });
    }
    drainChildExecutors(subexecutor) {
      if (subexecutor.activeChildExecutors.length === 0) {
        const lastClose = this._closeLastSubstream;
        if (lastClose !== undefined) {
          this.addFinalizer(() => succeed8(lastClose));
        }
        return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, (exit3) => subexecutor.upstreamExecutor.close(exit3));
      }
      const activeChild = subexecutor.activeChildExecutors[0];
      const rest = subexecutor.activeChildExecutors.slice(1);
      if (activeChild === undefined) {
        const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n, curr) => curr !== undefined ? n + 1 : n, 0))));
        this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
        if (isSome2(emitSeparator)) {
          this._emitted = emitSeparator.value;
          return Emit();
        }
        return;
      }
      const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
      this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
      return;
    }
  }
  var ifNotNull = (effect3) => effect3 !== undefined ? effect3 : _void;
  var runFinalizers = (finalizers, exit3) => {
    return pipe(forEach6(finalizers, (fin) => exit2(fin(exit3))), map16((exits) => pipe(all(exits), getOrElse(() => void_2))), flatMap11((exit4) => suspend3(() => exit4)));
  };
  var readUpstream = (r, onSuccess, onFailure) => {
    const readStack = [r];
    const read = () => {
      const current = readStack.pop();
      if (current === undefined || current.upstream === undefined) {
        return dieMessage2("Unexpected end of input for channel execution");
      }
      const state = current.upstream.run();
      switch (state._tag) {
        case OP_EMIT2: {
          const emitEffect = current.onEmit(current.upstream.getEmit());
          if (readStack.length === 0) {
            if (emitEffect === undefined) {
              return suspend3(onSuccess);
            }
            return pipe(emitEffect, matchCauseEffect3({
              onFailure,
              onSuccess
            }));
          }
          if (emitEffect === undefined) {
            return suspend3(() => read());
          }
          return pipe(emitEffect, matchCauseEffect3({
            onFailure,
            onSuccess: () => read()
          }));
        }
        case OP_DONE3: {
          const doneEffect = current.onDone(current.upstream.getDone());
          if (readStack.length === 0) {
            if (doneEffect === undefined) {
              return suspend3(onSuccess);
            }
            return pipe(doneEffect, matchCauseEffect3({
              onFailure,
              onSuccess
            }));
          }
          if (doneEffect === undefined) {
            return suspend3(() => read());
          }
          return pipe(doneEffect, matchCauseEffect3({
            onFailure,
            onSuccess: () => read()
          }));
        }
        case OP_FROM_EFFECT3: {
          readStack.push(current);
          return pipe(current.onEffect(state.effect), catchAllCause3((cause3) => suspend3(() => {
            const doneEffect = current.onDone(failCause3(cause3));
            return doneEffect === undefined ? _void : doneEffect;
          })), matchCauseEffect3({
            onFailure,
            onSuccess: () => read()
          }));
        }
        case OP_READ2: {
          readStack.push(current);
          readStack.push(state);
          return suspend3(() => read());
        }
      }
    };
    return read();
  };
  var runIn = /* @__PURE__ */ dual(2, (self2, scope5) => {
    const run = (channelDeferred, scopeDeferred, scope6) => acquireUseRelease2(sync3(() => new ChannelExecutor(self2, undefined, identity)), (exec) => suspend3(() => runScopedInterpret(exec.run(), exec).pipe(intoDeferred2(channelDeferred), zipRight3(_await(channelDeferred)), zipLeft2(_await(scopeDeferred)))), (exec, exit3) => {
      const finalize = exec.close(exit3);
      if (finalize === undefined) {
        return _void;
      }
      return tapErrorCause3(finalize, (cause3) => addFinalizer2(scope6, failCause8(cause3)));
    });
    return uninterruptibleMask3((restore) => all4([fork2(scope5, sequential3), make19(), make19()]).pipe(flatMap11(([child, channelDeferred, scopeDeferred]) => restore(run(channelDeferred, scopeDeferred, child)).pipe(forkIn2(scope5), flatMap11((fiber) => scope5.addFinalizer((exit3) => {
      const interruptors3 = isFailure(exit3) ? interruptors2(exit3.cause) : undefined;
      return isDone(channelDeferred).pipe(flatMap11((isDone6) => isDone6 ? succeed2(scopeDeferred, undefined).pipe(zipRight3(_await3(fiber)), zipRight3(inheritAll2(fiber))) : succeed2(scopeDeferred, undefined).pipe(zipRight3(interruptors3 && size3(interruptors3) > 0 ? interruptAs(fiber, combineAll2(interruptors3)) : interrupt6(fiber)), zipRight3(inheritAll2(fiber)))));
    }).pipe(zipRight3(restore(_await(channelDeferred)))))))));
  });
  var runScopedInterpret = (channelState, exec) => {
    const op = channelState;
    switch (op._tag) {
      case OP_FROM_EFFECT3: {
        return pipe(op.effect, flatMap11(() => runScopedInterpret(exec.run(), exec)));
      }
      case OP_EMIT2: {
        return runScopedInterpret(exec.run(), exec);
      }
      case OP_DONE3: {
        return suspend3(() => exec.getDone());
      }
      case OP_READ2: {
        return readUpstream(op, () => runScopedInterpret(exec.run(), exec), failCause8);
      }
    }
  };

  // node_modules/effect/dist/esm/internal/opCodes/channelMergeDecision.js
  var OP_DONE4 = "Done";
  var OP_AWAIT = "Await";

  // node_modules/effect/dist/esm/internal/channel/mergeDecision.js
  var MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
  var MergeDecisionTypeId = /* @__PURE__ */ Symbol.for(MergeDecisionSymbolKey);
  var proto9 = {
    [MergeDecisionTypeId]: {
      _R: (_) => _,
      _E0: (_) => _,
      _Z0: (_) => _,
      _E: (_) => _,
      _Z: (_) => _
    }
  };
  var Done3 = (effect3) => {
    const op = Object.create(proto9);
    op._tag = OP_DONE4;
    op.effect = effect3;
    return op;
  };
  var Await = (f) => {
    const op = Object.create(proto9);
    op._tag = OP_AWAIT;
    op.f = f;
    return op;
  };

  // node_modules/effect/dist/esm/internal/opCodes/channelMergeState.js
  var OP_BOTH_RUNNING = "BothRunning";
  var OP_LEFT_DONE = "LeftDone";
  var OP_RIGHT_DONE = "RightDone";

  // node_modules/effect/dist/esm/internal/channel/mergeState.js
  var MergeStateSymbolKey = "effect/ChannelMergeState";
  var MergeStateTypeId = /* @__PURE__ */ Symbol.for(MergeStateSymbolKey);
  var proto10 = {
    [MergeStateTypeId]: MergeStateTypeId
  };
  var BothRunning = (left3, right3) => {
    const op = Object.create(proto10);
    op._tag = OP_BOTH_RUNNING;
    op.left = left3;
    op.right = right3;
    return op;
  };
  var LeftDone = (f) => {
    const op = Object.create(proto10);
    op._tag = OP_LEFT_DONE;
    op.f = f;
    return op;
  };
  var RightDone = (f) => {
    const op = Object.create(proto10);
    op._tag = OP_RIGHT_DONE;
    op.f = f;
    return op;
  };

  // node_modules/effect/dist/esm/internal/opCodes/channelMergeStrategy.js
  var OP_BACK_PRESSURE = "BackPressure";
  var OP_BUFFER_SLIDING = "BufferSliding";

  // node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
  var MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
  var MergeStrategyTypeId = /* @__PURE__ */ Symbol.for(MergeStrategySymbolKey);
  var proto11 = {
    [MergeStrategyTypeId]: MergeStrategyTypeId
  };
  var BackPressure = (_) => {
    const op = Object.create(proto11);
    op._tag = OP_BACK_PRESSURE;
    return op;
  };
  var BufferSliding = (_) => {
    const op = Object.create(proto11);
    op._tag = OP_BUFFER_SLIDING;
    return op;
  };
  var match14 = /* @__PURE__ */ dual(2, (self2, {
    onBackPressure,
    onBufferSliding
  }) => {
    switch (self2._tag) {
      case OP_BACK_PRESSURE: {
        return onBackPressure();
      }
      case OP_BUFFER_SLIDING: {
        return onBufferSliding();
      }
    }
  });

  // node_modules/effect/dist/esm/internal/channel/singleProducerAsyncInput.js
  var OP_STATE_EMPTY = "Empty";
  var OP_STATE_EMIT = "Emit";
  var OP_STATE_ERROR = "Error";
  var OP_STATE_DONE2 = "Done";
  var stateEmpty = (notifyProducer) => ({
    _tag: OP_STATE_EMPTY,
    notifyProducer
  });
  var stateEmit = (notifyConsumers) => ({
    _tag: OP_STATE_EMIT,
    notifyConsumers
  });
  var stateError = (cause3) => ({
    _tag: OP_STATE_ERROR,
    cause: cause3
  });
  var stateDone = (done8) => ({
    _tag: OP_STATE_DONE2,
    done: done8
  });

  class SingleProducerAsyncInputImpl {
    ref;
    constructor(ref) {
      this.ref = ref;
    }
    awaitRead() {
      return flatten9(modify4(this.ref, (state) => state._tag === OP_STATE_EMPTY ? [_await(state.notifyProducer), state] : [_void, state]));
    }
    get close() {
      return fiberIdWith2((fiberId3) => this.error(interrupt5(fiberId3)));
    }
    done(value) {
      return flatten9(modify4(this.ref, (state) => {
        switch (state._tag) {
          case OP_STATE_EMPTY: {
            return [_await(state.notifyProducer), state];
          }
          case OP_STATE_EMIT: {
            return [forEach6(state.notifyConsumers, (deferred) => succeed2(deferred, left2(value)), {
              discard: true
            }), stateDone(value)];
          }
          case OP_STATE_ERROR: {
            return [interrupt7, state];
          }
          case OP_STATE_DONE2: {
            return [interrupt7, state];
          }
        }
      }));
    }
    emit(element) {
      return flatMap11(make19(), (deferred) => flatten9(modify4(this.ref, (state) => {
        switch (state._tag) {
          case OP_STATE_EMPTY: {
            return [_await(state.notifyProducer), state];
          }
          case OP_STATE_EMIT: {
            const notifyConsumer = state.notifyConsumers[0];
            const notifyConsumers = state.notifyConsumers.slice(1);
            if (notifyConsumer !== undefined) {
              return [succeed2(notifyConsumer, right2(element)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
            }
            throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues");
          }
          case OP_STATE_ERROR: {
            return [interrupt7, state];
          }
          case OP_STATE_DONE2: {
            return [interrupt7, state];
          }
        }
      })));
    }
    error(cause3) {
      return flatten9(modify4(this.ref, (state) => {
        switch (state._tag) {
          case OP_STATE_EMPTY: {
            return [_await(state.notifyProducer), state];
          }
          case OP_STATE_EMIT: {
            return [forEach6(state.notifyConsumers, (deferred) => failCause2(deferred, cause3), {
              discard: true
            }), stateError(cause3)];
          }
          case OP_STATE_ERROR: {
            return [interrupt7, state];
          }
          case OP_STATE_DONE2: {
            return [interrupt7, state];
          }
        }
      }));
    }
    get take() {
      return this.takeWith((cause3) => failCause3(map12(cause3, left2)), (elem) => succeed3(elem), (done8) => fail4(right2(done8)));
    }
    takeWith(onError3, onElement, onDone) {
      return flatMap11(make19(), (deferred) => flatten9(modify4(this.ref, (state) => {
        switch (state._tag) {
          case OP_STATE_EMPTY: {
            return [zipRight3(succeed2(state.notifyProducer, undefined), matchCause3(_await(deferred), {
              onFailure: onError3,
              onSuccess: match({
                onLeft: onDone,
                onRight: onElement
              })
            })), stateEmit([deferred])];
          }
          case OP_STATE_EMIT: {
            return [matchCause3(_await(deferred), {
              onFailure: onError3,
              onSuccess: match({
                onLeft: onDone,
                onRight: onElement
              })
            }), stateEmit([...state.notifyConsumers, deferred])];
          }
          case OP_STATE_ERROR: {
            return [succeed8(onError3(state.cause)), state];
          }
          case OP_STATE_DONE2: {
            return [succeed8(onDone(state.done)), state];
          }
        }
      })));
    }
  }
  var make43 = () => pipe(make19(), flatMap11((deferred) => make29(stateEmpty(deferred))), map16((ref) => new SingleProducerAsyncInputImpl(ref)));

  // node_modules/effect/dist/esm/internal/channel.js
  var acquireUseRelease3 = (acquire, use, release) => flatMap13(fromEffect4(make29(() => _void)), (ref) => pipe(fromEffect4(uninterruptible2(tap3(acquire, (a) => set6(ref, (exit3) => release(a, exit3))))), flatMap13(use), ensuringWith((exit3) => flatMap11(get12(ref), (f) => f(exit3)))));
  var as4 = /* @__PURE__ */ dual(2, (self2, value) => map18(self2, () => value));
  var catchAll5 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause5(self2, (cause3) => match(failureOrCause2(cause3), {
    onLeft: f,
    onRight: failCause10
  })));
  var concatMap = /* @__PURE__ */ dual(2, (self2, f) => concatMapWith(self2, f, () => {
    return;
  }, () => {
    return;
  }));
  var drain = (self2) => {
    const drainer = readWithCause({
      onInput: () => drainer,
      onFailure: failCause10,
      onDone: succeed10
    });
    return pipeTo(self2, drainer);
  };
  var ensuring3 = /* @__PURE__ */ dual(2, (self2, finalizer) => ensuringWith(self2, () => finalizer));
  var flatten11 = (self2) => flatMap13(self2, identity);
  var foldChannel = /* @__PURE__ */ dual(2, (self2, options) => foldCauseChannel(self2, {
    onFailure: (cause3) => {
      const either4 = failureOrCause2(cause3);
      switch (either4._tag) {
        case "Left": {
          return options.onFailure(either4.left);
        }
        case "Right": {
          return failCause10(either4.right);
        }
      }
    },
    onSuccess: options.onSuccess
  }));
  var fromInput = (input) => unwrap(input.takeWith(failCause10, (elem) => flatMap13(write(elem), () => fromInput(input)), succeed10));
  var fromQueue = (queue) => suspend5(() => fromQueueInternal(queue));
  var fromQueueInternal = (queue) => pipe(fromEffect4(take3(queue)), flatMap13(match({
    onLeft: match6({
      onFailure: failCause10,
      onSuccess: succeedNow
    }),
    onRight: (elem) => flatMap13(write(elem), () => fromQueueInternal(queue))
  })));
  var identityChannel = () => readWith({
    onInput: (input) => flatMap13(write(input), () => identityChannel()),
    onFailure: fail11,
    onDone: succeedNow
  });
  var interruptWhen = /* @__PURE__ */ dual(2, (self2, effect3) => mergeWith2(self2, {
    other: fromEffect4(effect3),
    onSelfDone: (selfDone) => Done3(suspend3(() => selfDone)),
    onOtherDone: (effectDone) => Done3(suspend3(() => effectDone))
  }));
  var interruptWhenDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => interruptWhen(self2, _await(deferred)));
  var map18 = /* @__PURE__ */ dual(2, (self2, f) => flatMap13(self2, (a) => sync5(() => f(a))));
  var mapError5 = /* @__PURE__ */ dual(2, (self2, f) => mapErrorCause3(self2, map12(f)));
  var mapErrorCause3 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause5(self2, (cause3) => failCause10(f(cause3))));
  var mapOut = /* @__PURE__ */ dual(2, (self2, f) => {
    const reader = readWith({
      onInput: (outElem) => flatMap13(write(f(outElem)), () => reader),
      onFailure: fail11,
      onDone: succeedNow
    });
    return pipeTo(self2, reader);
  });
  var mapOutEffect = /* @__PURE__ */ dual(2, (self2, f) => {
    const reader = readWithCause({
      onInput: (outElem) => pipe(fromEffect4(f(outElem)), flatMap13(write), flatMap13(() => reader)),
      onFailure: failCause10,
      onDone: succeedNow
    });
    return pipeTo(self2, reader);
  });
  var mapOutEffectPar = /* @__PURE__ */ dual(3, (self2, f, n) => unwrapScopedWith((scope5) => gen2(function* () {
    const input = yield* make43();
    const queueReader = fromInput(input);
    const queue = yield* bounded5(n);
    yield* addFinalizer2(scope5, shutdown4(queue));
    const errorSignal = yield* make19();
    const withPermits = n === Number.POSITIVE_INFINITY ? (_) => identity : (yield* makeSemaphore2(n)).withPermits;
    const pull = yield* queueReader.pipe(pipeTo(self2), toPullIn(scope5));
    yield* pull.pipe(matchCauseEffect3({
      onFailure: (cause3) => offer3(queue, failCause8(cause3)),
      onSuccess: match({
        onLeft: (outDone) => zipRight3(interruptible4(withPermits(n)(_void)), asVoid3(offer3(queue, succeed8(left2(outDone))))),
        onRight: (outElem) => gen2(function* () {
          const deferred = yield* make19();
          const latch = yield* make19();
          yield* offer3(queue, map16(_await(deferred), right2));
          yield* succeed2(latch, undefined).pipe(zipRight3(uninterruptibleMask3((restore) => exit2(restore(_await(errorSignal))).pipe(raceFirst2(exit2(restore(f(outElem)))), flatMap11(identity))).pipe(tapErrorCause3((cause3) => failCause2(errorSignal, cause3)), intoDeferred2(deferred))), withPermits(1), forkIn2(scope5));
          yield* _await(latch);
        })
      })
    }), forever3, interruptible4, forkIn2(scope5));
    const consumer = unwrap(matchCause3(flatten9(take3(queue)), {
      onFailure: failCause10,
      onSuccess: match({
        onLeft: succeedNow,
        onRight: (outElem) => flatMap13(write(outElem), () => consumer)
      })
    }));
    return embedInput(consumer, input);
  })));
  var mergeAll7 = (options) => {
    return (channels) => mergeAllWith(options)(channels, constVoid);
  };
  var mergeAllWith = ({
    bufferSize = 16,
    concurrency,
    mergeStrategy = BackPressure()
  }) => (channels, f) => unwrapScopedWith((scope5) => gen2(function* () {
    const concurrencyN = concurrency === "unbounded" ? Number.MAX_SAFE_INTEGER : concurrency;
    const input = yield* make43();
    const queueReader = fromInput(input);
    const queue = yield* bounded5(bufferSize);
    yield* addFinalizer2(scope5, shutdown4(queue));
    const cancelers = yield* unbounded5();
    yield* addFinalizer2(scope5, shutdown4(cancelers));
    const lastDone = yield* make29(none2());
    const errorSignal = yield* make19();
    const withPermits = (yield* makeSemaphore2(concurrencyN)).withPermits;
    const pull = yield* toPullIn(pipeTo(queueReader, channels), scope5);
    function evaluatePull(pull2) {
      return pull2.pipe(flatMap11(match({
        onLeft: (done8) => succeed8(some2(done8)),
        onRight: (outElem) => as3(offer3(queue, succeed8(right2(outElem))), none2())
      })), repeat({
        until: (_) => isSome2(_)
      }), flatMap11((outDone) => update3(lastDone, match2({
        onNone: () => some2(outDone.value),
        onSome: (lastDone2) => some2(f(lastDone2, outDone.value))
      }))), catchAllCause3((cause3) => isInterrupted2(cause3) ? failCause8(cause3) : offer3(queue, failCause8(cause3)).pipe(zipRight3(succeed2(errorSignal, undefined)), asVoid3)));
    }
    yield* pull.pipe(matchCauseEffect3({
      onFailure: (cause3) => offer3(queue, failCause8(cause3)).pipe(zipRight3(succeed8(false))),
      onSuccess: match({
        onLeft: (outDone) => raceWith2(interruptible4(_await(errorSignal)), interruptible4(withPermits(concurrencyN)(_void)), {
          onSelfDone: (_, permitAcquisition) => as3(interrupt6(permitAcquisition), false),
          onOtherDone: (_, failureAwait) => zipRight3(interrupt6(failureAwait), get12(lastDone).pipe(flatMap11(match2({
            onNone: () => offer3(queue, succeed8(left2(outDone))),
            onSome: (lastDone2) => offer3(queue, succeed8(left2(f(lastDone2, outDone))))
          })), as3(false)))
        }),
        onRight: (channel) => match14(mergeStrategy, {
          onBackPressure: () => gen2(function* () {
            const latch = yield* make19();
            const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel), scope6).pipe(flatMap11((pull2) => race2(exit2(evaluatePull(pull2)), exit2(interruptible4(_await(errorSignal))))), flatMap11(identity)));
            yield* succeed2(latch, undefined).pipe(zipRight3(raceEffects), withPermits(1), forkIn2(scope5));
            yield* _await(latch);
            const errored = yield* isDone(errorSignal);
            return !errored;
          }),
          onBufferSliding: () => gen2(function* () {
            const canceler = yield* make19();
            const latch = yield* make19();
            const size11 = yield* size10(cancelers);
            yield* take3(cancelers).pipe(flatMap11((canceler2) => succeed2(canceler2, undefined)), when2(() => size11 >= concurrencyN));
            yield* offer3(cancelers, canceler);
            const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel), scope6).pipe(flatMap11((pull2) => exit2(evaluatePull(pull2)).pipe(race2(exit2(interruptible4(_await(errorSignal)))), race2(exit2(interruptible4(_await(canceler)))))), flatMap11(identity)));
            yield* succeed2(latch, undefined).pipe(zipRight3(raceEffects), withPermits(1), forkIn2(scope5));
            yield* _await(latch);
            const errored = yield* isDone(errorSignal);
            return !errored;
          })
        })
      })
    }), repeat({
      while: (_) => _
    }), forkIn2(scope5));
    const consumer = pipe(take3(queue), flatten9, matchCause3({
      onFailure: failCause10,
      onSuccess: match({
        onLeft: succeedNow,
        onRight: (outElem) => flatMap13(write(outElem), () => consumer)
      })
    }), unwrap);
    return embedInput(consumer, input);
  }));
  var mergeMap = /* @__PURE__ */ dual(3, (self2, f, options) => mergeAll7(options)(mapOut(self2, f)));
  var mergeWith2 = /* @__PURE__ */ dual(2, (self2, options) => {
    function merge9(scope5) {
      return gen2(function* () {
        const input = yield* make43();
        const queueReader = fromInput(input);
        const pullL = yield* toPullIn(pipeTo(queueReader, self2), scope5);
        const pullR = yield* toPullIn(pipeTo(queueReader, options.other), scope5);
        function handleSide(exit3, fiber, pull) {
          return (done8, both2, single2) => {
            function onDecision(decision) {
              const op = decision;
              if (op._tag === OP_DONE4) {
                return succeed8(fromEffect4(zipRight3(interrupt6(fiber), op.effect)));
              }
              return map16(_await3(fiber), match6({
                onFailure: (cause3) => fromEffect4(op.f(failCause3(cause3))),
                onSuccess: match({
                  onLeft: (done9) => fromEffect4(op.f(succeed3(done9))),
                  onRight: (elem) => zipRight4(write(elem), go(single2(op.f)))
                })
              }));
            }
            return match6(exit3, {
              onFailure: (cause3) => onDecision(done8(failCause3(cause3))),
              onSuccess: match({
                onLeft: (z) => onDecision(done8(succeed3(z))),
                onRight: (elem) => succeed8(flatMap13(write(elem), () => flatMap13(fromEffect4(forkIn2(interruptible4(pull), scope5)), (leftFiber) => go(both2(leftFiber, fiber)))))
              })
            });
          };
        }
        function go(state) {
          switch (state._tag) {
            case OP_BOTH_RUNNING: {
              const leftJoin = interruptible4(join3(state.left));
              const rightJoin = interruptible4(join3(state.right));
              return unwrap(raceWith2(leftJoin, rightJoin, {
                onSelfDone: (leftExit, rf) => zipRight3(interrupt6(rf), handleSide(leftExit, state.right, pullL)(options.onSelfDone, BothRunning, (f) => LeftDone(f))),
                onOtherDone: (rightExit, lf) => zipRight3(interrupt6(lf), handleSide(rightExit, state.left, pullR)(options.onOtherDone, (left3, right3) => BothRunning(right3, left3), (f) => RightDone(f)))
              }));
            }
            case OP_LEFT_DONE: {
              return unwrap(map16(exit2(pullR), match6({
                onFailure: (cause3) => fromEffect4(state.f(failCause3(cause3))),
                onSuccess: match({
                  onLeft: (done8) => fromEffect4(state.f(succeed3(done8))),
                  onRight: (elem) => flatMap13(write(elem), () => go(LeftDone(state.f)))
                })
              })));
            }
            case OP_RIGHT_DONE: {
              return unwrap(map16(exit2(pullL), match6({
                onFailure: (cause3) => fromEffect4(state.f(failCause3(cause3))),
                onSuccess: match({
                  onLeft: (done8) => fromEffect4(state.f(succeed3(done8))),
                  onRight: (elem) => flatMap13(write(elem), () => go(RightDone(state.f)))
                })
              })));
            }
          }
        }
        return fromEffect4(withFiberRuntime2((parent) => {
          const inherit = withFiberRuntime2((state) => {
            state.transferChildren(parent.scope());
            return _void;
          });
          const leftFiber = interruptible4(pullL).pipe(ensuring2(inherit), forkIn2(scope5));
          const rightFiber = interruptible4(pullR).pipe(ensuring2(inherit), forkIn2(scope5));
          return zipWith5(leftFiber, rightFiber, (left3, right3) => BothRunning(left3, right3));
        })).pipe(flatMap13(go), embedInput(input));
      });
    }
    return unwrapScopedWith(merge9);
  });
  var orDieWith3 = /* @__PURE__ */ dual(2, (self2, f) => catchAll5(self2, (e) => failCauseSync5(() => die4(f(e)))));
  var orElse7 = /* @__PURE__ */ dual(2, (self2, that) => catchAll5(self2, that));
  var pipeToOrFail = /* @__PURE__ */ dual(2, (self2, that) => suspend5(() => {
    let channelException = undefined;
    const reader = readWith({
      onInput: (outElem) => flatMap13(write(outElem), () => reader),
      onFailure: (outErr) => {
        channelException = ChannelException(outErr);
        return failCause10(die4(channelException));
      },
      onDone: succeedNow
    });
    const writer = readWithCause({
      onInput: (outElem) => pipe(write(outElem), flatMap13(() => writer)),
      onFailure: (cause3) => isDieType2(cause3) && isChannelException(cause3.defect) && equals(cause3.defect, channelException) ? fail11(cause3.defect.error) : failCause10(cause3),
      onDone: succeedNow
    });
    return pipeTo(pipeTo(pipeTo(self2, reader), that), writer);
  }));
  var repeated = (self2) => flatMap13(self2, () => repeated(self2));
  var run = (self2) => scopedWith2((scope5) => runIn(self2, scope5));
  var runDrain = (self2) => run(drain(self2));
  var runScoped = (self2) => scopeWith2((scope5) => runIn(self2, scope5));
  var scoped4 = (effect3) => unwrap(uninterruptibleMask3((restore) => map16(make39(), (scope5) => acquireReleaseOut(tapErrorCause3(restore(extend2(effect3, scope5)), (cause3) => close(scope5, failCause3(cause3))), (_, exit3) => close(scope5, exit3)))));
  var scopedWith3 = (f) => unwrapScoped3(map16(scope3, (scope5) => flatMap13(fromEffect4(f(scope5)), write)));
  var splitLines = () => suspend5(() => {
    let stringBuilder = "";
    let midCRLF = false;
    const splitLinesChunk = (chunk2) => {
      const chunkBuilder = [];
      map4(chunk2, (str) => {
        if (str.length !== 0) {
          let from = 0;
          let indexOfCR = str.indexOf("\r");
          let indexOfLF = str.indexOf(`
`);
          if (midCRLF) {
            if (indexOfLF === 0) {
              chunkBuilder.push(stringBuilder);
              stringBuilder = "";
              from = 1;
              indexOfLF = str.indexOf(`
`, from);
            } else {
              stringBuilder = stringBuilder + "\r";
            }
            midCRLF = false;
          }
          while (indexOfCR !== -1 || indexOfLF !== -1) {
            if (indexOfCR === -1 || indexOfLF !== -1 && indexOfLF < indexOfCR) {
              if (stringBuilder.length === 0) {
                chunkBuilder.push(str.substring(from, indexOfLF));
              } else {
                chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF));
                stringBuilder = "";
              }
              from = indexOfLF + 1;
              indexOfLF = str.indexOf(`
`, from);
            } else {
              if (str.length === indexOfCR + 1) {
                midCRLF = true;
                indexOfCR = -1;
              } else {
                if (indexOfLF === indexOfCR + 1) {
                  if (stringBuilder.length === 0) {
                    chunkBuilder.push(str.substring(from, indexOfCR));
                  } else {
                    stringBuilder = stringBuilder + str.substring(from, indexOfCR);
                    chunkBuilder.push(stringBuilder);
                    stringBuilder = "";
                  }
                  from = indexOfCR + 2;
                  indexOfCR = str.indexOf("\r", from);
                  indexOfLF = str.indexOf(`
`, from);
                } else {
                  indexOfCR = str.indexOf("\r", indexOfCR + 1);
                }
              }
            }
          }
          if (midCRLF) {
            stringBuilder = stringBuilder + str.substring(from, str.length - 1);
          } else {
            stringBuilder = stringBuilder + str.substring(from, str.length);
          }
        }
      });
      return unsafeFromArray(chunkBuilder);
    };
    const loop3 = readWithCause({
      onInput: (input) => {
        const out = splitLinesChunk(input);
        return isEmpty(out) ? loop3 : flatMap13(write(out), () => loop3);
      },
      onFailure: (cause3) => stringBuilder.length === 0 ? failCause10(cause3) : flatMap13(write(of2(stringBuilder)), () => failCause10(cause3)),
      onDone: (done8) => stringBuilder.length === 0 ? succeed10(done8) : flatMap13(write(of2(stringBuilder)), () => succeed10(done8))
    });
    return loop3;
  });
  var toPubSub = (pubsub) => toQueue(pubsub);
  var toPull = (self2) => flatMap11(scope3, (scope5) => toPullIn(self2, scope5));
  var toPullIn = /* @__PURE__ */ dual(2, (self2, scope5) => zip5(sync3(() => new ChannelExecutor(self2, undefined, identity)), runtime4()).pipe(tap3(([executor, runtime5]) => addFinalizerExit(scope5, (exit3) => {
    const finalizer = executor.close(exit3);
    return finalizer !== undefined ? provide2(finalizer, runtime5) : _void;
  })), uninterruptible2, map16(([executor]) => suspend3(() => interpretToPull(executor.run(), executor)))));
  var interpretToPull = (channelState, exec) => {
    const state = channelState;
    switch (state._tag) {
      case OP_DONE3: {
        return match6(exec.getDone(), {
          onFailure: failCause8,
          onSuccess: (done8) => succeed8(left2(done8))
        });
      }
      case OP_EMIT2: {
        return succeed8(right2(exec.getEmit()));
      }
      case OP_FROM_EFFECT3: {
        return pipe(state.effect, flatMap11(() => interpretToPull(exec.run(), exec)));
      }
      case OP_READ2: {
        return readUpstream(state, () => interpretToPull(exec.run(), exec), (cause3) => failCause8(cause3));
      }
    }
  };
  var toQueue = (queue) => suspend5(() => toQueueInternal(queue));
  var toQueueInternal = (queue) => {
    return readWithCause({
      onInput: (elem) => flatMap13(fromEffect4(offer3(queue, right2(elem))), () => toQueueInternal(queue)),
      onFailure: (cause3) => fromEffect4(offer3(queue, left2(failCause3(cause3)))),
      onDone: (done8) => fromEffect4(offer3(queue, left2(succeed3(done8))))
    });
  };
  var unwrap = (channel) => flatten11(fromEffect4(channel));
  var unwrapScoped3 = (self2) => concatAllWith(scoped4(self2), (d, _) => d, (d, _) => d);
  var unwrapScopedWith = (f) => concatAllWith(scopedWith3(f), (d, _) => d, (d, _) => d);
  var withSpan5 = function() {
    const dataFirst = typeof arguments[0] !== "string";
    const name = dataFirst ? arguments[1] : arguments[0];
    const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
    const acquire = all4([makeSpan2(name, options), context3(), clock2, get13(currentTracerTimingEnabled2)]);
    if (dataFirst) {
      const self2 = arguments[0];
      return acquireUseRelease3(acquire, ([span4, context5]) => provideContext3(self2, add2(context5, spanTag, span4)), ([span4, , clock3, timingEnabled], exit3) => endSpan(span4, exit3, clock3, timingEnabled));
    }
    return (self2) => acquireUseRelease3(acquire, ([span4, context5]) => provideContext3(self2, add2(context5, spanTag, span4)), ([span4, , clock3, timingEnabled], exit3) => endSpan(span4, exit3, clock3, timingEnabled));
  };
  var writeAll = (...outs) => writeChunk(fromIterable2(outs));
  var writeChunk = (outs) => writeChunkWriter(0, outs.length, outs);
  var writeChunkWriter = (idx, len, chunk2) => {
    return idx === len ? void_5 : pipe(write(pipe(chunk2, unsafeGet4(idx))), flatMap13(() => writeChunkWriter(idx + 1, len, chunk2)));
  };
  var zip6 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options) => options?.concurrent ? mergeWith2(self2, {
    other: that,
    onSelfDone: (exit1) => Await((exit22) => suspend3(() => zip3(exit1, exit22))),
    onOtherDone: (exit22) => Await((exit1) => suspend3(() => zip3(exit1, exit22)))
  }) : flatMap13(self2, (a) => map18(that, (b) => [a, b])));
  var zipLeft3 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options) => options?.concurrent ? map18(zip6(self2, that, {
    concurrent: true
  }), (tuple) => tuple[0]) : flatMap13(self2, (z) => as4(that, z)));
  var zipRight4 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options) => options?.concurrent ? map18(zip6(self2, that, {
    concurrent: true
  }), (tuple) => tuple[1]) : flatMap13(self2, () => that));
  var ChannelExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Channel/ChannelException");
  var ChannelException = (error) => ({
    _tag: "ChannelException",
    [ChannelExceptionTypeId]: ChannelExceptionTypeId,
    error
  });
  var isChannelException = (u) => hasProperty(u, ChannelExceptionTypeId);

  // node_modules/effect/dist/esm/internal/sink.js
  var SinkTypeId2 = /* @__PURE__ */ Symbol.for("effect/Sink");
  var sinkVariance2 = {
    _A: (_) => _,
    _In: (_) => _,
    _L: (_) => _,
    _E: (_) => _,
    _R: (_) => _
  };

  class SinkImpl {
    channel;
    [SinkTypeId2] = sinkVariance2;
    constructor(channel) {
      this.channel = channel;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var isSink = (u) => hasProperty(u, SinkTypeId2);
  var suspend6 = (evaluate2) => new SinkImpl(suspend5(() => toChannel(evaluate2())));
  var collectAll = () => new SinkImpl(collectAllLoop(empty5()));
  var collectAllLoop = (acc) => readWithCause({
    onInput: (chunk2) => collectAllLoop(pipe(acc, appendAll2(chunk2))),
    onFailure: failCause10,
    onDone: () => succeed10(acc)
  });
  var collectAllN = (n) => suspend6(() => fromChannel(collectAllNLoop(n, empty5())));
  var collectAllNLoop = (n, acc) => readWithCause({
    onInput: (chunk2) => {
      const [collected, leftovers] = splitAt2(chunk2, n);
      if (collected.length < n) {
        return collectAllNLoop(n - collected.length, appendAll2(acc, collected));
      }
      if (isEmpty(leftovers)) {
        return succeed10(appendAll2(acc, collected));
      }
      return flatMap13(write(leftovers), () => succeed10(appendAll2(acc, collected)));
    },
    onFailure: failCause10,
    onDone: () => succeed10(acc)
  });
  var collectLeftover = (self2) => new SinkImpl(pipe(collectElements(toChannel(self2)), map18(([chunks, z]) => [z, flatten3(chunks)])));
  var drain2 = /* @__PURE__ */ new SinkImpl(/* @__PURE__ */ drain(/* @__PURE__ */ identityChannel()));
  var fail12 = (e) => new SinkImpl(fail11(e));
  var fold = (s, contFn, f) => suspend6(() => new SinkImpl(foldReader(s, contFn, f)));
  var foldReader = (s, contFn, f) => {
    if (!contFn(s)) {
      return succeedNow(s);
    }
    return readWith({
      onInput: (input) => {
        const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f, 0, input.length);
        if (isNonEmpty2(leftovers)) {
          return pipe(write(leftovers), as4(nextS));
        }
        return foldReader(nextS, contFn, f);
      },
      onFailure: fail11,
      onDone: () => succeedNow(s)
    });
  };
  var foldChunkSplit = (s, chunk2, contFn, f, index, length3) => {
    if (index === length3) {
      return [s, empty5()];
    }
    const s1 = f(s, pipe(chunk2, unsafeGet4(index)));
    if (contFn(s1)) {
      return foldChunkSplit(s1, chunk2, contFn, f, index + 1, length3);
    }
    return [s1, pipe(chunk2, drop2(index + 1))];
  };
  var foldSink = /* @__PURE__ */ dual(2, (self2, options) => {
    const newChannel = pipe(toChannel(self2), collectElements, foldChannel({
      onFailure: (error) => toChannel(options.onFailure(error)),
      onSuccess: ([leftovers, z]) => suspend5(() => {
        const leftoversRef = {
          ref: pipe(leftovers, filter3(isNonEmpty2))
        };
        const refReader = pipe(sync5(() => {
          const ref = leftoversRef.ref;
          leftoversRef.ref = empty5();
          return ref;
        }), flatMap13((chunk2) => writeChunk(chunk2)));
        const passthrough4 = identityChannel();
        const continuationSink = pipe(refReader, zipRight4(passthrough4), pipeTo(toChannel(options.onSuccess(z))));
        return flatMap13(collectElements(continuationSink), ([newLeftovers, z1]) => pipe(succeed10(leftoversRef.ref), flatMap13(writeChunk), zipRight4(writeChunk(newLeftovers)), as4(z1)));
      })
    }));
    return new SinkImpl(newChannel);
  });
  var foldChunks = (s, contFn, f) => suspend6(() => new SinkImpl(foldChunksReader(s, contFn, f)));
  var foldChunksReader = (s, contFn, f) => {
    if (!contFn(s)) {
      return succeedNow(s);
    }
    return readWith({
      onInput: (input) => foldChunksReader(f(s, input), contFn, f),
      onFailure: fail11,
      onDone: () => succeedNow(s)
    });
  };
  var foldEffect = (s, contFn, f) => suspend6(() => new SinkImpl(foldEffectReader(s, contFn, f)));
  var foldEffectReader = (s, contFn, f) => {
    if (!contFn(s)) {
      return succeedNow(s);
    }
    return readWith({
      onInput: (input) => pipe(fromEffect4(foldChunkSplitEffect(s, input, contFn, f)), flatMap13(([nextS, leftovers]) => pipe(leftovers, match2({
        onNone: () => foldEffectReader(nextS, contFn, f),
        onSome: (leftover) => pipe(write(leftover), as4(nextS))
      })))),
      onFailure: fail11,
      onDone: () => succeedNow(s)
    });
  };
  var foldChunkSplitEffect = (s, chunk2, contFn, f) => foldChunkSplitEffectInternal(s, chunk2, 0, chunk2.length, contFn, f);
  var foldChunkSplitEffectInternal = (s, chunk2, index, length3, contFn, f) => {
    if (index === length3) {
      return succeed8([s, none2()]);
    }
    return pipe(f(s, pipe(chunk2, unsafeGet4(index))), flatMap11((s1) => contFn(s1) ? foldChunkSplitEffectInternal(s1, chunk2, index + 1, length3, contFn, f) : succeed8([s1, some2(pipe(chunk2, drop2(index + 1)))])));
  };
  var foldLeftChunks = (s, f) => foldChunks(s, constTrue, f);
  var flatMap14 = /* @__PURE__ */ dual(2, (self2, f) => foldSink(self2, {
    onFailure: fail12,
    onSuccess: f
  }));
  var forEach7 = (f) => {
    const process2 = readWithCause({
      onInput: (input) => pipe(fromEffect4(forEach6(input, (v) => f(v), {
        discard: true
      })), flatMap13(() => process2)),
      onFailure: failCause10,
      onDone: () => void_5
    });
    return new SinkImpl(process2);
  };
  var forEachChunk = (f) => {
    const process2 = readWithCause({
      onInput: (input) => pipe(fromEffect4(f(input)), flatMap13(() => process2)),
      onFailure: failCause10,
      onDone: () => void_5
    });
    return new SinkImpl(process2);
  };
  var forEachWhile = (f) => {
    const process2 = readWithCause({
      onInput: (input) => forEachWhileReader(f, input, 0, input.length, process2),
      onFailure: failCause10,
      onDone: () => void_5
    });
    return new SinkImpl(process2);
  };
  var forEachWhileReader = (f, input, index, length3, cont) => {
    if (index === length3) {
      return cont;
    }
    return pipe(fromEffect4(f(pipe(input, unsafeGet4(index)))), flatMap13((bool) => bool ? forEachWhileReader(f, input, index + 1, length3, cont) : write(pipe(input, drop2(index)))), catchAll5((error) => pipe(write(pipe(input, drop2(index))), zipRight4(fail11(error)))));
  };
  var fromChannel = (channel) => new SinkImpl(channel);
  var fromEffect6 = (effect3) => new SinkImpl(fromEffect4(effect3));
  var head5 = () => fold(none2(), isNone2, (option3, input) => match2(option3, {
    onNone: () => some2(input),
    onSome: () => option3
  }));
  var last3 = () => foldLeftChunks(none2(), (s, input) => orElse(last2(input), () => s));
  var map19 = /* @__PURE__ */ dual(2, (self2, f) => {
    return new SinkImpl(pipe(toChannel(self2), map18(f)));
  });
  var raceWith3 = /* @__PURE__ */ dual(2, (self2, options) => {
    function race3(scope5) {
      return gen2(function* () {
        const pubsub = yield* bounded4(options?.capacity ?? 16);
        const subscription1 = yield* extend2(subscribe2(pubsub), scope5);
        const subscription2 = yield* extend2(subscribe2(pubsub), scope5);
        const reader = toPubSub(pubsub);
        const writer = fromQueue(subscription1).pipe(pipeTo(toChannel(self2)), zipLeft3(fromEffect4(shutdown4(subscription1))), mergeWith2({
          other: fromQueue(subscription2).pipe(pipeTo(toChannel(options.other)), zipLeft3(fromEffect4(shutdown4(subscription2)))),
          onSelfDone: options.onSelfDone,
          onOtherDone: options.onOtherDone
        }));
        const racedChannel = mergeWith2(reader, {
          other: writer,
          onSelfDone: () => Await(identity),
          onOtherDone: (exit3) => Done3(exit3)
        });
        return new SinkImpl(racedChannel);
      });
    }
    return unwrapScopedWith2(race3);
  });
  var sum2 = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk2) => acc + reduce2(chunk2, 0, (s, a) => s + a));
  var toChannel = (self2) => isEffect2(self2) ? toChannel(fromEffect6(self2)) : self2.channel;
  var unwrapScoped4 = (effect3) => new SinkImpl(unwrapScoped3(effect3.pipe(map16((sink) => toChannel(sink)))));
  var unwrapScopedWith2 = (f) => new SinkImpl(unwrapScopedWith((scope5) => f(scope5).pipe(map16((sink) => toChannel(sink)))));
  var zipRight5 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self2, that, options) => zipWith7(self2, that, (_, z2) => z2, options));
  var zipWith7 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self2, that, f, options) => options?.concurrent ? raceWith3(self2, {
    other: that,
    onSelfDone: match6({
      onFailure: (cause3) => Done3(failCause8(cause3)),
      onSuccess: (leftZ) => Await(match6({
        onFailure: failCause8,
        onSuccess: (rightZ) => succeed8(f(leftZ, rightZ))
      }))
    }),
    onOtherDone: match6({
      onFailure: (cause3) => Done3(failCause8(cause3)),
      onSuccess: (rightZ) => Await(match6({
        onFailure: failCause8,
        onSuccess: (leftZ) => succeed8(f(leftZ, rightZ))
      }))
    })
  }) : flatMap14(self2, (z) => map19(that, (z2) => f(z, z2))));
  var count = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk2) => acc + chunk2.length);
  var mkString = /* @__PURE__ */ suspend6(() => {
    const strings = [];
    return pipe(foldLeftChunks(undefined, (_, elems) => map4(elems, (elem) => {
      strings.push(String(elem));
    })), map19(() => strings.join("")));
  });

  // node_modules/effect/dist/esm/MergeDecision.js
  var Done4 = Done3;
  var Await2 = Await;

  // node_modules/effect/dist/esm/internal/rcRef.js
  var TypeId15 = /* @__PURE__ */ Symbol.for("effect/RcRef");
  var stateEmpty2 = {
    _tag: "Empty"
  };
  var stateClosed = {
    _tag: "Closed"
  };
  var variance5 = {
    _A: identity,
    _E: identity
  };

  class RcRefImpl extends Class {
    acquire;
    context;
    scope;
    idleTimeToLive;
    [TypeId15] = variance5;
    [TypeId12] = TypeId12;
    state = stateEmpty2;
    semaphore = /* @__PURE__ */ unsafeMakeSemaphore(1);
    constructor(acquire, context5, scope5, idleTimeToLive) {
      super();
      this.acquire = acquire;
      this.context = context5;
      this.scope = scope5;
      this.idleTimeToLive = idleTimeToLive;
      this.get = get14(this);
    }
    get;
    commit() {
      return this.get;
    }
  }
  var make44 = (options) => withFiberRuntime((fiber) => {
    const context5 = fiber.getFiberRef(currentContext);
    const scope5 = get3(context5, scopeTag);
    const ref = new RcRefImpl(options.acquire, context5, scope5, options.idleTimeToLive ? decode(options.idleTimeToLive) : undefined);
    return as(scope5.addFinalizer(() => ref.semaphore.withPermits(1)(suspend(() => {
      const close2 = ref.state._tag === "Acquired" ? scopeClose(ref.state.scope, exitVoid) : void_;
      ref.state = stateClosed;
      return close2;
    }))), ref);
  });
  var get14 = (self_) => {
    const self2 = self_;
    const isInfinite = self2.idleTimeToLive && !isFinite2(self2.idleTimeToLive);
    return uninterruptibleMask((restore) => suspend(() => {
      switch (self2.state._tag) {
        case "Closed": {
          return interrupt2;
        }
        case "Acquired": {
          self2.state.refCount++;
          return self2.state.fiber ? as(interruptFiber(self2.state.fiber), self2.state) : succeed(self2.state);
        }
        case "Empty": {
          return scopeMake().pipe(bindTo2("scope"), bind2("value", ({
            scope: scope5
          }) => restore(fiberRefLocally(self2.acquire, currentContext, add2(self2.context, scopeTag, scope5)))), map10(({
            scope: scope5,
            value
          }) => {
            const state = {
              _tag: "Acquired",
              value,
              scope: scope5,
              fiber: undefined,
              refCount: 1
            };
            self2.state = state;
            return state;
          }));
        }
      }
    })).pipe(self2.semaphore.withPermits(1), bindTo2("state"), bind2("scope", () => scopeTag), tap(({
      scope: scope5,
      state
    }) => scope5.addFinalizer(() => suspend(() => {
      state.refCount--;
      if (state.refCount > 0 || isInfinite) {
        return void_;
      }
      if (self2.idleTimeToLive === undefined) {
        self2.state = stateEmpty2;
        return scopeClose(state.scope, exitVoid);
      }
      return sleep3(self2.idleTimeToLive).pipe(interruptible2, zipRight(suspend(() => {
        if (self2.state._tag === "Acquired" && self2.state.refCount === 0) {
          self2.state = stateEmpty2;
          return scopeClose(state.scope, exitVoid);
        }
        return void_;
      })), ensuring(sync(() => {
        state.fiber = undefined;
      })), forkIn(self2.scope), tap((fiber) => {
        state.fiber = fiber;
      }), self2.semaphore.withPermits(1));
    }))), map10(({
      state
    }) => state.value));
  };

  // node_modules/effect/dist/esm/RcRef.js
  var make45 = make44;
  var get15 = get14;

  // node_modules/effect/dist/esm/Runtime.js
  var runFork3 = unsafeFork2;
  var runPromiseExit2 = unsafeRunPromiseExit;
  var defaultRuntime2 = defaultRuntime;
  var updateContext3 = updateContext2;

  // node_modules/effect/dist/esm/Schedule.js
  var driver2 = driver;
  var forever4 = forever2;
  var spaced2 = spaced;
  var CurrentIterationMetadata2 = CurrentIterationMetadata;

  // node_modules/effect/dist/esm/internal/opCodes/streamHaltStrategy.js
  var OP_LEFT = "Left";
  var OP_RIGHT = "Right";
  var OP_BOTH = "Both";
  var OP_EITHER = "Either";

  // node_modules/effect/dist/esm/internal/stream/haltStrategy.js
  var Left = {
    _tag: OP_LEFT
  };
  var Right = {
    _tag: OP_RIGHT
  };
  var Both = {
    _tag: OP_BOTH
  };
  var Either = {
    _tag: OP_EITHER
  };
  var fromInput2 = (input) => {
    switch (input) {
      case "left":
        return Left;
      case "right":
        return Right;
      case "both":
        return Both;
      case "either":
        return Either;
      default:
        return input;
    }
  };

  // node_modules/effect/dist/esm/StreamHaltStrategy.js
  var Both2 = Both;

  // node_modules/effect/dist/esm/internal/stm/versioned.js
  class Versioned {
    value;
    constructor(value) {
      this.value = value;
    }
  }

  // node_modules/effect/dist/esm/internal/stm/entry.js
  var make46 = (ref, isNew) => ({
    ref,
    isNew,
    isChanged: false,
    expected: ref.versioned,
    newValue: ref.versioned.value
  });
  var unsafeGet6 = (self2) => {
    return self2.newValue;
  };
  var unsafeSet = (self2, value) => {
    self2.isChanged = true;
    self2.newValue = value;
  };
  var commit = (self2) => {
    self2.ref.versioned = new Versioned(self2.newValue);
  };
  var isInvalid = (self2) => {
    return self2.ref.versioned !== self2.expected;
  };
  var isChanged = (self2) => {
    return self2.isChanged;
  };

  // node_modules/effect/dist/esm/internal/stm/journal.js
  var JournalAnalysisInvalid = "Invalid";
  var JournalAnalysisReadWrite = "ReadWrite";
  var JournalAnalysisReadOnly = "ReadOnly";
  var commitJournal = (journal) => {
    for (const entry of journal) {
      commit(entry[1]);
    }
  };
  var analyzeJournal = (journal) => {
    let val = JournalAnalysisReadOnly;
    for (const [, entry] of journal) {
      val = isInvalid(entry) ? JournalAnalysisInvalid : isChanged(entry) ? JournalAnalysisReadWrite : val;
      if (val === JournalAnalysisInvalid) {
        return val;
      }
    }
    return val;
  };
  var collectTodos = (journal) => {
    const allTodos = new Map;
    for (const [, entry] of journal) {
      for (const todo of entry.ref.todos) {
        allTodos.set(todo[0], todo[1]);
      }
      entry.ref.todos = new Map;
    }
    return allTodos;
  };
  var execTodos = (todos) => {
    const todosSorted = Array.from(todos.entries()).sort((x, y) => x[0] - y[0]);
    for (const [_, todo] of todosSorted) {
      todo();
    }
  };
  var addTodo = (txnId, journal, todoEffect) => {
    let added = false;
    for (const [, entry] of journal) {
      if (!entry.ref.todos.has(txnId)) {
        entry.ref.todos.set(txnId, todoEffect);
        added = true;
      }
    }
    return added;
  };

  // node_modules/effect/dist/esm/internal/stm/opCodes/stm.js
  var OP_WITH_STM_RUNTIME = "WithSTMRuntime";
  var OP_ON_FAILURE2 = "OnFailure";
  var OP_ON_RETRY = "OnRetry";
  var OP_ON_SUCCESS2 = "OnSuccess";
  var OP_PROVIDE3 = "Provide";
  var OP_SYNC2 = "Sync";
  var OP_SUCCEED2 = "Succeed";
  var OP_RETRY = "Retry";
  var OP_FAIL4 = "Fail";
  var OP_DIE2 = "Die";
  var OP_INTERRUPT2 = "Interrupt";

  // node_modules/effect/dist/esm/internal/stm/opCodes/tExit.js
  var OP_FAIL5 = "Fail";
  var OP_DIE3 = "Die";
  var OP_INTERRUPT3 = "Interrupt";
  var OP_SUCCEED3 = "Succeed";
  var OP_RETRY2 = "Retry";

  // node_modules/effect/dist/esm/internal/stm/opCodes/tryCommit.js
  var OP_DONE5 = "Done";
  var OP_SUSPEND3 = "Suspend";

  // node_modules/effect/dist/esm/internal/stm/opCodes/stmState.js
  var OP_DONE6 = "Done";
  var OP_INTERRUPTED = "Interrupted";
  var OP_RUNNING2 = "Running";

  // node_modules/effect/dist/esm/internal/stm/stmState.js
  var STMStateSymbolKey = "effect/STM/State";
  var STMStateTypeId = /* @__PURE__ */ Symbol.for(STMStateSymbolKey);
  var isSTMState = (u) => hasProperty(u, STMStateTypeId);
  var isRunning2 = (self2) => {
    return self2._tag === OP_RUNNING2;
  };
  var isDone6 = (self2) => {
    return self2._tag === OP_DONE6;
  };
  var done8 = (exit3) => {
    return {
      [STMStateTypeId]: STMStateTypeId,
      _tag: OP_DONE6,
      exit: exit3,
      [symbol]() {
        return pipe(hash(STMStateSymbolKey), combine(hash(OP_DONE6)), combine(hash(exit3)), cached(this));
      },
      [symbol2](that) {
        return isSTMState(that) && that._tag === OP_DONE6 && equals(exit3, that.exit);
      }
    };
  };
  var interruptedHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_INTERRUPTED)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("interrupted")));
  var interrupted2 = {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_INTERRUPTED,
    [symbol]() {
      return interruptedHash;
    },
    [symbol2](that) {
      return isSTMState(that) && that._tag === OP_INTERRUPTED;
    }
  };
  var runningHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RUNNING2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("running")));
  var running3 = {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_RUNNING2,
    [symbol]() {
      return runningHash;
    },
    [symbol2](that) {
      return isSTMState(that) && that._tag === OP_RUNNING2;
    }
  };
  var fromTExit = (tExit) => {
    switch (tExit._tag) {
      case OP_FAIL5: {
        return done8(fail4(tExit.error));
      }
      case OP_DIE3: {
        return done8(die3(tExit.defect));
      }
      case OP_INTERRUPT3: {
        return done8(interrupt4(tExit.fiberId));
      }
      case OP_SUCCEED3: {
        return done8(succeed3(tExit.value));
      }
      case OP_RETRY2: {
        throw new Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues");
      }
    }
  };

  // node_modules/effect/dist/esm/internal/stm/tExit.js
  var TExitSymbolKey = "effect/TExit";
  var TExitTypeId = /* @__PURE__ */ Symbol.for(TExitSymbolKey);
  var variance6 = {
    _A: (_) => _,
    _E: (_) => _
  };
  var isExit2 = (u) => hasProperty(u, TExitTypeId);
  var isSuccess4 = (self2) => {
    return self2._tag === OP_SUCCEED3;
  };
  var isRetry = (self2) => {
    return self2._tag === OP_RETRY2;
  };
  var fail13 = (error) => ({
    [TExitTypeId]: variance6,
    _tag: OP_FAIL5,
    error,
    [symbol]() {
      return pipe(hash(TExitSymbolKey), combine(hash(OP_FAIL5)), combine(hash(error)), cached(this));
    },
    [symbol2](that) {
      return isExit2(that) && that._tag === OP_FAIL5 && equals(error, that.error);
    }
  });
  var die8 = (defect) => ({
    [TExitTypeId]: variance6,
    _tag: OP_DIE3,
    defect,
    [symbol]() {
      return pipe(hash(TExitSymbolKey), combine(hash(OP_DIE3)), combine(hash(defect)), cached(this));
    },
    [symbol2](that) {
      return isExit2(that) && that._tag === OP_DIE3 && equals(defect, that.defect);
    }
  });
  var interrupt8 = (fiberId3) => ({
    [TExitTypeId]: variance6,
    _tag: OP_INTERRUPT3,
    fiberId: fiberId3,
    [symbol]() {
      return pipe(hash(TExitSymbolKey), combine(hash(OP_INTERRUPT3)), combine(hash(fiberId3)), cached(this));
    },
    [symbol2](that) {
      return isExit2(that) && that._tag === OP_INTERRUPT3 && equals(fiberId3, that.fiberId);
    }
  });
  var succeed12 = (value) => ({
    [TExitTypeId]: variance6,
    _tag: OP_SUCCEED3,
    value,
    [symbol]() {
      return pipe(hash(TExitSymbolKey), combine(hash(OP_SUCCEED3)), combine(hash(value)), cached(this));
    },
    [symbol2](that) {
      return isExit2(that) && that._tag === OP_SUCCEED3 && equals(value, that.value);
    }
  });
  var retryHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(TExitSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RETRY2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("retry")));
  var retry4 = {
    [TExitTypeId]: variance6,
    _tag: OP_RETRY2,
    [symbol]() {
      return retryHash;
    },
    [symbol2](that) {
      return isExit2(that) && isRetry(that);
    }
  };

  // node_modules/effect/dist/esm/internal/stm/tryCommit.js
  var done9 = (exit3) => {
    return {
      _tag: OP_DONE5,
      exit: exit3
    };
  };
  var suspend7 = (journal) => {
    return {
      _tag: OP_SUSPEND3,
      journal
    };
  };

  // node_modules/effect/dist/esm/internal/stm/txnId.js
  var txnCounter = {
    ref: 0
  };
  var make47 = () => {
    const newId = txnCounter.ref + 1;
    txnCounter.ref = newId;
    return newId;
  };

  // node_modules/effect/dist/esm/internal/stm/core.js
  var STMSymbolKey2 = "effect/STM";
  var STMTypeId2 = /* @__PURE__ */ Symbol.for(STMSymbolKey2);
  var stmVariance = {
    _R: (_) => _,
    _E: (_) => _,
    _A: (_) => _
  };

  class STMPrimitive {
    effect_instruction_i0;
    _op = OP_COMMIT;
    effect_instruction_i1 = undefined;
    effect_instruction_i2 = undefined;
    [EffectTypeId3];
    [StreamTypeId];
    [SinkTypeId2];
    [ChannelTypeId2];
    get [STMTypeId2]() {
      return stmVariance;
    }
    constructor(effect_instruction_i0) {
      this.effect_instruction_i0 = effect_instruction_i0;
      this[EffectTypeId3] = effectVariance;
      this[StreamTypeId] = stmVariance;
      this[SinkTypeId2] = stmVariance;
      this[ChannelTypeId2] = stmVariance;
    }
    [symbol2](that) {
      return this === that;
    }
    [symbol]() {
      return cached(this, random(this));
    }
    [Symbol.iterator]() {
      return new SingleShotGen2(new YieldWrap(this));
    }
    commit() {
      return unsafeAtomically(this, constVoid, constVoid);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var unsafeAtomically = (self2, onDone, onInterrupt3) => withFiberRuntime((state) => {
    const fiberId3 = state.id();
    const env = state.getFiberRef(currentContext2);
    const scheduler = state.getFiberRef(currentScheduler2);
    const priority = state.getFiberRef(currentSchedulingPriority2);
    const commitResult = tryCommitSync(fiberId3, self2, env, scheduler, priority);
    switch (commitResult._tag) {
      case OP_DONE5: {
        onDone(commitResult.exit);
        return commitResult.exit;
      }
      case OP_SUSPEND3: {
        const txnId = make47();
        const state2 = {
          value: running3
        };
        const effect3 = async((k) => tryCommitAsync(fiberId3, self2, txnId, state2, env, scheduler, priority, k));
        return uninterruptibleMask3((restore) => pipe(restore(effect3), catchAllCause3((cause3) => {
          let currentState = state2.value;
          if (isRunning2(currentState)) {
            state2.value = interrupted2;
          }
          currentState = state2.value;
          if (isDone6(currentState)) {
            onDone(currentState.exit);
            return currentState.exit;
          }
          onInterrupt3();
          return failCause8(cause3);
        })));
      }
    }
  });
  var tryCommit = (fiberId3, stm, state, env, scheduler, priority) => {
    const journal = new Map;
    const tExit = new STMDriver(stm, journal, fiberId3, env).run();
    const analysis = analyzeJournal(journal);
    if (analysis === JournalAnalysisReadWrite) {
      commitJournal(journal);
    } else if (analysis === JournalAnalysisInvalid) {
      throw new Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    switch (tExit._tag) {
      case OP_SUCCEED3: {
        state.value = fromTExit(tExit);
        return completeTodos(succeed3(tExit.value), journal, scheduler, priority);
      }
      case OP_FAIL5: {
        state.value = fromTExit(tExit);
        const cause3 = fail5(tExit.error);
        return completeTodos(failCause3(cause3), journal, scheduler, priority);
      }
      case OP_DIE3: {
        state.value = fromTExit(tExit);
        const cause3 = die4(tExit.defect);
        return completeTodos(failCause3(cause3), journal, scheduler, priority);
      }
      case OP_INTERRUPT3: {
        state.value = fromTExit(tExit);
        const cause3 = interrupt5(fiberId3);
        return completeTodos(failCause3(cause3), journal, scheduler, priority);
      }
      case OP_RETRY2: {
        return suspend7(journal);
      }
    }
  };
  var tryCommitSync = (fiberId3, stm, env, scheduler, priority) => {
    const journal = new Map;
    const tExit = new STMDriver(stm, journal, fiberId3, env).run();
    const analysis = analyzeJournal(journal);
    if (analysis === JournalAnalysisReadWrite && isSuccess4(tExit)) {
      commitJournal(journal);
    } else if (analysis === JournalAnalysisInvalid) {
      throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    switch (tExit._tag) {
      case OP_SUCCEED3: {
        return completeTodos(succeed3(tExit.value), journal, scheduler, priority);
      }
      case OP_FAIL5: {
        const cause3 = fail5(tExit.error);
        return completeTodos(failCause3(cause3), journal, scheduler, priority);
      }
      case OP_DIE3: {
        const cause3 = die4(tExit.defect);
        return completeTodos(failCause3(cause3), journal, scheduler, priority);
      }
      case OP_INTERRUPT3: {
        const cause3 = interrupt5(fiberId3);
        return completeTodos(failCause3(cause3), journal, scheduler, priority);
      }
      case OP_RETRY2: {
        return suspend7(journal);
      }
    }
  };
  var tryCommitAsync = (fiberId3, self2, txnId, state, context5, scheduler, priority, k) => {
    if (isRunning2(state.value)) {
      const result = tryCommit(fiberId3, self2, state, context5, scheduler, priority);
      switch (result._tag) {
        case OP_DONE5: {
          completeTryCommit(result.exit, k);
          break;
        }
        case OP_SUSPEND3: {
          addTodo(txnId, result.journal, () => tryCommitAsync(fiberId3, self2, txnId, state, context5, scheduler, priority, k));
          break;
        }
      }
    }
  };
  var completeTodos = (exit3, journal, scheduler, priority) => {
    const todos = collectTodos(journal);
    if (todos.size > 0) {
      scheduler.scheduleTask(() => execTodos(todos), priority);
    }
    return done9(exit3);
  };
  var completeTryCommit = (exit3, k) => {
    k(exit3);
  };
  class STMDriver {
    self;
    journal;
    fiberId;
    contStack = [];
    env;
    constructor(self2, journal, fiberId3, r0) {
      this.self = self2;
      this.journal = journal;
      this.fiberId = fiberId3;
      this.env = r0;
    }
    getEnv() {
      return this.env;
    }
    pushStack(cont) {
      this.contStack.push(cont);
    }
    popStack() {
      return this.contStack.pop();
    }
    nextSuccess() {
      let current = this.popStack();
      while (current !== undefined && current.effect_instruction_i0 !== OP_ON_SUCCESS2) {
        current = this.popStack();
      }
      return current;
    }
    nextFailure() {
      let current = this.popStack();
      while (current !== undefined && current.effect_instruction_i0 !== OP_ON_FAILURE2) {
        current = this.popStack();
      }
      return current;
    }
    nextRetry() {
      let current = this.popStack();
      while (current !== undefined && current.effect_instruction_i0 !== OP_ON_RETRY) {
        current = this.popStack();
      }
      return current;
    }
    run() {
      let curr = this.self;
      let exit3 = undefined;
      while (exit3 === undefined && curr !== undefined) {
        try {
          const current = curr;
          if (current) {
            switch (current._op) {
              case "Tag": {
                curr = effect3((_, __, env) => unsafeGet3(env, current));
                break;
              }
              case "Left": {
                curr = fail14(current.left);
                break;
              }
              case "None": {
                curr = fail14(new NoSuchElementException2);
                break;
              }
              case "Right": {
                curr = succeed13(current.right);
                break;
              }
              case "Some": {
                curr = succeed13(current.value);
                break;
              }
              case "Commit": {
                switch (current.effect_instruction_i0) {
                  case OP_DIE2: {
                    exit3 = die8(internalCall(() => current.effect_instruction_i1()));
                    break;
                  }
                  case OP_FAIL4: {
                    const cont = this.nextFailure();
                    if (cont === undefined) {
                      exit3 = fail13(internalCall(() => current.effect_instruction_i1()));
                    } else {
                      curr = internalCall(() => cont.effect_instruction_i2(internalCall(() => current.effect_instruction_i1())));
                    }
                    break;
                  }
                  case OP_RETRY: {
                    const cont = this.nextRetry();
                    if (cont === undefined) {
                      exit3 = retry4;
                    } else {
                      curr = internalCall(() => cont.effect_instruction_i2());
                    }
                    break;
                  }
                  case OP_INTERRUPT2: {
                    exit3 = interrupt8(this.fiberId);
                    break;
                  }
                  case OP_WITH_STM_RUNTIME: {
                    curr = internalCall(() => current.effect_instruction_i1(this));
                    break;
                  }
                  case OP_ON_SUCCESS2:
                  case OP_ON_FAILURE2:
                  case OP_ON_RETRY: {
                    this.pushStack(current);
                    curr = current.effect_instruction_i1;
                    break;
                  }
                  case OP_PROVIDE3: {
                    const env = this.env;
                    this.env = internalCall(() => current.effect_instruction_i2(env));
                    curr = pipe(current.effect_instruction_i1, ensuring5(sync7(() => this.env = env)));
                    break;
                  }
                  case OP_SUCCEED2: {
                    const value = current.effect_instruction_i1;
                    const cont = this.nextSuccess();
                    if (cont === undefined) {
                      exit3 = succeed12(value);
                    } else {
                      curr = internalCall(() => cont.effect_instruction_i2(value));
                    }
                    break;
                  }
                  case OP_SYNC2: {
                    const value = internalCall(() => current.effect_instruction_i1());
                    const cont = this.nextSuccess();
                    if (cont === undefined) {
                      exit3 = succeed12(value);
                    } else {
                      curr = internalCall(() => cont.effect_instruction_i2(value));
                    }
                    break;
                  }
                }
                break;
              }
            }
          }
        } catch (e) {
          curr = die9(e);
        }
      }
      return exit3;
    }
  }
  var catchAll6 = /* @__PURE__ */ dual(2, (self2, f) => {
    const stm = new STMPrimitive(OP_ON_FAILURE2);
    stm.effect_instruction_i1 = self2;
    stm.effect_instruction_i2 = f;
    return stm;
  });
  var die9 = (defect) => dieSync5(() => defect);
  var dieSync5 = (evaluate2) => {
    const stm = new STMPrimitive(OP_DIE2);
    stm.effect_instruction_i1 = evaluate2;
    return stm;
  };
  var effect3 = (f) => withSTMRuntime((_) => succeed13(f(_.journal, _.fiberId, _.getEnv())));
  var ensuring5 = /* @__PURE__ */ dual(2, (self2, finalizer) => matchSTM(self2, {
    onFailure: (e) => zipRight7(finalizer, fail14(e)),
    onSuccess: (a) => zipRight7(finalizer, succeed13(a))
  }));
  var fail14 = (error) => failSync6(() => error);
  var failSync6 = (evaluate2) => {
    const stm = new STMPrimitive(OP_FAIL4);
    stm.effect_instruction_i1 = evaluate2;
    return stm;
  };
  var flatMap15 = /* @__PURE__ */ dual(2, (self2, f) => {
    const stm = new STMPrimitive(OP_ON_SUCCESS2);
    stm.effect_instruction_i1 = self2;
    stm.effect_instruction_i2 = f;
    return stm;
  });
  var matchSTM = /* @__PURE__ */ dual(2, (self2, {
    onFailure,
    onSuccess
  }) => pipe(self2, map20(right2), catchAll6((e) => pipe(onFailure(e), map20(left2))), flatMap15((either5) => {
    switch (either5._tag) {
      case "Left": {
        return succeed13(either5.left);
      }
      case "Right": {
        return onSuccess(either5.right);
      }
    }
  })));
  var withSTMRuntime = (f) => {
    const stm = new STMPrimitive(OP_WITH_STM_RUNTIME);
    stm.effect_instruction_i1 = f;
    return stm;
  };
  var interruptAs2 = (fiberId3) => {
    const stm = new STMPrimitive(OP_INTERRUPT2);
    stm.effect_instruction_i1 = fiberId3;
    return stm;
  };
  var map20 = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, flatMap15((a) => sync7(() => f(a)))));
  var retry5 = /* @__PURE__ */ new STMPrimitive(OP_RETRY);
  var succeed13 = (value) => {
    const stm = new STMPrimitive(OP_SUCCEED2);
    stm.effect_instruction_i1 = value;
    return stm;
  };
  var sync7 = (evaluate2) => {
    const stm = new STMPrimitive(OP_SYNC2);
    stm.effect_instruction_i1 = evaluate2;
    return stm;
  };
  var zipRight7 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, flatMap15(() => that)));
  var zipWith9 = /* @__PURE__ */ dual(3, (self2, that, f) => pipe(self2, flatMap15((a) => pipe(that, map20((b) => f(a, b))))));

  // node_modules/effect/dist/esm/internal/stm/opCodes/strategy.js
  var OP_BACKPRESSURE_STRATEGY = "BackPressure";
  var OP_DROPPING_STRATEGY = "Dropping";
  var OP_SLIDING_STRATEGY = "Sliding";

  // node_modules/effect/dist/esm/internal/stm/stm.js
  var as6 = /* @__PURE__ */ dual(2, (self2, value) => pipe(self2, map20(() => value)));
  var flatten12 = (self2) => flatMap15(self2, identity);
  var forEach8 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (iterable, f, options) => {
    if (options?.discard) {
      return pipe(sync7(() => iterable[Symbol.iterator]()), flatMap15((iterator) => {
        const loop3 = suspend8(() => {
          const next = iterator.next();
          if (next.done) {
            return void_6;
          }
          return pipe(f(next.value), flatMap15(() => loop3));
        });
        return loop3;
      }));
    }
    return suspend8(() => fromIterable(iterable).reduce((acc, curr) => zipWith9(acc, f(curr), (array3, elem) => {
      array3.push(elem);
      return array3;
    }), succeed13([])));
  });
  var all5 = (input, options) => {
    if (Symbol.iterator in input) {
      return forEach8(input, identity, options);
    } else if (options?.discard) {
      return forEach8(Object.values(input), identity, options);
    }
    return map20(forEach8(Object.entries(input), ([_, e]) => map20(e, (a) => [_, a])), (values3) => {
      const res = {};
      for (const [k, v] of values3) {
        res[k] = v;
      }
      return res;
    });
  };
  var suspend8 = (evaluate2) => flatten12(sync7(evaluate2));
  var tap5 = /* @__PURE__ */ dual(2, (self2, f) => flatMap15(self2, (a) => as6(f(a), a)));
  var void_6 = /* @__PURE__ */ succeed13(undefined);

  // node_modules/effect/dist/esm/internal/stm/tRef.js
  var TRefSymbolKey = "effect/TRef";
  var TRefTypeId = /* @__PURE__ */ Symbol.for(TRefSymbolKey);
  var tRefVariance = {
    _A: (_) => _
  };

  class TRefImpl {
    [TRefTypeId] = tRefVariance;
    todos;
    versioned;
    constructor(value) {
      this.versioned = new Versioned(value);
      this.todos = new Map;
    }
    modify(f) {
      return effect3((journal) => {
        const entry = getOrMakeEntry(this, journal);
        const [retValue, newValue] = f(unsafeGet6(entry));
        unsafeSet(entry, newValue);
        return retValue;
      });
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var make48 = (value) => effect3((journal) => {
    const ref = new TRefImpl(value);
    journal.set(ref, make46(ref, true));
    return ref;
  });
  var get16 = (self2) => self2.modify((a) => [a, a]);
  var set7 = /* @__PURE__ */ dual(2, (self2, value) => self2.modify(() => [undefined, value]));
  var getOrMakeEntry = (self2, journal) => {
    if (journal.has(self2)) {
      return journal.get(self2);
    }
    const entry = make46(self2, false);
    journal.set(self2, entry);
    return entry;
  };
  var unsafeGet7 = /* @__PURE__ */ dual(2, (self2, journal) => unsafeGet6(getOrMakeEntry(self2, journal)));
  var unsafeSet2 = /* @__PURE__ */ dual(3, (self2, value, journal) => {
    const entry = getOrMakeEntry(self2, journal);
    unsafeSet(entry, value);
    return;
  });

  // node_modules/effect/dist/esm/internal/stm/tQueue.js
  var TEnqueueSymbolKey = "effect/TQueue/TEnqueue";
  var TEnqueueTypeId = /* @__PURE__ */ Symbol.for(TEnqueueSymbolKey);
  var TDequeueSymbolKey = "effect/TQueue/TDequeue";
  var TDequeueTypeId = /* @__PURE__ */ Symbol.for(TDequeueSymbolKey);
  var tDequeueVariance = {
    _Out: (_) => _
  };
  var tEnqueueVariance = {
    _In: (_) => _
  };

  class TQueueImpl {
    ref;
    requestedCapacity;
    strategy;
    [TDequeueTypeId] = tDequeueVariance;
    [TEnqueueTypeId] = tEnqueueVariance;
    constructor(ref, requestedCapacity, strategy) {
      this.ref = ref;
      this.requestedCapacity = requestedCapacity;
      this.strategy = strategy;
    }
    capacity() {
      return this.requestedCapacity;
    }
    size = /* @__PURE__ */ withSTMRuntime((runtime5) => {
      const queue = unsafeGet7(this.ref, runtime5.journal);
      if (queue === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      return succeed13(queue.length);
    });
    isFull = /* @__PURE__ */ map20(this.size, (size11) => size11 === this.requestedCapacity);
    isEmpty = /* @__PURE__ */ map20(this.size, (size11) => size11 === 0);
    shutdown = /* @__PURE__ */ withSTMRuntime((runtime5) => {
      unsafeSet2(this.ref, undefined, runtime5.journal);
      return void_6;
    });
    isShutdown = /* @__PURE__ */ effect3((journal) => {
      const queue = unsafeGet7(this.ref, journal);
      return queue === undefined;
    });
    awaitShutdown = /* @__PURE__ */ flatMap15(this.isShutdown, (isShutdown4) => isShutdown4 ? void_6 : retry5);
    offer(value) {
      return withSTMRuntime((runtime5) => {
        const queue = pipe(this.ref, unsafeGet7(runtime5.journal));
        if (queue === undefined) {
          return interruptAs2(runtime5.fiberId);
        }
        if (queue.length < this.requestedCapacity) {
          queue.push(value);
          unsafeSet2(this.ref, queue, runtime5.journal);
          return succeed13(true);
        }
        switch (this.strategy._tag) {
          case OP_BACKPRESSURE_STRATEGY: {
            return retry5;
          }
          case OP_DROPPING_STRATEGY: {
            return succeed13(false);
          }
          case OP_SLIDING_STRATEGY: {
            if (queue.length === 0) {
              return succeed13(true);
            }
            queue.shift();
            queue.push(value);
            unsafeSet2(this.ref, queue, runtime5.journal);
            return succeed13(true);
          }
        }
      });
    }
    offerAll(iterable) {
      return withSTMRuntime((runtime5) => {
        const as7 = Array.from(iterable);
        const queue = unsafeGet7(this.ref, runtime5.journal);
        if (queue === undefined) {
          return interruptAs2(runtime5.fiberId);
        }
        if (queue.length + as7.length <= this.requestedCapacity) {
          unsafeSet2(this.ref, [...queue, ...as7], runtime5.journal);
          return succeed13(true);
        }
        switch (this.strategy._tag) {
          case OP_BACKPRESSURE_STRATEGY: {
            return retry5;
          }
          case OP_DROPPING_STRATEGY: {
            const forQueue = as7.slice(0, this.requestedCapacity - queue.length);
            unsafeSet2(this.ref, [...queue, ...forQueue], runtime5.journal);
            return succeed13(false);
          }
          case OP_SLIDING_STRATEGY: {
            const forQueue = as7.slice(0, this.requestedCapacity - queue.length);
            const toDrop = queue.length + forQueue.length - this.requestedCapacity;
            const newQueue = queue.slice(toDrop);
            unsafeSet2(this.ref, [...newQueue, ...forQueue], runtime5.journal);
            return succeed13(true);
          }
        }
      });
    }
    peek = /* @__PURE__ */ withSTMRuntime((runtime5) => {
      const queue = unsafeGet7(this.ref, runtime5.journal);
      if (queue === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      if (queue.length === 0) {
        return retry5;
      }
      return succeed13(queue[0]);
    });
    peekOption = /* @__PURE__ */ withSTMRuntime((runtime5) => {
      const queue = unsafeGet7(this.ref, runtime5.journal);
      if (queue === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      return succeed13(fromNullable(queue[0]));
    });
    take = /* @__PURE__ */ withSTMRuntime((runtime5) => {
      const queue = unsafeGet7(this.ref, runtime5.journal);
      if (queue === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      if (queue.length === 0) {
        return retry5;
      }
      const dequeued = queue.shift();
      unsafeSet2(this.ref, queue, runtime5.journal);
      return succeed13(dequeued);
    });
    takeAll = /* @__PURE__ */ withSTMRuntime((runtime5) => {
      const queue = unsafeGet7(this.ref, runtime5.journal);
      if (queue === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      unsafeSet2(this.ref, [], runtime5.journal);
      return succeed13(queue);
    });
    takeUpTo(max5) {
      return withSTMRuntime((runtime5) => {
        const queue = unsafeGet7(this.ref, runtime5.journal);
        if (queue === undefined) {
          return interruptAs2(runtime5.fiberId);
        }
        const [toTake, remaining] = splitAt2(unsafeFromArray(queue), max5);
        unsafeSet2(this.ref, Array.from(remaining), runtime5.journal);
        return succeed13(Array.from(toTake));
      });
    }
  }
  var isShutdown4 = (self2) => self2.isShutdown;
  var shutdown5 = (self2) => self2.shutdown;
  var take4 = (self2) => self2.take;

  // node_modules/effect/dist/esm/internal/stm/tPubSub.js
  var TPubSubSymbolKey = "effect/TPubSub";
  var TPubSubTypeId = /* @__PURE__ */ Symbol.for(TPubSubSymbolKey);
  var AbsentValue2 = /* @__PURE__ */ Symbol.for("effect/TPubSub/AbsentValue");
  var makeNode2 = (head6, subscribers, tail) => ({
    head: head6,
    subscribers,
    tail
  });

  class TPubSubImpl {
    pubsubSize;
    publisherHead;
    publisherTail;
    requestedCapacity;
    strategy;
    subscriberCount;
    subscribers;
    [TPubSubTypeId] = {
      _A: (_) => _
    };
    [TEnqueueTypeId] = tEnqueueVariance;
    constructor(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers) {
      this.pubsubSize = pubsubSize;
      this.publisherHead = publisherHead;
      this.publisherTail = publisherTail;
      this.requestedCapacity = requestedCapacity;
      this.strategy = strategy;
      this.subscriberCount = subscriberCount;
      this.subscribers = subscribers;
    }
    isShutdown = /* @__PURE__ */ effect3((journal) => {
      const currentPublisherTail = unsafeGet7(this.publisherTail, journal);
      return currentPublisherTail === undefined;
    });
    awaitShutdown = /* @__PURE__ */ flatMap15(this.isShutdown, (isShutdown5) => isShutdown5 ? void_6 : retry5);
    capacity() {
      return this.requestedCapacity;
    }
    size = /* @__PURE__ */ withSTMRuntime((runtime5) => {
      const currentPublisherTail = unsafeGet7(this.publisherTail, runtime5.journal);
      if (currentPublisherTail === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      return succeed13(unsafeGet7(this.pubsubSize, runtime5.journal));
    });
    isEmpty = /* @__PURE__ */ map20(this.size, (size11) => size11 === 0);
    isFull = /* @__PURE__ */ map20(this.size, (size11) => size11 === this.capacity());
    offer(value) {
      return withSTMRuntime((runtime5) => {
        const currentPublisherTail = unsafeGet7(this.publisherTail, runtime5.journal);
        if (currentPublisherTail === undefined) {
          return interruptAs2(runtime5.fiberId);
        }
        const currentSubscriberCount = unsafeGet7(this.subscriberCount, runtime5.journal);
        if (currentSubscriberCount === 0) {
          return succeed13(true);
        }
        const currentPubSubSize = unsafeGet7(this.pubsubSize, runtime5.journal);
        if (currentPubSubSize < this.requestedCapacity) {
          const updatedPublisherTail = new TRefImpl(undefined);
          const updatedNode = makeNode2(value, currentSubscriberCount, updatedPublisherTail);
          unsafeSet2(currentPublisherTail, updatedNode, runtime5.journal);
          unsafeSet2(this.publisherTail, updatedPublisherTail, runtime5.journal);
          unsafeSet2(this.pubsubSize, currentPubSubSize + 1, runtime5.journal);
          return succeed13(true);
        }
        switch (this.strategy._tag) {
          case OP_BACKPRESSURE_STRATEGY: {
            return retry5;
          }
          case OP_DROPPING_STRATEGY: {
            return succeed13(false);
          }
          case OP_SLIDING_STRATEGY: {
            if (this.requestedCapacity > 0) {
              let currentPublisherHead = unsafeGet7(this.publisherHead, runtime5.journal);
              let loop3 = true;
              while (loop3) {
                const node = unsafeGet7(currentPublisherHead, runtime5.journal);
                if (node === undefined) {
                  return retry5;
                }
                const head6 = node.head;
                const tail = node.tail;
                if (head6 !== AbsentValue2) {
                  const updatedNode2 = makeNode2(AbsentValue2, node.subscribers, node.tail);
                  unsafeSet2(currentPublisherHead, updatedNode2, runtime5.journal);
                  unsafeSet2(this.publisherHead, tail, runtime5.journal);
                  loop3 = false;
                } else {
                  currentPublisherHead = tail;
                }
              }
            }
            const updatedPublisherTail = new TRefImpl(undefined);
            const updatedNode = makeNode2(value, currentSubscriberCount, updatedPublisherTail);
            unsafeSet2(currentPublisherTail, updatedNode, runtime5.journal);
            unsafeSet2(this.publisherTail, updatedPublisherTail, runtime5.journal);
            return succeed13(true);
          }
        }
      });
    }
    offerAll(iterable) {
      return map20(forEach8(iterable, (a) => this.offer(a)), every(identity));
    }
    shutdown = /* @__PURE__ */ effect3((journal) => {
      const currentPublisherTail = unsafeGet7(this.publisherTail, journal);
      if (currentPublisherTail !== undefined) {
        unsafeSet2(this.publisherTail, undefined, journal);
        const currentSubscribers = unsafeGet7(this.subscribers, journal);
        forEach3(currentSubscribers, (subscriber) => {
          unsafeSet2(subscriber, undefined, journal);
        });
        unsafeSet2(this.subscribers, empty8(), journal);
      }
    });
  }

  class TPubSubSubscriptionImpl {
    pubsubSize;
    publisherHead;
    requestedCapacity;
    subscriberHead;
    subscriberCount;
    subscribers;
    [TPubSubTypeId] = TPubSubTypeId;
    [TDequeueTypeId] = tDequeueVariance;
    constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
      this.pubsubSize = pubsubSize;
      this.publisherHead = publisherHead;
      this.requestedCapacity = requestedCapacity;
      this.subscriberHead = subscriberHead;
      this.subscriberCount = subscriberCount;
      this.subscribers = subscribers;
    }
    isShutdown = /* @__PURE__ */ effect3((journal) => {
      const currentSubscriberHead = unsafeGet7(this.subscriberHead, journal);
      return currentSubscriberHead === undefined;
    });
    awaitShutdown = /* @__PURE__ */ flatMap15(this.isShutdown, (isShutdown5) => isShutdown5 ? void_6 : retry5);
    capacity() {
      return this.requestedCapacity;
    }
    size = /* @__PURE__ */ withSTMRuntime((runtime5) => {
      let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime5.journal);
      if (currentSubscriberHead === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      let loop3 = true;
      let size11 = 0;
      while (loop3) {
        const node = unsafeGet7(currentSubscriberHead, runtime5.journal);
        if (node === undefined) {
          loop3 = false;
        } else {
          const head6 = node.head;
          const tail = node.tail;
          if (head6 !== AbsentValue2) {
            size11 = size11 + 1;
            if (size11 >= Number.MAX_SAFE_INTEGER) {
              loop3 = false;
            }
          }
          currentSubscriberHead = tail;
        }
      }
      return succeed13(size11);
    });
    isEmpty = /* @__PURE__ */ map20(this.size, (size11) => size11 === 0);
    isFull = /* @__PURE__ */ map20(this.size, (size11) => size11 === this.capacity());
    peek = /* @__PURE__ */ withSTMRuntime((runtime5) => {
      let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime5.journal);
      if (currentSubscriberHead === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      let value = AbsentValue2;
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet7(currentSubscriberHead, runtime5.journal);
        if (node === undefined) {
          return retry5;
        }
        const head6 = node.head;
        const tail = node.tail;
        if (head6 !== AbsentValue2) {
          value = head6;
          loop3 = false;
        } else {
          currentSubscriberHead = tail;
        }
      }
      return succeed13(value);
    });
    peekOption = /* @__PURE__ */ withSTMRuntime((runtime5) => {
      let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime5.journal);
      if (currentSubscriberHead === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      let value = none2();
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet7(currentSubscriberHead, runtime5.journal);
        if (node === undefined) {
          value = none2();
          loop3 = false;
        } else {
          const head6 = node.head;
          const tail = node.tail;
          if (head6 !== AbsentValue2) {
            value = some2(head6);
            loop3 = false;
          } else {
            currentSubscriberHead = tail;
          }
        }
      }
      return succeed13(value);
    });
    shutdown = /* @__PURE__ */ effect3((journal) => {
      let currentSubscriberHead = unsafeGet7(this.subscriberHead, journal);
      if (currentSubscriberHead !== undefined) {
        unsafeSet2(this.subscriberHead, undefined, journal);
        let loop3 = true;
        while (loop3) {
          const node = unsafeGet7(currentSubscriberHead, journal);
          if (node === undefined) {
            loop3 = false;
          } else {
            const head6 = node.head;
            const tail = node.tail;
            if (head6 !== AbsentValue2) {
              const subscribers = node.subscribers;
              if (subscribers === 1) {
                const size11 = unsafeGet7(this.pubsubSize, journal);
                const updatedNode = makeNode2(AbsentValue2, 0, tail);
                unsafeSet2(currentSubscriberHead, updatedNode, journal);
                unsafeSet2(this.publisherHead, tail, journal);
                unsafeSet2(this.pubsubSize, size11 - 1, journal);
              } else {
                const updatedNode = makeNode2(head6, subscribers - 1, tail);
                unsafeSet2(currentSubscriberHead, updatedNode, journal);
              }
            }
            currentSubscriberHead = tail;
          }
        }
        const currentSubscriberCount = unsafeGet7(this.subscriberCount, journal);
        unsafeSet2(this.subscriberCount, currentSubscriberCount - 1, journal);
        unsafeSet2(this.subscribers, remove4(unsafeGet7(this.subscribers, journal), this.subscriberHead), journal);
      }
    });
    take = /* @__PURE__ */ withSTMRuntime((runtime5) => {
      let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime5.journal);
      if (currentSubscriberHead === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      let value = AbsentValue2;
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet7(currentSubscriberHead, runtime5.journal);
        if (node === undefined) {
          return retry5;
        }
        const head6 = node.head;
        const tail = node.tail;
        if (head6 !== AbsentValue2) {
          const subscribers = node.subscribers;
          if (subscribers === 1) {
            const size11 = unsafeGet7(this.pubsubSize, runtime5.journal);
            const updatedNode = makeNode2(AbsentValue2, 0, tail);
            unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
            unsafeSet2(this.publisherHead, tail, runtime5.journal);
            unsafeSet2(this.pubsubSize, size11 - 1, runtime5.journal);
          } else {
            const updatedNode = makeNode2(head6, subscribers - 1, tail);
            unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
          }
          unsafeSet2(this.subscriberHead, tail, runtime5.journal);
          value = head6;
          loop3 = false;
        } else {
          currentSubscriberHead = tail;
        }
      }
      return succeed13(value);
    });
    takeAll = /* @__PURE__ */ this.takeUpTo(Number.POSITIVE_INFINITY);
    takeUpTo(max5) {
      return withSTMRuntime((runtime5) => {
        let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime5.journal);
        if (currentSubscriberHead === undefined) {
          return interruptAs2(runtime5.fiberId);
        }
        const builder = [];
        let n = 0;
        while (n !== max5) {
          const node = unsafeGet7(currentSubscriberHead, runtime5.journal);
          if (node === undefined) {
            n = max5;
          } else {
            const head6 = node.head;
            const tail = node.tail;
            if (head6 !== AbsentValue2) {
              const subscribers = node.subscribers;
              if (subscribers === 1) {
                const size11 = unsafeGet7(this.pubsubSize, runtime5.journal);
                const updatedNode = makeNode2(AbsentValue2, 0, tail);
                unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
                unsafeSet2(this.publisherHead, tail, runtime5.journal);
                unsafeSet2(this.pubsubSize, size11 - 1, runtime5.journal);
              } else {
                const updatedNode = makeNode2(head6, subscribers - 1, tail);
                unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
              }
              builder.push(head6);
              n = n + 1;
            }
            currentSubscriberHead = tail;
          }
        }
        unsafeSet2(this.subscriberHead, currentSubscriberHead, runtime5.journal);
        return succeed13(builder);
      });
    }
  }
  var makeSubscription2 = (pubsubSize, publisherHead, publisherTail, requestedCapacity, subscriberCount, subscribers) => pipe(get16(publisherTail), flatMap15((currentPublisherTail) => pipe(all5([make48(currentPublisherTail), get16(subscriberCount), get16(subscribers)]), tap5(([_, currentSubscriberCount]) => pipe(subscriberCount, set7(currentSubscriberCount + 1))), tap5(([subscriberHead, _, currentSubscribers]) => pipe(subscribers, set7(pipe(currentSubscribers, add4(subscriberHead))))), map20(([subscriberHead]) => new TPubSubSubscriptionImpl(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers)))));
  var subscribe3 = (self2) => makeSubscription2(self2.pubsubSize, self2.publisherHead, self2.publisherTail, self2.requestedCapacity, self2.subscriberCount, self2.subscribers);
  var subscribeScoped = (self2) => acquireRelease2(subscribe3(self2), (dequeue) => shutdown5(dequeue));

  // node_modules/effect/dist/esm/TPubSub.js
  var subscribeScoped2 = subscribeScoped;

  // node_modules/effect/dist/esm/TQueue.js
  var isShutdown6 = isShutdown4;
  var take5 = take4;

  // node_modules/effect/dist/esm/internal/ringBuffer.js
  class RingBuffer {
    capacity;
    array;
    size = 0;
    current = 0;
    constructor(capacity7) {
      this.capacity = capacity7;
      this.array = Array.from({
        length: capacity7
      }, constUndefined);
    }
    head() {
      return fromNullable(this.array[this.current]);
    }
    lastOrNull() {
      if (this.size === 0) {
        return;
      }
      const index = this.current === 0 ? this.array.length - 1 : this.current - 1;
      return this.array[index] ?? undefined;
    }
    put(value) {
      this.array[this.current] = value;
      this.increment();
    }
    dropLast() {
      if (this.size > 0) {
        this.decrement();
        this.array[this.current] = undefined;
      }
    }
    toChunk() {
      const begin = this.current - this.size;
      const newArray = begin < 0 ? [...this.array.slice(this.capacity + begin, this.capacity), ...this.array.slice(0, this.current)] : this.array.slice(begin, this.current);
      return fromIterable2(newArray);
    }
    increment() {
      if (this.size < this.capacity) {
        this.size += 1;
      }
      this.current = (this.current + 1) % this.capacity;
    }
    decrement() {
      this.size -= 1;
      if (this.current > 0) {
        this.current -= 1;
      } else {
        this.current = this.capacity - 1;
      }
    }
  }

  // node_modules/effect/dist/esm/internal/stream/debounceState.js
  var OP_NOT_STARTED = "NotStarted";
  var OP_PREVIOUS = "Previous";
  var OP_CURRENT = "Current";
  var notStarted = {
    _tag: OP_NOT_STARTED
  };
  var previous = (fiber) => ({
    _tag: OP_PREVIOUS,
    fiber
  });
  var current = (fiber) => ({
    _tag: OP_CURRENT,
    fiber
  });

  // node_modules/effect/dist/esm/internal/stream/emit.js
  var make49 = (emit) => {
    const ops = {
      chunk(as7) {
        return this(succeed8(as7));
      },
      die(defect) {
        return this(die6(defect));
      },
      dieMessage(message) {
        return this(dieMessage2(message));
      },
      done(exit3) {
        return this(suspend3(() => mapBoth3(exit3, {
          onFailure: some2,
          onSuccess: of2
        })));
      },
      end() {
        return this(fail9(none2()));
      },
      fail(e) {
        return this(fail9(some2(e)));
      },
      fromEffect(effect4) {
        return this(mapBoth4(effect4, {
          onFailure: some2,
          onSuccess: of2
        }));
      },
      fromEffectChunk(effect4) {
        return this(pipe(effect4, mapError3(some2)));
      },
      halt(cause3) {
        return this(failCause8(pipe(cause3, map12(some2))));
      },
      single(value) {
        return this(succeed8(of2(value)));
      }
    };
    return Object.assign(emit, ops);
  };
  var makePush = (queue, scheduler) => {
    let finished = false;
    let buffer = [];
    let running4 = false;
    function array3(items) {
      if (finished)
        return false;
      if (items.length <= 50000) {
        buffer.push.apply(buffer, items);
      } else {
        for (let i = 0;i < items.length; i++) {
          buffer.push(items[0]);
        }
      }
      if (!running4) {
        running4 = true;
        scheduler.scheduleTask(flush, 0);
      }
      return true;
    }
    function flush() {
      running4 = false;
      if (buffer.length > 0) {
        queue.unsafeOffer(buffer);
        buffer = [];
      }
    }
    function done10(exit3) {
      if (finished)
        return;
      finished = true;
      if (exit3._tag === "Success") {
        buffer.push(exit3.value);
      }
      flush();
      queue.unsafeOffer(exit3._tag === "Success" ? void_2 : exit3);
    }
    return {
      single(value) {
        if (finished)
          return false;
        buffer.push(value);
        if (!running4) {
          running4 = true;
          scheduler.scheduleTask(flush, 0);
        }
        return true;
      },
      array: array3,
      chunk(chunk2) {
        return array3(toReadonlyArray(chunk2));
      },
      done: done10,
      end() {
        if (finished)
          return;
        finished = true;
        flush();
        queue.unsafeOffer(void_2);
      },
      halt(cause3) {
        return done10(failCause3(cause3));
      },
      fail(error) {
        return done10(fail4(error));
      },
      die(defect) {
        return done10(die3(defect));
      },
      dieMessage(message) {
        return done10(die3(new Error(message)));
      }
    };
  };

  // node_modules/effect/dist/esm/internal/stream/handoff.js
  var HandoffTypeId = /* @__PURE__ */ Symbol.for("effect/Stream/Handoff");
  var OP_HANDOFF_STATE_EMPTY = "Empty";
  var OP_HANDOFF_STATE_FULL = "Full";
  var handoffStateEmpty = (notifyConsumer) => ({
    _tag: OP_HANDOFF_STATE_EMPTY,
    notifyConsumer
  });
  var handoffStateFull = (value, notifyProducer) => ({
    _tag: OP_HANDOFF_STATE_FULL,
    value,
    notifyProducer
  });
  var handoffStateMatch = (onEmpty, onFull) => {
    return (self2) => {
      switch (self2._tag) {
        case OP_HANDOFF_STATE_EMPTY: {
          return onEmpty(self2.notifyConsumer);
        }
        case OP_HANDOFF_STATE_FULL: {
          return onFull(self2.value, self2.notifyProducer);
        }
      }
    };
  };
  var handoffVariance = {
    _A: (_) => _
  };
  var make50 = () => pipe(make19(), flatMap11((deferred) => make29(handoffStateEmpty(deferred))), map16((ref) => ({
    [HandoffTypeId]: handoffVariance,
    ref
  })));
  var offer5 = /* @__PURE__ */ dual(2, (self2, value) => {
    return flatMap11(make19(), (deferred) => flatten9(modify4(self2.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [zipRight3(succeed2(notifyConsumer, undefined), _await(deferred)), handoffStateFull(value, deferred)], (_, notifyProducer) => [flatMap11(_await(notifyProducer), () => pipe(self2, offer5(value))), state])))));
  });
  var take6 = (self2) => flatMap11(make19(), (deferred) => flatten9(modify4(self2.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [flatMap11(_await(notifyConsumer), () => take6(self2)), state], (value, notifyProducer) => [as3(succeed2(notifyProducer, undefined), value), handoffStateEmpty(deferred)])))));

  // node_modules/effect/dist/esm/internal/stream/handoffSignal.js
  var OP_EMIT4 = "Emit";
  var OP_HALT = "Halt";
  var OP_END = "End";
  var emit = (elements) => ({
    _tag: OP_EMIT4,
    elements
  });
  var halt = (cause3) => ({
    _tag: OP_HALT,
    cause: cause3
  });
  var end3 = (reason) => ({
    _tag: OP_END,
    reason
  });

  // node_modules/effect/dist/esm/internal/take.js
  var TakeSymbolKey = "effect/Take";
  var TakeTypeId = /* @__PURE__ */ Symbol.for(TakeSymbolKey);
  var takeVariance = {
    _A: (_) => _,
    _E: (_) => _
  };

  class TakeImpl {
    exit;
    [TakeTypeId] = takeVariance;
    constructor(exit3) {
      this.exit = exit3;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var chunk2 = (chunk3) => new TakeImpl(succeed3(chunk3));
  var done10 = (self2) => suspend3(() => self2.exit);
  var end4 = /* @__PURE__ */ new TakeImpl(/* @__PURE__ */ fail4(/* @__PURE__ */ none2()));
  var failCause11 = (cause3) => new TakeImpl(failCause3(pipe(cause3, map12(some2))));
  var fromPull = (pull) => matchCause3(pull, {
    onFailure: (cause3) => match2(flipCauseOption2(cause3), {
      onNone: () => end4,
      onSome: failCause11
    }),
    onSuccess: chunk2
  });
  var match17 = /* @__PURE__ */ dual(2, (self2, {
    onEnd,
    onFailure,
    onSuccess
  }) => match6(self2.exit, {
    onFailure: (cause3) => match2(flipCauseOption2(cause3), {
      onNone: onEnd,
      onSome: onFailure
    }),
    onSuccess
  }));
  var of5 = (value) => new TakeImpl(succeed3(of2(value)));

  // node_modules/effect/dist/esm/internal/stream/pull.js
  var end5 = () => fail9(none2());
  var failCause12 = (cause3) => mapError3(failCause8(cause3), some2);

  // node_modules/effect/dist/esm/internal/stream/sinkEndReason.js
  var OP_SCHEDULE_END = "ScheduleEnd";
  var OP_UPSTREAM_END = "UpstreamEnd";
  var ScheduleEnd = {
    _tag: OP_SCHEDULE_END
  };
  var UpstreamEnd = {
    _tag: OP_UPSTREAM_END
  };

  // node_modules/effect/dist/esm/internal/stream/zipAllState.js
  var OP_DRAIN_LEFT = "DrainLeft";
  var OP_DRAIN_RIGHT = "DrainRight";
  var OP_PULL_BOTH = "PullBoth";
  var OP_PULL_LEFT = "PullLeft";
  var OP_PULL_RIGHT = "PullRight";
  var DrainLeft = {
    _tag: OP_DRAIN_LEFT
  };
  var DrainRight = {
    _tag: OP_DRAIN_RIGHT
  };
  var PullBoth = {
    _tag: OP_PULL_BOTH
  };
  var PullLeft = (rightChunk) => ({
    _tag: OP_PULL_LEFT,
    rightChunk
  });
  var PullRight = (leftChunk) => ({
    _tag: OP_PULL_RIGHT,
    leftChunk
  });

  // node_modules/effect/dist/esm/internal/stream/zipChunksState.js
  var OP_PULL_BOTH2 = "PullBoth";
  var OP_PULL_LEFT2 = "PullLet";
  var OP_PULL_RIGHT2 = "PullRight";
  var PullBoth2 = {
    _tag: OP_PULL_BOTH2
  };
  var PullLeft2 = (rightChunk) => ({
    _tag: OP_PULL_LEFT2,
    rightChunk
  });
  var PullRight2 = (leftChunk) => ({
    _tag: OP_PULL_RIGHT2,
    leftChunk
  });

  // node_modules/effect/dist/esm/internal/stream.js
  var StreamSymbolKey = "effect/Stream";
  var StreamTypeId2 = /* @__PURE__ */ Symbol.for(StreamSymbolKey);
  var streamVariance = {
    _R: (_) => _,
    _E: (_) => _,
    _A: (_) => _
  };

  class StreamImpl {
    channel;
    [StreamTypeId2] = streamVariance;
    constructor(channel) {
      this.channel = channel;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  var isStream = (u) => hasProperty(u, StreamTypeId2) || isEffect2(u);
  var DefaultChunkSize = 4096;
  var accumulate = (self2) => chunks(accumulateChunks(self2));
  var accumulateChunks = (self2) => {
    const accumulator = (s) => readWith({
      onInput: (input) => {
        const next = appendAll2(s, input);
        return flatMap13(write(next), () => accumulator(next));
      },
      onFailure: fail11,
      onDone: () => void_5
    });
    return new StreamImpl(pipeTo(toChannel2(self2), accumulator(empty5())));
  };
  var acquireRelease3 = (acquire, release) => scoped5(acquireRelease2(acquire, release));
  var aggregate = /* @__PURE__ */ dual(2, (self2, sink) => aggregateWithin(self2, sink, forever4));
  var aggregateWithin = /* @__PURE__ */ dual(3, (self2, sink, schedule2) => filterMap7(aggregateWithinEither(self2, sink, schedule2), (_) => match(_, {
    onLeft: none2,
    onRight: some2
  })));
  var aggregateWithinEither = /* @__PURE__ */ dual(3, (self2, sink, schedule2) => {
    const layer = all4([make50(), make29(ScheduleEnd), make29(empty5()), driver2(schedule2), make29(false), make29(false)]);
    return fromEffect7(layer).pipe(flatMap16(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {
      const handoffProducer = readWithCause({
        onInput: (input) => flatMap13(fromEffect4(pipe(handoff, offer5(emit(input)), when2(() => isNonEmpty2(input)))), () => handoffProducer),
        onFailure: (cause3) => fromEffect4(offer5(handoff, halt(cause3))),
        onDone: () => fromEffect4(offer5(handoff, end3(UpstreamEnd)))
      });
      const handoffConsumer = pipe(getAndSet2(sinkLeftovers, empty5()), flatMap11((leftovers) => {
        if (isNonEmpty2(leftovers)) {
          return pipe(set6(consumed, true), zipRight3(succeed8(pipe(write(leftovers), flatMap13(() => handoffConsumer)))));
        }
        return pipe(take6(handoff), map16((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return pipe(fromEffect4(set6(consumed, true)), zipRight4(write(signal.elements)), zipRight4(fromEffect4(get12(endAfterEmit))), flatMap13((bool) => bool ? void_5 : handoffConsumer));
            }
            case OP_HALT: {
              return failCause10(signal.cause);
            }
            case OP_END: {
              if (signal.reason._tag === OP_SCHEDULE_END) {
                return pipe(get12(consumed), map16((bool) => bool ? fromEffect4(pipe(set6(sinkEndReason, ScheduleEnd), zipRight3(set6(endAfterEmit, true)))) : pipe(fromEffect4(pipe(set6(sinkEndReason, ScheduleEnd), zipRight3(set6(endAfterEmit, true)))), flatMap13(() => handoffConsumer))), unwrap);
              }
              return pipe(set6(sinkEndReason, signal.reason), zipRight3(set6(endAfterEmit, true)), fromEffect4);
            }
          }
        }));
      }), unwrap);
      const timeout3 = (lastB) => scheduleDriver.next(lastB);
      const scheduledAggregator = (sinkFiber, scheduleFiber, scope5) => {
        const forkSink = pipe(set6(consumed, false), zipRight3(set6(endAfterEmit, false)), zipRight3(pipe(handoffConsumer, pipeToOrFail(toChannel(sink)), collectElements, run, forkIn2(scope5))));
        const handleSide = (leftovers, b, c) => pipe(set6(sinkLeftovers, flatten3(leftovers)), zipRight3(map16(get12(sinkEndReason), (reason) => {
          switch (reason._tag) {
            case OP_SCHEDULE_END: {
              return pipe(all4([get12(consumed), forkSink, pipe(timeout3(some2(b)), forkIn2(scope5))]), map16(([wasConsumed, sinkFiber2, scheduleFiber2]) => {
                const toWrite = pipe(c, match2({
                  onNone: () => of2(right2(b)),
                  onSome: (c2) => make6(right2(b), left2(c2))
                }));
                if (wasConsumed) {
                  return pipe(write(toWrite), flatMap13(() => scheduledAggregator(sinkFiber2, scheduleFiber2, scope5)));
                }
                return scheduledAggregator(sinkFiber2, scheduleFiber2, scope5);
              }), unwrap);
            }
            case OP_UPSTREAM_END: {
              return pipe(get12(consumed), map16((wasConsumed) => wasConsumed ? write(of2(right2(b))) : void_5), unwrap);
            }
          }
        })), unwrap);
        return unwrap(raceWith2(join3(sinkFiber), join3(scheduleFiber), {
          onSelfDone: (sinkExit, _) => pipe(interrupt6(scheduleFiber), zipRight3(pipe(suspend3(() => sinkExit), map16(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
          onOtherDone: (scheduleExit, _) => matchCauseEffect3(suspend3(() => scheduleExit), {
            onFailure: (cause3) => match(failureOrCause2(cause3), {
              onLeft: () => pipe(handoff, offer5(end3(ScheduleEnd)), forkDaemon2, zipRight3(pipe(join3(sinkFiber), map16(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
              onRight: (cause4) => pipe(handoff, offer5(halt(cause4)), forkDaemon2, zipRight3(pipe(join3(sinkFiber), map16(([leftovers, b]) => handleSide(leftovers, b, none2())))))
            }),
            onSuccess: (c) => pipe(handoff, offer5(end3(ScheduleEnd)), forkDaemon2, zipRight3(pipe(join3(sinkFiber), map16(([leftovers, b]) => handleSide(leftovers, b, some2(c))))))
          })
        }));
      };
      return unwrapScopedWith3((scope5) => pipeTo(toChannel2(self2), handoffProducer).pipe(run, forkIn2(scope5), zipRight3(pipeToOrFail(handoffConsumer, toChannel(sink)).pipe(collectElements, run, forkIn2(scope5), flatMap11((sinkFiber) => timeout3(none2()).pipe(forkIn2(scope5), map16((scheduleFiber) => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope5)))))))));
    }));
  });
  var as7 = /* @__PURE__ */ dual(2, (self2, value) => map21(self2, () => value));
  var queueFromBufferOptions = (bufferSize) => {
    if (bufferSize === "unbounded") {
      return unbounded5();
    } else if (typeof bufferSize === "number" || bufferSize === undefined) {
      return bounded5(bufferSize ?? 16);
    }
    switch (bufferSize.strategy) {
      case "dropping":
        return dropping4(bufferSize.bufferSize ?? 16);
      case "sliding":
        return sliding4(bufferSize.bufferSize ?? 16);
      default:
        return bounded5(bufferSize.bufferSize ?? 16);
    }
  };
  var _async = (register, bufferSize) => acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)).pipe(flatMap11((output) => runtime4().pipe(flatMap11((runtime5) => sync3(() => {
    const runPromiseExit3 = runPromiseExit2(runtime5);
    const canceler = register(make49((resume2) => fromPull(resume2).pipe(flatMap11((take7) => offer3(output, take7)), asVoid3, runPromiseExit3).then((exit3) => {
      if (isFailure(exit3)) {
        if (!isInterrupted2(exit3.cause)) {
          throw squash(exit3.cause);
        }
      }
    })));
    return canceler;
  })), map16((value) => {
    const loop3 = take3(output).pipe(flatMap11((take7) => done10(take7)), match12({
      onFailure: (maybeError) => fromEffect4(shutdown4(output)).pipe(zipRight4(match2(maybeError, {
        onNone: () => void_5,
        onSome: (error) => fail11(error)
      }))),
      onSuccess: (chunk3) => write(chunk3).pipe(flatMap13(() => loop3))
    }), unwrap);
    return fromChannel2(loop3).pipe(ensuring6(value ?? _void));
  }))), unwrapScoped5);
  var asyncEffect3 = (register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)), flatMap11((output) => pipe(runtime4(), flatMap11((runtime5) => pipe(register(make49((k) => pipe(fromPull(k), flatMap11((take7) => offer3(output, take7)), asVoid3, runPromiseExit2(runtime5)).then((exit3) => {
    if (isFailure(exit3)) {
      if (!isInterrupted2(exit3.cause)) {
        throw squash(exit3.cause);
      }
    }
  }))), map16(() => {
    const loop3 = pipe(take3(output), flatMap11(done10), match12({
      onFailure: (maybeError) => pipe(fromEffect4(shutdown4(output)), zipRight4(match2(maybeError, {
        onNone: () => void_5,
        onSome: fail11
      }))),
      onSuccess: (chunk3) => pipe(write(chunk3), flatMap13(() => loop3))
    }), unwrap);
    return loop3;
  }))))), unwrapScoped3, fromChannel2);
  var queueFromBufferOptionsPush = (options) => {
    if (options?.bufferSize === "unbounded" || options?.bufferSize === undefined && options?.strategy === undefined) {
      return unbounded5();
    }
    switch (options?.strategy) {
      case "sliding":
        return sliding4(options.bufferSize ?? 16);
      default:
        return dropping4(options?.bufferSize ?? 16);
    }
  };
  var asyncPush = (register, options) => acquireRelease2(queueFromBufferOptionsPush(options), shutdown4).pipe(tap3((queue) => getWith(currentScheduler2, (scheduler) => register(makePush(queue, scheduler)))), map16((queue) => {
    const loop3 = flatMap13(take3(queue), (item) => isExit(item) ? isSuccess(item) ? void_5 : failCause10(item.cause) : zipRight4(write(unsafeFromArray(item)), loop3));
    return loop3;
  }), unwrapScoped3, fromChannel2);
  var asyncScoped = (register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)), flatMap11((output) => pipe(runtime4(), flatMap11((runtime5) => pipe(register(make49((k) => pipe(fromPull(k), flatMap11((take7) => offer3(output, take7)), asVoid3, runPromiseExit2(runtime5)).then((exit3) => {
    if (isFailure(exit3)) {
      if (!isInterrupted2(exit3.cause)) {
        throw squash(exit3.cause);
      }
    }
  }))), zipRight3(make29(false)), flatMap11((ref) => pipe(get12(ref), map16((isDone7) => isDone7 ? end5() : pipe(take3(output), flatMap11(done10), onError2(() => pipe(set6(ref, true), zipRight3(shutdown4(output)))))))))))), scoped5, flatMap16(repeatEffectChunkOption));
  var branchAfter = /* @__PURE__ */ dual(3, (self2, n, f) => suspend9(() => {
    const buffering = (acc) => readWith({
      onInput: (input) => {
        const nextSize = acc.length + input.length;
        if (nextSize >= n) {
          const [b1, b2] = pipe(input, splitAt2(n - acc.length));
          return running4(pipe(acc, appendAll2(b1)), b2);
        }
        return buffering(pipe(acc, appendAll2(input)));
      },
      onFailure: fail11,
      onDone: () => running4(acc, empty5())
    });
    const running4 = (prefix, leftover) => pipeTo(zipRight4(write(leftover), identityChannel()), toChannel2(f(prefix)));
    return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(buffering(empty5()))));
  }));
  var broadcast = /* @__PURE__ */ dual(3, (self2, n, maximumLag) => pipe(self2, broadcastedQueues(n, maximumLag), map16((tuple) => tuple.map((queue) => flattenTake(fromQueue2(queue, {
    shutdown: true
  }))))));
  var broadcastDynamic = /* @__PURE__ */ dual(2, (self2, maximumLag) => map16(toPubSub2(self2, maximumLag), (pubsub) => flattenTake(fromPubSub(pubsub))));
  var share = /* @__PURE__ */ dual(2, (self2, options) => map16(make45({
    acquire: broadcastDynamic(self2, options),
    idleTimeToLive: options.idleTimeToLive
  }), (rcRef) => unwrapScoped5(get15(rcRef))));
  var broadcastedQueues = /* @__PURE__ */ dual(3, (self2, n, maximumLag) => flatMap11(pubsubFromOptions(maximumLag), (pubsub) => pipe(all4(Array.from({
    length: n
  }, () => subscribe2(pubsub))), tap3(() => forkScoped2(runIntoPubSubScoped(self2, pubsub))))));
  var broadcastedQueuesDynamic = /* @__PURE__ */ dual(2, (self2, maximumLag) => map16(toPubSub2(self2, maximumLag), subscribe2));
  var buffer = /* @__PURE__ */ dual(2, (self2, options) => {
    if (options.capacity === "unbounded") {
      return bufferUnbounded(self2);
    } else if (options.strategy === "dropping") {
      return bufferDropping(self2, options.capacity);
    } else if (options.strategy === "sliding") {
      return bufferSliding(self2, options.capacity);
    }
    const queue = toQueueOfElements(self2, options);
    return new StreamImpl(unwrapScoped3(map16(queue, (queue2) => {
      const process2 = pipe(fromEffect4(take3(queue2)), flatMap13(match6({
        onFailure: (cause3) => pipe(flipCauseOption2(cause3), match2({
          onNone: () => void_5,
          onSome: failCause10
        })),
        onSuccess: (value) => flatMap13(write(of2(value)), () => process2)
      })));
      return process2;
    })));
  });
  var bufferChunks = /* @__PURE__ */ dual(2, (self2, options) => {
    if (options.strategy === "dropping") {
      return bufferChunksDropping(self2, options.capacity);
    } else if (options.strategy === "sliding") {
      return bufferChunksSliding(self2, options.capacity);
    }
    const queue = toQueue2(self2, options);
    return new StreamImpl(unwrapScoped3(map16(queue, (queue2) => {
      const process2 = pipe(fromEffect4(take3(queue2)), flatMap13(match17({
        onEnd: () => void_5,
        onFailure: failCause10,
        onSuccess: (value) => pipe(write(value), flatMap13(() => process2))
      })));
      return process2;
    })));
  });
  var bufferChunksDropping = /* @__PURE__ */ dual(2, (self2, capacity7) => {
    const queue = acquireRelease2(dropping4(capacity7), (queue2) => shutdown4(queue2));
    return new StreamImpl(bufferSignal(queue, toChannel2(self2)));
  });
  var bufferChunksSliding = /* @__PURE__ */ dual(2, (self2, capacity7) => {
    const queue = acquireRelease2(sliding4(capacity7), (queue2) => shutdown4(queue2));
    return new StreamImpl(bufferSignal(queue, toChannel2(self2)));
  });
  var bufferDropping = /* @__PURE__ */ dual(2, (self2, capacity7) => {
    const queue = acquireRelease2(dropping4(capacity7), (queue2) => shutdown4(queue2));
    return new StreamImpl(bufferSignal(queue, toChannel2(rechunk(1)(self2))));
  });
  var bufferSliding = /* @__PURE__ */ dual(2, (self2, capacity7) => {
    const queue = acquireRelease2(sliding4(capacity7), (queue2) => shutdown4(queue2));
    return new StreamImpl(bufferSignal(queue, toChannel2(pipe(self2, rechunk(1)))));
  });
  var bufferUnbounded = (self2) => {
    const queue = toQueue2(self2, {
      strategy: "unbounded"
    });
    return new StreamImpl(unwrapScoped3(map16(queue, (queue2) => {
      const process2 = pipe(fromEffect4(take3(queue2)), flatMap13(match17({
        onEnd: () => void_5,
        onFailure: failCause10,
        onSuccess: (value) => flatMap13(write(value), () => process2)
      })));
      return process2;
    })));
  };
  var bufferSignal = (scoped5, bufferChannel) => {
    const producer = (queue, ref) => {
      const terminate = (take7) => pipe(get12(ref), tap3(_await), zipRight3(make19()), flatMap11((deferred) => pipe(offer3(queue, [take7, deferred]), zipRight3(set6(ref, deferred)), zipRight3(_await(deferred)))), asVoid3, fromEffect4);
      return readWithCause({
        onInput: (input) => pipe(make19(), flatMap11((deferred) => pipe(offer3(queue, [chunk2(input), deferred]), flatMap11((added) => pipe(set6(ref, deferred), when2(() => added))))), asVoid3, fromEffect4, flatMap13(() => producer(queue, ref))),
        onFailure: (error) => terminate(failCause11(error)),
        onDone: () => terminate(end4)
      });
    };
    const consumer = (queue) => {
      const process2 = pipe(fromEffect4(take3(queue)), flatMap13(([take7, deferred]) => zipRight4(fromEffect4(succeed2(deferred, undefined)), match17(take7, {
        onEnd: () => void_5,
        onFailure: failCause10,
        onSuccess: (value) => pipe(write(value), flatMap13(() => process2))
      }))));
      return process2;
    };
    return unwrapScoped3(pipe(scoped5, flatMap11((queue) => pipe(make19(), tap3((start3) => succeed2(start3, undefined)), flatMap11((start3) => pipe(make29(start3), flatMap11((ref) => pipe(bufferChannel, pipeTo(producer(queue, ref)), runScoped, forkScoped2)), as3(consumer(queue))))))));
  };
  var catchAll7 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause6(self2, (cause3) => match(failureOrCause2(cause3), {
    onLeft: f,
    onRight: failCause13
  })));
  var catchAllCause6 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), catchAllCause5((cause3) => toChannel2(f(cause3))))));
  var catchSome3 = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, catchAll7((error) => pipe(pf(error), getOrElse(() => fail15(error))))));
  var catchSomeCause3 = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, catchAllCause6((cause3) => pipe(pf(cause3), getOrElse(() => failCause13(cause3))))));
  var catchTag3 = /* @__PURE__ */ dual(3, (self2, k, f) => catchAll7(self2, (e) => {
    if ("_tag" in e && e["_tag"] === k) {
      return f(e);
    }
    return fail15(e);
  }));
  var catchTags3 = /* @__PURE__ */ dual(2, (self2, cases) => catchAll7(self2, (e) => {
    const keys3 = Object.keys(cases);
    if ("_tag" in e && keys3.includes(e["_tag"])) {
      return cases[e["_tag"]](e);
    }
    return fail15(e);
  }));
  var changes = (self2) => pipe(self2, changesWith((x, y) => equals(y)(x)));
  var changesWith = /* @__PURE__ */ dual(2, (self2, f) => {
    const writer = (last4) => readWithCause({
      onInput: (input) => {
        const [newLast, newChunk] = reduce2(input, [last4, empty5()], ([option3, outputs], output) => {
          if (isSome2(option3) && f(option3.value, output)) {
            return [some2(output), outputs];
          }
          return [some2(output), pipe(outputs, append2(output))];
        });
        return flatMap13(write(newChunk), () => writer(newLast));
      },
      onFailure: failCause10,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer(none2()))));
  });
  var changesWithEffect = /* @__PURE__ */ dual(2, (self2, f) => {
    const writer = (last4) => readWithCause({
      onInput: (input) => pipe(input, reduce10([last4, empty5()], ([option3, outputs], output) => {
        if (isSome2(option3)) {
          return pipe(f(option3.value, output), map16((bool) => bool ? [some2(output), outputs] : [some2(output), pipe(outputs, append2(output))]));
        }
        return succeed8([some2(output), pipe(outputs, append2(output))]);
      }), fromEffect4, flatMap13(([newLast, newChunk]) => pipe(write(newChunk), flatMap13(() => writer(newLast))))),
      onFailure: failCause10,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer(none2()))));
  });
  var chunks = (self2) => pipe(self2, mapChunks(of2));
  var chunksWith = /* @__PURE__ */ dual(2, (self2, f) => flattenChunks(f(chunks(self2))));
  var unsome = (effect4) => catchAll3(asSome2(effect4), (o) => o._tag === "None" ? succeedNone2 : fail9(o.value));
  var combine9 = /* @__PURE__ */ dual(4, (self2, that, s, f) => {
    function producer(handoff, latch) {
      return fromEffect4(take6(latch)).pipe(zipRight4(readWithCause({
        onInput: (input) => flatMap13(fromEffect4(offer5(handoff, succeed3(input))), () => producer(handoff, latch)),
        onFailure: (cause3) => fromEffect4(offer5(handoff, failCause3(pipe(cause3, map12(some2))))),
        onDone: () => flatMap13(fromEffect4(offer5(handoff, fail4(none2()))), () => producer(handoff, latch))
      })));
    }
    return new StreamImpl(unwrapScopedWith((scope5) => all4([make50(), make50(), make50(), make50()]).pipe(tap3(([left3, _, latchL]) => toChannel2(self2).pipe(concatMap(writeChunk), pipeTo(producer(left3, latchL)), runIn(scope5), forkIn2(scope5))), tap3(([, right3, _, rightL]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3, rightL)), runIn(scope5), forkIn2(scope5))), map16(([left3, right3, latchL, latchR]) => {
      const pullLeft = offer5(latchL, undefined).pipe(zipRight3(take6(left3).pipe(flatMap11(identity))));
      const pullRight = offer5(latchR, undefined).pipe(zipRight3(take6(right3).pipe(flatMap11(identity))));
      return toChannel2(unfoldEffect(s, (s2) => flatMap11(f(s2, pullLeft, pullRight), unsome)));
    }))));
  });
  var combineChunks = /* @__PURE__ */ dual(4, (self2, that, s, f) => {
    const producer = (handoff, latch) => zipRight4(fromEffect4(take6(latch)), readWithCause({
      onInput: (input) => flatMap13(fromEffect4(pipe(handoff, offer5(chunk2(input)))), () => producer(handoff, latch)),
      onFailure: (cause3) => fromEffect4(offer5(handoff, failCause11(cause3))),
      onDone: () => fromEffect4(offer5(handoff, end4))
    }));
    return new StreamImpl(unwrapScopedWith((scope5) => all4([make50(), make50(), make50(), make50()]).pipe(tap3(([left3, _, latchL]) => pipeTo(toChannel2(self2), producer(left3, latchL)).pipe(runIn(scope5), forkIn2(scope5))), tap3(([_, right3, __, latchR]) => pipeTo(toChannel2(that), producer(right3, latchR)).pipe(runIn(scope5), forkIn2(scope5))), map16(([left3, right3, latchL, latchR]) => {
      const pullLeft = offer5(latchL, undefined).pipe(zipRight3(take6(left3).pipe(flatMap11(done10))));
      const pullRight = offer5(latchR, undefined).pipe(zipRight3(take6(right3).pipe(flatMap11(done10))));
      return toChannel2(unfoldChunkEffect(s, (s2) => flatMap11(f(s2, pullLeft, pullRight), unsome)));
    }))));
  });
  var concat2 = /* @__PURE__ */ dual(2, (self2, that) => new StreamImpl(pipe(toChannel2(self2), zipRight4(toChannel2(that)))));
  var concatAll2 = (streams) => suspend9(() => pipe(streams, reduce2(empty31, (x, y) => concat2(y)(x))));
  var cross = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, a2) => [a, a2])));
  var crossLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, _) => a)));
  var crossRight = /* @__PURE__ */ dual(2, (left3, right3) => flatMap16(left3, () => right3));
  var crossWith = /* @__PURE__ */ dual(3, (left3, right3, f) => pipe(left3, flatMap16((a) => pipe(right3, map21((b) => f(a, b))))));
  var debounce = /* @__PURE__ */ dual(2, (self2, duration2) => unwrapScopedWith3((scope5) => gen2(function* () {
    const handoff = yield* make50();
    function enqueue(last4) {
      return sleep2(duration2).pipe(as3(last4), forkIn2(scope5), map16((fiber) => consumer(previous(fiber))));
    }
    const producer = readWithCause({
      onInput: (input) => match2(last2(input), {
        onNone: () => producer,
        onSome: (elem) => fromEffect4(offer5(handoff, emit(of2(elem)))).pipe(flatMap13(() => producer))
      }),
      onFailure: (cause3) => fromEffect4(offer5(handoff, halt(cause3))),
      onDone: () => fromEffect4(offer5(handoff, end3(UpstreamEnd)))
    });
    function consumer(state) {
      switch (state._tag) {
        case OP_NOT_STARTED: {
          return unwrap(take6(handoff).pipe(map16((signal) => {
            switch (signal._tag) {
              case OP_EMIT4: {
                return unwrap(enqueue(signal.elements));
              }
              case OP_HALT: {
                return failCause10(signal.cause);
              }
              case OP_END: {
                return void_5;
              }
            }
          })));
        }
        case OP_PREVIOUS: {
          return unwrap(take6(handoff).pipe(forkIn2(scope5), flatMap11((handoffFiber) => raceWith2(join3(state.fiber), join3(handoffFiber), {
            onSelfDone: (leftExit, current2) => match6(leftExit, {
              onFailure: (cause3) => interrupt6(current2).pipe(as3(failCause10(cause3))),
              onSuccess: (chunk3) => interrupt6(current2).pipe(zipRight3(succeed8(write(chunk3).pipe(flatMap13(() => consumer(current(handoffFiber)))))))
            }),
            onOtherDone: (rightExit, previous2) => match6(rightExit, {
              onFailure: (cause3) => interrupt6(previous2).pipe(as3(failCause10(cause3))),
              onSuccess: (signal) => {
                switch (signal._tag) {
                  case OP_EMIT4: {
                    return interrupt6(previous2).pipe(zipRight3(enqueue(signal.elements)));
                  }
                  case OP_HALT: {
                    return interrupt6(previous2).pipe(as3(failCause10(signal.cause)));
                  }
                  case OP_END: {
                    return join3(previous2).pipe(map16((chunk3) => write(chunk3).pipe(zipRight4(void_5))));
                  }
                }
              }
            })
          }))));
        }
        case OP_CURRENT: {
          return unwrap(join3(state.fiber).pipe(map16((signal) => {
            switch (signal._tag) {
              case OP_EMIT4: {
                return unwrap(enqueue(signal.elements));
              }
              case OP_HALT: {
                return failCause10(signal.cause);
              }
              case OP_END: {
                return void_5;
              }
            }
          })));
        }
      }
    }
    return scopedWith4((scope6) => pipeTo(toChannel2(self2), producer).pipe(runIn(scope6), forkIn2(scope6))).pipe(crossRight(new StreamImpl(consumer(notStarted))));
  })));
  var die10 = (defect) => fromEffect7(die6(defect));
  var dieSync6 = (evaluate2) => fromEffect7(dieSync3(evaluate2));
  var dieMessage4 = (message) => fromEffect7(dieMessage2(message));
  var distributedWith = /* @__PURE__ */ dual(2, (self2, options) => pipe(make19(), flatMap11((deferred) => pipe(self2, distributedWithDynamic({
    maximumLag: options.maximumLag,
    decide: (a) => flatMap11(_await(deferred), (f) => f(a))
  }), flatMap11((next) => pipe(all4(map4(range(0, options.size - 1), (id2) => map16(next, ([key, queue]) => [[key, id2], queue]))), map16(unsafeFromArray), flatMap11((entries2) => {
    const [mappings, queues] = reduceRight2(entries2, [new Map, empty5()], ([mappings2, queues2], [mapping, queue]) => [mappings2.set(mapping[0], mapping[1]), pipe(queues2, prepend2(queue))]);
    return pipe(succeed2(deferred, (a) => map16(options.decide(a), (f) => (key) => f(mappings.get(key)))), as3(Array.from(queues)));
  })))))));
  var distributedWithDynamicId = {
    ref: 0
  };
  var newDistributedWithDynamicId = () => {
    const current2 = distributedWithDynamicId.ref;
    distributedWithDynamicId.ref = current2 + 1;
    return current2;
  };
  var distributedWithDynamic = /* @__PURE__ */ dual(2, (self2, options) => distributedWithDynamicCallback(self2, options.maximumLag, options.decide, () => _void));
  var distributedWithDynamicCallback = /* @__PURE__ */ dual(4, (self2, maximumLag, decide, done11) => pipe(acquireRelease2(make29(new Map), (ref, _) => pipe(get12(ref), flatMap11((queues) => pipe(queues.values(), forEach6(shutdown4))))), flatMap11((queuesRef) => gen2(function* () {
    const offer6 = (a) => pipe(decide(a), flatMap11((shouldProcess) => pipe(get12(queuesRef), flatMap11((queues) => pipe(queues.entries(), reduce10(empty5(), (acc, [id2, queue]) => {
      if (shouldProcess(id2)) {
        return pipe(offer3(queue, succeed3(a)), matchCauseEffect3({
          onFailure: (cause3) => isInterrupted2(cause3) ? succeed8(pipe(acc, prepend2(id2))) : failCause8(cause3),
          onSuccess: () => succeed8(acc)
        }));
      }
      return succeed8(acc);
    }), flatMap11((ids3) => {
      if (isNonEmpty2(ids3)) {
        return update3(queuesRef, (map21) => {
          for (const id2 of ids3) {
            map21.delete(id2);
          }
          return map21;
        });
      }
      return _void;
    }))))), asVoid3);
    const queuesLock = yield* makeSemaphore2(1);
    const newQueue = yield* make29(pipe(bounded5(maximumLag), flatMap11((queue) => {
      const id2 = newDistributedWithDynamicId();
      return pipe(update3(queuesRef, (map21) => map21.set(id2, queue)), as3([id2, queue]));
    })));
    const finalize = (endTake) => queuesLock.withPermits(1)(pipe(set6(newQueue, pipe(bounded5(1), tap3((queue) => offer3(queue, endTake)), flatMap11((queue) => {
      const id2 = newDistributedWithDynamicId();
      return pipe(update3(queuesRef, (map21) => map21.set(id2, queue)), as3(make3(id2, queue)));
    }))), zipRight3(pipe(get12(queuesRef), flatMap11((map21) => pipe(fromIterable2(map21.values()), forEach6((queue) => pipe(offer3(queue, endTake), catchSomeCause2((cause3) => isInterrupted2(cause3) ? some2(_void) : none2()))))))), zipRight3(done11(endTake)), asVoid3));
    yield* pipe(self2, runForEachScoped(offer6), matchCauseEffect3({
      onFailure: (cause3) => finalize(failCause3(pipe(cause3, map12(some2)))),
      onSuccess: () => finalize(fail4(none2()))
    }), forkScoped2);
    return queuesLock.withPermits(1)(flatten9(get12(newQueue)));
  }))));
  var drain3 = (self2) => new StreamImpl(drain(toChannel2(self2)));
  var drainFork = /* @__PURE__ */ dual(2, (self2, that) => fromEffect7(make19()).pipe(flatMap16((backgroundDied) => scopedWith4((scope5) => toChannel2(that).pipe(drain, runIn(scope5), catchAllCause3((cause3) => failCause2(backgroundDied, cause3)), forkIn2(scope5))).pipe(crossRight(interruptWhenDeferred2(self2, backgroundDied))))));
  var drop3 = /* @__PURE__ */ dual(2, (self2, n) => {
    const loop3 = (r) => readWith({
      onInput: (input) => {
        const dropped = pipe(input, drop2(r));
        const leftover = Math.max(0, r - input.length);
        const more = isEmpty(input) || leftover > 0;
        if (more) {
          return loop3(leftover);
        }
        return pipe(write(dropped), zipRight4(identityChannel()));
      },
      onFailure: fail11,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3(n))));
  });
  var dropRight = /* @__PURE__ */ dual(2, (self2, n) => {
    if (n <= 0) {
      return identityStream();
    }
    return suspend9(() => {
      const queue = new RingBuffer(n);
      const reader = readWith({
        onInput: (input) => {
          const outputs = pipe(input, filterMap3((elem) => {
            const head6 = queue.head();
            queue.put(elem);
            return head6;
          }));
          return pipe(write(outputs), flatMap13(() => reader));
        },
        onFailure: fail11,
        onDone: () => void_5
      });
      return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(reader)));
    });
  });
  var dropUntil3 = /* @__PURE__ */ dual(2, (self2, predicate) => drop3(dropWhile4(self2, (a) => !predicate(a)), 1));
  var dropUntilEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
    const loop3 = readWith({
      onInput: (input) => pipe(dropUntil2(input, predicate), map16(unsafeFromArray), map16((leftover) => {
        const more = isEmpty(leftover);
        if (more) {
          return suspend5(() => loop3);
        }
        return pipe(write(leftover), zipRight4(identityChannel()));
      }), unwrap),
      onFailure: fail11,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
  });
  var dropWhile4 = /* @__PURE__ */ dual(2, (self2, predicate) => {
    const loop3 = readWith({
      onInput: (input) => {
        const output = dropWhile(input, predicate);
        if (isEmpty(output)) {
          return suspend5(() => loop3);
        }
        return zipRight4(write(output), identityChannel());
      },
      onFailure: fail11,
      onDone: succeedNow
    });
    return new StreamImpl(pipeToOrFail(toChannel2(self2), loop3));
  });
  var dropWhileEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
    const loop3 = readWith({
      onInput: (input) => pipe(dropWhile3(input, predicate), map16(unsafeFromArray), map16((leftover) => {
        const more = isEmpty(leftover);
        if (more) {
          return suspend5(() => loop3);
        }
        return zipRight4(write(leftover), identityChannel());
      }), unwrap),
      onFailure: fail11,
      onDone: () => void_5
    });
    return new StreamImpl(pipeToOrFail(toChannel2(self2), loop3));
  });
  var either5 = (self2) => pipe(self2, map21(right2), catchAll7((error) => make51(left2(error))));
  var empty31 = /* @__PURE__ */ new StreamImpl(void_5);
  var ensuring6 = /* @__PURE__ */ dual(2, (self2, finalizer) => new StreamImpl(pipe(toChannel2(self2), ensuring3(finalizer))));
  var ensuringWith2 = /* @__PURE__ */ dual(2, (self2, finalizer) => new StreamImpl(ensuringWith(toChannel2(self2), finalizer)));
  var context5 = () => fromEffect7(context3());
  var contextWith3 = (f) => pipe(context5(), map21(f));
  var contextWithEffect3 = (f) => pipe(context5(), mapEffectSequential(f));
  var contextWithStream = (f) => pipe(context5(), flatMap16(f));
  var execute = (effect4) => drain3(fromEffect7(effect4));
  var fail15 = (error) => fromEffectOption(fail9(some2(error)));
  var failSync7 = (evaluate2) => fromEffectOption(failSync3(() => some2(evaluate2())));
  var failCause13 = (cause3) => fromEffect7(failCause8(cause3));
  var failCauseSync6 = (evaluate2) => fromEffect7(failCauseSync3(evaluate2));
  var filter9 = /* @__PURE__ */ dual(2, (self2, predicate) => mapChunks(self2, filter3(predicate)));
  var filterEffect = /* @__PURE__ */ dual(2, (self2, f) => {
    const loop3 = (iterator) => {
      const next = iterator.next();
      if (next.done) {
        return readWithCause({
          onInput: (input) => loop3(input[Symbol.iterator]()),
          onFailure: failCause10,
          onDone: succeed10
        });
      } else {
        return pipe(f(next.value), map16((bool) => bool ? pipe(write(of2(next.value)), flatMap13(() => loop3(iterator))) : loop3(iterator)), unwrap);
      }
    };
    return new StreamImpl(suspend5(() => pipe(toChannel2(self2), pipeTo(loop3(empty5()[Symbol.iterator]())))));
  });
  var filterMap7 = /* @__PURE__ */ dual(2, (self2, pf) => mapChunks(self2, filterMap3(pf)));
  var filterMapEffect = /* @__PURE__ */ dual(2, (self2, pf) => suspend9(() => {
    const loop3 = (iterator) => {
      const next = iterator.next();
      if (next.done) {
        return readWithCause({
          onInput: (input) => loop3(input[Symbol.iterator]()),
          onFailure: failCause10,
          onDone: succeed10
        });
      } else {
        return pipe(pf(next.value), match2({
          onNone: () => sync3(() => loop3(iterator)),
          onSome: map16((a2) => flatMap13(write(of2(a2)), () => loop3(iterator)))
        }), unwrap);
      }
    };
    return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3(empty5()[Symbol.iterator]()))));
  }));
  var filterMapWhile3 = /* @__PURE__ */ dual(2, (self2, pf) => {
    const loop3 = readWith({
      onInput: (input) => {
        const mapped = filterMapWhile2(input, pf);
        if (mapped.length === input.length) {
          return pipe(write(mapped), flatMap13(() => loop3));
        }
        return write(mapped);
      },
      onFailure: fail11,
      onDone: succeed10
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
  });
  var filterMapWhileEffect = /* @__PURE__ */ dual(2, (self2, pf) => suspend9(() => {
    const loop3 = (iterator) => {
      const next = iterator.next();
      if (next.done) {
        return readWithCause({
          onInput: (input) => loop3(input[Symbol.iterator]()),
          onFailure: failCause10,
          onDone: succeed10
        });
      } else {
        return unwrap(match2(pf(next.value), {
          onNone: () => succeed8(void_5),
          onSome: map16((a2) => flatMap13(write(of2(a2)), () => loop3(iterator)))
        }));
      }
    };
    return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3(empty5()[Symbol.iterator]()))));
  }));
  var finalizer = (finalizer2) => acquireRelease3(_void, () => finalizer2);
  var find2 = /* @__PURE__ */ dual(2, (self2, predicate) => {
    const loop3 = readWith({
      onInput: (input) => match2(findFirst3(input, predicate), {
        onNone: () => loop3,
        onSome: (n) => write(of2(n))
      }),
      onFailure: fail11,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3)));
  });
  var findEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
    const loop3 = readWith({
      onInput: (input) => pipe(findFirst6(input, predicate), map16(match2({
        onNone: () => loop3,
        onSome: (n) => write(of2(n))
      })), unwrap),
      onFailure: fail11,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3)));
  });
  var flatMap16 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, f, options) => {
    const bufferSize = options?.bufferSize ?? 16;
    if (options?.switch) {
      return matchConcurrency(options?.concurrency, () => flatMapParSwitchBuffer(self2, 1, bufferSize, f), (n) => flatMapParSwitchBuffer(self2, n, bufferSize, f));
    }
    return matchConcurrency(options?.concurrency, () => new StreamImpl(concatMap(toChannel2(self2), (as8) => pipe(as8, map4((a) => toChannel2(f(a))), reduce2(void_5, (left3, right3) => pipe(left3, zipRight4(right3)))))), (_) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), options))));
  });
  var matchConcurrency = (concurrency, sequential5, bounded8) => {
    switch (concurrency) {
      case undefined:
        return sequential5();
      case "unbounded":
        return bounded8(Number.MAX_SAFE_INTEGER);
      default:
        return concurrency > 1 ? bounded8(concurrency) : sequential5();
    }
  };
  var flatMapParSwitchBuffer = /* @__PURE__ */ dual(4, (self2, n, bufferSize, f) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), {
    concurrency: n,
    mergeStrategy: BufferSliding(),
    bufferSize
  }))));
  var flatten13 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => flatMap16(self2, identity, options));
  var flattenChunks = (self2) => {
    const flatten14 = readWithCause({
      onInput: (chunks2) => flatMap13(writeChunk(chunks2), () => flatten14),
      onFailure: failCause10,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeTo(flatten14)));
  };
  var flattenEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => options?.unordered ? flatMap16(self2, (a) => fromEffect7(a), {
    concurrency: options.concurrency
  }) : matchConcurrency(options?.concurrency, () => mapEffectSequential(self2, identity), (n) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mapOutEffectPar(identity, n), mapOut(of2)))));
  var flattenExitOption = (self2) => {
    const processChunk = (chunk3, cont) => {
      const [toEmit, rest] = pipe(chunk3, splitWhere((exit3) => !isSuccess(exit3)));
      const next = pipe(head2(rest), match2({
        onNone: () => cont,
        onSome: match6({
          onFailure: (cause3) => match2(flipCauseOption2(cause3), {
            onNone: () => void_5,
            onSome: failCause10
          }),
          onSuccess: () => void_5
        })
      }));
      return pipe(write(pipe(toEmit, filterMap3((exit3) => isSuccess(exit3) ? some2(exit3.value) : none2()))), flatMap13(() => next));
    };
    const process2 = readWithCause({
      onInput: (chunk3) => processChunk(chunk3, process2),
      onFailure: (cause3) => failCause10(cause3),
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeTo(process2)));
  };
  var flattenIterables = (self2) => pipe(self2, map21(fromIterable2), flattenChunks);
  var flattenTake = (self2) => flattenChunks(flattenExitOption(pipe(self2, map21((take7) => take7.exit))));
  var forever5 = (self2) => new StreamImpl(repeated(toChannel2(self2)));
  var fromAsyncIterable = (iterable, onError3) => pipe(acquireRelease2(sync3(() => iterable[Symbol.asyncIterator]()), (iterator) => iterator.return ? promise2(async () => iterator.return()) : _void), map16((iterator) => repeatEffectOption(pipe(tryPromise2({
    try: async () => iterator.next(),
    catch: (reason) => some2(onError3(reason))
  }), flatMap11((result) => result.done ? fail9(none2()) : succeed8(result.value))))), unwrapScoped5);
  var fromChannel2 = (channel) => new StreamImpl(channel);
  var toChannel2 = (stream) => {
    if ("channel" in stream) {
      return stream.channel;
    } else if (isEffect2(stream)) {
      return toChannel2(fromEffect7(stream));
    } else {
      throw new TypeError(`Expected a Stream.`);
    }
  };
  var fromChunk = (chunk3) => new StreamImpl(isEmpty(chunk3) ? void_5 : write(chunk3));
  var fromChunkPubSub = (pubsub, options) => {
    if (options?.scoped) {
      const effect4 = map16(subscribe2(pubsub), fromChunkQueue);
      return options.shutdown ? map16(effect4, ensuring6(shutdown3(pubsub))) : effect4;
    }
    const stream = flatMap16(scoped5(subscribe2(pubsub)), fromChunkQueue);
    return options?.shutdown ? ensuring6(stream, shutdown3(pubsub)) : stream;
  };
  var fromChunkQueue = (queue, options) => pipe(take3(queue), catchAllCause3((cause3) => pipe(isShutdown3(queue), flatMap11((isShutdown7) => isShutdown7 && isInterrupted2(cause3) ? end5() : failCause12(cause3)))), repeatEffectChunkOption, options?.shutdown ? ensuring6(shutdown4(queue)) : identity);
  var fromChunks = (...chunks2) => pipe(fromIterable9(chunks2), flatMap16(fromChunk));
  var fromEffect7 = (effect4) => pipe(effect4, mapError3(some2), fromEffectOption);
  var fromEffectOption = (effect4) => new StreamImpl(unwrap(match12(effect4, {
    onFailure: match2({
      onNone: () => void_5,
      onSome: fail11
    }),
    onSuccess: (a) => write(of2(a))
  })));
  var fromPubSub = (pubsub, options) => {
    const maxChunkSize = options?.maxChunkSize ?? DefaultChunkSize;
    if (options?.scoped) {
      const effect4 = map16(subscribe2(pubsub), (queue) => fromQueue2(queue, {
        maxChunkSize,
        shutdown: true
      }));
      return options.shutdown ? map16(effect4, ensuring6(shutdown3(pubsub))) : effect4;
    }
    const stream = flatMap16(scoped5(subscribe2(pubsub)), (queue) => fromQueue2(queue, {
      maxChunkSize
    }));
    return options?.shutdown ? ensuring6(stream, shutdown3(pubsub)) : stream;
  };
  var fromTPubSub = (pubsub) => {
    return unwrapScoped5(map16(subscribeScoped2(pubsub), (queue) => fromTQueue(queue)));
  };
  var fromIterable9 = (iterable) => suspend9(() => isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]()));
  var fromIterableEffect = (effect4) => pipe(effect4, map16(fromIterable9), unwrap2);
  var fromIteratorSucceed = (iterator, maxChunkSize = DefaultChunkSize) => {
    return pipe(sync3(() => {
      let builder = [];
      const loop3 = (iterator2) => pipe(sync3(() => {
        let next = iterator2.next();
        if (maxChunkSize === 1) {
          if (next.done) {
            return void_5;
          }
          return pipe(write(of2(next.value)), flatMap13(() => loop3(iterator2)));
        }
        builder = [];
        let count3 = 0;
        while (next.done === false) {
          builder.push(next.value);
          count3 = count3 + 1;
          if (count3 >= maxChunkSize) {
            break;
          }
          next = iterator2.next();
        }
        if (count3 > 0) {
          return pipe(write(unsafeFromArray(builder)), flatMap13(() => loop3(iterator2)));
        }
        return void_5;
      }), unwrap);
      return new StreamImpl(loop3(iterator));
    }), unwrap2);
  };
  var fromPull2 = (effect4) => pipe(effect4, map16(repeatEffectChunkOption), unwrapScoped5);
  var fromQueue2 = (queue, options) => pipe(takeBetween2(queue, 1, options?.maxChunkSize ?? DefaultChunkSize), catchAllCause3((cause3) => pipe(isShutdown3(queue), flatMap11((isShutdown7) => isShutdown7 && isInterrupted2(cause3) ? end5() : failCause12(cause3)))), repeatEffectChunkOption, options?.shutdown ? ensuring6(shutdown4(queue)) : identity);
  var fromTQueue = (queue) => pipe(take5(queue), map16(of2), catchAllCause3((cause3) => pipe(isShutdown6(queue), flatMap11((isShutdown7) => isShutdown7 && isInterrupted2(cause3) ? end5() : failCause12(cause3)))), repeatEffectChunkOption);
  var fromSchedule = (schedule2) => pipe(driver2(schedule2), map16((driver3) => repeatEffectOption(driver3.next(undefined))), unwrap2);
  var fromReadableStream = (...args2) => {
    const evaluate2 = args2.length === 1 ? args2[0].evaluate : args2[0];
    const onError3 = args2.length === 1 ? args2[0].onError : args2[1];
    const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
    return unwrapScoped5(map16(acquireRelease2(sync3(() => evaluate2().getReader()), (reader) => releaseLockOnEnd ? sync3(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => repeatEffectOption(flatMap11(tryPromise2({
      try: () => reader.read(),
      catch: (reason) => some2(onError3(reason))
    }), ({
      done: done11,
      value
    }) => done11 ? fail9(none2()) : succeed8(value)))));
  };
  var fromReadableStreamByob = (...args2) => {
    const evaluate2 = args2.length === 1 ? args2[0].evaluate : args2[0];
    const onError3 = args2.length === 1 ? args2[0].onError : args2[1];
    const allocSize = (args2.length === 1 ? args2[0].bufferSize : args2[2]) ?? 4096;
    const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
    return unwrapScoped5(map16(acquireRelease2(sync3(() => evaluate2().getReader({
      mode: "byob"
    })), (reader) => releaseLockOnEnd ? sync3(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => catchAll7(forever5(readChunkStreamByobReader(reader, onError3, allocSize)), (error) => error === EOF ? empty31 : fail15(error))));
  };
  var EOF = /* @__PURE__ */ Symbol.for("effect/Stream/EOF");
  var readChunkStreamByobReader = (reader, onError3, size13) => {
    const buffer2 = new ArrayBuffer(size13);
    return paginateEffect(0, (offset) => flatMap11(tryPromise2({
      try: () => reader.read(new Uint8Array(buffer2, offset, buffer2.byteLength - offset)),
      catch: (reason) => onError3(reason)
    }), ({
      done: done11,
      value
    }) => {
      if (done11) {
        return fail9(EOF);
      }
      const newOffset = offset + value.byteLength;
      return succeed8([value, newOffset >= buffer2.byteLength ? none2() : some2(newOffset)]);
    }));
  };
  var groupAdjacentBy = /* @__PURE__ */ dual(2, (self2, f) => {
    const groupAdjacentByChunk = (state, chunk3) => {
      if (isEmpty(chunk3)) {
        return [state, empty5()];
      }
      const builder = [];
      let from = 0;
      let until = 0;
      let key = undefined;
      let previousChunk = empty5();
      switch (state._tag) {
        case "Some": {
          const tuple = state.value;
          key = tuple[0];
          let loop3 = true;
          while (loop3 && until < chunk3.length) {
            const input = unsafeGet4(chunk3, until);
            const updatedKey = f(input);
            if (!equals(key, updatedKey)) {
              const previousChunk2 = tuple[1];
              const additionalChunk = unsafeFromArray(Array.from(chunk3).slice(from, until));
              const group = appendAll2(previousChunk2, additionalChunk);
              builder.push([key, group]);
              key = updatedKey;
              from = until;
              loop3 = false;
            }
            until = until + 1;
          }
          if (loop3) {
            previousChunk = tuple[1];
          }
          break;
        }
        case "None": {
          key = f(unsafeGet4(chunk3, until));
          until = until + 1;
          break;
        }
      }
      while (until < chunk3.length) {
        const input = unsafeGet4(chunk3, until);
        const updatedKey = f(input);
        if (!equals(key, updatedKey)) {
          builder.push([key, unsafeFromArray(Array.from(chunk3).slice(from, until))]);
          key = updatedKey;
          from = until;
        }
        until = until + 1;
      }
      const nonEmptyChunk = appendAll2(previousChunk, unsafeFromArray(Array.from(chunk3).slice(from, until)));
      const output = unsafeFromArray(builder);
      return [some2([key, nonEmptyChunk]), output];
    };
    const groupAdjacent = (state) => readWithCause({
      onInput: (input) => {
        const [updatedState, output] = groupAdjacentByChunk(state, input);
        return isEmpty(output) ? groupAdjacent(updatedState) : flatMap13(write(output), () => groupAdjacent(updatedState));
      },
      onFailure: (cause3) => match2(state, {
        onNone: () => failCause10(cause3),
        onSome: (output) => flatMap13(write(of2(output)), () => failCause10(cause3))
      }),
      onDone: (done11) => match2(state, {
        onNone: () => succeedNow(done11),
        onSome: (output) => flatMap13(write(of2(output)), () => succeedNow(done11))
      })
    });
    return new StreamImpl(pipeToOrFail(toChannel2(self2), groupAdjacent(none2())));
  });
  var grouped = /* @__PURE__ */ dual(2, (self2, chunkSize) => pipe(self2, rechunk(chunkSize), chunks));
  var groupedWithin = /* @__PURE__ */ dual(3, (self2, chunkSize, duration2) => aggregateWithin(self2, collectAllN(chunkSize), spaced2(duration2)));
  var haltWhen = /* @__PURE__ */ dual(2, (self2, effect4) => {
    const writer = (fiber) => pipe(poll4(fiber), map16(match2({
      onNone: () => readWith({
        onInput: (input) => flatMap13(write(input), () => writer(fiber)),
        onFailure: fail11,
        onDone: () => void_5
      }),
      onSome: match6({
        onFailure: failCause10,
        onSuccess: () => void_5
      })
    })), unwrap);
    return new StreamImpl(unwrapScopedWith((scope5) => effect4.pipe(forkIn2(scope5), map16((fiber) => toChannel2(self2).pipe(pipeTo(writer(fiber)))))));
  });
  var haltAfter = /* @__PURE__ */ dual(2, (self2, duration2) => pipe(self2, haltWhen(sleep2(duration2))));
  var haltWhenDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => {
    const writer = pipe(poll(deferred), map16(match2({
      onNone: () => readWith({
        onInput: (input) => pipe(write(input), flatMap13(() => writer)),
        onFailure: fail11,
        onDone: () => void_5
      }),
      onSome: (effect4) => unwrap(match12(effect4, {
        onFailure: fail11,
        onSuccess: () => void_5
      }))
    })), unwrap);
    return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer)));
  });
  var identityStream = () => new StreamImpl(identityChannel());
  var interleave = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, interleaveWith(that, forever5(make51(true, false)))));
  var interleaveWith = /* @__PURE__ */ dual(3, (self2, that, decider) => {
    const producer = (handoff) => readWithCause({
      onInput: (value) => flatMap13(fromEffect4(offer5(handoff, of5(value))), () => producer(handoff)),
      onFailure: (cause3) => fromEffect4(offer5(handoff, failCause11(cause3))),
      onDone: () => fromEffect4(offer5(handoff, end4))
    });
    return new StreamImpl(unwrapScopedWith((scope5) => pipe(make50(), zip5(make50()), tap3(([left3]) => toChannel2(self2).pipe(concatMap(writeChunk), pipeTo(producer(left3)), runIn(scope5), forkIn2(scope5))), tap3(([_, right3]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3)), runIn(scope5), forkIn2(scope5))), map16(([left3, right3]) => {
      const process2 = (leftDone, rightDone) => readWithCause({
        onInput: (bool) => {
          if (bool && !leftDone) {
            return pipe(fromEffect4(take6(left3)), flatMap13(match17({
              onEnd: () => rightDone ? void_5 : process2(true, rightDone),
              onFailure: failCause10,
              onSuccess: (chunk3) => pipe(write(chunk3), flatMap13(() => process2(leftDone, rightDone)))
            })));
          }
          if (!bool && !rightDone) {
            return pipe(fromEffect4(take6(right3)), flatMap13(match17({
              onEnd: () => leftDone ? void_5 : process2(leftDone, true),
              onFailure: failCause10,
              onSuccess: (chunk3) => pipe(write(chunk3), flatMap13(() => process2(leftDone, rightDone)))
            })));
          }
          return process2(leftDone, rightDone);
        },
        onFailure: failCause10,
        onDone: () => void_5
      });
      return pipe(toChannel2(decider), concatMap(writeChunk), pipeTo(process2(false, false)));
    }))));
  });
  var intersperse = /* @__PURE__ */ dual(2, (self2, element) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(suspend5(() => {
    const writer = (isFirst) => readWithCause({
      onInput: (chunk3) => {
        const builder = [];
        let flagResult = isFirst;
        for (const output of chunk3) {
          if (flagResult) {
            flagResult = false;
            builder.push(output);
          } else {
            builder.push(element);
            builder.push(output);
          }
        }
        return pipe(write(unsafeFromArray(builder)), flatMap13(() => writer(flagResult)));
      },
      onFailure: failCause10,
      onDone: () => void_5
    });
    return writer(true);
  })))));
  var intersperseAffixes = /* @__PURE__ */ dual(2, (self2, {
    end: end6,
    middle,
    start: start3
  }) => pipe(make51(start3), concat2(pipe(self2, intersperse(middle))), concat2(make51(end6))));
  var interruptAfter = /* @__PURE__ */ dual(2, (self2, duration2) => pipe(self2, interruptWhen2(sleep2(duration2))));
  var interruptWhen2 = /* @__PURE__ */ dual(2, (self2, effect4) => new StreamImpl(pipe(toChannel2(self2), interruptWhen(effect4))));
  var interruptWhenDeferred2 = /* @__PURE__ */ dual(2, (self2, deferred) => new StreamImpl(pipe(toChannel2(self2), interruptWhenDeferred(deferred))));
  var iterate3 = (value, next) => unfold3(value, (a) => some2([a, next(a)]));
  var make51 = (...as8) => fromIterable9(as8);
  var map21 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapOut(map4(f)))));
  var mapAccum5 = /* @__PURE__ */ dual(3, (self2, s, f) => {
    const accumulator = (s2) => readWith({
      onInput: (input) => {
        const [nextS, chunk3] = mapAccum2(input, s2, f);
        return flatMap13(write(chunk3), () => accumulator(nextS));
      },
      onFailure: fail11,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeTo(accumulator(s))));
  });
  var mapAccumEffect = /* @__PURE__ */ dual(3, (self2, s, f) => suspend9(() => {
    const accumulator = (s2) => readWith({
      onInput: (input) => pipe(suspend3(() => {
        const outputs = [];
        const emit2 = (output) => sync3(() => {
          outputs.push(output);
        });
        return pipe(input, reduce10(s2, (s3, a) => pipe(f(s3, a), flatMap11(([s4, a2]) => pipe(emit2(a2), as3(s4))))), match12({
          onFailure: (error) => {
            if (outputs.length !== 0) {
              return zipRight4(write(unsafeFromArray(outputs)), fail11(error));
            }
            return fail11(error);
          },
          onSuccess: (s3) => flatMap13(write(unsafeFromArray(outputs)), () => accumulator(s3))
        }));
      }), unwrap),
      onFailure: fail11,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(accumulator(s))));
  }));
  var mapBoth6 = /* @__PURE__ */ dual(2, (self2, options) => pipe(self2, mapError6(options.onFailure), map21(options.onSuccess)));
  var mapChunks = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapOut(f))));
  var mapChunksEffect = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapOutEffect(f))));
  var mapConcat = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapConcatChunk((a) => fromIterable2(f(a)))));
  var mapConcatChunk = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapChunks(flatMap3(f))));
  var mapConcatChunkEffect = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapEffectSequential(f), mapConcatChunk(identity)));
  var mapConcatEffect = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapEffectSequential((a) => pipe(f(a), map16(fromIterable2))), mapConcatChunk(identity)));
  var mapEffectSequential = /* @__PURE__ */ dual(2, (self2, f) => {
    const loop3 = (iterator) => {
      const next = iterator.next();
      if (next.done) {
        return readWithCause({
          onInput: (elem) => loop3(elem[Symbol.iterator]()),
          onFailure: failCause10,
          onDone: succeed10
        });
      } else {
        const value = next.value;
        return unwrap(map16(f(value), (a2) => flatMap13(write(of2(a2)), () => loop3(iterator))));
      }
    };
    return new StreamImpl(pipe(toChannel2(self2), pipeTo(suspend5(() => loop3(empty5()[Symbol.iterator]())))));
  });
  var mapEffectPar = /* @__PURE__ */ dual(3, (self2, n, f) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mapOutEffectPar(f, n), mapOut(of2))));
  var mapError6 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapError5(f))));
  var mapErrorCause4 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapErrorCause3(f))));
  var merge9 = /* @__PURE__ */ dual((args2) => isStream(args2[1]), (self2, that, options) => mergeWith3(self2, that, {
    onSelf: identity,
    onOther: identity,
    haltStrategy: options?.haltStrategy
  }));
  var mergeAll8 = /* @__PURE__ */ dual((args2) => (Symbol.iterator in args2[0]), (streams, options) => flatten13(fromIterable9(streams), options));
  var mergeWithTag = /* @__PURE__ */ dual(2, (streams, options) => {
    const keys3 = Object.keys(streams);
    const values3 = keys3.map((key) => streams[key].pipe(map21((value) => ({
      _tag: key,
      value
    }))));
    return mergeAll8(values3, options);
  });
  var mergeEither = /* @__PURE__ */ dual(2, (self2, that) => mergeWith3(self2, that, {
    onSelf: left2,
    onOther: right2
  }));
  var mergeLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, merge9(drain3(right3))));
  var mergeRight = /* @__PURE__ */ dual(2, (left3, right3) => pipe(drain3(left3), merge9(right3)));
  var mergeWith3 = /* @__PURE__ */ dual(3, (self2, other, options) => {
    const strategy = options.haltStrategy ? fromInput2(options.haltStrategy) : Both2;
    const handler = (terminate) => (exit3) => terminate || !isSuccess(exit3) ? Done4(suspend3(() => exit3)) : Await2((exit4) => suspend3(() => exit4));
    return new StreamImpl(mergeWith2(toChannel2(map21(self2, options.onSelf)), {
      other: toChannel2(map21(other, options.onOther)),
      onSelfDone: handler(strategy._tag === "Either" || strategy._tag === "Left"),
      onOtherDone: handler(strategy._tag === "Either" || strategy._tag === "Right")
    }));
  });
  var mkString2 = (self2) => run3(self2, mkString);
  var never4 = /* @__PURE__ */ fromEffect7(never3);
  var onEnd = /* @__PURE__ */ dual(2, (self2, effect4) => concat2(self2, drain3(fromEffect7(effect4))));
  var onError3 = /* @__PURE__ */ dual(2, (self2, cleanup) => pipe(self2, catchAllCause6((cause3) => fromEffect7(pipe(cleanup(cause3), zipRight3(failCause8(cause3)))))));
  var onDone = /* @__PURE__ */ dual(2, (self2, cleanup) => new StreamImpl(pipe(toChannel2(self2), ensuringWith((exit3) => isSuccess(exit3) ? cleanup() : _void))));
  var onStart = /* @__PURE__ */ dual(2, (self2, effect4) => unwrap2(as3(effect4, self2)));
  var orDie5 = (self2) => pipe(self2, orDieWith4(identity));
  var orDieWith4 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), orDieWith3(f))));
  var orElse8 = /* @__PURE__ */ dual(2, (self2, that) => new StreamImpl(pipe(toChannel2(self2), orElse7(() => toChannel2(that())))));
  var orElseEither3 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, map21(left2), orElse8(() => pipe(that(), map21(right2)))));
  var orElseFail3 = /* @__PURE__ */ dual(2, (self2, error) => pipe(self2, orElse8(() => failSync7(error))));
  var orElseIfEmpty = /* @__PURE__ */ dual(2, (self2, element) => pipe(self2, orElseIfEmptyChunk(() => of2(element()))));
  var orElseIfEmptyChunk = /* @__PURE__ */ dual(2, (self2, chunk3) => pipe(self2, orElseIfEmptyStream(() => new StreamImpl(write(chunk3())))));
  var orElseIfEmptyStream = /* @__PURE__ */ dual(2, (self2, stream) => {
    const writer = readWith({
      onInput: (input) => {
        if (isEmpty(input)) {
          return suspend5(() => writer);
        }
        return pipe(write(input), zipRight4(identityChannel()));
      },
      onFailure: fail11,
      onDone: () => suspend5(() => toChannel2(stream()))
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer)));
  });
  var orElseSucceed3 = /* @__PURE__ */ dual(2, (self2, value) => pipe(self2, orElse8(() => sync8(value))));
  var paginate = (s, f) => paginateChunk(s, (s2) => {
    const page = f(s2);
    return [of2(page[0]), page[1]];
  });
  var paginateChunk = (s, f) => {
    const loop3 = (s2) => {
      const page = f(s2);
      return match2(page[1], {
        onNone: () => zipRight4(write(page[0]), void_5),
        onSome: (s3) => flatMap13(write(page[0]), () => loop3(s3))
      });
    };
    return new StreamImpl(suspend5(() => loop3(s)));
  };
  var paginateChunkEffect = (s, f) => {
    const loop3 = (s2) => unwrap(map16(f(s2), ([chunk3, option3]) => match2(option3, {
      onNone: () => zipRight4(write(chunk3), void_5),
      onSome: (s3) => flatMap13(write(chunk3), () => loop3(s3))
    })));
    return new StreamImpl(suspend5(() => loop3(s)));
  };
  var paginateEffect = (s, f) => paginateChunkEffect(s, (s2) => pipe(f(s2), map16(([a, s3]) => [of2(a), s3])));
  var peel = /* @__PURE__ */ dual(2, (self2, sink) => {
    const OP_EMIT5 = "Emit";
    const OP_HALT2 = "Halt";
    const OP_END2 = "End";
    return pipe(make19(), flatMap11((deferred) => pipe(make50(), map16((handoff) => {
      const consumer = foldSink(collectLeftover(sink), {
        onFailure: (error) => zipRight5(fromEffect6(fail3(deferred, error)), fail12(error)),
        onSuccess: ([z, leftovers]) => {
          const loop3 = readWithCause({
            onInput: (elements) => flatMap13(fromEffect4(offer5(handoff, {
              _tag: OP_EMIT5,
              elements
            })), () => loop3),
            onFailure: (cause3) => zipRight4(fromEffect4(offer5(handoff, {
              _tag: OP_HALT2,
              cause: cause3
            })), failCause10(cause3)),
            onDone: (_) => zipRight4(fromEffect4(offer5(handoff, {
              _tag: OP_END2
            })), void_5)
          });
          return fromChannel(pipe(fromEffect4(succeed2(deferred, z)), zipRight4(fromEffect4(pipe(handoff, offer5({
            _tag: OP_EMIT5,
            elements: leftovers
          })))), zipRight4(loop3)));
        }
      });
      const producer = pipe(take6(handoff), map16((signal) => {
        switch (signal._tag) {
          case OP_EMIT5: {
            return pipe(write(signal.elements), flatMap13(() => producer));
          }
          case OP_HALT2: {
            return failCause10(signal.cause);
          }
          case OP_END2: {
            return void_5;
          }
        }
      }), unwrap);
      return pipe(self2, tapErrorCause5((cause3) => failCause2(deferred, cause3)), run3(consumer), forkScoped2, zipRight3(_await(deferred)), map16((z) => [z, new StreamImpl(producer)]));
    }))), flatten9);
  });
  var partition5 = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self2, predicate, options) => partitionEither(self2, (a) => succeed8(predicate(a) ? right2(a) : left2(a)), options));
  var partitionEither = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self2, predicate, options) => pipe(mapEffectSequential(self2, predicate), distributedWith({
    size: 2,
    maximumLag: options?.bufferSize ?? 16,
    decide: match({
      onLeft: () => succeed8((n) => n === 0),
      onRight: () => succeed8((n) => n === 1)
    })
  }), flatMap11(([queue1, queue2]) => succeed8([filterMap7(flattenExitOption(fromQueue2(queue1, {
    shutdown: true
  })), (_) => match(_, {
    onLeft: some2,
    onRight: none2
  })), filterMap7(flattenExitOption(fromQueue2(queue2, {
    shutdown: true
  })), (_) => match(_, {
    onLeft: none2,
    onRight: some2
  }))]))));
  var pipeThrough = /* @__PURE__ */ dual(2, (self2, sink) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(toChannel(sink)))));
  var pipeThroughChannel = /* @__PURE__ */ dual(2, (self2, channel) => new StreamImpl(pipeTo(toChannel2(self2), channel)));
  var pipeThroughChannelOrFail = /* @__PURE__ */ dual(2, (self2, chan) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(chan))));
  var prepend4 = /* @__PURE__ */ dual(2, (self2, values3) => new StreamImpl(zipRight4(write(values3), toChannel2(self2))));
  var provideContext5 = /* @__PURE__ */ dual(2, (self2, context6) => new StreamImpl(pipe(toChannel2(self2), provideContext3(context6))));
  var provideSomeContext2 = /* @__PURE__ */ dual(2, (self2, context6) => mapInputContext5(self2, merge3(context6)));
  var provideLayer = /* @__PURE__ */ dual(2, (self2, layer) => new StreamImpl(unwrapScopedWith((scope5) => buildWithScope2(layer, scope5).pipe(map16((env) => pipe(toChannel2(self2), provideContext3(env)))))));
  var provideService5 = /* @__PURE__ */ dual(3, (self2, tag, resource) => provideServiceEffect3(self2, tag, succeed8(resource)));
  var provideServiceEffect3 = /* @__PURE__ */ dual(3, (self2, tag, effect4) => provideServiceStream(self2, tag, fromEffect7(effect4)));
  var provideServiceStream = /* @__PURE__ */ dual(3, (self2, tag, stream) => contextWithStream((env) => flatMap16(stream, (service3) => pipe(self2, provideContext5(add2(env, tag, service3))))));
  var mapInputContext5 = /* @__PURE__ */ dual(2, (self2, f) => contextWithStream((env) => pipe(self2, provideContext5(f(env)))));
  var provideSomeLayer2 = /* @__PURE__ */ dual(2, (self2, layer) => pipe(self2, provideLayer(pipe(context4(), merge8(layer)))));
  var range2 = (min3, max5, chunkSize = DefaultChunkSize) => suspend9(() => {
    if (min3 > max5) {
      return empty31;
    }
    const go = (min4, max6, chunkSize2) => {
      const remaining = max6 - min4 + 1;
      if (remaining > chunkSize2) {
        return pipe(write(range(min4, min4 + chunkSize2 - 1)), flatMap13(() => go(min4 + chunkSize2, max6, chunkSize2)));
      }
      return write(range(min4, min4 + remaining - 1));
    };
    return new StreamImpl(go(min3, max5, chunkSize));
  });
  var race3 = /* @__PURE__ */ dual(2, (left3, right3) => raceAll3(left3, right3));
  var raceAll3 = (...streams) => make19().pipe(map16((halt2) => {
    let winner = null;
    return mergeAll8(streams.map((stream, index) => stream.pipe(takeWhile4(() => {
      if (winner === null) {
        winner = index;
        unsafeDone(halt2, void_2);
        return true;
      }
      return winner === index;
    }), interruptWhen2(_await(halt2).pipe(flatMap11(() => winner === index ? never3 : _void))))), {
      concurrency: streams.length
    });
  }), unwrap2);
  var rechunk = /* @__PURE__ */ dual(2, (self2, n) => suspend9(() => {
    const target = Math.max(n, 1);
    const process2 = rechunkProcess(new StreamRechunker(target), target);
    return new StreamImpl(pipe(toChannel2(self2), pipeTo(process2)));
  }));
  var rechunkProcess = (rechunker, target) => readWithCause({
    onInput: (chunk3) => {
      if (chunk3.length === target && rechunker.isEmpty()) {
        return flatMap13(write(chunk3), () => rechunkProcess(rechunker, target));
      }
      if (chunk3.length > 0) {
        const chunks2 = [];
        let result = undefined;
        let index = 0;
        while (index < chunk3.length) {
          while (index < chunk3.length && result === undefined) {
            result = rechunker.write(pipe(chunk3, unsafeGet4(index)));
            index = index + 1;
          }
          if (result !== undefined) {
            chunks2.push(result);
            result = undefined;
          }
        }
        return flatMap13(writeAll(...chunks2), () => rechunkProcess(rechunker, target));
      }
      return suspend5(() => rechunkProcess(rechunker, target));
    },
    onFailure: (cause3) => zipRight4(rechunker.emitIfNotEmpty(), failCause10(cause3)),
    onDone: () => rechunker.emitIfNotEmpty()
  });

  class StreamRechunker {
    n;
    builder = [];
    pos = 0;
    constructor(n) {
      this.n = n;
    }
    isEmpty() {
      return this.pos === 0;
    }
    write(elem) {
      this.builder.push(elem);
      this.pos += 1;
      if (this.pos === this.n) {
        const result = unsafeFromArray(this.builder);
        this.builder = [];
        this.pos = 0;
        return result;
      }
      return;
    }
    emitIfNotEmpty() {
      if (this.pos !== 0) {
        return write(unsafeFromArray(this.builder));
      }
      return void_5;
    }
  }
  var refineOrDie = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, refineOrDieWith(pf, identity)));
  var refineOrDieWith = /* @__PURE__ */ dual(3, (self2, pf, f) => new StreamImpl(catchAll5(toChannel2(self2), (error) => match2(pf(error), {
    onNone: () => failCause10(die4(f(error))),
    onSome: fail11
  }))));
  var repeat2 = /* @__PURE__ */ dual(2, (self2, schedule2) => filterMap7(repeatEither(self2, schedule2), (_) => match(_, {
    onLeft: none2,
    onRight: some2
  })));
  var repeatEffect = (effect4) => repeatEffectOption(pipe(effect4, mapError3(some2)));
  var repeatEffectChunk = (effect4) => repeatEffectChunkOption(pipe(effect4, mapError3(some2)));
  var repeatEffectChunkOption = (effect4) => unfoldChunkEffect(effect4, (effect5) => pipe(map16(effect5, (chunk3) => some2([chunk3, effect5])), catchAll3(match2({
    onNone: () => succeed8(none2()),
    onSome: fail9
  }))));
  var repeatEffectOption = (effect4) => repeatEffectChunkOption(pipe(effect4, map16(of2)));
  var repeatEither = /* @__PURE__ */ dual(2, (self2, schedule2) => repeatWith(self2, schedule2, {
    onElement: (a) => right2(a),
    onSchedule: left2
  }));
  var repeatElements = /* @__PURE__ */ dual(2, (self2, schedule2) => filterMap7(repeatElementsWith(self2, schedule2, {
    onElement: (a) => some2(a),
    onSchedule: none2
  }), identity));
  var repeatElementsWith = /* @__PURE__ */ dual(3, (self2, schedule2, options) => {
    const driver3 = pipe(driver2(schedule2), map16((driver4) => {
      const feed = (input) => match2(head2(input), {
        onNone: () => loop3,
        onSome: (a) => zipRight4(write(of2(options.onElement(a))), step4(pipe(input, drop2(1)), a))
      });
      const step4 = (input, a) => {
        const advance = pipe(driver4.next(a), as3(pipe(write(of2(options.onElement(a))), flatMap13(() => step4(input, a)))));
        const reset = pipe(driver4.last, orDie3, flatMap11((b) => pipe(driver4.reset, map16(() => pipe(write(of2(options.onSchedule(b))), zipRight4(feed(input)))))));
        return pipe(advance, orElse5(() => reset), unwrap);
      };
      const loop3 = readWith({
        onInput: feed,
        onFailure: fail11,
        onDone: () => void_5
      });
      return loop3;
    }), unwrap);
    return new StreamImpl(pipe(toChannel2(self2), pipeTo(driver3)));
  });
  var repeatValue = (value) => new StreamImpl(repeated(write(of2(value))));
  var repeatWith = /* @__PURE__ */ dual(3, (self2, schedule2, options) => {
    return pipe(driver2(schedule2), map16((driver3) => {
      const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get12(driver3.iterationMeta));
      const process2 = pipe(self2, provideLastIterationInfo, map21(options.onElement), toChannel2);
      const loop3 = unwrap(match12(driver3.next(undefined), {
        onFailure: () => void_5,
        onSuccess: (output) => flatMap13(process2, () => zipRight4(write(of2(options.onSchedule(output))), loop3))
      }));
      return new StreamImpl(zipRight4(process2, loop3));
    }), unwrap2);
  });
  var repeatWithSchedule = (value, schedule2) => repeatEffectWithSchedule(succeed8(value), schedule2);
  var repeatEffectWithSchedule = (effect4, schedule2) => flatMap16(fromEffect7(zip5(effect4, driver2(schedule2))), ([a, driver3]) => {
    const provideLastIterationInfo = provideServiceEffect2(CurrentIterationMetadata2, get12(driver3.iterationMeta));
    return concat2(succeed14(a), unfoldEffect(a, (s) => matchEffect2(driver3.next(s), {
      onFailure: succeed8,
      onSuccess: () => map16(provideLastIterationInfo(effect4), (nextA) => some2([nextA, nextA]))
    })));
  });
  var retry6 = /* @__PURE__ */ dual(2, (self2, policy) => driver2(policy).pipe(map16((driver3) => {
    const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get12(driver3.iterationMeta));
    const loop3 = toChannel2(provideLastIterationInfo(self2)).pipe(mapOutEffect((out) => as3(driver3.reset, out)), catchAll5((error) => driver3.next(error).pipe(match12({
      onFailure: () => fail11(error),
      onSuccess: () => loop3
    }), unwrap)));
    return loop3;
  }), unwrap, fromChannel2));
  var withExecutionPlan3 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, policy, options) => suspend9(() => {
    const preventFallbackOnPartialStream = options?.preventFallbackOnPartialStream ?? false;
    let i = 0;
    let lastError = none2();
    const loop3 = suspend9(() => {
      const step4 = policy.steps[i++];
      if (!step4) {
        return fail15(getOrThrow2(lastError));
      }
      let nextStream = isContext2(step4.provide) ? provideSomeContext2(self2, step4.provide) : provideSomeLayer2(self2, step4.provide);
      let receivedElements = false;
      if (isSome2(lastError)) {
        const error = lastError.value;
        let attempted = false;
        const wrapped = nextStream;
        nextStream = suspend9(() => {
          if (attempted)
            return wrapped;
          attempted = true;
          return fail15(error);
        });
        nextStream = scheduleDefectRefail2(retry6(nextStream, scheduleFromStep(step4, false)));
      } else {
        const schedule2 = scheduleFromStep(step4, true);
        nextStream = schedule2 ? scheduleDefectRefail2(retry6(nextStream, schedule2)) : nextStream;
      }
      return catchAll7(preventFallbackOnPartialStream ? mapChunks(nextStream, (chunk3) => {
        receivedElements = true;
        return chunk3;
      }) : nextStream, (error) => {
        if (preventFallbackOnPartialStream && receivedElements) {
          return fail15(error);
        }
        lastError = some2(error);
        return loop3;
      });
    });
    return loop3;
  }));
  var scheduleDefectRefail2 = (self2) => catchAllCause6(self2, (cause3) => failCause13(scheduleDefectRefailCause(cause3)));
  var run3 = /* @__PURE__ */ dual(2, (self2, sink) => toChannel2(self2).pipe(pipeToOrFail(toChannel(sink)), runDrain));
  var runCollect = (self2) => run3(self2, collectAll());
  var runCount = (self2) => run3(self2, count);
  var runDrain2 = (self2) => run3(self2, drain2);
  var runFold = /* @__PURE__ */ dual(3, (self2, s, f) => runFoldWhile(self2, s, constTrue, f));
  var runFoldEffect = /* @__PURE__ */ dual(3, (self2, s, f) => runFoldWhileEffect(self2, s, constTrue, f));
  var runFoldScoped = /* @__PURE__ */ dual(3, (self2, s, f) => pipe(self2, runFoldWhileScoped(s, constTrue, f)));
  var runFoldScopedEffect = /* @__PURE__ */ dual(3, (self2, s, f) => pipe(self2, runFoldWhileScopedEffect(s, constTrue, f)));
  var runFoldWhile = /* @__PURE__ */ dual(4, (self2, s, cont, f) => run3(self2, fold(s, cont, f)));
  var runFoldWhileEffect = /* @__PURE__ */ dual(4, (self2, s, cont, f) => run3(self2, foldEffect(s, cont, f)));
  var runFoldWhileScoped = /* @__PURE__ */ dual(4, (self2, s, cont, f) => pipe(self2, runScoped2(fold(s, cont, f))));
  var runFoldWhileScopedEffect = /* @__PURE__ */ dual(4, (self2, s, cont, f) => pipe(self2, runScoped2(foldEffect(s, cont, f))));
  var runForEach = /* @__PURE__ */ dual(2, (self2, f) => run3(self2, forEach7(f)));
  var runForEachChunk = /* @__PURE__ */ dual(2, (self2, f) => run3(self2, forEachChunk(f)));
  var runForEachChunkScoped = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, runScoped2(forEachChunk(f))));
  var runForEachScoped = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, runScoped2(forEach7(f))));
  var runForEachWhile = /* @__PURE__ */ dual(2, (self2, f) => run3(self2, forEachWhile(f)));
  var runForEachWhileScoped = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, runScoped2(forEachWhile(f))));
  var runHead = (self2) => run3(self2, head5());
  var runIntoPubSub = /* @__PURE__ */ dual(2, (self2, pubsub) => pipe(self2, runIntoQueue(pubsub)));
  var runIntoPubSubScoped = /* @__PURE__ */ dual(2, (self2, pubsub) => pipe(self2, runIntoQueueScoped(pubsub)));
  var runIntoQueue = /* @__PURE__ */ dual(2, (self2, queue) => pipe(self2, runIntoQueueScoped(queue), scoped2));
  var runIntoQueueElementsScoped = /* @__PURE__ */ dual(2, (self2, queue) => {
    const writer = readWithCause({
      onInput: (input) => flatMap13(fromEffect4(offerAll3(queue, map4(input, succeed3))), () => writer),
      onFailure: (cause3) => fromEffect4(offer3(queue, failCause3(map12(cause3, some2)))),
      onDone: () => fromEffect4(offer3(queue, fail4(none2())))
    });
    return pipe(pipeTo(toChannel2(self2), writer), drain, runScoped, asVoid3);
  });
  var runIntoQueueScoped = /* @__PURE__ */ dual(2, (self2, queue) => {
    const writer = readWithCause({
      onInput: (input) => flatMap13(write(chunk2(input)), () => writer),
      onFailure: (cause3) => write(failCause11(cause3)),
      onDone: () => write(end4)
    });
    return pipe(pipeTo(toChannel2(self2), writer), mapOutEffect((take7) => offer3(queue, take7)), drain, runScoped, asVoid3);
  });
  var runLast = (self2) => run3(self2, last3());
  var runScoped2 = /* @__PURE__ */ dual(2, (self2, sink) => pipe(toChannel2(self2), pipeToOrFail(toChannel(sink)), drain, runScoped));
  var runSum = (self2) => run3(self2, sum2);
  var scan = /* @__PURE__ */ dual(3, (self2, s, f) => pipe(self2, scanEffect(s, (s2, a) => succeed8(f(s2, a)))));
  var scanReduce = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, scanReduceEffect((a2, a) => succeed8(f(a2, a)))));
  var scanReduceEffect = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapAccumEffect(none2(), (option3, a) => {
    switch (option3._tag) {
      case "None": {
        return succeed8([some2(a), a]);
      }
      case "Some": {
        return pipe(f(option3.value, a), map16((b) => [some2(b), b]));
      }
    }
  })));
  var schedule2 = /* @__PURE__ */ dual(2, (self2, schedule3) => filterMap7(scheduleWith(self2, schedule3, {
    onElement: some2,
    onSchedule: none2
  }), identity));
  var scheduleWith = /* @__PURE__ */ dual(3, (self2, schedule3, options) => {
    const loop3 = (driver3, iterator) => {
      const next = iterator.next();
      if (next.done) {
        return readWithCause({
          onInput: (chunk3) => loop3(driver3, chunk3[Symbol.iterator]()),
          onFailure: failCause10,
          onDone: succeedNow
        });
      }
      return unwrap(matchEffect2(driver3.next(next.value), {
        onFailure: () => pipe(driver3.last, orDie3, map16((b) => pipe(write(make6(options.onElement(next.value), options.onSchedule(b))), flatMap13(() => loop3(driver3, iterator)))), zipLeft2(driver3.reset)),
        onSuccess: () => succeed8(pipe(write(of2(options.onElement(next.value))), flatMap13(() => loop3(driver3, iterator))))
      }));
    };
    return new StreamImpl(pipe(fromEffect4(driver2(schedule3)), flatMap13((driver3) => pipe(toChannel2(self2), pipeTo(loop3(driver3, empty5()[Symbol.iterator]()))))));
  });
  var scanEffect = /* @__PURE__ */ dual(3, (self2, s, f) => new StreamImpl(pipe(write(of2(s)), flatMap13(() => toChannel2(pipe(self2, mapAccumEffect(s, (s2, a) => pipe(f(s2, a), map16((s3) => [s3, s3])))))))));
  var scoped5 = (effect4) => new StreamImpl(ensuring3(scoped4(pipe(effect4, map16(of2))), _void));
  var scopedWith4 = (f) => new StreamImpl(scopedWith3((scope5) => f(scope5).pipe(map16(of2))));
  var some5 = (self2) => pipe(self2, mapError6(some2), someOrFail(() => none2()));
  var someOrElse = /* @__PURE__ */ dual(2, (self2, fallback) => pipe(self2, map21(getOrElse(fallback))));
  var someOrFail = /* @__PURE__ */ dual(2, (self2, error) => mapEffectSequential(self2, match2({
    onNone: () => failSync3(error),
    onSome: succeed8
  })));
  var sliding7 = /* @__PURE__ */ dual(2, (self2, chunkSize) => slidingSize(self2, chunkSize, 1));
  var slidingSize = /* @__PURE__ */ dual(3, (self2, chunkSize, stepSize) => {
    if (chunkSize <= 0 || stepSize <= 0) {
      return die10(new IllegalArgumentException2("Invalid bounds - `chunkSize` and `stepSize` must be greater than zero"));
    }
    return new StreamImpl(suspend5(() => {
      const queue = new RingBuffer(chunkSize);
      const emitOnStreamEnd = (queueSize, channelEnd) => {
        if (queueSize < chunkSize) {
          const items = queue.toChunk();
          const result2 = isEmpty(items) ? empty5() : of2(items);
          return pipe(write(result2), flatMap13(() => channelEnd));
        }
        const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;
        if (lastEmitIndex === queueSize) {
          return channelEnd;
        }
        const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);
        const lastItems = pipe(queue.toChunk(), takeRight(leftovers));
        const result = isEmpty(lastItems) ? empty5() : of2(lastItems);
        return pipe(write(result), flatMap13(() => channelEnd));
      };
      const reader = (queueSize) => readWithCause({
        onInput: (input) => flatMap13(write(filterMap3(input, (element, index) => {
          queue.put(element);
          const currentIndex = queueSize + index + 1;
          if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {
            return none2();
          }
          return some2(queue.toChunk());
        })), () => reader(queueSize + input.length)),
        onFailure: (cause3) => emitOnStreamEnd(queueSize, failCause10(cause3)),
        onDone: () => emitOnStreamEnd(queueSize, void_5)
      });
      return pipe(toChannel2(self2), pipeTo(reader(0)));
    }));
  });
  var split = /* @__PURE__ */ dual(2, (self2, predicate) => {
    const split2 = (leftovers, input) => {
      const [chunk3, remaining] = pipe(leftovers, appendAll2(input), splitWhere(predicate));
      if (isEmpty(chunk3) || isEmpty(remaining)) {
        return loop3(pipe(chunk3, appendAll2(pipe(remaining, drop2(1)))));
      }
      return pipe(write(of2(chunk3)), flatMap13(() => split2(empty5(), pipe(remaining, drop2(1)))));
    };
    const loop3 = (leftovers) => readWith({
      onInput: (input) => split2(leftovers, input),
      onFailure: fail11,
      onDone: () => {
        if (isEmpty(leftovers)) {
          return void_5;
        }
        if (isNone2(pipe(leftovers, findFirst3(predicate)))) {
          return zipRight4(write(of2(leftovers)), void_5);
        }
        return zipRight4(split2(empty5(), leftovers), void_5);
      }
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3(empty5()))));
  });
  var splitOnChunk = /* @__PURE__ */ dual(2, (self2, delimiter) => {
    const next = (leftover, delimiterIndex) => readWithCause({
      onInput: (inputChunk) => {
        let buffer2;
        const [carry, delimiterCursor] = pipe(inputChunk, reduce2([pipe(leftover, getOrElse(() => empty5())), delimiterIndex], ([carry2, delimiterCursor2], a) => {
          const concatenated = pipe(carry2, append2(a));
          if (delimiterCursor2 < delimiter.length && equals(a, pipe(delimiter, unsafeGet4(delimiterCursor2)))) {
            if (delimiterCursor2 + 1 === delimiter.length) {
              if (buffer2 === undefined) {
                buffer2 = [];
              }
              buffer2.push(pipe(concatenated, take(concatenated.length - delimiter.length)));
              return [empty5(), 0];
            }
            return [concatenated, delimiterCursor2 + 1];
          }
          return [concatenated, equals(a, pipe(delimiter, unsafeGet4(0))) ? 1 : 0];
        }));
        const output = buffer2 === undefined ? empty5() : unsafeFromArray(buffer2);
        return flatMap13(write(output), () => next(isNonEmpty2(carry) ? some2(carry) : none2(), delimiterCursor));
      },
      onFailure: (cause3) => match2(leftover, {
        onNone: () => failCause10(cause3),
        onSome: (chunk3) => zipRight4(write(of2(chunk3)), failCause10(cause3))
      }),
      onDone: (done11) => match2(leftover, {
        onNone: () => succeed10(done11),
        onSome: (chunk3) => zipRight4(write(of2(chunk3)), succeed10(done11))
      })
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeTo(next(none2(), 0))));
  });
  var splitLines2 = (self2) => pipeThroughChannel(self2, splitLines());
  var succeed14 = (value) => fromChunk(of2(value));
  var sync8 = (evaluate2) => suspend9(() => fromChunk(of2(evaluate2())));
  var suspend9 = (stream) => new StreamImpl(suspend5(() => toChannel2(stream())));
  var take7 = /* @__PURE__ */ dual(2, (self2, n) => {
    if (!Number.isInteger(n)) {
      return die10(new IllegalArgumentException2(`${n} must be an integer`));
    }
    const loop3 = (n2) => readWith({
      onInput: (input) => {
        const taken = pipe(input, take(Math.min(n2, Number.POSITIVE_INFINITY)));
        const leftover = Math.max(0, n2 - taken.length);
        const more = leftover > 0;
        if (more) {
          return pipe(write(taken), flatMap13(() => loop3(leftover)));
        }
        return write(taken);
      },
      onFailure: fail11,
      onDone: succeed10
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(0 < n ? loop3(n) : void_5)));
  });
  var takeRight2 = /* @__PURE__ */ dual(2, (self2, n) => {
    if (n <= 0) {
      return empty31;
    }
    return new StreamImpl(pipe(succeed8(new RingBuffer(n)), map16((queue) => {
      const reader = readWith({
        onInput: (input) => {
          for (const element of input) {
            queue.put(element);
          }
          return reader;
        },
        onFailure: fail11,
        onDone: () => pipe(write(queue.toChunk()), zipRight4(void_5))
      });
      return pipe(toChannel2(self2), pipeTo(reader));
    }), unwrap));
  });
  var takeUntil3 = /* @__PURE__ */ dual(2, (self2, predicate) => {
    const loop3 = readWith({
      onInput: (input) => {
        const taken = pipe(input, takeWhile((a) => !predicate(a)));
        const last4 = pipe(input, drop2(taken.length), take(1));
        if (isEmpty(last4)) {
          return pipe(write(taken), flatMap13(() => loop3));
        }
        return write(pipe(taken, appendAll2(last4)));
      },
      onFailure: fail11,
      onDone: succeed10
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
  });
  var takeUntilEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
    const loop3 = (iterator) => {
      const next = iterator.next();
      if (next.done) {
        return readWithCause({
          onInput: (elem) => loop3(elem[Symbol.iterator]()),
          onFailure: failCause10,
          onDone: succeed10
        });
      }
      return pipe(predicate(next.value), map16((bool) => bool ? write(of2(next.value)) : pipe(write(of2(next.value)), flatMap13(() => loop3(iterator)))), unwrap);
    };
    return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3(empty5()[Symbol.iterator]()))));
  });
  var takeWhile4 = /* @__PURE__ */ dual(2, (self2, predicate) => {
    const loop3 = readWith({
      onInput: (input) => {
        const taken = pipe(input, takeWhile(predicate));
        const more = taken.length === input.length;
        if (more) {
          return pipe(write(taken), flatMap13(() => loop3));
        }
        return write(taken);
      },
      onFailure: fail11,
      onDone: succeed10
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
  });
  var tap6 = /* @__PURE__ */ dual(2, (self2, f) => mapEffectSequential(self2, (a) => as3(f(a), a)));
  var tapBoth3 = /* @__PURE__ */ dual(2, (self2, options) => pipe(self2, tapError5(options.onFailure), tap6(options.onSuccess)));
  var tapError5 = /* @__PURE__ */ dual(2, (self2, f) => catchAll7(self2, (error) => fromEffect7(zipRight3(f(error), fail9(error)))));
  var tapErrorCause5 = /* @__PURE__ */ dual(2, (self2, f) => {
    const loop3 = readWithCause({
      onInput: (chunk3) => flatMap13(write(chunk3), () => loop3),
      onFailure: (cause3) => fromEffect4(zipRight3(f(cause3), failCause8(cause3))),
      onDone: succeedNow
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3)));
  });
  var tapSink = /* @__PURE__ */ dual(2, (self2, sink) => pipe(fromEffect7(all4([bounded5(1), make19()])), flatMap16(([queue, deferred]) => {
    const right3 = flattenTake(fromQueue2(queue, {
      maxChunkSize: 1
    }));
    const loop3 = readWithCause({
      onInput: (chunk3) => pipe(fromEffect4(offer3(queue, chunk2(chunk3))), foldCauseChannel({
        onFailure: () => flatMap13(write(chunk3), () => identityChannel()),
        onSuccess: () => flatMap13(write(chunk3), () => loop3)
      })),
      onFailure: (cause3) => pipe(fromEffect4(offer3(queue, failCause11(cause3))), foldCauseChannel({
        onFailure: () => failCause10(cause3),
        onSuccess: () => failCause10(cause3)
      })),
      onDone: () => pipe(fromEffect4(offer3(queue, end4)), foldCauseChannel({
        onFailure: () => void_5,
        onSuccess: () => void_5
      }))
    });
    return pipe(new StreamImpl(pipe(pipeTo(toChannel2(self2), loop3), ensuring3(zipRight3(forkDaemon2(offer3(queue, end4)), _await(deferred))))), merge9(execute(pipe(run3(right3, sink), ensuring2(zipRight3(shutdown4(queue), succeed2(deferred, undefined)))))));
  })));
  var throttle = /* @__PURE__ */ dual(2, (self2, options) => throttleEffect(self2, {
    ...options,
    cost: (chunk3) => succeed8(options.cost(chunk3))
  }));
  var throttleEffect = /* @__PURE__ */ dual(2, (self2, options) => {
    if (options.strategy === "enforce") {
      return throttleEnforceEffect(self2, options.cost, options.units, options.duration, options.burst ?? 0);
    }
    return throttleShapeEffect(self2, options.cost, options.units, options.duration, options.burst ?? 0);
  });
  var throttleEnforceEffect = (self2, cost, units, duration2, burst) => {
    const loop3 = (tokens, timestampMillis) => readWithCause({
      onInput: (input) => pipe(cost(input), zip5(currentTimeMillis2), map16(([weight, currentTimeMillis3]) => {
        const elapsed2 = currentTimeMillis3 - timestampMillis;
        const cycles = elapsed2 / toMillis(duration2);
        const sum3 = tokens + cycles * units;
        const max5 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
        const available = sum3 < 0 ? max5 : Math.min(sum3, max5);
        if (weight <= available) {
          return pipe(write(input), flatMap13(() => loop3(available - weight, currentTimeMillis3)));
        }
        return loop3(tokens, timestampMillis);
      }), unwrap),
      onFailure: failCause10,
      onDone: () => void_5
    });
    const throttled = pipe(currentTimeMillis2, map16((currentTimeMillis3) => loop3(units, currentTimeMillis3)), unwrap);
    return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(throttled)));
  };
  var throttleShapeEffect = (self2, costFn, units, duration2, burst) => {
    const loop3 = (tokens, timestampMillis) => readWithCause({
      onInput: (input) => pipe(costFn(input), zip5(currentTimeMillis2), map16(([weight, currentTimeMillis3]) => {
        const elapsed2 = currentTimeMillis3 - timestampMillis;
        const cycles = elapsed2 / toMillis(duration2);
        const sum3 = tokens + cycles * units;
        const max5 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
        const available = sum3 < 0 ? max5 : Math.min(sum3, max5);
        const remaining = available - weight;
        const waitCycles = remaining >= 0 ? 0 : -remaining / units;
        const delay3 = millis(Math.max(0, waitCycles * toMillis(duration2)));
        if (greaterThan2(delay3, zero)) {
          return pipe(fromEffect4(sleep2(delay3)), zipRight4(write(input)), flatMap13(() => loop3(remaining, currentTimeMillis3)));
        }
        return flatMap13(write(input), () => loop3(remaining, currentTimeMillis3));
      }), unwrap),
      onFailure: failCause10,
      onDone: () => void_5
    });
    const throttled = pipe(currentTimeMillis2, map16((currentTimeMillis3) => loop3(units, currentTimeMillis3)), unwrap);
    return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(throttled)));
  };
  var tick = (interval) => repeatWithSchedule(undefined, spaced2(interval));
  var timeout3 = /* @__PURE__ */ dual(2, (self2, duration2) => pipe(toPull2(self2), map16(timeoutFail2({
    onTimeout: () => none2(),
    duration: duration2
  })), fromPull2));
  var timeoutFail3 = /* @__PURE__ */ dual(3, (self2, error, duration2) => pipe(self2, timeoutTo3(duration2, failSync7(error))));
  var timeoutFailCause3 = /* @__PURE__ */ dual(3, (self2, cause3, duration2) => pipe(toPull2(self2), map16(timeoutFailCause2({
    onTimeout: () => map12(cause3(), some2),
    duration: duration2
  })), fromPull2));
  var timeoutTo3 = /* @__PURE__ */ dual(3, (self2, duration2, that) => {
    const StreamTimeout = new RuntimeException2("Stream Timeout");
    return pipe(self2, timeoutFailCause3(() => die4(StreamTimeout), duration2), catchSomeCause3((cause3) => isDieType2(cause3) && isRuntimeException2(cause3.defect) && cause3.defect.message !== undefined && cause3.defect.message === "Stream Timeout" ? some2(that) : none2()));
  });
  var pubsubFromOptions = (options) => {
    if (typeof options === "number") {
      return bounded4(options);
    } else if (options.capacity === "unbounded") {
      return unbounded4({
        replay: options.replay
      });
    }
    switch (options.strategy) {
      case "dropping":
        return dropping3(options);
      case "sliding":
        return sliding3(options);
      default:
        return bounded4(options);
    }
  };
  var toPubSub2 = /* @__PURE__ */ dual(2, (self2, capacity7) => pipe(acquireRelease2(pubsubFromOptions(capacity7), (pubsub) => shutdown3(pubsub)), tap3((pubsub) => pipe(self2, runIntoPubSubScoped(pubsub), forkScoped2))));
  var toPull2 = (self2) => map16(toPull(toChannel2(self2)), (pull) => pipe(pull, mapError3(some2), flatMap11(match({
    onLeft: () => fail9(none2()),
    onRight: succeed8
  }))));
  var toQueue2 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => tap3(acquireRelease2(options?.strategy === "unbounded" ? unbounded5() : options?.strategy === "dropping" ? dropping4(options.capacity ?? 2) : options?.strategy === "sliding" ? sliding4(options.capacity ?? 2) : bounded5(options?.capacity ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped2(runIntoQueueScoped(self2, queue))));
  var toQueueOfElements = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => tap3(acquireRelease2(bounded5(options?.capacity ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped2(runIntoQueueElementsScoped(self2, queue))));
  var toReadableStream = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => toReadableStreamRuntime(self2, defaultRuntime2, options));
  var toReadableStreamEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => map16(runtime4(), (runtime5) => toReadableStreamRuntime(self2, runtime5, options)));
  var toReadableStreamRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, runtime5, options) => {
    const runFork4 = runFork3(runtime5);
    let currentResolve = undefined;
    let fiber = undefined;
    const latch = unsafeMakeLatch2(false);
    return new ReadableStream({
      start(controller) {
        fiber = runFork4(runForEachChunk(self2, (chunk3) => {
          if (chunk3.length === 0)
            return _void;
          return latch.whenOpen(sync3(() => {
            latch.unsafeClose();
            for (const item of chunk3) {
              controller.enqueue(item);
            }
            currentResolve();
            currentResolve = undefined;
          }));
        }));
        fiber.addObserver((exit3) => {
          try {
            if (exit3._tag === "Failure") {
              controller.error(squash(exit3.cause));
            } else {
              controller.close();
            }
          } catch {}
        });
      },
      pull() {
        return new Promise((resolve) => {
          currentResolve = resolve;
          runSync(latch.open);
        });
      },
      cancel() {
        if (!fiber)
          return;
        return runPromise(asVoid3(interrupt6(fiber)));
      }
    }, options?.strategy);
  });
  var transduce = /* @__PURE__ */ dual(2, (self2, sink) => {
    const newChannel = suspend5(() => {
      const leftovers = {
        ref: empty5()
      };
      const upstreamDone = {
        ref: false
      };
      const buffer2 = suspend5(() => {
        const leftover = leftovers.ref;
        if (isEmpty(leftover)) {
          return readWith({
            onInput: (input) => pipe(write(input), flatMap13(() => buffer2)),
            onFailure: fail11,
            onDone: succeedNow
          });
        }
        leftovers.ref = empty5();
        return pipe(writeChunk(leftover), flatMap13(() => buffer2));
      });
      const concatAndGet = (chunk3) => {
        const leftover = leftovers.ref;
        const concatenated = appendAll2(leftover, filter3(chunk3, (chunk4) => chunk4.length !== 0));
        leftovers.ref = concatenated;
        return concatenated;
      };
      const upstreamMarker = readWith({
        onInput: (input) => flatMap13(write(input), () => upstreamMarker),
        onFailure: fail11,
        onDone: (done11) => zipRight4(sync5(() => {
          upstreamDone.ref = true;
        }), succeedNow(done11))
      });
      const transducer = pipe(sink, toChannel, collectElements, flatMap13(([leftover, z]) => pipe(succeed10([upstreamDone.ref, concatAndGet(leftover)]), flatMap13(([done11, newLeftovers]) => {
        const nextChannel = done11 && isEmpty(newLeftovers) ? void_5 : transducer;
        return pipe(write(of2(z)), flatMap13(() => nextChannel));
      }))));
      return pipe(toChannel2(self2), pipeTo(upstreamMarker), pipeTo(buffer2), pipeToOrFail(transducer));
    });
    return new StreamImpl(newChannel);
  });
  var toAsyncIterableRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, runtime5) => {
    const runFork4 = runFork3(runtime5);
    return {
      [Symbol.asyncIterator]() {
        let currentResolve = undefined;
        let currentReject = undefined;
        let fiber = undefined;
        const latch = unsafeMakeLatch2(false);
        let returned = false;
        return {
          next() {
            if (!fiber) {
              fiber = runFork4(runForEach(self2, (value) => latch.whenOpen(sync3(() => {
                latch.unsafeClose();
                currentResolve({
                  done: false,
                  value
                });
                currentResolve = currentReject = undefined;
              }))));
              fiber.addObserver((exit3) => {
                if (returned)
                  return;
                fiber = runFork2(latch.whenOpen(sync3(() => {
                  if (exit3._tag === "Failure") {
                    currentReject(squash(exit3.cause));
                  } else {
                    currentResolve({
                      done: true,
                      value: undefined
                    });
                  }
                  currentResolve = currentReject = undefined;
                })));
              });
            }
            return new Promise((resolve, reject) => {
              currentResolve = resolve;
              currentReject = reject;
              latch.unsafeOpen();
            });
          },
          return() {
            returned = true;
            if (!fiber)
              return Promise.resolve({
                done: true,
                value: undefined
              });
            return runPromise(as3(interrupt6(fiber), {
              done: true,
              value: undefined
            }));
          }
        };
      }
    };
  });
  var toAsyncIterable = (self2) => toAsyncIterableRuntime(self2, defaultRuntime2);
  var toAsyncIterableEffect = (self2) => map16(runtime4(), (runtime5) => toAsyncIterableRuntime(self2, runtime5));
  var unfold3 = (s, f) => unfoldChunk(s, (s2) => pipe(f(s2), map2(([a, s3]) => [of2(a), s3])));
  var unfoldChunk = (s, f) => {
    const loop3 = (s2) => match2(f(s2), {
      onNone: () => void_5,
      onSome: ([chunk3, s3]) => flatMap13(write(chunk3), () => loop3(s3))
    });
    return new StreamImpl(suspend5(() => loop3(s)));
  };
  var unfoldChunkEffect = (s, f) => suspend9(() => {
    const loop3 = (s2) => unwrap(map16(f(s2), match2({
      onNone: () => void_5,
      onSome: ([chunk3, s3]) => flatMap13(write(chunk3), () => loop3(s3))
    })));
    return new StreamImpl(loop3(s));
  });
  var unfoldEffect = (s, f) => unfoldChunkEffect(s, (s2) => pipe(f(s2), map16(map2(([a, s3]) => [of2(a), s3]))));
  var void_7 = /* @__PURE__ */ succeed14(undefined);
  var unwrap2 = (effect4) => flatten13(fromEffect7(effect4));
  var unwrapScoped5 = (effect4) => flatten13(scoped5(effect4));
  var unwrapScopedWith3 = (f) => flatten13(scopedWith4((scope5) => f(scope5)));
  var updateService4 = /* @__PURE__ */ dual(3, (self2, tag, f) => pipe(self2, mapInputContext5((context6) => pipe(context6, add2(tag, f(pipe(context6, unsafeGet3(tag))))))));
  var when3 = /* @__PURE__ */ dual(2, (self2, test) => pipe(self2, whenEffect3(sync3(test))));
  var whenCase = (evaluate2, pf) => whenCaseEffect(pf)(sync3(evaluate2));
  var whenCaseEffect = /* @__PURE__ */ dual(2, (self2, pf) => pipe(fromEffect7(self2), flatMap16((a) => pipe(pf(a), getOrElse(() => empty31)))));
  var whenEffect3 = /* @__PURE__ */ dual(2, (self2, effect4) => pipe(fromEffect7(effect4), flatMap16((bool) => bool ? self2 : empty31)));
  var withSpan6 = function() {
    const dataFirst = typeof arguments[0] !== "string";
    const name = dataFirst ? arguments[1] : arguments[0];
    const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
    if (dataFirst) {
      const self2 = arguments[0];
      return new StreamImpl(withSpan5(toChannel2(self2), name, options));
    }
    return (self2) => new StreamImpl(withSpan5(toChannel2(self2), name, options));
  };
  var zip7 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, zipWith10(that, (a, a2) => [a, a2])));
  var zipFlatten = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, zipWith10(that, (a, a2) => [...a, a2])));
  var zipAll = /* @__PURE__ */ dual(2, (self2, options) => zipAllWith(self2, {
    other: options.other,
    onSelf: (a) => [a, options.defaultOther],
    onOther: (a2) => [options.defaultSelf, a2],
    onBoth: (a, a2) => [a, a2]
  }));
  var zipAllLeft = /* @__PURE__ */ dual(3, (self2, other, defaultSelf) => zipAllWith(self2, {
    other,
    onSelf: identity,
    onOther: () => defaultSelf,
    onBoth: (a) => a
  }));
  var zipAllRight = /* @__PURE__ */ dual(3, (self2, other, defaultRight) => zipAllWith(self2, {
    other,
    onSelf: () => defaultRight,
    onOther: identity,
    onBoth: (_, a2) => a2
  }));
  var zipAllSortedByKey = /* @__PURE__ */ dual(2, (self2, options) => zipAllSortedByKeyWith(self2, {
    other: options.other,
    onSelf: (a) => [a, options.defaultOther],
    onOther: (a2) => [options.defaultSelf, a2],
    onBoth: (a, a2) => [a, a2],
    order: options.order
  }));
  var zipAllSortedByKeyLeft = /* @__PURE__ */ dual(2, (self2, options) => zipAllSortedByKeyWith(self2, {
    other: options.other,
    onSelf: identity,
    onOther: () => options.defaultSelf,
    onBoth: (a) => a,
    order: options.order
  }));
  var zipAllSortedByKeyRight = /* @__PURE__ */ dual(2, (self2, options) => zipAllSortedByKeyWith(self2, {
    other: options.other,
    onSelf: () => options.defaultOther,
    onOther: identity,
    onBoth: (_, a2) => a2,
    order: options.order
  }));
  var zipAllSortedByKeyWith = /* @__PURE__ */ dual(2, (self2, options) => {
    const pull = (state, pullLeft, pullRight) => {
      switch (state._tag) {
        case OP_DRAIN_LEFT: {
          return pipe(pullLeft, match12({
            onFailure: fail4,
            onSuccess: (leftChunk) => succeed3([map4(leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])
          }));
        }
        case OP_DRAIN_RIGHT: {
          return pipe(pullRight, match12({
            onFailure: fail4,
            onSuccess: (rightChunk) => succeed3([map4(rightChunk, ([k, a2]) => [k, options.onOther(a2)]), DrainRight])
          }));
        }
        case OP_PULL_BOTH: {
          return pipe(unsome(pullLeft), zip5(unsome(pullRight), {
            concurrent: true
          }), matchEffect2({
            onFailure: (error) => succeed8(fail4(some2(error))),
            onSuccess: ([leftOption, rightOption]) => {
              if (isSome2(leftOption) && isSome2(rightOption)) {
                if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                  return pull(PullBoth, pullLeft, pullRight);
                }
                if (isEmpty(leftOption.value)) {
                  return pull(PullLeft(rightOption.value), pullLeft, pullRight);
                }
                if (isEmpty(rightOption.value)) {
                  return pull(PullRight(leftOption.value), pullLeft, pullRight);
                }
                return succeed8(succeed3(merge10(leftOption.value, rightOption.value)));
              }
              if (isSome2(leftOption) && isNone2(rightOption)) {
                if (isEmpty(leftOption.value)) {
                  return pull(DrainLeft, pullLeft, pullRight);
                }
                return succeed8(succeed3([pipe(leftOption.value, map4(([k, a]) => [k, options.onSelf(a)])), DrainLeft]));
              }
              if (isNone2(leftOption) && isSome2(rightOption)) {
                if (isEmpty(rightOption.value)) {
                  return pull(DrainRight, pullLeft, pullRight);
                }
                return succeed8(succeed3([pipe(rightOption.value, map4(([k, a2]) => [k, options.onOther(a2)])), DrainRight]));
              }
              return succeed8(fail4(none2()));
            }
          }));
        }
        case OP_PULL_LEFT: {
          return matchEffect2(pullLeft, {
            onFailure: match2({
              onNone: () => succeed8(succeed3([pipe(state.rightChunk, map4(([k, a2]) => [k, options.onOther(a2)])), DrainRight])),
              onSome: (error) => succeed8(fail4(some2(error)))
            }),
            onSuccess: (leftChunk) => isEmpty(leftChunk) ? pull(PullLeft(state.rightChunk), pullLeft, pullRight) : succeed8(succeed3(merge10(leftChunk, state.rightChunk)))
          });
        }
        case OP_PULL_RIGHT: {
          return matchEffect2(pullRight, {
            onFailure: match2({
              onNone: () => succeed8(succeed3([map4(state.leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])),
              onSome: (error) => succeed8(fail4(some2(error)))
            }),
            onSuccess: (rightChunk) => isEmpty(rightChunk) ? pull(PullRight(state.leftChunk), pullLeft, pullRight) : succeed8(succeed3(merge10(state.leftChunk, rightChunk)))
          });
        }
      }
    };
    const merge10 = (leftChunk, rightChunk) => {
      const hasNext = (chunk3, index) => index < chunk3.length - 1;
      const builder = [];
      let state = undefined;
      let leftIndex = 0;
      let rightIndex = 0;
      let leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
      let rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
      let k1 = leftTuple[0];
      let a = leftTuple[1];
      let k2 = rightTuple[0];
      let a2 = rightTuple[1];
      let loop3 = true;
      while (loop3) {
        const compare = options.order(k1, k2);
        if (compare === 0) {
          builder.push([k1, options.onBoth(a, a2)]);
          if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {
            leftIndex = leftIndex + 1;
            rightIndex = rightIndex + 1;
            leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
            rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
            k1 = leftTuple[0];
            a = leftTuple[1];
            k2 = rightTuple[0];
            a2 = rightTuple[1];
          } else if (hasNext(leftChunk, leftIndex)) {
            state = PullRight(pipe(leftChunk, drop2(leftIndex + 1)));
            loop3 = false;
          } else if (hasNext(rightChunk, rightIndex)) {
            state = PullLeft(pipe(rightChunk, drop2(rightIndex + 1)));
            loop3 = false;
          } else {
            state = PullBoth;
            loop3 = false;
          }
        } else if (compare < 0) {
          builder.push([k1, options.onSelf(a)]);
          if (hasNext(leftChunk, leftIndex)) {
            leftIndex = leftIndex + 1;
            leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
            k1 = leftTuple[0];
            a = leftTuple[1];
          } else {
            const rightBuilder = [];
            rightBuilder.push(rightTuple);
            while (hasNext(rightChunk, rightIndex)) {
              rightIndex = rightIndex + 1;
              rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
              rightBuilder.push(rightTuple);
            }
            state = PullLeft(unsafeFromArray(rightBuilder));
            loop3 = false;
          }
        } else {
          builder.push([k2, options.onOther(a2)]);
          if (hasNext(rightChunk, rightIndex)) {
            rightIndex = rightIndex + 1;
            rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
            k2 = rightTuple[0];
            a2 = rightTuple[1];
          } else {
            const leftBuilder = [];
            leftBuilder.push(leftTuple);
            while (hasNext(leftChunk, leftIndex)) {
              leftIndex = leftIndex + 1;
              leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
              leftBuilder.push(leftTuple);
            }
            state = PullRight(unsafeFromArray(leftBuilder));
            loop3 = false;
          }
        }
      }
      return [unsafeFromArray(builder), state];
    };
    return combineChunks(self2, options.other, PullBoth, pull);
  });
  var zipAllWith = /* @__PURE__ */ dual(2, (self2, options) => {
    const pull = (state, pullLeft, pullRight) => {
      switch (state._tag) {
        case OP_DRAIN_LEFT: {
          return matchEffect2(pullLeft, {
            onFailure: (error) => succeed8(fail4(error)),
            onSuccess: (leftChunk) => succeed8(succeed3([map4(leftChunk, options.onSelf), DrainLeft]))
          });
        }
        case OP_DRAIN_RIGHT: {
          return matchEffect2(pullRight, {
            onFailure: (error) => succeed8(fail4(error)),
            onSuccess: (rightChunk) => succeed8(succeed3([map4(rightChunk, options.onOther), DrainRight]))
          });
        }
        case OP_PULL_BOTH: {
          return pipe(unsome(pullLeft), zip5(unsome(pullRight), {
            concurrent: true
          }), matchEffect2({
            onFailure: (error) => succeed8(fail4(some2(error))),
            onSuccess: ([leftOption, rightOption]) => {
              if (isSome2(leftOption) && isSome2(rightOption)) {
                if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                  return pull(PullBoth, pullLeft, pullRight);
                }
                if (isEmpty(leftOption.value)) {
                  return pull(PullLeft(rightOption.value), pullLeft, pullRight);
                }
                if (isEmpty(rightOption.value)) {
                  return pull(PullRight(leftOption.value), pullLeft, pullRight);
                }
                return succeed8(succeed3(zip8(leftOption.value, rightOption.value, options.onBoth)));
              }
              if (isSome2(leftOption) && isNone2(rightOption)) {
                return succeed8(succeed3([map4(leftOption.value, options.onSelf), DrainLeft]));
              }
              if (isNone2(leftOption) && isSome2(rightOption)) {
                return succeed8(succeed3([map4(rightOption.value, options.onOther), DrainRight]));
              }
              return succeed8(fail4(none2()));
            }
          }));
        }
        case OP_PULL_LEFT: {
          return matchEffect2(pullLeft, {
            onFailure: match2({
              onNone: () => succeed8(succeed3([map4(state.rightChunk, options.onOther), DrainRight])),
              onSome: (error) => succeed8(fail4(some2(error)))
            }),
            onSuccess: (leftChunk) => {
              if (isEmpty(leftChunk)) {
                return pull(PullLeft(state.rightChunk), pullLeft, pullRight);
              }
              if (isEmpty(state.rightChunk)) {
                return pull(PullRight(leftChunk), pullLeft, pullRight);
              }
              return succeed8(succeed3(zip8(leftChunk, state.rightChunk, options.onBoth)));
            }
          });
        }
        case OP_PULL_RIGHT: {
          return matchEffect2(pullRight, {
            onFailure: match2({
              onNone: () => succeed8(succeed3([map4(state.leftChunk, options.onSelf), DrainLeft])),
              onSome: (error) => succeed8(fail4(some2(error)))
            }),
            onSuccess: (rightChunk) => {
              if (isEmpty(rightChunk)) {
                return pull(PullRight(state.leftChunk), pullLeft, pullRight);
              }
              if (isEmpty(state.leftChunk)) {
                return pull(PullLeft(rightChunk), pullLeft, pullRight);
              }
              return succeed8(succeed3(zip8(state.leftChunk, rightChunk, options.onBoth)));
            }
          });
        }
      }
    };
    const zip8 = (leftChunk, rightChunk, f) => {
      const [output, either6] = zipChunks(leftChunk, rightChunk, f);
      switch (either6._tag) {
        case "Left": {
          if (isEmpty(either6.left)) {
            return [output, PullBoth];
          }
          return [output, PullRight(either6.left)];
        }
        case "Right": {
          if (isEmpty(either6.right)) {
            return [output, PullBoth];
          }
          return [output, PullLeft(either6.right)];
        }
      }
    };
    return combineChunks(self2, options.other, PullBoth, pull);
  });
  var zipLatest = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipLatestWith(right3, (a, a2) => [a, a2])));
  var zipLatestAll = (...streams) => {
    if (streams.length === 0) {
      return empty31;
    } else if (streams.length === 1) {
      return map21(streams[0], (x) => [x]);
    }
    const [head6, ...tail] = streams;
    return zipLatestWith(head6, zipLatestAll(...tail), (first, second) => [first, ...second]);
  };
  var zipLatestWith = /* @__PURE__ */ dual(3, (left3, right3, f) => {
    const pullNonEmpty = (pull) => pipe(pull, flatMap11((chunk3) => isEmpty(chunk3) ? pullNonEmpty(pull) : succeed8(chunk3)));
    return pipe(toPull2(left3), map16(pullNonEmpty), zip5(pipe(toPull2(right3), map16(pullNonEmpty))), flatMap11(([left4, right4]) => pipe(fromEffectOption(raceWith2(left4, right4, {
      onSelfDone: (leftDone, rightFiber) => pipe(suspend3(() => leftDone), zipWith5(join3(rightFiber), (l, r) => [l, r, true])),
      onOtherDone: (rightDone, leftFiber) => pipe(suspend3(() => rightDone), zipWith5(join3(leftFiber), (l, r) => [r, l, false]))
    })), flatMap16(([l, r, leftFirst]) => pipe(fromEffect7(make29([unsafeLast(l), unsafeLast(r)])), flatMap16((latest) => pipe(fromChunk(leftFirst ? pipe(r, map4((a2) => f(unsafeLast(l), a2))) : pipe(l, map4((a) => f(a, unsafeLast(r))))), concat2(pipe(repeatEffectOption(left4), mergeEither(repeatEffectOption(right4)), mapEffectSequential(match({
      onLeft: (leftChunk) => modify4(latest, ([_, rightLatest]) => [pipe(leftChunk, map4((a) => f(a, rightLatest))), [unsafeLast(leftChunk), rightLatest]]),
      onRight: (rightChunk) => modify4(latest, ([leftLatest, _]) => [pipe(rightChunk, map4((a2) => f(leftLatest, a2))), [leftLatest, unsafeLast(rightChunk)]])
    })), flatMap16(fromChunk))))))), toPull2)), fromPull2);
  });
  var zipLeft5 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
    if (left4.length > right4.length) {
      return [pipe(left4, take(right4.length)), left2(pipe(left4, take(right4.length)))];
    }
    return [left4, right2(pipe(right4, drop2(left4.length)))];
  })));
  var zipRight8 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
    if (left4.length > right4.length) {
      return [right4, left2(pipe(left4, take(right4.length)))];
    }
    return [pipe(right4, take(left4.length)), right2(pipe(right4, drop2(left4.length)))];
  })));
  var zipWith10 = /* @__PURE__ */ dual(3, (left3, right3, f) => pipe(left3, zipWithChunks(right3, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f))));
  var zipWithChunks = /* @__PURE__ */ dual(3, (self2, that, f) => {
    const pull = (state, pullLeft, pullRight) => {
      switch (state._tag) {
        case OP_PULL_BOTH2: {
          return pipe(unsome(pullLeft), zip5(unsome(pullRight), {
            concurrent: true
          }), matchEffect2({
            onFailure: (error) => succeed8(fail4(some2(error))),
            onSuccess: ([leftOption, rightOption]) => {
              if (isSome2(leftOption) && isSome2(rightOption)) {
                if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                  return pull(PullBoth2, pullLeft, pullRight);
                }
                if (isEmpty(leftOption.value)) {
                  return pull(PullLeft2(rightOption.value), pullLeft, pullRight);
                }
                if (isEmpty(rightOption.value)) {
                  return pull(PullRight2(leftOption.value), pullLeft, pullRight);
                }
                return succeed8(succeed3(zip8(leftOption.value, rightOption.value)));
              }
              return succeed8(fail4(none2()));
            }
          }));
        }
        case OP_PULL_LEFT2: {
          return matchEffect2(pullLeft, {
            onFailure: (error) => succeed8(fail4(error)),
            onSuccess: (leftChunk) => {
              if (isEmpty(leftChunk)) {
                return pull(PullLeft2(state.rightChunk), pullLeft, pullRight);
              }
              if (isEmpty(state.rightChunk)) {
                return pull(PullRight2(leftChunk), pullLeft, pullRight);
              }
              return succeed8(succeed3(zip8(leftChunk, state.rightChunk)));
            }
          });
        }
        case OP_PULL_RIGHT2: {
          return matchEffect2(pullRight, {
            onFailure: (error) => succeed8(fail4(error)),
            onSuccess: (rightChunk) => {
              if (isEmpty(rightChunk)) {
                return pull(PullRight2(state.leftChunk), pullLeft, pullRight);
              }
              if (isEmpty(state.leftChunk)) {
                return pull(PullLeft2(rightChunk), pullLeft, pullRight);
              }
              return succeed8(succeed3(zip8(state.leftChunk, rightChunk)));
            }
          });
        }
      }
    };
    const zip8 = (leftChunk, rightChunk) => {
      const [output, either6] = f(leftChunk, rightChunk);
      switch (either6._tag) {
        case "Left": {
          if (isEmpty(either6.left)) {
            return [output, PullBoth2];
          }
          return [output, PullRight2(either6.left)];
        }
        case "Right": {
          if (isEmpty(either6.right)) {
            return [output, PullBoth2];
          }
          return [output, PullLeft2(either6.right)];
        }
      }
    };
    return pipe(self2, combineChunks(that, PullBoth2, pull));
  });
  var zipWithIndex = (self2) => pipe(self2, mapAccum5(0, (index, a) => [index + 1, [a, index]]));
  var zipWithNext = (self2) => {
    const process2 = (last4) => readWithCause({
      onInput: (input) => {
        const [newLast, chunk3] = mapAccum2(input, last4, (prev, curr) => [some2(curr), pipe(prev, map2((a) => [a, curr]))]);
        const output = filterMap3(chunk3, (option3) => isSome2(option3) ? some2([option3.value[0], some2(option3.value[1])]) : none2());
        return flatMap13(write(output), () => process2(newLast));
      },
      onFailure: failCause10,
      onDone: () => match2(last4, {
        onNone: () => void_5,
        onSome: (value) => zipRight4(write(of2([value, none2()])), void_5)
      })
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(process2(none2()))));
  };
  var zipWithPrevious = (self2) => pipe(self2, mapAccum5(none2(), (prev, curr) => [some2(curr), [prev, curr]]));
  var zipWithPreviousAndNext = (self2) => pipe(zipWithNext(zipWithPrevious(self2)), map21(([[prev, curr], next]) => [prev, curr, pipe(next, map2((tuple) => tuple[1]))]));
  var zipChunks = (left3, right3, f) => {
    if (left3.length > right3.length) {
      return [pipe(left3, take(right3.length), zipWith2(right3, f)), left2(pipe(left3, drop2(right3.length)))];
    }
    return [pipe(left3, zipWith2(pipe(right3, take(left3.length)), f)), right2(pipe(right3, drop2(left3.length)))];
  };
  var Do3 = /* @__PURE__ */ succeed14({});
  var bind4 = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self2, tag, f, options) => flatMap16(self2, (k) => map21(f(k), (a) => ({
    ...k,
    [tag]: a
  })), options));
  var bindTo4 = /* @__PURE__ */ bindTo(map21);
  var let_4 = /* @__PURE__ */ let_(map21);
  var decodeText = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, encoding = "utf-8") => suspend9(() => {
    const decoder = new TextDecoder(encoding);
    return map21(self2, (s) => decoder.decode(s));
  }));
  var encodeText = (self2) => suspend9(() => {
    const encoder = new TextEncoder;
    return map21(self2, (s) => encoder.encode(s));
  });
  var fromEventListener = (target, type, options) => asyncPush((emit2) => acquireRelease2(sync3(() => target.addEventListener(type, emit2.single, options)), () => sync3(() => target.removeEventListener(type, emit2.single, options))), {
    bufferSize: typeof options === "object" ? options.bufferSize : undefined
  });

  // node_modules/effect/dist/esm/Channel.js
  var acquireUseRelease4 = acquireUseRelease3;
  var embedInput2 = embedInput;
  var ensuring7 = ensuring3;
  var flatMap17 = flatMap13;
  var fromEffect8 = fromEffect4;
  var suspend10 = suspend5;
  var void_8 = void_5;
  var write2 = write;
  // node_modules/effect/dist/esm/FiberSet.js
  var TypeId16 = /* @__PURE__ */ Symbol.for("effect/FiberSet");
  var isFiberSet = (u) => hasProperty(u, TypeId16);
  var Proto2 = {
    [TypeId16]: TypeId16,
    [Symbol.iterator]() {
      if (this.state._tag === "Closed") {
        return empty();
      }
      return this.state.backing[Symbol.iterator]();
    },
    toString() {
      return format(this.toJSON());
    },
    toJSON() {
      return {
        _id: "FiberMap",
        state: this.state
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  var unsafeMake11 = (backing, deferred) => {
    const self2 = Object.create(Proto2);
    self2.state = {
      _tag: "Open",
      backing
    };
    self2.deferred = deferred;
    return self2;
  };
  var make52 = () => acquireRelease2(map16(make19(), (deferred) => unsafeMake11(new Set, deferred)), (set8) => withFiberRuntime2((parent) => {
    const state = set8.state;
    if (state._tag === "Closed")
      return _void;
    set8.state = {
      _tag: "Closed"
    };
    const fibers = state.backing;
    return interruptAllAs2(fibers, combine3(parent.id(), internalFiberId)).pipe(intoDeferred2(set8.deferred));
  }));
  var internalFiberIdId = -1;
  var internalFiberId = /* @__PURE__ */ make13(internalFiberIdId, 0);
  var isInternalInterruption = /* @__PURE__ */ reduceWithContext2(undefined, {
    emptyCase: constFalse,
    failCase: constFalse,
    dieCase: constFalse,
    interruptCase: (_, fiberId3) => has3(ids2(fiberId3), internalFiberIdId),
    sequentialCase: (_, left3, right3) => left3 || right3,
    parallelCase: (_, left3, right3) => left3 || right3
  });
  var unsafeAdd = /* @__PURE__ */ dual((args2) => isFiberSet(args2[0]), (self2, fiber, options) => {
    if (self2.state._tag === "Closed") {
      fiber.unsafeInterruptAsFork(combine3(options?.interruptAs ?? none4, internalFiberId));
      return;
    } else if (self2.state.backing.has(fiber)) {
      return;
    }
    self2.state.backing.add(fiber);
    fiber.addObserver((exit3) => {
      if (self2.state._tag === "Closed") {
        return;
      }
      self2.state.backing.delete(fiber);
      if (isFailure(exit3) && (options?.propagateInterruption === true ? !isInternalInterruption(exit3.cause) : !isInterruptedOnly2(exit3.cause))) {
        unsafeDone(self2.deferred, exit3);
      }
    });
  });
  var join4 = (self2) => _await(self2.deferred);
  // node_modules/effect/dist/esm/internal/groupBy.js
  var GroupBySymbolKey = "effect/GroupBy";
  var GroupByTypeId = /* @__PURE__ */ Symbol.for(GroupBySymbolKey);
  var groupByVariance = {
    _R: (_) => _,
    _E: (_) => _,
    _K: (_) => _,
    _V: (_) => _
  };
  var isGroupBy = (u) => hasProperty(u, GroupByTypeId);
  var evaluate2 = /* @__PURE__ */ dual((args2) => isGroupBy(args2[0]), (self2, f, options) => flatMap16(self2.grouped, ([key, queue]) => f(key, flattenTake(fromQueue2(queue, {
    shutdown: true
  }))), {
    concurrency: "unbounded",
    bufferSize: options?.bufferSize ?? 16
  }));
  var make53 = (grouped2) => ({
    [GroupByTypeId]: groupByVariance,
    pipe() {
      return pipeArguments(this, arguments);
    },
    grouped: grouped2
  });
  var groupBy = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, f, options) => make53(unwrapScoped5(gen2(function* () {
    const decider = yield* make19();
    const output = yield* acquireRelease2(bounded5(options?.bufferSize ?? 16), (queue) => shutdown4(queue));
    const ref = yield* make29(new Map);
    const add5 = yield* pipe(mapEffectSequential(self2, f), distributedWithDynamicCallback(options?.bufferSize ?? 16, ([key, value]) => flatMap11(_await(decider), (f2) => f2(key, value)), (exit3) => offer3(output, exit3)));
    yield* succeed2(decider, (key, _) => pipe(get12(ref), map16((map22) => fromNullable(map22.get(key))), flatMap11(match2({
      onNone: () => flatMap11(add5, ([index, queue]) => zipRight3(update3(ref, (map22) => map22.set(key, index)), pipe(offer3(output, succeed3([key, mapDequeue(queue, (exit3) => new TakeImpl(pipe(exit3, map11((tuple) => of2(tuple[1])))))])), as3((n) => n === index)))),
      onSome: (index) => succeed8((n) => n === index)
    }))));
    return flattenExitOption(fromQueue2(output, {
      shutdown: true
    }));
  }))));
  var mapEffectOptions = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self2, f, options) => {
    if (options?.key) {
      return evaluate2(groupByKey(self2, options.key, {
        bufferSize: options.bufferSize
      }), (_, s) => mapEffectSequential(s, f));
    }
    return matchConcurrency(options?.concurrency, () => mapEffectSequential(self2, f), (n) => options?.unordered ? flatMap16(self2, (a) => fromEffect7(f(a)), {
      concurrency: n
    }) : mapEffectPar(self2, n, f));
  });
  var bindEffect = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self2, tag, f, options) => mapEffectOptions(self2, (k) => map16(f(k), (a) => ({
    ...k,
    [tag]: a
  })), options));
  var mapDequeue = (dequeue, f) => new MapDequeue(dequeue, f);

  class MapDequeue extends Class {
    dequeue;
    f;
    [DequeueTypeId2] = {
      _Out: (_) => _
    };
    constructor(dequeue, f) {
      super();
      this.dequeue = dequeue;
      this.f = f;
    }
    capacity() {
      return capacity4(this.dequeue);
    }
    get size() {
      return size10(this.dequeue);
    }
    unsafeSize() {
      return this.dequeue.unsafeSize();
    }
    get awaitShutdown() {
      return awaitShutdown3(this.dequeue);
    }
    isActive() {
      return this.dequeue.isActive();
    }
    get isShutdown() {
      return isShutdown3(this.dequeue);
    }
    get shutdown() {
      return shutdown4(this.dequeue);
    }
    get isFull() {
      return isFull3(this.dequeue);
    }
    get isEmpty() {
      return isEmpty12(this.dequeue);
    }
    get take() {
      return pipe(take3(this.dequeue), map16((a) => this.f(a)));
    }
    get takeAll() {
      return pipe(takeAll2(this.dequeue), map16(map4((a) => this.f(a))));
    }
    takeUpTo(max5) {
      return pipe(takeUpTo2(this.dequeue, max5), map16(map4((a) => this.f(a))));
    }
    takeBetween(min3, max5) {
      return pipe(takeBetween2(this.dequeue, min3, max5), map16(map4((a) => this.f(a))));
    }
    takeN(n) {
      return pipe(takeN2(this.dequeue, n), map16(map4((a) => this.f(a))));
    }
    poll() {
      return pipe(poll6(this.dequeue), map16(map2((a) => this.f(a))));
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    commit() {
      return this.take;
    }
  }
  var groupByKey = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self2, f, options) => {
    const loop3 = (map22, outerQueue) => readWithCause({
      onInput: (input) => flatMap13(fromEffect4(forEach6(groupByIterable(input, f), ([key, values3]) => {
        const innerQueue = map22.get(key);
        if (innerQueue === undefined) {
          return pipe(bounded5(options?.bufferSize ?? 16), flatMap11((innerQueue2) => pipe(sync3(() => {
            map22.set(key, innerQueue2);
          }), zipRight3(offer3(outerQueue, of5([key, innerQueue2]))), zipRight3(pipe(offer3(innerQueue2, chunk2(values3)), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2()))))));
        }
        return catchSomeCause2(offer3(innerQueue, chunk2(values3)), (cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2());
      }, {
        discard: true
      })), () => loop3(map22, outerQueue)),
      onFailure: (cause3) => fromEffect4(offer3(outerQueue, failCause11(cause3))),
      onDone: () => fromEffect4(pipe(forEach6(map22.entries(), ([_, innerQueue]) => pipe(offer3(innerQueue, end4), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2())), {
        discard: true
      }), zipRight3(offer3(outerQueue, end4))))
    });
    return make53(unwrapScopedWith3((scope5) => gen2(function* () {
      const map22 = new Map;
      const queue = yield* unbounded5();
      yield* addFinalizer2(scope5, shutdown4(queue));
      return yield* toChannel2(self2).pipe(pipeTo(loop3(map22, queue)), drain, runIn(scope5), forkIn2(scope5), as3(flattenTake(fromQueue2(queue, {
        shutdown: true
      }))));
    })));
  });
  var groupByIterable = /* @__PURE__ */ dual(2, (iterable, f) => {
    const builder = [];
    const iterator = iterable[Symbol.iterator]();
    const map22 = new Map;
    let next;
    while ((next = iterator.next()) && !next.done) {
      const value = next.value;
      const key = f(value);
      if (map22.has(key)) {
        const innerBuilder = map22.get(key);
        innerBuilder.push(value);
      } else {
        const innerBuilder = [value];
        builder.push([key, innerBuilder]);
        map22.set(key, innerBuilder);
      }
    }
    return unsafeFromArray(builder.map((tuple) => [tuple[0], unsafeFromArray(tuple[1])]));
  });
  // node_modules/effect/dist/esm/ParseResult.js
  class Pointer {
    path;
    actual;
    issue;
    _tag = "Pointer";
    constructor(path, actual, issue) {
      this.path = path;
      this.actual = actual;
      this.issue = issue;
    }
  }

  class Unexpected {
    actual;
    message;
    _tag = "Unexpected";
    constructor(actual, message) {
      this.actual = actual;
      this.message = message;
    }
  }

  class Missing {
    ast;
    message;
    _tag = "Missing";
    actual = undefined;
    constructor(ast, message) {
      this.ast = ast;
      this.message = message;
    }
  }

  class Composite2 {
    ast;
    actual;
    issues;
    output;
    _tag = "Composite";
    constructor(ast, actual, issues, output) {
      this.ast = ast;
      this.actual = actual;
      this.issues = issues;
      this.output = output;
    }
  }

  class Refinement2 {
    ast;
    actual;
    kind;
    issue;
    _tag = "Refinement";
    constructor(ast, actual, kind, issue) {
      this.ast = ast;
      this.actual = actual;
      this.kind = kind;
      this.issue = issue;
    }
  }

  class Transformation2 {
    ast;
    actual;
    kind;
    issue;
    _tag = "Transformation";
    constructor(ast, actual, kind, issue) {
      this.ast = ast;
      this.actual = actual;
      this.kind = kind;
      this.issue = issue;
    }
  }

  class Type2 {
    ast;
    actual;
    message;
    _tag = "Type";
    constructor(ast, actual, message) {
      this.ast = ast;
      this.actual = actual;
      this.message = message;
    }
  }

  class Forbidden {
    ast;
    actual;
    message;
    _tag = "Forbidden";
    constructor(ast, actual, message) {
      this.ast = ast;
      this.actual = actual;
      this.message = message;
    }
  }
  var ParseErrorTypeId = /* @__PURE__ */ Symbol.for("effect/Schema/ParseErrorTypeId");
  class ParseError extends (/* @__PURE__ */ TaggedError("ParseError")) {
    [ParseErrorTypeId] = ParseErrorTypeId;
    get message() {
      return this.toString();
    }
    toString() {
      return TreeFormatter.formatIssueSync(this.issue);
    }
    toJSON() {
      return {
        _id: "ParseError",
        message: this.toString()
      };
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  }
  var parseError = (issue) => new ParseError({
    issue
  });
  var succeed15 = right2;
  var fail16 = left2;
  var isEither4 = isEither2;
  var flatMap18 = /* @__PURE__ */ dual(2, (self2, f) => {
    return isEither4(self2) ? match(self2, {
      onLeft: left2,
      onRight: f
    }) : flatMap11(self2, f);
  });
  var map22 = /* @__PURE__ */ dual(2, (self2, f) => {
    return isEither4(self2) ? map(self2, f) : map16(self2, f);
  });
  var mapError7 = /* @__PURE__ */ dual(2, (self2, f) => {
    return isEither4(self2) ? mapLeft(self2, f) : mapError3(self2, f);
  });
  var mapBoth7 = /* @__PURE__ */ dual(2, (self2, options) => {
    return isEither4(self2) ? mapBoth(self2, {
      onLeft: options.onFailure,
      onRight: options.onSuccess
    }) : mapBoth4(self2, options);
  });
  var orElse9 = /* @__PURE__ */ dual(2, (self2, f) => {
    return isEither4(self2) ? match(self2, {
      onLeft: f,
      onRight: right2
    }) : catchAll3(self2, f);
  });
  var mergeInternalOptions = (options, overrideOptions) => {
    if (overrideOptions === undefined || isNumber(overrideOptions)) {
      return options;
    }
    if (options === undefined) {
      return overrideOptions;
    }
    return {
      ...options,
      ...overrideOptions
    };
  };
  var getEither = (ast, isDecoding, options) => {
    const parser = goMemo(ast, isDecoding);
    return (u, overrideOptions) => parser(u, mergeInternalOptions(options, overrideOptions));
  };
  var getSync = (ast, isDecoding, options) => {
    const parser = getEither(ast, isDecoding, options);
    return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError);
  };
  var getEffect = (ast, isDecoding, options) => {
    const parser = goMemo(ast, isDecoding);
    return (input, overrideOptions) => parser(input, {
      ...mergeInternalOptions(options, overrideOptions),
      isEffectAllowed: true
    });
  };
  var decodeUnknownSync = (schema, options) => getSync(schema.ast, true, options);
  var decodeUnknown = (schema, options) => getEffect(schema.ast, true, options);
  var encodeUnknownSync = (schema, options) => getSync(schema.ast, false, options);
  var encodeUnknown = (schema, options) => getEffect(schema.ast, false, options);
  var decodeSync = decodeUnknownSync;
  var validateSync = (schema, options) => getSync(typeAST(schema.ast), true, options);
  var is = (schema, options) => {
    const parser = goMemo(typeAST(schema.ast), true);
    return (u, overrideOptions) => isRight2(parser(u, {
      exact: true,
      ...mergeInternalOptions(options, overrideOptions)
    }));
  };
  var encodeSync = encodeUnknownSync;
  var decodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/decodeMemoMap"), () => new WeakMap);
  var encodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/encodeMemoMap"), () => new WeakMap);
  var goMemo = (ast, isDecoding) => {
    const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
    const memo = memoMap.get(ast);
    if (memo) {
      return memo;
    }
    const raw = go(ast, isDecoding);
    const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
    const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i, options) => raw(i, mergeInternalOptions(options, parseOptionsAnnotation.value)) : raw;
    const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
    const parser = isDecoding && isSome2(decodingFallbackAnnotation) ? (i, options) => handleForbidden(orElse9(parserWithOptions(i, options), decodingFallbackAnnotation.value), ast, i, options) : parserWithOptions;
    memoMap.set(ast, parser);
    return parser;
  };
  var getConcurrency = (ast) => getOrUndefined(getConcurrencyAnnotation(ast));
  var getBatching = (ast) => getOrUndefined(getBatchingAnnotation(ast));
  var go = (ast, isDecoding) => {
    switch (ast._tag) {
      case "Refinement": {
        if (isDecoding) {
          const from = goMemo(ast.from, true);
          return (i, options) => {
            options = options ?? defaultParseOption;
            const allErrors = options?.errors === "all";
            const result = flatMap18(orElse9(from(i, options), (ef) => {
              const issue = new Refinement2(ast, i, "From", ef);
              if (allErrors && hasStableFilter(ast) && isComposite2(ef)) {
                return match2(ast.filter(i, options, ast), {
                  onNone: () => left2(issue),
                  onSome: (ep) => left2(new Composite2(ast, i, [issue, new Refinement2(ast, i, "Predicate", ep)]))
                });
              }
              return left2(issue);
            }), (a) => match2(ast.filter(a, options, ast), {
              onNone: () => right2(a),
              onSome: (ep) => left2(new Refinement2(ast, i, "Predicate", ep))
            }));
            return handleForbidden(result, ast, i, options);
          };
        } else {
          const from = goMemo(typeAST(ast), true);
          const to = goMemo(dropRightRefinement(ast.from), false);
          return (i, options) => handleForbidden(flatMap18(from(i, options), (a) => to(a, options)), ast, i, options);
        }
      }
      case "Transformation": {
        const transform2 = getFinalTransformation(ast.transformation, isDecoding);
        const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
        const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
        return (i, options) => handleForbidden(flatMap18(mapError7(from(i, options), (e) => new Transformation2(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap18(mapError7(transform2(a, options ?? defaultParseOption, ast, i), (e) => new Transformation2(ast, i, "Transformation", e)), (i2) => mapError7(to(i2, options), (e) => new Transformation2(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options);
      }
      case "Declaration": {
        const parse = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
        return (i, options) => handleForbidden(parse(i, options ?? defaultParseOption, ast), ast, i, options);
      }
      case "Literal":
        return fromRefinement(ast, (u) => u === ast.literal);
      case "UniqueSymbol":
        return fromRefinement(ast, (u) => u === ast.symbol);
      case "UndefinedKeyword":
        return fromRefinement(ast, isUndefined);
      case "NeverKeyword":
        return fromRefinement(ast, isNever);
      case "UnknownKeyword":
      case "AnyKeyword":
      case "VoidKeyword":
        return right2;
      case "StringKeyword":
        return fromRefinement(ast, isString);
      case "NumberKeyword":
        return fromRefinement(ast, isNumber);
      case "BooleanKeyword":
        return fromRefinement(ast, isBoolean);
      case "BigIntKeyword":
        return fromRefinement(ast, isBigInt);
      case "SymbolKeyword":
        return fromRefinement(ast, isSymbol);
      case "ObjectKeyword":
        return fromRefinement(ast, isObject);
      case "Enums":
        return fromRefinement(ast, (u) => ast.enums.some(([_, value]) => value === u));
      case "TemplateLiteral": {
        const regex = getTemplateLiteralRegExp(ast);
        return fromRefinement(ast, (u) => isString(u) && regex.test(u));
      }
      case "TupleType": {
        const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
        const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
        let requiredTypes = ast.elements.filter((e) => !e.isOptional);
        if (ast.rest.length > 0) {
          requiredTypes = requiredTypes.concat(ast.rest.slice(1));
        }
        const requiredLen = requiredTypes.length;
        const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
        const concurrency = getConcurrency(ast);
        const batching = getBatching(ast);
        return (input, options) => {
          if (!isArray(input)) {
            return left2(new Type2(ast, input));
          }
          const allErrors = options?.errors === "all";
          const es = [];
          let stepKey = 0;
          const output = [];
          const len = input.length;
          for (let i2 = len;i2 <= requiredLen - 1; i2++) {
            const e = new Pointer(i2, input, new Missing(requiredTypes[i2 - len]));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite2(ast, input, e, output));
            }
          }
          if (ast.rest.length === 0) {
            for (let i2 = ast.elements.length;i2 <= len - 1; i2++) {
              const e = new Pointer(i2, input, new Unexpected(input[i2], `is unexpected, expected: ${expectedIndexes}`));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
          }
          let i = 0;
          let queue = undefined;
          for (;i < elements.length; i++) {
            if (len < i + 1) {
              if (ast.elements[i].isOptional) {
                continue;
              }
            } else {
              const parser = elements[i];
              const te = parser(input[i], options);
              if (isEither4(te)) {
                if (isLeft2(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output)));
                  }
                }
                output.push([stepKey++, te.right]);
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap11(either3(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                    }
                  }
                  output2.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
          if (isNonEmptyReadonlyArray(rest)) {
            const [head6, ...tail] = rest;
            for (;i < len - tail.length; i++) {
              const te = head6(input[i], options);
              if (isEither4(te)) {
                if (isLeft2(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output)));
                  }
                } else {
                  output.push([stepKey++, te.right]);
                }
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap11(either3(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                    }
                  } else {
                    output2.push([nk, t.right]);
                    return _void;
                  }
                }));
              }
            }
            for (let j = 0;j < tail.length; j++) {
              i += j;
              if (len < i + 1) {
                continue;
              } else {
                const te = tail[j](input[i], options);
                if (isEither4(te)) {
                  if (isLeft2(te)) {
                    const e = new Pointer(i, input, te.left);
                    if (allErrors) {
                      es.push([stepKey++, e]);
                      continue;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output)));
                    }
                  }
                  output.push([stepKey++, te.right]);
                } else {
                  const nk = stepKey++;
                  const index = i;
                  if (!queue) {
                    queue = [];
                  }
                  queue.push(({
                    es: es2,
                    output: output2
                  }) => flatMap11(either3(te), (t) => {
                    if (isLeft2(t)) {
                      const e = new Pointer(index, input, t.left);
                      if (allErrors) {
                        es2.push([nk, e]);
                        return _void;
                      } else {
                        return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                      }
                    }
                    output2.push([nk, t.right]);
                    return _void;
                  }));
                }
              }
            }
          }
          const computeResult = ({
            es: es2,
            output: output2
          }) => isNonEmptyArray2(es2) ? left2(new Composite2(ast, input, sortByIndex(es2), sortByIndex(output2))) : right2(sortByIndex(output2));
          if (queue && queue.length > 0) {
            const cqueue = queue;
            return suspend3(() => {
              const state = {
                es: copy(es),
                output: copy(output)
              };
              return flatMap11(forEach6(cqueue, (f) => f(state), {
                concurrency,
                batching,
                discard: true
              }), () => computeResult(state));
            });
          }
          return computeResult({
            output,
            es
          });
        };
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          return fromRefinement(ast, isNotNullable);
        }
        const propertySignatures = [];
        const expectedKeysMap = {};
        const expectedKeys = [];
        for (const ps of ast.propertySignatures) {
          propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
          expectedKeysMap[ps.name] = null;
          expectedKeys.push(ps.name);
        }
        const indexSignatures = ast.indexSignatures.map((is2) => [goMemo(is2.parameter, isDecoding), goMemo(is2.type, isDecoding), is2.parameter]);
        const expectedAST = Union.make(ast.indexSignatures.map((is2) => is2.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal(key))));
        const expected = goMemo(expectedAST, isDecoding);
        const concurrency = getConcurrency(ast);
        const batching = getBatching(ast);
        return (input, options) => {
          if (!isRecord(input)) {
            return left2(new Type2(ast, input));
          }
          const allErrors = options?.errors === "all";
          const es = [];
          let stepKey = 0;
          const onExcessPropertyError = options?.onExcessProperty === "error";
          const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
          const output = {};
          let inputKeys;
          if (onExcessPropertyError || onExcessPropertyPreserve) {
            inputKeys = Reflect.ownKeys(input);
            for (const key of inputKeys) {
              const te = expected(key, options);
              if (isEither4(te) && isLeft2(te)) {
                if (onExcessPropertyError) {
                  const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, output));
                  }
                } else {
                  output[key] = input[key];
                }
              }
            }
          }
          let queue = undefined;
          const isExact = options?.exact === true;
          for (let i = 0;i < propertySignatures.length; i++) {
            const ps = propertySignatures[i][1];
            const name = ps.name;
            const hasKey = Object.prototype.hasOwnProperty.call(input, name);
            if (!hasKey) {
              if (ps.isOptional) {
                continue;
              } else if (isExact) {
                const e = new Pointer(name, input, new Missing(ps));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output));
                }
              }
            }
            const parser = propertySignatures[i][0];
            const te = parser(input[name], options);
            if (isEither4(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output));
                }
              }
              output[name] = te.right;
            } else {
              const nk = stepKey++;
              const index = name;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap11(either3(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps));
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, output2));
                  }
                }
                output2[index] = t.right;
                return _void;
              }));
            }
          }
          for (let i = 0;i < indexSignatures.length; i++) {
            const indexSignature = indexSignatures[i];
            const parameter = indexSignature[0];
            const type = indexSignature[1];
            const keys3 = getKeysForIndexSignature(input, indexSignature[2]);
            for (const key of keys3) {
              const keu = parameter(key, options);
              if (isEither4(keu) && isRight2(keu)) {
                const vpr = type(input[key], options);
                if (isEither4(vpr)) {
                  if (isLeft2(vpr)) {
                    const e = new Pointer(key, input, vpr.left);
                    if (allErrors) {
                      es.push([stepKey++, e]);
                      continue;
                    } else {
                      return left2(new Composite2(ast, input, e, output));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output[key] = vpr.right;
                    }
                  }
                } else {
                  const nk = stepKey++;
                  const index = key;
                  if (!queue) {
                    queue = [];
                  }
                  queue.push(({
                    es: es2,
                    output: output2
                  }) => flatMap11(either3(vpr), (tv) => {
                    if (isLeft2(tv)) {
                      const e = new Pointer(index, input, tv.left);
                      if (allErrors) {
                        es2.push([nk, e]);
                        return _void;
                      } else {
                        return left2(new Composite2(ast, input, e, output2));
                      }
                    } else {
                      if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                        output2[key] = tv.right;
                      }
                      return _void;
                    }
                  }));
                }
              }
            }
          }
          const computeResult = ({
            es: es2,
            output: output2
          }) => {
            if (isNonEmptyArray2(es2)) {
              return left2(new Composite2(ast, input, sortByIndex(es2), output2));
            }
            if (options?.propertyOrder === "original") {
              const keys3 = inputKeys || Reflect.ownKeys(input);
              for (const name of expectedKeys) {
                if (keys3.indexOf(name) === -1) {
                  keys3.push(name);
                }
              }
              const out = {};
              for (const key of keys3) {
                if (Object.prototype.hasOwnProperty.call(output2, key)) {
                  out[key] = output2[key];
                }
              }
              return right2(out);
            }
            return right2(output2);
          };
          if (queue && queue.length > 0) {
            const cqueue = queue;
            return suspend3(() => {
              const state = {
                es: copy(es),
                output: Object.assign({}, output)
              };
              return flatMap11(forEach6(cqueue, (f) => f(state), {
                concurrency,
                batching,
                discard: true
              }), () => computeResult(state));
            });
          }
          return computeResult({
            es,
            output
          });
        };
      }
      case "Union": {
        const searchTree = getSearchTree(ast.types, isDecoding);
        const ownKeys = Reflect.ownKeys(searchTree.keys);
        const ownKeysLen = ownKeys.length;
        const astTypesLen = ast.types.length;
        const map23 = new Map;
        for (let i = 0;i < astTypesLen; i++) {
          map23.set(ast.types[i], goMemo(ast.types[i], isDecoding));
        }
        const concurrency = getConcurrency(ast) ?? 1;
        const batching = getBatching(ast);
        return (input, options) => {
          const es = [];
          let stepKey = 0;
          let candidates = [];
          if (ownKeysLen > 0) {
            if (isRecordOrArray(input)) {
              for (let i = 0;i < ownKeysLen; i++) {
                const name = ownKeys[i];
                const buckets = searchTree.keys[name].buckets;
                if (Object.prototype.hasOwnProperty.call(input, name)) {
                  const literal = String(input[name]);
                  if (Object.prototype.hasOwnProperty.call(buckets, literal)) {
                    candidates = candidates.concat(buckets[literal]);
                  } else {
                    const {
                      candidates: candidates2,
                      literals
                    } = searchTree.keys[name];
                    const literalsUnion = Union.make(literals);
                    const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([new PropertySignature(name, literalsUnion, false, true)], []) : Union.make(candidates2);
                    es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Type2(literalsUnion, input[name])))]);
                  }
                } else {
                  const {
                    candidates: candidates2,
                    literals
                  } = searchTree.keys[name];
                  const fakePropertySignature = new PropertySignature(name, Union.make(literals), false, true);
                  const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates2);
                  es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
                }
              }
            } else {
              const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
              es.push([stepKey++, new Type2(errorAst, input)]);
            }
          }
          if (searchTree.otherwise.length > 0) {
            candidates = candidates.concat(searchTree.otherwise);
          }
          let queue = undefined;
          for (let i = 0;i < candidates.length; i++) {
            const candidate = candidates[i];
            const pr = map23.get(candidate)(input, options);
            if (isEither4(pr) && (!queue || queue.length === 0)) {
              if (isRight2(pr)) {
                return pr;
              } else {
                es.push([stepKey++, pr.left]);
              }
            } else {
              const nk = stepKey++;
              if (!queue) {
                queue = [];
              }
              queue.push((state) => suspend3(() => {
                if ("finalResult" in state) {
                  return _void;
                } else {
                  return flatMap11(either3(pr), (t) => {
                    if (isRight2(t)) {
                      state.finalResult = t;
                    } else {
                      state.es.push([nk, t.left]);
                    }
                    return _void;
                  });
                }
              }));
            }
          }
          const computeResult = (es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite2(ast, input, sortByIndex(es2))) : left2(new Type2(ast, input));
          if (queue && queue.length > 0) {
            const cqueue = queue;
            return suspend3(() => {
              const state = {
                es: copy(es)
              };
              return flatMap11(forEach6(cqueue, (f) => f(state), {
                concurrency,
                batching,
                discard: true
              }), () => {
                if ("finalResult" in state) {
                  return state.finalResult;
                }
                return computeResult(state.es);
              });
            });
          }
          return computeResult(es);
        };
      }
      case "Suspend": {
        const get17 = memoizeThunk(() => goMemo(ast.f(), isDecoding));
        return (a, options) => get17()(a, options);
      }
    }
  };
  var fromRefinement = (ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type2(ast, u));
  var getLiterals = (ast, isDecoding) => {
    switch (ast._tag) {
      case "Declaration": {
        const annotation = getSurrogateAnnotation(ast);
        if (isSome2(annotation)) {
          return getLiterals(annotation.value, isDecoding);
        }
        break;
      }
      case "TypeLiteral": {
        const out = [];
        for (let i = 0;i < ast.propertySignatures.length; i++) {
          const propertySignature = ast.propertySignatures[i];
          const type = isDecoding ? encodedAST(propertySignature.type) : typeAST(propertySignature.type);
          if (isLiteral(type) && !propertySignature.isOptional) {
            out.push([propertySignature.name, type]);
          }
        }
        return out;
      }
      case "TupleType": {
        const out = [];
        for (let i = 0;i < ast.elements.length; i++) {
          const element = ast.elements[i];
          const type = isDecoding ? encodedAST(element.type) : typeAST(element.type);
          if (isLiteral(type) && !element.isOptional) {
            out.push([i, type]);
          }
        }
        return out;
      }
      case "Refinement":
        return getLiterals(ast.from, isDecoding);
      case "Suspend":
        return getLiterals(ast.f(), isDecoding);
      case "Transformation":
        return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
    }
    return [];
  };
  var getSearchTree = (members, isDecoding) => {
    const keys3 = {};
    const otherwise = [];
    const candidates = [];
    for (let i = 0;i < members.length; i++) {
      const member = members[i];
      const tags = getLiterals(member, isDecoding);
      if (tags.length > 0) {
        candidates.push(member);
        for (let j = 0;j < tags.length; j++) {
          const [key, literal] = tags[j];
          const hash2 = String(literal.literal);
          keys3[key] = keys3[key] || {
            buckets: {},
            literals: [],
            candidates: []
          };
          const buckets = keys3[key].buckets;
          if (Object.prototype.hasOwnProperty.call(buckets, hash2)) {
            if (j < tags.length - 1) {
              continue;
            }
            buckets[hash2].push(member);
            keys3[key].literals.push(literal);
            keys3[key].candidates.push(member);
          } else {
            buckets[hash2] = [member];
            keys3[key].literals.push(literal);
            keys3[key].candidates.push(member);
            break;
          }
        }
      } else {
        otherwise.push(member);
      }
    }
    return {
      keys: keys3,
      otherwise,
      candidates
    };
  };
  var dropRightRefinement = (ast) => isRefinement(ast) ? dropRightRefinement(ast.from) : ast;
  var handleForbidden = (effect4, ast, actual, options) => {
    if (options?.isEffectAllowed === true) {
      return effect4;
    }
    if (isEither4(effect4)) {
      return effect4;
    }
    const scheduler = new SyncScheduler;
    const fiber = runFork2(effect4, {
      scheduler
    });
    scheduler.flush();
    const exit3 = fiber.unsafePoll();
    if (exit3) {
      if (isSuccess(exit3)) {
        return right2(exit3.value);
      }
      const cause3 = exit3.cause;
      if (isFailType2(cause3)) {
        return left2(cause3.error);
      }
      return left2(new Forbidden(ast, actual, pretty2(cause3)));
    }
    return left2(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
  };
  var compare = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0;
  function sortByIndex(es) {
    return es.sort(compare).map((t) => t[1]);
  }
  var getFinalTransformation = (transformation, isDecoding) => {
    switch (transformation._tag) {
      case "FinalTransformation":
        return isDecoding ? transformation.decode : transformation.encode;
      case "ComposeTransformation":
        return right2;
      case "TypeLiteralTransformation":
        return (input) => {
          let out = right2(input);
          for (const pst of transformation.propertySignatureTransformations) {
            const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
            const transformation2 = isDecoding ? pst.decode : pst.encode;
            const f = (input2) => {
              const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some2(input2[from]) : none2());
              delete input2[from];
              if (isSome2(o)) {
                input2[to] = o.value;
              }
              return input2;
            };
            out = map22(out, f);
          }
          return out;
        };
    }
  };
  var makeTree = (value, forest = []) => ({
    value,
    forest
  });
  var TreeFormatter = {
    formatIssue: (issue) => map22(formatTree(issue), drawTree),
    formatIssueSync: (issue) => {
      const e = TreeFormatter.formatIssue(issue);
      return isEither4(e) ? getOrThrow(e) : runSync(e);
    },
    formatError: (error) => TreeFormatter.formatIssue(error.issue),
    formatErrorSync: (error) => TreeFormatter.formatIssueSync(error.issue)
  };
  var drawTree = (tree) => tree.value + draw(`
`, tree.forest);
  var draw = (indentation, forest) => {
    let r = "";
    const len = forest.length;
    let tree;
    for (let i = 0;i < len; i++) {
      tree = forest[i];
      const isLast = i === len - 1;
      r += indentation + (isLast ? "" : "") + " " + tree.value;
      r += draw(indentation + (len > 1 && !isLast ? "  " : "   "), tree.forest);
    }
    return r;
  };
  var formatTransformationKind = (kind) => {
    switch (kind) {
      case "Encoded":
        return "Encoded side transformation failure";
      case "Transformation":
        return "Transformation process failure";
      case "Type":
        return "Type side transformation failure";
    }
  };
  var formatRefinementKind = (kind) => {
    switch (kind) {
      case "From":
        return "From side refinement failure";
      case "Predicate":
        return "Predicate refinement failure";
    }
  };
  var getAnnotated = (issue) => ("ast" in issue) ? some2(issue.ast) : none2();
  var Either_void = /* @__PURE__ */ right2(undefined);
  var getCurrentMessage = (issue) => getAnnotated(issue).pipe(flatMap(getMessageAnnotation), match2({
    onNone: () => Either_void,
    onSome: (messageAnnotation) => {
      const union9 = messageAnnotation(issue);
      if (isString(union9)) {
        return right2({
          message: union9,
          override: false
        });
      }
      if (isEffect2(union9)) {
        return map16(union9, (message) => ({
          message,
          override: false
        }));
      }
      if (isString(union9.message)) {
        return right2({
          message: union9.message,
          override: union9.override
        });
      }
      return map16(union9.message, (message) => ({
        message,
        override: union9.override
      }));
    }
  }));
  var createParseIssueGuard = (tag) => (issue) => issue._tag === tag;
  var isComposite2 = /* @__PURE__ */ createParseIssueGuard("Composite");
  var isRefinement2 = /* @__PURE__ */ createParseIssueGuard("Refinement");
  var isTransformation2 = /* @__PURE__ */ createParseIssueGuard("Transformation");
  var getMessage = (issue) => flatMap18(getCurrentMessage(issue), (currentMessage) => {
    if (currentMessage !== undefined) {
      const useInnerMessage = !currentMessage.override && (isComposite2(issue) || isRefinement2(issue) && issue.kind === "From" || isTransformation2(issue) && issue.kind !== "Transformation");
      return useInnerMessage ? isTransformation2(issue) || isRefinement2(issue) ? getMessage(issue.issue) : Either_void : right2(currentMessage.message);
    }
    return Either_void;
  });
  var getParseIssueTitleAnnotation2 = (issue) => getAnnotated(issue).pipe(flatMap(getParseIssueTitleAnnotation), flatMapNullable((annotation) => annotation(issue)), getOrUndefined);
  function getRefinementExpected(ast) {
    return getDescriptionAnnotation(ast).pipe(orElse(() => getTitleAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), orElse(() => getIdentifierAnnotation(ast)), getOrElse(() => `{ ${ast.from} | filter }`));
  }
  function getDefaultTypeMessage(issue) {
    if (issue.message !== undefined) {
      return issue.message;
    }
    const expected = isRefinement(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast);
    return `Expected ${expected}, actual ${formatUnknown(issue.actual)}`;
  }
  var formatTypeMessage = (issue) => map22(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation2(issue) ?? getDefaultTypeMessage(issue));
  var getParseIssueTitle = (issue) => getParseIssueTitleAnnotation2(issue) ?? String(issue.ast);
  var formatForbiddenMessage = (issue) => issue.message ?? "is forbidden";
  var formatUnexpectedMessage = (issue) => issue.message ?? "is unexpected";
  var formatMissingMessage = (issue) => {
    const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
    if (isSome2(missingMessageAnnotation)) {
      const annotation = missingMessageAnnotation.value();
      return isString(annotation) ? right2(annotation) : annotation;
    }
    return right2(issue.message ?? "is missing");
  };
  var formatTree = (issue) => {
    switch (issue._tag) {
      case "Type":
        return map22(formatTypeMessage(issue), makeTree);
      case "Forbidden":
        return right2(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
      case "Unexpected":
        return right2(makeTree(formatUnexpectedMessage(issue)));
      case "Missing":
        return map22(formatMissingMessage(issue), makeTree);
      case "Transformation":
        return flatMap18(getMessage(issue), (message) => {
          if (message !== undefined) {
            return right2(makeTree(message));
          }
          return map22(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
        });
      case "Refinement":
        return flatMap18(getMessage(issue), (message) => {
          if (message !== undefined) {
            return right2(makeTree(message));
          }
          return map22(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
        });
      case "Pointer":
        return map22(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
      case "Composite":
        return flatMap18(getMessage(issue), (message) => {
          if (message !== undefined) {
            return right2(makeTree(message));
          }
          const parseIssueTitle = getParseIssueTitle(issue);
          return isNonEmpty(issue.issues) ? map22(forEach6(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map22(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
        });
    }
  };
  // node_modules/effect/dist/esm/internal/mailbox.js
  var TypeId17 = /* @__PURE__ */ Symbol.for("effect/Mailbox");
  var ReadonlyTypeId = /* @__PURE__ */ Symbol.for("effect/Mailbox/ReadonlyMailbox");
  var empty32 = /* @__PURE__ */ empty5();
  var exitEmpty = /* @__PURE__ */ exitSucceed(empty32);
  var exitFalse = /* @__PURE__ */ exitSucceed(false);
  var exitTrue = /* @__PURE__ */ exitSucceed(true);
  var constDone = [empty32, true];

  class MailboxImpl extends Class {
    scheduler;
    capacity;
    strategy;
    [TypeId17] = TypeId17;
    [ReadonlyTypeId] = ReadonlyTypeId;
    state = {
      _tag: "Open",
      takers: /* @__PURE__ */ new Set,
      offers: /* @__PURE__ */ new Set,
      awaiters: /* @__PURE__ */ new Set
    };
    messages = [];
    messagesChunk = /* @__PURE__ */ empty5();
    constructor(scheduler, capacity7, strategy) {
      super();
      this.scheduler = scheduler;
      this.capacity = capacity7;
      this.strategy = strategy;
    }
    offer(message) {
      return suspend(() => {
        if (this.state._tag !== "Open") {
          return exitFalse;
        } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
          switch (this.strategy) {
            case "dropping":
              return exitFalse;
            case "suspend":
              if (this.capacity <= 0 && this.state.takers.size > 0) {
                this.messages.push(message);
                this.releaseTaker();
                return exitTrue;
              }
              return this.offerRemainingSingle(message);
            case "sliding":
              this.unsafeTake();
              this.messages.push(message);
              return exitTrue;
          }
        }
        this.messages.push(message);
        this.scheduleReleaseTaker();
        return exitTrue;
      });
    }
    unsafeOffer(message) {
      if (this.state._tag !== "Open") {
        return false;
      } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
        if (this.strategy === "sliding") {
          this.unsafeTake();
          this.messages.push(message);
          return true;
        } else if (this.capacity <= 0 && this.state.takers.size > 0) {
          this.messages.push(message);
          this.releaseTaker();
          return true;
        }
        return false;
      }
      this.messages.push(message);
      this.scheduleReleaseTaker();
      return true;
    }
    offerAll(messages) {
      return suspend(() => {
        if (this.state._tag !== "Open") {
          return succeed(fromIterable2(messages));
        }
        const remaining = this.unsafeOfferAllArray(messages);
        if (remaining.length === 0) {
          return exitEmpty;
        } else if (this.strategy === "dropping") {
          return succeed(unsafeFromArray(remaining));
        }
        return this.offerRemainingArray(remaining);
      });
    }
    unsafeOfferAll(messages) {
      return unsafeFromArray(this.unsafeOfferAllArray(messages));
    }
    unsafeOfferAllArray(messages) {
      if (this.state._tag !== "Open") {
        return fromIterable(messages);
      } else if (this.capacity === Number.POSITIVE_INFINITY || this.strategy === "sliding") {
        if (this.messages.length > 0) {
          this.messagesChunk = appendAll2(this.messagesChunk, unsafeFromArray(this.messages));
        }
        if (this.strategy === "sliding") {
          this.messagesChunk = this.messagesChunk.pipe(appendAll2(fromIterable2(messages)), takeRight(this.capacity));
        } else if (isChunk(messages)) {
          this.messagesChunk = appendAll2(this.messagesChunk, messages);
        } else {
          this.messages = fromIterable(messages);
        }
        this.scheduleReleaseTaker();
        return [];
      }
      const free = this.capacity <= 0 ? this.state.takers.size : this.capacity - this.messages.length - this.messagesChunk.length;
      if (free === 0) {
        return fromIterable(messages);
      }
      const remaining = [];
      let i = 0;
      for (const message of messages) {
        if (i < free) {
          this.messages.push(message);
        } else {
          remaining.push(message);
        }
        i++;
      }
      this.scheduleReleaseTaker();
      return remaining;
    }
    fail(error) {
      return this.done(exitFail(error));
    }
    failCause(cause3) {
      return this.done(exitFailCause(cause3));
    }
    unsafeDone(exit3) {
      if (this.state._tag !== "Open") {
        return false;
      } else if (this.state.offers.size === 0 && this.messages.length === 0 && this.messagesChunk.length === 0) {
        this.finalize(exit3);
        return true;
      }
      this.state = {
        ...this.state,
        _tag: "Closing",
        exit: exit3
      };
      return true;
    }
    shutdown = /* @__PURE__ */ sync(() => {
      if (this.state._tag === "Done") {
        return true;
      }
      this.messages = [];
      this.messagesChunk = empty32;
      const offers = this.state.offers;
      this.finalize(this.state._tag === "Open" ? exitVoid : this.state.exit);
      if (offers.size > 0) {
        for (const entry of offers) {
          if (entry._tag === "Single") {
            entry.resume(exitFalse);
          } else {
            entry.resume(exitSucceed(unsafeFromArray(entry.remaining.slice(entry.offset))));
          }
        }
        offers.clear();
      }
      return true;
    });
    done(exit3) {
      return sync(() => this.unsafeDone(exit3));
    }
    end = /* @__PURE__ */ this.done(exitVoid);
    clear = /* @__PURE__ */ suspend(() => {
      if (this.state._tag === "Done") {
        return exitAs(this.state.exit, empty32);
      }
      const messages = this.unsafeTakeAll();
      this.releaseCapacity();
      return succeed(messages);
    });
    takeAll = /* @__PURE__ */ suspend(() => {
      if (this.state._tag === "Done") {
        return exitAs(this.state.exit, constDone);
      }
      const messages = this.unsafeTakeAll();
      if (messages.length === 0) {
        return zipRight(this.awaitTake, this.takeAll);
      }
      return succeed([messages, this.releaseCapacity()]);
    });
    takeN(n) {
      return suspend(() => {
        if (this.state._tag === "Done") {
          return exitAs(this.state.exit, constDone);
        } else if (n <= 0) {
          return succeed([empty32, false]);
        }
        n = Math.min(n, this.capacity);
        let messages;
        if (n <= this.messagesChunk.length) {
          messages = take(this.messagesChunk, n);
          this.messagesChunk = drop2(this.messagesChunk, n);
        } else if (n <= this.messages.length + this.messagesChunk.length) {
          this.messagesChunk = appendAll2(this.messagesChunk, unsafeFromArray(this.messages));
          this.messages = [];
          messages = take(this.messagesChunk, n);
          this.messagesChunk = drop2(this.messagesChunk, n);
        } else {
          return zipRight(this.awaitTake, this.takeN(n));
        }
        return succeed([messages, this.releaseCapacity()]);
      });
    }
    unsafeTake() {
      if (this.state._tag === "Done") {
        return exitZipRight(this.state.exit, exitFail(new NoSuchElementException2));
      }
      let message;
      if (this.messagesChunk.length > 0) {
        message = unsafeHead(this.messagesChunk);
        this.messagesChunk = drop2(this.messagesChunk, 1);
      } else if (this.messages.length > 0) {
        message = this.messages[0];
        this.messagesChunk = drop2(unsafeFromArray(this.messages), 1);
        this.messages = [];
      } else if (this.capacity <= 0 && this.state.offers.size > 0) {
        this.capacity = 1;
        this.releaseCapacity();
        this.capacity = 0;
        return this.messages.length > 0 ? exitSucceed(this.messages.pop()) : undefined;
      } else {
        return;
      }
      this.releaseCapacity();
      return exitSucceed(message);
    }
    take = /* @__PURE__ */ suspend(() => this.unsafeTake() ?? zipRight(this.awaitTake, this.take));
    await = /* @__PURE__ */ asyncInterrupt((resume2) => {
      if (this.state._tag === "Done") {
        return resume2(this.state.exit);
      }
      this.state.awaiters.add(resume2);
      return sync(() => {
        if (this.state._tag !== "Done") {
          this.state.awaiters.delete(resume2);
        }
      });
    });
    unsafeSize() {
      const size13 = this.messages.length + this.messagesChunk.length;
      return this.state._tag === "Done" ? none2() : some2(size13);
    }
    size = /* @__PURE__ */ sync(() => this.unsafeSize());
    commit() {
      return this.takeAll;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    toJSON() {
      return {
        _id: "effect/Mailbox",
        state: this.state._tag,
        size: this.unsafeSize().toJSON()
      };
    }
    toString() {
      return format(this);
    }
    [NodeInspectSymbol]() {
      return format(this);
    }
    offerRemainingSingle(message) {
      return asyncInterrupt((resume2) => {
        if (this.state._tag !== "Open") {
          return resume2(exitFalse);
        }
        const entry = {
          _tag: "Single",
          message,
          resume: resume2
        };
        this.state.offers.add(entry);
        return sync(() => {
          if (this.state._tag === "Open") {
            this.state.offers.delete(entry);
          }
        });
      });
    }
    offerRemainingArray(remaining) {
      return asyncInterrupt((resume2) => {
        if (this.state._tag !== "Open") {
          return resume2(exitSucceed(unsafeFromArray(remaining)));
        }
        const entry = {
          _tag: "Array",
          remaining,
          offset: 0,
          resume: resume2
        };
        this.state.offers.add(entry);
        return sync(() => {
          if (this.state._tag === "Open") {
            this.state.offers.delete(entry);
          }
        });
      });
    }
    releaseCapacity() {
      if (this.state._tag === "Done") {
        return this.state.exit._tag === "Success";
      } else if (this.state.offers.size === 0) {
        if (this.state._tag === "Closing" && this.messages.length === 0 && this.messagesChunk.length === 0) {
          this.finalize(this.state.exit);
          return this.state.exit._tag === "Success";
        }
        return false;
      }
      let n = this.capacity - this.messages.length - this.messagesChunk.length;
      for (const entry of this.state.offers) {
        if (n === 0)
          return false;
        else if (entry._tag === "Single") {
          this.messages.push(entry.message);
          n--;
          entry.resume(exitTrue);
          this.state.offers.delete(entry);
        } else {
          for (;entry.offset < entry.remaining.length; entry.offset++) {
            if (n === 0)
              return false;
            this.messages.push(entry.remaining[entry.offset]);
            n--;
          }
          entry.resume(exitEmpty);
          this.state.offers.delete(entry);
        }
      }
      return false;
    }
    awaitTake = /* @__PURE__ */ asyncInterrupt((resume2) => {
      if (this.state._tag === "Done") {
        return resume2(this.state.exit);
      }
      this.state.takers.add(resume2);
      return sync(() => {
        if (this.state._tag !== "Done") {
          this.state.takers.delete(resume2);
        }
      });
    });
    scheduleRunning = false;
    scheduleReleaseTaker() {
      if (this.scheduleRunning) {
        return;
      }
      this.scheduleRunning = true;
      this.scheduler.scheduleTask(this.releaseTaker, 0);
    }
    releaseTaker = () => {
      this.scheduleRunning = false;
      if (this.state._tag === "Done") {
        return;
      } else if (this.state.takers.size === 0) {
        return;
      }
      for (const taker of this.state.takers) {
        this.state.takers.delete(taker);
        taker(exitVoid);
        if (this.messages.length + this.messagesChunk.length === 0) {
          break;
        }
      }
    };
    unsafeTakeAll() {
      if (this.messagesChunk.length > 0) {
        const messages = this.messages.length > 0 ? appendAll2(this.messagesChunk, unsafeFromArray(this.messages)) : this.messagesChunk;
        this.messagesChunk = empty32;
        this.messages = [];
        return messages;
      } else if (this.messages.length > 0) {
        const messages = unsafeFromArray(this.messages);
        this.messages = [];
        return messages;
      } else if (this.state._tag !== "Done" && this.state.offers.size > 0) {
        this.capacity = 1;
        this.releaseCapacity();
        this.capacity = 0;
        return of2(this.messages.pop());
      }
      return empty32;
    }
    finalize(exit3) {
      if (this.state._tag === "Done") {
        return;
      }
      const openState = this.state;
      this.state = {
        _tag: "Done",
        exit: exit3
      };
      for (const taker of openState.takers) {
        taker(exit3);
      }
      openState.takers.clear();
      for (const awaiter of openState.awaiters) {
        awaiter(exit3);
      }
      openState.awaiters.clear();
    }
  }
  var make54 = (capacity7) => withFiberRuntime((fiber) => succeed(new MailboxImpl(fiber.currentScheduler, typeof capacity7 === "number" ? capacity7 : capacity7?.capacity ?? Number.POSITIVE_INFINITY, typeof capacity7 === "number" ? "suspend" : capacity7?.strategy ?? "suspend")));
  var toChannel3 = (self2) => {
    const loop3 = flatMap13(self2.takeAll, ([messages, done11]) => done11 ? messages.length === 0 ? void_5 : write(messages) : zipRight4(write(messages), loop3));
    return loop3;
  };

  // node_modules/effect/dist/esm/Mailbox.js
  var TypeId18 = TypeId17;
  var isMailbox = (u) => hasProperty(u, TypeId18);
  var make55 = make54;
  var toChannel4 = toChannel3;
  // node_modules/effect/dist/esm/Struct.js
  var pick3 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys3) => {
    const out = {};
    for (const k of keys3) {
      if (k in s) {
        out[k] = s[k];
      }
    }
    return out;
  });
  var omit3 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys3) => {
    const out = {
      ...s
    };
    for (const k of keys3) {
      delete out[k];
    }
    return out;
  });

  // node_modules/effect/dist/esm/Schema.js
  var TypeId19 = /* @__PURE__ */ Symbol.for("effect/Schema");
  function make56(ast) {
    return class SchemaClass {
      [TypeId19] = variance7;
      static ast = ast;
      static annotations(annotations2) {
        return make56(mergeSchemaAnnotations(this.ast, annotations2));
      }
      static pipe() {
        return pipeArguments(this, arguments);
      }
      static toString() {
        return String(ast);
      }
      static Type;
      static Encoded;
      static Context;
      static [TypeId19] = variance7;
    };
  }
  var variance7 = {
    _A: (_) => _,
    _I: (_) => _,
    _R: (_) => _
  };
  var builtInAnnotations = {
    schemaId: SchemaIdAnnotationId,
    message: MessageAnnotationId,
    missingMessage: MissingMessageAnnotationId,
    identifier: IdentifierAnnotationId,
    title: TitleAnnotationId,
    description: DescriptionAnnotationId,
    examples: ExamplesAnnotationId,
    default: DefaultAnnotationId,
    documentation: DocumentationAnnotationId,
    jsonSchema: JSONSchemaAnnotationId,
    arbitrary: ArbitraryAnnotationId,
    pretty: PrettyAnnotationId,
    equivalence: EquivalenceAnnotationId,
    concurrency: ConcurrencyAnnotationId,
    batching: BatchingAnnotationId,
    parseIssueTitle: ParseIssueTitleAnnotationId,
    parseOptions: ParseOptionsAnnotationId,
    decodingFallback: DecodingFallbackAnnotationId
  };
  var toASTAnnotations = (annotations2) => {
    if (!annotations2) {
      return {};
    }
    const out = {
      ...annotations2
    };
    for (const key in builtInAnnotations) {
      if (key in annotations2) {
        const id2 = builtInAnnotations[key];
        out[id2] = annotations2[key];
        delete out[key];
      }
    }
    return out;
  };
  var mergeSchemaAnnotations = (ast, annotations2) => annotations(ast, toASTAnnotations(annotations2));
  function asSchema(schema) {
    return schema;
  }
  var format4 = (schema) => String(schema.ast);
  var encodedSchema = (schema) => make56(encodedAST(schema.ast));
  var typeSchema = (schema) => make56(typeAST(schema.ast));
  var isSchema = (u) => hasProperty(u, TypeId19) && isObject(u[TypeId19]);
  function getDefaultLiteralAST(literals) {
    return isMembers(literals) ? Union.make(mapMembers(literals, (literal) => new Literal(literal))) : new Literal(literals[0]);
  }
  function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
    return class LiteralClass extends make56(ast) {
      static annotations(annotations2) {
        return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations2));
      }
      static literals = [...literals];
    };
  }
  function Literal2(...literals) {
    return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
  }
  var declareConstructor = (typeParameters, options, annotations2) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options.decode(...typeParameters2.map(make56)), (...typeParameters2) => options.encode(...typeParameters2.map(make56)), toASTAnnotations(annotations2)));
  var declarePrimitive = (is2, annotations2) => {
    const decodeUnknown2 = () => (input, _, ast) => is2(input) ? succeed15(input) : fail16(new Type2(ast, input));
    const encodeUnknown2 = decodeUnknown2;
    return makeDeclareClass([], new Declaration([], decodeUnknown2, encodeUnknown2, toASTAnnotations(annotations2)));
  };
  function makeDeclareClass(typeParameters, ast) {
    return class DeclareClass extends make56(ast) {
      static annotations(annotations2) {
        return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations2));
      }
      static typeParameters = [...typeParameters];
    };
  }
  var declare = function() {
    if (Array.isArray(arguments[0])) {
      const typeParameters = arguments[0];
      const options = arguments[1];
      const annotations3 = arguments[2];
      return declareConstructor(typeParameters, options, annotations3);
    }
    const is2 = arguments[0];
    const annotations2 = arguments[1];
    return declarePrimitive(is2, annotations2);
  };
  class Undefined extends (/* @__PURE__ */ make56(undefinedKeyword)) {
  }
  class Never extends (/* @__PURE__ */ make56(neverKeyword)) {
  }

  class Unknown extends (/* @__PURE__ */ make56(unknownKeyword)) {
  }
  class String$ extends (/* @__PURE__ */ make56(stringKeyword)) {
  }

  class Number$ extends (/* @__PURE__ */ make56(numberKeyword)) {
  }

  class Boolean$ extends (/* @__PURE__ */ make56(booleanKeyword)) {
  }
  var getDefaultUnionAST = (members) => Union.make(members.map((m) => m.ast));
  function makeUnionClass(members, ast = getDefaultUnionAST(members)) {
    return class UnionClass extends make56(ast) {
      static annotations(annotations2) {
        return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations2));
      }
      static members = [...members];
    };
  }
  function Union2(...members) {
    return isMembers(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never;
  }
  var UndefinedOr = (self2) => Union2(self2, Undefined);
  var getDefaultTupleTypeAST = (elements, rest) => new TupleType(elements.map((el) => isSchema(el) ? new OptionalType(el.ast, false) : el.ast), rest.map((el) => isSchema(el) ? new Type(el.ast) : el.ast), true);
  function makeTupleTypeClass(elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) {
    return class TupleTypeClass extends make56(ast) {
      static annotations(annotations2) {
        return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations2));
      }
      static elements = [...elements];
      static rest = [...rest];
    };
  }
  function makeArrayClass(value, ast) {
    return class ArrayClass extends makeTupleTypeClass([], [value], ast) {
      static annotations(annotations2) {
        return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations2));
      }
      static value = value;
    };
  }
  var Array$ = (value) => makeArrayClass(value);
  var formatPropertySignatureToken = (isOptional) => isOptional ? '"?:"' : '":"';

  class PropertySignatureDeclaration extends OptionalType {
    isReadonly;
    defaultValue;
    _tag = "PropertySignatureDeclaration";
    constructor(type, isOptional, isReadonly, annotations2, defaultValue) {
      super(type, isOptional, annotations2);
      this.isReadonly = isReadonly;
      this.defaultValue = defaultValue;
    }
    toString() {
      const token = formatPropertySignatureToken(this.isOptional);
      const type = String(this.type);
      return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`;
    }
  }
  class ToPropertySignature extends OptionalType {
    isReadonly;
    defaultValue;
    constructor(type, isOptional, isReadonly, annotations2, defaultValue) {
      super(type, isOptional, annotations2);
      this.isReadonly = isReadonly;
      this.defaultValue = defaultValue;
    }
  }
  var formatPropertyKey2 = (p) => {
    if (p === undefined) {
      return "never";
    }
    if (isString(p)) {
      return JSON.stringify(p);
    }
    return String(p);
  };

  class PropertySignatureTransformation2 {
    from;
    to;
    decode;
    encode;
    _tag = "PropertySignatureTransformation";
    constructor(from, to, decode2, encode) {
      this.from = from;
      this.to = to;
      this.decode = decode2;
      this.encode = encode;
    }
    toString() {
      return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey2(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
    }
  }
  var mergeSignatureAnnotations = (ast, annotations2) => {
    switch (ast._tag) {
      case "PropertySignatureDeclaration": {
        return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
          ...ast.annotations,
          ...annotations2
        }, ast.defaultValue);
      }
      case "PropertySignatureTransformation": {
        return new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
          ...ast.to.annotations,
          ...annotations2
        }, ast.to.defaultValue), ast.decode, ast.encode);
      }
    }
  };
  var PropertySignatureTypeId = /* @__PURE__ */ Symbol.for("effect/PropertySignature");
  var isPropertySignature = (u) => hasProperty(u, PropertySignatureTypeId);

  class PropertySignatureImpl {
    ast;
    [TypeId19];
    [PropertySignatureTypeId] = null;
    _TypeToken;
    _Key;
    _EncodedToken;
    _HasDefault;
    constructor(ast) {
      this.ast = ast;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    annotations(annotations2) {
      return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations2)));
    }
    toString() {
      return String(this.ast);
    }
  }
  var makePropertySignature = (ast) => new PropertySignatureImpl(ast);

  class PropertySignatureWithFromImpl extends PropertySignatureImpl {
    from;
    constructor(ast, from) {
      super(ast);
      this.from = from;
    }
    annotations(annotations2) {
      return new PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations2)), this.from);
    }
  }
  var propertySignature = (self2) => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self2.ast, false, true, {}, undefined), self2);
  var withConstructorDefault = /* @__PURE__ */ dual(2, (self2, defaultValue) => {
    const ast = self2.ast;
    switch (ast._tag) {
      case "PropertySignatureDeclaration":
        return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
      case "PropertySignatureTransformation":
        return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
    }
  });
  var optional = (self2) => {
    const ast = self2.ast === undefinedKeyword || self2.ast === neverKeyword ? undefinedKeyword : UndefinedOr(self2).ast;
    return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, undefined), self2);
  };
  var preserveMissingMessageAnnotation = /* @__PURE__ */ pickAnnotations([MissingMessageAnnotationId]);
  var getDefaultTypeLiteralAST = (fields, records) => {
    const ownKeys = Reflect.ownKeys(fields);
    const pss = [];
    if (ownKeys.length > 0) {
      const from = [];
      const to = [];
      const transformations = [];
      for (let i = 0;i < ownKeys.length; i++) {
        const key = ownKeys[i];
        const field = fields[key];
        if (isPropertySignature(field)) {
          const ast = field.ast;
          switch (ast._tag) {
            case "PropertySignatureDeclaration": {
              const type = ast.type;
              const isOptional = ast.isOptional;
              const toAnnotations = ast.annotations;
              from.push(new PropertySignature(key, type, isOptional, true, preserveMissingMessageAnnotation(ast)));
              to.push(new PropertySignature(key, typeAST(type), isOptional, true, toAnnotations));
              pss.push(new PropertySignature(key, type, isOptional, true, toAnnotations));
              break;
            }
            case "PropertySignatureTransformation": {
              const fromKey = ast.from.fromKey ?? key;
              from.push(new PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
              to.push(new PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
              transformations.push(new PropertySignatureTransformation(fromKey, key, ast.decode, ast.encode));
              break;
            }
          }
        } else {
          from.push(new PropertySignature(key, field.ast, false, true));
          to.push(new PropertySignature(key, typeAST(field.ast), false, true));
          pss.push(new PropertySignature(key, field.ast, false, true));
        }
      }
      if (isNonEmptyReadonlyArray(transformations)) {
        const issFrom = [];
        const issTo = [];
        for (const r of records) {
          const {
            indexSignatures,
            propertySignatures
          } = record(r.key.ast, r.value.ast);
          propertySignatures.forEach((ps) => {
            from.push(ps);
            to.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
          });
          indexSignatures.forEach((is2) => {
            issFrom.push(is2);
            issTo.push(new IndexSignature(is2.parameter, typeAST(is2.type), is2.isReadonly));
          });
        }
        return new Transformation(new TypeLiteral(from, issFrom, {
          [AutoTitleAnnotationId]: "Struct (Encoded side)"
        }), new TypeLiteral(to, issTo, {
          [AutoTitleAnnotationId]: "Struct (Type side)"
        }), new TypeLiteralTransformation(transformations));
      }
    }
    const iss = [];
    for (const r of records) {
      const {
        indexSignatures,
        propertySignatures
      } = record(r.key.ast, r.value.ast);
      propertySignatures.forEach((ps) => pss.push(ps));
      indexSignatures.forEach((is2) => iss.push(is2));
    }
    return new TypeLiteral(pss, iss);
  };
  var lazilyMergeDefaults = (fields, out) => {
    const ownKeys = Reflect.ownKeys(fields);
    for (const key of ownKeys) {
      const field = fields[key];
      if (out[key] === undefined && isPropertySignature(field)) {
        const ast = field.ast;
        const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
        if (defaultValue !== undefined) {
          out[key] = defaultValue();
        }
      }
    }
    return out;
  };
  function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
    return class TypeLiteralClass extends make56(ast) {
      static annotations(annotations2) {
        return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations2));
      }
      static fields = {
        ...fields
      };
      static records = [...records];
      static make = (props, options) => {
        const propsWithDefaults = lazilyMergeDefaults(fields, {
          ...props
        });
        return getDisableValidationMakeOption(options) ? propsWithDefaults : validateSync(this)(propsWithDefaults);
      };
      static pick(...keys3) {
        return Struct(pick3(fields, ...keys3));
      }
      static omit(...keys3) {
        return Struct(omit3(fields, ...keys3));
      }
    };
  }
  function Struct(fields, ...records) {
    return makeTypeLiteralClass(fields, records);
  }
  function makeRecordClass(key, value, ast) {
    return class RecordClass extends makeTypeLiteralClass({}, [{
      key,
      value
    }], ast) {
      static annotations(annotations2) {
        return makeRecordClass(key, value, mergeSchemaAnnotations(this.ast, annotations2));
      }
      static key = key;
      static value = value;
    };
  }
  var Record = (options) => makeRecordClass(options.key, options.value);
  var intersectTypeLiterals = (x, y, path) => {
    if (isTypeLiteral(x) && isTypeLiteral(y)) {
      const propertySignatures = [...x.propertySignatures];
      for (const ps of y.propertySignatures) {
        const name = ps.name;
        const i = propertySignatures.findIndex((ps2) => ps2.name === name);
        if (i === -1) {
          propertySignatures.push(ps);
        } else {
          const {
            isOptional,
            type
          } = propertySignatures[i];
          propertySignatures[i] = new PropertySignature(name, extendAST(type, ps.type, path.concat(name)), isOptional, true);
        }
      }
      return new TypeLiteral(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
    }
    throw new Error(getSchemaExtendErrorMessage(x, y, path));
  };
  var preserveRefinementAnnotations = /* @__PURE__ */ omitAnnotations([IdentifierAnnotationId]);
  var addRefinementToMembers = (refinement, asts) => asts.map((ast) => new Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)));
  var extendAST = (x, y, path) => Union.make(intersectUnionMembers([x], [y], path));
  var getTypes = (ast) => isUnion(ast) ? ast.types : [ast];
  var intersectUnionMembers = (xs, ys, path) => flatMap2(xs, (x) => flatMap2(ys, (y) => {
    switch (y._tag) {
      case "Literal": {
        if (isString(y.literal) && isStringKeyword(x) || isNumber(y.literal) && isNumberKeyword(x) || isBoolean(y.literal) && isBooleanKeyword(x)) {
          return [y];
        }
        break;
      }
      case "StringKeyword": {
        if (y === stringKeyword) {
          if (isStringKeyword(x) || isLiteral(x) && isString(x.literal)) {
            return [x];
          } else if (isRefinement(x)) {
            return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
          }
        } else if (x === stringKeyword) {
          return [y];
        }
        break;
      }
      case "NumberKeyword": {
        if (y === numberKeyword) {
          if (isNumberKeyword(x) || isLiteral(x) && isNumber(x.literal)) {
            return [x];
          } else if (isRefinement(x)) {
            return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
          }
        } else if (x === numberKeyword) {
          return [y];
        }
        break;
      }
      case "BooleanKeyword": {
        if (y === booleanKeyword) {
          if (isBooleanKeyword(x) || isLiteral(x) && isBoolean(x.literal)) {
            return [x];
          } else if (isRefinement(x)) {
            return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
          }
        } else if (x === booleanKeyword) {
          return [y];
        }
        break;
      }
      case "Union":
        return intersectUnionMembers(getTypes(x), y.types, path);
      case "Suspend":
        return [new Suspend(() => extendAST(x, y.f(), path))];
      case "Refinement":
        return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path));
      case "TypeLiteral": {
        switch (x._tag) {
          case "Union":
            return intersectUnionMembers(x.types, [y], path);
          case "Suspend":
            return [new Suspend(() => extendAST(x.f(), y, path))];
          case "Refinement":
            return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
          case "TypeLiteral":
            return [intersectTypeLiterals(x, y, path)];
          case "Transformation": {
            const transformation = x.transformation;
            const from = intersectTypeLiterals(x.from, y, path);
            const to = intersectTypeLiterals(x.to, typeAST(y), path);
            switch (transformation._tag) {
              case "TypeLiteralTransformation":
                return [new Transformation(from, to, new TypeLiteralTransformation(transformation.propertySignatureTransformations))];
              case "ComposeTransformation":
                return [new Transformation(from, to, composeTransformation)];
              case "FinalTransformation":
                return [new Transformation(from, to, new FinalTransformation((fromA, options, ast, fromI) => map22(transformation.decode(fromA, options, ast, fromI), (partial2) => ({
                  ...fromA,
                  ...partial2
                })), (toI, options, ast, toA) => map22(transformation.encode(toI, options, ast, toA), (partial2) => ({
                  ...toI,
                  ...partial2
                }))))];
            }
          }
        }
        break;
      }
      case "Transformation": {
        if (isTransformation(x)) {
          if (isTypeLiteralTransformation(y.transformation) && isTypeLiteralTransformation(x.transformation)) {
            return [new Transformation(intersectTypeLiterals(x.from, y.from, path), intersectTypeLiterals(x.to, y.to, path), new TypeLiteralTransformation(y.transformation.propertySignatureTransformations.concat(x.transformation.propertySignatureTransformations)))];
          }
        } else {
          return intersectUnionMembers([y], [x], path);
        }
        break;
      }
    }
    throw new Error(getSchemaExtendErrorMessage(x, y, path));
  }));
  var extend3 = /* @__PURE__ */ dual(2, (self2, that) => make56(extendAST(self2.ast, that.ast, [])));
  var suspend11 = (f) => make56(new Suspend(() => f().ast));
  var RefineSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Refine");
  function makeRefineClass(from, filter10, ast) {
    return class RefineClass extends make56(ast) {
      static annotations(annotations2) {
        return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations2));
      }
      static [RefineSchemaId] = from;
      static from = from;
      static filter = filter10;
      static make = (a, options) => {
        return getDisableValidationMakeOption(options) ? a : validateSync(this)(a);
      };
    };
  }
  var fromFilterPredicateReturnTypeItem = (item, ast, input) => {
    if (isBoolean(item)) {
      return item ? none2() : some2(new Type2(ast, input));
    }
    if (isString(item)) {
      return some2(new Type2(ast, input, item));
    }
    if (item !== undefined) {
      if ("_tag" in item) {
        return some2(item);
      }
      const issue = new Type2(ast, input, item.message);
      return some2(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
    }
    return none2();
  };
  var toFilterParseIssue = (out, ast, input) => {
    if (isSingle(out)) {
      return fromFilterPredicateReturnTypeItem(out, ast, input);
    }
    if (isNonEmptyReadonlyArray(out)) {
      const issues = filterMap2(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
      if (isNonEmptyReadonlyArray(issues)) {
        return some2(issues.length === 1 ? issues[0] : new Composite2(ast, input, issues));
      }
    }
    return none2();
  };
  function filter10(predicate, annotations2) {
    return (self2) => {
      function filter11(input, options, ast2) {
        return toFilterParseIssue(predicate(input, options, ast2), ast2, input);
      }
      const ast = new Refinement(self2.ast, filter11, toASTAnnotations(annotations2));
      return makeRefineClass(self2, filter11, ast);
    };
  }
  function makeTransformationClass(from, to, ast) {
    return class TransformationClass extends make56(ast) {
      static annotations(annotations2) {
        return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations2));
      }
      static from = from;
      static to = to;
    };
  }
  var transformOrFail = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options) => makeTransformationClass(from, to, new Transformation(from.ast, to.ast, new FinalTransformation(options.decode, options.encode))));
  var transform2 = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options) => transformOrFail(from, to, {
    strict: true,
    decode: (fromA, _options, _ast, toA) => succeed15(options.decode(fromA, toA)),
    encode: (toI, _options, _ast, toA) => succeed15(options.encode(toI, toA))
  }));
  var PatternSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Pattern");
  var pattern = (regex, annotations2) => (self2) => {
    const source = regex.source;
    return self2.pipe(filter10((a) => {
      regex.lastIndex = 0;
      return regex.test(a);
    }, {
      schemaId: PatternSchemaId,
      [PatternSchemaId]: {
        regex
      },
      description: `a string matching the pattern ${source}`,
      jsonSchema: {
        pattern: source
      },
      ...annotations2
    }));
  };
  var UUIDSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/UUID");
  var uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;

  class UUID extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ pattern(uuidRegexp, {
    schemaId: UUIDSchemaId,
    identifier: "UUID",
    jsonSchema: {
      format: "uuid",
      pattern: uuidRegexp.source
    },
    description: "a Universally Unique Identifier",
    arbitrary: () => (fc) => fc.uuid()
  }))) {
  }
  var GreaterThanSchemaId2 = GreaterThanSchemaId;
  var greaterThan4 = (exclusiveMinimum, annotations2) => (self2) => self2.pipe(filter10((a) => a > exclusiveMinimum, {
    schemaId: GreaterThanSchemaId2,
    title: `greaterThan(${exclusiveMinimum})`,
    description: exclusiveMinimum === 0 ? "a positive number" : `a number greater than ${exclusiveMinimum}`,
    jsonSchema: {
      exclusiveMinimum
    },
    ...annotations2
  }));
  var IntSchemaId2 = IntSchemaId;
  var int = (annotations2) => (self2) => self2.pipe(filter10((a) => Number.isSafeInteger(a), {
    schemaId: IntSchemaId2,
    title: "int",
    description: "an integer",
    jsonSchema: {
      type: "integer"
    },
    ...annotations2
  }));
  var positive = (annotations2) => greaterThan4(0, {
    title: "positive",
    ...annotations2
  });
  class Int extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ int({
    identifier: "Int"
  }))) {
  }
  var toComposite = (eff, onSuccess, ast, actual) => mapBoth7(eff, {
    onFailure: (e) => new Composite2(ast, actual, e),
    onSuccess
  });
  var DateFromSelfSchemaId2 = DateFromSelfSchemaId;

  class DateFromSelf extends (/* @__PURE__ */ declare(isDate, {
    identifier: "DateFromSelf",
    schemaId: DateFromSelfSchemaId2,
    [DateFromSelfSchemaId2]: {
      noInvalidDate: false
    },
    description: "a potentially invalid Date instance",
    pretty: () => (date) => `new Date(${JSON.stringify(date)})`,
    arbitrary: () => (fc) => fc.date({
      noInvalidDate: false
    }),
    equivalence: () => Date2
  })) {
  }
  var isField = (u) => isSchema(u) || isPropertySignature(u);
  var isFields = (fields) => Reflect.ownKeys(fields).every((key) => isField(fields[key]));
  var getFields = (hasFields) => ("fields" in hasFields) ? hasFields.fields : getFields(hasFields[RefineSchemaId]);
  var getSchemaFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr));
  var getFieldsFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr);
  var getClassTag = (tag) => withConstructorDefault(propertySignature(Literal2(tag)), () => tag);
  var TaggedError2 = (identifier2) => (tag, fieldsOr, annotations2) => {
    class Base3 extends Error3 {
    }
    Base3.prototype.name = tag;
    const fields = getFieldsFromFieldsOr(fieldsOr);
    const schema = getSchemaFromFieldsOr(fieldsOr);
    const newFields = {
      _tag: getClassTag(tag)
    };
    const taggedFields = extendFields(newFields, fields);
    const hasMessageField = "message" in taggedFields;

    class TaggedErrorClass extends makeClass({
      kind: "TaggedError",
      identifier: identifier2 ?? tag,
      schema: extend3(schema, Struct(newFields)),
      fields: taggedFields,
      Base: Base3,
      annotations: annotations2,
      disableToString: true
    }) {
      static _tag = tag;
    }
    if (!hasMessageField) {
      Object.defineProperty(TaggedErrorClass.prototype, "message", {
        get() {
          return `{ ${Reflect.ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} }`;
        },
        enumerable: false,
        configurable: true
      });
    }
    return TaggedErrorClass;
  };
  var extendFields = (a, b) => {
    const out = {
      ...a
    };
    for (const key of Reflect.ownKeys(b)) {
      if (key in a) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage(key));
      }
      out[key] = b[key];
    }
    return out;
  };
  function getDisableValidationMakeOption(options) {
    return isBoolean(options) ? options : options?.disableValidation ?? false;
  }
  var astCache = /* @__PURE__ */ globalValue("effect/Schema/astCache", () => new WeakMap);
  var getClassAnnotations = (annotations2) => {
    if (annotations2 === undefined) {
      return [];
    } else if (Array.isArray(annotations2)) {
      return annotations2;
    } else {
      return [annotations2];
    }
  };
  var makeClass = ({
    Base: Base3,
    annotations: annotations2,
    disableToString,
    fields,
    identifier: identifier2,
    kind,
    schema
  }) => {
    const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier2}`);
    const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations2);
    const typeSchema_ = typeSchema(schema);
    const declarationSurrogate = typeSchema_.annotations({
      identifier: identifier2,
      ...typeAnnotations
    });
    const typeSide = typeSchema_.annotations({
      [AutoTitleAnnotationId]: `${identifier2} (Type side)`,
      ...typeAnnotations
    });
    const constructorSchema = schema.annotations({
      [AutoTitleAnnotationId]: `${identifier2} (Constructor)`,
      ...typeAnnotations
    });
    const encodedSide = schema.annotations({
      [AutoTitleAnnotationId]: `${identifier2} (Encoded side)`,
      ...encodedAnnotations
    });
    const transformationSurrogate = schema.annotations({
      ...encodedAnnotations,
      ...typeAnnotations,
      ...transformationAnnotations
    });
    const fallbackInstanceOf = (u) => hasProperty(u, classSymbol) && is(typeSide)(u);
    const klass = class extends Base3 {
      constructor(props = {}, options = false) {
        props = {
          ...props
        };
        if (kind !== "Class") {
          delete props["_tag"];
        }
        props = lazilyMergeDefaults(fields, props);
        if (!getDisableValidationMakeOption(options)) {
          props = validateSync(constructorSchema)(props);
        }
        super(props, true);
      }
      static [TypeId19] = variance7;
      static get ast() {
        let out = astCache.get(this);
        if (out) {
          return out;
        }
        const declaration = declare([schema], {
          decode: () => (input, _, ast) => input instanceof this || fallbackInstanceOf(input) ? succeed15(input) : fail16(new Type2(ast, input)),
          encode: () => (input, options) => input instanceof this ? succeed15(input) : map22(encodeUnknown(typeSide)(input, options), (props) => new this(props, true))
        }, {
          identifier: identifier2,
          pretty: (pretty4) => (self2) => `${identifier2}(${pretty4(self2)})`,
          arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),
          equivalence: identity,
          [SurrogateAnnotationId]: declarationSurrogate.ast,
          ...typeAnnotations
        });
        out = transform2(encodedSide, declaration, {
          strict: true,
          decode: (i) => new this(i, true),
          encode: identity
        }).annotations({
          [SurrogateAnnotationId]: transformationSurrogate.ast,
          ...transformationAnnotations
        }).ast;
        astCache.set(this, out);
        return out;
      }
      static pipe() {
        return pipeArguments(this, arguments);
      }
      static annotations(annotations3) {
        return make56(this.ast).annotations(annotations3);
      }
      static toString() {
        return `(${String(encodedSide)} <-> ${identifier2})`;
      }
      static make(...args2) {
        return new this(...args2);
      }
      static fields = {
        ...fields
      };
      static identifier = identifier2;
      static extend(identifier3) {
        return (newFieldsOr, annotations3) => {
          const newFields = getFieldsFromFieldsOr(newFieldsOr);
          const newSchema = getSchemaFromFieldsOr(newFieldsOr);
          const extendedFields = extendFields(fields, newFields);
          return makeClass({
            kind,
            identifier: identifier3,
            schema: extend3(schema, newSchema),
            fields: extendedFields,
            Base: this,
            annotations: annotations3
          });
        };
      }
      static transformOrFail(identifier3) {
        return (newFieldsOr, options, annotations3) => {
          const transformedFields = extendFields(fields, newFieldsOr);
          return makeClass({
            kind,
            identifier: identifier3,
            schema: transformOrFail(schema, typeSchema(Struct(transformedFields)), options),
            fields: transformedFields,
            Base: this,
            annotations: annotations3
          });
        };
      }
      static transformOrFailFrom(identifier3) {
        return (newFields, options, annotations3) => {
          const transformedFields = extendFields(fields, newFields);
          return makeClass({
            kind,
            identifier: identifier3,
            schema: transformOrFail(encodedSchema(schema), Struct(transformedFields), options),
            fields: transformedFields,
            Base: this,
            annotations: annotations3
          });
        };
      }
      get [classSymbol]() {
        return classSymbol;
      }
    };
    if (disableToString !== true) {
      Object.defineProperty(klass.prototype, "toString", {
        value() {
          return `${identifier2}({ ${Reflect.ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} })`;
        },
        configurable: true,
        writable: true
      });
    }
    return klass;
  };
  var FiberIdNoneEncoded = /* @__PURE__ */ Struct({
    _tag: Literal2("None")
  }).annotations({
    identifier: "FiberIdNoneEncoded"
  });
  var FiberIdRuntimeEncoded = /* @__PURE__ */ Struct({
    _tag: Literal2("Runtime"),
    id: Int,
    startTimeMillis: Int
  }).annotations({
    identifier: "FiberIdRuntimeEncoded"
  });
  var FiberIdCompositeEncoded = /* @__PURE__ */ Struct({
    _tag: Literal2("Composite"),
    left: suspend11(() => FiberIdEncoded),
    right: suspend11(() => FiberIdEncoded)
  }).annotations({
    identifier: "FiberIdCompositeEncoded"
  });
  var FiberIdEncoded = /* @__PURE__ */ Union2(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
    identifier: "FiberIdEncoded"
  });
  var fiberIdArbitrary = (fc) => fc.letrec((tie) => ({
    None: fc.record({
      _tag: fc.constant("None")
    }),
    Runtime: fc.record({
      _tag: fc.constant("Runtime"),
      id: fc.integer(),
      startTimeMillis: fc.integer()
    }),
    Composite: fc.record({
      _tag: fc.constant("Composite"),
      left: tie("FiberId"),
      right: tie("FiberId")
    }),
    FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
  })).FiberId.map(fiberIdDecode);
  var fiberIdPretty = (fiberId3) => {
    switch (fiberId3._tag) {
      case "None":
        return "FiberId.none";
      case "Runtime":
        return `FiberId.runtime(${fiberId3.id}, ${fiberId3.startTimeMillis})`;
      case "Composite":
        return `FiberId.composite(${fiberIdPretty(fiberId3.right)}, ${fiberIdPretty(fiberId3.left)})`;
    }
  };
  var fiberIdDecode = (input) => {
    switch (input._tag) {
      case "None":
        return none4;
      case "Runtime":
        return runtime2(input.id, input.startTimeMillis);
      case "Composite":
        return composite2(fiberIdDecode(input.left), fiberIdDecode(input.right));
    }
  };
  var causeDieEncoded = (defect) => Struct({
    _tag: Literal2("Die"),
    defect
  });
  var CauseEmptyEncoded = /* @__PURE__ */ Struct({
    _tag: /* @__PURE__ */ Literal2("Empty")
  });
  var causeFailEncoded = (error) => Struct({
    _tag: Literal2("Fail"),
    error
  });
  var CauseInterruptEncoded = /* @__PURE__ */ Struct({
    _tag: /* @__PURE__ */ Literal2("Interrupt"),
    fiberId: FiberIdEncoded
  });
  var causeEncodedId = 0;
  var causeEncoded = (error, defect) => {
    const error_ = asSchema(error);
    const defect_ = asSchema(defect);
    const suspended3 = suspend11(() => out);
    const out = Union2(CauseEmptyEncoded, causeFailEncoded(error_), causeDieEncoded(defect_), CauseInterruptEncoded, Struct({
      _tag: Literal2("Sequential"),
      left: suspended3,
      right: suspended3
    }), Struct({
      _tag: Literal2("Parallel"),
      left: suspended3,
      right: suspended3
    })).annotations({
      title: `CauseEncoded<${format4(error)}>`,
      [JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`
    });
    return out;
  };
  var causeArbitrary = (error, defect) => (fc) => fc.letrec((tie) => ({
    Empty: fc.record({
      _tag: fc.constant("Empty")
    }),
    Fail: fc.record({
      _tag: fc.constant("Fail"),
      error: error(fc)
    }),
    Die: fc.record({
      _tag: fc.constant("Die"),
      defect: defect(fc)
    }),
    Interrupt: fc.record({
      _tag: fc.constant("Interrupt"),
      fiberId: fiberIdArbitrary(fc)
    }),
    Sequential: fc.record({
      _tag: fc.constant("Sequential"),
      left: tie("Cause"),
      right: tie("Cause")
    }),
    Parallel: fc.record({
      _tag: fc.constant("Parallel"),
      left: tie("Cause"),
      right: tie("Cause")
    }),
    Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
  })).Cause.map(causeDecode);
  var causePretty = (error) => (cause3) => {
    const f = (cause4) => {
      switch (cause4._tag) {
        case "Empty":
          return "Cause.empty";
        case "Fail":
          return `Cause.fail(${error(cause4.error)})`;
        case "Die":
          return `Cause.die(${pretty2(cause4)})`;
        case "Interrupt":
          return `Cause.interrupt(${fiberIdPretty(cause4.fiberId)})`;
        case "Sequential":
          return `Cause.sequential(${f(cause4.left)}, ${f(cause4.right)})`;
        case "Parallel":
          return `Cause.parallel(${f(cause4.left)}, ${f(cause4.right)})`;
      }
    };
    return f(cause3);
  };
  var causeParse = (decodeUnknown2) => (u, options, ast) => isCause2(u) ? toComposite(decodeUnknown2(causeEncode(u), options), causeDecode, ast, u) : fail16(new Type2(ast, u));
  var CauseFromSelf = ({
    defect,
    error
  }) => {
    return declare([error, defect], {
      decode: (error2, defect2) => causeParse(decodeUnknown(causeEncoded(error2, defect2))),
      encode: (error2, defect2) => causeParse(encodeUnknown(causeEncoded(error2, defect2)))
    }, {
      title: `Cause<${error.ast}>`,
      pretty: causePretty,
      arbitrary: causeArbitrary
    });
  };
  function causeDecode(cause3) {
    switch (cause3._tag) {
      case "Empty":
        return empty25;
      case "Fail":
        return fail5(cause3.error);
      case "Die":
        return die4(cause3.defect);
      case "Interrupt":
        return interrupt5(fiberIdDecode(cause3.fiberId));
      case "Sequential":
        return sequential4(causeDecode(cause3.left), causeDecode(cause3.right));
      case "Parallel":
        return parallel4(causeDecode(cause3.left), causeDecode(cause3.right));
    }
  }
  function causeEncode(cause3) {
    switch (cause3._tag) {
      case "Empty":
        return {
          _tag: "Empty"
        };
      case "Fail":
        return {
          _tag: "Fail",
          error: cause3.error
        };
      case "Die":
        return {
          _tag: "Die",
          defect: cause3.defect
        };
      case "Interrupt":
        return {
          _tag: "Interrupt",
          fiberId: cause3.fiberId
        };
      case "Sequential":
        return {
          _tag: "Sequential",
          left: causeEncode(cause3.left),
          right: causeEncode(cause3.right)
        };
      case "Parallel":
        return {
          _tag: "Parallel",
          left: causeEncode(cause3.left),
          right: causeEncode(cause3.right)
        };
    }
  }
  var Cause = ({
    defect,
    error
  }) => {
    const error_ = asSchema(error);
    const defect_ = asSchema(defect);
    const out = transform2(causeEncoded(error_, defect_), CauseFromSelf({
      error: typeSchema(error_),
      defect: typeSchema(defect_)
    }), {
      strict: false,
      decode: (i) => causeDecode(i),
      encode: (a) => causeEncode(a)
    });
    return out;
  };

  class Defect extends (/* @__PURE__ */ transform2(Unknown, Unknown, {
    strict: true,
    decode: (i) => {
      if (isObject(i) && "message" in i && typeof i.message === "string") {
        const err = new Error(i.message, {
          cause: i
        });
        if ("name" in i && typeof i.name === "string") {
          err.name = i.name;
        }
        err.stack = "stack" in i && typeof i.stack === "string" ? i.stack : "";
        return err;
      }
      return prettyErrorMessage(i);
    },
    encode: (a) => {
      if (a instanceof Error) {
        return {
          name: a.name,
          message: a.message
        };
      }
      return prettyErrorMessage(a);
    }
  }).annotations({
    identifier: "Defect"
  })) {
  }
  // node_modules/effect/dist/esm/Sink.js
  var drain4 = drain2;
  var foldLeftChunks2 = foldLeftChunks;
  var forEach9 = forEach7;
  var fromChannel3 = fromChannel;
  var unwrapScoped6 = unwrapScoped4;
  // node_modules/effect/dist/esm/Stream.js
  var exports_Stream = {};
  __export(exports_Stream, {
    zipWithPreviousAndNext: () => zipWithPreviousAndNext2,
    zipWithPrevious: () => zipWithPrevious2,
    zipWithNext: () => zipWithNext2,
    zipWithIndex: () => zipWithIndex2,
    zipWithChunks: () => zipWithChunks2,
    zipWith: () => zipWith11,
    zipRight: () => zipRight9,
    zipLeft: () => zipLeft7,
    zipLatestWith: () => zipLatestWith2,
    zipLatestAll: () => zipLatestAll2,
    zipLatest: () => zipLatest2,
    zipFlatten: () => zipFlatten2,
    zipAllWith: () => zipAllWith2,
    zipAllSortedByKeyWith: () => zipAllSortedByKeyWith2,
    zipAllSortedByKeyRight: () => zipAllSortedByKeyRight2,
    zipAllSortedByKeyLeft: () => zipAllSortedByKeyLeft2,
    zipAllSortedByKey: () => zipAllSortedByKey2,
    zipAllRight: () => zipAllRight2,
    zipAllLeft: () => zipAllLeft2,
    zipAll: () => zipAll2,
    zip: () => zip9,
    withSpan: () => withSpan7,
    withExecutionPlan: () => withExecutionPlan4,
    whenEffect: () => whenEffect4,
    whenCaseEffect: () => whenCaseEffect2,
    whenCase: () => whenCase2,
    when: () => when4,
    void: () => void_9,
    updateService: () => updateService6,
    unwrapScopedWith: () => unwrapScopedWith4,
    unwrapScoped: () => unwrapScoped7,
    unwrap: () => unwrap4,
    unfoldEffect: () => unfoldEffect2,
    unfoldChunkEffect: () => unfoldChunkEffect2,
    unfoldChunk: () => unfoldChunk2,
    unfold: () => unfold4,
    transduce: () => transduce2,
    toReadableStreamRuntime: () => toReadableStreamRuntime2,
    toReadableStreamEffect: () => toReadableStreamEffect2,
    toReadableStream: () => toReadableStream2,
    toQueueOfElements: () => toQueueOfElements2,
    toQueue: () => toQueue3,
    toPull: () => toPull3,
    toPubSub: () => toPubSub3,
    toChannel: () => toChannel5,
    toAsyncIterableRuntime: () => toAsyncIterableRuntime2,
    toAsyncIterableEffect: () => toAsyncIterableEffect2,
    toAsyncIterable: () => toAsyncIterable2,
    timeoutTo: () => timeoutTo4,
    timeoutFailCause: () => timeoutFailCause4,
    timeoutFail: () => timeoutFail4,
    timeout: () => timeout4,
    tick: () => tick2,
    throttleEffect: () => throttleEffect2,
    throttle: () => throttle2,
    tapSink: () => tapSink2,
    tapErrorCause: () => tapErrorCause6,
    tapError: () => tapError6,
    tapBoth: () => tapBoth4,
    tap: () => tap7,
    takeWhile: () => takeWhile5,
    takeUntilEffect: () => takeUntilEffect2,
    takeUntil: () => takeUntil4,
    takeRight: () => takeRight3,
    take: () => take9,
    sync: () => sync10,
    suspend: () => suspend12,
    succeed: () => succeed17,
    splitOnChunk: () => splitOnChunk2,
    splitLines: () => splitLines3,
    split: () => split2,
    someOrFail: () => someOrFail2,
    someOrElse: () => someOrElse2,
    some: () => some7,
    slidingSize: () => slidingSize2,
    sliding: () => sliding8,
    share: () => share2,
    scopedWith: () => scopedWith5,
    scoped: () => scoped6,
    scheduleWith: () => scheduleWith2,
    schedule: () => schedule3,
    scanReduceEffect: () => scanReduceEffect2,
    scanReduce: () => scanReduce2,
    scanEffect: () => scanEffect2,
    scan: () => scan2,
    runSum: () => runSum2,
    runScoped: () => runScoped3,
    runLast: () => runLast2,
    runIntoQueueScoped: () => runIntoQueueScoped2,
    runIntoQueueElementsScoped: () => runIntoQueueElementsScoped2,
    runIntoQueue: () => runIntoQueue2,
    runIntoPubSubScoped: () => runIntoPubSubScoped2,
    runIntoPubSub: () => runIntoPubSub2,
    runHead: () => runHead2,
    runForEachWhileScoped: () => runForEachWhileScoped2,
    runForEachWhile: () => runForEachWhile2,
    runForEachScoped: () => runForEachScoped2,
    runForEachChunkScoped: () => runForEachChunkScoped2,
    runForEachChunk: () => runForEachChunk2,
    runForEach: () => runForEach2,
    runFoldWhileScopedEffect: () => runFoldWhileScopedEffect2,
    runFoldWhileScoped: () => runFoldWhileScoped2,
    runFoldWhileEffect: () => runFoldWhileEffect2,
    runFoldWhile: () => runFoldWhile2,
    runFoldScopedEffect: () => runFoldScopedEffect2,
    runFoldScoped: () => runFoldScoped2,
    runFoldEffect: () => runFoldEffect2,
    runFold: () => runFold2,
    runDrain: () => runDrain3,
    runCount: () => runCount2,
    runCollect: () => runCollect3,
    run: () => run4,
    retry: () => retry7,
    repeatWith: () => repeatWith2,
    repeatValue: () => repeatValue2,
    repeatElementsWith: () => repeatElementsWith2,
    repeatElements: () => repeatElements2,
    repeatEither: () => repeatEither2,
    repeatEffectWithSchedule: () => repeatEffectWithSchedule2,
    repeatEffectOption: () => repeatEffectOption2,
    repeatEffectChunkOption: () => repeatEffectChunkOption2,
    repeatEffectChunk: () => repeatEffectChunk2,
    repeatEffect: () => repeatEffect2,
    repeat: () => repeat3,
    refineOrDieWith: () => refineOrDieWith3,
    refineOrDie: () => refineOrDie3,
    rechunk: () => rechunk2,
    range: () => range3,
    raceAll: () => raceAll4,
    race: () => race5,
    provideSomeLayer: () => provideSomeLayer4,
    provideSomeContext: () => provideSomeContext3,
    provideServiceStream: () => provideServiceStream2,
    provideServiceEffect: () => provideServiceEffect4,
    provideService: () => provideService7,
    provideLayer: () => provideLayer3,
    provideContext: () => provideContext7,
    prepend: () => prepend5,
    pipeThroughChannelOrFail: () => pipeThroughChannelOrFail2,
    pipeThroughChannel: () => pipeThroughChannel2,
    pipeThrough: () => pipeThrough2,
    peel: () => peel2,
    partitionEither: () => partitionEither2,
    partition: () => partition6,
    paginateEffect: () => paginateEffect2,
    paginateChunkEffect: () => paginateChunkEffect2,
    paginateChunk: () => paginateChunk2,
    paginate: () => paginate2,
    orElseSucceed: () => orElseSucceed4,
    orElseIfEmptyStream: () => orElseIfEmptyStream2,
    orElseIfEmptyChunk: () => orElseIfEmptyChunk2,
    orElseIfEmpty: () => orElseIfEmpty2,
    orElseFail: () => orElseFail4,
    orElseEither: () => orElseEither4,
    orElse: () => orElse11,
    orDieWith: () => orDieWith5,
    orDie: () => orDie7,
    onStart: () => onStart2,
    onError: () => onError4,
    onEnd: () => onEnd2,
    onDone: () => onDone2,
    never: () => never7,
    mkString: () => mkString3,
    mergeWithTag: () => mergeWithTag2,
    mergeWith: () => mergeWith4,
    mergeRight: () => mergeRight2,
    mergeLeft: () => mergeLeft2,
    mergeEither: () => mergeEither2,
    mergeAll: () => mergeAll9,
    merge: () => merge10,
    mapInputContext: () => mapInputContext7,
    mapErrorCause: () => mapErrorCause5,
    mapError: () => mapError9,
    mapEffect: () => mapEffect5,
    mapConcatEffect: () => mapConcatEffect2,
    mapConcatChunkEffect: () => mapConcatChunkEffect2,
    mapConcatChunk: () => mapConcatChunk2,
    mapConcat: () => mapConcat2,
    mapChunksEffect: () => mapChunksEffect2,
    mapChunks: () => mapChunks2,
    mapBoth: () => mapBoth8,
    mapAccumEffect: () => mapAccumEffect2,
    mapAccum: () => mapAccum6,
    map: () => map23,
    make: () => make57,
    let: () => let_5,
    iterate: () => iterate4,
    intersperseAffixes: () => intersperseAffixes2,
    intersperse: () => intersperse2,
    interruptWhenDeferred: () => interruptWhenDeferred3,
    interruptWhen: () => interruptWhen3,
    interruptAfter: () => interruptAfter2,
    interleaveWith: () => interleaveWith2,
    interleave: () => interleave2,
    identity: () => identity3,
    haltWhenDeferred: () => haltWhenDeferred2,
    haltWhen: () => haltWhen2,
    haltAfter: () => haltAfter2,
    groupedWithin: () => groupedWithin2,
    grouped: () => grouped2,
    groupByKey: () => groupByKey2,
    groupBy: () => groupBy2,
    groupAdjacentBy: () => groupAdjacentBy2,
    fromTQueue: () => fromTQueue2,
    fromTPubSub: () => fromTPubSub2,
    fromSchedule: () => fromSchedule2,
    fromReadableStreamByob: () => fromReadableStreamByob2,
    fromReadableStream: () => fromReadableStream2,
    fromQueue: () => fromQueue4,
    fromPull: () => fromPull3,
    fromPubSub: () => fromPubSub4,
    fromIteratorSucceed: () => fromIteratorSucceed2,
    fromIterableEffect: () => fromIterableEffect2,
    fromIterable: () => fromIterable10,
    fromEventListener: () => fromEventListener2,
    fromEffectOption: () => fromEffectOption2,
    fromEffect: () => fromEffect9,
    fromChunks: () => fromChunks2,
    fromChunkQueue: () => fromChunkQueue2,
    fromChunkPubSub: () => fromChunkPubSub2,
    fromChunk: () => fromChunk2,
    fromChannel: () => fromChannel4,
    fromAsyncIterable: () => fromAsyncIterable2,
    forever: () => forever6,
    flattenTake: () => flattenTake2,
    flattenIterables: () => flattenIterables2,
    flattenExitOption: () => flattenExitOption2,
    flattenEffect: () => flattenEffect2,
    flattenChunks: () => flattenChunks2,
    flatten: () => flatten14,
    flatMap: () => flatMap19,
    findEffect: () => findEffect3,
    find: () => find3,
    finalizer: () => finalizer2,
    filterMapWhileEffect: () => filterMapWhileEffect2,
    filterMapWhile: () => filterMapWhile4,
    filterMapEffect: () => filterMapEffect2,
    filterMap: () => filterMap8,
    filterEffect: () => filterEffect2,
    filter: () => filter11,
    failSync: () => failSync9,
    failCauseSync: () => failCauseSync8,
    failCause: () => failCause15,
    fail: () => fail17,
    execute: () => execute2,
    ensuringWith: () => ensuringWith4,
    ensuring: () => ensuring9,
    encodeText: () => encodeText2,
    empty: () => empty33,
    either: () => either6,
    dropWhileEffect: () => dropWhileEffect3,
    dropWhile: () => dropWhile6,
    dropUntilEffect: () => dropUntilEffect3,
    dropUntil: () => dropUntil5,
    dropRight: () => dropRight2,
    drop: () => drop5,
    drainFork: () => drainFork2,
    drain: () => drain5,
    distributedWithDynamic: () => distributedWithDynamic2,
    distributedWith: () => distributedWith2,
    dieSync: () => dieSync8,
    dieMessage: () => dieMessage6,
    die: () => die12,
    decodeText: () => decodeText2,
    debounce: () => debounce2,
    crossWith: () => crossWith2,
    crossRight: () => crossRight2,
    crossLeft: () => crossLeft2,
    cross: () => cross2,
    contextWithStream: () => contextWithStream2,
    contextWithEffect: () => contextWithEffect6,
    contextWith: () => contextWith6,
    context: () => context8,
    concatAll: () => concatAll3,
    concat: () => concat3,
    combineChunks: () => combineChunks2,
    combine: () => combine10,
    chunksWith: () => chunksWith2,
    chunks: () => chunks2,
    changesWithEffect: () => changesWithEffect2,
    changesWith: () => changesWith2,
    changes: () => changes2,
    catchTags: () => catchTags4,
    catchTag: () => catchTag4,
    catchSomeCause: () => catchSomeCause4,
    catchSome: () => catchSome4,
    catchAllCause: () => catchAllCause7,
    catchAll: () => catchAll8,
    bufferChunks: () => bufferChunks2,
    buffer: () => buffer3,
    broadcastedQueuesDynamic: () => broadcastedQueuesDynamic2,
    broadcastedQueues: () => broadcastedQueues2,
    broadcastDynamic: () => broadcastDynamic2,
    broadcast: () => broadcast2,
    branchAfter: () => branchAfter2,
    bindTo: () => bindTo5,
    bindEffect: () => bindEffect2,
    bind: () => bind5,
    asyncScoped: () => asyncScoped2,
    asyncPush: () => asyncPush2,
    asyncEffect: () => asyncEffect4,
    async: () => _async2,
    as: () => as9,
    aggregateWithinEither: () => aggregateWithinEither2,
    aggregateWithin: () => aggregateWithin2,
    aggregate: () => aggregate2,
    acquireRelease: () => acquireRelease4,
    accumulateChunks: () => accumulateChunks2,
    accumulate: () => accumulate2,
    StreamTypeId: () => StreamTypeId3,
    Do: () => Do4,
    DefaultChunkSize: () => DefaultChunkSize2
  });
  var StreamTypeId3 = StreamTypeId2;
  var DefaultChunkSize2 = DefaultChunkSize;
  var accumulate2 = accumulate;
  var accumulateChunks2 = accumulateChunks;
  var acquireRelease4 = acquireRelease3;
  var aggregate2 = aggregate;
  var aggregateWithin2 = aggregateWithin;
  var aggregateWithinEither2 = aggregateWithinEither;
  var as9 = as7;
  var _async2 = _async;
  var asyncEffect4 = asyncEffect3;
  var asyncPush2 = asyncPush;
  var asyncScoped2 = asyncScoped;
  var branchAfter2 = branchAfter;
  var broadcast2 = broadcast;
  var share2 = share;
  var broadcastDynamic2 = broadcastDynamic;
  var broadcastedQueues2 = broadcastedQueues;
  var broadcastedQueuesDynamic2 = broadcastedQueuesDynamic;
  var buffer3 = buffer;
  var bufferChunks2 = bufferChunks;
  var catchAll8 = catchAll7;
  var catchAllCause7 = catchAllCause6;
  var catchSome4 = catchSome3;
  var catchTag4 = catchTag3;
  var catchTags4 = catchTags3;
  var catchSomeCause4 = catchSomeCause3;
  var changes2 = changes;
  var changesWith2 = changesWith;
  var changesWithEffect2 = changesWithEffect;
  var chunks2 = chunks;
  var chunksWith2 = chunksWith;
  var combine10 = combine9;
  var combineChunks2 = combineChunks;
  var concat3 = concat2;
  var concatAll3 = concatAll2;
  var cross2 = cross;
  var crossLeft2 = crossLeft;
  var crossRight2 = crossRight;
  var crossWith2 = crossWith;
  var debounce2 = debounce;
  var die12 = die10;
  var dieSync8 = dieSync6;
  var dieMessage6 = dieMessage4;
  var distributedWith2 = distributedWith;
  var distributedWithDynamic2 = distributedWithDynamic;
  var drain5 = drain3;
  var drainFork2 = drainFork;
  var drop5 = drop3;
  var dropRight2 = dropRight;
  var dropUntil5 = dropUntil3;
  var dropUntilEffect3 = dropUntilEffect;
  var dropWhile6 = dropWhile4;
  var dropWhileEffect3 = dropWhileEffect;
  var either6 = either5;
  var empty33 = empty31;
  var ensuring9 = ensuring6;
  var ensuringWith4 = ensuringWith2;
  var context8 = context5;
  var contextWith6 = contextWith3;
  var contextWithEffect6 = contextWithEffect3;
  var contextWithStream2 = contextWithStream;
  var execute2 = execute;
  var fail17 = fail15;
  var failSync9 = failSync7;
  var failCause15 = failCause13;
  var failCauseSync8 = failCauseSync6;
  var filter11 = filter9;
  var filterEffect2 = filterEffect;
  var filterMap8 = filterMap7;
  var filterMapEffect2 = filterMapEffect;
  var filterMapWhile4 = filterMapWhile3;
  var filterMapWhileEffect2 = filterMapWhileEffect;
  var finalizer2 = finalizer;
  var find3 = find2;
  var findEffect3 = findEffect;
  var flatMap19 = flatMap16;
  var flatten14 = flatten13;
  var flattenChunks2 = flattenChunks;
  var flattenEffect2 = flattenEffect;
  var flattenExitOption2 = flattenExitOption;
  var flattenIterables2 = flattenIterables;
  var flattenTake2 = flattenTake;
  var forever6 = forever5;
  var fromAsyncIterable2 = fromAsyncIterable;
  var fromChannel4 = fromChannel2;
  var toChannel5 = toChannel2;
  var fromChunk2 = fromChunk;
  var fromChunkPubSub2 = fromChunkPubSub;
  var fromChunkQueue2 = fromChunkQueue;
  var fromChunks2 = fromChunks;
  var fromEffect9 = fromEffect7;
  var fromEffectOption2 = fromEffectOption;
  var fromPubSub4 = fromPubSub;
  var fromTPubSub2 = fromTPubSub;
  var fromIterable10 = fromIterable9;
  var fromIterableEffect2 = fromIterableEffect;
  var fromIteratorSucceed2 = fromIteratorSucceed;
  var fromPull3 = fromPull2;
  var fromQueue4 = fromQueue2;
  var fromTQueue2 = fromTQueue;
  var fromReadableStream2 = fromReadableStream;
  var fromReadableStreamByob2 = fromReadableStreamByob;
  var fromSchedule2 = fromSchedule;
  var groupAdjacentBy2 = groupAdjacentBy;
  var groupBy2 = groupBy;
  var groupByKey2 = groupByKey;
  var grouped2 = grouped;
  var groupedWithin2 = groupedWithin;
  var haltAfter2 = haltAfter;
  var haltWhen2 = haltWhen;
  var haltWhenDeferred2 = haltWhenDeferred;
  var identity3 = identityStream;
  var interleave2 = interleave;
  var interleaveWith2 = interleaveWith;
  var intersperse2 = intersperse;
  var intersperseAffixes2 = intersperseAffixes;
  var interruptAfter2 = interruptAfter;
  var interruptWhen3 = interruptWhen2;
  var interruptWhenDeferred3 = interruptWhenDeferred2;
  var iterate4 = iterate3;
  var make57 = make51;
  var map23 = map21;
  var mapAccum6 = mapAccum5;
  var mapAccumEffect2 = mapAccumEffect;
  var mapBoth8 = mapBoth6;
  var mapChunks2 = mapChunks;
  var mapChunksEffect2 = mapChunksEffect;
  var mapConcat2 = mapConcat;
  var mapConcatChunk2 = mapConcatChunk;
  var mapConcatChunkEffect2 = mapConcatChunkEffect;
  var mapConcatEffect2 = mapConcatEffect;
  var mapEffect5 = mapEffectOptions;
  var mapError9 = mapError6;
  var mapErrorCause5 = mapErrorCause4;
  var merge10 = merge9;
  var mergeAll9 = mergeAll8;
  var mergeWithTag2 = mergeWithTag;
  var mergeWith4 = mergeWith3;
  var mergeEither2 = mergeEither;
  var mergeLeft2 = mergeLeft;
  var mergeRight2 = mergeRight;
  var mkString3 = mkString2;
  var never7 = never4;
  var onEnd2 = onEnd;
  var onError4 = onError3;
  var onDone2 = onDone;
  var onStart2 = onStart;
  var orDie7 = orDie5;
  var orDieWith5 = orDieWith4;
  var orElse11 = orElse8;
  var orElseEither4 = orElseEither3;
  var orElseFail4 = orElseFail3;
  var orElseIfEmpty2 = orElseIfEmpty;
  var orElseIfEmptyChunk2 = orElseIfEmptyChunk;
  var orElseIfEmptyStream2 = orElseIfEmptyStream;
  var orElseSucceed4 = orElseSucceed3;
  var paginate2 = paginate;
  var paginateChunk2 = paginateChunk;
  var paginateChunkEffect2 = paginateChunkEffect;
  var paginateEffect2 = paginateEffect;
  var partition6 = partition5;
  var partitionEither2 = partitionEither;
  var peel2 = peel;
  var pipeThrough2 = pipeThrough;
  var pipeThroughChannel2 = pipeThroughChannel;
  var pipeThroughChannelOrFail2 = pipeThroughChannelOrFail;
  var prepend5 = prepend4;
  var provideContext7 = provideContext5;
  var provideSomeContext3 = provideSomeContext2;
  var provideLayer3 = provideLayer;
  var provideService7 = provideService5;
  var provideServiceEffect4 = provideServiceEffect3;
  var provideServiceStream2 = provideServiceStream;
  var mapInputContext7 = mapInputContext5;
  var provideSomeLayer4 = provideSomeLayer2;
  var race5 = race3;
  var raceAll4 = raceAll3;
  var range3 = range2;
  var rechunk2 = rechunk;
  var refineOrDie3 = refineOrDie;
  var refineOrDieWith3 = refineOrDieWith;
  var repeat3 = repeat2;
  var repeatEffect2 = repeatEffect;
  var repeatEffectChunk2 = repeatEffectChunk;
  var repeatEffectChunkOption2 = repeatEffectChunkOption;
  var repeatEffectOption2 = repeatEffectOption;
  var repeatEffectWithSchedule2 = repeatEffectWithSchedule;
  var repeatEither2 = repeatEither;
  var repeatElements2 = repeatElements;
  var repeatElementsWith2 = repeatElementsWith;
  var repeatValue2 = repeatValue;
  var repeatWith2 = repeatWith;
  var retry7 = retry6;
  var withExecutionPlan4 = withExecutionPlan3;
  var run4 = run3;
  var runCollect3 = runCollect;
  var runCount2 = runCount;
  var runDrain3 = runDrain2;
  var runFold2 = runFold;
  var runFoldEffect2 = runFoldEffect;
  var runFoldScoped2 = runFoldScoped;
  var runFoldScopedEffect2 = runFoldScopedEffect;
  var runFoldWhile2 = runFoldWhile;
  var runFoldWhileEffect2 = runFoldWhileEffect;
  var runFoldWhileScoped2 = runFoldWhileScoped;
  var runFoldWhileScopedEffect2 = runFoldWhileScopedEffect;
  var runForEach2 = runForEach;
  var runForEachChunk2 = runForEachChunk;
  var runForEachChunkScoped2 = runForEachChunkScoped;
  var runForEachScoped2 = runForEachScoped;
  var runForEachWhile2 = runForEachWhile;
  var runForEachWhileScoped2 = runForEachWhileScoped;
  var runHead2 = runHead;
  var runIntoPubSub2 = runIntoPubSub;
  var runIntoPubSubScoped2 = runIntoPubSubScoped;
  var runIntoQueue2 = runIntoQueue;
  var runIntoQueueElementsScoped2 = runIntoQueueElementsScoped;
  var runIntoQueueScoped2 = runIntoQueueScoped;
  var runLast2 = runLast;
  var runScoped3 = runScoped2;
  var runSum2 = runSum;
  var scan2 = scan;
  var scanEffect2 = scanEffect;
  var scanReduce2 = scanReduce;
  var scanReduceEffect2 = scanReduceEffect;
  var schedule3 = schedule2;
  var scheduleWith2 = scheduleWith;
  var scoped6 = scoped5;
  var scopedWith5 = scopedWith4;
  var sliding8 = sliding7;
  var slidingSize2 = slidingSize;
  var some7 = some5;
  var someOrElse2 = someOrElse;
  var someOrFail2 = someOrFail;
  var split2 = split;
  var splitOnChunk2 = splitOnChunk;
  var splitLines3 = splitLines2;
  var succeed17 = succeed14;
  var sync10 = sync8;
  var suspend12 = suspend9;
  var take9 = take7;
  var takeRight3 = takeRight2;
  var takeUntil4 = takeUntil3;
  var takeUntilEffect2 = takeUntilEffect;
  var takeWhile5 = takeWhile4;
  var tap7 = tap6;
  var tapBoth4 = tapBoth3;
  var tapError6 = tapError5;
  var tapErrorCause6 = tapErrorCause5;
  var tapSink2 = tapSink;
  var throttle2 = throttle;
  var throttleEffect2 = throttleEffect;
  var tick2 = tick;
  var timeout4 = timeout3;
  var timeoutFail4 = timeoutFail3;
  var timeoutFailCause4 = timeoutFailCause3;
  var timeoutTo4 = timeoutTo3;
  var toPubSub3 = toPubSub2;
  var toPull3 = toPull2;
  var toQueue3 = toQueue2;
  var toQueueOfElements2 = toQueueOfElements;
  var toReadableStream2 = toReadableStream;
  var toReadableStreamEffect2 = toReadableStreamEffect;
  var toReadableStreamRuntime2 = toReadableStreamRuntime;
  var toAsyncIterableRuntime2 = toAsyncIterableRuntime;
  var toAsyncIterableEffect2 = toAsyncIterableEffect;
  var toAsyncIterable2 = toAsyncIterable;
  var transduce2 = transduce;
  var unfold4 = unfold3;
  var unfoldChunk2 = unfoldChunk;
  var unfoldChunkEffect2 = unfoldChunkEffect;
  var unfoldEffect2 = unfoldEffect;
  var void_9 = void_7;
  var unwrap4 = unwrap2;
  var unwrapScoped7 = unwrapScoped5;
  var unwrapScopedWith4 = unwrapScopedWith3;
  var updateService6 = updateService4;
  var when4 = when3;
  var whenCase2 = whenCase;
  var whenCaseEffect2 = whenCaseEffect;
  var whenEffect4 = whenEffect3;
  var withSpan7 = withSpan6;
  var zip9 = zip7;
  var zipFlatten2 = zipFlatten;
  var zipAll2 = zipAll;
  var zipAllLeft2 = zipAllLeft;
  var zipAllRight2 = zipAllRight;
  var zipAllSortedByKey2 = zipAllSortedByKey;
  var zipAllSortedByKeyLeft2 = zipAllSortedByKeyLeft;
  var zipAllSortedByKeyRight2 = zipAllSortedByKeyRight;
  var zipAllSortedByKeyWith2 = zipAllSortedByKeyWith;
  var zipAllWith2 = zipAllWith;
  var zipLatest2 = zipLatest;
  var zipLatestAll2 = zipLatestAll;
  var zipLatestWith2 = zipLatestWith;
  var zipLeft7 = zipLeft5;
  var zipRight9 = zipRight8;
  var zipWith11 = zipWith10;
  var zipWithChunks2 = zipWithChunks;
  var zipWithNext2 = zipWithNext;
  var zipWithPrevious2 = zipWithPrevious;
  var zipWithPreviousAndNext2 = zipWithPreviousAndNext;
  var zipWithIndex2 = zipWithIndex;
  var Do4 = Do3;
  var bind5 = bind4;
  var bindEffect2 = bindEffect;
  var bindTo5 = bindTo4;
  var let_5 = let_4;
  var decodeText2 = decodeText;
  var encodeText2 = encodeText;
  var fromEventListener2 = fromEventListener;
  // node_modules/@effect/platform/dist/esm/Error.js
  var TypeId20 = /* @__PURE__ */ Symbol.for("@effect/platform/Error");
  var Module = /* @__PURE__ */ Literal2("Clipboard", "Command", "FileSystem", "KeyValueStore", "Path", "Stream", "Terminal");

  class BadArgument extends (/* @__PURE__ */ TaggedError2("@effect/platform/Error/BadArgument")("BadArgument", {
    module: Module,
    method: String$,
    description: /* @__PURE__ */ optional(String$),
    cause: /* @__PURE__ */ optional(Defect)
  })) {
    [TypeId20] = TypeId20;
    get message() {
      return `${this.module}.${this.method}${this.description ? `: ${this.description}` : ""}`;
    }
  }
  var SystemErrorReason = /* @__PURE__ */ Literal2("AlreadyExists", "BadResource", "Busy", "InvalidData", "NotFound", "PermissionDenied", "TimedOut", "UnexpectedEof", "Unknown", "WouldBlock", "WriteZero");

  class SystemError extends (/* @__PURE__ */ TaggedError2("@effect/platform/Error/SystemError")("SystemError", {
    reason: SystemErrorReason,
    module: Module,
    method: String$,
    description: /* @__PURE__ */ optional(String$),
    syscall: /* @__PURE__ */ optional(String$),
    pathOrDescriptor: /* @__PURE__ */ optional(/* @__PURE__ */ Union2(String$, Number$)),
    cause: /* @__PURE__ */ optional(Defect)
  })) {
    [TypeId20] = TypeId20;
    get message() {
      return `${this.reason}: ${this.module}.${this.method}${this.pathOrDescriptor !== undefined ? ` (${this.pathOrDescriptor})` : ""}${this.description ? `: ${this.description}` : ""}`;
    }
  }

  // node_modules/@effect/platform/dist/esm/internal/fileSystem.js
  var tag = /* @__PURE__ */ GenericTag("@effect/platform/FileSystem");
  var Size = (bytes) => typeof bytes === "bigint" ? bytes : BigInt(bytes);
  var bigint1024 = /* @__PURE__ */ BigInt(1024);
  var bigintPiB = bigint1024 * bigint1024 * bigint1024 * bigint1024 * bigint1024;
  var make58 = (impl) => {
    return tag.of({
      ...impl,
      exists: (path) => pipe(impl.access(path), as3(true), catchTag2("SystemError", (e) => e.reason === "NotFound" ? succeed8(false) : fail9(e))),
      readFileString: (path, encoding) => tryMap2(impl.readFile(path), {
        try: (_) => new TextDecoder(encoding).decode(_),
        catch: (cause3) => new BadArgument({
          module: "FileSystem",
          method: "readFileString",
          description: "invalid encoding",
          cause: cause3
        })
      }),
      stream: (path, options) => pipe(impl.open(path, {
        flag: "r"
      }), options?.offset ? tap3((file) => file.seek(options.offset, "start")) : identity, map16((file) => stream(file, options)), unwrapScoped7),
      sink: (path, options) => pipe(impl.open(path, {
        flag: "w",
        ...options
      }), map16((file) => forEach9((_) => file.writeAll(_))), unwrapScoped6),
      writeFileString: (path, data, options) => flatMap11(try_2({
        try: () => new TextEncoder().encode(data),
        catch: (cause3) => new BadArgument({
          module: "FileSystem",
          method: "writeFileString",
          description: "could not encode string",
          cause: cause3
        })
      }), (_) => impl.writeFile(path, _, options))
    });
  };
  var stream = (file, {
    bufferSize = 16,
    bytesToRead: bytesToRead_,
    chunkSize: chunkSize_ = Size(64 * 1024)
  } = {}) => {
    const bytesToRead = bytesToRead_ !== undefined ? Size(bytesToRead_) : undefined;
    const chunkSize = Size(chunkSize_);
    function loop3(totalBytesRead) {
      if (bytesToRead !== undefined && bytesToRead <= totalBytesRead) {
        return void_8;
      }
      const toRead = bytesToRead !== undefined && bytesToRead - totalBytesRead < chunkSize ? bytesToRead - totalBytesRead : chunkSize;
      return flatMap17(file.readAlloc(toRead), match2({
        onNone: () => void_8,
        onSome: (buf) => flatMap17(write2(of2(buf)), (_) => loop3(totalBytesRead + BigInt(buf.length)))
      }));
    }
    return bufferChunks2(fromChannel4(loop3(BigInt(0))), {
      capacity: bufferSize
    });
  };

  // node_modules/@effect/platform/dist/esm/FileSystem.js
  var Size2 = Size;
  var FileSystem = tag;
  var make59 = make58;
  var FileTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/FileSystem/File");
  var FileDescriptor = /* @__PURE__ */ nominal();
  var WatchEventCreate = /* @__PURE__ */ tagged2("Create");
  var WatchEventUpdate = /* @__PURE__ */ tagged2("Update");
  var WatchEventRemove = /* @__PURE__ */ tagged2("Remove");

  class WatchBackend extends (/* @__PURE__ */ Tag2("@effect/platform/FileSystem/WatchBackend")()) {
  }

  // node_modules/@effect/platform/dist/esm/internal/path.js
  var TypeId21 = /* @__PURE__ */ Symbol.for("@effect/platform/Path");
  var Path = /* @__PURE__ */ GenericTag("@effect/platform/Path");
  function normalizeStringPosix(path, allowAboveRoot) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for (let i = 0;i <= path.length; ++i) {
      if (i < path.length) {
        code = path.charCodeAt(i);
      } else if (code === 47) {
        break;
      } else {
        code = 47;
      }
      if (code === 47) {
        if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              const lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) {
            res += "/" + path.slice(lastSlash + 1, i);
          } else {
            res = path.slice(lastSlash + 1, i);
          }
          lastSegmentLength = i - lastSlash - 1;
        }
        lastSlash = i;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep + base;
  }
  function fromFileUrl(url) {
    if (url.protocol !== "file:") {
      return fail9(new BadArgument({
        module: "Path",
        method: "fromFileUrl",
        description: "URL must be of scheme file"
      }));
    } else if (url.hostname !== "") {
      return fail9(new BadArgument({
        module: "Path",
        method: "fromFileUrl",
        description: "Invalid file URL host"
      }));
    }
    const pathname = url.pathname;
    for (let n = 0;n < pathname.length; n++) {
      if (pathname[n] === "%") {
        const third = pathname.codePointAt(n + 2) | 32;
        if (pathname[n + 1] === "2" && third === 102) {
          return fail9(new BadArgument({
            module: "Path",
            method: "fromFileUrl",
            description: "must not include encoded / characters"
          }));
        }
      }
    }
    return succeed8(decodeURIComponent(pathname));
  }
  var resolve = function resolve2() {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    let cwd = undefined;
    for (let i = arguments.length - 1;i >= -1 && !resolvedAbsolute; i--) {
      let path;
      if (i >= 0) {
        path = arguments[i];
      } else {
        const process2 = globalThis.process;
        if (cwd === undefined && "process" in globalThis && typeof process2 === "object" && process2 !== null && typeof process2.cwd === "function") {
          cwd = process2.cwd();
        }
        path = cwd;
      }
      if (path.length === 0) {
        continue;
      }
      resolvedPath = path + "/" + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47;
    }
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
    if (resolvedAbsolute) {
      if (resolvedPath.length > 0) {
        return "/" + resolvedPath;
      } else {
        return "/";
      }
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return ".";
    }
  };
  var CHAR_FORWARD_SLASH = 47;
  function toFileUrl(filepath) {
    const outURL = new URL("file://");
    let resolved = resolve(filepath);
    const filePathLast = filepath.charCodeAt(filepath.length - 1);
    if (filePathLast === CHAR_FORWARD_SLASH && resolved[resolved.length - 1] !== "/") {
      resolved += "/";
    }
    outURL.pathname = encodePathChars(resolved);
    return succeed8(outURL);
  }
  var percentRegEx = /%/g;
  var backslashRegEx = /\\/g;
  var newlineRegEx = /\n/g;
  var carriageReturnRegEx = /\r/g;
  var tabRegEx = /\t/g;
  function encodePathChars(filepath) {
    if (filepath.includes("%")) {
      filepath = filepath.replace(percentRegEx, "%25");
    }
    if (filepath.includes("\\")) {
      filepath = filepath.replace(backslashRegEx, "%5C");
    }
    if (filepath.includes(`
`)) {
      filepath = filepath.replace(newlineRegEx, "%0A");
    }
    if (filepath.includes("\r")) {
      filepath = filepath.replace(carriageReturnRegEx, "%0D");
    }
    if (filepath.includes("\t")) {
      filepath = filepath.replace(tabRegEx, "%09");
    }
    return filepath;
  }
  var posixImpl = /* @__PURE__ */ Path.of({
    [TypeId21]: TypeId21,
    resolve,
    normalize(path) {
      if (path.length === 0)
        return ".";
      const isAbsolute = path.charCodeAt(0) === 47;
      const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
      path = normalizeStringPosix(path, !isAbsolute);
      if (path.length === 0 && !isAbsolute)
        path = ".";
      if (path.length > 0 && trailingSeparator)
        path += "/";
      if (isAbsolute)
        return "/" + path;
      return path;
    },
    isAbsolute(path) {
      return path.length > 0 && path.charCodeAt(0) === 47;
    },
    join() {
      if (arguments.length === 0) {
        return ".";
      }
      let joined;
      for (let i = 0;i < arguments.length; ++i) {
        const arg = arguments[i];
        if (arg.length > 0) {
          if (joined === undefined) {
            joined = arg;
          } else {
            joined += "/" + arg;
          }
        }
      }
      if (joined === undefined) {
        return ".";
      }
      return posixImpl.normalize(joined);
    },
    relative(from, to) {
      if (from === to)
        return "";
      from = posixImpl.resolve(from);
      to = posixImpl.resolve(to);
      if (from === to)
        return "";
      let fromStart = 1;
      for (;fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47) {
          break;
        }
      }
      const fromEnd = from.length;
      const fromLen = fromEnd - fromStart;
      let toStart = 1;
      for (;toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47) {
          break;
        }
      }
      const toEnd = to.length;
      const toLen = toEnd - toStart;
      const length3 = fromLen < toLen ? fromLen : toLen;
      let lastCommonSep = -1;
      let i = 0;
      for (;i <= length3; ++i) {
        if (i === length3) {
          if (toLen > length3) {
            if (to.charCodeAt(toStart + i) === 47) {
              return to.slice(toStart + i + 1);
            } else if (i === 0) {
              return to.slice(toStart + i);
            }
          } else if (fromLen > length3) {
            if (from.charCodeAt(fromStart + i) === 47) {
              lastCommonSep = i;
            } else if (i === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) {
          break;
        } else if (fromCode === 47) {
          lastCommonSep = i;
        }
      }
      let out = "";
      for (i = fromStart + lastCommonSep + 1;i <= fromEnd; ++i) {
        if (i === fromEnd || from.charCodeAt(i) === 47) {
          if (out.length === 0) {
            out += "..";
          } else {
            out += "/..";
          }
        }
      }
      if (out.length > 0) {
        return out + to.slice(toStart + lastCommonSep);
      } else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) {
          ++toStart;
        }
        return to.slice(toStart);
      }
    },
    dirname(path) {
      if (path.length === 0)
        return ".";
      let code = path.charCodeAt(0);
      const hasRoot = code === 47;
      let end6 = -1;
      let matchedSlash = true;
      for (let i = path.length - 1;i >= 1; --i) {
        code = path.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            end6 = i;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end6 === -1)
        return hasRoot ? "/" : ".";
      if (hasRoot && end6 === 1)
        return "//";
      return path.slice(0, end6);
    },
    basename(path, ext) {
      let start3 = 0;
      let end6 = -1;
      let matchedSlash = true;
      let i;
      if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path)
          return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for (i = path.length - 1;i >= 0; --i) {
          const code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              start3 = i + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end6 = i;
                }
              } else {
                extIdx = -1;
                end6 = firstNonSlashEnd;
              }
            }
          }
        }
        if (start3 === end6)
          end6 = firstNonSlashEnd;
        else if (end6 === -1)
          end6 = path.length;
        return path.slice(start3, end6);
      } else {
        for (i = path.length - 1;i >= 0; --i) {
          if (path.charCodeAt(i) === 47) {
            if (!matchedSlash) {
              start3 = i + 1;
              break;
            }
          } else if (end6 === -1) {
            matchedSlash = false;
            end6 = i + 1;
          }
        }
        if (end6 === -1)
          return "";
        return path.slice(start3, end6);
      }
    },
    extname(path) {
      let startDot = -1;
      let startPart = 0;
      let end6 = -1;
      let matchedSlash = true;
      let preDotState = 0;
      for (let i = path.length - 1;i >= 0; --i) {
        const code = path.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end6 === -1) {
          matchedSlash = false;
          end6 = i + 1;
        }
        if (code === 46) {
          if (startDot === -1) {
            startDot = i;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end6 === -1 || preDotState === 0 || preDotState === 1 && startDot === end6 - 1 && startDot === startPart + 1) {
        return "";
      }
      return path.slice(startDot, end6);
    },
    format: function format5(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse(path) {
      const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path.length === 0)
        return ret;
      let code = path.charCodeAt(0);
      const isAbsolute = code === 47;
      let start3;
      if (isAbsolute) {
        ret.root = "/";
        start3 = 1;
      } else {
        start3 = 0;
      }
      let startDot = -1;
      let startPart = 0;
      let end6 = -1;
      let matchedSlash = true;
      let i = path.length - 1;
      let preDotState = 0;
      for (;i >= start3; --i) {
        code = path.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
        if (end6 === -1) {
          matchedSlash = false;
          end6 = i + 1;
        }
        if (code === 46) {
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end6 === -1 || preDotState === 0 || preDotState === 1 && startDot === end6 - 1 && startDot === startPart + 1) {
        if (end6 !== -1) {
          if (startPart === 0 && isAbsolute)
            ret.base = ret.name = path.slice(1, end6);
          else
            ret.base = ret.name = path.slice(startPart, end6);
        }
      } else {
        if (startPart === 0 && isAbsolute) {
          ret.name = path.slice(1, startDot);
          ret.base = path.slice(1, end6);
        } else {
          ret.name = path.slice(startPart, startDot);
          ret.base = path.slice(startPart, end6);
        }
        ret.ext = path.slice(startDot, end6);
      }
      if (startPart > 0)
        ret.dir = path.slice(0, startPart - 1);
      else if (isAbsolute)
        ret.dir = "/";
      return ret;
    },
    sep: "/",
    fromFileUrl,
    toFileUrl,
    toNamespacedPath: identity
  });

  // node_modules/@effect/platform/dist/esm/Path.js
  var TypeId22 = TypeId21;
  var Path2 = Path;

  // node_modules/@effect/platform/dist/esm/Transferable.js
  class Collector extends (/* @__PURE__ */ Tag2("@effect/platform/Transferable/Collector")()) {
  }
  var unsafeMakeCollector = () => {
    let tranferables = [];
    const unsafeAddAll = (transfers) => {
      tranferables.push(...transfers);
    };
    const unsafeRead = () => tranferables;
    const unsafeClear = () => {
      const prev = tranferables;
      tranferables = [];
      return prev;
    };
    return Collector.of({
      unsafeAddAll,
      addAll: (transferables) => sync3(() => unsafeAddAll(transferables)),
      unsafeRead,
      read: sync3(unsafeRead),
      unsafeClear,
      clear: sync3(unsafeClear)
    });
  };

  // node_modules/@effect/platform/dist/esm/internal/workerError.js
  var WorkerErrorTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/WorkerError");

  // node_modules/@effect/platform/dist/esm/WorkerError.js
  var WorkerErrorTypeId2 = WorkerErrorTypeId;
  class WorkerError extends (/* @__PURE__ */ TaggedError2()("WorkerError", {
    reason: /* @__PURE__ */ Literal2("spawn", "decode", "send", "unknown", "encode"),
    cause: Defect
  })) {
    [WorkerErrorTypeId2] = WorkerErrorTypeId2;
    static Cause = /* @__PURE__ */ Cause({
      error: this,
      defect: Defect
    });
    static encodeCause = /* @__PURE__ */ encodeSync(this.Cause);
    static decodeCause = /* @__PURE__ */ decodeSync(this.Cause);
    get message() {
      switch (this.reason) {
        case "send":
          return "An error occurred calling .postMessage";
        case "spawn":
          return "An error occurred while spawning a worker";
        case "decode":
          return "An error occurred during decoding";
        case "encode":
          return "An error occurred during encoding";
        case "unknown":
          return "An unexpected error occurred";
      }
    }
  }

  // node_modules/@effect/platform/dist/esm/internal/worker.js
  var PlatformWorkerTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Worker/PlatformWorker");
  var PlatformWorker = /* @__PURE__ */ GenericTag("@effect/platform/Worker/PlatformWorker");
  var WorkerManagerTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Worker/WorkerManager");
  var WorkerManager = /* @__PURE__ */ GenericTag("@effect/platform/Worker/WorkerManager");
  var Spawner = /* @__PURE__ */ GenericTag("@effect/platform/Worker/Spawner");
  var makeManager = /* @__PURE__ */ gen2(function* () {
    const platform = yield* PlatformWorker;
    let idCounter = 0;
    return WorkerManager.of({
      [WorkerManagerTypeId]: WorkerManagerTypeId,
      spawn({
        encode,
        initialMessage
      }) {
        return gen2(function* () {
          const id2 = idCounter++;
          let requestIdCounter = 0;
          const requestMap = new Map;
          const collector = unsafeMakeCollector();
          const wrappedEncode = encode ? (message) => zipRight3(collector.clear, provideService2(encode(message), Collector, collector)) : succeed8;
          const readyLatch = yield* make19();
          const backing = yield* platform.spawn(id2);
          yield* backing.run((message) => {
            if (message[0] === 0) {
              return complete(readyLatch, _void);
            }
            return handleMessage(message[1]);
          }).pipe(onError2((cause3) => forEach6(requestMap.values(), (mailbox) => (DeferredTypeId2 in mailbox) ? failCause2(mailbox, cause3) : mailbox.failCause(cause3))), tapErrorCause3(logWarning2), retry2(spaced2(1000)), annotateLogs3({
            package: "@effect/platform",
            module: "Worker"
          }), interruptible4, forkScoped2);
          yield* addFinalizer3(() => zipRight3(forEach6(requestMap.values(), (mailbox) => (DeferredTypeId2 in mailbox) ? interrupt3(mailbox) : mailbox.end, {
            discard: true
          }), sync3(() => requestMap.clear())));
          const handleMessage = (response) => suspend3(() => {
            const mailbox = requestMap.get(response[0]);
            if (!mailbox)
              return _void;
            switch (response[1]) {
              case 0: {
                return DeferredTypeId2 in mailbox ? succeed2(mailbox, response[2][0]) : mailbox.offerAll(response[2]);
              }
              case 1: {
                if (response.length === 2) {
                  return DeferredTypeId2 in mailbox ? interrupt3(mailbox) : mailbox.end;
                }
                return DeferredTypeId2 in mailbox ? succeed2(mailbox, response[2][0]) : zipRight3(mailbox.offerAll(response[2]), mailbox.end);
              }
              case 2:
              case 3: {
                if (response[1] === 2) {
                  return DeferredTypeId2 in mailbox ? fail3(mailbox, response[2]) : mailbox.fail(response[2]);
                }
                const cause3 = WorkerError.decodeCause(response[2]);
                return DeferredTypeId2 in mailbox ? failCause2(mailbox, cause3) : mailbox.failCause(cause3);
              }
            }
          });
          const executeAcquire = (request2, makeMailbox) => withFiberRuntime2((fiber) => {
            const context9 = fiber.getFiberRef(currentContext2);
            const span4 = getOption2(context9, ParentSpan).pipe(filter((span5) => span5._tag === "Span"));
            const id3 = requestIdCounter++;
            return makeMailbox.pipe(tap3((mailbox) => {
              requestMap.set(id3, mailbox);
              return wrappedEncode(request2).pipe(tap3((payload) => backing.send([id3, 0, payload, span4._tag === "Some" ? [span4.value.traceId, span4.value.spanId, span4.value.sampled] : undefined], collector.unsafeRead())), catchAllCause3((cause3) => isMailbox(mailbox) ? mailbox.failCause(cause3) : failCause2(mailbox, cause3)));
            }), map16((mailbox) => ({
              id: id3,
              mailbox
            })));
          });
          const executeRelease = ({
            id: id3
          }, exit3) => {
            const release = sync3(() => requestMap.delete(id3));
            return isFailure(exit3) ? zipRight3(orDie3(backing.send([id3, 1])), release) : release;
          };
          const execute3 = (request2) => fromChannel4(acquireUseRelease4(executeAcquire(request2, make55()), ({
            mailbox
          }) => toChannel4(mailbox), executeRelease));
          const executeEffect = (request2) => acquireUseRelease2(executeAcquire(request2, make19()), ({
            mailbox
          }) => _await(mailbox), executeRelease);
          yield* _await(readyLatch);
          if (initialMessage) {
            yield* sync3(initialMessage).pipe(flatMap11(executeEffect), mapError3((cause3) => new WorkerError({
              reason: "spawn",
              cause: cause3
            })));
          }
          return {
            id: id2,
            execute: execute3,
            executeEffect
          };
        });
      }
    });
  });
  var layerManager = /* @__PURE__ */ effect(WorkerManager, makeManager);
  var makePlatform = () => (options) => PlatformWorker.of({
    [PlatformWorkerTypeId]: PlatformWorkerTypeId,
    spawn(id2) {
      return gen2(function* () {
        const spawn = yield* Spawner;
        let currentPort;
        const buffer4 = [];
        const run5 = (handler) => uninterruptibleMask3((restore) => gen2(function* () {
          const scope5 = yield* scope3;
          const port = yield* options.setup({
            worker: spawn(id2),
            scope: scope5
          });
          currentPort = port;
          yield* addFinalizer2(scope5, sync3(() => {
            currentPort = undefined;
          }));
          const runtime5 = (yield* runtime4()).pipe(updateContext3(omit2(Scope)));
          const fiberSet = yield* make52();
          const runFork4 = runFork3(runtime5);
          yield* options.listen({
            port,
            scope: scope5,
            emit(data) {
              unsafeAdd(fiberSet, runFork4(handler(data)));
            },
            deferred: fiberSet.deferred
          });
          if (buffer4.length > 0) {
            for (const [message, transfers] of buffer4) {
              port.postMessage([0, message], transfers);
            }
            buffer4.length = 0;
          }
          return yield* restore(join4(fiberSet));
        }).pipe(scoped2));
        const send = (message, transfers) => try_2({
          try: () => {
            if (currentPort === undefined) {
              buffer4.push([message, transfers]);
            } else {
              currentPort.postMessage([0, message], transfers);
            }
          },
          catch: (cause3) => new WorkerError({
            reason: "send",
            cause: cause3
          })
        });
        return {
          run: run5,
          send
        };
      });
    }
  });

  // node_modules/@effect/platform/dist/esm/Worker.js
  var makePlatform2 = makePlatform;
  var PlatformWorker2 = PlatformWorker;
  var layerManager2 = layerManager;

  // node_modules/@effect/platform-bun/dist/esm/BunContext.js
  var exports_BunContext = {};
  __export(exports_BunContext, {
    layer: () => layer15
  });

  // node_modules/@effect/platform/dist/esm/internal/commandExecutor.js
  var TypeId23 = /* @__PURE__ */ Symbol.for("@effect/platform/CommandExecutor");
  var ProcessTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Process");
  var ExitCode = /* @__PURE__ */ nominal();
  var ProcessId = /* @__PURE__ */ nominal();
  var CommandExecutor = /* @__PURE__ */ GenericTag("@effect/platform/CommandExecutor");
  var makeExecutor = (start3) => {
    const stream2 = (command) => unwrapScoped7(map16(start3(command), (process2) => process2.stdout));
    const streamLines = (command, encoding) => {
      const decoder = new TextDecoder(encoding);
      return splitLines3(mapChunks2(stream2(command), map4((bytes) => decoder.decode(bytes))));
    };
    return {
      [TypeId23]: TypeId23,
      start: start3,
      exitCode: (command) => scoped2(flatMap11(start3(command), (process2) => process2.exitCode)),
      stream: stream2,
      string: (command, encoding = "utf-8") => {
        const decoder = new TextDecoder(encoding);
        return pipe(start3(command), flatMap11((process2) => run4(process2.stdout, collectUint8Array)), map16((bytes) => decoder.decode(bytes)), scoped2);
      },
      lines: (command, encoding = "utf-8") => {
        return pipe(streamLines(command, encoding), runCollect3, map16(toArray2));
      },
      streamLines
    };
  };
  var collectUint8Array = /* @__PURE__ */ foldLeftChunks2(/* @__PURE__ */ new Uint8Array, (bytes, chunk3) => reduce2(chunk3, bytes, (acc, curr) => {
    const newArray = new Uint8Array(acc.length + curr.length);
    newArray.set(acc);
    newArray.set(curr, acc.length);
    return newArray;
  }));

  // node_modules/@effect/platform/dist/esm/internal/command.js
  var CommandTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Command");
  var flatten15 = (self2) => Array.from(flattenLoop(self2));
  var flattenLoop = (self2) => {
    switch (self2._tag) {
      case "StandardCommand": {
        return of2(self2);
      }
      case "PipedCommand": {
        return appendAll2(flattenLoop(self2.left), flattenLoop(self2.right));
      }
    }
  };
  var Proto3 = {
    [CommandTypeId]: CommandTypeId,
    pipe() {
      return pipeArguments(this, arguments);
    },
    ...BaseProto
  };
  var StandardProto = {
    ...Proto3,
    _tag: "StandardCommand",
    toJSON() {
      return {
        _id: "@effect/platform/Command",
        _tag: this._tag,
        command: this.command,
        args: this.args,
        env: Object.fromEntries(this.env),
        cwd: this.cwd.toJSON(),
        shell: this.shell,
        gid: this.gid.toJSON(),
        uid: this.uid.toJSON()
      };
    }
  };
  var makeStandard = (options) => Object.assign(Object.create(StandardProto), options);
  var PipedProto = {
    ...Proto3,
    _tag: "PipedCommand",
    toJSON() {
      return {
        _id: "@effect/platform/Command",
        _tag: this._tag,
        left: this.left.toJSON(),
        right: this.right.toJSON()
      };
    }
  };
  var makePiped = (options) => Object.assign(Object.create(PipedProto), options);
  var stdin = /* @__PURE__ */ dual(2, (self2, input) => {
    switch (self2._tag) {
      case "StandardCommand": {
        return makeStandard({
          ...self2,
          stdin: input
        });
      }
      case "PipedCommand": {
        return makePiped({
          ...self2,
          left: stdin(self2.left, input)
        });
      }
    }
  });

  // node_modules/@effect/platform/dist/esm/Command.js
  var flatten16 = flatten15;
  var stdin2 = stdin;

  // node_modules/@effect/platform/dist/esm/CommandExecutor.js
  var CommandExecutor2 = CommandExecutor;
  var ProcessTypeId2 = ProcessTypeId;
  var ExitCode2 = ExitCode;
  var ProcessId2 = ProcessId;
  var makeExecutor2 = makeExecutor;

  // node_modules/@effect/platform-node-shared/dist/esm/internal/commandExecutor.js
  var ChildProcess = (() => ({}));

  // node_modules/@effect/platform-node-shared/dist/esm/internal/error.js
  var handleErrnoException = (module, method) => (err, [path]) => {
    let reason = "Unknown";
    switch (err.code) {
      case "ENOENT":
        reason = "NotFound";
        break;
      case "EACCES":
        reason = "PermissionDenied";
        break;
      case "EEXIST":
        reason = "AlreadyExists";
        break;
      case "EISDIR":
        reason = "BadResource";
        break;
      case "ENOTDIR":
        reason = "BadResource";
        break;
      case "EBUSY":
        reason = "Busy";
        break;
      case "ELOOP":
        reason = "BadResource";
        break;
    }
    return new SystemError({
      reason,
      module,
      method,
      pathOrDescriptor: path,
      syscall: err.syscall,
      description: err.message,
      cause: err
    });
  };

  // node_modules/@effect/platform-node-shared/dist/esm/internal/stream.js
  var import_node_stream = __toESM(require_stream());
  var fromReadable = (evaluate3, onError5, options) => fromChannel4(fromReadableChannel(evaluate3, onError5, options));
  var fromReadableChannel = (evaluate3, onError5, options) => suspend10(() => unsafeReadableRead(evaluate3(), onError5, make11(undefined), options));
  var writeInput = (writable, onFailure, {
    encoding,
    endOnDone = true
  } = {}, onDone3 = _void) => {
    const write4 = writeEffect(writable, encoding);
    const close2 = endOnDone ? async((resume2) => {
      if ("closed" in writable && writable.closed) {
        resume2(_void);
      } else {
        writable.once("finish", () => resume2(_void));
        writable.end();
      }
    }) : _void;
    return {
      awaitRead: () => _void,
      emit: write4,
      error: (cause3) => zipRight3(close2, onFailure(cause3)),
      done: (_) => zipRight3(close2, onDone3)
    };
  };
  var writeEffect = (writable, encoding) => (chunk3) => chunk3.length === 0 ? _void : async((resume2) => {
    const iterator = chunk3[Symbol.iterator]();
    let next = iterator.next();
    function loop3() {
      const item = next;
      next = iterator.next();
      const success = writable.write(item.value, encoding);
      if (next.done) {
        resume2(_void);
      } else if (success) {
        loop3();
      } else {
        writable.once("drain", loop3);
      }
    }
    loop3();
  });
  var unsafeReadableRead = (readable, onError5, exit3, options) => {
    if (!readable.readable) {
      return void_8;
    }
    const latch = unsafeMakeLatch2(false);
    function onReadable() {
      latch.unsafeOpen();
    }
    function onErr(err) {
      exit3.current = fail4(onError5(err));
      latch.unsafeOpen();
    }
    function onEnd3() {
      exit3.current = void_2;
      latch.unsafeOpen();
    }
    readable.on("readable", onReadable);
    readable.on("error", onErr);
    readable.on("end", onEnd3);
    const chunkSize = options?.chunkSize ? Number(options.chunkSize) : undefined;
    const read3 = suspend10(function loop() {
      let item = readable.read(chunkSize);
      if (item === null) {
        if (exit3.current) {
          return fromEffect8(exit3.current);
        }
        latch.unsafeClose();
        return flatMap17(latch.await, loop);
      }
      const arr = [item];
      while (true) {
        item = readable.read(chunkSize);
        if (item === null) {
          return flatMap17(write2(unsafeFromArray(arr)), loop);
        }
        arr.push(item);
      }
    });
    return ensuring7(read3, sync3(() => {
      readable.off("readable", onReadable);
      readable.off("error", onErr);
      readable.off("end", onEnd3);
      if (options?.closeOnDone !== false && "closed" in readable && !readable.closed) {
        readable.destroy();
      }
    }));
  };

  // node_modules/@effect/platform-node-shared/dist/esm/internal/sink.js
  var fromWritable = (evaluate3, onError5, options) => fromChannel3(fromWritableChannel(evaluate3, onError5, options));
  var fromWritableChannel = (writable, onError5, options) => flatMap17(zip5(sync3(() => writable()), make19()), ([writable2, deferred]) => embedInput2(writableOutput(writable2, deferred, onError5), writeInput(writable2, (cause3) => failCause2(deferred, cause3), options, complete(deferred, _void))));
  var writableOutput = (writable, deferred, onError5) => suspend3(() => {
    function handleError(err) {
      unsafeDone(deferred, fail9(onError5(err)));
    }
    writable.on("error", handleError);
    return ensuring2(_await(deferred), sync3(() => {
      writable.removeListener("error", handleError);
    }));
  });

  // node_modules/@effect/platform-node-shared/dist/esm/internal/commandExecutor.js
  var inputToStdioOption = (stdin3) => typeof stdin3 === "string" ? stdin3 : "pipe";
  var outputToStdioOption = (output) => typeof output === "string" ? output : "pipe";
  var toError = (err) => err instanceof globalThis.Error ? err : new globalThis.Error(String(err));
  var toPlatformError = (method, error, command) => {
    const flattened = flatten16(command).reduce((acc, curr) => {
      const command2 = `${curr.command} ${curr.args.join(" ")}`;
      return acc.length === 0 ? command2 : `${acc} | ${command2}`;
    }, "");
    return handleErrnoException("Command", method)(error, [flattened]);
  };
  var ProcessProto = {
    [ProcessTypeId2]: ProcessTypeId2,
    ...BaseProto,
    toJSON() {
      return {
        _id: "@effect/platform/CommandExecutor/Process",
        pid: this.pid
      };
    }
  };
  var runCommand = (fileSystem) => (command) => {
    switch (command._tag) {
      case "StandardCommand": {
        const spawn2 = flatMap11(make19(), (exitCode2) => async((resume2) => {
          const handle = ChildProcess.spawn(command.command, command.args, {
            stdio: [inputToStdioOption(command.stdin), outputToStdioOption(command.stdout), outputToStdioOption(command.stderr)],
            cwd: getOrElse(command.cwd, constUndefined),
            shell: command.shell,
            env: {
              ...process.env,
              ...Object.fromEntries(command.env)
            },
            detached: process.platform !== "win32"
          });
          handle.on("error", (err) => {
            resume2(fail9(toPlatformError("spawn", err, command)));
          });
          handle.on("exit", (...args2) => {
            unsafeDone(exitCode2, succeed8(args2));
          });
          handle.on("spawn", () => {
            resume2(succeed8([handle, exitCode2]));
          });
          return sync3(() => {
            handle.kill("SIGTERM");
          });
        }));
        const killProcessGroup = process.platform === "win32" ? (handle, _) => async((resume2) => {
          ChildProcess.exec(`taskkill /pid ${handle.pid} /T /F`, (error) => {
            if (error) {
              resume2(fail9(toPlatformError("kill", toError(error), command)));
            } else {
              resume2(_void);
            }
          });
        }) : (handle, signal) => try_2({
          try: () => process.kill(-handle.pid, signal),
          catch: (error) => toPlatformError("kill", toError(error), command)
        });
        const killProcess = (handle, signal) => suspend3(() => handle.kill(signal) ? _void : fail9(toPlatformError("kill", new globalThis.Error("Failed to kill process"), command)));
        return pipe(match2(command.cwd, {
          onNone: () => _void,
          onSome: (dir) => fileSystem.access(dir)
        }), zipRight3(acquireRelease2(spawn2, ([handle, exitCode2]) => flatMap11(isDone(exitCode2), (done11) => {
          if (!done11) {
            return killProcessGroup(handle, "SIGTERM").pipe(orElse5(() => killProcess(handle, "SIGTERM")), zipRight3(_await(exitCode2)), ignore2);
          }
          return flatMap11(_await(exitCode2), ([code2]) => {
            if (code2 !== 0 && code2 !== null) {
              return killProcessGroup(handle, "SIGTERM").pipe(ignore2);
            }
            return _void;
          });
        }))), map16(([handle, exitCodeDeferred]) => {
          let stdin3 = drain4;
          if (handle.stdin !== null) {
            stdin3 = fromWritable(() => handle.stdin, (err) => toPlatformError("toWritable", toError(err), command));
          }
          const exitCode2 = flatMap11(_await(exitCodeDeferred), ([code2, signal]) => {
            if (code2 !== null) {
              return succeed8(ExitCode2(code2));
            }
            return fail9(toPlatformError("exitCode", new globalThis.Error(`Process interrupted due to receipt of signal: ${signal}`), command));
          });
          const isRunning3 = negate2(isDone(exitCodeDeferred));
          const kill = (signal = "SIGTERM") => killProcessGroup(handle, signal).pipe(orElse5(() => killProcess(handle, signal)), zipRight3(asVoid3(_await(exitCodeDeferred))));
          const pid2 = ProcessId2(handle.pid);
          const stderr2 = fromReadable(() => handle.stderr, (err) => toPlatformError("fromReadable(stderr)", toError(err), command));
          let stdout2 = fromReadable(() => handle.stdout, (err) => toPlatformError("fromReadable(stdout)", toError(err), command));
          if (typeof command.stdout !== "string") {
            stdout2 = transduce2(stdout2, command.stdout);
          }
          return Object.assign(Object.create(ProcessProto), {
            pid: pid2,
            exitCode: exitCode2,
            isRunning: isRunning3,
            kill,
            stdin: stdin3,
            stderr: stderr2,
            stdout: stdout2
          });
        }), typeof command.stdin === "string" ? identity : tap3((process2) => forkDaemon2(run4(command.stdin, process2.stdin))));
      }
      case "PipedCommand": {
        const flattened = flatten16(command);
        if (flattened.length === 1) {
          return pipe(flattened[0], runCommand(fileSystem));
        }
        const head6 = flattened[0];
        const tail = flattened.slice(1);
        const initial = tail.slice(0, tail.length - 1);
        const last4 = tail[tail.length - 1];
        const stream3 = initial.reduce((stdin3, command2) => pipe(stdin2(command2, stdin3), runCommand(fileSystem), map16((process2) => process2.stdout), unwrapScoped7), pipe(runCommand(fileSystem)(head6), map16((process2) => process2.stdout), unwrapScoped7));
        return pipe(stdin2(last4, stream3), runCommand(fileSystem));
      }
    }
  };
  var layer2 = /* @__PURE__ */ effect(CommandExecutor2, /* @__PURE__ */ pipe(FileSystem, /* @__PURE__ */ map16((fileSystem) => makeExecutor2(runCommand(fileSystem)))));

  // node_modules/@effect/platform-node-shared/dist/esm/NodeCommandExecutor.js
  var layer3 = layer2;

  // node_modules/@effect/platform-bun/dist/esm/BunCommandExecutor.js
  var layer4 = layer3;

  // node_modules/@effect/platform/dist/esm/internal/effectify.js
  var effectify = (fn2, onError5, onSyncError) => (...args2) => async((resume2) => {
    try {
      fn2(...args2, (err, result) => {
        if (err) {
          resume2(fail9(onError5 ? onError5(err, args2) : err));
        } else {
          resume2(succeed8(result));
        }
      });
    } catch (err) {
      resume2(onSyncError ? fail9(onSyncError(err, args2)) : die6(err));
    }
  });

  // node_modules/@effect/platform/dist/esm/Effectify.js
  var effectify2 = effectify;

  // node_modules/@effect/platform-node-shared/dist/esm/internal/fileSystem.js
  init_crypto();
  var NFS = (() => ({}));

  // node:os
  var tmpdir = function() {
    return "/tmp";
  };

  // node:path
  var exports_path2 = {};
  __export(exports_path2, {
    sep: () => sep,
    resolve: () => resolve3,
    relative: () => relative,
    posix: () => posix,
    parse: () => parse,
    normalize: () => normalize,
    join: () => join5,
    isAbsolute: () => isAbsolute,
    format: () => format7,
    extname: () => extname,
    dirname: () => dirname,
    delimiter: () => delimiter,
    default: () => path_default,
    basename: () => basename,
    _makeLong: () => _makeLong
  });
  function assertPath(path) {
    if (typeof path !== "string")
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
  }
  function normalizeStringPosix2(path, allowAboveRoot) {
    var res = "", lastSegmentLength = 0, lastSlash = -1, dots = 0, code2;
    for (var i2 = 0;i2 <= path.length; ++i2) {
      if (i2 < path.length)
        code2 = path.charCodeAt(i2);
      else if (code2 === 47)
        break;
      else
        code2 = 47;
      if (code2 === 47) {
        if (lastSlash === i2 - 1 || dots === 1)
          ;
        else if (lastSlash !== i2 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1)
                  res = "", lastSegmentLength = 0;
                else
                  res = res.slice(0, lastSlashIndex), lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                lastSlash = i2, dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "", lastSegmentLength = 0, lastSlash = i2, dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0)
              res += "/..";
            else
              res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0)
            res += "/" + path.slice(lastSlash + 1, i2);
          else
            res = path.slice(lastSlash + 1, i2);
          lastSegmentLength = i2 - lastSlash - 1;
        }
        lastSlash = i2, dots = 0;
      } else if (code2 === 46 && dots !== -1)
        ++dots;
      else
        dots = -1;
    }
    return res;
  }
  function _format2(sep, pathObject) {
    var dir = pathObject.dir || pathObject.root, base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir)
      return base;
    if (dir === pathObject.root)
      return dir + base;
    return dir + sep + base;
  }
  function resolve3() {
    var resolvedPath = "", resolvedAbsolute = false, cwd;
    for (var i2 = arguments.length - 1;i2 >= -1 && !resolvedAbsolute; i2--) {
      var path;
      if (i2 >= 0)
        path = arguments[i2];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }
      if (assertPath(path), path.length === 0)
        continue;
      resolvedPath = path + "/" + resolvedPath, resolvedAbsolute = path.charCodeAt(0) === 47;
    }
    if (resolvedPath = normalizeStringPosix2(resolvedPath, !resolvedAbsolute), resolvedAbsolute)
      if (resolvedPath.length > 0)
        return "/" + resolvedPath;
      else
        return "/";
    else if (resolvedPath.length > 0)
      return resolvedPath;
    else
      return ".";
  }
  function normalize(path) {
    if (assertPath(path), path.length === 0)
      return ".";
    var isAbsolute = path.charCodeAt(0) === 47, trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    if (path = normalizeStringPosix2(path, !isAbsolute), path.length === 0 && !isAbsolute)
      path = ".";
    if (path.length > 0 && trailingSeparator)
      path += "/";
    if (isAbsolute)
      return "/" + path;
    return path;
  }
  function isAbsolute(path) {
    return assertPath(path), path.length > 0 && path.charCodeAt(0) === 47;
  }
  function join5() {
    if (arguments.length === 0)
      return ".";
    var joined;
    for (var i2 = 0;i2 < arguments.length; ++i2) {
      var arg = arguments[i2];
      if (assertPath(arg), arg.length > 0)
        if (joined === undefined)
          joined = arg;
        else
          joined += "/" + arg;
    }
    if (joined === undefined)
      return ".";
    return normalize(joined);
  }
  function relative(from2, to) {
    if (assertPath(from2), assertPath(to), from2 === to)
      return "";
    if (from2 = resolve3(from2), to = resolve3(to), from2 === to)
      return "";
    var fromStart = 1;
    for (;fromStart < from2.length; ++fromStart)
      if (from2.charCodeAt(fromStart) !== 47)
        break;
    var fromEnd = from2.length, fromLen = fromEnd - fromStart, toStart = 1;
    for (;toStart < to.length; ++toStart)
      if (to.charCodeAt(toStart) !== 47)
        break;
    var toEnd = to.length, toLen = toEnd - toStart, length3 = fromLen < toLen ? fromLen : toLen, lastCommonSep = -1, i2 = 0;
    for (;i2 <= length3; ++i2) {
      if (i2 === length3) {
        if (toLen > length3) {
          if (to.charCodeAt(toStart + i2) === 47)
            return to.slice(toStart + i2 + 1);
          else if (i2 === 0)
            return to.slice(toStart + i2);
        } else if (fromLen > length3) {
          if (from2.charCodeAt(fromStart + i2) === 47)
            lastCommonSep = i2;
          else if (i2 === 0)
            lastCommonSep = 0;
        }
        break;
      }
      var fromCode = from2.charCodeAt(fromStart + i2), toCode = to.charCodeAt(toStart + i2);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47)
        lastCommonSep = i2;
    }
    var out = "";
    for (i2 = fromStart + lastCommonSep + 1;i2 <= fromEnd; ++i2)
      if (i2 === fromEnd || from2.charCodeAt(i2) === 47)
        if (out.length === 0)
          out += "..";
        else
          out += "/..";
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      if (toStart += lastCommonSep, to.charCodeAt(toStart) === 47)
        ++toStart;
      return to.slice(toStart);
    }
  }
  function _makeLong(path) {
    return path;
  }
  function dirname(path) {
    if (assertPath(path), path.length === 0)
      return ".";
    var code2 = path.charCodeAt(0), hasRoot = code2 === 47, end6 = -1, matchedSlash = true;
    for (var i2 = path.length - 1;i2 >= 1; --i2)
      if (code2 = path.charCodeAt(i2), code2 === 47) {
        if (!matchedSlash) {
          end6 = i2;
          break;
        }
      } else
        matchedSlash = false;
    if (end6 === -1)
      return hasRoot ? "/" : ".";
    if (hasRoot && end6 === 1)
      return "//";
    return path.slice(0, end6);
  }
  function basename(path, ext) {
    if (ext !== undefined && typeof ext !== "string")
      throw new TypeError('"ext" argument must be a string');
    assertPath(path);
    var start4 = 0, end6 = -1, matchedSlash = true, i2;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path)
        return "";
      var extIdx = ext.length - 1, firstNonSlashEnd = -1;
      for (i2 = path.length - 1;i2 >= 0; --i2) {
        var code2 = path.charCodeAt(i2);
        if (code2 === 47) {
          if (!matchedSlash) {
            start4 = i2 + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1)
            matchedSlash = false, firstNonSlashEnd = i2 + 1;
          if (extIdx >= 0)
            if (code2 === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1)
                end6 = i2;
            } else
              extIdx = -1, end6 = firstNonSlashEnd;
        }
      }
      if (start4 === end6)
        end6 = firstNonSlashEnd;
      else if (end6 === -1)
        end6 = path.length;
      return path.slice(start4, end6);
    } else {
      for (i2 = path.length - 1;i2 >= 0; --i2)
        if (path.charCodeAt(i2) === 47) {
          if (!matchedSlash) {
            start4 = i2 + 1;
            break;
          }
        } else if (end6 === -1)
          matchedSlash = false, end6 = i2 + 1;
      if (end6 === -1)
        return "";
      return path.slice(start4, end6);
    }
  }
  function extname(path) {
    assertPath(path);
    var startDot = -1, startPart = 0, end6 = -1, matchedSlash = true, preDotState = 0;
    for (var i2 = path.length - 1;i2 >= 0; --i2) {
      var code2 = path.charCodeAt(i2);
      if (code2 === 47) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      if (end6 === -1)
        matchedSlash = false, end6 = i2 + 1;
      if (code2 === 46) {
        if (startDot === -1)
          startDot = i2;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1)
        preDotState = -1;
    }
    if (startDot === -1 || end6 === -1 || preDotState === 0 || preDotState === 1 && startDot === end6 - 1 && startDot === startPart + 1)
      return "";
    return path.slice(startDot, end6);
  }
  function format7(pathObject) {
    if (pathObject === null || typeof pathObject !== "object")
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    return _format2("/", pathObject);
  }
  function parse(path) {
    assertPath(path);
    var ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path.length === 0)
      return ret;
    var code2 = path.charCodeAt(0), isAbsolute2 = code2 === 47, start4;
    if (isAbsolute2)
      ret.root = "/", start4 = 1;
    else
      start4 = 0;
    var startDot = -1, startPart = 0, end6 = -1, matchedSlash = true, i2 = path.length - 1, preDotState = 0;
    for (;i2 >= start4; --i2) {
      if (code2 = path.charCodeAt(i2), code2 === 47) {
        if (!matchedSlash) {
          startPart = i2 + 1;
          break;
        }
        continue;
      }
      if (end6 === -1)
        matchedSlash = false, end6 = i2 + 1;
      if (code2 === 46) {
        if (startDot === -1)
          startDot = i2;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1)
        preDotState = -1;
    }
    if (startDot === -1 || end6 === -1 || preDotState === 0 || preDotState === 1 && startDot === end6 - 1 && startDot === startPart + 1) {
      if (end6 !== -1)
        if (startPart === 0 && isAbsolute2)
          ret.base = ret.name = path.slice(1, end6);
        else
          ret.base = ret.name = path.slice(startPart, end6);
    } else {
      if (startPart === 0 && isAbsolute2)
        ret.name = path.slice(1, startDot), ret.base = path.slice(1, end6);
      else
        ret.name = path.slice(startPart, startDot), ret.base = path.slice(startPart, end6);
      ret.ext = path.slice(startDot, end6);
    }
    if (startPart > 0)
      ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute2)
      ret.dir = "/";
    return ret;
  }
  var sep = "/";
  var delimiter = ":";
  var posix = ((p) => (p.posix = p, p))({ resolve: resolve3, normalize, isAbsolute, join: join5, relative, _makeLong, dirname, basename, extname, format: format7, parse, sep, delimiter, win32: null, posix: null });
  var path_default = posix;

  // node_modules/@effect/platform-node-shared/dist/esm/internal/fileSystem.js
  var handleBadArgument = (method) => (cause3) => new BadArgument({
    module: "FileSystem",
    method,
    cause: cause3
  });
  var access2 = /* @__PURE__ */ (() => {
    const nodeAccess = /* @__PURE__ */ effectify2(NFS.access, /* @__PURE__ */ handleErrnoException("FileSystem", "access"), /* @__PURE__ */ handleBadArgument("access"));
    return (path, options) => {
      let mode = NFS.constants.F_OK;
      if (options?.readable) {
        mode |= NFS.constants.R_OK;
      }
      if (options?.writable) {
        mode |= NFS.constants.W_OK;
      }
      return nodeAccess(path, mode);
    };
  })();
  var copy5 = /* @__PURE__ */ (() => {
    const nodeCp = /* @__PURE__ */ effectify2(NFS.cp, /* @__PURE__ */ handleErrnoException("FileSystem", "copy"), /* @__PURE__ */ handleBadArgument("copy"));
    return (fromPath, toPath, options) => nodeCp(fromPath, toPath, {
      force: options?.overwrite ?? false,
      preserveTimestamps: options?.preserveTimestamps ?? false,
      recursive: true
    });
  })();
  var copyFile2 = /* @__PURE__ */ (() => {
    const nodeCopyFile = /* @__PURE__ */ effectify2(NFS.copyFile, /* @__PURE__ */ handleErrnoException("FileSystem", "copyFile"), /* @__PURE__ */ handleBadArgument("copyFile"));
    return (fromPath, toPath) => nodeCopyFile(fromPath, toPath);
  })();
  var chmod2 = /* @__PURE__ */ (() => {
    const nodeChmod = /* @__PURE__ */ effectify2(NFS.chmod, /* @__PURE__ */ handleErrnoException("FileSystem", "chmod"), /* @__PURE__ */ handleBadArgument("chmod"));
    return (path, mode) => nodeChmod(path, mode);
  })();
  var chown2 = /* @__PURE__ */ (() => {
    const nodeChown = /* @__PURE__ */ effectify2(NFS.chown, /* @__PURE__ */ handleErrnoException("FileSystem", "chown"), /* @__PURE__ */ handleBadArgument("chown"));
    return (path, uid, gid) => nodeChown(path, uid, gid);
  })();
  var link2 = /* @__PURE__ */ (() => {
    const nodeLink = /* @__PURE__ */ effectify2(NFS.link, /* @__PURE__ */ handleErrnoException("FileSystem", "link"), /* @__PURE__ */ handleBadArgument("link"));
    return (existingPath, newPath) => nodeLink(existingPath, newPath);
  })();
  var makeDirectory = /* @__PURE__ */ (() => {
    const nodeMkdir = /* @__PURE__ */ effectify2(NFS.mkdir, /* @__PURE__ */ handleErrnoException("FileSystem", "makeDirectory"), /* @__PURE__ */ handleBadArgument("makeDirectory"));
    return (path, options) => nodeMkdir(path, {
      recursive: options?.recursive ?? false,
      mode: options?.mode
    });
  })();
  var makeTempDirectoryFactory = (method) => {
    const nodeMkdtemp = effectify2(NFS.mkdtemp, handleErrnoException("FileSystem", method), handleBadArgument(method));
    return (options) => suspend3(() => {
      const prefix = options?.prefix ?? "";
      const directory = typeof options?.directory === "string" ? join5(options.directory, ".") : tmpdir();
      return nodeMkdtemp(prefix ? join5(directory, prefix) : directory + "/");
    });
  };
  var makeTempDirectory = /* @__PURE__ */ makeTempDirectoryFactory("makeTempDirectory");
  var removeFactory = (method) => {
    const nodeRm = effectify2(NFS.rm, handleErrnoException("FileSystem", method), handleBadArgument(method));
    return (path, options) => nodeRm(path, {
      recursive: options?.recursive ?? false,
      force: options?.force ?? false
    });
  };
  var remove7 = /* @__PURE__ */ removeFactory("remove");
  var makeTempDirectoryScoped = /* @__PURE__ */ (() => {
    const makeDirectory2 = /* @__PURE__ */ makeTempDirectoryFactory("makeTempDirectoryScoped");
    const removeDirectory = /* @__PURE__ */ removeFactory("makeTempDirectoryScoped");
    return (options) => acquireRelease2(makeDirectory2(options), (directory) => orDie3(removeDirectory(directory, {
      recursive: true
    })));
  })();
  var openFactory = (method) => {
    const nodeOpen = effectify2(NFS.open, handleErrnoException("FileSystem", method), handleBadArgument(method));
    const nodeClose = effectify2(NFS.close, handleErrnoException("FileSystem", method), handleBadArgument(method));
    return (path, options) => pipe(acquireRelease2(nodeOpen(path, options?.flag ?? "r", options?.mode), (fd) => orDie3(nodeClose(fd))), map16((fd) => makeFile(FileDescriptor(fd), options?.flag?.startsWith("a") ?? false)));
  };
  var open2 = /* @__PURE__ */ openFactory("open");
  var makeFile = /* @__PURE__ */ (() => {
    const nodeReadFactory = (method) => effectify2(NFS.read, handleErrnoException("FileSystem", method), handleBadArgument(method));
    const nodeRead = /* @__PURE__ */ nodeReadFactory("read");
    const nodeReadAlloc = /* @__PURE__ */ nodeReadFactory("readAlloc");
    const nodeStat = /* @__PURE__ */ effectify2(NFS.fstat, /* @__PURE__ */ handleErrnoException("FileSystem", "stat"), /* @__PURE__ */ handleBadArgument("stat"));
    const nodeTruncate = /* @__PURE__ */ effectify2(NFS.ftruncate, /* @__PURE__ */ handleErrnoException("FileSystem", "truncate"), /* @__PURE__ */ handleBadArgument("truncate"));
    const nodeSync = /* @__PURE__ */ effectify2(NFS.fsync, /* @__PURE__ */ handleErrnoException("FileSystem", "sync"), /* @__PURE__ */ handleBadArgument("sync"));
    const nodeWriteFactory = (method) => effectify2(NFS.write, handleErrnoException("FileSystem", method), handleBadArgument(method));
    const nodeWrite = /* @__PURE__ */ nodeWriteFactory("write");
    const nodeWriteAll = /* @__PURE__ */ nodeWriteFactory("writeAll");

    class FileImpl {
      fd;
      append;
      [FileTypeId];
      semaphore = /* @__PURE__ */ unsafeMakeSemaphore2(1);
      position = 0n;
      constructor(fd, append4) {
        this.fd = fd;
        this.append = append4;
        this[FileTypeId] = FileTypeId;
      }
      get stat() {
        return map16(nodeStat(this.fd), makeFileInfo);
      }
      get sync() {
        return nodeSync(this.fd);
      }
      seek(offset, from2) {
        const offsetSize = Size2(offset);
        return this.semaphore.withPermits(1)(sync3(() => {
          if (from2 === "start") {
            this.position = offsetSize;
          } else if (from2 === "current") {
            this.position = this.position + offsetSize;
          }
          return this.position;
        }));
      }
      read(buffer4) {
        return this.semaphore.withPermits(1)(map16(suspend3(() => nodeRead(this.fd, {
          buffer: buffer4,
          position: this.position
        })), (bytesRead) => {
          const sizeRead = Size2(bytesRead);
          this.position = this.position + sizeRead;
          return sizeRead;
        }));
      }
      readAlloc(size13) {
        const sizeNumber = Number(size13);
        return this.semaphore.withPermits(1)(flatMap11(sync3(() => Buffer.allocUnsafeSlow(sizeNumber)), (buffer4) => map16(nodeReadAlloc(this.fd, {
          buffer: buffer4,
          position: this.position
        }), (bytesRead) => {
          if (bytesRead === 0) {
            return none2();
          }
          this.position = this.position + BigInt(bytesRead);
          if (bytesRead === sizeNumber) {
            return some2(buffer4);
          }
          const dst = Buffer.allocUnsafeSlow(bytesRead);
          buffer4.copy(dst, 0, 0, bytesRead);
          return some2(dst);
        })));
      }
      truncate(length3) {
        return this.semaphore.withPermits(1)(map16(nodeTruncate(this.fd, length3 ? Number(length3) : undefined), () => {
          if (!this.append) {
            const len2 = BigInt(length3 ?? 0);
            if (this.position > len2) {
              this.position = len2;
            }
          }
        }));
      }
      write(buffer4) {
        return this.semaphore.withPermits(1)(map16(suspend3(() => nodeWrite(this.fd, buffer4, undefined, undefined, this.append ? undefined : Number(this.position))), (bytesWritten) => {
          const sizeWritten = Size2(bytesWritten);
          if (!this.append) {
            this.position = this.position + sizeWritten;
          }
          return sizeWritten;
        }));
      }
      writeAllChunk(buffer4) {
        return flatMap11(suspend3(() => nodeWriteAll(this.fd, buffer4, undefined, undefined, this.append ? undefined : Number(this.position))), (bytesWritten) => {
          if (bytesWritten === 0) {
            return fail9(new SystemError({
              module: "FileSystem",
              method: "writeAll",
              reason: "WriteZero",
              pathOrDescriptor: this.fd,
              description: "write returned 0 bytes written"
            }));
          }
          if (!this.append) {
            this.position = this.position + BigInt(bytesWritten);
          }
          return bytesWritten < buffer4.length ? this.writeAllChunk(buffer4.subarray(bytesWritten)) : _void;
        });
      }
      writeAll(buffer4) {
        return this.semaphore.withPermits(1)(this.writeAllChunk(buffer4));
      }
    }
    return (fd, append4) => new FileImpl(fd, append4);
  })();
  var makeTempFileFactory = (method) => {
    const makeDirectory2 = makeTempDirectoryFactory(method);
    const open3 = openFactory(method);
    const randomHexString2 = (bytes) => sync3(() => randomBytes2(bytes).toString("hex"));
    return (options) => pipe(zip5(makeDirectory2(options), randomHexString2(6)), map16(([directory, random4]) => join5(directory, random4 + (options?.suffix ?? ""))), tap3((path) => scoped2(open3(path, {
      flag: "w+"
    }))));
  };
  var makeTempFile = /* @__PURE__ */ makeTempFileFactory("makeTempFile");
  var makeTempFileScoped = /* @__PURE__ */ (() => {
    const makeFile2 = /* @__PURE__ */ makeTempFileFactory("makeTempFileScoped");
    const removeDirectory = /* @__PURE__ */ removeFactory("makeTempFileScoped");
    return (options) => acquireRelease2(makeFile2(options), (file) => orDie3(removeDirectory(dirname(file), {
      recursive: true
    })));
  })();
  var readDirectory = (path, options) => tryPromise2({
    try: () => NFS.promises.readdir(path, options),
    catch: (err) => handleErrnoException("FileSystem", "readDirectory")(err, [path])
  });
  var readFile2 = (path) => async((resume2, signal) => {
    try {
      NFS.readFile(path, {
        signal
      }, (err, data) => {
        if (err) {
          resume2(fail9(handleErrnoException("FileSystem", "readFile")(err, [path])));
        } else {
          resume2(succeed8(data));
        }
      });
    } catch (err) {
      resume2(fail9(handleBadArgument("readFile")(err)));
    }
  });
  var readLink = /* @__PURE__ */ (() => {
    const nodeReadLink = /* @__PURE__ */ effectify2(NFS.readlink, /* @__PURE__ */ handleErrnoException("FileSystem", "readLink"), /* @__PURE__ */ handleBadArgument("readLink"));
    return (path) => nodeReadLink(path);
  })();
  var realPath = /* @__PURE__ */ (() => {
    const nodeRealPath = /* @__PURE__ */ effectify2(NFS.realpath, /* @__PURE__ */ handleErrnoException("FileSystem", "realPath"), /* @__PURE__ */ handleBadArgument("realPath"));
    return (path) => nodeRealPath(path);
  })();
  var rename3 = /* @__PURE__ */ (() => {
    const nodeRename = /* @__PURE__ */ effectify2(NFS.rename, /* @__PURE__ */ handleErrnoException("FileSystem", "rename"), /* @__PURE__ */ handleBadArgument("rename"));
    return (oldPath, newPath) => nodeRename(oldPath, newPath);
  })();
  var makeFileInfo = (stat2) => ({
    type: stat2.isFile() ? "File" : stat2.isDirectory() ? "Directory" : stat2.isSymbolicLink() ? "SymbolicLink" : stat2.isBlockDevice() ? "BlockDevice" : stat2.isCharacterDevice() ? "CharacterDevice" : stat2.isFIFO() ? "FIFO" : stat2.isSocket() ? "Socket" : "Unknown",
    mtime: fromNullable(stat2.mtime),
    atime: fromNullable(stat2.atime),
    birthtime: fromNullable(stat2.birthtime),
    dev: stat2.dev,
    rdev: fromNullable(stat2.rdev),
    ino: fromNullable(stat2.ino),
    mode: stat2.mode,
    nlink: fromNullable(stat2.nlink),
    uid: fromNullable(stat2.uid),
    gid: fromNullable(stat2.gid),
    size: Size2(stat2.size),
    blksize: map2(fromNullable(stat2.blksize), Size2),
    blocks: fromNullable(stat2.blocks)
  });
  var stat2 = /* @__PURE__ */ (() => {
    const nodeStat = /* @__PURE__ */ effectify2(NFS.stat, /* @__PURE__ */ handleErrnoException("FileSystem", "stat"), /* @__PURE__ */ handleBadArgument("stat"));
    return (path) => map16(nodeStat(path), makeFileInfo);
  })();
  var symlink2 = /* @__PURE__ */ (() => {
    const nodeSymlink = /* @__PURE__ */ effectify2(NFS.symlink, /* @__PURE__ */ handleErrnoException("FileSystem", "symlink"), /* @__PURE__ */ handleBadArgument("symlink"));
    return (target, path) => nodeSymlink(target, path);
  })();
  var truncate2 = /* @__PURE__ */ (() => {
    const nodeTruncate = /* @__PURE__ */ effectify2(NFS.truncate, /* @__PURE__ */ handleErrnoException("FileSystem", "truncate"), /* @__PURE__ */ handleBadArgument("truncate"));
    return (path, length3) => nodeTruncate(path, length3 !== undefined ? Number(length3) : undefined);
  })();
  var utimes2 = /* @__PURE__ */ (() => {
    const nodeUtimes = /* @__PURE__ */ effectify2(NFS.utimes, /* @__PURE__ */ handleErrnoException("FileSystem", "utime"), /* @__PURE__ */ handleBadArgument("utime"));
    return (path, atime, mtime) => nodeUtimes(path, atime, mtime);
  })();
  var watchNode = (path, options) => asyncScoped2((emit3) => acquireRelease2(sync3(() => {
    const watcher = NFS.watch(path, {
      recursive: options?.recursive
    }, (event, path2) => {
      if (!path2)
        return;
      switch (event) {
        case "rename": {
          emit3.fromEffect(matchEffect2(stat2(path2), {
            onSuccess: (_) => succeed8(WatchEventCreate({
              path: path2
            })),
            onFailure: (err) => err._tag === "SystemError" && err.reason === "NotFound" ? succeed8(WatchEventRemove({
              path: path2
            })) : fail9(err)
          }));
          return;
        }
        case "change": {
          emit3.single(WatchEventUpdate({
            path: path2
          }));
          return;
        }
      }
    });
    watcher.on("error", (error) => {
      emit3.fail(new SystemError({
        module: "FileSystem",
        reason: "Unknown",
        method: "watch",
        pathOrDescriptor: path,
        cause: error
      }));
    });
    watcher.on("close", () => {
      emit3.end();
    });
    return watcher;
  }), (watcher) => sync3(() => watcher.close())));
  var watch2 = (backend, path, options) => stat2(path).pipe(map16((stat3) => backend.pipe(flatMap((_) => _.register(path, stat3, options)), getOrElse(() => watchNode(path, options)))), unwrap4);
  var writeFile2 = (path, data, options) => async((resume2, signal) => {
    try {
      NFS.writeFile(path, data, {
        signal,
        flag: options?.flag,
        mode: options?.mode
      }, (err) => {
        if (err) {
          resume2(fail9(handleErrnoException("FileSystem", "writeFile")(err, [path])));
        } else {
          resume2(_void);
        }
      });
    } catch (err) {
      resume2(fail9(handleBadArgument("writeFile")(err)));
    }
  });
  var makeFileSystem = /* @__PURE__ */ map16(/* @__PURE__ */ serviceOption2(WatchBackend), (backend) => make59({
    access: access2,
    chmod: chmod2,
    chown: chown2,
    copy: copy5,
    copyFile: copyFile2,
    link: link2,
    makeDirectory,
    makeTempDirectory,
    makeTempDirectoryScoped,
    makeTempFile,
    makeTempFileScoped,
    open: open2,
    readDirectory,
    readFile: readFile2,
    readLink,
    realPath,
    remove: remove7,
    rename: rename3,
    stat: stat2,
    symlink: symlink2,
    truncate: truncate2,
    utimes: utimes2,
    watch(path, options) {
      return watch2(backend, path, options);
    },
    writeFile: writeFile2
  }));
  var layer5 = /* @__PURE__ */ effect(FileSystem, makeFileSystem);

  // node_modules/@effect/platform-node-shared/dist/esm/NodeFileSystem.js
  var layer6 = layer5;

  // node_modules/@effect/platform-bun/dist/esm/BunFileSystem.js
  var layer7 = layer6;

  // node:url
  var { URL: URL2, URLSearchParams: URLSearchParams2 } = globalThis;
  function util_isString(arg) {
    return typeof arg === "string";
  }
  function util_isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  function util_isNull(arg) {
    return arg === null;
  }
  function util_isNullOrUndefined(arg) {
    return arg == null;
  }
  function Url() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
  }
  var protocolPattern = /^([a-z0-9.+-]+:)/i;
  var portPattern = /:[0-9]*$/;
  var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
  var delims = ["<", ">", '"', "`", " ", "\r", `
`, "\t"];
  var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
  var autoEscape = ["'"].concat(unwise);
  var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
  var hostEndingChars = ["/", "?", "#"];
  var hostnameMaxLen = 255;
  var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
  var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
  var unsafeProtocol = { javascript: true, "javascript:": true };
  var hostlessProtocol = { javascript: true, "javascript:": true };
  var slashedProtocol = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
  var querystring = { parse(str) {
    var decode2 = decodeURIComponent;
    return (str + "").replace(/\+/g, " ").split("&").filter(Boolean).reduce(function(obj, item, index) {
      var ref = item.split("="), key = decode2(ref[0] || ""), val = decode2(ref[1] || ""), prev = obj[key];
      return obj[key] = prev === undefined ? val : [].concat(prev, val), obj;
    }, {});
  }, stringify(obj) {
    var encode = encodeURIComponent;
    return Object.keys(obj || {}).reduce(function(arr, key) {
      return [].concat(obj[key]).forEach(function(v) {
        arr.push(encode(key) + "=" + encode(v));
      }), arr;
    }, []).join("&").replace(/\s/g, "+");
  } };
  function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && util_isObject(url) && url instanceof Url)
      return url;
    var u = new Url;
    return u.parse(url, parseQueryString, slashesDenoteHost), u;
  }
  Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
    if (!util_isString(url))
      throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
    var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
    uSplit[0] = uSplit[0].replace(slashRegex, "/"), url = uSplit.join(splitter);
    var rest = url;
    if (rest = rest.trim(), !slashesDenoteHost && url.split("#").length === 1) {
      var simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        if (this.path = rest, this.href = rest, this.pathname = simplePath[1], simplePath[2])
          if (this.search = simplePath[2], parseQueryString)
            this.query = querystring.parse(this.search.substr(1));
          else
            this.query = this.search.substr(1);
        else if (parseQueryString)
          this.search = "", this.query = {};
        return this;
      }
    }
    var proto12 = protocolPattern.exec(rest);
    if (proto12) {
      proto12 = proto12[0];
      var lowerProto = proto12.toLowerCase();
      this.protocol = lowerProto, rest = rest.substr(proto12.length);
    }
    if (slashesDenoteHost || proto12 || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var slashes = rest.substr(0, 2) === "//";
      if (slashes && !(proto12 && hostlessProtocol[proto12]))
        rest = rest.substr(2), this.slashes = true;
    }
    if (!hostlessProtocol[proto12] && (slashes || proto12 && !slashedProtocol[proto12])) {
      var hostEnd = -1;
      for (var i2 = 0;i2 < hostEndingChars.length; i2++) {
        var hec = rest.indexOf(hostEndingChars[i2]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      var auth, atSign;
      if (hostEnd === -1)
        atSign = rest.lastIndexOf("@");
      else
        atSign = rest.lastIndexOf("@", hostEnd);
      if (atSign !== -1)
        auth = rest.slice(0, atSign), rest = rest.slice(atSign + 1), this.auth = decodeURIComponent(auth);
      hostEnd = -1;
      for (var i2 = 0;i2 < nonHostChars.length; i2++) {
        var hec = rest.indexOf(nonHostChars[i2]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      if (hostEnd === -1)
        hostEnd = rest.length;
      this.host = rest.slice(0, hostEnd), rest = rest.slice(hostEnd), this.parseHost(), this.hostname = this.hostname || "";
      var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!ipv6Hostname) {
        var hostparts = this.hostname.split(/\./);
        for (var i2 = 0, l = hostparts.length;i2 < l; i2++) {
          var part = hostparts[i2];
          if (!part)
            continue;
          if (!part.match(hostnamePartPattern)) {
            var newpart = "";
            for (var j = 0, k = part.length;j < k; j++)
              if (part.charCodeAt(j) > 127)
                newpart += "x";
              else
                newpart += part[j];
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i2), notHost = hostparts.slice(i2 + 1), bit = part.match(hostnamePartStart);
              if (bit)
                validParts.push(bit[1]), notHost.unshift(bit[2]);
              if (notHost.length)
                rest = "/" + notHost.join(".") + rest;
              this.hostname = validParts.join(".");
              break;
            }
          }
        }
      }
      if (this.hostname.length > hostnameMaxLen)
        this.hostname = "";
      else
        this.hostname = this.hostname.toLowerCase();
      if (!ipv6Hostname)
        this.hostname = new URL2(`https://${this.hostname}`).hostname;
      var p = this.port ? ":" + this.port : "", h = this.hostname || "";
      if (this.host = h + p, this.href += this.host, ipv6Hostname) {
        if (this.hostname = this.hostname.substr(1, this.hostname.length - 2), rest[0] !== "/")
          rest = "/" + rest;
      }
    }
    if (!unsafeProtocol[lowerProto])
      for (var i2 = 0, l = autoEscape.length;i2 < l; i2++) {
        var ae = autoEscape[i2];
        if (rest.indexOf(ae) === -1)
          continue;
        var esc = encodeURIComponent(ae);
        if (esc === ae)
          esc = escape(ae);
        rest = rest.split(ae).join(esc);
      }
    var hash2 = rest.indexOf("#");
    if (hash2 !== -1)
      this.hash = rest.substr(hash2), rest = rest.slice(0, hash2);
    var qm = rest.indexOf("?");
    if (qm !== -1) {
      if (this.search = rest.substr(qm), this.query = rest.substr(qm + 1), parseQueryString)
        this.query = querystring.parse(this.query);
      rest = rest.slice(0, qm);
    } else if (parseQueryString)
      this.search = "", this.query = {};
    if (rest)
      this.pathname = rest;
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname)
      this.pathname = "/";
    if (this.pathname || this.search) {
      var p = this.pathname || "", s = this.search || "";
      this.path = p + s;
    }
    return this.href = this.format(), this;
  };
  Url.prototype.format = function() {
    var auth = this.auth || "";
    if (auth)
      auth = encodeURIComponent(auth), auth = auth.replace(/%3A/i, ":"), auth += "@";
    var protocol = this.protocol || "", pathname = this.pathname || "", hash2 = this.hash || "", host = false, query = "";
    if (this.host)
      host = auth + this.host;
    else if (this.hostname) {
      if (host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port)
        host += ":" + this.port;
    }
    if (this.query && util_isObject(this.query) && Object.keys(this.query).length)
      query = querystring.stringify(this.query);
    var search = this.search || query && "?" + query || "";
    if (protocol && protocol.substr(-1) !== ":")
      protocol += ":";
    if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
      if (host = "//" + (host || ""), pathname && pathname.charAt(0) !== "/")
        pathname = "/" + pathname;
    } else if (!host)
      host = "";
    if (hash2 && hash2.charAt(0) !== "#")
      hash2 = "#" + hash2;
    if (search && search.charAt(0) !== "?")
      search = "?" + search;
    return pathname = pathname.replace(/[?#]/g, function(match18) {
      return encodeURIComponent(match18);
    }), search = search.replace("#", "%23"), protocol + host + pathname + search + hash2;
  };
  Url.prototype.resolve = function(relative2) {
    return this.resolveObject(urlParse(relative2, false, true)).format();
  };
  Url.prototype.resolveObject = function(relative2) {
    if (util_isString(relative2)) {
      var rel = new Url;
      rel.parse(relative2, false, true), relative2 = rel;
    }
    var result = new Url, tkeys = Object.keys(this);
    for (var tk = 0;tk < tkeys.length; tk++) {
      var tkey = tkeys[tk];
      result[tkey] = this[tkey];
    }
    if (result.hash = relative2.hash, relative2.href === "")
      return result.href = result.format(), result;
    if (relative2.slashes && !relative2.protocol) {
      var rkeys = Object.keys(relative2);
      for (var rk = 0;rk < rkeys.length; rk++) {
        var rkey = rkeys[rk];
        if (rkey !== "protocol")
          result[rkey] = relative2[rkey];
      }
      if (slashedProtocol[result.protocol] && result.hostname && !result.pathname)
        result.path = result.pathname = "/";
      return result.href = result.format(), result;
    }
    if (relative2.protocol && relative2.protocol !== result.protocol) {
      if (!slashedProtocol[relative2.protocol]) {
        var keys3 = Object.keys(relative2);
        for (var v = 0;v < keys3.length; v++) {
          var k = keys3[v];
          result[k] = relative2[k];
        }
        return result.href = result.format(), result;
      }
      if (result.protocol = relative2.protocol, !relative2.host && !hostlessProtocol[relative2.protocol]) {
        var relPath = (relative2.pathname || "").split("/");
        while (relPath.length && !(relative2.host = relPath.shift()))
          ;
        if (!relative2.host)
          relative2.host = "";
        if (!relative2.hostname)
          relative2.hostname = "";
        if (relPath[0] !== "")
          relPath.unshift("");
        if (relPath.length < 2)
          relPath.unshift("");
        result.pathname = relPath.join("/");
      } else
        result.pathname = relative2.pathname;
      if (result.search = relative2.search, result.query = relative2.query, result.host = relative2.host || "", result.auth = relative2.auth, result.hostname = relative2.hostname || relative2.host, result.port = relative2.port, result.pathname || result.search) {
        var p = result.pathname || "", s = result.search || "";
        result.path = p + s;
      }
      return result.slashes = result.slashes || relative2.slashes, result.href = result.format(), result;
    }
    var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative2.host || relative2.pathname && relative2.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative2.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative2.pathname && relative2.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
    if (psychotic) {
      if (result.hostname = "", result.port = null, result.host)
        if (srcPath[0] === "")
          srcPath[0] = result.host;
        else
          srcPath.unshift(result.host);
      if (result.host = "", relative2.protocol) {
        if (relative2.hostname = null, relative2.port = null, relative2.host)
          if (relPath[0] === "")
            relPath[0] = relative2.host;
          else
            relPath.unshift(relative2.host);
        relative2.host = null;
      }
      mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs)
      result.host = relative2.host || relative2.host === "" ? relative2.host : result.host, result.hostname = relative2.hostname || relative2.hostname === "" ? relative2.hostname : result.hostname, result.search = relative2.search, result.query = relative2.query, srcPath = relPath;
    else if (relPath.length) {
      if (!srcPath)
        srcPath = [];
      srcPath.pop(), srcPath = srcPath.concat(relPath), result.search = relative2.search, result.query = relative2.query;
    } else if (!util_isNullOrUndefined(relative2.search)) {
      if (psychotic) {
        result.hostname = result.host = srcPath.shift();
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost)
          result.auth = authInHost.shift(), result.host = result.hostname = authInHost.shift();
      }
      if (result.search = relative2.search, result.query = relative2.query, !util_isNull(result.pathname) || !util_isNull(result.search))
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      return result.href = result.format(), result;
    }
    if (!srcPath.length) {
      if (result.pathname = null, result.search)
        result.path = "/" + result.search;
      else
        result.path = null;
      return result.href = result.format(), result;
    }
    var last4 = srcPath.slice(-1)[0], hasTrailingSlash = (result.host || relative2.host || srcPath.length > 1) && (last4 === "." || last4 === "..") || last4 === "", up = 0;
    for (var i2 = srcPath.length;i2 >= 0; i2--)
      if (last4 = srcPath[i2], last4 === ".")
        srcPath.splice(i2, 1);
      else if (last4 === "..")
        srcPath.splice(i2, 1), up++;
      else if (up)
        srcPath.splice(i2, 1), up--;
    if (!mustEndAbs && !removeAllDots)
      for (;up--; up)
        srcPath.unshift("..");
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/"))
      srcPath.unshift("");
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/")
      srcPath.push("");
    var isAbsolute2 = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
    if (psychotic) {
      result.hostname = result.host = isAbsolute2 ? "" : srcPath.length ? srcPath.shift() : "";
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost)
        result.auth = authInHost.shift(), result.host = result.hostname = authInHost.shift();
    }
    if (mustEndAbs = mustEndAbs || result.host && srcPath.length, mustEndAbs && !isAbsolute2)
      srcPath.unshift("");
    if (!srcPath.length)
      result.pathname = null, result.path = null;
    else
      result.pathname = srcPath.join("/");
    if (!util_isNull(result.pathname) || !util_isNull(result.search))
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    return result.auth = relative2.auth || result.auth, result.slashes = result.slashes || relative2.slashes, result.href = result.format(), result;
  };
  Url.prototype.parseHost = function() {
    var host = this.host, port = portPattern.exec(host);
    if (port) {
      if (port = port[0], port !== ":")
        this.port = port.substr(1);
      host = host.substr(0, host.length - port.length);
    }
    if (host)
      this.hostname = host;
  };

  // node_modules/@effect/platform-node-shared/dist/esm/internal/path.js
  var fromFileUrl2 = (url) => try_2({
    try: () => undefined(url),
    catch: (error) => new BadArgument({
      module: "Path",
      method: "fromFileUrl",
      description: `Invalid file URL: ${url}`,
      cause: error
    })
  });
  var toFileUrl2 = (path) => try_2({
    try: () => undefined(path),
    catch: (error) => new BadArgument({
      module: "Path",
      method: "toFileUrl",
      description: `Invalid path: ${path}`,
      cause: error
    })
  });
  var layerPosix = /* @__PURE__ */ succeed9(Path2, /* @__PURE__ */ Path2.of({
    [TypeId22]: TypeId22,
    ...posix,
    fromFileUrl: fromFileUrl2,
    toFileUrl: toFileUrl2
  }));
  var layerWin32 = /* @__PURE__ */ succeed9(Path2, /* @__PURE__ */ Path2.of({
    [TypeId22]: TypeId22,
    ...undefined,
    fromFileUrl: fromFileUrl2,
    toFileUrl: toFileUrl2
  }));
  var layer8 = /* @__PURE__ */ succeed9(Path2, /* @__PURE__ */ Path2.of({
    [TypeId22]: TypeId22,
    ...exports_path2,
    fromFileUrl: fromFileUrl2,
    toFileUrl: toFileUrl2
  }));

  // node_modules/@effect/platform-node-shared/dist/esm/NodePath.js
  var layer9 = layer8;

  // node_modules/@effect/platform-bun/dist/esm/BunPath.js
  var layer10 = layer9;

  // node_modules/@effect/platform/dist/esm/internal/terminal.js
  var tag2 = /* @__PURE__ */ GenericTag("@effect/platform/Terminal");

  // node_modules/@effect/platform/dist/esm/Terminal.js
  var Terminal = tag2;

  // node_modules/@effect/platform-node-shared/dist/esm/internal/terminal.js
  var readline = (() => ({}));
  var defaultShouldQuit = (input) => input.key.ctrl && (input.key.name === "c" || input.key.name === "d");
  var make61 = /* @__PURE__ */ fnUntraced2(function* (shouldQuit = defaultShouldQuit) {
    const stdin3 = process.stdin;
    const stdout2 = process.stdout;
    const rlRef = yield* make45({
      acquire: acquireRelease2(sync3(() => {
        const rl = readline.createInterface({
          input: stdin3,
          escapeCodeTimeout: 50
        });
        readline.emitKeypressEvents(stdin3, rl);
        if (stdin3.isTTY) {
          stdin3.setRawMode(true);
        }
        return rl;
      }), (rl) => sync3(() => {
        if (stdin3.isTTY) {
          stdin3.setRawMode(false);
        }
        rl.close();
      }))
    });
    const columns = sync3(() => stdout2.columns ?? 0);
    const readInput = gen2(function* () {
      yield* get15(rlRef);
      const mailbox = yield* make55();
      const handleKeypress = (s, k) => {
        const userInput = {
          input: fromNullable(s),
          key: {
            name: k.name ?? "",
            ctrl: !!k.ctrl,
            meta: !!k.meta,
            shift: !!k.shift
          }
        };
        mailbox.unsafeOffer(userInput);
        if (shouldQuit(userInput)) {
          mailbox.unsafeDone(void_2);
        }
      };
      yield* addFinalizer3(() => sync3(() => stdin3.off("keypress", handleKeypress)));
      stdin3.on("keypress", handleKeypress);
      return mailbox;
    });
    const readLine = get15(rlRef).pipe(flatMap11((readlineInterface) => async((resume2) => {
      const onLine = (line) => resume2(succeed8(line));
      readlineInterface.once("line", onLine);
      return sync3(() => readlineInterface.off("line", onLine));
    })), scoped2);
    const display = (prompt) => uninterruptible2(async((resume2) => {
      stdout2.write(prompt, (err) => err ? resume2(fail9(new BadArgument({
        module: "Terminal",
        method: "display",
        description: "Failed to write prompt to stdout",
        cause: err
      }))) : resume2(_void));
    }));
    return Terminal.of({
      columns,
      readInput,
      readLine,
      display
    });
  });
  var layer11 = /* @__PURE__ */ scoped3(Terminal, /* @__PURE__ */ make61(defaultShouldQuit));

  // node_modules/@effect/platform-node-shared/dist/esm/NodeTerminal.js
  var layer12 = layer11;

  // node_modules/@effect/platform-bun/dist/esm/BunTerminal.js
  var layer13 = layer12;

  // node_modules/@effect/platform-bun/dist/esm/internal/worker.js
  var platformWorkerImpl = /* @__PURE__ */ makePlatform2()({
    setup({
      scope: scope5,
      worker
    }) {
      return flatMap11(make19(), (closeDeferred) => {
        worker.addEventListener("close", () => {
          unsafeDone(closeDeferred, void_2);
        });
        return as3(addFinalizer2(scope5, suspend3(() => {
          worker.postMessage([1]);
          return _await(closeDeferred);
        }).pipe(interruptible4, timeout2(5000), catchAllCause3(() => sync3(() => worker.terminate())))), worker);
      });
    },
    listen({
      deferred,
      emit: emit3,
      port,
      scope: scope5
    }) {
      function onMessage(event) {
        emit3(event.data);
      }
      function onError5(event) {
        unsafeDone(deferred, new WorkerError({
          reason: "unknown",
          cause: event.error ?? event.message
        }));
      }
      port.addEventListener("message", onMessage);
      port.addEventListener("error", onError5);
      return addFinalizer2(scope5, sync3(() => {
        port.removeEventListener("message", onMessage);
        port.removeEventListener("error", onError5);
      }));
    }
  });
  var layerWorker = /* @__PURE__ */ succeed9(PlatformWorker2, platformWorkerImpl);
  var layerManager3 = /* @__PURE__ */ provide3(layerManager2, layerWorker);

  // node_modules/@effect/platform-bun/dist/esm/BunWorker.js
  var layerManager4 = layerManager3;

  // node_modules/@effect/platform-bun/dist/esm/BunContext.js
  var layer15 = /* @__PURE__ */ pipe(/* @__PURE__ */ mergeAll6(layer10, layer4, layer13, layerManager4), /* @__PURE__ */ provideMerge2(layer7));
  // src/desktop/protocol.ts
  function generateCorrelationId() {
    return `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  }
  var isSocketResponse = (msg) => {
    if (typeof msg !== "object" || msg === null)
      return false;
    const obj = msg;
    return typeof obj.type === "string" && obj.type.startsWith("response:");
  };
  var isHudEvent = (msg) => {
    if (typeof msg !== "object" || msg === null)
      return false;
    const obj = msg;
    if (typeof obj.type !== "string")
      return false;
    return !obj.type.startsWith("request:") && !obj.type.startsWith("response:");
  };
  var serializeSocketMessage = (msg) => JSON.stringify(msg);
  var parseSocketMessage = (data) => {
    try {
      const parsed = JSON.parse(data);
      if (typeof parsed !== "object" || parsed === null)
        return null;
      if (typeof parsed.type !== "string")
        return null;
      return parsed;
    } catch {
      return null;
    }
  };
  var DESKTOP_HTTP_PORT = 8080;
  var DESKTOP_WS_PATH = "/ws";
  var DESKTOP_WS_URL = `ws://localhost:${DESKTOP_HTTP_PORT}${DESKTOP_WS_PATH}`;

  // src/mainview/socket-client.ts
  class SocketClient {
    ws = null;
    url;
    requestTimeout;
    autoReconnect;
    maxReconnectAttempts;
    verbose;
    pendingRequests = new Map;
    messageQueue = [];
    messageHandlers = [];
    connectHandlers = [];
    disconnectHandlers = [];
    reconnectAttempts = 0;
    reconnectTimer = null;
    isConnecting = false;
    constructor(options = {}) {
      this.url = options.url ?? `ws://localhost:${DESKTOP_HTTP_PORT}${DESKTOP_WS_PATH}`;
      this.requestTimeout = options.requestTimeout ?? 1e4;
      this.autoReconnect = options.autoReconnect ?? true;
      this.maxReconnectAttempts = options.maxReconnectAttempts ?? 10;
      this.verbose = options.verbose ?? false;
    }
    connect() {
      return new Promise((resolve4, reject) => {
        if (this.ws?.readyState === WebSocket.OPEN) {
          resolve4();
          return;
        }
        if (this.isConnecting) {
          const checkInterval = setInterval(() => {
            if (this.ws?.readyState === WebSocket.OPEN) {
              clearInterval(checkInterval);
              resolve4();
            }
          }, 100);
          return;
        }
        this.isConnecting = true;
        this.log(`Connecting to ${this.url}`);
        if (window.bunLog) {
          window.bunLog(`[SocketClient] Connecting to ${this.url}`);
        }
        try {
          this.ws = new WebSocket(this.url);
          if (window.bunLog) {
            window.bunLog(`[SocketClient] WebSocket created, waiting for open...`);
          }
          this.ws.onopen = () => {
            this.isConnecting = false;
            this.reconnectAttempts = 0;
            this.log("Connected");
            if (window.bunLog) {
              window.bunLog(`[SocketClient] WebSocket OPEN!`);
            }
            while (this.messageQueue.length > 0) {
              const msg = this.messageQueue.shift();
              this.ws?.send(msg);
            }
            for (const handler of this.connectHandlers) {
              try {
                handler();
              } catch (e) {
                console.error("[SocketClient] Connect handler error:", e);
              }
            }
            resolve4();
          };
          this.ws.onmessage = (event) => {
            this.handleMessage(event.data);
          };
          this.ws.onclose = () => {
            this.isConnecting = false;
            this.log("Disconnected");
            for (const handler of this.disconnectHandlers) {
              try {
                handler();
              } catch (e) {
                console.error("[SocketClient] Disconnect handler error:", e);
              }
            }
            if (this.autoReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {
              this.scheduleReconnect();
            }
          };
          this.ws.onerror = (error) => {
            this.isConnecting = false;
            this.log(`Connection error: ${error}`);
            if (window.bunLog) {
              window.bunLog(`[SocketClient] WebSocket ERROR:`, String(error));
            }
            reject(new Error("WebSocket connection failed"));
          };
        } catch (e) {
          this.isConnecting = false;
          reject(e);
        }
      });
    }
    disconnect() {
      if (this.reconnectTimer) {
        clearTimeout(this.reconnectTimer);
        this.reconnectTimer = null;
      }
      this.reconnectAttempts = this.maxReconnectAttempts;
      if (this.ws) {
        this.ws.close();
        this.ws = null;
      }
      for (const [_id, pending3] of this.pendingRequests) {
        clearTimeout(pending3.timeout);
        pending3.reject(new Error("Client disconnected"));
      }
      this.pendingRequests.clear();
    }
    isConnected() {
      return this.ws?.readyState === WebSocket.OPEN;
    }
    async request(type, params) {
      const correlationId = generateCorrelationId();
      const request2 = { type, correlationId, ...params };
      return new Promise((resolve4, reject) => {
        const timeout5 = setTimeout(() => {
          this.pendingRequests.delete(correlationId);
          reject(new Error(`Request timeout: ${type}`));
        }, this.requestTimeout);
        this.pendingRequests.set(correlationId, {
          resolve: resolve4,
          reject,
          timeout: timeout5
        });
        const msg = serializeSocketMessage(request2);
        if (this.ws?.readyState === WebSocket.OPEN) {
          this.ws.send(msg);
        } else {
          this.messageQueue.push(msg);
          if (!this.isConnecting && this.autoReconnect) {
            this.connect().catch(() => {});
          }
        }
      });
    }
    onMessage(handler) {
      this.messageHandlers.push(handler);
      return () => {
        const idx = this.messageHandlers.indexOf(handler);
        if (idx >= 0)
          this.messageHandlers.splice(idx, 1);
      };
    }
    onConnect(handler) {
      this.connectHandlers.push(handler);
      return () => {
        const idx = this.connectHandlers.indexOf(handler);
        if (idx >= 0)
          this.connectHandlers.splice(idx, 1);
      };
    }
    onDisconnect(handler) {
      this.disconnectHandlers.push(handler);
      return () => {
        const idx = this.disconnectHandlers.indexOf(handler);
        if (idx >= 0)
          this.disconnectHandlers.splice(idx, 1);
      };
    }
    async loadTBSuite(suitePath) {
      const response = await this.request("request:loadTBSuite", { suitePath });
      if (!response.success) {
        throw new Error(response.error ?? "Failed to load suite");
      }
      return response.data;
    }
    async startTBRun(options) {
      const response = await this.request("request:startTBRun", options);
      if (!response.success) {
        throw new Error(response.error ?? "Failed to start run");
      }
      return response.data;
    }
    async stopTBRun() {
      const response = await this.request("request:stopTBRun", {});
      if (!response.success) {
        throw new Error(response.error ?? "Failed to stop run");
      }
      return response.data;
    }
    async loadRecentTBRuns(count3) {
      const response = await this.request("request:loadRecentTBRuns", { count: count3 });
      if (!response.success) {
        throw new Error(response.error ?? "Failed to load runs");
      }
      return response.data;
    }
    async loadTBRunDetails(runId) {
      const response = await this.request("request:loadTBRunDetails", { runId });
      if (!response.success) {
        throw new Error(response.error ?? "Failed to load run details");
      }
      return response.data ?? null;
    }
    async loadReadyTasks(limit) {
      const response = await this.request("request:loadReadyTasks", { limit });
      if (!response.success) {
        throw new Error(response.error ?? "Failed to load ready tasks");
      }
      return response.data ?? [];
    }
    async assignTaskToMC(taskId, options) {
      const response = await this.request("request:assignTaskToMC", { taskId, options });
      if (!response.success) {
        throw new Error(response.error ?? "Failed to assign task");
      }
      return response.data ?? { assigned: false };
    }
    async loadUnifiedTrajectories(limit) {
      const response = await this.request("request:loadUnifiedTrajectories", { limit });
      if (!response.success) {
        throw new Error(response.error ?? "Failed to load trajectories");
      }
      return response.data ?? [];
    }
    handleMessage(data) {
      const parsed = parseSocketMessage(data);
      if (!parsed) {
        this.log(`Invalid message: ${data.slice(0, 100)}`);
        return;
      }
      if (isSocketResponse(parsed)) {
        const pending3 = this.pendingRequests.get(parsed.correlationId);
        if (pending3) {
          clearTimeout(pending3.timeout);
          this.pendingRequests.delete(parsed.correlationId);
          pending3.resolve(parsed);
        }
        return;
      }
      if (isHudEvent(parsed)) {
        for (const handler of this.messageHandlers) {
          try {
            handler(parsed);
          } catch (e) {
            console.error("[SocketClient] Message handler error:", e);
          }
        }
      }
    }
    scheduleReconnect() {
      if (this.reconnectTimer)
        return;
      const delay3 = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
      this.log(`Reconnecting in ${delay3}ms (attempt ${this.reconnectAttempts + 1})`);
      this.reconnectTimer = setTimeout(() => {
        this.reconnectTimer = null;
        this.reconnectAttempts++;
        this.connect().catch(() => {});
      }, delay3);
    }
    log(msg) {
      if (this.verbose) {
        console.log(`[SocketClient] ${msg}`);
      }
    }
  }
  var defaultClient = null;
  function getSocketClient(options) {
    if (!defaultClient) {
      defaultClient = new SocketClient(options);
    }
    return defaultClient;
  }

  // src/effuse/template/types.ts
  var isTemplateResult = (value) => typeof value === "object" && value !== null && ("_tag" in value) && value._tag === "TemplateResult";

  // src/effuse/template/escape.ts
  var ESCAPE_MAP = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  var escapeHtml = (str) => str.replace(/[&<>"']/g, (char) => ESCAPE_MAP[char] ?? char);

  // src/effuse/template/html.ts
  var renderValue = (value) => {
    if (value === null || value === undefined) {
      return "";
    }
    if (typeof value === "string") {
      return escapeHtml(value);
    }
    if (typeof value === "number" || typeof value === "boolean") {
      return String(value);
    }
    if (isTemplateResult(value)) {
      return value.toString();
    }
    if (Array.isArray(value)) {
      return value.map(renderValue).join("");
    }
    return escapeHtml(String(value));
  };
  function html(strings, ...values3) {
    return {
      _tag: "TemplateResult",
      strings,
      values: values3,
      toString() {
        let result = "";
        for (let i2 = 0;i2 < strings.length; i2++) {
          result += strings[i2];
          if (i2 < values3.length) {
            result += renderValue(values3[i2]);
          }
        }
        return result;
      }
    };
  }
  function rawHtml(content) {
    return {
      _tag: "TemplateResult",
      strings: [content],
      values: [],
      toString() {
        return content;
      }
    };
  }
  function joinTemplates(templates, separator = "") {
    const joined = templates.map((t) => t.toString()).join(separator);
    return rawHtml(joined);
  }
  // src/effuse/state/cell.ts
  var makeCell = (initial) => exports_Effect.gen(function* () {
    const ref = yield* exports_Ref.make(initial);
    const queue = yield* exports_Queue.unbounded();
    yield* exports_Effect.addFinalizer(() => exports_Queue.shutdown(queue));
    const cell = {
      get: exports_Ref.get(ref),
      set: (value) => exports_Effect.gen(function* () {
        yield* exports_Ref.set(ref, value);
        yield* exports_Queue.offer(queue, value);
      }),
      update: (f) => exports_Effect.gen(function* () {
        const newValue = yield* exports_Ref.updateAndGet(ref, f);
        yield* exports_Queue.offer(queue, newValue);
      }),
      changes: exports_Stream.fromQueue(queue)
    };
    return cell;
  });
  // src/effuse/services/dom.ts
  class DomError extends Error {
    reason;
    _tag = "DomError";
    constructor(reason, message) {
      super(message);
      this.reason = reason;
      this.name = "DomError";
    }
  }

  class DomServiceTag extends exports_Context.Tag("effuse/DomService")() {
  }
  // src/effuse/services/state.ts
  class StateServiceTag extends exports_Context.Tag("effuse/StateService")() {
  }
  // src/effuse/services/socket.ts
  class SocketError extends Error {
    reason;
    _tag = "SocketError";
    constructor(reason, message) {
      super(message);
      this.reason = reason;
      this.name = "SocketError";
    }
  }

  class SocketServiceTag extends exports_Context.Tag("effuse/SocketService")() {
  }
  // src/effuse/services/dom-live.ts
  var makeDomService = (root = document) => ({
    query: (selector) => exports_Effect.gen(function* () {
      const element = root.querySelector(selector);
      if (!element) {
        return yield* exports_Effect.fail(new DomError("element_not_found", `Element not found: ${selector}`));
      }
      return element;
    }),
    queryOption: (selector) => exports_Effect.succeed(root.querySelector(selector)),
    queryId: (id2) => exports_Effect.gen(function* () {
      const element = document.getElementById(id2);
      if (!element) {
        return yield* exports_Effect.fail(new DomError("element_not_found", `Element not found: #${id2}`));
      }
      return element;
    }),
    render: (element, content) => exports_Effect.gen(function* () {
      try {
        element.innerHTML = content.toString();
      } catch (error) {
        return yield* exports_Effect.fail(new DomError("render_failed", `Failed to render: ${error instanceof Error ? error.message : String(error)}`));
      }
    }),
    listen: (element, event, handler, options) => exports_Effect.sync(() => {
      const listener = handler;
      element.addEventListener(event, listener, options);
      return () => element.removeEventListener(event, listener, options);
    }),
    delegate: (container, selector, event, handler) => exports_Effect.sync(() => {
      const listener = (e) => {
        const target = e.target?.closest(selector);
        if (target && container.contains(target)) {
          handler(e, target);
        }
      };
      container.addEventListener(event, listener);
      return () => container.removeEventListener(event, listener);
    }),
    createFragment: (content) => exports_Effect.gen(function* () {
      try {
        const template = document.createElement("template");
        template.innerHTML = content.toString();
        return template.content;
      } catch (error) {
        return yield* exports_Effect.fail(new DomError("render_failed", `Failed to create fragment: ${error instanceof Error ? error.message : String(error)}`));
      }
    })
  });
  var DomServiceLive = exports_Layer.effect(DomServiceTag, exports_Effect.sync(() => makeDomService()));
  // src/effuse/services/state-live.ts
  var makeStateService = () => ({
    cell: makeCell
  });
  var StateServiceLive = exports_Layer.succeed(StateServiceTag, makeStateService());
  // src/effuse/services/socket-live.ts
  var wrapRequest = (fn2, errorReason = "request_failed") => exports_Effect.tryPromise({
    try: fn2,
    catch: (error) => new SocketError(errorReason, error instanceof Error ? error.message : String(error))
  });
  var makeSocketService = (client) => {
    let messageStream = null;
    return {
      connect: () => exports_Effect.tryPromise({
        try: () => client.connect(),
        catch: (error) => new SocketError("connection_failed", error instanceof Error ? error.message : String(error))
      }),
      disconnect: () => exports_Effect.sync(() => client.disconnect()),
      isConnected: () => exports_Effect.sync(() => client.isConnected()),
      getMessages: () => {
        if (!messageStream) {
          messageStream = exports_Stream.async((emit3) => {
            const unsubscribe = client.onMessage((message) => {
              emit3.single(message).catch(() => {});
            });
            return exports_Effect.sync(unsubscribe);
          });
        }
        return messageStream;
      },
      loadTBSuite: (suitePath) => wrapRequest(() => client.loadTBSuite(suitePath)),
      startTBRun: (options) => wrapRequest(() => client.startTBRun(options)),
      stopTBRun: () => wrapRequest(() => client.stopTBRun()),
      loadRecentTBRuns: (count3) => wrapRequest(() => client.loadRecentTBRuns(count3)),
      loadTBRunDetails: (runId) => wrapRequest(() => client.loadTBRunDetails(runId)),
      loadReadyTasks: (limit) => wrapRequest(() => client.loadReadyTasks(limit)),
      assignTaskToMC: (taskId, options) => wrapRequest(() => client.assignTaskToMC(taskId, options)),
      loadUnifiedTrajectories: (limit) => wrapRequest(() => client.loadUnifiedTrajectories(limit))
    };
  };
  var SocketServiceLive = (options) => exports_Layer.succeed(SocketServiceTag, makeSocketService(new SocketClient(options)));
  var SocketServiceFromClient = (client) => exports_Layer.succeed(SocketServiceTag, makeSocketService(client));
  var SocketServiceDefault = SocketServiceLive();
  // src/effuse/widget/mount.ts
  var mountWidget = (widget, container) => exports_Effect.gen(function* () {
    const dom = yield* DomServiceTag;
    const stateService = yield* StateServiceTag;
    const state = yield* stateService.cell(widget.initialState());
    const eventQueue = yield* exports_Effect.acquireRelease(exports_Queue.unbounded(), (queue) => exports_Queue.shutdown(queue));
    const emit3 = (event) => exports_Queue.offer(eventQueue, event).pipe(exports_Effect.catchAll(() => exports_Effect.void));
    const ctx = {
      state,
      emit: emit3,
      dom,
      container
    };
    const initialContent = yield* widget.render(ctx);
    yield* dom.render(container, initialContent).pipe(exports_Effect.catchAll((error) => {
      console.error(`[Effuse] Initial render error for "${widget.id}":`, error);
      return exports_Effect.void;
    }));
    if (widget.setupEvents) {
      yield* widget.setupEvents(ctx);
    }
    yield* pipe(state.changes, exports_Stream.tap(() => exports_Effect.gen(function* () {
      const content = yield* widget.render(ctx);
      yield* dom.render(container, content).pipe(exports_Effect.catchAll((error) => {
        console.error(`[Effuse] Re-render error for "${widget.id}":`, error);
        return exports_Effect.void;
      }));
    })), exports_Stream.runDrain, exports_Effect.forkScoped);
    if (widget.handleEvent) {
      yield* pipe(exports_Stream.fromQueue(eventQueue), exports_Stream.tap((event) => widget.handleEvent(event, ctx)), exports_Stream.runDrain, exports_Effect.forkScoped);
    }
    if (widget.subscriptions) {
      const subs = widget.subscriptions(ctx);
      for (const sub of subs) {
        yield* pipe(sub, exports_Stream.tap((effect4) => effect4), exports_Stream.runDrain, exports_Effect.forkScoped);
      }
    }
    const mounted = {
      unmount: exports_Effect.void,
      events: exports_Stream.fromQueue(eventQueue),
      emit: emit3
    };
    return mounted;
  });
  var mountWidgetById = (widget, containerId) => exports_Effect.gen(function* () {
    const dom = yield* DomServiceTag;
    const container = yield* dom.queryId(containerId);
    return yield* mountWidget(widget, container);
  }).pipe(exports_Effect.catchAll((error) => {
    console.error(`[Effuse] Failed to mount widget "${widget.id}":`, error);
    return exports_Effect.succeed({
      unmount: exports_Effect.void,
      events: exports_Stream.empty,
      emit: () => exports_Effect.void
    });
  }));
  // src/effuse/layers/live.ts
  var EffuseLive = exports_Layer.mergeAll(DomServiceLive, StateServiceLive, SocketServiceDefault);
  var EffuseLiveNoSocket = exports_Layer.mergeAll(DomServiceLive, StateServiceLive);
  // src/effuse/widgets/apm-widget.ts
  var getAPMColorClass = (apm) => {
    if (apm >= 30)
      return "text-emerald-400";
    if (apm >= 15)
      return "text-zinc-200";
    if (apm >= 5)
      return "text-zinc-400";
    return "text-zinc-500";
  };
  var getAPMBgClass = (apm) => {
    if (apm >= 30)
      return "bg-emerald-950/20 border-emerald-800/40";
    if (apm >= 15)
      return "bg-zinc-900/60 border-zinc-700/50";
    if (apm >= 5)
      return "bg-zinc-900/40 border-zinc-700/40";
    return "bg-zinc-950/40 border-zinc-800/30";
  };
  var formatDuration = (minutes2) => {
    if (minutes2 < 60)
      return `${minutes2.toFixed(0)}m`;
    const hours2 = Math.floor(minutes2 / 60);
    const mins = Math.round(minutes2 % 60);
    return mins > 0 ? `${hours2}h ${mins}m` : `${hours2}h`;
  };
  var isAPMUpdate = (msg) => msg.type === "apm_update";
  var isAPMSnapshot = (msg) => msg.type === "apm_snapshot";
  var APMWidget = {
    id: "apm-widget",
    initialState: () => ({
      sessionAPM: 0,
      recentAPM: 0,
      totalActions: 0,
      durationMinutes: 0,
      apm1h: 0,
      apm6h: 0,
      apm1d: 0,
      apmLifetime: 0,
      claudeCodeAPM: 0,
      mechaCoderAPM: 0,
      efficiencyRatio: 0,
      expanded: false
    }),
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      const colorClass = getAPMColorClass(state.sessionAPM);
      const bgClass = getAPMBgClass(state.sessionAPM);
      if (!state.expanded) {
        return html`
          <div
            class="fixed bottom-4 right-4 rounded-xl border ${bgClass} px-4 py-3 shadow-lg backdrop-blur-sm cursor-pointer transition-all hover:scale-105"
            data-action="toggleExpand"
          >
            <div class="flex items-center gap-3">
              <div class="text-2xl font-bold ${colorClass} font-mono">
                ${state.sessionAPM.toFixed(1)}
              </div>
              <div class="text-xs text-zinc-500 uppercase tracking-wide">APM</div>
            </div>
            ${state.totalActions > 0 ? html`
                  <div class="text-xs text-zinc-500 mt-1">
                    ${state.totalActions} actions in ${formatDuration(state.durationMinutes)}
                  </div>
                ` : ""}
          </div>
        `;
      }
      return html`
        <div
          class="fixed bottom-4 right-4 w-72 rounded-xl border ${bgClass} shadow-xl backdrop-blur-sm"
        >
          <!-- Header -->
          <div
            class="flex items-center justify-between px-4 py-3 border-b border-zinc-800/50 cursor-pointer"
            data-action="toggleExpand"
          >
            <div class="flex items-center gap-2">
              <div class="text-xl font-bold ${colorClass} font-mono">
                ${state.sessionAPM.toFixed(1)}
              </div>
              <div class="text-xs text-zinc-500 uppercase">APM</div>
            </div>
            <div class="text-zinc-500 text-sm">-</div>
          </div>

          <!-- Current Session -->
          <div class="px-4 py-3 border-b border-zinc-800/30">
            <div class="text-xs text-zinc-500 uppercase tracking-wide mb-2">Session</div>
            <div class="grid grid-cols-2 gap-2 text-sm">
              <div>
                <span class="text-zinc-500">Recent:</span>
                <span class="text-zinc-300 font-mono ml-1">${state.recentAPM.toFixed(1)}</span>
              </div>
              <div>
                <span class="text-zinc-500">Actions:</span>
                <span class="text-zinc-300 font-mono ml-1">${state.totalActions}</span>
              </div>
              <div class="col-span-2">
                <span class="text-zinc-500">Duration:</span>
                <span class="text-zinc-300 ml-1">${formatDuration(state.durationMinutes)}</span>
              </div>
            </div>
          </div>

          <!-- Historical -->
          ${state.apm1h > 0 || state.apmLifetime > 0 ? html`
                <div class="px-4 py-3 border-b border-zinc-800/30">
                  <div class="text-xs text-zinc-500 uppercase tracking-wide mb-2">Historical</div>
                  <div class="grid grid-cols-2 gap-2 text-sm">
                    <div>
                      <span class="text-zinc-500">1h:</span>
                      <span class="text-zinc-300 font-mono ml-1">${state.apm1h.toFixed(1)}</span>
                    </div>
                    <div>
                      <span class="text-zinc-500">6h:</span>
                      <span class="text-zinc-300 font-mono ml-1">${state.apm6h.toFixed(1)}</span>
                    </div>
                    <div>
                      <span class="text-zinc-500">1d:</span>
                      <span class="text-zinc-300 font-mono ml-1">${state.apm1d.toFixed(1)}</span>
                    </div>
                    <div>
                      <span class="text-zinc-500">All:</span>
                      <span class="text-zinc-300 font-mono ml-1">${state.apmLifetime.toFixed(1)}</span>
                    </div>
                  </div>
                </div>
              ` : ""}

          <!-- Comparison -->
          ${state.efficiencyRatio > 0 ? html`
                <div class="px-4 py-3">
                  <div class="text-xs text-zinc-500 uppercase tracking-wide mb-2">Comparison</div>
                  <div class="grid grid-cols-2 gap-2 text-sm">
                    <div>
                      <span class="text-zinc-500">Claude:</span>
                      <span class="text-zinc-300 font-mono ml-1">${state.claudeCodeAPM.toFixed(1)}</span>
                    </div>
                    <div>
                      <span class="text-zinc-500">MC:</span>
                      <span class="text-zinc-300 font-mono ml-1">${state.mechaCoderAPM.toFixed(1)}</span>
                    </div>
                  </div>
                  <div class="mt-2 text-sm">
                    <span class="text-emerald-400 font-medium">
                      ${state.efficiencyRatio.toFixed(1)}x
                    </span>
                    <span class="text-zinc-500 ml-1">efficiency boost</span>
                  </div>
                </div>
              ` : ""}
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (_e, target) => {
        const action = target.dataset.action;
        if (action === "toggleExpand") {
          exports_Effect.runFork(ctx.emit({ type: "toggleExpand" }));
        }
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      switch (event.type) {
        case "toggleExpand":
          yield* ctx.state.update((s) => ({ ...s, expanded: !s.expanded }));
          break;
        case "refresh":
          break;
      }
    }),
    subscriptions: (ctx) => {
      const socket = exports_Effect.map(SocketServiceTag, (s) => s);
      return [
        pipe(exports_Stream.unwrap(exports_Effect.map(socket, (s) => s.getMessages())), exports_Stream.filter((msg) => isAPMUpdate(msg) || isAPMSnapshot(msg)), exports_Stream.map((msg) => exports_Effect.gen(function* () {
          if (isAPMUpdate(msg)) {
            yield* ctx.state.update((s) => ({
              ...s,
              sessionAPM: msg.sessionAPM,
              recentAPM: msg.recentAPM,
              totalActions: msg.totalActions,
              durationMinutes: msg.durationMinutes
            }));
          }
          if (isAPMSnapshot(msg)) {
            yield* ctx.state.update((s) => ({
              ...s,
              apm1h: msg.combined.apm1h,
              apm6h: msg.combined.apm6h,
              apm1d: msg.combined.apm1d,
              apmLifetime: msg.combined.apmLifetime,
              claudeCodeAPM: msg.comparison.claudeCodeAPM,
              mechaCoderAPM: msg.comparison.mechaCoderAPM,
              efficiencyRatio: msg.comparison.efficiencyRatio
            }));
          }
        })))
      ];
    }
  };
  var initialAPMState = APMWidget.initialState();
  // src/effuse/widgets/trajectory-pane.ts
  var formatTimestamp = (iso) => {
    try {
      return new Date(iso).toLocaleString(undefined, {
        month: "short",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      });
    } catch {
      return iso;
    }
  };
  var shortId = (id2) => id2.slice(-8);
  var getTypeClass = (type) => {
    return type === "tb-run" ? "bg-emerald-900/40 text-emerald-300 border-emerald-700/50" : "bg-violet-900/40 text-violet-300 border-violet-700/50";
  };
  var getTypeLabel = (type) => {
    return type === "tb-run" ? "TB" : "ATIF";
  };
  var TrajectoryPaneWidget = {
    id: "trajectory-pane",
    initialState: () => ({
      trajectories: [],
      selectedId: null,
      loading: false,
      error: null,
      collapsed: false
    }),
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      const header = html`
        <div class="flex items-center justify-between px-3 py-2 border-b border-zinc-800/60">
          <button
            class="text-sm font-medium text-zinc-300 hover:text-zinc-100 transition-colors"
            data-action="toggleCollapse"
          >
            ${state.collapsed ? "+" : "-"} Trajectories
          </button>
          <div class="flex items-center gap-2">
            <span class="text-xs text-zinc-500">${state.trajectories.length}</span>
            <button
              class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
              data-action="load"
            >
              ${state.loading ? "Loading..." : "Refresh"}
            </button>
          </div>
        </div>
      `;
      if (state.collapsed) {
        return html`
          <div class="h-full flex flex-col bg-zinc-950/80 border-r border-zinc-800/60">
            ${header}
          </div>
        `;
      }
      if (state.loading && state.trajectories.length === 0) {
        return html`
          <div class="h-full flex flex-col bg-zinc-950/80 border-r border-zinc-800/60">
            ${header}
            <div class="flex-1 flex items-center justify-center">
              <div class="text-sm text-zinc-500">Loading trajectories...</div>
            </div>
          </div>
        `;
      }
      if (state.error && state.trajectories.length === 0) {
        return html`
          <div class="h-full flex flex-col bg-zinc-950/80 border-r border-zinc-800/60">
            ${header}
            <div class="flex-1 flex items-center justify-center p-4">
              <div class="text-sm text-red-400 text-center">${state.error}</div>
            </div>
          </div>
        `;
      }
      if (state.trajectories.length === 0) {
        return html`
          <div class="h-full flex flex-col bg-zinc-950/80 border-r border-zinc-800/60">
            ${header}
            <div class="flex-1 flex items-center justify-center p-4">
              <div class="text-sm text-zinc-500 text-center">
                No trajectories found.<br />
                <button class="text-zinc-400 hover:text-zinc-200 underline mt-2" data-action="load">
                  Load trajectories
                </button>
              </div>
            </div>
          </div>
        `;
      }
      const trajectoryCards = state.trajectories.map((traj) => {
        const isSelected = traj.id === state.selectedId;
        const typeClass = getTypeClass(traj.type);
        return html`
          <div
            class="px-3 py-2 border-b border-zinc-800/40 cursor-pointer transition-colors
                   ${isSelected ? "bg-zinc-800/60" : "hover:bg-zinc-900/40"}"
            data-action="select"
            data-trajectory-id="${traj.id}"
          >
            <div class="flex items-center justify-between mb-1">
              <code class="text-xs font-mono text-zinc-400">${shortId(traj.id)}</code>
              <span class="text-xs px-1.5 py-0.5 rounded border ${typeClass}">
                ${getTypeLabel(traj.type)}
              </span>
            </div>
            <div class="text-sm text-zinc-300 truncate" title="${traj.label}">
              ${traj.label}
            </div>
            <div class="text-xs text-zinc-500 mt-1">
              ${formatTimestamp(traj.timestamp)}
            </div>
          </div>
        `;
      });
      return html`
        <div class="h-full flex flex-col bg-zinc-950/80 border-r border-zinc-800/60">
          ${header}
          <div class="flex-1 overflow-y-auto">
            ${trajectoryCards}
          </div>
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (_e, target) => {
        const action = target.dataset.action;
        const trajectoryId = target.dataset.trajectoryId;
        if (action === "load") {
          exports_Effect.runFork(ctx.emit({ type: "load" }));
        } else if (action === "select" && trajectoryId) {
          exports_Effect.runFork(ctx.emit({ type: "select", trajectoryId }));
        } else if (action === "toggleCollapse") {
          exports_Effect.runFork(ctx.emit({ type: "toggleCollapse" }));
        }
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      const socket = yield* SocketServiceTag;
      switch (event.type) {
        case "load":
          yield* ctx.state.update((s) => ({ ...s, loading: true, error: null }));
          const result = yield* socket.loadUnifiedTrajectories(50).pipe(exports_Effect.map((trajectories) => ({ trajectories, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ trajectories: [], error: e.message })));
          yield* ctx.state.update((s) => ({
            ...s,
            loading: false,
            trajectories: result.trajectories,
            error: result.error
          }));
          break;
        case "select":
          yield* ctx.state.update((s) => ({ ...s, selectedId: event.trajectoryId }));
          break;
        case "toggleCollapse":
          yield* ctx.state.update((s) => ({ ...s, collapsed: !s.collapsed }));
          break;
        case "clear":
          yield* ctx.state.update((s) => ({
            ...s,
            trajectories: [],
            selectedId: null,
            error: null
          }));
          break;
      }
    })
  };
  var initialTrajectoryPaneState = TrajectoryPaneWidget.initialState();
  // src/effuse/widgets/container-panes.ts
  var MAX_VISIBLE_PANES = 10;
  var MAX_LINES_PER_PANE = 500;
  var getStatusIcon = (pane) => {
    if (pane.status === "running")
      return "";
    if (pane.status === "completed" && pane.exitCode === 0)
      return "";
    return "";
  };
  var getStatusColorClass = (pane) => {
    if (pane.status === "running")
      return "text-zinc-300";
    if (pane.exitCode === 0)
      return "text-emerald-400";
    return "text-red-400";
  };
  var formatDuration2 = (ms) => {
    if (ms === undefined)
      return "";
    return `${(ms / 1000).toFixed(1)}s`;
  };
  var truncateCommand = (command, maxLen = 60) => {
    const full = command.join(" ");
    if (full.length <= maxLen)
      return full;
    return full.slice(0, maxLen) + "...";
  };
  var isContainerStart = (msg) => msg.type === "container_start";
  var isContainerOutput = (msg) => msg.type === "container_output";
  var isContainerComplete = (msg) => msg.type === "container_complete";
  var isContainerError = (msg) => msg.type === "container_error";
  var isContainerMessage = (msg) => isContainerStart(msg) || isContainerOutput(msg) || isContainerComplete(msg) || isContainerError(msg);
  var ContainerPanesWidget = {
    id: "container-panes",
    initialState: () => ({
      panes: new Map,
      maxVisible: MAX_VISIBLE_PANES,
      maxLinesPerPane: MAX_LINES_PER_PANE,
      collapsed: false
    }),
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      const panes = Array.from(state.panes.values()).sort((a, b) => b.startedAt.localeCompare(a.startedAt)).slice(0, state.maxVisible);
      const header = html`
        <div class="flex items-center justify-between px-3 py-2 border-b border-zinc-800/60">
          <button
            class="text-sm font-medium text-zinc-300 hover:text-zinc-100 transition-colors"
            data-action="toggleCollapse"
          >
            ${state.collapsed ? "+" : "-"} Containers
          </button>
          <div class="flex items-center gap-2">
            <span class="text-xs text-zinc-500">${panes.length} active</span>
            ${panes.length > 0 ? html`
                  <button
                    class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
                    data-action="clear"
                  >
                    Clear
                  </button>
                ` : ""}
          </div>
        </div>
      `;
      if (state.collapsed) {
        return html`
          <div class="flex flex-col bg-zinc-950/80 border border-zinc-800/60 rounded-lg">
            ${header}
          </div>
        `;
      }
      if (panes.length === 0) {
        return html`
          <div class="flex flex-col bg-zinc-950/80 border border-zinc-800/60 rounded-lg">
            ${header}
            <div class="flex items-center justify-center py-8">
              <div class="text-sm text-zinc-500">No container executions</div>
            </div>
          </div>
        `;
      }
      const paneCards = panes.map((pane) => {
        const statusIcon = getStatusIcon(pane);
        const statusColor = getStatusColorClass(pane);
        const duration2 = formatDuration2(pane.durationMs);
        const cmdDisplay = truncateCommand(pane.command);
        const badge = pane.sandboxed ? html`<span class="text-xs px-1.5 py-0.5 rounded bg-violet-900/40 text-violet-300 border border-violet-700/50">sandbox</span>` : html`<span class="text-xs px-1.5 py-0.5 rounded bg-amber-900/40 text-amber-300 border border-amber-700/50">host</span>`;
        const exitCodeBadge = pane.exitCode !== undefined ? html`
                <span
                  class="text-xs px-1.5 py-0.5 rounded font-mono ${pane.exitCode === 0 ? "bg-emerald-900/40 text-emerald-300" : "bg-red-900/40 text-red-300"}"
                >
                  ${pane.exitCode}
                </span>
              ` : "";
        const outputLines = pane.outputLines.slice(-100).map((line) => html`
            <div class="font-mono text-xs ${line.stream === "stderr" ? "text-red-400" : "text-zinc-300"}">
              ${line.text}
            </div>
          `);
        return html`
          <div
            class="border border-zinc-800/50 rounded-lg overflow-hidden ${pane.status === "running" ? "border-l-2 border-l-blue-500" : ""}"
            data-execution-id="${pane.executionId}"
          >
            <div class="flex items-center justify-between px-3 py-2 bg-zinc-900/60">
              <div class="flex items-center gap-2">
                <span class="${statusColor}">${statusIcon}</span>
                <span class="text-sm text-zinc-300">${pane.image}</span>
                ${badge}
              </div>
              <div class="flex items-center gap-2">
                ${duration2 ? html`<span class="text-xs text-zinc-500">${duration2}</span>` : ""}
                ${exitCodeBadge}
                <button
                  class="text-zinc-500 hover:text-zinc-300 transition-colors"
                  data-action="dismiss"
                  data-execution-id="${pane.executionId}"
                >
                  
                </button>
              </div>
            </div>
            <div class="px-3 py-1 border-b border-zinc-800/40 bg-zinc-900/40">
              <code class="text-xs text-zinc-400 font-mono" title="${pane.command.join(" ")}">
                ${cmdDisplay}
              </code>
            </div>
            <div class="px-3 py-2 max-h-40 overflow-y-auto bg-zinc-950/60">
              ${outputLines.length > 0 ? joinTemplates(outputLines) : html`<div class="text-xs text-zinc-600">No output yet</div>`}
            </div>
          </div>
        `;
      });
      return html`
        <div class="flex flex-col bg-zinc-950/80 border border-zinc-800/60 rounded-lg">
          ${header}
          <div class="p-3 grid gap-3">
            ${joinTemplates(paneCards)}
          </div>
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (_e, target) => {
        const el = target;
        const action = el.dataset.action;
        const executionId = el.dataset.executionId;
        if (action === "clear") {
          exports_Effect.runFork(ctx.emit({ type: "clear" }));
        } else if (action === "toggleCollapse") {
          exports_Effect.runFork(ctx.emit({ type: "toggleCollapse" }));
        } else if (action === "dismiss" && executionId) {
          exports_Effect.runFork(ctx.emit({ type: "dismiss", executionId }));
        }
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      switch (event.type) {
        case "clear":
          yield* ctx.state.update((s) => ({
            ...s,
            panes: new Map
          }));
          break;
        case "toggleCollapse":
          yield* ctx.state.update((s) => ({ ...s, collapsed: !s.collapsed }));
          break;
        case "dismiss":
          yield* ctx.state.update((s) => {
            const newPanes = new Map(s.panes);
            newPanes.delete(event.executionId);
            return { ...s, panes: newPanes };
          });
          break;
      }
    }),
    subscriptions: (ctx) => {
      const socket = exports_Effect.map(SocketServiceTag, (s) => s);
      return [
        pipe(exports_Stream.unwrap(exports_Effect.map(socket, (s) => s.getMessages())), exports_Stream.filter((msg) => isContainerMessage(msg)), exports_Stream.map((msg) => exports_Effect.gen(function* () {
          if (isContainerStart(msg)) {
            yield* ctx.state.update((s) => {
              const newPanes = new Map(s.panes);
              newPanes.set(msg.executionId, {
                executionId: msg.executionId,
                image: msg.image,
                command: msg.command,
                context: msg.context,
                sandboxed: msg.sandboxed,
                workdir: msg.workdir,
                status: "running",
                outputLines: [],
                startedAt: msg.timestamp
              });
              return { ...s, panes: newPanes };
            });
          }
          if (isContainerOutput(msg)) {
            yield* ctx.state.update((s) => {
              const pane = s.panes.get(msg.executionId);
              if (!pane)
                return s;
              const newPanes = new Map(s.panes);
              const updatedLines = [
                ...pane.outputLines,
                { text: msg.text, stream: msg.stream, sequence: msg.sequence }
              ].slice(-s.maxLinesPerPane);
              newPanes.set(msg.executionId, {
                ...pane,
                outputLines: updatedLines
              });
              return { ...s, panes: newPanes };
            });
          }
          if (isContainerComplete(msg)) {
            yield* ctx.state.update((s) => {
              const pane = s.panes.get(msg.executionId);
              if (!pane)
                return s;
              const newPanes = new Map(s.panes);
              newPanes.set(msg.executionId, {
                ...pane,
                status: "completed",
                exitCode: msg.exitCode,
                durationMs: msg.durationMs
              });
              return { ...s, panes: newPanes };
            });
          }
          if (isContainerError(msg)) {
            yield* ctx.state.update((s) => {
              const pane = s.panes.get(msg.executionId);
              if (!pane)
                return s;
              const newPanes = new Map(s.panes);
              newPanes.set(msg.executionId, {
                ...pane,
                status: "error",
                outputLines: [
                  ...pane.outputLines,
                  { text: `Error: ${msg.error}`, stream: "stderr", sequence: Date.now() }
                ]
              });
              return { ...s, panes: newPanes };
            });
          }
        })))
      ];
    }
  };
  var initialContainerPanesState = ContainerPanesWidget.initialState();
  // src/hud/protocol.ts
  var HUD_WS_PORT = 8080;
  var HUD_WS_URL = `ws://localhost:${HUD_WS_PORT}/ws`;
  var isATIFStep = (msg) => msg.type === "atif_step";

  // src/effuse/widgets/tb-output.ts
  var MAX_OUTPUT_LINES = 500;
  var getSourceColorClass = (source) => {
    switch (source) {
      case "agent":
        return "text-blue-300";
      case "verification":
        return "text-emerald-300";
      case "system":
        return "text-zinc-400";
      case "tool":
        return "text-amber-300";
    }
  };
  var getSourceLabel = (source) => {
    switch (source) {
      case "agent":
        return "AGT";
      case "verification":
        return "VRF";
      case "system":
        return "SYS";
      case "tool":
        return "TL";
    }
  };
  var formatToolCall = (toolCall) => {
    const args2 = toolCall.arguments;
    let argsStr = "";
    if (args2 && typeof args2 === "object") {
      const truncated = Object.entries(args2).slice(0, 3).map(([k, v]) => {
        const val = typeof v === "string" && v.length > 50 ? v.slice(0, 47) + "..." : v;
        return `${k}=${JSON.stringify(val)}`;
      }).join(", ");
      argsStr = truncated + (Object.keys(args2).length > 3 ? ", ..." : "");
    }
    return ` ${toolCall.function_name}(${argsStr})`;
  };
  var formatObservationResult = (result) => {
    const content = result.content;
    if (typeof content === "string") {
      const truncated = content.length > 100 ? content.slice(0, 97) + "..." : content;
      return ` ${truncated}`;
    }
    if (content && typeof content === "object") {
      const str = JSON.stringify(content);
      return ` ${str.length > 100 ? str.slice(0, 97) + "..." : str}`;
    }
    return ` (result)`;
  };
  var isTBTaskOutput = (msg) => msg.type === "tb_task_output";
  var isTBRunStart = (msg) => msg.type === "tb_run_start";
  var isTBRunComplete = (msg) => msg.type === "tb_run_complete";
  var isTBMessage = (msg) => isTBTaskOutput(msg) || isTBRunStart(msg) || isTBRunComplete(msg) || isATIFStep(msg);
  var TBOutputWidget = {
    id: "tb-output",
    initialState: () => ({
      outputLines: [],
      maxLines: MAX_OUTPUT_LINES,
      visible: false,
      runId: null,
      taskId: null,
      autoScroll: true,
      showLineNumbers: true,
      selectedLine: null,
      visibleSources: {
        agent: true,
        verification: true,
        system: true,
        tool: true
      }
    }),
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      if (!state.visible) {
        return html`<div class="hidden"></div>`;
      }
      const header = html`
        <div class="flex items-center justify-between px-3 py-2 border-b border-zinc-800/60 bg-zinc-900/80">
          <div class="flex items-center gap-2">
            <span class="text-sm font-medium text-zinc-300">TB Output</span>
            ${state.runId ? html`<code class="text-xs text-zinc-500 font-mono">${state.runId.slice(-8)}</code>` : ""}
            ${state.taskId ? html`<span class="text-xs text-zinc-400"> ${state.taskId}</span>` : ""}
          </div>
          <div class="flex items-center gap-2">
            <button
              class="text-xs px-2 py-1 rounded border transition-colors ${state.autoScroll ? "bg-blue-900/40 text-blue-300 border-blue-700/50" : "text-zinc-400 border-zinc-700/50 hover:border-zinc-600/60"}"
              data-action="toggleAutoScroll"
              title="Auto-scroll"
            >
              
            </button>
            <div class="flex items-center gap-1">
              ${["agent", "verification", "system", "tool"].map((source) => {
        const active2 = state.visibleSources[source];
        const label = getSourceLabel(source);
        const base = "text-xs px-2 py-1 rounded border transition-colors";
        const activeClasses = "bg-zinc-800/80 text-zinc-100 border-zinc-600/60";
        const inactiveClasses = "text-zinc-400 border-zinc-700/50 hover:border-zinc-600/60";
        return html`
                  <button
                    class="${base} ${active2 ? activeClasses : inactiveClasses}"
                    data-action="toggleSource"
                    data-source="${source}"
                    title="Toggle ${source} output"
                  >
                    ${label}
                  </button>
                `;
      })}
            </div>
            <button
              class="text-xs px-2 py-1 rounded border transition-colors ${state.showLineNumbers ? "bg-zinc-800/80 text-zinc-100 border-zinc-600/60" : "text-zinc-400 border-zinc-700/50 hover:border-zinc-600/60"}"
              data-action="toggleLineNumbers"
              title="Toggle line numbers"
            >
              #
            </button>
            <button
              class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
              data-action="copy"
            >
              Copy
            </button>
            <button
              class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
              data-action="clear"
            >
              Clear
            </button>
            <button
              class="text-zinc-500 hover:text-zinc-300 transition-colors"
              data-action="close"
            >
              
            </button>
          </div>
        </div>
      `;
      const visibleLines = state.outputLines.filter((line) => state.visibleSources[line.source]);
      const lines2 = visibleLines.length > 0 ? joinTemplates(visibleLines.slice(-100).map((line, index, arr) => {
        const lineNumber = state.outputLines.length - arr.length + index + 1;
        const lineNumberStyles = state.selectedLine === lineNumber ? "bg-zinc-800/80 text-zinc-100 border-zinc-700/60" : "text-zinc-500 border-transparent";
        return html`
                  <div class="flex gap-2 font-mono text-xs leading-relaxed">
                    ${state.showLineNumbers ? html`
                          <button
                            class="w-10 text-right pr-2 rounded border ${lineNumberStyles}"
                            data-action="selectLine"
                            data-line="${lineNumber}"
                            title="Line ${lineNumber}"
                          >
                            ${lineNumber}
                          </button>
                        ` : ""}
                    <span class="w-8 flex-shrink-0 ${getSourceColorClass(line.source)}">
                      ${getSourceLabel(line.source)}
                    </span>
                    <span class="text-zinc-300 whitespace-pre-wrap break-all">${line.text}</span>
                  </div>
                `;
      })) : html`<div class="text-xs text-zinc-600 italic">No output yet</div>`;
      return html`
        <div class="fixed right-4 bottom-20 w-[600px] max-h-[400px] flex flex-col bg-zinc-950/95 border border-zinc-800/60 rounded-lg shadow-xl backdrop-blur-sm overflow-hidden">
          ${header}
          <div
            class="flex-1 p-3 overflow-y-auto space-y-1"
            id="tb-output-scroll"
            data-autoscroll="${state.autoScroll ? "true" : "false"}"
          >
            ${lines2}
          </div>
          <div class="px-3 py-1 border-t border-zinc-800/40 bg-zinc-900/60 text-xs text-zinc-500">
            ${visibleLines.length} lines
          </div>
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (_e, target) => {
        const action = target.dataset.action;
        if (action === "clear") {
          exports_Effect.runFork(ctx.emit({ type: "clear" }));
        } else if (action === "copy") {
          exports_Effect.runFork(ctx.emit({ type: "copy" }));
        } else if (action === "close") {
          exports_Effect.runFork(ctx.emit({ type: "close" }));
        } else if (action === "toggleAutoScroll") {
          exports_Effect.runFork(ctx.emit({ type: "toggleAutoScroll" }));
        } else if (action === "toggleLineNumbers") {
          exports_Effect.runFork(ctx.emit({ type: "toggleLineNumbers" }));
        } else if (action === "selectLine") {
          const lineValue = target.dataset.line;
          if (lineValue) {
            exports_Effect.runFork(ctx.emit({ type: "selectLine", lineNumber: Number(lineValue) }));
          }
        } else if (action === "toggleSource") {
          const source = target.dataset.source;
          if (source) {
            exports_Effect.runFork(ctx.emit({ type: "toggleSource", source }));
          }
        }
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      switch (event.type) {
        case "clear":
          yield* ctx.state.update((s) => ({
            ...s,
            outputLines: [],
            selectedLine: null
          }));
          break;
        case "copy": {
          const state = yield* ctx.state.get;
          const linesToCopy = state.outputLines.filter((line) => state.visibleSources[line.source]);
          const total = state.outputLines.length;
          const start4 = total - linesToCopy.length;
          const text = linesToCopy.map((l, index) => {
            const lineNumber = start4 + index + 1;
            const prefix = state.showLineNumbers ? `${lineNumber}: ` : "";
            return `${prefix}[${l.source}] ${l.text}`;
          }).join(`
`);
          if (typeof navigator !== "undefined" && navigator.clipboard) {
            try {
              yield* exports_Effect.promise(() => navigator.clipboard.writeText(text));
            } catch {}
          }
          break;
        }
        case "close":
          yield* ctx.state.update((s) => ({ ...s, visible: false }));
          break;
        case "open":
          yield* ctx.state.update((s) => ({ ...s, visible: true }));
          break;
        case "toggleAutoScroll":
          yield* ctx.state.update((s) => ({ ...s, autoScroll: !s.autoScroll }));
          break;
        case "toggleLineNumbers":
          yield* ctx.state.update((s) => ({
            ...s,
            showLineNumbers: !s.showLineNumbers,
            selectedLine: s.showLineNumbers ? null : s.selectedLine
          }));
          break;
        case "selectLine":
          yield* ctx.state.update((s) => ({
            ...s,
            selectedLine: s.selectedLine === event.lineNumber ? null : event.lineNumber
          }));
          break;
        case "toggleSource":
          yield* ctx.state.update((s) => ({
            ...s,
            visibleSources: {
              ...s.visibleSources,
              [event.source]: !s.visibleSources[event.source]
            },
            selectedLine: s.showLineNumbers ? s.selectedLine : null
          }));
          break;
      }
    }),
    subscriptions: (ctx) => {
      const socket = exports_Effect.map(SocketServiceTag, (s) => s);
      return [
        pipe(exports_Stream.unwrap(exports_Effect.map(socket, (s) => s.getMessages())), exports_Stream.filter((msg) => isTBMessage(msg)), exports_Stream.map((msg) => exports_Effect.gen(function* () {
          if (isTBRunStart(msg)) {
            yield* ctx.state.update((s) => ({
              ...s,
              runId: msg.runId,
              taskId: null,
              outputLines: [],
              visible: true,
              selectedLine: null,
              visibleSources: {
                agent: true,
                verification: true,
                system: true,
                tool: true
              }
            }));
          }
          if (isTBTaskOutput(msg)) {
            yield* ctx.state.update((s) => {
              if (s.runId && s.runId !== msg.runId)
                return s;
              const newLines = [
                ...s.outputLines,
                {
                  text: msg.text,
                  source: msg.source,
                  timestamp: Date.now()
                }
              ].slice(-s.maxLines);
              return {
                ...s,
                taskId: msg.taskId,
                outputLines: newLines
              };
            });
          }
          if (isATIFStep(msg)) {
            yield* ctx.state.update((s) => {
              if (s.runId && s.runId !== msg.runId)
                return s;
              const newLines = [...s.outputLines];
              const timestamp2 = Date.now();
              if (msg.step.tool_calls && msg.step.tool_calls.length > 0) {
                for (const toolCall of msg.step.tool_calls) {
                  newLines.push({
                    text: formatToolCall(toolCall),
                    source: "tool",
                    timestamp: timestamp2
                  });
                }
              }
              if (msg.step.observation?.results && msg.step.observation.results.length > 0) {
                for (const result of msg.step.observation.results) {
                  newLines.push({
                    text: formatObservationResult(result),
                    source: "tool",
                    timestamp: timestamp2
                  });
                }
              }
              return {
                ...s,
                outputLines: newLines.slice(-s.maxLines)
              };
            });
          }
          if (isTBRunComplete(msg)) {
            yield* ctx.state.update((s) => {
              if (s.runId !== msg.runId)
                return s;
              return {
                ...s,
                runId: null
              };
            });
          }
        })))
      ];
    }
  };
  var initialTBOutputState = TBOutputWidget.initialState();
  // src/effuse/widgets/mc-tasks.ts
  var getPriorityLabel = (priority) => {
    return `P${priority}`;
  };
  var getPriorityClasses = (priority) => {
    switch (priority) {
      case 0:
        return "bg-red-900/40 text-red-300 border-red-700/50";
      case 1:
        return "bg-orange-900/40 text-orange-300 border-orange-700/50";
      case 2:
        return "bg-zinc-800/50 text-zinc-200 border-zinc-600/50";
      case 3:
        return "bg-zinc-800/30 text-zinc-300 border-zinc-700/40";
      case 4:
        return "bg-zinc-900/30 text-zinc-400 border-zinc-700/30";
      default:
        return "bg-zinc-800/40 text-zinc-300 border-zinc-600/40";
    }
  };
  var getTypeBadgeClass = (type) => {
    switch (type) {
      case "bug":
        return "text-red-400";
      case "feature":
        return "text-emerald-400";
      case "task":
        return "text-blue-400";
      case "epic":
        return "text-violet-400";
      case "chore":
        return "text-zinc-400";
      default:
        return "text-zinc-400";
    }
  };
  var MCTasksWidget = {
    id: "mc-tasks",
    initialState: () => ({
      tasks: [],
      loading: false,
      error: null,
      collapsed: false,
      maxDisplay: 20,
      assigningId: null
    }),
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      const header = html`
        <div
          class="flex items-center justify-between px-4 py-3 border-b border-zinc-800/60 cursor-pointer"
          data-action="toggleCollapse"
        >
          <h2 class="text-zinc-100 font-bold font-mono text-lg">
            Ready Tasks (${state.tasks.length})
          </h2>
          <div class="flex items-center gap-3">
            <button
              class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
              data-action="load"
            >
              ${state.loading ? "Loading..." : "Refresh"}
            </button>
            <span class="text-zinc-500">${state.collapsed ? "" : ""}</span>
          </div>
        </div>
      `;
      if (state.loading && state.tasks.length === 0) {
        return html`
          <div class="rounded-2xl border border-zinc-800/60 bg-zinc-950/80 shadow-2xl backdrop-blur-xl">
            ${header}
            <div class="flex items-center justify-center py-8">
              <div class="text-zinc-400 font-mono text-sm">Loading ready tasks...</div>
            </div>
          </div>
        `;
      }
      if (state.error && state.tasks.length === 0) {
        return html`
          <div class="rounded-2xl border border-zinc-800/60 bg-zinc-950/80 shadow-2xl backdrop-blur-xl">
            ${header}
            <div class="flex items-center justify-center py-8">
              <div class="text-red-400 font-mono text-sm">${state.error}</div>
            </div>
          </div>
        `;
      }
      if (state.tasks.length === 0) {
        return html`
          <div class="rounded-2xl border border-zinc-800/60 bg-zinc-950/80 shadow-2xl backdrop-blur-xl">
            ${header}
            <div class="flex items-center justify-center py-8">
              <div class="text-zinc-500 font-mono text-sm">No ready tasks found</div>
            </div>
          </div>
        `;
      }
      if (state.collapsed) {
        return html`
          <div class="rounded-2xl border border-zinc-800/60 bg-zinc-950/80 shadow-2xl backdrop-blur-xl">
            ${header}
          </div>
        `;
      }
      const taskRows = state.tasks.slice(0, state.maxDisplay).map((task) => {
        const prioClasses = getPriorityClasses(task.priority);
        const prioLabel = getPriorityLabel(task.priority);
        const typeClass = getTypeBadgeClass(task.type);
        const labelsStr = task.labels.slice(0, 2).join(", ");
        const isAssigning = state.assigningId === task.id;
        return html`
          <tr class="border-b border-zinc-800/40 last:border-0 hover:bg-zinc-900/30">
            <td class="py-2 px-3">
              <span class="inline-flex items-center px-1.5 py-0.5 text-[10px] font-bold rounded border ${prioClasses}">
                ${prioLabel}
              </span>
            </td>
            <td class="py-2 px-3">
              <code class="text-zinc-500 font-mono text-[10px]">${task.id}</code>
            </td>
            <td class="py-2 px-3">
              <span class="font-medium font-mono text-zinc-100 text-sm" title="${task.title}">
                ${task.title.length > 50 ? task.title.slice(0, 50) + "..." : task.title}
              </span>
            </td>
            <td class="py-2 px-3">
              <span class="${typeClass} font-mono text-xs">${task.type}</span>
            </td>
            <td class="py-2 px-3">
              <span class="text-zinc-400 font-mono text-xs">${labelsStr}</span>
            </td>
            <td class="py-2 px-3">
              <button
                class="inline-flex items-center justify-center border px-3 py-1 text-[10px] font-mono font-semibold uppercase rounded transition-colors
                       ${isAssigning ? "border-zinc-600 text-zinc-500 bg-zinc-800/40 cursor-not-allowed" : "border-zinc-700 text-zinc-50 bg-zinc-900/80 hover:bg-zinc-900/95"}"
                data-action="assign"
                data-task-id="${task.id}"
                ${isAssigning ? "disabled" : ""}
              >
                ${isAssigning ? "Starting..." : "Assign"}
              </button>
            </td>
          </tr>
        `;
      });
      const moreIndicator = state.tasks.length > state.maxDisplay ? html`
              <div class="px-4 py-2 border-t border-zinc-800/60 text-center text-xs font-mono text-zinc-500">
                + ${state.tasks.length - state.maxDisplay} more tasks...
              </div>
            ` : "";
      return html`
        <div class="rounded-2xl border border-zinc-800/60 bg-zinc-950/80 shadow-2xl backdrop-blur-xl max-h-[70vh] overflow-hidden">
          ${header}
          <div class="overflow-x-auto max-h-[calc(70vh-60px)] overflow-y-auto">
            <table class="min-w-full table-auto text-xs font-mono text-zinc-200">
              <thead>
                <tr class="text-zinc-500 uppercase text-[9px] tracking-[0.4em] bg-zinc-900/40">
                  <th class="w-12 px-3 py-2 text-left">Pri</th>
                  <th class="w-24 px-3 py-2 text-left">ID</th>
                  <th class="px-3 py-2 text-left">Title</th>
                  <th class="w-20 px-3 py-2 text-left">Type</th>
                  <th class="w-32 px-3 py-2 text-left">Labels</th>
                  <th class="w-24 px-3 py-2 text-left">Action</th>
                </tr>
              </thead>
              <tbody>
                ${joinTemplates(taskRows)}
              </tbody>
            </table>
          </div>
          ${moreIndicator}
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (e, target) => {
        const el = target;
        const action = el.dataset.action;
        const taskId = el.dataset.taskId;
        if (action === "load") {
          e.stopPropagation();
          exports_Effect.runFork(ctx.emit({ type: "load" }));
        } else if (action === "toggleCollapse") {
          exports_Effect.runFork(ctx.emit({ type: "toggleCollapse" }));
        } else if (action === "assign" && taskId) {
          e.stopPropagation();
          exports_Effect.runFork(ctx.emit({ type: "assign", taskId }));
        }
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      const socket = yield* SocketServiceTag;
      switch (event.type) {
        case "load":
          yield* ctx.state.update((s) => ({ ...s, loading: true, error: null }));
          const result = yield* socket.loadReadyTasks(50).pipe(exports_Effect.map((tasks) => ({ tasks, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ tasks: [], error: e.message })));
          yield* ctx.state.update((s) => ({
            ...s,
            loading: false,
            tasks: result.tasks,
            error: result.error
          }));
          break;
        case "toggleCollapse":
          yield* ctx.state.update((s) => ({ ...s, collapsed: !s.collapsed }));
          break;
        case "assign":
          yield* ctx.state.update((s) => ({ ...s, assigningId: event.taskId }));
          const assignResult = yield* socket.assignTaskToMC(event.taskId, { sandbox: true }).pipe(exports_Effect.map(() => ({ success: true, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ success: false, error: e.message })));
          if (assignResult.success) {
            yield* ctx.state.update((s) => ({
              ...s,
              assigningId: null,
              tasks: s.tasks.filter((t) => t.id !== event.taskId)
            }));
          } else {
            yield* ctx.state.update((s) => ({
              ...s,
              assigningId: null,
              error: assignResult.error
            }));
          }
          break;
      }
    })
  };
  var initialMCTasksState = MCTasksWidget.initialState();
  // src/effuse/widgets/tb-controls.ts
  var getDifficultyClass = (difficulty) => {
    switch (difficulty.toLowerCase()) {
      case "easy":
        return "bg-emerald-900/40 text-emerald-300 border-emerald-700/50";
      case "medium":
        return "bg-amber-900/40 text-amber-300 border-amber-700/50";
      case "hard":
        return "bg-red-900/40 text-red-300 border-red-700/50";
      default:
        return "bg-zinc-800/40 text-zinc-300 border-zinc-700/50";
    }
  };
  var getStatusColorClass2 = (statusType) => {
    switch (statusType) {
      case "running":
        return "text-blue-400";
      case "error":
        return "text-red-400";
      case "success":
        return "text-emerald-400";
      case "loading":
        return "text-zinc-400";
      default:
        return "text-zinc-500";
    }
  };
  var formatDuration3 = (ms) => {
    const totalSeconds = Math.floor(ms / 1000);
    const hours2 = Math.floor(totalSeconds / 3600);
    const minutes2 = Math.floor(totalSeconds % 3600 / 60);
    const seconds2 = totalSeconds % 60;
    return `${String(hours2).padStart(2, "0")}:${String(minutes2).padStart(2, "0")}:${String(seconds2).padStart(2, "0")}`;
  };
  var isTBRunStart2 = (msg) => msg.type === "tb_run_start";
  var isTBRunComplete2 = (msg) => msg.type === "tb_run_complete";
  var isTBTaskComplete = (msg) => msg.type === "tb_task_complete";
  var isTBMessage2 = (msg) => isTBRunStart2(msg) || isTBRunComplete2(msg) || isTBTaskComplete(msg);
  var TBControlsWidget = {
    id: "tb-controls",
    initialState: () => ({
      suitePath: "./tasks/terminal-bench-2.json",
      suite: null,
      selectedTaskIds: new Set,
      loading: false,
      status: "Ready",
      statusType: "idle",
      isRunning: false,
      runId: null,
      collapsed: false,
      totalTasks: 0,
      completedTasks: 0,
      passedTasks: 0,
      failedTasks: 0,
      startedAt: null,
      duration: null,
      difficultyFilter: null,
      searchFilter: ""
    }),
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      const statusColor = getStatusColorClass2(state.statusType);
      const header = html`
        <div
          class="flex items-center justify-between px-4 py-3 border-b border-zinc-800/60 cursor-pointer"
          data-action="toggleCollapse"
        >
          <div class="flex items-center gap-3">
            <h2 class="text-zinc-100 font-bold font-mono text-lg">Terminal-Bench</h2>
            <span class="text-xs ${statusColor}">${state.status}</span>
          </div>
          <span class="text-zinc-500">${state.collapsed ? "" : ""}</span>
        </div>
      `;
      if (state.collapsed) {
        return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header}
          </div>
        `;
      }
      const pathInput = html`
        <div class="flex items-center gap-2 px-4 py-3 border-b border-zinc-800/40">
          <input
            type="text"
            class="flex-1 bg-zinc-900/60 border border-zinc-700/50 rounded px-3 py-2 text-sm font-mono text-zinc-200 placeholder-zinc-500 focus:border-zinc-600/60 focus:outline-none"
            placeholder="Path to suite..."
            value="${state.suitePath}"
            data-input="suitePath"
            ${state.isRunning ? "disabled" : ""}
          />
          <button
            class="px-3 py-2 text-xs font-mono uppercase rounded border transition-colors
                   ${state.isRunning ? "border-zinc-700 text-zinc-500 bg-zinc-800/40 cursor-not-allowed" : "border-zinc-700 text-zinc-200 bg-zinc-900/80 hover:bg-zinc-900/95"}"
            data-action="loadSuite"
            ${state.isRunning ? "disabled" : ""}
          >
            ${state.loading ? "Loading..." : "Load"}
          </button>
        </div>
      `;
      const controls = html`
        <div class="flex items-center gap-2 px-4 py-3 border-b border-zinc-800/40">
          <button
            class="px-4 py-2 text-xs font-mono uppercase rounded border transition-colors
                   ${state.isRunning || !state.suite ? "border-zinc-700 text-zinc-500 bg-zinc-800/40 cursor-not-allowed" : "border-emerald-700 text-emerald-300 bg-emerald-900/40 hover:bg-emerald-900/60"}"
            data-action="startRun"
            ${state.isRunning || !state.suite ? "disabled" : ""}
          >
            Start
          </button>
          <button
            class="px-4 py-2 text-xs font-mono uppercase rounded border transition-colors
                   ${state.isRunning || !state.suite ? "border-zinc-700 text-zinc-500 bg-zinc-800/40 cursor-not-allowed" : "border-violet-700 text-violet-300 bg-violet-900/40 hover:bg-violet-900/60"}"
            data-action="startRandomTask"
            ${state.isRunning || !state.suite ? "disabled" : ""}
          >
            Random
          </button>
          <button
            class="px-4 py-2 text-xs font-mono uppercase rounded border transition-colors
                   ${!state.isRunning ? "border-zinc-700 text-zinc-500 bg-zinc-800/40 cursor-not-allowed" : "border-red-700 text-red-300 bg-red-900/40 hover:bg-red-900/60"}"
            data-action="stopRun"
            ${!state.isRunning ? "disabled" : ""}
          >
            Stop
          </button>
          <span class="flex-1"></span>
          <span class="text-xs text-zinc-500 font-mono">
            ${state.selectedTaskIds.size}/${state.suite?.tasks.length ?? 0} selected
          </span>
        </div>
      `;
      const progressPercent = state.totalTasks > 0 ? Math.round(state.completedTasks / state.totalTasks * 100) : 0;
      const passPercent = state.totalTasks > 0 ? Math.round(state.passedTasks / state.totalTasks * 100) : 0;
      const failPercent = state.totalTasks > 0 ? Math.round(state.failedTasks / state.totalTasks * 100) : 0;
      const elapsedMs = state.startedAt ? state.duration ?? Date.now() - state.startedAt : state.duration ?? 0;
      const durationDisplay = elapsedMs > 0 ? formatDuration3(elapsedMs) : null;
      const progressBar = state.isRunning || state.completedTasks > 0 ? html`
        <div class="px-4 py-2 border-b border-zinc-800/40" data-testid="progress-bar">
          <div class="flex items-center justify-between mb-1">
            <div class="flex items-center gap-3">
              <span class="text-xs font-mono text-zinc-400">
                Progress: ${state.completedTasks}/${state.totalTasks} (${progressPercent}%)
              </span>
              ${durationDisplay ? html`<span class="text-xs font-mono text-zinc-500" data-testid="run-duration"> ${durationDisplay}</span>` : ""}
            </div>
            <span class="text-xs font-mono">
              <span class="text-emerald-400">${state.passedTasks}</span>
              <span class="text-zinc-500 mx-1">|</span>
              <span class="text-red-400">${state.failedTasks}</span>
            </span>
          </div>
          <div class="h-2 bg-zinc-800 rounded-full overflow-hidden">
            <div class="h-full flex">
              <div
                class="bg-emerald-500 transition-all duration-300"
                style="width: ${passPercent}%"
                data-testid="progress-passed"
              ></div>
              <div
                class="bg-red-500 transition-all duration-300"
                style="width: ${failPercent}%"
                data-testid="progress-failed"
              ></div>
            </div>
          </div>
        </div>
      ` : "";
      const taskList = state.suite ? html`
            <div class="border-b border-zinc-800/40">
              <div class="flex items-center justify-between px-4 py-2 bg-zinc-900/40">
                <span class="text-xs text-zinc-400 font-mono">
                  ${state.suite.name} v${state.suite.version}
                </span>
                <div class="flex items-center gap-2">
                  <button
                    class="text-xs text-zinc-400 hover:text-zinc-200 transition-colors"
                    data-action="selectAll"
                  >
                    All
                  </button>
                  <span class="text-zinc-600">|</span>
                  <button
                    class="text-xs text-zinc-400 hover:text-zinc-200 transition-colors"
                    data-action="selectNone"
                  >
                    None
                  </button>
                </div>
              </div>
              <div class="flex items-center gap-2 px-4 py-2 border-b border-zinc-800/40 bg-zinc-900/20">
                <input
                  type="text"
                  class="flex-1 bg-zinc-900/60 border border-zinc-700/50 rounded px-2 py-1 text-xs font-mono text-zinc-200 placeholder-zinc-500 focus:border-zinc-600/60 focus:outline-none"
                  placeholder="Search tasks..."
                  value="${state.searchFilter}"
                  data-input="searchFilter"
                />
                <select
                  class="bg-zinc-900/60 border border-zinc-700/50 rounded px-2 py-1 text-xs font-mono text-zinc-200 focus:border-zinc-600/60 focus:outline-none"
                  data-input="difficultyFilter"
                >
                  <option value="" ${!state.difficultyFilter ? "selected" : ""}>All Difficulties</option>
                  <option value="easy" ${state.difficultyFilter === "easy" ? "selected" : ""}>Easy</option>
                  <option value="medium" ${state.difficultyFilter === "medium" ? "selected" : ""}>Medium</option>
                  <option value="hard" ${state.difficultyFilter === "hard" ? "selected" : ""}>Hard</option>
                </select>
              </div>
              <div class="max-h-60 overflow-y-auto">
                ${joinTemplates(state.suite.tasks.filter((task) => {
        if (state.difficultyFilter && task.difficulty.toLowerCase() !== state.difficultyFilter.toLowerCase()) {
          return false;
        }
        if (state.searchFilter) {
          const search = state.searchFilter.toLowerCase();
          return task.name.toLowerCase().includes(search) || task.id.toLowerCase().includes(search);
        }
        return true;
      }).map((task) => {
        const isSelected = state.selectedTaskIds.has(task.id);
        const diffClass = getDifficultyClass(task.difficulty);
        return html`
                      <label
                        class="flex items-center gap-3 px-4 py-2 hover:bg-zinc-900/40 cursor-pointer transition-colors"
                      >
                        <input
                          type="checkbox"
                          class="form-checkbox rounded border-zinc-600 bg-zinc-800 text-blue-500 focus:ring-blue-500/20"
                          data-action="toggleTask"
                          data-task-id="${task.id}"
                          ${isSelected ? "checked" : ""}
                        />
                        <span class="flex-1 text-sm font-mono text-zinc-200 truncate" title="${task.name}">
                          ${task.name}
                        </span>
                        <span class="text-xs px-1.5 py-0.5 rounded border ${diffClass}">
                          ${task.difficulty}
                        </span>
                      </label>
                    `;
      }))}
              </div>
            </div>
          ` : "";
      return html`
        <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm overflow-hidden">
          ${header}
          ${pathInput}
          ${controls}
          ${progressBar}
          ${taskList}
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (e, target) => {
        const el = target;
        const action = el.dataset.action;
        const taskId = el.dataset.taskId;
        if (action === "toggleCollapse") {
          exports_Effect.runFork(ctx.emit({ type: "toggleCollapse" }));
        } else if (action === "loadSuite") {
          e.stopPropagation();
          exports_Effect.runFork(ctx.emit({ type: "loadSuite" }));
        } else if (action === "startRun") {
          e.stopPropagation();
          exports_Effect.runFork(ctx.emit({ type: "startRun" }));
        } else if (action === "startRandomTask") {
          e.stopPropagation();
          exports_Effect.runFork(ctx.emit({ type: "startRandomTask" }));
        } else if (action === "stopRun") {
          e.stopPropagation();
          exports_Effect.runFork(ctx.emit({ type: "stopRun" }));
        } else if (action === "selectAll") {
          e.stopPropagation();
          exports_Effect.runFork(ctx.emit({ type: "selectAll" }));
        } else if (action === "selectNone") {
          e.stopPropagation();
          exports_Effect.runFork(ctx.emit({ type: "selectNone" }));
        } else if (action === "toggleTask" && taskId) {
          exports_Effect.runFork(ctx.emit({ type: "toggleTask", taskId }));
        }
      });
      yield* ctx.dom.delegate(ctx.container, "[data-input]", "input", (_e, target) => {
        const el = target;
        const inputType = el.dataset.input;
        if (inputType === "suitePath") {
          exports_Effect.runFork(ctx.emit({ type: "setSuitePath", path: el.value }));
        } else if (inputType === "searchFilter") {
          exports_Effect.runFork(ctx.emit({ type: "setSearchFilter", search: el.value }));
        } else if (inputType === "difficultyFilter") {
          exports_Effect.runFork(ctx.emit({ type: "setDifficultyFilter", difficulty: el.value || null }));
        }
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      const socket = yield* SocketServiceTag;
      switch (event.type) {
        case "setSuitePath":
          yield* ctx.state.update((s) => ({ ...s, suitePath: event.path }));
          break;
        case "loadSuite": {
          const state = yield* ctx.state.get;
          if (!state.suitePath.trim()) {
            yield* ctx.state.update((s) => ({ ...s, status: "No path", statusType: "error" }));
            return;
          }
          yield* ctx.state.update((s) => ({ ...s, loading: true, status: "Loading...", statusType: "loading" }));
          const result = yield* socket.loadTBSuite(state.suitePath).pipe(exports_Effect.map((suite) => ({ suite, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ suite: null, error: e.message })));
          if (result.error) {
            yield* ctx.state.update((s) => ({
              ...s,
              loading: false,
              suite: null,
              selectedTaskIds: new Set,
              status: "Load failed",
              statusType: "error"
            }));
          } else if (result.suite) {
            const allIds = new Set(result.suite.tasks.map((t) => t.id));
            yield* ctx.state.update((s) => ({
              ...s,
              loading: false,
              suite: result.suite,
              selectedTaskIds: allIds,
              status: "Ready",
              statusType: "idle"
            }));
          }
          break;
        }
        case "startRun": {
          const state = yield* ctx.state.get;
          if (!state.suite || state.selectedTaskIds.size === 0)
            return;
          yield* ctx.state.update((s) => ({
            ...s,
            isRunning: true,
            status: "Starting...",
            statusType: "running",
            totalTasks: s.selectedTaskIds.size,
            completedTasks: 0,
            passedTasks: 0,
            failedTasks: 0,
            startedAt: Date.now(),
            duration: null
          }));
          const result = yield* socket.startTBRun({
            suitePath: state.suitePath,
            taskIds: Array.from(state.selectedTaskIds),
            timeout: 300000,
            maxTurns: 10
          }).pipe(exports_Effect.map((res) => ({ runId: res.runId, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ runId: null, error: e.message })));
          if (result.error) {
            yield* ctx.state.update((s) => ({
              ...s,
              isRunning: false,
              status: "Start failed",
              statusType: "error"
            }));
          } else {
            yield* ctx.state.update((s) => ({
              ...s,
              runId: result.runId,
              status: "Running...",
              statusType: "running"
            }));
          }
          break;
        }
        case "startRandomTask": {
          const state = yield* ctx.state.get;
          if (!state.suite || state.suite.tasks.length === 0)
            return;
          const randomIndex = Math.floor(Math.random() * state.suite.tasks.length);
          const randomTask = state.suite.tasks[randomIndex];
          yield* ctx.state.update((s) => ({
            ...s,
            isRunning: true,
            status: `Random: ${randomTask.name}`,
            statusType: "running",
            totalTasks: 1,
            completedTasks: 0,
            passedTasks: 0,
            failedTasks: 0,
            startedAt: Date.now(),
            duration: null
          }));
          const result = yield* socket.startTBRun({
            suitePath: state.suitePath,
            taskIds: [randomTask.id],
            timeout: 300000,
            maxTurns: 10
          }).pipe(exports_Effect.map((res) => ({ runId: res.runId, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ runId: null, error: e.message })));
          if (result.error) {
            yield* ctx.state.update((s) => ({
              ...s,
              isRunning: false,
              status: "Start failed",
              statusType: "error"
            }));
          } else {
            yield* ctx.state.update((s) => ({
              ...s,
              runId: result.runId,
              status: "Running...",
              statusType: "running"
            }));
          }
          break;
        }
        case "stopRun": {
          yield* ctx.state.update((s) => ({ ...s, status: "Stopping...", statusType: "loading" }));
          const result = yield* socket.stopTBRun().pipe(exports_Effect.map((res) => ({ stopped: res.stopped, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ stopped: false, error: e.message })));
          yield* ctx.state.update((s) => ({
            ...s,
            isRunning: false,
            runId: null,
            status: result.stopped ? "Stopped" : "No active run",
            statusType: result.error ? "error" : "idle"
          }));
          break;
        }
        case "selectAll": {
          const state = yield* ctx.state.get;
          if (!state.suite)
            return;
          const allIds = new Set(state.suite.tasks.map((t) => t.id));
          yield* ctx.state.update((s) => ({ ...s, selectedTaskIds: allIds }));
          break;
        }
        case "selectNone":
          yield* ctx.state.update((s) => ({ ...s, selectedTaskIds: new Set }));
          break;
        case "toggleTask": {
          yield* ctx.state.update((s) => {
            const newSelected = new Set(s.selectedTaskIds);
            if (newSelected.has(event.taskId)) {
              newSelected.delete(event.taskId);
            } else {
              newSelected.add(event.taskId);
            }
            return { ...s, selectedTaskIds: newSelected };
          });
          break;
        }
        case "setDifficultyFilter":
          yield* ctx.state.update((s) => ({ ...s, difficultyFilter: event.difficulty }));
          break;
        case "setSearchFilter":
          yield* ctx.state.update((s) => ({ ...s, searchFilter: event.search }));
          break;
        case "toggleCollapse":
          yield* ctx.state.update((s) => ({ ...s, collapsed: !s.collapsed }));
          break;
      }
    }),
    subscriptions: (ctx) => {
      const socket = exports_Effect.map(SocketServiceTag, (s) => s);
      return [
        pipe(exports_Stream.unwrap(exports_Effect.map(socket, (s) => s.getMessages())), exports_Stream.filter((msg) => isTBMessage2(msg)), exports_Stream.map((msg) => exports_Effect.gen(function* () {
          if (isTBRunStart2(msg)) {
            yield* ctx.state.update((s) => ({
              ...s,
              isRunning: true,
              runId: msg.runId,
              status: "Running...",
              statusType: "running"
            }));
          }
          if (isTBTaskComplete(msg)) {
            yield* ctx.state.update((s) => {
              if (s.runId !== msg.runId)
                return s;
              const isPassed = msg.outcome === "passed";
              return {
                ...s,
                completedTasks: s.completedTasks + 1,
                passedTasks: s.passedTasks + (isPassed ? 1 : 0),
                failedTasks: s.failedTasks + (isPassed ? 0 : 1),
                status: `${s.completedTasks + 1}/${s.totalTasks} tasks`
              };
            });
          }
          if (isTBRunComplete2(msg)) {
            yield* ctx.state.update((s) => {
              if (s.runId !== msg.runId)
                return s;
              const passRate = s.totalTasks > 0 ? Math.round(s.passedTasks / s.totalTasks * 100) : 0;
              const duration2 = s.startedAt ? Date.now() - s.startedAt : 0;
              return {
                ...s,
                isRunning: false,
                runId: null,
                status: `Complete: ${passRate}% (${s.passedTasks}/${s.totalTasks})`,
                statusType: "success",
                duration: duration2,
                startedAt: null
              };
            });
          }
        })))
      ];
    }
  };
  var initialTBControlsState = TBControlsWidget.initialState();
  // src/effuse/widgets/category-tree.ts
  var getStatusIcon2 = (status2) => {
    switch (status2) {
      case "passed":
        return "";
      case "failed":
        return "";
      case "error":
        return "";
      case "timeout":
        return "";
      case "running":
        return "";
      default:
        return "";
    }
  };
  var getStatusColorClass3 = (status2) => {
    switch (status2) {
      case "passed":
        return "text-emerald-400";
      case "failed":
        return "text-red-400";
      case "error":
        return "text-orange-400";
      case "timeout":
        return "text-amber-400";
      case "running":
        return "text-blue-400";
      default:
        return "text-zinc-500";
    }
  };
  var getDifficultyClass2 = (difficulty) => {
    switch (difficulty.toLowerCase()) {
      case "easy":
        return "bg-emerald-900/40 text-emerald-300";
      case "medium":
        return "bg-amber-900/40 text-amber-300";
      case "hard":
        return "bg-red-900/40 text-red-300";
      default:
        return "bg-zinc-800/40 text-zinc-300";
    }
  };
  var groupTasksByCategory = (tasks) => {
    const categories = new Map;
    for (const task of tasks.values()) {
      const cat = task.category || "uncategorized";
      if (!categories.has(cat)) {
        categories.set(cat, { category: cat, tasks: [], passed: 0, failed: 0, pending: 0, total: 0 });
      }
      const catData = categories.get(cat);
      catData.tasks.push(task);
      catData.total++;
      if (task.status === "passed")
        catData.passed++;
      if (task.status === "failed" || task.status === "error" || task.status === "timeout") {
        catData.failed++;
      }
      if (task.status === "pending")
        catData.pending++;
    }
    return categories;
  };
  var isTBTaskStart = (msg) => msg.type === "tb_task_start";
  var isTBTaskComplete2 = (msg) => msg.type === "tb_task_complete";
  var isTBSuiteInfo = (msg) => msg.type === "tb_suite_info";
  var isTBMessage3 = (msg) => isTBTaskStart(msg) || isTBTaskComplete2(msg) || isTBSuiteInfo(msg);
  var CategoryTreeWidget = {
    id: "category-tree",
    initialState: () => ({
      tasks: new Map,
      collapsedCategories: new Set,
      visible: false,
      selectedTaskId: null
    }),
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      if (!state.visible) {
        return html`<div class="hidden"></div>`;
      }
      const categories = groupTasksByCategory(state.tasks);
      const header = html`
        <div class="flex items-center justify-between px-3 py-2 border-b border-zinc-800/60 bg-zinc-900/80">
          <span class="text-sm font-medium text-zinc-300">Categories</span>
          <div class="flex items-center gap-2">
            <button
              class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
              data-action="expandAll"
            >
              Expand
            </button>
            <button
              class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
              data-action="collapseAll"
            >
              Collapse
            </button>
            <button
              class="text-zinc-500 hover:text-zinc-300 transition-colors"
              data-action="hide"
            >
              
            </button>
          </div>
        </div>
      `;
      if (categories.size === 0) {
        return html`
          <div class="fixed right-4 top-20 w-72 rounded-lg border border-zinc-800/60 bg-zinc-950/95 shadow-xl backdrop-blur-sm overflow-hidden">
            ${header}
            <div class="p-4 text-center">
              <span class="text-sm text-zinc-500">No tasks loaded</span>
            </div>
          </div>
        `;
      }
      const categoryList = Array.from(categories.entries()).sort(([a], [b]) => a.localeCompare(b)).map(([catName, catData]) => {
        const isCollapsed = state.collapsedCategories.has(catName);
        const statsHtml = catData.passed > 0 || catData.failed > 0 ? html`
                  <span class="text-xs text-emerald-400">${catData.passed}</span>
                  <span class="text-xs text-red-400">${catData.failed}</span>
                ` : "";
        const taskItems = catData.tasks.map((task) => {
          const icon = getStatusIcon2(task.status);
          const statusColor = getStatusColorClass3(task.status);
          const diffClass = getDifficultyClass2(task.difficulty);
          const isSelected = state.selectedTaskId === task.id;
          const isRunning3 = task.status === "running";
          return html`
              <div
                class="flex items-center gap-2 px-3 py-1.5 hover:bg-zinc-900/40 cursor-pointer transition-colors
                       ${isSelected ? "bg-zinc-800/60" : ""} ${isRunning3 ? "animate-pulse" : ""}"
                data-action="selectTask"
                data-task-id="${task.id}"
              >
                <span class="${statusColor}">${icon}</span>
                <span class="flex-1 text-xs text-zinc-300 truncate" title="${task.name}">
                  ${task.name}
                </span>
                ${task.difficulty ? html`<span class="text-[9px] px-1 py-0.5 rounded ${diffClass}">${task.difficulty.slice(0, 1).toUpperCase()}</span>` : ""}
              </div>
            `;
        });
        return html`
            <div class="border-b border-zinc-800/40 last:border-0">
              <div
                class="flex items-center gap-2 px-3 py-2 hover:bg-zinc-900/40 cursor-pointer transition-colors"
                data-action="toggleCategory"
                data-category="${catName}"
              >
                <span class="text-zinc-500 text-xs">${isCollapsed ? "" : ""}</span>
                <span class="flex-1 text-sm font-medium text-zinc-200">${catName}</span>
                <div class="flex items-center gap-2">
                  ${statsHtml}
                  <span class="text-xs text-zinc-500">${catData.total}</span>
                </div>
              </div>
              ${isCollapsed ? "" : html`<div class="pb-1">${joinTemplates(taskItems)}</div>`}
            </div>
          `;
      });
      return html`
        <div class="fixed right-4 top-20 w-72 max-h-[70vh] flex flex-col rounded-lg border border-zinc-800/60 bg-zinc-950/95 shadow-xl backdrop-blur-sm overflow-hidden">
          ${header}
          <div class="flex-1 overflow-y-auto">
            ${joinTemplates(categoryList)}
          </div>
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (_e, target) => {
        const el = target;
        const action = el.dataset.action;
        const category = el.dataset.category;
        const taskId = el.dataset.taskId;
        if (action === "hide") {
          exports_Effect.runFork(ctx.emit({ type: "hide" }));
        } else if (action === "expandAll") {
          exports_Effect.runFork(ctx.emit({ type: "expandAll" }));
        } else if (action === "collapseAll") {
          exports_Effect.runFork(ctx.emit({ type: "collapseAll" }));
        } else if (action === "toggleCategory" && category) {
          exports_Effect.runFork(ctx.emit({ type: "toggleCategory", category }));
        } else if (action === "selectTask" && taskId) {
          exports_Effect.runFork(ctx.emit({ type: "selectTask", taskId }));
        }
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      switch (event.type) {
        case "show":
          yield* ctx.state.update((s) => ({ ...s, visible: true }));
          break;
        case "hide":
          yield* ctx.state.update((s) => ({ ...s, visible: false }));
          break;
        case "toggleCategory":
          yield* ctx.state.update((s) => {
            const newCollapsed = new Set(s.collapsedCategories);
            if (newCollapsed.has(event.category)) {
              newCollapsed.delete(event.category);
            } else {
              newCollapsed.add(event.category);
            }
            return { ...s, collapsedCategories: newCollapsed };
          });
          break;
        case "expandAll":
          yield* ctx.state.update((s) => ({ ...s, collapsedCategories: new Set }));
          break;
        case "collapseAll": {
          const state = yield* ctx.state.get;
          const categories = groupTasksByCategory(state.tasks);
          const allCategories = new Set(categories.keys());
          yield* ctx.state.update((s) => ({ ...s, collapsedCategories: allCategories }));
          break;
        }
        case "selectTask":
          yield* ctx.state.update((s) => ({ ...s, selectedTaskId: event.taskId }));
          break;
      }
    }),
    subscriptions: (ctx) => {
      const socket = exports_Effect.map(SocketServiceTag, (s) => s);
      return [
        pipe(exports_Stream.unwrap(exports_Effect.map(socket, (s) => s.getMessages())), exports_Stream.filter((msg) => isTBMessage3(msg)), exports_Stream.map((msg) => exports_Effect.gen(function* () {
          if (isTBSuiteInfo(msg)) {
            const newTasks = new Map;
            for (const task of msg.tasks) {
              newTasks.set(task.id, {
                id: task.id,
                name: task.name,
                difficulty: task.difficulty,
                category: task.category,
                status: "pending"
              });
            }
            yield* ctx.state.update((s) => ({
              ...s,
              tasks: newTasks,
              visible: true
            }));
          }
          if (isTBTaskStart(msg)) {
            yield* ctx.state.update((s) => {
              const task = s.tasks.get(msg.taskId);
              if (!task)
                return s;
              const newTasks = new Map(s.tasks);
              newTasks.set(msg.taskId, { ...task, status: "running" });
              return { ...s, tasks: newTasks };
            });
          }
          if (isTBTaskComplete2(msg)) {
            yield* ctx.state.update((s) => {
              const task = s.tasks.get(msg.taskId);
              if (!task)
                return s;
              const newTasks = new Map(s.tasks);
              const status2 = msg.outcome;
              newTasks.set(msg.taskId, { ...task, status: status2 });
              return { ...s, tasks: newTasks };
            });
          }
        })))
      ];
    }
  };
  var initialCategoryTreeState = CategoryTreeWidget.initialState();
  // src/huggingface/schema.ts
  class HFDatasetError extends Error {
    reason;
    cause;
    _tag = "HFDatasetError";
    constructor(reason, message, cause3) {
      super(message);
      this.reason = reason;
      this.cause = cause3;
      this.name = "HFDatasetError";
    }
  }
  var DEFAULT_DATASETS_DIR = ".openagents/datasets";
  var DATASETS_INDEX_FILE = "index.json";
  var OPENTHOUGHTS_SFT_CONFIG = {
    repo: "open-thoughts/OpenThoughts-Agent-v1-SFT",
    revision: "main",
    filePattern: ".parquet"
  };

  // node_modules/@huggingface/hub/dist/browser/index.mjs
  init_chunk_QXAXOUZS();
  var HUB_URL = "https://huggingface.co";
  async function createApiError(response, opts) {
    const error = new HubApiError(response.url, response.status, response.headers.get("X-Request-Id") ?? opts?.requestId);
    error.message = `Api error with status ${error.statusCode}${opts?.message ? `. ${opts.message}` : ""}`;
    const trailer = [`URL: ${error.url}`, error.requestId ? `Request ID: ${error.requestId}` : undefined].filter(Boolean).join(". ");
    if (response.headers.get("Content-Type")?.startsWith("application/json")) {
      const json = await response.json();
      error.message = json.error || json.message || error.message;
      if (json.error_description) {
        error.message = error.message ? error.message + `: ${json.error_description}` : json.error_description;
      }
      error.data = json;
    } else {
      error.data = { message: await response.text() };
    }
    error.message += `. ${trailer}`;
    throw error;
  }
  var HubApiError = class extends Error {
    statusCode;
    url;
    requestId;
    data;
    constructor(url, statusCode, requestId, message) {
      super(message);
      this.statusCode = statusCode;
      this.requestId = requestId;
      this.url = url;
    }
  };
  var InvalidApiResponseFormatError = class extends Error {
  };
  function checkAccessToken(accessToken) {
    if (!accessToken.startsWith("hf_")) {
      throw new TypeError("Your access token must start with 'hf_'");
    }
  }
  function checkCredentials(params) {
    if (params.accessToken) {
      checkAccessToken(params.accessToken);
      return params.accessToken;
    }
    if (params.credentials?.accessToken) {
      checkAccessToken(params.credentials.accessToken);
      return params.credentials.accessToken;
    }
  }
  function toRepoId(repo) {
    if (typeof repo !== "string") {
      return repo;
    }
    if (repo.startsWith("model/") || repo.startsWith("models/")) {
      throw new TypeError("A repo designation for a model should not start with 'models/', directly specify the model namespace / name");
    }
    if (repo.startsWith("space/")) {
      throw new TypeError("Spaces should start with 'spaces/', plural, not 'space/'");
    }
    if (repo.startsWith("dataset/")) {
      throw new TypeError("Datasets should start with 'dataset/', plural, not 'dataset/'");
    }
    const slashes = repo.split("/").length - 1;
    if (repo.startsWith("spaces/")) {
      if (slashes !== 2) {
        throw new TypeError("Space Id must include namespace and name of the space");
      }
      return {
        type: "space",
        name: repo.slice("spaces/".length)
      };
    }
    if (repo.startsWith("datasets/")) {
      if (slashes > 2) {
        throw new TypeError("Too many slashes in repo designation: " + repo);
      }
      return {
        type: "dataset",
        name: repo.slice("datasets/".length)
      };
    }
    if (slashes > 1) {
      throw new TypeError("Too many slashes in repo designation: " + repo);
    }
    return {
      type: "model",
      name: repo
    };
  }
  var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  var isWebWorker = typeof self === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
  var resolve4;
  var waitPromise = new Promise((r) => {
    resolve4 = r;
  });
  var WebBlob = class extends Blob {
    static async create(url, opts) {
      const customFetch = opts?.fetch ?? fetch;
      const response = await customFetch(url, {
        method: "HEAD",
        ...opts?.accessToken && {
          headers: {
            Authorization: `Bearer ${opts.accessToken}`
          }
        }
      });
      const size13 = Number(response.headers.get("content-length"));
      const contentType = response.headers.get("content-type") || "";
      const supportRange = response.headers.get("accept-ranges") === "bytes";
      if (!supportRange || size13 < (opts?.cacheBelow ?? 1e6)) {
        return await (await customFetch(url)).blob();
      }
      return new WebBlob(url, 0, size13, contentType, true, customFetch, opts?.accessToken);
    }
    url;
    start;
    end;
    contentType;
    full;
    fetch;
    accessToken;
    constructor(url, start4, end6, contentType, full, customFetch, accessToken) {
      super([]);
      this.url = url;
      this.start = start4;
      this.end = end6;
      this.contentType = contentType;
      this.full = full;
      this.fetch = customFetch;
      this.accessToken = accessToken;
    }
    get size() {
      return this.end - this.start;
    }
    get type() {
      return this.contentType;
    }
    slice(start4 = 0, end6 = this.size) {
      if (start4 < 0 || end6 < 0) {
        new TypeError("Unsupported negative start/end on WebBlob.slice");
      }
      const slice2 = new WebBlob(this.url, this.start + start4, Math.min(this.start + end6, this.end), this.contentType, start4 === 0 && end6 === this.size ? this.full : false, this.fetch, this.accessToken);
      return slice2;
    }
    async arrayBuffer() {
      const result = await this.fetchRange();
      return result.arrayBuffer();
    }
    async text() {
      const result = await this.fetchRange();
      return result.text();
    }
    stream() {
      const stream3 = new TransformStream;
      this.fetchRange().then((response) => response.body?.pipeThrough(stream3)).catch((error) => stream3.writable.abort(error.message));
      return stream3.readable;
    }
    fetchRange() {
      const fetch2 = this.fetch;
      if (this.full) {
        return fetch2(this.url, {
          ...this.accessToken && {
            headers: {
              Authorization: `Bearer ${this.accessToken}`
            }
          }
        }).then((resp) => resp.ok ? resp : createApiError(resp));
      }
      return fetch2(this.url, {
        headers: {
          Range: `bytes=${this.start}-${this.end - 1}`,
          ...this.accessToken && { Authorization: `Bearer ${this.accessToken}` }
        }
      }).then((resp) => resp.ok ? resp : createApiError(resp));
    }
  };
  function combineUint8Arrays(a, b) {
    const aLength = a.length;
    const combinedBytes = new Uint8Array(aLength + b.length);
    combinedBytes.set(a);
    combinedBytes.set(b, aLength);
    return combinedBytes;
  }
  function readU64(b, n) {
    let x = 0;
    x |= b[n++] << 0;
    x |= b[n++] << 8;
    x |= b[n++] << 16;
    x |= b[n++] << 24;
    x |= b[n++] << 32;
    x |= b[n++] << 40;
    x |= b[n++] << 48;
    x |= b[n++] << 56;
    return x;
  }
  function readU32(b, n) {
    let x = 0;
    x |= b[n++] << 0;
    x |= b[n++] << 8;
    x |= b[n++] << 16;
    x |= b[n++] << 24;
    return x;
  }
  var minMatch = 4;
  var hashSize = 65536;
  var mlBits = 4;
  var mlMask = (1 << mlBits) - 1;
  var runBits = 4;
  var runMask = (1 << runBits) - 1;
  var blockBuf = makeBuffer(5242880);
  var hashTable = makeHashTable();
  var magicNum = 407708164;
  var fdContentChksum = 4;
  var fdContentSize = 8;
  var fdBlockChksum = 16;
  var fdVersion = 64;
  var fdVersionMask = 192;
  var bsUncompressed = 2147483648;
  var bsShift = 4;
  var bsMask = 7;
  var bsMap = {
    4: 65536,
    5: 262144,
    6: 1048576,
    7: 4194304
  };
  function makeHashTable() {
    try {
      return new Uint32Array(hashSize);
    } catch (error) {
      const hashTable2 = new Array(hashSize);
      for (let i2 = 0;i2 < hashSize; i2++) {
        hashTable2[i2] = 0;
      }
      return hashTable2;
    }
  }
  function makeBuffer(size13) {
    return new Uint8Array(size13);
  }
  function sliceArray(array4, start4, end6) {
    return array4.slice(start4, end6);
  }
  function decompressBound(src) {
    let sIndex = 0;
    if (readU32(src, sIndex) !== magicNum) {
      throw new Error("invalid magic number");
    }
    sIndex += 4;
    const descriptor3 = src[sIndex++];
    if ((descriptor3 & fdVersionMask) !== fdVersion) {
      throw new Error("incompatible descriptor version " + (descriptor3 & fdVersionMask));
    }
    const useBlockSum = (descriptor3 & fdBlockChksum) !== 0;
    const useContentSize = (descriptor3 & fdContentSize) !== 0;
    const bsIdx = src[sIndex++] >> bsShift & bsMask;
    if (bsMap[bsIdx] === undefined) {
      throw new Error("invalid block size " + bsIdx);
    }
    const maxBlockSize = bsMap[bsIdx];
    if (useContentSize) {
      return readU64(src, sIndex);
    }
    sIndex++;
    let maxSize = 0;
    while (true) {
      let blockSize = readU32(src, sIndex);
      sIndex += 4;
      if (blockSize & bsUncompressed) {
        blockSize &= ~bsUncompressed;
        maxSize += blockSize;
      } else if (blockSize > 0) {
        maxSize += maxBlockSize;
      }
      if (blockSize === 0) {
        return maxSize;
      }
      if (useBlockSum) {
        sIndex += 4;
      }
      sIndex += blockSize;
    }
  }
  function decompressBlock(src, dst, sIndex, sLength, dIndex) {
    let mLength, mOffset, sEnd, n, i2;
    const hasCopyWithin = dst.copyWithin !== undefined && dst.fill !== undefined;
    sEnd = sIndex + sLength;
    while (sIndex < sEnd) {
      const token = src[sIndex++];
      let literalCount = token >> 4;
      if (literalCount > 0) {
        if (literalCount === 15) {
          while (true) {
            literalCount += src[sIndex];
            if (src[sIndex++] !== 255) {
              break;
            }
          }
        }
        for (n = sIndex + literalCount;sIndex < n; ) {
          dst[dIndex++] = src[sIndex++];
        }
      }
      if (sIndex >= sEnd) {
        break;
      }
      mLength = token & 15;
      mOffset = src[sIndex++] | src[sIndex++] << 8;
      if (mLength === 15) {
        while (true) {
          mLength += src[sIndex];
          if (src[sIndex++] !== 255) {
            break;
          }
        }
      }
      mLength += minMatch;
      if (hasCopyWithin && mOffset === 1) {
        dst.fill(dst[dIndex - 1] | 0, dIndex, dIndex + mLength);
        dIndex += mLength;
      } else if (hasCopyWithin && mOffset > mLength && mLength > 31) {
        dst.copyWithin(dIndex, dIndex - mOffset, dIndex - mOffset + mLength);
        dIndex += mLength;
      } else {
        for (i2 = dIndex - mOffset, n = i2 + mLength;i2 < n; ) {
          dst[dIndex++] = dst[i2++] | 0;
        }
      }
    }
    return dIndex;
  }
  function decompressFrame(src, dst) {
    let useBlockSum, useContentSum, useContentSize, descriptor3;
    let sIndex = 0;
    let dIndex = 0;
    if (readU32(src, sIndex) !== magicNum) {
      throw new Error("invalid magic number");
    }
    sIndex += 4;
    descriptor3 = src[sIndex++];
    if ((descriptor3 & fdVersionMask) !== fdVersion) {
      throw new Error("incompatible descriptor version");
    }
    useBlockSum = (descriptor3 & fdBlockChksum) !== 0;
    useContentSum = (descriptor3 & fdContentChksum) !== 0;
    useContentSize = (descriptor3 & fdContentSize) !== 0;
    const bsIdx = src[sIndex++] >> bsShift & bsMask;
    if (bsMap[bsIdx] === undefined) {
      throw new Error("invalid block size");
    }
    if (useContentSize) {
      sIndex += 8;
    }
    sIndex++;
    while (true) {
      var compSize;
      compSize = readU32(src, sIndex);
      sIndex += 4;
      if (compSize === 0) {
        break;
      }
      if (useBlockSum) {
        sIndex += 4;
      }
      if ((compSize & bsUncompressed) !== 0) {
        compSize &= ~bsUncompressed;
        for (let j = 0;j < compSize; j++) {
          dst[dIndex++] = src[sIndex++];
        }
      } else {
        dIndex = decompressBlock(src, dst, sIndex, compSize, dIndex);
        sIndex += compSize;
      }
    }
    if (useContentSum) {
      sIndex += 4;
    }
    return dIndex;
  }
  function decompress(src, maxSize) {
    let dst, size13;
    if (maxSize === undefined) {
      maxSize = decompressBound(src);
    }
    dst = makeBuffer(maxSize);
    size13 = decompressFrame(src, dst);
    if (size13 !== maxSize) {
      dst = sliceArray(dst, 0, size13);
    }
    return dst;
  }
  var RangeList = class {
    ranges = [];
    add(start4, end6) {
      if (end6 <= start4) {
        throw new TypeError("End must be greater than start");
      }
      const overlappingRanges = [];
      for (let i2 = 0;i2 < this.ranges.length; i2++) {
        const range22 = this.ranges[i2];
        if (start4 < range22.end && end6 > range22.start) {
          overlappingRanges.push({ index: i2, range: range22 });
        }
        if (range22.data !== null) {
          throw new Error("Overlapping range already has data");
        }
      }
      if (overlappingRanges.length === 0) {
        this.ranges.push({ start: start4, end: end6, refCount: 1, data: null });
        this.ranges.sort((a, b) => a.start - b.start);
        return;
      }
      const newRanges = [];
      let currentPos = start4;
      for (let i2 = 0;i2 < overlappingRanges.length; i2++) {
        const { range: range22 } = overlappingRanges[i2];
        if (currentPos < range22.start) {
          newRanges.push({
            start: currentPos,
            end: range22.start,
            refCount: 1,
            data: null
          });
        } else if (range22.start < currentPos) {
          newRanges.push({
            start: range22.start,
            end: currentPos,
            refCount: range22.refCount,
            data: null
          });
        }
        newRanges.push({
          start: Math.max(currentPos, range22.start),
          end: Math.min(end6, range22.end),
          refCount: range22.refCount + 1,
          data: null
        });
        if (range22.end > end6) {
          newRanges.push({
            start: end6,
            end: range22.end,
            refCount: range22.refCount,
            data: null
          });
        }
        currentPos = Math.max(currentPos, range22.end);
      }
      if (currentPos < end6) {
        newRanges.push({
          start: currentPos,
          end: end6,
          refCount: 1,
          data: null
        });
      }
      const firstIndex = overlappingRanges[0].index;
      const lastIndex = overlappingRanges[overlappingRanges.length - 1].index;
      this.ranges.splice(firstIndex, lastIndex - firstIndex + 1, ...newRanges);
      this.ranges.sort((a, b) => a.start - b.start);
    }
    remove(start4, end6) {
      if (end6 <= start4) {
        throw new TypeError("End must be greater than start");
      }
      const affectedRanges = [];
      for (let i2 = 0;i2 < this.ranges.length; i2++) {
        const range22 = this.ranges[i2];
        if (start4 < range22.end && end6 > range22.start) {
          affectedRanges.push({ index: i2, range: range22 });
        }
      }
      if (affectedRanges.length === 0) {
        throw new Error("No ranges found to remove");
      }
      if (start4 !== affectedRanges[0].range.start || end6 !== affectedRanges[affectedRanges.length - 1].range.end) {
        throw new Error("Range boundaries must match existing boundaries");
      }
      for (let i2 = 0;i2 < affectedRanges.length; i2++) {
        const { range: range22 } = affectedRanges[i2];
        range22.refCount--;
      }
      this.ranges = this.ranges.filter((range22) => range22.refCount > 0);
    }
    getRanges(start4, end6) {
      if (end6 <= start4) {
        throw new TypeError("End must be greater than start");
      }
      return this.ranges.filter((range22) => start4 < range22.end && end6 > range22.start);
    }
    getAllRanges() {
      return [...this.ranges];
    }
  };
  var JWT_SAFETY_PERIOD = 60000;
  var JWT_CACHE_SIZE = 1000;
  var compressionSchemeLabels = {
    [0]: "None",
    [1]: "LZ4",
    [2]: "ByteGroupingLZ4"
  };
  var XET_CHUNK_HEADER_BYTES = 8;
  var XetBlob = class extends Blob {
    fetch;
    accessToken;
    refreshUrl;
    reconstructionUrl;
    hash;
    start = 0;
    end = 0;
    internalLogging = false;
    reconstructionInfo;
    listener;
    constructor(params) {
      super([]);
      this.fetch = params.fetch ?? fetch.bind(globalThis);
      this.accessToken = checkCredentials(params);
      this.refreshUrl = params.refreshUrl;
      this.end = params.size;
      this.reconstructionUrl = params.reconstructionUrl;
      this.hash = params.hash;
      this.listener = params.listener;
      this.internalLogging = params.internalLogging ?? false;
      this.refreshUrl;
    }
    get size() {
      return this.end - this.start;
    }
    #clone() {
      const blob = new XetBlob({
        fetch: this.fetch,
        hash: this.hash,
        refreshUrl: this.refreshUrl,
        reconstructionUrl: this.reconstructionUrl,
        size: this.size
      });
      blob.accessToken = this.accessToken;
      blob.start = this.start;
      blob.end = this.end;
      blob.reconstructionInfo = this.reconstructionInfo;
      blob.listener = this.listener;
      blob.internalLogging = this.internalLogging;
      return blob;
    }
    slice(start4 = 0, end6 = this.size) {
      if (start4 < 0 || end6 < 0) {
        new TypeError("Unsupported negative start/end on XetBlob.slice");
      }
      const slice2 = this.#clone();
      slice2.start = this.start + start4;
      slice2.end = Math.min(this.start + end6, this.end);
      if (slice2.start !== this.start || slice2.end !== this.end) {
        slice2.reconstructionInfo = undefined;
      }
      return slice2;
    }
    #reconstructionInfoPromise;
    #loadReconstructionInfo() {
      if (this.#reconstructionInfoPromise) {
        return this.#reconstructionInfoPromise;
      }
      this.#reconstructionInfoPromise = (async () => {
        const connParams = await getAccessToken(this.accessToken, this.fetch, this.refreshUrl);
        const resp = await this.fetch(this.reconstructionUrl ?? `${connParams.casUrl}/v1/reconstructions/${this.hash}`, {
          headers: {
            Authorization: `Bearer ${connParams.accessToken}`,
            Range: `bytes=${this.start}-${this.end - 1}`
          }
        });
        if (!resp.ok) {
          throw await createApiError(resp);
        }
        this.reconstructionInfo = await resp.json();
        return this.reconstructionInfo;
      })().finally(() => this.#reconstructionInfoPromise = undefined);
      return this.#reconstructionInfoPromise;
    }
    async#fetch() {
      if (!this.reconstructionInfo) {
        await this.#loadReconstructionInfo();
      }
      const rangeLists = /* @__PURE__ */ new Map;
      if (!this.reconstructionInfo) {
        throw new Error("Failed to load reconstruction info");
      }
      for (const term of this.reconstructionInfo.terms) {
        let rangeList = rangeLists.get(term.hash);
        if (!rangeList) {
          rangeList = new RangeList;
          rangeLists.set(term.hash, rangeList);
        }
        rangeList.add(term.range.start, term.range.end);
      }
      const listener = this.listener;
      const log4 = this.internalLogging ? (...args2) => console.log(...args2) : () => {};
      async function* readData(reconstructionInfo, customFetch, maxBytes, reloadReconstructionInfo) {
        let totalBytesRead = 0;
        let readBytesToSkip = reconstructionInfo.offset_into_first_range;
        for (const term of reconstructionInfo.terms) {
          if (totalBytesRead >= maxBytes) {
            break;
          }
          const rangeList = rangeLists.get(term.hash);
          if (!rangeList) {
            throw new Error(`Failed to find range list for term ${term.hash}`);
          }
          {
            const termRanges = rangeList.getRanges(term.range.start, term.range.end);
            if (termRanges.every((range22) => range22.data)) {
              log4("all data available for term", term.hash, readBytesToSkip);
              rangeLoop:
                for (const range22 of termRanges) {
                  for (let chunk22 of range22.data) {
                    if (readBytesToSkip) {
                      const skipped = Math.min(readBytesToSkip, chunk22.byteLength);
                      chunk22 = chunk22.slice(skipped);
                      readBytesToSkip -= skipped;
                      if (!chunk22.byteLength) {
                        continue;
                      }
                    }
                    if (chunk22.byteLength > maxBytes - totalBytesRead) {
                      chunk22 = chunk22.slice(0, maxBytes - totalBytesRead);
                    }
                    totalBytesRead += chunk22.byteLength;
                    yield range22.refCount > 1 ? chunk22.slice() : chunk22;
                    listener?.({ event: "progress", progress: { read: totalBytesRead, total: maxBytes } });
                    if (totalBytesRead >= maxBytes) {
                      break rangeLoop;
                    }
                  }
                }
              rangeList.remove(term.range.start, term.range.end);
              continue;
            }
          }
          const fetchInfo = reconstructionInfo.fetch_info[term.hash].find((info) => info.range.start <= term.range.start && info.range.end >= term.range.end);
          if (!fetchInfo) {
            throw new Error(`Failed to find fetch info for term ${term.hash} and range ${term.range.start}-${term.range.end}`);
          }
          log4("term", term);
          log4("fetchinfo", fetchInfo);
          log4("readBytesToSkip", readBytesToSkip);
          let resp = await customFetch(fetchInfo.url, {
            headers: {
              Range: `bytes=${fetchInfo.url_range.start}-${fetchInfo.url_range.end}`
            }
          });
          if (resp.status === 403) {
            reconstructionInfo = await reloadReconstructionInfo();
            resp = await customFetch(fetchInfo.url, {
              headers: {
                Range: `bytes=${fetchInfo.url_range.start}-${fetchInfo.url_range.end}`
              }
            });
          }
          if (!resp.ok) {
            throw await createApiError(resp);
          }
          log4("expected content length", resp.headers.get("content-length"), "range", fetchInfo.url_range, resp.headers.get("content-range"));
          const reader = resp.body?.getReader();
          if (!reader) {
            throw new Error("Failed to get reader from response body");
          }
          let done11 = false;
          let chunkIndex = fetchInfo.range.start;
          const ranges = rangeList.getRanges(fetchInfo.range.start, fetchInfo.range.end);
          let leftoverBytes = undefined;
          let totalFetchBytes = 0;
          fetchData:
            while (!done11 && totalBytesRead < maxBytes) {
              const result = await reader.read();
              listener?.({ event: "read" });
              done11 = result.done;
              log4("read", result.value?.byteLength, "bytes", "total read", totalBytesRead, "toSkip", readBytesToSkip);
              if (!result.value) {
                log4("no data in result, cancelled", result);
                continue;
              }
              totalFetchBytes += result.value.byteLength;
              if (leftoverBytes) {
                result.value = combineUint8Arrays(leftoverBytes, result.value);
                leftoverBytes = undefined;
              }
              while (totalBytesRead < maxBytes && result.value?.byteLength) {
                if (result.value.byteLength < 8) {
                  leftoverBytes = result.value;
                  continue fetchData;
                }
                const header = new DataView(result.value.buffer, result.value.byteOffset, XET_CHUNK_HEADER_BYTES);
                const chunkHeader = {
                  version: header.getUint8(0),
                  compressed_length: header.getUint8(1) | header.getUint8(2) << 8 | header.getUint8(3) << 16,
                  compression_scheme: header.getUint8(4),
                  uncompressed_length: header.getUint8(5) | header.getUint8(6) << 8 | header.getUint8(7) << 16
                };
                log4("chunk header", chunkHeader, "to skip", readBytesToSkip);
                if (chunkHeader.version !== 0) {
                  throw new Error(`Unsupported chunk version ${chunkHeader.version}`);
                }
                if (chunkHeader.compression_scheme !== 0 && chunkHeader.compression_scheme !== 1 && chunkHeader.compression_scheme !== 2) {
                  throw new Error(`Unsupported compression scheme ${compressionSchemeLabels[chunkHeader.compression_scheme] ?? chunkHeader.compression_scheme}`);
                }
                if (result.value.byteLength < chunkHeader.compressed_length + XET_CHUNK_HEADER_BYTES) {
                  leftoverBytes = result.value;
                  continue fetchData;
                }
                result.value = result.value.slice(XET_CHUNK_HEADER_BYTES);
                let uncompressed = chunkHeader.compression_scheme === 1 ? decompress(result.value.slice(0, chunkHeader.compressed_length), chunkHeader.uncompressed_length) : chunkHeader.compression_scheme === 2 ? bg4_regroup_bytes(decompress(result.value.slice(0, chunkHeader.compressed_length), chunkHeader.uncompressed_length)) : result.value.slice(0, chunkHeader.compressed_length);
                const range22 = ranges.find((range32) => chunkIndex >= range32.start && chunkIndex < range32.end);
                const shouldYield = chunkIndex >= term.range.start && chunkIndex < term.range.end;
                const minRefCountToStore = shouldYield ? 2 : 1;
                let stored = false;
                if (range22 && range22.refCount >= minRefCountToStore) {
                  range22.data ??= [];
                  range22.data.push(uncompressed);
                  stored = true;
                }
                if (shouldYield) {
                  if (readBytesToSkip) {
                    const skipped = Math.min(readBytesToSkip, uncompressed.byteLength);
                    uncompressed = uncompressed.slice(readBytesToSkip);
                    readBytesToSkip -= skipped;
                  }
                  if (uncompressed.byteLength > maxBytes - totalBytesRead) {
                    uncompressed = uncompressed.slice(0, maxBytes - totalBytesRead);
                  }
                  if (uncompressed.byteLength) {
                    log4("yield", uncompressed.byteLength, "bytes", result.value.byteLength, "total read", totalBytesRead, stored);
                    totalBytesRead += uncompressed.byteLength;
                    yield stored ? uncompressed.slice() : uncompressed;
                    listener?.({ event: "progress", progress: { read: totalBytesRead, total: maxBytes } });
                  }
                }
                chunkIndex++;
                result.value = result.value.slice(chunkHeader.compressed_length);
              }
            }
          if (done11 && totalBytesRead < maxBytes && totalFetchBytes < fetchInfo.url_range.end - fetchInfo.url_range.start + 1) {
            log4("done", done11, "total read", totalBytesRead, maxBytes, totalFetchBytes);
            log4("failed to fetch all data for term", term.hash);
            throw new Error(`Failed to fetch all data for term ${term.hash}, fetched ${totalFetchBytes} bytes out of ${fetchInfo.url_range.end - fetchInfo.url_range.start + 1}`);
          }
          log4("done", done11, "total read", totalBytesRead, maxBytes, totalFetchBytes);
          log4("cancel reader");
          await reader.cancel();
        }
      }
      const iterator = readData(this.reconstructionInfo, this.fetch, this.end - this.start, this.#loadReconstructionInfo.bind(this));
      return new ReadableStream({
        async pull(controller) {
          const result = await iterator.next();
          if (result.value) {
            controller.enqueue(result.value);
          }
          if (result.done) {
            controller.close();
          }
        },
        type: "bytes"
      }, {
        highWaterMark: 1000
      });
    }
    async arrayBuffer() {
      const result = await this.#fetch();
      return new Response(result).arrayBuffer();
    }
    async text() {
      const result = await this.#fetch();
      return new Response(result).text();
    }
    async response() {
      const result = await this.#fetch();
      return new Response(result);
    }
    stream() {
      const stream3 = new TransformStream;
      this.#fetch().then((response) => response.pipeThrough(stream3)).catch((error) => stream3.writable.abort(error.message));
      return stream3.readable;
    }
  };
  var jwtPromises = /* @__PURE__ */ new Map;
  var jwts = /* @__PURE__ */ new Map;
  function cacheKey(params) {
    return JSON.stringify([params.refreshUrl, params.initialAccessToken]);
  }
  function bg4_regroup_bytes(bytes) {
    const split3 = Math.floor(bytes.byteLength / 4);
    const rem = bytes.byteLength % 4;
    const g1_pos = split3 + (rem >= 1 ? 1 : 0);
    const g2_pos = g1_pos + split3 + (rem >= 2 ? 1 : 0);
    const g3_pos = g2_pos + split3 + (rem == 3 ? 1 : 0);
    const ret = new Uint8Array(bytes.byteLength);
    for (let i2 = 0, j = 0;i2 < bytes.byteLength; i2 += 4, j++) {
      ret[i2] = bytes[j];
    }
    for (let i2 = 1, j = g1_pos;i2 < bytes.byteLength; i2 += 4, j++) {
      ret[i2] = bytes[j];
    }
    for (let i2 = 2, j = g2_pos;i2 < bytes.byteLength; i2 += 4, j++) {
      ret[i2] = bytes[j];
    }
    for (let i2 = 3, j = g3_pos;i2 < bytes.byteLength; i2 += 4, j++) {
      ret[i2] = bytes[j];
    }
    return ret;
  }
  async function getAccessToken(initialAccessToken, customFetch, refreshUrl) {
    const key = cacheKey({ refreshUrl, initialAccessToken });
    const jwt = jwts.get(key);
    if (jwt && jwt.expiresAt > new Date(Date.now() + JWT_SAFETY_PERIOD)) {
      return { accessToken: jwt.accessToken, casUrl: jwt.casUrl };
    }
    const existingPromise = jwtPromises.get(key);
    if (existingPromise) {
      return existingPromise;
    }
    const promise3 = (async () => {
      const resp = await customFetch(refreshUrl, {
        headers: {
          ...initialAccessToken ? {
            Authorization: `Bearer ${initialAccessToken}`
          } : {}
        }
      });
      if (!resp.ok) {
        throw new Error(`Failed to get JWT token: ${resp.status} ${await resp.text()}`);
      }
      const json = await resp.json();
      const jwt2 = {
        accessToken: json.accessToken,
        expiresAt: new Date(json.exp * 1000),
        casUrl: json.casUrl
      };
      jwtPromises.delete(key);
      for (const [key2, value] of jwts.entries()) {
        if (value.expiresAt < new Date(Date.now() + JWT_SAFETY_PERIOD)) {
          jwts.delete(key2);
        } else {
          break;
        }
      }
      if (jwts.size >= JWT_CACHE_SIZE) {
        const keyToDelete = jwts.keys().next().value;
        if (keyToDelete) {
          jwts.delete(keyToDelete);
        }
      }
      jwts.set(key, jwt2);
      return {
        accessToken: json.accessToken,
        casUrl: json.casUrl
      };
    })();
    jwtPromises.set(key, promise3);
    return promise3;
  }
  var HASH_LENGTH = 32;
  var XORB_HASH_BOOKEND = "ff".repeat(HASH_LENGTH);
  var TARGET_CHUNK_SIZE = 65536;
  var MAX_CHUNK_SIZE = 2 * TARGET_CHUNK_SIZE;
  var PROCESSING_PROGRESS_RATIO = 0.1;
  var UPLOADING_PROGRESS_RATIO = 1 - PROCESSING_PROGRESS_RATIO;
  var SHARD_MAGIC_TAG = new Uint8Array([
    72,
    70,
    82,
    101,
    112,
    111,
    77,
    101,
    116,
    97,
    68,
    97,
    116,
    97,
    0,
    85,
    105,
    103,
    69,
    106,
    123,
    129,
    87,
    131,
    165,
    189,
    217,
    92,
    205,
    209,
    74,
    169
  ]);
  function parseLinkHeader(header) {
    const regex = /<(https?:[/][/][^>]+)>;\s+rel="([^"]+)"/g;
    return Object.fromEntries([...header.matchAll(regex)].map(([, url, rel]) => [rel, url]));
  }
  async function fileDownloadInfo(params) {
    const accessToken = checkCredentials(params);
    const repoId = toRepoId(params.repo);
    const hubUrl = params.hubUrl ?? HUB_URL;
    const url = `${hubUrl}/${repoId.type === "model" ? "" : `${repoId.type}s/`}${repoId.name}/${params.raw ? "raw" : "resolve"}/${encodeURIComponent(params.revision ?? "main")}/${params.path}` + (params.noContentDisposition ? "?noContentDisposition=1" : "");
    const resp = await (params.fetch ?? fetch)(url, {
      method: "GET",
      headers: {
        ...accessToken && {
          Authorization: `Bearer ${accessToken}`
        },
        Range: "bytes=0-0",
        Accept: "application/vnd.xet-fileinfo+json, */*"
      }
    });
    if (resp.status === 404 && resp.headers.get("X-Error-Code") === "EntryNotFound") {
      return null;
    }
    if (!resp.ok) {
      throw await createApiError(resp);
    }
    let size13;
    let xetInfo;
    if (resp.headers.get("Content-Type")?.includes("application/vnd.xet-fileinfo+json")) {
      size13 = parseInt(resp.headers.get("X-Linked-Size") ?? "invalid");
      if (isNaN(size13)) {
        throw new InvalidApiResponseFormatError("Invalid file size received in X-Linked-Size header");
      }
      const hash2 = resp.headers.get("X-Xet-Hash");
      const links = parseLinkHeader(resp.headers.get("Link") ?? "");
      const reconstructionUrl = (() => {
        try {
          return new URL(links["xet-reconstruction-info"]);
        } catch {
          return null;
        }
      })();
      const refreshUrl = (() => {
        try {
          return new URL(links["xet-auth"]);
        } catch {
          return null;
        }
      })();
      if (!hash2) {
        throw new InvalidApiResponseFormatError("No hash received in X-Xet-Hash header");
      }
      if (!reconstructionUrl || !refreshUrl) {
        throw new InvalidApiResponseFormatError("No xet-reconstruction-info or xet-auth link header");
      }
      xetInfo = {
        hash: hash2,
        refreshUrl,
        reconstructionUrl
      };
    }
    if (size13 === undefined || isNaN(size13)) {
      const contentRangeHeader = resp.headers.get("content-range");
      if (!contentRangeHeader) {
        throw new InvalidApiResponseFormatError("Expected size information");
      }
      const [, parsedSize] = contentRangeHeader.split("/");
      size13 = parseInt(parsedSize);
      if (isNaN(size13)) {
        throw new InvalidApiResponseFormatError("Invalid file size received");
      }
    }
    const etag = resp.headers.get("X-Linked-ETag") ?? resp.headers.get("ETag") ?? undefined;
    if (!etag) {
      throw new InvalidApiResponseFormatError("Expected ETag");
    }
    return {
      etag,
      size: size13,
      xet: xetInfo,
      url: resp.url && (new URL(resp.url).origin === new URL(hubUrl).origin || resp.headers.get("X-Cache")?.endsWith(" cloudfront")) ? resp.url : url
    };
  }
  async function downloadFile(params) {
    const accessToken = checkCredentials(params);
    const info = params.downloadInfo ?? await fileDownloadInfo({
      accessToken,
      repo: params.repo,
      path: params.path,
      revision: params.revision,
      hubUrl: params.hubUrl,
      fetch: params.fetch,
      raw: params.raw
    });
    if (!info) {
      return null;
    }
    if (info.xet && params.xet) {
      return new XetBlob({
        refreshUrl: info.xet.refreshUrl.href,
        reconstructionUrl: info.xet.reconstructionUrl.href,
        fetch: params.fetch,
        accessToken,
        size: info.size
      });
    }
    return new WebBlob(new URL(info.url), 0, info.size, "", true, params.fetch ?? fetch, accessToken);
  }
  async function* listFiles(params) {
    const accessToken = checkCredentials(params);
    const repoId = toRepoId(params.repo);
    let url = `${params.hubUrl || HUB_URL}/api/${repoId.type}s/${repoId.name}/tree/${params.revision || "main"}${params.path ? "/" + params.path : ""}?recursive=${!!params.recursive}&expand=${!!params.expand}`;
    while (url) {
      const res = await (params.fetch ?? fetch)(url, {
        headers: {
          accept: "application/json",
          ...accessToken ? { Authorization: `Bearer ${accessToken}` } : undefined
        }
      });
      if (!res.ok) {
        throw await createApiError(res);
      }
      const items = await res.json();
      for (const item of items) {
        yield item;
      }
      const linkHeader = res.headers.get("Link");
      url = linkHeader ? parseLinkHeader(linkHeader).next : undefined;
    }
  }

  // src/huggingface/service.ts
  class HFDatasetService extends exports_Context.Tag("HFDatasetService")() {
  }
  var makeHFDatasetService = (config = {}) => exports_Effect.gen(function* () {
    const fs = yield* FileSystem;
    const pathService = yield* Path2;
    const datasetsDir = config.datasetsDir ?? DEFAULT_DATASETS_DIR;
    const defaultToken = config.accessToken ?? process.env.HF_TOKEN;
    yield* fs.makeDirectory(datasetsDir, { recursive: true }).pipe(exports_Effect.catchAll(() => exports_Effect.void));
    const getIndexPath = () => pathService.join(datasetsDir, DATASETS_INDEX_FILE);
    const loadIndex = () => exports_Effect.gen(function* () {
      const indexPath = getIndexPath();
      const exists4 = yield* fs.exists(indexPath).pipe(exports_Effect.catchAll(() => exports_Effect.succeed(false)));
      if (!exists4) {
        return { datasets: {}, updatedAt: new Date().toISOString() };
      }
      const content = yield* fs.readFileString(indexPath).pipe(exports_Effect.mapError((e) => new HFDatasetError("parse_error", `Failed to read index: ${e.message}`)));
      try {
        return JSON.parse(content);
      } catch (e) {
        return yield* exports_Effect.fail(new HFDatasetError("parse_error", `Failed to parse index: ${e}`));
      }
    });
    const saveIndex = (index) => exports_Effect.gen(function* () {
      const indexPath = getIndexPath();
      const content = JSON.stringify(index, null, 2);
      yield* fs.writeFileString(indexPath, content).pipe(exports_Effect.mapError((e) => new HFDatasetError("write_error", `Failed to save index: ${e.message}`)));
    });
    const getRepoDir = (repo) => {
      const [owner, name] = repo.split("/");
      return pathService.join(datasetsDir, owner ?? repo, name ?? "");
    };
    const matchesPattern = (filePath, pattern2) => {
      if (!pattern2)
        return true;
      if (pattern2.startsWith(".")) {
        return filePath.endsWith(pattern2);
      }
      return filePath.includes(pattern2);
    };
    const service3 = {
      getDatasetsDir: () => datasetsDir,
      download: (downloadConfig) => exports_Effect.gen(function* () {
        const { repo, revision = "main", filePattern = "**/*.parquet" } = downloadConfig;
        const accessToken = downloadConfig.accessToken ?? defaultToken;
        const repoDir = getRepoDir(repo);
        yield* fs.makeDirectory(repoDir, { recursive: true }).pipe(exports_Effect.mapError((e) => new HFDatasetError("write_error", `Failed to create directory: ${e.message}`)));
        const files = yield* exports_Effect.tryPromise({
          try: async () => {
            const result = [];
            for await (const file of listFiles({
              repo: { type: "dataset", name: repo },
              revision,
              credentials: accessToken ? { accessToken } : undefined,
              recursive: true
            })) {
              if (file.type === "file" && matchesPattern(file.path, filePattern)) {
                result.push(file);
              }
            }
            return result;
          },
          catch: (e) => {
            const error = e;
            if (error.message?.includes("401") || error.message?.includes("403")) {
              return new HFDatasetError("auth_required", `Authentication required for ${repo}`);
            }
            if (error.message?.includes("404")) {
              return new HFDatasetError("not_found", `Dataset not found: ${repo}`);
            }
            if (error.message?.includes("429")) {
              return new HFDatasetError("rate_limited", `Rate limited. Try again later.`);
            }
            return new HFDatasetError("network_error", `Failed to list files: ${error.message}`, e);
          }
        });
        if (files.length === 0) {
          return yield* exports_Effect.fail(new HFDatasetError("not_found", `No files matching pattern "${filePattern}" found in ${repo}`));
        }
        const downloadedFiles = [];
        let totalBytes = 0;
        for (const file of files) {
          const localFilePath = pathService.join(repoDir, file.path);
          const localFileDir = pathService.dirname(localFilePath);
          yield* fs.makeDirectory(localFileDir, { recursive: true }).pipe(exports_Effect.catchAll(() => exports_Effect.void));
          console.log(`Downloading ${file.path} (${formatBytes(file.size ?? 0)})...`);
          const buffer4 = yield* exports_Effect.tryPromise({
            try: async () => {
              const response = await downloadFile({
                repo: { type: "dataset", name: repo },
                path: file.path,
                revision,
                credentials: accessToken ? { accessToken } : undefined
              });
              if (!response) {
                throw new Error("No response");
              }
              const arrayBuffer = await response.arrayBuffer();
              return new Uint8Array(arrayBuffer);
            },
            catch: (e) => {
              const error = e;
              return new HFDatasetError("network_error", `Failed to download ${file.path}: ${error.message}`, e);
            }
          });
          yield* fs.writeFile(localFilePath, buffer4).pipe(exports_Effect.mapError((e) => new HFDatasetError("write_error", `Failed to write ${file.path}: ${e.message}`)));
          downloadedFiles.push(file.path);
          totalBytes += buffer4.length;
          console.log(`  Saved to ${localFilePath}`);
        }
        const downloadInfo = {
          repo,
          localPath: repoDir,
          files: downloadedFiles,
          totalBytes,
          downloadedAt: new Date().toISOString(),
          revision
        };
        const index = yield* loadIndex();
        index.datasets[repo] = downloadInfo;
        index.updatedAt = new Date().toISOString();
        yield* saveIndex(index);
        console.log(`
Download complete: ${downloadedFiles.length} files, ${formatBytes(totalBytes)}`);
        return downloadInfo;
      }),
      isDownloaded: (repo) => exports_Effect.gen(function* () {
        const index = yield* loadIndex();
        return repo in index.datasets;
      }),
      getDownloadInfo: (repo) => exports_Effect.gen(function* () {
        const index = yield* loadIndex();
        return index.datasets[repo] ?? null;
      }),
      getLocalPath: (repo) => exports_Effect.gen(function* () {
        const index = yield* loadIndex();
        const info = index.datasets[repo];
        return info?.localPath ?? null;
      }),
      listDownloaded: () => exports_Effect.gen(function* () {
        const index = yield* loadIndex();
        return Object.values(index.datasets);
      }),
      delete: (repo) => exports_Effect.gen(function* () {
        const index = yield* loadIndex();
        const info = index.datasets[repo];
        if (!info) {
          return yield* exports_Effect.fail(new HFDatasetError("not_found", `Dataset not downloaded: ${repo}`));
        }
        yield* fs.remove(info.localPath, { recursive: true }).pipe(exports_Effect.mapError((e) => new HFDatasetError("write_error", `Failed to delete: ${e.message}`)));
        delete index.datasets[repo];
        index.updatedAt = new Date().toISOString();
        yield* saveIndex(index);
      })
    };
    return service3;
  });
  var HFDatasetServiceLive = (config = {}) => exports_Layer.effect(HFDatasetService, makeHFDatasetService(config));
  function formatBytes(bytes) {
    if (bytes === 0)
      return "0 B";
    const k = 1024;
    const sizes = ["B", "KB", "MB", "GB"];
    const i2 = Math.floor(Math.log(bytes) / Math.log(k));
    return `${(bytes / Math.pow(k, i2)).toFixed(1)} ${sizes[i2]}`;
  }

  // node_modules/parquet-wasm/esm/parquet_wasm.js
  var wasm;
  var cachedUint8ArrayMemory0 = null;
  function getUint8ArrayMemory0() {
    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
      cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8ArrayMemory0;
  }
  var cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
  cachedTextDecoder.decode();
  var MAX_SAFARI_DECODE_BYTES = 2146435072;
  var numBytesDecoded = 0;
  function decodeText3(ptr, len2) {
    numBytesDecoded += len2;
    if (numBytesDecoded >= MAX_SAFARI_DECODE_BYTES) {
      cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
      cachedTextDecoder.decode();
      numBytesDecoded = len2;
    }
    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len2));
  }
  function getStringFromWasm0(ptr, len2) {
    ptr = ptr >>> 0;
    return decodeText3(ptr, len2);
  }
  var WASM_VECTOR_LEN = 0;
  var cachedTextEncoder = new TextEncoder;
  if (!("encodeInto" in cachedTextEncoder)) {
    cachedTextEncoder.encodeInto = function(arg, view) {
      const buf = cachedTextEncoder.encode(arg);
      view.set(buf);
      return {
        read: arg.length,
        written: buf.length
      };
    };
  }
  function passStringToWasm0(arg, malloc, realloc) {
    if (realloc === undefined) {
      const buf = cachedTextEncoder.encode(arg);
      const ptr2 = malloc(buf.length, 1) >>> 0;
      getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
      WASM_VECTOR_LEN = buf.length;
      return ptr2;
    }
    let len2 = arg.length;
    let ptr = malloc(len2, 1) >>> 0;
    const mem = getUint8ArrayMemory0();
    let offset = 0;
    for (;offset < len2; offset++) {
      const code2 = arg.charCodeAt(offset);
      if (code2 > 127)
        break;
      mem[ptr + offset] = code2;
    }
    if (offset !== len2) {
      if (offset !== 0) {
        arg = arg.slice(offset);
      }
      ptr = realloc(ptr, len2, len2 = offset + arg.length * 3, 1) >>> 0;
      const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len2);
      const ret = cachedTextEncoder.encodeInto(arg, view);
      offset += ret.written;
      ptr = realloc(ptr, len2, offset, 1) >>> 0;
    }
    WASM_VECTOR_LEN = offset;
    return ptr;
  }
  var cachedDataViewMemory0 = null;
  function getDataViewMemory0() {
    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
      cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
    }
    return cachedDataViewMemory0;
  }
  function addToExternrefTable0(obj) {
    const idx = wasm.__externref_table_alloc();
    wasm.__wbindgen_export_4.set(idx, obj);
    return idx;
  }
  function isLikeNone(x) {
    return x === undefined || x === null;
  }
  function getArrayU8FromWasm0(ptr, len2) {
    ptr = ptr >>> 0;
    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len2);
  }
  var CLOSURE_DTORS = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((state) => {
    wasm.__wbindgen_export_5.get(state.dtor)(state.a, state.b);
  });
  function takeFromExternrefTable0(idx) {
    const value = wasm.__wbindgen_export_4.get(idx);
    wasm.__externref_table_dealloc(idx);
    return value;
  }
  function getArrayJsValueFromWasm0(ptr, len2) {
    ptr = ptr >>> 0;
    const mem = getDataViewMemory0();
    const result = [];
    for (let i2 = ptr;i2 < ptr + 4 * len2; i2 += 4) {
      result.push(wasm.__wbindgen_export_4.get(mem.getUint32(i2, true)));
    }
    wasm.__externref_drop_slice(ptr, len2);
    return result;
  }
  function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1, 1) >>> 0;
    getUint8ArrayMemory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
  }
  function readParquet(parquet_file, options) {
    const ptr0 = passArray8ToWasm0(parquet_file, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.readParquet(ptr0, len0, isLikeNone(options) ? 0 : addToExternrefTable0(options));
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return Table.__wrap(ret[0]);
  }
  function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
      throw new Error(`expected instance of ${klass.name}`);
    }
  }
  var cachedUint32ArrayMemory0 = null;
  function getUint32ArrayMemory0() {
    if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {
      cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);
    }
    return cachedUint32ArrayMemory0;
  }
  function getArrayU32FromWasm0(ptr, len2) {
    ptr = ptr >>> 0;
    return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len2);
  }
  var Compression = Object.freeze({
    UNCOMPRESSED: 0,
    "0": "UNCOMPRESSED",
    SNAPPY: 1,
    "1": "SNAPPY",
    GZIP: 2,
    "2": "GZIP",
    BROTLI: 3,
    "3": "BROTLI",
    LZ4: 4,
    "4": "LZ4",
    ZSTD: 5,
    "5": "ZSTD",
    LZ4_RAW: 6,
    "6": "LZ4_RAW",
    LZO: 7,
    "7": "LZO"
  });
  var EnabledStatistics = Object.freeze({
    None: 0,
    "0": "None",
    Chunk: 1,
    "1": "Chunk",
    Page: 2,
    "2": "Page"
  });
  var Encoding = Object.freeze({
    PLAIN: 0,
    "0": "PLAIN",
    PLAIN_DICTIONARY: 1,
    "1": "PLAIN_DICTIONARY",
    RLE: 2,
    "2": "RLE",
    BIT_PACKED: 3,
    "3": "BIT_PACKED",
    DELTA_BINARY_PACKED: 4,
    "4": "DELTA_BINARY_PACKED",
    DELTA_LENGTH_BYTE_ARRAY: 5,
    "5": "DELTA_LENGTH_BYTE_ARRAY",
    DELTA_BYTE_ARRAY: 6,
    "6": "DELTA_BYTE_ARRAY",
    RLE_DICTIONARY: 7,
    "7": "RLE_DICTIONARY",
    BYTE_STREAM_SPLIT: 8,
    "8": "BYTE_STREAM_SPLIT"
  });
  var WriterVersion = Object.freeze({
    V1: 0,
    "0": "V1",
    V2: 1,
    "1": "V2"
  });
  var __wbindgen_enum_ReadableStreamType = ["bytes"];
  var ColumnChunkMetaDataFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_columnchunkmetadata_free(ptr >>> 0, 1));

  class ColumnChunkMetaData {
    static __wrap(ptr) {
      ptr = ptr >>> 0;
      const obj = Object.create(ColumnChunkMetaData.prototype);
      obj.__wbg_ptr = ptr;
      ColumnChunkMetaDataFinalization.register(obj, obj.__wbg_ptr, obj);
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      ColumnChunkMetaDataFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_columnchunkmetadata_free(ptr, 0);
    }
    filePath() {
      const ret = wasm.columnchunkmetadata_filePath(this.__wbg_ptr);
      let v1;
      if (ret[0] !== 0) {
        v1 = getStringFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
      }
      return v1;
    }
    fileOffset() {
      const ret = wasm.columnchunkmetadata_fileOffset(this.__wbg_ptr);
      return ret;
    }
    columnPath() {
      const ret = wasm.columnchunkmetadata_columnPath(this.__wbg_ptr);
      var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
      return v1;
    }
    encodings() {
      const ret = wasm.columnchunkmetadata_encodings(this.__wbg_ptr);
      var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
      return v1;
    }
    numValues() {
      const ret = wasm.columnchunkmetadata_numValues(this.__wbg_ptr);
      return ret;
    }
    compression() {
      const ret = wasm.columnchunkmetadata_compression(this.__wbg_ptr);
      return ret;
    }
    compressedSize() {
      const ret = wasm.columnchunkmetadata_compressedSize(this.__wbg_ptr);
      return ret;
    }
    uncompressedSize() {
      const ret = wasm.columnchunkmetadata_uncompressedSize(this.__wbg_ptr);
      return ret;
    }
  }
  if (Symbol.dispose)
    ColumnChunkMetaData.prototype[Symbol.dispose] = ColumnChunkMetaData.prototype.free;
  var FFIDataFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_ffidata_free(ptr >>> 0, 1));

  class FFIData {
    static __wrap(ptr) {
      ptr = ptr >>> 0;
      const obj = Object.create(FFIData.prototype);
      obj.__wbg_ptr = ptr;
      FFIDataFinalization.register(obj, obj.__wbg_ptr, obj);
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      FFIDataFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_ffidata_free(ptr, 0);
    }
    arrayAddr() {
      const ret = wasm.ffidata_arrayAddr(this.__wbg_ptr);
      return ret >>> 0;
    }
    schemaAddr() {
      const ret = wasm.ffidata_schemaAddr(this.__wbg_ptr);
      return ret >>> 0;
    }
  }
  if (Symbol.dispose)
    FFIData.prototype[Symbol.dispose] = FFIData.prototype.free;
  var FFISchemaFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_ffischema_free(ptr >>> 0, 1));

  class FFISchema {
    static __wrap(ptr) {
      ptr = ptr >>> 0;
      const obj = Object.create(FFISchema.prototype);
      obj.__wbg_ptr = ptr;
      FFISchemaFinalization.register(obj, obj.__wbg_ptr, obj);
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      FFISchemaFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_ffischema_free(ptr, 0);
    }
    addr() {
      const ret = wasm.ffischema_addr(this.__wbg_ptr);
      return ret >>> 0;
    }
  }
  if (Symbol.dispose)
    FFISchema.prototype[Symbol.dispose] = FFISchema.prototype.free;
  var FFIStreamFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_ffistream_free(ptr >>> 0, 1));

  class FFIStream {
    static __wrap(ptr) {
      ptr = ptr >>> 0;
      const obj = Object.create(FFIStream.prototype);
      obj.__wbg_ptr = ptr;
      FFIStreamFinalization.register(obj, obj.__wbg_ptr, obj);
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      FFIStreamFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_ffistream_free(ptr, 0);
    }
    numArrays() {
      const ret = wasm.ffistream_numArrays(this.__wbg_ptr);
      return ret >>> 0;
    }
    schemaAddr() {
      const ret = wasm.ffistream_schemaAddr(this.__wbg_ptr);
      return ret >>> 0;
    }
    arrayAddr(chunk3) {
      const ret = wasm.ffistream_arrayAddr(this.__wbg_ptr, chunk3);
      return ret >>> 0;
    }
    arrayAddrs() {
      const ret = wasm.ffistream_arrayAddrs(this.__wbg_ptr);
      var v1 = getArrayU32FromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
      return v1;
    }
    drop() {
      const ptr = this.__destroy_into_raw();
      wasm.ffistream_drop(ptr);
    }
  }
  if (Symbol.dispose)
    FFIStream.prototype[Symbol.dispose] = FFIStream.prototype.free;
  var FileMetaDataFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_filemetadata_free(ptr >>> 0, 1));

  class FileMetaData {
    static __wrap(ptr) {
      ptr = ptr >>> 0;
      const obj = Object.create(FileMetaData.prototype);
      obj.__wbg_ptr = ptr;
      FileMetaDataFinalization.register(obj, obj.__wbg_ptr, obj);
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      FileMetaDataFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_filemetadata_free(ptr, 0);
    }
    version() {
      const ret = wasm.filemetadata_version(this.__wbg_ptr);
      return ret;
    }
    numRows() {
      const ret = wasm.filemetadata_numRows(this.__wbg_ptr);
      return ret;
    }
    createdBy() {
      const ret = wasm.filemetadata_createdBy(this.__wbg_ptr);
      let v1;
      if (ret[0] !== 0) {
        v1 = getStringFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
      }
      return v1;
    }
    keyValueMetadata() {
      const ret = wasm.filemetadata_keyValueMetadata(this.__wbg_ptr);
      if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
      }
      return takeFromExternrefTable0(ret[0]);
    }
  }
  if (Symbol.dispose)
    FileMetaData.prototype[Symbol.dispose] = FileMetaData.prototype.free;
  var IntoUnderlyingByteSourceFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_intounderlyingbytesource_free(ptr >>> 0, 1));

  class IntoUnderlyingByteSource {
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      IntoUnderlyingByteSourceFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_intounderlyingbytesource_free(ptr, 0);
    }
    get type() {
      const ret = wasm.intounderlyingbytesource_type(this.__wbg_ptr);
      return __wbindgen_enum_ReadableStreamType[ret];
    }
    get autoAllocateChunkSize() {
      const ret = wasm.intounderlyingbytesource_autoAllocateChunkSize(this.__wbg_ptr);
      return ret >>> 0;
    }
    start(controller) {
      wasm.intounderlyingbytesource_start(this.__wbg_ptr, controller);
    }
    pull(controller) {
      const ret = wasm.intounderlyingbytesource_pull(this.__wbg_ptr, controller);
      return ret;
    }
    cancel() {
      const ptr = this.__destroy_into_raw();
      wasm.intounderlyingbytesource_cancel(ptr);
    }
  }
  if (Symbol.dispose)
    IntoUnderlyingByteSource.prototype[Symbol.dispose] = IntoUnderlyingByteSource.prototype.free;
  var IntoUnderlyingSinkFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_intounderlyingsink_free(ptr >>> 0, 1));

  class IntoUnderlyingSink {
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      IntoUnderlyingSinkFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_intounderlyingsink_free(ptr, 0);
    }
    write(chunk3) {
      const ret = wasm.intounderlyingsink_write(this.__wbg_ptr, chunk3);
      return ret;
    }
    close() {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.intounderlyingsink_close(ptr);
      return ret;
    }
    abort(reason) {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.intounderlyingsink_abort(ptr, reason);
      return ret;
    }
  }
  if (Symbol.dispose)
    IntoUnderlyingSink.prototype[Symbol.dispose] = IntoUnderlyingSink.prototype.free;
  var IntoUnderlyingSourceFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_intounderlyingsource_free(ptr >>> 0, 1));

  class IntoUnderlyingSource {
    static __wrap(ptr) {
      ptr = ptr >>> 0;
      const obj = Object.create(IntoUnderlyingSource.prototype);
      obj.__wbg_ptr = ptr;
      IntoUnderlyingSourceFinalization.register(obj, obj.__wbg_ptr, obj);
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      IntoUnderlyingSourceFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_intounderlyingsource_free(ptr, 0);
    }
    pull(controller) {
      const ret = wasm.intounderlyingsource_pull(this.__wbg_ptr, controller);
      return ret;
    }
    cancel() {
      const ptr = this.__destroy_into_raw();
      wasm.intounderlyingsource_cancel(ptr);
    }
  }
  if (Symbol.dispose)
    IntoUnderlyingSource.prototype[Symbol.dispose] = IntoUnderlyingSource.prototype.free;
  var ParquetFileFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_parquetfile_free(ptr >>> 0, 1));

  class ParquetFile {
    static __wrap(ptr) {
      ptr = ptr >>> 0;
      const obj = Object.create(ParquetFile.prototype);
      obj.__wbg_ptr = ptr;
      ParquetFileFinalization.register(obj, obj.__wbg_ptr, obj);
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      ParquetFileFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_parquetfile_free(ptr, 0);
    }
    static fromUrl(url) {
      const ptr0 = passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      const ret = wasm.parquetfile_fromUrl(ptr0, len0);
      return ret;
    }
    static fromFile(handle) {
      const ret = wasm.parquetfile_fromFile(handle);
      return ret;
    }
    metadata() {
      const ret = wasm.parquetfile_metadata(this.__wbg_ptr);
      if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
      }
      return ParquetMetaData.__wrap(ret[0]);
    }
    schema() {
      const ret = wasm.parquetfile_schema(this.__wbg_ptr);
      if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
      }
      return Schema.__wrap(ret[0]);
    }
    read(options) {
      const ret = wasm.parquetfile_read(this.__wbg_ptr, isLikeNone(options) ? 0 : addToExternrefTable0(options));
      return ret;
    }
    stream(options) {
      const ret = wasm.parquetfile_stream(this.__wbg_ptr, isLikeNone(options) ? 0 : addToExternrefTable0(options));
      return ret;
    }
  }
  if (Symbol.dispose)
    ParquetFile.prototype[Symbol.dispose] = ParquetFile.prototype.free;
  var ParquetMetaDataFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_parquetmetadata_free(ptr >>> 0, 1));

  class ParquetMetaData {
    static __wrap(ptr) {
      ptr = ptr >>> 0;
      const obj = Object.create(ParquetMetaData.prototype);
      obj.__wbg_ptr = ptr;
      ParquetMetaDataFinalization.register(obj, obj.__wbg_ptr, obj);
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      ParquetMetaDataFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_parquetmetadata_free(ptr, 0);
    }
    fileMetadata() {
      const ret = wasm.parquetmetadata_fileMetadata(this.__wbg_ptr);
      return FileMetaData.__wrap(ret);
    }
    numRowGroups() {
      const ret = wasm.parquetmetadata_numRowGroups(this.__wbg_ptr);
      return ret >>> 0;
    }
    rowGroup(i2) {
      const ret = wasm.parquetmetadata_rowGroup(this.__wbg_ptr, i2);
      return RowGroupMetaData.__wrap(ret);
    }
    rowGroups() {
      const ret = wasm.parquetmetadata_rowGroups(this.__wbg_ptr);
      var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
      return v1;
    }
  }
  if (Symbol.dispose)
    ParquetMetaData.prototype[Symbol.dispose] = ParquetMetaData.prototype.free;
  var RecordBatchFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_recordbatch_free(ptr >>> 0, 1));

  class RecordBatch {
    static __wrap(ptr) {
      ptr = ptr >>> 0;
      const obj = Object.create(RecordBatch.prototype);
      obj.__wbg_ptr = ptr;
      RecordBatchFinalization.register(obj, obj.__wbg_ptr, obj);
      return obj;
    }
    static __unwrap(jsValue) {
      if (!(jsValue instanceof RecordBatch)) {
        return 0;
      }
      return jsValue.__destroy_into_raw();
    }
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      RecordBatchFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_recordbatch_free(ptr, 0);
    }
    get numRows() {
      const ret = wasm.recordbatch_numRows(this.__wbg_ptr);
      return ret >>> 0;
    }
    get numColumns() {
      const ret = wasm.recordbatch_numColumns(this.__wbg_ptr);
      return ret >>> 0;
    }
    get schema() {
      const ret = wasm.recordbatch_schema(this.__wbg_ptr);
      return Schema.__wrap(ret);
    }
    toFFI() {
      const ret = wasm.recordbatch_toFFI(this.__wbg_ptr);
      if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
      }
      return FFIData.__wrap(ret[0]);
    }
    intoFFI() {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.recordbatch_intoFFI(ptr);
      if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
      }
      return FFIData.__wrap(ret[0]);
    }
    intoIPCStream() {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.recordbatch_intoIPCStream(ptr);
      if (ret[3]) {
        throw takeFromExternrefTable0(ret[2]);
      }
      var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
      return v1;
    }
    withSchema(schema) {
      _assertClass(schema, Schema);
      var ptr0 = schema.__destroy_into_raw();
      const ret = wasm.recordbatch_withSchema(this.__wbg_ptr, ptr0);
      if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
      }
      return RecordBatch.__wrap(ret[0]);
    }
    slice(offset, length3) {
      const ret = wasm.recordbatch_slice(this.__wbg_ptr, offset, length3);
      return RecordBatch.__wrap(ret);
    }
    getArrayMemorySize() {
      const ret = wasm.recordbatch_getArrayMemorySize(this.__wbg_ptr);
      return ret >>> 0;
    }
  }
  if (Symbol.dispose)
    RecordBatch.prototype[Symbol.dispose] = RecordBatch.prototype.free;
  var RowGroupMetaDataFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_rowgroupmetadata_free(ptr >>> 0, 1));

  class RowGroupMetaData {
    static __wrap(ptr) {
      ptr = ptr >>> 0;
      const obj = Object.create(RowGroupMetaData.prototype);
      obj.__wbg_ptr = ptr;
      RowGroupMetaDataFinalization.register(obj, obj.__wbg_ptr, obj);
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      RowGroupMetaDataFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_rowgroupmetadata_free(ptr, 0);
    }
    numColumns() {
      const ret = wasm.rowgroupmetadata_numColumns(this.__wbg_ptr);
      return ret >>> 0;
    }
    column(i2) {
      const ret = wasm.rowgroupmetadata_column(this.__wbg_ptr, i2);
      return ColumnChunkMetaData.__wrap(ret);
    }
    columns() {
      const ret = wasm.rowgroupmetadata_columns(this.__wbg_ptr);
      var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
      return v1;
    }
    numRows() {
      const ret = wasm.rowgroupmetadata_numRows(this.__wbg_ptr);
      return ret;
    }
    totalByteSize() {
      const ret = wasm.rowgroupmetadata_totalByteSize(this.__wbg_ptr);
      return ret;
    }
    compressedSize() {
      const ret = wasm.rowgroupmetadata_compressedSize(this.__wbg_ptr);
      return ret;
    }
  }
  if (Symbol.dispose)
    RowGroupMetaData.prototype[Symbol.dispose] = RowGroupMetaData.prototype.free;
  var SchemaFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_schema_free(ptr >>> 0, 1));

  class Schema {
    static __wrap(ptr) {
      ptr = ptr >>> 0;
      const obj = Object.create(Schema.prototype);
      obj.__wbg_ptr = ptr;
      SchemaFinalization.register(obj, obj.__wbg_ptr, obj);
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      SchemaFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_schema_free(ptr, 0);
    }
    toFFI() {
      const ret = wasm.schema_toFFI(this.__wbg_ptr);
      if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
      }
      return FFISchema.__wrap(ret[0]);
    }
    intoFFI() {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.schema_intoFFI(ptr);
      if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
      }
      return FFISchema.__wrap(ret[0]);
    }
    intoIPCStream() {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.schema_intoIPCStream(ptr);
      if (ret[3]) {
        throw takeFromExternrefTable0(ret[2]);
      }
      var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
      return v1;
    }
    withMetadata(metadata) {
      const ret = wasm.schema_withMetadata(this.__wbg_ptr, metadata);
      if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
      }
      return Schema.__wrap(ret[0]);
    }
    indexOf(name) {
      const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      const ret = wasm.schema_indexOf(this.__wbg_ptr, ptr0, len0);
      if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
      }
      return ret[0] >>> 0;
    }
    metadata() {
      const ret = wasm.schema_metadata(this.__wbg_ptr);
      if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
      }
      return takeFromExternrefTable0(ret[0]);
    }
  }
  if (Symbol.dispose)
    Schema.prototype[Symbol.dispose] = Schema.prototype.free;
  var TableFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_table_free(ptr >>> 0, 1));

  class Table {
    static __wrap(ptr) {
      ptr = ptr >>> 0;
      const obj = Object.create(Table.prototype);
      obj.__wbg_ptr = ptr;
      TableFinalization.register(obj, obj.__wbg_ptr, obj);
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      TableFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_table_free(ptr, 0);
    }
    get schema() {
      const ret = wasm.table_schema(this.__wbg_ptr);
      return Schema.__wrap(ret);
    }
    recordBatch(index) {
      const ret = wasm.table_recordBatch(this.__wbg_ptr, index);
      return ret === 0 ? undefined : RecordBatch.__wrap(ret);
    }
    recordBatches() {
      const ret = wasm.table_recordBatches(this.__wbg_ptr);
      var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
      return v1;
    }
    get numBatches() {
      const ret = wasm.table_numBatches(this.__wbg_ptr);
      return ret >>> 0;
    }
    toFFI() {
      const ret = wasm.table_toFFI(this.__wbg_ptr);
      if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
      }
      return FFIStream.__wrap(ret[0]);
    }
    intoFFI() {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.table_intoFFI(ptr);
      if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
      }
      return FFIStream.__wrap(ret[0]);
    }
    intoIPCStream() {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.table_intoIPCStream(ptr);
      if (ret[3]) {
        throw takeFromExternrefTable0(ret[2]);
      }
      var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
      return v1;
    }
    static fromIPCStream(buf) {
      const ptr0 = passArray8ToWasm0(buf, wasm.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN;
      const ret = wasm.table_fromIPCStream(ptr0, len0);
      if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
      }
      return Table.__wrap(ret[0]);
    }
    getArrayMemorySize() {
      const ret = wasm.table_getArrayMemorySize(this.__wbg_ptr);
      return ret >>> 0;
    }
  }
  if (Symbol.dispose)
    Table.prototype[Symbol.dispose] = Table.prototype.free;
  var WriterPropertiesFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_writerproperties_free(ptr >>> 0, 1));

  class WriterProperties {
    static __wrap(ptr) {
      ptr = ptr >>> 0;
      const obj = Object.create(WriterProperties.prototype);
      obj.__wbg_ptr = ptr;
      WriterPropertiesFinalization.register(obj, obj.__wbg_ptr, obj);
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      WriterPropertiesFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_writerproperties_free(ptr, 0);
    }
  }
  if (Symbol.dispose)
    WriterProperties.prototype[Symbol.dispose] = WriterProperties.prototype.free;
  var WriterPropertiesBuilderFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_writerpropertiesbuilder_free(ptr >>> 0, 1));

  class WriterPropertiesBuilder {
    static __wrap(ptr) {
      ptr = ptr >>> 0;
      const obj = Object.create(WriterPropertiesBuilder.prototype);
      obj.__wbg_ptr = ptr;
      WriterPropertiesBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
      return obj;
    }
    __destroy_into_raw() {
      const ptr = this.__wbg_ptr;
      this.__wbg_ptr = 0;
      WriterPropertiesBuilderFinalization.unregister(this);
      return ptr;
    }
    free() {
      const ptr = this.__destroy_into_raw();
      wasm.__wbg_writerpropertiesbuilder_free(ptr, 0);
    }
    constructor() {
      const ret = wasm.writerpropertiesbuilder_new();
      this.__wbg_ptr = ret >>> 0;
      WriterPropertiesBuilderFinalization.register(this, this.__wbg_ptr, this);
      return this;
    }
    build() {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.writerpropertiesbuilder_build(ptr);
      return WriterProperties.__wrap(ret);
    }
    setWriterVersion(value) {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.writerpropertiesbuilder_setWriterVersion(ptr, value);
      return WriterPropertiesBuilder.__wrap(ret);
    }
    setDataPageSizeLimit(value) {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.writerpropertiesbuilder_setDataPageSizeLimit(ptr, value);
      return WriterPropertiesBuilder.__wrap(ret);
    }
    setDictionaryPageSizeLimit(value) {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.writerpropertiesbuilder_setDictionaryPageSizeLimit(ptr, value);
      return WriterPropertiesBuilder.__wrap(ret);
    }
    setWriteBatchSize(value) {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.writerpropertiesbuilder_setWriteBatchSize(ptr, value);
      return WriterPropertiesBuilder.__wrap(ret);
    }
    setMaxRowGroupSize(value) {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.writerpropertiesbuilder_setMaxRowGroupSize(ptr, value);
      return WriterPropertiesBuilder.__wrap(ret);
    }
    setCreatedBy(value) {
      const ptr = this.__destroy_into_raw();
      const ptr0 = passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      const ret = wasm.writerpropertiesbuilder_setCreatedBy(ptr, ptr0, len0);
      return WriterPropertiesBuilder.__wrap(ret);
    }
    setKeyValueMetadata(value) {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.writerpropertiesbuilder_setKeyValueMetadata(ptr, value);
      if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
      }
      return WriterPropertiesBuilder.__wrap(ret[0]);
    }
    setEncoding(value) {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.writerpropertiesbuilder_setEncoding(ptr, value);
      return WriterPropertiesBuilder.__wrap(ret);
    }
    setCompression(value) {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.writerpropertiesbuilder_setCompression(ptr, value);
      return WriterPropertiesBuilder.__wrap(ret);
    }
    setDictionaryEnabled(value) {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.writerpropertiesbuilder_setDictionaryEnabled(ptr, value);
      return WriterPropertiesBuilder.__wrap(ret);
    }
    setStatisticsEnabled(value) {
      const ptr = this.__destroy_into_raw();
      const ret = wasm.writerpropertiesbuilder_setStatisticsEnabled(ptr, value);
      return WriterPropertiesBuilder.__wrap(ret);
    }
    setColumnEncoding(col, value) {
      const ptr = this.__destroy_into_raw();
      const ptr0 = passStringToWasm0(col, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      const ret = wasm.writerpropertiesbuilder_setColumnEncoding(ptr, ptr0, len0, value);
      return WriterPropertiesBuilder.__wrap(ret);
    }
    setColumnCompression(col, value) {
      const ptr = this.__destroy_into_raw();
      const ptr0 = passStringToWasm0(col, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      const ret = wasm.writerpropertiesbuilder_setColumnCompression(ptr, ptr0, len0, value);
      return WriterPropertiesBuilder.__wrap(ret);
    }
    setColumnDictionaryEnabled(col, value) {
      const ptr = this.__destroy_into_raw();
      const ptr0 = passStringToWasm0(col, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      const ret = wasm.writerpropertiesbuilder_setColumnDictionaryEnabled(ptr, ptr0, len0, value);
      return WriterPropertiesBuilder.__wrap(ret);
    }
    setColumnStatisticsEnabled(col, value) {
      const ptr = this.__destroy_into_raw();
      const ptr0 = passStringToWasm0(col, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      const ret = wasm.writerpropertiesbuilder_setColumnStatisticsEnabled(ptr, ptr0, len0, value);
      return WriterPropertiesBuilder.__wrap(ret);
    }
  }
  if (Symbol.dispose)
    WriterPropertiesBuilder.prototype[Symbol.dispose] = WriterPropertiesBuilder.prototype.free;
  var EXPECTED_RESPONSE_TYPES = new Set(["basic", "cors", "default"]);

  // node_modules/tslib/tslib.es6.mjs
  function __rest(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p = Object.getOwnPropertySymbols(s);i2 < p.length; i2++) {
        if (e.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i2]))
          t[p[i2]] = s[p[i2]];
      }
    return t;
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve5) {
        resolve5(value);
      });
    }
    return new (P || (P = Promise))(function(resolve5, reject) {
      function fulfilled(value) {
        try {
          step4(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step4(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step4(result) {
        result.done ? resolve5(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step4((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i2, q = [];
    return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function awaitReturn(f) {
      return function(v) {
        return Promise.resolve(v).then(f, reject);
      };
    }
    function verb(n, f) {
      if (g[n]) {
        i2[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume2(n, v);
          });
        };
        if (f)
          i2[n] = f(i2[n]);
      }
    }
    function resume2(n, v) {
      try {
        step4(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step4(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume2("next", value);
    }
    function reject(value) {
      resume2("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume2(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator(o) {
    var i2, p;
    return i2 = {}, verb("next"), verb("throw", function(e) {
      throw e;
    }), verb("return"), i2[Symbol.iterator] = function() {
      return this;
    }, i2;
    function verb(n, f) {
      i2[n] = o[n] ? function(v) {
        return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
      } : f;
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i2;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n) {
      i2[n] = o[n] && function(v) {
        return new Promise(function(resolve5, reject) {
          v = o[n](v), settle(resolve5, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve5, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve5({ value: v2, done: d });
      }, reject);
    }
  }

  // node_modules/apache-arrow/util/buffer.mjs
  var exports_buffer2 = {};
  __export(exports_buffer2, {
    toUint8ClampedArrayIterator: () => toUint8ClampedArrayIterator,
    toUint8ClampedArrayAsyncIterator: () => toUint8ClampedArrayAsyncIterator,
    toUint8ClampedArray: () => toUint8ClampedArray,
    toUint8ArrayIterator: () => toUint8ArrayIterator,
    toUint8ArrayAsyncIterator: () => toUint8ArrayAsyncIterator,
    toUint8Array: () => toUint8Array,
    toUint32ArrayIterator: () => toUint32ArrayIterator,
    toUint32ArrayAsyncIterator: () => toUint32ArrayAsyncIterator,
    toUint32Array: () => toUint32Array,
    toUint16ArrayIterator: () => toUint16ArrayIterator,
    toUint16ArrayAsyncIterator: () => toUint16ArrayAsyncIterator,
    toUint16Array: () => toUint16Array,
    toInt8ArrayIterator: () => toInt8ArrayIterator,
    toInt8ArrayAsyncIterator: () => toInt8ArrayAsyncIterator,
    toInt8Array: () => toInt8Array,
    toInt32ArrayIterator: () => toInt32ArrayIterator,
    toInt32ArrayAsyncIterator: () => toInt32ArrayAsyncIterator,
    toInt32Array: () => toInt32Array,
    toInt16ArrayIterator: () => toInt16ArrayIterator,
    toInt16ArrayAsyncIterator: () => toInt16ArrayAsyncIterator,
    toInt16Array: () => toInt16Array,
    toFloat64ArrayIterator: () => toFloat64ArrayIterator,
    toFloat64ArrayAsyncIterator: () => toFloat64ArrayAsyncIterator,
    toFloat64Array: () => toFloat64Array,
    toFloat32ArrayIterator: () => toFloat32ArrayIterator,
    toFloat32ArrayAsyncIterator: () => toFloat32ArrayAsyncIterator,
    toFloat32Array: () => toFloat32Array,
    toBigUint64Array: () => toBigUint64Array,
    toBigInt64Array: () => toBigInt64Array,
    toArrayBufferViewIterator: () => toArrayBufferViewIterator,
    toArrayBufferViewAsyncIterator: () => toArrayBufferViewAsyncIterator,
    toArrayBufferView: () => toArrayBufferView,
    rebaseValueOffsets: () => rebaseValueOffsets,
    memcpy: () => memcpy,
    joinUint8Arrays: () => joinUint8Arrays,
    compareArrayLike: () => compareArrayLike
  });

  // node_modules/apache-arrow/util/utf8.mjs
  var decoder = new TextDecoder("utf-8");
  var decodeUtf8 = decoder.decode.bind(decoder);
  var encoder = new TextEncoder;
  var encodeUtf8 = (value) => encoder.encode(value);

  // node_modules/apache-arrow/util/compat.mjs
  var isNumber3 = (x) => typeof x === "number";
  var isBoolean3 = (x) => typeof x === "boolean";
  var isFunction4 = (x) => typeof x === "function";
  var isObject3 = (x) => x != null && Object(x) === x;
  var isPromise = (x) => {
    return isObject3(x) && isFunction4(x.then);
  };
  var isIterable2 = (x) => {
    return isObject3(x) && isFunction4(x[Symbol.iterator]);
  };
  var isAsyncIterable = (x) => {
    return isObject3(x) && isFunction4(x[Symbol.asyncIterator]);
  };
  var isArrowJSON = (x) => {
    return isObject3(x) && isObject3(x["schema"]);
  };
  var isIteratorResult = (x) => {
    return isObject3(x) && "done" in x && "value" in x;
  };
  var isFileHandle = (x) => {
    return isObject3(x) && isFunction4(x["stat"]) && isNumber3(x["fd"]);
  };
  var isFetchResponse = (x) => {
    return isObject3(x) && isReadableDOMStream(x["body"]);
  };
  var isReadableInterop = (x) => ("_getDOMStream" in x) && ("_getNodeStream" in x);
  var isWritableDOMStream = (x) => {
    return isObject3(x) && isFunction4(x["abort"]) && isFunction4(x["getWriter"]) && !isReadableInterop(x);
  };
  var isReadableDOMStream = (x) => {
    return isObject3(x) && isFunction4(x["cancel"]) && isFunction4(x["getReader"]) && !isReadableInterop(x);
  };
  var isWritableNodeStream = (x) => {
    return isObject3(x) && isFunction4(x["end"]) && isFunction4(x["write"]) && isBoolean3(x["writable"]) && !isReadableInterop(x);
  };
  var isReadableNodeStream = (x) => {
    return isObject3(x) && isFunction4(x["read"]) && isFunction4(x["pipe"]) && isBoolean3(x["readable"]) && !isReadableInterop(x);
  };
  var isFlatbuffersByteBuffer = (x) => {
    return isObject3(x) && isFunction4(x["clear"]) && isFunction4(x["bytes"]) && isFunction4(x["position"]) && isFunction4(x["setPosition"]) && isFunction4(x["capacity"]) && isFunction4(x["getBufferIdentifier"]) && isFunction4(x["createLong"]);
  };

  // node_modules/apache-arrow/util/buffer.mjs
  var SharedArrayBuf = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : ArrayBuffer;
  function collapseContiguousByteRanges(chunks3) {
    const result = chunks3[0] ? [chunks3[0]] : [];
    let xOffset, yOffset, xLen, yLen;
    for (let x, y, i2 = 0, j = 0, n = chunks3.length;++i2 < n; ) {
      x = result[j];
      y = chunks3[i2];
      if (!x || !y || x.buffer !== y.buffer || y.byteOffset < x.byteOffset) {
        y && (result[++j] = y);
        continue;
      }
      ({ byteOffset: xOffset, byteLength: xLen } = x);
      ({ byteOffset: yOffset, byteLength: yLen } = y);
      if (xOffset + xLen < yOffset || yOffset + yLen < xOffset) {
        y && (result[++j] = y);
        continue;
      }
      result[j] = new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen);
    }
    return result;
  }
  function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
    const targetByteLength = target.byteLength;
    const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
    const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
    dst.set(src, targetByteOffset);
    return target;
  }
  function joinUint8Arrays(chunks3, size13) {
    const result = collapseContiguousByteRanges(chunks3);
    const byteLength2 = result.reduce((x, b) => x + b.byteLength, 0);
    let source, sliced, buffer4;
    let offset = 0, index = -1;
    const length3 = Math.min(size13 || Number.POSITIVE_INFINITY, byteLength2);
    for (const n = result.length;++index < n; ) {
      source = result[index];
      sliced = source.subarray(0, Math.min(source.length, length3 - offset));
      if (length3 <= offset + sliced.length) {
        if (sliced.length < source.length) {
          result[index] = source.subarray(sliced.length);
        } else if (sliced.length === source.length) {
          index++;
        }
        buffer4 ? memcpy(buffer4, sliced, offset) : buffer4 = sliced;
        break;
      }
      memcpy(buffer4 || (buffer4 = new Uint8Array(length3)), sliced, offset);
      offset += sliced.length;
    }
    return [buffer4 || new Uint8Array(0), result.slice(index), byteLength2 - (buffer4 ? buffer4.byteLength : 0)];
  }
  function toArrayBufferView(ArrayBufferViewCtor, input) {
    let value = isIteratorResult(input) ? input.value : input;
    if (value instanceof ArrayBufferViewCtor) {
      if (ArrayBufferViewCtor === Uint8Array) {
        return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);
      }
      return value;
    }
    if (!value) {
      return new ArrayBufferViewCtor(0);
    }
    if (typeof value === "string") {
      value = encodeUtf8(value);
    }
    if (value instanceof ArrayBuffer) {
      return new ArrayBufferViewCtor(value);
    }
    if (value instanceof SharedArrayBuf) {
      return new ArrayBufferViewCtor(value);
    }
    if (isFlatbuffersByteBuffer(value)) {
      return toArrayBufferView(ArrayBufferViewCtor, value.bytes());
    }
    return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0) : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);
  }
  var toInt8Array = (input) => toArrayBufferView(Int8Array, input);
  var toInt16Array = (input) => toArrayBufferView(Int16Array, input);
  var toInt32Array = (input) => toArrayBufferView(Int32Array, input);
  var toBigInt64Array = (input) => toArrayBufferView(BigInt64Array, input);
  var toUint8Array = (input) => toArrayBufferView(Uint8Array, input);
  var toUint16Array = (input) => toArrayBufferView(Uint16Array, input);
  var toUint32Array = (input) => toArrayBufferView(Uint32Array, input);
  var toBigUint64Array = (input) => toArrayBufferView(BigUint64Array, input);
  var toFloat32Array = (input) => toArrayBufferView(Float32Array, input);
  var toFloat64Array = (input) => toArrayBufferView(Float64Array, input);
  var toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);
  var pump = (iterator) => {
    iterator.next();
    return iterator;
  };
  function* toArrayBufferViewIterator(ArrayCtor, source) {
    const wrap = function* (x) {
      yield x;
    };
    const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : !isIterable2(source) ? wrap(source) : source;
    yield* pump(function* (it) {
      let r = null;
      do {
        r = it.next(yield toArrayBufferView(ArrayCtor, r));
      } while (!r.done);
    }(buffers[Symbol.iterator]()));
    return new ArrayCtor;
  }
  var toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);
  var toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);
  var toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);
  var toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);
  var toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);
  var toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);
  var toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);
  var toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);
  var toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);
  function toArrayBufferViewAsyncIterator(ArrayCtor, source) {
    return __asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {
      if (isPromise(source)) {
        return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield __await(source))))));
      }
      const wrap = function(x) {
        return __asyncGenerator(this, arguments, function* () {
          yield yield __await(yield __await(x));
        });
      };
      const emit3 = function(source2) {
        return __asyncGenerator(this, arguments, function* () {
          yield __await(yield* __asyncDelegator(__asyncValues(pump(function* (it) {
            let r = null;
            do {
              r = it.next(yield r === null || r === undefined ? undefined : r.value);
            } while (!r.done);
          }(source2[Symbol.iterator]())))));
        });
      };
      const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : isIterable2(source) ? emit3(source) : !isAsyncIterable(source) ? wrap(source) : source;
      yield __await(yield* __asyncDelegator(__asyncValues(pump(function(it) {
        return __asyncGenerator(this, arguments, function* () {
          let r = null;
          do {
            r = yield __await(it.next(yield yield __await(toArrayBufferView(ArrayCtor, r))));
          } while (!r.done);
        });
      }(buffers[Symbol.asyncIterator]())))));
      return yield __await(new ArrayCtor);
    });
  }
  var toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);
  var toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);
  var toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);
  var toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);
  var toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);
  var toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);
  var toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);
  var toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);
  var toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);
  function rebaseValueOffsets(offset, length3, valueOffsets) {
    if (offset !== 0) {
      valueOffsets = valueOffsets.slice(0, length3);
      for (let i2 = -1, n = valueOffsets.length;++i2 < n; ) {
        valueOffsets[i2] += offset;
      }
    }
    return valueOffsets.subarray(0, length3);
  }
  function compareArrayLike(a, b) {
    let i2 = 0;
    const n = a.length;
    if (n !== b.length) {
      return false;
    }
    if (n > 0) {
      do {
        if (a[i2] !== b[i2]) {
          return false;
        }
      } while (++i2 < n);
    }
    return true;
  }

  // node_modules/apache-arrow/io/adapters.mjs
  var adapters_default = {
    fromIterable(source) {
      return pump2(fromIterable11(source));
    },
    fromAsyncIterable(source) {
      return pump2(fromAsyncIterable3(source));
    },
    fromDOMStream(source) {
      return pump2(fromDOMStream(source));
    },
    fromNodeStream(stream3) {
      return pump2(fromNodeStream(stream3));
    },
    toDOMStream(source, options) {
      throw new Error(`"toDOMStream" not available in this environment`);
    },
    toNodeStream(source, options) {
      throw new Error(`"toNodeStream" not available in this environment`);
    }
  };
  var pump2 = (iterator) => {
    iterator.next();
    return iterator;
  };
  function* fromIterable11(source) {
    let done11, threw = false;
    let buffers = [], buffer4;
    let cmd, size13, bufferLength = 0;
    function byteRange() {
      if (cmd === "peek") {
        return joinUint8Arrays(buffers, size13)[0];
      }
      [buffer4, buffers, bufferLength] = joinUint8Arrays(buffers, size13);
      return buffer4;
    }
    ({ cmd, size: size13 } = (yield (() => null)()) || { cmd: "read", size: 0 });
    const it = toUint8ArrayIterator(source)[Symbol.iterator]();
    try {
      do {
        ({ done: done11, value: buffer4 } = Number.isNaN(size13 - bufferLength) ? it.next() : it.next(size13 - bufferLength));
        if (!done11 && buffer4.byteLength > 0) {
          buffers.push(buffer4);
          bufferLength += buffer4.byteLength;
        }
        if (done11 || size13 <= bufferLength) {
          do {
            ({ cmd, size: size13 } = yield byteRange());
          } while (size13 < bufferLength);
        }
      } while (!done11);
    } catch (e) {
      threw = true;
      typeof it.throw === "function" && it.throw(e);
    } finally {
      threw === false && typeof it.return === "function" && it.return(null);
    }
    return null;
  }
  function fromAsyncIterable3(source) {
    return __asyncGenerator(this, arguments, function* fromAsyncIterable_1() {
      let done11, threw = false;
      let buffers = [], buffer4;
      let cmd, size13, bufferLength = 0;
      function byteRange() {
        if (cmd === "peek") {
          return joinUint8Arrays(buffers, size13)[0];
        }
        [buffer4, buffers, bufferLength] = joinUint8Arrays(buffers, size13);
        return buffer4;
      }
      ({ cmd, size: size13 } = (yield yield __await((() => null)())) || { cmd: "read", size: 0 });
      const it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();
      try {
        do {
          ({ done: done11, value: buffer4 } = Number.isNaN(size13 - bufferLength) ? yield __await(it.next()) : yield __await(it.next(size13 - bufferLength)));
          if (!done11 && buffer4.byteLength > 0) {
            buffers.push(buffer4);
            bufferLength += buffer4.byteLength;
          }
          if (done11 || size13 <= bufferLength) {
            do {
              ({ cmd, size: size13 } = yield yield __await(byteRange()));
            } while (size13 < bufferLength);
          }
        } while (!done11);
      } catch (e) {
        threw = true;
        typeof it.throw === "function" && (yield __await(it.throw(e)));
      } finally {
        threw === false && typeof it.return === "function" && (yield __await(it.return(new Uint8Array(0))));
      }
      return yield __await(null);
    });
  }
  function fromDOMStream(source) {
    return __asyncGenerator(this, arguments, function* fromDOMStream_1() {
      let done11 = false, threw = false;
      let buffers = [], buffer4;
      let cmd, size13, bufferLength = 0;
      function byteRange() {
        if (cmd === "peek") {
          return joinUint8Arrays(buffers, size13)[0];
        }
        [buffer4, buffers, bufferLength] = joinUint8Arrays(buffers, size13);
        return buffer4;
      }
      ({ cmd, size: size13 } = (yield yield __await((() => null)())) || { cmd: "read", size: 0 });
      const it = new AdaptiveByteReader(source);
      try {
        do {
          ({ done: done11, value: buffer4 } = Number.isNaN(size13 - bufferLength) ? yield __await(it["read"]()) : yield __await(it["read"](size13 - bufferLength)));
          if (!done11 && buffer4.byteLength > 0) {
            buffers.push(toUint8Array(buffer4));
            bufferLength += buffer4.byteLength;
          }
          if (done11 || size13 <= bufferLength) {
            do {
              ({ cmd, size: size13 } = yield yield __await(byteRange()));
            } while (size13 < bufferLength);
          }
        } while (!done11);
      } catch (e) {
        threw = true;
        yield __await(it["cancel"](e));
      } finally {
        threw === false ? yield __await(it["cancel"]()) : source["locked"] && it.releaseLock();
      }
      return yield __await(null);
    });
  }

  class AdaptiveByteReader {
    constructor(source) {
      this.source = source;
      this.reader = null;
      this.reader = this.source["getReader"]();
      this.reader["closed"].catch(() => {});
    }
    get closed() {
      return this.reader ? this.reader["closed"].catch(() => {}) : Promise.resolve();
    }
    releaseLock() {
      if (this.reader) {
        this.reader.releaseLock();
      }
      this.reader = null;
    }
    cancel(reason) {
      return __awaiter(this, undefined, undefined, function* () {
        const { reader, source } = this;
        reader && (yield reader["cancel"](reason).catch(() => {}));
        source && (source["locked"] && this.releaseLock());
      });
    }
    read(size13) {
      return __awaiter(this, undefined, undefined, function* () {
        if (size13 === 0) {
          return { done: this.reader == null, value: new Uint8Array(0) };
        }
        const result = yield this.reader.read();
        !result.done && (result.value = toUint8Array(result));
        return result;
      });
    }
  }
  var onEvent = (stream3, event) => {
    const handler = (_) => resolve5([event, _]);
    let resolve5;
    return [event, handler, new Promise((r) => (resolve5 = r) && stream3["once"](event, handler))];
  };
  function fromNodeStream(stream3) {
    return __asyncGenerator(this, arguments, function* fromNodeStream_1() {
      const events = [];
      let event = "error";
      let done11 = false, err = null;
      let cmd, size13, bufferLength = 0;
      let buffers = [], buffer4;
      function byteRange() {
        if (cmd === "peek") {
          return joinUint8Arrays(buffers, size13)[0];
        }
        [buffer4, buffers, bufferLength] = joinUint8Arrays(buffers, size13);
        return buffer4;
      }
      ({ cmd, size: size13 } = (yield yield __await((() => null)())) || { cmd: "read", size: 0 });
      if (stream3["isTTY"]) {
        yield yield __await(new Uint8Array(0));
        return yield __await(null);
      }
      try {
        events[0] = onEvent(stream3, "end");
        events[1] = onEvent(stream3, "error");
        do {
          events[2] = onEvent(stream3, "readable");
          [event, err] = yield __await(Promise.race(events.map((x) => x[2])));
          if (event === "error") {
            break;
          }
          if (!(done11 = event === "end")) {
            if (!Number.isFinite(size13 - bufferLength)) {
              buffer4 = toUint8Array(stream3["read"]());
            } else {
              buffer4 = toUint8Array(stream3["read"](size13 - bufferLength));
              if (buffer4.byteLength < size13 - bufferLength) {
                buffer4 = toUint8Array(stream3["read"]());
              }
            }
            if (buffer4.byteLength > 0) {
              buffers.push(buffer4);
              bufferLength += buffer4.byteLength;
            }
          }
          if (done11 || size13 <= bufferLength) {
            do {
              ({ cmd, size: size13 } = yield yield __await(byteRange()));
            } while (size13 < bufferLength);
          }
        } while (!done11);
      } finally {
        yield __await(cleanup(events, event === "error" ? err : null));
      }
      return yield __await(null);
      function cleanup(events2, err2) {
        buffer4 = buffers = null;
        return new Promise((resolve5, reject) => {
          for (const [evt, fn2] of events2) {
            stream3["off"](evt, fn2);
          }
          try {
            const destroy = stream3["destroy"];
            destroy && destroy.call(stream3, err2);
            err2 = undefined;
          } catch (e) {
            err2 = e || err2;
          } finally {
            err2 != null ? reject(err2) : resolve5();
          }
        });
      }
    });
  }

  // node_modules/apache-arrow/fb/metadata-version.mjs
  var MetadataVersion;
  (function(MetadataVersion2) {
    MetadataVersion2[MetadataVersion2["V1"] = 0] = "V1";
    MetadataVersion2[MetadataVersion2["V2"] = 1] = "V2";
    MetadataVersion2[MetadataVersion2["V3"] = 2] = "V3";
    MetadataVersion2[MetadataVersion2["V4"] = 3] = "V4";
    MetadataVersion2[MetadataVersion2["V5"] = 4] = "V5";
  })(MetadataVersion || (MetadataVersion = {}));
  // node_modules/apache-arrow/fb/union-mode.mjs
  var UnionMode;
  (function(UnionMode2) {
    UnionMode2[UnionMode2["Sparse"] = 0] = "Sparse";
    UnionMode2[UnionMode2["Dense"] = 1] = "Dense";
  })(UnionMode || (UnionMode = {}));
  // node_modules/apache-arrow/fb/precision.mjs
  var Precision;
  (function(Precision2) {
    Precision2[Precision2["HALF"] = 0] = "HALF";
    Precision2[Precision2["SINGLE"] = 1] = "SINGLE";
    Precision2[Precision2["DOUBLE"] = 2] = "DOUBLE";
  })(Precision || (Precision = {}));
  // node_modules/apache-arrow/fb/date-unit.mjs
  var DateUnit;
  (function(DateUnit2) {
    DateUnit2[DateUnit2["DAY"] = 0] = "DAY";
    DateUnit2[DateUnit2["MILLISECOND"] = 1] = "MILLISECOND";
  })(DateUnit || (DateUnit = {}));
  // node_modules/apache-arrow/fb/time-unit.mjs
  var TimeUnit;
  (function(TimeUnit2) {
    TimeUnit2[TimeUnit2["SECOND"] = 0] = "SECOND";
    TimeUnit2[TimeUnit2["MILLISECOND"] = 1] = "MILLISECOND";
    TimeUnit2[TimeUnit2["MICROSECOND"] = 2] = "MICROSECOND";
    TimeUnit2[TimeUnit2["NANOSECOND"] = 3] = "NANOSECOND";
  })(TimeUnit || (TimeUnit = {}));
  // node_modules/apache-arrow/fb/interval-unit.mjs
  var IntervalUnit;
  (function(IntervalUnit2) {
    IntervalUnit2[IntervalUnit2["YEAR_MONTH"] = 0] = "YEAR_MONTH";
    IntervalUnit2[IntervalUnit2["DAY_TIME"] = 1] = "DAY_TIME";
    IntervalUnit2[IntervalUnit2["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
  })(IntervalUnit || (IntervalUnit = {}));
  // node_modules/flatbuffers/mjs/constants.js
  var SIZEOF_SHORT = 2;
  var SIZEOF_INT = 4;
  var FILE_IDENTIFIER_LENGTH = 4;
  var SIZE_PREFIX_LENGTH = 4;
  // node_modules/flatbuffers/mjs/utils.js
  var int32 = new Int32Array(2);
  var float32 = new Float32Array(int32.buffer);
  var float64 = new Float64Array(int32.buffer);
  var isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
  // node_modules/flatbuffers/mjs/encoding.js
  var Encoding2;
  (function(Encoding3) {
    Encoding3[Encoding3["UTF8_BYTES"] = 1] = "UTF8_BYTES";
    Encoding3[Encoding3["UTF16_STRING"] = 2] = "UTF16_STRING";
  })(Encoding2 || (Encoding2 = {}));

  // node_modules/flatbuffers/mjs/byte-buffer.js
  class ByteBuffer {
    constructor(bytes_) {
      this.bytes_ = bytes_;
      this.position_ = 0;
      this.text_decoder_ = new TextDecoder;
    }
    static allocate(byte_size) {
      return new ByteBuffer(new Uint8Array(byte_size));
    }
    clear() {
      this.position_ = 0;
    }
    bytes() {
      return this.bytes_;
    }
    position() {
      return this.position_;
    }
    setPosition(position) {
      this.position_ = position;
    }
    capacity() {
      return this.bytes_.length;
    }
    readInt8(offset) {
      return this.readUint8(offset) << 24 >> 24;
    }
    readUint8(offset) {
      return this.bytes_[offset];
    }
    readInt16(offset) {
      return this.readUint16(offset) << 16 >> 16;
    }
    readUint16(offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
    }
    readInt32(offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
    }
    readUint32(offset) {
      return this.readInt32(offset) >>> 0;
    }
    readInt64(offset) {
      return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
    }
    readUint64(offset) {
      return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
    }
    readFloat32(offset) {
      int32[0] = this.readInt32(offset);
      return float32[0];
    }
    readFloat64(offset) {
      int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);
      int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
      return float64[0];
    }
    writeInt8(offset, value) {
      this.bytes_[offset] = value;
    }
    writeUint8(offset, value) {
      this.bytes_[offset] = value;
    }
    writeInt16(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    }
    writeUint16(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    }
    writeInt32(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    }
    writeUint32(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    }
    writeInt64(offset, value) {
      this.writeInt32(offset, Number(BigInt.asIntN(32, value)));
      this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));
    }
    writeUint64(offset, value) {
      this.writeUint32(offset, Number(BigInt.asUintN(32, value)));
      this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));
    }
    writeFloat32(offset, value) {
      float32[0] = value;
      this.writeInt32(offset, int32[0]);
    }
    writeFloat64(offset, value) {
      float64[0] = value;
      this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);
      this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);
    }
    getBufferIdentifier() {
      if (this.bytes_.length < this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {
        throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
      }
      let result = "";
      for (let i2 = 0;i2 < FILE_IDENTIFIER_LENGTH; i2++) {
        result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i2));
      }
      return result;
    }
    __offset(bb_pos, vtable_offset) {
      const vtable = bb_pos - this.readInt32(bb_pos);
      return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
    }
    __union(t, offset) {
      t.bb_pos = offset + this.readInt32(offset);
      t.bb = this;
      return t;
    }
    __string(offset, opt_encoding) {
      offset += this.readInt32(offset);
      const length3 = this.readInt32(offset);
      offset += SIZEOF_INT;
      const utf8bytes = this.bytes_.subarray(offset, offset + length3);
      if (opt_encoding === Encoding2.UTF8_BYTES)
        return utf8bytes;
      else
        return this.text_decoder_.decode(utf8bytes);
    }
    __union_with_string(o, offset) {
      if (typeof o === "string") {
        return this.__string(offset);
      }
      return this.__union(o, offset);
    }
    __indirect(offset) {
      return offset + this.readInt32(offset);
    }
    __vector(offset) {
      return offset + this.readInt32(offset) + SIZEOF_INT;
    }
    __vector_len(offset) {
      return this.readInt32(offset + this.readInt32(offset));
    }
    __has_identifier(ident) {
      if (ident.length != FILE_IDENTIFIER_LENGTH) {
        throw new Error("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
      }
      for (let i2 = 0;i2 < FILE_IDENTIFIER_LENGTH; i2++) {
        if (ident.charCodeAt(i2) != this.readInt8(this.position() + SIZEOF_INT + i2)) {
          return false;
        }
      }
      return true;
    }
    createScalarList(listAccessor, listLength) {
      const ret = [];
      for (let i2 = 0;i2 < listLength; ++i2) {
        const val = listAccessor(i2);
        if (val !== null) {
          ret.push(val);
        }
      }
      return ret;
    }
    createObjList(listAccessor, listLength) {
      const ret = [];
      for (let i2 = 0;i2 < listLength; ++i2) {
        const val = listAccessor(i2);
        if (val !== null) {
          ret.push(val.unpack());
        }
      }
      return ret;
    }
  }

  // node_modules/flatbuffers/mjs/builder.js
  class Builder {
    constructor(opt_initial_size) {
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
      this.string_maps = null;
      this.text_encoder = new TextEncoder;
      let initial_size;
      if (!opt_initial_size) {
        initial_size = 1024;
      } else {
        initial_size = opt_initial_size;
      }
      this.bb = ByteBuffer.allocate(initial_size);
      this.space = initial_size;
    }
    clear() {
      this.bb.clear();
      this.space = this.bb.capacity();
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
      this.string_maps = null;
    }
    forceDefaults(forceDefaults) {
      this.force_defaults = forceDefaults;
    }
    dataBuffer() {
      return this.bb;
    }
    asUint8Array() {
      return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
    }
    prep(size13, additional_bytes) {
      if (size13 > this.minalign) {
        this.minalign = size13;
      }
      const align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size13 - 1;
      while (this.space < align_size + size13 + additional_bytes) {
        const old_buf_size = this.bb.capacity();
        this.bb = Builder.growByteBuffer(this.bb);
        this.space += this.bb.capacity() - old_buf_size;
      }
      this.pad(align_size);
    }
    pad(byte_size) {
      for (let i2 = 0;i2 < byte_size; i2++) {
        this.bb.writeInt8(--this.space, 0);
      }
    }
    writeInt8(value) {
      this.bb.writeInt8(this.space -= 1, value);
    }
    writeInt16(value) {
      this.bb.writeInt16(this.space -= 2, value);
    }
    writeInt32(value) {
      this.bb.writeInt32(this.space -= 4, value);
    }
    writeInt64(value) {
      this.bb.writeInt64(this.space -= 8, value);
    }
    writeFloat32(value) {
      this.bb.writeFloat32(this.space -= 4, value);
    }
    writeFloat64(value) {
      this.bb.writeFloat64(this.space -= 8, value);
    }
    addInt8(value) {
      this.prep(1, 0);
      this.writeInt8(value);
    }
    addInt16(value) {
      this.prep(2, 0);
      this.writeInt16(value);
    }
    addInt32(value) {
      this.prep(4, 0);
      this.writeInt32(value);
    }
    addInt64(value) {
      this.prep(8, 0);
      this.writeInt64(value);
    }
    addFloat32(value) {
      this.prep(4, 0);
      this.writeFloat32(value);
    }
    addFloat64(value) {
      this.prep(8, 0);
      this.writeFloat64(value);
    }
    addFieldInt8(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt8(value);
        this.slot(voffset);
      }
    }
    addFieldInt16(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt16(value);
        this.slot(voffset);
      }
    }
    addFieldInt32(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt32(value);
        this.slot(voffset);
      }
    }
    addFieldInt64(voffset, value, defaultValue) {
      if (this.force_defaults || value !== defaultValue) {
        this.addInt64(value);
        this.slot(voffset);
      }
    }
    addFieldFloat32(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat32(value);
        this.slot(voffset);
      }
    }
    addFieldFloat64(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat64(value);
        this.slot(voffset);
      }
    }
    addFieldOffset(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addOffset(value);
        this.slot(voffset);
      }
    }
    addFieldStruct(voffset, value, defaultValue) {
      if (value != defaultValue) {
        this.nested(value);
        this.slot(voffset);
      }
    }
    nested(obj) {
      if (obj != this.offset()) {
        throw new TypeError("FlatBuffers: struct must be serialized inline.");
      }
    }
    notNested() {
      if (this.isNested) {
        throw new TypeError("FlatBuffers: object serialization must not be nested.");
      }
    }
    slot(voffset) {
      if (this.vtable !== null)
        this.vtable[voffset] = this.offset();
    }
    offset() {
      return this.bb.capacity() - this.space;
    }
    static growByteBuffer(bb) {
      const old_buf_size = bb.capacity();
      if (old_buf_size & 3221225472) {
        throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
      }
      const new_buf_size = old_buf_size << 1;
      const nbb = ByteBuffer.allocate(new_buf_size);
      nbb.setPosition(new_buf_size - old_buf_size);
      nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
      return nbb;
    }
    addOffset(offset) {
      this.prep(SIZEOF_INT, 0);
      this.writeInt32(this.offset() - offset + SIZEOF_INT);
    }
    startObject(numfields) {
      this.notNested();
      if (this.vtable == null) {
        this.vtable = [];
      }
      this.vtable_in_use = numfields;
      for (let i2 = 0;i2 < numfields; i2++) {
        this.vtable[i2] = 0;
      }
      this.isNested = true;
      this.object_start = this.offset();
    }
    endObject() {
      if (this.vtable == null || !this.isNested) {
        throw new Error("FlatBuffers: endObject called without startObject");
      }
      this.addInt32(0);
      const vtableloc = this.offset();
      let i2 = this.vtable_in_use - 1;
      for (;i2 >= 0 && this.vtable[i2] == 0; i2--) {}
      const trimmed_size = i2 + 1;
      for (;i2 >= 0; i2--) {
        this.addInt16(this.vtable[i2] != 0 ? vtableloc - this.vtable[i2] : 0);
      }
      const standard_fields = 2;
      this.addInt16(vtableloc - this.object_start);
      const len2 = (trimmed_size + standard_fields) * SIZEOF_SHORT;
      this.addInt16(len2);
      let existing_vtable = 0;
      const vt1 = this.space;
      outer_loop:
        for (i2 = 0;i2 < this.vtables.length; i2++) {
          const vt2 = this.bb.capacity() - this.vtables[i2];
          if (len2 == this.bb.readInt16(vt2)) {
            for (let j = SIZEOF_SHORT;j < len2; j += SIZEOF_SHORT) {
              if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
                continue outer_loop;
              }
            }
            existing_vtable = this.vtables[i2];
            break;
          }
        }
      if (existing_vtable) {
        this.space = this.bb.capacity() - vtableloc;
        this.bb.writeInt32(this.space, existing_vtable - vtableloc);
      } else {
        this.vtables.push(this.offset());
        this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
      }
      this.isNested = false;
      return vtableloc;
    }
    finish(root_table, opt_file_identifier, opt_size_prefix) {
      const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;
      if (opt_file_identifier) {
        const file_identifier = opt_file_identifier;
        this.prep(this.minalign, SIZEOF_INT + FILE_IDENTIFIER_LENGTH + size_prefix);
        if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {
          throw new TypeError("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
        }
        for (let i2 = FILE_IDENTIFIER_LENGTH - 1;i2 >= 0; i2--) {
          this.writeInt8(file_identifier.charCodeAt(i2));
        }
      }
      this.prep(this.minalign, SIZEOF_INT + size_prefix);
      this.addOffset(root_table);
      if (size_prefix) {
        this.addInt32(this.bb.capacity() - this.space);
      }
      this.bb.setPosition(this.space);
    }
    finishSizePrefixed(root_table, opt_file_identifier) {
      this.finish(root_table, opt_file_identifier, true);
    }
    requiredField(table, field) {
      const table_start = this.bb.capacity() - table;
      const vtable_start = table_start - this.bb.readInt32(table_start);
      const ok = field < this.bb.readInt16(vtable_start) && this.bb.readInt16(vtable_start + field) != 0;
      if (!ok) {
        throw new TypeError("FlatBuffers: field " + field + " must be set");
      }
    }
    startVector(elem_size, num_elems, alignment) {
      this.notNested();
      this.vector_num_elems = num_elems;
      this.prep(SIZEOF_INT, elem_size * num_elems);
      this.prep(alignment, elem_size * num_elems);
    }
    endVector() {
      this.writeInt32(this.vector_num_elems);
      return this.offset();
    }
    createSharedString(s) {
      if (!s) {
        return 0;
      }
      if (!this.string_maps) {
        this.string_maps = new Map;
      }
      if (this.string_maps.has(s)) {
        return this.string_maps.get(s);
      }
      const offset = this.createString(s);
      this.string_maps.set(s, offset);
      return offset;
    }
    createString(s) {
      if (s === null || s === undefined) {
        return 0;
      }
      let utf8;
      if (s instanceof Uint8Array) {
        utf8 = s;
      } else {
        utf8 = this.text_encoder.encode(s);
      }
      this.addInt8(0);
      this.startVector(1, utf8.length, 1);
      this.bb.setPosition(this.space -= utf8.length);
      this.bb.bytes().set(utf8, this.space);
      return this.endVector();
    }
    createByteVector(v) {
      if (v === null || v === undefined) {
        return 0;
      }
      this.startVector(1, v.length, 1);
      this.bb.setPosition(this.space -= v.length);
      this.bb.bytes().set(v, this.space);
      return this.endVector();
    }
    createObjectOffset(obj) {
      if (obj === null) {
        return 0;
      }
      if (typeof obj === "string") {
        return this.createString(obj);
      } else {
        return obj.pack(this);
      }
    }
    createObjectOffsetList(list) {
      const ret = [];
      for (let i2 = 0;i2 < list.length; ++i2) {
        const val = list[i2];
        if (val !== null) {
          ret.push(this.createObjectOffset(val));
        } else {
          throw new TypeError("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
        }
      }
      return ret;
    }
    createStructOffsetList(list, startFunc) {
      startFunc(this, list.length);
      this.createObjectOffsetList(list.slice().reverse());
      return this.endVector();
    }
  }
  // node_modules/apache-arrow/fb/body-compression-method.mjs
  var BodyCompressionMethod;
  (function(BodyCompressionMethod2) {
    BodyCompressionMethod2[BodyCompressionMethod2["BUFFER"] = 0] = "BUFFER";
  })(BodyCompressionMethod || (BodyCompressionMethod = {}));

  // node_modules/apache-arrow/fb/compression-type.mjs
  var CompressionType;
  (function(CompressionType2) {
    CompressionType2[CompressionType2["LZ4_FRAME"] = 0] = "LZ4_FRAME";
    CompressionType2[CompressionType2["ZSTD"] = 1] = "ZSTD";
  })(CompressionType || (CompressionType = {}));

  // node_modules/apache-arrow/fb/body-compression.mjs
  class BodyCompression {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsBodyCompression(bb, obj) {
      return (obj || new BodyCompression).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBodyCompression(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new BodyCompression).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    codec() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt8(this.bb_pos + offset) : CompressionType.LZ4_FRAME;
    }
    method() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt8(this.bb_pos + offset) : BodyCompressionMethod.BUFFER;
    }
    static startBodyCompression(builder) {
      builder.startObject(2);
    }
    static addCodec(builder, codec) {
      builder.addFieldInt8(0, codec, CompressionType.LZ4_FRAME);
    }
    static addMethod(builder, method) {
      builder.addFieldInt8(1, method, BodyCompressionMethod.BUFFER);
    }
    static endBodyCompression(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createBodyCompression(builder, codec, method) {
      BodyCompression.startBodyCompression(builder);
      BodyCompression.addCodec(builder, codec);
      BodyCompression.addMethod(builder, method);
      return BodyCompression.endBodyCompression(builder);
    }
  }

  // node_modules/apache-arrow/fb/buffer.mjs
  class Buffer3 {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    offset() {
      return this.bb.readInt64(this.bb_pos);
    }
    length() {
      return this.bb.readInt64(this.bb_pos + 8);
    }
    static sizeOf() {
      return 16;
    }
    static createBuffer(builder, offset, length3) {
      builder.prep(8, 16);
      builder.writeInt64(BigInt(length3 !== null && length3 !== undefined ? length3 : 0));
      builder.writeInt64(BigInt(offset !== null && offset !== undefined ? offset : 0));
      return builder.offset();
    }
  }

  // node_modules/apache-arrow/fb/field-node.mjs
  class FieldNode {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    length() {
      return this.bb.readInt64(this.bb_pos);
    }
    nullCount() {
      return this.bb.readInt64(this.bb_pos + 8);
    }
    static sizeOf() {
      return 16;
    }
    static createFieldNode(builder, length3, null_count) {
      builder.prep(8, 16);
      builder.writeInt64(BigInt(null_count !== null && null_count !== undefined ? null_count : 0));
      builder.writeInt64(BigInt(length3 !== null && length3 !== undefined ? length3 : 0));
      return builder.offset();
    }
  }

  // node_modules/apache-arrow/fb/record-batch.mjs
  class RecordBatch2 {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsRecordBatch(bb, obj) {
      return (obj || new RecordBatch2).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRecordBatch(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new RecordBatch2).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    length() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
    }
    nodes(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new FieldNode).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    nodesLength() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    buffers(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? (obj || new Buffer3).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    buffersLength() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    compression(obj) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? (obj || new BodyCompression).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startRecordBatch(builder) {
      builder.startObject(4);
    }
    static addLength(builder, length3) {
      builder.addFieldInt64(0, length3, BigInt("0"));
    }
    static addNodes(builder, nodesOffset) {
      builder.addFieldOffset(1, nodesOffset, 0);
    }
    static startNodesVector(builder, numElems) {
      builder.startVector(16, numElems, 8);
    }
    static addBuffers(builder, buffersOffset) {
      builder.addFieldOffset(2, buffersOffset, 0);
    }
    static startBuffersVector(builder, numElems) {
      builder.startVector(16, numElems, 8);
    }
    static addCompression(builder, compressionOffset) {
      builder.addFieldOffset(3, compressionOffset, 0);
    }
    static endRecordBatch(builder) {
      const offset = builder.endObject();
      return offset;
    }
  }

  // node_modules/apache-arrow/fb/dictionary-batch.mjs
  class DictionaryBatch {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsDictionaryBatch(bb, obj) {
      return (obj || new DictionaryBatch).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDictionaryBatch(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new DictionaryBatch).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
    }
    data(obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new RecordBatch2).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    isDelta() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startDictionaryBatch(builder) {
      builder.startObject(3);
    }
    static addId(builder, id2) {
      builder.addFieldInt64(0, id2, BigInt("0"));
    }
    static addData(builder, dataOffset) {
      builder.addFieldOffset(1, dataOffset, 0);
    }
    static addIsDelta(builder, isDelta) {
      builder.addFieldInt8(2, +isDelta, 0);
    }
    static endDictionaryBatch(builder) {
      const offset = builder.endObject();
      return offset;
    }
  }

  // node_modules/apache-arrow/fb/endianness.mjs
  var Endianness;
  (function(Endianness2) {
    Endianness2[Endianness2["Little"] = 0] = "Little";
    Endianness2[Endianness2["Big"] = 1] = "Big";
  })(Endianness || (Endianness = {}));

  // node_modules/apache-arrow/fb/dictionary-kind.mjs
  var DictionaryKind;
  (function(DictionaryKind2) {
    DictionaryKind2[DictionaryKind2["DenseArray"] = 0] = "DenseArray";
  })(DictionaryKind || (DictionaryKind = {}));

  // node_modules/apache-arrow/fb/int.mjs
  class Int2 {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsInt(bb, obj) {
      return (obj || new Int2).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsInt(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Int2).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    bitWidth() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    isSigned() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startInt(builder) {
      builder.startObject(2);
    }
    static addBitWidth(builder, bitWidth) {
      builder.addFieldInt32(0, bitWidth, 0);
    }
    static addIsSigned(builder, isSigned) {
      builder.addFieldInt8(1, +isSigned, 0);
    }
    static endInt(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createInt(builder, bitWidth, isSigned) {
      Int2.startInt(builder);
      Int2.addBitWidth(builder, bitWidth);
      Int2.addIsSigned(builder, isSigned);
      return Int2.endInt(builder);
    }
  }

  // node_modules/apache-arrow/fb/dictionary-encoding.mjs
  class DictionaryEncoding {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsDictionaryEncoding(bb, obj) {
      return (obj || new DictionaryEncoding).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDictionaryEncoding(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new DictionaryEncoding).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
    }
    indexType(obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new Int2).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    isOrdered() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    dictionaryKind() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : DictionaryKind.DenseArray;
    }
    static startDictionaryEncoding(builder) {
      builder.startObject(4);
    }
    static addId(builder, id2) {
      builder.addFieldInt64(0, id2, BigInt("0"));
    }
    static addIndexType(builder, indexTypeOffset) {
      builder.addFieldOffset(1, indexTypeOffset, 0);
    }
    static addIsOrdered(builder, isOrdered) {
      builder.addFieldInt8(2, +isOrdered, 0);
    }
    static addDictionaryKind(builder, dictionaryKind) {
      builder.addFieldInt16(3, dictionaryKind, DictionaryKind.DenseArray);
    }
    static endDictionaryEncoding(builder) {
      const offset = builder.endObject();
      return offset;
    }
  }

  // node_modules/apache-arrow/fb/key-value.mjs
  class KeyValue {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsKeyValue(bb, obj) {
      return (obj || new KeyValue).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsKeyValue(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new KeyValue).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    key(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    value(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startKeyValue(builder) {
      builder.startObject(2);
    }
    static addKey(builder, keyOffset) {
      builder.addFieldOffset(0, keyOffset, 0);
    }
    static addValue(builder, valueOffset) {
      builder.addFieldOffset(1, valueOffset, 0);
    }
    static endKeyValue(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createKeyValue(builder, keyOffset, valueOffset) {
      KeyValue.startKeyValue(builder);
      KeyValue.addKey(builder, keyOffset);
      KeyValue.addValue(builder, valueOffset);
      return KeyValue.endKeyValue(builder);
    }
  }

  // node_modules/apache-arrow/fb/binary.mjs
  class Binary {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsBinary(bb, obj) {
      return (obj || new Binary).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBinary(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Binary).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startBinary(builder) {
      builder.startObject(0);
    }
    static endBinary(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createBinary(builder) {
      Binary.startBinary(builder);
      return Binary.endBinary(builder);
    }
  }

  // node_modules/apache-arrow/fb/bool.mjs
  class Bool {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsBool(bb, obj) {
      return (obj || new Bool).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBool(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Bool).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startBool(builder) {
      builder.startObject(0);
    }
    static endBool(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createBool(builder) {
      Bool.startBool(builder);
      return Bool.endBool(builder);
    }
  }

  // node_modules/apache-arrow/fb/date.mjs
  class Date3 {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsDate(bb, obj) {
      return (obj || new Date3).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDate(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Date3).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : DateUnit.MILLISECOND;
    }
    static startDate(builder) {
      builder.startObject(1);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, DateUnit.MILLISECOND);
    }
    static endDate(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createDate(builder, unit) {
      Date3.startDate(builder);
      Date3.addUnit(builder, unit);
      return Date3.endDate(builder);
    }
  }

  // node_modules/apache-arrow/fb/decimal.mjs
  class Decimal {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsDecimal(bb, obj) {
      return (obj || new Decimal).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDecimal(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Decimal).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    precision() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    scale() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    bitWidth() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 128;
    }
    static startDecimal(builder) {
      builder.startObject(3);
    }
    static addPrecision(builder, precision) {
      builder.addFieldInt32(0, precision, 0);
    }
    static addScale(builder, scale) {
      builder.addFieldInt32(1, scale, 0);
    }
    static addBitWidth(builder, bitWidth) {
      builder.addFieldInt32(2, bitWidth, 128);
    }
    static endDecimal(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createDecimal(builder, precision, scale, bitWidth) {
      Decimal.startDecimal(builder);
      Decimal.addPrecision(builder, precision);
      Decimal.addScale(builder, scale);
      Decimal.addBitWidth(builder, bitWidth);
      return Decimal.endDecimal(builder);
    }
  }

  // node_modules/apache-arrow/fb/duration.mjs
  class Duration {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsDuration(bb, obj) {
      return (obj || new Duration).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDuration(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Duration).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit.MILLISECOND;
    }
    static startDuration(builder) {
      builder.startObject(1);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, TimeUnit.MILLISECOND);
    }
    static endDuration(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createDuration(builder, unit) {
      Duration.startDuration(builder);
      Duration.addUnit(builder, unit);
      return Duration.endDuration(builder);
    }
  }

  // node_modules/apache-arrow/fb/fixed-size-binary.mjs
  class FixedSizeBinary {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsFixedSizeBinary(bb, obj) {
      return (obj || new FixedSizeBinary).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFixedSizeBinary(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new FixedSizeBinary).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    byteWidth() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    static startFixedSizeBinary(builder) {
      builder.startObject(1);
    }
    static addByteWidth(builder, byteWidth) {
      builder.addFieldInt32(0, byteWidth, 0);
    }
    static endFixedSizeBinary(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createFixedSizeBinary(builder, byteWidth) {
      FixedSizeBinary.startFixedSizeBinary(builder);
      FixedSizeBinary.addByteWidth(builder, byteWidth);
      return FixedSizeBinary.endFixedSizeBinary(builder);
    }
  }

  // node_modules/apache-arrow/fb/fixed-size-list.mjs
  class FixedSizeList {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsFixedSizeList(bb, obj) {
      return (obj || new FixedSizeList).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFixedSizeList(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new FixedSizeList).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    listSize() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    static startFixedSizeList(builder) {
      builder.startObject(1);
    }
    static addListSize(builder, listSize) {
      builder.addFieldInt32(0, listSize, 0);
    }
    static endFixedSizeList(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createFixedSizeList(builder, listSize) {
      FixedSizeList.startFixedSizeList(builder);
      FixedSizeList.addListSize(builder, listSize);
      return FixedSizeList.endFixedSizeList(builder);
    }
  }

  // node_modules/apache-arrow/fb/floating-point.mjs
  class FloatingPoint {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsFloatingPoint(bb, obj) {
      return (obj || new FloatingPoint).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFloatingPoint(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new FloatingPoint).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    precision() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : Precision.HALF;
    }
    static startFloatingPoint(builder) {
      builder.startObject(1);
    }
    static addPrecision(builder, precision) {
      builder.addFieldInt16(0, precision, Precision.HALF);
    }
    static endFloatingPoint(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createFloatingPoint(builder, precision) {
      FloatingPoint.startFloatingPoint(builder);
      FloatingPoint.addPrecision(builder, precision);
      return FloatingPoint.endFloatingPoint(builder);
    }
  }

  // node_modules/apache-arrow/fb/interval.mjs
  class Interval {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsInterval(bb, obj) {
      return (obj || new Interval).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsInterval(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Interval).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : IntervalUnit.YEAR_MONTH;
    }
    static startInterval(builder) {
      builder.startObject(1);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, IntervalUnit.YEAR_MONTH);
    }
    static endInterval(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createInterval(builder, unit) {
      Interval.startInterval(builder);
      Interval.addUnit(builder, unit);
      return Interval.endInterval(builder);
    }
  }

  // node_modules/apache-arrow/fb/large-binary.mjs
  class LargeBinary {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsLargeBinary(bb, obj) {
      return (obj || new LargeBinary).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsLargeBinary(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new LargeBinary).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startLargeBinary(builder) {
      builder.startObject(0);
    }
    static endLargeBinary(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createLargeBinary(builder) {
      LargeBinary.startLargeBinary(builder);
      return LargeBinary.endLargeBinary(builder);
    }
  }

  // node_modules/apache-arrow/fb/large-utf8.mjs
  class LargeUtf8 {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsLargeUtf8(bb, obj) {
      return (obj || new LargeUtf8).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsLargeUtf8(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new LargeUtf8).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startLargeUtf8(builder) {
      builder.startObject(0);
    }
    static endLargeUtf8(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createLargeUtf8(builder) {
      LargeUtf8.startLargeUtf8(builder);
      return LargeUtf8.endLargeUtf8(builder);
    }
  }

  // node_modules/apache-arrow/fb/list.mjs
  class List {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsList(bb, obj) {
      return (obj || new List).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsList(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new List).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startList(builder) {
      builder.startObject(0);
    }
    static endList(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createList(builder) {
      List.startList(builder);
      return List.endList(builder);
    }
  }

  // node_modules/apache-arrow/fb/map.mjs
  class Map2 {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsMap(bb, obj) {
      return (obj || new Map2).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMap(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Map2).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    keysSorted() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startMap(builder) {
      builder.startObject(1);
    }
    static addKeysSorted(builder, keysSorted) {
      builder.addFieldInt8(0, +keysSorted, 0);
    }
    static endMap(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createMap(builder, keysSorted) {
      Map2.startMap(builder);
      Map2.addKeysSorted(builder, keysSorted);
      return Map2.endMap(builder);
    }
  }

  // node_modules/apache-arrow/fb/null.mjs
  class Null {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsNull(bb, obj) {
      return (obj || new Null).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsNull(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Null).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startNull(builder) {
      builder.startObject(0);
    }
    static endNull(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createNull(builder) {
      Null.startNull(builder);
      return Null.endNull(builder);
    }
  }

  // node_modules/apache-arrow/fb/struct-.mjs
  class Struct_ {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsStruct_(bb, obj) {
      return (obj || new Struct_).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsStruct_(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Struct_).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startStruct_(builder) {
      builder.startObject(0);
    }
    static endStruct_(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createStruct_(builder) {
      Struct_.startStruct_(builder);
      return Struct_.endStruct_(builder);
    }
  }

  // node_modules/apache-arrow/fb/time.mjs
  class Time {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsTime(bb, obj) {
      return (obj || new Time).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTime(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Time).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit.MILLISECOND;
    }
    bitWidth() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 32;
    }
    static startTime(builder) {
      builder.startObject(2);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, TimeUnit.MILLISECOND);
    }
    static addBitWidth(builder, bitWidth) {
      builder.addFieldInt32(1, bitWidth, 32);
    }
    static endTime(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createTime(builder, unit, bitWidth) {
      Time.startTime(builder);
      Time.addUnit(builder, unit);
      Time.addBitWidth(builder, bitWidth);
      return Time.endTime(builder);
    }
  }

  // node_modules/apache-arrow/fb/timestamp.mjs
  class Timestamp {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsTimestamp(bb, obj) {
      return (obj || new Timestamp).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTimestamp(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Timestamp).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit.SECOND;
    }
    timezone(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startTimestamp(builder) {
      builder.startObject(2);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, TimeUnit.SECOND);
    }
    static addTimezone(builder, timezoneOffset) {
      builder.addFieldOffset(1, timezoneOffset, 0);
    }
    static endTimestamp(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createTimestamp(builder, unit, timezoneOffset) {
      Timestamp.startTimestamp(builder);
      Timestamp.addUnit(builder, unit);
      Timestamp.addTimezone(builder, timezoneOffset);
      return Timestamp.endTimestamp(builder);
    }
  }

  // node_modules/apache-arrow/fb/union.mjs
  class Union3 {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsUnion(bb, obj) {
      return (obj || new Union3).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUnion(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Union3).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    mode() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : UnionMode.Sparse;
    }
    typeIds(index) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
    typeIdsLength() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    typeIdsArray() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startUnion(builder) {
      builder.startObject(2);
    }
    static addMode(builder, mode) {
      builder.addFieldInt16(0, mode, UnionMode.Sparse);
    }
    static addTypeIds(builder, typeIdsOffset) {
      builder.addFieldOffset(1, typeIdsOffset, 0);
    }
    static createTypeIdsVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i2 = data.length - 1;i2 >= 0; i2--) {
        builder.addInt32(data[i2]);
      }
      return builder.endVector();
    }
    static startTypeIdsVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endUnion(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createUnion(builder, mode, typeIdsOffset) {
      Union3.startUnion(builder);
      Union3.addMode(builder, mode);
      Union3.addTypeIds(builder, typeIdsOffset);
      return Union3.endUnion(builder);
    }
  }

  // node_modules/apache-arrow/fb/utf8.mjs
  class Utf8 {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsUtf8(bb, obj) {
      return (obj || new Utf8).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUtf8(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Utf8).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startUtf8(builder) {
      builder.startObject(0);
    }
    static endUtf8(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createUtf8(builder) {
      Utf8.startUtf8(builder);
      return Utf8.endUtf8(builder);
    }
  }

  // node_modules/apache-arrow/fb/type.mjs
  var Type3;
  (function(Type4) {
    Type4[Type4["NONE"] = 0] = "NONE";
    Type4[Type4["Null"] = 1] = "Null";
    Type4[Type4["Int"] = 2] = "Int";
    Type4[Type4["FloatingPoint"] = 3] = "FloatingPoint";
    Type4[Type4["Binary"] = 4] = "Binary";
    Type4[Type4["Utf8"] = 5] = "Utf8";
    Type4[Type4["Bool"] = 6] = "Bool";
    Type4[Type4["Decimal"] = 7] = "Decimal";
    Type4[Type4["Date"] = 8] = "Date";
    Type4[Type4["Time"] = 9] = "Time";
    Type4[Type4["Timestamp"] = 10] = "Timestamp";
    Type4[Type4["Interval"] = 11] = "Interval";
    Type4[Type4["List"] = 12] = "List";
    Type4[Type4["Struct_"] = 13] = "Struct_";
    Type4[Type4["Union"] = 14] = "Union";
    Type4[Type4["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type4[Type4["FixedSizeList"] = 16] = "FixedSizeList";
    Type4[Type4["Map"] = 17] = "Map";
    Type4[Type4["Duration"] = 18] = "Duration";
    Type4[Type4["LargeBinary"] = 19] = "LargeBinary";
    Type4[Type4["LargeUtf8"] = 20] = "LargeUtf8";
    Type4[Type4["LargeList"] = 21] = "LargeList";
    Type4[Type4["RunEndEncoded"] = 22] = "RunEndEncoded";
  })(Type3 || (Type3 = {}));

  // node_modules/apache-arrow/fb/field.mjs
  class Field {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsField(bb, obj) {
      return (obj || new Field).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsField(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Field).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    nullable() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    typeType() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.readUint8(this.bb_pos + offset) : Type3.NONE;
    }
    type(obj) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    dictionary(obj) {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? (obj || new DictionaryEncoding).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    children(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 14);
      return offset ? (obj || new Field).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    childrenLength() {
      const offset = this.bb.__offset(this.bb_pos, 14);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 16);
      return offset ? (obj || new KeyValue).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 16);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startField(builder) {
      builder.startObject(7);
    }
    static addName(builder, nameOffset) {
      builder.addFieldOffset(0, nameOffset, 0);
    }
    static addNullable(builder, nullable) {
      builder.addFieldInt8(1, +nullable, 0);
    }
    static addTypeType(builder, typeType) {
      builder.addFieldInt8(2, typeType, Type3.NONE);
    }
    static addType(builder, typeOffset) {
      builder.addFieldOffset(3, typeOffset, 0);
    }
    static addDictionary(builder, dictionaryOffset) {
      builder.addFieldOffset(4, dictionaryOffset, 0);
    }
    static addChildren(builder, childrenOffset) {
      builder.addFieldOffset(5, childrenOffset, 0);
    }
    static createChildrenVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i2 = data.length - 1;i2 >= 0; i2--) {
        builder.addOffset(data[i2]);
      }
      return builder.endVector();
    }
    static startChildrenVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(6, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i2 = data.length - 1;i2 >= 0; i2--) {
        builder.addOffset(data[i2]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endField(builder) {
      const offset = builder.endObject();
      return offset;
    }
  }

  // node_modules/apache-arrow/fb/schema.mjs
  class Schema2 {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsSchema(bb, obj) {
      return (obj || new Schema2).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSchema(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Schema2).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    endianness() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : Endianness.Little;
    }
    fields(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new Field).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    fieldsLength() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? (obj || new KeyValue).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    features(index) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
    featuresLength() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startSchema(builder) {
      builder.startObject(4);
    }
    static addEndianness(builder, endianness) {
      builder.addFieldInt16(0, endianness, Endianness.Little);
    }
    static addFields(builder, fieldsOffset) {
      builder.addFieldOffset(1, fieldsOffset, 0);
    }
    static createFieldsVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i2 = data.length - 1;i2 >= 0; i2--) {
        builder.addOffset(data[i2]);
      }
      return builder.endVector();
    }
    static startFieldsVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(2, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i2 = data.length - 1;i2 >= 0; i2--) {
        builder.addOffset(data[i2]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static addFeatures(builder, featuresOffset) {
      builder.addFieldOffset(3, featuresOffset, 0);
    }
    static createFeaturesVector(builder, data) {
      builder.startVector(8, data.length, 8);
      for (let i2 = data.length - 1;i2 >= 0; i2--) {
        builder.addInt64(data[i2]);
      }
      return builder.endVector();
    }
    static startFeaturesVector(builder, numElems) {
      builder.startVector(8, numElems, 8);
    }
    static endSchema(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static finishSchemaBuffer(builder, offset) {
      builder.finish(offset);
    }
    static finishSizePrefixedSchemaBuffer(builder, offset) {
      builder.finish(offset, undefined, true);
    }
    static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {
      Schema2.startSchema(builder);
      Schema2.addEndianness(builder, endianness);
      Schema2.addFields(builder, fieldsOffset);
      Schema2.addCustomMetadata(builder, customMetadataOffset);
      Schema2.addFeatures(builder, featuresOffset);
      return Schema2.endSchema(builder);
    }
  }

  // node_modules/apache-arrow/fb/message-header.mjs
  var MessageHeader;
  (function(MessageHeader2) {
    MessageHeader2[MessageHeader2["NONE"] = 0] = "NONE";
    MessageHeader2[MessageHeader2["Schema"] = 1] = "Schema";
    MessageHeader2[MessageHeader2["DictionaryBatch"] = 2] = "DictionaryBatch";
    MessageHeader2[MessageHeader2["RecordBatch"] = 3] = "RecordBatch";
    MessageHeader2[MessageHeader2["Tensor"] = 4] = "Tensor";
    MessageHeader2[MessageHeader2["SparseTensor"] = 5] = "SparseTensor";
  })(MessageHeader || (MessageHeader = {}));

  // node_modules/apache-arrow/enum.mjs
  var Type4;
  (function(Type5) {
    Type5[Type5["NONE"] = 0] = "NONE";
    Type5[Type5["Null"] = 1] = "Null";
    Type5[Type5["Int"] = 2] = "Int";
    Type5[Type5["Float"] = 3] = "Float";
    Type5[Type5["Binary"] = 4] = "Binary";
    Type5[Type5["Utf8"] = 5] = "Utf8";
    Type5[Type5["Bool"] = 6] = "Bool";
    Type5[Type5["Decimal"] = 7] = "Decimal";
    Type5[Type5["Date"] = 8] = "Date";
    Type5[Type5["Time"] = 9] = "Time";
    Type5[Type5["Timestamp"] = 10] = "Timestamp";
    Type5[Type5["Interval"] = 11] = "Interval";
    Type5[Type5["List"] = 12] = "List";
    Type5[Type5["Struct"] = 13] = "Struct";
    Type5[Type5["Union"] = 14] = "Union";
    Type5[Type5["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type5[Type5["FixedSizeList"] = 16] = "FixedSizeList";
    Type5[Type5["Map"] = 17] = "Map";
    Type5[Type5["Duration"] = 18] = "Duration";
    Type5[Type5["LargeBinary"] = 19] = "LargeBinary";
    Type5[Type5["LargeUtf8"] = 20] = "LargeUtf8";
    Type5[Type5["Dictionary"] = -1] = "Dictionary";
    Type5[Type5["Int8"] = -2] = "Int8";
    Type5[Type5["Int16"] = -3] = "Int16";
    Type5[Type5["Int32"] = -4] = "Int32";
    Type5[Type5["Int64"] = -5] = "Int64";
    Type5[Type5["Uint8"] = -6] = "Uint8";
    Type5[Type5["Uint16"] = -7] = "Uint16";
    Type5[Type5["Uint32"] = -8] = "Uint32";
    Type5[Type5["Uint64"] = -9] = "Uint64";
    Type5[Type5["Float16"] = -10] = "Float16";
    Type5[Type5["Float32"] = -11] = "Float32";
    Type5[Type5["Float64"] = -12] = "Float64";
    Type5[Type5["DateDay"] = -13] = "DateDay";
    Type5[Type5["DateMillisecond"] = -14] = "DateMillisecond";
    Type5[Type5["TimestampSecond"] = -15] = "TimestampSecond";
    Type5[Type5["TimestampMillisecond"] = -16] = "TimestampMillisecond";
    Type5[Type5["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
    Type5[Type5["TimestampNanosecond"] = -18] = "TimestampNanosecond";
    Type5[Type5["TimeSecond"] = -19] = "TimeSecond";
    Type5[Type5["TimeMillisecond"] = -20] = "TimeMillisecond";
    Type5[Type5["TimeMicrosecond"] = -21] = "TimeMicrosecond";
    Type5[Type5["TimeNanosecond"] = -22] = "TimeNanosecond";
    Type5[Type5["DenseUnion"] = -23] = "DenseUnion";
    Type5[Type5["SparseUnion"] = -24] = "SparseUnion";
    Type5[Type5["IntervalDayTime"] = -25] = "IntervalDayTime";
    Type5[Type5["IntervalYearMonth"] = -26] = "IntervalYearMonth";
    Type5[Type5["DurationSecond"] = -27] = "DurationSecond";
    Type5[Type5["DurationMillisecond"] = -28] = "DurationMillisecond";
    Type5[Type5["DurationMicrosecond"] = -29] = "DurationMicrosecond";
    Type5[Type5["DurationNanosecond"] = -30] = "DurationNanosecond";
    Type5[Type5["IntervalMonthDayNano"] = -31] = "IntervalMonthDayNano";
  })(Type4 || (Type4 = {}));
  var BufferType;
  (function(BufferType2) {
    BufferType2[BufferType2["OFFSET"] = 0] = "OFFSET";
    BufferType2[BufferType2["DATA"] = 1] = "DATA";
    BufferType2[BufferType2["VALIDITY"] = 2] = "VALIDITY";
    BufferType2[BufferType2["TYPE"] = 3] = "TYPE";
  })(BufferType || (BufferType = {}));

  // node_modules/apache-arrow/util/vector.mjs
  var exports_vector = {};
  __export(exports_vector, {
    wrapIndex: () => wrapIndex,
    createElementComparator: () => createElementComparator,
    clampRange: () => clampRange
  });

  // node_modules/apache-arrow/util/pretty.mjs
  var exports_pretty = {};
  __export(exports_pretty, {
    valueToString: () => valueToString
  });
  var undf = undefined;
  function valueToString(x) {
    if (x === null) {
      return "null";
    }
    if (x === undf) {
      return "undefined";
    }
    switch (typeof x) {
      case "number":
        return `${x}`;
      case "bigint":
        return `${x}`;
      case "string":
        return `"${x}"`;
    }
    if (typeof x[Symbol.toPrimitive] === "function") {
      return x[Symbol.toPrimitive]("string");
    }
    if (ArrayBuffer.isView(x)) {
      if (x instanceof BigInt64Array || x instanceof BigUint64Array) {
        return `[${[...x].map((x2) => valueToString(x2))}]`;
      }
      return `[${x}]`;
    }
    return ArrayBuffer.isView(x) ? `[${x}]` : JSON.stringify(x, (_, y) => typeof y === "bigint" ? `${y}` : y);
  }

  // node_modules/apache-arrow/util/bn.mjs
  var exports_bn = {};
  __export(exports_bn, {
    isArrowBigNumSymbol: () => isArrowBigNumSymbol,
    bigNumToString: () => bigNumToString,
    bigNumToNumber: () => bigNumToNumber,
    bigNumToBigInt: () => bigNumToBigInt,
    BN: () => BN
  });

  // node_modules/apache-arrow/util/bigint.mjs
  function bigIntToNumber(number4) {
    if (typeof number4 === "bigint" && (number4 < Number.MIN_SAFE_INTEGER || number4 > Number.MAX_SAFE_INTEGER)) {
      throw new TypeError(`${number4} is not safe to convert to a number.`);
    }
    return Number(number4);
  }
  function divideBigInts(number4, divisor) {
    return bigIntToNumber(number4 / divisor) + bigIntToNumber(number4 % divisor) / bigIntToNumber(divisor);
  }

  // node_modules/apache-arrow/util/bn.mjs
  var isArrowBigNumSymbol = Symbol.for("isArrowBigNum");
  function BigNum(x, ...xs) {
    if (xs.length === 0) {
      return Object.setPrototypeOf(toArrayBufferView(this["TypedArray"], x), this.constructor.prototype);
    }
    return Object.setPrototypeOf(new this["TypedArray"](x, ...xs), this.constructor.prototype);
  }
  BigNum.prototype[isArrowBigNumSymbol] = true;
  BigNum.prototype.toJSON = function() {
    return `"${bigNumToString(this)}"`;
  };
  BigNum.prototype.valueOf = function(scale) {
    return bigNumToNumber(this, scale);
  };
  BigNum.prototype.toString = function() {
    return bigNumToString(this);
  };
  BigNum.prototype[Symbol.toPrimitive] = function(hint = "default") {
    switch (hint) {
      case "number":
        return bigNumToNumber(this);
      case "string":
        return bigNumToString(this);
      case "default":
        return bigNumToBigInt(this);
    }
    return bigNumToString(this);
  };
  function SignedBigNum(...args2) {
    return BigNum.apply(this, args2);
  }
  function UnsignedBigNum(...args2) {
    return BigNum.apply(this, args2);
  }
  function DecimalBigNum(...args2) {
    return BigNum.apply(this, args2);
  }
  Object.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));
  Object.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));
  Object.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));
  Object.assign(SignedBigNum.prototype, BigNum.prototype, { constructor: SignedBigNum, signed: true, TypedArray: Int32Array, BigIntArray: BigInt64Array });
  Object.assign(UnsignedBigNum.prototype, BigNum.prototype, { constructor: UnsignedBigNum, signed: false, TypedArray: Uint32Array, BigIntArray: BigUint64Array });
  Object.assign(DecimalBigNum.prototype, BigNum.prototype, { constructor: DecimalBigNum, signed: true, TypedArray: Uint32Array, BigIntArray: BigUint64Array });
  var TWO_TO_THE_64 = BigInt(4294967296) * BigInt(4294967296);
  var TWO_TO_THE_64_MINUS_1 = TWO_TO_THE_64 - BigInt(1);
  function bigNumToNumber(bn, scale) {
    const { buffer: buffer4, byteOffset, byteLength: byteLength2, signed } = bn;
    const words = new BigUint64Array(buffer4, byteOffset, byteLength2 / 8);
    const negative = signed && words.at(-1) & BigInt(1) << BigInt(63);
    let number4 = BigInt(0);
    let i2 = 0;
    if (negative) {
      for (const word of words) {
        number4 |= (word ^ TWO_TO_THE_64_MINUS_1) * (BigInt(1) << BigInt(64 * i2++));
      }
      number4 *= BigInt(-1);
      number4 -= BigInt(1);
    } else {
      for (const word of words) {
        number4 |= word * (BigInt(1) << BigInt(64 * i2++));
      }
    }
    if (typeof scale === "number" && scale > 0) {
      const denominator = BigInt("1".padEnd(scale + 1, "0"));
      const quotient = number4 / denominator;
      const remainder = negative ? -(number4 % denominator) : number4 % denominator;
      const integerPart = bigIntToNumber(quotient);
      const fractionPart = `${remainder}`.padStart(scale, "0");
      const sign = negative && integerPart === 0 ? "-" : "";
      return +`${sign}${integerPart}.${fractionPart}`;
    }
    return bigIntToNumber(number4);
  }
  function bigNumToString(a) {
    if (a.byteLength === 8) {
      const bigIntArray = new a["BigIntArray"](a.buffer, a.byteOffset, 1);
      return `${bigIntArray[0]}`;
    }
    if (!a["signed"]) {
      return unsignedBigNumToString(a);
    }
    let array4 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
    const highOrderWord = new Int16Array([array4.at(-1)])[0];
    if (highOrderWord >= 0) {
      return unsignedBigNumToString(a);
    }
    array4 = array4.slice();
    let carry = 1;
    for (let i2 = 0;i2 < array4.length; i2++) {
      const elem = array4[i2];
      const updated = ~elem + carry;
      array4[i2] = updated;
      carry &= elem === 0 ? 1 : 0;
    }
    const negated = unsignedBigNumToString(array4);
    return `-${negated}`;
  }
  function bigNumToBigInt(a) {
    if (a.byteLength === 8) {
      const bigIntArray = new a["BigIntArray"](a.buffer, a.byteOffset, 1);
      return bigIntArray[0];
    } else {
      return bigNumToString(a);
    }
  }
  function unsignedBigNumToString(a) {
    let digits = "";
    const base64 = new Uint32Array(2);
    let base32 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
    const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);
    let i2 = -1;
    const n = base32.length - 1;
    do {
      for (base64[0] = base32[i2 = 0];i2 < n; ) {
        base32[i2++] = base64[1] = base64[0] / 10;
        base64[0] = (base64[0] - base64[1] * 10 << 16) + base32[i2];
      }
      base32[i2] = base64[1] = base64[0] / 10;
      base64[0] = base64[0] - base64[1] * 10;
      digits = `${base64[0]}${digits}`;
    } while (checks[0] || checks[1] || checks[2] || checks[3]);
    return digits !== null && digits !== undefined ? digits : `0`;
  }

  class BN {
    static new(num, isSigned) {
      switch (isSigned) {
        case true:
          return new SignedBigNum(num);
        case false:
          return new UnsignedBigNum(num);
      }
      switch (num.constructor) {
        case Int8Array:
        case Int16Array:
        case Int32Array:
        case BigInt64Array:
          return new SignedBigNum(num);
      }
      if (num.byteLength === 16) {
        return new DecimalBigNum(num);
      }
      return new UnsignedBigNum(num);
    }
    static signed(num) {
      return new SignedBigNum(num);
    }
    static unsigned(num) {
      return new UnsignedBigNum(num);
    }
    static decimal(num) {
      return new DecimalBigNum(num);
    }
    constructor(num, isSigned) {
      return BN.new(num, isSigned);
    }
  }

  // node_modules/apache-arrow/type.mjs
  var _a;
  var _b;
  var _c;
  var _d;
  var _e;
  var _f;
  var _g;
  var _h;
  var _j;
  var _k;
  var _l;
  var _m;
  var _o;
  var _p;
  var _q;
  var _r;
  var _s;
  var _t;
  var _u;
  var _v;
  var _w;
  var _x;

  class DataType {
    static isNull(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.Null;
    }
    static isInt(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.Int;
    }
    static isFloat(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.Float;
    }
    static isBinary(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.Binary;
    }
    static isLargeBinary(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.LargeBinary;
    }
    static isUtf8(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.Utf8;
    }
    static isLargeUtf8(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.LargeUtf8;
    }
    static isBool(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.Bool;
    }
    static isDecimal(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.Decimal;
    }
    static isDate(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.Date;
    }
    static isTime(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.Time;
    }
    static isTimestamp(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.Timestamp;
    }
    static isInterval(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.Interval;
    }
    static isDuration(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.Duration;
    }
    static isList(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.List;
    }
    static isStruct(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.Struct;
    }
    static isUnion(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.Union;
    }
    static isFixedSizeBinary(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.FixedSizeBinary;
    }
    static isFixedSizeList(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.FixedSizeList;
    }
    static isMap(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.Map;
    }
    static isDictionary(x) {
      return (x === null || x === undefined ? undefined : x.typeId) === Type4.Dictionary;
    }
    static isDenseUnion(x) {
      return DataType.isUnion(x) && x.mode === UnionMode.Dense;
    }
    static isSparseUnion(x) {
      return DataType.isUnion(x) && x.mode === UnionMode.Sparse;
    }
    constructor(typeId) {
      this.typeId = typeId;
    }
  }
  _a = Symbol.toStringTag;
  DataType[_a] = ((proto12) => {
    proto12.children = null;
    proto12.ArrayType = Array;
    proto12.OffsetArrayType = Int32Array;
    return proto12[Symbol.toStringTag] = "DataType";
  })(DataType.prototype);

  class Null2 extends DataType {
    constructor() {
      super(Type4.Null);
    }
    toString() {
      return `Null`;
    }
  }
  _b = Symbol.toStringTag;
  Null2[_b] = ((proto12) => proto12[Symbol.toStringTag] = "Null")(Null2.prototype);

  class Int_ extends DataType {
    constructor(isSigned, bitWidth) {
      super(Type4.Int);
      this.isSigned = isSigned;
      this.bitWidth = bitWidth;
    }
    get ArrayType() {
      switch (this.bitWidth) {
        case 8:
          return this.isSigned ? Int8Array : Uint8Array;
        case 16:
          return this.isSigned ? Int16Array : Uint16Array;
        case 32:
          return this.isSigned ? Int32Array : Uint32Array;
        case 64:
          return this.isSigned ? BigInt64Array : BigUint64Array;
      }
      throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
    toString() {
      return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`;
    }
  }
  _c = Symbol.toStringTag;
  Int_[_c] = ((proto12) => {
    proto12.isSigned = null;
    proto12.bitWidth = null;
    return proto12[Symbol.toStringTag] = "Int";
  })(Int_.prototype);
  class Int8 extends Int_ {
    constructor() {
      super(true, 8);
    }
    get ArrayType() {
      return Int8Array;
    }
  }

  class Int16 extends Int_ {
    constructor() {
      super(true, 16);
    }
    get ArrayType() {
      return Int16Array;
    }
  }

  class Int32 extends Int_ {
    constructor() {
      super(true, 32);
    }
    get ArrayType() {
      return Int32Array;
    }
  }

  class Int64 extends Int_ {
    constructor() {
      super(true, 64);
    }
    get ArrayType() {
      return BigInt64Array;
    }
  }

  class Uint8 extends Int_ {
    constructor() {
      super(false, 8);
    }
    get ArrayType() {
      return Uint8Array;
    }
  }

  class Uint16 extends Int_ {
    constructor() {
      super(false, 16);
    }
    get ArrayType() {
      return Uint16Array;
    }
  }

  class Uint32 extends Int_ {
    constructor() {
      super(false, 32);
    }
    get ArrayType() {
      return Uint32Array;
    }
  }

  class Uint64 extends Int_ {
    constructor() {
      super(false, 64);
    }
    get ArrayType() {
      return BigUint64Array;
    }
  }
  Object.defineProperty(Int8.prototype, "ArrayType", { value: Int8Array });
  Object.defineProperty(Int16.prototype, "ArrayType", { value: Int16Array });
  Object.defineProperty(Int32.prototype, "ArrayType", { value: Int32Array });
  Object.defineProperty(Int64.prototype, "ArrayType", { value: BigInt64Array });
  Object.defineProperty(Uint8.prototype, "ArrayType", { value: Uint8Array });
  Object.defineProperty(Uint16.prototype, "ArrayType", { value: Uint16Array });
  Object.defineProperty(Uint32.prototype, "ArrayType", { value: Uint32Array });
  Object.defineProperty(Uint64.prototype, "ArrayType", { value: BigUint64Array });

  class Float extends DataType {
    constructor(precision) {
      super(Type4.Float);
      this.precision = precision;
    }
    get ArrayType() {
      switch (this.precision) {
        case Precision.HALF:
          return Uint16Array;
        case Precision.SINGLE:
          return Float32Array;
        case Precision.DOUBLE:
          return Float64Array;
      }
      throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
    toString() {
      return `Float${this.precision << 5 || 16}`;
    }
  }
  _d = Symbol.toStringTag;
  Float[_d] = ((proto12) => {
    proto12.precision = null;
    return proto12[Symbol.toStringTag] = "Float";
  })(Float.prototype);

  class Float16 extends Float {
    constructor() {
      super(Precision.HALF);
    }
  }

  class Float32 extends Float {
    constructor() {
      super(Precision.SINGLE);
    }
  }

  class Float64 extends Float {
    constructor() {
      super(Precision.DOUBLE);
    }
  }
  Object.defineProperty(Float16.prototype, "ArrayType", { value: Uint16Array });
  Object.defineProperty(Float32.prototype, "ArrayType", { value: Float32Array });
  Object.defineProperty(Float64.prototype, "ArrayType", { value: Float64Array });

  class Binary2 extends DataType {
    constructor() {
      super(Type4.Binary);
    }
    toString() {
      return `Binary`;
    }
  }
  _e = Symbol.toStringTag;
  Binary2[_e] = ((proto12) => {
    proto12.ArrayType = Uint8Array;
    return proto12[Symbol.toStringTag] = "Binary";
  })(Binary2.prototype);

  class LargeBinary2 extends DataType {
    constructor() {
      super(Type4.LargeBinary);
    }
    toString() {
      return `LargeBinary`;
    }
  }
  _f = Symbol.toStringTag;
  LargeBinary2[_f] = ((proto12) => {
    proto12.ArrayType = Uint8Array;
    proto12.OffsetArrayType = BigInt64Array;
    return proto12[Symbol.toStringTag] = "LargeBinary";
  })(LargeBinary2.prototype);

  class Utf82 extends DataType {
    constructor() {
      super(Type4.Utf8);
    }
    toString() {
      return `Utf8`;
    }
  }
  _g = Symbol.toStringTag;
  Utf82[_g] = ((proto12) => {
    proto12.ArrayType = Uint8Array;
    return proto12[Symbol.toStringTag] = "Utf8";
  })(Utf82.prototype);

  class LargeUtf82 extends DataType {
    constructor() {
      super(Type4.LargeUtf8);
    }
    toString() {
      return `LargeUtf8`;
    }
  }
  _h = Symbol.toStringTag;
  LargeUtf82[_h] = ((proto12) => {
    proto12.ArrayType = Uint8Array;
    proto12.OffsetArrayType = BigInt64Array;
    return proto12[Symbol.toStringTag] = "LargeUtf8";
  })(LargeUtf82.prototype);

  class Bool2 extends DataType {
    constructor() {
      super(Type4.Bool);
    }
    toString() {
      return `Bool`;
    }
  }
  _j = Symbol.toStringTag;
  Bool2[_j] = ((proto12) => {
    proto12.ArrayType = Uint8Array;
    return proto12[Symbol.toStringTag] = "Bool";
  })(Bool2.prototype);

  class Decimal2 extends DataType {
    constructor(scale, precision, bitWidth = 128) {
      super(Type4.Decimal);
      this.scale = scale;
      this.precision = precision;
      this.bitWidth = bitWidth;
    }
    toString() {
      return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`;
    }
  }
  _k = Symbol.toStringTag;
  Decimal2[_k] = ((proto12) => {
    proto12.scale = null;
    proto12.precision = null;
    proto12.ArrayType = Uint32Array;
    return proto12[Symbol.toStringTag] = "Decimal";
  })(Decimal2.prototype);

  class Date_ extends DataType {
    constructor(unit) {
      super(Type4.Date);
      this.unit = unit;
    }
    toString() {
      return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;
    }
    get ArrayType() {
      return this.unit === DateUnit.DAY ? Int32Array : BigInt64Array;
    }
  }
  _l = Symbol.toStringTag;
  Date_[_l] = ((proto12) => {
    proto12.unit = null;
    return proto12[Symbol.toStringTag] = "Date";
  })(Date_.prototype);
  class Time_ extends DataType {
    constructor(unit, bitWidth) {
      super(Type4.Time);
      this.unit = unit;
      this.bitWidth = bitWidth;
    }
    toString() {
      return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;
    }
    get ArrayType() {
      switch (this.bitWidth) {
        case 32:
          return Int32Array;
        case 64:
          return BigInt64Array;
      }
      throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
  }
  _m = Symbol.toStringTag;
  Time_[_m] = ((proto12) => {
    proto12.unit = null;
    proto12.bitWidth = null;
    return proto12[Symbol.toStringTag] = "Time";
  })(Time_.prototype);
  class Timestamp_ extends DataType {
    constructor(unit, timezone) {
      super(Type4.Timestamp);
      this.unit = unit;
      this.timezone = timezone;
    }
    toString() {
      return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;
    }
  }
  _o = Symbol.toStringTag;
  Timestamp_[_o] = ((proto12) => {
    proto12.unit = null;
    proto12.timezone = null;
    proto12.ArrayType = BigInt64Array;
    return proto12[Symbol.toStringTag] = "Timestamp";
  })(Timestamp_.prototype);
  class Interval_ extends DataType {
    constructor(unit) {
      super(Type4.Interval);
      this.unit = unit;
    }
    toString() {
      return `Interval<${IntervalUnit[this.unit]}>`;
    }
  }
  _p = Symbol.toStringTag;
  Interval_[_p] = ((proto12) => {
    proto12.unit = null;
    proto12.ArrayType = Int32Array;
    return proto12[Symbol.toStringTag] = "Interval";
  })(Interval_.prototype);
  class Duration2 extends DataType {
    constructor(unit) {
      super(Type4.Duration);
      this.unit = unit;
    }
    toString() {
      return `Duration<${TimeUnit[this.unit]}>`;
    }
  }
  _q = Symbol.toStringTag;
  Duration2[_q] = ((proto12) => {
    proto12.unit = null;
    proto12.ArrayType = BigInt64Array;
    return proto12[Symbol.toStringTag] = "Duration";
  })(Duration2.prototype);
  class List2 extends DataType {
    constructor(child) {
      super(Type4.List);
      this.children = [child];
    }
    toString() {
      return `List<${this.valueType}>`;
    }
    get valueType() {
      return this.children[0].type;
    }
    get valueField() {
      return this.children[0];
    }
    get ArrayType() {
      return this.valueType.ArrayType;
    }
  }
  _r = Symbol.toStringTag;
  List2[_r] = ((proto12) => {
    proto12.children = null;
    return proto12[Symbol.toStringTag] = "List";
  })(List2.prototype);

  class Struct2 extends DataType {
    constructor(children2) {
      super(Type4.Struct);
      this.children = children2;
    }
    toString() {
      return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
    }
  }
  _s = Symbol.toStringTag;
  Struct2[_s] = ((proto12) => {
    proto12.children = null;
    return proto12[Symbol.toStringTag] = "Struct";
  })(Struct2.prototype);

  class Union_ extends DataType {
    constructor(mode, typeIds, children2) {
      super(Type4.Union);
      this.mode = mode;
      this.children = children2;
      this.typeIds = typeIds = Int32Array.from(typeIds);
      this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, Object.create(null));
    }
    toString() {
      return `${this[Symbol.toStringTag]}<${this.children.map((x) => `${x.type}`).join(` | `)}>`;
    }
  }
  _t = Symbol.toStringTag;
  Union_[_t] = ((proto12) => {
    proto12.mode = null;
    proto12.typeIds = null;
    proto12.children = null;
    proto12.typeIdToChildIndex = null;
    proto12.ArrayType = Int8Array;
    return proto12[Symbol.toStringTag] = "Union";
  })(Union_.prototype);
  class FixedSizeBinary2 extends DataType {
    constructor(byteWidth) {
      super(Type4.FixedSizeBinary);
      this.byteWidth = byteWidth;
    }
    toString() {
      return `FixedSizeBinary[${this.byteWidth}]`;
    }
  }
  _u = Symbol.toStringTag;
  FixedSizeBinary2[_u] = ((proto12) => {
    proto12.byteWidth = null;
    proto12.ArrayType = Uint8Array;
    return proto12[Symbol.toStringTag] = "FixedSizeBinary";
  })(FixedSizeBinary2.prototype);

  class FixedSizeList2 extends DataType {
    constructor(listSize, child) {
      super(Type4.FixedSizeList);
      this.listSize = listSize;
      this.children = [child];
    }
    get valueType() {
      return this.children[0].type;
    }
    get valueField() {
      return this.children[0];
    }
    get ArrayType() {
      return this.valueType.ArrayType;
    }
    toString() {
      return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
    }
  }
  _v = Symbol.toStringTag;
  FixedSizeList2[_v] = ((proto12) => {
    proto12.children = null;
    proto12.listSize = null;
    return proto12[Symbol.toStringTag] = "FixedSizeList";
  })(FixedSizeList2.prototype);

  class Map_ extends DataType {
    constructor(entries2, keysSorted = false) {
      var _y, _z, _0;
      super(Type4.Map);
      this.children = [entries2];
      this.keysSorted = keysSorted;
      if (entries2) {
        entries2["name"] = "entries";
        if ((_y = entries2 === null || entries2 === undefined ? undefined : entries2.type) === null || _y === undefined ? undefined : _y.children) {
          const key = (_z = entries2 === null || entries2 === undefined ? undefined : entries2.type) === null || _z === undefined ? undefined : _z.children[0];
          if (key) {
            key["name"] = "key";
          }
          const val = (_0 = entries2 === null || entries2 === undefined ? undefined : entries2.type) === null || _0 === undefined ? undefined : _0.children[1];
          if (val) {
            val["name"] = "value";
          }
        }
      }
    }
    get keyType() {
      return this.children[0].type.children[0].type;
    }
    get valueType() {
      return this.children[0].type.children[1].type;
    }
    get childType() {
      return this.children[0].type;
    }
    toString() {
      return `Map<{${this.children[0].type.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
    }
  }
  _w = Symbol.toStringTag;
  Map_[_w] = ((proto12) => {
    proto12.children = null;
    proto12.keysSorted = null;
    return proto12[Symbol.toStringTag] = "Map_";
  })(Map_.prototype);
  var getId = ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);

  class Dictionary extends DataType {
    constructor(dictionary, indices, id2, isOrdered) {
      super(Type4.Dictionary);
      this.indices = indices;
      this.dictionary = dictionary;
      this.isOrdered = isOrdered || false;
      this.id = id2 == null ? getId() : bigIntToNumber(id2);
    }
    get children() {
      return this.dictionary.children;
    }
    get valueType() {
      return this.dictionary;
    }
    get ArrayType() {
      return this.dictionary.ArrayType;
    }
    toString() {
      return `Dictionary<${this.indices}, ${this.dictionary}>`;
    }
  }
  _x = Symbol.toStringTag;
  Dictionary[_x] = ((proto12) => {
    proto12.id = null;
    proto12.indices = null;
    proto12.isOrdered = null;
    proto12.dictionary = null;
    return proto12[Symbol.toStringTag] = "Dictionary";
  })(Dictionary.prototype);
  function strideForType(type) {
    const t = type;
    switch (type.typeId) {
      case Type4.Decimal:
        return type.bitWidth / 32;
      case Type4.Interval: {
        if (t.unit === IntervalUnit.MONTH_DAY_NANO) {
          return 4;
        }
        return 1 + t.unit;
      }
      case Type4.FixedSizeList:
        return t.listSize;
      case Type4.FixedSizeBinary:
        return t.byteWidth;
      default:
        return 1;
    }
  }

  // node_modules/apache-arrow/visitor.mjs
  class Visitor {
    visitMany(nodes, ...args2) {
      return nodes.map((node, i2) => this.visit(node, ...args2.map((x) => x[i2])));
    }
    visit(...args2) {
      return this.getVisitFn(args2[0], false).apply(this, args2);
    }
    getVisitFn(node, throwIfNotFound = true) {
      return getVisitFn(this, node, throwIfNotFound);
    }
    getVisitFnByTypeId(typeId, throwIfNotFound = true) {
      return getVisitFnByTypeId(this, typeId, throwIfNotFound);
    }
    visitNull(_node, ..._args) {
      return null;
    }
    visitBool(_node, ..._args) {
      return null;
    }
    visitInt(_node, ..._args) {
      return null;
    }
    visitFloat(_node, ..._args) {
      return null;
    }
    visitUtf8(_node, ..._args) {
      return null;
    }
    visitLargeUtf8(_node, ..._args) {
      return null;
    }
    visitBinary(_node, ..._args) {
      return null;
    }
    visitLargeBinary(_node, ..._args) {
      return null;
    }
    visitFixedSizeBinary(_node, ..._args) {
      return null;
    }
    visitDate(_node, ..._args) {
      return null;
    }
    visitTimestamp(_node, ..._args) {
      return null;
    }
    visitTime(_node, ..._args) {
      return null;
    }
    visitDecimal(_node, ..._args) {
      return null;
    }
    visitList(_node, ..._args) {
      return null;
    }
    visitStruct(_node, ..._args) {
      return null;
    }
    visitUnion(_node, ..._args) {
      return null;
    }
    visitDictionary(_node, ..._args) {
      return null;
    }
    visitInterval(_node, ..._args) {
      return null;
    }
    visitDuration(_node, ..._args) {
      return null;
    }
    visitFixedSizeList(_node, ..._args) {
      return null;
    }
    visitMap(_node, ..._args) {
      return null;
    }
  }
  function getVisitFn(visitor, node, throwIfNotFound = true) {
    if (typeof node === "number") {
      return getVisitFnByTypeId(visitor, node, throwIfNotFound);
    }
    if (typeof node === "string" && node in Type4) {
      return getVisitFnByTypeId(visitor, Type4[node], throwIfNotFound);
    }
    if (node && node instanceof DataType) {
      return getVisitFnByTypeId(visitor, inferDType(node), throwIfNotFound);
    }
    if ((node === null || node === undefined ? undefined : node.type) && node.type instanceof DataType) {
      return getVisitFnByTypeId(visitor, inferDType(node.type), throwIfNotFound);
    }
    return getVisitFnByTypeId(visitor, Type4.NONE, throwIfNotFound);
  }
  function getVisitFnByTypeId(visitor, dtype, throwIfNotFound = true) {
    let fn2 = null;
    switch (dtype) {
      case Type4.Null:
        fn2 = visitor.visitNull;
        break;
      case Type4.Bool:
        fn2 = visitor.visitBool;
        break;
      case Type4.Int:
        fn2 = visitor.visitInt;
        break;
      case Type4.Int8:
        fn2 = visitor.visitInt8 || visitor.visitInt;
        break;
      case Type4.Int16:
        fn2 = visitor.visitInt16 || visitor.visitInt;
        break;
      case Type4.Int32:
        fn2 = visitor.visitInt32 || visitor.visitInt;
        break;
      case Type4.Int64:
        fn2 = visitor.visitInt64 || visitor.visitInt;
        break;
      case Type4.Uint8:
        fn2 = visitor.visitUint8 || visitor.visitInt;
        break;
      case Type4.Uint16:
        fn2 = visitor.visitUint16 || visitor.visitInt;
        break;
      case Type4.Uint32:
        fn2 = visitor.visitUint32 || visitor.visitInt;
        break;
      case Type4.Uint64:
        fn2 = visitor.visitUint64 || visitor.visitInt;
        break;
      case Type4.Float:
        fn2 = visitor.visitFloat;
        break;
      case Type4.Float16:
        fn2 = visitor.visitFloat16 || visitor.visitFloat;
        break;
      case Type4.Float32:
        fn2 = visitor.visitFloat32 || visitor.visitFloat;
        break;
      case Type4.Float64:
        fn2 = visitor.visitFloat64 || visitor.visitFloat;
        break;
      case Type4.Utf8:
        fn2 = visitor.visitUtf8;
        break;
      case Type4.LargeUtf8:
        fn2 = visitor.visitLargeUtf8;
        break;
      case Type4.Binary:
        fn2 = visitor.visitBinary;
        break;
      case Type4.LargeBinary:
        fn2 = visitor.visitLargeBinary;
        break;
      case Type4.FixedSizeBinary:
        fn2 = visitor.visitFixedSizeBinary;
        break;
      case Type4.Date:
        fn2 = visitor.visitDate;
        break;
      case Type4.DateDay:
        fn2 = visitor.visitDateDay || visitor.visitDate;
        break;
      case Type4.DateMillisecond:
        fn2 = visitor.visitDateMillisecond || visitor.visitDate;
        break;
      case Type4.Timestamp:
        fn2 = visitor.visitTimestamp;
        break;
      case Type4.TimestampSecond:
        fn2 = visitor.visitTimestampSecond || visitor.visitTimestamp;
        break;
      case Type4.TimestampMillisecond:
        fn2 = visitor.visitTimestampMillisecond || visitor.visitTimestamp;
        break;
      case Type4.TimestampMicrosecond:
        fn2 = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;
        break;
      case Type4.TimestampNanosecond:
        fn2 = visitor.visitTimestampNanosecond || visitor.visitTimestamp;
        break;
      case Type4.Time:
        fn2 = visitor.visitTime;
        break;
      case Type4.TimeSecond:
        fn2 = visitor.visitTimeSecond || visitor.visitTime;
        break;
      case Type4.TimeMillisecond:
        fn2 = visitor.visitTimeMillisecond || visitor.visitTime;
        break;
      case Type4.TimeMicrosecond:
        fn2 = visitor.visitTimeMicrosecond || visitor.visitTime;
        break;
      case Type4.TimeNanosecond:
        fn2 = visitor.visitTimeNanosecond || visitor.visitTime;
        break;
      case Type4.Decimal:
        fn2 = visitor.visitDecimal;
        break;
      case Type4.List:
        fn2 = visitor.visitList;
        break;
      case Type4.Struct:
        fn2 = visitor.visitStruct;
        break;
      case Type4.Union:
        fn2 = visitor.visitUnion;
        break;
      case Type4.DenseUnion:
        fn2 = visitor.visitDenseUnion || visitor.visitUnion;
        break;
      case Type4.SparseUnion:
        fn2 = visitor.visitSparseUnion || visitor.visitUnion;
        break;
      case Type4.Dictionary:
        fn2 = visitor.visitDictionary;
        break;
      case Type4.Interval:
        fn2 = visitor.visitInterval;
        break;
      case Type4.IntervalDayTime:
        fn2 = visitor.visitIntervalDayTime || visitor.visitInterval;
        break;
      case Type4.IntervalYearMonth:
        fn2 = visitor.visitIntervalYearMonth || visitor.visitInterval;
        break;
      case Type4.IntervalMonthDayNano:
        fn2 = visitor.visitIntervalMonthDayNano || visitor.visitInterval;
        break;
      case Type4.Duration:
        fn2 = visitor.visitDuration;
        break;
      case Type4.DurationSecond:
        fn2 = visitor.visitDurationSecond || visitor.visitDuration;
        break;
      case Type4.DurationMillisecond:
        fn2 = visitor.visitDurationMillisecond || visitor.visitDuration;
        break;
      case Type4.DurationMicrosecond:
        fn2 = visitor.visitDurationMicrosecond || visitor.visitDuration;
        break;
      case Type4.DurationNanosecond:
        fn2 = visitor.visitDurationNanosecond || visitor.visitDuration;
        break;
      case Type4.FixedSizeList:
        fn2 = visitor.visitFixedSizeList;
        break;
      case Type4.Map:
        fn2 = visitor.visitMap;
        break;
    }
    if (typeof fn2 === "function")
      return fn2;
    if (!throwIfNotFound)
      return () => null;
    throw new Error(`Unrecognized type '${Type4[dtype]}'`);
  }
  function inferDType(type) {
    switch (type.typeId) {
      case Type4.Null:
        return Type4.Null;
      case Type4.Int: {
        const { bitWidth, isSigned } = type;
        switch (bitWidth) {
          case 8:
            return isSigned ? Type4.Int8 : Type4.Uint8;
          case 16:
            return isSigned ? Type4.Int16 : Type4.Uint16;
          case 32:
            return isSigned ? Type4.Int32 : Type4.Uint32;
          case 64:
            return isSigned ? Type4.Int64 : Type4.Uint64;
        }
        return Type4.Int;
      }
      case Type4.Float:
        switch (type.precision) {
          case Precision.HALF:
            return Type4.Float16;
          case Precision.SINGLE:
            return Type4.Float32;
          case Precision.DOUBLE:
            return Type4.Float64;
        }
        return Type4.Float;
      case Type4.Binary:
        return Type4.Binary;
      case Type4.LargeBinary:
        return Type4.LargeBinary;
      case Type4.Utf8:
        return Type4.Utf8;
      case Type4.LargeUtf8:
        return Type4.LargeUtf8;
      case Type4.Bool:
        return Type4.Bool;
      case Type4.Decimal:
        return Type4.Decimal;
      case Type4.Time:
        switch (type.unit) {
          case TimeUnit.SECOND:
            return Type4.TimeSecond;
          case TimeUnit.MILLISECOND:
            return Type4.TimeMillisecond;
          case TimeUnit.MICROSECOND:
            return Type4.TimeMicrosecond;
          case TimeUnit.NANOSECOND:
            return Type4.TimeNanosecond;
        }
        return Type4.Time;
      case Type4.Timestamp:
        switch (type.unit) {
          case TimeUnit.SECOND:
            return Type4.TimestampSecond;
          case TimeUnit.MILLISECOND:
            return Type4.TimestampMillisecond;
          case TimeUnit.MICROSECOND:
            return Type4.TimestampMicrosecond;
          case TimeUnit.NANOSECOND:
            return Type4.TimestampNanosecond;
        }
        return Type4.Timestamp;
      case Type4.Date:
        switch (type.unit) {
          case DateUnit.DAY:
            return Type4.DateDay;
          case DateUnit.MILLISECOND:
            return Type4.DateMillisecond;
        }
        return Type4.Date;
      case Type4.Interval:
        switch (type.unit) {
          case IntervalUnit.DAY_TIME:
            return Type4.IntervalDayTime;
          case IntervalUnit.YEAR_MONTH:
            return Type4.IntervalYearMonth;
          case IntervalUnit.MONTH_DAY_NANO:
            return Type4.IntervalMonthDayNano;
        }
        return Type4.Interval;
      case Type4.Duration:
        switch (type.unit) {
          case TimeUnit.SECOND:
            return Type4.DurationSecond;
          case TimeUnit.MILLISECOND:
            return Type4.DurationMillisecond;
          case TimeUnit.MICROSECOND:
            return Type4.DurationMicrosecond;
          case TimeUnit.NANOSECOND:
            return Type4.DurationNanosecond;
        }
        return Type4.Duration;
      case Type4.Map:
        return Type4.Map;
      case Type4.List:
        return Type4.List;
      case Type4.Struct:
        return Type4.Struct;
      case Type4.Union:
        switch (type.mode) {
          case UnionMode.Dense:
            return Type4.DenseUnion;
          case UnionMode.Sparse:
            return Type4.SparseUnion;
        }
        return Type4.Union;
      case Type4.FixedSizeBinary:
        return Type4.FixedSizeBinary;
      case Type4.FixedSizeList:
        return Type4.FixedSizeList;
      case Type4.Dictionary:
        return Type4.Dictionary;
    }
    throw new Error(`Unrecognized type '${Type4[type.typeId]}'`);
  }
  Visitor.prototype.visitInt8 = null;
  Visitor.prototype.visitInt16 = null;
  Visitor.prototype.visitInt32 = null;
  Visitor.prototype.visitInt64 = null;
  Visitor.prototype.visitUint8 = null;
  Visitor.prototype.visitUint16 = null;
  Visitor.prototype.visitUint32 = null;
  Visitor.prototype.visitUint64 = null;
  Visitor.prototype.visitFloat16 = null;
  Visitor.prototype.visitFloat32 = null;
  Visitor.prototype.visitFloat64 = null;
  Visitor.prototype.visitDateDay = null;
  Visitor.prototype.visitDateMillisecond = null;
  Visitor.prototype.visitTimestampSecond = null;
  Visitor.prototype.visitTimestampMillisecond = null;
  Visitor.prototype.visitTimestampMicrosecond = null;
  Visitor.prototype.visitTimestampNanosecond = null;
  Visitor.prototype.visitTimeSecond = null;
  Visitor.prototype.visitTimeMillisecond = null;
  Visitor.prototype.visitTimeMicrosecond = null;
  Visitor.prototype.visitTimeNanosecond = null;
  Visitor.prototype.visitDenseUnion = null;
  Visitor.prototype.visitSparseUnion = null;
  Visitor.prototype.visitIntervalDayTime = null;
  Visitor.prototype.visitIntervalYearMonth = null;
  Visitor.prototype.visitIntervalMonthDayNano = null;
  Visitor.prototype.visitDuration = null;
  Visitor.prototype.visitDurationSecond = null;
  Visitor.prototype.visitDurationMillisecond = null;
  Visitor.prototype.visitDurationMicrosecond = null;
  Visitor.prototype.visitDurationNanosecond = null;

  // node_modules/apache-arrow/util/math.mjs
  var exports_math = {};
  __export(exports_math, {
    uint16ToFloat64: () => uint16ToFloat64,
    float64ToUint16: () => float64ToUint16
  });
  var f64 = new Float64Array(1);
  var u32 = new Uint32Array(f64.buffer);
  function uint16ToFloat64(h) {
    const expo = (h & 31744) >> 10;
    const sigf = (h & 1023) / 1024;
    const sign = Math.pow(-1, (h & 32768) >> 15);
    switch (expo) {
      case 31:
        return sign * (sigf ? Number.NaN : 1 / 0);
      case 0:
        return sign * (sigf ? 0.00006103515625 * sigf : 0);
    }
    return sign * Math.pow(2, expo - 15) * (1 + sigf);
  }
  function float64ToUint16(d) {
    if (d !== d) {
      return 32256;
    }
    f64[0] = d;
    const sign = (u32[1] & 2147483648) >> 16 & 65535;
    let expo = u32[1] & 2146435072, sigf = 0;
    if (expo >= 1089470464) {
      if (u32[0] > 0) {
        expo = 31744;
      } else {
        expo = (expo & 2080374784) >> 16;
        sigf = (u32[1] & 1048575) >> 10;
      }
    } else if (expo <= 1056964608) {
      sigf = 1048576 + (u32[1] & 1048575);
      sigf = 1048576 + (sigf << (expo >> 20) - 998) >> 21;
      expo = 0;
    } else {
      expo = expo - 1056964608 >> 10;
      sigf = (u32[1] & 1048575) + 512 >> 10;
    }
    return sign | expo | sigf & 65535;
  }

  // node_modules/apache-arrow/visitor/set.mjs
  class SetVisitor extends Visitor {
  }
  function wrapSet(fn2) {
    return (data, _1, _2) => {
      if (data.setValid(_1, _2 != null)) {
        return fn2(data, _1, _2);
      }
    };
  }
  var setEpochMsToDays = (data, index, epochMs) => {
    data[index] = Math.floor(epochMs / 86400000);
  };
  var setVariableWidthBytes = (values3, valueOffsets, index, value) => {
    if (index + 1 < valueOffsets.length) {
      const x = bigIntToNumber(valueOffsets[index]);
      const y = bigIntToNumber(valueOffsets[index + 1]);
      values3.set(value.subarray(0, y - x), x);
    }
  };
  var setBool = ({ offset, values: values3 }, index, val) => {
    const idx = offset + index;
    val ? values3[idx >> 3] |= 1 << idx % 8 : values3[idx >> 3] &= ~(1 << idx % 8);
  };
  var setInt = ({ values: values3 }, index, value) => {
    values3[index] = value;
  };
  var setFloat = ({ values: values3 }, index, value) => {
    values3[index] = value;
  };
  var setFloat16 = ({ values: values3 }, index, value) => {
    values3[index] = float64ToUint16(value);
  };
  var setAnyFloat = (data, index, value) => {
    switch (data.type.precision) {
      case Precision.HALF:
        return setFloat16(data, index, value);
      case Precision.SINGLE:
      case Precision.DOUBLE:
        return setFloat(data, index, value);
    }
  };
  var setDateDay = ({ values: values3 }, index, value) => {
    setEpochMsToDays(values3, index, value.valueOf());
  };
  var setDateMillisecond = ({ values: values3 }, index, value) => {
    values3[index] = BigInt(value);
  };
  var setFixedSizeBinary = ({ stride, values: values3 }, index, value) => {
    values3.set(value.subarray(0, stride), stride * index);
  };
  var setBinary = ({ values: values3, valueOffsets }, index, value) => setVariableWidthBytes(values3, valueOffsets, index, value);
  var setUtf8 = ({ values: values3, valueOffsets }, index, value) => setVariableWidthBytes(values3, valueOffsets, index, encodeUtf8(value));
  var setDate = (data, index, value) => {
    data.type.unit === DateUnit.DAY ? setDateDay(data, index, value) : setDateMillisecond(data, index, value);
  };
  var setTimestampSecond = ({ values: values3 }, index, value) => {
    values3[index] = BigInt(value / 1000);
  };
  var setTimestampMillisecond = ({ values: values3 }, index, value) => {
    values3[index] = BigInt(value);
  };
  var setTimestampMicrosecond = ({ values: values3 }, index, value) => {
    values3[index] = BigInt(value * 1000);
  };
  var setTimestampNanosecond = ({ values: values3 }, index, value) => {
    values3[index] = BigInt(value * 1e6);
  };
  var setTimestamp = (data, index, value) => {
    switch (data.type.unit) {
      case TimeUnit.SECOND:
        return setTimestampSecond(data, index, value);
      case TimeUnit.MILLISECOND:
        return setTimestampMillisecond(data, index, value);
      case TimeUnit.MICROSECOND:
        return setTimestampMicrosecond(data, index, value);
      case TimeUnit.NANOSECOND:
        return setTimestampNanosecond(data, index, value);
    }
  };
  var setTimeSecond = ({ values: values3 }, index, value) => {
    values3[index] = value;
  };
  var setTimeMillisecond = ({ values: values3 }, index, value) => {
    values3[index] = value;
  };
  var setTimeMicrosecond = ({ values: values3 }, index, value) => {
    values3[index] = value;
  };
  var setTimeNanosecond = ({ values: values3 }, index, value) => {
    values3[index] = value;
  };
  var setTime = (data, index, value) => {
    switch (data.type.unit) {
      case TimeUnit.SECOND:
        return setTimeSecond(data, index, value);
      case TimeUnit.MILLISECOND:
        return setTimeMillisecond(data, index, value);
      case TimeUnit.MICROSECOND:
        return setTimeMicrosecond(data, index, value);
      case TimeUnit.NANOSECOND:
        return setTimeNanosecond(data, index, value);
    }
  };
  var setDecimal = ({ values: values3, stride }, index, value) => {
    values3.set(value.subarray(0, stride), stride * index);
  };
  var setList = (data, index, value) => {
    const values3 = data.children[0];
    const valueOffsets = data.valueOffsets;
    const set8 = instance.getVisitFn(values3);
    if (Array.isArray(value)) {
      for (let idx = -1, itr = valueOffsets[index], end6 = valueOffsets[index + 1];itr < end6; ) {
        set8(values3, itr++, value[++idx]);
      }
    } else {
      for (let idx = -1, itr = valueOffsets[index], end6 = valueOffsets[index + 1];itr < end6; ) {
        set8(values3, itr++, value.get(++idx));
      }
    }
  };
  var setMap = (data, index, value) => {
    const values3 = data.children[0];
    const { valueOffsets } = data;
    const set8 = instance.getVisitFn(values3);
    let { [index]: idx, [index + 1]: end6 } = valueOffsets;
    const entries2 = value instanceof Map ? value.entries() : Object.entries(value);
    for (const val of entries2) {
      set8(values3, idx, val);
      if (++idx >= end6)
        break;
    }
  };
  var _setStructArrayValue = (o, v) => (set8, c, _, i2) => c && set8(c, o, v[i2]);
  var _setStructVectorValue = (o, v) => (set8, c, _, i2) => c && set8(c, o, v.get(i2));
  var _setStructMapValue = (o, v) => (set8, c, f, _) => c && set8(c, o, v.get(f.name));
  var _setStructObjectValue = (o, v) => (set8, c, f, _) => c && set8(c, o, v[f.name]);
  var setStruct = (data, index, value) => {
    const childSetters = data.type.children.map((f) => instance.getVisitFn(f.type));
    const set8 = value instanceof Map ? _setStructMapValue(index, value) : value instanceof Vector ? _setStructVectorValue(index, value) : Array.isArray(value) ? _setStructArrayValue(index, value) : _setStructObjectValue(index, value);
    data.type.children.forEach((f, i2) => set8(childSetters[i2], data.children[i2], f, i2));
  };
  var setUnion = (data, index, value) => {
    data.type.mode === UnionMode.Dense ? setDenseUnion(data, index, value) : setSparseUnion(data, index, value);
  };
  var setDenseUnion = (data, index, value) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    instance.visit(child, data.valueOffsets[index], value);
  };
  var setSparseUnion = (data, index, value) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    instance.visit(child, index, value);
  };
  var setDictionary = (data, index, value) => {
    var _a2;
    (_a2 = data.dictionary) === null || _a2 === undefined || _a2.set(data.values[index], value);
  };
  var setIntervalValue = (data, index, value) => {
    switch (data.type.unit) {
      case IntervalUnit.YEAR_MONTH:
        return setIntervalYearMonth(data, index, value);
      case IntervalUnit.DAY_TIME:
        return setIntervalDayTime(data, index, value);
      case IntervalUnit.MONTH_DAY_NANO:
        return setIntervalMonthDayNano(data, index, value);
    }
  };
  var setIntervalDayTime = ({ values: values3 }, index, value) => {
    values3.set(value.subarray(0, 2), 2 * index);
  };
  var setIntervalYearMonth = ({ values: values3 }, index, value) => {
    values3[index] = value[0] * 12 + value[1] % 12;
  };
  var setIntervalMonthDayNano = ({ values: values3, stride }, index, value) => {
    values3.set(value.subarray(0, stride), stride * index);
  };
  var setDurationSecond = ({ values: values3 }, index, value) => {
    values3[index] = value;
  };
  var setDurationMillisecond = ({ values: values3 }, index, value) => {
    values3[index] = value;
  };
  var setDurationMicrosecond = ({ values: values3 }, index, value) => {
    values3[index] = value;
  };
  var setDurationNanosecond = ({ values: values3 }, index, value) => {
    values3[index] = value;
  };
  var setDuration = (data, index, value) => {
    switch (data.type.unit) {
      case TimeUnit.SECOND:
        return setDurationSecond(data, index, value);
      case TimeUnit.MILLISECOND:
        return setDurationMillisecond(data, index, value);
      case TimeUnit.MICROSECOND:
        return setDurationMicrosecond(data, index, value);
      case TimeUnit.NANOSECOND:
        return setDurationNanosecond(data, index, value);
    }
  };
  var setFixedSizeList = (data, index, value) => {
    const { stride } = data;
    const child = data.children[0];
    const set8 = instance.getVisitFn(child);
    if (Array.isArray(value)) {
      for (let idx = -1, offset = index * stride;++idx < stride; ) {
        set8(child, offset + idx, value[idx]);
      }
    } else {
      for (let idx = -1, offset = index * stride;++idx < stride; ) {
        set8(child, offset + idx, value.get(idx));
      }
    }
  };
  SetVisitor.prototype.visitBool = wrapSet(setBool);
  SetVisitor.prototype.visitInt = wrapSet(setInt);
  SetVisitor.prototype.visitInt8 = wrapSet(setInt);
  SetVisitor.prototype.visitInt16 = wrapSet(setInt);
  SetVisitor.prototype.visitInt32 = wrapSet(setInt);
  SetVisitor.prototype.visitInt64 = wrapSet(setInt);
  SetVisitor.prototype.visitUint8 = wrapSet(setInt);
  SetVisitor.prototype.visitUint16 = wrapSet(setInt);
  SetVisitor.prototype.visitUint32 = wrapSet(setInt);
  SetVisitor.prototype.visitUint64 = wrapSet(setInt);
  SetVisitor.prototype.visitFloat = wrapSet(setAnyFloat);
  SetVisitor.prototype.visitFloat16 = wrapSet(setFloat16);
  SetVisitor.prototype.visitFloat32 = wrapSet(setFloat);
  SetVisitor.prototype.visitFloat64 = wrapSet(setFloat);
  SetVisitor.prototype.visitUtf8 = wrapSet(setUtf8);
  SetVisitor.prototype.visitLargeUtf8 = wrapSet(setUtf8);
  SetVisitor.prototype.visitBinary = wrapSet(setBinary);
  SetVisitor.prototype.visitLargeBinary = wrapSet(setBinary);
  SetVisitor.prototype.visitFixedSizeBinary = wrapSet(setFixedSizeBinary);
  SetVisitor.prototype.visitDate = wrapSet(setDate);
  SetVisitor.prototype.visitDateDay = wrapSet(setDateDay);
  SetVisitor.prototype.visitDateMillisecond = wrapSet(setDateMillisecond);
  SetVisitor.prototype.visitTimestamp = wrapSet(setTimestamp);
  SetVisitor.prototype.visitTimestampSecond = wrapSet(setTimestampSecond);
  SetVisitor.prototype.visitTimestampMillisecond = wrapSet(setTimestampMillisecond);
  SetVisitor.prototype.visitTimestampMicrosecond = wrapSet(setTimestampMicrosecond);
  SetVisitor.prototype.visitTimestampNanosecond = wrapSet(setTimestampNanosecond);
  SetVisitor.prototype.visitTime = wrapSet(setTime);
  SetVisitor.prototype.visitTimeSecond = wrapSet(setTimeSecond);
  SetVisitor.prototype.visitTimeMillisecond = wrapSet(setTimeMillisecond);
  SetVisitor.prototype.visitTimeMicrosecond = wrapSet(setTimeMicrosecond);
  SetVisitor.prototype.visitTimeNanosecond = wrapSet(setTimeNanosecond);
  SetVisitor.prototype.visitDecimal = wrapSet(setDecimal);
  SetVisitor.prototype.visitList = wrapSet(setList);
  SetVisitor.prototype.visitStruct = wrapSet(setStruct);
  SetVisitor.prototype.visitUnion = wrapSet(setUnion);
  SetVisitor.prototype.visitDenseUnion = wrapSet(setDenseUnion);
  SetVisitor.prototype.visitSparseUnion = wrapSet(setSparseUnion);
  SetVisitor.prototype.visitDictionary = wrapSet(setDictionary);
  SetVisitor.prototype.visitInterval = wrapSet(setIntervalValue);
  SetVisitor.prototype.visitIntervalDayTime = wrapSet(setIntervalDayTime);
  SetVisitor.prototype.visitIntervalYearMonth = wrapSet(setIntervalYearMonth);
  SetVisitor.prototype.visitIntervalMonthDayNano = wrapSet(setIntervalMonthDayNano);
  SetVisitor.prototype.visitDuration = wrapSet(setDuration);
  SetVisitor.prototype.visitDurationSecond = wrapSet(setDurationSecond);
  SetVisitor.prototype.visitDurationMillisecond = wrapSet(setDurationMillisecond);
  SetVisitor.prototype.visitDurationMicrosecond = wrapSet(setDurationMicrosecond);
  SetVisitor.prototype.visitDurationNanosecond = wrapSet(setDurationNanosecond);
  SetVisitor.prototype.visitFixedSizeList = wrapSet(setFixedSizeList);
  SetVisitor.prototype.visitMap = wrapSet(setMap);
  var instance = new SetVisitor;

  // node_modules/apache-arrow/row/struct.mjs
  var kParent = Symbol.for("parent");
  var kRowIndex = Symbol.for("rowIndex");

  class StructRow {
    constructor(parent, rowIndex) {
      this[kParent] = parent;
      this[kRowIndex] = rowIndex;
      return new Proxy(this, structRowProxyHandler);
    }
    toArray() {
      return Object.values(this.toJSON());
    }
    toJSON() {
      const i2 = this[kRowIndex];
      const parent = this[kParent];
      const keys3 = parent.type.children;
      const json = {};
      for (let j = -1, n = keys3.length;++j < n; ) {
        json[keys3[j].name] = instance2.visit(parent.children[j], i2);
      }
      return json;
    }
    toString() {
      return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(", ")}}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.toString();
    }
    [Symbol.iterator]() {
      return new StructRowIterator(this[kParent], this[kRowIndex]);
    }
  }

  class StructRowIterator {
    constructor(data, rowIndex) {
      this.childIndex = 0;
      this.children = data.children;
      this.rowIndex = rowIndex;
      this.childFields = data.type.children;
      this.numChildren = this.childFields.length;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      const i2 = this.childIndex;
      if (i2 < this.numChildren) {
        this.childIndex = i2 + 1;
        return {
          done: false,
          value: [
            this.childFields[i2].name,
            instance2.visit(this.children[i2], this.rowIndex)
          ]
        };
      }
      return { done: true, value: null };
    }
  }
  Object.defineProperties(StructRow.prototype, {
    [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
    [kParent]: { writable: true, enumerable: false, configurable: false, value: null },
    [kRowIndex]: { writable: true, enumerable: false, configurable: false, value: -1 }
  });

  class StructRowProxyHandler {
    isExtensible() {
      return false;
    }
    deleteProperty() {
      return false;
    }
    preventExtensions() {
      return true;
    }
    ownKeys(row) {
      return row[kParent].type.children.map((f) => f.name);
    }
    has(row, key) {
      return row[kParent].type.children.some((f) => f.name === key);
    }
    getOwnPropertyDescriptor(row, key) {
      if (row[kParent].type.children.some((f) => f.name === key)) {
        return { writable: true, enumerable: true, configurable: true };
      }
      return;
    }
    get(row, key) {
      if (Reflect.has(row, key)) {
        return row[key];
      }
      const idx = row[kParent].type.children.findIndex((f) => f.name === key);
      if (idx !== -1) {
        const val = instance2.visit(row[kParent].children[idx], row[kRowIndex]);
        Reflect.set(row, key, val);
        return val;
      }
    }
    set(row, key, val) {
      const idx = row[kParent].type.children.findIndex((f) => f.name === key);
      if (idx !== -1) {
        instance.visit(row[kParent].children[idx], row[kRowIndex], val);
        return Reflect.set(row, key, val);
      } else if (Reflect.has(row, key) || typeof key === "symbol") {
        return Reflect.set(row, key, val);
      }
      return false;
    }
  }
  var structRowProxyHandler = new StructRowProxyHandler;

  // node_modules/apache-arrow/visitor/get.mjs
  class GetVisitor extends Visitor {
  }
  function wrapGet(fn2) {
    return (data, _1) => data.getValid(_1) ? fn2(data, _1) : null;
  }
  var epochDaysToMs = (data, index) => 86400000 * data[index];
  var getNull = (_data, _index) => null;
  var getVariableWidthBytes = (values3, valueOffsets, index) => {
    if (index + 1 >= valueOffsets.length) {
      return null;
    }
    const x = bigIntToNumber(valueOffsets[index]);
    const y = bigIntToNumber(valueOffsets[index + 1]);
    return values3.subarray(x, y);
  };
  var getBool = ({ offset, values: values3 }, index) => {
    const idx = offset + index;
    const byte = values3[idx >> 3];
    return (byte & 1 << idx % 8) !== 0;
  };
  var getDateDay = ({ values: values3 }, index) => epochDaysToMs(values3, index);
  var getDateMillisecond = ({ values: values3 }, index) => bigIntToNumber(values3[index]);
  var getNumeric = ({ stride, values: values3 }, index) => values3[stride * index];
  var getFloat16 = ({ stride, values: values3 }, index) => uint16ToFloat64(values3[stride * index]);
  var getBigInts = ({ values: values3 }, index) => values3[index];
  var getFixedSizeBinary = ({ stride, values: values3 }, index) => values3.subarray(stride * index, stride * (index + 1));
  var getBinary = ({ values: values3, valueOffsets }, index) => getVariableWidthBytes(values3, valueOffsets, index);
  var getUtf8 = ({ values: values3, valueOffsets }, index) => {
    const bytes = getVariableWidthBytes(values3, valueOffsets, index);
    return bytes !== null ? decodeUtf8(bytes) : null;
  };
  var getInt = ({ values: values3 }, index) => values3[index];
  var getFloat = ({ type, values: values3 }, index) => type.precision !== Precision.HALF ? values3[index] : uint16ToFloat64(values3[index]);
  var getDate = (data, index) => data.type.unit === DateUnit.DAY ? getDateDay(data, index) : getDateMillisecond(data, index);
  var getTimestampSecond = ({ values: values3 }, index) => 1000 * bigIntToNumber(values3[index]);
  var getTimestampMillisecond = ({ values: values3 }, index) => bigIntToNumber(values3[index]);
  var getTimestampMicrosecond = ({ values: values3 }, index) => divideBigInts(values3[index], BigInt(1000));
  var getTimestampNanosecond = ({ values: values3 }, index) => divideBigInts(values3[index], BigInt(1e6));
  var getTimestamp = (data, index) => {
    switch (data.type.unit) {
      case TimeUnit.SECOND:
        return getTimestampSecond(data, index);
      case TimeUnit.MILLISECOND:
        return getTimestampMillisecond(data, index);
      case TimeUnit.MICROSECOND:
        return getTimestampMicrosecond(data, index);
      case TimeUnit.NANOSECOND:
        return getTimestampNanosecond(data, index);
    }
  };
  var getTimeSecond = ({ values: values3 }, index) => values3[index];
  var getTimeMillisecond = ({ values: values3 }, index) => values3[index];
  var getTimeMicrosecond = ({ values: values3 }, index) => values3[index];
  var getTimeNanosecond = ({ values: values3 }, index) => values3[index];
  var getTime = (data, index) => {
    switch (data.type.unit) {
      case TimeUnit.SECOND:
        return getTimeSecond(data, index);
      case TimeUnit.MILLISECOND:
        return getTimeMillisecond(data, index);
      case TimeUnit.MICROSECOND:
        return getTimeMicrosecond(data, index);
      case TimeUnit.NANOSECOND:
        return getTimeNanosecond(data, index);
    }
  };
  var getDecimal = ({ values: values3, stride }, index) => BN.decimal(values3.subarray(stride * index, stride * (index + 1)));
  var getList = (data, index) => {
    const { valueOffsets, stride, children: children2 } = data;
    const { [index * stride]: begin, [index * stride + 1]: end6 } = valueOffsets;
    const child = children2[0];
    const slice2 = child.slice(begin, end6 - begin);
    return new Vector([slice2]);
  };
  var getMap = (data, index) => {
    const { valueOffsets, children: children2 } = data;
    const { [index]: begin, [index + 1]: end6 } = valueOffsets;
    const child = children2[0];
    return new MapRow(child.slice(begin, end6 - begin));
  };
  var getStruct = (data, index) => {
    return new StructRow(data, index);
  };
  var getUnion = (data, index) => {
    return data.type.mode === UnionMode.Dense ? getDenseUnion(data, index) : getSparseUnion(data, index);
  };
  var getDenseUnion = (data, index) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    return instance2.visit(child, data.valueOffsets[index]);
  };
  var getSparseUnion = (data, index) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    return instance2.visit(child, index);
  };
  var getDictionary = (data, index) => {
    var _a2;
    return (_a2 = data.dictionary) === null || _a2 === undefined ? undefined : _a2.get(data.values[index]);
  };
  var getInterval = (data, index) => data.type.unit === IntervalUnit.MONTH_DAY_NANO ? getIntervalMonthDayNano(data, index) : data.type.unit === IntervalUnit.DAY_TIME ? getIntervalDayTime(data, index) : getIntervalYearMonth(data, index);
  var getIntervalDayTime = ({ values: values3 }, index) => values3.subarray(2 * index, 2 * (index + 1));
  var getIntervalYearMonth = ({ values: values3 }, index) => {
    const interval = values3[index];
    const int32s = new Int32Array(2);
    int32s[0] = Math.trunc(interval / 12);
    int32s[1] = Math.trunc(interval % 12);
    return int32s;
  };
  var getIntervalMonthDayNano = ({ values: values3 }, index) => values3.subarray(4 * index, 4 * (index + 1));
  var getDurationSecond = ({ values: values3 }, index) => values3[index];
  var getDurationMillisecond = ({ values: values3 }, index) => values3[index];
  var getDurationMicrosecond = ({ values: values3 }, index) => values3[index];
  var getDurationNanosecond = ({ values: values3 }, index) => values3[index];
  var getDuration = (data, index) => {
    switch (data.type.unit) {
      case TimeUnit.SECOND:
        return getDurationSecond(data, index);
      case TimeUnit.MILLISECOND:
        return getDurationMillisecond(data, index);
      case TimeUnit.MICROSECOND:
        return getDurationMicrosecond(data, index);
      case TimeUnit.NANOSECOND:
        return getDurationNanosecond(data, index);
    }
  };
  var getFixedSizeList = (data, index) => {
    const { stride, children: children2 } = data;
    const child = children2[0];
    const slice2 = child.slice(index * stride, stride);
    return new Vector([slice2]);
  };
  GetVisitor.prototype.visitNull = wrapGet(getNull);
  GetVisitor.prototype.visitBool = wrapGet(getBool);
  GetVisitor.prototype.visitInt = wrapGet(getInt);
  GetVisitor.prototype.visitInt8 = wrapGet(getNumeric);
  GetVisitor.prototype.visitInt16 = wrapGet(getNumeric);
  GetVisitor.prototype.visitInt32 = wrapGet(getNumeric);
  GetVisitor.prototype.visitInt64 = wrapGet(getBigInts);
  GetVisitor.prototype.visitUint8 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUint16 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUint32 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUint64 = wrapGet(getBigInts);
  GetVisitor.prototype.visitFloat = wrapGet(getFloat);
  GetVisitor.prototype.visitFloat16 = wrapGet(getFloat16);
  GetVisitor.prototype.visitFloat32 = wrapGet(getNumeric);
  GetVisitor.prototype.visitFloat64 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUtf8 = wrapGet(getUtf8);
  GetVisitor.prototype.visitLargeUtf8 = wrapGet(getUtf8);
  GetVisitor.prototype.visitBinary = wrapGet(getBinary);
  GetVisitor.prototype.visitLargeBinary = wrapGet(getBinary);
  GetVisitor.prototype.visitFixedSizeBinary = wrapGet(getFixedSizeBinary);
  GetVisitor.prototype.visitDate = wrapGet(getDate);
  GetVisitor.prototype.visitDateDay = wrapGet(getDateDay);
  GetVisitor.prototype.visitDateMillisecond = wrapGet(getDateMillisecond);
  GetVisitor.prototype.visitTimestamp = wrapGet(getTimestamp);
  GetVisitor.prototype.visitTimestampSecond = wrapGet(getTimestampSecond);
  GetVisitor.prototype.visitTimestampMillisecond = wrapGet(getTimestampMillisecond);
  GetVisitor.prototype.visitTimestampMicrosecond = wrapGet(getTimestampMicrosecond);
  GetVisitor.prototype.visitTimestampNanosecond = wrapGet(getTimestampNanosecond);
  GetVisitor.prototype.visitTime = wrapGet(getTime);
  GetVisitor.prototype.visitTimeSecond = wrapGet(getTimeSecond);
  GetVisitor.prototype.visitTimeMillisecond = wrapGet(getTimeMillisecond);
  GetVisitor.prototype.visitTimeMicrosecond = wrapGet(getTimeMicrosecond);
  GetVisitor.prototype.visitTimeNanosecond = wrapGet(getTimeNanosecond);
  GetVisitor.prototype.visitDecimal = wrapGet(getDecimal);
  GetVisitor.prototype.visitList = wrapGet(getList);
  GetVisitor.prototype.visitStruct = wrapGet(getStruct);
  GetVisitor.prototype.visitUnion = wrapGet(getUnion);
  GetVisitor.prototype.visitDenseUnion = wrapGet(getDenseUnion);
  GetVisitor.prototype.visitSparseUnion = wrapGet(getSparseUnion);
  GetVisitor.prototype.visitDictionary = wrapGet(getDictionary);
  GetVisitor.prototype.visitInterval = wrapGet(getInterval);
  GetVisitor.prototype.visitIntervalDayTime = wrapGet(getIntervalDayTime);
  GetVisitor.prototype.visitIntervalYearMonth = wrapGet(getIntervalYearMonth);
  GetVisitor.prototype.visitIntervalMonthDayNano = wrapGet(getIntervalMonthDayNano);
  GetVisitor.prototype.visitDuration = wrapGet(getDuration);
  GetVisitor.prototype.visitDurationSecond = wrapGet(getDurationSecond);
  GetVisitor.prototype.visitDurationMillisecond = wrapGet(getDurationMillisecond);
  GetVisitor.prototype.visitDurationMicrosecond = wrapGet(getDurationMicrosecond);
  GetVisitor.prototype.visitDurationNanosecond = wrapGet(getDurationNanosecond);
  GetVisitor.prototype.visitFixedSizeList = wrapGet(getFixedSizeList);
  GetVisitor.prototype.visitMap = wrapGet(getMap);
  var instance2 = new GetVisitor;

  // node_modules/apache-arrow/row/map.mjs
  var kKeys = Symbol.for("keys");
  var kVals = Symbol.for("vals");
  var kKeysAsStrings = Symbol.for("kKeysAsStrings");
  var _kKeysAsStrings = Symbol.for("_kKeysAsStrings");

  class MapRow {
    constructor(slice2) {
      this[kKeys] = new Vector([slice2.children[0]]).memoize();
      this[kVals] = slice2.children[1];
      return new Proxy(this, new MapRowProxyHandler);
    }
    get [kKeysAsStrings]() {
      return this[_kKeysAsStrings] || (this[_kKeysAsStrings] = Array.from(this[kKeys].toArray(), String));
    }
    [Symbol.iterator]() {
      return new MapRowIterator(this[kKeys], this[kVals]);
    }
    get size() {
      return this[kKeys].length;
    }
    toArray() {
      return Object.values(this.toJSON());
    }
    toJSON() {
      const keys3 = this[kKeys];
      const vals = this[kVals];
      const json = {};
      for (let i2 = -1, n = keys3.length;++i2 < n; ) {
        json[keys3.get(i2)] = instance2.visit(vals, i2);
      }
      return json;
    }
    toString() {
      return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(", ")}}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.toString();
    }
  }

  class MapRowIterator {
    constructor(keys3, vals) {
      this.keys = keys3;
      this.vals = vals;
      this.keyIndex = 0;
      this.numKeys = keys3.length;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      const i2 = this.keyIndex;
      if (i2 === this.numKeys) {
        return { done: true, value: null };
      }
      this.keyIndex++;
      return {
        done: false,
        value: [
          this.keys.get(i2),
          instance2.visit(this.vals, i2)
        ]
      };
    }
  }

  class MapRowProxyHandler {
    isExtensible() {
      return false;
    }
    deleteProperty() {
      return false;
    }
    preventExtensions() {
      return true;
    }
    ownKeys(row) {
      return row[kKeysAsStrings];
    }
    has(row, key) {
      return row[kKeysAsStrings].includes(key);
    }
    getOwnPropertyDescriptor(row, key) {
      const idx = row[kKeysAsStrings].indexOf(key);
      if (idx !== -1) {
        return { writable: true, enumerable: true, configurable: true };
      }
      return;
    }
    get(row, key) {
      if (Reflect.has(row, key)) {
        return row[key];
      }
      const idx = row[kKeysAsStrings].indexOf(key);
      if (idx !== -1) {
        const val = instance2.visit(Reflect.get(row, kVals), idx);
        Reflect.set(row, key, val);
        return val;
      }
    }
    set(row, key, val) {
      const idx = row[kKeysAsStrings].indexOf(key);
      if (idx !== -1) {
        instance.visit(Reflect.get(row, kVals), idx, val);
        return Reflect.set(row, key, val);
      } else if (Reflect.has(row, key)) {
        return Reflect.set(row, key, val);
      }
      return false;
    }
  }
  Object.defineProperties(MapRow.prototype, {
    [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
    [kKeys]: { writable: true, enumerable: false, configurable: false, value: null },
    [kVals]: { writable: true, enumerable: false, configurable: false, value: null },
    [_kKeysAsStrings]: { writable: true, enumerable: false, configurable: false, value: null }
  });

  // node_modules/apache-arrow/util/vector.mjs
  var tmp;
  function clampRange(source, begin, end6, then) {
    const { length: len2 = 0 } = source;
    let lhs = typeof begin !== "number" ? 0 : begin;
    let rhs = typeof end6 !== "number" ? len2 : end6;
    lhs < 0 && (lhs = (lhs % len2 + len2) % len2);
    rhs < 0 && (rhs = (rhs % len2 + len2) % len2);
    rhs < lhs && (tmp = lhs, lhs = rhs, rhs = tmp);
    rhs > len2 && (rhs = len2);
    return then ? then(source, lhs, rhs) : [lhs, rhs];
  }
  var wrapIndex = (index, len2) => index < 0 ? len2 + index : index;
  var isNaNFast = (value) => value !== value;
  function createElementComparator(search) {
    const typeofSearch = typeof search;
    if (typeofSearch !== "object" || search === null) {
      if (isNaNFast(search)) {
        return isNaNFast;
      }
      return (value) => value === search;
    }
    if (search instanceof Date) {
      const valueOfSearch = search.valueOf();
      return (value) => value instanceof Date ? value.valueOf() === valueOfSearch : false;
    }
    if (ArrayBuffer.isView(search)) {
      return (value) => value ? compareArrayLike(search, value) : false;
    }
    if (search instanceof Map) {
      return createMapComparator(search);
    }
    if (Array.isArray(search)) {
      return createArrayLikeComparator(search);
    }
    if (search instanceof Vector) {
      return createVectorComparator(search);
    }
    return createObjectComparator(search, true);
  }
  function createArrayLikeComparator(lhs) {
    const comparators = [];
    for (let i2 = -1, n = lhs.length;++i2 < n; ) {
      comparators[i2] = createElementComparator(lhs[i2]);
    }
    return createSubElementsComparator(comparators);
  }
  function createMapComparator(lhs) {
    let i2 = -1;
    const comparators = [];
    for (const v of lhs.values())
      comparators[++i2] = createElementComparator(v);
    return createSubElementsComparator(comparators);
  }
  function createVectorComparator(lhs) {
    const comparators = [];
    for (let i2 = -1, n = lhs.length;++i2 < n; ) {
      comparators[i2] = createElementComparator(lhs.get(i2));
    }
    return createSubElementsComparator(comparators);
  }
  function createObjectComparator(lhs, allowEmpty = false) {
    const keys3 = Object.keys(lhs);
    if (!allowEmpty && keys3.length === 0) {
      return () => false;
    }
    const comparators = [];
    for (let i2 = -1, n = keys3.length;++i2 < n; ) {
      comparators[i2] = createElementComparator(lhs[keys3[i2]]);
    }
    return createSubElementsComparator(comparators, keys3);
  }
  function createSubElementsComparator(comparators, keys3) {
    return (rhs) => {
      if (!rhs || typeof rhs !== "object") {
        return false;
      }
      switch (rhs.constructor) {
        case Array:
          return compareArray(comparators, rhs);
        case Map:
          return compareObject(comparators, rhs, rhs.keys());
        case MapRow:
        case StructRow:
        case Object:
        case undefined:
          return compareObject(comparators, rhs, keys3 || Object.keys(rhs));
      }
      return rhs instanceof Vector ? compareVector(comparators, rhs) : false;
    };
  }
  function compareArray(comparators, arr) {
    const n = comparators.length;
    if (arr.length !== n) {
      return false;
    }
    for (let i2 = -1;++i2 < n; ) {
      if (!comparators[i2](arr[i2])) {
        return false;
      }
    }
    return true;
  }
  function compareVector(comparators, vec) {
    const n = comparators.length;
    if (vec.length !== n) {
      return false;
    }
    for (let i2 = -1;++i2 < n; ) {
      if (!comparators[i2](vec.get(i2))) {
        return false;
      }
    }
    return true;
  }
  function compareObject(comparators, obj, keys3) {
    const lKeyItr = keys3[Symbol.iterator]();
    const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();
    const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();
    let i2 = 0;
    const n = comparators.length;
    let rVal = rValItr.next();
    let lKey = lKeyItr.next();
    let rKey = rKeyItr.next();
    for (;i2 < n && !lKey.done && !rKey.done && !rVal.done; ++i2, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {
      if (lKey.value !== rKey.value || !comparators[i2](rVal.value)) {
        break;
      }
    }
    if (i2 === n && lKey.done && rKey.done && rVal.done) {
      return true;
    }
    lKeyItr.return && lKeyItr.return();
    rKeyItr.return && rKeyItr.return();
    rValItr.return && rValItr.return();
    return false;
  }

  // node_modules/apache-arrow/util/bit.mjs
  var exports_bit = {};
  __export(exports_bit, {
    truncateBitmap: () => truncateBitmap,
    setBool: () => setBool2,
    popcnt_uint32: () => popcnt_uint32,
    popcnt_bit_range: () => popcnt_bit_range,
    popcnt_array: () => popcnt_array,
    packBools: () => packBools,
    getBool: () => getBool2,
    getBit: () => getBit,
    BitIterator: () => BitIterator
  });
  function getBool2(_data, _index, byte, bit) {
    return (byte & 1 << bit) !== 0;
  }
  function getBit(_data, _index, byte, bit) {
    return (byte & 1 << bit) >> bit;
  }
  function setBool2(bytes, index, value) {
    return value ? !!(bytes[index >> 3] |= 1 << index % 8) || true : !(bytes[index >> 3] &= ~(1 << index % 8)) && false;
  }
  function truncateBitmap(offset, length3, bitmap) {
    const alignedSize = bitmap.byteLength + 7 & ~7;
    if (offset > 0 || bitmap.byteLength < alignedSize) {
      const bytes = new Uint8Array(alignedSize);
      bytes.set(offset % 8 === 0 ? bitmap.subarray(offset >> 3) : packBools(new BitIterator(bitmap, offset, length3, null, getBool2)).subarray(0, alignedSize));
      return bytes;
    }
    return bitmap;
  }
  function packBools(values3) {
    const xs = [];
    let i2 = 0, bit = 0, byte = 0;
    for (const value of values3) {
      value && (byte |= 1 << bit);
      if (++bit === 8) {
        xs[i2++] = byte;
        byte = bit = 0;
      }
    }
    if (i2 === 0 || bit > 0) {
      xs[i2++] = byte;
    }
    const b = new Uint8Array(xs.length + 7 & ~7);
    b.set(xs);
    return b;
  }

  class BitIterator {
    constructor(bytes, begin, length3, context9, get17) {
      this.bytes = bytes;
      this.length = length3;
      this.context = context9;
      this.get = get17;
      this.bit = begin % 8;
      this.byteIndex = begin >> 3;
      this.byte = bytes[this.byteIndex++];
      this.index = 0;
    }
    next() {
      if (this.index < this.length) {
        if (this.bit === 8) {
          this.bit = 0;
          this.byte = this.bytes[this.byteIndex++];
        }
        return {
          value: this.get(this.context, this.index++, this.byte, this.bit++)
        };
      }
      return { done: true, value: null };
    }
    [Symbol.iterator]() {
      return this;
    }
  }
  function popcnt_bit_range(data, lhs, rhs) {
    if (rhs - lhs <= 0) {
      return 0;
    }
    if (rhs - lhs < 8) {
      let sum3 = 0;
      for (const bit of new BitIterator(data, lhs, rhs - lhs, data, getBit)) {
        sum3 += bit;
      }
      return sum3;
    }
    const rhsInside = rhs >> 3 << 3;
    const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);
    return popcnt_bit_range(data, lhs, lhsInside) + popcnt_bit_range(data, rhsInside, rhs) + popcnt_array(data, lhsInside >> 3, rhsInside - lhsInside >> 3);
  }
  function popcnt_array(arr, byteOffset, byteLength2) {
    let cnt = 0, pos = Math.trunc(byteOffset);
    const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    const len2 = byteLength2 === undefined ? arr.byteLength : pos + byteLength2;
    while (len2 - pos >= 4) {
      cnt += popcnt_uint32(view.getUint32(pos));
      pos += 4;
    }
    while (len2 - pos >= 2) {
      cnt += popcnt_uint32(view.getUint16(pos));
      pos += 2;
    }
    while (len2 - pos >= 1) {
      cnt += popcnt_uint32(view.getUint8(pos));
      pos += 1;
    }
    return cnt;
  }
  function popcnt_uint32(uint32) {
    let i2 = Math.trunc(uint32);
    i2 = i2 - (i2 >>> 1 & 1431655765);
    i2 = (i2 & 858993459) + (i2 >>> 2 & 858993459);
    return (i2 + (i2 >>> 4) & 252645135) * 16843009 >>> 24;
  }

  // node_modules/apache-arrow/data.mjs
  var kUnknownNullCount = -1;

  class Data {
    get typeId() {
      return this.type.typeId;
    }
    get ArrayType() {
      return this.type.ArrayType;
    }
    get buffers() {
      return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
    }
    get nullable() {
      if (this._nullCount !== 0) {
        const { type } = this;
        if (DataType.isSparseUnion(type)) {
          return this.children.some((child) => child.nullable);
        } else if (DataType.isDenseUnion(type)) {
          return this.children.some((child) => child.nullable);
        }
        return this.nullBitmap && this.nullBitmap.byteLength > 0;
      }
      return true;
    }
    get byteLength() {
      let byteLength2 = 0;
      const { valueOffsets, values: values3, nullBitmap, typeIds } = this;
      valueOffsets && (byteLength2 += valueOffsets.byteLength);
      values3 && (byteLength2 += values3.byteLength);
      nullBitmap && (byteLength2 += nullBitmap.byteLength);
      typeIds && (byteLength2 += typeIds.byteLength);
      return this.children.reduce((byteLength3, child) => byteLength3 + child.byteLength, byteLength2);
    }
    get nullCount() {
      if (DataType.isUnion(this.type)) {
        return this.children.reduce((nullCount2, child) => nullCount2 + child.nullCount, 0);
      }
      let nullCount = this._nullCount;
      let nullBitmap;
      if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {
        this._nullCount = nullCount = nullBitmap.length === 0 ? 0 : this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);
      }
      return nullCount;
    }
    constructor(type, offset, length3, nullCount, buffers, children2 = [], dictionary) {
      this.type = type;
      this.children = children2;
      this.dictionary = dictionary;
      this.offset = Math.floor(Math.max(offset || 0, 0));
      this.length = Math.floor(Math.max(length3 || 0, 0));
      this._nullCount = Math.floor(Math.max(nullCount || 0, -1));
      let buffer4;
      if (buffers instanceof Data) {
        this.stride = buffers.stride;
        this.values = buffers.values;
        this.typeIds = buffers.typeIds;
        this.nullBitmap = buffers.nullBitmap;
        this.valueOffsets = buffers.valueOffsets;
      } else {
        this.stride = strideForType(type);
        if (buffers) {
          (buffer4 = buffers[0]) && (this.valueOffsets = buffer4);
          (buffer4 = buffers[1]) && (this.values = buffer4);
          (buffer4 = buffers[2]) && (this.nullBitmap = buffer4);
          (buffer4 = buffers[3]) && (this.typeIds = buffer4);
        }
      }
    }
    getValid(index) {
      const { type } = this;
      if (DataType.isUnion(type)) {
        const union9 = type;
        const child = this.children[union9.typeIdToChildIndex[this.typeIds[index]]];
        const indexInChild = union9.mode === UnionMode.Dense ? this.valueOffsets[index] : index;
        return child.getValid(indexInChild);
      }
      if (this.nullable && this.nullCount > 0) {
        const pos = this.offset + index;
        const val = this.nullBitmap[pos >> 3];
        return (val & 1 << pos % 8) !== 0;
      }
      return true;
    }
    setValid(index, value) {
      let prev;
      const { type } = this;
      if (DataType.isUnion(type)) {
        const union9 = type;
        const child = this.children[union9.typeIdToChildIndex[this.typeIds[index]]];
        const indexInChild = union9.mode === UnionMode.Dense ? this.valueOffsets[index] : index;
        prev = child.getValid(indexInChild);
        child.setValid(indexInChild, value);
      } else {
        let { nullBitmap } = this;
        const { offset, length: length3 } = this;
        const idx = offset + index;
        const mask = 1 << idx % 8;
        const byteOffset = idx >> 3;
        if (!nullBitmap || nullBitmap.byteLength <= byteOffset) {
          nullBitmap = new Uint8Array((offset + length3 + 63 & ~63) >> 3).fill(255);
          if (this.nullCount > 0) {
            nullBitmap.set(truncateBitmap(offset, length3, this.nullBitmap), 0);
            Object.assign(this, { nullBitmap });
          } else {
            Object.assign(this, { nullBitmap, _nullCount: 0 });
          }
        }
        const byte = nullBitmap[byteOffset];
        prev = (byte & mask) !== 0;
        nullBitmap[byteOffset] = value ? byte | mask : byte & ~mask;
      }
      if (prev !== !!value) {
        this._nullCount = this.nullCount + (value ? -1 : 1);
      }
      return value;
    }
    clone(type = this.type, offset = this.offset, length3 = this.length, nullCount = this._nullCount, buffers = this, children2 = this.children) {
      return new Data(type, offset, length3, nullCount, buffers, children2, this.dictionary);
    }
    slice(offset, length3) {
      const { stride, typeId, children: children2 } = this;
      const nullCount = +(this._nullCount === 0) - 1;
      const childStride = typeId === 16 ? stride : 1;
      const buffers = this._sliceBuffers(offset, length3, stride, typeId);
      return this.clone(this.type, this.offset + offset, length3, nullCount, buffers, children2.length === 0 || this.valueOffsets ? children2 : this._sliceChildren(children2, childStride * offset, childStride * length3));
    }
    _changeLengthAndBackfillNullBitmap(newLength) {
      if (this.typeId === Type4.Null) {
        return this.clone(this.type, 0, newLength, 0);
      }
      const { length: length3, nullCount } = this;
      const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length3 >> 3);
      bitmap[length3 >> 3] = (1 << length3 - (length3 & ~7)) - 1;
      if (nullCount > 0) {
        bitmap.set(truncateBitmap(this.offset, length3, this.nullBitmap), 0);
      }
      const buffers = this.buffers;
      buffers[BufferType.VALIDITY] = bitmap;
      return this.clone(this.type, 0, newLength, nullCount + (newLength - length3), buffers);
    }
    _sliceBuffers(offset, length3, stride, typeId) {
      let arr;
      const { buffers } = this;
      (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset, offset + length3));
      (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset, offset + length3 + 1)) || (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length3)));
      return buffers;
    }
    _sliceChildren(children2, offset, length3) {
      return children2.map((child) => child.slice(offset, length3));
    }
  }
  Data.prototype.children = Object.freeze([]);

  class MakeDataVisitor extends Visitor {
    visit(props) {
      return this.getVisitFn(props["type"]).call(this, props);
    }
    visitNull(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["length"]: length3 = 0 } = props;
      return new Data(type, offset, length3, length3);
    }
    visitBool(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length3 = data.length >> 3, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
    }
    visitInt(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length3 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
    }
    visitFloat(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length3 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
    }
    visitUtf8(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const data = toUint8Array(props["data"]);
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length3 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [valueOffsets, data, nullBitmap]);
    }
    visitLargeUtf8(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const data = toUint8Array(props["data"]);
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toBigInt64Array(props["valueOffsets"]);
      const { ["length"]: length3 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [valueOffsets, data, nullBitmap]);
    }
    visitBinary(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const data = toUint8Array(props["data"]);
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length3 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [valueOffsets, data, nullBitmap]);
    }
    visitLargeBinary(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const data = toUint8Array(props["data"]);
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toBigInt64Array(props["valueOffsets"]);
      const { ["length"]: length3 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [valueOffsets, data, nullBitmap]);
    }
    visitFixedSizeBinary(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length3 = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
    }
    visitDate(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length3 = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
    }
    visitTimestamp(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length3 = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
    }
    visitTime(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length3 = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
    }
    visitDecimal(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length3 = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
    }
    visitList(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length3 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [valueOffsets, undefined, nullBitmap], [child]);
    }
    visitStruct(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["children"]: children2 = [] } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const { length: length3 = children2.reduce((len2, { length: length4 }) => Math.max(len2, length4), 0), nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [undefined, undefined, nullBitmap], children2);
    }
    visitUnion(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["children"]: children2 = [] } = props;
      const typeIds = toArrayBufferView(type.ArrayType, props["typeIds"]);
      const { ["length"]: length3 = typeIds.length, ["nullCount"]: nullCount = -1 } = props;
      if (DataType.isSparseUnion(type)) {
        return new Data(type, offset, length3, nullCount, [undefined, undefined, undefined, typeIds], children2);
      }
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      return new Data(type, offset, length3, nullCount, [valueOffsets, undefined, undefined, typeIds], children2);
    }
    visitDictionary(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.indices.ArrayType, props["data"]);
      const { ["dictionary"]: dictionary = new Vector([new MakeDataVisitor().visit({ type: type.dictionary })]) } = props;
      const { ["length"]: length3 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap], [], dictionary);
    }
    visitInterval(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length3 = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
    }
    visitDuration(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length3 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
    }
    visitFixedSizeList(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child = new MakeDataVisitor().visit({ type: type.valueType }) } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const { ["length"]: length3 = child.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [undefined, undefined, nullBitmap], [child]);
    }
    visitMap(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child = new MakeDataVisitor().visit({ type: type.childType }) } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length3 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length3, nullCount, [valueOffsets, undefined, nullBitmap], [child]);
    }
  }
  var makeDataVisitor = new MakeDataVisitor;
  function makeData(props) {
    return makeDataVisitor.visit(props);
  }

  // node_modules/apache-arrow/util/chunk.mjs
  class ChunkedIterator {
    constructor(numChunks = 0, getChunkIterator) {
      this.numChunks = numChunks;
      this.getChunkIterator = getChunkIterator;
      this.chunkIndex = 0;
      this.chunkIterator = this.getChunkIterator(0);
    }
    next() {
      while (this.chunkIndex < this.numChunks) {
        const next = this.chunkIterator.next();
        if (!next.done) {
          return next;
        }
        if (++this.chunkIndex < this.numChunks) {
          this.chunkIterator = this.getChunkIterator(this.chunkIndex);
        }
      }
      return { done: true, value: null };
    }
    [Symbol.iterator]() {
      return this;
    }
  }
  function computeChunkNullable(chunks3) {
    return chunks3.some((chunk3) => chunk3.nullable);
  }
  function computeChunkNullCounts(chunks3) {
    return chunks3.reduce((nullCount, chunk3) => nullCount + chunk3.nullCount, 0);
  }
  function computeChunkOffsets(chunks3) {
    return chunks3.reduce((offsets, chunk3, index) => {
      offsets[index + 1] = offsets[index] + chunk3.length;
      return offsets;
    }, new Uint32Array(chunks3.length + 1));
  }
  function sliceChunks(chunks3, offsets, begin, end6) {
    const slices = [];
    for (let i2 = -1, n = chunks3.length;++i2 < n; ) {
      const chunk3 = chunks3[i2];
      const offset = offsets[i2];
      const { length: length3 } = chunk3;
      if (offset >= end6) {
        break;
      }
      if (begin >= offset + length3) {
        continue;
      }
      if (offset >= begin && offset + length3 <= end6) {
        slices.push(chunk3);
        continue;
      }
      const from2 = Math.max(0, begin - offset);
      const to = Math.min(end6 - offset, length3);
      slices.push(chunk3.slice(from2, to - from2));
    }
    if (slices.length === 0) {
      slices.push(chunks3[0].slice(0, 0));
    }
    return slices;
  }
  function binarySearch(chunks3, offsets, idx, fn2) {
    let lhs = 0, mid = 0, rhs = offsets.length - 1;
    do {
      if (lhs >= rhs - 1) {
        return idx < offsets[rhs] ? fn2(chunks3, lhs, idx - offsets[lhs]) : null;
      }
      mid = lhs + Math.trunc((rhs - lhs) * 0.5);
      idx < offsets[mid] ? rhs = mid : lhs = mid;
    } while (lhs < rhs);
  }
  function isChunkedValid(data, index) {
    return data.getValid(index);
  }
  function wrapChunkedCall1(fn2) {
    function chunkedFn(chunks3, i2, j) {
      return fn2(chunks3[i2], j);
    }
    return function(index) {
      const data = this.data;
      return binarySearch(data, this._offsets, index, chunkedFn);
    };
  }
  function wrapChunkedCall2(fn2) {
    let _2;
    function chunkedFn(chunks3, i2, j) {
      return fn2(chunks3[i2], j, _2);
    }
    return function(index, value) {
      const data = this.data;
      _2 = value;
      const result = binarySearch(data, this._offsets, index, chunkedFn);
      _2 = undefined;
      return result;
    };
  }
  function wrapChunkedIndexOf(indexOf2) {
    let _1;
    function chunkedIndexOf(data, chunkIndex, fromIndex) {
      let begin = fromIndex, index = 0, total = 0;
      for (let i2 = chunkIndex - 1, n = data.length;++i2 < n; ) {
        const chunk3 = data[i2];
        if (~(index = indexOf2(chunk3, _1, begin))) {
          return total + index;
        }
        begin = 0;
        total += chunk3.length;
      }
      return -1;
    }
    return function(element, offset) {
      _1 = element;
      const data = this.data;
      const result = typeof offset !== "number" ? chunkedIndexOf(data, 0, 0) : binarySearch(data, this._offsets, offset, chunkedIndexOf);
      _1 = undefined;
      return result;
    };
  }

  // node_modules/apache-arrow/visitor/indexof.mjs
  class IndexOfVisitor extends Visitor {
  }
  function nullIndexOf(data, searchElement) {
    return searchElement === null && data.length > 0 ? 0 : -1;
  }
  function indexOfNull(data, fromIndex) {
    const { nullBitmap } = data;
    if (!nullBitmap || data.nullCount <= 0) {
      return -1;
    }
    let i2 = 0;
    for (const isValid2 of new BitIterator(nullBitmap, data.offset + (fromIndex || 0), data.length, nullBitmap, getBool2)) {
      if (!isValid2) {
        return i2;
      }
      ++i2;
    }
    return -1;
  }
  function indexOfValue(data, searchElement, fromIndex) {
    if (searchElement === undefined) {
      return -1;
    }
    if (searchElement === null) {
      switch (data.typeId) {
        case Type4.Union:
          break;
        case Type4.Dictionary:
          break;
        default:
          return indexOfNull(data, fromIndex);
      }
    }
    const get17 = instance2.getVisitFn(data);
    const compare3 = createElementComparator(searchElement);
    for (let i2 = (fromIndex || 0) - 1, n = data.length;++i2 < n; ) {
      if (compare3(get17(data, i2))) {
        return i2;
      }
    }
    return -1;
  }
  function indexOfUnion(data, searchElement, fromIndex) {
    const get17 = instance2.getVisitFn(data);
    const compare3 = createElementComparator(searchElement);
    for (let i2 = (fromIndex || 0) - 1, n = data.length;++i2 < n; ) {
      if (compare3(get17(data, i2))) {
        return i2;
      }
    }
    return -1;
  }
  IndexOfVisitor.prototype.visitNull = nullIndexOf;
  IndexOfVisitor.prototype.visitBool = indexOfValue;
  IndexOfVisitor.prototype.visitInt = indexOfValue;
  IndexOfVisitor.prototype.visitInt8 = indexOfValue;
  IndexOfVisitor.prototype.visitInt16 = indexOfValue;
  IndexOfVisitor.prototype.visitInt32 = indexOfValue;
  IndexOfVisitor.prototype.visitInt64 = indexOfValue;
  IndexOfVisitor.prototype.visitUint8 = indexOfValue;
  IndexOfVisitor.prototype.visitUint16 = indexOfValue;
  IndexOfVisitor.prototype.visitUint32 = indexOfValue;
  IndexOfVisitor.prototype.visitUint64 = indexOfValue;
  IndexOfVisitor.prototype.visitFloat = indexOfValue;
  IndexOfVisitor.prototype.visitFloat16 = indexOfValue;
  IndexOfVisitor.prototype.visitFloat32 = indexOfValue;
  IndexOfVisitor.prototype.visitFloat64 = indexOfValue;
  IndexOfVisitor.prototype.visitUtf8 = indexOfValue;
  IndexOfVisitor.prototype.visitLargeUtf8 = indexOfValue;
  IndexOfVisitor.prototype.visitBinary = indexOfValue;
  IndexOfVisitor.prototype.visitLargeBinary = indexOfValue;
  IndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;
  IndexOfVisitor.prototype.visitDate = indexOfValue;
  IndexOfVisitor.prototype.visitDateDay = indexOfValue;
  IndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestamp = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;
  IndexOfVisitor.prototype.visitTime = indexOfValue;
  IndexOfVisitor.prototype.visitTimeSecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;
  IndexOfVisitor.prototype.visitDecimal = indexOfValue;
  IndexOfVisitor.prototype.visitList = indexOfValue;
  IndexOfVisitor.prototype.visitStruct = indexOfValue;
  IndexOfVisitor.prototype.visitUnion = indexOfValue;
  IndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;
  IndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;
  IndexOfVisitor.prototype.visitDictionary = indexOfValue;
  IndexOfVisitor.prototype.visitInterval = indexOfValue;
  IndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;
  IndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;
  IndexOfVisitor.prototype.visitIntervalMonthDayNano = indexOfValue;
  IndexOfVisitor.prototype.visitDuration = indexOfValue;
  IndexOfVisitor.prototype.visitDurationSecond = indexOfValue;
  IndexOfVisitor.prototype.visitDurationMillisecond = indexOfValue;
  IndexOfVisitor.prototype.visitDurationMicrosecond = indexOfValue;
  IndexOfVisitor.prototype.visitDurationNanosecond = indexOfValue;
  IndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;
  IndexOfVisitor.prototype.visitMap = indexOfValue;
  var instance3 = new IndexOfVisitor;

  // node_modules/apache-arrow/visitor/iterator.mjs
  class IteratorVisitor extends Visitor {
  }
  function vectorIterator(vector) {
    const { type } = vector;
    if (vector.nullCount === 0 && vector.stride === 1 && (DataType.isInt(type) && type.bitWidth !== 64 || DataType.isTime(type) && type.bitWidth !== 64 || DataType.isFloat(type) && type.precision !== Precision.HALF)) {
      return new ChunkedIterator(vector.data.length, (chunkIndex) => {
        const data = vector.data[chunkIndex];
        return data.values.subarray(0, data.length)[Symbol.iterator]();
      });
    }
    let offset = 0;
    return new ChunkedIterator(vector.data.length, (chunkIndex) => {
      const data = vector.data[chunkIndex];
      const length3 = data.length;
      const inner = vector.slice(offset, offset + length3);
      offset += length3;
      return new VectorIterator(inner);
    });
  }

  class VectorIterator {
    constructor(vector) {
      this.vector = vector;
      this.index = 0;
    }
    next() {
      if (this.index < this.vector.length) {
        return {
          value: this.vector.get(this.index++)
        };
      }
      return { done: true, value: null };
    }
    [Symbol.iterator]() {
      return this;
    }
  }
  IteratorVisitor.prototype.visitNull = vectorIterator;
  IteratorVisitor.prototype.visitBool = vectorIterator;
  IteratorVisitor.prototype.visitInt = vectorIterator;
  IteratorVisitor.prototype.visitInt8 = vectorIterator;
  IteratorVisitor.prototype.visitInt16 = vectorIterator;
  IteratorVisitor.prototype.visitInt32 = vectorIterator;
  IteratorVisitor.prototype.visitInt64 = vectorIterator;
  IteratorVisitor.prototype.visitUint8 = vectorIterator;
  IteratorVisitor.prototype.visitUint16 = vectorIterator;
  IteratorVisitor.prototype.visitUint32 = vectorIterator;
  IteratorVisitor.prototype.visitUint64 = vectorIterator;
  IteratorVisitor.prototype.visitFloat = vectorIterator;
  IteratorVisitor.prototype.visitFloat16 = vectorIterator;
  IteratorVisitor.prototype.visitFloat32 = vectorIterator;
  IteratorVisitor.prototype.visitFloat64 = vectorIterator;
  IteratorVisitor.prototype.visitUtf8 = vectorIterator;
  IteratorVisitor.prototype.visitLargeUtf8 = vectorIterator;
  IteratorVisitor.prototype.visitBinary = vectorIterator;
  IteratorVisitor.prototype.visitLargeBinary = vectorIterator;
  IteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;
  IteratorVisitor.prototype.visitDate = vectorIterator;
  IteratorVisitor.prototype.visitDateDay = vectorIterator;
  IteratorVisitor.prototype.visitDateMillisecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestamp = vectorIterator;
  IteratorVisitor.prototype.visitTimestampSecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;
  IteratorVisitor.prototype.visitTime = vectorIterator;
  IteratorVisitor.prototype.visitTimeSecond = vectorIterator;
  IteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;
  IteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;
  IteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;
  IteratorVisitor.prototype.visitDecimal = vectorIterator;
  IteratorVisitor.prototype.visitList = vectorIterator;
  IteratorVisitor.prototype.visitStruct = vectorIterator;
  IteratorVisitor.prototype.visitUnion = vectorIterator;
  IteratorVisitor.prototype.visitDenseUnion = vectorIterator;
  IteratorVisitor.prototype.visitSparseUnion = vectorIterator;
  IteratorVisitor.prototype.visitDictionary = vectorIterator;
  IteratorVisitor.prototype.visitInterval = vectorIterator;
  IteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;
  IteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;
  IteratorVisitor.prototype.visitIntervalMonthDayNano = vectorIterator;
  IteratorVisitor.prototype.visitDuration = vectorIterator;
  IteratorVisitor.prototype.visitDurationSecond = vectorIterator;
  IteratorVisitor.prototype.visitDurationMillisecond = vectorIterator;
  IteratorVisitor.prototype.visitDurationMicrosecond = vectorIterator;
  IteratorVisitor.prototype.visitDurationNanosecond = vectorIterator;
  IteratorVisitor.prototype.visitFixedSizeList = vectorIterator;
  IteratorVisitor.prototype.visitMap = vectorIterator;
  var instance4 = new IteratorVisitor;

  // node_modules/apache-arrow/vector.mjs
  var _a2;
  var visitorsByTypeId = {};
  var vectorPrototypesByTypeId = {};

  class Vector {
    constructor(input) {
      var _b2, _c2, _d2;
      const data = input[0] instanceof Vector ? input.flatMap((x) => x.data) : input;
      if (data.length === 0 || data.some((x) => !(x instanceof Data))) {
        throw new TypeError("Vector constructor expects an Array of Data instances.");
      }
      const type = (_b2 = data[0]) === null || _b2 === undefined ? undefined : _b2.type;
      switch (data.length) {
        case 0:
          this._offsets = [0];
          break;
        case 1: {
          const { get: get17, set: set8, indexOf: indexOf2 } = visitorsByTypeId[type.typeId];
          const unchunkedData = data[0];
          this.isValid = (index) => isChunkedValid(unchunkedData, index);
          this.get = (index) => get17(unchunkedData, index);
          this.set = (index, value) => set8(unchunkedData, index, value);
          this.indexOf = (index) => indexOf2(unchunkedData, index);
          this._offsets = [0, unchunkedData.length];
          break;
        }
        default:
          Object.setPrototypeOf(this, vectorPrototypesByTypeId[type.typeId]);
          this._offsets = computeChunkOffsets(data);
          break;
      }
      this.data = data;
      this.type = type;
      this.stride = strideForType(type);
      this.numChildren = (_d2 = (_c2 = type.children) === null || _c2 === undefined ? undefined : _c2.length) !== null && _d2 !== undefined ? _d2 : 0;
      this.length = this._offsets.at(-1);
    }
    get byteLength() {
      return this.data.reduce((byteLength2, data) => byteLength2 + data.byteLength, 0);
    }
    get nullable() {
      return computeChunkNullable(this.data);
    }
    get nullCount() {
      return computeChunkNullCounts(this.data);
    }
    get ArrayType() {
      return this.type.ArrayType;
    }
    get [Symbol.toStringTag]() {
      return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
    }
    get VectorName() {
      return `${Type4[this.type.typeId]}Vector`;
    }
    isValid(index) {
      return false;
    }
    get(index) {
      return null;
    }
    at(index) {
      return this.get(wrapIndex(index, this.length));
    }
    set(index, value) {
      return;
    }
    indexOf(element, offset) {
      return -1;
    }
    includes(element, offset) {
      return this.indexOf(element, offset) > -1;
    }
    [Symbol.iterator]() {
      return instance4.visit(this);
    }
    concat(...others) {
      return new Vector(this.data.concat(others.flatMap((x) => x.data).flat(Number.POSITIVE_INFINITY)));
    }
    slice(begin, end6) {
      return new Vector(clampRange(this, begin, end6, ({ data, _offsets }, begin2, end7) => sliceChunks(data, _offsets, begin2, end7)));
    }
    toJSON() {
      return [...this];
    }
    toArray() {
      const { type, data, length: length3, stride, ArrayType } = this;
      switch (type.typeId) {
        case Type4.Int:
        case Type4.Float:
        case Type4.Decimal:
        case Type4.Time:
        case Type4.Timestamp:
          switch (data.length) {
            case 0:
              return new ArrayType;
            case 1:
              return data[0].values.subarray(0, length3 * stride);
            default:
              return data.reduce((memo, { values: values3, length: chunk_length }) => {
                memo.array.set(values3.subarray(0, chunk_length * stride), memo.offset);
                memo.offset += chunk_length * stride;
                return memo;
              }, { array: new ArrayType(length3 * stride), offset: 0 }).array;
          }
      }
      return [...this];
    }
    toString() {
      return `[${[...this].join(",")}]`;
    }
    getChild(name) {
      var _b2;
      return this.getChildAt((_b2 = this.type.children) === null || _b2 === undefined ? undefined : _b2.findIndex((f) => f.name === name));
    }
    getChildAt(index) {
      if (index > -1 && index < this.numChildren) {
        return new Vector(this.data.map(({ children: children2 }) => children2[index]));
      }
      return null;
    }
    get isMemoized() {
      if (DataType.isDictionary(this.type)) {
        return this.data[0].dictionary.isMemoized;
      }
      return false;
    }
    memoize() {
      if (DataType.isDictionary(this.type)) {
        const dictionary = new MemoizedVector(this.data[0].dictionary);
        const newData = this.data.map((data) => {
          const cloned = data.clone();
          cloned.dictionary = dictionary;
          return cloned;
        });
        return new Vector(newData);
      }
      return new MemoizedVector(this);
    }
    unmemoize() {
      if (DataType.isDictionary(this.type) && this.isMemoized) {
        const dictionary = this.data[0].dictionary.unmemoize();
        const newData = this.data.map((data) => {
          const newData2 = data.clone();
          newData2.dictionary = dictionary;
          return newData2;
        });
        return new Vector(newData);
      }
      return this;
    }
  }
  _a2 = Symbol.toStringTag;
  Vector[_a2] = ((proto12) => {
    proto12.type = DataType.prototype;
    proto12.data = [];
    proto12.length = 0;
    proto12.stride = 1;
    proto12.numChildren = 0;
    proto12._offsets = new Uint32Array([0]);
    proto12[Symbol.isConcatSpreadable] = true;
    const typeIds = Object.keys(Type4).map((T) => Type4[T]).filter((T) => typeof T === "number" && T !== Type4.NONE);
    for (const typeId of typeIds) {
      const get17 = instance2.getVisitFnByTypeId(typeId);
      const set8 = instance.getVisitFnByTypeId(typeId);
      const indexOf2 = instance3.getVisitFnByTypeId(typeId);
      visitorsByTypeId[typeId] = { get: get17, set: set8, indexOf: indexOf2 };
      vectorPrototypesByTypeId[typeId] = Object.create(proto12, {
        ["isValid"]: { value: wrapChunkedCall1(isChunkedValid) },
        ["get"]: { value: wrapChunkedCall1(instance2.getVisitFnByTypeId(typeId)) },
        ["set"]: { value: wrapChunkedCall2(instance.getVisitFnByTypeId(typeId)) },
        ["indexOf"]: { value: wrapChunkedIndexOf(instance3.getVisitFnByTypeId(typeId)) }
      });
    }
    return "Vector";
  })(Vector.prototype);

  class MemoizedVector extends Vector {
    constructor(vector) {
      super(vector.data);
      const get17 = this.get;
      const set8 = this.set;
      const slice2 = this.slice;
      const cache = new Array(this.length);
      Object.defineProperty(this, "get", {
        value(index) {
          const cachedValue = cache[index];
          if (cachedValue !== undefined) {
            return cachedValue;
          }
          const value = get17.call(this, index);
          cache[index] = value;
          return value;
        }
      });
      Object.defineProperty(this, "set", {
        value(index, value) {
          set8.call(this, index, value);
          cache[index] = value;
        }
      });
      Object.defineProperty(this, "slice", {
        value: (begin, end6) => new MemoizedVector(slice2.call(this, begin, end6))
      });
      Object.defineProperty(this, "isMemoized", { value: true });
      Object.defineProperty(this, "unmemoize", {
        value: () => new Vector(this.data)
      });
      Object.defineProperty(this, "memoize", {
        value: () => this
      });
    }
  }

  // node_modules/apache-arrow/builder/valid.mjs
  function createIsValidFunction(nullValues) {
    if (!nullValues || nullValues.length <= 0) {
      return function isValid(value) {
        return true;
      };
    }
    let fnBody = "";
    const noNaNs = nullValues.filter((x) => x === x);
    if (noNaNs.length > 0) {
      fnBody = `
    switch (x) {${noNaNs.map((x) => `
        case ${valueToCase(x)}:`).join("")}
            return false;
    }`;
    }
    if (nullValues.length !== noNaNs.length) {
      fnBody = `if (x !== x) return false;
${fnBody}`;
    }
    return new Function(`x`, `${fnBody}
return true;`);
  }
  function valueToCase(x) {
    if (typeof x !== "bigint") {
      return valueToString(x);
    }
    return `${valueToString(x)}n`;
  }

  // node_modules/apache-arrow/builder/buffer.mjs
  function roundLengthUpToNearest64Bytes(len2, BPE) {
    const bytesMinus1 = Math.ceil(len2) * BPE - 1;
    return (bytesMinus1 - bytesMinus1 % 64 + 64 || 64) / BPE;
  }
  function resizeArray(arr, len2 = 0) {
    return arr.length >= len2 ? arr.subarray(0, len2) : memcpy(new arr.constructor(len2), arr, 0);
  }

  class BufferBuilder {
    constructor(bufferType, initialSize = 0, stride = 1) {
      this.length = Math.ceil(initialSize / stride);
      this.buffer = new bufferType(this.length);
      this.stride = stride;
      this.BYTES_PER_ELEMENT = bufferType.BYTES_PER_ELEMENT;
      this.ArrayType = bufferType;
    }
    get byteLength() {
      return Math.ceil(this.length * this.stride) * this.BYTES_PER_ELEMENT;
    }
    get reservedLength() {
      return this.buffer.length / this.stride;
    }
    get reservedByteLength() {
      return this.buffer.byteLength;
    }
    set(index, value) {
      return this;
    }
    append(value) {
      return this.set(this.length, value);
    }
    reserve(extra) {
      if (extra > 0) {
        this.length += extra;
        const stride = this.stride;
        const length3 = this.length * stride;
        const reserved = this.buffer.length;
        if (length3 >= reserved) {
          this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes(length3 * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes(length3 * 2, this.BYTES_PER_ELEMENT));
        }
      }
      return this;
    }
    flush(length3 = this.length) {
      length3 = roundLengthUpToNearest64Bytes(length3 * this.stride, this.BYTES_PER_ELEMENT);
      const array4 = resizeArray(this.buffer, length3);
      this.clear();
      return array4;
    }
    clear() {
      this.length = 0;
      this.buffer = new this.ArrayType;
      return this;
    }
    _resize(newLength) {
      return this.buffer = resizeArray(this.buffer, newLength);
    }
  }

  class DataBufferBuilder extends BufferBuilder {
    last() {
      return this.get(this.length - 1);
    }
    get(index) {
      return this.buffer[index];
    }
    set(index, value) {
      this.reserve(index - this.length + 1);
      this.buffer[index * this.stride] = value;
      return this;
    }
  }

  class BitmapBufferBuilder extends DataBufferBuilder {
    constructor() {
      super(Uint8Array, 0, 1 / 8);
      this.numValid = 0;
    }
    get numInvalid() {
      return this.length - this.numValid;
    }
    get(idx) {
      return this.buffer[idx >> 3] >> idx % 8 & 1;
    }
    set(idx, val) {
      const { buffer: buffer4 } = this.reserve(idx - this.length + 1);
      const byte = idx >> 3, bit = idx % 8, cur = buffer4[byte] >> bit & 1;
      val ? cur === 0 && (buffer4[byte] |= 1 << bit, ++this.numValid) : cur === 1 && (buffer4[byte] &= ~(1 << bit), --this.numValid);
      return this;
    }
    clear() {
      this.numValid = 0;
      return super.clear();
    }
  }

  class OffsetsBufferBuilder extends DataBufferBuilder {
    constructor(type) {
      super(type.OffsetArrayType, 1, 1);
    }
    append(value) {
      return this.set(this.length - 1, value);
    }
    set(index, value) {
      const offset = this.length - 1;
      const buffer4 = this.reserve(index - offset + 1).buffer;
      if (offset < index++ && offset >= 0) {
        buffer4.fill(buffer4[offset], offset, index);
      }
      buffer4[index] = buffer4[index - 1] + value;
      return this;
    }
    flush(length3 = this.length - 1) {
      if (length3 > this.length) {
        this.set(length3 - 1, this.BYTES_PER_ELEMENT > 4 ? BigInt(0) : 0);
      }
      return super.flush(length3 + 1);
    }
  }

  // node_modules/apache-arrow/builder.mjs
  class Builder2 {
    static throughNode(options) {
      throw new Error(`"throughNode" not available in this environment`);
    }
    static throughDOM(options) {
      throw new Error(`"throughDOM" not available in this environment`);
    }
    constructor({ type, nullValues: nulls }) {
      this.length = 0;
      this.finished = false;
      this.type = type;
      this.children = [];
      this.nullValues = nulls;
      this.stride = strideForType(type);
      this._nulls = new BitmapBufferBuilder;
      if (nulls && nulls.length > 0) {
        this._isValid = createIsValidFunction(nulls);
      }
    }
    toVector() {
      return new Vector([this.flush()]);
    }
    get ArrayType() {
      return this.type.ArrayType;
    }
    get nullCount() {
      return this._nulls.numInvalid;
    }
    get numChildren() {
      return this.children.length;
    }
    get byteLength() {
      let size13 = 0;
      const { _offsets, _values, _nulls, _typeIds, children: children2 } = this;
      _offsets && (size13 += _offsets.byteLength);
      _values && (size13 += _values.byteLength);
      _nulls && (size13 += _nulls.byteLength);
      _typeIds && (size13 += _typeIds.byteLength);
      return children2.reduce((size14, child) => size14 + child.byteLength, size13);
    }
    get reservedLength() {
      return this._nulls.reservedLength;
    }
    get reservedByteLength() {
      let size13 = 0;
      this._offsets && (size13 += this._offsets.reservedByteLength);
      this._values && (size13 += this._values.reservedByteLength);
      this._nulls && (size13 += this._nulls.reservedByteLength);
      this._typeIds && (size13 += this._typeIds.reservedByteLength);
      return this.children.reduce((size14, child) => size14 + child.reservedByteLength, size13);
    }
    get valueOffsets() {
      return this._offsets ? this._offsets.buffer : null;
    }
    get values() {
      return this._values ? this._values.buffer : null;
    }
    get nullBitmap() {
      return this._nulls ? this._nulls.buffer : null;
    }
    get typeIds() {
      return this._typeIds ? this._typeIds.buffer : null;
    }
    append(value) {
      return this.set(this.length, value);
    }
    isValid(value) {
      return this._isValid(value);
    }
    set(index, value) {
      if (this.setValid(index, this.isValid(value))) {
        this.setValue(index, value);
      }
      return this;
    }
    setValue(index, value) {
      this._setValue(this, index, value);
    }
    setValid(index, valid) {
      this.length = this._nulls.set(index, +valid).length;
      return valid;
    }
    addChild(child, name = `${this.numChildren}`) {
      throw new Error(`Cannot append children to non-nested type "${this.type}"`);
    }
    getChildAt(index) {
      return this.children[index] || null;
    }
    flush() {
      let data;
      let typeIds;
      let nullBitmap;
      let valueOffsets;
      const { type, length: length3, nullCount, _typeIds, _offsets, _values, _nulls } = this;
      if (typeIds = _typeIds === null || _typeIds === undefined ? undefined : _typeIds.flush(length3)) {
        valueOffsets = _offsets === null || _offsets === undefined ? undefined : _offsets.flush(length3);
      } else if (valueOffsets = _offsets === null || _offsets === undefined ? undefined : _offsets.flush(length3)) {
        data = _values === null || _values === undefined ? undefined : _values.flush(_offsets.last());
      } else {
        data = _values === null || _values === undefined ? undefined : _values.flush(length3);
      }
      if (nullCount > 0) {
        nullBitmap = _nulls === null || _nulls === undefined ? undefined : _nulls.flush(length3);
      }
      const children2 = this.children.map((child) => child.flush());
      this.clear();
      return makeData({
        type,
        length: length3,
        nullCount,
        children: children2,
        child: children2[0],
        data,
        typeIds,
        nullBitmap,
        valueOffsets
      });
    }
    finish() {
      this.finished = true;
      for (const child of this.children)
        child.finish();
      return this;
    }
    clear() {
      var _a3, _b2, _c2, _d2;
      this.length = 0;
      (_a3 = this._nulls) === null || _a3 === undefined || _a3.clear();
      (_b2 = this._values) === null || _b2 === undefined || _b2.clear();
      (_c2 = this._offsets) === null || _c2 === undefined || _c2.clear();
      (_d2 = this._typeIds) === null || _d2 === undefined || _d2.clear();
      for (const child of this.children)
        child.clear();
      return this;
    }
  }
  Builder2.prototype.length = 1;
  Builder2.prototype.stride = 1;
  Builder2.prototype.children = null;
  Builder2.prototype.finished = false;
  Builder2.prototype.nullValues = null;
  Builder2.prototype._isValid = () => true;

  class FixedWidthBuilder extends Builder2 {
    constructor(opts) {
      super(opts);
      this._values = new DataBufferBuilder(this.ArrayType, 0, this.stride);
    }
    setValue(index, value) {
      const values3 = this._values;
      values3.reserve(index - values3.length + 1);
      return super.setValue(index, value);
    }
  }

  class VariableWidthBuilder extends Builder2 {
    constructor(opts) {
      super(opts);
      this._pendingLength = 0;
      this._offsets = new OffsetsBufferBuilder(opts.type);
    }
    setValue(index, value) {
      const pending3 = this._pending || (this._pending = new Map);
      const current2 = pending3.get(index);
      current2 && (this._pendingLength -= current2.length);
      this._pendingLength += value instanceof MapRow ? value[kKeys].length : value.length;
      pending3.set(index, value);
    }
    setValid(index, isValid2) {
      if (!super.setValid(index, isValid2)) {
        (this._pending || (this._pending = new Map)).set(index, undefined);
        return false;
      }
      return true;
    }
    clear() {
      this._pendingLength = 0;
      this._pending = undefined;
      return super.clear();
    }
    flush() {
      this._flush();
      return super.flush();
    }
    finish() {
      this._flush();
      return super.finish();
    }
    _flush() {
      const pending3 = this._pending;
      const pendingLength = this._pendingLength;
      this._pendingLength = 0;
      this._pending = undefined;
      if (pending3 && pending3.size > 0) {
        this._flushPending(pending3, pendingLength);
      }
      return this;
    }
  }

  // node_modules/apache-arrow/fb/block.mjs
  class Block {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    offset() {
      return this.bb.readInt64(this.bb_pos);
    }
    metaDataLength() {
      return this.bb.readInt32(this.bb_pos + 8);
    }
    bodyLength() {
      return this.bb.readInt64(this.bb_pos + 16);
    }
    static sizeOf() {
      return 24;
    }
    static createBlock(builder, offset, metaDataLength, bodyLength) {
      builder.prep(8, 24);
      builder.writeInt64(BigInt(bodyLength !== null && bodyLength !== undefined ? bodyLength : 0));
      builder.pad(4);
      builder.writeInt32(metaDataLength);
      builder.writeInt64(BigInt(offset !== null && offset !== undefined ? offset : 0));
      return builder.offset();
    }
  }

  // node_modules/apache-arrow/fb/footer.mjs
  class Footer {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsFooter(bb, obj) {
      return (obj || new Footer).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFooter(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Footer).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    version() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : MetadataVersion.V1;
    }
    schema(obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new Schema2).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    dictionaries(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? (obj || new Block).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
    }
    dictionariesLength() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    recordBatches(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? (obj || new Block).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
    }
    recordBatchesLength() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? (obj || new KeyValue).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startFooter(builder) {
      builder.startObject(5);
    }
    static addVersion(builder, version) {
      builder.addFieldInt16(0, version, MetadataVersion.V1);
    }
    static addSchema(builder, schemaOffset) {
      builder.addFieldOffset(1, schemaOffset, 0);
    }
    static addDictionaries(builder, dictionariesOffset) {
      builder.addFieldOffset(2, dictionariesOffset, 0);
    }
    static startDictionariesVector(builder, numElems) {
      builder.startVector(24, numElems, 8);
    }
    static addRecordBatches(builder, recordBatchesOffset) {
      builder.addFieldOffset(3, recordBatchesOffset, 0);
    }
    static startRecordBatchesVector(builder, numElems) {
      builder.startVector(24, numElems, 8);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(4, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i2 = data.length - 1;i2 >= 0; i2--) {
        builder.addOffset(data[i2]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endFooter(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static finishFooterBuffer(builder, offset) {
      builder.finish(offset);
    }
    static finishSizePrefixedFooterBuffer(builder, offset) {
      builder.finish(offset, undefined, true);
    }
  }

  // node_modules/apache-arrow/schema.mjs
  class Schema3 {
    constructor(fields = [], metadata, dictionaries, metadataVersion = MetadataVersion.V5) {
      this.fields = fields || [];
      this.metadata = metadata || new Map;
      if (!dictionaries) {
        dictionaries = generateDictionaryMap(this.fields);
      }
      this.dictionaries = dictionaries;
      this.metadataVersion = metadataVersion;
    }
    get [Symbol.toStringTag]() {
      return "Schema";
    }
    get names() {
      return this.fields.map((f) => f.name);
    }
    toString() {
      return `Schema<{ ${this.fields.map((f, i2) => `${i2}: ${f}`).join(", ")} }>`;
    }
    select(fieldNames) {
      const names = new Set(fieldNames);
      const fields = this.fields.filter((f) => names.has(f.name));
      return new Schema3(fields, this.metadata);
    }
    selectAt(fieldIndices) {
      const fields = fieldIndices.map((i2) => this.fields[i2]).filter(Boolean);
      return new Schema3(fields, this.metadata);
    }
    assign(...args2) {
      const other = args2[0] instanceof Schema3 ? args2[0] : Array.isArray(args2[0]) ? new Schema3(args2[0]) : new Schema3(args2);
      const curFields = [...this.fields];
      const metadata = mergeMaps(mergeMaps(new Map, this.metadata), other.metadata);
      const newFields = other.fields.filter((f2) => {
        const i2 = curFields.findIndex((f) => f.name === f2.name);
        return ~i2 ? (curFields[i2] = f2.clone({
          metadata: mergeMaps(mergeMaps(new Map, curFields[i2].metadata), f2.metadata)
        })) && false : true;
      });
      const newDictionaries = generateDictionaryMap(newFields, new Map);
      return new Schema3([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));
    }
  }
  Schema3.prototype.fields = null;
  Schema3.prototype.metadata = null;
  Schema3.prototype.dictionaries = null;

  class Field2 {
    static new(...args2) {
      let [name, type, nullable, metadata] = args2;
      if (args2[0] && typeof args2[0] === "object") {
        ({ name } = args2[0]);
        type === undefined && (type = args2[0].type);
        nullable === undefined && (nullable = args2[0].nullable);
        metadata === undefined && (metadata = args2[0].metadata);
      }
      return new Field2(`${name}`, type, nullable, metadata);
    }
    constructor(name, type, nullable = false, metadata) {
      this.name = name;
      this.type = type;
      this.nullable = nullable;
      this.metadata = metadata || new Map;
    }
    get typeId() {
      return this.type.typeId;
    }
    get [Symbol.toStringTag]() {
      return "Field";
    }
    toString() {
      return `${this.name}: ${this.type}`;
    }
    clone(...args2) {
      let [name, type, nullable, metadata] = args2;
      !args2[0] || typeof args2[0] !== "object" ? [name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args2 : { name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata } = args2[0];
      return Field2.new(name, type, nullable, metadata);
    }
  }
  Field2.prototype.type = null;
  Field2.prototype.name = null;
  Field2.prototype.nullable = null;
  Field2.prototype.metadata = null;
  function mergeMaps(m1, m2) {
    return new Map([...m1 || new Map, ...m2 || new Map]);
  }
  function generateDictionaryMap(fields, dictionaries = new Map) {
    for (let i2 = -1, n = fields.length;++i2 < n; ) {
      const field = fields[i2];
      const type = field.type;
      if (DataType.isDictionary(type)) {
        if (!dictionaries.has(type.id)) {
          dictionaries.set(type.id, type.dictionary);
        } else if (dictionaries.get(type.id) !== type.dictionary) {
          throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
        }
      }
      if (type.children && type.children.length > 0) {
        generateDictionaryMap(type.children, dictionaries);
      }
    }
    return dictionaries;
  }

  // node_modules/apache-arrow/ipc/metadata/file.mjs
  var Builder3 = Builder;
  var ByteBuffer2 = ByteBuffer;

  class Footer_ {
    static decode(buf) {
      buf = new ByteBuffer2(toUint8Array(buf));
      const footer = Footer.getRootAsFooter(buf);
      const schema = Schema3.decode(footer.schema(), new Map, footer.version());
      return new OffHeapFooter(schema, footer);
    }
    static encode(footer) {
      const b = new Builder3;
      const schemaOffset = Schema3.encode(b, footer.schema);
      Footer.startRecordBatchesVector(b, footer.numRecordBatches);
      for (const rb of [...footer.recordBatches()].slice().reverse()) {
        FileBlock.encode(b, rb);
      }
      const recordBatchesOffset = b.endVector();
      Footer.startDictionariesVector(b, footer.numDictionaries);
      for (const db of [...footer.dictionaryBatches()].slice().reverse()) {
        FileBlock.encode(b, db);
      }
      const dictionaryBatchesOffset = b.endVector();
      Footer.startFooter(b);
      Footer.addSchema(b, schemaOffset);
      Footer.addVersion(b, MetadataVersion.V5);
      Footer.addRecordBatches(b, recordBatchesOffset);
      Footer.addDictionaries(b, dictionaryBatchesOffset);
      Footer.finishFooterBuffer(b, Footer.endFooter(b));
      return b.asUint8Array();
    }
    get numRecordBatches() {
      return this._recordBatches.length;
    }
    get numDictionaries() {
      return this._dictionaryBatches.length;
    }
    constructor(schema, version = MetadataVersion.V5, recordBatches, dictionaryBatches) {
      this.schema = schema;
      this.version = version;
      recordBatches && (this._recordBatches = recordBatches);
      dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);
    }
    *recordBatches() {
      for (let block, i2 = -1, n = this.numRecordBatches;++i2 < n; ) {
        if (block = this.getRecordBatch(i2)) {
          yield block;
        }
      }
    }
    *dictionaryBatches() {
      for (let block, i2 = -1, n = this.numDictionaries;++i2 < n; ) {
        if (block = this.getDictionaryBatch(i2)) {
          yield block;
        }
      }
    }
    getRecordBatch(index) {
      return index >= 0 && index < this.numRecordBatches && this._recordBatches[index] || null;
    }
    getDictionaryBatch(index) {
      return index >= 0 && index < this.numDictionaries && this._dictionaryBatches[index] || null;
    }
  }
  class OffHeapFooter extends Footer_ {
    get numRecordBatches() {
      return this._footer.recordBatchesLength();
    }
    get numDictionaries() {
      return this._footer.dictionariesLength();
    }
    constructor(schema, _footer) {
      super(schema, _footer.version());
      this._footer = _footer;
    }
    getRecordBatch(index) {
      if (index >= 0 && index < this.numRecordBatches) {
        const fileBlock = this._footer.recordBatches(index);
        if (fileBlock) {
          return FileBlock.decode(fileBlock);
        }
      }
      return null;
    }
    getDictionaryBatch(index) {
      if (index >= 0 && index < this.numDictionaries) {
        const fileBlock = this._footer.dictionaries(index);
        if (fileBlock) {
          return FileBlock.decode(fileBlock);
        }
      }
      return null;
    }
  }

  class FileBlock {
    static decode(block) {
      return new FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());
    }
    static encode(b, fileBlock) {
      const { metaDataLength } = fileBlock;
      const offset = BigInt(fileBlock.offset);
      const bodyLength = BigInt(fileBlock.bodyLength);
      return Block.createBlock(b, offset, metaDataLength, bodyLength);
    }
    constructor(metaDataLength, bodyLength, offset) {
      this.metaDataLength = metaDataLength;
      this.offset = bigIntToNumber(offset);
      this.bodyLength = bigIntToNumber(bodyLength);
    }
  }

  // node_modules/apache-arrow/fb/message.mjs
  class Message {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i2, bb) {
      this.bb_pos = i2;
      this.bb = bb;
      return this;
    }
    static getRootAsMessage(bb, obj) {
      return (obj || new Message).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMessage(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Message).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    version() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : MetadataVersion.V1;
    }
    headerType() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readUint8(this.bb_pos + offset) : MessageHeader.NONE;
    }
    header(obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    bodyLength() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
    }
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? (obj || new KeyValue).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startMessage(builder) {
      builder.startObject(5);
    }
    static addVersion(builder, version) {
      builder.addFieldInt16(0, version, MetadataVersion.V1);
    }
    static addHeaderType(builder, headerType) {
      builder.addFieldInt8(1, headerType, MessageHeader.NONE);
    }
    static addHeader(builder, headerOffset) {
      builder.addFieldOffset(2, headerOffset, 0);
    }
    static addBodyLength(builder, bodyLength) {
      builder.addFieldInt64(3, bodyLength, BigInt("0"));
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(4, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i2 = data.length - 1;i2 >= 0; i2--) {
        builder.addOffset(data[i2]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endMessage(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static finishMessageBuffer(builder, offset) {
      builder.finish(offset);
    }
    static finishSizePrefixedMessageBuffer(builder, offset) {
      builder.finish(offset, undefined, true);
    }
    static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {
      Message.startMessage(builder);
      Message.addVersion(builder, version);
      Message.addHeaderType(builder, headerType);
      Message.addHeader(builder, headerOffset);
      Message.addBodyLength(builder, bodyLength);
      Message.addCustomMetadata(builder, customMetadataOffset);
      return Message.endMessage(builder);
    }
  }

  // node_modules/apache-arrow/visitor/typeassembler.mjs
  class TypeAssembler extends Visitor {
    visit(node, builder) {
      return node == null || builder == null ? undefined : super.visit(node, builder);
    }
    visitNull(_node, b) {
      Null.startNull(b);
      return Null.endNull(b);
    }
    visitInt(node, b) {
      Int2.startInt(b);
      Int2.addBitWidth(b, node.bitWidth);
      Int2.addIsSigned(b, node.isSigned);
      return Int2.endInt(b);
    }
    visitFloat(node, b) {
      FloatingPoint.startFloatingPoint(b);
      FloatingPoint.addPrecision(b, node.precision);
      return FloatingPoint.endFloatingPoint(b);
    }
    visitBinary(_node, b) {
      Binary.startBinary(b);
      return Binary.endBinary(b);
    }
    visitLargeBinary(_node, b) {
      LargeBinary.startLargeBinary(b);
      return LargeBinary.endLargeBinary(b);
    }
    visitBool(_node, b) {
      Bool.startBool(b);
      return Bool.endBool(b);
    }
    visitUtf8(_node, b) {
      Utf8.startUtf8(b);
      return Utf8.endUtf8(b);
    }
    visitLargeUtf8(_node, b) {
      LargeUtf8.startLargeUtf8(b);
      return LargeUtf8.endLargeUtf8(b);
    }
    visitDecimal(node, b) {
      Decimal.startDecimal(b);
      Decimal.addScale(b, node.scale);
      Decimal.addPrecision(b, node.precision);
      Decimal.addBitWidth(b, node.bitWidth);
      return Decimal.endDecimal(b);
    }
    visitDate(node, b) {
      Date3.startDate(b);
      Date3.addUnit(b, node.unit);
      return Date3.endDate(b);
    }
    visitTime(node, b) {
      Time.startTime(b);
      Time.addUnit(b, node.unit);
      Time.addBitWidth(b, node.bitWidth);
      return Time.endTime(b);
    }
    visitTimestamp(node, b) {
      const timezone = node.timezone && b.createString(node.timezone) || undefined;
      Timestamp.startTimestamp(b);
      Timestamp.addUnit(b, node.unit);
      if (timezone !== undefined) {
        Timestamp.addTimezone(b, timezone);
      }
      return Timestamp.endTimestamp(b);
    }
    visitInterval(node, b) {
      Interval.startInterval(b);
      Interval.addUnit(b, node.unit);
      return Interval.endInterval(b);
    }
    visitDuration(node, b) {
      Duration.startDuration(b);
      Duration.addUnit(b, node.unit);
      return Duration.endDuration(b);
    }
    visitList(_node, b) {
      List.startList(b);
      return List.endList(b);
    }
    visitStruct(_node, b) {
      Struct_.startStruct_(b);
      return Struct_.endStruct_(b);
    }
    visitUnion(node, b) {
      Union3.startTypeIdsVector(b, node.typeIds.length);
      const typeIds = Union3.createTypeIdsVector(b, node.typeIds);
      Union3.startUnion(b);
      Union3.addMode(b, node.mode);
      Union3.addTypeIds(b, typeIds);
      return Union3.endUnion(b);
    }
    visitDictionary(node, b) {
      const indexType = this.visit(node.indices, b);
      DictionaryEncoding.startDictionaryEncoding(b);
      DictionaryEncoding.addId(b, BigInt(node.id));
      DictionaryEncoding.addIsOrdered(b, node.isOrdered);
      if (indexType !== undefined) {
        DictionaryEncoding.addIndexType(b, indexType);
      }
      return DictionaryEncoding.endDictionaryEncoding(b);
    }
    visitFixedSizeBinary(node, b) {
      FixedSizeBinary.startFixedSizeBinary(b);
      FixedSizeBinary.addByteWidth(b, node.byteWidth);
      return FixedSizeBinary.endFixedSizeBinary(b);
    }
    visitFixedSizeList(node, b) {
      FixedSizeList.startFixedSizeList(b);
      FixedSizeList.addListSize(b, node.listSize);
      return FixedSizeList.endFixedSizeList(b);
    }
    visitMap(node, b) {
      Map2.startMap(b);
      Map2.addKeysSorted(b, node.keysSorted);
      return Map2.endMap(b);
    }
  }
  var instance5 = new TypeAssembler;

  // node_modules/apache-arrow/ipc/metadata/json.mjs
  function schemaFromJSON(_schema, dictionaries = new Map) {
    return new Schema3(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema["metadata"]), dictionaries);
  }
  function recordBatchFromJSON(b) {
    return new RecordBatch3(b["count"], fieldNodesFromJSON(b["columns"]), buffersFromJSON(b["columns"]), null);
  }
  function dictionaryBatchFromJSON(b) {
    return new DictionaryBatch2(recordBatchFromJSON(b["data"]), b["id"], b["isDelta"]);
  }
  function schemaFieldsFromJSON(_schema, dictionaries) {
    return (_schema["fields"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));
  }
  function fieldChildrenFromJSON(_field, dictionaries) {
    return (_field["children"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));
  }
  function fieldNodesFromJSON(xs) {
    return (xs || []).reduce((fieldNodes, column) => [
      ...fieldNodes,
      new FieldNode2(column["count"], nullCountFromJSON(column["VALIDITY"])),
      ...fieldNodesFromJSON(column["children"])
    ], []);
  }
  function buffersFromJSON(xs, buffers = []) {
    for (let i2 = -1, n = (xs || []).length;++i2 < n; ) {
      const column = xs[i2];
      column["VALIDITY"] && buffers.push(new BufferRegion(buffers.length, column["VALIDITY"].length));
      column["TYPE_ID"] && buffers.push(new BufferRegion(buffers.length, column["TYPE_ID"].length));
      column["OFFSET"] && buffers.push(new BufferRegion(buffers.length, column["OFFSET"].length));
      column["DATA"] && buffers.push(new BufferRegion(buffers.length, column["DATA"].length));
      buffers = buffersFromJSON(column["children"], buffers);
    }
    return buffers;
  }
  function nullCountFromJSON(validity) {
    return (validity || []).reduce((sum3, val) => sum3 + +(val === 0), 0);
  }
  function fieldFromJSON(_field, dictionaries) {
    let id2;
    let keys3;
    let field;
    let dictMeta;
    let type;
    let dictType;
    if (!dictionaries || !(dictMeta = _field["dictionary"])) {
      type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));
      field = new Field2(_field["name"], type, _field["nullable"], customMetadataFromJSON(_field["metadata"]));
    } else if (!dictionaries.has(id2 = dictMeta["id"])) {
      keys3 = (keys3 = dictMeta["indexType"]) ? indexTypeFromJSON(keys3) : new Int32;
      dictionaries.set(id2, type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));
      dictType = new Dictionary(type, keys3, id2, dictMeta["isOrdered"]);
      field = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["metadata"]));
    } else {
      keys3 = (keys3 = dictMeta["indexType"]) ? indexTypeFromJSON(keys3) : new Int32;
      dictType = new Dictionary(dictionaries.get(id2), keys3, id2, dictMeta["isOrdered"]);
      field = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["metadata"]));
    }
    return field || null;
  }
  function customMetadataFromJSON(metadata = []) {
    return new Map(metadata.map(({ key, value }) => [key, value]));
  }
  function indexTypeFromJSON(_type) {
    return new Int_(_type["isSigned"], _type["bitWidth"]);
  }
  function typeFromJSON(f, children2) {
    const typeId = f["type"]["name"];
    switch (typeId) {
      case "NONE":
        return new Null2;
      case "null":
        return new Null2;
      case "binary":
        return new Binary2;
      case "largebinary":
        return new LargeBinary2;
      case "utf8":
        return new Utf82;
      case "largeutf8":
        return new LargeUtf82;
      case "bool":
        return new Bool2;
      case "list":
        return new List2((children2 || [])[0]);
      case "struct":
        return new Struct2(children2 || []);
      case "struct_":
        return new Struct2(children2 || []);
    }
    switch (typeId) {
      case "int": {
        const t = f["type"];
        return new Int_(t["isSigned"], t["bitWidth"]);
      }
      case "floatingpoint": {
        const t = f["type"];
        return new Float(Precision[t["precision"]]);
      }
      case "decimal": {
        const t = f["type"];
        return new Decimal2(t["scale"], t["precision"], t["bitWidth"]);
      }
      case "date": {
        const t = f["type"];
        return new Date_(DateUnit[t["unit"]]);
      }
      case "time": {
        const t = f["type"];
        return new Time_(TimeUnit[t["unit"]], t["bitWidth"]);
      }
      case "timestamp": {
        const t = f["type"];
        return new Timestamp_(TimeUnit[t["unit"]], t["timezone"]);
      }
      case "interval": {
        const t = f["type"];
        return new Interval_(IntervalUnit[t["unit"]]);
      }
      case "duration": {
        const t = f["type"];
        return new Duration2(TimeUnit[t["unit"]]);
      }
      case "union": {
        const t = f["type"];
        const [m, ...ms] = (t["mode"] + "").toLowerCase();
        const mode = m.toUpperCase() + ms.join("");
        return new Union_(UnionMode[mode], t["typeIds"] || [], children2 || []);
      }
      case "fixedsizebinary": {
        const t = f["type"];
        return new FixedSizeBinary2(t["byteWidth"]);
      }
      case "fixedsizelist": {
        const t = f["type"];
        return new FixedSizeList2(t["listSize"], (children2 || [])[0]);
      }
      case "map": {
        const t = f["type"];
        return new Map_((children2 || [])[0], t["keysSorted"]);
      }
    }
    throw new Error(`Unrecognized type: "${typeId}"`);
  }

  // node_modules/apache-arrow/ipc/metadata/message.mjs
  var Builder4 = Builder;
  var ByteBuffer3 = ByteBuffer;

  class Message2 {
    static fromJSON(msg, headerType) {
      const message = new Message2(0, MetadataVersion.V5, headerType);
      message._createHeader = messageHeaderFromJSON(msg, headerType);
      return message;
    }
    static decode(buf) {
      buf = new ByteBuffer3(toUint8Array(buf));
      const _message = Message.getRootAsMessage(buf);
      const bodyLength = _message.bodyLength();
      const version = _message.version();
      const headerType = _message.headerType();
      const message = new Message2(bodyLength, version, headerType);
      message._createHeader = decodeMessageHeader(_message, headerType);
      return message;
    }
    static encode(message) {
      const b = new Builder4;
      let headerOffset = -1;
      if (message.isSchema()) {
        headerOffset = Schema3.encode(b, message.header());
      } else if (message.isRecordBatch()) {
        headerOffset = RecordBatch3.encode(b, message.header());
      } else if (message.isDictionaryBatch()) {
        headerOffset = DictionaryBatch2.encode(b, message.header());
      }
      Message.startMessage(b);
      Message.addVersion(b, MetadataVersion.V5);
      Message.addHeader(b, headerOffset);
      Message.addHeaderType(b, message.headerType);
      Message.addBodyLength(b, BigInt(message.bodyLength));
      Message.finishMessageBuffer(b, Message.endMessage(b));
      return b.asUint8Array();
    }
    static from(header, bodyLength = 0) {
      if (header instanceof Schema3) {
        return new Message2(0, MetadataVersion.V5, MessageHeader.Schema, header);
      }
      if (header instanceof RecordBatch3) {
        return new Message2(bodyLength, MetadataVersion.V5, MessageHeader.RecordBatch, header);
      }
      if (header instanceof DictionaryBatch2) {
        return new Message2(bodyLength, MetadataVersion.V5, MessageHeader.DictionaryBatch, header);
      }
      throw new Error(`Unrecognized Message header: ${header}`);
    }
    get type() {
      return this.headerType;
    }
    get version() {
      return this._version;
    }
    get headerType() {
      return this._headerType;
    }
    get compression() {
      return this._compression;
    }
    get bodyLength() {
      return this._bodyLength;
    }
    header() {
      return this._createHeader();
    }
    isSchema() {
      return this.headerType === MessageHeader.Schema;
    }
    isRecordBatch() {
      return this.headerType === MessageHeader.RecordBatch;
    }
    isDictionaryBatch() {
      return this.headerType === MessageHeader.DictionaryBatch;
    }
    constructor(bodyLength, version, headerType, header) {
      this._version = version;
      this._headerType = headerType;
      this.body = new Uint8Array(0);
      this._compression = header === null || header === undefined ? undefined : header.compression;
      header && (this._createHeader = () => header);
      this._bodyLength = bigIntToNumber(bodyLength);
    }
  }

  class RecordBatch3 {
    get nodes() {
      return this._nodes;
    }
    get length() {
      return this._length;
    }
    get buffers() {
      return this._buffers;
    }
    get compression() {
      return this._compression;
    }
    constructor(length3, nodes, buffers, compression) {
      this._nodes = nodes;
      this._buffers = buffers;
      this._length = bigIntToNumber(length3);
      this._compression = compression;
    }
  }

  class DictionaryBatch2 {
    get id() {
      return this._id;
    }
    get data() {
      return this._data;
    }
    get isDelta() {
      return this._isDelta;
    }
    get length() {
      return this.data.length;
    }
    get nodes() {
      return this.data.nodes;
    }
    get buffers() {
      return this.data.buffers;
    }
    constructor(data, id2, isDelta = false) {
      this._data = data;
      this._isDelta = isDelta;
      this._id = bigIntToNumber(id2);
    }
  }

  class BufferRegion {
    constructor(offset, length3) {
      this.offset = bigIntToNumber(offset);
      this.length = bigIntToNumber(length3);
    }
  }

  class FieldNode2 {
    constructor(length3, nullCount) {
      this.length = bigIntToNumber(length3);
      this.nullCount = bigIntToNumber(nullCount);
    }
  }

  class BodyCompression2 {
    constructor(type, method = BodyCompressionMethod.BUFFER) {
      this.type = type;
      this.method = method;
    }
  }
  function messageHeaderFromJSON(message, type) {
    return () => {
      switch (type) {
        case MessageHeader.Schema:
          return Schema3.fromJSON(message);
        case MessageHeader.RecordBatch:
          return RecordBatch3.fromJSON(message);
        case MessageHeader.DictionaryBatch:
          return DictionaryBatch2.fromJSON(message);
      }
      throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type]}, type: ${type} }`);
    };
  }
  function decodeMessageHeader(message, type) {
    return () => {
      switch (type) {
        case MessageHeader.Schema:
          return Schema3.decode(message.header(new Schema2), new Map, message.version());
        case MessageHeader.RecordBatch:
          return RecordBatch3.decode(message.header(new RecordBatch2), message.version());
        case MessageHeader.DictionaryBatch:
          return DictionaryBatch2.decode(message.header(new DictionaryBatch), message.version());
      }
      throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type]}, type: ${type} }`);
    };
  }
  Field2["encode"] = encodeField;
  Field2["decode"] = decodeField;
  Field2["fromJSON"] = fieldFromJSON;
  Schema3["encode"] = encodeSchema;
  Schema3["decode"] = decodeSchema;
  Schema3["fromJSON"] = schemaFromJSON;
  RecordBatch3["encode"] = encodeRecordBatch;
  RecordBatch3["decode"] = decodeRecordBatch;
  RecordBatch3["fromJSON"] = recordBatchFromJSON;
  DictionaryBatch2["encode"] = encodeDictionaryBatch;
  DictionaryBatch2["decode"] = decodeDictionaryBatch;
  DictionaryBatch2["fromJSON"] = dictionaryBatchFromJSON;
  FieldNode2["encode"] = encodeFieldNode;
  FieldNode2["decode"] = decodeFieldNode;
  BufferRegion["encode"] = encodeBufferRegion;
  BufferRegion["decode"] = decodeBufferRegion;
  BodyCompression2["encode"] = encodeBodyCompression;
  BodyCompression2["decode"] = decodeBodyCompression;
  function decodeSchema(_schema, dictionaries = new Map, version = MetadataVersion.V5) {
    const fields = decodeSchemaFields(_schema, dictionaries);
    return new Schema3(fields, decodeCustomMetadata(_schema), dictionaries, version);
  }
  function decodeRecordBatch(batch, version = MetadataVersion.V5) {
    const recordBatch = new RecordBatch3(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version), decodeBodyCompression(batch.compression()));
    return recordBatch;
  }
  function decodeDictionaryBatch(batch, version = MetadataVersion.V5) {
    return new DictionaryBatch2(RecordBatch3.decode(batch.data(), version), batch.id(), batch.isDelta());
  }
  function decodeBufferRegion(b) {
    return new BufferRegion(b.offset(), b.length());
  }
  function decodeFieldNode(f) {
    return new FieldNode2(f.length(), f.nullCount());
  }
  function decodeFieldNodes(batch) {
    const nodes = [];
    for (let f, i2 = -1, j = -1, n = batch.nodesLength();++i2 < n; ) {
      if (f = batch.nodes(i2)) {
        nodes[++j] = FieldNode2.decode(f);
      }
    }
    return nodes;
  }
  function decodeBuffers(batch, version) {
    const bufferRegions = [];
    for (let b, i2 = -1, j = -1, n = batch.buffersLength();++i2 < n; ) {
      if (b = batch.buffers(i2)) {
        if (version < MetadataVersion.V4) {
          b.bb_pos += 8 * (i2 + 1);
        }
        bufferRegions[++j] = BufferRegion.decode(b);
      }
    }
    return bufferRegions;
  }
  function decodeSchemaFields(schema, dictionaries) {
    const fields = [];
    for (let f, i2 = -1, j = -1, n = schema.fieldsLength();++i2 < n; ) {
      if (f = schema.fields(i2)) {
        fields[++j] = Field2.decode(f, dictionaries);
      }
    }
    return fields;
  }
  function decodeFieldChildren(field, dictionaries) {
    const children2 = [];
    for (let f, i2 = -1, j = -1, n = field.childrenLength();++i2 < n; ) {
      if (f = field.children(i2)) {
        children2[++j] = Field2.decode(f, dictionaries);
      }
    }
    return children2;
  }
  function decodeField(f, dictionaries) {
    let id2;
    let field;
    let type;
    let keys3;
    let dictType;
    let dictMeta;
    if (!dictionaries || !(dictMeta = f.dictionary())) {
      type = decodeFieldType(f, decodeFieldChildren(f, dictionaries));
      field = new Field2(f.name(), type, f.nullable(), decodeCustomMetadata(f));
    } else if (!dictionaries.has(id2 = bigIntToNumber(dictMeta.id()))) {
      keys3 = (keys3 = dictMeta.indexType()) ? decodeIndexType(keys3) : new Int32;
      dictionaries.set(id2, type = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));
      dictType = new Dictionary(type, keys3, id2, dictMeta.isOrdered());
      field = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
    } else {
      keys3 = (keys3 = dictMeta.indexType()) ? decodeIndexType(keys3) : new Int32;
      dictType = new Dictionary(dictionaries.get(id2), keys3, id2, dictMeta.isOrdered());
      field = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
    }
    return field || null;
  }
  function decodeCustomMetadata(parent) {
    const data = new Map;
    if (parent) {
      for (let entry, key, i2 = -1, n = Math.trunc(parent.customMetadataLength());++i2 < n; ) {
        if ((entry = parent.customMetadata(i2)) && (key = entry.key()) != null) {
          data.set(key, entry.value());
        }
      }
    }
    return data;
  }
  function decodeIndexType(_type) {
    return new Int_(_type.isSigned(), _type.bitWidth());
  }
  function decodeFieldType(f, children2) {
    const typeId = f.typeType();
    switch (typeId) {
      case Type3["NONE"]:
        return new Null2;
      case Type3["Null"]:
        return new Null2;
      case Type3["Binary"]:
        return new Binary2;
      case Type3["LargeBinary"]:
        return new LargeBinary2;
      case Type3["Utf8"]:
        return new Utf82;
      case Type3["LargeUtf8"]:
        return new LargeUtf82;
      case Type3["Bool"]:
        return new Bool2;
      case Type3["List"]:
        return new List2((children2 || [])[0]);
      case Type3["Struct_"]:
        return new Struct2(children2 || []);
    }
    switch (typeId) {
      case Type3["Int"]: {
        const t = f.type(new Int2);
        return new Int_(t.isSigned(), t.bitWidth());
      }
      case Type3["FloatingPoint"]: {
        const t = f.type(new FloatingPoint);
        return new Float(t.precision());
      }
      case Type3["Decimal"]: {
        const t = f.type(new Decimal);
        return new Decimal2(t.scale(), t.precision(), t.bitWidth());
      }
      case Type3["Date"]: {
        const t = f.type(new Date3);
        return new Date_(t.unit());
      }
      case Type3["Time"]: {
        const t = f.type(new Time);
        return new Time_(t.unit(), t.bitWidth());
      }
      case Type3["Timestamp"]: {
        const t = f.type(new Timestamp);
        return new Timestamp_(t.unit(), t.timezone());
      }
      case Type3["Interval"]: {
        const t = f.type(new Interval);
        return new Interval_(t.unit());
      }
      case Type3["Duration"]: {
        const t = f.type(new Duration);
        return new Duration2(t.unit());
      }
      case Type3["Union"]: {
        const t = f.type(new Union3);
        return new Union_(t.mode(), t.typeIdsArray() || [], children2 || []);
      }
      case Type3["FixedSizeBinary"]: {
        const t = f.type(new FixedSizeBinary);
        return new FixedSizeBinary2(t.byteWidth());
      }
      case Type3["FixedSizeList"]: {
        const t = f.type(new FixedSizeList);
        return new FixedSizeList2(t.listSize(), (children2 || [])[0]);
      }
      case Type3["Map"]: {
        const t = f.type(new Map2);
        return new Map_((children2 || [])[0], t.keysSorted());
      }
    }
    throw new Error(`Unrecognized type: "${Type3[typeId]}" (${typeId})`);
  }
  function decodeBodyCompression(b) {
    return b ? new BodyCompression2(b.codec(), b.method()) : null;
  }
  function encodeSchema(b, schema) {
    const fieldOffsets = schema.fields.map((f) => Field2.encode(b, f));
    Schema2.startFieldsVector(b, fieldOffsets.length);
    const fieldsVectorOffset = Schema2.createFieldsVector(b, fieldOffsets);
    const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 : Schema2.createCustomMetadataVector(b, [...schema.metadata].map(([k, v]) => {
      const key = b.createString(`${k}`);
      const val = b.createString(`${v}`);
      KeyValue.startKeyValue(b);
      KeyValue.addKey(b, key);
      KeyValue.addValue(b, val);
      return KeyValue.endKeyValue(b);
    }));
    Schema2.startSchema(b);
    Schema2.addFields(b, fieldsVectorOffset);
    Schema2.addEndianness(b, platformIsLittleEndian ? Endianness.Little : Endianness.Big);
    if (metadataOffset !== -1) {
      Schema2.addCustomMetadata(b, metadataOffset);
    }
    return Schema2.endSchema(b);
  }
  function encodeField(b, field) {
    let nameOffset = -1;
    let typeOffset = -1;
    let dictionaryOffset = -1;
    const type = field.type;
    let typeId = field.typeId;
    if (!DataType.isDictionary(type)) {
      typeOffset = instance5.visit(type, b);
    } else {
      typeId = type.dictionary.typeId;
      dictionaryOffset = instance5.visit(type, b);
      typeOffset = instance5.visit(type.dictionary, b);
    }
    const childOffsets = (type.children || []).map((f) => Field2.encode(b, f));
    const childrenVectorOffset = Field.createChildrenVector(b, childOffsets);
    const metadataOffset = !(field.metadata && field.metadata.size > 0) ? -1 : Field.createCustomMetadataVector(b, [...field.metadata].map(([k, v]) => {
      const key = b.createString(`${k}`);
      const val = b.createString(`${v}`);
      KeyValue.startKeyValue(b);
      KeyValue.addKey(b, key);
      KeyValue.addValue(b, val);
      return KeyValue.endKeyValue(b);
    }));
    if (field.name) {
      nameOffset = b.createString(field.name);
    }
    Field.startField(b);
    Field.addType(b, typeOffset);
    Field.addTypeType(b, typeId);
    Field.addChildren(b, childrenVectorOffset);
    Field.addNullable(b, !!field.nullable);
    if (nameOffset !== -1) {
      Field.addName(b, nameOffset);
    }
    if (dictionaryOffset !== -1) {
      Field.addDictionary(b, dictionaryOffset);
    }
    if (metadataOffset !== -1) {
      Field.addCustomMetadata(b, metadataOffset);
    }
    return Field.endField(b);
  }
  function encodeRecordBatch(b, recordBatch) {
    const nodes = recordBatch.nodes || [];
    const buffers = recordBatch.buffers || [];
    RecordBatch2.startNodesVector(b, nodes.length);
    for (const n of nodes.slice().reverse())
      FieldNode2.encode(b, n);
    const nodesVectorOffset = b.endVector();
    RecordBatch2.startBuffersVector(b, buffers.length);
    for (const b_ of buffers.slice().reverse())
      BufferRegion.encode(b, b_);
    const buffersVectorOffset = b.endVector();
    let bodyCompressionOffset = null;
    if (recordBatch.compression !== null) {
      bodyCompressionOffset = encodeBodyCompression(b, recordBatch.compression);
    }
    RecordBatch2.startRecordBatch(b);
    RecordBatch2.addLength(b, BigInt(recordBatch.length));
    RecordBatch2.addNodes(b, nodesVectorOffset);
    RecordBatch2.addBuffers(b, buffersVectorOffset);
    if (recordBatch.compression !== null && bodyCompressionOffset) {
      RecordBatch2.addCompression(b, bodyCompressionOffset);
    }
    return RecordBatch2.endRecordBatch(b);
  }
  function encodeBodyCompression(b, node) {
    BodyCompression.startBodyCompression(b);
    BodyCompression.addCodec(b, node.type);
    BodyCompression.addMethod(b, node.method);
    return BodyCompression.endBodyCompression(b);
  }
  function encodeDictionaryBatch(b, dictionaryBatch) {
    const dataOffset = RecordBatch3.encode(b, dictionaryBatch.data);
    DictionaryBatch.startDictionaryBatch(b);
    DictionaryBatch.addId(b, BigInt(dictionaryBatch.id));
    DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);
    DictionaryBatch.addData(b, dataOffset);
    return DictionaryBatch.endDictionaryBatch(b);
  }
  function encodeFieldNode(b, node) {
    return FieldNode.createFieldNode(b, BigInt(node.length), BigInt(node.nullCount));
  }
  function encodeBufferRegion(b, node) {
    return Buffer3.createBuffer(b, BigInt(node.offset), BigInt(node.length));
  }
  var platformIsLittleEndian = (() => {
    const buffer4 = new ArrayBuffer(2);
    new DataView(buffer4).setInt16(0, 256, true);
    return new Int16Array(buffer4)[0] === 256;
  })();

  // node_modules/apache-arrow/io/interfaces.mjs
  var ITERATOR_DONE = Object.freeze({ done: true, value: undefined });

  class ArrowJSON {
    constructor(_json) {
      this._json = _json;
    }
    get schema() {
      return this._json["schema"];
    }
    get batches() {
      return this._json["batches"] || [];
    }
    get dictionaries() {
      return this._json["dictionaries"] || [];
    }
  }

  class ReadableInterop {
    tee() {
      return this._getDOMStream().tee();
    }
    pipe(writable, options) {
      return this._getNodeStream().pipe(writable, options);
    }
    pipeTo(writable, options) {
      return this._getDOMStream().pipeTo(writable, options);
    }
    pipeThrough(duplex, options) {
      return this._getDOMStream().pipeThrough(duplex, options);
    }
    _getDOMStream() {
      return this._DOMStream || (this._DOMStream = this.toDOMStream());
    }
    _getNodeStream() {
      return this._nodeStream || (this._nodeStream = this.toNodeStream());
    }
  }

  class AsyncQueue extends ReadableInterop {
    constructor() {
      super();
      this._values = [];
      this.resolvers = [];
      this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
    }
    get closed() {
      return this._closedPromise;
    }
    cancel(reason) {
      return __awaiter(this, undefined, undefined, function* () {
        yield this.return(reason);
      });
    }
    write(value) {
      if (this._ensureOpen()) {
        this.resolvers.length <= 0 ? this._values.push(value) : this.resolvers.shift().resolve({ done: false, value });
      }
    }
    abort(value) {
      if (this._closedPromiseResolve) {
        this.resolvers.length <= 0 ? this._error = { error: value } : this.resolvers.shift().reject({ done: true, value });
      }
    }
    close() {
      if (this._closedPromiseResolve) {
        const { resolvers } = this;
        while (resolvers.length > 0) {
          resolvers.shift().resolve(ITERATOR_DONE);
        }
        this._closedPromiseResolve();
        this._closedPromiseResolve = undefined;
      }
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    toDOMStream(options) {
      return adapters_default.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, options);
    }
    toNodeStream(options) {
      return adapters_default.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, options);
    }
    throw(_) {
      return __awaiter(this, undefined, undefined, function* () {
        yield this.abort(_);
        return ITERATOR_DONE;
      });
    }
    return(_) {
      return __awaiter(this, undefined, undefined, function* () {
        yield this.close();
        return ITERATOR_DONE;
      });
    }
    read(size13) {
      return __awaiter(this, undefined, undefined, function* () {
        return (yield this.next(size13, "read")).value;
      });
    }
    peek(size13) {
      return __awaiter(this, undefined, undefined, function* () {
        return (yield this.next(size13, "peek")).value;
      });
    }
    next(..._args) {
      if (this._values.length > 0) {
        return Promise.resolve({ done: false, value: this._values.shift() });
      } else if (this._error) {
        return Promise.reject({ done: true, value: this._error.error });
      } else if (!this._closedPromiseResolve) {
        return Promise.resolve(ITERATOR_DONE);
      } else {
        return new Promise((resolve5, reject) => {
          this.resolvers.push({ resolve: resolve5, reject });
        });
      }
    }
    _ensureOpen() {
      if (this._closedPromiseResolve) {
        return true;
      }
      throw new Error(`AsyncQueue is closed`);
    }
  }

  // node_modules/apache-arrow/io/stream.mjs
  class AsyncByteQueue extends AsyncQueue {
    write(value) {
      if ((value = toUint8Array(value)).byteLength > 0) {
        return super.write(value);
      }
    }
    toString(sync11 = false) {
      return sync11 ? decodeUtf8(this.toUint8Array(true)) : this.toUint8Array(false).then(decodeUtf8);
    }
    toUint8Array(sync11 = false) {
      return sync11 ? joinUint8Arrays(this._values)[0] : (() => __awaiter(this, undefined, undefined, function* () {
        var _a3, e_1, _b2, _c2;
        const buffers = [];
        let byteLength2 = 0;
        try {
          for (var _d2 = true, _e2 = __asyncValues(this), _f2;_f2 = yield _e2.next(), _a3 = _f2.done, !_a3; _d2 = true) {
            _c2 = _f2.value;
            _d2 = false;
            const chunk3 = _c2;
            buffers.push(chunk3);
            byteLength2 += chunk3.byteLength;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d2 && !_a3 && (_b2 = _e2.return))
              yield _b2.call(_e2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return joinUint8Arrays(buffers, byteLength2)[0];
      }))();
    }
  }

  class ByteStream {
    constructor(source) {
      if (source) {
        this.source = new ByteStreamSource(adapters_default.fromIterable(source));
      }
    }
    [Symbol.iterator]() {
      return this;
    }
    next(value) {
      return this.source.next(value);
    }
    throw(value) {
      return this.source.throw(value);
    }
    return(value) {
      return this.source.return(value);
    }
    peek(size13) {
      return this.source.peek(size13);
    }
    read(size13) {
      return this.source.read(size13);
    }
  }

  class AsyncByteStream {
    constructor(source) {
      if (source instanceof AsyncByteStream) {
        this.source = source.source;
      } else if (source instanceof AsyncByteQueue) {
        this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
      } else if (isReadableNodeStream(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromNodeStream(source));
      } else if (isReadableDOMStream(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source));
      } else if (isFetchResponse(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source.body));
      } else if (isIterable2(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromIterable(source));
      } else if (isPromise(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
      } else if (isAsyncIterable(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
      }
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    next(value) {
      return this.source.next(value);
    }
    throw(value) {
      return this.source.throw(value);
    }
    return(value) {
      return this.source.return(value);
    }
    get closed() {
      return this.source.closed;
    }
    cancel(reason) {
      return this.source.cancel(reason);
    }
    peek(size13) {
      return this.source.peek(size13);
    }
    read(size13) {
      return this.source.read(size13);
    }
  }

  class ByteStreamSource {
    constructor(source) {
      this.source = source;
    }
    cancel(reason) {
      this.return(reason);
    }
    peek(size13) {
      return this.next(size13, "peek").value;
    }
    read(size13) {
      return this.next(size13, "read").value;
    }
    next(size13, cmd = "read") {
      return this.source.next({ cmd, size: size13 });
    }
    throw(value) {
      return Object.create(this.source.throw && this.source.throw(value) || ITERATOR_DONE);
    }
    return(value) {
      return Object.create(this.source.return && this.source.return(value) || ITERATOR_DONE);
    }
  }

  class AsyncByteStreamSource {
    constructor(source) {
      this.source = source;
      this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
    }
    cancel(reason) {
      return __awaiter(this, undefined, undefined, function* () {
        yield this.return(reason);
      });
    }
    get closed() {
      return this._closedPromise;
    }
    read(size13) {
      return __awaiter(this, undefined, undefined, function* () {
        return (yield this.next(size13, "read")).value;
      });
    }
    peek(size13) {
      return __awaiter(this, undefined, undefined, function* () {
        return (yield this.next(size13, "peek")).value;
      });
    }
    next(size_1) {
      return __awaiter(this, arguments, undefined, function* (size13, cmd = "read") {
        return yield this.source.next({ cmd, size: size13 });
      });
    }
    throw(value) {
      return __awaiter(this, undefined, undefined, function* () {
        const result = this.source.throw && (yield this.source.throw(value)) || ITERATOR_DONE;
        this._closedPromiseResolve && this._closedPromiseResolve();
        this._closedPromiseResolve = undefined;
        return Object.create(result);
      });
    }
    return(value) {
      return __awaiter(this, undefined, undefined, function* () {
        const result = this.source.return && (yield this.source.return(value)) || ITERATOR_DONE;
        this._closedPromiseResolve && this._closedPromiseResolve();
        this._closedPromiseResolve = undefined;
        return Object.create(result);
      });
    }
  }

  // node_modules/apache-arrow/io/file.mjs
  class RandomAccessFile extends ByteStream {
    constructor(buffer4, byteLength2) {
      super();
      this.position = 0;
      this.buffer = toUint8Array(buffer4);
      this.size = byteLength2 === undefined ? this.buffer.byteLength : byteLength2;
    }
    readInt32(position) {
      const { buffer: buffer4, byteOffset } = this.readAt(position, 4);
      return new DataView(buffer4, byteOffset).getInt32(0, true);
    }
    seek(position) {
      this.position = Math.min(position, this.size);
      return position < this.size;
    }
    read(nBytes) {
      const { buffer: buffer4, size: size13, position } = this;
      if (buffer4 && position < size13) {
        if (typeof nBytes !== "number") {
          nBytes = Number.POSITIVE_INFINITY;
        }
        this.position = Math.min(size13, position + Math.min(size13 - position, nBytes));
        return buffer4.subarray(position, this.position);
      }
      return null;
    }
    readAt(position, nBytes) {
      const buf = this.buffer;
      const end6 = Math.min(this.size, position + nBytes);
      return buf ? buf.subarray(position, end6) : new Uint8Array(nBytes);
    }
    close() {
      this.buffer && (this.buffer = null);
    }
    throw(value) {
      this.close();
      return { done: true, value };
    }
    return(value) {
      this.close();
      return { done: true, value };
    }
  }

  class AsyncRandomAccessFile extends AsyncByteStream {
    constructor(file, byteLength2) {
      super();
      this.position = 0;
      this._handle = file;
      if (typeof byteLength2 === "number") {
        this.size = byteLength2;
      } else {
        this._pending = (() => __awaiter(this, undefined, undefined, function* () {
          this.size = (yield file.stat()).size;
          delete this._pending;
        }))();
      }
    }
    readInt32(position) {
      return __awaiter(this, undefined, undefined, function* () {
        const { buffer: buffer4, byteOffset } = yield this.readAt(position, 4);
        return new DataView(buffer4, byteOffset).getInt32(0, true);
      });
    }
    seek(position) {
      return __awaiter(this, undefined, undefined, function* () {
        this._pending && (yield this._pending);
        this.position = Math.min(position, this.size);
        return position < this.size;
      });
    }
    read(nBytes) {
      return __awaiter(this, undefined, undefined, function* () {
        this._pending && (yield this._pending);
        const { _handle: file, size: size13, position } = this;
        if (file && position < size13) {
          if (typeof nBytes !== "number") {
            nBytes = Number.POSITIVE_INFINITY;
          }
          let pos = position, offset = 0, bytesRead = 0;
          const end6 = Math.min(size13, pos + Math.min(size13 - pos, nBytes));
          const buffer4 = new Uint8Array(Math.max(0, (this.position = end6) - pos));
          while ((pos += bytesRead) < end6 && (offset += bytesRead) < buffer4.byteLength) {
            ({ bytesRead } = yield file.read(buffer4, offset, buffer4.byteLength - offset, pos));
          }
          return buffer4;
        }
        return null;
      });
    }
    readAt(position, nBytes) {
      return __awaiter(this, undefined, undefined, function* () {
        this._pending && (yield this._pending);
        const { _handle: file, size: size13 } = this;
        if (file && position + nBytes < size13) {
          const end6 = Math.min(size13, position + nBytes);
          const buffer4 = new Uint8Array(end6 - position);
          return (yield file.read(buffer4, 0, nBytes, position)).buffer;
        }
        return new Uint8Array(nBytes);
      });
    }
    close() {
      return __awaiter(this, undefined, undefined, function* () {
        const f = this._handle;
        this._handle = null;
        f && (yield f.close());
      });
    }
    throw(value) {
      return __awaiter(this, undefined, undefined, function* () {
        yield this.close();
        return { done: true, value };
      });
    }
    return(value) {
      return __awaiter(this, undefined, undefined, function* () {
        yield this.close();
        return { done: true, value };
      });
    }
  }

  // node_modules/apache-arrow/util/int.mjs
  var exports_int = {};
  __export(exports_int, {
    Uint64: () => Uint642,
    Int64: () => Int642,
    Int128: () => Int128,
    BaseInt64: () => BaseInt64
  });
  var carryBit16 = 1 << 16;
  function intAsHex(value) {
    if (value < 0) {
      value = 4294967295 + value + 1;
    }
    return `0x${value.toString(16)}`;
  }
  var kInt32DecimalDigits = 8;
  var kPowersOfTen = [
    1,
    10,
    100,
    1000,
    1e4,
    1e5,
    1e6,
    1e7,
    1e8
  ];

  class BaseInt64 {
    constructor(buffer4) {
      this.buffer = buffer4;
    }
    high() {
      return this.buffer[1];
    }
    low() {
      return this.buffer[0];
    }
    _times(other) {
      const L = new Uint32Array([
        this.buffer[1] >>> 16,
        this.buffer[1] & 65535,
        this.buffer[0] >>> 16,
        this.buffer[0] & 65535
      ]);
      const R = new Uint32Array([
        other.buffer[1] >>> 16,
        other.buffer[1] & 65535,
        other.buffer[0] >>> 16,
        other.buffer[0] & 65535
      ]);
      let product = L[3] * R[3];
      this.buffer[0] = product & 65535;
      let sum3 = product >>> 16;
      product = L[2] * R[3];
      sum3 += product;
      product = L[3] * R[2] >>> 0;
      sum3 += product;
      this.buffer[0] += sum3 << 16;
      this.buffer[1] = sum3 >>> 0 < product ? carryBit16 : 0;
      this.buffer[1] += sum3 >>> 16;
      this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];
      this.buffer[1] += L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0] << 16;
      return this;
    }
    _plus(other) {
      const sum3 = this.buffer[0] + other.buffer[0] >>> 0;
      this.buffer[1] += other.buffer[1];
      if (sum3 < this.buffer[0] >>> 0) {
        ++this.buffer[1];
      }
      this.buffer[0] = sum3;
    }
    lessThan(other) {
      return this.buffer[1] < other.buffer[1] || this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0];
    }
    equals(other) {
      return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];
    }
    greaterThan(other) {
      return other.lessThan(this);
    }
    hex() {
      return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
    }
  }

  class Uint642 extends BaseInt64 {
    times(other) {
      this._times(other);
      return this;
    }
    plus(other) {
      this._plus(other);
      return this;
    }
    static from(val, out_buffer = new Uint32Array(2)) {
      return Uint642.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
    }
    static fromNumber(num, out_buffer = new Uint32Array(2)) {
      return Uint642.fromString(num.toString(), out_buffer);
    }
    static fromString(str, out_buffer = new Uint32Array(2)) {
      const length3 = str.length;
      const out = new Uint642(out_buffer);
      for (let posn = 0;posn < length3; ) {
        const group = kInt32DecimalDigits < length3 - posn ? kInt32DecimalDigits : length3 - posn;
        const chunk3 = new Uint642(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));
        const multiple = new Uint642(new Uint32Array([kPowersOfTen[group], 0]));
        out.times(multiple);
        out.plus(chunk3);
        posn += group;
      }
      return out;
    }
    static convertArray(values3) {
      const data = new Uint32Array(values3.length * 2);
      for (let i2 = -1, n = values3.length;++i2 < n; ) {
        Uint642.from(values3[i2], new Uint32Array(data.buffer, data.byteOffset + 2 * i2 * 4, 2));
      }
      return data;
    }
    static multiply(left3, right3) {
      const rtrn = new Uint642(new Uint32Array(left3.buffer));
      return rtrn.times(right3);
    }
    static add(left3, right3) {
      const rtrn = new Uint642(new Uint32Array(left3.buffer));
      return rtrn.plus(right3);
    }
  }

  class Int642 extends BaseInt64 {
    negate() {
      this.buffer[0] = ~this.buffer[0] + 1;
      this.buffer[1] = ~this.buffer[1];
      if (this.buffer[0] == 0) {
        ++this.buffer[1];
      }
      return this;
    }
    times(other) {
      this._times(other);
      return this;
    }
    plus(other) {
      this._plus(other);
      return this;
    }
    lessThan(other) {
      const this_high = this.buffer[1] << 0;
      const other_high = other.buffer[1] << 0;
      return this_high < other_high || this_high === other_high && this.buffer[0] < other.buffer[0];
    }
    static from(val, out_buffer = new Uint32Array(2)) {
      return Int642.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
    }
    static fromNumber(num, out_buffer = new Uint32Array(2)) {
      return Int642.fromString(num.toString(), out_buffer);
    }
    static fromString(str, out_buffer = new Uint32Array(2)) {
      const negate3 = str.startsWith("-");
      const length3 = str.length;
      const out = new Int642(out_buffer);
      for (let posn = negate3 ? 1 : 0;posn < length3; ) {
        const group = kInt32DecimalDigits < length3 - posn ? kInt32DecimalDigits : length3 - posn;
        const chunk3 = new Int642(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));
        const multiple = new Int642(new Uint32Array([kPowersOfTen[group], 0]));
        out.times(multiple);
        out.plus(chunk3);
        posn += group;
      }
      return negate3 ? out.negate() : out;
    }
    static convertArray(values3) {
      const data = new Uint32Array(values3.length * 2);
      for (let i2 = -1, n = values3.length;++i2 < n; ) {
        Int642.from(values3[i2], new Uint32Array(data.buffer, data.byteOffset + 2 * i2 * 4, 2));
      }
      return data;
    }
    static multiply(left3, right3) {
      const rtrn = new Int642(new Uint32Array(left3.buffer));
      return rtrn.times(right3);
    }
    static add(left3, right3) {
      const rtrn = new Int642(new Uint32Array(left3.buffer));
      return rtrn.plus(right3);
    }
  }

  class Int128 {
    constructor(buffer4) {
      this.buffer = buffer4;
    }
    high() {
      return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
    }
    low() {
      return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
    }
    negate() {
      this.buffer[0] = ~this.buffer[0] + 1;
      this.buffer[1] = ~this.buffer[1];
      this.buffer[2] = ~this.buffer[2];
      this.buffer[3] = ~this.buffer[3];
      if (this.buffer[0] == 0) {
        ++this.buffer[1];
      }
      if (this.buffer[1] == 0) {
        ++this.buffer[2];
      }
      if (this.buffer[2] == 0) {
        ++this.buffer[3];
      }
      return this;
    }
    times(other) {
      const L0 = new Uint642(new Uint32Array([this.buffer[3], 0]));
      const L1 = new Uint642(new Uint32Array([this.buffer[2], 0]));
      const L2 = new Uint642(new Uint32Array([this.buffer[1], 0]));
      const L3 = new Uint642(new Uint32Array([this.buffer[0], 0]));
      const R0 = new Uint642(new Uint32Array([other.buffer[3], 0]));
      const R1 = new Uint642(new Uint32Array([other.buffer[2], 0]));
      const R2 = new Uint642(new Uint32Array([other.buffer[1], 0]));
      const R3 = new Uint642(new Uint32Array([other.buffer[0], 0]));
      let product = Uint642.multiply(L3, R3);
      this.buffer[0] = product.low();
      const sum3 = new Uint642(new Uint32Array([product.high(), 0]));
      product = Uint642.multiply(L2, R3);
      sum3.plus(product);
      product = Uint642.multiply(L3, R2);
      sum3.plus(product);
      this.buffer[1] = sum3.low();
      this.buffer[3] = sum3.lessThan(product) ? 1 : 0;
      this.buffer[2] = sum3.high();
      const high = new Uint642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
      high.plus(Uint642.multiply(L1, R3)).plus(Uint642.multiply(L2, R2)).plus(Uint642.multiply(L3, R1));
      this.buffer[3] += Uint642.multiply(L0, R3).plus(Uint642.multiply(L1, R2)).plus(Uint642.multiply(L2, R1)).plus(Uint642.multiply(L3, R0)).low();
      return this;
    }
    plus(other) {
      const sums = new Uint32Array(4);
      sums[3] = this.buffer[3] + other.buffer[3] >>> 0;
      sums[2] = this.buffer[2] + other.buffer[2] >>> 0;
      sums[1] = this.buffer[1] + other.buffer[1] >>> 0;
      sums[0] = this.buffer[0] + other.buffer[0] >>> 0;
      if (sums[0] < this.buffer[0] >>> 0) {
        ++sums[1];
      }
      if (sums[1] < this.buffer[1] >>> 0) {
        ++sums[2];
      }
      if (sums[2] < this.buffer[2] >>> 0) {
        ++sums[3];
      }
      this.buffer[3] = sums[3];
      this.buffer[2] = sums[2];
      this.buffer[1] = sums[1];
      this.buffer[0] = sums[0];
      return this;
    }
    hex() {
      return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
    }
    static multiply(left3, right3) {
      const rtrn = new Int128(new Uint32Array(left3.buffer));
      return rtrn.times(right3);
    }
    static add(left3, right3) {
      const rtrn = new Int128(new Uint32Array(left3.buffer));
      return rtrn.plus(right3);
    }
    static from(val, out_buffer = new Uint32Array(4)) {
      return Int128.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
    }
    static fromNumber(num, out_buffer = new Uint32Array(4)) {
      return Int128.fromString(num.toString(), out_buffer);
    }
    static fromString(str, out_buffer = new Uint32Array(4)) {
      const negate3 = str.startsWith("-");
      const length3 = str.length;
      const out = new Int128(out_buffer);
      for (let posn = negate3 ? 1 : 0;posn < length3; ) {
        const group = kInt32DecimalDigits < length3 - posn ? kInt32DecimalDigits : length3 - posn;
        const chunk3 = new Int128(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0, 0, 0]));
        const multiple = new Int128(new Uint32Array([kPowersOfTen[group], 0, 0, 0]));
        out.times(multiple);
        out.plus(chunk3);
        posn += group;
      }
      return negate3 ? out.negate() : out;
    }
    static convertArray(values3) {
      const data = new Uint32Array(values3.length * 4);
      for (let i2 = -1, n = values3.length;++i2 < n; ) {
        Int128.from(values3[i2], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i2, 4));
      }
      return data;
    }
  }

  // node_modules/apache-arrow/util/interval.mjs
  var exports_interval2 = {};
  __export(exports_interval2, {
    toIntervalMonthDayNanoObjects: () => toIntervalMonthDayNanoObjects,
    toIntervalMonthDayNanoInt32Array: () => toIntervalMonthDayNanoInt32Array,
    toIntervalDayTimeObjects: () => toIntervalDayTimeObjects,
    toIntervalDayTimeInt32Array: () => toIntervalDayTimeInt32Array
  });
  function toIntervalDayTimeInt32Array(objects) {
    var _a3, _b2;
    const length3 = objects.length;
    const array4 = new Int32Array(length3 * 2);
    for (let oi = 0, ai = 0;oi < length3; oi++) {
      const interval = objects[oi];
      array4[ai++] = (_a3 = interval["days"]) !== null && _a3 !== undefined ? _a3 : 0;
      array4[ai++] = (_b2 = interval["milliseconds"]) !== null && _b2 !== undefined ? _b2 : 0;
    }
    return array4;
  }
  function toIntervalMonthDayNanoInt32Array(objects) {
    var _a3, _b2;
    const length3 = objects.length;
    const data = new Int32Array(length3 * 4);
    for (let oi = 0, ai = 0;oi < length3; oi++) {
      const interval = objects[oi];
      data[ai++] = (_a3 = interval["months"]) !== null && _a3 !== undefined ? _a3 : 0;
      data[ai++] = (_b2 = interval["days"]) !== null && _b2 !== undefined ? _b2 : 0;
      const nanoseconds = interval["nanoseconds"];
      if (nanoseconds) {
        data[ai++] = Number(BigInt(nanoseconds) & BigInt(4294967295));
        data[ai++] = Number(BigInt(nanoseconds) >> BigInt(32));
      } else {
        ai += 2;
      }
    }
    return data;
  }
  function toIntervalDayTimeObjects(array4) {
    const length3 = array4.length;
    const objects = new Array(length3 / 2);
    for (let ai = 0, oi = 0;ai < length3; ai += 2) {
      objects[oi++] = {
        days: array4[ai],
        milliseconds: array4[ai + 1]
      };
    }
    return objects;
  }
  function toIntervalMonthDayNanoObjects(array4, stringifyNano) {
    const length3 = array4.length;
    const objects = new Array(length3 / 4);
    for (let ai = 0, oi = 0;ai < length3; ai += 4) {
      const nanoseconds = BigInt(array4[ai + 3]) << BigInt(32) | BigInt(array4[ai + 2] >>> 0);
      objects[oi++] = {
        months: array4[ai],
        days: array4[ai + 1],
        nanoseconds: stringifyNano ? `${nanoseconds}` : nanoseconds
      };
    }
    return objects;
  }

  // node_modules/apache-arrow/visitor/vectorloader.mjs
  class VectorLoader extends Visitor {
    constructor(bytes, nodes, buffers, dictionaries, metadataVersion = MetadataVersion.V5) {
      super();
      this.nodesIndex = -1;
      this.buffersIndex = -1;
      this.bytes = bytes;
      this.nodes = nodes;
      this.buffers = buffers;
      this.dictionaries = dictionaries;
      this.metadataVersion = metadataVersion;
    }
    visit(node) {
      return super.visit(node instanceof Field2 ? node.type : node);
    }
    visitNull(type, { length: length3 } = this.nextFieldNode()) {
      return makeData({ type, length: length3 });
    }
    visitBool(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitInt(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitFloat(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitUtf8(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitLargeUtf8(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitBinary(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitLargeBinary(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitFixedSizeBinary(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDate(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitTimestamp(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitTime(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDecimal(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitList(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), child: this.visit(type.children[0]) });
    }
    visitStruct(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), children: this.visitMany(type.children) });
    }
    visitUnion(type, { length: length3, nullCount } = this.nextFieldNode()) {
      if (this.metadataVersion < MetadataVersion.V5) {
        this.readNullBitmap(type, nullCount);
      }
      return type.mode === UnionMode.Sparse ? this.visitSparseUnion(type, { length: length3, nullCount }) : this.visitDenseUnion(type, { length: length3, nullCount });
    }
    visitDenseUnion(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, typeIds: this.readTypeIds(type), valueOffsets: this.readOffsets(type), children: this.visitMany(type.children) });
    }
    visitSparseUnion(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, typeIds: this.readTypeIds(type), children: this.visitMany(type.children) });
    }
    visitDictionary(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type.indices), dictionary: this.readDictionary(type) });
    }
    visitInterval(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDuration(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitFixedSizeList(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), child: this.visit(type.children[0]) });
    }
    visitMap(type, { length: length3, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), child: this.visit(type.children[0]) });
    }
    nextFieldNode() {
      return this.nodes[++this.nodesIndex];
    }
    nextBufferRange() {
      return this.buffers[++this.buffersIndex];
    }
    readNullBitmap(type, nullCount, buffer4 = this.nextBufferRange()) {
      return nullCount > 0 && this.readData(type, buffer4) || new Uint8Array(0);
    }
    readOffsets(type, buffer4) {
      return this.readData(type, buffer4);
    }
    readTypeIds(type, buffer4) {
      return this.readData(type, buffer4);
    }
    readData(_type, { length: length3, offset } = this.nextBufferRange()) {
      return this.bytes.subarray(offset, offset + length3);
    }
    readDictionary(type) {
      return this.dictionaries.get(type.id);
    }
  }

  class JSONVectorLoader extends VectorLoader {
    constructor(sources, nodes, buffers, dictionaries, metadataVersion) {
      super(new Uint8Array(0), nodes, buffers, dictionaries, metadataVersion);
      this.sources = sources;
    }
    readNullBitmap(_type, nullCount, { offset } = this.nextBufferRange()) {
      return nullCount <= 0 ? new Uint8Array(0) : packBools(this.sources[offset]);
    }
    readOffsets(_type, { offset } = this.nextBufferRange()) {
      return toArrayBufferView(Uint8Array, toArrayBufferView(_type.OffsetArrayType, this.sources[offset]));
    }
    readTypeIds(type, { offset } = this.nextBufferRange()) {
      return toArrayBufferView(Uint8Array, toArrayBufferView(type.ArrayType, this.sources[offset]));
    }
    readData(type, { offset } = this.nextBufferRange()) {
      const { sources } = this;
      if (DataType.isTimestamp(type)) {
        return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset]));
      } else if ((DataType.isInt(type) || DataType.isTime(type)) && type.bitWidth === 64 || DataType.isDuration(type)) {
        return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset]));
      } else if (DataType.isDate(type) && type.unit === DateUnit.MILLISECOND) {
        return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset]));
      } else if (DataType.isDecimal(type)) {
        return toArrayBufferView(Uint8Array, Int128.convertArray(sources[offset]));
      } else if (DataType.isBinary(type) || DataType.isLargeBinary(type) || DataType.isFixedSizeBinary(type)) {
        return binaryDataFromJSON(sources[offset]);
      } else if (DataType.isBool(type)) {
        return packBools(sources[offset]);
      } else if (DataType.isUtf8(type) || DataType.isLargeUtf8(type)) {
        return encodeUtf8(sources[offset].join(""));
      } else if (DataType.isInterval(type)) {
        switch (type.unit) {
          case IntervalUnit.DAY_TIME:
            return toIntervalDayTimeInt32Array(sources[offset]);
          case IntervalUnit.MONTH_DAY_NANO:
            return toIntervalMonthDayNanoInt32Array(sources[offset]);
          default:
            break;
        }
      }
      return toArrayBufferView(Uint8Array, toArrayBufferView(type.ArrayType, sources[offset].map((x) => +x)));
    }
  }
  function binaryDataFromJSON(values3) {
    const joined = values3.join("");
    const data = new Uint8Array(joined.length / 2);
    for (let i2 = 0;i2 < joined.length; i2 += 2) {
      data[i2 >> 1] = Number.parseInt(joined.slice(i2, i2 + 2), 16);
    }
    return data;
  }

  class CompressedVectorLoader extends VectorLoader {
    constructor(bodyChunks, nodes, buffers, dictionaries, metadataVersion) {
      super(new Uint8Array(0), nodes, buffers, dictionaries, metadataVersion);
      this.bodyChunks = bodyChunks;
    }
    readData(_type, _buffer = this.nextBufferRange()) {
      return this.bodyChunks[this.buffersIndex];
    }
  }

  // node_modules/apache-arrow/builder/binary.mjs
  class BinaryBuilder extends VariableWidthBuilder {
    constructor(opts) {
      super(opts);
      this._values = new BufferBuilder(Uint8Array);
    }
    get byteLength() {
      let size13 = this._pendingLength + this.length * 4;
      this._offsets && (size13 += this._offsets.byteLength);
      this._values && (size13 += this._values.byteLength);
      this._nulls && (size13 += this._nulls.byteLength);
      return size13;
    }
    setValue(index, value) {
      return super.setValue(index, toUint8Array(value));
    }
    _flushPending(pending3, pendingLength) {
      const offsets = this._offsets;
      const data = this._values.reserve(pendingLength).buffer;
      let offset = 0;
      for (const [index, value] of pending3) {
        if (value === undefined) {
          offsets.set(index, 0);
        } else {
          const length3 = value.length;
          data.set(value, offset);
          offsets.set(index, length3);
          offset += length3;
        }
      }
    }
  }

  // node_modules/apache-arrow/builder/largebinary.mjs
  class LargeBinaryBuilder extends VariableWidthBuilder {
    constructor(opts) {
      super(opts);
      this._values = new BufferBuilder(Uint8Array);
    }
    get byteLength() {
      let size13 = this._pendingLength + this.length * 4;
      this._offsets && (size13 += this._offsets.byteLength);
      this._values && (size13 += this._values.byteLength);
      this._nulls && (size13 += this._nulls.byteLength);
      return size13;
    }
    setValue(index, value) {
      return super.setValue(index, toUint8Array(value));
    }
    _flushPending(pending3, pendingLength) {
      const offsets = this._offsets;
      const data = this._values.reserve(pendingLength).buffer;
      let offset = 0;
      for (const [index, value] of pending3) {
        if (value === undefined) {
          offsets.set(index, BigInt(0));
        } else {
          const length3 = value.length;
          data.set(value, offset);
          offsets.set(index, BigInt(length3));
          offset += length3;
        }
      }
    }
  }

  // node_modules/apache-arrow/builder/bool.mjs
  class BoolBuilder extends Builder2 {
    constructor(options) {
      super(options);
      this._values = new BitmapBufferBuilder;
    }
    setValue(index, value) {
      this._values.set(index, +value);
    }
  }

  // node_modules/apache-arrow/builder/date.mjs
  class DateBuilder extends FixedWidthBuilder {
  }
  DateBuilder.prototype._setValue = setDate;

  class DateDayBuilder extends DateBuilder {
  }
  DateDayBuilder.prototype._setValue = setDateDay;

  class DateMillisecondBuilder extends DateBuilder {
  }
  DateMillisecondBuilder.prototype._setValue = setDateMillisecond;

  // node_modules/apache-arrow/builder/decimal.mjs
  class DecimalBuilder extends FixedWidthBuilder {
  }
  DecimalBuilder.prototype._setValue = setDecimal;

  // node_modules/apache-arrow/builder/dictionary.mjs
  class DictionaryBuilder extends Builder2 {
    constructor({ type, nullValues: nulls, dictionaryHashFunction: hashFn }) {
      super({ type: new Dictionary(type.dictionary, type.indices, type.id, type.isOrdered) });
      this._nulls = null;
      this._dictionaryOffset = 0;
      this._keysToIndices = Object.create(null);
      this.indices = makeBuilder2({ type: this.type.indices, nullValues: nulls });
      this.dictionary = makeBuilder2({ type: this.type.dictionary, nullValues: null });
      if (typeof hashFn === "function") {
        this.valueToKey = hashFn;
      }
    }
    get values() {
      return this.indices.values;
    }
    get nullCount() {
      return this.indices.nullCount;
    }
    get nullBitmap() {
      return this.indices.nullBitmap;
    }
    get byteLength() {
      return this.indices.byteLength + this.dictionary.byteLength;
    }
    get reservedLength() {
      return this.indices.reservedLength + this.dictionary.reservedLength;
    }
    get reservedByteLength() {
      return this.indices.reservedByteLength + this.dictionary.reservedByteLength;
    }
    isValid(value) {
      return this.indices.isValid(value);
    }
    setValid(index, valid) {
      const indices = this.indices;
      valid = indices.setValid(index, valid);
      this.length = indices.length;
      return valid;
    }
    setValue(index, value) {
      const keysToIndices = this._keysToIndices;
      const key = this.valueToKey(value);
      let idx = keysToIndices[key];
      if (idx === undefined) {
        keysToIndices[key] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;
      }
      return this.indices.setValue(index, idx);
    }
    flush() {
      const type = this.type;
      const prev = this._dictionary;
      const curr = this.dictionary.toVector();
      const data = this.indices.flush().clone(type);
      data.dictionary = prev ? prev.concat(curr) : curr;
      this.finished || (this._dictionaryOffset += curr.length);
      this._dictionary = data.dictionary;
      this.clear();
      return data;
    }
    finish() {
      this.indices.finish();
      this.dictionary.finish();
      this._dictionaryOffset = 0;
      this._keysToIndices = Object.create(null);
      return super.finish();
    }
    clear() {
      this.indices.clear();
      this.dictionary.clear();
      return super.clear();
    }
    valueToKey(val) {
      return typeof val === "string" ? val : `${val}`;
    }
  }

  // node_modules/apache-arrow/builder/fixedsizebinary.mjs
  class FixedSizeBinaryBuilder extends FixedWidthBuilder {
  }
  FixedSizeBinaryBuilder.prototype._setValue = setFixedSizeBinary;

  // node_modules/apache-arrow/builder/fixedsizelist.mjs
  class FixedSizeListBuilder extends Builder2 {
    setValue(index, value) {
      const [child] = this.children;
      const start4 = index * this.stride;
      for (let i2 = -1, n = this.stride;++i2 < n; ) {
        child.set(start4 + i2, value[i2]);
      }
    }
    setValid(index, valid) {
      if (!super.setValid(index, valid)) {
        this.children[0].setValid((index + 1) * this.stride - 1, false);
      }
      return valid;
    }
    addChild(child, name = "0") {
      if (this.numChildren > 0) {
        throw new Error("FixedSizeListBuilder can only have one child.");
      }
      const childIndex = this.children.push(child);
      this.type = new FixedSizeList2(this.type.listSize, new Field2(name, child.type, true));
      return childIndex;
    }
  }

  // node_modules/apache-arrow/builder/float.mjs
  class FloatBuilder extends FixedWidthBuilder {
    setValue(index, value) {
      this._values.set(index, value);
    }
  }

  class Float16Builder extends FloatBuilder {
    setValue(index, value) {
      super.setValue(index, float64ToUint16(value));
    }
  }

  class Float32Builder extends FloatBuilder {
  }

  class Float64Builder extends FloatBuilder {
  }

  // node_modules/apache-arrow/builder/interval.mjs
  class IntervalBuilder extends FixedWidthBuilder {
  }
  IntervalBuilder.prototype._setValue = setIntervalValue;

  class IntervalDayTimeBuilder extends IntervalBuilder {
  }
  IntervalDayTimeBuilder.prototype._setValue = setIntervalDayTime;

  class IntervalYearMonthBuilder extends IntervalBuilder {
  }
  IntervalYearMonthBuilder.prototype._setValue = setIntervalYearMonth;

  class IntervalMonthDayNanoBuilder extends IntervalBuilder {
  }
  IntervalMonthDayNanoBuilder.prototype._setValue = setIntervalMonthDayNano;

  // node_modules/apache-arrow/builder/duration.mjs
  class DurationBuilder extends FixedWidthBuilder {
  }
  DurationBuilder.prototype._setValue = setDuration;

  class DurationSecondBuilder extends DurationBuilder {
  }
  DurationSecondBuilder.prototype._setValue = setDurationSecond;

  class DurationMillisecondBuilder extends DurationBuilder {
  }
  DurationMillisecondBuilder.prototype._setValue = setDurationMillisecond;

  class DurationMicrosecondBuilder extends DurationBuilder {
  }
  DurationMicrosecondBuilder.prototype._setValue = setDurationMicrosecond;

  class DurationNanosecondBuilder extends DurationBuilder {
  }
  DurationNanosecondBuilder.prototype._setValue = setDurationNanosecond;

  // node_modules/apache-arrow/builder/int.mjs
  class IntBuilder extends FixedWidthBuilder {
    setValue(index, value) {
      this._values.set(index, value);
    }
  }

  class Int8Builder extends IntBuilder {
  }

  class Int16Builder extends IntBuilder {
  }

  class Int32Builder extends IntBuilder {
  }

  class Int64Builder extends IntBuilder {
  }

  class Uint8Builder extends IntBuilder {
  }

  class Uint16Builder extends IntBuilder {
  }

  class Uint32Builder extends IntBuilder {
  }

  class Uint64Builder extends IntBuilder {
  }

  // node_modules/apache-arrow/builder/list.mjs
  class ListBuilder extends VariableWidthBuilder {
    constructor(opts) {
      super(opts);
      this._offsets = new OffsetsBufferBuilder(opts.type);
    }
    addChild(child, name = "0") {
      if (this.numChildren > 0) {
        throw new Error("ListBuilder can only have one child.");
      }
      this.children[this.numChildren] = child;
      this.type = new List2(new Field2(name, child.type, true));
      return this.numChildren - 1;
    }
    _flushPending(pending3) {
      const offsets = this._offsets;
      const [child] = this.children;
      for (const [index, value] of pending3) {
        if (typeof value === "undefined") {
          offsets.set(index, 0);
        } else {
          const v = value;
          const n = v.length;
          const start4 = offsets.set(index, n).buffer[index];
          for (let i2 = -1;++i2 < n; ) {
            child.set(start4 + i2, v[i2]);
          }
        }
      }
    }
  }

  // node_modules/apache-arrow/builder/map.mjs
  class MapBuilder extends VariableWidthBuilder {
    set(index, value) {
      return super.set(index, value);
    }
    setValue(index, value) {
      const row = value instanceof Map ? value : new Map(Object.entries(value));
      const pending3 = this._pending || (this._pending = new Map);
      const current2 = pending3.get(index);
      current2 && (this._pendingLength -= current2.size);
      this._pendingLength += row.size;
      pending3.set(index, row);
    }
    addChild(child, name = `${this.numChildren}`) {
      if (this.numChildren > 0) {
        throw new Error("ListBuilder can only have one child.");
      }
      this.children[this.numChildren] = child;
      this.type = new Map_(new Field2(name, child.type, true), this.type.keysSorted);
      return this.numChildren - 1;
    }
    _flushPending(pending3) {
      const offsets = this._offsets;
      const [child] = this.children;
      for (const [index, value] of pending3) {
        if (value === undefined) {
          offsets.set(index, 0);
        } else {
          let { [index]: idx, [index + 1]: end6 } = offsets.set(index, value.size).buffer;
          for (const val of value.entries()) {
            child.set(idx, val);
            if (++idx >= end6)
              break;
          }
        }
      }
    }
  }

  // node_modules/apache-arrow/builder/null.mjs
  class NullBuilder extends Builder2 {
    setValue(index, value) {}
    setValid(index, valid) {
      this.length = Math.max(index + 1, this.length);
      return valid;
    }
  }

  // node_modules/apache-arrow/builder/struct.mjs
  class StructBuilder extends Builder2 {
    setValue(index, value) {
      const { children: children2, type } = this;
      switch (Array.isArray(value) || value.constructor) {
        case true:
          return type.children.forEach((_, i2) => children2[i2].set(index, value[i2]));
        case Map:
          return type.children.forEach((f, i2) => children2[i2].set(index, value.get(f.name)));
        default:
          return type.children.forEach((f, i2) => children2[i2].set(index, value[f.name]));
      }
    }
    setValid(index, valid) {
      if (!super.setValid(index, valid)) {
        this.children.forEach((child) => child.setValid(index, valid));
      }
      return valid;
    }
    addChild(child, name = `${this.numChildren}`) {
      const childIndex = this.children.push(child);
      this.type = new Struct2([...this.type.children, new Field2(name, child.type, true)]);
      return childIndex;
    }
  }

  // node_modules/apache-arrow/builder/timestamp.mjs
  class TimestampBuilder extends FixedWidthBuilder {
  }
  TimestampBuilder.prototype._setValue = setTimestamp;

  class TimestampSecondBuilder extends TimestampBuilder {
  }
  TimestampSecondBuilder.prototype._setValue = setTimestampSecond;

  class TimestampMillisecondBuilder extends TimestampBuilder {
  }
  TimestampMillisecondBuilder.prototype._setValue = setTimestampMillisecond;

  class TimestampMicrosecondBuilder extends TimestampBuilder {
  }
  TimestampMicrosecondBuilder.prototype._setValue = setTimestampMicrosecond;

  class TimestampNanosecondBuilder extends TimestampBuilder {
  }
  TimestampNanosecondBuilder.prototype._setValue = setTimestampNanosecond;

  // node_modules/apache-arrow/builder/time.mjs
  class TimeBuilder extends FixedWidthBuilder {
  }
  TimeBuilder.prototype._setValue = setTime;

  class TimeSecondBuilder extends TimeBuilder {
  }
  TimeSecondBuilder.prototype._setValue = setTimeSecond;

  class TimeMillisecondBuilder extends TimeBuilder {
  }
  TimeMillisecondBuilder.prototype._setValue = setTimeMillisecond;

  class TimeMicrosecondBuilder extends TimeBuilder {
  }
  TimeMicrosecondBuilder.prototype._setValue = setTimeMicrosecond;

  class TimeNanosecondBuilder extends TimeBuilder {
  }
  TimeNanosecondBuilder.prototype._setValue = setTimeNanosecond;

  // node_modules/apache-arrow/builder/union.mjs
  class UnionBuilder extends Builder2 {
    constructor(options) {
      super(options);
      this._typeIds = new DataBufferBuilder(Int8Array, 0, 1);
      if (typeof options["valueToChildTypeId"] === "function") {
        this._valueToChildTypeId = options["valueToChildTypeId"];
      }
    }
    get typeIdToChildIndex() {
      return this.type.typeIdToChildIndex;
    }
    append(value, childTypeId) {
      return this.set(this.length, value, childTypeId);
    }
    set(index, value, childTypeId) {
      if (childTypeId === undefined) {
        childTypeId = this._valueToChildTypeId(this, value, index);
      }
      this.setValue(index, value, childTypeId);
      return this;
    }
    setValue(index, value, childTypeId) {
      this._typeIds.set(index, childTypeId);
      const childIndex = this.type.typeIdToChildIndex[childTypeId];
      const child = this.children[childIndex];
      child === null || child === undefined || child.set(index, value);
      this.length = Math.max(index + 1, this.length);
    }
    addChild(child, name = `${this.children.length}`) {
      const childTypeId = this.children.push(child);
      const { type: { children: children2, mode, typeIds } } = this;
      const fields = [...children2, new Field2(name, child.type)];
      this.type = new Union_(mode, [...typeIds, childTypeId], fields);
      return childTypeId;
    }
    _valueToChildTypeId(builder, value, offset) {
      throw new Error(`Cannot map UnionBuilder value to child typeId. Pass the \`childTypeId\` as the second argument to unionBuilder.append(), or supply a \`valueToChildTypeId\` function as part of the UnionBuilder constructor options.`);
    }
  }

  class SparseUnionBuilder extends UnionBuilder {
  }

  class DenseUnionBuilder extends UnionBuilder {
    constructor(options) {
      super(options);
      this._offsets = new DataBufferBuilder(Int32Array);
    }
    setValue(index, value, childTypeId) {
      const id2 = this._typeIds.set(index, childTypeId).buffer[index];
      const child = this.getChildAt(this.type.typeIdToChildIndex[id2]);
      const denseIndex = this._offsets.set(index, child.length).buffer[index];
      child === null || child === undefined || child.set(denseIndex, value);
      this.length = Math.max(index + 1, this.length);
    }
  }

  // node_modules/apache-arrow/builder/utf8.mjs
  class Utf8Builder extends VariableWidthBuilder {
    constructor(opts) {
      super(opts);
      this._values = new BufferBuilder(Uint8Array);
    }
    get byteLength() {
      let size13 = this._pendingLength + this.length * 4;
      this._offsets && (size13 += this._offsets.byteLength);
      this._values && (size13 += this._values.byteLength);
      this._nulls && (size13 += this._nulls.byteLength);
      return size13;
    }
    setValue(index, value) {
      return super.setValue(index, encodeUtf8(value));
    }
    _flushPending(pending3, pendingLength) {}
  }
  Utf8Builder.prototype._flushPending = BinaryBuilder.prototype._flushPending;

  // node_modules/apache-arrow/builder/largeutf8.mjs
  class LargeUtf8Builder extends VariableWidthBuilder {
    constructor(opts) {
      super(opts);
      this._values = new BufferBuilder(Uint8Array);
    }
    get byteLength() {
      let size13 = this._pendingLength + this.length * 4;
      this._offsets && (size13 += this._offsets.byteLength);
      this._values && (size13 += this._values.byteLength);
      this._nulls && (size13 += this._nulls.byteLength);
      return size13;
    }
    setValue(index, value) {
      return super.setValue(index, encodeUtf8(value));
    }
    _flushPending(pending3, pendingLength) {}
  }
  LargeUtf8Builder.prototype._flushPending = LargeBinaryBuilder.prototype._flushPending;

  // node_modules/apache-arrow/visitor/builderctor.mjs
  class GetBuilderCtor extends Visitor {
    visitNull() {
      return NullBuilder;
    }
    visitBool() {
      return BoolBuilder;
    }
    visitInt() {
      return IntBuilder;
    }
    visitInt8() {
      return Int8Builder;
    }
    visitInt16() {
      return Int16Builder;
    }
    visitInt32() {
      return Int32Builder;
    }
    visitInt64() {
      return Int64Builder;
    }
    visitUint8() {
      return Uint8Builder;
    }
    visitUint16() {
      return Uint16Builder;
    }
    visitUint32() {
      return Uint32Builder;
    }
    visitUint64() {
      return Uint64Builder;
    }
    visitFloat() {
      return FloatBuilder;
    }
    visitFloat16() {
      return Float16Builder;
    }
    visitFloat32() {
      return Float32Builder;
    }
    visitFloat64() {
      return Float64Builder;
    }
    visitUtf8() {
      return Utf8Builder;
    }
    visitLargeUtf8() {
      return LargeUtf8Builder;
    }
    visitBinary() {
      return BinaryBuilder;
    }
    visitLargeBinary() {
      return LargeBinaryBuilder;
    }
    visitFixedSizeBinary() {
      return FixedSizeBinaryBuilder;
    }
    visitDate() {
      return DateBuilder;
    }
    visitDateDay() {
      return DateDayBuilder;
    }
    visitDateMillisecond() {
      return DateMillisecondBuilder;
    }
    visitTimestamp() {
      return TimestampBuilder;
    }
    visitTimestampSecond() {
      return TimestampSecondBuilder;
    }
    visitTimestampMillisecond() {
      return TimestampMillisecondBuilder;
    }
    visitTimestampMicrosecond() {
      return TimestampMicrosecondBuilder;
    }
    visitTimestampNanosecond() {
      return TimestampNanosecondBuilder;
    }
    visitTime() {
      return TimeBuilder;
    }
    visitTimeSecond() {
      return TimeSecondBuilder;
    }
    visitTimeMillisecond() {
      return TimeMillisecondBuilder;
    }
    visitTimeMicrosecond() {
      return TimeMicrosecondBuilder;
    }
    visitTimeNanosecond() {
      return TimeNanosecondBuilder;
    }
    visitDecimal() {
      return DecimalBuilder;
    }
    visitList() {
      return ListBuilder;
    }
    visitStruct() {
      return StructBuilder;
    }
    visitUnion() {
      return UnionBuilder;
    }
    visitDenseUnion() {
      return DenseUnionBuilder;
    }
    visitSparseUnion() {
      return SparseUnionBuilder;
    }
    visitDictionary() {
      return DictionaryBuilder;
    }
    visitInterval() {
      return IntervalBuilder;
    }
    visitIntervalDayTime() {
      return IntervalDayTimeBuilder;
    }
    visitIntervalYearMonth() {
      return IntervalYearMonthBuilder;
    }
    visitIntervalMonthDayNano() {
      return IntervalMonthDayNanoBuilder;
    }
    visitDuration() {
      return DurationBuilder;
    }
    visitDurationSecond() {
      return DurationSecondBuilder;
    }
    visitDurationMillisecond() {
      return DurationMillisecondBuilder;
    }
    visitDurationMicrosecond() {
      return DurationMicrosecondBuilder;
    }
    visitDurationNanosecond() {
      return DurationNanosecondBuilder;
    }
    visitFixedSizeList() {
      return FixedSizeListBuilder;
    }
    visitMap() {
      return MapBuilder;
    }
  }
  var instance6 = new GetBuilderCtor;

  // node_modules/apache-arrow/visitor/typecomparator.mjs
  class TypeComparator extends Visitor {
    compareSchemas(schema, other) {
      return schema === other || other instanceof schema.constructor && this.compareManyFields(schema.fields, other.fields);
    }
    compareManyFields(fields, others) {
      return fields === others || Array.isArray(fields) && Array.isArray(others) && fields.length === others.length && fields.every((f, i2) => this.compareFields(f, others[i2]));
    }
    compareFields(field, other) {
      return field === other || other instanceof field.constructor && field.name === other.name && field.nullable === other.nullable && this.visit(field.type, other.type);
    }
  }
  function compareConstructor(type, other) {
    return other instanceof type.constructor;
  }
  function compareAny(type, other) {
    return type === other || compareConstructor(type, other);
  }
  function compareInt(type, other) {
    return type === other || compareConstructor(type, other) && type.bitWidth === other.bitWidth && type.isSigned === other.isSigned;
  }
  function compareFloat(type, other) {
    return type === other || compareConstructor(type, other) && type.precision === other.precision;
  }
  function compareFixedSizeBinary(type, other) {
    return type === other || compareConstructor(type, other) && type.byteWidth === other.byteWidth;
  }
  function compareDate(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit;
  }
  function compareTimestamp(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit && type.timezone === other.timezone;
  }
  function compareTime(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit && type.bitWidth === other.bitWidth;
  }
  function compareList(type, other) {
    return type === other || compareConstructor(type, other) && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
  }
  function compareStruct(type, other) {
    return type === other || compareConstructor(type, other) && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
  }
  function compareUnion(type, other) {
    return type === other || compareConstructor(type, other) && type.mode === other.mode && type.typeIds.every((x, i2) => x === other.typeIds[i2]) && instance7.compareManyFields(type.children, other.children);
  }
  function compareDictionary(type, other) {
    return type === other || compareConstructor(type, other) && type.id === other.id && type.isOrdered === other.isOrdered && instance7.visit(type.indices, other.indices) && instance7.visit(type.dictionary, other.dictionary);
  }
  function compareInterval(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit;
  }
  function compareDuration(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit;
  }
  function compareFixedSizeList(type, other) {
    return type === other || compareConstructor(type, other) && type.listSize === other.listSize && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
  }
  function compareMap(type, other) {
    return type === other || compareConstructor(type, other) && type.keysSorted === other.keysSorted && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
  }
  TypeComparator.prototype.visitNull = compareAny;
  TypeComparator.prototype.visitBool = compareAny;
  TypeComparator.prototype.visitInt = compareInt;
  TypeComparator.prototype.visitInt8 = compareInt;
  TypeComparator.prototype.visitInt16 = compareInt;
  TypeComparator.prototype.visitInt32 = compareInt;
  TypeComparator.prototype.visitInt64 = compareInt;
  TypeComparator.prototype.visitUint8 = compareInt;
  TypeComparator.prototype.visitUint16 = compareInt;
  TypeComparator.prototype.visitUint32 = compareInt;
  TypeComparator.prototype.visitUint64 = compareInt;
  TypeComparator.prototype.visitFloat = compareFloat;
  TypeComparator.prototype.visitFloat16 = compareFloat;
  TypeComparator.prototype.visitFloat32 = compareFloat;
  TypeComparator.prototype.visitFloat64 = compareFloat;
  TypeComparator.prototype.visitUtf8 = compareAny;
  TypeComparator.prototype.visitLargeUtf8 = compareAny;
  TypeComparator.prototype.visitBinary = compareAny;
  TypeComparator.prototype.visitLargeBinary = compareAny;
  TypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;
  TypeComparator.prototype.visitDate = compareDate;
  TypeComparator.prototype.visitDateDay = compareDate;
  TypeComparator.prototype.visitDateMillisecond = compareDate;
  TypeComparator.prototype.visitTimestamp = compareTimestamp;
  TypeComparator.prototype.visitTimestampSecond = compareTimestamp;
  TypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;
  TypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;
  TypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;
  TypeComparator.prototype.visitTime = compareTime;
  TypeComparator.prototype.visitTimeSecond = compareTime;
  TypeComparator.prototype.visitTimeMillisecond = compareTime;
  TypeComparator.prototype.visitTimeMicrosecond = compareTime;
  TypeComparator.prototype.visitTimeNanosecond = compareTime;
  TypeComparator.prototype.visitDecimal = compareAny;
  TypeComparator.prototype.visitList = compareList;
  TypeComparator.prototype.visitStruct = compareStruct;
  TypeComparator.prototype.visitUnion = compareUnion;
  TypeComparator.prototype.visitDenseUnion = compareUnion;
  TypeComparator.prototype.visitSparseUnion = compareUnion;
  TypeComparator.prototype.visitDictionary = compareDictionary;
  TypeComparator.prototype.visitInterval = compareInterval;
  TypeComparator.prototype.visitIntervalDayTime = compareInterval;
  TypeComparator.prototype.visitIntervalYearMonth = compareInterval;
  TypeComparator.prototype.visitIntervalMonthDayNano = compareInterval;
  TypeComparator.prototype.visitDuration = compareDuration;
  TypeComparator.prototype.visitDurationSecond = compareDuration;
  TypeComparator.prototype.visitDurationMillisecond = compareDuration;
  TypeComparator.prototype.visitDurationMicrosecond = compareDuration;
  TypeComparator.prototype.visitDurationNanosecond = compareDuration;
  TypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;
  TypeComparator.prototype.visitMap = compareMap;
  var instance7 = new TypeComparator;
  function compareSchemas(schema, other) {
    return instance7.compareSchemas(schema, other);
  }
  function compareFields(field, other) {
    return instance7.compareFields(field, other);
  }
  function compareTypes(type, other) {
    return instance7.visit(type, other);
  }

  // node_modules/apache-arrow/factories.mjs
  function makeBuilder2(options) {
    const type = options.type;
    const builder = new (instance6.getVisitFn(type)())(options);
    if (type.children && type.children.length > 0) {
      const children2 = options["children"] || [];
      const defaultOptions = { nullValues: options["nullValues"] };
      const getChildOptions = Array.isArray(children2) ? (_, i2) => children2[i2] || defaultOptions : ({ name }) => children2[name] || defaultOptions;
      for (const [index, field] of type.children.entries()) {
        const { type: type2 } = field;
        const opts = getChildOptions(field, index);
        builder.children.push(makeBuilder2(Object.assign(Object.assign({}, opts), { type: type2 })));
      }
    }
    return builder;
  }

  // node_modules/apache-arrow/util/recordbatch.mjs
  function distributeVectorsIntoRecordBatches(schema, vecs) {
    return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v) => v.data.concat()));
  }
  function uniformlyDistributeChunksAcrossRecordBatches(schema, cols) {
    const fields = [...schema.fields];
    const batches = [];
    const memo = { numBatches: cols.reduce((n, c) => Math.max(n, c.length), 0) };
    let numBatches = 0, batchLength = 0;
    let i2 = -1;
    const numColumns = cols.length;
    let child, children2 = [];
    while (memo.numBatches-- > 0) {
      for (batchLength = Number.POSITIVE_INFINITY, i2 = -1;++i2 < numColumns; ) {
        children2[i2] = child = cols[i2].shift();
        batchLength = Math.min(batchLength, child ? child.length : batchLength);
      }
      if (Number.isFinite(batchLength)) {
        children2 = distributeChildren(fields, batchLength, children2, cols, memo);
        if (batchLength > 0) {
          batches[numBatches++] = makeData({
            type: new Struct2(fields),
            length: batchLength,
            nullCount: 0,
            children: children2.slice()
          });
        }
      }
    }
    return [
      schema = schema.assign(fields),
      batches.map((data) => new RecordBatch4(schema, data))
    ];
  }
  function distributeChildren(fields, batchLength, children2, columns, memo) {
    var _a3;
    const nullBitmapSize = (batchLength + 63 & ~63) >> 3;
    for (let i2 = -1, n = columns.length;++i2 < n; ) {
      const child = children2[i2];
      const length3 = child === null || child === undefined ? undefined : child.length;
      if (length3 >= batchLength) {
        if (length3 === batchLength) {
          children2[i2] = child;
        } else {
          children2[i2] = child.slice(0, batchLength);
          memo.numBatches = Math.max(memo.numBatches, columns[i2].unshift(child.slice(batchLength, length3 - batchLength)));
        }
      } else {
        const field = fields[i2];
        fields[i2] = field.clone({ nullable: true });
        children2[i2] = (_a3 = child === null || child === undefined ? undefined : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a3 !== undefined ? _a3 : makeData({
          type: field.type,
          length: batchLength,
          nullCount: batchLength,
          nullBitmap: new Uint8Array(nullBitmapSize)
        });
      }
    }
    return children2;
  }

  // node_modules/apache-arrow/table.mjs
  var _a3;

  class Table2 {
    constructor(...args2) {
      var _b2, _c2;
      if (args2.length === 0) {
        this.batches = [];
        this.schema = new Schema3([]);
        this._offsets = [0];
        return this;
      }
      let schema;
      let offsets;
      if (args2[0] instanceof Schema3) {
        schema = args2.shift();
      }
      if (args2.at(-1) instanceof Uint32Array) {
        offsets = args2.pop();
      }
      const unwrap5 = (x) => {
        if (x) {
          if (x instanceof RecordBatch4) {
            return [x];
          } else if (x instanceof Table2) {
            return x.batches;
          } else if (x instanceof Data) {
            if (x.type instanceof Struct2) {
              return [new RecordBatch4(new Schema3(x.type.children), x)];
            }
          } else if (Array.isArray(x)) {
            return x.flatMap((v) => unwrap5(v));
          } else if (typeof x[Symbol.iterator] === "function") {
            return [...x].flatMap((v) => unwrap5(v));
          } else if (typeof x === "object") {
            const keys3 = Object.keys(x);
            const vecs = keys3.map((k) => new Vector([x[k]]));
            const batchSchema = schema !== null && schema !== undefined ? schema : new Schema3(keys3.map((k, i2) => new Field2(String(k), vecs[i2].type, vecs[i2].nullable)));
            const [, batches2] = distributeVectorsIntoRecordBatches(batchSchema, vecs);
            return batches2.length === 0 ? [new RecordBatch4(x)] : batches2;
          }
        }
        return [];
      };
      const batches = args2.flatMap((v) => unwrap5(v));
      schema = (_c2 = schema !== null && schema !== undefined ? schema : (_b2 = batches[0]) === null || _b2 === undefined ? undefined : _b2.schema) !== null && _c2 !== undefined ? _c2 : new Schema3([]);
      if (!(schema instanceof Schema3)) {
        throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
      }
      for (const batch of batches) {
        if (!(batch instanceof RecordBatch4)) {
          throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
        }
        if (!compareSchemas(schema, batch.schema)) {
          throw new TypeError("Table and inner RecordBatch schemas must be equivalent.");
        }
      }
      this.schema = schema;
      this.batches = batches;
      this._offsets = offsets !== null && offsets !== undefined ? offsets : computeChunkOffsets(this.data);
    }
    get data() {
      return this.batches.map(({ data }) => data);
    }
    get numCols() {
      return this.schema.fields.length;
    }
    get numRows() {
      return this.data.reduce((numRows, data) => numRows + data.length, 0);
    }
    get nullCount() {
      if (this._nullCount === -1) {
        this._nullCount = computeChunkNullCounts(this.data);
      }
      return this._nullCount;
    }
    isValid(index) {
      return false;
    }
    get(index) {
      return null;
    }
    at(index) {
      return this.get(wrapIndex(index, this.numRows));
    }
    set(index, value) {
      return;
    }
    indexOf(element, offset) {
      return -1;
    }
    [Symbol.iterator]() {
      if (this.batches.length > 0) {
        return instance4.visit(new Vector(this.data));
      }
      return new Array(0)[Symbol.iterator]();
    }
    toArray() {
      return [...this];
    }
    toString() {
      return `[
  ${this.toArray().join(`,
  `)}
]`;
    }
    concat(...others) {
      const schema = this.schema;
      const data = this.data.concat(others.flatMap(({ data: data2 }) => data2));
      return new Table2(schema, data.map((data2) => new RecordBatch4(schema, data2)));
    }
    slice(begin, end6) {
      const schema = this.schema;
      [begin, end6] = clampRange({ length: this.numRows }, begin, end6);
      const data = sliceChunks(this.data, this._offsets, begin, end6);
      return new Table2(schema, data.map((chunk3) => new RecordBatch4(schema, chunk3)));
    }
    getChild(name) {
      return this.getChildAt(this.schema.fields.findIndex((f) => f.name === name));
    }
    getChildAt(index) {
      if (index > -1 && index < this.schema.fields.length) {
        const data = this.data.map((data2) => data2.children[index]);
        if (data.length === 0) {
          const { type } = this.schema.fields[index];
          const empty34 = makeData({ type, length: 0, nullCount: 0 });
          data.push(empty34._changeLengthAndBackfillNullBitmap(this.numRows));
        }
        return new Vector(data);
      }
      return null;
    }
    setChild(name, child) {
      var _b2;
      return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === undefined ? undefined : _b2.findIndex((f) => f.name === name), child);
    }
    setChildAt(index, child) {
      let schema = this.schema;
      let batches = [...this.batches];
      if (index > -1 && index < this.numCols) {
        if (!child) {
          child = new Vector([makeData({ type: new Null2, length: this.numRows })]);
        }
        const fields = schema.fields.slice();
        const field = fields[index].clone({ type: child.type });
        const children2 = this.schema.fields.map((_, i2) => this.getChildAt(i2));
        [fields[index], children2[index]] = [field, child];
        [schema, batches] = distributeVectorsIntoRecordBatches(schema, children2);
      }
      return new Table2(schema, batches);
    }
    select(columnNames) {
      const nameToIndex = this.schema.fields.reduce((m, f, i2) => m.set(f.name, i2), new Map);
      return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x) => x > -1));
    }
    selectAt(columnIndices) {
      const schema = this.schema.selectAt(columnIndices);
      const data = this.batches.map((batch) => batch.selectAt(columnIndices));
      return new Table2(schema, data);
    }
    assign(other) {
      const fields = this.schema.fields;
      const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {
        const [indices2, oldToNew2] = memo;
        const i2 = fields.findIndex((f) => f.name === f2.name);
        ~i2 ? oldToNew2[i2] = newIdx : indices2.push(newIdx);
        return memo;
      }, [[], []]);
      const schema = this.schema.assign(other.schema);
      const columns = [
        ...fields.map((_, i2) => [i2, oldToNew[i2]]).map(([i2, j]) => j === undefined ? this.getChildAt(i2) : other.getChildAt(j)),
        ...indices.map((i2) => other.getChildAt(i2))
      ].filter(Boolean);
      return new Table2(...distributeVectorsIntoRecordBatches(schema, columns));
    }
  }
  _a3 = Symbol.toStringTag;
  Table2[_a3] = ((proto12) => {
    proto12.schema = null;
    proto12.batches = [];
    proto12._offsets = new Uint32Array([0]);
    proto12._nullCount = -1;
    proto12[Symbol.isConcatSpreadable] = true;
    proto12["isValid"] = wrapChunkedCall1(isChunkedValid);
    proto12["get"] = wrapChunkedCall1(instance2.getVisitFn(Type4.Struct));
    proto12["set"] = wrapChunkedCall2(instance.getVisitFn(Type4.Struct));
    proto12["indexOf"] = wrapChunkedIndexOf(instance3.getVisitFn(Type4.Struct));
    return "Table";
  })(Table2.prototype);

  // node_modules/apache-arrow/recordbatch.mjs
  var _a4;

  class RecordBatch4 {
    constructor(...args2) {
      switch (args2.length) {
        case 2: {
          [this.schema] = args2;
          if (!(this.schema instanceof Schema3)) {
            throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
          }
          [
            ,
            this.data = makeData({
              nullCount: 0,
              type: new Struct2(this.schema.fields),
              children: this.schema.fields.map((f) => makeData({ type: f.type, nullCount: 0 }))
            })
          ] = args2;
          if (!(this.data instanceof Data)) {
            throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
          }
          [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);
          break;
        }
        case 1: {
          const [obj] = args2;
          const { fields, children: children2, length: length3 } = Object.keys(obj).reduce((memo, name, i2) => {
            memo.children[i2] = obj[name];
            memo.length = Math.max(memo.length, obj[name].length);
            memo.fields[i2] = Field2.new({ name, type: obj[name].type, nullable: true });
            return memo;
          }, {
            length: 0,
            fields: new Array,
            children: new Array
          });
          const schema = new Schema3(fields);
          const data = makeData({ type: new Struct2(fields), length: length3, children: children2, nullCount: 0 });
          [this.schema, this.data] = ensureSameLengthData(schema, data.children, length3);
          break;
        }
        default:
          throw new TypeError("RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.");
      }
    }
    get dictionaries() {
      return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));
    }
    get numCols() {
      return this.schema.fields.length;
    }
    get numRows() {
      return this.data.length;
    }
    get nullCount() {
      return this.data.nullCount;
    }
    isValid(index) {
      return this.data.getValid(index);
    }
    get(index) {
      return instance2.visit(this.data, index);
    }
    at(index) {
      return this.get(wrapIndex(index, this.numRows));
    }
    set(index, value) {
      return instance.visit(this.data, index, value);
    }
    indexOf(element, offset) {
      return instance3.visit(this.data, element, offset);
    }
    [Symbol.iterator]() {
      return instance4.visit(new Vector([this.data]));
    }
    toArray() {
      return [...this];
    }
    concat(...others) {
      return new Table2(this.schema, [this, ...others]);
    }
    slice(begin, end6) {
      const [slice2] = new Vector([this.data]).slice(begin, end6).data;
      return new RecordBatch4(this.schema, slice2);
    }
    getChild(name) {
      var _b2;
      return this.getChildAt((_b2 = this.schema.fields) === null || _b2 === undefined ? undefined : _b2.findIndex((f) => f.name === name));
    }
    getChildAt(index) {
      if (index > -1 && index < this.schema.fields.length) {
        return new Vector([this.data.children[index]]);
      }
      return null;
    }
    setChild(name, child) {
      var _b2;
      return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === undefined ? undefined : _b2.findIndex((f) => f.name === name), child);
    }
    setChildAt(index, child) {
      let schema = this.schema;
      let data = this.data;
      if (index > -1 && index < this.numCols) {
        if (!child) {
          child = new Vector([makeData({ type: new Null2, length: this.numRows })]);
        }
        const fields = schema.fields.slice();
        const children2 = data.children.slice();
        const field = fields[index].clone({ type: child.type });
        [fields[index], children2[index]] = [field, child.data[0]];
        schema = new Schema3(fields, new Map(this.schema.metadata));
        data = makeData({ type: new Struct2(fields), children: children2 });
      }
      return new RecordBatch4(schema, data);
    }
    select(columnNames) {
      const schema = this.schema.select(columnNames);
      const type = new Struct2(schema.fields);
      const children2 = [];
      for (const name of columnNames) {
        const index = this.schema.fields.findIndex((f) => f.name === name);
        if (~index) {
          children2[index] = this.data.children[index];
        }
      }
      return new RecordBatch4(schema, makeData({ type, length: this.numRows, children: children2 }));
    }
    selectAt(columnIndices) {
      const schema = this.schema.selectAt(columnIndices);
      const children2 = columnIndices.map((i2) => this.data.children[i2]).filter(Boolean);
      const subset = makeData({ type: new Struct2(schema.fields), length: this.numRows, children: children2 });
      return new RecordBatch4(schema, subset);
    }
  }
  _a4 = Symbol.toStringTag;
  RecordBatch4[_a4] = ((proto12) => {
    proto12._nullCount = -1;
    proto12[Symbol.isConcatSpreadable] = true;
    return "RecordBatch";
  })(RecordBatch4.prototype);
  function ensureSameLengthData(schema, chunks3, maxLength = chunks3.reduce((max5, col) => Math.max(max5, col.length), 0)) {
    var _b2;
    const fields = [...schema.fields];
    const children2 = [...chunks3];
    const nullBitmapSize = (maxLength + 63 & ~63) >> 3;
    for (const [idx, field] of schema.fields.entries()) {
      const chunk3 = chunks3[idx];
      if (!chunk3 || chunk3.length !== maxLength) {
        fields[idx] = field.clone({ nullable: true });
        children2[idx] = (_b2 = chunk3 === null || chunk3 === undefined ? undefined : chunk3._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b2 !== undefined ? _b2 : makeData({
          type: field.type,
          length: maxLength,
          nullCount: maxLength,
          nullBitmap: new Uint8Array(nullBitmapSize)
        });
      }
    }
    return [
      schema.assign(fields),
      makeData({ type: new Struct2(fields), length: maxLength, children: children2 })
    ];
  }
  function collectDictionaries(fields, children2, dictionaries = new Map) {
    var _b2, _c2;
    if (((_b2 = fields === null || fields === undefined ? undefined : fields.length) !== null && _b2 !== undefined ? _b2 : 0) > 0 && (fields === null || fields === undefined ? undefined : fields.length) === (children2 === null || children2 === undefined ? undefined : children2.length)) {
      for (let i2 = -1, n = fields.length;++i2 < n; ) {
        const { type } = fields[i2];
        const data = children2[i2];
        for (const next of [data, ...((_c2 = data === null || data === undefined ? undefined : data.dictionary) === null || _c2 === undefined ? undefined : _c2.data) || []]) {
          collectDictionaries(type.children, next === null || next === undefined ? undefined : next.children, dictionaries);
        }
        if (DataType.isDictionary(type)) {
          const { id: id2 } = type;
          if (!dictionaries.has(id2)) {
            if (data === null || data === undefined ? undefined : data.dictionary) {
              dictionaries.set(id2, data.dictionary);
            }
          } else if (dictionaries.get(id2) !== data.dictionary) {
            throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
          }
        }
      }
    }
    return dictionaries;
  }

  class _InternalEmptyPlaceholderRecordBatch extends RecordBatch4 {
    constructor(schema) {
      const children2 = schema.fields.map((f) => makeData({ type: f.type }));
      const data = makeData({ type: new Struct2(schema.fields), nullCount: 0, children: children2 });
      super(schema, data);
    }
  }

  // node_modules/apache-arrow/ipc/message.mjs
  var invalidMessageType = (type) => `Expected ${MessageHeader[type]} Message in stream, but was null or length 0.`;
  var nullMessage = (type) => `Header pointer of flatbuffer-encoded ${MessageHeader[type]} Message is null or length 0.`;
  var invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;
  var invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;

  class MessageReader {
    constructor(source) {
      this.source = source instanceof ByteStream ? source : new ByteStream(source);
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      let r;
      if ((r = this.readMetadataLength()).done) {
        return ITERATOR_DONE;
      }
      if (r.value === -1 && (r = this.readMetadataLength()).done) {
        return ITERATOR_DONE;
      }
      if ((r = this.readMetadata(r.value)).done) {
        return ITERATOR_DONE;
      }
      return r;
    }
    throw(value) {
      return this.source.throw(value);
    }
    return(value) {
      return this.source.return(value);
    }
    readMessage(type) {
      let r;
      if ((r = this.next()).done) {
        return null;
      }
      if (type != null && r.value.headerType !== type) {
        throw new Error(invalidMessageType(type));
      }
      return r.value;
    }
    readMessageBody(bodyLength) {
      if (bodyLength <= 0) {
        return new Uint8Array(0);
      }
      const buf = toUint8Array(this.source.read(bodyLength));
      if (buf.byteLength < bodyLength) {
        throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
      }
      return buf.byteOffset % 8 === 0 && buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice();
    }
    readSchema(throwIfNull = false) {
      const type = MessageHeader.Schema;
      const message = this.readMessage(type);
      const schema = message === null || message === undefined ? undefined : message.header();
      if (throwIfNull && !schema) {
        throw new Error(nullMessage(type));
      }
      return schema;
    }
    readMetadataLength() {
      const buf = this.source.read(PADDING);
      const bb = buf && new ByteBuffer(buf);
      const len2 = (bb === null || bb === undefined ? undefined : bb.readInt32(0)) || 0;
      return { done: len2 === 0, value: len2 };
    }
    readMetadata(metadataLength) {
      const buf = this.source.read(metadataLength);
      if (!buf) {
        return ITERATOR_DONE;
      }
      if (buf.byteLength < metadataLength) {
        throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
      }
      return { done: false, value: Message2.decode(buf) };
    }
  }

  class AsyncMessageReader {
    constructor(source, byteLength2) {
      this.source = source instanceof AsyncByteStream ? source : isFileHandle(source) ? new AsyncRandomAccessFile(source, byteLength2) : new AsyncByteStream(source);
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    next() {
      return __awaiter(this, undefined, undefined, function* () {
        let r;
        if ((r = yield this.readMetadataLength()).done) {
          return ITERATOR_DONE;
        }
        if (r.value === -1 && (r = yield this.readMetadataLength()).done) {
          return ITERATOR_DONE;
        }
        if ((r = yield this.readMetadata(r.value)).done) {
          return ITERATOR_DONE;
        }
        return r;
      });
    }
    throw(value) {
      return __awaiter(this, undefined, undefined, function* () {
        return yield this.source.throw(value);
      });
    }
    return(value) {
      return __awaiter(this, undefined, undefined, function* () {
        return yield this.source.return(value);
      });
    }
    readMessage(type) {
      return __awaiter(this, undefined, undefined, function* () {
        let r;
        if ((r = yield this.next()).done) {
          return null;
        }
        if (type != null && r.value.headerType !== type) {
          throw new Error(invalidMessageType(type));
        }
        return r.value;
      });
    }
    readMessageBody(bodyLength) {
      return __awaiter(this, undefined, undefined, function* () {
        if (bodyLength <= 0) {
          return new Uint8Array(0);
        }
        const buf = toUint8Array(yield this.source.read(bodyLength));
        if (buf.byteLength < bodyLength) {
          throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
        }
        return buf.byteOffset % 8 === 0 && buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice();
      });
    }
    readSchema() {
      return __awaiter(this, arguments, undefined, function* (throwIfNull = false) {
        const type = MessageHeader.Schema;
        const message = yield this.readMessage(type);
        const schema = message === null || message === undefined ? undefined : message.header();
        if (throwIfNull && !schema) {
          throw new Error(nullMessage(type));
        }
        return schema;
      });
    }
    readMetadataLength() {
      return __awaiter(this, undefined, undefined, function* () {
        const buf = yield this.source.read(PADDING);
        const bb = buf && new ByteBuffer(buf);
        const len2 = (bb === null || bb === undefined ? undefined : bb.readInt32(0)) || 0;
        return { done: len2 === 0, value: len2 };
      });
    }
    readMetadata(metadataLength) {
      return __awaiter(this, undefined, undefined, function* () {
        const buf = yield this.source.read(metadataLength);
        if (!buf) {
          return ITERATOR_DONE;
        }
        if (buf.byteLength < metadataLength) {
          throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
        }
        return { done: false, value: Message2.decode(buf) };
      });
    }
  }

  class JSONMessageReader extends MessageReader {
    constructor(source) {
      super(new Uint8Array(0));
      this._schema = false;
      this._body = [];
      this._batchIndex = 0;
      this._dictionaryIndex = 0;
      this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);
    }
    next() {
      const { _json } = this;
      if (!this._schema) {
        this._schema = true;
        const message = Message2.fromJSON(_json.schema, MessageHeader.Schema);
        return { done: false, value: message };
      }
      if (this._dictionaryIndex < _json.dictionaries.length) {
        const batch = _json.dictionaries[this._dictionaryIndex++];
        this._body = batch["data"]["columns"];
        const message = Message2.fromJSON(batch, MessageHeader.DictionaryBatch);
        return { done: false, value: message };
      }
      if (this._batchIndex < _json.batches.length) {
        const batch = _json.batches[this._batchIndex++];
        this._body = batch["columns"];
        const message = Message2.fromJSON(batch, MessageHeader.RecordBatch);
        return { done: false, value: message };
      }
      this._body = [];
      return ITERATOR_DONE;
    }
    readMessageBody(_bodyLength) {
      return flattenDataSources(this._body);
      function flattenDataSources(xs) {
        return (xs || []).reduce((buffers, column) => [
          ...buffers,
          ...column["VALIDITY"] && [column["VALIDITY"]] || [],
          ...column["TYPE_ID"] && [column["TYPE_ID"]] || [],
          ...column["OFFSET"] && [column["OFFSET"]] || [],
          ...column["DATA"] && [column["DATA"]] || [],
          ...flattenDataSources(column["children"])
        ], []);
      }
    }
    readMessage(type) {
      let r;
      if ((r = this.next()).done) {
        return null;
      }
      if (type != null && r.value.headerType !== type) {
        throw new Error(invalidMessageType(type));
      }
      return r.value;
    }
    readSchema() {
      const type = MessageHeader.Schema;
      const message = this.readMessage(type);
      const schema = message === null || message === undefined ? undefined : message.header();
      if (!message || !schema) {
        throw new Error(nullMessage(type));
      }
      return schema;
    }
  }
  var PADDING = 4;
  var MAGIC_STR = "ARROW1";
  var MAGIC = new Uint8Array(MAGIC_STR.length);
  for (let i2 = 0;i2 < MAGIC_STR.length; i2 += 1) {
    MAGIC[i2] = MAGIC_STR.codePointAt(i2);
  }
  function checkForMagicArrowString(buffer4, index = 0) {
    for (let i2 = -1, n = MAGIC.length;++i2 < n; ) {
      if (MAGIC[i2] !== buffer4[index + i2]) {
        return false;
      }
    }
    return true;
  }
  var magicLength = MAGIC.length;
  var magicAndPadding = magicLength + PADDING;
  var magicX2AndPadding = magicLength * 2 + PADDING;

  // node_modules/apache-arrow/ipc/compression/validators.mjs
  class Lz4FrameValidator {
    constructor() {
      this.LZ4_FRAME_MAGIC = new Uint8Array([4, 34, 77, 24]);
      this.MIN_HEADER_LENGTH = 7;
    }
    isValidCodecEncode(codec) {
      const testData = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);
      const compressed = codec.encode(testData);
      return this._isValidCompressed(compressed);
    }
    _isValidCompressed(buffer4) {
      return this._hasMinimumLength(buffer4) && this._hasValidMagicNumber(buffer4) && this._hasValidVersion(buffer4);
    }
    _hasMinimumLength(buffer4) {
      return buffer4.length >= this.MIN_HEADER_LENGTH;
    }
    _hasValidMagicNumber(buffer4) {
      return this.LZ4_FRAME_MAGIC.every((byte, i2) => buffer4[i2] === byte);
    }
    _hasValidVersion(buffer4) {
      const flg = buffer4[4];
      const versionBits = (flg & 192) >> 6;
      return versionBits === 1;
    }
  }

  class ZstdValidator {
    constructor() {
      this.ZSTD_MAGIC = new Uint8Array([40, 181, 47, 253]);
      this.MIN_HEADER_LENGTH = 6;
    }
    isValidCodecEncode(codec) {
      const testData = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);
      const compressed = codec.encode(testData);
      return this._isValidCompressed(compressed);
    }
    _isValidCompressed(buffer4) {
      return this._hasMinimumLength(buffer4) && this._hasValidMagicNumber(buffer4);
    }
    _hasMinimumLength(buffer4) {
      return buffer4.length >= this.MIN_HEADER_LENGTH;
    }
    _hasValidMagicNumber(buffer4) {
      return this.ZSTD_MAGIC.every((byte, i2) => buffer4[i2] === byte);
    }
  }
  var compressionValidators = {
    [CompressionType.LZ4_FRAME]: new Lz4FrameValidator,
    [CompressionType.ZSTD]: new ZstdValidator
  };

  // node_modules/apache-arrow/ipc/compression/registry.mjs
  class _CompressionRegistry {
    constructor() {
      this.registry = {};
    }
    set(compression, codec) {
      if ((codec === null || codec === undefined ? undefined : codec.encode) && typeof codec.encode === "function" && !compressionValidators[compression].isValidCodecEncode(codec)) {
        throw new Error(`Encoder for ${CompressionType[compression]} is not valid.`);
      }
      this.registry[compression] = codec;
    }
    get(compression) {
      var _a5;
      return ((_a5 = this.registry) === null || _a5 === undefined ? undefined : _a5[compression]) || null;
    }
  }
  var compressionRegistry = new _CompressionRegistry;

  // node_modules/apache-arrow/ipc/compression/constants.mjs
  var LENGTH_NO_COMPRESSED_DATA = -1;
  var COMPRESS_LENGTH_PREFIX = 8;

  // node_modules/apache-arrow/ipc/reader.mjs
  class RecordBatchReader extends ReadableInterop {
    constructor(impl) {
      super();
      this._impl = impl;
    }
    get closed() {
      return this._impl.closed;
    }
    get schema() {
      return this._impl.schema;
    }
    get autoDestroy() {
      return this._impl.autoDestroy;
    }
    get dictionaries() {
      return this._impl.dictionaries;
    }
    get numDictionaries() {
      return this._impl.numDictionaries;
    }
    get numRecordBatches() {
      return this._impl.numRecordBatches;
    }
    get footer() {
      return this._impl.isFile() ? this._impl.footer : null;
    }
    isSync() {
      return this._impl.isSync();
    }
    isAsync() {
      return this._impl.isAsync();
    }
    isFile() {
      return this._impl.isFile();
    }
    isStream() {
      return this._impl.isStream();
    }
    next() {
      return this._impl.next();
    }
    throw(value) {
      return this._impl.throw(value);
    }
    return(value) {
      return this._impl.return(value);
    }
    cancel() {
      return this._impl.cancel();
    }
    reset(schema) {
      this._impl.reset(schema);
      this._DOMStream = undefined;
      this._nodeStream = undefined;
      return this;
    }
    open(options) {
      const opening = this._impl.open(options);
      return isPromise(opening) ? opening.then(() => this) : this;
    }
    readRecordBatch(index) {
      return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;
    }
    [Symbol.iterator]() {
      return this._impl[Symbol.iterator]();
    }
    [Symbol.asyncIterator]() {
      return this._impl[Symbol.asyncIterator]();
    }
    toDOMStream() {
      return adapters_default.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });
    }
    toNodeStream() {
      return adapters_default.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: true });
    }
    static throughNode(options) {
      throw new Error(`"throughNode" not available in this environment`);
    }
    static throughDOM(writableStrategy, readableStrategy) {
      throw new Error(`"throughDOM" not available in this environment`);
    }
    static from(source) {
      if (source instanceof RecordBatchReader) {
        return source;
      } else if (isArrowJSON(source)) {
        return fromArrowJSON(source);
      } else if (isFileHandle(source)) {
        return fromFileHandle(source);
      } else if (isPromise(source)) {
        return (() => __awaiter(this, undefined, undefined, function* () {
          return yield RecordBatchReader.from(yield source);
        }))();
      } else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {
        return fromAsyncByteStream(new AsyncByteStream(source));
      }
      return fromByteStream(new ByteStream(source));
    }
    static readAll(source) {
      if (source instanceof RecordBatchReader) {
        return source.isSync() ? readAllSync(source) : readAllAsync(source);
      } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable2(source) || isIteratorResult(source)) {
        return readAllSync(source);
      }
      return readAllAsync(source);
    }
  }

  class RecordBatchStreamReader extends RecordBatchReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
    readAll() {
      return [...this];
    }
    [Symbol.iterator]() {
      return this._impl[Symbol.iterator]();
    }
    [Symbol.asyncIterator]() {
      return __asyncGenerator(this, arguments, function* _a() {
        yield __await(yield* __asyncDelegator(__asyncValues(this[Symbol.iterator]())));
      });
    }
  }

  class AsyncRecordBatchStreamReader extends RecordBatchReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
    readAll() {
      return __awaiter(this, undefined, undefined, function* () {
        var _a5, e_1, _b2, _c2;
        const batches = new Array;
        try {
          for (var _d2 = true, _e2 = __asyncValues(this), _f2;_f2 = yield _e2.next(), _a5 = _f2.done, !_a5; _d2 = true) {
            _c2 = _f2.value;
            _d2 = false;
            const batch = _c2;
            batches.push(batch);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d2 && !_a5 && (_b2 = _e2.return))
              yield _b2.call(_e2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return batches;
      });
    }
    [Symbol.iterator]() {
      throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);
    }
    [Symbol.asyncIterator]() {
      return this._impl[Symbol.asyncIterator]();
    }
  }

  class RecordBatchFileReader extends RecordBatchStreamReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
  }

  class AsyncRecordBatchFileReader extends AsyncRecordBatchStreamReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
  }

  class RecordBatchReaderImpl {
    get numDictionaries() {
      return this._dictionaryIndex;
    }
    get numRecordBatches() {
      return this._recordBatchIndex;
    }
    constructor(dictionaries = new Map) {
      this.closed = false;
      this.autoDestroy = true;
      this._dictionaryIndex = 0;
      this._recordBatchIndex = 0;
      this.dictionaries = dictionaries;
    }
    isSync() {
      return false;
    }
    isAsync() {
      return false;
    }
    isFile() {
      return false;
    }
    isStream() {
      return false;
    }
    reset(schema) {
      this._dictionaryIndex = 0;
      this._recordBatchIndex = 0;
      this.schema = schema;
      this.dictionaries = new Map;
      return this;
    }
    _loadRecordBatch(header, body) {
      let children2;
      if (header.compression != null) {
        const codec = compressionRegistry.get(header.compression.type);
        if ((codec === null || codec === undefined ? undefined : codec.decode) && typeof codec.decode === "function") {
          const { decommpressedBody, buffers } = this._decompressBuffers(header, body, codec);
          children2 = this._loadCompressedVectors(header, decommpressedBody, this.schema.fields);
          header = new RecordBatch3(header.length, header.nodes, buffers, null);
        } else {
          throw new Error("Record batch is compressed but codec not found");
        }
      } else {
        children2 = this._loadVectors(header, body, this.schema.fields);
      }
      const data = makeData({ type: new Struct2(this.schema.fields), length: header.length, children: children2 });
      return new RecordBatch4(this.schema, data);
    }
    _loadDictionaryBatch(header, body) {
      const { id: id2, isDelta } = header;
      const { dictionaries, schema } = this;
      const dictionary = dictionaries.get(id2);
      const type = schema.dictionaries.get(id2);
      let data;
      if (header.data.compression != null) {
        const codec = compressionRegistry.get(header.data.compression.type);
        if ((codec === null || codec === undefined ? undefined : codec.decode) && typeof codec.decode === "function") {
          const { decommpressedBody, buffers } = this._decompressBuffers(header.data, body, codec);
          data = this._loadCompressedVectors(header.data, decommpressedBody, [type]);
          header = new DictionaryBatch2(new RecordBatch3(header.data.length, header.data.nodes, buffers, null), id2, isDelta);
        } else {
          throw new Error("Dictionary batch is compressed but codec not found");
        }
      } else {
        data = this._loadVectors(header.data, body, [type]);
      }
      return (dictionary && isDelta ? dictionary.concat(new Vector(data)) : new Vector(data)).memoize();
    }
    _loadVectors(header, body, types2) {
      return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types2);
    }
    _loadCompressedVectors(header, body, types2) {
      return new CompressedVectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types2);
    }
    _decompressBuffers(header, body, codec) {
      const decompressedBuffers = [];
      const newBufferRegions = [];
      let currentOffset = 0;
      for (const { offset, length: length3 } of header.buffers) {
        if (length3 === 0) {
          decompressedBuffers.push(new Uint8Array(0));
          newBufferRegions.push(new BufferRegion(currentOffset, 0));
          continue;
        }
        const byteBuf = new ByteBuffer(body.subarray(offset, offset + length3));
        const uncompressedLenth = bigIntToNumber(byteBuf.readInt64(0));
        const bytes = byteBuf.bytes().subarray(COMPRESS_LENGTH_PREFIX);
        const decompressed = uncompressedLenth === LENGTH_NO_COMPRESSED_DATA ? bytes : codec.decode(bytes);
        decompressedBuffers.push(decompressed);
        const padding = (currentOffset + 7 & ~7) - currentOffset;
        currentOffset += padding;
        newBufferRegions.push(new BufferRegion(currentOffset, decompressed.length));
        currentOffset += decompressed.length;
      }
      return {
        decommpressedBody: decompressedBuffers,
        buffers: newBufferRegions
      };
    }
  }

  class RecordBatchStreamReaderImpl extends RecordBatchReaderImpl {
    constructor(source, dictionaries) {
      super(dictionaries);
      this._reader = !isArrowJSON(source) ? new MessageReader(this._handle = source) : new JSONMessageReader(this._handle = source);
    }
    isSync() {
      return true;
    }
    isStream() {
      return true;
    }
    [Symbol.iterator]() {
      return this;
    }
    cancel() {
      if (!this.closed && (this.closed = true)) {
        this.reset()._reader.return();
        this._reader = null;
        this.dictionaries = null;
      }
    }
    open(options) {
      if (!this.closed) {
        this.autoDestroy = shouldAutoDestroy(this, options);
        if (!(this.schema || (this.schema = this._reader.readSchema()))) {
          this.cancel();
        }
      }
      return this;
    }
    throw(value) {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return this.reset()._reader.throw(value);
      }
      return ITERATOR_DONE;
    }
    return(value) {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return this.reset()._reader.return(value);
      }
      return ITERATOR_DONE;
    }
    next() {
      if (this.closed) {
        return ITERATOR_DONE;
      }
      let message;
      const { _reader: reader } = this;
      while (message = this._readNextMessageAndValidate()) {
        if (message.isSchema()) {
          this.reset(message.header());
        } else if (message.isRecordBatch()) {
          this._recordBatchIndex++;
          const header = message.header();
          const buffer4 = reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer4);
          return { done: false, value: recordBatch };
        } else if (message.isDictionaryBatch()) {
          this._dictionaryIndex++;
          const header = message.header();
          const buffer4 = reader.readMessageBody(message.bodyLength);
          const vector = this._loadDictionaryBatch(header, buffer4);
          this.dictionaries.set(header.id, vector);
        }
      }
      if (this.schema && this._recordBatchIndex === 0) {
        this._recordBatchIndex++;
        return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };
      }
      return this.return();
    }
    _readNextMessageAndValidate(type) {
      return this._reader.readMessage(type);
    }
  }

  class AsyncRecordBatchStreamReaderImpl extends RecordBatchReaderImpl {
    constructor(source, dictionaries) {
      super(dictionaries);
      this._reader = new AsyncMessageReader(this._handle = source);
    }
    isAsync() {
      return true;
    }
    isStream() {
      return true;
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    cancel() {
      return __awaiter(this, undefined, undefined, function* () {
        if (!this.closed && (this.closed = true)) {
          yield this.reset()._reader.return();
          this._reader = null;
          this.dictionaries = null;
        }
      });
    }
    open(options) {
      return __awaiter(this, undefined, undefined, function* () {
        if (!this.closed) {
          this.autoDestroy = shouldAutoDestroy(this, options);
          if (!(this.schema || (this.schema = yield this._reader.readSchema()))) {
            yield this.cancel();
          }
        }
        return this;
      });
    }
    throw(value) {
      return __awaiter(this, undefined, undefined, function* () {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return yield this.reset()._reader.throw(value);
        }
        return ITERATOR_DONE;
      });
    }
    return(value) {
      return __awaiter(this, undefined, undefined, function* () {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return yield this.reset()._reader.return(value);
        }
        return ITERATOR_DONE;
      });
    }
    next() {
      return __awaiter(this, undefined, undefined, function* () {
        if (this.closed) {
          return ITERATOR_DONE;
        }
        let message;
        const { _reader: reader } = this;
        while (message = yield this._readNextMessageAndValidate()) {
          if (message.isSchema()) {
            yield this.reset(message.header());
          } else if (message.isRecordBatch()) {
            this._recordBatchIndex++;
            const header = message.header();
            const buffer4 = yield reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer4);
            return { done: false, value: recordBatch };
          } else if (message.isDictionaryBatch()) {
            this._dictionaryIndex++;
            const header = message.header();
            const buffer4 = yield reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer4);
            this.dictionaries.set(header.id, vector);
          }
        }
        if (this.schema && this._recordBatchIndex === 0) {
          this._recordBatchIndex++;
          return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };
        }
        return yield this.return();
      });
    }
    _readNextMessageAndValidate(type) {
      return __awaiter(this, undefined, undefined, function* () {
        return yield this._reader.readMessage(type);
      });
    }
  }

  class RecordBatchFileReaderImpl extends RecordBatchStreamReaderImpl {
    get footer() {
      return this._footer;
    }
    get numDictionaries() {
      return this._footer ? this._footer.numDictionaries : 0;
    }
    get numRecordBatches() {
      return this._footer ? this._footer.numRecordBatches : 0;
    }
    constructor(source, dictionaries) {
      super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);
    }
    isSync() {
      return true;
    }
    isFile() {
      return true;
    }
    open(options) {
      if (!this.closed && !this._footer) {
        this.schema = (this._footer = this._readFooter()).schema;
        for (const block of this._footer.dictionaryBatches()) {
          block && this._readDictionaryBatch(this._dictionaryIndex++);
        }
      }
      return super.open(options);
    }
    readRecordBatch(index) {
      var _a5;
      if (this.closed) {
        return null;
      }
      if (!this._footer) {
        this.open();
      }
      const block = (_a5 = this._footer) === null || _a5 === undefined ? undefined : _a5.getRecordBatch(index);
      if (block && this._handle.seek(block.offset)) {
        const message = this._reader.readMessage(MessageHeader.RecordBatch);
        if (message === null || message === undefined ? undefined : message.isRecordBatch()) {
          const header = message.header();
          const buffer4 = this._reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer4);
          return recordBatch;
        }
      }
      return null;
    }
    _readDictionaryBatch(index) {
      var _a5;
      const block = (_a5 = this._footer) === null || _a5 === undefined ? undefined : _a5.getDictionaryBatch(index);
      if (block && this._handle.seek(block.offset)) {
        const message = this._reader.readMessage(MessageHeader.DictionaryBatch);
        if (message === null || message === undefined ? undefined : message.isDictionaryBatch()) {
          const header = message.header();
          const buffer4 = this._reader.readMessageBody(message.bodyLength);
          const vector = this._loadDictionaryBatch(header, buffer4);
          this.dictionaries.set(header.id, vector);
        }
      }
    }
    _readFooter() {
      const { _handle } = this;
      const offset = _handle.size - magicAndPadding;
      const length3 = _handle.readInt32(offset);
      const buffer4 = _handle.readAt(offset - length3, length3);
      return Footer_.decode(buffer4);
    }
    _readNextMessageAndValidate(type) {
      var _a5;
      if (!this._footer) {
        this.open();
      }
      if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
        const block = (_a5 = this._footer) === null || _a5 === undefined ? undefined : _a5.getRecordBatch(this._recordBatchIndex);
        if (block && this._handle.seek(block.offset)) {
          return this._reader.readMessage(type);
        }
      }
      return null;
    }
  }

  class AsyncRecordBatchFileReaderImpl extends AsyncRecordBatchStreamReaderImpl {
    get footer() {
      return this._footer;
    }
    get numDictionaries() {
      return this._footer ? this._footer.numDictionaries : 0;
    }
    get numRecordBatches() {
      return this._footer ? this._footer.numRecordBatches : 0;
    }
    constructor(source, ...rest) {
      const byteLength2 = typeof rest[0] !== "number" ? rest.shift() : undefined;
      const dictionaries = rest[0] instanceof Map ? rest.shift() : undefined;
      super(source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength2), dictionaries);
    }
    isFile() {
      return true;
    }
    isAsync() {
      return true;
    }
    open(options) {
      const _super = Object.create(null, {
        open: { get: () => super.open }
      });
      return __awaiter(this, undefined, undefined, function* () {
        if (!this.closed && !this._footer) {
          this.schema = (this._footer = yield this._readFooter()).schema;
          for (const block of this._footer.dictionaryBatches()) {
            block && (yield this._readDictionaryBatch(this._dictionaryIndex++));
          }
        }
        return yield _super.open.call(this, options);
      });
    }
    readRecordBatch(index) {
      return __awaiter(this, undefined, undefined, function* () {
        var _a5;
        if (this.closed) {
          return null;
        }
        if (!this._footer) {
          yield this.open();
        }
        const block = (_a5 = this._footer) === null || _a5 === undefined ? undefined : _a5.getRecordBatch(index);
        if (block && (yield this._handle.seek(block.offset))) {
          const message = yield this._reader.readMessage(MessageHeader.RecordBatch);
          if (message === null || message === undefined ? undefined : message.isRecordBatch()) {
            const header = message.header();
            const buffer4 = yield this._reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer4);
            return recordBatch;
          }
        }
        return null;
      });
    }
    _readDictionaryBatch(index) {
      return __awaiter(this, undefined, undefined, function* () {
        var _a5;
        const block = (_a5 = this._footer) === null || _a5 === undefined ? undefined : _a5.getDictionaryBatch(index);
        if (block && (yield this._handle.seek(block.offset))) {
          const message = yield this._reader.readMessage(MessageHeader.DictionaryBatch);
          if (message === null || message === undefined ? undefined : message.isDictionaryBatch()) {
            const header = message.header();
            const buffer4 = yield this._reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer4);
            this.dictionaries.set(header.id, vector);
          }
        }
      });
    }
    _readFooter() {
      return __awaiter(this, undefined, undefined, function* () {
        const { _handle } = this;
        _handle._pending && (yield _handle._pending);
        const offset = _handle.size - magicAndPadding;
        const length3 = yield _handle.readInt32(offset);
        const buffer4 = yield _handle.readAt(offset - length3, length3);
        return Footer_.decode(buffer4);
      });
    }
    _readNextMessageAndValidate(type) {
      return __awaiter(this, undefined, undefined, function* () {
        if (!this._footer) {
          yield this.open();
        }
        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
          const block = this._footer.getRecordBatch(this._recordBatchIndex);
          if (block && (yield this._handle.seek(block.offset))) {
            return yield this._reader.readMessage(type);
          }
        }
        return null;
      });
    }
  }

  class RecordBatchJSONReaderImpl extends RecordBatchStreamReaderImpl {
    constructor(source, dictionaries) {
      super(source, dictionaries);
    }
    _loadVectors(header, body, types2) {
      return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types2);
    }
  }
  function shouldAutoDestroy(self2, options) {
    return options && typeof options["autoDestroy"] === "boolean" ? options["autoDestroy"] : self2["autoDestroy"];
  }
  function* readAllSync(source) {
    const reader = RecordBatchReader.from(source);
    try {
      if (!reader.open({ autoDestroy: false }).closed) {
        do {
          yield reader;
        } while (!reader.reset().open().closed);
      }
    } finally {
      reader.cancel();
    }
  }
  function readAllAsync(source) {
    return __asyncGenerator(this, arguments, function* readAllAsync_1() {
      const reader = yield __await(RecordBatchReader.from(source));
      try {
        if (!(yield __await(reader.open({ autoDestroy: false }))).closed) {
          do {
            yield yield __await(reader);
          } while (!(yield __await(reader.reset().open())).closed);
        }
      } finally {
        yield __await(reader.cancel());
      }
    });
  }
  function fromArrowJSON(source) {
    return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));
  }
  function fromByteStream(source) {
    const bytes = source.peek(magicLength + 7 & ~7);
    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function* () {}()));
  }
  function fromAsyncByteStream(source) {
    return __awaiter(this, undefined, undefined, function* () {
      const bytes = yield source.peek(magicLength + 7 & ~7);
      return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(yield source.read())) : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(function() {
        return __asyncGenerator(this, arguments, function* () {});
      }()));
    });
  }
  function fromFileHandle(source) {
    return __awaiter(this, undefined, undefined, function* () {
      const { size: size13 } = yield source.stat();
      const file = new AsyncRandomAccessFile(source, size13);
      if (size13 >= magicX2AndPadding && checkForMagicArrowString(yield file.readAt(0, magicLength + 7 & ~7))) {
        return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));
      }
      return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));
    });
  }

  // node_modules/apache-arrow/visitor/vectorassembler.mjs
  class VectorAssembler extends Visitor {
    static assemble(...args2) {
      const unwrap5 = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap5(node) : node instanceof RecordBatch4 ? node.data.children : node.data);
      const assembler = new VectorAssembler;
      assembler.visitMany(unwrap5(args2));
      return assembler;
    }
    constructor() {
      super();
      this._byteLength = 0;
      this._nodes = [];
      this._buffers = [];
      this._bufferRegions = [];
    }
    visit(data) {
      if (data instanceof Vector) {
        this.visitMany(data.data);
        return this;
      }
      const { type } = data;
      if (!DataType.isDictionary(type)) {
        const { length: length3 } = data;
        if (length3 > 2147483647) {
          throw new RangeError("Cannot write arrays larger than 2^31 - 1 in length");
        }
        if (DataType.isUnion(type)) {
          this.nodes.push(new FieldNode2(length3, 0));
        } else {
          const { nullCount } = data;
          if (!DataType.isNull(type)) {
            addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) : truncateBitmap(data.offset, length3, data.nullBitmap));
          }
          this.nodes.push(new FieldNode2(length3, nullCount));
        }
      }
      return super.visit(data);
    }
    visitNull(_null) {
      return this;
    }
    visitDictionary(data) {
      return this.visit(data.clone(data.type.indices));
    }
    get nodes() {
      return this._nodes;
    }
    get buffers() {
      return this._buffers;
    }
    get byteLength() {
      return this._byteLength;
    }
    get bufferRegions() {
      return this._bufferRegions;
    }
  }
  function addBuffer(values3) {
    const byteLength2 = values3.byteLength + 7 & ~7;
    this.buffers.push(values3);
    this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength2));
    this._byteLength += byteLength2;
    return this;
  }
  function assembleUnion(data) {
    var _a5;
    const { type, length: length3, typeIds, valueOffsets } = data;
    addBuffer.call(this, typeIds);
    if (type.mode === UnionMode.Sparse) {
      return assembleNestedVector.call(this, data);
    } else if (type.mode === UnionMode.Dense) {
      if (data.offset <= 0) {
        addBuffer.call(this, valueOffsets);
        return assembleNestedVector.call(this, data);
      } else {
        const shiftedOffsets = new Int32Array(length3);
        const childOffsets = Object.create(null);
        const childLengths = Object.create(null);
        for (let typeId, shift2, index = -1;++index < length3; ) {
          if ((typeId = typeIds[index]) === undefined) {
            continue;
          }
          if ((shift2 = childOffsets[typeId]) === undefined) {
            shift2 = childOffsets[typeId] = valueOffsets[index];
          }
          shiftedOffsets[index] = valueOffsets[index] - shift2;
          childLengths[typeId] = ((_a5 = childLengths[typeId]) !== null && _a5 !== undefined ? _a5 : 0) + 1;
        }
        addBuffer.call(this, shiftedOffsets);
        this.visitMany(data.children.map((child, childIndex) => {
          const typeId = type.typeIds[childIndex];
          const childOffset = childOffsets[typeId];
          const childLength = childLengths[typeId];
          return child.slice(childOffset, Math.min(length3, childLength));
        }));
      }
    }
    return this;
  }
  function assembleBoolVector(data) {
    let values3;
    if (data.nullCount >= data.length) {
      return addBuffer.call(this, new Uint8Array(0));
    } else if ((values3 = data.values) instanceof Uint8Array) {
      return addBuffer.call(this, truncateBitmap(data.offset, data.length, values3));
    }
    return addBuffer.call(this, packBools(data.values));
  }
  function assembleFlatVector(data) {
    return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));
  }
  function assembleFlatListVector(data) {
    const { length: length3, values: values3, valueOffsets } = data;
    const begin = bigIntToNumber(valueOffsets[0]);
    const end6 = bigIntToNumber(valueOffsets[length3]);
    const byteLength2 = Math.min(end6 - begin, values3.byteLength - begin);
    addBuffer.call(this, rebaseValueOffsets(-begin, length3 + 1, valueOffsets));
    addBuffer.call(this, values3.subarray(begin, begin + byteLength2));
    return this;
  }
  function assembleListVector(data) {
    const { length: length3, valueOffsets } = data;
    if (valueOffsets) {
      const { [0]: begin, [length3]: end6 } = valueOffsets;
      addBuffer.call(this, rebaseValueOffsets(-begin, length3 + 1, valueOffsets));
      return this.visit(data.children[0].slice(begin, end6 - begin));
    }
    return this.visit(data.children[0]);
  }
  function assembleNestedVector(data) {
    return this.visitMany(data.type.children.map((_, i2) => data.children[i2]).filter(Boolean))[0];
  }
  VectorAssembler.prototype.visitBool = assembleBoolVector;
  VectorAssembler.prototype.visitInt = assembleFlatVector;
  VectorAssembler.prototype.visitFloat = assembleFlatVector;
  VectorAssembler.prototype.visitUtf8 = assembleFlatListVector;
  VectorAssembler.prototype.visitLargeUtf8 = assembleFlatListVector;
  VectorAssembler.prototype.visitBinary = assembleFlatListVector;
  VectorAssembler.prototype.visitLargeBinary = assembleFlatListVector;
  VectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;
  VectorAssembler.prototype.visitDate = assembleFlatVector;
  VectorAssembler.prototype.visitTimestamp = assembleFlatVector;
  VectorAssembler.prototype.visitTime = assembleFlatVector;
  VectorAssembler.prototype.visitDecimal = assembleFlatVector;
  VectorAssembler.prototype.visitList = assembleListVector;
  VectorAssembler.prototype.visitStruct = assembleNestedVector;
  VectorAssembler.prototype.visitUnion = assembleUnion;
  VectorAssembler.prototype.visitInterval = assembleFlatVector;
  VectorAssembler.prototype.visitDuration = assembleFlatVector;
  VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
  VectorAssembler.prototype.visitMap = assembleListVector;

  // node_modules/apache-arrow/ipc/writer.mjs
  class RecordBatchWriter extends ReadableInterop {
    static throughNode(options) {
      throw new Error(`"throughNode" not available in this environment`);
    }
    static throughDOM(writableStrategy, readableStrategy) {
      throw new Error(`"throughDOM" not available in this environment`);
    }
    constructor(options) {
      super();
      this._position = 0;
      this._started = false;
      this._compression = null;
      this._sink = new AsyncByteQueue;
      this._schema = null;
      this._dictionaryBlocks = [];
      this._recordBatchBlocks = [];
      this._seenDictionaries = new Map;
      this._dictionaryDeltaOffsets = new Map;
      isObject3(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false, compressionType: null });
      this._autoDestroy = typeof options.autoDestroy === "boolean" ? options.autoDestroy : true;
      this._writeLegacyIpcFormat = typeof options.writeLegacyIpcFormat === "boolean" ? options.writeLegacyIpcFormat : false;
      if (options.compressionType != null) {
        if (this._writeLegacyIpcFormat) {
          throw new Error("Legacy IPC format does not support columnar compression. Use modern IPC format (writeLegacyIpcFormat=false).");
        }
        if (Object.values(CompressionType).includes(options.compressionType)) {
          this._compression = new BodyCompression2(options.compressionType);
        } else {
          const validCompressionTypes = Object.values(CompressionType).filter((v) => typeof v === "string");
          throw new Error(`Unsupported compressionType: ${options.compressionType} Available types: ${validCompressionTypes.join(", ")}`);
        }
      } else {
        this._compression = null;
      }
    }
    toString(sync11 = false) {
      return this._sink.toString(sync11);
    }
    toUint8Array(sync11 = false) {
      return this._sink.toUint8Array(sync11);
    }
    writeAll(input) {
      if (isPromise(input)) {
        return input.then((x) => this.writeAll(x));
      } else if (isAsyncIterable(input)) {
        return writeAllAsync(this, input);
      }
      return writeAll2(this, input);
    }
    get closed() {
      return this._sink.closed;
    }
    [Symbol.asyncIterator]() {
      return this._sink[Symbol.asyncIterator]();
    }
    toDOMStream(options) {
      return this._sink.toDOMStream(options);
    }
    toNodeStream(options) {
      return this._sink.toNodeStream(options);
    }
    close() {
      return this.reset()._sink.close();
    }
    abort(reason) {
      return this.reset()._sink.abort(reason);
    }
    finish() {
      this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);
      return this;
    }
    reset(sink = this._sink, schema = null) {
      if (sink === this._sink || sink instanceof AsyncByteQueue) {
        this._sink = sink;
      } else {
        this._sink = new AsyncByteQueue;
        if (sink && isWritableDOMStream(sink)) {
          this.toDOMStream({ type: "bytes" }).pipeTo(sink);
        } else if (sink && isWritableNodeStream(sink)) {
          this.toNodeStream({ objectMode: false }).pipe(sink);
        }
      }
      if (this._started && this._schema) {
        this._writeFooter(this._schema);
      }
      this._started = false;
      this._dictionaryBlocks = [];
      this._recordBatchBlocks = [];
      this._seenDictionaries = new Map;
      this._dictionaryDeltaOffsets = new Map;
      if (!schema || !compareSchemas(schema, this._schema)) {
        if (schema == null) {
          this._position = 0;
          this._schema = null;
        } else {
          this._started = true;
          this._schema = schema;
          this._writeSchema(schema);
        }
      }
      return this;
    }
    write(payload) {
      let schema = null;
      if (!this._sink) {
        throw new Error(`RecordBatchWriter is closed`);
      } else if (payload == null) {
        return this.finish() && undefined;
      } else if (payload instanceof Table2 && !(schema = payload.schema)) {
        return this.finish() && undefined;
      } else if (payload instanceof RecordBatch4 && !(schema = payload.schema)) {
        return this.finish() && undefined;
      }
      if (schema && !compareSchemas(schema, this._schema)) {
        if (this._started && this._autoDestroy) {
          return this.close();
        }
        this.reset(this._sink, schema);
      }
      if (payload instanceof RecordBatch4) {
        if (!(payload instanceof _InternalEmptyPlaceholderRecordBatch)) {
          this._writeRecordBatch(payload);
        }
      } else if (payload instanceof Table2) {
        this.writeAll(payload.batches);
      } else if (isIterable2(payload)) {
        this.writeAll(payload);
      }
    }
    _writeMessage(message, alignment = 8) {
      const a = alignment - 1;
      const buffer4 = Message2.encode(message);
      const flatbufferSize = buffer4.byteLength;
      const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;
      const alignedSize = flatbufferSize + prefixSize + a & ~a;
      const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;
      if (message.headerType === MessageHeader.RecordBatch) {
        this._recordBatchBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));
      } else if (message.headerType === MessageHeader.DictionaryBatch) {
        this._dictionaryBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));
      }
      if (!this._writeLegacyIpcFormat) {
        this._write(Int32Array.of(-1));
      }
      this._write(Int32Array.of(alignedSize - prefixSize));
      if (flatbufferSize > 0) {
        this._write(buffer4);
      }
      return this._writePadding(nPaddingBytes);
    }
    _write(chunk3) {
      if (this._started) {
        const buffer4 = toUint8Array(chunk3);
        if (buffer4 && buffer4.byteLength > 0) {
          this._sink.write(buffer4);
          this._position += buffer4.byteLength;
        }
      }
      return this;
    }
    _writeSchema(schema) {
      return this._writeMessage(Message2.from(schema));
    }
    _writeFooter(schema) {
      return this._writeLegacyIpcFormat ? this._write(Int32Array.of(0)) : this._write(Int32Array.of(-1, 0));
    }
    _writeMagic() {
      return this._write(MAGIC);
    }
    _writePadding(nBytes) {
      return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;
    }
    _writeRecordBatch(batch) {
      const { byteLength: byteLength2, nodes, bufferRegions, buffers } = this._assembleRecordBatch(batch);
      const recordBatch = new RecordBatch3(batch.numRows, nodes, bufferRegions, this._compression);
      const message = Message2.from(recordBatch, byteLength2);
      return this._writeDictionaries(batch)._writeMessage(message)._writeBodyBuffers(buffers);
    }
    _assembleRecordBatch(batch) {
      let { byteLength: byteLength2, nodes, bufferRegions, buffers } = VectorAssembler.assemble(batch);
      if (this._compression != null) {
        ({ byteLength: byteLength2, bufferRegions, buffers } = this._compressBodyBuffers(buffers));
      }
      return { byteLength: byteLength2, nodes, bufferRegions, buffers };
    }
    _compressBodyBuffers(buffers) {
      const codec = compressionRegistry.get(this._compression.type);
      if (!(codec === null || codec === undefined ? undefined : codec.encode) || typeof codec.encode !== "function") {
        throw new Error(`Codec for compression type "${CompressionType[this._compression.type]}" has invalid encode method`);
      }
      let currentOffset = 0;
      const compressedBuffers = [];
      const bufferRegions = [];
      for (const buffer4 of buffers) {
        const byteBuf = toUint8Array(buffer4);
        if (byteBuf.length === 0) {
          compressedBuffers.push(new Uint8Array(0), new Uint8Array(0));
          bufferRegions.push(new BufferRegion(currentOffset, 0));
          continue;
        }
        const compressed = codec.encode(byteBuf);
        const isCompressionEffective = compressed.length < byteBuf.length;
        const finalBuffer = isCompressionEffective ? compressed : byteBuf;
        const byteLength2 = isCompressionEffective ? finalBuffer.length : LENGTH_NO_COMPRESSED_DATA;
        const lengthPrefix = new ByteBuffer(new Uint8Array(COMPRESS_LENGTH_PREFIX));
        lengthPrefix.writeInt64(0, BigInt(byteLength2));
        compressedBuffers.push(lengthPrefix.bytes(), new Uint8Array(finalBuffer));
        const padding = (currentOffset + 7 & ~7) - currentOffset;
        currentOffset += padding;
        const fullBodyLength = COMPRESS_LENGTH_PREFIX + finalBuffer.length;
        bufferRegions.push(new BufferRegion(currentOffset, fullBodyLength));
        currentOffset += fullBodyLength;
      }
      const finalPadding = (currentOffset + 7 & ~7) - currentOffset;
      currentOffset += finalPadding;
      return { byteLength: currentOffset, bufferRegions, buffers: compressedBuffers };
    }
    _writeDictionaryBatch(dictionary, id2, isDelta = false) {
      const { byteLength: byteLength2, nodes, bufferRegions, buffers } = this._assembleRecordBatch(new Vector([dictionary]));
      const recordBatch = new RecordBatch3(dictionary.length, nodes, bufferRegions, this._compression);
      const dictionaryBatch = new DictionaryBatch2(recordBatch, id2, isDelta);
      const message = Message2.from(dictionaryBatch, byteLength2);
      return this._writeMessage(message)._writeBodyBuffers(buffers);
    }
    _writeBodyBuffers(buffers) {
      const bufGroupSize = this._compression != null ? 2 : 1;
      const bufs = new Array(bufGroupSize);
      for (let i2 = 0;i2 < buffers.length; i2 += bufGroupSize) {
        let size13 = 0;
        for (let j = -1;++j < bufGroupSize; ) {
          bufs[j] = buffers[i2 + j];
          size13 += bufs[j].byteLength;
        }
        if (size13 === 0) {
          continue;
        }
        for (const buf of bufs)
          this._write(buf);
        const padding = (size13 + 7 & ~7) - size13;
        if (padding > 0) {
          this._writePadding(padding);
        }
      }
      return this;
    }
    _writeDictionaries(batch) {
      var _a5, _b2;
      for (const [id2, dictionary] of batch.dictionaries) {
        const chunks3 = (_a5 = dictionary === null || dictionary === undefined ? undefined : dictionary.data) !== null && _a5 !== undefined ? _a5 : [];
        const prevDictionary = this._seenDictionaries.get(id2);
        const offset = (_b2 = this._dictionaryDeltaOffsets.get(id2)) !== null && _b2 !== undefined ? _b2 : 0;
        if (!prevDictionary || prevDictionary.data[0] !== chunks3[0]) {
          for (const [index, chunk3] of chunks3.entries())
            this._writeDictionaryBatch(chunk3, id2, index > 0);
        } else if (offset < chunks3.length) {
          for (const chunk3 of chunks3.slice(offset))
            this._writeDictionaryBatch(chunk3, id2, true);
        }
        this._seenDictionaries.set(id2, dictionary);
        this._dictionaryDeltaOffsets.set(id2, chunks3.length);
      }
      return this;
    }
  }

  class RecordBatchStreamWriter extends RecordBatchWriter {
    static writeAll(input, options) {
      const writer = new RecordBatchStreamWriter(options);
      if (isPromise(input)) {
        return input.then((x) => writer.writeAll(x));
      } else if (isAsyncIterable(input)) {
        return writeAllAsync(writer, input);
      }
      return writeAll2(writer, input);
    }
  }

  class RecordBatchFileWriter extends RecordBatchWriter {
    static writeAll(input, options) {
      const writer = new RecordBatchFileWriter(options);
      if (isPromise(input)) {
        return input.then((x) => writer.writeAll(x));
      } else if (isAsyncIterable(input)) {
        return writeAllAsync(writer, input);
      }
      return writeAll2(writer, input);
    }
    constructor(options) {
      super(options);
      this._autoDestroy = true;
      this._writeLegacyIpcFormat = false;
    }
    _writeSchema(schema) {
      return this._writeMagic()._writePadding(2);
    }
    _writeDictionaryBatch(dictionary, id2, isDelta = false) {
      if (!isDelta && this._seenDictionaries.has(id2)) {
        throw new Error("The Arrow File format does not support replacement dictionaries. ");
      }
      return super._writeDictionaryBatch(dictionary, id2, isDelta);
    }
    _writeFooter(schema) {
      const buffer4 = Footer_.encode(new Footer_(schema, MetadataVersion.V5, this._recordBatchBlocks, this._dictionaryBlocks));
      return super._writeFooter(schema)._write(buffer4)._write(Int32Array.of(buffer4.byteLength))._writeMagic();
    }
  }
  function writeAll2(writer, input) {
    let chunks3 = input;
    if (input instanceof Table2) {
      chunks3 = input.batches;
      writer.reset(undefined, input.schema);
    }
    for (const batch of chunks3) {
      writer.write(batch);
    }
    return writer.finish();
  }
  function writeAllAsync(writer, batches) {
    return __awaiter(this, undefined, undefined, function* () {
      var _a5, batches_1, batches_1_1;
      var _b2, e_1, _c2, _d2;
      try {
        for (_a5 = true, batches_1 = __asyncValues(batches);batches_1_1 = yield batches_1.next(), _b2 = batches_1_1.done, !_b2; _a5 = true) {
          _d2 = batches_1_1.value;
          _a5 = false;
          const batch = _d2;
          writer.write(batch);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_a5 && !_b2 && (_c2 = batches_1.return))
            yield _c2.call(batches_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return writer.finish();
    });
  }

  // node_modules/apache-arrow/io/whatwg/iterable.mjs
  function toDOMStream(source, options) {
    if (isAsyncIterable(source)) {
      return asyncIterableAsReadableDOMStream(source, options);
    }
    if (isIterable2(source)) {
      return iterableAsReadableDOMStream(source, options);
    }
    throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);
  }
  function iterableAsReadableDOMStream(source, options) {
    let it = null;
    const bm = (options === null || options === undefined ? undefined : options.type) === "bytes" || false;
    const hwm = (options === null || options === undefined ? undefined : options.highWaterMark) || Math.pow(2, 24);
    return new ReadableStream(Object.assign(Object.assign({}, options), {
      start(controller) {
        next(controller, it || (it = source[Symbol.iterator]()));
      },
      pull(controller) {
        it ? next(controller, it) : controller.close();
      },
      cancel() {
        (it === null || it === undefined ? undefined : it.return) && it.return();
        it = null;
      }
    }), Object.assign({ highWaterMark: bm ? hwm : undefined }, options));
    function next(controller, it2) {
      let buf;
      let r = null;
      let size13 = controller.desiredSize || null;
      while (!(r = it2.next(bm ? size13 : null)).done) {
        if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {
          size13 != null && bm && (size13 = size13 - buf.byteLength + 1);
          r.value = buf;
        }
        controller.enqueue(r.value);
        if (size13 != null && --size13 <= 0) {
          return;
        }
      }
      controller.close();
    }
  }
  function asyncIterableAsReadableDOMStream(source, options) {
    let it = null;
    const bm = (options === null || options === undefined ? undefined : options.type) === "bytes" || false;
    const hwm = (options === null || options === undefined ? undefined : options.highWaterMark) || Math.pow(2, 24);
    return new ReadableStream(Object.assign(Object.assign({}, options), {
      start(controller) {
        return __awaiter(this, undefined, undefined, function* () {
          yield next(controller, it || (it = source[Symbol.asyncIterator]()));
        });
      },
      pull(controller) {
        return __awaiter(this, undefined, undefined, function* () {
          it ? yield next(controller, it) : controller.close();
        });
      },
      cancel() {
        return __awaiter(this, undefined, undefined, function* () {
          (it === null || it === undefined ? undefined : it.return) && (yield it.return());
          it = null;
        });
      }
    }), Object.assign({ highWaterMark: bm ? hwm : undefined }, options));
    function next(controller, it2) {
      return __awaiter(this, undefined, undefined, function* () {
        let buf;
        let r = null;
        let size13 = controller.desiredSize || null;
        while (!(r = yield it2.next(bm ? size13 : null)).done) {
          if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {
            size13 != null && bm && (size13 = size13 - buf.byteLength + 1);
            r.value = buf;
          }
          controller.enqueue(r.value);
          if (size13 != null && --size13 <= 0) {
            return;
          }
        }
        controller.close();
      });
    }
  }

  // node_modules/apache-arrow/io/whatwg/builder.mjs
  function builderThroughDOMStream(options) {
    return new BuilderTransform(options);
  }

  class BuilderTransform {
    constructor(options) {
      this._numChunks = 0;
      this._finished = false;
      this._bufferedSize = 0;
      const { ["readableStrategy"]: readableStrategy, ["writableStrategy"]: writableStrategy, ["queueingStrategy"]: queueingStrategy = "count" } = options, builderOptions = __rest(options, ["readableStrategy", "writableStrategy", "queueingStrategy"]);
      this._controller = null;
      this._builder = makeBuilder2(builderOptions);
      this._getSize = queueingStrategy !== "bytes" ? chunkLength : chunkByteLength;
      const { ["highWaterMark"]: readableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1000 } = Object.assign({}, readableStrategy);
      const { ["highWaterMark"]: writableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1000 } = Object.assign({}, writableStrategy);
      this["readable"] = new ReadableStream({
        ["cancel"]: () => {
          this._builder.clear();
        },
        ["pull"]: (c) => {
          this._maybeFlush(this._builder, this._controller = c);
        },
        ["start"]: (c) => {
          this._maybeFlush(this._builder, this._controller = c);
        }
      }, {
        highWaterMark: readableHighWaterMark,
        size: queueingStrategy !== "bytes" ? chunkLength : chunkByteLength
      });
      this["writable"] = new WritableStream({
        ["abort"]: () => {
          this._builder.clear();
        },
        ["write"]: () => {
          this._maybeFlush(this._builder, this._controller);
        },
        ["close"]: () => {
          this._maybeFlush(this._builder.finish(), this._controller);
        }
      }, {
        highWaterMark: writableHighWaterMark,
        size: (value) => this._writeValueAndReturnChunkSize(value)
      });
    }
    _writeValueAndReturnChunkSize(value) {
      const bufferedSize = this._bufferedSize;
      this._bufferedSize = this._getSize(this._builder.append(value));
      return this._bufferedSize - bufferedSize;
    }
    _maybeFlush(builder, controller) {
      if (controller == null) {
        return;
      }
      if (this._bufferedSize >= controller.desiredSize) {
        ++this._numChunks && this._enqueue(controller, builder.toVector());
      }
      if (builder.finished) {
        if (builder.length > 0 || this._numChunks === 0) {
          ++this._numChunks && this._enqueue(controller, builder.toVector());
        }
        if (!this._finished && (this._finished = true)) {
          this._enqueue(controller, null);
        }
      }
    }
    _enqueue(controller, chunk3) {
      this._bufferedSize = 0;
      this._controller = null;
      chunk3 == null ? controller.close() : controller.enqueue(chunk3);
    }
  }
  var chunkLength = (chunk3) => {
    var _a5;
    return (_a5 = chunk3 === null || chunk3 === undefined ? undefined : chunk3.length) !== null && _a5 !== undefined ? _a5 : 0;
  };
  var chunkByteLength = (chunk3) => {
    var _a5;
    return (_a5 = chunk3 === null || chunk3 === undefined ? undefined : chunk3.byteLength) !== null && _a5 !== undefined ? _a5 : 0;
  };

  // node_modules/apache-arrow/io/whatwg/reader.mjs
  function recordBatchReaderThroughDOMStream(writableStrategy, readableStrategy) {
    const queue = new AsyncByteQueue;
    let reader = null;
    const readable = new ReadableStream({
      cancel() {
        return __awaiter(this, undefined, undefined, function* () {
          yield queue.close();
        });
      },
      start(controller) {
        return __awaiter(this, undefined, undefined, function* () {
          yield next(controller, reader || (reader = yield open3()));
        });
      },
      pull(controller) {
        return __awaiter(this, undefined, undefined, function* () {
          reader ? yield next(controller, reader) : controller.close();
        });
      }
    });
    return { writable: new WritableStream(queue, Object.assign({ highWaterMark: Math.pow(2, 14) }, writableStrategy)), readable };
    function open3() {
      return __awaiter(this, undefined, undefined, function* () {
        return yield (yield RecordBatchReader.from(queue)).open(readableStrategy);
      });
    }
    function next(controller, reader2) {
      return __awaiter(this, undefined, undefined, function* () {
        let size13 = controller.desiredSize;
        let r = null;
        while (!(r = yield reader2.next()).done) {
          controller.enqueue(r.value);
          if (size13 != null && --size13 <= 0) {
            return;
          }
        }
        controller.close();
      });
    }
  }

  // node_modules/apache-arrow/io/whatwg/writer.mjs
  function recordBatchWriterThroughDOMStream(writableStrategy, readableStrategy) {
    const writer = new this(writableStrategy);
    const reader = new AsyncByteStream(writer);
    const readable = new ReadableStream({
      cancel() {
        return __awaiter(this, undefined, undefined, function* () {
          yield reader.cancel();
        });
      },
      pull(controller) {
        return __awaiter(this, undefined, undefined, function* () {
          yield next(controller);
        });
      },
      start(controller) {
        return __awaiter(this, undefined, undefined, function* () {
          yield next(controller);
        });
      }
    }, Object.assign({ highWaterMark: Math.pow(2, 14) }, readableStrategy));
    return { writable: new WritableStream(writer, writableStrategy), readable };
    function next(controller) {
      return __awaiter(this, undefined, undefined, function* () {
        let buf = null;
        let size13 = controller.desiredSize;
        while (buf = yield reader.read(size13 || null)) {
          controller.enqueue(buf);
          if (size13 != null && (size13 -= buf.byteLength) <= 0) {
            return;
          }
        }
        controller.close();
      });
    }
  }

  // node_modules/apache-arrow/ipc/serialization.mjs
  function tableFromIPC(input) {
    const reader = RecordBatchReader.from(input);
    if (isPromise(reader)) {
      return reader.then((reader2) => tableFromIPC(reader2));
    }
    if (reader.isAsync()) {
      return reader.readAll().then((xs) => new Table2(xs));
    }
    return new Table2(reader.readAll());
  }
  // node_modules/apache-arrow/Arrow.mjs
  var util = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, exports_bn), exports_int), exports_bit), exports_math), exports_buffer2), exports_vector), exports_pretty), exports_interval2), {
    compareSchemas,
    compareFields,
    compareTypes
  });
  // node_modules/apache-arrow/Arrow.dom.mjs
  adapters_default.toDOMStream = toDOMStream;
  Builder2["throughDOM"] = builderThroughDOMStream;
  RecordBatchReader["throughDOM"] = recordBatchReaderThroughDOMStream;
  RecordBatchFileReader["throughDOM"] = recordBatchReaderThroughDOMStream;
  RecordBatchStreamReader["throughDOM"] = recordBatchReaderThroughDOMStream;
  RecordBatchWriter["throughDOM"] = recordBatchWriterThroughDOMStream;
  RecordBatchFileWriter["throughDOM"] = recordBatchWriterThroughDOMStream;
  RecordBatchStreamWriter["throughDOM"] = recordBatchWriterThroughDOMStream;

  // src/huggingface/parquet.ts
  var readParquetToArrow = (filePath) => exports_Effect.gen(function* () {
    const fs = yield* FileSystem;
    const exists4 = yield* fs.exists(filePath).pipe(exports_Effect.catchAll(() => exports_Effect.succeed(false)));
    if (!exists4) {
      return yield* exports_Effect.fail(new HFDatasetError("not_found", `Parquet file not found: ${filePath}`));
    }
    const fileContent = yield* fs.readFile(filePath).pipe(exports_Effect.mapError((e) => new HFDatasetError("parse_error", `Failed to read file: ${e.message}`)));
    const table = yield* exports_Effect.try({
      try: () => {
        const parquetTable = readParquet(new Uint8Array(fileContent));
        return tableFromIPC(parquetTable.intoIPCStream());
      },
      catch: (e) => {
        const error = e;
        return new HFDatasetError("parse_error", `Failed to parse parquet: ${error.message}`, e);
      }
    });
    return table;
  });
  var readParquetFile = (filePath, options = {}) => exports_Effect.gen(function* () {
    const table = yield* readParquetToArrow(filePath);
    const { limit, offset = 0 } = options;
    const endIndex = limit !== undefined ? offset + limit : table.numRows;
    const rows = [];
    for (let i2 = offset;i2 < Math.min(endIndex, table.numRows); i2++) {
      const row = table.get(i2);
      if (row) {
        rows.push(row.toJSON());
      }
    }
    return rows;
  });
  var getParquetRowCount = (filePath) => exports_Effect.gen(function* () {
    const table = yield* readParquetToArrow(filePath);
    return table.numRows;
  });
  async function* streamParquetRows(filePath) {
    const file = Bun.file(filePath);
    const buffer4 = new Uint8Array(await file.arrayBuffer());
    const parquetTable = readParquet(buffer4);
    const table = tableFromIPC(parquetTable.intoIPCStream());
    for (let i2 = 0;i2 < table.numRows; i2++) {
      const row = table.get(i2);
      if (row) {
        yield row.toJSON();
      }
    }
  }

  // src/atif/schema.ts
  var ATIF_SCHEMA_VERSION = "ATIF-v1.4";
  var StepSource = Literal2("user", "agent", "system");
  var Agent = Struct({
    name: String$,
    version: String$,
    model_name: String$,
    extra: optional(Record({ key: String$, value: Unknown }))
  });
  var ToolCall = Struct({
    tool_call_id: String$,
    function_name: String$,
    arguments: Unknown
  });
  var SubagentTrajectoryRef = Struct({
    session_id: String$,
    trajectory_path: optional(String$),
    extra: optional(Record({ key: String$, value: Unknown }))
  });
  var ObservationResult = Struct({
    source_call_id: optional(String$),
    content: optional(Unknown),
    subagent_trajectory_ref: optional(Array$(SubagentTrajectoryRef))
  });
  var Observation = Struct({
    results: Array$(ObservationResult)
  });
  var Metrics = Struct({
    prompt_tokens: optional(Number$),
    completion_tokens: optional(Number$),
    cached_tokens: optional(Number$),
    cost_usd: optional(Number$),
    logprobs: optional(Array$(Number$)),
    completion_token_ids: optional(Array$(Number$)),
    prompt_token_ids: optional(Array$(Number$)),
    extra: optional(Record({ key: String$, value: Unknown }))
  });
  var FinalMetrics = Struct({
    total_prompt_tokens: Number$,
    total_completion_tokens: Number$,
    total_cached_tokens: optional(Number$),
    total_cost_usd: optional(Number$),
    total_steps: Number$,
    extra: optional(Record({ key: String$, value: Unknown }))
  });
  var StepStatus = Literal2("pending", "executing", "completed", "failed", "replayed");
  var Step = Struct({
    step_id: Number$.pipe(int(), positive()),
    timestamp: String$,
    source: StepSource,
    message: Unknown,
    reasoning_content: optional(String$),
    model_name: optional(String$),
    tool_calls: optional(Array$(ToolCall)),
    observation: optional(Observation),
    metrics: optional(Metrics),
    status: optional(StepStatus),
    completed_at: optional(String$),
    error: optional(String$),
    extra: optional(Record({ key: String$, value: Unknown }))
  });
  var Checkpoint = Struct({
    checkpoint_id: String$,
    phase: String$,
    timestamp: String$,
    resumable: Boolean$,
    step_id: optional(Number$.pipe(int(), positive())),
    extra: optional(Record({ key: String$, value: Unknown }))
  });
  var RecoveryInfo = Struct({
    recovered_from_session: optional(String$),
    recovered_at_step: optional(Number$.pipe(int(), positive())),
    recovery_timestamp: optional(String$),
    notes: optional(String$),
    extra: optional(Record({ key: String$, value: Unknown }))
  });
  var Trajectory = Struct({
    schema_version: Literal2(ATIF_SCHEMA_VERSION),
    session_id: String$,
    agent: Agent,
    steps: Array$(Step),
    notes: optional(String$),
    final_metrics: optional(FinalMetrics),
    checkpoints: optional(Array$(Checkpoint)),
    recovery_info: optional(RecoveryInfo),
    extra: optional(Record({ key: String$, value: Unknown }))
  });
  var decodeTrajectory = decodeUnknownSync(Trajectory);
  var encodeTrajectory = encodeSync(Trajectory);
  var decodeStep = decodeUnknownSync(Step);
  var encodeStep = encodeSync(Step);
  var decodeAgent = decodeUnknownSync(Agent);
  var encodeAgent = encodeSync(Agent);
  var hasToolCalls = (step4) => (step4.tool_calls?.length ?? 0) > 0;
  var hasObservation = (step4) => step4.observation !== undefined && step4.observation.results.length > 0;
  var extractStepText = (step4) => {
    if (typeof step4.message === "string")
      return step4.message;
    if (typeof step4.message === "object" && step4.message !== null) {
      const msg = step4.message;
      if (typeof msg.content === "string")
        return msg.content;
      if (typeof msg.text === "string")
        return msg.text;
    }
    return "";
  };

  // src/huggingface/openthoughts.ts
  class OpenThoughtsService extends exports_Context.Tag("OpenThoughtsService")() {
  }
  function sftRowToTrajectory(row, index) {
    const sessionId = row.run_id ? `openthoughts-${row.run_id}` : `openthoughts-${row.task}__${row.episode}__${index}`;
    const conversations = Array.isArray(row.conversations) ? row.conversations : Array.from(row.conversations);
    const steps = conversations.map((msg, idx) => ({
      step_id: idx + 1,
      timestamp: row.date || new Date().toISOString(),
      source: msg.role === "assistant" ? "agent" : "user",
      message: msg.content
    }));
    return {
      schema_version: ATIF_SCHEMA_VERSION,
      session_id: sessionId,
      agent: {
        name: row.agent || "unknown",
        version: "1.0",
        model_name: row.model || "unknown"
      },
      steps,
      extra: {
        source_dataset: "open-thoughts/OpenThoughts-Agent-v1-SFT",
        task: row.task,
        episode: row.episode,
        run_id: row.run_id,
        trial_name: row.trial_name,
        model_provider: row.model_provider,
        original_date: row.date
      }
    };
  }
  var makeOpenThoughtsService = () => exports_Effect.gen(function* () {
    const hfService = yield* HFDatasetService;
    const fs = yield* FileSystem;
    const pathService = yield* Path2;
    const repo = OPENTHOUGHTS_SFT_CONFIG.repo;
    const getParquetFilePath = () => exports_Effect.gen(function* () {
      const info = yield* hfService.getDownloadInfo(repo);
      if (!info)
        return null;
      const parquetFile = info.files.find((f) => f.endsWith(".parquet"));
      if (!parquetFile)
        return null;
      return pathService.join(info.localPath, parquetFile);
    });
    const service3 = {
      ensureDownloaded: () => exports_Effect.gen(function* () {
        const isDownloaded = yield* hfService.isDownloaded(repo);
        if (!isDownloaded) {
          console.log(`Downloading OpenThoughts SFT dataset...`);
          yield* hfService.download(OPENTHOUGHTS_SFT_CONFIG);
        }
        const path = yield* getParquetFilePath();
        if (!path) {
          return yield* exports_Effect.fail(new HFDatasetError("not_found", "Dataset downloaded but parquet file not found"));
        }
        return path;
      }),
      count: () => exports_Effect.gen(function* () {
        const parquetPath = yield* service3.ensureDownloaded();
        return yield* getParquetRowCount(parquetPath);
      }),
      getTrajectory: (index) => exports_Effect.gen(function* () {
        const parquetPath = yield* service3.ensureDownloaded();
        const rows = yield* readParquetFile(parquetPath, {
          offset: index,
          limit: 1
        });
        if (rows.length === 0)
          return null;
        return sftRowToTrajectory(rows[0], index);
      }),
      getTrajectoryByRunId: (runId) => exports_Effect.gen(function* () {
        const parquetPath = yield* service3.ensureDownloaded();
        const result = yield* exports_Effect.tryPromise({
          try: async () => {
            let index = 0;
            for await (const row of streamParquetRows(parquetPath)) {
              if (row.run_id === runId) {
                return sftRowToTrajectory(row, index);
              }
              index++;
            }
            return null;
          },
          catch: (e) => new HFDatasetError("parse_error", `Failed to search by run_id: ${e}`)
        });
        return result;
      }),
      getTrajectories: (offset = 0, limit = 100) => exports_Effect.gen(function* () {
        const parquetPath = yield* service3.ensureDownloaded();
        const rows = yield* readParquetFile(parquetPath, {
          offset,
          limit
        });
        return rows.map((row, idx) => sftRowToTrajectory(row, offset + idx));
      }),
      streamTrajectories: () => exports_Effect.gen(function* () {
        const parquetPath = yield* service3.ensureDownloaded();
        async function* generator() {
          let index = 0;
          for await (const row of streamParquetRows(parquetPath)) {
            yield sftRowToTrajectory(row, index);
            index++;
          }
        }
        return generator();
      }),
      getParquetPath: () => getParquetFilePath()
    };
    return service3;
  });
  var OpenThoughtsServiceLive = exports_Layer.effect(OpenThoughtsService, makeOpenThoughtsService());

  // src/effuse/widgets/hf-trajectory-list.ts
  var extractMetadata = (trajectory, index) => {
    const agent = trajectory.agent;
    const extra = trajectory.extra;
    return {
      sessionId: trajectory.session_id,
      agentName: agent?.name ?? "unknown",
      modelName: agent?.model_name ?? "unknown",
      task: extra?.task ?? "unknown",
      episode: extra?.episode ?? "unknown",
      date: extra?.date ?? trajectory.steps[0]?.timestamp ?? new Date().toISOString(),
      stepCount: trajectory.steps.length,
      index
    };
  };
  var filterTrajectories = (trajectories, query) => {
    if (!query.trim())
      return trajectories;
    const lowercaseQuery = query.toLowerCase();
    return trajectories.filter((t) => t.agentName.toLowerCase().includes(lowercaseQuery) || t.task.toLowerCase().includes(lowercaseQuery) || t.episode.toLowerCase().includes(lowercaseQuery) || t.sessionId.toLowerCase().includes(lowercaseQuery));
  };
  var formatDate2 = (iso) => {
    try {
      return new Date(iso).toLocaleDateString(undefined, {
        month: "short",
        day: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      });
    } catch {
      return iso.slice(0, 10);
    }
  };
  var HFTrajectoryListWidget = {
    id: "hf-trajectory-list",
    initialState: () => {
      if (window.bunLog) {
        window.bunLog("[HFTrajectoryList] Creating initial state");
      }
      return {
        trajectories: [],
        filteredTrajectories: [],
        selectedSessionId: null,
        searchQuery: "",
        currentPage: 0,
        pageSize: 100,
        totalCount: 0,
        loading: true,
        error: null,
        collapsed: false
      };
    },
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      if (window.bunLog) {
        window.bunLog(`[HFTrajectoryList] Rendering, loading=${state.loading}, totalCount=${state.totalCount}, trajectories=${state.trajectories.length}, error=${state.error}`);
      }
      const header = html`
        <div
          class="flex items-center justify-between px-4 py-3 border-b border-zinc-800/60 cursor-pointer bg-zinc-900/40"
          data-action="toggleCollapse"
        >
          <div class="flex items-center gap-2">
            <h3 class="text-sm font-bold font-mono text-zinc-100">HuggingFace Trajectories</h3>
            ${state.totalCount > 0 ? html`<span class="text-xs text-zinc-400">(${state.totalCount})</span>` : ""}
          </div>
          <span class="text-zinc-500">${state.collapsed ? "" : ""}</span>
        </div>
      `;
      if (state.collapsed) {
        return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header}
          </div>
        `;
      }
      const searchInput = html`
        <div class="px-4 pt-3 pb-2">
          <input
            type="text"
            placeholder="Search by agent, task, episode..."
            class="w-full px-3 py-2 bg-zinc-900 border border-zinc-800 rounded text-zinc-100 text-sm placeholder:text-zinc-500 focus:border-zinc-700 focus:outline-none"
            data-action="search"
            value="${state.searchQuery}"
          />
        </div>
      `;
      const startIndex = state.currentPage * state.pageSize + 1;
      const endIndex = Math.min((state.currentPage + 1) * state.pageSize, state.totalCount);
      const pageInfo = html`
        <div class="px-4 py-2 border-b border-zinc-800/40 text-xs text-zinc-400">
          Showing ${startIndex}-${endIndex} of ${state.totalCount}
        </div>
      `;
      if (state.loading) {
        return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header} ${searchInput} ${pageInfo}
            <div class="px-4 py-8 text-center text-sm text-zinc-500">Loading trajectories...</div>
          </div>
        `;
      }
      if (state.error) {
        return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header} ${searchInput} ${pageInfo}
            <div class="px-4 py-8">
              <div class="text-sm text-red-400 mb-2">Error loading trajectories</div>
              <div class="text-xs text-zinc-500">${state.error}</div>
              <button
                class="mt-3 px-3 py-1.5 rounded bg-zinc-800 hover:bg-zinc-700 text-zinc-200 text-xs transition-colors"
                data-action="refresh"
              >
                Retry
              </button>
            </div>
          </div>
        `;
      }
      if (state.filteredTrajectories.length === 0) {
        const message = state.searchQuery ? `No trajectories match "${state.searchQuery}"` : "No trajectories found";
        return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header} ${searchInput} ${pageInfo}
            <div class="px-4 py-8 text-center text-sm text-zinc-500">${message}</div>
          </div>
        `;
      }
      const trajectoryItems = joinTemplates(state.filteredTrajectories.map((traj) => {
        const isSelected = traj.sessionId === state.selectedSessionId;
        const baseClasses = "bg-zinc-900/40 border border-zinc-800/40 rounded-lg p-3 mb-2 cursor-pointer transition-colors";
        const selectedClasses = isSelected ? "bg-zinc-800/60 border-zinc-700/50" : "hover:bg-zinc-900/60";
        return html`
            <div
              class="${baseClasses} ${selectedClasses}"
              data-action="select"
              data-session-id="${traj.sessionId}"
              data-index="${traj.index}"
            >
              <div class="flex items-center justify-between mb-1">
                <span class="text-sm font-mono text-zinc-200">${traj.agentName}</span>
                <span class="text-xs text-zinc-500">${formatDate2(traj.date)}</span>
              </div>
              <div class="text-xs text-zinc-400 mb-0.5">task: ${traj.task}</div>
              <div class="flex items-center gap-2 text-xs text-zinc-500">
                <span>${traj.episode}</span>
                <span></span>
                <span>${traj.stepCount} steps</span>
              </div>
            </div>
          `;
      }));
      const hasPrev = state.currentPage > 0;
      const hasNext = (state.currentPage + 1) * state.pageSize < state.totalCount;
      const pagination = html`
        <div class="px-4 py-3 border-t border-zinc-800/40 flex items-center justify-between">
          <button
            class="px-3 py-1.5 rounded bg-zinc-800 text-zinc-200 text-xs transition-colors ${hasPrev ? "hover:bg-zinc-700" : "opacity-50 cursor-not-allowed"}"
            data-action="prevPage"
            ${hasPrev ? "" : "disabled"}
          >
             Prev
          </button>
          <span class="text-xs text-zinc-500">Page ${state.currentPage + 1}</span>
          <button
            class="px-3 py-1.5 rounded bg-zinc-800 text-zinc-200 text-xs transition-colors ${hasNext ? "hover:bg-zinc-700" : "opacity-50 cursor-not-allowed"}"
            data-action="nextPage"
            ${hasNext ? "" : "disabled"}
          >
            Next 
          </button>
        </div>
      `;
      return html`
        <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm overflow-hidden">
          ${header} ${searchInput} ${pageInfo}
          <div class="max-h-[calc(100vh-16rem)] overflow-y-auto px-4 py-2">${trajectoryItems}</div>
          ${pagination}
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (e, target) => {
        const el = target;
        const action = el.dataset.action;
        if (action === "toggleCollapse") {
          exports_Effect.runFork(ctx.emit({ type: "toggleCollapse" }));
        } else if (action === "select") {
          const sessionId = el.dataset.sessionId;
          const index = el.dataset.index;
          if (sessionId && index) {
            exports_Effect.runFork(ctx.emit({ type: "select", sessionId, index: parseInt(index, 10) }));
          }
        } else if (action === "prevPage") {
          exports_Effect.runFork(ctx.emit({ type: "loadPage", page: -1 }));
        } else if (action === "nextPage") {
          exports_Effect.runFork(ctx.emit({ type: "loadPage", page: -2 }));
        } else if (action === "refresh") {
          exports_Effect.runFork(ctx.emit({ type: "refresh" }));
        }
      });
      yield* ctx.dom.delegate(ctx.container, "[data-action='search']", "input", (e) => {
        const input = e.target;
        exports_Effect.runFork(ctx.emit({ type: "search", query: input.value }));
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      const service3 = yield* OpenThoughtsService;
      switch (event.type) {
        case "loadPage": {
          const state = yield* ctx.state.get;
          let newPage = event.page;
          if (newPage === -1) {
            newPage = Math.max(0, state.currentPage - 1);
          } else if (newPage === -2) {
            newPage = state.currentPage + 1;
          }
          const maxPage = Math.ceil(state.totalCount / state.pageSize) - 1;
          if (newPage < 0 || newPage > maxPage)
            break;
          yield* ctx.state.update((s) => ({ ...s, loading: true, error: null }));
          try {
            const offset = newPage * state.pageSize;
            const trajectories = yield* service3.getTrajectories(offset, state.pageSize);
            const metadata = trajectories.map((t, i2) => extractMetadata(t, offset + i2));
            yield* ctx.state.update((s) => ({
              ...s,
              trajectories: metadata,
              filteredTrajectories: filterTrajectories(metadata, s.searchQuery),
              currentPage: newPage,
              loading: false
            }));
          } catch (error) {
            yield* ctx.state.update((s) => ({
              ...s,
              loading: false,
              error: error instanceof Error ? error.message : String(error)
            }));
          }
          break;
        }
        case "search": {
          yield* ctx.state.update((s) => ({
            ...s,
            searchQuery: event.query,
            filteredTrajectories: filterTrajectories(s.trajectories, event.query)
          }));
          break;
        }
        case "select": {
          yield* ctx.state.update((s) => ({
            ...s,
            selectedSessionId: event.sessionId
          }));
          break;
        }
        case "toggleCollapse": {
          yield* ctx.state.update((s) => ({ ...s, collapsed: !s.collapsed }));
          break;
        }
        case "refresh": {
          yield* ctx.emit({ type: "loadPage", page: 0 });
          break;
        }
      }
    }),
    subscriptions: (ctx) => {
      const initialLoad = exports_Effect.gen(function* () {
        if (window.bunLog) {
          window.bunLog("[HFTrajectoryList] Starting initial load...");
        }
        const service3 = yield* OpenThoughtsService;
        try {
          if (window.bunLog) {
            window.bunLog("[HFTrajectoryList] Getting trajectory count...");
          }
          const totalCount = yield* service3.count();
          if (window.bunLog) {
            window.bunLog(`[HFTrajectoryList] Total count: ${totalCount}`);
          }
          if (window.bunLog) {
            window.bunLog("[HFTrajectoryList] Loading first page...");
          }
          const trajectories = yield* service3.getTrajectories(0, 100);
          if (window.bunLog) {
            window.bunLog(`[HFTrajectoryList] Loaded trajectories: ${trajectories.length}`);
          }
          const metadata = trajectories.map((t, i2) => extractMetadata(t, i2));
          yield* ctx.state.update((s) => ({
            ...s,
            trajectories: metadata,
            filteredTrajectories: metadata,
            totalCount,
            loading: false
          }));
          if (window.bunLog) {
            window.bunLog("[HFTrajectoryList] Initial load complete");
          }
        } catch (error) {
          if (window.bunLog) {
            window.bunLog(`[HFTrajectoryList] Initial load failed: ${error}`);
          }
          yield* ctx.state.update((s) => ({
            ...s,
            loading: false,
            error: error instanceof Error ? error.message : String(error)
          }));
        }
      });
      return [exports_Effect.asVoid(initialLoad)];
    }
  };
  var initialHFTrajectoryListState = HFTrajectoryListWidget.initialState();
  // src/effuse/widgets/hf-trajectory-detail.ts
  var formatTimestamp2 = (iso) => {
    try {
      return new Date(iso).toLocaleTimeString(undefined, {
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      });
    } catch {
      return iso.slice(0, 19).replace("T", " ");
    }
  };
  var formatDate3 = (iso) => {
    try {
      return new Date(iso).toLocaleDateString(undefined, {
        month: "short",
        day: "numeric",
        year: "numeric",
        hour: "2-digit",
        minute: "2-digit"
      });
    } catch {
      return iso.slice(0, 16).replace("T", " ");
    }
  };
  var getSourceClass = (source) => {
    switch (source) {
      case "user":
        return "bg-blue-900/40 text-blue-300 border-blue-700/50";
      case "agent":
        return "bg-emerald-900/40 text-emerald-300 border-emerald-700/50";
      case "system":
        return "bg-zinc-800/40 text-zinc-300 border-zinc-700/50";
      default:
        return "bg-zinc-800/40 text-zinc-300 border-zinc-700/50";
    }
  };
  var formatJSON = (obj) => {
    try {
      if (typeof obj === "string")
        return obj;
      return JSON.stringify(obj, null, 2);
    } catch {
      return String(obj);
    }
  };
  var getMessageText = (step4) => {
    const text = extractStepText(step4);
    if (text.length > 500) {
      return text.slice(0, 500) + "... (truncated)";
    }
    return text;
  };
  var HFTrajectoryDetailWidget = {
    id: "hf-trajectory-detail",
    initialState: () => {
      if (window.bunLog) {
        window.bunLog("[HFTrajectoryDetail] Creating initial state");
      }
      return {
        trajectory: null,
        sessionId: null,
        loading: false,
        error: null,
        collapsed: false,
        expandedStepId: null,
        viewMode: "formatted"
      };
    },
    render: (ctx) => exports_Effect.gen(function* () {
      const state = yield* ctx.state.get;
      const header = html`
        <div
          class="flex items-center justify-between px-4 py-3 border-b border-zinc-800/60 cursor-pointer bg-zinc-900/40"
          data-action="toggleCollapse"
        >
          <h3 class="text-sm font-bold font-mono text-zinc-100">HF Trajectory Details</h3>
          <span class="text-zinc-500">${state.collapsed ? "" : ""}</span>
        </div>
      `;
      if (state.collapsed) {
        return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header}
          </div>
        `;
      }
      if (state.loading) {
        return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header}
            <div class="px-4 py-8 text-center text-sm text-zinc-500">Loading trajectory...</div>
          </div>
        `;
      }
      if (state.error) {
        return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header}
            <div class="px-4 py-8">
              <div class="text-sm text-red-400 mb-2">Error loading trajectory</div>
              <div class="text-xs text-zinc-500">${state.error}</div>
            </div>
          </div>
        `;
      }
      if (!state.trajectory) {
        return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header}
            <div class="px-4 py-8 text-center text-sm text-zinc-500">
              No trajectory selected. Click a trajectory in the sidebar to view details.
            </div>
          </div>
        `;
      }
      const traj = state.trajectory;
      const agent = traj.agent;
      const extra = traj.extra;
      const task = extra?.task ?? "unknown";
      const episode = extra?.episode ?? "unknown";
      const date = extra?.date ?? traj.steps[0]?.timestamp ?? "unknown";
      const metadata = html`
        <div class="px-4 py-3 bg-zinc-900/20 border-b border-zinc-800/40 space-y-1.5">
          <div class="flex items-center gap-2 text-xs">
            <span class="text-zinc-500">Session:</span>
            <span class="text-zinc-300 font-mono">${traj.session_id}</span>
          </div>
          <div class="flex items-center gap-2 text-xs">
            <span class="text-zinc-500">Agent:</span>
            <span class="text-zinc-300">${agent?.name ?? "unknown"}</span>
            ${agent?.model_name ? html`<span class="text-zinc-500">(${agent.model_name})</span>` : ""}
          </div>
          <div class="flex items-center gap-2 text-xs">
            <span class="text-zinc-500">Task:</span>
            <span class="text-zinc-300">${task}</span>
            <span class="text-zinc-500"></span>
            <span class="text-zinc-500">Episode:</span>
            <span class="text-zinc-300">${episode}</span>
          </div>
          <div class="flex items-center gap-2 text-xs">
            <span class="text-zinc-500">Steps:</span>
            <span class="text-zinc-300">${traj.steps.length}</span>
            <span class="text-zinc-500"></span>
            <span class="text-zinc-500">Date:</span>
            <span class="text-zinc-300">${formatDate3(date)}</span>
          </div>
        </div>
      `;
      const stepsList = html`
        <div class="max-h-[calc(100vh-20rem)] overflow-y-auto">
          ${joinTemplates(traj.steps.map((step4) => {
        const isExpanded = state.expandedStepId === step4.step_id;
        const source = step4.source ?? "system";
        const sourceClass = getSourceClass(source);
        const toolCallCount = hasToolCalls(step4) ? step4.tool_calls.length : 0;
        const hasObs = hasObservation(step4);
        const stepHeader = html`
                <div
                  class="flex items-center justify-between px-4 py-2 hover:bg-zinc-900/40 cursor-pointer transition-colors border-b border-zinc-800/40"
                  data-action="toggleStep"
                  data-step-id="${step4.step_id}"
                >
                  <div class="flex items-center gap-3 flex-1">
                    <span class="text-xs font-mono text-zinc-500">#${step4.step_id}</span>
                    <span class="text-xs px-1.5 py-0.5 rounded border ${sourceClass} uppercase font-mono">
                      ${source}
                    </span>
                    <span class="text-xs text-zinc-400 font-mono">${formatTimestamp2(step4.timestamp)}</span>
                    ${toolCallCount > 0 ? html`<span class="text-xs text-violet-400"> ${toolCallCount} tool${toolCallCount > 1 ? "s" : ""}</span>` : ""}
                    ${hasObs ? html`<span class="text-xs text-emerald-400"> obs</span>` : ""}
                  </div>
                  <span class="text-zinc-500">${isExpanded ? "" : ""}</span>
                </div>
              `;
        if (!isExpanded) {
          return stepHeader;
        }
        const expandedContent = html`
                <div class="px-4 py-3 bg-zinc-900/20 space-y-3">
                  ${step4.message ? html`
                        <div>
                          <div class="text-xs font-mono text-zinc-400 mb-1">Message:</div>
                          <pre
                            class="text-xs font-mono text-zinc-200 bg-zinc-950/60 p-2 rounded border border-zinc-800/40 overflow-x-auto whitespace-pre-wrap"
                          >${getMessageText(step4)}</pre>
                        </div>
                      ` : ""}
                  ${step4.reasoning_content ? html`
                        <div>
                          <div class="text-xs font-mono text-zinc-400 mb-1">Reasoning:</div>
                          <pre
                            class="text-xs font-mono text-zinc-300 bg-zinc-950/60 p-2 rounded border border-zinc-800/40 overflow-x-auto whitespace-pre-wrap"
                          >${step4.reasoning_content}</pre>
                        </div>
                      ` : ""}
                  ${hasToolCalls(step4) ? html`
                        <div>
                          <div class="text-xs font-mono text-zinc-400 mb-1">Tool Calls:</div>
                          ${joinTemplates(step4.tool_calls.map((tc) => html`
                                <div class="bg-zinc-950/60 p-2 rounded border border-zinc-800/40 mb-2">
                                  <div class="text-xs font-mono text-violet-300 mb-1">${tc.function_name}</div>
                                  <pre
                                    class="text-xs font-mono text-zinc-400 overflow-x-auto whitespace-pre-wrap"
                                  >${formatJSON(tc.arguments)}</pre>
                                </div>
                              `))}
                        </div>
                      ` : ""}
                  ${hasObservation(step4) ? html`
                        <div>
                          <div class="text-xs font-mono text-zinc-400 mb-1">Observation:</div>
                          ${joinTemplates(step4.observation.results.map((result) => {
          const content = result.content;
          const contentStr = typeof content === "string" ? content.length > 500 ? content.slice(0, 500) + "... (truncated)" : content : formatJSON(content);
          return html`
                                <pre
                                  class="text-xs font-mono text-emerald-300 bg-zinc-950/60 p-2 rounded border border-zinc-800/40 overflow-x-auto mb-2 whitespace-pre-wrap"
                                >${contentStr}</pre>
                              `;
        }))}
                        </div>
                      ` : ""}
                  ${step4.metrics ? html`
                        <div>
                          <div class="text-xs font-mono text-zinc-400 mb-1">Metrics:</div>
                          <div class="text-xs text-zinc-300 space-x-3">
                            ${step4.metrics.prompt_tokens ? html`<span>${step4.metrics.prompt_tokens} prompt tokens</span>` : ""}
                            ${step4.metrics.completion_tokens ? html`<span> ${step4.metrics.completion_tokens} completion tokens</span>` : ""}
                            ${step4.metrics.cost_usd ? html`<span> $${step4.metrics.cost_usd.toFixed(4)}</span>` : ""}
                          </div>
                        </div>
                      ` : ""}
                  ${step4.error ? html`
                        <div>
                          <div class="text-xs font-mono text-red-400 mb-1">Error:</div>
                          <pre
                            class="text-xs font-mono text-red-300 bg-red-950/20 p-2 rounded border border-red-800/40 overflow-x-auto whitespace-pre-wrap"
                          >${step4.error}</pre>
                        </div>
                      ` : ""}
                </div>
              `;
        return html`
                <div class="border-b border-zinc-800/40">
                  ${stepHeader}
                  ${expandedContent}
                </div>
              `;
      }))}
        </div>
      `;
      return html`
        <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm overflow-hidden">
          ${header} ${metadata} ${stepsList}
        </div>
      `;
    }),
    setupEvents: (ctx) => exports_Effect.gen(function* () {
      yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (e, target) => {
        const el = target;
        const action = el.dataset.action;
        const stepId = el.dataset.stepId;
        if (action === "toggleCollapse") {
          exports_Effect.runFork(ctx.emit({ type: "toggleCollapse" }));
        } else if (action === "toggleStep" && stepId) {
          exports_Effect.runFork(ctx.emit({ type: "toggleStep", stepId: parseInt(stepId, 10) }));
        }
      });
    }),
    handleEvent: (event, ctx) => exports_Effect.gen(function* () {
      switch (event.type) {
        case "load": {
          yield* ctx.state.update((s) => ({
            ...s,
            trajectory: event.trajectory,
            sessionId: event.sessionId,
            loading: false,
            error: null,
            expandedStepId: null
          }));
          break;
        }
        case "toggleCollapse":
          yield* ctx.state.update((s) => ({ ...s, collapsed: !s.collapsed }));
          break;
        case "toggleStep": {
          yield* ctx.state.update((s) => ({
            ...s,
            expandedStepId: s.expandedStepId === event.stepId ? null : event.stepId
          }));
          break;
        }
        case "clear":
          yield* ctx.state.update(() => HFTrajectoryDetailWidget.initialState());
          break;
        case "toggleViewMode": {
          yield* ctx.state.update((s) => ({
            ...s,
            viewMode: s.viewMode === "formatted" ? "json" : "formatted"
          }));
          break;
        }
      }
    }),
    subscriptions: () => []
  };
  var initialHFTrajectoryDetailState = HFTrajectoryDetailWidget.initialState();
  // src/mainview/effuse-main.ts
  console.log("[Effuse] Loading mainview...");
  if (window.bunLog) {
    window.bunLog("[Effuse] ========== EFFUSE-MAIN.TS IS EXECUTING ==========");
  }
  var showError = (msg) => {
    document.body.innerHTML = `<div style="padding:20px;color:red;font-family:monospace;background:#1a1a1a;">
    <h2>Effuse Error</h2>
    <pre>${msg}</pre>
  </div>`;
  };
  window.onerror = (msg, src, line, col, error) => {
    console.error("[Effuse] Global error:", msg, src, line, col, error);
    showError(`${msg}

Source: ${src}:${line}:${col}

${error?.stack || ""}`);
    return false;
  };
  window.onunhandledrejection = (event) => {
    if (event.reason && event.reason.constructor?.name === "Error" && Object.keys(event.reason).length === 0) {
      event.preventDefault();
      return;
    }
    console.error("[Effuse] Unhandled rejection:", event.reason);
    showError(`Unhandled Promise rejection:

${event.reason?.stack || event.reason}`);
  };
  var createEffuseLayer = () => {
    const socketClient = getSocketClient();
    return exports_Layer.mergeAll(exports_BunContext.layer, DomServiceLive, StateServiceLive, SocketServiceFromClient(socketClient), HFDatasetServiceLive(), OpenThoughtsServiceLive);
  };
  var mountAllWidgets = exports_Effect.gen(function* () {
    console.log("[Effuse] Mounting HF Trajectory Browser widgets...");
    if (window.bunLog) {
      window.bunLog("[Effuse] ========== MOUNTING HF TRAJECTORY WIDGETS ==========");
    }
    const socket = yield* SocketServiceTag;
    yield* socket.connect().pipe(exports_Effect.tap(() => console.log("[Effuse] Socket connected")), exports_Effect.catchAll((e) => {
      console.warn("[Effuse] Socket connection failed:", e);
      return exports_Effect.void;
    }));
    const openThoughtsService = yield* OpenThoughtsService;
    const listWidget = yield* mountWidgetById(HFTrajectoryListWidget, "hf-trajectory-list-widget").pipe(exports_Effect.tap(() => console.log("[Effuse] HF Trajectory List widget mounted")), exports_Effect.catchAll((e) => {
      console.error("[Effuse] Failed to mount HF Trajectory List widget:", e);
      return exports_Effect.die(e);
    }));
    const detailWidget = yield* mountWidgetById(HFTrajectoryDetailWidget, "hf-trajectory-detail-widget").pipe(exports_Effect.tap(() => console.log("[Effuse] HF Trajectory Detail widget mounted")), exports_Effect.catchAll((e) => {
      console.error("[Effuse] Failed to mount HF Trajectory Detail widget:", e);
      return exports_Effect.die(e);
    }));
    yield* exports_Stream.runForEach(listWidget.events, (event) => exports_Effect.gen(function* () {
      if (event.type === "select") {
        console.log("[Effuse] Loading trajectory:", event.sessionId, "at index:", event.index);
        yield* detailWidget.emit({ type: "clear" });
        try {
          const trajectory = yield* openThoughtsService.getTrajectory(event.index);
          yield* detailWidget.emit({
            type: "load",
            sessionId: event.sessionId,
            trajectory
          });
          console.log("[Effuse] Trajectory loaded successfully");
        } catch (error) {
          console.error("[Effuse] Failed to load trajectory:", error);
        }
      }
    })).pipe(exports_Effect.forkScoped);
    console.log("[Effuse] HF Trajectory Browser ready");
  });
  var initEffuse = () => {
    console.log("[Effuse] Creating layer...");
    if (window.bunLog) {
      window.bunLog("[Effuse] ========== INIT EFFUSE CALLED ==========");
    }
    let layer16;
    try {
      layer16 = createEffuseLayer();
      console.log("[Effuse] Layer created");
    } catch (e) {
      console.error("[Effuse] Failed to create layer:", e);
      return;
    }
    const program = exports_Effect.gen(function* () {
      yield* mountAllWidgets;
      console.log("[Effuse] Widgets mounted, keeping scope alive...");
      yield* exports_Effect.never;
    });
    console.log("[Effuse] Starting Effect runtime...");
    exports_Effect.runFork(program.pipe(exports_Effect.provide(layer16), exports_Effect.scoped, exports_Effect.catchAllDefect((defect) => {
      console.error("[Effuse] Defect caught:", defect);
      console.error("[Effuse] Defect type:", typeof defect);
      console.error("[Effuse] Defect constructor:", defect?.constructor?.name);
      if (defect instanceof Error) {
        console.error("[Effuse] Error message:", defect.message);
        console.error("[Effuse] Error stack:", defect.stack);
      }
      try {
        console.error("[Effuse] Defect stringified:", JSON.stringify(defect, null, 2));
      } catch {
        console.error("[Effuse] Could not stringify defect");
      }
      return exports_Effect.void;
    })));
    console.log("[Effuse] Mainview initialized");
  };
  if (window.bunLog) {
    window.bunLog(`[Effuse] document.readyState = ${document.readyState}`);
  }
  if (document.readyState === "loading") {
    if (window.bunLog) {
      window.bunLog("[Effuse] Waiting for DOMContentLoaded...");
    }
    document.addEventListener("DOMContentLoaded", () => {
      if (window.bunLog) {
        window.bunLog("[Effuse] DOMContentLoaded fired!");
      }
      try {
        initEffuse();
      } catch (e) {
        console.error("[Effuse] Init error:", e);
        if (window.bunLog) {
          window.bunLog(`[Effuse] Init error: ${e}`);
        }
      }
    });
  } else {
    if (window.bunLog) {
      window.bunLog("[Effuse] DOM already ready, initializing immediately");
    }
    try {
      initEffuse();
    } catch (e) {
      console.error("[Effuse] Init error:", e);
      if (window.bunLog) {
        window.bunLog(`[Effuse] Init error: ${e}`);
      }
    }
  }
})();
