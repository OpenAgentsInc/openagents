var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node_modules/@huggingface/hub/dist/browser/chunk-QXAXOUZS.mjs
var init_chunk_QXAXOUZS = () => {};

// node_modules/effect/dist/esm/Function.js
var isFunction = (input) => typeof input === "function";
var dual = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self2) => body(self2, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self2) {
          return body(self2, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self2) {
          return body(self2, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self2) {
          return body(self2, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self2) {
          return body(self2, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args = arguments;
        return function(self2) {
          return body(self2, ...args);
        };
      };
  }
};
var identity = (a) => a;
var constant = (value) => () => value;
var constTrue = /* @__PURE__ */ constant(true);
var constFalse = /* @__PURE__ */ constant(false);
var constUndefined = /* @__PURE__ */ constant(undefined);
var constVoid = constUndefined;
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1;i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
// node_modules/effect/dist/esm/Equivalence.js
var make = (isEquivalent) => (self2, that) => self2 === that || isEquivalent(self2, that);
var isStrictEquivalent = (x, y) => x === y;
var strict = () => isStrictEquivalent;
var number = /* @__PURE__ */ strict();
var mapInput = /* @__PURE__ */ dual(2, (self2, f) => make((x, y) => self2(f(x), f(y))));
var Date2 = /* @__PURE__ */ mapInput(number, (date) => date.getTime());
var array = (item) => make((self2, that) => {
  if (self2.length !== that.length) {
    return false;
  }
  for (let i = 0;i < self2.length; i++) {
    const isEq = item(self2[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
});

// node_modules/effect/dist/esm/internal/doNotation.js
var let_ = (map) => dual(3, (self2, name, f) => map(self2, (a) => ({
  ...a,
  [name]: f(a)
})));
var bindTo = (map) => dual(2, (self2, name) => map(self2, (a) => ({
  [name]: a
})));
var bind = (map, flatMap) => dual(3, (self2, name, f) => flatMap(self2, (a) => map(f(a), (b) => ({
  ...a,
  [name]: b
}))));

// node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId = `effect/GlobalValue`;
var globalStore;
var globalValue = (id, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ??= new Map;
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id)) {
    globalStore.set(id, compute());
  }
  return globalStore.get(id);
};

// node_modules/effect/dist/esm/Predicate.js
var isString = (input) => typeof input === "string";
var isNumber = (input) => typeof input === "number";
var isBoolean = (input) => typeof input === "boolean";
var isBigInt = (input) => typeof input === "bigint";
var isSymbol = (input) => typeof input === "symbol";
var isFunction2 = isFunction;
var isUndefined = (input) => input === undefined;
var isNever = (_) => false;
var isRecordOrArray = (input) => typeof input === "object" && input !== null;
var isObject = (input) => isRecordOrArray(input) || isFunction2(input);
var hasProperty = /* @__PURE__ */ dual(2, (self2, property) => isObject(self2) && (property in self2));
var isTagged = /* @__PURE__ */ dual(2, (self2, tag) => hasProperty(self2, "_tag") && self2["_tag"] === tag);
var isNullable = (input) => input === null || input === undefined;
var isNotNullable = (input) => input !== null && input !== undefined;
var isDate = (input) => input instanceof Date;
var isIterable = (input) => typeof input === "string" || hasProperty(input, Symbol.iterator);
var isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);
var isPromiseLike = (input) => hasProperty(input, "then") && isFunction2(input.then);

// node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

// node_modules/effect/dist/esm/Utils.js
class SingleShotGen {
  self;
  called = false;
  constructor(self2) {
    this.self = self2;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new SingleShotGen(this.self);
  }
}
var defaultIncHi = 335903614;
var defaultIncLo = 4150755663;
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var BIT_53 = 9007199254740992;
var BIT_27 = 134217728;

class PCGRandom {
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  integer(max) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max;
  }
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
}
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
var YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");

class YieldWrap {
  #value;
  constructor(value) {
    this.#value = value;
  }
  [YieldWrapTypeId]() {
    return this.#value;
  }
}
function yieldWrapGet(self2) {
  if (typeof self2 === "object" && self2 !== null && YieldWrapTypeId in self2) {
    return self2[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
var structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: undefined
}));
var standard = {
  effect_internal_function: (body) => {
    return body();
  }
};
var forced = {
  effect_internal_function: (body) => {
    try {
      return body();
    } finally {}
  }
};
var isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
var genConstructor = function* () {}.constructor;
var isGeneratorFunction = (u) => isObject(u) && u.constructor === genConstructor;

// node_modules/effect/dist/esm/Hash.js
var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => new WeakMap);
var symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
var hash = (self2) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self2) {
    case "number":
      return number2(self2);
    case "bigint":
      return string(self2.toString(10));
    case "boolean":
      return string(String(self2));
    case "symbol":
      return string(String(self2));
    case "string":
      return string(self2);
    case "undefined":
      return string("undefined");
    case "function":
    case "object": {
      if (self2 === null) {
        return string("null");
      } else if (self2 instanceof Date) {
        return hash(self2.toISOString());
      } else if (self2 instanceof URL) {
        return hash(self2.href);
      } else if (isHash(self2)) {
        return self2[symbol]();
      } else {
        return random(self2);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self2} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
var random = (self2) => {
  if (!randomHashCache.has(self2)) {
    randomHashCache.set(self2, number2(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self2);
};
var combine = (b) => (self2) => self2 * 53 ^ b;
var optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
var isHash = (u) => hasProperty(u, symbol);
var number2 = (n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h = n | 0;
  if (h !== n) {
    h ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h ^= n /= 4294967295;
  }
  return optimize(h);
};
var string = (str) => {
  let h = 5381, i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h);
};
var structureKeys = (o, keys) => {
  let h = 12289;
  for (let i = 0;i < keys.length; i++) {
    h ^= pipe(string(keys[i]), combine(hash(o[keys[i]])));
  }
  return optimize(h);
};
var structure = (o) => structureKeys(o, Object.keys(o));
var array2 = (arr) => {
  let h = 6151;
  for (let i = 0;i < arr.length; i++) {
    h = pipe(h, combine(hash(arr[i])));
  }
  return optimize(h);
};
var cached = function() {
  if (arguments.length === 1) {
    const self3 = arguments[0];
    return function(hash3) {
      Object.defineProperty(self3, symbol, {
        value() {
          return hash3;
        },
        enumerable: false
      });
      return hash3;
    };
  }
  const self2 = arguments[0];
  const hash2 = arguments[1];
  Object.defineProperty(self2, symbol, {
    value() {
      return hash2;
    },
    enumerable: false
  });
  return hash2;
};

// node_modules/effect/dist/esm/Equal.js
var symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self2) => compareBoth(self2, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self2, that) {
  if (self2 === that) {
    return true;
  }
  const selfType = typeof self2;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self2 !== null && that !== null) {
      if (isEqual(self2) && isEqual(that)) {
        if (hash(self2) === hash(that) && self2[symbol2](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
        }
      } else if (self2 instanceof Date && that instanceof Date) {
        return self2.toISOString() === that.toISOString();
      } else if (self2 instanceof URL && that instanceof URL) {
        return self2.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self2) && Array.isArray(that)) {
        return self2.length === that.length && self2.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self2) === Object.prototype && Object.getPrototypeOf(self2) === Object.prototype) {
        const keysSelf = Object.keys(self2);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!((key in that) && compareBoth(self2[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
}
var isEqual = (u) => hasProperty(u, symbol2);
var equivalence = () => equals;

// node_modules/effect/dist/esm/Inspectable.js
var NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var toJSON = (x) => {
  try {
    if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
};
var CIRCULAR = "[Circular]";
function formatDate(date) {
  try {
    return date.toISOString();
  } catch {
    return "Invalid Date";
  }
}
function safeToString(input) {
  try {
    const s = input.toString();
    return typeof s === "string" ? s : String(s);
  } catch {
    return "[toString threw]";
  }
}
function formatPropertyKey(name) {
  return isString(name) ? JSON.stringify(name) : String(name);
}
function formatUnknown(input, options) {
  const space = options?.space ?? 0;
  const seen = new WeakSet;
  const gap = !space ? "" : isNumber(space) ? " ".repeat(space) : space;
  const ind = (d) => gap.repeat(d);
  const wrap = (v, body) => {
    const ctor = v?.constructor;
    return ctor && ctor !== Object.prototype.constructor && ctor.name ? `${ctor.name}(${body})` : body;
  };
  const ownKeys = (o) => {
    try {
      return Reflect.ownKeys(o);
    } catch {
      return ["[ownKeys threw]"];
    }
  };
  function go(v, d = 0) {
    if (Array.isArray(v)) {
      if (seen.has(v))
        return CIRCULAR;
      seen.add(v);
      if (!gap || v.length <= 1)
        return `[${v.map((x) => go(x, d)).join(",")}]`;
      const inner = v.map((x) => go(x, d + 1)).join(`,
` + ind(d + 1));
      return `[
${ind(d + 1)}${inner}
${ind(d)}]`;
    }
    if (isDate(v))
      return formatDate(v);
    if (!options?.ignoreToString && hasProperty(v, "toString") && isFunction2(v["toString"]) && v["toString"] !== Object.prototype.toString && v["toString"] !== Array.prototype.toString) {
      const s = safeToString(v);
      if (v instanceof Error && v.cause) {
        return `${s} (cause: ${go(v.cause, d)})`;
      }
      return s;
    }
    if (isString(v))
      return JSON.stringify(v);
    if (isNumber(v) || v == null || isBoolean(v) || isSymbol(v))
      return String(v);
    if (isBigInt(v))
      return String(v) + "n";
    if (v instanceof Set || v instanceof Map) {
      if (seen.has(v))
        return CIRCULAR;
      seen.add(v);
      return `${v.constructor.name}(${go(Array.from(v), d)})`;
    }
    if (isObject(v)) {
      if (seen.has(v))
        return CIRCULAR;
      seen.add(v);
      const keys = ownKeys(v);
      if (!gap || keys.length <= 1) {
        const body2 = `{${keys.map((k) => `${formatPropertyKey(k)}:${go(v[k], d)}`).join(",")}}`;
        return wrap(v, body2);
      }
      const body = `{
${keys.map((k) => `${ind(d + 1)}${formatPropertyKey(k)}: ${go(v[k], d + 1)}`).join(`,
`)}
${ind(d)}}`;
      return wrap(v, body);
    }
    return String(v);
  }
  return go(input, 0);
}
var format = (x) => JSON.stringify(x, null, 2);
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var toStringUnknown = (u, whitespace = 2) => {
  if (typeof u === "string") {
    return u;
  }
  try {
    return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
  } catch {
    return String(u);
  }
};
var stringifyCircular = (obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value) => typeof value === "object" && value !== null ? cache.includes(value) ? undefined : cache.push(value) && (redactableState.fiberRefs !== undefined && isRedactable(value) ? value[symbolRedactable](redactableState.fiberRefs) : value) : value, whitespace);
  cache = undefined;
  return retVal;
};
var symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
var isRedactable = (u) => typeof u === "object" && u !== null && (symbolRedactable in u);
var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: undefined
}));
var withRedactableContext = (context, f) => {
  const prev = redactableState.fiberRefs;
  redactableState.fiberRefs = context;
  try {
    return f();
  } finally {
    redactableState.fiberRefs = prev;
  }
};
var redact = (u) => {
  if (isRedactable(u) && redactableState.fiberRefs !== undefined) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
};

// node_modules/effect/dist/esm/Pipeable.js
var pipeArguments = (self2, args) => {
  switch (args.length) {
    case 0:
      return self2;
    case 1:
      return args[0](self2);
    case 2:
      return args[1](args[0](self2));
    case 3:
      return args[2](args[1](args[0](self2)));
    case 4:
      return args[3](args[2](args[1](args[0](self2))));
    case 5:
      return args[4](args[3](args[2](args[1](args[0](self2)))));
    case 6:
      return args[5](args[4](args[3](args[2](args[1](args[0](self2))))));
    case 7:
      return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self2)))))));
    case 8:
      return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self2))))))));
    case 9:
      return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self2)))))))));
    default: {
      let ret = self2;
      for (let i = 0, len = args.length;i < len; i++) {
        ret = args[i](ret);
      }
      return ret;
    }
  }
};

// node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_ASYNC = "Async";
var OP_COMMIT = "Commit";
var OP_FAILURE = "Failure";
var OP_ON_FAILURE = "OnFailure";
var OP_ON_SUCCESS = "OnSuccess";
var OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
var OP_SUCCESS = "Success";
var OP_SYNC = "Sync";
var OP_TAG = "Tag";
var OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
var OP_WHILE = "While";
var OP_ITERATOR = "Iterator";
var OP_WITH_RUNTIME = "WithRuntime";
var OP_YIELD = "Yield";
var OP_REVERT_FLAGS = "RevertFlags";

// node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.19.8";
var getCurrentVersion = () => moduleVersion;

// node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
var StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
var SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
var ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
var effectVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _A: (_) => _,
  _V: /* @__PURE__ */ getCurrentVersion()
};
var sinkVariance = {
  _A: (_) => _,
  _In: (_) => _,
  _L: (_) => _,
  _E: (_) => _,
  _R: (_) => _
};
var channelVariance = {
  _Env: (_) => _,
  _InErr: (_) => _,
  _InElem: (_) => _,
  _InDone: (_) => _,
  _OutErr: (_) => _,
  _OutElem: (_) => _,
  _OutDone: (_) => _
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol2](that) {
    return this === that;
  },
  [symbol]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol]() {
    return cached(this, structure(this));
  },
  [symbol2](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!((key in that) && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};
var Base = /* @__PURE__ */ function() {
  function Base2() {}
  Base2.prototype = CommitPrototype;
  return Base2;
}();

// node_modules/effect/dist/esm/internal/option.js
var TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol2](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol]() {
    return cached(this, combine(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = /* @__PURE__ */ hash("None");
var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol2](that) {
    return isOption(that) && isNone(that);
  },
  [symbol]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = (input) => hasProperty(input, TypeId);
var isNone = (fa) => fa._tag === "None";
var isSome = (fa) => fa._tag === "Some";
var none = /* @__PURE__ */ Object.create(NoneProto);
var some = (value) => {
  const a = Object.create(SomeProto);
  a.value = value;
  return a;
};

// node_modules/effect/dist/esm/internal/either.js
var TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId2]: {
    _R: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol2](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol2](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = (input) => hasProperty(input, TypeId2);
var isLeft = (ma) => ma._tag === "Left";
var isRight = (ma) => ma._tag === "Right";
var left = (left2) => {
  const a = Object.create(LeftProto);
  a.left = left2;
  return a;
};
var right = (right2) => {
  const a = Object.create(RightProto);
  a.right = right2;
  return a;
};

// node_modules/effect/dist/esm/Either.js
var right2 = right;
var left2 = left;
var isEither2 = isEither;
var isLeft2 = isLeft;
var isRight2 = isRight;
var mapLeft = /* @__PURE__ */ dual(2, (self2, f) => isLeft2(self2) ? left2(f(self2.left)) : right2(self2.right));
var map = /* @__PURE__ */ dual(2, (self2, f) => isRight2(self2) ? right2(f(self2.right)) : left2(self2.left));
var match = /* @__PURE__ */ dual(2, (self2, {
  onLeft,
  onRight
}) => isLeft2(self2) ? onLeft(self2.left) : onRight(self2.right));
var merge = /* @__PURE__ */ match({
  onLeft: identity,
  onRight: identity
});
var getOrThrowWith = /* @__PURE__ */ dual(2, (self2, onLeft) => {
  if (isRight2(self2)) {
    return self2.right;
  }
  throw onLeft(self2.left);
});
var getOrThrow = /* @__PURE__ */ getOrThrowWith(() => new Error("getOrThrow called on a Left"));

// node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray = (self2) => self2.length > 0;

// node_modules/effect/dist/esm/Order.js
var make2 = (compare) => (self2, that) => self2 === that ? 0 : compare(self2, that);
var number3 = /* @__PURE__ */ make2((self2, that) => self2 < that ? -1 : 1);
var mapInput2 = /* @__PURE__ */ dual(2, (self2, f) => make2((b1, b2) => self2(f(b1), f(b2))));
var greaterThan = (O) => dual(2, (self2, that) => O(self2, that) === 1);

// node_modules/effect/dist/esm/Option.js
var none2 = () => none;
var some2 = some;
var isNone2 = isNone;
var isSome2 = isSome;
var match2 = /* @__PURE__ */ dual(2, (self2, {
  onNone,
  onSome
}) => isNone2(self2) ? onNone() : onSome(self2.value));
var getOrElse = /* @__PURE__ */ dual(2, (self2, onNone) => isNone2(self2) ? onNone() : self2.value);
var orElse = /* @__PURE__ */ dual(2, (self2, that) => isNone2(self2) ? that() : self2);
var orElseSome = /* @__PURE__ */ dual(2, (self2, onNone) => isNone2(self2) ? some2(onNone()) : self2);
var fromNullable = (nullableValue) => nullableValue == null ? none2() : some2(nullableValue);
var getOrUndefined = /* @__PURE__ */ getOrElse(constUndefined);
var liftThrowable = (f) => (...a) => {
  try {
    return some2(f(...a));
  } catch {
    return none2();
  }
};
var getOrThrowWith2 = /* @__PURE__ */ dual(2, (self2, onNone) => {
  if (isSome2(self2)) {
    return self2.value;
  }
  throw onNone();
});
var getOrThrow2 = /* @__PURE__ */ getOrThrowWith2(() => new Error("getOrThrow called on a None"));
var map2 = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : some2(f(self2.value)));
var flatMap = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : f(self2.value));
var flatMapNullable = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : fromNullable(f(self2.value)));
var containsWith = (isEquivalent) => dual(2, (self2, a) => isNone2(self2) ? false : isEquivalent(self2.value, a));
var _equivalence = /* @__PURE__ */ equivalence();
var contains = /* @__PURE__ */ containsWith(_equivalence);
var exists = /* @__PURE__ */ dual(2, (self2, refinement) => isNone2(self2) ? false : refinement(self2.value));
var mergeWith = (f) => (o1, o2) => {
  if (isNone2(o1)) {
    return o2;
  } else if (isNone2(o2)) {
    return o1;
  }
  return some2(f(o1.value, o2.value));
};

// node_modules/effect/dist/esm/Tuple.js
var make3 = (...elements) => elements;

// node_modules/effect/dist/esm/Iterable.js
var findFirst = /* @__PURE__ */ dual(2, (self2, f) => {
  let i = 0;
  for (const a of self2) {
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some2(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
    i++;
  }
  return none2();
});
var constEmpty = {
  [Symbol.iterator]() {
    return constEmptyIterator;
  }
};
var constEmptyIterator = {
  next() {
    return {
      done: true,
      value: undefined
    };
  }
};

// node_modules/effect/dist/esm/Array.js
var allocate = (n) => new Array(n);
var makeBy = /* @__PURE__ */ dual(2, (n, f) => {
  const max = Math.max(1, Math.floor(n));
  const out = new Array(max);
  for (let i = 0;i < max; i++) {
    out[i] = f(i);
  }
  return out;
});
var fromIterable = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
var ensure = (self2) => Array.isArray(self2) ? self2 : [self2];
var matchLeft = /* @__PURE__ */ dual(2, (self2, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(headNonEmpty(self2), tailNonEmpty(self2)) : onEmpty());
var prepend = /* @__PURE__ */ dual(2, (self2, head) => [head, ...self2]);
var append = /* @__PURE__ */ dual(2, (self2, last) => [...self2, last]);
var appendAll = /* @__PURE__ */ dual(2, (self2, that) => fromIterable(self2).concat(fromIterable(that)));
var isArray = Array.isArray;
var isEmptyArray = (self2) => self2.length === 0;
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyArray2 = isNonEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var isOutOfBounds = (i, as) => i < 0 || i >= as.length;
var clamp = (i, as) => Math.floor(Math.min(Math.max(0, i), as.length));
var get = /* @__PURE__ */ dual(2, (self2, index) => {
  const i = Math.floor(index);
  return isOutOfBounds(i, self2) ? none2() : some2(self2[i]);
});
var unsafeGet = /* @__PURE__ */ dual(2, (self2, index) => {
  const i = Math.floor(index);
  if (isOutOfBounds(i, self2)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self2[i];
});
var head = /* @__PURE__ */ get(0);
var headNonEmpty = /* @__PURE__ */ unsafeGet(0);
var last = (self2) => isNonEmptyReadonlyArray(self2) ? some2(lastNonEmpty(self2)) : none2();
var lastNonEmpty = (self2) => self2[self2.length - 1];
var tailNonEmpty = (self2) => self2.slice(1);
var spanIndex = (self2, predicate) => {
  let i = 0;
  for (const a of self2) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
};
var span = /* @__PURE__ */ dual(2, (self2, predicate) => splitAt(self2, spanIndex(self2, predicate)));
var drop = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable(self2);
  return input.slice(clamp(n, input), input.length);
});
var findFirst2 = findFirst;
var reverse = (self2) => Array.from(self2).reverse();
var sort = /* @__PURE__ */ dual(2, (self2, O) => {
  const out = Array.from(self2);
  out.sort(O);
  return out;
});
var zip = /* @__PURE__ */ dual(2, (self2, that) => zipWith(self2, that, make3));
var zipWith = /* @__PURE__ */ dual(3, (self2, that, f) => {
  const as = fromIterable(self2);
  const bs = fromIterable(that);
  if (isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs)) {
    const out = [f(headNonEmpty(as), headNonEmpty(bs))];
    const len = Math.min(as.length, bs.length);
    for (let i = 1;i < len; i++) {
      out[i] = f(as[i], bs[i]);
    }
    return out;
  }
  return [];
});
var _equivalence2 = /* @__PURE__ */ equivalence();
var splitAt = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = Array.from(self2);
  const _n = Math.floor(n);
  if (isNonEmptyReadonlyArray(input)) {
    if (_n >= 1) {
      return splitNonEmptyAt(input, _n);
    }
    return [[], input];
  }
  return [input, []];
});
var splitNonEmptyAt = /* @__PURE__ */ dual(2, (self2, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self2.length ? [copy(self2), []] : [prepend(self2.slice(1, _n), headNonEmpty(self2)), self2.slice(_n)];
});
var copy = (self2) => self2.slice();
var unionWith = /* @__PURE__ */ dual(3, (self2, that, isEquivalent) => {
  const a = fromIterable(self2);
  const b = fromIterable(that);
  if (isNonEmptyReadonlyArray(a)) {
    if (isNonEmptyReadonlyArray(b)) {
      const dedupe = dedupeWith(isEquivalent);
      return dedupe(appendAll(a, b));
    }
    return a;
  }
  return b;
});
var union = /* @__PURE__ */ dual(2, (self2, that) => unionWith(self2, that, _equivalence2));
var empty = () => [];
var of = (a) => [a];
var map3 = /* @__PURE__ */ dual(2, (self2, f) => self2.map(f));
var flatMap2 = /* @__PURE__ */ dual(2, (self2, f) => {
  if (isEmptyReadonlyArray(self2)) {
    return [];
  }
  const out = [];
  for (let i = 0;i < self2.length; i++) {
    const inner = f(self2[i], i);
    for (let j = 0;j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
var flatten = /* @__PURE__ */ flatMap2(identity);
var filterMap = /* @__PURE__ */ dual(2, (self2, f) => {
  const as = fromIterable(self2);
  const out = [];
  for (let i = 0;i < as.length; i++) {
    const o = f(as[i], i);
    if (isSome2(o)) {
      out.push(o.value);
    }
  }
  return out;
});
var filterMapWhile = /* @__PURE__ */ dual(2, (self2, f) => {
  let i = 0;
  const out = [];
  for (const a of self2) {
    const b = f(a, i);
    if (isSome2(b)) {
      out.push(b.value);
    } else {
      break;
    }
    i++;
  }
  return out;
});
var partitionMap = /* @__PURE__ */ dual(2, (self2, f) => {
  const left3 = [];
  const right3 = [];
  const as = fromIterable(self2);
  for (let i = 0;i < as.length; i++) {
    const e = f(as[i], i);
    if (isLeft2(e)) {
      left3.push(e.left);
    } else {
      right3.push(e.right);
    }
  }
  return [left3, right3];
});
var getSomes = /* @__PURE__ */ filterMap(identity);
var filter = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const as = fromIterable(self2);
  const out = [];
  for (let i = 0;i < as.length; i++) {
    if (predicate(as[i], i)) {
      out.push(as[i]);
    }
  }
  return out;
});
var reduce = /* @__PURE__ */ dual(3, (self2, b, f) => fromIterable(self2).reduce((b2, a, i) => f(b2, a, i), b));
var reduceRight = /* @__PURE__ */ dual(3, (self2, b, f) => fromIterable(self2).reduceRight((b2, a, i) => f(b2, a, i), b));
var every = /* @__PURE__ */ dual(2, (self2, refinement) => self2.every(refinement));
var unfold = (b, f) => {
  const out = [];
  let next = b;
  let o;
  while (isSome2(o = f(next))) {
    const [a, b2] = o.value;
    out.push(a);
    next = b2;
  }
  return out;
};
var getEquivalence = array;
var dedupeWith = /* @__PURE__ */ dual(2, (self2, isEquivalent) => {
  const input = fromIterable(self2);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every((a) => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe = (self2) => dedupeWith(self2, equivalence());
var join = /* @__PURE__ */ dual(2, (self2, sep) => fromIterable(self2).join(sep));
var mapAccum = /* @__PURE__ */ dual(3, (self2, s, f) => {
  let i = 0;
  let s1 = s;
  const out = [];
  for (const a of self2) {
    const r = f(s1, a, i);
    s1 = r[0];
    out.push(r[1]);
    i++;
  }
  return [s1, out];
});

// node_modules/effect/dist/esm/internal/schema/util.js
var getKeysForIndexSignature = (input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature(input, parameter.from);
  }
};
var memoizeThunk = (f) => {
  let done = false;
  let a;
  return () => {
    if (done) {
      return a;
    }
    a = f();
    done = true;
    return a;
  };
};
var isNonEmpty = (x) => Array.isArray(x);
var isSingle = (x) => !Array.isArray(x);
var formatPathKey = (key) => `[${formatPropertyKey(key)}]`;
var formatPath = (path) => isNonEmpty(path) ? path.map(formatPathKey).join("") : formatPathKey(path);

// node_modules/effect/dist/esm/internal/schema/errors.js
var getErrorMessage = (reason, details, path, ast) => {
  let out = reason;
  if (path && isNonEmptyReadonlyArray(path)) {
    out += `
at path: ${formatPath(path)}`;
  }
  if (details !== undefined) {
    out += `
details: ${details}`;
  }
  if (ast) {
    out += `
schema (${ast._tag}): ${ast}`;
  }
  return out;
};
var getSchemaExtendErrorMessage = (x, y, path) => getErrorMessage("Unsupported schema or overlapping types", `cannot extend ${x} with ${y}`, path);
var getASTUnsupportedKeySchemaErrorMessage = (ast) => getErrorMessage("Unsupported key schema", undefined, undefined, ast);
var getASTUnsupportedLiteralErrorMessage = (literal) => getErrorMessage("Unsupported literal", `literal value: ${formatUnknown(literal)}`);
var getASTDuplicateIndexSignatureErrorMessage = (type) => getErrorMessage("Duplicate index signature", `${type} index signature`);
var getASTIndexSignatureParameterErrorMessage = /* @__PURE__ */ getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
var getASTRequiredElementFollowinAnOptionalElementErrorMessage = /* @__PURE__ */ getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
var getASTDuplicatePropertySignatureTransformationErrorMessage = (key) => getErrorMessage("Duplicate property signature transformation", `Duplicate key ${formatUnknown(key)}`);
var getASTDuplicatePropertySignatureErrorMessage = (key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`);

// node_modules/effect/dist/esm/internal/schema/schemaId.js
var DateFromSelfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/DateFromSelf");
var GreaterThanSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThan");
var IntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Int");

// node_modules/effect/dist/esm/Number.js
var Order = number3;
var nextPow2 = (n) => {
  const nextPow = Math.ceil(Math.log(n) / Math.log(2));
  return Math.max(Math.pow(2, nextPow), 2);
};

// node_modules/effect/dist/esm/RegExp.js
var escape = (string2) => string2.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

// node_modules/effect/dist/esm/SchemaAST.js
var BrandAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Brand");
var SchemaIdAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/SchemaId");
var MessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Message");
var MissingMessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/MissingMessage");
var IdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Identifier");
var TitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Title");
var AutoTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/AutoTitle");
var DescriptionAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Description");
var ExamplesAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Examples");
var DefaultAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Default");
var JSONSchemaAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONSchema");
var ArbitraryAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Arbitrary");
var PrettyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Pretty");
var EquivalenceAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Equivalence");
var DocumentationAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Documentation");
var ConcurrencyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Concurrency");
var BatchingAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Batching");
var ParseIssueTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseIssueTitle");
var ParseOptionsAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseOptions");
var DecodingFallbackAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/DecodingFallback");
var SurrogateAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Surrogate");
var StableFilterAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/StableFilter");
var getAnnotation = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some2(annotated.annotations[key]) : none2());
var getBrandAnnotation = /* @__PURE__ */ getAnnotation(BrandAnnotationId);
var getMessageAnnotation = /* @__PURE__ */ getAnnotation(MessageAnnotationId);
var getMissingMessageAnnotation = /* @__PURE__ */ getAnnotation(MissingMessageAnnotationId);
var getTitleAnnotation = /* @__PURE__ */ getAnnotation(TitleAnnotationId);
var getAutoTitleAnnotation = /* @__PURE__ */ getAnnotation(AutoTitleAnnotationId);
var getIdentifierAnnotation = /* @__PURE__ */ getAnnotation(IdentifierAnnotationId);
var getDescriptionAnnotation = /* @__PURE__ */ getAnnotation(DescriptionAnnotationId);
var getConcurrencyAnnotation = /* @__PURE__ */ getAnnotation(ConcurrencyAnnotationId);
var getBatchingAnnotation = /* @__PURE__ */ getAnnotation(BatchingAnnotationId);
var getParseIssueTitleAnnotation = /* @__PURE__ */ getAnnotation(ParseIssueTitleAnnotationId);
var getParseOptionsAnnotation = /* @__PURE__ */ getAnnotation(ParseOptionsAnnotationId);
var getDecodingFallbackAnnotation = /* @__PURE__ */ getAnnotation(DecodingFallbackAnnotationId);
var getSurrogateAnnotation = /* @__PURE__ */ getAnnotation(SurrogateAnnotationId);
var getStableFilterAnnotation = /* @__PURE__ */ getAnnotation(StableFilterAnnotationId);
var hasStableFilter = (annotated) => exists(getStableFilterAnnotation(annotated), (b) => b === true);
var JSONIdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONIdentifier");
var getJSONIdentifierAnnotation = /* @__PURE__ */ getAnnotation(JSONIdentifierAnnotationId);
var getJSONIdentifier = (annotated) => orElse(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
class Declaration {
  typeParameters;
  decodeUnknown;
  encodeUnknown;
  annotations;
  _tag = "Declaration";
  constructor(typeParameters, decodeUnknown, encodeUnknown, annotations = {}) {
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown;
    this.encodeUnknown = encodeUnknown;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => "<declaration schema>");
  }
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var createASTGuard = (tag) => (ast) => ast._tag === tag;
class Literal {
  literal;
  annotations;
  _tag = "Literal";
  constructor(literal, annotations = {}) {
    this.literal = literal;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatUnknown(this.literal));
  }
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isLiteral = /* @__PURE__ */ createASTGuard("Literal");
class UniqueSymbol {
  symbol;
  annotations;
  _tag = "UniqueSymbol";
  constructor(symbol3, annotations = {}) {
    this.symbol = symbol3;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatUnknown(this.symbol));
  }
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
class UndefinedKeyword {
  annotations;
  _tag = "UndefinedKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var undefinedKeyword = /* @__PURE__ */ new UndefinedKeyword({
  [TitleAnnotationId]: "undefined"
});
class VoidKeyword {
  annotations;
  _tag = "VoidKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var voidKeyword = /* @__PURE__ */ new VoidKeyword({
  [TitleAnnotationId]: "void"
});
class NeverKeyword {
  annotations;
  _tag = "NeverKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var neverKeyword = /* @__PURE__ */ new NeverKeyword({
  [TitleAnnotationId]: "never"
});
class UnknownKeyword {
  annotations;
  _tag = "UnknownKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var unknownKeyword = /* @__PURE__ */ new UnknownKeyword({
  [TitleAnnotationId]: "unknown"
});
class AnyKeyword {
  annotations;
  _tag = "AnyKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var anyKeyword = /* @__PURE__ */ new AnyKeyword({
  [TitleAnnotationId]: "any"
});
class StringKeyword {
  annotations;
  _tag = "StringKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var stringKeyword = /* @__PURE__ */ new StringKeyword({
  [TitleAnnotationId]: "string",
  [DescriptionAnnotationId]: "a string"
});
var isStringKeyword = /* @__PURE__ */ createASTGuard("StringKeyword");

class NumberKeyword {
  annotations;
  _tag = "NumberKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var numberKeyword = /* @__PURE__ */ new NumberKeyword({
  [TitleAnnotationId]: "number",
  [DescriptionAnnotationId]: "a number"
});
var isNumberKeyword = /* @__PURE__ */ createASTGuard("NumberKeyword");

class BooleanKeyword {
  annotations;
  _tag = "BooleanKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var booleanKeyword = /* @__PURE__ */ new BooleanKeyword({
  [TitleAnnotationId]: "boolean",
  [DescriptionAnnotationId]: "a boolean"
});
var isBooleanKeyword = /* @__PURE__ */ createASTGuard("BooleanKeyword");

class BigIntKeyword {
  annotations;
  _tag = "BigIntKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var bigIntKeyword = /* @__PURE__ */ new BigIntKeyword({
  [TitleAnnotationId]: "bigint",
  [DescriptionAnnotationId]: "a bigint"
});
class SymbolKeyword {
  annotations;
  _tag = "SymbolKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var symbolKeyword = /* @__PURE__ */ new SymbolKeyword({
  [TitleAnnotationId]: "symbol",
  [DescriptionAnnotationId]: "a symbol"
});
var isSymbolKeyword = /* @__PURE__ */ createASTGuard("SymbolKeyword");

class ObjectKeyword {
  annotations;
  _tag = "ObjectKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var objectKeyword = /* @__PURE__ */ new ObjectKeyword({
  [TitleAnnotationId]: "object",
  [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
});
class Type {
  type;
  annotations;
  constructor(type, annotations = {}) {
    this.type = type;
    this.annotations = annotations;
  }
  toJSON() {
    return {
      type: this.type.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  toString() {
    return String(this.type);
  }
}

class OptionalType extends Type {
  isOptional;
  constructor(type, isOptional, annotations = {}) {
    super(type, annotations);
    this.isOptional = isOptional;
  }
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
}
var getRestASTs = (rest) => rest.map((annotatedAST) => annotatedAST.type);

class TupleType {
  elements;
  rest;
  isReadonly;
  annotations;
  _tag = "TupleType";
  constructor(elements, rest, isReadonly, annotations = {}) {
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
    }
  }
  toString() {
    return getOrElse(getExpected(this), () => formatTuple(this));
  }
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map((e) => e.toJSON()),
      rest: this.rest.map((ast) => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var formatTuple = (ast) => {
  const formattedElements = ast.elements.map(String).join(", ");
  return matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head2, tail) => {
      const formattedHead = String(head2);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail.length > 0) {
        const formattedTail = tail.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
};
class PropertySignature extends OptionalType {
  name;
  isReadonly;
  constructor(name, type, isOptional, isReadonly, annotations) {
    super(type, isOptional, annotations);
    this.name = name;
    this.isReadonly = isReadonly;
  }
  toString() {
    return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
  }
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter(ast.from);
  }
  return false;
};

class IndexSignature {
  type;
  isReadonly;
  parameter;
  constructor(parameter, type, isReadonly) {
    this.type = type;
    this.isReadonly = isReadonly;
    if (isParameter(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(getASTIndexSignatureParameterErrorMessage);
    }
  }
  toString() {
    return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
  }
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
}

class TypeLiteral {
  annotations;
  _tag = "TypeLiteral";
  propertySignatures;
  indexSignatures;
  constructor(propertySignatures, indexSignatures, annotations = {}) {
    this.annotations = annotations;
    const keys = {};
    for (let i = 0;i < propertySignatures.length; i++) {
      const name = propertySignatures[i].name;
      if (Object.prototype.hasOwnProperty.call(keys, name)) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
      }
      keys[name] = null;
    }
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i = 0;i < indexSignatures.length; i++) {
      const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
      if (isStringKeyword(encodedParameter)) {
        if (parameters.string) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword(encodedParameter)) {
        if (parameters.symbol) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = propertySignatures;
    this.indexSignatures = indexSignatures;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatTypeLiteral(this));
  }
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var formatIndexSignatures = (iss) => iss.map(String).join("; ");
var formatTypeLiteral = (ast) => {
  if (ast.propertySignatures.length > 0) {
    const pss = ast.propertySignatures.map(String).join("; ");
    if (ast.indexSignatures.length > 0) {
      return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return `{ ${pss} }`;
    }
  } else {
    if (ast.indexSignatures.length > 0) {
      return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return "{}";
    }
  }
};
var isTypeLiteral = /* @__PURE__ */ createASTGuard("TypeLiteral");
var sortCandidates = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput2(Order, (ast) => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
var literalMap = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
var flatten2 = (candidates) => flatMap2(candidates, (ast) => isUnion(ast) ? flatten2(ast.types) : [ast]);
var unify = (candidates) => {
  const cs = sortCandidates(candidates);
  const out = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword];
      case "UnknownKeyword":
        return [unknownKeyword];
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword": {
        if (!uniques[ast._tag]) {
          uniques[ast._tag] = ast;
          out.push(ast);
        }
        break;
      }
      case "Literal": {
        const type = typeof ast.literal;
        switch (type) {
          case "string":
          case "number":
          case "bigint":
          case "boolean": {
            const _tag = literalMap[type];
            if (!uniques[_tag] && !literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
          case "object": {
            if (!literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
        }
        break;
      }
      case "UniqueSymbol": {
        if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
          literals.push(ast.symbol);
          out.push(ast);
        }
        break;
      }
      case "TupleType": {
        if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          if (!uniques["{}"]) {
            uniques["{}"] = ast;
            out.push(ast);
          }
        } else if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      default:
        out.push(ast);
    }
  }
  return out;
};

class Union {
  types;
  annotations;
  static make = (types, annotations) => {
    return isMembers(types) ? new Union(types, annotations) : types.length === 1 ? types[0] : neverKeyword;
  };
  static unify = (candidates, annotations) => {
    return Union.make(unify(flatten2(candidates)), annotations);
  };
  _tag = "Union";
  constructor(types, annotations = {}) {
    this.types = types;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => this.types.map(String).join(" | "));
  }
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var mapMembers = (members, f) => members.map(f);
var isMembers = (as) => as.length > 1;
var isUnion = /* @__PURE__ */ createASTGuard("Union");
var toJSONMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => new WeakMap);

class Suspend {
  f;
  annotations;
  _tag = "Suspend";
  constructor(f, annotations = {}) {
    this.f = f;
    this.annotations = annotations;
    this.f = memoizeThunk(f);
  }
  toString() {
    return getExpected(this).pipe(orElse(() => flatMap(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse(() => "<suspended schema>"));
  }
  toJSON() {
    const ast = this.f();
    let out = toJSONMemoMap.get(ast);
    if (out) {
      return out;
    }
    toJSONMemoMap.set(ast, {
      _tag: this._tag
    });
    out = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
    toJSONMemoMap.set(ast, out);
    return out;
  }
}
class Refinement {
  from;
  filter;
  annotations;
  _tag = "Refinement";
  constructor(from, filter2, annotations = {}) {
    this.from = from;
    this.filter = filter2;
    this.annotations = annotations;
  }
  toString() {
    return getIdentifierAnnotation(this).pipe(getOrElse(() => match2(getOrElseExpected(this), {
      onNone: () => `{ ${this.from} | filter }`,
      onSome: (expected) => isRefinement(this.from) ? String(this.from) + " & " + expected : expected
    })));
  }
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isRefinement = /* @__PURE__ */ createASTGuard("Refinement");
var defaultParseOption = {};

class Transformation {
  from;
  to;
  transformation;
  annotations;
  _tag = "Transformation";
  constructor(from, to, transformation, annotations = {}) {
    this.from = from;
    this.to = to;
    this.transformation = transformation;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
  }
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isTransformation = /* @__PURE__ */ createASTGuard("Transformation");

class FinalTransformation {
  decode;
  encode;
  _tag = "FinalTransformation";
  constructor(decode, encode) {
    this.decode = decode;
    this.encode = encode;
  }
}
var createTransformationGuard = (tag) => (ast) => ast._tag === tag;
class ComposeTransformation {
  _tag = "ComposeTransformation";
}
var composeTransformation = /* @__PURE__ */ new ComposeTransformation;
class PropertySignatureTransformation {
  from;
  to;
  decode;
  encode;
  constructor(from, to, decode, encode) {
    this.from = from;
    this.to = to;
    this.decode = decode;
    this.encode = encode;
  }
}
class TypeLiteralTransformation {
  propertySignatureTransformations;
  _tag = "TypeLiteralTransformation";
  constructor(propertySignatureTransformations) {
    this.propertySignatureTransformations = propertySignatureTransformations;
    const fromKeys = {};
    const toKeys = {};
    for (const pst of propertySignatureTransformations) {
      const from = pst.from;
      if (fromKeys[from]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(from));
      }
      fromKeys[from] = true;
      const to = pst.to;
      if (toKeys[to]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(to));
      }
      toKeys[to] = true;
    }
  }
}
var isTypeLiteralTransformation = /* @__PURE__ */ createTransformationGuard("TypeLiteralTransformation");
var annotations = (ast, overrides) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  const base = {
    ...ast.annotations
  };
  delete base[IdentifierAnnotationId];
  const value = {
    ...base,
    ...overrides
  };
  const surrogate = getSurrogateAnnotation(ast);
  if (isSome2(surrogate)) {
    value[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
  }
  d.annotations.value = value;
  return Object.create(Object.getPrototypeOf(ast), d);
};
var STRING_KEYWORD_PATTERN = "[\\s\\S]*?";
var NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
var getTemplateLiteralSpanTypePattern = (type, capture) => {
  switch (type._tag) {
    case "Literal":
      return escape(String(type.literal));
    case "StringKeyword":
      return STRING_KEYWORD_PATTERN;
    case "NumberKeyword":
      return NUMBER_KEYWORD_PATTERN;
    case "TemplateLiteral":
      return getTemplateLiteralPattern(type, capture, false);
    case "Union":
      return type.types.map((type2) => getTemplateLiteralSpanTypePattern(type2, capture)).join("|");
  }
};
var handleTemplateLiteralSpanTypeParens = (type, s, capture, top) => {
  if (isUnion(type)) {
    if (capture && !top) {
      return `(?:${s})`;
    }
  } else if (!capture || !top) {
    return s;
  }
  return `(${s})`;
};
var getTemplateLiteralPattern = (ast, capture, top) => {
  let pattern = ``;
  if (ast.head !== "") {
    const head2 = escape(ast.head);
    pattern += capture && top ? `(${head2})` : head2;
  }
  for (const span2 of ast.spans) {
    const spanPattern = getTemplateLiteralSpanTypePattern(span2.type, capture);
    pattern += handleTemplateLiteralSpanTypeParens(span2.type, spanPattern, capture, top);
    if (span2.literal !== "") {
      const literal = escape(span2.literal);
      pattern += capture && top ? `(${literal})` : literal;
    }
  }
  return pattern;
};
var getTemplateLiteralRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`);
var record = (key, value) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go = (key2) => {
    switch (key2._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(new IndexSignature(key2, value, true));
        break;
      case "Literal":
        if (isString(key2.literal) || isNumber(key2.literal)) {
          propertySignatures.push(new PropertySignature(key2.literal, value, false, true));
        } else {
          throw new Error(getASTUnsupportedLiteralErrorMessage(key2.literal));
        }
        break;
      case "Enums": {
        for (const [_, name] of key2.enums) {
          propertySignatures.push(new PropertySignature(name, value, false, true));
        }
        break;
      }
      case "UniqueSymbol":
        propertySignatures.push(new PropertySignature(key2.symbol, value, false, true));
        break;
      case "Union":
        key2.types.forEach(go);
        break;
      default:
        throw new Error(getASTUnsupportedKeySchemaErrorMessage(key2));
    }
  };
  go(key);
  return {
    propertySignatures,
    indexSignatures
  };
};
var pickAnnotations = (annotationIds) => (annotated) => {
  let out = undefined;
  for (const id of annotationIds) {
    if (Object.prototype.hasOwnProperty.call(annotated.annotations, id)) {
      if (out === undefined) {
        out = {};
      }
      out[id] = annotated.annotations[id];
    }
  }
  return out;
};
var omitAnnotations = (annotationIds) => (annotated) => {
  const out = {
    ...annotated.annotations
  };
  for (const id of annotationIds) {
    delete out[id];
  }
  return out;
};
var preserveTransformationAnnotations = /* @__PURE__ */ pickAnnotations([ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId]);
var typeAST = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, typeAST);
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type = typeAST(e.type);
        return type === e.type ? e : new OptionalType(type, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, typeAST);
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type) => new Type(type)), ast.isReadonly, ast.annotations);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (p) => {
        const type = typeAST(p.type);
        return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is) => {
        const type = typeAST(is.type);
        return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap(ast.types, typeAST);
      return types === ast.types ? ast : Union.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => typeAST(ast.f()), ast.annotations);
    case "Refinement": {
      const from = typeAST(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const preserve = preserveTransformationAnnotations(ast);
      return typeAST(preserve !== undefined ? annotations(ast.to, preserve) : ast.to);
    }
  }
  return ast;
};
function changeMap(as, f) {
  let changed = false;
  const out = allocate(as.length);
  for (let i = 0;i < as.length; i++) {
    const a = as[i];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as;
}
var getTransformationFrom = (ast) => {
  switch (ast._tag) {
    case "Transformation":
      return ast.from;
    case "Refinement":
      return getTransformationFrom(ast.from);
    case "Suspend":
      return getTransformationFrom(ast.f());
  }
};
var encodedAST_ = (ast, isBound) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, (ast2) => encodedAST_(ast2, isBound));
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type = encodedAST_(e.type, isBound);
        return type === e.type ? e : new OptionalType(type, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, (ast2) => encodedAST_(ast2, isBound));
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast2) => new Type(ast2)), ast.isReadonly);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
        const type = encodedAST_(ps.type, isBound);
        return type === ps.type ? ps : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is) => {
        const type = encodedAST_(is.type, isBound);
        return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures);
    }
    case "Union": {
      const types = changeMap(ast.types, (ast2) => encodedAST_(ast2, isBound));
      return types === ast.types ? ast : Union.make(types);
    }
    case "Suspend": {
      let borrowedAnnotations = undefined;
      const identifier = getJSONIdentifier(ast);
      if (isSome2(identifier)) {
        const suffix = isBound ? "Bound" : "";
        borrowedAnnotations = {
          [JSONIdentifierAnnotationId]: `${identifier.value}Encoded${suffix}`
        };
      }
      return new Suspend(() => encodedAST_(ast.f(), isBound), borrowedAnnotations);
    }
    case "Refinement": {
      const from = encodedAST_(ast.from, isBound);
      if (isBound) {
        if (from === ast.from)
          return ast;
        if (getTransformationFrom(ast.from) === undefined && hasStableFilter(ast)) {
          return new Refinement(from, ast.filter, ast.annotations);
        }
        return from;
      } else {
        return from;
      }
    }
    case "Transformation":
      return encodedAST_(ast.from, isBound);
  }
  return ast;
};
var encodedAST = (ast) => encodedAST_(ast, false);
var toJSONAnnotations = (annotations2) => {
  const out = {};
  for (const k of Object.getOwnPropertySymbols(annotations2)) {
    out[String(k)] = annotations2[k];
  }
  return out;
};
var getEncodedParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getEncodedParameter(ast.from);
  }
};
var formatKeyword = (ast) => getOrElse(getExpected(ast), () => ast._tag);
function getBrands(ast) {
  return match2(getBrandAnnotation(ast), {
    onNone: () => "",
    onSome: (brands) => brands.map((brand) => ` & Brand<${formatUnknown(brand)}>`).join("")
  });
}
var getOrElseExpected = (ast) => getTitleAnnotation(ast).pipe(orElse(() => getDescriptionAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), map2((s) => s + getBrands(ast)));
var getExpected = (ast) => orElse(getIdentifierAnnotation(ast), () => getOrElseExpected(ast));
// node_modules/effect/dist/esm/Boolean.js
var not = (self2) => !self2;
// node_modules/effect/dist/esm/Context.js
var exports_Context = {};
__export(exports_Context, {
  unsafeMake: () => unsafeMake,
  unsafeGet: () => unsafeGet3,
  pick: () => pick2,
  omit: () => omit2,
  mergeAll: () => mergeAll2,
  merge: () => merge3,
  make: () => make5,
  isTag: () => isTag2,
  isReference: () => isReference2,
  isContext: () => isContext2,
  getOrElse: () => getOrElse3,
  getOption: () => getOption2,
  get: () => get3,
  empty: () => empty3,
  add: () => add2,
  TagTypeId: () => TagTypeId2,
  Tag: () => Tag2,
  ReferenceTypeId: () => ReferenceTypeId2,
  Reference: () => Reference2,
  GenericTag: () => GenericTag
});

// node_modules/effect/dist/esm/internal/context.js
var TagTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
var ReferenceTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
var STMSymbolKey = "effect/STM";
var STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
var TagProto = {
  ...EffectPrototype,
  _op: "Tag",
  [STMTypeId]: effectVariance,
  [TagTypeId]: {
    _Service: (_) => _,
    _Identifier: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self2) {
    return self2;
  },
  context(self2) {
    return make4(this, self2);
  }
};
var ReferenceProto = {
  ...TagProto,
  [ReferenceTypeId]: ReferenceTypeId
};
var makeGenericTag = (key) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  const tag = Object.create(TagProto);
  Object.defineProperty(tag, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag.key = key;
  return tag;
};
var Tag = (id) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  function TagClass() {}
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return TagClass;
};
var Reference = () => (id, options) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  function ReferenceClass() {}
  Object.setPrototypeOf(ReferenceClass, ReferenceProto);
  ReferenceClass.key = id;
  ReferenceClass.defaultValue = options.defaultValue;
  Object.defineProperty(ReferenceClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return ReferenceClass;
};
var TypeId3 = /* @__PURE__ */ Symbol.for("effect/Context");
var ContextProto = {
  [TypeId3]: {
    _Services: (_) => _
  },
  [symbol2](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol]() {
    return cached(this, number2(this.unsafeMap.size));
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var makeContext = (unsafeMap) => {
  const context = Object.create(ContextProto);
  context.unsafeMap = unsafeMap;
  return context;
};
var serviceNotFoundError = (tag) => {
  const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : ""}`);
  if (tag.stack) {
    const lines = tag.stack.split(`
`);
    if (lines.length > 2) {
      const afterAt = lines[2].match(/at (.*)/);
      if (afterAt) {
        error.message = error.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error.stack) {
    const lines = error.stack.split(`
`);
    lines.splice(1, 3);
    error.stack = lines.join(`
`);
  }
  return error;
};
var isContext = (u) => hasProperty(u, TypeId3);
var isTag = (u) => hasProperty(u, TagTypeId);
var isReference = (u) => hasProperty(u, ReferenceTypeId);
var _empty = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map);
var empty2 = () => _empty;
var make4 = (tag, service) => makeContext(new Map([[tag.key, service]]));
var add = /* @__PURE__ */ dual(3, (self2, tag, service) => {
  const map4 = new Map(self2.unsafeMap);
  map4.set(tag.key, service);
  return makeContext(map4);
});
var defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => new Map);
var getDefaultValue = (tag) => {
  if (defaultValueCache.has(tag.key)) {
    return defaultValueCache.get(tag.key);
  }
  const value = tag.defaultValue();
  defaultValueCache.set(tag.key, value);
  return value;
};
var unsafeGetReference = (self2, tag) => {
  return self2.unsafeMap.has(tag.key) ? self2.unsafeMap.get(tag.key) : getDefaultValue(tag);
};
var unsafeGet2 = /* @__PURE__ */ dual(2, (self2, tag) => {
  if (!self2.unsafeMap.has(tag.key)) {
    if (ReferenceTypeId in tag)
      return getDefaultValue(tag);
    throw serviceNotFoundError(tag);
  }
  return self2.unsafeMap.get(tag.key);
});
var get2 = unsafeGet2;
var getOrElse2 = /* @__PURE__ */ dual(3, (self2, tag, orElse2) => {
  if (!self2.unsafeMap.has(tag.key)) {
    return isReference(tag) ? getDefaultValue(tag) : orElse2();
  }
  return self2.unsafeMap.get(tag.key);
});
var getOption = /* @__PURE__ */ dual(2, (self2, tag) => {
  if (!self2.unsafeMap.has(tag.key)) {
    return isReference(tag) ? some(getDefaultValue(tag)) : none;
  }
  return some(self2.unsafeMap.get(tag.key));
});
var merge2 = /* @__PURE__ */ dual(2, (self2, that) => {
  const map4 = new Map(self2.unsafeMap);
  for (const [tag, s] of that.unsafeMap) {
    map4.set(tag, s);
  }
  return makeContext(map4);
});
var mergeAll = (...ctxs) => {
  const map4 = new Map;
  for (let i = 0;i < ctxs.length; i++) {
    ctxs[i].unsafeMap.forEach((value, key) => {
      map4.set(key, value);
    });
  }
  return makeContext(map4);
};
var pick = (...tags) => (self2) => {
  const tagSet = new Set(tags.map((_) => _.key));
  const newEnv = new Map;
  for (const [tag, s] of self2.unsafeMap.entries()) {
    if (tagSet.has(tag)) {
      newEnv.set(tag, s);
    }
  }
  return makeContext(newEnv);
};
var omit = (...tags) => (self2) => {
  const newEnv = new Map(self2.unsafeMap);
  for (const tag of tags) {
    newEnv.delete(tag.key);
  }
  return makeContext(newEnv);
};

// node_modules/effect/dist/esm/Context.js
var TagTypeId2 = TagTypeId;
var ReferenceTypeId2 = ReferenceTypeId;
var GenericTag = makeGenericTag;
var unsafeMake = makeContext;
var isContext2 = isContext;
var isTag2 = isTag;
var isReference2 = isReference;
var empty3 = empty2;
var make5 = make4;
var add2 = add;
var get3 = get2;
var getOrElse3 = getOrElse2;
var unsafeGet3 = unsafeGet2;
var getOption2 = getOption;
var merge3 = merge2;
var mergeAll2 = mergeAll;
var pick2 = pick;
var omit2 = omit;
var Tag2 = Tag;
var Reference2 = Reference;

// node_modules/effect/dist/esm/Chunk.js
var TypeId4 = /* @__PURE__ */ Symbol.for("effect/Chunk");
function copy2(src, srcPos, dest, destPos, len) {
  for (let i = srcPos;i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
var emptyArray = [];
var getEquivalence2 = (isEquivalent) => make((self2, that) => self2.length === that.length && toReadonlyArray(self2).every((value, i) => isEquivalent(value, unsafeGet4(that, i))));
var _equivalence3 = /* @__PURE__ */ getEquivalence2(equals);
var ChunkProto = {
  [TypeId4]: {
    _A: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isChunk(that) && _equivalence3(this, that);
  },
  [symbol]() {
    return cached(this, array2(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeChunk = (backing) => {
  const chunk = Object.create(ChunkProto);
  chunk.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk.length = 0;
      chunk.depth = 0;
      chunk.left = chunk;
      chunk.right = chunk;
      break;
    }
    case "IConcat": {
      chunk.length = backing.left.length + backing.right.length;
      chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk.left = backing.left;
      chunk.right = backing.right;
      break;
    }
    case "IArray": {
      chunk.length = backing.array.length;
      chunk.depth = 0;
      chunk.left = _empty2;
      chunk.right = _empty2;
      break;
    }
    case "ISingleton": {
      chunk.length = 1;
      chunk.depth = 0;
      chunk.left = _empty2;
      chunk.right = _empty2;
      break;
    }
    case "ISlice": {
      chunk.length = backing.length;
      chunk.depth = backing.chunk.depth + 1;
      chunk.left = _empty2;
      chunk.right = _empty2;
      break;
    }
  }
  return chunk;
};
var isChunk = (u) => hasProperty(u, TypeId4);
var _empty2 = /* @__PURE__ */ makeChunk({
  _tag: "IEmpty"
});
var empty4 = () => _empty2;
var make6 = (...as) => unsafeFromNonEmptyArray(as);
var of2 = (a) => makeChunk({
  _tag: "ISingleton",
  a
});
var fromIterable2 = (self2) => isChunk(self2) ? self2 : unsafeFromArray(fromIterable(self2));
var copyToArray = (self2, array3, initial) => {
  switch (self2.backing._tag) {
    case "IArray": {
      copy2(self2.backing.array, 0, array3, initial, self2.length);
      break;
    }
    case "IConcat": {
      copyToArray(self2.left, array3, initial);
      copyToArray(self2.right, array3, initial + self2.left.length);
      break;
    }
    case "ISingleton": {
      array3[initial] = self2.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j = initial;
      while (i < self2.length) {
        array3[j] = unsafeGet4(self2, i);
        i += 1;
        j += 1;
      }
      break;
    }
  }
};
var toReadonlyArray_ = (self2) => {
  switch (self2.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self2.backing.array;
    }
    default: {
      const arr = new Array(self2.length);
      copyToArray(self2, arr, 0);
      self2.backing = {
        _tag: "IArray",
        array: arr
      };
      self2.left = _empty2;
      self2.right = _empty2;
      self2.depth = 0;
      return arr;
    }
  }
};
var toReadonlyArray = toReadonlyArray_;
var reverseChunk = (self2) => {
  switch (self2.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self2;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse(self2.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse2(self2.backing.right),
        right: reverse2(self2.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse(toReadonlyArray(self2)));
  }
};
var reverse2 = reverseChunk;
var get4 = /* @__PURE__ */ dual(2, (self2, index) => index < 0 || index >= self2.length ? none2() : some2(unsafeGet4(self2, index)));
var unsafeFromArray = (self2) => self2.length === 0 ? empty4() : self2.length === 1 ? of2(self2[0]) : makeChunk({
  _tag: "IArray",
  array: self2
});
var unsafeFromNonEmptyArray = (self2) => unsafeFromArray(self2);
var unsafeGet4 = /* @__PURE__ */ dual(2, (self2, index) => {
  switch (self2.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self2.backing.a;
    }
    case "IArray": {
      if (index >= self2.length || index < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self2.backing.array[index];
    }
    case "IConcat": {
      return index < self2.left.length ? unsafeGet4(self2.left, index) : unsafeGet4(self2.right, index - self2.left.length);
    }
    case "ISlice": {
      return unsafeGet4(self2.backing.chunk, index + self2.backing.offset);
    }
  }
});
var append2 = /* @__PURE__ */ dual(2, (self2, a) => appendAll2(self2, of2(a)));
var prepend2 = /* @__PURE__ */ dual(2, (self2, elem) => appendAll2(of2(elem), self2));
var take = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return _empty2;
  } else if (n >= self2.length) {
    return self2;
  } else {
    switch (self2.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2.backing.chunk,
          length: n,
          offset: self2.backing.offset
        });
      }
      case "IConcat": {
        if (n > self2.left.length) {
          return makeChunk({
            _tag: "IConcat",
            left: self2.left,
            right: take(self2.right, n - self2.left.length)
          });
        }
        return take(self2.left, n);
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2,
          offset: 0,
          length: n
        });
      }
    }
  }
});
var drop2 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return self2;
  } else if (n >= self2.length) {
    return _empty2;
  } else {
    switch (self2.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2.backing.chunk,
          offset: self2.backing.offset + n,
          length: self2.backing.length - n
        });
      }
      case "IConcat": {
        if (n > self2.left.length) {
          return drop2(self2.right, n - self2.left.length);
        }
        return makeChunk({
          _tag: "IConcat",
          left: drop2(self2.left, n),
          right: self2.right
        });
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2,
          offset: n,
          length: self2.length - n
        });
      }
    }
  }
});
var dropWhile = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const arr = toReadonlyArray(self2);
  const len = arr.length;
  let i = 0;
  while (i < len && predicate(arr[i])) {
    i++;
  }
  return drop2(self2, i);
});
var appendAll2 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self2;
  }
  const diff = that.depth - self2.depth;
  if (Math.abs(diff) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self2,
      right: that
    });
  } else if (diff < -1) {
    if (self2.left.depth >= self2.right.depth) {
      const nr = appendAll2(self2.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self2.left,
        right: nr
      });
    } else {
      const nrr = appendAll2(self2.right.right, that);
      if (nrr.depth === self2.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self2.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self2.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self2.left,
          right: self2.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll2(self2, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll2(self2, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var filterMap2 = /* @__PURE__ */ dual(2, (self2, f) => unsafeFromArray(filterMap(self2, f)));
var filter2 = /* @__PURE__ */ dual(2, (self2, predicate) => unsafeFromArray(filter(self2, predicate)));
var filterMapWhile2 = /* @__PURE__ */ dual(2, (self2, f) => unsafeFromArray(filterMapWhile(self2, f)));
var flatMap3 = /* @__PURE__ */ dual(2, (self2, f) => {
  if (self2.backing._tag === "ISingleton") {
    return f(self2.backing.a, 0);
  }
  let out = _empty2;
  let i = 0;
  for (const k of self2) {
    out = appendAll2(out, f(k, i++));
  }
  return out;
});
var flatten3 = /* @__PURE__ */ flatMap3(identity);
var isEmpty = (self2) => self2.length === 0;
var isNonEmpty2 = (self2) => self2.length > 0;
var head2 = /* @__PURE__ */ get4(0);
var unsafeHead = (self2) => unsafeGet4(self2, 0);
var headNonEmpty2 = unsafeHead;
var last2 = (self2) => get4(self2, self2.length - 1);
var unsafeLast = (self2) => unsafeGet4(self2, self2.length - 1);
var map4 = /* @__PURE__ */ dual(2, (self2, f) => self2.backing._tag === "ISingleton" ? of2(f(self2.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self2), map3((a, i) => f(a, i)))));
var mapAccum2 = /* @__PURE__ */ dual(3, (self2, s, f) => {
  const [s1, as] = mapAccum(self2, s, f);
  return [s1, unsafeFromArray(as)];
});
var splitAt2 = /* @__PURE__ */ dual(2, (self2, n) => [take(self2, n), drop2(self2, n)]);
var splitWhere = /* @__PURE__ */ dual(2, (self2, predicate) => {
  let i = 0;
  for (const a of toReadonlyArray(self2)) {
    if (predicate(a)) {
      break;
    } else {
      i++;
    }
  }
  return splitAt2(self2, i);
});
var tailNonEmpty2 = (self2) => drop2(self2, 1);
var takeRight = /* @__PURE__ */ dual(2, (self2, n) => drop2(self2, self2.length - n));
var takeWhile = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const out = [];
  for (const a of toReadonlyArray(self2)) {
    if (predicate(a)) {
      out.push(a);
    } else {
      break;
    }
  }
  return unsafeFromArray(out);
});
var zipWith2 = /* @__PURE__ */ dual(3, (self2, that, f) => unsafeFromArray(zipWith(self2, that, f)));
var makeBy2 = /* @__PURE__ */ dual(2, (n, f) => fromIterable2(makeBy(n, f)));
var range = (start, end) => start <= end ? makeBy2(end - start + 1, (i) => start + i) : of2(start);
var findFirst3 = findFirst2;
var reduce2 = reduce;
var reduceRight2 = reduceRight;

// node_modules/effect/dist/esm/Duration.js
var TypeId5 = /* @__PURE__ */ Symbol.for("effect/Duration");
var bigint0 = /* @__PURE__ */ BigInt(0);
var bigint24 = /* @__PURE__ */ BigInt(24);
var bigint60 = /* @__PURE__ */ BigInt(60);
var bigint1e3 = /* @__PURE__ */ BigInt(1000);
var bigint1e6 = /* @__PURE__ */ BigInt(1e6);
var bigint1e9 = /* @__PURE__ */ BigInt(1e9);
var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
var decode = (input) => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return millis(input);
  } else if (isBigInt(input)) {
    return nanos(input);
  } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
      return zero;
    }
    if (input[0] === Infinity || input[1] === Infinity) {
      return infinity;
    }
    return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
  } else if (isString(input)) {
    const match4 = DURATION_REGEX.exec(input);
    if (match4) {
      const [_, valueStr, unit] = match4;
      const value = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value);
        case "second":
        case "seconds":
          return seconds(value);
        case "minute":
        case "minutes":
          return minutes(value);
        case "hour":
        case "hours":
          return hours(value);
        case "day":
        case "days":
          return days(value);
        case "week":
        case "weeks":
          return weeks(value);
      }
    }
  }
  throw new Error("Invalid DurationInput");
};
var zeroValue = {
  _tag: "Millis",
  millis: 0
};
var infinityValue = {
  _tag: "Infinity"
};
var DurationProto = {
  [TypeId5]: TypeId5,
  [symbol]() {
    return cached(this, structure(this.value));
  },
  [symbol2](that) {
    return isDuration(that) && equals2(this, that);
  },
  toString() {
    return `Duration(${format2(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make7 = (input) => {
  const duration = Object.create(DurationProto);
  if (isNumber(input)) {
    if (isNaN(input) || input <= 0) {
      duration.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1e6))
      };
    } else {
      duration.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint0) {
    duration.value = zeroValue;
  } else {
    duration.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration;
};
var isDuration = (u) => hasProperty(u, TypeId5);
var isFinite = (self2) => self2.value._tag !== "Infinity";
var isZero = (self2) => {
  switch (self2.value._tag) {
    case "Millis": {
      return self2.value.millis === 0;
    }
    case "Nanos": {
      return self2.value.nanos === bigint0;
    }
    case "Infinity": {
      return false;
    }
  }
};
var zero = /* @__PURE__ */ make7(0);
var infinity = /* @__PURE__ */ make7(Infinity);
var nanos = (nanos2) => make7(nanos2);
var micros = (micros2) => make7(micros2 * bigint1e3);
var millis = (millis2) => make7(millis2);
var seconds = (seconds2) => make7(seconds2 * 1000);
var minutes = (minutes2) => make7(minutes2 * 60000);
var hours = (hours2) => make7(hours2 * 3600000);
var days = (days2) => make7(days2 * 86400000);
var weeks = (weeks2) => make7(weeks2 * 604800000);
var toMillis = (self2) => match4(self2, {
  onMillis: (millis2) => millis2,
  onNanos: (nanos2) => Number(nanos2) / 1e6
});
var unsafeToNanos = (self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1e6));
  }
};
var toHrTime = (self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1000), Math.round(_self.value.millis % 1000 * 1e6)];
  }
};
var match4 = /* @__PURE__ */ dual(2, (self2, options) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Nanos":
      return options.onNanos(_self.value.nanos);
    case "Infinity":
      return options.onMillis(Infinity);
    case "Millis":
      return options.onMillis(_self.value.millis);
  }
});
var matchWith = /* @__PURE__ */ dual(3, (self2, that, options) => {
  const _self = decode(self2);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
var Equivalence = (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 === that2,
  onNanos: (self3, that2) => self3 === that2
});
var sum = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => make7(self3 + that2),
  onNanos: (self3, that2) => make7(self3 + that2)
}));
var lessThanOrEqualTo2 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 <= that2,
  onNanos: (self3, that2) => self3 <= that2
}));
var greaterThan2 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 > that2,
  onNanos: (self3, that2) => self3 > that2
}));
var greaterThanOrEqualTo2 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 >= that2,
  onNanos: (self3, that2) => self3 >= that2
}));
var equals2 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence(decode(self2), decode(that)));
var parts = (self2) => {
  const duration = decode(self2);
  if (duration.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos2 = unsafeToNanos(duration);
  const ms = nanos2 / bigint1e6;
  const sec = ms / bigint1e3;
  const min2 = sec / bigint60;
  const hr = min2 / bigint60;
  const days2 = hr / bigint24;
  return {
    days: Number(days2),
    hours: Number(hr % bigint24),
    minutes: Number(min2 % bigint60),
    seconds: Number(sec % bigint60),
    millis: Number(ms % bigint1e3),
    nanos: Number(nanos2 % bigint1e6)
  };
};
var format2 = (self2) => {
  const duration = decode(self2);
  if (duration.value._tag === "Infinity") {
    return "Infinity";
  }
  if (isZero(duration)) {
    return "0";
  }
  const fragments = parts(duration);
  const pieces = [];
  if (fragments.days !== 0) {
    pieces.push(`${fragments.days}d`);
  }
  if (fragments.hours !== 0) {
    pieces.push(`${fragments.hours}h`);
  }
  if (fragments.minutes !== 0) {
    pieces.push(`${fragments.minutes}m`);
  }
  if (fragments.seconds !== 0) {
    pieces.push(`${fragments.seconds}s`);
  }
  if (fragments.millis !== 0) {
    pieces.push(`${fragments.millis}ms`);
  }
  if (fragments.nanos !== 0) {
    pieces.push(`${fragments.nanos}ns`);
  }
  return pieces.join(" ");
};

// node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE = 5;
var BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
var MASK = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function hashFragment(shift, h) {
  return h >>> shift & MASK;
}
function toBitmap(x) {
  return 1 << x;
}
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}

// node_modules/effect/dist/esm/internal/stack.js
var make8 = (value, previous) => ({
  value,
  previous
});

// node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate(mutate, at, v, arr) {
  let out = arr;
  if (!mutate) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0;i < len; ++i)
      out[i] = arr[i];
  }
  out[at] = v;
  return out;
}
function arraySpliceOut(mutate, at, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate) {
    i = g = at;
  } else {
    out = new Array(newLen);
    while (i < at)
      out[g++] = arr[i++];
  }
  ++i;
  while (i <= newLen)
    out[g++] = arr[i++];
  if (mutate) {
    out.length = newLen;
  }
  return out;
}
function arraySpliceIn(mutate, at, v, arr) {
  const len = arr.length;
  if (mutate) {
    let i2 = len;
    while (i2 >= at)
      arr[i2--] = arr[i2];
    arr[at] = v;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at)
    out[g++] = arr[i++];
  out[at] = v;
  while (i < len)
    out[++g] = arr[i++];
  return out;
}

// node_modules/effect/dist/esm/internal/hashMap/node.js
class EmptyNode {
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash2, key, size) {
    const v = f(none2());
    if (isNone2(v))
      return new EmptyNode;
    ++size.value;
    return new LeafNode(edit, hash2, key, v);
  }
}
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}

class LeafNode {
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash2, key, value) {
    this.edit = edit;
    this.hash = hash2;
    this.key = key;
    this.value = value;
  }
  modify(edit, shift, f, hash2, key, size) {
    if (equals(key, this.key)) {
      const v2 = f(this.value);
      if (v2 === this.value)
        return this;
      else if (isNone2(v2)) {
        --size.value;
        return new EmptyNode;
      }
      if (canEditNode(this, edit)) {
        this.value = v2;
        return this;
      }
      return new LeafNode(edit, hash2, key, v2);
    }
    const v = f(none2());
    if (isNone2(v))
      return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
  }
}

class CollisionNode {
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash2, children) {
    this.edit = edit;
    this.hash = hash2;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size) {
    if (hash2 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size);
      if (list === this.children)
        return this;
      return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0];
    }
    const v = f(none2());
    if (isNone2(v))
      return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
  }
  updateCollisionList(mutate, edit, hash2, list, f, key, size) {
    const len = list.length;
    for (let i = 0;i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals(key, child.key)) {
        const value = child.value;
        const newValue2 = f(value);
        if (newValue2 === value)
          return list;
        if (isNone2(newValue2)) {
          --size.value;
          return arraySpliceOut(mutate, i, list);
        }
        return arrayUpdate(mutate, i, new LeafNode(edit, hash2, key, newValue2), list);
      }
    }
    const newValue = f(none2());
    if (isNone2(newValue))
      return list;
    ++size.value;
    return arrayUpdate(mutate, len, new LeafNode(edit, hash2, key, newValue), list);
  }
}

class IndexedNode {
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children) {
    this.edit = edit;
    this.mask = mask;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size) {
    const mask = this.mask;
    const children = this.children;
    const frag = hashFragment(shift, hash2);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists2 = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists2) {
      const _newChild = new EmptyNode().modify(edit, shift + SIZE, f, hash2, key, size);
      if (!_newChild)
        return this;
      return children.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children) : new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children));
    }
    const current = children[indx];
    const child = current.modify(edit, shift + SIZE, f, hash2, key, size);
    if (current === child)
      return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap)
        return new EmptyNode;
      if (children.length <= 2 && isLeafNode(children[indx ^ 1])) {
        return children[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new IndexedNode(edit, bitmap, newChildren);
  }
}

class ArrayNode {
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size, children) {
    this.edit = edit;
    this.size = size;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size) {
    let count = this.size;
    const children = this.children;
    const frag = hashFragment(shift, hash2);
    const child = children[frag];
    const newChild = (child || new EmptyNode).modify(edit, shift + SIZE, f, hash2, key, size);
    if (child === newChild)
      return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count;
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count;
      if (count <= MIN_ARRAY_NODE) {
        return pack(edit, count, frag, children);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode, children);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    }
    if (canEdit) {
      this.size = count;
      this.children = newChildren;
      return this;
    }
    return new ArrayNode(edit, count, newChildren);
  }
}
function pack(edit, count, removed, elements) {
  const children = new Array(count - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length;i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count = 0;
  for (let i = 0;bit; ++i) {
    if (bit & 1)
      arr[i] = subNodes[count++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count + 1, arr);
}
function mergeLeavesInner(edit, shift, h1, n1, h2, n2) {
  if (h1 === h2)
    return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift, h1);
  const subH2 = hashFragment(shift, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children);
  }
}
function mergeLeaves(edit, shift, h1, n1, h2, n2) {
  let stack = undefined;
  let currentShift = shift;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = make8(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}

// node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap";
var HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
var HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v) => [k, v]);
  },
  [symbol]() {
    let hash2 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash2);
  },
  [symbol2](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone2(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl = (editable, edit, root, size) => {
  const map5 = Object.create(HashMapProto);
  map5._editable = editable;
  map5._edit = edit;
  map5._root = root;
  map5._size = size;
  return map5;
};

class HashMapIterator {
  map;
  f;
  v;
  constructor(map5, f) {
    this.map = map5;
    this.f = f;
    this.v = visitLazy(this.map._root, this.f, undefined);
  }
  next() {
    if (isNone2(this.v)) {
      return {
        done: true,
        value: undefined
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new HashMapIterator(this.map, this.f);
  }
}
var applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2();
var visitLazy = (node, f, cont = undefined) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome2(node.value)) {
        return some2({
          value: f(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children = node.children;
      return visitLazyChildren(children.length, children, 0, f, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
};
var visitLazyChildren = (len, children, i, f, cont) => {
  while (i < len) {
    const child = children[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f, [len, children, i, f, cont]);
    }
  }
  return applyCont(cont);
};
var _empty3 = /* @__PURE__ */ makeImpl(false, 0, /* @__PURE__ */ new EmptyNode, 0);
var empty5 = () => _empty3;
var fromIterable3 = (entries) => {
  const map5 = beginMutation(empty5());
  for (const entry of entries) {
    set(map5, entry[0], entry[1]);
  }
  return endMutation(map5);
};
var isHashMap = (u) => hasProperty(u, HashMapTypeId);
var isEmpty2 = (self2) => self2 && isEmptyNode(self2._root);
var get5 = /* @__PURE__ */ dual(2, (self2, key) => getHash(self2, key, hash(key)));
var getHash = /* @__PURE__ */ dual(3, (self2, key, hash2) => {
  let node = self2._root;
  let shift = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none2();
      }
      case "CollisionNode": {
        if (hash2 === node.hash) {
          const children = node.children;
          for (let i = 0, len = children.length;i < len; ++i) {
            const child = children[i];
            if ("key" in child && equals(key, child.key)) {
              return child.value;
            }
          }
        }
        return none2();
      }
      case "IndexedNode": {
        const frag = hashFragment(shift, hash2);
        const bit = toBitmap(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap(node.mask, bit)];
          shift += SIZE;
          break;
        }
        return none2();
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift, hash2)];
        if (node) {
          shift += SIZE;
          break;
        }
        return none2();
      }
      default:
        return none2();
    }
  }
});
var has = /* @__PURE__ */ dual(2, (self2, key) => isSome2(getHash(self2, key, hash(key))));
var set = /* @__PURE__ */ dual(3, (self2, key, value) => modifyAt(self2, key, () => some2(value)));
var setTree = /* @__PURE__ */ dual(3, (self2, newRoot, newSize) => {
  if (self2._editable) {
    self2._root = newRoot;
    self2._size = newSize;
    return self2;
  }
  return newRoot === self2._root ? self2 : makeImpl(self2._editable, self2._edit, newRoot, newSize);
});
var keys = (self2) => new HashMapIterator(self2, (key) => key);
var size = (self2) => self2._size;
var beginMutation = (self2) => makeImpl(true, self2._edit + 1, self2._root, self2._size);
var endMutation = (self2) => {
  self2._editable = false;
  return self2;
};
var mutate = /* @__PURE__ */ dual(2, (self2, f) => {
  const transient = beginMutation(self2);
  f(transient);
  return endMutation(transient);
});
var modifyAt = /* @__PURE__ */ dual(3, (self2, key, f) => modifyHash(self2, key, hash(key), f));
var modifyHash = /* @__PURE__ */ dual(4, (self2, key, hash2, f) => {
  const size2 = {
    value: self2._size
  };
  const newRoot = self2._root.modify(self2._editable ? self2._edit : NaN, 0, f, hash2, key, size2);
  return pipe(self2, setTree(newRoot, size2.value));
});
var remove2 = /* @__PURE__ */ dual(2, (self2, key) => modifyAt(self2, key, none2));
var map5 = /* @__PURE__ */ dual(2, (self2, f) => reduce3(self2, empty5(), (map6, value, key) => set(map6, key, f(value, key))));
var forEach = /* @__PURE__ */ dual(2, (self2, f) => reduce3(self2, undefined, (_, value, key) => f(value, key)));
var reduce3 = /* @__PURE__ */ dual(3, (self2, zero2, f) => {
  const root = self2._root;
  if (root._tag === "LeafNode") {
    return isSome2(root.value) ? f(zero2, root.value.value, root.key) : zero2;
  }
  if (root._tag === "EmptyNode") {
    return zero2;
  }
  const toVisit = [root.children];
  let children;
  while (children = toVisit.pop()) {
    for (let i = 0, len = children.length;i < len; ) {
      const child = children[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome2(child.value)) {
            zero2 = f(zero2, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero2;
});

// node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet";
var HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
var HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys(this._keyMap);
  },
  [symbol]() {
    return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol2](that) {
    if (isHashSet(that)) {
      return size(this._keyMap) === size(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = (keyMap) => {
  const set2 = Object.create(HashSetProto);
  set2._keyMap = keyMap;
  return set2;
};
var isHashSet = (u) => hasProperty(u, HashSetTypeId);
var _empty4 = /* @__PURE__ */ makeImpl2(/* @__PURE__ */ empty5());
var empty6 = () => _empty4;
var fromIterable4 = (elements) => {
  const set2 = beginMutation2(empty6());
  for (const value of elements) {
    add3(set2, value);
  }
  return endMutation2(set2);
};
var make9 = (...elements) => {
  const set2 = beginMutation2(empty6());
  for (const value of elements) {
    add3(set2, value);
  }
  return endMutation2(set2);
};
var has2 = /* @__PURE__ */ dual(2, (self2, value) => has(self2._keyMap, value));
var size2 = (self2) => size(self2._keyMap);
var beginMutation2 = (self2) => makeImpl2(beginMutation(self2._keyMap));
var endMutation2 = (self2) => {
  self2._keyMap._editable = false;
  return self2;
};
var mutate2 = /* @__PURE__ */ dual(2, (self2, f) => {
  const transient = beginMutation2(self2);
  f(transient);
  return endMutation2(transient);
});
var add3 = /* @__PURE__ */ dual(2, (self2, value) => self2._keyMap._editable ? (set(value, true)(self2._keyMap), self2) : makeImpl2(set(value, true)(self2._keyMap)));
var remove3 = /* @__PURE__ */ dual(2, (self2, value) => self2._keyMap._editable ? (remove2(value)(self2._keyMap), self2) : makeImpl2(remove2(value)(self2._keyMap)));
var difference2 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(self2, (set2) => {
  for (const value of that) {
    remove3(set2, value);
  }
}));
var union2 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(empty6(), (set2) => {
  forEach2(self2, (value) => add3(set2, value));
  for (const value of that) {
    add3(set2, value);
  }
}));
var forEach2 = /* @__PURE__ */ dual(2, (self2, f) => forEach(self2._keyMap, (_, k) => f(k)));
var reduce4 = /* @__PURE__ */ dual(3, (self2, zero2, f) => reduce3(self2._keyMap, zero2, (z, _, a) => f(z, a)));

// node_modules/effect/dist/esm/HashSet.js
var empty7 = empty6;
var fromIterable5 = fromIterable4;
var make10 = make9;
var has3 = has2;
var size3 = size2;
var add4 = add3;
var remove4 = remove3;
var difference3 = difference2;
var union3 = union2;
var forEach3 = forEach2;
var reduce5 = reduce4;

// node_modules/effect/dist/esm/MutableRef.js
var TypeId6 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
var MutableRefProto = {
  [TypeId6]: TypeId6,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON(this.current)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make11 = (value) => {
  const ref = Object.create(MutableRefProto);
  ref.current = value;
  return ref;
};
var compareAndSet = /* @__PURE__ */ dual(3, (self2, oldValue, newValue) => {
  if (equals(oldValue, self2.current)) {
    self2.current = newValue;
    return true;
  }
  return false;
});
var get6 = (self2) => self2.current;
var set2 = /* @__PURE__ */ dual(2, (self2, value) => {
  self2.current = value;
  return self2;
});

// node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey = "effect/FiberId";
var FiberIdTypeId = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
var OP_NONE = "None";
var OP_RUNTIME = "Runtime";
var OP_COMPOSITE = "Composite";
var emptyHash = /* @__PURE__ */ string(`${FiberIdSymbolKey}-${OP_NONE}`);

class None {
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_NONE;
  id = -1;
  startTimeMillis = -1;
  [symbol]() {
    return emptyHash;
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_NONE;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}

class Runtime {
  id;
  startTimeMillis;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_RUNTIME;
  constructor(id, startTimeMillis) {
    this.id = id;
    this.startTimeMillis = startTimeMillis;
  }
  [symbol]() {
    return cached(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}

class Composite {
  left;
  right;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_COMPOSITE;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  _hash;
  [symbol]() {
    return pipe(string(`${FiberIdSymbolKey}-${this._tag}`), combine(hash(this.left)), combine(hash(this.right)), cached(this));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON(this.left),
      right: toJSON(this.right)
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}
var none3 = /* @__PURE__ */ new None;
var isFiberId = (self2) => hasProperty(self2, FiberIdTypeId);
var combine2 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2._tag === OP_NONE) {
    return that;
  }
  if (that._tag === OP_NONE) {
    return self2;
  }
  return new Composite(self2, that);
});
var combineAll = (fiberIds) => {
  return pipe(fiberIds, reduce5(none3, (a, b) => combine2(b)(a)));
};
var ids = (self2) => {
  switch (self2._tag) {
    case OP_NONE: {
      return empty7();
    }
    case OP_RUNTIME: {
      return make10(self2.id);
    }
    case OP_COMPOSITE: {
      return pipe(ids(self2.left), union3(ids(self2.right)));
    }
  }
};
var _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make11(0));
var threadName = (self2) => {
  const identifiers = Array.from(ids(self2)).map((n) => `#${n}`).join(",");
  return identifiers;
};
var unsafeMake2 = () => {
  const id = get6(_fiberCounter);
  pipe(_fiberCounter, set2(id + 1));
  return new Runtime(id, Date.now());
};

// node_modules/effect/dist/esm/FiberId.js
var none4 = none3;
var combine3 = combine2;
var combineAll2 = combineAll;
var ids2 = ids;
var threadName2 = threadName;
var unsafeMake3 = unsafeMake2;

// node_modules/effect/dist/esm/HashMap.js
var empty8 = empty5;
var fromIterable6 = fromIterable3;
var isEmpty3 = isEmpty2;
var get7 = get5;
var set3 = set;
var keys2 = keys;
var mutate3 = mutate;
var modifyAt2 = modifyAt;
var map7 = map5;
var forEach4 = forEach;
var reduce6 = reduce3;

// node_modules/effect/dist/esm/List.js
var TypeId7 = /* @__PURE__ */ Symbol.for("effect/List");
var toArray2 = (self2) => fromIterable(self2);
var getEquivalence3 = (isEquivalent) => mapInput(getEquivalence(isEquivalent), toArray2);
var _equivalence4 = /* @__PURE__ */ getEquivalence3(equals);
var ConsProto = {
  [TypeId7]: TypeId7,
  _tag: "Cons",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: toArray2(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag && _equivalence4(this, that);
  },
  [symbol]() {
    return cached(this, array2(toArray2(this)));
  },
  [Symbol.iterator]() {
    let done = false;
    let self2 = this;
    return {
      next() {
        if (done) {
          return this.return();
        }
        if (self2._tag === "Nil") {
          done = true;
          return this.return();
        }
        const value = self2.head;
        self2 = self2.tail;
        return {
          done,
          value
        };
      },
      return(value) {
        if (!done) {
          done = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeCons = (head3, tail) => {
  const cons = Object.create(ConsProto);
  cons.head = head3;
  cons.tail = tail;
  return cons;
};
var NilHash = /* @__PURE__ */ string("Nil");
var NilProto = {
  [TypeId7]: TypeId7,
  _tag: "Nil",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol]() {
    return NilHash;
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: undefined
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _Nil = /* @__PURE__ */ Object.create(NilProto);
var isList = (u) => hasProperty(u, TypeId7);
var isNil = (self2) => self2._tag === "Nil";
var isCons = (self2) => self2._tag === "Cons";
var nil = () => _Nil;
var cons = (head3, tail) => makeCons(head3, tail);
var empty9 = nil;
var of3 = (value) => makeCons(value, _Nil);
var appendAll3 = /* @__PURE__ */ dual(2, (self2, that) => prependAll(that, self2));
var prepend3 = /* @__PURE__ */ dual(2, (self2, element) => cons(element, self2));
var prependAll = /* @__PURE__ */ dual(2, (self2, prefix) => {
  if (isNil(self2)) {
    return prefix;
  } else if (isNil(prefix)) {
    return self2;
  } else {
    const result = makeCons(prefix.head, self2);
    let curr = result;
    let that = prefix.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self2);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
var reduce7 = /* @__PURE__ */ dual(3, (self2, zero2, f) => {
  let acc = zero2;
  let these = self2;
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reverse3 = (self2) => {
  let result = empty9();
  let these = self2;
  while (!isNil(these)) {
    result = prepend3(result, these.head);
    these = these.tail;
  }
  return result;
};

// node_modules/effect/dist/esm/internal/data.js
var ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
  [symbol]() {
    return cached(this, array2(this));
  },
  [symbol2](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v, i) => equals(v, that[i]));
    } else {
      return false;
    }
  }
});
var Structural = /* @__PURE__ */ function() {
  function Structural2(args) {
    if (args) {
      Object.assign(this, args);
    }
  }
  Structural2.prototype = StructuralPrototype;
  return Structural2;
}();
var struct = (as) => Object.assign(Object.create(StructuralPrototype), as);

// node_modules/effect/dist/esm/internal/differ/contextPatch.js
var ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
function variance(a) {
  return a;
}
var PatchProto = {
  ...Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: variance,
    _Patch: variance
  }
};
var EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "Empty"
});
var _empty5 = /* @__PURE__ */ Object.create(EmptyProto);
var empty10 = () => _empty5;
var AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "AndThen"
});
var makeAndThen = (first, second) => {
  const o = Object.create(AndThenProto);
  o.first = first;
  o.second = second;
  return o;
};
var AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "AddService"
});
var makeAddService = (key, service) => {
  const o = Object.create(AddServiceProto);
  o.key = key;
  o.service = service;
  return o;
};
var RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "RemoveService"
});
var makeRemoveService = (key) => {
  const o = Object.create(RemoveServiceProto);
  o.key = key;
  return o;
};
var UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "UpdateService"
});
var makeUpdateService = (key, update) => {
  const o = Object.create(UpdateServiceProto);
  o.key = key;
  o.update = update;
  return o;
};
var diff = (oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch = empty10();
  for (const [tag, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag)) {
      const old = missingServices.get(tag);
      missingServices.delete(tag);
      if (!equals(old, newService)) {
        patch = combine4(makeUpdateService(tag, () => newService))(patch);
      }
    } else {
      missingServices.delete(tag);
      patch = combine4(makeAddService(tag, newService))(patch);
    }
  }
  for (const [tag] of missingServices.entries()) {
    patch = combine4(makeRemoveService(tag))(patch);
  }
  return patch;
};
var combine4 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen(self2, that));
var patch = /* @__PURE__ */ dual(2, (self2, context) => {
  if (self2._tag === "Empty") {
    return context;
  }
  let wasServiceUpdated = false;
  let patches = of2(self2);
  const updatedContext = new Map(context.unsafeMap);
  while (isNonEmpty2(patches)) {
    const head3 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head3._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AddService": {
        updatedContext.set(head3.key, head3.service);
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend2(prepend2(tail, head3.second), head3.first);
        break;
      }
      case "RemoveService": {
        updatedContext.delete(head3.key);
        patches = tail;
        break;
      }
      case "UpdateService": {
        updatedContext.set(head3.key, head3.update(updatedContext.get(head3.key)));
        wasServiceUpdated = true;
        patches = tail;
        break;
      }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext(updatedContext);
  }
  const map8 = new Map;
  for (const [tag] of context.unsafeMap) {
    if (updatedContext.has(tag)) {
      map8.set(tag, updatedContext.get(tag));
      updatedContext.delete(tag);
    }
  }
  for (const [tag, s] of updatedContext) {
    map8.set(tag, s);
  }
  return makeContext(map8);
});

// node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
var HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
function variance2(a) {
  return a;
}
var PatchProto2 = {
  ...Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: variance2,
    _Key: variance2,
    _Patch: variance2
  }
};
var EmptyProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Empty"
});
var _empty6 = /* @__PURE__ */ Object.create(EmptyProto2);
var empty11 = () => _empty6;
var AndThenProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "AndThen"
});
var makeAndThen2 = (first, second) => {
  const o = Object.create(AndThenProto2);
  o.first = first;
  o.second = second;
  return o;
};
var AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Add"
});
var makeAdd = (value) => {
  const o = Object.create(AddProto);
  o.value = value;
  return o;
};
var RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Remove"
});
var makeRemove = (value) => {
  const o = Object.create(RemoveProto);
  o.value = value;
  return o;
};
var diff2 = (oldValue, newValue) => {
  const [removed, patch2] = reduce5([oldValue, empty11()], ([set4, patch3], value) => {
    if (has3(value)(set4)) {
      return [remove4(value)(set4), patch3];
    }
    return [set4, combine5(makeAdd(value))(patch3)];
  })(newValue);
  return reduce5(patch2, (patch3, value) => combine5(makeRemove(value))(patch3))(removed);
};
var combine5 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen2(self2, that));
var patch2 = /* @__PURE__ */ dual(2, (self2, oldValue) => {
  if (self2._tag === "Empty") {
    return oldValue;
  }
  let set4 = oldValue;
  let patches = of2(self2);
  while (isNonEmpty2(patches)) {
    const head3 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head3._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend2(head3.first)(prepend2(head3.second)(tail));
        break;
      }
      case "Add": {
        set4 = add4(head3.value)(set4);
        patches = tail;
        break;
      }
      case "Remove": {
        set4 = remove4(head3.value)(set4);
        patches = tail;
      }
    }
  }
  return set4;
});

// node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
var ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
function variance3(a) {
  return a;
}
var PatchProto3 = {
  ...Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: variance3,
    _Patch: variance3
  }
};
var EmptyProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Empty"
});
var _empty7 = /* @__PURE__ */ Object.create(EmptyProto3);
var empty12 = () => _empty7;
var AndThenProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "AndThen"
});
var makeAndThen3 = (first, second) => {
  const o = Object.create(AndThenProto3);
  o.first = first;
  o.second = second;
  return o;
};
var AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Append"
});
var makeAppend = (values3) => {
  const o = Object.create(AppendProto);
  o.values = values3;
  return o;
};
var SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Slice"
});
var makeSlice = (from, until) => {
  const o = Object.create(SliceProto);
  o.from = from;
  o.until = until;
  return o;
};
var UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Update"
});
var makeUpdate = (index, patch3) => {
  const o = Object.create(UpdateProto);
  o.index = index;
  o.patch = patch3;
  return o;
};
var diff3 = (options) => {
  let i = 0;
  let patch3 = empty12();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = options.oldValue[i];
    const newElement = options.newValue[i];
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options.differ.empty)) {
      patch3 = combine6(patch3, makeUpdate(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch3 = combine6(patch3, makeSlice(0, i));
  }
  if (i < options.newValue.length) {
    patch3 = combine6(patch3, makeAppend(drop(i)(options.newValue)));
  }
  return patch3;
};
var combine6 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen3(self2, that));
var patch3 = /* @__PURE__ */ dual(3, (self2, oldValue, differ) => {
  if (self2._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray = oldValue.slice();
  let patches = of(self2);
  while (isNonEmptyArray2(patches)) {
    const head3 = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head3._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        tail.unshift(head3.first, head3.second);
        patches = tail;
        break;
      }
      case "Append": {
        for (const value of head3.values) {
          readonlyArray.push(value);
        }
        patches = tail;
        break;
      }
      case "Slice": {
        readonlyArray = readonlyArray.slice(head3.from, head3.until);
        patches = tail;
        break;
      }
      case "Update": {
        readonlyArray[head3.index] = differ.patch(head3.patch, readonlyArray[head3.index]);
        patches = tail;
        break;
      }
    }
  }
  return readonlyArray;
});

// node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
var DifferProto = {
  [DifferTypeId]: {
    _P: identity,
    _V: identity
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make14 = (params) => {
  const differ = Object.create(DifferProto);
  differ.empty = params.empty;
  differ.diff = params.diff;
  differ.combine = params.combine;
  differ.patch = params.patch;
  return differ;
};
var environment = () => make14({
  empty: empty10(),
  combine: (first, second) => combine4(second)(first),
  diff: (oldValue, newValue) => diff(oldValue, newValue),
  patch: (patch4, oldValue) => patch(oldValue)(patch4)
});
var hashSet = () => make14({
  empty: empty11(),
  combine: (first, second) => combine5(second)(first),
  diff: (oldValue, newValue) => diff2(oldValue, newValue),
  patch: (patch4, oldValue) => patch2(oldValue)(patch4)
});
var readonlyArray = (differ) => make14({
  empty: empty12(),
  combine: (first, second) => combine6(first, second),
  diff: (oldValue, newValue) => diff3({
    oldValue,
    newValue,
    differ
  }),
  patch: (patch4, oldValue) => patch3(patch4, oldValue, differ)
});
var update = () => updateWith((_, a) => a);
var updateWith = (f) => make14({
  empty: identity,
  combine: (first, second) => {
    if (first === identity) {
      return second;
    }
    if (second === identity) {
      return first;
    }
    return (a) => second(first(a));
  },
  diff: (oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return identity;
    }
    return constant(newValue);
  },
  patch: (patch4, oldValue) => f(oldValue, patch4(oldValue))
});

// node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
var BIT_MASK = 255;
var BIT_SHIFT = 8;
var active = (patch4) => patch4 & BIT_MASK;
var enabled = (patch4) => patch4 >> BIT_SHIFT & BIT_MASK;
var make15 = (active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT);
var empty13 = /* @__PURE__ */ make15(0, 0);
var enable = (flag) => make15(flag, flag);
var disable = (flag) => make15(flag, 0);
var exclude = /* @__PURE__ */ dual(2, (self2, flag) => make15(active(self2) & ~flag, enabled(self2)));
var andThen = /* @__PURE__ */ dual(2, (self2, that) => self2 | that);
var invert = (n) => ~n >>> 0 & BIT_MASK;

// node_modules/effect/dist/esm/internal/runtimeFlags.js
var None2 = 0;
var Interruption = 1 << 0;
var OpSupervision = 1 << 1;
var RuntimeMetrics = 1 << 2;
var WindDown = 1 << 4;
var CooperativeYielding = 1 << 5;
var cooperativeYielding = (self2) => isEnabled(self2, CooperativeYielding);
var disable2 = /* @__PURE__ */ dual(2, (self2, flag) => self2 & ~flag);
var enable2 = /* @__PURE__ */ dual(2, (self2, flag) => self2 | flag);
var interruptible = (self2) => interruption(self2) && !windDown(self2);
var interruption = (self2) => isEnabled(self2, Interruption);
var isEnabled = /* @__PURE__ */ dual(2, (self2, flag) => (self2 & flag) !== 0);
var make16 = (...flags) => flags.reduce((a, b) => a | b, 0);
var none5 = /* @__PURE__ */ make16(None2);
var runtimeMetrics = (self2) => isEnabled(self2, RuntimeMetrics);
var windDown = (self2) => isEnabled(self2, WindDown);
var diff4 = /* @__PURE__ */ dual(2, (self2, that) => make15(self2 ^ that, that));
var patch4 = /* @__PURE__ */ dual(2, (self2, patch5) => self2 & (invert(active(patch5)) | enabled(patch5)) | active(patch5) & enabled(patch5));
var differ = /* @__PURE__ */ make14({
  empty: empty13,
  diff: (oldValue, newValue) => diff4(oldValue, newValue),
  combine: (first, second) => andThen(second)(first),
  patch: (_patch, oldValue) => patch4(oldValue, _patch)
});

// node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var empty14 = empty13;
var enable3 = enable;
var disable3 = disable;
var exclude2 = exclude;

// node_modules/effect/dist/esm/internal/blockedRequests.js
var empty15 = {
  _tag: "Empty"
};
var par = (self2, that) => ({
  _tag: "Par",
  left: self2,
  right: that
});
var seq = (self2, that) => ({
  _tag: "Seq",
  left: self2,
  right: that
});
var single = (dataSource, blockedRequest) => ({
  _tag: "Single",
  dataSource,
  blockedRequest
});
var flatten4 = (self2) => {
  let current = of3(self2);
  let updated = empty9();
  while (true) {
    const [parallel, sequential] = reduce7(current, [parallelCollectionEmpty(), empty9()], ([parallel2, sequential2], blockedRequest) => {
      const [par2, seq2] = step(blockedRequest);
      return [parallelCollectionCombine(parallel2, par2), appendAll3(sequential2, seq2)];
    });
    updated = merge4(updated, parallel);
    if (isNil(sequential)) {
      return reverse3(updated);
    }
    current = sequential;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var step = (requests) => {
  let current = requests;
  let parallel = parallelCollectionEmpty();
  let stack = empty9();
  let sequential = empty9();
  while (true) {
    switch (current._tag) {
      case "Empty": {
        if (isNil(stack)) {
          return [parallel, sequential];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
      case "Par": {
        stack = cons(current.right, stack);
        current = current.left;
        break;
      }
      case "Seq": {
        const left3 = current.left;
        const right3 = current.right;
        switch (left3._tag) {
          case "Empty": {
            current = right3;
            break;
          }
          case "Par": {
            const l = left3.left;
            const r = left3.right;
            current = par(seq(l, right3), seq(r, right3));
            break;
          }
          case "Seq": {
            const l = left3.left;
            const r = left3.right;
            current = seq(l, seq(r, right3));
            break;
          }
          case "Single": {
            current = left3;
            sequential = cons(right3, sequential);
            break;
          }
        }
        break;
      }
      case "Single": {
        parallel = parallelCollectionAdd(parallel, current);
        if (isNil(stack)) {
          return [parallel, sequential];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var merge4 = (sequential, parallel) => {
  if (isNil(sequential)) {
    return of3(parallelCollectionToSequentialCollection(parallel));
  }
  if (parallelCollectionIsEmpty(parallel)) {
    return sequential;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential.head);
  const parKeys = parallelCollectionKeys(parallel);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential.head, parallelCollectionToSequentialCollection(parallel)), sequential.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel), sequential);
};
var EntryTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/Entry");

class EntryImpl {
  request;
  result;
  listeners;
  ownerId;
  state;
  [EntryTypeId] = blockedRequestVariance;
  constructor(request, result, listeners, ownerId, state) {
    this.request = request;
    this.result = result;
    this.listeners = listeners;
    this.ownerId = ownerId;
    this.state = state;
  }
}
var blockedRequestVariance = {
  _R: (_) => _
};
var makeEntry = (options) => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state);
var RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
var parallelVariance = {
  _R: (_) => _
};

class ParallelImpl {
  map;
  [RequestBlockParallelTypeId] = parallelVariance;
  constructor(map8) {
    this.map = map8;
  }
}
var parallelCollectionEmpty = () => new ParallelImpl(empty8());
var parallelCollectionAdd = (self2, blockedRequest) => new ParallelImpl(modifyAt2(self2.map, blockedRequest.dataSource, (_) => orElseSome(map2(_, append2(blockedRequest.blockedRequest)), () => of2(blockedRequest.blockedRequest))));
var parallelCollectionCombine = (self2, that) => new ParallelImpl(reduce6(self2.map, that.map, (map8, value, key) => set3(map8, key, match2(get7(map8, key), {
  onNone: () => value,
  onSome: (other) => appendAll2(value, other)
}))));
var parallelCollectionIsEmpty = (self2) => isEmpty3(self2.map);
var parallelCollectionKeys = (self2) => Array.from(keys2(self2.map));
var parallelCollectionToSequentialCollection = (self2) => sequentialCollectionMake(map7(self2.map, (x) => of2(x)));
var SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
var sequentialVariance = {
  _R: (_) => _
};

class SequentialImpl {
  map;
  [SequentialCollectionTypeId] = sequentialVariance;
  constructor(map8) {
    this.map = map8;
  }
}
var sequentialCollectionMake = (map8) => new SequentialImpl(map8);
var sequentialCollectionCombine = (self2, that) => new SequentialImpl(reduce6(that.map, self2.map, (map8, value, key) => set3(map8, key, match2(get7(map8, key), {
  onNone: () => empty4(),
  onSome: (a) => appendAll2(a, value)
}))));
var sequentialCollectionKeys = (self2) => Array.from(keys2(self2.map));
var sequentialCollectionToChunk = (self2) => Array.from(self2.map);

// node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE = "Die";
var OP_EMPTY = "Empty";
var OP_FAIL = "Fail";
var OP_INTERRUPT = "Interrupt";
var OP_PARALLEL = "Parallel";
var OP_SEQUENTIAL = "Sequential";

// node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause";
var CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
var variance4 = {
  _E: (_) => _
};
var proto = {
  [CauseTypeId]: variance4,
  [symbol]() {
    return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
  },
  [symbol2](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var empty16 = /* @__PURE__ */ (() => {
  const o = /* @__PURE__ */ Object.create(proto);
  o._tag = OP_EMPTY;
  return o;
})();
var fail = (error) => {
  const o = Object.create(proto);
  o._tag = OP_FAIL;
  o.error = error;
  return o;
};
var die = (defect) => {
  const o = Object.create(proto);
  o._tag = OP_DIE;
  o.defect = defect;
  return o;
};
var interrupt = (fiberId) => {
  const o = Object.create(proto);
  o._tag = OP_INTERRUPT;
  o.fiberId = fiberId;
  return o;
};
var parallel = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_PARALLEL;
  o.left = left3;
  o.right = right3;
  return o;
};
var sequential = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_SEQUENTIAL;
  o.left = left3;
  o.right = right3;
  return o;
};
var isCause = (u) => hasProperty(u, CauseTypeId);
var isEmptyType = (self2) => self2._tag === OP_EMPTY;
var isFailType = (self2) => self2._tag === OP_FAIL;
var isDieType = (self2) => self2._tag === OP_DIE;
var isEmpty5 = (self2) => {
  if (self2._tag === OP_EMPTY) {
    return true;
  }
  return reduce8(self2, true, (acc, cause) => {
    switch (cause._tag) {
      case OP_EMPTY: {
        return some2(acc);
      }
      case OP_DIE:
      case OP_FAIL:
      case OP_INTERRUPT: {
        return some2(false);
      }
      default: {
        return none2();
      }
    }
  });
};
var isInterrupted = (self2) => isSome2(interruptOption(self2));
var isInterruptedOnly = (self2) => reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)(self2);
var failures = (self2) => reverse2(reduce8(self2, empty4(), (list, cause) => cause._tag === OP_FAIL ? some2(pipe(list, prepend2(cause.error))) : none2()));
var defects = (self2) => reverse2(reduce8(self2, empty4(), (list, cause) => cause._tag === OP_DIE ? some2(pipe(list, prepend2(cause.defect))) : none2()));
var interruptors = (self2) => reduce8(self2, empty7(), (set4, cause) => cause._tag === OP_INTERRUPT ? some2(pipe(set4, add4(cause.fiberId))) : none2());
var failureOption = (self2) => find(self2, (cause) => cause._tag === OP_FAIL ? some2(cause.error) : none2());
var failureOrCause = (self2) => {
  const option = failureOption(self2);
  switch (option._tag) {
    case "None": {
      return right2(self2);
    }
    case "Some": {
      return left2(option.value);
    }
  }
};
var flipCauseOption = (self2) => match5(self2, {
  onEmpty: some2(empty16),
  onFail: map2(fail),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: (fiberId) => some2(interrupt(fiberId)),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var interruptOption = (self2) => find(self2, (cause) => cause._tag === OP_INTERRUPT ? some2(cause.fiberId) : none2());
var keepDefects = (self2) => match5(self2, {
  onEmpty: none2(),
  onFail: () => none2(),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var keepDefectsAndElectFailures = (self2) => match5(self2, {
  onEmpty: none2(),
  onFail: (failure) => some2(die(failure)),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var stripFailures = (self2) => match5(self2, {
  onEmpty: empty16,
  onFail: () => empty16,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var electFailures = (self2) => match5(self2, {
  onEmpty: empty16,
  onFail: die,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var map9 = /* @__PURE__ */ dual(2, (self2, f) => flatMap7(self2, (e) => fail(f(e))));
var flatMap7 = /* @__PURE__ */ dual(2, (self2, f) => match5(self2, {
  onEmpty: empty16,
  onFail: (error) => f(error),
  onDie: (defect) => die(defect),
  onInterrupt: (fiberId) => interrupt(fiberId),
  onSequential: (left3, right3) => sequential(left3, right3),
  onParallel: (left3, right3) => parallel(left3, right3)
}));
var flatten5 = (self2) => flatMap7(self2, identity);
var causeEquals = (left3, right3) => {
  let leftStack = of2(left3);
  let rightStack = of2(right3);
  while (isNonEmpty2(leftStack) && isNonEmpty2(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce8([empty7(), empty4()], ([parallel2, sequential2], cause) => {
      const [par2, seq2] = evaluateCause(cause);
      return some2([pipe(parallel2, union3(par2)), pipe(sequential2, appendAll2(seq2))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce8([empty7(), empty4()], ([parallel2, sequential2], cause) => {
      const [par2, seq2] = evaluateCause(cause);
      return some2([pipe(parallel2, union3(par2)), pipe(sequential2, appendAll2(seq2))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
};
var flattenCause = (cause) => {
  return flattenCauseLoop(of2(cause), empty4());
};
var flattenCauseLoop = (causes, flattened) => {
  while (true) {
    const [parallel2, sequential2] = pipe(causes, reduce([empty7(), empty4()], ([parallel3, sequential3], cause) => {
      const [par2, seq2] = evaluateCause(cause);
      return [pipe(parallel3, union3(par2)), pipe(sequential3, appendAll2(seq2))];
    }));
    const updated = size3(parallel2) > 0 ? pipe(flattened, prepend2(parallel2)) : flattened;
    if (isEmpty(sequential2)) {
      return reverse2(updated);
    }
    causes = sequential2;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
var find = /* @__PURE__ */ dual(2, (self2, pf) => {
  const stack = [self2];
  while (stack.length > 0) {
    const item = stack.pop();
    const option = pf(item);
    switch (option._tag) {
      case "None": {
        switch (item._tag) {
          case OP_SEQUENTIAL:
          case OP_PARALLEL: {
            stack.push(item.right);
            stack.push(item.left);
            break;
          }
        }
        break;
      }
      case "Some": {
        return option;
      }
    }
  }
  return none2();
});
var evaluateCause = (self2) => {
  let cause = self2;
  const stack = [];
  let _parallel = empty7();
  let _sequential = empty4();
  while (cause !== undefined) {
    switch (cause._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add4(_parallel, make6(cause._tag, cause.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add4(_parallel, make6(cause._tag, cause.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add4(_parallel, make6(cause._tag, cause.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause.left._tag) {
          case OP_EMPTY: {
            cause = cause.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));
            break;
          }
          case OP_PARALLEL: {
            cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));
            break;
          }
          default: {
            _sequential = prepend2(_sequential, cause.right);
            cause = cause.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause.right);
        cause = cause.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
var IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: (_, left3, right3) => left3 && right3,
  parallelCase: (_, left3, right3) => left3 && right3
};
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
var match5 = /* @__PURE__ */ dual(2, (self2, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt,
  onParallel,
  onSequential
}) => {
  return reduceWithContext(self2, undefined, {
    emptyCase: () => onEmpty,
    failCase: (_, error) => onFail(error),
    dieCase: (_, defect) => onDie(defect),
    interruptCase: (_, fiberId) => onInterrupt(fiberId),
    sequentialCase: (_, left3, right3) => onSequential(left3, right3),
    parallelCase: (_, left3, right3) => onParallel(left3, right3)
  });
});
var reduce8 = /* @__PURE__ */ dual(3, (self2, zero2, pf) => {
  let accumulator = zero2;
  let cause = self2;
  const causes = [];
  while (cause !== undefined) {
    const option = pf(accumulator, cause);
    accumulator = isSome2(option) ? option.value : accumulator;
    switch (cause._tag) {
      case OP_SEQUENTIAL: {
        causes.push(cause.right);
        cause = cause.left;
        break;
      }
      case OP_PARALLEL: {
        causes.push(cause.right);
        cause = cause.left;
        break;
      }
      default: {
        cause = undefined;
        break;
      }
    }
    if (cause === undefined && causes.length > 0) {
      cause = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext = /* @__PURE__ */ dual(3, (self2, context, reducer) => {
  const input = [self2];
  const output = [];
  while (input.length > 0) {
    const cause = input.pop();
    switch (cause._tag) {
      case OP_EMPTY: {
        output.push(right2(reducer.emptyCase(context)));
        break;
      }
      case OP_FAIL: {
        output.push(right2(reducer.failCase(context, cause.error)));
        break;
      }
      case OP_DIE: {
        output.push(right2(reducer.dieCase(context, cause.defect)));
        break;
      }
      case OP_INTERRUPT: {
        output.push(right2(reducer.interruptCase(context, cause.fiberId)));
        break;
      }
      case OP_SEQUENTIAL: {
        input.push(cause.right);
        input.push(cause.left);
        output.push(left2({
          _tag: OP_SEQUENTIAL_CASE
        }));
        break;
      }
      case OP_PARALLEL: {
        input.push(cause.right);
        input.push(cause.left);
        output.push(left2({
          _tag: OP_PARALLEL_CASE
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either2 = output.pop();
    switch (either2._tag) {
      case "Left": {
        switch (either2.left._tag) {
          case OP_SEQUENTIAL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.sequentialCase(context, left3, right3);
            accumulator.push(value);
            break;
          }
          case OP_PARALLEL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.parallelCase(context, left3, right3);
            accumulator.push(value);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either2.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var pretty = (cause, options) => {
  if (isInterruptedOnly(cause)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause).map(function(e) {
    if (options?.renderErrorCause !== true || e.cause === undefined) {
      return e.stack;
    }
    return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
  }).join(`
`);
};
var renderErrorCause = (cause, prefix) => {
  const lines = cause.stack.split(`
`);
  let stack = `${prefix}[cause]: ${lines[0]}`;
  for (let i = 1, len = lines.length;i < len; i++) {
    stack += `
${prefix}${lines[i]}`;
  }
  if (cause.cause) {
    stack += ` {
${renderErrorCause(cause.cause, `${prefix}  `)}
${prefix}}`;
  }
  return stack;
};

class PrettyError extends globalThis.Error {
  span = undefined;
  constructor(originalError) {
    const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
      cause: new PrettyError(originalError.cause)
    } : undefined);
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError instanceof Error ? originalError.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol in originalError) {
        this.span = originalError[spanSymbol];
      }
      Object.keys(originalError).forEach((key) => {
        if (!(key in this)) {
          this[key] = originalError[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
  }
}
var prettyErrorMessage = (u) => {
  if (typeof u === "string") {
    return u;
  }
  if (typeof u === "object" && u !== null && u instanceof Error) {
    return u.message;
  }
  try {
    if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {}
  return stringifyCircular(u);
};
var locationRegex = /\((.*)\)/g;
var spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => new WeakMap);
var prettyErrorStack = (message, stack, span2) => {
  const out = [message];
  const lines = stack.startsWith(message) ? stack.slice(message.length).split(`
`) : stack.split(`
`);
  for (let i = 1;i < lines.length; i++) {
    if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
      i++;
      continue;
    }
    if (lines[i].includes("Generator.next")) {
      break;
    }
    if (lines[i].includes("effect_internal_function")) {
      break;
    }
    out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span2) {
    let current = span2;
    let i = 0;
    while (current && current._tag === "Span" && i < 10) {
      const stackFn = spanToTrace.get(current);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex);
          let match6 = false;
          for (const [, location] of locationMatchAll) {
            match6 = true;
            out.push(`    at ${current.name} (${location})`);
          }
          if (!match6) {
            out.push(`    at ${current.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out.push(`    at ${current.name}`);
        }
      } else {
        out.push(`    at ${current.name}`);
      }
      current = getOrUndefined(current.parent);
      i++;
    }
  }
  return out.join(`
`);
};
var spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
var prettyErrors = (cause) => reduceWithContext(cause, undefined, {
  emptyCase: () => [],
  dieCase: (_, unknownError) => {
    return [new PrettyError(unknownError)];
  },
  failCase: (_, error) => {
    return [new PrettyError(error)];
  },
  interruptCase: () => [],
  parallelCase: (_, l, r) => [...l, ...r],
  sequentialCase: (_, l, r) => [...l, ...r]
});

// node_modules/effect/dist/esm/internal/opCodes/deferred.js
var OP_STATE_PENDING = "Pending";
var OP_STATE_DONE = "Done";

// node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey = "effect/Deferred";
var DeferredTypeId = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
var deferredVariance = {
  _E: (_) => _,
  _A: (_) => _
};
var pending = (joiners) => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
};
var done = (effect) => {
  return {
    _tag: OP_STATE_DONE,
    effect
  };
};

// node_modules/effect/dist/esm/internal/singleShotGen.js
class SingleShotGen2 {
  self;
  called = false;
  constructor(self2) {
    this.self = self2;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(this.self);
  }
}

// node_modules/effect/dist/esm/internal/core.js
var blocked = (blockedRequests, _continue) => {
  const effect = new EffectPrimitive("Blocked");
  effect.effect_instruction_i0 = blockedRequests;
  effect.effect_instruction_i1 = _continue;
  return effect;
};
var runRequestBlock = (blockedRequests) => {
  const effect = new EffectPrimitive("RunBlocked");
  effect.effect_instruction_i0 = blockedRequests;
  return effect;
};
var EffectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Effect");

class RevertFlags {
  patch;
  op;
  _op = OP_REVERT_FLAGS;
  constructor(patch5, op) {
    this.patch = patch5;
    this.op = op;
  }
}

class EffectPrimitive {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
}

class EffectPrimitiveFailure {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Failure" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(string(this._tag), combine(hash(this.effect_instruction_i0)), cached(this));
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
}

class EffectPrimitiveSuccess {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Success" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(string(this._tag), combine(hash(this.effect_instruction_i0)), cached(this));
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
}
var isEffect = (u) => hasProperty(u, EffectTypeId2);
var withFiberRuntime = (withRuntime) => {
  const effect = new EffectPrimitive(OP_WITH_RUNTIME);
  effect.effect_instruction_i0 = withRuntime;
  return effect;
};
var acquireUseRelease = /* @__PURE__ */ dual(3, (acquire, use, release) => uninterruptibleMask((restore) => flatMap8(acquire, (a) => flatMap8(exit(suspend(() => restore(use(a)))), (exit) => {
  return suspend(() => release(a, exit)).pipe(matchCauseEffect({
    onFailure: (cause) => {
      switch (exit._tag) {
        case OP_FAILURE:
          return failCause(sequential(exit.effect_instruction_i0, cause));
        case OP_SUCCESS:
          return failCause(cause);
      }
    },
    onSuccess: () => exit
  }));
}))));
var as = /* @__PURE__ */ dual(2, (self2, value) => flatMap8(self2, () => succeed(value)));
var asVoid = (self2) => as(self2, undefined);
var custom = function() {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.commit = arguments[1];
      break;
    }
    case 3: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.commit = arguments[2];
      break;
    }
    case 4: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.effect_instruction_i2 = arguments[2];
      wrapper.commit = arguments[3];
      break;
    }
    default: {
      throw new Error(getBugErrorMessage("you're not supposed to end up here"));
    }
  }
  return wrapper;
};
var unsafeAsync = (register, blockingOn = none4) => {
  const effect = new EffectPrimitive(OP_ASYNC);
  let cancelerRef = undefined;
  effect.effect_instruction_i0 = (resume) => {
    cancelerRef = register(resume);
  };
  effect.effect_instruction_i1 = blockingOn;
  return onInterrupt(effect, (_) => isEffect(cancelerRef) ? cancelerRef : void_);
};
var asyncInterrupt = (register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn));
var async_ = (resume, blockingOn = none4) => {
  return custom(resume, function() {
    let backingResume = undefined;
    let pendingEffect = undefined;
    function proxyResume(effect2) {
      if (backingResume) {
        backingResume(effect2);
      } else if (pendingEffect === undefined) {
        pendingEffect = effect2;
      }
    }
    const effect = new EffectPrimitive(OP_ASYNC);
    effect.effect_instruction_i0 = (resume2) => {
      backingResume = resume2;
      if (pendingEffect) {
        resume2(pendingEffect);
      }
    };
    effect.effect_instruction_i1 = blockingOn;
    let cancelerRef = undefined;
    let controllerRef = undefined;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController;
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
    } else {
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
    }
    return cancelerRef || controllerRef ? onInterrupt(effect, (_) => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_;
    }) : effect;
  });
};
var catchAllCause = /* @__PURE__ */ dual(2, (self2, f) => {
  const effect = new EffectPrimitive(OP_ON_FAILURE);
  effect.effect_instruction_i0 = self2;
  effect.effect_instruction_i1 = f;
  return effect;
});
var catchAll = /* @__PURE__ */ dual(2, (self2, f) => matchEffect(self2, {
  onFailure: f,
  onSuccess: succeed
}));
var catchIf = /* @__PURE__ */ dual(3, (self2, predicate, f) => catchAllCause(self2, (cause) => {
  const either2 = failureOrCause(cause);
  switch (either2._tag) {
    case "Left":
      return predicate(either2.left) ? f(either2.left) : failCause(cause);
    case "Right":
      return failCause(either2.right);
  }
}));
var catchSome = /* @__PURE__ */ dual(2, (self2, pf) => catchAllCause(self2, (cause) => {
  const either2 = failureOrCause(cause);
  switch (either2._tag) {
    case "Left":
      return pipe(pf(either2.left), getOrElse(() => failCause(cause)));
    case "Right":
      return failCause(either2.right);
  }
}));
var checkInterruptible = (f) => withFiberRuntime((_, status) => f(interruption(status.runtimeFlags)));
var originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
var capture = (obj, span2) => {
  if (isSome2(span2)) {
    return new Proxy(obj, {
      has(target, p) {
        return p === spanSymbol || p === originalSymbol || p in target;
      },
      get(target, p) {
        if (p === spanSymbol) {
          return span2.value;
        }
        if (p === originalSymbol) {
          return obj;
        }
        return target[p];
      }
    });
  }
  return obj;
};
var die2 = (defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect));
var dieMessage = (message) => failCauseSync(() => die(new RuntimeException(message)));
var dieSync = (evaluate) => flatMap8(sync(evaluate), die2);
var either2 = (self2) => matchEffect(self2, {
  onFailure: (e) => succeed(left2(e)),
  onSuccess: (a) => succeed(right2(a))
});
var exit = (self2) => matchCause(self2, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
});
var fail2 = (error) => isObject(error) && !(spanSymbol in error) ? withFiberRuntime((fiber) => failCause(fail(capture(error, currentSpanFromFiber(fiber))))) : failCause(fail(error));
var failSync = (evaluate) => flatMap8(sync(evaluate), fail2);
var failCause = (cause) => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause;
  return effect;
};
var failCauseSync = (evaluate) => flatMap8(sync(evaluate), failCause);
var fiberId = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.id()));
var fiberIdWith = (f) => withFiberRuntime((state) => f(state.id()));
var flatMap8 = /* @__PURE__ */ dual(2, (self2, f) => {
  const effect = new EffectPrimitive(OP_ON_SUCCESS);
  effect.effect_instruction_i0 = self2;
  effect.effect_instruction_i1 = f;
  return effect;
});
var andThen2 = /* @__PURE__ */ dual(2, (self2, f) => flatMap8(self2, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return b;
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume) => {
      b.then((a2) => resume(succeed(a2)), (e) => resume(fail2(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
    });
  }
  return succeed(b);
}));
var step2 = (self2) => {
  const effect = new EffectPrimitive("OnStep");
  effect.effect_instruction_i0 = self2;
  return effect;
};
var flatten6 = (self2) => flatMap8(self2, identity);
var flip = (self2) => matchEffect(self2, {
  onFailure: succeed,
  onSuccess: fail2
});
var matchCause = /* @__PURE__ */ dual(2, (self2, options) => matchCauseEffect(self2, {
  onFailure: (cause) => succeed(options.onFailure(cause)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var matchCauseEffect = /* @__PURE__ */ dual(2, (self2, options) => {
  const effect = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
  effect.effect_instruction_i0 = self2;
  effect.effect_instruction_i1 = options.onFailure;
  effect.effect_instruction_i2 = options.onSuccess;
  return effect;
});
var matchEffect = /* @__PURE__ */ dual(2, (self2, options) => matchCauseEffect(self2, {
  onFailure: (cause) => {
    const defects2 = defects(cause);
    if (defects2.length > 0) {
      return failCause(electFailures(cause));
    }
    const failures2 = failures(cause);
    if (failures2.length > 0) {
      return options.onFailure(unsafeHead(failures2));
    }
    return failCause(cause);
  },
  onSuccess: options.onSuccess
}));
var forEachSequential = /* @__PURE__ */ dual(2, (self2, f) => suspend(() => {
  const arr = fromIterable(self2);
  const ret = allocate(arr.length);
  let i = 0;
  return as(whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: (b) => {
      ret[i++] = b;
    }
  }), ret);
}));
var forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self2, f) => suspend(() => {
  const arr = fromIterable(self2);
  let i = 0;
  return whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: () => {
      i++;
    }
  });
}));
var if_ = /* @__PURE__ */ dual((args) => typeof args[0] === "boolean" || isEffect(args[0]), (self2, options) => isEffect(self2) ? flatMap8(self2, (b) => b ? options.onTrue() : options.onFalse()) : self2 ? options.onTrue() : options.onFalse());
var interrupt2 = /* @__PURE__ */ flatMap8(fiberId, (fiberId2) => interruptWith(fiberId2));
var interruptWith = (fiberId2) => failCause(interrupt(fiberId2));
var interruptible2 = (self2) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = enable3(Interruption);
  effect.effect_instruction_i1 = () => self2;
  return effect;
};
var interruptibleMask = (f) => custom(f, function() {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = enable3(Interruption);
  effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect;
});
var intoDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => uninterruptibleMask((restore) => flatMap8(exit(restore(self2)), (exit2) => deferredDone(deferred, exit2))));
var map10 = /* @__PURE__ */ dual(2, (self2, f) => flatMap8(self2, (a) => sync(() => f(a))));
var mapBoth = /* @__PURE__ */ dual(2, (self2, options) => matchEffect(self2, {
  onFailure: (e) => failSync(() => options.onFailure(e)),
  onSuccess: (a) => sync(() => options.onSuccess(a))
}));
var mapError = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause) => {
    const either3 = failureOrCause(cause);
    switch (either3._tag) {
      case "Left": {
        return failSync(() => f(either3.left));
      }
      case "Right": {
        return failCause(either3.right);
      }
    }
  },
  onSuccess: succeed
}));
var onError = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit(self2, (exit2) => exitIsSuccess(exit2) ? void_ : cleanup(exit2.effect_instruction_i0)));
var onExit = /* @__PURE__ */ dual(2, (self2, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self2), {
  onFailure: (cause1) => {
    const result = exitFailCause(cause1);
    return matchCauseEffect(cleanup(result), {
      onFailure: (cause2) => exitFailCause(sequential(cause1, cause2)),
      onSuccess: () => result
    });
  },
  onSuccess: (success) => {
    const result = exitSucceed(success);
    return zipRight(cleanup(result), result);
  }
})));
var onInterrupt = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit(self2, exitMatch({
  onFailure: (cause) => isInterruptedOnly(cause) ? asVoid(cleanup(interruptors(cause))) : void_,
  onSuccess: () => void_
})));
var orElse2 = /* @__PURE__ */ dual(2, (self2, that) => attemptOrElse(self2, that, succeed));
var orDie = (self2) => orDieWith(self2, identity);
var orDieWith = /* @__PURE__ */ dual(2, (self2, f) => matchEffect(self2, {
  onFailure: (e) => die2(f(e)),
  onSuccess: succeed
}));
var partitionMap2 = partitionMap;
var runtimeFlags = /* @__PURE__ */ withFiberRuntime((_, status) => succeed(status.runtimeFlags));
var succeed = (value) => {
  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
};
var suspend = (evaluate) => {
  const effect = new EffectPrimitive(OP_COMMIT);
  effect.commit = evaluate;
  return effect;
};
var sync = (thunk) => {
  const effect = new EffectPrimitive(OP_SYNC);
  effect.effect_instruction_i0 = thunk;
  return effect;
};
var tap = /* @__PURE__ */ dual((args) => args.length === 3 || args.length === 2 && !(isObject(args[1]) && ("onlyEffect" in args[1])), (self2, f) => flatMap8(self2, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return as(b, a);
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume) => {
      b.then((_) => resume(succeed(a)), (e) => resume(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
    });
  }
  return succeed(a);
}));
var transplant = (f) => withFiberRuntime((state) => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride);
  const scope = pipe(scopeOverride, getOrElse(() => state.scope()));
  return f(fiberRefLocally(currentForkScopeOverride, some2(scope)));
});
var attemptOrElse = /* @__PURE__ */ dual(3, (self2, that, onSuccess) => matchCauseEffect(self2, {
  onFailure: (cause) => {
    const defects2 = defects(cause);
    if (defects2.length > 0) {
      return failCause(getOrThrow2(keepDefectsAndElectFailures(cause)));
    }
    return that();
  },
  onSuccess
}));
var uninterruptible = (self2) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = disable3(Interruption);
  effect.effect_instruction_i1 = () => self2;
  return effect;
};
var uninterruptibleMask = (f) => custom(f, function() {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = disable3(Interruption);
  effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect;
});
var void_ = /* @__PURE__ */ succeed(undefined);
var updateRuntimeFlags = (patch5) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = patch5;
  effect.effect_instruction_i1 = undefined;
  return effect;
};
var whenEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap8(condition, (b) => {
  if (b) {
    return pipe(self2, map10(some2));
  }
  return succeed(none2());
}));
var whileLoop = (options) => {
  const effect = new EffectPrimitive(OP_WHILE);
  effect.effect_instruction_i0 = options.while;
  effect.effect_instruction_i1 = options.body;
  effect.effect_instruction_i2 = options.step;
  return effect;
};
var fromIterator = (iterator) => suspend(() => {
  const effect = new EffectPrimitive(OP_ITERATOR);
  effect.effect_instruction_i0 = iterator();
  return effect;
});
var gen = function() {
  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
  return fromIterator(() => f(pipe));
};
var fnUntraced = (body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args) {
  return fromIterator(() => body.apply(this, args));
} : function(...args) {
  let effect = fromIterator(() => body.apply(this, args));
  for (const x of pipeables) {
    effect = x(effect, ...args);
  }
  return effect;
}, "length", {
  value: body.length,
  configurable: true
});
var withConcurrency = /* @__PURE__ */ dual(2, (self2, concurrency) => fiberRefLocally(self2, currentConcurrency, concurrency));
var withRequestBatching = /* @__PURE__ */ dual(2, (self2, requestBatching) => fiberRefLocally(self2, currentRequestBatching, requestBatching));
var withRuntimeFlags = /* @__PURE__ */ dual(2, (self2, update2) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = update2;
  effect.effect_instruction_i1 = () => self2;
  return effect;
});
var withTracerEnabled = /* @__PURE__ */ dual(2, (effect, enabled2) => fiberRefLocally(effect, currentTracerEnabled, enabled2));
var withTracerTiming = /* @__PURE__ */ dual(2, (effect, enabled2) => fiberRefLocally(effect, currentTracerTimingEnabled, enabled2));
var yieldNow = (options) => {
  const effect = new EffectPrimitive(OP_YIELD);
  return typeof options?.priority !== "undefined" ? withSchedulingPriority(effect, options.priority) : effect;
};
var zip2 = /* @__PURE__ */ dual(2, (self2, that) => flatMap8(self2, (a) => map10(that, (b) => [a, b])));
var zipLeft = /* @__PURE__ */ dual(2, (self2, that) => flatMap8(self2, (a) => as(that, a)));
var zipRight = /* @__PURE__ */ dual(2, (self2, that) => flatMap8(self2, () => that));
var zipWith3 = /* @__PURE__ */ dual(3, (self2, that, f) => flatMap8(self2, (a) => map10(that, (b) => f(a, b))));
var never = /* @__PURE__ */ asyncInterrupt(() => {
  const interval = setInterval(() => {}, 2 ** 31 - 1);
  return sync(() => clearInterval(interval));
});
var interruptFiber = (self2) => flatMap8(fiberId, (fiberId2) => pipe(self2, interruptAsFiber(fiberId2)));
var interruptAsFiber = /* @__PURE__ */ dual(2, (self2, fiberId2) => flatMap8(self2.interruptAsFork(fiberId2), () => self2.await));
var logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 50000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 40000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 30000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 20000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 1e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var FiberRefSymbolKey = "effect/FiberRef";
var FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
var fiberRefVariance = {
  _A: (_) => _
};
var fiberRefGet = (self2) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self2)));
var fiberRefGetWith = /* @__PURE__ */ dual(2, (self2, f) => flatMap8(fiberRefGet(self2), f));
var fiberRefSet = /* @__PURE__ */ dual(2, (self2, value) => fiberRefModify(self2, () => [undefined, value]));
var fiberRefModify = /* @__PURE__ */ dual(2, (self2, f) => withFiberRuntime((state) => {
  const [b, a] = f(state.getFiberRef(self2));
  state.setFiberRef(self2, a);
  return succeed(b);
}));
var fiberRefLocally = /* @__PURE__ */ dual(3, (use, self2, value) => acquireUseRelease(zipLeft(fiberRefGet(self2), fiberRefSet(self2, value)), () => use, (oldValue) => fiberRefSet(self2, oldValue)));
var fiberRefLocallyWith = /* @__PURE__ */ dual(3, (use, self2, f) => fiberRefGetWith(self2, (a) => fiberRefLocally(use, self2, f(a))));
var fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
  differ: update(),
  fork: options?.fork ?? identity,
  join: options?.join
});
var fiberRefUnsafeMakeHashSet = (initial) => {
  const differ2 = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: differ2.empty
  });
};
var fiberRefUnsafeMakeReadonlyArray = (initial) => {
  const differ2 = readonlyArray(update());
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: differ2.empty
  });
};
var fiberRefUnsafeMakeContext = (initial) => {
  const differ2 = environment();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: differ2.empty
  });
};
var fiberRefUnsafeMakePatch = (initial, options) => {
  const _fiberRef = {
    ...CommitPrototype,
    [FiberRefTypeId]: fiberRefVariance,
    initial,
    commit() {
      return fiberRefGet(this);
    },
    diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
    combine: (first, second) => options.differ.combine(first, second),
    patch: (patch5) => (oldValue) => options.differ.patch(patch5, oldValue),
    fork: options.fork,
    join: options.join ?? ((_, n) => n)
  };
  return _fiberRef;
};
var fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ,
  fork: differ.empty
});
var currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty3()));
var currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
var currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
var currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty8()));
var currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
var currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty9()));
var withSchedulingPriority = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentSchedulingPriority, scheduler));
var withMaxOpsBeforeYield = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentMaxOpsBeforeYield, scheduler));
var currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
var currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
var currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelDebug)));
var currentVersionMismatchErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/versionMismatchErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelWarning)));
var withUnhandledErrorLogLevel = /* @__PURE__ */ dual(2, (self2, level) => fiberRefLocally(self2, currentUnhandledErrorLogLevel, level));
var currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty()));
var metricLabels = /* @__PURE__ */ fiberRefGet(currentMetricLabels);
var currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
  fork: () => none2(),
  join: (parent, _) => parent
}));
var currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty16, {
  fork: () => empty16,
  join: (parent, _) => parent
}));
var currentTracerEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
var currentTracerTimingEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
var currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty8()));
var currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty4()));
var ScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Scope");
var CloseableScopeTypeId = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
var scopeAddFinalizer = (self2, finalizer) => self2.addFinalizer(() => asVoid(finalizer));
var scopeAddFinalizerExit = (self2, finalizer) => self2.addFinalizer(finalizer);
var scopeClose = (self2, exit2) => self2.close(exit2);
var scopeFork = (self2, strategy) => self2.fork(strategy);
var causeSquash = (self2) => {
  return causeSquashWith(identity)(self2);
};
var causeSquashWith = /* @__PURE__ */ dual(2, (self2, f) => {
  const option = pipe(self2, failureOption, map2(f));
  switch (option._tag) {
    case "None": {
      return pipe(defects(self2), head2, match2({
        onNone: () => {
          const interrupts = fromIterable(interruptors(self2)).flatMap((fiberId2) => fromIterable(ids2(fiberId2)).map((id) => `#${id}`));
          return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : undefined);
        },
        onSome: identity
      }));
    }
    case "Some": {
      return option.value;
    }
  }
});
var YieldableError = /* @__PURE__ */ function() {

  class YieldableError2 extends globalThis.Error {
    commit() {
      return fail2(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message)
        obj.message = this.message;
      if (this.cause)
        obj.cause = this.cause;
      return obj;
    }
    [NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}
${this.stack.split(`
`).slice(1).join(`
`)}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty(fail(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  Object.assign(YieldableError2.prototype, StructuralCommitPrototype);
  return YieldableError2;
}();
var makeException = (proto2, tag) => {

  class Base2 extends YieldableError {
    _tag = tag;
  }
  Object.assign(Base2.prototype, proto2);
  Base2.prototype.name = tag;
  return Base2;
};
var RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException = /* @__PURE__ */ makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
var isRuntimeException = (u) => hasProperty(u, RuntimeExceptionTypeId);
var InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException = /* @__PURE__ */ makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
var isInterruptedException = (u) => hasProperty(u, InterruptedExceptionTypeId);
var IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
var IllegalArgumentException = /* @__PURE__ */ makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
var NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException = /* @__PURE__ */ makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
var isNoSuchElementException = (u) => hasProperty(u, NoSuchElementExceptionTypeId);
var InvalidPubSubCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
var InvalidPubSubCapacityException = /* @__PURE__ */ makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
var ExceededCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
var ExceededCapacityException = /* @__PURE__ */ makeException({
  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}, "ExceededCapacityException");
var TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException = /* @__PURE__ */ makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
var timeoutExceptionFromDuration = (duration) => new TimeoutException(`Operation timed out after '${format2(duration)}'`);
var UnknownExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
var UnknownException = /* @__PURE__ */ function() {

  class UnknownException2 extends YieldableError {
    _tag = "UnknownException";
    error;
    constructor(cause, message) {
      super(message ?? "An unknown error occurred", {
        cause
      });
      this.error = cause;
    }
  }
  Object.assign(UnknownException2.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException2;
}();
var exitIsExit = (u) => isEffect(u) && ("_tag" in u) && (u._tag === "Success" || u._tag === "Failure");
var exitIsFailure = (self2) => self2._tag === "Failure";
var exitIsSuccess = (self2) => self2._tag === "Success";
var exitAs = /* @__PURE__ */ dual(2, (self2, value) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      return exitFailCause(self2.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return exitSucceed(value);
    }
  }
});
var exitAsVoid = (self2) => exitAs(self2, undefined);
var exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel : sequential);
var exitDie = (defect) => exitFailCause(die(defect));
var exitFail = (error) => exitFailCause(fail(error));
var exitFailCause = (cause) => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause;
  return effect;
};
var exitFlatMap = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      return exitFailCause(self2.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return f(self2.effect_instruction_i0);
    }
  }
});
var exitFlatten = (self2) => pipe(self2, exitFlatMap(identity));
var exitInterrupt = (fiberId2) => exitFailCause(interrupt(fiberId2));
var exitMap = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return exitFailCause(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return exitSucceed(f(self2.effect_instruction_i0));
  }
});
var exitMapBoth = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self2.effect_instruction_i0, map9(onFailure)));
    case OP_SUCCESS:
      return exitSucceed(onSuccess(self2.effect_instruction_i0));
  }
});
var exitMatch = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return onFailure(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self2.effect_instruction_i0);
  }
});
var exitMatchEffect = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return onFailure(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self2.effect_instruction_i0);
  }
});
var exitSucceed = (value) => {
  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
};
var exitVoid = /* @__PURE__ */ exitSucceed(undefined);
var exitZip = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
  onSuccess: (a, a2) => [a, a2],
  onFailure: sequential
}));
var exitZipRight = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
  onSuccess: (_, a2) => a2,
  onFailure: sequential
}));
var exitZipWith = /* @__PURE__ */ dual(3, (self2, that, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitFailCause(self2.effect_instruction_i0);
        case OP_FAILURE: {
          return exitFailCause(onFailure(self2.effect_instruction_i0, that.effect_instruction_i0));
        }
      }
    }
    case OP_SUCCESS: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitSucceed(onSuccess(self2.effect_instruction_i0, that.effect_instruction_i0));
        case OP_FAILURE:
          return exitFailCause(that.effect_instruction_i0);
      }
    }
  }
});
var exitCollectAllInternal = (exits, combineCauses) => {
  const list = fromIterable2(exits);
  if (!isNonEmpty2(list)) {
    return none2();
  }
  return pipe(tailNonEmpty2(list), reduce(pipe(headNonEmpty2(list), exitMap(of2)), (accumulator, current) => pipe(accumulator, exitZipWith(current, {
    onSuccess: (list2, value) => pipe(list2, prepend2(value)),
    onFailure: combineCauses
  }))), exitMap(reverse2), exitMap((chunk) => toReadonlyArray(chunk)), some2);
};
var deferredUnsafeMake = (fiberId2) => {
  const _deferred = {
    ...CommitPrototype,
    [DeferredTypeId]: deferredVariance,
    state: make11(pending([])),
    commit() {
      return deferredAwait(this);
    },
    blockingOn: fiberId2
  };
  return _deferred;
};
var deferredMake = () => flatMap8(fiberId, (id) => deferredMakeAs(id));
var deferredMakeAs = (fiberId2) => sync(() => deferredUnsafeMake(fiberId2));
var deferredAwait = (self2) => asyncInterrupt((resume) => {
  const state = get6(self2.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return resume(state.effect);
    }
    case OP_STATE_PENDING: {
      state.joiners.push(resume);
      return deferredInterruptJoiner(self2, resume);
    }
  }
}, self2.blockingOn);
var deferredComplete = /* @__PURE__ */ dual(2, (self2, effect) => intoDeferred(effect, self2));
var deferredCompleteWith = /* @__PURE__ */ dual(2, (self2, effect) => sync(() => {
  const state = get6(self2.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return false;
    }
    case OP_STATE_PENDING: {
      set2(self2.state, done(effect));
      for (let i = 0, len = state.joiners.length;i < len; i++) {
        state.joiners[i](effect);
      }
      return true;
    }
  }
}));
var deferredDone = /* @__PURE__ */ dual(2, (self2, exit2) => deferredCompleteWith(self2, exit2));
var deferredFail = /* @__PURE__ */ dual(2, (self2, error) => deferredCompleteWith(self2, fail2(error)));
var deferredFailCause = /* @__PURE__ */ dual(2, (self2, cause) => deferredCompleteWith(self2, failCause(cause)));
var deferredInterrupt = (self2) => flatMap8(fiberId, (fiberId2) => deferredCompleteWith(self2, interruptWith(fiberId2)));
var deferredInterruptWith = /* @__PURE__ */ dual(2, (self2, fiberId2) => deferredCompleteWith(self2, interruptWith(fiberId2)));
var deferredIsDone = (self2) => sync(() => get6(self2.state)._tag === OP_STATE_DONE);
var deferredPoll = (self2) => sync(() => {
  const state = get6(self2.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return some2(state.effect);
    }
    case OP_STATE_PENDING: {
      return none2();
    }
  }
});
var deferredSucceed = /* @__PURE__ */ dual(2, (self2, value) => deferredCompleteWith(self2, succeed(value)));
var deferredUnsafeDone = (self2, effect) => {
  const state = get6(self2.state);
  if (state._tag === OP_STATE_PENDING) {
    set2(self2.state, done(effect));
    for (let i = 0, len = state.joiners.length;i < len; i++) {
      state.joiners[i](effect);
    }
  }
};
var deferredInterruptJoiner = (self2, joiner) => sync(() => {
  const state = get6(self2.state);
  if (state._tag === OP_STATE_PENDING) {
    const index = state.joiners.indexOf(joiner);
    if (index >= 0) {
      state.joiners.splice(index, 1);
    }
  }
});
var constContext = /* @__PURE__ */ withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
var context = () => constContext;
var contextWithEffect = (f) => flatMap8(context(), f);
var provideContext = /* @__PURE__ */ dual(2, (self2, context2) => fiberRefLocally(currentContext, context2)(self2));
var provideSomeContext = /* @__PURE__ */ dual(2, (self2, context2) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context2))(self2));
var mapInputContext = /* @__PURE__ */ dual(2, (self2, f) => contextWithEffect((context2) => provideContext(self2, f(context2))));
var filterEffectOrElse = /* @__PURE__ */ dual(2, (self2, options) => flatMap8(self2, (a) => flatMap8(options.predicate(a), (pass) => pass ? succeed(a) : options.orElse(a))));
var filterEffectOrFail = /* @__PURE__ */ dual(2, (self2, options) => filterEffectOrElse(self2, {
  predicate: options.predicate,
  orElse: (a) => fail2(options.orFailWith(a))
}));
var currentSpanFromFiber = (fiber) => {
  const span2 = fiber.currentSpan;
  return span2 !== undefined && span2._tag === "Span" ? some2(span2) : none2();
};
var NoopSpanProto = {
  _tag: "Span",
  spanId: "noop",
  traceId: "noop",
  sampled: false,
  status: {
    _tag: "Ended",
    startTime: /* @__PURE__ */ BigInt(0),
    endTime: /* @__PURE__ */ BigInt(0),
    exit: exitVoid
  },
  attributes: /* @__PURE__ */ new Map,
  links: [],
  kind: "internal",
  attribute() {},
  event() {},
  end() {},
  addLinks() {}
};
var noopSpan = (options) => Object.assign(Object.create(NoopSpanProto), options);

// node_modules/effect/dist/esm/Deferred.js
var make18 = deferredMake;
var _await = deferredAwait;
var done2 = deferredDone;
var fail3 = deferredFail;
var failCause2 = deferredFailCause;
var interrupt3 = deferredInterrupt;
var isDone = deferredIsDone;
var poll = deferredPoll;
var succeed2 = deferredSucceed;
var unsafeMake4 = deferredUnsafeMake;
var unsafeDone = deferredUnsafeDone;

// node_modules/effect/dist/esm/Exit.js
var isExit = exitIsExit;
var isFailure = exitIsFailure;
var isSuccess = exitIsSuccess;
var all = exitCollectAll;
var die3 = exitDie;
var fail4 = exitFail;
var failCause3 = exitFailCause;
var flatten7 = exitFlatten;
var interrupt4 = exitInterrupt;
var map11 = exitMap;
var mapBoth2 = exitMapBoth;
var match6 = exitMatch;
var succeed3 = exitSucceed;
var void_2 = exitVoid;
var zip3 = exitZip;
var zipRight2 = exitZipRight;

// node_modules/effect/dist/esm/MutableHashMap.js
var TypeId8 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
var MutableHashMapProto = {
  [TypeId8]: TypeId8,
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};

class MutableHashMapIterator {
  self;
  referentialIterator;
  bucketIterator;
  constructor(self2) {
    this.self = self2;
    this.referentialIterator = self2.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== undefined) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this.self);
  }
}

class BucketIterator {
  backing;
  constructor(backing) {
    this.backing = backing;
  }
  currentBucket;
  next() {
    if (this.currentBucket === undefined) {
      const result2 = this.backing.next();
      if (result2.done) {
        return result2;
      }
      this.currentBucket = result2.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = undefined;
      return this.next();
    }
    return result;
  }
}
var empty17 = () => {
  const self2 = Object.create(MutableHashMapProto);
  self2.referential = new Map;
  self2.buckets = new Map;
  self2.bucketsSize = 0;
  return self2;
};
var get8 = /* @__PURE__ */ dual(2, (self2, key) => {
  if (isEqual(key) === false) {
    return self2.referential.has(key) ? some2(self2.referential.get(key)) : none2();
  }
  const hash2 = key[symbol]();
  const bucket = self2.buckets.get(hash2);
  if (bucket === undefined) {
    return none2();
  }
  return getFromBucket(self2, bucket, key);
});
var getFromBucket = (self2, bucket, key, remove5 = false) => {
  for (let i = 0, len = bucket.length;i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      const value = bucket[i][1];
      if (remove5) {
        bucket.splice(i, 1);
        self2.bucketsSize--;
      }
      return some2(value);
    }
  }
  return none2();
};
var has4 = /* @__PURE__ */ dual(2, (self2, key) => isSome2(get8(self2, key)));
var set4 = /* @__PURE__ */ dual(3, (self2, key, value) => {
  if (isEqual(key) === false) {
    self2.referential.set(key, value);
    return self2;
  }
  const hash2 = key[symbol]();
  const bucket = self2.buckets.get(hash2);
  if (bucket === undefined) {
    self2.buckets.set(hash2, [[key, value]]);
    self2.bucketsSize++;
    return self2;
  }
  removeFromBucket(self2, bucket, key);
  bucket.push([key, value]);
  self2.bucketsSize++;
  return self2;
});
var removeFromBucket = (self2, bucket, key) => {
  for (let i = 0, len = bucket.length;i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      bucket.splice(i, 1);
      self2.bucketsSize--;
      return;
    }
  }
};
var remove5 = /* @__PURE__ */ dual(2, (self2, key) => {
  if (isEqual(key) === false) {
    self2.referential.delete(key);
    return self2;
  }
  const hash2 = key[symbol]();
  const bucket = self2.buckets.get(hash2);
  if (bucket === undefined) {
    return self2;
  }
  removeFromBucket(self2, bucket, key);
  if (bucket.length === 0) {
    self2.buckets.delete(hash2);
  }
  return self2;
});
var size4 = (self2) => {
  return self2.referential.size + self2.bucketsSize;
};

// node_modules/effect/dist/esm/MutableList.js
var TypeId9 = /* @__PURE__ */ Symbol.for("effect/MutableList");
var MutableListProto = {
  [TypeId9]: TypeId9,
  [Symbol.iterator]() {
    let done3 = false;
    let head3 = this.head;
    return {
      next() {
        if (done3) {
          return this.return();
        }
        if (head3 == null) {
          done3 = true;
          return this.return();
        }
        const value = head3.value;
        head3 = head3.next;
        return {
          done: done3,
          value
        };
      },
      return(value) {
        if (!done3) {
          done3 = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeNode = (value) => ({
  value,
  removed: false,
  prev: undefined,
  next: undefined
});
var empty18 = () => {
  const list = Object.create(MutableListProto);
  list.head = undefined;
  list.tail = undefined;
  list._length = 0;
  return list;
};
var isEmpty6 = (self2) => length(self2) === 0;
var length = (self2) => self2._length;
var append3 = /* @__PURE__ */ dual(2, (self2, value) => {
  const node = makeNode(value);
  if (self2.head === undefined) {
    self2.head = node;
  }
  if (self2.tail === undefined) {
    self2.tail = node;
  } else {
    self2.tail.next = node;
    node.prev = self2.tail;
    self2.tail = node;
  }
  self2._length += 1;
  return self2;
});
var shift = (self2) => {
  const head3 = self2.head;
  if (head3 !== undefined) {
    remove6(self2, head3);
    return head3.value;
  }
  return;
};
var remove6 = (self2, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== undefined && node.next !== undefined) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== undefined) {
    self2.tail = node.prev;
    node.prev.next = undefined;
  } else if (node.next !== undefined) {
    self2.head = node.next;
    node.next.prev = undefined;
  } else {
    self2.tail = undefined;
    self2.head = undefined;
  }
  if (self2._length > 0) {
    self2._length -= 1;
  }
};

// node_modules/effect/dist/esm/MutableQueue.js
var TypeId10 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
var EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
var MutableQueueProto = {
  [TypeId10]: TypeId10,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make19 = (capacity) => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = empty18();
  queue.capacity = capacity;
  return queue;
};
var bounded = (capacity) => make19(capacity);
var unbounded = () => make19(undefined);
var length2 = (self2) => length(self2.queue);
var isEmpty7 = (self2) => isEmpty6(self2.queue);
var capacity = (self2) => self2.capacity === undefined ? Infinity : self2.capacity;
var offer = /* @__PURE__ */ dual(2, (self2, value) => {
  const queueLength = length(self2.queue);
  if (self2.capacity !== undefined && queueLength === self2.capacity) {
    return false;
  }
  append3(value)(self2.queue);
  return true;
});
var offerAll = /* @__PURE__ */ dual(2, (self2, values3) => {
  const iterator = values3[Symbol.iterator]();
  let next;
  let remainder = empty4();
  let offering = true;
  while (offering && (next = iterator.next()) && !next.done) {
    offering = offer(next.value)(self2);
  }
  while (next != null && !next.done) {
    remainder = prepend2(next.value)(remainder);
    next = iterator.next();
  }
  return reverse2(remainder);
});
var poll2 = /* @__PURE__ */ dual(2, (self2, def) => {
  if (isEmpty6(self2.queue)) {
    return def;
  }
  return shift(self2.queue);
});
var pollUpTo = /* @__PURE__ */ dual(2, (self2, n) => {
  let result = empty4();
  let count = 0;
  while (count < n) {
    const element = poll2(EmptyMutableQueue)(self2);
    if (element === EmptyMutableQueue) {
      break;
    }
    result = prepend2(element)(result);
    count += 1;
  }
  return reverse2(result);
});

// node_modules/effect/dist/esm/internal/clock.js
var ClockSymbolKey = "effect/Clock";
var ClockTypeId = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
var clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
var MAX_TIMER_MILLIS = 2 ** 31 - 1;
var globalClockScheduler = {
  unsafeSchedule(task, duration) {
    const millis2 = toMillis(duration);
    if (millis2 > MAX_TIMER_MILLIS) {
      return constFalse;
    }
    let completed = false;
    const handle = setTimeout(() => {
      completed = true;
      task();
    }, millis2);
    return () => {
      clearTimeout(handle);
      return !completed;
    };
  }
};
var performanceNowNanos = /* @__PURE__ */ function() {
  const bigint1e62 = /* @__PURE__ */ BigInt(1e6);
  if (typeof performance === "undefined") {
    return () => BigInt(Date.now()) * bigint1e62;
  }
  let origin;
  return () => {
    if (origin === undefined) {
      origin = BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
    }
    return origin + BigInt(Math.round(performance.now() * 1e6));
  };
}();
var processOrPerformanceNow = /* @__PURE__ */ function() {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : undefined;
  if (!processHrtime) {
    return performanceNowNanos;
  }
  const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
  return () => origin + processHrtime.bigint();
}();

class ClockImpl {
  [ClockTypeId] = ClockTypeId;
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow();
  }
  currentTimeMillis = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeMillis());
  currentTimeNanos = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeNanos());
  scheduler() {
    return succeed(globalClockScheduler);
  }
  sleep(duration) {
    return async_((resume) => {
      const canceler = globalClockScheduler.unsafeSchedule(() => resume(void_), duration);
      return asVoid(sync(canceler));
    });
  }
}
var make20 = () => new ClockImpl;

// node_modules/effect/dist/esm/internal/opCodes/configError.js
var OP_AND = "And";
var OP_OR = "Or";
var OP_INVALID_DATA = "InvalidData";
var OP_MISSING_DATA = "MissingData";
var OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
var OP_UNSUPPORTED = "Unsupported";

// node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey = "effect/ConfigError";
var ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
var proto2 = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
var And = (self2, that) => {
  const error = Object.create(proto2);
  error._op = OP_AND;
  error.left = self2;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  Object.defineProperty(error, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error;
};
var Or = (self2, that) => {
  const error = Object.create(proto2);
  error._op = OP_OR;
  error.left = self2;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  Object.defineProperty(error, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error;
};
var InvalidData = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_INVALID_DATA;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Invalid data at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var MissingData = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_MISSING_DATA;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Missing data at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var SourceUnavailable = (path, message, cause, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_SOURCE_UNAVAILABLE;
  error.path = path;
  error.message = message;
  error.cause = cause;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Source unavailable at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var Unsupported = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_UNSUPPORTED;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Unsupported operation at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var prefixed = /* @__PURE__ */ dual(2, (self2, prefix) => {
  switch (self2._op) {
    case OP_AND: {
      return And(prefixed(self2.left, prefix), prefixed(self2.right, prefix));
    }
    case OP_OR: {
      return Or(prefixed(self2.left, prefix), prefixed(self2.right, prefix));
    }
    case OP_INVALID_DATA: {
      return InvalidData([...prefix, ...self2.path], self2.message);
    }
    case OP_MISSING_DATA: {
      return MissingData([...prefix, ...self2.path], self2.message);
    }
    case OP_SOURCE_UNAVAILABLE: {
      return SourceUnavailable([...prefix, ...self2.path], self2.message, self2.cause);
    }
    case OP_UNSUPPORTED: {
      return Unsupported([...prefix, ...self2.path], self2.message);
    }
  }
});

// node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
var empty19 = {
  _tag: "Empty"
};
var patch5 = /* @__PURE__ */ dual(2, (path, patch6) => {
  let input = of3(patch6);
  let output = path;
  while (isCons(input)) {
    const patch7 = input.head;
    switch (patch7._tag) {
      case "Empty": {
        input = input.tail;
        break;
      }
      case "AndThen": {
        input = cons(patch7.first, cons(patch7.second, input.tail));
        break;
      }
      case "MapName": {
        output = map3(output, patch7.f);
        input = input.tail;
        break;
      }
      case "Nested": {
        output = prepend(output, patch7.name);
        input = input.tail;
        break;
      }
      case "Unnested": {
        const containsName = pipe(head(output), contains(patch7.name));
        if (containsName) {
          output = tailNonEmpty(output);
          input = input.tail;
        } else {
          return left2(MissingData(output, `Expected ${patch7.name} to be in path in ConfigProvider#unnested`));
        }
        break;
      }
    }
  }
  return right2(output);
});

// node_modules/effect/dist/esm/internal/opCodes/config.js
var OP_CONSTANT = "Constant";
var OP_FAIL2 = "Fail";
var OP_FALLBACK = "Fallback";
var OP_DESCRIBED = "Described";
var OP_LAZY = "Lazy";
var OP_MAP_OR_FAIL = "MapOrFail";
var OP_NESTED = "Nested";
var OP_PRIMITIVE = "Primitive";
var OP_SEQUENCE = "Sequence";
var OP_HASHMAP = "HashMap";
var OP_ZIP_WITH = "ZipWith";

// node_modules/effect/dist/esm/internal/configProvider.js
var concat = (l, r) => [...l, ...r];
var ConfigProviderSymbolKey = "effect/ConfigProvider";
var ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
var configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
var FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
var FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
var make22 = (options) => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var makeFlat = (options) => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options.patch,
  load: (path, config, split = true) => options.load(path, config, split),
  enumerateChildren: options.enumerateChildren
});
var fromFlat = (flat) => make22({
  load: (config) => flatMap8(fromFlatLoop(flat, empty(), config, false), (chunk) => match2(head(chunk), {
    onNone: () => fail2(MissingData(empty(), `Expected a single value having structure: ${config}`)),
    onSome: succeed
  })),
  flattened: flat
});
var fromEnv = (options) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options);
  const makePathString = (path) => pipe(path, join(pathDelim));
  const unmakePathString = (pathString) => pathString.split(pathDelim);
  const getEnv = () => typeof process !== "undefined" && ("env" in process) && typeof process.env === "object" ? process.env : {};
  const load = (path, primitive, split = true) => {
    const pathString = makePathString(path);
    const current = getEnv();
    const valueOpt = pathString in current ? some2(current[pathString]) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap8((value) => parsePrimitive(value, path, primitive, seqDelim, split)));
  };
  const enumerateChildren = (path) => sync(() => {
    const current = getEnv();
    const keys3 = Object.keys(current);
    const keyPaths = keys3.map((value) => unmakePathString(value.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0;i < path.length; i++) {
        const pathComponent = pipe(path, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === undefined || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
    return fromIterable5(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty19
  }));
};
var extend = (leftDef, rightDef, left3, right3) => {
  const leftPad = unfold(left3.length, (index) => index >= right3.length ? none2() : some2([leftDef(index), index + 1]));
  const rightPad = unfold(right3.length, (index) => index >= left3.length ? none2() : some2([rightDef(index), index + 1]));
  const leftExtension = concat(left3, leftPad);
  const rightExtension = concat(right3, rightPad);
  return [leftExtension, rightExtension];
};
var appendConfigPath = (path, config) => {
  let op = config;
  if (op._tag === "Nested") {
    const out = path.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path;
};
var fromFlatLoop = (flat, prefix, config, split) => {
  const op = config;
  switch (op._tag) {
    case OP_CONSTANT: {
      return succeed(of(op.value));
    }
    case OP_DESCRIBED: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config, split));
    }
    case OP_FAIL2: {
      return fail2(MissingData(prefix, op.message));
    }
    case OP_FALLBACK: {
      return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split)), catchAll((error1) => {
        if (op.condition(error1)) {
          return pipe(fromFlatLoop(flat, prefix, op.second, split), catchAll((error2) => fail2(Or(error1, error2))));
        }
        return fail2(error1);
      }));
    }
    case OP_LAZY: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config(), split));
    }
    case OP_MAP_OR_FAIL: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split), flatMap8(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
    }
    case OP_NESTED: {
      return suspend(() => fromFlatLoop(flat, concat(prefix, of(op.name)), op.config, split));
    }
    case OP_PRIMITIVE: {
      return pipe(patch5(prefix, flat.patch), flatMap8((prefix2) => pipe(flat.load(prefix2, op, split), flatMap8((values3) => {
        if (values3.length === 0) {
          const name = pipe(last(prefix2), getOrElse(() => "<n/a>"));
          return fail2(MissingData([], `Expected ${op.description} with name ${name}`));
        }
        return succeed(values3);
      }))));
    }
    case OP_SEQUENCE: {
      return pipe(patch5(prefix, flat.patch), flatMap8((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap8(indicesFrom), flatMap8((indices) => {
        if (indices.length === 0) {
          return suspend(() => map10(fromFlatLoop(flat, prefix, op.config, true), of));
        }
        return pipe(forEachSequential(indices, (index) => fromFlatLoop(flat, append(prefix, `[${index}]`), op.config, true)), map10((chunkChunk) => {
          const flattened = flatten(chunkChunk);
          if (flattened.length === 0) {
            return of(empty());
          }
          return of(flattened);
        }));
      }))));
    }
    case OP_HASHMAP: {
      return suspend(() => pipe(patch5(prefix, flat.patch), flatMap8((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap8((keys3) => {
        return pipe(keys3, forEachSequential((key) => fromFlatLoop(flat, concat(prefix2, of(key)), op.valueConfig, split)), map10((matrix) => {
          if (matrix.length === 0) {
            return of(empty8());
          }
          return pipe(transpose(matrix), map3((values3) => fromIterable6(zip(fromIterable(keys3), values3))));
        }));
      })))));
    }
    case OP_ZIP_WITH: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split), either2, flatMap8((left3) => pipe(fromFlatLoop(flat, prefix, op.right, split), either2, flatMap8((right3) => {
        if (isLeft2(left3) && isLeft2(right3)) {
          return fail2(And(left3.left, right3.left));
        }
        if (isLeft2(left3) && isRight2(right3)) {
          return fail2(left3.left);
        }
        if (isRight2(left3) && isLeft2(right3)) {
          return fail2(right3.left);
        }
        if (isRight2(left3) && isRight2(right3)) {
          const path = pipe(prefix, join("."));
          const fail5 = fromFlatLoopFail(prefix, path);
          const [lefts, rights] = extend(fail5, fail5, pipe(left3.right, map3(right2)), pipe(right3.right, map3(right2)));
          return pipe(lefts, zip(rights), forEachSequential(([left4, right4]) => pipe(zip2(left4, right4), map10(([left5, right5]) => op.zip(left5, right5)))));
        }
        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
      })))));
    }
  }
};
var fromFlatLoopFail = (prefix, path) => (index) => left2(MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`));
var splitPathString = (text, delim) => {
  const split = text.split(new RegExp(`\\s*${escape(delim)}\\s*`));
  return split;
};
var parsePrimitive = (text, path, primitive, delimiter, split) => {
  if (!split) {
    return pipe(primitive.parse(text), mapBoth({
      onFailure: prefixed(path),
      onSuccess: of
    }));
  }
  return pipe(splitPathString(text, delimiter), forEachSequential((char) => primitive.parse(char.trim())), mapError(prefixed(path)));
};
var transpose = (array3) => {
  return Object.keys(array3[0]).map((column) => array3.map((row) => row[column]));
};
var indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth({
  onFailure: () => empty(),
  onSuccess: sort(Order)
}), either2, map10(merge));
var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
var parseQuotedIndex = (str) => {
  const match7 = str.match(QUOTED_INDEX_REGEX);
  if (match7 !== null) {
    const matchedIndex = match7[2];
    return pipe(matchedIndex !== undefined && matchedIndex.length > 0 ? some2(matchedIndex) : none2(), flatMap(parseInteger));
  }
  return none2();
};
var parseInteger = (str) => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none2() : some2(parsedIndex);
};

// node_modules/effect/dist/esm/internal/defaultServices/console.js
var TypeId11 = /* @__PURE__ */ Symbol.for("effect/Console");
var consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
var defaultConsole = {
  [TypeId11]: TypeId11,
  assert(condition, ...args) {
    return sync(() => {
      console.assert(condition, ...args);
    });
  },
  clear: /* @__PURE__ */ sync(() => {
    console.clear();
  }),
  count(label) {
    return sync(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync(() => {
      console.countReset(label);
    });
  },
  debug(...args) {
    return sync(() => {
      console.debug(...args);
    });
  },
  dir(item, options) {
    return sync(() => {
      console.dir(item, options);
    });
  },
  dirxml(...args) {
    return sync(() => {
      console.dirxml(...args);
    });
  },
  error(...args) {
    return sync(() => {
      console.error(...args);
    });
  },
  group(options) {
    return options?.collapsed ? sync(() => console.groupCollapsed(options?.label)) : sync(() => console.group(options?.label));
  },
  groupEnd: /* @__PURE__ */ sync(() => {
    console.groupEnd();
  }),
  info(...args) {
    return sync(() => {
      console.info(...args);
    });
  },
  log(...args) {
    return sync(() => {
      console.log(...args);
    });
  },
  table(tabularData, properties) {
    return sync(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync(() => console.time(label));
  },
  timeEnd(label) {
    return sync(() => console.timeEnd(label));
  },
  timeLog(label, ...args) {
    return sync(() => {
      console.timeLog(label, ...args);
    });
  },
  trace(...args) {
    return sync(() => {
      console.trace(...args);
    });
  },
  warn(...args) {
    return sync(() => {
      console.warn(...args);
    });
  },
  unsafe: console
};

// node_modules/effect/dist/esm/internal/random.js
var RandomSymbolKey = "effect/Random";
var RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
var randomTag = /* @__PURE__ */ GenericTag("effect/Random");

class RandomImpl {
  seed;
  [RandomTypeId] = RandomTypeId;
  PRNG;
  constructor(seed) {
    this.seed = seed;
    this.PRNG = new PCGRandom(seed);
  }
  get next() {
    return sync(() => this.PRNG.number());
  }
  get nextBoolean() {
    return map10(this.next, (n) => n > 0.5);
  }
  get nextInt() {
    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min2, max2) {
    return map10(this.next, (n) => (max2 - min2) * n + min2);
  }
  nextIntBetween(min2, max2) {
    return sync(() => this.PRNG.integer(max2 - min2) + min2);
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
}
var shuffleWith = (elements, nextIntBounded) => {
  return suspend(() => pipe(sync(() => Array.from(elements)), flatMap8((buffer) => {
    const numbers = [];
    for (let i = buffer.length;i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map10((k) => swap(buffer, n - 1, k)))), as(fromIterable2(buffer)));
  })));
};
var swap = (buffer, index1, index2) => {
  const tmp = buffer[index1];
  buffer[index1] = buffer[index2];
  buffer[index2] = tmp;
  return buffer;
};
var make23 = (seed) => new RandomImpl(hash(seed));

class FixedRandomImpl {
  values;
  [RandomTypeId] = RandomTypeId;
  index = 0;
  constructor(values3) {
    this.values = values3;
    if (values3.length === 0) {
      throw new Error("Requires at least one value");
    }
  }
  getNextValue() {
    const value = this.values[this.index];
    this.index = (this.index + 1) % this.values.length;
    return value;
  }
  get next() {
    return sync(() => {
      const value = this.getNextValue();
      if (typeof value === "number") {
        return Math.max(0, Math.min(1, value));
      }
      return hash(value) / 2147483647;
    });
  }
  get nextBoolean() {
    return sync(() => {
      const value = this.getNextValue();
      if (typeof value === "boolean") {
        return value;
      }
      return hash(value) % 2 === 0;
    });
  }
  get nextInt() {
    return sync(() => {
      const value = this.getNextValue();
      if (typeof value === "number" && Number.isFinite(value)) {
        return Math.round(value);
      }
      return Math.abs(hash(value));
    });
  }
  nextRange(min2, max2) {
    return map10(this.next, (n) => (max2 - min2) * n + min2);
  }
  nextIntBetween(min2, max2) {
    return sync(() => {
      const value = this.getNextValue();
      if (typeof value === "number" && Number.isFinite(value)) {
        return Math.max(min2, Math.min(max2 - 1, Math.round(value)));
      }
      const hash2 = Math.abs(hash(value));
      return min2 + hash2 % (max2 - min2);
    });
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
}
var fixed = (values3) => new FixedRandomImpl(values3);

// node_modules/effect/dist/esm/internal/tracer.js
var TracerTypeId = /* @__PURE__ */ Symbol.for("effect/Tracer");
var make24 = (options) => ({
  [TracerTypeId]: TracerTypeId,
  ...options
});
var tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
var spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
var randomHexString = /* @__PURE__ */ function() {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function(length3) {
    let result = "";
    for (let i = 0;i < length3; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
}();

class NativeSpan {
  name;
  parent;
  context;
  startTime;
  kind;
  _tag = "Span";
  spanId;
  traceId = "native";
  sampled = true;
  status;
  attributes;
  events = [];
  links;
  constructor(name, parent, context2, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context2;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = new Map;
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
    this.links = Array.from(links);
  }
  end(endTime, exit2) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit2,
      startTime: this.status.startTime
    };
  }
  attribute(key, value) {
    this.attributes.set(key, value);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
  addLinks(links) {
    this.links.push(...links);
  }
}
var nativeTracer = /* @__PURE__ */ make24({
  span: (name, parent, context2, links, startTime, kind) => new NativeSpan(name, parent, context2, links, startTime, kind),
  context: (f) => f()
});
var addSpanStackTrace = (options) => {
  if (options?.captureStackTrace === false) {
    return options;
  } else if (options?.captureStackTrace !== undefined && typeof options.captureStackTrace !== "boolean") {
    return options;
  }
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 3;
  const traceError = new Error;
  Error.stackTraceLimit = limit;
  let cache = false;
  return {
    ...options,
    captureStackTrace: () => {
      if (cache !== false) {
        return cache;
      }
      if (traceError.stack !== undefined) {
        const stack = traceError.stack.split(`
`);
        if (stack[3] !== undefined) {
          cache = stack[3].trim();
          return cache;
        }
      }
    }
  };
};
var DisablePropagation = /* @__PURE__ */ Reference2()("effect/Tracer/DisablePropagation", {
  defaultValue: constFalse
});

// node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty3(), /* @__PURE__ */ add2(clockTag, /* @__PURE__ */ make20()), /* @__PURE__ */ add2(consoleTag, defaultConsole), /* @__PURE__ */ add2(randomTag, /* @__PURE__ */ make23(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add2(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add2(tracerTag, nativeTracer));
var currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
var sleep = (duration) => {
  const decodedDuration = decode(duration);
  return clockWith((clock) => clock.sleep(decodedDuration));
};
var defaultServicesWith = (f) => withFiberRuntime((fiber) => f(fiber.currentDefaultServices));
var clockWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key)));
var currentTimeMillis = /* @__PURE__ */ clockWith((clock) => clock.currentTimeMillis);
var currentTimeNanos = /* @__PURE__ */ clockWith((clock) => clock.currentTimeNanos);
var withClock = /* @__PURE__ */ dual(2, (effect, c) => fiberRefLocallyWith(currentServices, add2(clockTag, c))(effect));
var withConfigProvider = /* @__PURE__ */ dual(2, (self2, provider) => fiberRefLocallyWith(currentServices, add2(configProviderTag, provider))(self2));
var configProviderWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(configProviderTag.key)));
var randomWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(randomTag.key)));
var withRandom = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add2(randomTag, value))(effect));
var tracerWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(tracerTag.key)));
var withTracer = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add2(tracerTag, value))(effect));

// node_modules/effect/dist/esm/Clock.js
var sleep2 = sleep;
var currentTimeMillis2 = currentTimeMillis;
var currentTimeNanos2 = currentTimeNanos;
var clockWith2 = clockWith;
var Clock = clockTag;

// node_modules/effect/dist/esm/internal/fiberRefs.js
function unsafeMake5(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
function empty20() {
  return unsafeMake5(new Map);
}
var FiberRefsSym = /* @__PURE__ */ Symbol.for("effect/FiberRefs");

class FiberRefsImpl {
  locals;
  [FiberRefsSym] = FiberRefsSym;
  constructor(locals) {
    this.locals = locals;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = undefined;
  while (ret === undefined) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty(parentStack)[0];
      const parentAncestors = tailNonEmpty(parentStack);
      const childFiberId = headNonEmpty(childStack)[0];
      const childRefValue = headNonEmpty(childStack)[1];
      const childAncestors = tailNonEmpty(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
};
var joinAs = /* @__PURE__ */ dual(3, (self2, fiberId2, that) => {
  const parentFiberRefs = new Map(self2.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][symbol2](fiberId2)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId2, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch6 = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch6)(oldValue));
        if (!equals(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[symbol2](fiberId2)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId2, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
var forkAs = /* @__PURE__ */ dual(2, (self2, childId) => {
  const map12 = new Map;
  unsafeForkAs(self2, map12, childId);
  return new FiberRefsImpl(map12);
});
var unsafeForkAs = (self2, map12, fiberId2) => {
  self2.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals(oldValue, newValue)) {
      map12.set(fiberRef, stack);
    } else {
      map12.set(fiberRef, [[fiberId2, newValue], ...stack]);
    }
  });
};
var fiberRefs = (self2) => fromIterable5(self2.locals.keys());
var setAll = (self2) => forEachSequentialDiscard(fiberRefs(self2), (fiberRef) => fiberRefSet(fiberRef, getOrDefault(self2, fiberRef)));
var delete_ = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
  const locals = new Map(self2.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl(locals);
});
var get9 = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
  if (!self2.locals.has(fiberRef)) {
    return none2();
  }
  return some2(headNonEmpty(self2.locals.get(fiberRef))[1]);
});
var getOrDefault = /* @__PURE__ */ dual(2, (self2, fiberRef) => pipe(get9(self2, fiberRef), getOrElse(() => fiberRef.initial)));
var updateAs = /* @__PURE__ */ dual(2, (self2, {
  fiberId: fiberId2,
  fiberRef,
  value
}) => {
  if (self2.locals.size === 0) {
    return new FiberRefsImpl(new Map([[fiberRef, [[fiberId2, value]]]]));
  }
  const locals = new Map(self2.locals);
  unsafeUpdateAs(locals, fiberId2, fiberRef, value);
  return new FiberRefsImpl(locals);
});
var unsafeUpdateAs = (locals, fiberId2, fiberRef, value) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty(oldStack);
    if (currentId[symbol2](fiberId2)) {
      if (equals(currentValue, value)) {
        return;
      } else {
        newStack = [[fiberId2, value], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId2, value], ...oldStack];
    }
  } else {
    newStack = [[fiberId2, value]];
  }
  locals.set(fiberRef, newStack);
};
var updateManyAs = /* @__PURE__ */ dual(2, (self2, {
  entries: entries2,
  forkAs: forkAs2
}) => {
  if (self2.locals.size === 0) {
    return new FiberRefsImpl(new Map(entries2));
  }
  const locals = new Map(self2.locals);
  if (forkAs2 !== undefined) {
    unsafeForkAs(self2, locals, forkAs2);
  }
  entries2.forEach(([fiberRef, values3]) => {
    if (values3.length === 1) {
      unsafeUpdateAs(locals, values3[0][0], fiberRef, values3[0][1]);
    } else {
      values3.forEach(([fiberId2, value]) => {
        unsafeUpdateAs(locals, fiberId2, fiberRef, value);
      });
    }
  });
  return new FiberRefsImpl(locals);
});

// node_modules/effect/dist/esm/FiberRefs.js
var get10 = get9;
var getOrDefault2 = getOrDefault;
var joinAs2 = joinAs;
var setAll2 = setAll;
var updateManyAs2 = updateManyAs;
var empty21 = empty20;

// node_modules/effect/dist/esm/LogLevel.js
var All = logLevelAll;
var Fatal = logLevelFatal;
var Error2 = logLevelError;
var Warning = logLevelWarning;
var Info = logLevelInfo;
var Debug = logLevelDebug;
var Trace = logLevelTrace;
var None3 = logLevelNone;
var Order2 = /* @__PURE__ */ pipe(Order, /* @__PURE__ */ mapInput2((level) => level.ordinal));
var greaterThan3 = /* @__PURE__ */ greaterThan(Order2);
var fromLiteral = (literal) => {
  switch (literal) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return Error2;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return None3;
    case "Warning":
      return Warning;
  }
};

// node_modules/effect/dist/esm/internal/logSpan.js
var make25 = (label, startTime) => ({
  label,
  startTime
});
var formatLabel = (key) => key.replace(/[\s="]/g, "_");
var render = (now) => (self2) => {
  const label = formatLabel(self2.label);
  return `${label}=${now - self2.startTime}ms`;
};

// node_modules/effect/dist/esm/LogSpan.js
var make26 = make25;

// node_modules/effect/dist/esm/Ref.js
var exports_Ref = {};
__export(exports_Ref, {
  updateSomeAndGet: () => updateSomeAndGet2,
  updateSome: () => updateSome2,
  updateAndGet: () => updateAndGet2,
  update: () => update3,
  unsafeMake: () => unsafeMake7,
  setAndGet: () => setAndGet2,
  set: () => set6,
  modifySome: () => modifySome2,
  modify: () => modify4,
  make: () => make28,
  getAndUpdateSome: () => getAndUpdateSome2,
  getAndUpdate: () => getAndUpdate2,
  getAndSet: () => getAndSet2,
  get: () => get12,
  RefTypeId: () => RefTypeId2
});

// node_modules/effect/dist/esm/Effectable.js
var EffectPrototype2 = EffectPrototype;
var CommitPrototype2 = CommitPrototype;
var Base2 = Base;
class Class extends Base2 {
}

// node_modules/effect/dist/esm/Readable.js
var TypeId12 = /* @__PURE__ */ Symbol.for("effect/Readable");
var Proto = {
  [TypeId12]: TypeId12,
  pipe() {
    return pipeArguments(this, arguments);
  }
};

// node_modules/effect/dist/esm/internal/ref.js
var RefTypeId = /* @__PURE__ */ Symbol.for("effect/Ref");
var refVariance = {
  _A: (_) => _
};

class RefImpl extends Class {
  ref;
  commit() {
    return this.get;
  }
  [RefTypeId] = refVariance;
  [TypeId12] = TypeId12;
  constructor(ref) {
    super();
    this.ref = ref;
    this.get = sync(() => get6(this.ref));
  }
  get;
  modify(f) {
    return sync(() => {
      const current = get6(this.ref);
      const [b, a] = f(current);
      if (current !== a) {
        set2(a)(this.ref);
      }
      return b;
    });
  }
}
var unsafeMake6 = (value) => new RefImpl(make11(value));
var make27 = (value) => sync(() => unsafeMake6(value));
var get11 = (self2) => self2.get;
var set5 = /* @__PURE__ */ dual(2, (self2, value) => self2.modify(() => [undefined, value]));
var getAndSet = /* @__PURE__ */ dual(2, (self2, value) => self2.modify((a) => [a, value]));
var getAndUpdate = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [a, f(a)]));
var getAndUpdateSome = /* @__PURE__ */ dual(2, (self2, pf) => self2.modify((value) => {
  const option = pf(value);
  switch (option._tag) {
    case "None": {
      return [value, value];
    }
    case "Some": {
      return [value, option.value];
    }
  }
}));
var setAndGet = /* @__PURE__ */ dual(2, (self2, value) => self2.modify(() => [value, value]));
var modify3 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify(f));
var modifySome = /* @__PURE__ */ dual(3, (self2, fallback, pf) => self2.modify((value) => {
  const option = pf(value);
  switch (option._tag) {
    case "None": {
      return [fallback, value];
    }
    case "Some": {
      return option.value;
    }
  }
}));
var update2 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [undefined, f(a)]));
var updateAndGet = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => {
  const result = f(a);
  return [result, result];
}));
var updateSome = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [undefined, match2(f(a), {
  onNone: () => a,
  onSome: (b) => b
})]));
var updateSomeAndGet = /* @__PURE__ */ dual(2, (self2, pf) => self2.modify((value) => {
  const option = pf(value);
  switch (option._tag) {
    case "None": {
      return [value, value];
    }
    case "Some": {
      return [option.value, option.value];
    }
  }
}));

// node_modules/effect/dist/esm/Ref.js
var RefTypeId2 = RefTypeId;
var make28 = make27;
var get12 = get11;
var getAndSet2 = getAndSet;
var getAndUpdate2 = getAndUpdate;
var getAndUpdateSome2 = getAndUpdateSome;
var modify4 = modify3;
var modifySome2 = modifySome;
var set6 = set5;
var setAndGet2 = setAndGet;
var update3 = update2;
var updateAndGet2 = updateAndGet;
var updateSome2 = updateSome;
var updateSomeAndGet2 = updateSomeAndGet;
var unsafeMake7 = unsafeMake6;

// node_modules/effect/dist/esm/Tracer.js
var tracerWith2 = tracerWith;

// node_modules/effect/dist/esm/internal/fiberRefs/patch.js
var OP_EMPTY2 = "Empty";
var OP_ADD = "Add";
var OP_REMOVE = "Remove";
var OP_UPDATE = "Update";
var OP_AND_THEN = "AndThen";
var empty22 = {
  _tag: OP_EMPTY2
};
var diff5 = (oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch6 = empty22;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue2 = headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== undefined) {
      const oldValue2 = headNonEmpty(old)[1];
      if (!equals(oldValue2, newValue2)) {
        patch6 = combine7({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue2, newValue2)
        })(patch6);
      }
    } else {
      patch6 = combine7({
        _tag: OP_ADD,
        fiberRef,
        value: newValue2
      })(patch6);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch6 = combine7({
      _tag: OP_REMOVE,
      fiberRef
    })(patch6);
  }
  return patch6;
};
var combine7 = /* @__PURE__ */ dual(2, (self2, that) => ({
  _tag: OP_AND_THEN,
  first: self2,
  second: that
}));
var patch6 = /* @__PURE__ */ dual(3, (self2, fiberId2, oldValue) => {
  let fiberRefs2 = oldValue;
  let patches = of(self2);
  while (isNonEmptyReadonlyArray(patches)) {
    const head3 = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head3._tag) {
      case OP_EMPTY2: {
        patches = tail;
        break;
      }
      case OP_ADD: {
        fiberRefs2 = updateAs(fiberRefs2, {
          fiberId: fiberId2,
          fiberRef: head3.fiberRef,
          value: head3.value
        });
        patches = tail;
        break;
      }
      case OP_REMOVE: {
        fiberRefs2 = delete_(fiberRefs2, head3.fiberRef);
        patches = tail;
        break;
      }
      case OP_UPDATE: {
        const value = getOrDefault(fiberRefs2, head3.fiberRef);
        fiberRefs2 = updateAs(fiberRefs2, {
          fiberId: fiberId2,
          fiberRef: head3.fiberRef,
          value: head3.fiberRef.patch(head3.patch)(value)
        });
        patches = tail;
        break;
      }
      case OP_AND_THEN: {
        patches = prepend(head3.first)(prepend(head3.second)(tail));
        break;
      }
    }
  }
  return fiberRefs2;
});

// node_modules/effect/dist/esm/internal/metric/label.js
var MetricLabelSymbolKey = "effect/MetricLabel";
var MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);

class MetricLabelImpl {
  key;
  value;
  [MetricLabelTypeId] = MetricLabelTypeId;
  _hash;
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this._hash = string(MetricLabelSymbolKey + this.key + this.value);
  }
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var make29 = (key, value) => {
  return new MetricLabelImpl(key, value);
};
var isMetricLabel = (u) => hasProperty(u, MetricLabelTypeId);

// node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs = /* @__PURE__ */ dual((args) => isEffect(args[0]), function() {
  const args = arguments;
  return fiberRefLocallyWith(args[0], currentLogAnnotations, typeof args[1] === "string" ? set3(args[1], args[2]) : (annotations2) => Object.entries(args[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
});
var asSome = (self2) => map10(self2, some2);
var asSomeError = (self2) => mapError(self2, some2);
var try_ = (arg) => {
  let evaluate;
  let onFailure = undefined;
  if (typeof arg === "function") {
    evaluate = arg;
  } else {
    evaluate = arg.try;
    onFailure = arg.catch;
  }
  return suspend(() => {
    try {
      return succeed(internalCall(evaluate));
    } catch (error) {
      return fail2(onFailure ? internalCall(() => onFailure(error)) : new UnknownException(error, "An unknown error occurred in Effect.try"));
    }
  });
};
var _catch = /* @__PURE__ */ dual(3, (self2, tag, options) => catchAll(self2, (e) => {
  if (hasProperty(e, tag) && e[tag] === options.failure) {
    return options.onFailure(e);
  }
  return fail2(e);
}));
var catchAllDefect = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause(self2, (cause) => {
  const option = find(cause, (_) => isDieType(_) ? some2(_) : none2());
  switch (option._tag) {
    case "None": {
      return failCause(cause);
    }
    case "Some": {
      return f(option.value.defect);
    }
  }
}));
var catchSomeCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause) => {
    const option = f(cause);
    switch (option._tag) {
      case "None": {
        return failCause(cause);
      }
      case "Some": {
        return option.value;
      }
    }
  },
  onSuccess: succeed
}));
var catchSomeDefect = /* @__PURE__ */ dual(2, (self2, pf) => catchAllCause(self2, (cause) => {
  const option = find(cause, (_) => isDieType(_) ? some2(_) : none2());
  switch (option._tag) {
    case "None": {
      return failCause(cause);
    }
    case "Some": {
      const optionEffect = pf(option.value.defect);
      return optionEffect._tag === "Some" ? optionEffect.value : failCause(cause);
    }
  }
}));
var catchTag = /* @__PURE__ */ dual((args) => isEffect(args[0]), (self2, ...args) => {
  const f = args[args.length - 1];
  let predicate;
  if (args.length === 2) {
    predicate = isTagged(args[0]);
  } else {
    predicate = (e) => {
      const tag = hasProperty(e, "_tag") ? e["_tag"] : undefined;
      if (!tag)
        return false;
      for (let i = 0;i < args.length - 1; i++) {
        if (args[i] === tag)
          return true;
      }
      return false;
    };
  }
  return catchIf(self2, predicate, f);
});
var catchTags = /* @__PURE__ */ dual(2, (self2, cases) => {
  let keys3;
  return catchIf(self2, (e) => {
    keys3 ??= Object.keys(cases);
    return hasProperty(e, "_tag") && isString(e["_tag"]) && keys3.includes(e["_tag"]);
  }, (e) => cases[e["_tag"]](e));
});
var cause = (self2) => matchCause(self2, {
  onFailure: identity,
  onSuccess: () => empty16
});
var clockWith3 = clockWith2;
var clock = /* @__PURE__ */ clockWith3(succeed);
var delay = /* @__PURE__ */ dual(2, (self2, duration) => zipRight(sleep2(duration), self2));
var descriptorWith = (f) => withFiberRuntime((state, status) => f({
  id: state.id(),
  status,
  interruptors: interruptors(state.getFiberRef(currentInterruptedCause))
}));
var allowInterrupt = /* @__PURE__ */ descriptorWith((descriptor) => size3(descriptor.interruptors) > 0 ? interrupt2 : void_);
var descriptor = /* @__PURE__ */ descriptorWith(succeed);
var diffFiberRefs = (self2) => summarized(self2, fiberRefs2, diff5);
var diffFiberRefsAndRuntimeFlags = (self2) => summarized(self2, zip2(fiberRefs2, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff5(refs, refsNew), diff4(flags, flagsNew)]);
var Do = /* @__PURE__ */ succeed({});
var bind2 = /* @__PURE__ */ bind(map10, flatMap8);
var bindTo2 = /* @__PURE__ */ bindTo(map10);
var let_2 = /* @__PURE__ */ let_(map10);
var dropUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let dropping = succeed(false);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    dropping = flatMap8(dropping, (bool) => {
      if (bool) {
        builder.push(a);
        return succeed(true);
      }
      return predicate(a, index);
    });
  }
  return map10(dropping, () => builder);
}));
var dropWhile2 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let dropping = succeed(true);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    dropping = flatMap8(dropping, (d) => map10(d ? predicate(a, index) : succeed(false), (b) => {
      if (!b) {
        builder.push(a);
      }
      return b;
    }));
  }
  return map10(dropping, () => builder);
}));
var contextWith = (f) => map10(context(), f);
var eventually = (self2) => orElse2(self2, () => flatMap8(yieldNow(), () => eventually(self2)));
var filterMap4 = /* @__PURE__ */ dual(2, (elements, pf) => map10(forEachSequential(elements, identity), filterMap(pf)));
var filterOrDie = /* @__PURE__ */ dual(3, (self2, predicate, orDieWith2) => filterOrElse(self2, predicate, (a) => dieSync(() => orDieWith2(a))));
var filterOrDieMessage = /* @__PURE__ */ dual(3, (self2, predicate, message) => filterOrElse(self2, predicate, () => dieMessage(message)));
var filterOrElse = /* @__PURE__ */ dual(3, (self2, predicate, orElse3) => flatMap8(self2, (a) => predicate(a) ? succeed(a) : orElse3(a)));
var liftPredicate = /* @__PURE__ */ dual(3, (self2, predicate, orFailWith) => suspend(() => predicate(self2) ? succeed(self2) : fail2(orFailWith(self2))));
var filterOrFail = /* @__PURE__ */ dual((args) => isEffect(args[0]), (self2, predicate, orFailWith) => filterOrElse(self2, predicate, (a) => orFailWith === undefined ? fail2(new NoSuchElementException) : failSync(() => orFailWith(a))));
var findFirst5 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const next = iterator.next();
  if (!next.done) {
    return findLoop(iterator, 0, predicate, next.value);
  }
  return succeed(none2());
}));
var findLoop = (iterator, index, f, value) => flatMap8(f(value, index), (result) => {
  if (result) {
    return succeed(some2(value));
  }
  const next = iterator.next();
  if (!next.done) {
    return findLoop(iterator, index + 1, f, next.value);
  }
  return succeed(none2());
});
var firstSuccessOf = (effects) => suspend(() => {
  const list = fromIterable2(effects);
  if (!isNonEmpty2(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  return pipe(tailNonEmpty2(list), reduce(headNonEmpty2(list), (left3, right3) => orElse2(left3, () => right3)));
});
var flipWith = /* @__PURE__ */ dual(2, (self2, f) => flip(f(flip(self2))));
var match7 = /* @__PURE__ */ dual(2, (self2, options) => matchEffect(self2, {
  onFailure: (e) => succeed(options.onFailure(e)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var every5 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));
var forAllLoop = (iterator, index, f) => {
  const next = iterator.next();
  return next.done ? succeed(true) : flatMap8(f(next.value, index), (b) => b ? forAllLoop(iterator, index + 1, f) : succeed(b));
};
var forever = (self2) => {
  const loop = flatMap8(flatMap8(self2, () => yieldNow()), () => loop);
  return loop;
};
var fiberRefs2 = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.getFiberRefs()));
var head3 = (self2) => flatMap8(self2, (as2) => {
  const iterator = as2[Symbol.iterator]();
  const next = iterator.next();
  if (next.done) {
    return fail2(new NoSuchElementException);
  }
  return succeed(next.value);
});
var ignore = (self2) => match7(self2, {
  onFailure: constVoid,
  onSuccess: constVoid
});
var ignoreLogged = (self2) => matchCauseEffect(self2, {
  onFailure: (cause2) => logDebug(cause2, "An error was silently ignored because it is not anticipated to be useful"),
  onSuccess: () => void_
});
var inheritFiberRefs = (childFiberRefs) => updateFiberRefs((parentFiberId, parentFiberRefs) => joinAs2(parentFiberRefs, parentFiberId, childFiberRefs));
var isFailure2 = (self2) => match7(self2, {
  onFailure: constTrue,
  onSuccess: constFalse
});
var isSuccess2 = (self2) => match7(self2, {
  onFailure: constFalse,
  onSuccess: constTrue
});
var iterate = (initial, options) => suspend(() => {
  if (options.while(initial)) {
    return flatMap8(options.body(initial), (z2) => iterate(z2, options));
  }
  return succeed(initial);
});
var logWithLevel = (level) => (...message) => {
  const levelOption = fromNullable(level);
  let cause2 = undefined;
  for (let i = 0, len = message.length;i < len; i++) {
    const msg = message[i];
    if (isCause(msg)) {
      if (cause2 !== undefined) {
        cause2 = sequential(cause2, msg);
      } else {
        cause2 = msg;
      }
      message = [...message.slice(0, i), ...message.slice(i + 1)];
      i--;
    }
  }
  if (cause2 === undefined) {
    cause2 = empty16;
  }
  return withFiberRuntime((fiberState) => {
    fiberState.log(message, cause2, levelOption);
    return void_;
  });
};
var log = /* @__PURE__ */ logWithLevel();
var logTrace = /* @__PURE__ */ logWithLevel(Trace);
var logDebug = /* @__PURE__ */ logWithLevel(Debug);
var logInfo = /* @__PURE__ */ logWithLevel(Info);
var logWarning = /* @__PURE__ */ logWithLevel(Warning);
var logError = /* @__PURE__ */ logWithLevel(Error2);
var logFatal = /* @__PURE__ */ logWithLevel(Fatal);
var withLogSpan = /* @__PURE__ */ dual(2, (effect, label) => flatMap8(currentTimeMillis2, (now) => fiberRefLocallyWith(effect, currentLogSpan, prepend3(make26(label, now)))));
var logAnnotations = /* @__PURE__ */ fiberRefGet(currentLogAnnotations);
var loop = (initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : map10(loopInternal(initial, options.while, options.step, options.body), fromIterable);
var loopInternal = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap8(body(initial), (a) => map10(loopInternal(inc(initial), cont, inc, body), prepend3(a))) : sync(() => empty9()));
var loopDiscard = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap8(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : void_);
var mapAccum3 = /* @__PURE__ */ dual(3, (elements, initial, f) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let result = succeed(initial);
  let next;
  let i = 0;
  while (!(next = iterator.next()).done) {
    const index = i++;
    const value = next.value;
    result = flatMap8(result, (state) => map10(f(state, value, index), ([z, b]) => {
      builder.push(b);
      return z;
    }));
  }
  return map10(result, (z) => [z, builder]);
}));
var mapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (c) => failCauseSync(() => f(c)),
  onSuccess: succeed
}));
var memoize = (self2) => pipe(deferredMake(), flatMap8((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self2), intoDeferred(deferred), once, map10((complete) => zipRight(complete, pipe(deferredAwait(deferred), flatMap8(([patch7, a]) => as(zip2(patchFiberRefs(patch7[0]), updateRuntimeFlags(patch7[1])), a))))))));
var merge5 = (self2) => matchEffect(self2, {
  onFailure: (e) => succeed(e),
  onSuccess: succeed
});
var negate = (self2) => map10(self2, (b) => !b);
var none6 = (self2) => flatMap8(self2, (option) => {
  switch (option._tag) {
    case "None":
      return void_;
    case "Some":
      return fail2(new NoSuchElementException);
  }
});
var once = (self2) => map10(make28(true), (ref) => asVoid(whenEffect(self2, getAndSet2(ref, false))));
var option = (self2) => matchEffect(self2, {
  onFailure: () => succeed(none2()),
  onSuccess: (a) => succeed(some2(a))
});
var orElseFail = /* @__PURE__ */ dual(2, (self2, evaluate) => orElse2(self2, () => failSync(evaluate)));
var orElseSucceed = /* @__PURE__ */ dual(2, (self2, evaluate) => orElse2(self2, () => sync(evaluate)));
var parallelErrors = (self2) => matchCauseEffect(self2, {
  onFailure: (cause2) => {
    const errors = fromIterable(failures(cause2));
    return errors.length === 0 ? failCause(cause2) : fail2(errors);
  },
  onSuccess: succeed
});
var patchFiberRefs = (patch7) => updateFiberRefs((fiberId2, fiberRefs3) => pipe(patch7, patch6(fiberId2, fiberRefs3)));
var promise = (evaluate) => evaluate.length >= 1 ? async_((resolve, signal) => {
  try {
    evaluate(signal).then((a) => resolve(succeed(a)), (e) => resolve(die2(e)));
  } catch (e) {
    resolve(die2(e));
  }
}) : async_((resolve) => {
  try {
    evaluate().then((a) => resolve(succeed(a)), (e) => resolve(die2(e)));
  } catch (e) {
    resolve(die2(e));
  }
});
var provideService = /* @__PURE__ */ dual(3, (self2, tag, service) => contextWithEffect((env) => provideContext(self2, add2(env, tag, service))));
var provideServiceEffect = /* @__PURE__ */ dual(3, (self2, tag, effect) => contextWithEffect((env) => flatMap8(effect, (service) => provideContext(self2, pipe(env, add2(tag, service))))));
var random2 = /* @__PURE__ */ randomWith(succeed);
var reduce9 = /* @__PURE__ */ dual(3, (elements, zero2, f) => fromIterable(elements).reduce((acc, el, i) => flatMap8(acc, (a) => f(a, el, i)), succeed(zero2)));
var reduceRight3 = /* @__PURE__ */ dual(3, (elements, zero2, f) => fromIterable(elements).reduceRight((acc, el, i) => flatMap8(acc, (a) => f(el, a, i)), succeed(zero2)));
var reduceWhile = /* @__PURE__ */ dual(3, (elements, zero2, options) => flatMap8(sync(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop(iterator, 0, zero2, options.while, options.body)));
var reduceWhileLoop = (iterator, index, state, predicate, f) => {
  const next = iterator.next();
  if (!next.done && predicate(state)) {
    return flatMap8(f(state, next.value, index), (nextState) => reduceWhileLoop(iterator, index + 1, nextState, predicate, f));
  }
  return succeed(state);
};
var repeatN = /* @__PURE__ */ dual(2, (self2, n) => suspend(() => repeatNLoop(self2, n)));
var repeatNLoop = (self2, n) => flatMap8(self2, (a) => n <= 0 ? succeed(a) : zipRight(yieldNow(), repeatNLoop(self2, n - 1)));
var sandbox = (self2) => matchCauseEffect(self2, {
  onFailure: fail2,
  onSuccess: succeed
});
var setFiberRefs = (fiberRefs3) => suspend(() => setAll2(fiberRefs3));
var sleep3 = sleep2;
var succeedNone = /* @__PURE__ */ succeed(/* @__PURE__ */ none2());
var succeedSome = (value) => succeed(some2(value));
var summarized = /* @__PURE__ */ dual(3, (self2, summary, f) => flatMap8(summary, (start) => flatMap8(self2, (value) => map10(summary, (end) => [f(start, end), value]))));
var tagMetrics = /* @__PURE__ */ dual((args) => isEffect(args[0]), function() {
  return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [make29(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => make29(k, v)));
});
var labelMetrics = /* @__PURE__ */ dual(2, (self2, labels) => fiberRefLocallyWith(self2, currentMetricLabels, (old) => union(old, labels)));
var takeUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let effect = succeed(false);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    effect = flatMap8(effect, (bool) => {
      if (bool) {
        return succeed(true);
      }
      builder.push(a);
      return predicate(a, index);
    });
  }
  return map10(effect, () => builder);
}));
var takeWhile2 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let taking = succeed(true);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    taking = flatMap8(taking, (taking2) => pipe(taking2 ? predicate(a, index) : succeed(false), map10((bool) => {
      if (bool) {
        builder.push(a);
      }
      return bool;
    })));
  }
  return map10(taking, () => builder);
}));
var tapBoth = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => matchCauseEffect(self2, {
  onFailure: (cause2) => {
    const either3 = failureOrCause(cause2);
    switch (either3._tag) {
      case "Left": {
        return zipRight(onFailure(either3.left), failCause(cause2));
      }
      case "Right": {
        return failCause(cause2);
      }
    }
  },
  onSuccess: (a) => as(onSuccess(a), a)
}));
var tapDefect = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause(self2, (cause2) => match2(keepDefects(cause2), {
  onNone: () => failCause(cause2),
  onSome: (a) => zipRight(f(a), failCause(cause2))
})));
var tapError = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause2) => {
    const either3 = failureOrCause(cause2);
    switch (either3._tag) {
      case "Left":
        return zipRight(f(either3.left), failCause(cause2));
      case "Right":
        return failCause(cause2);
    }
  },
  onSuccess: succeed
}));
var tapErrorTag = /* @__PURE__ */ dual(3, (self2, k, f) => tapError(self2, (e) => {
  if (isTagged(e, k)) {
    return f(e);
  }
  return void_;
}));
var tapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause2) => zipRight(f(cause2), failCause(cause2)),
  onSuccess: succeed
}));
var timed = (self2) => timedWith(self2, currentTimeNanos2);
var timedWith = /* @__PURE__ */ dual(2, (self2, nanos2) => summarized(self2, nanos2, (start, end) => nanos(end - start)));
var tracerWith3 = tracerWith2;
var tracer = /* @__PURE__ */ tracerWith3(succeed);
var tryPromise = (arg) => {
  let evaluate;
  let catcher = undefined;
  if (typeof arg === "function") {
    evaluate = arg;
  } else {
    evaluate = arg.try;
    catcher = arg.catch;
  }
  const fail5 = (e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
  if (evaluate.length >= 1) {
    return async_((resolve, signal) => {
      try {
        evaluate(signal).then((a) => resolve(succeed(a)), (e) => resolve(fail5(e)));
      } catch (e) {
        resolve(fail5(e));
      }
    });
  }
  return async_((resolve) => {
    try {
      evaluate().then((a) => resolve(succeed(a)), (e) => resolve(fail5(e)));
    } catch (e) {
      resolve(fail5(e));
    }
  });
};
var tryMap = /* @__PURE__ */ dual(2, (self2, options) => flatMap8(self2, (a) => try_({
  try: () => options.try(a),
  catch: options.catch
})));
var tryMapPromise = /* @__PURE__ */ dual(2, (self2, options) => flatMap8(self2, (a) => tryPromise({
  try: options.try.length >= 1 ? (signal) => options.try(a, signal) : () => options.try(a),
  catch: options.catch
})));
var unless = /* @__PURE__ */ dual(2, (self2, condition) => suspend(() => condition() ? succeedNone : asSome(self2)));
var unlessEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap8(condition, (b) => b ? succeedNone : asSome(self2)));
var unsandbox = (self2) => mapErrorCause(self2, flatten5);
var updateFiberRefs = (f) => withFiberRuntime((state) => {
  state.setFiberRefs(f(state.id(), state.getFiberRefs()));
  return void_;
});
var updateService = /* @__PURE__ */ dual(3, (self2, tag, f) => mapInputContext(self2, (context2) => add2(context2, tag, f(unsafeGet3(context2, tag)))));
var when = /* @__PURE__ */ dual(2, (self2, condition) => suspend(() => condition() ? map10(self2, some2) : succeed(none2())));
var whenFiberRef = /* @__PURE__ */ dual(3, (self2, fiberRef, predicate) => flatMap8(fiberRefGet(fiberRef), (s) => predicate(s) ? map10(self2, (a) => [s, some2(a)]) : succeed([s, none2()])));
var whenRef = /* @__PURE__ */ dual(3, (self2, ref, predicate) => flatMap8(get12(ref), (s) => predicate(s) ? map10(self2, (a) => [s, some2(a)]) : succeed([s, none2()])));
var withMetric = /* @__PURE__ */ dual(2, (self2, metric) => metric(self2));
var serviceFunctionEffect = (getService, f) => (...args) => flatMap8(getService, (a) => f(a)(...args));
var serviceFunction = (getService, f) => (...args) => map10(getService, (a) => f(a)(...args));
var serviceFunctions = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return (...args) => flatMap8(getService, (s) => s[prop](...args));
  }
});
var serviceConstants = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return flatMap8(getService, (s) => isEffect(s[prop]) ? s[prop] : succeed(s[prop]));
  }
});
var serviceMembers = (getService) => ({
  functions: serviceFunctions(getService),
  constants: serviceConstants(getService)
});
var serviceOption = (tag) => map10(context(), getOption2(tag));
var serviceOptional = (tag) => flatMap8(context(), getOption2(tag));
var annotateCurrentSpan = function() {
  const args = arguments;
  return ignore(flatMap8(currentSpan, (span2) => sync(() => {
    if (typeof args[0] === "string") {
      span2.attribute(args[0], args[1]);
    } else {
      for (const key in args[0]) {
        span2.attribute(key, args[0][key]);
      }
    }
  })));
};
var linkSpanCurrent = function() {
  const args = arguments;
  const links = Array.isArray(args[0]) ? args[0] : [{
    _tag: "SpanLink",
    span: args[0],
    attributes: args[1] ?? {}
  }];
  return ignore(flatMap8(currentSpan, (span2) => sync(() => span2.addLinks(links))));
};
var annotateSpans = /* @__PURE__ */ dual((args) => isEffect(args[0]), function() {
  const args = arguments;
  return fiberRefLocallyWith(args[0], currentTracerSpanAnnotations, typeof args[1] === "string" ? set3(args[1], args[2]) : (annotations2) => Object.entries(args[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
});
var currentParentSpan = /* @__PURE__ */ serviceOptional(spanTag);
var currentSpan = /* @__PURE__ */ flatMap8(/* @__PURE__ */ context(), (context2) => {
  const span2 = context2.unsafeMap.get(spanTag.key);
  return span2 !== undefined && span2._tag === "Span" ? succeed(span2) : fail2(new NoSuchElementException);
});
var linkSpans = /* @__PURE__ */ dual((args) => isEffect(args[0]), (self2, span2, attributes) => fiberRefLocallyWith(self2, currentTracerSpanLinks, append2({
  _tag: "SpanLink",
  span: span2,
  attributes: attributes ?? {}
})));
var bigint02 = /* @__PURE__ */ BigInt(0);
var filterDisablePropagation = /* @__PURE__ */ flatMap((span2) => get3(span2.context, DisablePropagation) ? span2._tag === "Span" ? filterDisablePropagation(span2.parent) : none2() : some2(span2));
var unsafeMakeSpan = (fiber, name, options) => {
  const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options.context && get3(options.context, DisablePropagation);
  const context2 = fiber.getFiberRef(currentContext);
  const parent = options.parent ? some2(options.parent) : options.root ? none2() : filterDisablePropagation(getOption2(context2, spanTag));
  let span2;
  if (disablePropagation) {
    span2 = noopSpan({
      name,
      parent,
      context: add2(options.context ?? empty3(), DisablePropagation, true)
    });
  } else {
    const services = fiber.getFiberRef(currentServices);
    const tracer2 = get3(services, tracerTag);
    const clock2 = get3(services, Clock);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const fiberRefs3 = fiber.getFiberRefs();
    const annotationsFromEnv = get10(fiberRefs3, currentTracerSpanAnnotations);
    const linksFromEnv = get10(fiberRefs3, currentTracerSpanLinks);
    const links = linksFromEnv._tag === "Some" ? options.links !== undefined ? [...toReadonlyArray(linksFromEnv.value), ...options.links ?? []] : toReadonlyArray(linksFromEnv.value) : options.links ?? empty();
    span2 = tracer2.span(name, parent, options.context ?? empty3(), links, timingEnabled ? clock2.unsafeCurrentTimeNanos() : bigint02, options.kind ?? "internal", options);
    if (annotationsFromEnv._tag === "Some") {
      forEach4(annotationsFromEnv.value, (value, key) => span2.attribute(key, value));
    }
    if (options.attributes !== undefined) {
      Object.entries(options.attributes).forEach(([k, v]) => span2.attribute(k, v));
    }
  }
  if (typeof options.captureStackTrace === "function") {
    spanToTrace.set(span2, options.captureStackTrace);
  }
  return span2;
};
var makeSpan = (name, options) => {
  options = addSpanStackTrace(options);
  return withFiberRuntime((fiber) => succeed(unsafeMakeSpan(fiber, name, options)));
};
var spanAnnotations = /* @__PURE__ */ fiberRefGet(currentTracerSpanAnnotations);
var spanLinks = /* @__PURE__ */ fiberRefGet(currentTracerSpanLinks);
var endSpan = (span2, exit2, clock2, timingEnabled) => sync(() => {
  if (span2.status._tag === "Ended") {
    return;
  }
  if (exitIsFailure(exit2) && spanToTrace.has(span2)) {
    span2.attribute("code.stacktrace", spanToTrace.get(span2)());
  }
  span2.end(timingEnabled ? clock2.unsafeCurrentTimeNanos() : bigint02, exit2);
});
var useSpan = (name, ...args) => {
  const options = addSpanStackTrace(args.length === 1 ? undefined : args[0]);
  const evaluate = args[args.length - 1];
  return withFiberRuntime((fiber) => {
    const span2 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock2 = get3(fiber.getFiberRef(currentServices), clockTag);
    return onExit(evaluate(span2), (exit2) => endSpan(span2, exit2, clock2, timingEnabled));
  });
};
var withParentSpan = /* @__PURE__ */ dual(2, (self2, span2) => provideService(self2, spanTag, span2));
var withSpan = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return useSpan(name, options, (span2) => withParentSpan(self2, span2));
  }
  return (self2) => useSpan(name, options, (span2) => withParentSpan(self2, span2));
};
var functionWithSpan = (options) => function() {
  let captureStackTrace = options.captureStackTrace ?? false;
  if (options.captureStackTrace !== false) {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error = new Error;
    Error.stackTraceLimit = limit;
    let cache = false;
    captureStackTrace = () => {
      if (cache !== false) {
        return cache;
      }
      if (error.stack) {
        const stack = error.stack.trim().split(`
`);
        cache = stack.slice(2).join(`
`).trim();
        return cache;
      }
    };
  }
  return suspend(() => {
    const opts = typeof options.options === "function" ? options.options.apply(null, arguments) : options.options;
    return withSpan(suspend(() => internalCall(() => options.body.apply(this, arguments))), opts.name, {
      ...opts,
      captureStackTrace
    });
  });
};
var fromNullable2 = (value) => value == null ? fail2(new NoSuchElementException) : succeed(value);
var optionFromOptional = (self2) => catchAll(map10(self2, some2), (error) => isNoSuchElementException(error) ? succeedNone : fail2(error));

// node_modules/effect/dist/esm/internal/executionStrategy.js
var OP_SEQUENTIAL2 = "Sequential";
var OP_PARALLEL2 = "Parallel";
var OP_PARALLEL_N = "ParallelN";
var sequential2 = {
  _tag: OP_SEQUENTIAL2
};
var parallel2 = {
  _tag: OP_PARALLEL2
};
var parallelN = (parallelism) => ({
  _tag: OP_PARALLEL_N,
  parallelism
});
var isSequential = (self2) => self2._tag === OP_SEQUENTIAL2;
var isParallel = (self2) => self2._tag === OP_PARALLEL2;

// node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential3 = sequential2;
var parallel3 = parallel2;
var parallelN2 = parallelN;

// node_modules/effect/dist/esm/FiberRefsPatch.js
var diff6 = diff5;
var patch7 = patch6;

// node_modules/effect/dist/esm/internal/fiberStatus.js
var FiberStatusSymbolKey = "effect/FiberStatus";
var FiberStatusTypeId = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
var OP_DONE = "Done";
var OP_RUNNING = "Running";
var OP_SUSPENDED = "Suspended";
var DoneHash = /* @__PURE__ */ string(`${FiberStatusSymbolKey}-${OP_DONE}`);

class Done {
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_DONE;
  [symbol]() {
    return DoneHash;
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
}

class Running {
  runtimeFlags;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_RUNNING;
  constructor(runtimeFlags2) {
    this.runtimeFlags = runtimeFlags2;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
}

class Suspended {
  runtimeFlags;
  blockingOn;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_SUSPENDED;
  constructor(runtimeFlags2, blockingOn) {
    this.runtimeFlags = runtimeFlags2;
    this.blockingOn = blockingOn;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), combine(hash(this.blockingOn)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
  }
}
var done3 = /* @__PURE__ */ new Done;
var running = (runtimeFlags2) => new Running(runtimeFlags2);
var suspended = (runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn);
var isFiberStatus = (u) => hasProperty(u, FiberStatusTypeId);
var isDone2 = (self2) => self2._tag === OP_DONE;

// node_modules/effect/dist/esm/FiberStatus.js
var done4 = done3;
var running2 = running;
var suspended2 = suspended;
var isDone3 = isDone2;

// node_modules/effect/dist/esm/Micro.js
var TypeId13 = /* @__PURE__ */ Symbol.for("effect/Micro");
var MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
var MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
var microCauseVariance = {
  _E: identity
};

class MicroCauseImpl extends globalThis.Error {
  _tag;
  traces;
  [MicroCauseTypeId];
  constructor(_tag, originalError, traces) {
    const causeName = `MicroCause.${_tag}`;
    let name;
    let message;
    let stack;
    if (originalError instanceof globalThis.Error) {
      name = `(${causeName}) ${originalError.name}`;
      message = originalError.message;
      const messageLines = message.split(`
`).length;
      stack = originalError.stack ? `(${causeName}) ${originalError.stack.split(`
`).slice(0, messageLines + 3).join(`
`)}` : `${name}: ${message}`;
    } else {
      name = causeName;
      message = toStringUnknown(originalError, 0);
      stack = `${name}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `
    ${traces.join(`
    `)}`;
    }
    super(message);
    this._tag = _tag;
    this.traces = traces;
    this[MicroCauseTypeId] = microCauseVariance;
    this.name = name;
    this.stack = stack;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [NodeInspectSymbol]() {
    return this.stack;
  }
}
class Die extends MicroCauseImpl {
  defect;
  constructor(defect, traces = []) {
    super("Die", defect, traces);
    this.defect = defect;
  }
}
var causeDie = (defect, traces = []) => new Die(defect, traces);

class Interrupt extends MicroCauseImpl {
  constructor(traces = []) {
    super("Interrupt", "interrupted", traces);
  }
}
var causeInterrupt = (traces = []) => new Interrupt(traces);
var causeIsInterrupt = (self2) => self2._tag === "Interrupt";
var MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
var fiberVariance = {
  _A: identity,
  _E: identity
};

class MicroFiberImpl {
  context;
  interruptible;
  [MicroFiberTypeId];
  _stack = [];
  _observers = [];
  _exit;
  _children;
  currentOpCount = 0;
  constructor(context2, interruptible3 = true) {
    this.context = context2;
    this.interruptible = interruptible3;
    this[MicroFiberTypeId] = fiberVariance;
  }
  getRef(ref) {
    return unsafeGetReference(this.context, ref);
  }
  addObserver(cb) {
    if (this._exit) {
      cb(this._exit);
      return constVoid;
    }
    this._observers.push(cb);
    return () => {
      const index = this._observers.indexOf(cb);
      if (index >= 0) {
        this._observers.splice(index, 1);
      }
    };
  }
  _interrupted = false;
  unsafeInterrupt() {
    if (this._exit) {
      return;
    }
    this._interrupted = true;
    if (this.interruptible) {
      this.evaluate(exitInterrupt2);
    }
  }
  unsafePoll() {
    return this._exit;
  }
  evaluate(effect) {
    if (this._exit) {
      return;
    } else if (this._yielded !== undefined) {
      const yielded = this._yielded;
      this._yielded = undefined;
      yielded();
    }
    const exit2 = this.runLoop(effect);
    if (exit2 === Yield) {
      return;
    }
    const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
    if (interruptChildren !== undefined) {
      return this.evaluate(flatMap9(interruptChildren, () => exit2));
    }
    this._exit = exit2;
    for (let i = 0;i < this._observers.length; i++) {
      this._observers[i](exit2);
    }
    this._observers.length = 0;
  }
  runLoop(effect) {
    let yielding = false;
    let current = effect;
    this.currentOpCount = 0;
    try {
      while (true) {
        this.currentOpCount++;
        if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
          yielding = true;
          const prev = current;
          current = flatMap9(yieldNow2, () => prev);
        }
        current = current[evaluate](this);
        if (current === Yield) {
          const yielded = this._yielded;
          if (MicroExitTypeId in yielded) {
            this._yielded = undefined;
            return yielded;
          }
          return Yield;
        }
      }
    } catch (error) {
      if (!hasProperty(current, evaluate)) {
        return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
      }
      return exitDie2(error);
    }
  }
  getCont(symbol3) {
    while (true) {
      const op = this._stack.pop();
      if (!op)
        return;
      const cont = op[ensureCont] && op[ensureCont](this);
      if (cont)
        return {
          [symbol3]: cont
        };
      if (op[symbol3])
        return op;
    }
  }
  _yielded = undefined;
  yieldWith(value) {
    this._yielded = value;
    return Yield;
  }
  children() {
    return this._children ??= new Set;
  }
}
var fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({
  interruptChildren: undefined
}));
var identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
var args = /* @__PURE__ */ Symbol.for("effect/Micro/args");
var evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
var successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
var failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
var ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
var Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
var microVariance = {
  _A: identity,
  _E: identity,
  _R: identity
};
var MicroProto = {
  ...EffectPrototype2,
  _op: "Micro",
  [TypeId13]: microVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  toJSON() {
    return {
      _id: "Micro",
      op: this[identifier],
      ...args in this ? {
        args: this[args]
      } : undefined
    };
  },
  toString() {
    return format(this);
  },
  [NodeInspectSymbol]() {
    return format(this);
  }
};
function defaultEvaluate(_fiber) {
  return exitDie2(`Micro.evaluate: Not implemented`);
}
var makePrimitiveProto = (options) => ({
  ...MicroProto,
  [identifier]: options.op,
  [evaluate]: options.eval ?? defaultEvaluate,
  [successCont]: options.contA,
  [failureCont]: options.contE,
  [ensureCont]: options.ensure
});
var makePrimitive = (options) => {
  const Proto2 = makePrimitiveProto(options);
  return function() {
    const self2 = Object.create(Proto2);
    self2[args] = options.single === false ? arguments : arguments[0];
    return self2;
  };
};
var makeExit = (options) => {
  const Proto2 = {
    ...makePrimitiveProto(options),
    [MicroExitTypeId]: MicroExitTypeId,
    _tag: options.op,
    get [options.prop]() {
      return this[args];
    },
    toJSON() {
      return {
        _id: "MicroExit",
        _tag: options.op,
        [options.prop]: this[args]
      };
    },
    [symbol2](that) {
      return isMicroExit(that) && that._tag === options.op && equals(this[args], that[args]);
    },
    [symbol]() {
      return cached(this, combine(string(options.op))(hash(this[args])));
    }
  };
  return function(value) {
    const self2 = Object.create(Proto2);
    self2[args] = value;
    self2[successCont] = undefined;
    self2[failureCont] = undefined;
    self2[ensureCont] = undefined;
    return self2;
  };
};
var succeed4 = /* @__PURE__ */ makeExit({
  op: "Success",
  prop: "value",
  eval(fiber) {
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var failCause4 = /* @__PURE__ */ makeExit({
  op: "Failure",
  prop: "cause",
  eval(fiber) {
    let cont = fiber.getCont(failureCont);
    while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
      cont = fiber.getCont(failureCont);
    }
    return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var yieldNowWith = /* @__PURE__ */ makePrimitive({
  op: "Yield",
  eval(fiber) {
    let resumed = false;
    fiber.getRef(CurrentScheduler).scheduleTask(() => {
      if (resumed)
        return;
      fiber.evaluate(exitVoid2);
    }, this[args] ?? 0);
    return fiber.yieldWith(() => {
      resumed = true;
    });
  }
});
var yieldNow2 = /* @__PURE__ */ yieldNowWith(0);
var void_3 = /* @__PURE__ */ succeed4(undefined);
var withMicroFiber = /* @__PURE__ */ makePrimitive({
  op: "WithMicroFiber",
  eval(fiber) {
    return this[args](fiber);
  }
});
var flatMap9 = /* @__PURE__ */ dual(2, (self2, f) => {
  const onSuccess = Object.create(OnSuccessProto);
  onSuccess[args] = self2;
  onSuccess[successCont] = f;
  return onSuccess;
});
var OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccess",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var isMicroExit = (u) => hasProperty(u, MicroExitTypeId);
var exitSucceed2 = succeed4;
var exitFailCause2 = failCause4;
var exitInterrupt2 = /* @__PURE__ */ exitFailCause2(/* @__PURE__ */ causeInterrupt());
var exitDie2 = (defect) => exitFailCause2(causeDie(defect));
var exitVoid2 = /* @__PURE__ */ exitSucceed2(undefined);
var setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);

class MicroSchedulerDefault {
  tasks = [];
  running = false;
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate(this.afterScheduled);
    }
  }
  afterScheduled = () => {
    this.running = false;
    this.runTasks();
  };
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i = 0, len = tasks.length;i < len; i++) {
      tasks[i]();
    }
  }
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
  }
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
}
var updateContext = /* @__PURE__ */ dual(2, (self2, f) => withMicroFiber((fiber) => {
  const prev = fiber.context;
  fiber.context = f(prev);
  return onExit2(self2, () => {
    fiber.context = prev;
    return void_3;
  });
}));
var provideContext2 = /* @__PURE__ */ dual(2, (self2, provided) => updateContext(self2, merge3(provided)));
class MaxOpsBeforeYield extends (/* @__PURE__ */ Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
  defaultValue: () => 2048
})) {
}
class CurrentScheduler extends (/* @__PURE__ */ Reference2()("effect/Micro/currentScheduler", {
  defaultValue: () => new MicroSchedulerDefault
})) {
}
var matchCauseEffect2 = /* @__PURE__ */ dual(2, (self2, options) => {
  const primitive = Object.create(OnSuccessAndFailureProto);
  primitive[args] = self2;
  primitive[successCont] = options.onSuccess;
  primitive[failureCont] = options.onFailure;
  return primitive;
});
var OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccessAndFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var onExit2 = /* @__PURE__ */ dual(2, (self2, f) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self2), {
  onFailure: (cause2) => flatMap9(f(exitFailCause2(cause2)), () => failCause4(cause2)),
  onSuccess: (a) => flatMap9(f(exitSucceed2(a)), () => succeed4(a))
})));
var setInterruptible = /* @__PURE__ */ makePrimitive({
  op: "SetInterruptible",
  ensure(fiber) {
    fiber.interruptible = this[args];
    if (fiber._interrupted && fiber.interruptible) {
      return () => exitInterrupt2;
    }
  }
});
var interruptible3 = (self2) => withMicroFiber((fiber) => {
  if (fiber.interruptible)
    return self2;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible(false));
  if (fiber._interrupted)
    return exitInterrupt2;
  return self2;
});
var uninterruptibleMask2 = (f) => withMicroFiber((fiber) => {
  if (!fiber.interruptible)
    return f(identity);
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return f(interruptible3);
});
var runFork = (effect, options) => {
  const fiber = new MicroFiberImpl(CurrentScheduler.context(options?.scheduler ?? new MicroSchedulerDefault));
  fiber.evaluate(effect);
  if (options?.signal) {
    if (options.signal.aborted) {
      fiber.unsafeInterrupt();
    } else {
      const abort = () => fiber.unsafeInterrupt();
      options.signal.addEventListener("abort", abort, {
        once: true
      });
      fiber.addObserver(() => options.signal.removeEventListener("abort", abort));
    }
  }
  return fiber;
};

// node_modules/effect/dist/esm/Scheduler.js
class PriorityBuckets {
  buckets = [];
  scheduleTask(task, priority) {
    const length3 = this.buckets.length;
    let bucket = undefined;
    let index = 0;
    for (;index < length3; index++) {
      if (this.buckets[index][0] <= priority) {
        bucket = this.buckets[index];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index === length3) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index, 0, [priority, [task]]);
    }
  }
}

class MixedScheduler {
  maxNextTickBeforeTimer;
  running = false;
  tasks = /* @__PURE__ */ new PriorityBuckets;
  constructor(maxNextTickBeforeTimer) {
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0;i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(undefined).then(() => this.starveInternal(depth + 1));
    }
  }
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
}
var defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));

class SyncScheduler {
  tasks = /* @__PURE__ */ new PriorityBuckets;
  deferred = false;
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0;i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
}
var currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
var withScheduler = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentScheduler, scheduler));

// node_modules/effect/dist/esm/internal/completedRequestMap.js
var currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(new Map));

// node_modules/effect/dist/esm/internal/concurrency.js
var match9 = (concurrency, sequential4, unbounded2, bounded2) => {
  switch (concurrency) {
    case undefined:
      return sequential4();
    case "unbounded":
      return unbounded2();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded2() : concurrency2 > 1 ? bounded2(concurrency2) : sequential4());
    default:
      return concurrency > 1 ? bounded2(concurrency) : sequential4();
  }
};
var matchSimple = (concurrency, sequential4, concurrent) => {
  switch (concurrency) {
    case undefined:
      return sequential4();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential4());
    default:
      return concurrency > 1 ? concurrent() : sequential4();
  }
};

// node_modules/effect/dist/esm/internal/fiberMessage.js
var OP_INTERRUPT_SIGNAL = "InterruptSignal";
var OP_STATEFUL = "Stateful";
var OP_RESUME = "Resume";
var OP_YIELD_NOW = "YieldNow";
var interruptSignal = (cause2) => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause: cause2
});
var stateful = (onFiber) => ({
  _tag: OP_STATEFUL,
  onFiber
});
var resume = (effect) => ({
  _tag: OP_RESUME,
  effect
});
var yieldNow3 = () => ({
  _tag: OP_YIELD_NOW
});

// node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey = "effect/FiberScope";
var FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);

class Global {
  [FiberScopeTypeId] = FiberScopeTypeId;
  fiberId = none4;
  roots = /* @__PURE__ */ new Set;
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
}

class Local {
  fiberId;
  parent;
  [FiberScopeTypeId] = FiberScopeTypeId;
  constructor(fiberId2, parent) {
    this.fiberId = fiberId2;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful((parentFiber) => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
}
var unsafeMake8 = (fiber) => {
  return new Local(fiber.id(), fiber);
};
var globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global);

// node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey = "effect/Fiber";
var FiberTypeId = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
var fiberVariance2 = {
  _E: (_) => _,
  _A: (_) => _
};
var fiberProto = {
  [FiberTypeId]: fiberVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var RuntimeFiberSymbolKey = "effect/Fiber";
var RuntimeFiberTypeId = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
var isRuntimeFiber = (self2) => (RuntimeFiberTypeId in self2);
var _await2 = (self2) => self2.await;
var inheritAll = (self2) => self2.inheritAll;
var interruptAllAs = /* @__PURE__ */ dual(2, /* @__PURE__ */ fnUntraced(function* (fibers, fiberId2) {
  for (const fiber of fibers) {
    if (isRuntimeFiber(fiber)) {
      fiber.unsafeInterruptAsFork(fiberId2);
      continue;
    }
    yield* fiber.interruptAsFork(fiberId2);
  }
  for (const fiber of fibers) {
    if (isRuntimeFiber(fiber) && fiber.unsafePoll()) {
      continue;
    }
    yield* fiber.await;
  }
}));
var interruptAsFork = /* @__PURE__ */ dual(2, (self2, fiberId2) => self2.interruptAsFork(fiberId2));
var join2 = (self2) => zipLeft(flatten6(self2.await), self2.inheritAll);
var _never = {
  ...CommitPrototype,
  commit() {
    return join2(this);
  },
  ...fiberProto,
  id: () => none4,
  await: never,
  children: /* @__PURE__ */ succeed([]),
  inheritAll: never,
  poll: /* @__PURE__ */ succeed(/* @__PURE__ */ none2()),
  interruptAsFork: () => never
};
var poll3 = (self2) => self2.poll;
var currentFiberURI = "effect/FiberCurrent";

// node_modules/effect/dist/esm/internal/logger.js
var LoggerSymbolKey = "effect/Logger";
var LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
var loggerVariance = {
  _Message: (_) => _,
  _Output: (_) => _
};
var makeLogger = (log2) => ({
  [LoggerTypeId]: loggerVariance,
  log: log2,
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var none7 = {
  [LoggerTypeId]: loggerVariance,
  log: constVoid,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var textOnly = /^[^\s"=]*$/;
var format3 = (quoteValue, whitespace) => ({
  annotations: annotations2,
  cause: cause2,
  date,
  fiberId: fiberId2,
  logLevel,
  message,
  spans
}) => {
  const formatValue = (value) => value.match(textOnly) ? value : quoteValue(value);
  const format4 = (label, value) => `${formatLabel(label)}=${formatValue(value)}`;
  const append4 = (label, value) => " " + format4(label, value);
  let out = format4("timestamp", date.toISOString());
  out += append4("level", logLevel.label);
  out += append4("fiber", threadName(fiberId2));
  const messages = ensure(message);
  for (let i = 0;i < messages.length; i++) {
    out += append4("message", toStringUnknown(messages[i], whitespace));
  }
  if (!isEmptyType(cause2)) {
    out += append4("cause", pretty(cause2, {
      renderErrorCause: true
    }));
  }
  for (const span2 of spans) {
    out += " " + render(date.getTime())(span2);
  }
  for (const [label, value] of annotations2) {
    out += append4(label, toStringUnknown(value, whitespace));
  }
  return out;
};
var escapeDoubleQuotes = (s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
var stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format3(escapeDoubleQuotes));
var colors = {
  bold: "1",
  red: "31",
  green: "32",
  yellow: "33",
  blue: "34",
  cyan: "36",
  white: "37",
  gray: "90",
  black: "30",
  bgBrightRed: "101"
};
var logLevelColors = {
  None: [],
  All: [],
  Trace: [colors.gray],
  Debug: [colors.blue],
  Info: [colors.green],
  Warning: [colors.yellow],
  Error: [colors.red],
  Fatal: [colors.bgBrightRed, colors.black]
};
var hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
var processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
var hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;

// node_modules/effect/dist/esm/internal/metric/boundaries.js
var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
var MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);

class MetricBoundariesImpl {
  values;
  [MetricBoundariesTypeId] = MetricBoundariesTypeId;
  constructor(values3) {
    this.values = values3;
    this._hash = pipe(string(MetricBoundariesSymbolKey), combine(array2(this.values)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricBoundaries(u) && equals(this.values, u.values);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var isMetricBoundaries = (u) => hasProperty(u, MetricBoundariesTypeId);
var fromIterable7 = (iterable) => {
  const values3 = pipe(iterable, appendAll(of2(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values3);
};
var exponential = (options) => pipe(makeBy(options.count - 1, (i) => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromIterable7);

// node_modules/effect/dist/esm/internal/metric/keyType.js
var MetricKeyTypeSymbolKey = "effect/MetricKeyType";
var MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
var CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
var FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
var FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
var GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
var GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
var HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
var SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
var SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
var metricKeyTypeVariance = {
  _In: (_) => _,
  _Out: (_) => _
};

class CounterKeyType {
  incremental;
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
  constructor(incremental, bigint) {
    this.incremental = incremental;
    this.bigint = bigint;
    this._hash = string(CounterKeyTypeSymbolKey);
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isCounterKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
class HistogramKeyType {
  boundaries;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
  constructor(boundaries) {
    this.boundaries = boundaries;
    this._hash = pipe(string(HistogramKeyTypeSymbolKey), combine(hash(this.boundaries)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var counter = (options) => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);
var histogram = (boundaries) => {
  return new HistogramKeyType(boundaries);
};
var isCounterKey = (u) => hasProperty(u, CounterKeyTypeTypeId);
var isFrequencyKey = (u) => hasProperty(u, FrequencyKeyTypeTypeId);
var isGaugeKey = (u) => hasProperty(u, GaugeKeyTypeTypeId);
var isHistogramKey = (u) => hasProperty(u, HistogramKeyTypeTypeId);
var isSummaryKey = (u) => hasProperty(u, SummaryKeyTypeTypeId);

// node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey = "effect/MetricKey";
var MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
var metricKeyVariance = {
  _Type: (_) => _
};
var arrayEquivilence = /* @__PURE__ */ getEquivalence(equals);

class MetricKeyImpl {
  name;
  keyType;
  description;
  tags;
  [MetricKeyTypeId] = metricKeyVariance;
  constructor(name, keyType, description, tags = []) {
    this.name = name;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags;
    this._hash = pipe(string(this.name + this.description), combine(hash(this.keyType)), combine(array2(this.tags)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var isMetricKey = (u) => hasProperty(u, MetricKeyTypeId);
var counter2 = (name, options) => new MetricKeyImpl(name, counter(options), fromNullable(options?.description));
var histogram2 = (name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable(description));
var taggedWithLabels = /* @__PURE__ */ dual(2, (self2, extraTags) => extraTags.length === 0 ? self2 : new MetricKeyImpl(self2.name, self2.keyType, self2.description, union(self2.tags, extraTags)));

// node_modules/effect/dist/esm/internal/metric/state.js
var MetricStateSymbolKey = "effect/MetricState";
var MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
var CounterStateSymbolKey = "effect/MetricState/Counter";
var CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
var FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
var GaugeStateSymbolKey = "effect/MetricState/Gauge";
var GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
var HistogramStateSymbolKey = "effect/MetricState/Histogram";
var HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
var SummaryStateSymbolKey = "effect/MetricState/Summary";
var SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
var metricStateVariance = {
  _A: (_) => _
};

class CounterState {
  count;
  [MetricStateTypeId] = metricStateVariance;
  [CounterStateTypeId] = CounterStateTypeId;
  constructor(count) {
    this.count = count;
  }
  [symbol]() {
    return pipe(hash(CounterStateSymbolKey), combine(hash(this.count)), cached(this));
  }
  [symbol2](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var arrayEquals = /* @__PURE__ */ getEquivalence(equals);

class FrequencyState {
  occurrences;
  [MetricStateTypeId] = metricStateVariance;
  [FrequencyStateTypeId] = FrequencyStateTypeId;
  constructor(occurrences) {
    this.occurrences = occurrences;
  }
  _hash;
  [symbol]() {
    return pipe(string(FrequencyStateSymbolKey), combine(array2(fromIterable(this.occurrences.entries()))), cached(this));
  }
  [symbol2](that) {
    return isFrequencyState(that) && arrayEquals(fromIterable(this.occurrences.entries()), fromIterable(that.occurrences.entries()));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}

class GaugeState {
  value;
  [MetricStateTypeId] = metricStateVariance;
  [GaugeStateTypeId] = GaugeStateTypeId;
  constructor(value) {
    this.value = value;
  }
  [symbol]() {
    return pipe(hash(GaugeStateSymbolKey), combine(hash(this.value)), cached(this));
  }
  [symbol2](u) {
    return isGaugeState(u) && this.value === u.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}

class HistogramState {
  buckets;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [HistogramStateTypeId] = HistogramStateTypeId;
  constructor(buckets, count, min2, max2, sum2) {
    this.buckets = buckets;
    this.count = count;
    this.min = min2;
    this.max = max2;
    this.sum = sum2;
  }
  [symbol]() {
    return pipe(hash(HistogramStateSymbolKey), combine(hash(this.buckets)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}

class SummaryState {
  error;
  quantiles;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [SummaryStateTypeId] = SummaryStateTypeId;
  constructor(error, quantiles, count, min2, max2, sum2) {
    this.error = error;
    this.quantiles = quantiles;
    this.count = count;
    this.min = min2;
    this.max = max2;
    this.sum = sum2;
  }
  [symbol]() {
    return pipe(hash(SummaryStateSymbolKey), combine(hash(this.error)), combine(hash(this.quantiles)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var counter3 = (count) => new CounterState(count);
var frequency2 = (occurrences) => {
  return new FrequencyState(occurrences);
};
var gauge2 = (count) => new GaugeState(count);
var histogram3 = (options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
var summary2 = (options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
var isCounterState = (u) => hasProperty(u, CounterStateTypeId);
var isFrequencyState = (u) => hasProperty(u, FrequencyStateTypeId);
var isGaugeState = (u) => hasProperty(u, GaugeStateTypeId);
var isHistogramState = (u) => hasProperty(u, HistogramStateTypeId);
var isSummaryState = (u) => hasProperty(u, SummaryStateTypeId);

// node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey = "effect/MetricHook";
var MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
var metricHookVariance = {
  _In: (_) => _,
  _Out: (_) => _
};
var make30 = (options) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var bigint03 = /* @__PURE__ */ BigInt(0);
var counter4 = (key) => {
  let sum2 = key.keyType.bigint ? bigint03 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value) => value >= bigint03 : (value) => value >= 0 : (_value) => true;
  const update4 = (value) => {
    if (canUpdate(value)) {
      sum2 = sum2 + value;
    }
  };
  return make30({
    get: () => counter3(sum2),
    update: update4,
    modify: update4
  });
};
var frequency3 = (key) => {
  const values3 = new Map;
  for (const word of key.keyType.preregisteredWords) {
    values3.set(word, 0);
  }
  const update4 = (word) => {
    const slotCount = values3.get(word) ?? 0;
    values3.set(word, slotCount + 1);
  };
  return make30({
    get: () => frequency2(values3),
    update: update4,
    modify: update4
  });
};
var gauge3 = (_key, startAt) => {
  let value = startAt;
  return make30({
    get: () => gauge2(value),
    update: (v) => {
      value = v;
    },
    modify: (v) => {
      value = value + v;
    }
  });
};
var histogram4 = (key) => {
  const bounds = key.keyType.boundaries.values;
  const size5 = bounds.length;
  const values3 = new Uint32Array(size5 + 1);
  const boundaries = new Float64Array(size5);
  let count = 0;
  let sum2 = 0;
  let min2 = Number.MAX_VALUE;
  let max2 = Number.MIN_VALUE;
  pipe(bounds, sort(Order), map3((n, i) => {
    boundaries[i] = n;
  }));
  const update4 = (value) => {
    let from = 0;
    let to = size5;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      if (to === from + 1) {
        if (value <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values3[from] = values3[from] + 1;
    count = count + 1;
    sum2 = sum2 + value;
    if (value < min2) {
      min2 = value;
    }
    if (value > max2) {
      max2 = value;
    }
  };
  const getBuckets = () => {
    const builder = allocate(size5);
    let cumulated = 0;
    for (let i = 0;i < size5; i++) {
      const boundary = boundaries[i];
      const value = values3[i];
      cumulated = cumulated + value;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  };
  return make30({
    get: () => histogram3({
      buckets: getBuckets(),
      count,
      min: min2,
      max: max2,
      sum: sum2
    }),
    update: update4,
    modify: update4
  });
};
var summary3 = (key) => {
  const {
    error,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe(quantiles, sort(Order));
  const values3 = allocate(maxSize);
  let head4 = 0;
  let count = 0;
  let sum2 = 0;
  let min2 = 0;
  let max2 = 0;
  const snapshot = (now) => {
    const builder = [];
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values3[i];
      if (item != null) {
        const [t, v] = item;
        const age = millis(now - t);
        if (greaterThanOrEqualTo2(age, zero) && lessThanOrEqualTo2(age, maxAge)) {
          builder.push(v);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles(error, sortedQuantiles, sort(builder, Order));
  };
  const observe = (value, timestamp) => {
    if (maxSize > 0) {
      head4 = head4 + 1;
      const target = head4 % maxSize;
      values3[target] = [timestamp, value];
    }
    min2 = count === 0 ? value : Math.min(min2, value);
    max2 = count === 0 ? value : Math.max(max2, value);
    count = count + 1;
    sum2 = sum2 + value;
  };
  return make30({
    get: () => summary2({
      error,
      quantiles: snapshot(Date.now()),
      count,
      min: min2,
      max: max2,
      sum: sum2
    }),
    update: ([value, timestamp]) => observe(value, timestamp),
    modify: ([value, timestamp]) => observe(value, timestamp)
  });
};
var calculateQuantiles = (error, sortedQuantiles, sortedSamples) => {
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return empty();
  }
  const head4 = sortedQuantiles[0];
  const tail = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error, sampleCount, none2(), 0, head4, sortedSamples);
  const resolved = of(resolvedHead);
  tail.forEach((quantile) => {
    resolved.push(resolveQuantile(error, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map3(resolved, (rq) => [rq.quantile, rq.value]);
};
var resolveQuantile = (error, sampleCount, current, consumed, quantile, rest) => {
  let error_1 = error;
  let sampleCount_1 = sampleCount;
  let current_1 = current;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error;
  let sampleCount_2 = sampleCount;
  let current_2 = current;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  while (true) {
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: none2(),
        consumed: consumed_1,
        rest: []
      };
    }
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some2(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    const headValue = headNonEmpty(rest_1);
    const sameHead = span(rest_1, (n) => n === headValue);
    const desired = quantile_1 * sampleCount_1;
    const allowedError = error_1 / 2 * desired;
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    if (candConsumed > desired + allowedError) {
      const valueToReturn = isNone2(current_1) ? some2(headValue) : current_1;
      return {
        quantile: quantile_1,
        value: valueToReturn,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    switch (current_1._tag) {
      case "None": {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      case "Some": {
        const prevError = Math.abs(desired - current_1.value);
        if (candError < prevError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        return {
          quantile: quantile_1,
          value: some2(current_1.value),
          consumed: consumed_1,
          rest: rest_1
        };
      }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};

// node_modules/effect/dist/esm/internal/metric/pair.js
var MetricPairSymbolKey = "effect/MetricPair";
var MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
var metricPairVariance = {
  _Type: (_) => _
};
var unsafeMake9 = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};

// node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey = "effect/MetricRegistry";
var MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);

class MetricRegistryImpl {
  [MetricRegistryTypeId] = MetricRegistryTypeId;
  map = /* @__PURE__ */ empty17();
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(unsafeMake9(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = pipe(this.map, get8(key), getOrUndefined);
    if (hook == null) {
      if (isCounterKey(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const counter5 = counter4(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set4(key, counter5));
      }
      value = counter5;
    }
    return value;
  }
  getFrequency(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const frequency4 = frequency3(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set4(key, frequency4));
      }
      value = frequency4;
    }
    return value;
  }
  getGauge(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const gauge4 = gauge3(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set4(key, gauge4));
      }
      value = gauge4;
    }
    return value;
  }
  getHistogram(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const histogram5 = histogram4(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set4(key, histogram5));
      }
      value = histogram5;
    }
    return value;
  }
  getSummary(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const summary4 = summary3(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set4(key, summary4));
      }
      value = summary4;
    }
    return value;
  }
}
var make31 = () => {
  return new MetricRegistryImpl;
};

// node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey = "effect/Metric";
var MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
var metricVariance = {
  _Type: (_) => _,
  _In: (_) => _,
  _Out: (_) => _
};
var globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make31());
var make32 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign((effect) => tap(effect, (a) => update4(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  return metric;
};
var counter5 = (name, options) => fromMetricKey(counter2(name, options));
var fromMetricKey = (key) => {
  let untaggedHook;
  const hookCache = new WeakMap;
  const hook = (extraTags) => {
    if (extraTags.length === 0) {
      if (untaggedHook !== undefined) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook2 = hookCache.get(extraTags);
    if (hook2 !== undefined) {
      return hook2;
    }
    hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook2);
    return hook2;
  };
  return make32(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
};
var histogram5 = (name, boundaries, description) => fromMetricKey(histogram2(name, boundaries, description));
var tagged = /* @__PURE__ */ dual(3, (self2, key, value) => taggedWithLabels2(self2, [make29(key, value)]));
var taggedWithLabels2 = /* @__PURE__ */ dual(2, (self2, extraTags) => {
  return make32(self2.keyType, (input, extraTags1) => self2.unsafeUpdate(input, union(extraTags, extraTags1)), (extraTags1) => self2.unsafeValue(union(extraTags, extraTags1)), (input, extraTags1) => self2.unsafeModify(input, union(extraTags, extraTags1)));
});
var update4 = /* @__PURE__ */ dual(2, (self2, input) => fiberRefGetWith(currentMetricLabels, (tags) => sync(() => self2.unsafeUpdate(input, tags))));

// node_modules/effect/dist/esm/internal/request.js
var RequestSymbolKey = "effect/Request";
var RequestTypeId = /* @__PURE__ */ Symbol.for(RequestSymbolKey);
var requestVariance = {
  _E: (_) => _,
  _A: (_) => _
};
var RequestPrototype = {
  ...StructuralPrototype,
  [RequestTypeId]: requestVariance
};
var isRequest = (u) => hasProperty(u, RequestTypeId);
var complete = /* @__PURE__ */ dual(2, (self2, result) => fiberRefGetWith(currentRequestMap, (map12) => sync(() => {
  if (map12.has(self2)) {
    const entry = map12.get(self2);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone(entry.result, result);
    }
  }
})));
class Listeners {
  count = 0;
  observers = /* @__PURE__ */ new Set;
  interrupted = false;
  addObserver(f) {
    this.observers.add(f);
  }
  removeObserver(f) {
    this.observers.delete(f);
  }
  increment() {
    this.count++;
    this.observers.forEach((f) => f(this.count));
  }
  decrement() {
    this.count--;
    this.observers.forEach((f) => f(this.count));
  }
}

// node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey = "effect/Supervisor";
var SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
var supervisorVariance = {
  _T: (_) => _
};

class ProxySupervisor {
  underlying;
  value0;
  [SupervisorTypeId] = supervisorVariance;
  constructor(underlying, value0) {
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context2, effect, parent, fiber) {
    this.underlying.onStart(context2, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.underlying.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.underlying.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map10(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
}

class Zip {
  left;
  right;
  _tag = "Zip";
  [SupervisorTypeId] = supervisorVariance;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  get value() {
    return zip2(this.left.value, this.right.value);
  }
  onStart(context2, effect, parent, fiber) {
    this.left.onStart(context2, effect, parent, fiber);
    this.right.onStart(context2, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.left.onEnd(value, fiber);
    this.right.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.left.onEffect(fiber, effect);
    this.right.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map10(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
}
var isZip = (self2) => hasProperty(self2, SupervisorTypeId) && isTagged(self2, "Zip");

class Track {
  [SupervisorTypeId] = supervisorVariance;
  fibers = /* @__PURE__ */ new Set;
  get value() {
    return sync(() => Array.from(this.fibers));
  }
  onStart(_context, _effect, _parent, fiber) {
    this.fibers.add(fiber);
  }
  onEnd(_value, fiber) {
    this.fibers.delete(fiber);
  }
  onEffect(_fiber, _effect) {}
  onSuspend(_fiber) {}
  onResume(_fiber) {}
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map10(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
}

class Const {
  effect;
  [SupervisorTypeId] = supervisorVariance;
  constructor(effect) {
    this.effect = effect;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {}
  onEnd(_value, _fiber) {}
  onEffect(_fiber, _effect) {}
  onSuspend(_fiber) {}
  onResume(_fiber) {}
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map10(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
}
var unsafeTrack = () => {
  return new Track;
};
var track = /* @__PURE__ */ sync(unsafeTrack);
var fromEffect = (effect) => {
  return new Const(effect);
};
var none8 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect(void_));

// node_modules/effect/dist/esm/Differ.js
var make33 = make14;

// node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY3 = "Empty";
var OP_ADD_SUPERVISOR = "AddSupervisor";
var OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
var OP_AND_THEN2 = "AndThen";
var empty23 = {
  _tag: OP_EMPTY3
};
var combine8 = (self2, that) => {
  return {
    _tag: OP_AND_THEN2,
    first: self2,
    second: that
  };
};
var patch8 = (self2, supervisor) => {
  return patchLoop(supervisor, of2(self2));
};
var patchLoop = (_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty2(patches)) {
    const head4 = headNonEmpty2(patches);
    switch (head4._tag) {
      case OP_EMPTY3: {
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_ADD_SUPERVISOR: {
        supervisor = supervisor.zip(head4.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_REMOVE_SUPERVISOR: {
        supervisor = removeSupervisor(supervisor, head4.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_AND_THEN2: {
        patches = prepend2(head4.first)(prepend2(head4.second)(tailNonEmpty2(patches)));
        break;
      }
    }
  }
  return supervisor;
};
var removeSupervisor = (self2, that) => {
  if (equals(self2, that)) {
    return none8;
  } else {
    if (isZip(self2)) {
      return removeSupervisor(self2.left, that).zip(removeSupervisor(self2.right, that));
    } else {
      return self2;
    }
  }
};
var toSet2 = (self2) => {
  if (equals(self2, none8)) {
    return empty7();
  } else {
    if (isZip(self2)) {
      return pipe(toSet2(self2.left), union3(toSet2(self2.right)));
    } else {
      return make10(self2);
    }
  }
};
var diff7 = (oldValue, newValue) => {
  if (equals(oldValue, newValue)) {
    return empty23;
  }
  const oldSupervisors = toSet2(oldValue);
  const newSupervisors = toSet2(newValue);
  const added = pipe(newSupervisors, difference3(oldSupervisors), reduce5(empty23, (patch9, supervisor) => combine8(patch9, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = pipe(oldSupervisors, difference3(newSupervisors), reduce5(empty23, (patch9, supervisor) => combine8(patch9, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine8(added, removed);
};
var differ2 = /* @__PURE__ */ make33({
  empty: empty23,
  patch: patch8,
  combine: combine8,
  diff: diff7
});

// node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted = /* @__PURE__ */ counter5("effect_fiber_started", {
  incremental: true
});
var fiberActive = /* @__PURE__ */ counter5("effect_fiber_active");
var fiberSuccesses = /* @__PURE__ */ counter5("effect_fiber_successes", {
  incremental: true
});
var fiberFailures = /* @__PURE__ */ counter5("effect_fiber_failures", {
  incremental: true
});
var fiberLifetimes = /* @__PURE__ */ tagged(/* @__PURE__ */ histogram5("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
var EvaluationSignalContinue = "Continue";
var EvaluationSignalDone = "Done";
var EvaluationSignalYieldNow = "Yield";
var runtimeFiberVariance = {
  _E: (_) => _,
  _A: (_) => _
};
var absurd = (_) => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
var YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
var yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
var contOpSuccess = {
  [OP_ON_SUCCESS]: (_, cont, value) => {
    return internalCall(() => cont.effect_instruction_i1(value));
  },
  ["OnStep"]: (_, _cont, value) => {
    return exitSucceed(exitSucceed(value));
  },
  [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value) => {
    return internalCall(() => cont.effect_instruction_i2(value));
  },
  [OP_REVERT_FLAGS]: (self2, cont, value) => {
    self2.patchRuntimeFlags(self2.currentRuntimeFlags, cont.patch);
    if (interruptible(self2.currentRuntimeFlags) && self2.isInterrupted()) {
      return exitFailCause(self2.getInterruptedCause());
    } else {
      return exitSucceed(value);
    }
  },
  [OP_WHILE]: (self2, cont, value) => {
    internalCall(() => cont.effect_instruction_i2(value));
    if (internalCall(() => cont.effect_instruction_i0())) {
      self2.pushStack(cont);
      return internalCall(() => cont.effect_instruction_i1());
    } else {
      return void_;
    }
  },
  [OP_ITERATOR]: (self2, cont, value) => {
    while (true) {
      const state = internalCall(() => cont.effect_instruction_i0.next(value));
      if (state.done) {
        return exitSucceed(state.value);
      }
      const primitive = yieldWrapGet(state.value);
      if (!exitIsExit(primitive)) {
        self2.pushStack(cont);
        return primitive;
      } else if (primitive._tag === "Failure") {
        return primitive;
      }
      value = primitive.value;
    }
  }
};
var drainQueueWhileRunningTable = {
  [OP_INTERRUPT_SIGNAL]: (self2, runtimeFlags2, cur, message) => {
    self2.processNewInterruptSignal(message.cause);
    return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
  },
  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL]: (self2, runtimeFlags2, cur, message) => {
    message.onFiber(self2, running2(runtimeFlags2));
    return cur;
  },
  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return flatMap8(yieldNow(), () => cur);
  }
};
var runBlockedRequests = (self2) => forEachSequentialDiscard(flatten4(self2), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential4]) => {
  const map12 = new Map;
  const arr = [];
  for (const block of sequential4) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map12.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map12);
}, false, false));
var _version = /* @__PURE__ */ getCurrentVersion();

class FiberRuntime extends Class {
  [FiberTypeId] = fiberVariance2;
  [RuntimeFiberTypeId] = runtimeFiberVariance;
  _fiberRefs;
  _fiberId;
  _queue = /* @__PURE__ */ new Array;
  _children = null;
  _observers = /* @__PURE__ */ new Array;
  _running = false;
  _stack = [];
  _asyncInterruptor = null;
  _asyncBlockingOn = null;
  _exitValue = null;
  _steps = [];
  _isYielding = false;
  currentRuntimeFlags;
  currentOpCount = 0;
  currentSupervisor;
  currentScheduler;
  currentTracer;
  currentSpan;
  currentContext;
  currentDefaultServices;
  constructor(fiberId2, fiberRefs0, runtimeFlags0) {
    super();
    this.currentRuntimeFlags = runtimeFlags0;
    this._fiberId = fiberId2;
    this._fiberRefs = fiberRefs0;
    if (runtimeMetrics(runtimeFlags0)) {
      const tags = this.getFiberRef(currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags);
      fiberActive.unsafeUpdate(1, tags);
    }
    this.refreshRefCache();
  }
  commit() {
    return join2(this);
  }
  id() {
    return this._fiberId;
  }
  resume(effect) {
    this.tell(resume(effect));
  }
  get status() {
    return this.ask((_, status) => status);
  }
  get runtimeFlags() {
    return this.ask((state, status) => {
      if (isDone3(status)) {
        return state.currentRuntimeFlags;
      }
      return status.runtimeFlags;
    });
  }
  scope() {
    return unsafeMake8(this);
  }
  get children() {
    return this.ask((fiber) => Array.from(fiber.getChildren()));
  }
  getChildren() {
    if (this._children === null) {
      this._children = new Set;
    }
    return this._children;
  }
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause);
  }
  fiberRefs() {
    return this.ask((fiber) => fiber.getFiberRefs());
  }
  ask(f) {
    return suspend(() => {
      const deferred = deferredUnsafeMake(this._fiberId);
      this.tell(stateful((fiber, status) => {
        deferredUnsafeDone(deferred, sync(() => f(fiber, status)));
      }));
      return deferredAwait(deferred);
    });
  }
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return async_((resume2) => {
      const cb = (exit2) => resume2(succeed(exit2));
      this.tell(stateful((fiber, _) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync(() => this.tell(stateful((fiber, _) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch9 = pipe(diff4(parentRuntimeFlags, updatedRuntimeFlags), exclude2(Interruption), exclude2(WindDown));
      return updateRuntimeFlags(patch9);
    });
  }
  get poll() {
    return sync(() => fromNullable(this._exitValue));
  }
  unsafePoll() {
    return this._exitValue;
  }
  interruptAsFork(fiberId2) {
    return sync(() => this.tell(interruptSignal(interrupt(fiberId2))));
  }
  unsafeInterruptAsFork(fiberId2) {
    this.tell(interruptSignal(interrupt(fiberId2)));
  }
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  removeObserver(observer) {
    this._observers = this._observers.filter((o) => o !== observer);
  }
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
    return this._fiberRefs;
  }
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_(this._fiberRefs, fiberRef);
  }
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  setFiberRef(fiberRef, value) {
    this._fiberRefs = updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(currentServices);
    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
    this.currentSupervisor = this.getFiberRef(currentSupervisor);
    this.currentScheduler = this.getFiberRef(currentScheduler);
    this.currentContext = this.getFiberRef(currentContext);
    this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
  }
  setFiberRefs(fiberRefs3) {
    this._fiberRefs = fiberRefs3;
    this.refreshRefCache();
  }
  addChild(child) {
    this.getChildren().add(child);
  }
  removeChild(child) {
    this.getChildren().delete(child);
  }
  transferChildren(scope) {
    const children = this._children;
    this._children = null;
    if (children !== null && children.size > 0) {
      for (const child of children) {
        if (child._exitValue === null) {
          scope.add(this.currentRuntimeFlags, child);
        }
      }
    }
  }
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
      }
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
  }
  drainQueueWhileRunning(runtimeFlags2, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
    }
    return cur;
  }
  isInterrupted() {
    return !isEmpty5(this.getFiberRef(currentInterruptedCause));
  }
  addInterruptedCause(cause2) {
    const oldSC = this.getFiberRef(currentInterruptedCause);
    this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause2));
  }
  processNewInterruptSignal(cause2) {
    this.addInterruptedCause(cause2);
    this.sendInterruptSignalToAllChildren();
  }
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal(interrupt(this.id())));
      told = true;
    }
    return told;
  }
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it = this._children.values();
      this._children = null;
      let isDone4 = false;
      const body = () => {
        const next = it.next();
        if (!next.done) {
          return asVoid(next.value.await);
        } else {
          return sync(() => {
            isDone4 = true;
          });
        }
      };
      return whileLoop({
        while: () => !isDone4,
        body,
        step: () => {}
      });
    }
    return null;
  }
  reportExitValue(exit2) {
    if (runtimeMetrics(this.currentRuntimeFlags)) {
      const tags = this.getFiberRef(currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
      fiberActive.unsafeUpdate(-1, tags);
      switch (exit2._tag) {
        case OP_SUCCESS: {
          fiberSuccesses.unsafeUpdate(1, tags);
          break;
        }
        case OP_FAILURE: {
          fiberFailures.unsafeUpdate(1, tags);
          break;
        }
      }
    }
    if (exit2._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel);
      if (!isInterruptedOnly(exit2.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit2.cause, level);
      }
    }
  }
  setExitValue(exit2) {
    this._exitValue = exit2;
    this.reportExitValue(exit2);
    for (let i = this._observers.length - 1;i >= 0; i--) {
      this._observers[i](exit2);
    }
    this._observers = [];
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause2, overrideLogLevel) {
    const logLevel = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
    const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
    if (greaterThan3(minimumLogLevel, logLevel)) {
      return;
    }
    const spans = this.getFiberRef(currentLogSpan);
    const annotations2 = this.getFiberRef(currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (size3(loggers) > 0) {
      const clockService = get3(this.getFiberRef(currentServices), clockTag);
      const date = new Date(clockService.unsafeCurrentTimeMillis());
      withRedactableContext(contextMap, () => {
        for (const logger of loggers) {
          logger.log({
            fiberId: this.id(),
            logLevel,
            message,
            cause: cause2,
            context: contextMap,
            spans,
            annotations: annotations2,
            date
          });
        }
      });
    }
  }
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW: {
        return EvaluationSignalYieldNow;
      }
      case OP_INTERRUPT_SIGNAL: {
        this.processNewInterruptSignal(message.cause);
        if (this._asyncInterruptor !== null) {
          this._asyncInterruptor(exitFailCause(message.cause));
          this._asyncInterruptor = null;
        }
        return EvaluationSignalContinue;
      }
      case OP_RESUME: {
        this._asyncInterruptor = null;
        this._asyncBlockingOn = null;
        this.evaluateEffect(message.effect);
        return EvaluationSignalContinue;
      }
      case OP_STATEFUL: {
        message.onFiber(this, this._exitValue !== null ? done4 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
        return EvaluationSignalContinue;
      }
      default: {
        return absurd(message);
      }
    }
  }
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this);
    try {
      let effect = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
      while (effect !== null) {
        const eff = effect;
        const exit2 = this.runLoop(eff);
        if (exit2 === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OP_YIELD) {
            if (cooperativeYielding(this.currentRuntimeFlags)) {
              this.tell(yieldNow3());
              this.tell(resume(exitVoid));
              effect = null;
            } else {
              effect = exitVoid;
            }
          } else if (op._op === OP_ASYNC) {
            effect = null;
          }
        } else {
          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
          const interruption2 = this.interruptAllChildren();
          if (interruption2 !== null) {
            effect = flatMap8(interruption2, () => exit2);
          } else {
            if (this._queue.length === 0) {
              this.setExitValue(exit2);
            } else {
              this.tell(resume(exit2));
            }
            effect = null;
          }
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this);
    }
  }
  start(effect) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        this.evaluateEffect(effect);
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume(effect));
    }
  }
  startFork(effect) {
    this.tell(resume(effect));
  }
  patchRuntimeFlags(oldRuntimeFlags, patch9) {
    const newRuntimeFlags = patch4(oldRuntimeFlags, patch9);
    globalThis[currentFiberURI] = this;
    this.currentRuntimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  initiateAsync(runtimeFlags2, asyncRegister) {
    let alreadyCalled = false;
    const callback = (effect) => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume(effect));
      }
    };
    if (interruptible(runtimeFlags2)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause(die(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this.currentRuntimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [OP_TAG](op) {
    return sync(() => unsafeGet3(this.currentContext, op));
  }
  ["Left"](op) {
    return fail2(op.left);
  }
  ["None"](_) {
    return fail2(new NoSuchElementException);
  }
  ["Right"](op) {
    return exitSucceed(op.right);
  }
  ["Some"](op) {
    return exitSucceed(op.value);
  }
  ["Micro"](op) {
    return unsafeAsync((microResume) => {
      let resume2 = microResume;
      const fiber = runFork(provideContext2(op, this.currentContext));
      fiber.addObserver((exit2) => {
        if (exit2._tag === "Success") {
          return resume2(exitSucceed(exit2.value));
        }
        switch (exit2.cause._tag) {
          case "Interrupt": {
            return resume2(exitFailCause(interrupt(none4)));
          }
          case "Fail": {
            return resume2(fail2(exit2.cause.error));
          }
          case "Die": {
            return resume2(die2(exit2.cause.defect));
          }
        }
      });
      return unsafeAsync((abortResume) => {
        resume2 = (_) => {
          abortResume(void_);
        };
        fiber.unsafeInterrupt();
      });
    });
  }
  [OP_SYNC](op) {
    const value = internalCall(() => op.effect_instruction_i0());
    const cont = this.getNextSuccessCont();
    if (cont !== undefined) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, value);
    } else {
      yieldedOpChannel.currentOp = exitSucceed(value);
      return YieldedOp;
    }
  }
  [OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== undefined) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OP_FAILURE](op) {
    const cause2 = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== undefined) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE: {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return internalCall(() => cont.effect_instruction_i1(cause2));
          } else {
            return exitFailCause(stripFailures(cause2));
          }
        }
        case "OnStep": {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return exitSucceed(exitFailCause(cause2));
          } else {
            return exitFailCause(stripFailures(cause2));
          }
        }
        case OP_REVERT_FLAGS: {
          this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
          if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
            return exitFailCause(sequential(cause2, this.getInterruptedCause()));
          } else {
            return exitFailCause(cause2);
          }
        }
        default: {
          absurd(cont);
        }
      }
    } else {
      yieldedOpChannel.currentOp = exitFailCause(cause2);
      return YieldedOp;
    }
  }
  [OP_WITH_RUNTIME](op) {
    return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this.currentRuntimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this.currentRuntimeFlags = snap.flags;
      const patchRefs = diff6(snap.refs, refs);
      const patchFlags = diff4(snap.flags, flags);
      return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(patch7(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber.currentRuntimeFlags = patch4(patchFlags)(newFiber.currentRuntimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask((restore) => flatMap8(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this.currentRuntimeFlags;
    const newRuntimeFlags = patch4(oldRuntimeFlags, updateFlags);
    if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause(this.getInterruptedCause());
    } else {
      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        const revertFlags = diff4(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags(revertFlags, op));
        return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
      } else {
        return exitVoid;
      }
    }
  }
  [OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_YIELD](op) {
    this._isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_WHILE](op) {
    const check = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check()) {
      this.pushStack(op);
      return body();
    } else {
      return exitVoid;
    }
  }
  [OP_ITERATOR](op) {
    return contOpSuccess[OP_ITERATOR](this, op, undefined);
  }
  [OP_COMMIT](op) {
    return internalCall(() => op.commit());
  }
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
        this.currentSupervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
      }
      if (!this._isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this.currentScheduler.shouldYield(this);
        if (shouldYield !== false) {
          this._isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = flatMap8(yieldNow({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        cur = this.currentTracer.context(() => {
          if (_version !== cur[EffectTypeId2]._V) {
            const level = this.getFiberRef(currentVersionMismatchErrorLogLevel);
            if (level._tag === "Some") {
              const effectVersion = cur[EffectTypeId2]._V;
              this.log(`Executing an Effect versioned ${effectVersion} with a Runtime of version ${getCurrentVersion()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`, empty16, level);
            }
          }
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OP_YIELD || op._op === OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
        }
      } catch (e) {
        if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
          cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
        } else if (isInterruptedException(e)) {
          cur = exitFailCause(sequential(die(e), interrupt(none4)));
        } else {
          cur = die2(e);
        }
      }
    }
  }
  run = () => {
    this.drainQueueOnCurrentThread();
  };
}
var currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
var loggerWithConsoleLog = (self2) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get3(services, consoleTag).unsafe.log(self2.log(opts));
});
var defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
var tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
  annotations: annotations2,
  cause: cause2,
  context: context2,
  fiberId: fiberId2,
  logLevel,
  message
}) => {
  const span2 = getOption2(getOrDefault(context2, currentContext), spanTag);
  if (span2._tag === "None" || span2.value._tag === "ExternalSpan") {
    return;
  }
  const clockService = unsafeGet3(getOrDefault(context2, currentServices), clockTag);
  const attributes = {};
  for (const [key, value] of annotations2) {
    attributes[key] = value;
  }
  attributes["effect.fiberId"] = threadName2(fiberId2);
  attributes["effect.logLevel"] = logLevel.label;
  if (cause2 !== null && cause2._tag !== "Empty") {
    attributes["effect.cause"] = pretty(cause2, {
      renderErrorCause: true
    });
  }
  span2.value.event(toStringUnknown(Array.isArray(message) && message.length === 1 ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
var currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make10(defaultLogger, tracerLogger)));
var annotateLogsScoped = function() {
  if (typeof arguments[0] === "string") {
    return fiberRefLocallyScopedWith(currentLogAnnotations, set3(arguments[0], arguments[1]));
  }
  const entries2 = Object.entries(arguments[0]);
  return fiberRefLocallyScopedWith(currentLogAnnotations, mutate3((annotations2) => {
    for (let i = 0;i < entries2.length; i++) {
      const [key, value] = entries2[i];
      set3(annotations2, key, value);
    }
    return annotations2;
  }));
};
var whenLogLevel = /* @__PURE__ */ dual(2, (effect, level) => {
  const requiredLogLevel = typeof level === "string" ? fromLiteral(level) : level;
  return withFiberRuntime((fiberState) => {
    const minimumLogLevel = fiberState.getFiberRef(currentMinimumLogLevel);
    if (greaterThan3(minimumLogLevel, requiredLogLevel)) {
      return succeed(none2());
    }
    return map10(effect, some2);
  });
});
var acquireRelease = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => uninterruptible(tap(acquire, (a) => addFinalizer((exit2) => release(a, exit2)))));
var acquireReleaseInterruptible = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => ensuring(acquire, addFinalizer((exit2) => release(exit2))));
var addFinalizer = (finalizer) => withFiberRuntime((runtime2) => {
  const acquireRefs = runtime2.getFiberRefs();
  const acquireFlags = disable2(runtime2.currentRuntimeFlags, Interruption);
  return flatMap8(scope, (scope) => scopeAddFinalizerExit(scope, (exit2) => withFiberRuntime((runtimeFinalizer) => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer.currentRuntimeFlags;
    const patchRefs = diff6(preRefs, acquireRefs);
    const patchFlags = diff4(preFlags, acquireFlags);
    const inverseRefs = diff6(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(patch7(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring(withRuntimeFlags(finalizer(exit2), patchFlags), sync(() => {
      runtimeFinalizer.setFiberRefs(patch7(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
});
var daemonChildren = (self2) => {
  const forkScope = fiberRefLocally(currentForkScopeOverride, some2(globalScope));
  return forkScope(self2);
};
var _existsParFound = /* @__PURE__ */ Symbol.for("effect/Effect/existsPar/found");
var exists2 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => matchSimple(options?.concurrency, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => matchEffect(forEach5(elements, (a, i) => if_(predicate(a, i), {
  onTrue: () => fail2(_existsParFound),
  onFalse: () => void_
}), options), {
  onFailure: (e) => e === _existsParFound ? succeed(true) : fail2(e),
  onSuccess: () => succeed(false)
})));
var existsLoop = (iterator, index, f) => {
  const next = iterator.next();
  if (next.done) {
    return succeed(false);
  }
  return flatMap8(f(next.value, index), (b) => b ? succeed(b) : existsLoop(iterator, index + 1, f));
};
var filter5 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => {
  const predicate_ = options?.negate ? (a, i) => map10(predicate(a, i), not) : predicate;
  return matchSimple(options?.concurrency, () => suspend(() => fromIterable(elements).reduceRight((effect, a, i) => zipWith3(effect, suspend(() => predicate_(a, i)), (list, b) => b ? [a, ...list] : list), sync(() => new Array))), () => map10(forEach5(elements, (a, i) => map10(predicate_(a, i), (b) => b ? some2(a) : none2()), options), getSomes));
});
var allResolveInput = (input) => {
  if (Array.isArray(input) || isIterable(input)) {
    return [input, none2()];
  }
  const keys3 = Object.keys(input);
  const size5 = keys3.length;
  return [keys3.map((k) => input[k]), some2((values3) => {
    const res = {};
    for (let i = 0;i < size5; i++) {
      res[keys3[i]] = values3[i];
    }
    return res;
  })];
};
var allValidate = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect of effects) {
    eitherEffects.push(either2(effect));
  }
  return flatMap8(forEach5(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => {
    const none9 = none2();
    const size5 = eithers.length;
    const errors = new Array(size5);
    const successes = new Array(size5);
    let errored = false;
    for (let i = 0;i < size5; i++) {
      const either3 = eithers[i];
      if (either3._tag === "Left") {
        errors[i] = some2(either3.left);
        errored = true;
      } else {
        successes[i] = either3.right;
        errors[i] = none9;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? fail2(reconcile.value(errors)) : fail2(errors);
    } else if (options?.discard) {
      return void_;
    }
    return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
  });
};
var allEither = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect of effects) {
    eitherEffects.push(either2(effect));
  }
  if (options?.discard) {
    return forEach5(eitherEffects, identity, {
      concurrency: options?.concurrency,
      batching: options?.batching,
      discard: true,
      concurrentFinalizers: options?.concurrentFinalizers
    });
  }
  return map10(forEach5(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
};
var all3 = (arg, options) => {
  const [effects, reconcile] = allResolveInput(arg);
  if (options?.mode === "validate") {
    return allValidate(effects, reconcile, options);
  } else if (options?.mode === "either") {
    return allEither(effects, reconcile, options);
  }
  return options?.discard !== true && reconcile._tag === "Some" ? map10(forEach5(effects, identity, options), reconcile.value) : forEach5(effects, identity, options);
};
var allWith = (options) => (arg) => all3(arg, options);
var allSuccesses = (elements, options) => map10(all3(fromIterable(elements).map(exit), options), filterMap((exit2) => exitIsSuccess(exit2) ? some2(exit2.effect_instruction_i0) : none2()));
var replicate = /* @__PURE__ */ dual(2, (self2, n) => Array.from({
  length: n
}, () => self2));
var replicateEffect = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, n, options) => all3(replicate(self2, n), options));
var forEach5 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (self2, f, options) => withFiberRuntime((r) => {
  const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
  if (options?.discard) {
    return match9(options.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self2, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
  }
  return match9(options?.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self2, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self2, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachParUnbounded(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachParN(self2, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
}));
var forEachParUnbounded = (self2, f, batching) => suspend(() => {
  const as2 = fromIterable(self2);
  const array3 = new Array(as2.length);
  const fn = (a, i) => flatMap8(f(a, i), (b) => sync(() => array3[i] = b));
  return zipRight(forEachConcurrentDiscard(as2, fn, batching, false), succeed(array3));
});
var forEachConcurrentDiscard = (self2, f, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
  let todos = Array.from(self2).reverse();
  let target = todos.length;
  if (target === 0) {
    return void_;
  }
  let counter6 = 0;
  let interrupted = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers = new Set;
  const results = new Array;
  const interruptAll = () => fibers.forEach((fiber) => {
    fiber.currentScheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  });
  const startOrder = new Array;
  const joinOrder = new Array;
  const residual = new Array;
  const collectExits = () => {
    const exits = results.filter(({
      exit: exit2
    }) => exit2._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
      exit: exit2
    }) => exit2);
    if (exits.length === 0) {
      exits.push(exitVoid);
    }
    return exits;
  };
  const runFiber = (eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
    parent.currentScheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  };
  const onInterruptSignal = () => {
    if (!processAll) {
      target -= todos.length;
      todos = [];
    }
    interrupted = true;
    interruptAll();
  };
  const stepOrExit = batching ? step2 : exit;
  const processingFiber = runFiber(async_((resume2) => {
    const pushResult = (res, index) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index,
          exit: res
        });
        if (res._op === "Failure" && !interrupted) {
          onInterruptSignal();
        }
      }
    };
    const next = () => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index = counter6++;
        const returnNextElement = () => {
          const a2 = todos.pop();
          index = counter6++;
          return flatMap8(yieldNow(), () => flatMap8(stepOrExit(restore(f(a2, index))), onRes));
        };
        const onRes = (res) => {
          if (todos.length > 0) {
            pushResult(res, index);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed(res);
        };
        const todo = flatMap8(stepOrExit(restore(f(a, index))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers.add(fiber);
        if (interrupted) {
          fiber.currentScheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver((wrapped) => {
          let exit2;
          if (wrapped._op === "Failure") {
            exit2 = wrapped;
          } else {
            exit2 = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers.delete(fiber);
          pushResult(exit2, index);
          if (results.length === target) {
            resume2(succeed(getOrElse(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid)));
          } else if (residual.length + results.length === target) {
            const exits = collectExits();
            const requests = residual.map((blocked2) => blocked2.effect_instruction_i0).reduce(par);
            resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse(exitCollectAll(exits, {
              parallel: true
            }), () => exitVoid), ...residual.map((blocked2) => blocked2.effect_instruction_i1)], (i) => i, batching, true, n))));
          } else {
            next();
          }
        });
      }
    };
    for (let i = 0;i < fibersCount; i++) {
      next();
    }
  }));
  return asVoid(onExit(flatten6(restore(join2(processingFiber))), exitMatch({
    onFailure: (cause2) => {
      onInterruptSignal();
      const target2 = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async_((cb) => {
        const exits = [];
        let count = 0;
        let index = 0;
        const check = (index2, hitNext) => (exit2) => {
          exits[index2] = exit2;
          count++;
          if (count === target2) {
            cb(exitSucceed(exitFailCause(cause2)));
          }
          if (toPop.length > 0 && hitNext) {
            next();
          }
        };
        const next = () => {
          runFiber(toPop.pop(), true).addObserver(check(index, true));
          index++;
        };
        processingFiber.addObserver(check(index, false));
        index++;
        for (let i = 0;i < concurrency; i++) {
          next();
        }
      });
    },
    onSuccess: () => forEachSequential(joinOrder, (f2) => f2.inheritAll)
  })));
})));
var forEachParN = (self2, n, f, batching) => suspend(() => {
  const as2 = fromIterable(self2);
  const array3 = new Array(as2.length);
  const fn = (a, i) => map10(f(a, i), (b) => array3[i] = b);
  return zipRight(forEachConcurrentDiscard(as2, fn, batching, false, n), succeed(array3));
});
var fork = (self2) => withFiberRuntime((state, status) => succeed(unsafeFork(self2, state, status.runtimeFlags)));
var forkDaemon = (self2) => forkWithScopeOverride(self2, globalScope);
var forkWithErrorHandler = /* @__PURE__ */ dual(2, (self2, handler) => fork(onError(self2, (cause2) => {
  const either3 = failureOrCause(cause2);
  switch (either3._tag) {
    case "Left":
      return handler(either3.left);
    case "Right":
      return failCause(either3.right);
  }
})));
var unsafeFork = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect);
  return childFiber;
};
var unsafeForkUnstarted = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
};
var unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake3();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault(childFiberRefs, currentContext);
  const supervisor = childFiber.currentSupervisor;
  supervisor.onStart(childContext, effect, some2(parentFiber), childFiber);
  childFiber.addObserver((exit2) => supervisor.onEnd(exit2, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
};
var forkWithScopeOverride = (self2, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork(self2, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
var mergeAll3 = /* @__PURE__ */ dual((args2) => isFunction2(args2[2]), (elements, zero2, f, options) => matchSimple(options?.concurrency, () => fromIterable(elements).reduce((acc, a, i) => zipWith3(acc, a, (acc2, a2) => f(acc2, a2, i)), succeed(zero2)), () => flatMap8(make28(zero2), (acc) => flatMap8(forEach5(elements, (effect, i) => flatMap8(effect, (a) => update3(acc, (b) => f(b, a, i))), options), () => get12(acc)))));
var partition3 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => pipe(forEach5(elements, (a, i) => either2(f(a, i)), options), map10((chunk2) => partitionMap2(chunk2, identity))));
var validateAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => flatMap8(partition3(elements, f, {
  concurrency: options?.concurrency,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([es, bs]) => isNonEmptyArray2(es) ? fail2(es) : options?.discard ? void_ : succeed(bs)));
var raceAll = (all4) => withFiberRuntime((state, status) => async_((resume2) => {
  const fibers = new Set;
  let winner;
  let failures2 = empty16;
  const interruptAll = () => {
    for (const fiber of fibers) {
      fiber.unsafeInterruptAsFork(state.id());
    }
  };
  let latch = false;
  let empty24 = true;
  for (const self2 of all4) {
    empty24 = false;
    const fiber = unsafeFork(interruptible2(self2), state, status.runtimeFlags);
    fibers.add(fiber);
    fiber.addObserver((exit2) => {
      fibers.delete(fiber);
      if (!winner) {
        if (exit2._tag === "Success") {
          latch = true;
          winner = fiber;
          failures2 = empty16;
          interruptAll();
        } else {
          failures2 = parallel(exit2.cause, failures2);
        }
      }
      if (latch && fibers.size === 0) {
        resume2(winner ? zipRight(inheritAll(winner), winner.unsafePoll()) : failCause(failures2));
      }
    });
    if (winner)
      break;
  }
  if (empty24) {
    return resume2(dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`)));
  }
  latch = true;
  return interruptAllAs(fibers, state.id());
}));
var reduceEffect = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, zero2, f, options) => matchSimple(options?.concurrency, () => fromIterable(elements).reduce((acc, a, i) => zipWith3(acc, a, (acc2, a2) => f(acc2, a2, i)), zero2), () => suspend(() => pipe(mergeAll3([zero2, ...elements], none2(), (acc, elem, i) => {
  switch (acc._tag) {
    case "None": {
      return some2(elem);
    }
    case "Some": {
      return some2(f(acc.value, elem, i));
    }
  }
}, options), map10((option2) => {
  switch (option2._tag) {
    case "None": {
      throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    case "Some": {
      return option2.value;
    }
  }
})))));
var parallelFinalizers = (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self2,
  onSome: (scope) => {
    switch (scope.strategy._tag) {
      case "Parallel":
        return self2;
      case "Sequential":
      case "ParallelN":
        return flatMap8(scopeFork(scope, parallel3), (inner) => scopeExtend(self2, inner));
    }
  }
}));
var parallelNFinalizers = (parallelism) => (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self2,
  onSome: (scope) => {
    if (scope.strategy._tag === "ParallelN" && scope.strategy.parallelism === parallelism) {
      return self2;
    }
    return flatMap8(scopeFork(scope, parallelN2(parallelism)), (inner) => scopeExtend(self2, inner));
  }
}));
var finalizersMask = (strategy) => (self2) => finalizersMaskInternal(strategy, true)(self2);
var finalizersMaskInternal = (strategy, concurrentFinalizers) => (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self2(identity),
  onSome: (scope) => {
    if (concurrentFinalizers === true) {
      const patch9 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
      switch (scope.strategy._tag) {
        case "Parallel":
          return patch9(self2(parallelFinalizers));
        case "Sequential":
          return patch9(self2(sequentialFinalizers));
        case "ParallelN":
          return patch9(self2(parallelNFinalizers(scope.strategy.parallelism)));
      }
    } else {
      return self2(identity);
    }
  }
}));
var scopeWith = (f) => flatMap8(scopeTag, f);
var scopedWith = (f) => flatMap8(scopeMake(), (scope) => onExit(f(scope), (exit2) => scope.close(exit2)));
var scopedEffect = (effect) => flatMap8(scopeMake(), (scope) => scopeUse(effect, scope));
var sequentialFinalizers = (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self2,
  onSome: (scope) => {
    switch (scope.strategy._tag) {
      case "Sequential":
        return self2;
      case "Parallel":
      case "ParallelN":
        return flatMap8(scopeFork(scope, sequential3), (inner) => scopeExtend(self2, inner));
    }
  }
}));
var tagMetricsScoped = (key, value) => labelMetricsScoped([make29(key, value)]);
var labelMetricsScoped = (labels) => fiberRefLocallyScopedWith(currentMetricLabels, (old) => union(old, labels));
var using = /* @__PURE__ */ dual(2, (self2, use) => scopedWith((scope) => flatMap8(scopeExtend(self2, scope), use)));
var validate = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => validateWith(self2, that, (a, b) => [a, b], options));
var validateWith = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, f, options) => flatten6(zipWithOptions(exit(self2), exit(that), (ea, eb) => exitZipWith(ea, eb, {
  onSuccess: f,
  onFailure: (ca, cb) => options?.concurrent ? parallel(ca, cb) : sequential(ca, cb)
}), options)));
var validateFirst = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => flip(forEach5(elements, (a, i) => flip(f(a, i)), options)));
var withClockScoped = (c) => fiberRefLocallyScopedWith(currentServices, add2(clockTag, c));
var withRandomScoped = (value) => fiberRefLocallyScopedWith(currentServices, add2(randomTag, value));
var withConfigProviderScoped = (provider) => fiberRefLocallyScopedWith(currentServices, add2(configProviderTag, provider));
var withEarlyRelease = (self2) => scopeWith((parent) => flatMap8(scopeFork(parent, sequential2), (child) => pipe(self2, scopeExtend(child), map10((value) => [fiberIdWith((fiberId2) => scopeClose(child, exitInterrupt(fiberId2))), value]))));
var zipOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => zipWithOptions(self2, that, (a, b) => [a, b], options));
var zipLeftOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => {
  if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
    return zipLeft(self2, that);
  }
  return zipWithOptions(self2, that, (a, _) => a, options);
});
var zipRightOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => {
  if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
    return zipRight(self2, that);
  }
  return zipWithOptions(self2, that, (_, b) => b, options);
});
var zipWithOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, f, options) => map10(all3([self2, that], {
  concurrency: options?.concurrent ? 2 : 1,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([a, a2]) => f(a, a2)));
var withRuntimeFlagsScoped = (update5) => {
  if (update5 === empty14) {
    return void_;
  }
  return pipe(runtimeFlags, flatMap8((runtimeFlags2) => {
    const updatedRuntimeFlags = patch4(runtimeFlags2, update5);
    const revertRuntimeFlags = diff4(updatedRuntimeFlags, runtimeFlags2);
    return pipe(updateRuntimeFlags(update5), zipRight(addFinalizer(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid);
  }), uninterruptible);
};
var scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
var scope = scopeTag;
var scopeUnsafeAddFinalizer = (scope2, fin) => {
  if (scope2.state._tag === "Open") {
    scope2.state.finalizers.set({}, fin);
  }
};
var ScopeImplProto = {
  [ScopeTypeId]: ScopeTypeId,
  [CloseableScopeTypeId]: CloseableScopeTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  fork(strategy) {
    return sync(() => {
      const newScope = scopeUnsafeMake(strategy);
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      const key = {};
      const fin = (exit2) => newScope.close(exit2);
      this.state.finalizers.set(key, fin);
      scopeUnsafeAddFinalizer(newScope, (_) => sync(() => {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(key);
        }
      }));
      return newScope;
    });
  },
  close(exit2) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return void_;
      }
      const finalizers = Array.from(this.state.finalizers.values()).reverse();
      this.state = {
        _tag: "Closed",
        exit: exit2
      };
      if (finalizers.length === 0) {
        return void_;
      }
      return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit(fin(exit2))), flatMap8((results) => pipe(exitCollectAll(results), map2(exitAsVoid), getOrElse(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit(fin(exit2)), false), flatMap8((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit(fin(exit2)), false), flatMap8((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse(() => exitVoid))));
    });
  },
  addFinalizer(fin) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return fin(this.state.exit);
      }
      this.state.finalizers.set({}, fin);
      return void_;
    });
  }
};
var scopeUnsafeMake = (strategy = sequential2) => {
  const scope2 = Object.create(ScopeImplProto);
  scope2.strategy = strategy;
  scope2.state = {
    _tag: "Open",
    finalizers: new Map
  };
  return scope2;
};
var scopeMake = (strategy = sequential2) => sync(() => scopeUnsafeMake(strategy));
var scopeExtend = /* @__PURE__ */ dual(2, (effect, scope2) => mapInputContext(effect, merge3(make5(scopeTag, scope2))));
var scopeUse = /* @__PURE__ */ dual(2, (effect, scope2) => pipe(effect, scopeExtend(scope2), onExit((exit2) => scope2.close(exit2))));
var fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ: differ2,
  fork: empty23
});
var fiberRefLocallyScoped = /* @__PURE__ */ dual(2, (self2, value) => asVoid(acquireRelease(flatMap8(fiberRefGet(self2), (oldValue) => as(fiberRefSet(self2, value), oldValue)), (oldValue) => fiberRefSet(self2, oldValue))));
var fiberRefLocallyScopedWith = /* @__PURE__ */ dual(2, (self2, f) => fiberRefGetWith(self2, (a) => fiberRefLocallyScoped(self2, f(a))));
var currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none5);
var currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none8);
var fiberAwaitAll = (fibers) => forEach5(fibers, _await2);
var fiberAll = (fibers) => {
  const _fiberAll = {
    ...CommitPrototype2,
    commit() {
      return join2(this);
    },
    [FiberTypeId]: fiberVariance2,
    id: () => fromIterable(fibers).reduce((id, fiber) => combine3(id, fiber.id()), none4),
    await: exit(forEachParUnbounded(fibers, (fiber) => flatten6(fiber.await), false)),
    children: map10(forEachParUnbounded(fibers, (fiber) => fiber.children, false), flatten),
    inheritAll: forEachSequentialDiscard(fibers, (fiber) => fiber.inheritAll),
    poll: map10(forEachSequential(fibers, (fiber) => fiber.poll), reduceRight(some2(exitSucceed(new Array)), (optionB, optionA) => {
      switch (optionA._tag) {
        case "None": {
          return none2();
        }
        case "Some": {
          switch (optionB._tag) {
            case "None": {
              return none2();
            }
            case "Some": {
              return some2(exitZipWith(optionA.value, optionB.value, {
                onSuccess: (a, chunk2) => [a, ...chunk2],
                onFailure: parallel
              }));
            }
          }
        }
      }
    })),
    interruptAsFork: (fiberId2) => forEachSequentialDiscard(fibers, (fiber) => fiber.interruptAsFork(fiberId2))
  };
  return _fiberAll;
};
var raceWith = /* @__PURE__ */ dual(3, (self2, other, options) => raceFibersWith(self2, other, {
  onSelfWin: (winner, loser) => flatMap8(winner.await, (exit2) => {
    switch (exit2._tag) {
      case OP_SUCCESS: {
        return flatMap8(winner.inheritAll, () => options.onSelfDone(exit2, loser));
      }
      case OP_FAILURE: {
        return options.onSelfDone(exit2, loser);
      }
    }
  }),
  onOtherWin: (winner, loser) => flatMap8(winner.await, (exit2) => {
    switch (exit2._tag) {
      case OP_SUCCESS: {
        return flatMap8(winner.inheritAll, () => options.onOtherDone(exit2, loser));
      }
      case OP_FAILURE: {
        return options.onOtherDone(exit2, loser);
      }
    }
  })
}));
var disconnect = (self2) => uninterruptibleMask((restore) => fiberIdWith((fiberId2) => flatMap8(forkDaemon(restore(self2)), (fiber) => pipe(restore(join2(fiber)), onInterrupt(() => pipe(fiber, interruptAsFork(fiberId2)))))));
var race = /* @__PURE__ */ dual(2, (self2, that) => fiberIdWith((parentFiberId) => raceWith(self2, that, {
  onSelfDone: (exit2, right3) => exitMatchEffect(exit2, {
    onFailure: (cause2) => pipe(join2(right3), mapErrorCause((cause22) => parallel(cause2, cause22))),
    onSuccess: (value) => pipe(right3, interruptAsFiber(parentFiberId), as(value))
  }),
  onOtherDone: (exit2, left3) => exitMatchEffect(exit2, {
    onFailure: (cause2) => pipe(join2(left3), mapErrorCause((cause22) => parallel(cause22, cause2))),
    onSuccess: (value) => pipe(left3, interruptAsFiber(parentFiberId), as(value))
  })
})));
var raceFibersWith = /* @__PURE__ */ dual(3, (self2, other, options) => withFiberRuntime((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = make11(true);
  const leftFiber = unsafeMakeChildFiber(self2, parentFiber, parentRuntimeFlags, options.selfScope);
  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
  return async_((cb) => {
    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self2);
    rightFiber.startFork(other);
  }, combine3(leftFiber.id(), rightFiber.id()));
}));
var completeRace = (winner, loser, cont, ab, cb) => {
  if (compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
};
var ensuring = /* @__PURE__ */ dual(2, (self2, finalizer) => uninterruptibleMask((restore) => matchCauseEffect(restore(self2), {
  onFailure: (cause1) => matchCauseEffect(finalizer, {
    onFailure: (cause2) => failCause(sequential(cause1, cause2)),
    onSuccess: () => failCause(cause1)
  }),
  onSuccess: (a) => as(finalizer, a)
})));
var invokeWithInterrupt = (self2, entries2, onInterrupt2) => fiberIdWith((id) => flatMap8(flatMap8(forkDaemon(interruptible2(self2)), (processing) => async_((cb) => {
  const counts = entries2.map((_) => _.listeners.count);
  const checkDone = () => {
    if (counts.every((count) => count === 0)) {
      if (entries2.every((_) => {
        if (_.result.state.current._tag === "Pending") {
          return true;
        } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted(_.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach((f) => f());
        onInterrupt2?.();
        cb(interruptFiber(processing));
      }
    }
  };
  processing.addObserver((exit2) => {
    cleanup.forEach((f) => f());
    cb(exit2);
  });
  const cleanup = entries2.map((r, i) => {
    const observer = (count) => {
      counts[i] = count;
      checkDone();
    };
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach((f) => f());
  });
})), () => suspend(() => {
  const residual = entries2.flatMap((entry) => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, (entry) => complete(entry.request, exitInterrupt(id)));
})));
var makeSpanScoped = (name, options) => {
  options = addSpanStackTrace(options);
  return uninterruptible(withFiberRuntime((fiber) => {
    const scope2 = unsafeGet3(fiber.getFiberRef(currentContext), scopeTag);
    const span2 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock_ = get3(fiber.getFiberRef(currentServices), clockTag);
    return as(scopeAddFinalizerExit(scope2, (exit2) => endSpan(span2, exit2, clock_, timingEnabled)), span2);
  }));
};
var withTracerScoped = (value) => fiberRefLocallyScopedWith(currentServices, add2(tracerTag, value));
var withSpanScoped = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return flatMap8(makeSpanScoped(name, addSpanStackTrace(options)), (span2) => provideService(self2, spanTag, span2));
  }
  return (self2) => flatMap8(makeSpanScoped(name, addSpanStackTrace(options)), (span2) => provideService(self2, spanTag, span2));
};

// node_modules/effect/dist/esm/internal/cache.js
var complete2 = (key, exit2, entryStats, timeToLiveMillis) => struct({
  _tag: "Complete",
  key,
  exit: exit2,
  entryStats,
  timeToLiveMillis
});
var pending2 = (key, deferred) => struct({
  _tag: "Pending",
  key,
  deferred
});
var refreshing = (deferred, complete3) => struct({
  _tag: "Refreshing",
  deferred,
  complete: complete3
});
var MapKeyTypeId = /* @__PURE__ */ Symbol.for("effect/Cache/MapKey");

class MapKeyImpl {
  current;
  [MapKeyTypeId] = MapKeyTypeId;
  previous = undefined;
  next = undefined;
  constructor(current) {
    this.current = current;
  }
  [symbol]() {
    return pipe(hash(this.current), combine(hash(this.previous)), combine(hash(this.next)), cached(this));
  }
  [symbol2](that) {
    if (this === that) {
      return true;
    }
    return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
  }
}
var makeMapKey = (current) => new MapKeyImpl(current);
var isMapKey = (u) => hasProperty(u, MapKeyTypeId);

class KeySetImpl {
  head = undefined;
  tail = undefined;
  add(key) {
    if (key !== this.tail) {
      if (this.tail === undefined) {
        this.head = key;
        this.tail = key;
      } else {
        const previous = key.previous;
        const next = key.next;
        if (next !== undefined) {
          key.next = undefined;
          if (previous !== undefined) {
            previous.next = next;
            next.previous = previous;
          } else {
            this.head = next;
            this.head.previous = undefined;
          }
        }
        this.tail.next = key;
        key.previous = this.tail;
        this.tail = key;
      }
    }
  }
  remove() {
    const key = this.head;
    if (key !== undefined) {
      const next = key.next;
      if (next !== undefined) {
        key.next = undefined;
        this.head = next;
        this.head.previous = undefined;
      } else {
        this.head = undefined;
        this.tail = undefined;
      }
    }
    return key;
  }
}
var makeKeySet = () => new KeySetImpl;
var makeCacheState = (map12, keys3, accesses, updating, hits, misses) => ({
  map: map12,
  keys: keys3,
  accesses,
  updating,
  hits,
  misses
});
var initialCacheState = () => makeCacheState(empty17(), makeKeySet(), unbounded(), make11(false), 0, 0);
var CacheSymbolKey = "effect/Cache";
var CacheTypeId = /* @__PURE__ */ Symbol.for(CacheSymbolKey);
var cacheVariance = {
  _Key: (_) => _,
  _Error: (_) => _,
  _Value: (_) => _
};
var ConsumerCacheSymbolKey = "effect/ConsumerCache";
var ConsumerCacheTypeId = /* @__PURE__ */ Symbol.for(ConsumerCacheSymbolKey);
var consumerCacheVariance = {
  _Key: (_) => _,
  _Error: (_) => _,
  _Value: (_) => _
};
var makeCacheStats = (options) => options;
var makeEntryStats = (loadedMillis) => ({
  loadedMillis
});

class CacheImpl {
  capacity;
  context;
  fiberId;
  lookup;
  timeToLive;
  [CacheTypeId] = cacheVariance;
  [ConsumerCacheTypeId] = consumerCacheVariance;
  cacheState;
  constructor(capacity2, context2, fiberId2, lookup, timeToLive) {
    this.capacity = capacity2;
    this.context = context2;
    this.fiberId = fiberId2;
    this.lookup = lookup;
    this.timeToLive = timeToLive;
    this.cacheState = initialCacheState();
  }
  get(key) {
    return map10(this.getEither(key), merge);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size4(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match2(get8(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value) => this.resolveMapValue(value)
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match2(get8(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value) => this.resolveMapValue(value, true)
    }));
  }
  contains(key) {
    return sync(() => has4(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const option2 = get8(this.cacheState.map, key);
      if (isSome2(option2)) {
        switch (option2.value._tag) {
          case "Complete": {
            const loaded = option2.value.entryStats.loadedMillis;
            return some2(makeEntryStats(loaded));
          }
          case "Pending": {
            return none2();
          }
          case "Refreshing": {
            const loaded = option2.value.complete.entryStats.loadedMillis;
            return some2(makeEntryStats(loaded));
          }
        }
      }
      return none2();
    });
  }
  getEither(key) {
    return suspend(() => {
      const k = key;
      let mapKey = undefined;
      let deferred = undefined;
      let value = getOrUndefined(get8(this.cacheState.map, k));
      if (value === undefined) {
        deferred = unsafeMake4(this.fiberId);
        mapKey = makeMapKey(k);
        if (has4(this.cacheState.map, k)) {
          value = getOrUndefined(get8(this.cacheState.map, k));
        } else {
          set4(this.cacheState.map, k, pending2(mapKey, deferred));
        }
      }
      if (value === undefined) {
        this.trackAccess(mapKey);
        this.trackMiss();
        return map10(this.lookupValueOf(key, deferred), right2);
      } else {
        return flatMap8(this.resolveMapValue(value), match2({
          onNone: () => this.getEither(key),
          onSome: (value2) => succeed(left2(value2))
        }));
      }
    });
  }
  invalidate(key) {
    return sync(() => {
      remove5(this.cacheState.map, key);
    });
  }
  invalidateWhen(key, when2) {
    return sync(() => {
      const value = get8(this.cacheState.map, key);
      if (isSome2(value) && value.value._tag === "Complete") {
        if (value.value.exit._tag === "Success") {
          if (when2(value.value.exit.value)) {
            remove5(this.cacheState.map, key);
          }
        }
      }
    });
  }
  get invalidateAll() {
    return sync(() => {
      this.cacheState.map = empty17();
    });
  }
  refresh(key) {
    return clockWith3((clock2) => suspend(() => {
      const k = key;
      const deferred = unsafeMake4(this.fiberId);
      let value = getOrUndefined(get8(this.cacheState.map, k));
      if (value === undefined) {
        if (has4(this.cacheState.map, k)) {
          value = getOrUndefined(get8(this.cacheState.map, k));
        } else {
          set4(this.cacheState.map, k, pending2(makeMapKey(k), deferred));
        }
      }
      if (value === undefined) {
        return asVoid(this.lookupValueOf(key, deferred));
      } else {
        switch (value._tag) {
          case "Complete": {
            if (this.hasExpired(clock2, value.timeToLiveMillis)) {
              const found = getOrUndefined(get8(this.cacheState.map, k));
              if (equals(found, value)) {
                remove5(this.cacheState.map, k);
              }
              return asVoid(this.get(key));
            }
            return pipe(this.lookupValueOf(key, deferred), when(() => {
              const current = getOrUndefined(get8(this.cacheState.map, k));
              if (equals(current, value)) {
                const mapValue = refreshing(deferred, value);
                set4(this.cacheState.map, k, mapValue);
                return true;
              }
              return false;
            }), asVoid);
          }
          case "Pending": {
            return _await(value.deferred);
          }
          case "Refreshing": {
            return _await(value.deferred);
          }
        }
      }
    }));
  }
  set(key, value) {
    return clockWith3((clock2) => sync(() => {
      const now = clock2.unsafeCurrentTimeMillis();
      const k = key;
      const lookupResult = succeed3(value);
      const mapValue = complete2(makeMapKey(k), lookupResult, makeEntryStats(now), now + toMillis(decode(this.timeToLive(lookupResult))));
      set4(this.cacheState.map, k, mapValue);
    }));
  }
  get size() {
    return sync(() => {
      return size4(this.cacheState.map);
    });
  }
  get values() {
    return sync(() => {
      const values3 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values3.push(entry[1].exit.value);
        }
      }
      return values3;
    });
  }
  get entries() {
    return sync(() => {
      const values3 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values3.push([entry[0], entry[1].exit.value]);
        }
      }
      return values3;
    });
  }
  get keys() {
    return sync(() => {
      const keys3 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          keys3.push(entry[0]);
        }
      }
      return keys3;
    });
  }
  resolveMapValue(value, ignorePending = false) {
    return clockWith3((clock2) => {
      switch (value._tag) {
        case "Complete": {
          this.trackAccess(value.key);
          if (this.hasExpired(clock2, value.timeToLiveMillis)) {
            remove5(this.cacheState.map, value.key.current);
            return succeed(none2());
          }
          this.trackHit();
          return map10(value.exit, some2);
        }
        case "Pending": {
          this.trackAccess(value.key);
          this.trackHit();
          if (ignorePending) {
            return succeed(none2());
          }
          return map10(_await(value.deferred), some2);
        }
        case "Refreshing": {
          this.trackAccess(value.complete.key);
          this.trackHit();
          if (this.hasExpired(clock2, value.complete.timeToLiveMillis)) {
            if (ignorePending) {
              return succeed(none2());
            }
            return map10(_await(value.deferred), some2);
          }
          return map10(value.complete.exit, some2);
        }
      }
    });
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop2 = true;
      while (loop2) {
        const key2 = poll2(this.cacheState.accesses, EmptyMutableQueue);
        if (key2 === EmptyMutableQueue) {
          loop2 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size5 = size4(this.cacheState.map);
      loop2 = size5 > this.capacity;
      while (loop2) {
        const key2 = this.cacheState.keys.remove();
        if (key2 !== undefined) {
          if (has4(this.cacheState.map, key2.current)) {
            remove5(this.cacheState.map, key2.current);
            size5 = size5 - 1;
            loop2 = size5 > this.capacity;
          }
        } else {
          loop2 = false;
        }
      }
      set2(this.cacheState.updating, false);
    }
  }
  hasExpired(clock2, timeToLiveMillis) {
    return clock2.unsafeCurrentTimeMillis() > timeToLiveMillis;
  }
  lookupValueOf(input, deferred) {
    return clockWith3((clock2) => suspend(() => {
      const key = input;
      return pipe(this.lookup(input), provideContext(this.context), exit, flatMap8((exit2) => {
        const now = clock2.unsafeCurrentTimeMillis();
        const stats = makeEntryStats(now);
        const value = complete2(makeMapKey(key), exit2, stats, now + toMillis(decode(this.timeToLive(exit2))));
        set4(this.cacheState.map, key, value);
        return zipRight(done2(deferred, exit2), exit2);
      }), onInterrupt(() => zipRight(interrupt3(deferred), sync(() => {
        remove5(this.cacheState.map, key);
      }))));
    }));
  }
}
var unsafeMakeWith = (capacity2, lookup, timeToLive) => new CacheImpl(capacity2, empty3(), none3, lookup, (exit2) => decode(timeToLive(exit2)));
// node_modules/effect/dist/esm/Cause.js
var fail5 = fail;
var die4 = die;
var interrupt5 = interrupt;
var isFailType2 = isFailType;
var isDieType2 = isDieType;
var isInterrupted2 = isInterrupted;
var isInterruptedOnly2 = isInterruptedOnly;
var interruptors2 = interruptors;
var failureOrCause2 = failureOrCause;
var flipCauseOption2 = flipCauseOption;
var map12 = map9;
var squash = causeSquash;
var IllegalArgumentException2 = IllegalArgumentException;
var NoSuchElementException2 = NoSuchElementException;
var RuntimeException2 = RuntimeException;
var isRuntimeException2 = isRuntimeException;
var pretty2 = pretty;
// node_modules/effect/dist/esm/Effect.js
var exports_Effect = {};
__export(exports_Effect, {
  zipWith: () => zipWith5,
  zipRight: () => zipRight3,
  zipLeft: () => zipLeft2,
  zip: () => zip5,
  yieldNow: () => yieldNow4,
  withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel2,
  withTracerTiming: () => withTracerTiming2,
  withTracerScoped: () => withTracerScoped2,
  withTracerEnabled: () => withTracerEnabled2,
  withTracer: () => withTracer2,
  withSpanScoped: () => withSpanScoped2,
  withSpan: () => withSpan3,
  withSchedulingPriority: () => withSchedulingPriority2,
  withScheduler: () => withScheduler2,
  withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped,
  withRuntimeFlagsPatch: () => withRuntimeFlagsPatch,
  withRequestCaching: () => withRequestCaching2,
  withRequestCache: () => withRequestCache2,
  withRequestBatching: () => withRequestBatching2,
  withRandomScoped: () => withRandomScoped2,
  withRandomFixed: () => withRandomFixed,
  withRandom: () => withRandom2,
  withParentSpan: () => withParentSpan3,
  withMetric: () => withMetric2,
  withMaxOpsBeforeYield: () => withMaxOpsBeforeYield2,
  withLogSpan: () => withLogSpan2,
  withFiberRuntime: () => withFiberRuntime2,
  withExecutionPlan: () => withExecutionPlan2,
  withEarlyRelease: () => withEarlyRelease2,
  withConsoleScoped: () => withConsoleScoped2,
  withConsole: () => withConsole2,
  withConfigProviderScoped: () => withConfigProviderScoped2,
  withConfigProvider: () => withConfigProvider2,
  withConcurrency: () => withConcurrency2,
  withClockScoped: () => withClockScoped2,
  withClock: () => withClock2,
  whileLoop: () => whileLoop2,
  whenRef: () => whenRef2,
  whenLogLevel: () => whenLogLevel2,
  whenFiberRef: () => whenFiberRef2,
  whenEffect: () => whenEffect2,
  when: () => when2,
  void: () => _void,
  validateWith: () => validateWith2,
  validateFirst: () => validateFirst2,
  validateAll: () => validateAll2,
  validate: () => validate2,
  using: () => using2,
  useSpan: () => useSpan2,
  updateService: () => updateService2,
  updateFiberRefs: () => updateFiberRefs2,
  unsandbox: () => unsandbox2,
  unsafeMakeSemaphore: () => unsafeMakeSemaphore2,
  unsafeMakeLatch: () => unsafeMakeLatch2,
  unlessEffect: () => unlessEffect2,
  unless: () => unless2,
  uninterruptibleMask: () => uninterruptibleMask3,
  uninterruptible: () => uninterruptible2,
  tryPromise: () => tryPromise2,
  tryMapPromise: () => tryMapPromise2,
  tryMap: () => tryMap2,
  try: () => try_2,
  transposeOption: () => transposeOption,
  transposeMapOption: () => transposeMapOption,
  transplant: () => transplant2,
  tracerWith: () => tracerWith4,
  tracer: () => tracer2,
  timeoutTo: () => timeoutTo2,
  timeoutOption: () => timeoutOption2,
  timeoutFailCause: () => timeoutFailCause2,
  timeoutFail: () => timeoutFail2,
  timeout: () => timeout2,
  timedWith: () => timedWith2,
  timed: () => timed2,
  tapErrorTag: () => tapErrorTag2,
  tapErrorCause: () => tapErrorCause3,
  tapError: () => tapError3,
  tapDefect: () => tapDefect2,
  tapBoth: () => tapBoth2,
  tap: () => tap3,
  takeWhile: () => takeWhile3,
  takeUntil: () => takeUntil2,
  tagMetricsScoped: () => tagMetricsScoped2,
  tagMetrics: () => tagMetrics2,
  sync: () => sync3,
  suspend: () => suspend3,
  supervised: () => supervised2,
  summarized: () => summarized2,
  succeedSome: () => succeedSome2,
  succeedNone: () => succeedNone2,
  succeed: () => succeed8,
  step: () => step3,
  spanLinks: () => spanLinks2,
  spanAnnotations: () => spanAnnotations2,
  sleep: () => sleep4,
  setFiberRefs: () => setFiberRefs2,
  serviceOptional: () => serviceOptional2,
  serviceOption: () => serviceOption2,
  serviceMembers: () => serviceMembers2,
  serviceFunctions: () => serviceFunctions2,
  serviceFunctionEffect: () => serviceFunctionEffect2,
  serviceFunction: () => serviceFunction2,
  serviceConstants: () => serviceConstants2,
  sequentialFinalizers: () => sequentialFinalizers2,
  scopedWith: () => scopedWith2,
  scoped: () => scoped2,
  scopeWith: () => scopeWith2,
  scope: () => scope3,
  scheduleFrom: () => scheduleFrom,
  scheduleForked: () => scheduleForked2,
  schedule: () => schedule,
  sandbox: () => sandbox2,
  runtime: () => runtime3,
  runSyncExit: () => runSyncExit,
  runSync: () => runSync,
  runRequestBlock: () => runRequestBlock2,
  runPromiseExit: () => runPromiseExit,
  runPromise: () => runPromise,
  runFork: () => runFork2,
  runCallback: () => runCallback,
  retryOrElse: () => retryOrElse,
  retry: () => retry2,
  request: () => request,
  replicateEffect: () => replicateEffect2,
  replicate: () => replicate2,
  repeatOrElse: () => repeatOrElse,
  repeatN: () => repeatN2,
  repeat: () => repeat,
  reduceWhile: () => reduceWhile2,
  reduceRight: () => reduceRight4,
  reduceEffect: () => reduceEffect2,
  reduce: () => reduce10,
  randomWith: () => randomWith2,
  random: () => random3,
  raceWith: () => raceWith2,
  raceFirst: () => raceFirst2,
  raceAll: () => raceAll2,
  race: () => race2,
  provideServiceEffect: () => provideServiceEffect2,
  provideService: () => provideService2,
  provide: () => provide2,
  promise: () => promise2,
  patchRuntimeFlags: () => patchRuntimeFlags,
  patchFiberRefs: () => patchFiberRefs2,
  partition: () => partition4,
  parallelFinalizers: () => parallelFinalizers2,
  parallelErrors: () => parallelErrors2,
  orElseSucceed: () => orElseSucceed2,
  orElseFail: () => orElseFail2,
  orElse: () => orElse5,
  orDieWith: () => orDieWith2,
  orDie: () => orDie3,
  optionFromOptional: () => optionFromOptional2,
  option: () => option2,
  once: () => once3,
  onInterrupt: () => onInterrupt2,
  onExit: () => onExit3,
  onError: () => onError2,
  none: () => none9,
  never: () => never3,
  negate: () => negate2,
  metricLabels: () => metricLabels2,
  mergeAll: () => mergeAll5,
  merge: () => merge7,
  matchEffect: () => matchEffect2,
  matchCauseEffect: () => matchCauseEffect3,
  matchCause: () => matchCause3,
  match: () => match12,
  mapInputContext: () => mapInputContext2,
  mapErrorCause: () => mapErrorCause2,
  mapError: () => mapError3,
  mapBoth: () => mapBoth3,
  mapAccum: () => mapAccum4,
  map: () => map16,
  makeSpanScoped: () => makeSpanScoped2,
  makeSpan: () => makeSpan2,
  makeSemaphore: () => makeSemaphore2,
  makeLatch: () => makeLatch2,
  loop: () => loop2,
  logWithLevel: () => logWithLevel2,
  logWarning: () => logWarning2,
  logTrace: () => logTrace2,
  logInfo: () => logInfo2,
  logFatal: () => logFatal2,
  logError: () => logError2,
  logDebug: () => logDebug2,
  logAnnotations: () => logAnnotations2,
  log: () => log2,
  locallyWith: () => locallyWith,
  locallyScopedWith: () => locallyScopedWith,
  locallyScoped: () => locallyScoped,
  locally: () => locally,
  linkSpans: () => linkSpans2,
  linkSpanCurrent: () => linkSpanCurrent2,
  liftPredicate: () => liftPredicate2,
  let: () => let_3,
  labelMetricsScoped: () => labelMetricsScoped2,
  labelMetrics: () => labelMetrics2,
  iterate: () => iterate2,
  isSuccess: () => isSuccess3,
  isFailure: () => isFailure4,
  isEffect: () => isEffect2,
  intoDeferred: () => intoDeferred2,
  interruptibleMask: () => interruptibleMask2,
  interruptible: () => interruptible4,
  interruptWith: () => interruptWith2,
  interrupt: () => interrupt7,
  inheritFiberRefs: () => inheritFiberRefs2,
  ignoreLogged: () => ignoreLogged2,
  ignore: () => ignore2,
  if: () => if_2,
  head: () => head4,
  getRuntimeFlags: () => getRuntimeFlags,
  getFiberRefs: () => getFiberRefs,
  gen: () => gen2,
  functionWithSpan: () => functionWithSpan2,
  fromNullable: () => fromNullable3,
  fromFiberEffect: () => fromFiberEffect2,
  fromFiber: () => fromFiber2,
  forkWithErrorHandler: () => forkWithErrorHandler2,
  forkScoped: () => forkScoped2,
  forkIn: () => forkIn2,
  forkDaemon: () => forkDaemon2,
  forkAll: () => forkAll2,
  fork: () => fork3,
  forever: () => forever3,
  forEach: () => forEach6,
  fnUntraced: () => fnUntraced2,
  fn: () => fn,
  flipWith: () => flipWith2,
  flip: () => flip2,
  flatten: () => flatten9,
  flatMap: () => flatMap11,
  firstSuccessOf: () => firstSuccessOf2,
  findFirst: () => findFirst6,
  finalizersMask: () => finalizersMask2,
  filterOrFail: () => filterOrFail2,
  filterOrElse: () => filterOrElse2,
  filterOrDieMessage: () => filterOrDieMessage2,
  filterOrDie: () => filterOrDie2,
  filterMap: () => filterMap5,
  filterEffectOrFail: () => filterEffectOrFail2,
  filterEffectOrElse: () => filterEffectOrElse2,
  filter: () => filter7,
  fiberIdWith: () => fiberIdWith2,
  fiberId: () => fiberId2,
  failSync: () => failSync3,
  failCauseSync: () => failCauseSync3,
  failCause: () => failCause8,
  fail: () => fail9,
  exit: () => exit2,
  exists: () => exists3,
  every: () => every6,
  eventually: () => eventually2,
  ensuringChildren: () => ensuringChildren2,
  ensuringChild: () => ensuringChild2,
  ensuring: () => ensuring2,
  ensureSuccessType: () => ensureSuccessType,
  ensureRequirementsType: () => ensureRequirementsType,
  ensureErrorType: () => ensureErrorType,
  either: () => either3,
  dropWhile: () => dropWhile3,
  dropUntil: () => dropUntil2,
  disconnect: () => disconnect2,
  diffFiberRefs: () => diffFiberRefs2,
  dieSync: () => dieSync3,
  dieMessage: () => dieMessage2,
  die: () => die6,
  descriptorWith: () => descriptorWith2,
  descriptor: () => descriptor2,
  delay: () => delay2,
  daemonChildren: () => daemonChildren2,
  custom: () => custom2,
  currentSpan: () => currentSpan2,
  currentParentSpan: () => currentParentSpan2,
  contextWithEffect: () => contextWithEffect2,
  contextWith: () => contextWith2,
  context: () => context3,
  consoleWith: () => consoleWith2,
  console: () => console3,
  configProviderWith: () => configProviderWith2,
  clockWith: () => clockWith4,
  clock: () => clock2,
  checkInterruptible: () => checkInterruptible2,
  cause: () => cause2,
  catchTags: () => catchTags2,
  catchTag: () => catchTag2,
  catchSomeDefect: () => catchSomeDefect2,
  catchSomeCause: () => catchSomeCause2,
  catchSome: () => catchSome2,
  catchIf: () => catchIf2,
  catchAllDefect: () => catchAllDefect2,
  catchAllCause: () => catchAllCause3,
  catchAll: () => catchAll3,
  catch: () => _catch2,
  cachedWithTTL: () => cachedWithTTL,
  cachedInvalidateWithTTL: () => cachedInvalidateWithTTL2,
  cachedFunction: () => cachedFunction2,
  cached: () => cached3,
  cacheRequestResult: () => cacheRequestResult,
  blocked: () => blocked2,
  bindTo: () => bindTo3,
  bindAll: () => bindAll2,
  bind: () => bind3,
  awaitAllChildren: () => awaitAllChildren2,
  asyncEffect: () => asyncEffect2,
  async: () => async,
  asVoid: () => asVoid3,
  asSomeError: () => asSomeError2,
  asSome: () => asSome2,
  as: () => as3,
  ap: () => ap,
  annotateSpans: () => annotateSpans3,
  annotateLogsScoped: () => annotateLogsScoped2,
  annotateLogs: () => annotateLogs3,
  annotateCurrentSpan: () => annotateCurrentSpan2,
  andThen: () => andThen4,
  allowInterrupt: () => allowInterrupt2,
  allWith: () => allWith2,
  allSuccesses: () => allSuccesses2,
  all: () => all4,
  addFinalizer: () => addFinalizer3,
  acquireUseRelease: () => acquireUseRelease2,
  acquireReleaseInterruptible: () => acquireReleaseInterruptible2,
  acquireRelease: () => acquireRelease2,
  Tag: () => Tag3,
  Service: () => Service,
  EffectTypeId: () => EffectTypeId3,
  Do: () => Do2
});

// node_modules/effect/dist/esm/internal/schedule/interval.js
var IntervalSymbolKey = "effect/ScheduleInterval";
var IntervalTypeId = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
var empty24 = {
  [IntervalTypeId]: IntervalTypeId,
  startMillis: 0,
  endMillis: 0
};
var make34 = (startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty24;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
};
var lessThan2 = /* @__PURE__ */ dual(2, (self2, that) => min2(self2, that) === self2);
var min2 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2.endMillis <= that.startMillis)
    return self2;
  if (that.endMillis <= self2.startMillis)
    return that;
  if (self2.startMillis < that.startMillis)
    return self2;
  if (that.startMillis < self2.startMillis)
    return that;
  if (self2.endMillis <= that.endMillis)
    return self2;
  return that;
});
var isEmpty8 = (self2) => {
  return self2.startMillis >= self2.endMillis;
};
var intersect = /* @__PURE__ */ dual(2, (self2, that) => {
  const start = Math.max(self2.startMillis, that.startMillis);
  const end = Math.min(self2.endMillis, that.endMillis);
  return make34(start, end);
});
var size6 = (self2) => {
  return millis(self2.endMillis - self2.startMillis);
};
var after = (startMilliseconds) => {
  return make34(startMilliseconds, Number.POSITIVE_INFINITY);
};

// node_modules/effect/dist/esm/ScheduleInterval.js
var make35 = make34;
var empty25 = empty24;
var lessThan3 = lessThan2;
var isEmpty9 = isEmpty8;
var intersect2 = intersect;
var size7 = size6;
var after2 = after;

// node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey = "effect/ScheduleIntervals";
var IntervalsTypeId = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
var make36 = (intervals) => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
};
var intersect3 = /* @__PURE__ */ dual(2, (self2, that) => intersectLoop(self2.intervals, that.intervals, empty4()));
var intersectLoop = (_left, _right, _acc) => {
  let left3 = _left;
  let right3 = _right;
  let acc = _acc;
  while (isNonEmpty2(left3) && isNonEmpty2(right3)) {
    const interval = pipe(headNonEmpty2(left3), intersect2(headNonEmpty2(right3)));
    const intervals = isEmpty9(interval) ? acc : pipe(acc, prepend2(interval));
    if (pipe(headNonEmpty2(left3), lessThan3(headNonEmpty2(right3)))) {
      left3 = tailNonEmpty2(left3);
    } else {
      right3 = tailNonEmpty2(right3);
    }
    acc = intervals;
  }
  return make36(reverse2(acc));
};
var start = (self2) => {
  return pipe(self2.intervals, head2, getOrElse(() => empty25)).startMillis;
};
var end = (self2) => {
  return pipe(self2.intervals, head2, getOrElse(() => empty25)).endMillis;
};
var lessThan4 = /* @__PURE__ */ dual(2, (self2, that) => start(self2) < start(that));
var isNonEmpty4 = (self2) => {
  return isNonEmpty2(self2.intervals);
};

// node_modules/effect/dist/esm/ScheduleIntervals.js
var make37 = make36;
var intersect4 = intersect3;
var start2 = start;
var end2 = end;
var lessThan5 = lessThan4;
var isNonEmpty5 = isNonEmpty4;

// node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE = "Continue";
var OP_DONE2 = "Done";
var _continue = (intervals) => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
};
var continueWith = (interval) => {
  return {
    _tag: OP_CONTINUE,
    intervals: make37(of2(interval))
  };
};
var done5 = {
  _tag: OP_DONE2
};
var isContinue = (self2) => {
  return self2._tag === OP_CONTINUE;
};
var isDone4 = (self2) => {
  return self2._tag === OP_DONE2;
};

// node_modules/effect/dist/esm/ScheduleDecision.js
var _continue2 = _continue;
var continueWith2 = continueWith;
var done6 = done5;
var isContinue2 = isContinue;
var isDone5 = isDone4;

// node_modules/effect/dist/esm/Scope.js
var Scope = scopeTag;
var addFinalizer2 = scopeAddFinalizer;
var addFinalizerExit = scopeAddFinalizerExit;
var close = scopeClose;
var extend2 = scopeExtend;
var fork2 = scopeFork;
var make38 = scopeMake;

// node_modules/effect/dist/esm/internal/effect/circular.js
class Semaphore {
  permits;
  waiters = /* @__PURE__ */ new Set;
  taken = 0;
  constructor(permits) {
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
  take = (n) => asyncInterrupt((resume2) => {
    if (this.free < n) {
      const observer = () => {
        if (this.free < n) {
          return;
        }
        this.waiters.delete(observer);
        this.taken += n;
        resume2(succeed(n));
      };
      this.waiters.add(observer);
      return sync(() => {
        this.waiters.delete(observer);
      });
    }
    this.taken += n;
    return resume2(succeed(n));
  });
  updateTakenUnsafe(fiber, f) {
    this.taken = f(this.taken);
    if (this.waiters.size > 0) {
      fiber.getFiberRef(currentScheduler).scheduleTask(() => {
        const iter = this.waiters.values();
        let item = iter.next();
        while (item.done === false && this.free > 0) {
          item.value();
          item = iter.next();
        }
      }, fiber.getFiberRef(currentSchedulingPriority));
    }
    return succeed(this.free);
  }
  updateTaken(f) {
    return withFiberRuntime((fiber) => this.updateTakenUnsafe(fiber, f));
  }
  resize = (permits) => asVoid(withFiberRuntime((fiber) => {
    this.permits = permits;
    if (this.free < 0) {
      return void_;
    }
    return this.updateTakenUnsafe(fiber, (taken) => taken);
  }));
  release = (n) => this.updateTaken((taken) => taken - n);
  releaseAll = /* @__PURE__ */ this.updateTaken((_) => 0);
  withPermits = (n) => (self2) => uninterruptibleMask((restore) => flatMap8(restore(this.take(n)), (permits) => ensuring(restore(self2), this.release(permits))));
  withPermitsIfAvailable = (n) => (self2) => uninterruptibleMask((restore) => suspend(() => {
    if (this.free < n) {
      return succeedNone;
    }
    this.taken += n;
    return ensuring(restore(asSome(self2)), this.release(n));
  }));
}
var unsafeMakeSemaphore = (permits) => new Semaphore(permits);
var makeSemaphore = (permits) => sync(() => unsafeMakeSemaphore(permits));

class Latch extends Class {
  isOpen;
  waiters = [];
  scheduled = false;
  constructor(isOpen) {
    super();
    this.isOpen = isOpen;
  }
  commit() {
    return this.await;
  }
  unsafeSchedule(fiber) {
    if (this.scheduled || this.waiters.length === 0) {
      return void_;
    }
    this.scheduled = true;
    fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
    return void_;
  }
  flushWaiters = () => {
    this.scheduled = false;
    const waiters = this.waiters;
    this.waiters = [];
    for (let i = 0;i < waiters.length; i++) {
      waiters[i](exitVoid);
    }
  };
  open = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_;
    }
    this.isOpen = true;
    return this.unsafeSchedule(fiber);
  });
  unsafeOpen() {
    if (this.isOpen)
      return;
    this.isOpen = true;
    this.flushWaiters();
  }
  release = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_;
    }
    return this.unsafeSchedule(fiber);
  });
  await = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.isOpen) {
      return resume2(void_);
    }
    this.waiters.push(resume2);
    return sync(() => {
      const index = this.waiters.indexOf(resume2);
      if (index !== -1) {
        this.waiters.splice(index, 1);
      }
    });
  });
  unsafeClose() {
    this.isOpen = false;
  }
  close = /* @__PURE__ */ sync(() => {
    this.isOpen = false;
  });
  whenOpen = (self2) => {
    return zipRight(this.await, self2);
  };
}
var unsafeMakeLatch = (open) => new Latch(open ?? false);
var makeLatch = (open) => sync(() => unsafeMakeLatch(open));
var awaitAllChildren = (self2) => ensuringChildren(self2, fiberAwaitAll);
var cached2 = /* @__PURE__ */ dual(2, (self2, timeToLive) => map10(cachedInvalidateWithTTL(self2, timeToLive), (tuple) => tuple[0]));
var cachedInvalidateWithTTL = /* @__PURE__ */ dual(2, (self2, timeToLive) => {
  const duration = decode(timeToLive);
  return flatMap8(context(), (env) => map10(makeSynchronized(none2()), (cache) => [provideContext(getCachedValue(self2, duration, cache), env), invalidateCache(cache)]));
});
var computeCachedValue = (self2, timeToLive, start3) => {
  const timeToLiveMillis = toMillis(decode(timeToLive));
  return pipe(deferredMake(), tap((deferred) => intoDeferred(self2, deferred)), map10((deferred) => some2([start3 + timeToLiveMillis, deferred])));
};
var getCachedValue = (self2, timeToLive, cache) => uninterruptibleMask((restore) => pipe(clockWith3((clock2) => clock2.currentTimeMillis), flatMap8((time) => updateSomeAndGetEffectSynchronized(cache, (option2) => {
  switch (option2._tag) {
    case "None": {
      return some2(computeCachedValue(self2, timeToLive, time));
    }
    case "Some": {
      const [end3] = option2.value;
      return end3 - time <= 0 ? some2(computeCachedValue(self2, timeToLive, time)) : none2();
    }
  }
})), flatMap8((option2) => isNone2(option2) ? dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option2.value[1])))));
var invalidateCache = (cache) => set5(cache, none2());
var ensuringChild = /* @__PURE__ */ dual(2, (self2, f) => ensuringChildren(self2, (children) => f(fiberAll(children))));
var ensuringChildren = /* @__PURE__ */ dual(2, (self2, children) => flatMap8(track, (supervisor) => pipe(supervised(self2, supervisor), ensuring(flatMap8(supervisor.value, children)))));
var forkAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (effects, options) => options?.discard ? forEachSequentialDiscard(effects, fork) : map10(forEachSequential(effects, fork), fiberAll));
var forkIn = /* @__PURE__ */ dual(2, (self2, scope2) => withFiberRuntime((parent, parentStatus) => {
  const scopeImpl = scope2;
  const fiber = unsafeFork(self2, parent, parentStatus.runtimeFlags, globalScope);
  if (scopeImpl.state._tag === "Open") {
    const finalizer = () => fiberIdWith((fiberId2) => equals(fiberId2, fiber.id()) ? void_ : asVoid(interruptFiber(fiber)));
    const key = {};
    scopeImpl.state.finalizers.set(key, finalizer);
    fiber.addObserver(() => {
      if (scopeImpl.state._tag === "Closed")
        return;
      scopeImpl.state.finalizers.delete(key);
    });
  } else {
    fiber.unsafeInterruptAsFork(parent.id());
  }
  return succeed(fiber);
}));
var forkScoped = (self2) => scopeWith((scope2) => forkIn(self2, scope2));
var fromFiber = (fiber) => join2(fiber);
var fromFiberEffect = (fiber) => suspend(() => flatMap8(fiber, join2));
var memoKeySymbol = /* @__PURE__ */ Symbol.for("effect/Effect/memoizeFunction.key");

class Key {
  a;
  eq;
  [memoKeySymbol] = memoKeySymbol;
  constructor(a, eq) {
    this.a = a;
    this.eq = eq;
  }
  [symbol2](that) {
    if (hasProperty(that, memoKeySymbol)) {
      if (this.eq) {
        return this.eq(this.a, that.a);
      } else {
        return equals(this.a, that.a);
      }
    }
    return false;
  }
  [symbol]() {
    return this.eq ? 0 : cached(this, hash(this.a));
  }
}
var cachedFunction = (f, eq) => {
  return pipe(sync(() => empty17()), flatMap8(makeSynchronized), map10((ref) => (a) => pipe(ref.modifyEffect((map13) => {
    const result = pipe(map13, get8(new Key(a, eq)));
    if (isNone2(result)) {
      return pipe(deferredMake(), tap((deferred) => pipe(diffFiberRefs(f(a)), intoDeferred(deferred), fork)), map10((deferred) => [deferred, pipe(map13, set4(new Key(a, eq), deferred))]));
    }
    return succeed([result.value, map13]);
  }), flatMap8(deferredAwait), flatMap8(([patch9, b]) => pipe(patchFiberRefs(patch9), as(b))))));
};
var raceFirst = /* @__PURE__ */ dual(2, (self2, that) => pipe(exit(self2), race(exit(that)), (effect) => flatten6(effect)));
var supervised = /* @__PURE__ */ dual(2, (self2, supervisor) => {
  const supervise = fiberRefLocallyWith(currentSupervisor, (s) => s.zip(supervisor));
  return supervise(self2);
});
var timeout = /* @__PURE__ */ dual(2, (self2, duration) => timeoutFail(self2, {
  onTimeout: () => timeoutExceptionFromDuration(duration),
  duration
}));
var timeoutFail = /* @__PURE__ */ dual(2, (self2, {
  duration,
  onTimeout
}) => flatten6(timeoutTo(self2, {
  onTimeout: () => failSync(onTimeout),
  onSuccess: succeed,
  duration
})));
var timeoutFailCause = /* @__PURE__ */ dual(2, (self2, {
  duration,
  onTimeout
}) => flatten6(timeoutTo(self2, {
  onTimeout: () => failCauseSync(onTimeout),
  onSuccess: succeed,
  duration
})));
var timeoutOption = /* @__PURE__ */ dual(2, (self2, duration) => timeoutTo(self2, {
  duration,
  onSuccess: some2,
  onTimeout: none2
}));
var timeoutTo = /* @__PURE__ */ dual(2, (self2, {
  duration,
  onSuccess,
  onTimeout
}) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self2), interruptible2(sleep3(duration)), {
  onSelfWin: (winner, loser) => flatMap8(winner.await, (exit2) => {
    if (exit2._tag === "Success") {
      return flatMap8(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onSuccess(exit2.value)));
    } else {
      return flatMap8(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit2.cause));
    }
  }),
  onOtherWin: (winner, loser) => flatMap8(winner.await, (exit2) => {
    if (exit2._tag === "Success") {
      return flatMap8(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onTimeout()));
    } else {
      return flatMap8(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit2.cause));
    }
  }),
  otherScope: globalScope
}))));
var SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
var SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
var synchronizedVariance = {
  _A: (_) => _
};

class SynchronizedImpl extends Class {
  ref;
  withLock;
  [SynchronizedTypeId] = synchronizedVariance;
  [RefTypeId] = refVariance;
  [TypeId12] = TypeId12;
  constructor(ref, withLock) {
    super();
    this.ref = ref;
    this.withLock = withLock;
    this.get = get11(this.ref);
  }
  get;
  commit() {
    return this.get;
  }
  modify(f) {
    return this.modifyEffect((a) => succeed(f(a)));
  }
  modifyEffect(f) {
    return this.withLock(pipe(flatMap8(get11(this.ref), f), flatMap8(([b, a]) => as(set5(this.ref, a), b))));
  }
}
var makeSynchronized = (value) => sync(() => unsafeMakeSynchronized(value));
var unsafeMakeSynchronized = (value) => {
  const ref = unsafeMake6(value);
  const sem = unsafeMakeSemaphore(1);
  return new SynchronizedImpl(ref, sem.withPermits(1));
};
var updateSomeAndGetEffectSynchronized = /* @__PURE__ */ dual(2, (self2, pf) => self2.modifyEffect((value) => {
  const result = pf(value);
  switch (result._tag) {
    case "None": {
      return succeed([value, value]);
    }
    case "Some": {
      return map10(result.value, (a) => [a, a]);
    }
  }
}));
var bindAll = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, f, options) => flatMap8(self2, (a) => all3(f(a), options).pipe(map10((record2) => Object.assign({}, a, record2)))));

// node_modules/effect/dist/esm/internal/managedRuntime/circular.js
var TypeId14 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");

// node_modules/effect/dist/esm/internal/opCodes/layer.js
var OP_EXTEND_SCOPE = "ExtendScope";
var OP_FOLD = "Fold";
var OP_FRESH = "Fresh";
var OP_FROM_EFFECT = "FromEffect";
var OP_SCOPED = "Scoped";
var OP_SUSPEND = "Suspend";
var OP_PROVIDE = "Provide";
var OP_PROVIDE_MERGE = "ProvideMerge";
var OP_MERGE_ALL = "MergeAll";
var OP_ZIP_WITH2 = "ZipWith";

// node_modules/effect/dist/esm/Fiber.js
var _await3 = _await2;
var inheritAll2 = inheritAll;
var interrupt6 = interruptFiber;
var interruptAs = interruptAsFiber;
var join3 = join2;
var poll4 = poll3;

// node_modules/effect/dist/esm/internal/runtime.js
var makeDual = (f) => function() {
  if (arguments.length === 1) {
    const runtime2 = arguments[0];
    return (effect, ...args2) => f(runtime2, effect, ...args2);
  }
  return f.apply(this, arguments);
};
var unsafeFork2 = /* @__PURE__ */ makeDual((runtime2, self2, options) => {
  const fiberId2 = unsafeMake3();
  const fiberRefUpdates = [[currentContext, [[fiberId2, runtime2.context]]]];
  if (options?.scheduler) {
    fiberRefUpdates.push([currentScheduler, [[fiberId2, options.scheduler]]]);
  }
  let fiberRefs3 = updateManyAs2(runtime2.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId2
  });
  if (options?.updateRefs) {
    fiberRefs3 = options.updateRefs(fiberRefs3, fiberId2);
  }
  const fiberRuntime = new FiberRuntime(fiberId2, fiberRefs3, runtime2.runtimeFlags);
  let effect = self2;
  if (options?.scope) {
    effect = flatMap8(fork2(options.scope, sequential2), (closeableScope) => zipRight(scopeAddFinalizer(closeableScope, fiberIdWith((id2) => equals(id2, fiberRuntime.id()) ? void_ : interruptAsFiber(fiberRuntime, id2))), onExit(self2, (exit2) => close(closeableScope, exit2))));
  }
  const supervisor = fiberRuntime.currentSupervisor;
  if (supervisor !== none8) {
    supervisor.onStart(runtime2.context, effect, none2(), fiberRuntime);
    fiberRuntime.addObserver((exit2) => supervisor.onEnd(exit2, fiberRuntime));
  }
  globalScope.add(runtime2.runtimeFlags, fiberRuntime);
  if (options?.immediate === false) {
    fiberRuntime.resume(effect);
  } else {
    fiberRuntime.start(effect);
  }
  return fiberRuntime;
});
var unsafeRunCallback = /* @__PURE__ */ makeDual((runtime2, effect, options = {}) => {
  const fiberRuntime = unsafeFork2(runtime2, effect, options);
  if (options.onExit) {
    fiberRuntime.addObserver((exit2) => {
      options.onExit(exit2);
    });
  }
  return (id2, cancelOptions) => unsafeRunCallback(runtime2)(pipe(fiberRuntime, interruptAs(id2 ?? none4)), {
    ...cancelOptions,
    onExit: cancelOptions?.onExit ? (exit2) => cancelOptions.onExit(flatten7(exit2)) : undefined
  });
});
var unsafeRunSync = /* @__PURE__ */ makeDual((runtime2, effect) => {
  const result = unsafeRunSyncExit(runtime2)(effect);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  }
  return result.effect_instruction_i0;
});

class AsyncFiberExceptionImpl extends Error {
  fiber;
  _tag = "AsyncFiberException";
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
}
var asyncFiberException = (fiber) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit;
  return error;
};
var FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");

class FiberFailureImpl extends Error {
  [FiberFailureId];
  [FiberFailureCauseId];
  constructor(cause2) {
    const head4 = prettyErrors(cause2)[0];
    super(head4?.message || "An error has occurred");
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause2;
    this.name = head4 ? `(FiberFailure) ${head4.name}` : "FiberFailure";
    if (head4?.stack) {
      this.stack = head4.stack;
    }
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
      renderErrorCause: true
    });
  }
  [NodeInspectSymbol]() {
    return this.toString();
  }
}
var fiberFailure = (cause2) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new FiberFailureImpl(cause2);
  Error.stackTraceLimit = limit;
  return error;
};
var fastPath = (effect) => {
  const op = effect;
  switch (op._op) {
    case "Failure":
    case "Success": {
      return op;
    }
    case "Left": {
      return exitFail(op.left);
    }
    case "Right": {
      return exitSucceed(op.right);
    }
    case "Some": {
      return exitSucceed(op.value);
    }
    case "None": {
      return exitFail(NoSuchElementException());
    }
  }
};
var unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime2, effect) => {
  const op = fastPath(effect);
  if (op) {
    return op;
  }
  const scheduler = new SyncScheduler;
  const fiberRuntime = unsafeFork2(runtime2)(effect, {
    scheduler
  });
  scheduler.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
});
var unsafeRunPromise = /* @__PURE__ */ makeDual((runtime2, effect, options) => unsafeRunPromiseExit(runtime2, effect, options).then((result) => {
  switch (result._tag) {
    case OP_SUCCESS: {
      return result.effect_instruction_i0;
    }
    case OP_FAILURE: {
      throw fiberFailure(result.effect_instruction_i0);
    }
  }
}));
var unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime2, effect, options) => new Promise((resolve) => {
  const op = fastPath(effect);
  if (op) {
    resolve(op);
  }
  const fiber = unsafeFork2(runtime2)(effect);
  fiber.addObserver((exit2) => {
    resolve(exit2);
  });
  if (options?.signal !== undefined) {
    if (options.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      }, {
        once: true
      });
    }
  }
}));

class RuntimeImpl {
  context;
  runtimeFlags;
  fiberRefs;
  constructor(context2, runtimeFlags2, fiberRefs3) {
    this.context = context2;
    this.runtimeFlags = runtimeFlags2;
    this.fiberRefs = fiberRefs3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var make39 = (options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
var runtime2 = () => withFiberRuntime((state, status2) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status2.runtimeFlags, state.getFiberRefs())));
var defaultRuntimeFlags = /* @__PURE__ */ make16(Interruption, CooperativeYielding, RuntimeMetrics);
var defaultRuntime = /* @__PURE__ */ make39({
  context: /* @__PURE__ */ empty3(),
  runtimeFlags: defaultRuntimeFlags,
  fiberRefs: /* @__PURE__ */ empty21()
});
var unsafeRunEffect = /* @__PURE__ */ unsafeRunCallback(defaultRuntime);
var unsafeForkEffect = /* @__PURE__ */ unsafeFork2(defaultRuntime);
var unsafeRunPromiseEffect = /* @__PURE__ */ unsafeRunPromise(defaultRuntime);
var unsafeRunPromiseExitEffect = /* @__PURE__ */ unsafeRunPromiseExit(defaultRuntime);
var unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);
var unsafeRunSyncExitEffect = /* @__PURE__ */ unsafeRunSyncExit(defaultRuntime);
var asyncEffect = (register) => suspend(() => {
  let cleanup = undefined;
  return flatMap8(deferredMake(), (deferred) => flatMap8(runtime2(), (runtime3) => uninterruptibleMask((restore) => zipRight(fork(restore(matchCauseEffect(register((cb) => unsafeRunCallback(runtime3)(intoDeferred(cb, deferred))), {
    onFailure: (cause2) => deferredFailCause(deferred, cause2),
    onSuccess: (cleanup_) => {
      cleanup = cleanup_;
      return void_;
    }
  }))), restore(onInterrupt(deferredAwait(deferred), () => cleanup ?? void_))))));
});

// node_modules/effect/dist/esm/internal/synchronizedRef.js
var modifyEffect = /* @__PURE__ */ dual(2, (self2, f) => self2.modifyEffect(f));

// node_modules/effect/dist/esm/internal/layer.js
var LayerSymbolKey = "effect/Layer";
var LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
var layerVariance = {
  _RIn: (_) => _,
  _E: (_) => _,
  _ROut: (_) => _
};
var proto3 = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MemoMapTypeIdKey = "effect/Layer/MemoMap";
var MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
var CurrentMemoMap = /* @__PURE__ */ Reference2()("effect/Layer/CurrentMemoMap", {
  defaultValue: () => unsafeMakeMemoMap()
});
var isLayer = (u) => hasProperty(u, LayerTypeId);
var isFresh = (self2) => {
  return self2._op_layer === OP_FRESH;
};

class MemoMapImpl {
  ref;
  [MemoMapTypeId];
  constructor(ref) {
    this.ref = ref;
    this[MemoMapTypeId] = MemoMapTypeId;
  }
  getOrElseMemoize(layer, scope2) {
    return pipe(modifyEffect(this.ref, (map14) => {
      const inMap = map14.get(layer);
      if (inMap !== undefined) {
        const [acquire, release] = inMap;
        const cached3 = pipe(acquire, flatMap8(([patch9, b]) => pipe(patchFiberRefs(patch9), as(b))), onExit(exitMatch({
          onFailure: () => void_,
          onSuccess: () => scopeAddFinalizerExit(scope2, release)
        })));
        return succeed([cached3, map14]);
      }
      return pipe(make27(0), flatMap8((observers) => pipe(deferredMake(), flatMap8((deferred) => pipe(make27(() => void_), map10((finalizerRef) => {
        const resource = uninterruptibleMask((restore) => pipe(scopeMake(), flatMap8((innerScope) => pipe(restore(flatMap8(makeBuilder(layer, innerScope, true), (f) => diffFiberRefs(f(this)))), exit, flatMap8((exit2) => {
          switch (exit2._tag) {
            case OP_FAILURE: {
              return pipe(deferredFailCause(deferred, exit2.effect_instruction_i0), zipRight(scopeClose(innerScope, exit2)), zipRight(failCause(exit2.effect_instruction_i0)));
            }
            case OP_SUCCESS: {
              return pipe(set5(finalizerRef, (exit3) => pipe(scopeClose(innerScope, exit3), whenEffect(modify3(observers, (n) => [n === 1, n - 1])), asVoid)), zipRight(update2(observers, (n) => n + 1)), zipRight(scopeAddFinalizerExit(scope2, (exit3) => pipe(sync(() => map14.delete(layer)), zipRight(get11(finalizerRef)), flatMap8((finalizer) => finalizer(exit3))))), zipRight(deferredSucceed(deferred, exit2.effect_instruction_i0)), as(exit2.effect_instruction_i0[1]));
            }
          }
        })))));
        const memoized = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
          onFailure: () => void_,
          onSuccess: () => update2(observers, (n) => n + 1)
        }))), (exit2) => pipe(get11(finalizerRef), flatMap8((finalizer) => finalizer(exit2)))];
        return [resource, isFresh(layer) ? map14 : map14.set(layer, memoized)];
      }))))));
    }), flatten6);
  }
}
var makeMemoMap = /* @__PURE__ */ suspend(() => map10(makeSynchronized(new Map), (ref) => new MemoMapImpl(ref)));
var unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(new Map));
var build = (self2) => scopeWith((scope2) => buildWithScope(self2, scope2));
var buildWithScope = /* @__PURE__ */ dual(2, (self2, scope2) => flatMap8(makeMemoMap, (memoMap) => buildWithMemoMap(self2, memoMap, scope2)));
var buildWithMemoMap = /* @__PURE__ */ dual(3, (self2, memoMap, scope2) => flatMap8(makeBuilder(self2, scope2), (run) => provideService(run(memoMap), CurrentMemoMap, memoMap)));
var makeBuilder = (self2, scope2, inMemoMap = false) => {
  const op = self2;
  switch (op._op_layer) {
    case "Locally": {
      return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope2)));
    }
    case "ExtendScope": {
      return sync(() => (memoMap) => scopeWith((scope3) => memoMap.getOrElseMemoize(op.layer, scope3)));
    }
    case "Fold": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope2), matchCauseEffect({
        onFailure: (cause2) => memoMap.getOrElseMemoize(op.failureK(cause2), scope2),
        onSuccess: (value) => memoMap.getOrElseMemoize(op.successK(value), scope2)
      })));
    }
    case "Fresh": {
      return sync(() => (_) => pipe(op.layer, buildWithScope(scope2)));
    }
    case "FromEffect": {
      return inMemoMap ? sync(() => (_) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope2));
    }
    case "Provide": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), flatMap8((env) => pipe(memoMap.getOrElseMemoize(op.second, scope2), provideContext(env)))));
    }
    case "Scoped": {
      return inMemoMap ? sync(() => (_) => scopeExtend(op.effect, scope2)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope2));
    }
    case "Suspend": {
      return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope2));
    }
    case "ProvideMerge": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), zipWith3(memoMap.getOrElseMemoize(op.second, scope2), op.zipK)));
    }
    case "ZipWith": {
      return gen(function* () {
        const parallelScope = yield* scopeFork(scope2, parallel2);
        const firstScope = yield* scopeFork(parallelScope, sequential2);
        const secondScope = yield* scopeFork(parallelScope, sequential2);
        return (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, firstScope), zipWithOptions(memoMap.getOrElseMemoize(op.second, secondScope), op.zipK, {
          concurrent: true
        }));
      });
    }
    case "MergeAll": {
      const layers = op.layers;
      return map10(scopeFork(scope2, parallel2), (parallelScope) => (memoMap) => {
        const contexts = new Array(layers.length);
        return map10(forEachConcurrentDiscard(layers, fnUntraced(function* (layer, i) {
          const scope3 = yield* scopeFork(parallelScope, sequential2);
          const context2 = yield* memoMap.getOrElseMemoize(layer, scope3);
          contexts[i] = context2;
        }), false, false), () => mergeAll2(...contexts));
      });
    }
  }
};
var catchAll2 = /* @__PURE__ */ dual(2, (self2, onFailure) => match11(self2, {
  onFailure,
  onSuccess: succeedContext
}));
var catchAllCause2 = /* @__PURE__ */ dual(2, (self2, onFailure) => matchCause2(self2, {
  onFailure,
  onSuccess: succeedContext
}));
var die5 = (defect) => failCause6(die4(defect));
var dieSync2 = (evaluate2) => failCauseSync2(() => die4(evaluate2()));
var discard = (self2) => map14(self2, () => empty3());
var context2 = () => fromEffectContext(context());
var extendScope = (self2) => {
  const extendScope2 = Object.create(proto3);
  extendScope2._op_layer = OP_EXTEND_SCOPE;
  extendScope2.layer = self2;
  return extendScope2;
};
var fail7 = (error) => failCause6(fail5(error));
var failSync2 = (evaluate2) => failCauseSync2(() => fail5(evaluate2()));
var failCause6 = (cause2) => fromEffectContext(failCause(cause2));
var failCauseSync2 = (evaluate2) => fromEffectContext(failCauseSync(evaluate2));
var flatMap10 = /* @__PURE__ */ dual(2, (self2, f) => match11(self2, {
  onFailure: fail7,
  onSuccess: f
}));
var flatten8 = /* @__PURE__ */ dual(2, (self2, tag) => flatMap10(self2, get3(tag)));
var fresh = (self2) => {
  const fresh2 = Object.create(proto3);
  fresh2._op_layer = OP_FRESH;
  fresh2.layer = self2;
  return fresh2;
};
var fromEffect3 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const effect = tagFirst ? b : a;
  return fromEffectContext(map10(effect, (service) => make5(tag, service)));
});
var fromEffectDiscard = (effect) => fromEffectContext(map10(effect, () => empty3()));
function fromEffectContext(effect) {
  const fromEffect4 = Object.create(proto3);
  fromEffect4._op_layer = OP_FROM_EFFECT;
  fromEffect4.effect = effect;
  return fromEffect4;
}
var fiberRefLocally2 = /* @__PURE__ */ dual(3, (self2, ref, value) => locallyEffect(self2, fiberRefLocally(ref, value)));
var locallyEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  const locally = Object.create(proto3);
  locally._op_layer = "Locally";
  locally.self = self2;
  locally.f = f;
  return locally;
});
var fiberRefLocallyWith2 = /* @__PURE__ */ dual(3, (self2, ref, value) => locallyEffect(self2, fiberRefLocallyWith(ref, value)));
var fiberRefLocallyScoped2 = (self2, value) => scopedDiscard(fiberRefLocallyScoped(self2, value));
var fiberRefLocallyScopedWith2 = (self2, value) => scopedDiscard(fiberRefLocallyScopedWith(self2, value));
var fromFunction = (tagA, tagB, f) => fromEffectContext(map10(tagA, (a) => make5(tagB, f(a))));
var launch = (self2) => scopedEffect(zipRight(scopeWith((scope2) => pipe(self2, buildWithScope(scope2))), never));
var mock = function() {
  if (arguments.length === 1) {
    return (service) => mockImpl(arguments[0], service);
  }
  return mockImpl(arguments[0], arguments[1]);
};
var mockImpl = (tag, service) => succeed6(tag, new Proxy({
  ...service
}, {
  get(target, prop, _receiver) {
    if (prop in target) {
      return target[prop];
    }
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error = new Error(`${tag.key}: Unimplemented method "${prop.toString()}"`);
    Error.stackTraceLimit = prevLimit;
    error.name = "UnimplementedError";
    return makeUnimplemented(error);
  },
  has: constTrue
}));
var makeUnimplemented = (error) => {
  const dead = die2(error);
  function unimplemented() {
    return dead;
  }
  Object.assign(unimplemented, dead);
  Object.setPrototypeOf(unimplemented, Object.getPrototypeOf(dead));
  return unimplemented;
};
var map14 = /* @__PURE__ */ dual(2, (self2, f) => flatMap10(self2, (context3) => succeedContext(f(context3))));
var mapError2 = /* @__PURE__ */ dual(2, (self2, f) => catchAll2(self2, (error) => failSync2(() => f(error))));
var matchCause2 = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  const fold = Object.create(proto3);
  fold._op_layer = OP_FOLD;
  fold.layer = self2;
  fold.failureK = onFailure;
  fold.successK = onSuccess;
  return fold;
});
var match11 = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => matchCause2(self2, {
  onFailure: (cause2) => {
    const failureOrCause3 = failureOrCause2(cause2);
    switch (failureOrCause3._tag) {
      case "Left": {
        return onFailure(failureOrCause3.left);
      }
      case "Right": {
        return failCause6(failureOrCause3.right);
      }
    }
  },
  onSuccess
}));
var memoize2 = (self2) => scopeWith((scope2) => map10(memoize(buildWithScope(self2, scope2)), fromEffectContext));
var merge6 = /* @__PURE__ */ dual(2, (self2, that) => zipWith4(self2, that, (a, b) => merge3(a, b)));
var mergeAll4 = (...layers) => {
  const mergeAll5 = Object.create(proto3);
  mergeAll5._op_layer = OP_MERGE_ALL;
  mergeAll5.layers = layers;
  return mergeAll5;
};
var orDie2 = (self2) => catchAll2(self2, (defect) => die5(defect));
var orElse4 = /* @__PURE__ */ dual(2, (self2, that) => catchAll2(self2, that));
var passthrough = (self2) => merge6(context2(), self2);
var project = /* @__PURE__ */ dual(4, (self2, tagA, tagB, f) => map14(self2, (context3) => make5(tagB, f(unsafeGet3(context3, tagA)))));
var retry = /* @__PURE__ */ dual(2, (self2, schedule) => suspend2(() => {
  const stateTag = GenericTag("effect/Layer/retry/{ state: unknown }");
  return pipe(succeed6(stateTag, {
    state: schedule.initial
  }), flatMap10((env) => retryLoop(self2, schedule, stateTag, pipe(env, get3(stateTag)).state)));
}));
var retryLoop = (self2, schedule, stateTag, state) => {
  return pipe(self2, catchAll2((error) => pipe(retryUpdate(schedule, stateTag, error, state), flatMap10((env) => fresh(retryLoop(self2, schedule, stateTag, pipe(env, get3(stateTag)).state))))));
};
var retryUpdate = (schedule, stateTag, error, state) => {
  return fromEffect3(stateTag, pipe(currentTimeMillis2, flatMap8((now) => pipe(schedule.step(now, error, state), flatMap8(([state2, _, decision]) => isDone5(decision) ? fail2(error) : pipe(sleep2(millis(start2(decision.intervals) - now)), as({
    state: state2
  })))))));
};
var scoped = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const effect = tagFirst ? b : a;
  return scopedContext(map10(effect, (service) => make5(tag, service)));
});
var scopedDiscard = (effect) => scopedContext(pipe(effect, as(empty3())));
var scopedContext = (effect) => {
  const scoped2 = Object.create(proto3);
  scoped2._op_layer = OP_SCOPED;
  scoped2.effect = effect;
  return scoped2;
};
var scope2 = /* @__PURE__ */ scopedContext(/* @__PURE__ */ map10(/* @__PURE__ */ acquireRelease(/* @__PURE__ */ scopeMake(), (scope3, exit2) => scope3.close(exit2)), (scope3) => make5(Scope, scope3)));
var service = (tag) => fromEffect3(tag, tag);
var succeed6 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const resource = tagFirst ? b : a;
  return fromEffectContext(succeed(make5(tag, resource)));
});
var succeedContext = (context3) => {
  return fromEffectContext(succeed(context3));
};
var empty27 = /* @__PURE__ */ succeedContext(/* @__PURE__ */ empty3());
var suspend2 = (evaluate2) => {
  const suspend3 = Object.create(proto3);
  suspend3._op_layer = OP_SUSPEND;
  suspend3.evaluate = evaluate2;
  return suspend3;
};
var sync2 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const evaluate2 = tagFirst ? b : a;
  return fromEffectContext(sync(() => make5(tag, evaluate2())));
});
var syncContext = (evaluate2) => {
  return fromEffectContext(sync(evaluate2));
};
var tap2 = /* @__PURE__ */ dual(2, (self2, f) => flatMap10(self2, (context3) => fromEffectContext(as(f(context3), context3))));
var tapError2 = /* @__PURE__ */ dual(2, (self2, f) => catchAll2(self2, (e) => fromEffectContext(flatMap8(f(e), () => fail2(e)))));
var tapErrorCause2 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause2(self2, (cause2) => fromEffectContext(flatMap8(f(cause2), () => failCause(cause2)))));
var toRuntime = (self2) => pipe(scopeWith((scope3) => buildWithScope(self2, scope3)), flatMap8((context3) => pipe(runtime2(), provideContext(context3))));
var toRuntimeWithMemoMap = /* @__PURE__ */ dual(2, (self2, memoMap) => flatMap8(scopeWith((scope3) => buildWithMemoMap(self2, memoMap, scope3)), (context3) => pipe(runtime2(), provideContext(context3))));
var provide = /* @__PURE__ */ dual(2, (self2, that) => suspend2(() => {
  const provideTo = Object.create(proto3);
  provideTo._op_layer = OP_PROVIDE;
  provideTo.first = Object.create(proto3, {
    _op_layer: {
      value: OP_PROVIDE_MERGE,
      enumerable: true
    },
    first: {
      value: context2(),
      enumerable: true
    },
    second: {
      value: Array.isArray(that) ? mergeAll4(...that) : that
    },
    zipK: {
      value: (a, b) => pipe(a, merge3(b))
    }
  });
  provideTo.second = self2;
  return provideTo;
}));
var provideMerge = /* @__PURE__ */ dual(2, (that, self2) => {
  const zipWith4 = Object.create(proto3);
  zipWith4._op_layer = OP_PROVIDE_MERGE;
  zipWith4.first = self2;
  zipWith4.second = provide(that, self2);
  zipWith4.zipK = (a, b) => {
    return pipe(a, merge3(b));
  };
  return zipWith4;
});
var zipWith4 = /* @__PURE__ */ dual(3, (self2, that, f) => suspend2(() => {
  const zipWith5 = Object.create(proto3);
  zipWith5._op_layer = OP_ZIP_WITH2;
  zipWith5.first = self2;
  zipWith5.second = that;
  zipWith5.zipK = f;
  return zipWith5;
}));
var unwrapEffect = (self2) => {
  const tag = GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
  return flatMap10(fromEffect3(tag, self2), (context3) => get3(context3, tag));
};
var unwrapScoped = (self2) => {
  const tag = GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
  return flatMap10(scoped(tag, self2), (context3) => get3(context3, tag));
};
var annotateLogs2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith2(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations2) => Object.entries(args2[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
});
var annotateSpans2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith2(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations2) => Object.entries(args2[1]).reduce((acc, [key, value]) => set3(acc, key, value), annotations2));
});
var withSpan2 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return unwrapScoped(map10(options?.onEnd ? tap(makeSpanScoped(name, options), (span2) => addFinalizer((exit2) => options.onEnd(span2, exit2))) : makeSpanScoped(name, options), (span2) => withParentSpan2(self2, span2)));
  }
  return (self2) => unwrapScoped(map10(options?.onEnd ? tap(makeSpanScoped(name, options), (span2) => addFinalizer((exit2) => options.onEnd(span2, exit2))) : makeSpanScoped(name, options), (span2) => withParentSpan2(self2, span2)));
};
var withParentSpan2 = /* @__PURE__ */ dual(2, (self2, span2) => provide(self2, succeedContext(make5(spanTag, span2))));
var provideSomeLayer = /* @__PURE__ */ dual(2, (self2, layer) => scopedWith((scope3) => flatMap8(buildWithScope(layer, scope3), (context3) => provideSomeContext(self2, context3))));
var provideSomeRuntime = /* @__PURE__ */ dual(2, (self2, rt) => {
  const patchRefs = diff6(defaultRuntime.fiberRefs, rt.fiberRefs);
  const patchFlags = diff4(defaultRuntime.runtimeFlags, rt.runtimeFlags);
  return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
    const oldContext = fiber.getFiberRef(currentContext);
    const oldRefs = fiber.getFiberRefs();
    const newRefs = patch7(fiber.id(), oldRefs)(patchRefs);
    const oldFlags = fiber.currentRuntimeFlags;
    const newFlags = patch4(patchFlags)(oldFlags);
    const rollbackRefs = diff6(newRefs, oldRefs);
    const rollbackFlags = diff4(newFlags, oldFlags);
    fiber.setFiberRefs(newRefs);
    fiber.currentRuntimeFlags = newFlags;
    return ensuring(provideSomeContext(restore(self2), merge3(oldContext, rt.context)), withFiberRuntime((fiber2) => {
      fiber2.setFiberRefs(patch7(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
      fiber2.currentRuntimeFlags = patch4(rollbackFlags)(fiber2.currentRuntimeFlags);
      return void_;
    }));
  }));
});
var effect_provide = /* @__PURE__ */ dual(2, (self2, source) => {
  if (Array.isArray(source)) {
    return provideSomeLayer(self2, mergeAll4(...source));
  } else if (isLayer(source)) {
    return provideSomeLayer(self2, source);
  } else if (isContext2(source)) {
    return provideSomeContext(self2, source);
  } else if (TypeId14 in source) {
    return flatMap8(source.runtimeEffect, (rt) => provideSomeRuntime(self2, rt));
  } else {
    return provideSomeRuntime(self2, source);
  }
});

// node_modules/effect/dist/esm/internal/console.js
var console2 = /* @__PURE__ */ map10(/* @__PURE__ */ fiberRefGet(currentServices), /* @__PURE__ */ get3(consoleTag));
var consoleWith = (f) => fiberRefGetWith(currentServices, (services) => f(get3(services, consoleTag)));
var withConsole = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(effect, currentServices, add2(consoleTag, value)));
var withConsoleScoped = (console3) => fiberRefLocallyScopedWith(currentServices, add2(consoleTag, console3));

// node_modules/effect/dist/esm/Data.js
var Error3 = /* @__PURE__ */ function() {
  const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
  const O = {
    BaseEffectError: class extends YieldableError {
      constructor(args2) {
        super(args2?.message, args2?.cause ? {
          cause: args2.cause
        } : undefined);
        if (args2) {
          Object.assign(this, args2);
          Object.defineProperty(this, plainArgsSymbol, {
            value: args2,
            enumerable: false
          });
        }
      }
      toJSON() {
        return {
          ...this[plainArgsSymbol],
          ...this
        };
      }
    }
  };
  return O.BaseEffectError;
}();
var TaggedError = (tag) => {
  const O = {
    BaseEffectError: class extends Error3 {
      _tag = tag;
    }
  };
  O.BaseEffectError.prototype.name = tag;
  return O.BaseEffectError;
};

// node_modules/effect/dist/esm/Random.js
var fixed2 = fixed;

// node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey = "effect/Schedule";
var ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
var isSchedule = (u) => hasProperty(u, ScheduleTypeId);
var ScheduleDriverSymbolKey = "effect/ScheduleDriver";
var ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
var defaultIterationMetadata = {
  start: 0,
  now: 0,
  input: undefined,
  output: undefined,
  elapsed: zero,
  elapsedSincePrevious: zero,
  recurrence: 0
};
var CurrentIterationMetadata = /* @__PURE__ */ Reference2()("effect/Schedule/CurrentIterationMetadata", {
  defaultValue: () => defaultIterationMetadata
});
var scheduleVariance = {
  _Out: (_) => _,
  _In: (_) => _,
  _R: (_) => _
};
var scheduleDriverVariance = {
  _Out: (_) => _,
  _In: (_) => _,
  _R: (_) => _
};

class ScheduleImpl {
  initial;
  step;
  [ScheduleTypeId] = scheduleVariance;
  constructor(initial, step3) {
    this.initial = initial;
    this.step = step3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var updateInfo = (iterationMetaRef, now, input, output) => update2(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
  now,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: zero,
  elapsedSincePrevious: zero,
  start: now
} : {
  now,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: millis(now - prev.start),
  elapsedSincePrevious: millis(now - prev.now),
  start: prev.start
});

class ScheduleDriverImpl {
  schedule;
  ref;
  [ScheduleDriverTypeId] = scheduleDriverVariance;
  constructor(schedule, ref) {
    this.schedule = schedule;
    this.ref = ref;
  }
  get state() {
    return map10(get11(this.ref), (tuple) => tuple[1]);
  }
  get last() {
    return flatMap8(get11(this.ref), ([element, _]) => {
      switch (element._tag) {
        case "None": {
          return failSync(() => new NoSuchElementException);
        }
        case "Some": {
          return succeed(element.value);
        }
      }
    });
  }
  iterationMeta = /* @__PURE__ */ unsafeMake6(defaultIterationMetadata);
  get reset() {
    return set5(this.ref, [none2(), this.schedule.initial]).pipe(zipLeft(set5(this.iterationMeta, defaultIterationMetadata)));
  }
  next(input) {
    return pipe(map10(get11(this.ref), (tuple) => tuple[1]), flatMap8((state) => pipe(currentTimeMillis2, flatMap8((now) => pipe(suspend(() => this.schedule.step(now, input, state)), flatMap8(([state2, out, decision]) => {
      const setState = set5(this.ref, [some2(out), state2]);
      if (isDone5(decision)) {
        return setState.pipe(zipRight(fail2(none2())));
      }
      const millis2 = start2(decision.intervals) - now;
      if (millis2 <= 0) {
        return setState.pipe(zipRight(updateInfo(this.iterationMeta, now, input, out)), as(out));
      }
      const duration = millis(millis2);
      return pipe(setState, zipRight(updateInfo(this.iterationMeta, now, input, out)), zipRight(sleep3(duration)), as(out));
    }))))));
  }
}
var makeWithState = (initial, step3) => new ScheduleImpl(initial, step3);
var addDelay = /* @__PURE__ */ dual(2, (self2, f) => addDelayEffect(self2, (out) => sync(() => f(out))));
var addDelayEffect = /* @__PURE__ */ dual(2, (self2, f) => modifyDelayEffect(self2, (out, duration) => map10(f(out), (delay2) => sum(duration, decode(delay2)))));
var asVoid2 = (self2) => map15(self2, constVoid);
var check = /* @__PURE__ */ dual(2, (self2, test) => checkEffect(self2, (input, out) => sync(() => test(input, out))));
var checkEffect = /* @__PURE__ */ dual(2, (self2, test) => makeWithState(self2.initial, (now, input, state) => flatMap8(self2.step(now, input, state), ([state2, out, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out, done6]);
  }
  return map10(test(input, out), (cont) => cont ? [state2, out, decision] : [state2, out, done6]);
})));
var driver = (self2) => pipe(make27([none2(), self2.initial]), map10((ref) => new ScheduleDriverImpl(self2, ref)));
var intersect5 = /* @__PURE__ */ dual(2, (self2, that) => intersectWith(self2, that, intersect4));
var intersectWith = /* @__PURE__ */ dual(3, (self2, that, f) => makeWithState([self2.initial, that.initial], (now, input, state) => pipe(zipWith3(self2.step(now, input, state[0]), that.step(now, input, state[1]), (a, b) => [a, b]), flatMap8(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    return intersectWithLoop(self2, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
  }
  return succeed([[lState, rState], [out, out2], done6]);
}))));
var intersectWithLoop = (self2, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
  const combined = f(lInterval, rInterval);
  if (isNonEmpty5(combined)) {
    return succeed([[lState, rState], [out, out2], _continue2(combined)]);
  }
  if (pipe(lInterval, lessThan5(rInterval))) {
    return flatMap8(self2.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
      if (isDone5(decision)) {
        return succeed([[lState2, rState], [out3, out2], done6]);
      }
      return intersectWithLoop(self2, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f);
    });
  }
  return flatMap8(that.step(end2(rInterval), input, rState), ([rState2, out22, decision]) => {
    if (isDone5(decision)) {
      return succeed([[lState, rState2], [out, out22], done6]);
    }
    return intersectWithLoop(self2, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f);
  });
};
var map15 = /* @__PURE__ */ dual(2, (self2, f) => mapEffect2(self2, (out) => sync(() => f(out))));
var mapEffect2 = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now, input, state) => flatMap8(self2.step(now, input, state), ([state2, out, decision]) => map10(f(out), (out2) => [state2, out2, decision]))));
var modifyDelayEffect = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now, input, state) => flatMap8(self2.step(now, input, state), ([state2, out, decision]) => {
  if (isDone5(decision)) {
    return succeed([state2, out, decision]);
  }
  const intervals = decision.intervals;
  const delay2 = size7(make35(now, start2(intervals)));
  return map10(f(out, delay2), (durationInput) => {
    const duration = decode(durationInput);
    const oldStart = start2(intervals);
    const newStart = now + toMillis(duration);
    const delta = newStart - oldStart;
    const newEnd = Math.max(0, end2(intervals) + delta);
    const newInterval = make35(newStart, newEnd);
    return [state2, out, continueWith2(newInterval)];
  });
})));
var passthrough2 = (self2) => makeWithState(self2.initial, (now, input, state) => pipe(self2.step(now, input, state), map10(([state2, _, decision]) => [state2, input, decision])));
var recurs = (n) => whileOutput(forever2, (out) => out < n);
var spaced = (duration) => addDelay(forever2, () => duration);
var unfold2 = (initial, f) => makeWithState(initial, (now, _, state) => sync(() => [f(state), state, continueWith2(after2(now))]));
var untilInputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (input, _) => negate(f(input))));
var whileInputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (input, _) => f(input)));
var whileOutput = /* @__PURE__ */ dual(2, (self2, f) => check(self2, (_, out) => f(out)));
var ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");

class ScheduleDefect {
  error;
  [ScheduleDefectTypeId];
  constructor(error) {
    this.error = error;
    this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
  }
}
var isScheduleDefect = (u) => hasProperty(u, ScheduleDefectTypeId);
var scheduleDefectWrap = (self2) => catchAll(self2, (e) => die2(new ScheduleDefect(e)));
var scheduleDefectRefailCause = (cause2) => match2(find(cause2, (_) => isDieType(_) && isScheduleDefect(_.defect) ? some2(_.defect) : none2()), {
  onNone: () => cause2,
  onSome: (error) => fail(error.error)
});
var scheduleDefectRefail = (effect) => catchAllCause(effect, (cause2) => failCause(scheduleDefectRefailCause(cause2)));
var repeat_Effect = /* @__PURE__ */ dual(2, (self2, schedule) => repeatOrElse_Effect(self2, schedule, (e, _) => fail2(e)));
var repeat_combined = /* @__PURE__ */ dual(2, (self2, options) => {
  if (isSchedule(options)) {
    return repeat_Effect(self2, options);
  }
  const base = options.schedule ?? passthrough2(forever2);
  const withWhile = options.while ? whileInputEffect(base, (a) => {
    const applied = options.while(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (a) => {
    const applied = options.until(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options.times ? intersect5(withUntil, recurs(options.times)).pipe(map15((intersectionPair) => intersectionPair[0])) : withUntil;
  return scheduleDefectRefail(repeat_Effect(self2, withTimes));
});
var repeatOrElse_Effect = /* @__PURE__ */ dual(3, (self2, schedule, orElse5) => flatMap8(driver(schedule), (driver2) => matchEffect(self2, {
  onFailure: (error) => orElse5(error, none2()),
  onSuccess: (value) => repeatOrElseEffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver2.iterationMeta)), driver2, (error, option2) => provideServiceEffect(orElse5(error, option2), CurrentIterationMetadata, get11(driver2.iterationMeta)), value)
})));
var repeatOrElseEffectLoop = (self2, driver2, orElse5, value) => matchEffect(driver2.next(value), {
  onFailure: () => orDie(driver2.last),
  onSuccess: (b) => matchEffect(self2, {
    onFailure: (error) => orElse5(error, some2(b)),
    onSuccess: (value2) => repeatOrElseEffectLoop(self2, driver2, orElse5, value2)
  })
});
var retry_Effect = /* @__PURE__ */ dual(2, (self2, policy) => retryOrElse_Effect(self2, policy, (e, _) => fail2(e)));
var retry_combined = /* @__PURE__ */ dual(2, (self2, options) => {
  if (isSchedule(options)) {
    return retry_Effect(self2, options);
  }
  return scheduleDefectRefail(retry_Effect(self2, fromRetryOptions(options)));
});
var fromRetryOptions = (options) => {
  const base = options.schedule ?? forever2;
  const withWhile = options.while ? whileInputEffect(base, (e) => {
    const applied = options.while(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (e) => {
    const applied = options.until(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  return options.times ? intersect5(withUntil, recurs(options.times)) : withUntil;
};
var retryOrElse_Effect = /* @__PURE__ */ dual(3, (self2, policy, orElse5) => flatMap8(driver(policy), (driver2) => retryOrElse_EffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver2.iterationMeta)), driver2, (e, out) => provideServiceEffect(orElse5(e, out), CurrentIterationMetadata, get11(driver2.iterationMeta)))));
var retryOrElse_EffectLoop = (self2, driver2, orElse5) => {
  return catchAll(self2, (e) => matchEffect(driver2.next(e), {
    onFailure: () => pipe(driver2.last, orDie, flatMap8((out) => orElse5(e, out))),
    onSuccess: () => retryOrElse_EffectLoop(self2, driver2, orElse5)
  }));
};
var schedule_Effect = /* @__PURE__ */ dual(2, (self2, schedule) => scheduleFrom_Effect(self2, undefined, schedule));
var scheduleFrom_Effect = /* @__PURE__ */ dual(3, (self2, initial, schedule) => flatMap8(driver(schedule), (driver2) => scheduleFrom_EffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver2.iterationMeta)), initial, driver2)));
var scheduleFrom_EffectLoop = (self2, initial, driver2) => matchEffect(driver2.next(initial), {
  onFailure: () => orDie(driver2.last),
  onSuccess: () => flatMap8(self2, (a) => scheduleFrom_EffectLoop(self2, a, driver2))
});
var forever2 = /* @__PURE__ */ unfold2(0, (n) => n + 1);
var once2 = /* @__PURE__ */ asVoid2(/* @__PURE__ */ recurs(1));
var scheduleForked = /* @__PURE__ */ dual(2, (self2, schedule) => forkScoped(schedule_Effect(self2, schedule)));

// node_modules/effect/dist/esm/internal/executionPlan.js
var withExecutionPlan = /* @__PURE__ */ dual(2, (effect, plan) => suspend(() => {
  let i = 0;
  let result;
  return flatMap8(whileLoop({
    while: () => i < plan.steps.length && (result === undefined || isLeft2(result)),
    body: () => {
      const step3 = plan.steps[i];
      let nextEffect = effect_provide(effect, step3.provide);
      if (result) {
        let attempted = false;
        const wrapped = nextEffect;
        nextEffect = suspend(() => {
          if (attempted)
            return wrapped;
          attempted = true;
          return result;
        });
        nextEffect = scheduleDefectRefail(retry_Effect(nextEffect, scheduleFromStep(step3, false)));
      } else {
        const schedule = scheduleFromStep(step3, true);
        nextEffect = schedule ? scheduleDefectRefail(retry_Effect(nextEffect, schedule)) : nextEffect;
      }
      return either2(nextEffect);
    },
    step: (either3) => {
      result = either3;
      i++;
    }
  }), () => result);
}));
var scheduleFromStep = (step3, first) => {
  if (!first) {
    return fromRetryOptions({
      schedule: step3.schedule ? step3.schedule : step3.attempts ? undefined : once2,
      times: step3.attempts,
      while: step3.while
    });
  } else if (step3.attempts === 1 || !(step3.schedule || step3.attempts)) {
    return;
  }
  return fromRetryOptions({
    schedule: step3.schedule,
    while: step3.while,
    times: step3.attempts ? step3.attempts - 1 : undefined
  });
};

// node_modules/effect/dist/esm/internal/query.js
var currentCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map10(deferredMake(), (handle) => ({
  listeners: new Listeners,
  handle
})), () => seconds(60))));
var currentCacheEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
var fromRequest = (request, dataSource) => flatMap8(isEffect(dataSource) ? dataSource : succeed(dataSource), (ds) => fiberIdWith((id2) => {
  const proxy = new Proxy(request, {});
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      const cached3 = fiberRefGetWith(currentCache, (cache) => flatMap8(cache.getEither(proxy), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            if (orNew.left.listeners.interrupted) {
              return flatMap8(cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached3);
            }
            orNew.left.listeners.increment();
            return uninterruptibleMask((restore) => flatMap8(exit(blocked(empty15, restore(deferredAwait(orNew.left.handle)))), (exit2) => {
              orNew.left.listeners.decrement();
              return exit2;
            }));
          }
          case "Right": {
            orNew.right.listeners.increment();
            return uninterruptibleMask((restore) => flatMap8(exit(blocked(single(ds, makeEntry({
              request: proxy,
              result: orNew.right.handle,
              listeners: orNew.right.listeners,
              ownerId: id2,
              state: {
                completed: false
              }
            })), restore(deferredAwait(orNew.right.handle)))), () => {
              orNew.right.listeners.decrement();
              return deferredAwait(orNew.right.handle);
            }));
          }
        }
      }));
      return cached3;
    }
    const listeners = new Listeners;
    listeners.increment();
    return flatMap8(deferredMake(), (ref) => ensuring(blocked(single(ds, makeEntry({
      request: proxy,
      result: ref,
      listeners,
      ownerId: id2,
      state: {
        completed: false
      }
    })), deferredAwait(ref)), sync(() => listeners.decrement())));
  });
}));
var cacheRequest = (request, result) => {
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      return fiberRefGetWith(currentCache, (cache) => flatMap8(cache.getEither(request), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            return void_;
          }
          case "Right": {
            return deferredComplete(orNew.right.handle, result);
          }
        }
      }));
    }
    return void_;
  });
};
var withRequestCaching = /* @__PURE__ */ dual(2, (self2, strategy) => fiberRefLocally(self2, currentCacheEnabled, strategy));
var withRequestCache = /* @__PURE__ */ dual(2, (self2, cache) => fiberRefLocally(self2, currentCache, cache));

// node_modules/effect/dist/esm/Request.js
var isRequest2 = isRequest;

// node_modules/effect/dist/esm/Effect.js
var EffectTypeId3 = EffectTypeId2;
var isEffect2 = isEffect;
var cachedWithTTL = cached2;
var cachedInvalidateWithTTL2 = cachedInvalidateWithTTL;
var cached3 = memoize;
var cachedFunction2 = cachedFunction;
var once3 = once;
var all4 = all3;
var allWith2 = allWith;
var allSuccesses2 = allSuccesses;
var dropUntil2 = dropUntil;
var dropWhile3 = dropWhile2;
var takeUntil2 = takeUntil;
var takeWhile3 = takeWhile2;
var every6 = every5;
var exists3 = exists2;
var filter7 = filter5;
var filterMap5 = filterMap4;
var findFirst6 = findFirst5;
var forEach6 = forEach5;
var head4 = head3;
var mergeAll5 = mergeAll3;
var partition4 = partition3;
var reduce10 = reduce9;
var reduceWhile2 = reduceWhile;
var reduceRight4 = reduceRight3;
var reduceEffect2 = reduceEffect;
var replicate2 = replicate;
var replicateEffect2 = replicateEffect;
var validateAll2 = validateAll;
var validateFirst2 = validateFirst;
var async = async_;
var asyncEffect2 = asyncEffect;
var custom2 = custom;
var withFiberRuntime2 = withFiberRuntime;
var fail9 = fail2;
var failSync3 = failSync;
var failCause8 = failCause;
var failCauseSync3 = failCauseSync;
var die6 = die2;
var dieMessage2 = dieMessage;
var dieSync3 = dieSync;
var gen2 = gen;
var never3 = never;
var none9 = none6;
var promise2 = promise;
var succeed8 = succeed;
var succeedNone2 = succeedNone;
var succeedSome2 = succeedSome;
var suspend3 = suspend;
var sync3 = sync;
var _void = void_;
var yieldNow4 = yieldNow;
var _catch2 = _catch;
var catchAll3 = catchAll;
var catchAllCause3 = catchAllCause;
var catchAllDefect2 = catchAllDefect;
var catchIf2 = catchIf;
var catchSome2 = catchSome;
var catchSomeCause2 = catchSomeCause;
var catchSomeDefect2 = catchSomeDefect;
var catchTag2 = catchTag;
var catchTags2 = catchTags;
var cause2 = cause;
var eventually2 = eventually;
var ignore2 = ignore;
var ignoreLogged2 = ignoreLogged;
var parallelErrors2 = parallelErrors;
var sandbox2 = sandbox;
var retry2 = retry_combined;
var withExecutionPlan2 = withExecutionPlan;
var retryOrElse = retryOrElse_Effect;
var try_2 = try_;
var tryMap2 = tryMap;
var tryMapPromise2 = tryMapPromise;
var tryPromise2 = tryPromise;
var unsandbox2 = unsandbox;
var allowInterrupt2 = allowInterrupt;
var checkInterruptible2 = checkInterruptible;
var disconnect2 = disconnect;
var interrupt7 = interrupt2;
var interruptWith2 = interruptWith;
var interruptible4 = interruptible2;
var interruptibleMask2 = interruptibleMask;
var onInterrupt2 = onInterrupt;
var uninterruptible2 = uninterruptible;
var uninterruptibleMask3 = uninterruptibleMask;
var liftPredicate2 = liftPredicate;
var as3 = as;
var asSome2 = asSome;
var asSomeError2 = asSomeError;
var asVoid3 = asVoid;
var flip2 = flip;
var flipWith2 = flipWith;
var map16 = map10;
var mapAccum4 = mapAccum3;
var mapBoth3 = mapBoth;
var mapError3 = mapError;
var mapErrorCause2 = mapErrorCause;
var merge7 = merge5;
var negate2 = negate;
var acquireRelease2 = acquireRelease;
var acquireReleaseInterruptible2 = acquireReleaseInterruptible;
var acquireUseRelease2 = acquireUseRelease;
var addFinalizer3 = addFinalizer;
var ensuring2 = ensuring;
var onError2 = onError;
var onExit3 = onExit;
var parallelFinalizers2 = parallelFinalizers;
var sequentialFinalizers2 = sequentialFinalizers;
var finalizersMask2 = finalizersMask;
var scope3 = scope;
var scopeWith2 = scopeWith;
var scopedWith2 = scopedWith;
var scoped2 = scopedEffect;
var using2 = using;
var withEarlyRelease2 = withEarlyRelease;
var awaitAllChildren2 = awaitAllChildren;
var daemonChildren2 = daemonChildren;
var descriptor2 = descriptor;
var descriptorWith2 = descriptorWith;
var diffFiberRefs2 = diffFiberRefs;
var ensuringChild2 = ensuringChild;
var ensuringChildren2 = ensuringChildren;
var fiberId2 = fiberId;
var fiberIdWith2 = fiberIdWith;
var fork3 = fork;
var forkDaemon2 = forkDaemon;
var forkAll2 = forkAll;
var forkIn2 = forkIn;
var forkScoped2 = forkScoped;
var forkWithErrorHandler2 = forkWithErrorHandler;
var fromFiber2 = fromFiber;
var fromFiberEffect2 = fromFiberEffect;
var supervised2 = supervised;
var transplant2 = transplant;
var withConcurrency2 = withConcurrency;
var withScheduler2 = withScheduler;
var withSchedulingPriority2 = withSchedulingPriority;
var withMaxOpsBeforeYield2 = withMaxOpsBeforeYield;
var clock2 = clock;
var clockWith4 = clockWith3;
var withClockScoped2 = withClockScoped;
var withClock2 = withClock;
var console3 = console2;
var consoleWith2 = consoleWith;
var withConsoleScoped2 = withConsoleScoped;
var withConsole2 = withConsole;
var delay2 = delay;
var sleep4 = sleep3;
var timed2 = timed;
var timedWith2 = timedWith;
var timeout2 = timeout;
var timeoutOption2 = timeoutOption;
var timeoutFail2 = timeoutFail;
var timeoutFailCause2 = timeoutFailCause;
var timeoutTo2 = timeoutTo;
var configProviderWith2 = configProviderWith;
var withConfigProvider2 = withConfigProvider;
var withConfigProviderScoped2 = withConfigProviderScoped;
var context3 = context;
var contextWith2 = contextWith;
var contextWithEffect2 = contextWithEffect;
var mapInputContext2 = mapInputContext;
var provide2 = effect_provide;
var provideService2 = provideService;
var provideServiceEffect2 = provideServiceEffect;
var serviceFunction2 = serviceFunction;
var serviceFunctionEffect2 = serviceFunctionEffect;
var serviceFunctions2 = serviceFunctions;
var serviceConstants2 = serviceConstants;
var serviceMembers2 = serviceMembers;
var serviceOption2 = serviceOption;
var serviceOptional2 = serviceOptional;
var updateService2 = updateService;
var Do2 = Do;
var bind3 = bind2;
var bindAll2 = bindAll;
var bindTo3 = bindTo2;
var let_3 = let_2;
var option2 = option;
var either3 = either2;
var exit2 = exit;
var intoDeferred2 = intoDeferred;
var if_2 = if_;
var filterOrDie2 = filterOrDie;
var filterOrDieMessage2 = filterOrDieMessage;
var filterOrElse2 = filterOrElse;
var filterOrFail2 = filterOrFail;
var filterEffectOrElse2 = filterEffectOrElse;
var filterEffectOrFail2 = filterEffectOrFail;
var unless2 = unless;
var unlessEffect2 = unlessEffect;
var when2 = when;
var whenEffect2 = whenEffect;
var whenFiberRef2 = whenFiberRef;
var whenRef2 = whenRef;
var flatMap11 = flatMap8;
var andThen4 = andThen2;
var flatten9 = flatten6;
var race2 = race;
var raceAll2 = raceAll;
var raceFirst2 = raceFirst;
var raceWith2 = raceWith;
var summarized2 = summarized;
var tap3 = tap;
var tapBoth2 = tapBoth;
var tapDefect2 = tapDefect;
var tapError3 = tapError;
var tapErrorTag2 = tapErrorTag;
var tapErrorCause3 = tapErrorCause;
var forever3 = forever;
var iterate2 = iterate;
var loop2 = loop;
var repeat = repeat_combined;
var repeatN2 = repeatN;
var repeatOrElse = repeatOrElse_Effect;
var schedule = schedule_Effect;
var scheduleForked2 = scheduleForked;
var scheduleFrom = scheduleFrom_Effect;
var whileLoop2 = whileLoop;
var getFiberRefs = fiberRefs2;
var inheritFiberRefs2 = inheritFiberRefs;
var locally = fiberRefLocally;
var locallyWith = fiberRefLocallyWith;
var locallyScoped = fiberRefLocallyScoped;
var locallyScopedWith = fiberRefLocallyScopedWith;
var patchFiberRefs2 = patchFiberRefs;
var setFiberRefs2 = setFiberRefs;
var updateFiberRefs2 = updateFiberRefs;
var isFailure4 = isFailure2;
var isSuccess3 = isSuccess2;
var match12 = match7;
var matchCause3 = matchCause;
var matchCauseEffect3 = matchCauseEffect;
var matchEffect2 = matchEffect;
var log2 = log;
var logWithLevel2 = (level, ...message) => logWithLevel(level)(...message);
var logTrace2 = logTrace;
var logDebug2 = logDebug;
var logInfo2 = logInfo;
var logWarning2 = logWarning;
var logError2 = logError;
var logFatal2 = logFatal;
var withLogSpan2 = withLogSpan;
var annotateLogs3 = annotateLogs;
var annotateLogsScoped2 = annotateLogsScoped;
var logAnnotations2 = logAnnotations;
var withUnhandledErrorLogLevel2 = withUnhandledErrorLogLevel;
var whenLogLevel2 = whenLogLevel;
var orDie3 = orDie;
var orDieWith2 = orDieWith;
var orElse5 = orElse2;
var orElseFail2 = orElseFail;
var orElseSucceed2 = orElseSucceed;
var firstSuccessOf2 = firstSuccessOf;
var random3 = random2;
var randomWith2 = randomWith;
var withRandom2 = withRandom;
var withRandomFixed = /* @__PURE__ */ dual(2, (effect, values3) => withRandom2(effect, fixed2(values3)));
var withRandomScoped2 = withRandomScoped;
var runtime3 = runtime2;
var getRuntimeFlags = runtimeFlags;
var patchRuntimeFlags = updateRuntimeFlags;
var withRuntimeFlagsPatch = withRuntimeFlags;
var withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
var tagMetrics2 = tagMetrics;
var labelMetrics2 = labelMetrics;
var tagMetricsScoped2 = tagMetricsScoped;
var labelMetricsScoped2 = labelMetricsScoped;
var metricLabels2 = metricLabels;
var withMetric2 = withMetric;
var unsafeMakeSemaphore2 = unsafeMakeSemaphore;
var makeSemaphore2 = makeSemaphore;
var unsafeMakeLatch2 = unsafeMakeLatch;
var makeLatch2 = makeLatch;
var runFork2 = unsafeForkEffect;
var runCallback = unsafeRunEffect;
var runPromise = unsafeRunPromiseEffect;
var runPromiseExit = unsafeRunPromiseExitEffect;
var runSync = unsafeRunSyncEffect;
var runSyncExit = unsafeRunSyncExitEffect;
var validate2 = validate;
var validateWith2 = validateWith;
var zip5 = zipOptions;
var zipLeft2 = zipLeftOptions;
var zipRight3 = zipRightOptions;
var zipWith5 = zipWithOptions;
var ap = /* @__PURE__ */ dual(2, (self2, that) => zipWith5(self2, that, (f, a) => f(a)));
var blocked2 = blocked;
var runRequestBlock2 = runRequestBlock;
var step3 = step2;
var request = /* @__PURE__ */ dual((args2) => isRequest2(args2[0]), fromRequest);
var cacheRequestResult = cacheRequest;
var withRequestBatching2 = withRequestBatching;
var withRequestCaching2 = withRequestCaching;
var withRequestCache2 = withRequestCache;
var tracer2 = tracer;
var tracerWith4 = tracerWith;
var withTracer2 = withTracer;
var withTracerScoped2 = withTracerScoped;
var withTracerEnabled2 = withTracerEnabled;
var withTracerTiming2 = withTracerTiming;
var annotateSpans3 = annotateSpans;
var annotateCurrentSpan2 = annotateCurrentSpan;
var currentSpan2 = currentSpan;
var currentParentSpan2 = currentParentSpan;
var spanAnnotations2 = spanAnnotations;
var spanLinks2 = spanLinks;
var linkSpans2 = linkSpans;
var linkSpanCurrent2 = linkSpanCurrent;
var makeSpan2 = makeSpan;
var makeSpanScoped2 = makeSpanScoped;
var useSpan2 = useSpan;
var withSpan3 = withSpan;
var functionWithSpan2 = functionWithSpan;
var withSpanScoped2 = withSpanScoped;
var withParentSpan3 = withParentSpan;
var fromNullable3 = fromNullable2;
var optionFromOptional2 = optionFromOptional;
var transposeOption = (self2) => {
  return isNone(self2) ? succeedNone2 : map16(self2.value, some);
};
var transposeMapOption = /* @__PURE__ */ dual(2, (self2, f) => isNone(self2) ? succeedNone2 : map16(f(self2.value), some));
var makeTagProxy = (TagClass) => {
  const cache = new Map;
  return new Proxy(TagClass, {
    get(target, prop, receiver) {
      if (prop in target) {
        return Reflect.get(target, prop, receiver);
      }
      if (cache.has(prop)) {
        return cache.get(prop);
      }
      const fn = (...args2) => andThen2(target, (s) => {
        if (typeof s[prop] === "function") {
          cache.set(prop, (...args3) => andThen2(target, (s2) => s2[prop](...args3)));
          return s[prop](...args2);
        }
        cache.set(prop, andThen2(target, (s2) => s2[prop]));
        return s[prop];
      });
      const cn = andThen2(target, (s) => s[prop]);
      Object.assign(fn, cn);
      const apply = fn.apply;
      const bind4 = fn.bind;
      const call = fn.call;
      const proto4 = Object.setPrototypeOf({}, Object.getPrototypeOf(cn));
      proto4.apply = apply;
      proto4.bind = bind4;
      proto4.call = call;
      Object.setPrototypeOf(fn, proto4);
      cache.set(prop, fn);
      return fn;
    }
  });
};
var Tag3 = (id2) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  function TagClass() {}
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id2;
  Object.defineProperty(TagClass, "use", {
    get() {
      return (body) => andThen2(this, body);
    }
  });
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return makeTagProxy(TagClass);
};
var Service = function() {
  return function() {
    const [id2, maker] = arguments;
    const proxy = "accessors" in maker ? maker["accessors"] : false;
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error;
    Error.stackTraceLimit = limit;
    let patchState = "unchecked";
    const TagClass = function(service2) {
      if (patchState === "unchecked") {
        const proto4 = Object.getPrototypeOf(service2);
        if (proto4 === Object.prototype || proto4 === null) {
          patchState = "plain";
        } else {
          const selfProto = Object.getPrototypeOf(this);
          Object.setPrototypeOf(selfProto, proto4);
          patchState = "patched";
        }
      }
      if (patchState === "plain") {
        Object.assign(this, service2);
      } else if (patchState === "patched") {
        Object.setPrototypeOf(service2, Object.getPrototypeOf(this));
        return service2;
      }
    };
    TagClass.prototype._tag = id2;
    Object.defineProperty(TagClass, "make", {
      get() {
        return (service2) => new this(service2);
      }
    });
    Object.defineProperty(TagClass, "use", {
      get() {
        return (body) => andThen2(this, body);
      }
    });
    TagClass.key = id2;
    Object.assign(TagClass, TagProto);
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
    const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
    let layerCache;
    let isFunction3 = false;
    if ("effect" in maker) {
      isFunction3 = typeof maker.effect === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return function() {
              return fromEffect3(TagClass, map16(maker.effect.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ??= fromEffect3(TagClass, map16(maker.effect, (_) => new this(_)));
        }
      });
    } else if ("scoped" in maker) {
      isFunction3 = typeof maker.scoped === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return function() {
              return scoped(TagClass, map16(maker.scoped.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ??= scoped(TagClass, map16(maker.scoped, (_) => new this(_)));
        }
      });
    } else if ("sync" in maker) {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= sync2(TagClass, () => new this(maker.sync()));
        }
      });
    } else {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= succeed6(TagClass, new this(maker.succeed));
        }
      });
    }
    if (hasDeps) {
      let layerWithDepsCache;
      Object.defineProperty(TagClass, "Default", {
        get() {
          if (isFunction3) {
            return function() {
              return provide(this.DefaultWithoutDependencies.apply(null, arguments), maker.dependencies);
            };
          }
          return layerWithDepsCache ??= provide(this.DefaultWithoutDependencies, maker.dependencies);
        }
      });
    }
    return proxy === true ? makeTagProxy(TagClass) : TagClass;
  };
};
var fn = function(nameOrBody, ...pipeables) {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const errorDef = new Error;
  Error.stackTraceLimit = limit;
  if (typeof nameOrBody !== "string") {
    return defineLength(nameOrBody.length, function(...args2) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error;
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body: nameOrBody,
        args: args2,
        pipeables,
        spanName: "<anonymous>",
        spanOptions: {
          context: DisablePropagation.context(true)
        },
        errorDef,
        errorCall
      });
    });
  }
  const name = nameOrBody;
  const options = pipeables[0];
  return (body, ...pipeables2) => defineLength(body.length, {
    [name](...args2) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error;
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body,
        args: args2,
        pipeables: pipeables2,
        spanName: name,
        spanOptions: options,
        errorDef,
        errorCall
      });
    }
  }[name]);
};
function defineLength(length3, fn2) {
  return Object.defineProperty(fn2, "length", {
    value: length3,
    configurable: true
  });
}
function fnApply(options) {
  let effect;
  let fnError = undefined;
  if (isGeneratorFunction(options.body)) {
    effect = fromIterator(() => options.body.apply(options.self, options.args));
  } else {
    try {
      effect = options.body.apply(options.self, options.args);
    } catch (error) {
      fnError = error;
      effect = die6(error);
    }
  }
  if (options.pipeables.length > 0) {
    try {
      for (const x of options.pipeables) {
        effect = x(effect, ...options.args);
      }
    } catch (error) {
      effect = fnError ? failCause8(sequential(die(fnError), die(error))) : die6(error);
    }
  }
  let cache = false;
  const captureStackTrace = () => {
    if (cache !== false) {
      return cache;
    }
    if (options.errorCall.stack) {
      const stackDef = options.errorDef.stack.trim().split(`
`);
      const stackCall = options.errorCall.stack.trim().split(`
`);
      let endStackDef = stackDef.slice(2).join(`
`).trim();
      if (!endStackDef.includes(`(`)) {
        endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
      }
      let endStackCall = stackCall.slice(2).join(`
`).trim();
      if (!endStackCall.includes(`(`)) {
        endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
      }
      cache = `${endStackDef}
${endStackCall}`;
      return cache;
    }
  };
  const opts = options.spanOptions && "captureStackTrace" in options.spanOptions ? options.spanOptions : {
    captureStackTrace,
    ...options.spanOptions
  };
  return withSpan3(effect, options.spanName, opts);
}
var fnUntraced2 = fnUntraced;
var ensureSuccessType = () => (effect) => effect;
var ensureErrorType = () => (effect) => effect;
var ensureRequirementsType = () => (effect) => effect;

// node_modules/effect/dist/esm/FiberRef.js
var get13 = fiberRefGet;
var getWith = fiberRefGetWith;
var currentContext2 = currentContext;
var currentSchedulingPriority2 = currentSchedulingPriority;
var currentScheduler2 = currentScheduler;
var currentTracerTimingEnabled2 = currentTracerTimingEnabled;

// node_modules/effect/dist/esm/Layer.js
var exports_Layer = {};
__export(exports_Layer, {
  zipWith: () => zipWith6,
  withSpan: () => withSpan4,
  withParentSpan: () => withParentSpan4,
  updateService: () => updateService3,
  unwrapScoped: () => unwrapScoped2,
  unwrapEffect: () => unwrapEffect2,
  toRuntimeWithMemoMap: () => toRuntimeWithMemoMap2,
  toRuntime: () => toRuntime2,
  tapErrorCause: () => tapErrorCause4,
  tapError: () => tapError4,
  tap: () => tap4,
  syncContext: () => syncContext2,
  sync: () => sync4,
  suspend: () => suspend4,
  succeedContext: () => succeedContext2,
  succeed: () => succeed9,
  span: () => span3,
  setVersionMismatchErrorLogLevel: () => setVersionMismatchErrorLogLevel,
  setUnhandledErrorLogLevel: () => setUnhandledErrorLogLevel,
  setTracerTiming: () => setTracerTiming,
  setTracerEnabled: () => setTracerEnabled,
  setTracer: () => setTracer2,
  setScheduler: () => setScheduler,
  setRequestCaching: () => setRequestCaching,
  setRequestCache: () => setRequestCache,
  setRequestBatching: () => setRequestBatching,
  setRandom: () => setRandom,
  setConfigProvider: () => setConfigProvider2,
  setClock: () => setClock,
  service: () => service2,
  scopedDiscard: () => scopedDiscard2,
  scopedContext: () => scopedContext2,
  scoped: () => scoped3,
  scope: () => scope4,
  retry: () => retry3,
  provideMerge: () => provideMerge2,
  provide: () => provide3,
  project: () => project2,
  passthrough: () => passthrough3,
  parentSpan: () => parentSpan2,
  orElse: () => orElse6,
  orDie: () => orDie4,
  mock: () => mock2,
  mergeAll: () => mergeAll6,
  merge: () => merge8,
  memoize: () => memoize3,
  matchCause: () => matchCause4,
  match: () => match13,
  mapError: () => mapError4,
  map: () => map17,
  makeMemoMap: () => makeMemoMap2,
  locallyWith: () => locallyWith2,
  locallyScoped: () => locallyScoped2,
  locallyEffect: () => locallyEffect2,
  locally: () => locally2,
  launch: () => launch2,
  isLayer: () => isLayer2,
  isFresh: () => isFresh2,
  function: () => fromFunction2,
  fresh: () => fresh2,
  flatten: () => flatten10,
  flatMap: () => flatMap12,
  fiberRefLocallyScopedWith: () => fiberRefLocallyScopedWith3,
  failSync: () => failSync4,
  failCauseSync: () => failCauseSync4,
  failCause: () => failCause9,
  fail: () => fail10,
  extendScope: () => extendScope2,
  empty: () => empty28,
  effectDiscard: () => effectDiscard,
  effectContext: () => effectContext,
  effect: () => effect,
  discard: () => discard2,
  dieSync: () => dieSync4,
  die: () => die7,
  context: () => context4,
  catchAllCause: () => catchAllCause4,
  catchAll: () => catchAll4,
  buildWithScope: () => buildWithScope2,
  buildWithMemoMap: () => buildWithMemoMap2,
  build: () => build2,
  annotateSpans: () => annotateSpans4,
  annotateLogs: () => annotateLogs4,
  MemoMapTypeId: () => MemoMapTypeId2,
  LayerTypeId: () => LayerTypeId2,
  CurrentMemoMap: () => CurrentMemoMap2
});

// node_modules/effect/dist/esm/internal/layer/circular.js
var setConfigProvider = (configProvider) => scopedDiscard(withConfigProviderScoped(configProvider));
var parentSpan = (span2) => succeedContext(make5(spanTag, span2));
var span2 = (name, options) => {
  options = addSpanStackTrace(options);
  return scoped(spanTag, options?.onEnd ? tap(makeSpanScoped(name, options), (span3) => addFinalizer((exit3) => options.onEnd(span3, exit3))) : makeSpanScoped(name, options));
};
var setTracer = (tracer3) => scopedDiscard(withTracerScoped(tracer3));

// node_modules/effect/dist/esm/Layer.js
var LayerTypeId2 = LayerTypeId;
var MemoMapTypeId2 = MemoMapTypeId;
var CurrentMemoMap2 = CurrentMemoMap;
var isLayer2 = isLayer;
var isFresh2 = isFresh;
var annotateLogs4 = annotateLogs2;
var annotateSpans4 = annotateSpans2;
var build2 = build;
var buildWithScope2 = buildWithScope;
var catchAll4 = catchAll2;
var catchAllCause4 = catchAllCause2;
var context4 = context2;
var die7 = die5;
var dieSync4 = dieSync2;
var discard2 = discard;
var effect = fromEffect3;
var effectDiscard = fromEffectDiscard;
var effectContext = fromEffectContext;
var empty28 = empty27;
var extendScope2 = extendScope;
var fail10 = fail7;
var failSync4 = failSync2;
var failCause9 = failCause6;
var failCauseSync4 = failCauseSync2;
var flatMap12 = flatMap10;
var flatten10 = flatten8;
var fresh2 = fresh;
var mock2 = mock;
var fromFunction2 = fromFunction;
var launch2 = launch;
var map17 = map14;
var mapError4 = mapError2;
var match13 = match11;
var matchCause4 = matchCause2;
var memoize3 = memoize2;
var merge8 = merge6;
var mergeAll6 = mergeAll4;
var orDie4 = orDie2;
var orElse6 = orElse4;
var passthrough3 = passthrough;
var project2 = project;
var locallyEffect2 = locallyEffect;
var locally2 = fiberRefLocally2;
var locallyWith2 = fiberRefLocallyWith2;
var locallyScoped2 = fiberRefLocallyScoped2;
var fiberRefLocallyScopedWith3 = fiberRefLocallyScopedWith2;
var retry3 = retry;
var scope4 = scope2;
var scoped3 = scoped;
var scopedDiscard2 = scopedDiscard;
var scopedContext2 = scopedContext;
var service2 = service;
var succeed9 = succeed6;
var succeedContext2 = succeedContext;
var suspend4 = suspend2;
var sync4 = sync2;
var syncContext2 = syncContext;
var tap4 = tap2;
var tapError4 = tapError2;
var tapErrorCause4 = tapErrorCause2;
var toRuntime2 = toRuntime;
var toRuntimeWithMemoMap2 = toRuntimeWithMemoMap;
var provide3 = provide;
var provideMerge2 = provideMerge;
var zipWith6 = zipWith4;
var unwrapEffect2 = unwrapEffect;
var unwrapScoped2 = unwrapScoped;
var setClock = (clock3) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(clockTag, clock3)));
var setConfigProvider2 = setConfigProvider;
var parentSpan2 = parentSpan;
var setRandom = (random4) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(randomTag, random4)));
var setRequestBatching = (requestBatching) => scopedDiscard2(fiberRefLocallyScoped(currentRequestBatching, requestBatching));
var setRequestCaching = (requestCaching) => scopedDiscard2(fiberRefLocallyScoped(currentCacheEnabled, requestCaching));
var setRequestCache = (cache) => scopedDiscard2(isEffect(cache) ? flatMap8(cache, (x) => fiberRefLocallyScoped(currentCache, x)) : fiberRefLocallyScoped(currentCache, cache));
var setScheduler = (scheduler) => scopedDiscard2(fiberRefLocallyScoped(currentScheduler, scheduler));
var span3 = span2;
var setTracer2 = setTracer;
var setTracerEnabled = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerEnabled, enabled2));
var setTracerTiming = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerTimingEnabled, enabled2));
var setUnhandledErrorLogLevel = (level) => scopedDiscard2(fiberRefLocallyScoped(currentUnhandledErrorLogLevel, level));
var setVersionMismatchErrorLogLevel = (level) => scopedDiscard2(fiberRefLocallyScoped(currentVersionMismatchErrorLogLevel, level));
var withSpan4 = withSpan2;
var withParentSpan4 = withParentSpan2;
var makeMemoMap2 = makeMemoMap;
var buildWithMemoMap2 = buildWithMemoMap;
var updateService3 = /* @__PURE__ */ dual(3, (layer, tag, f) => provide3(layer, map17(context4(), (c) => add2(c, tag, f(unsafeGet3(c, tag))))));

// node_modules/effect/dist/esm/internal/queue.js
var EnqueueSymbolKey = "effect/QueueEnqueue";
var EnqueueTypeId = /* @__PURE__ */ Symbol.for(EnqueueSymbolKey);
var DequeueSymbolKey = "effect/QueueDequeue";
var DequeueTypeId = /* @__PURE__ */ Symbol.for(DequeueSymbolKey);
var QueueStrategySymbolKey = "effect/QueueStrategy";
var QueueStrategyTypeId = /* @__PURE__ */ Symbol.for(QueueStrategySymbolKey);
var BackingQueueSymbolKey = "effect/BackingQueue";
var BackingQueueTypeId = /* @__PURE__ */ Symbol.for(BackingQueueSymbolKey);
var queueStrategyVariance = {
  _A: (_) => _
};
var backingQueueVariance = {
  _A: (_) => _
};
var enqueueVariance = {
  _In: (_) => _
};
var dequeueVariance = {
  _Out: (_) => _
};

class QueueImpl extends Class {
  queue;
  takers;
  shutdownHook;
  shutdownFlag;
  strategy;
  [EnqueueTypeId] = enqueueVariance;
  [DequeueTypeId] = dequeueVariance;
  constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
    super();
    this.queue = queue;
    this.takers = takers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
  capacity() {
    return this.queue.capacity();
  }
  get size() {
    return suspend(() => catchAll(this.unsafeSize(), () => interrupt2));
  }
  unsafeSize() {
    if (get6(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.queue.length() - length2(this.takers) + this.strategy.surplusSize());
  }
  get isEmpty() {
    return map10(this.size, (size8) => size8 <= 0);
  }
  get isFull() {
    return map10(this.size, (size8) => size8 >= this.capacity());
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set2(true));
      return pipe(forEachConcurrentDiscard(unsafePollAll(this.takers), (d) => deferredInterruptWith(d, state.id()), false, false), zipRight(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, undefined)), asVoid);
    }));
  }
  get isShutdown() {
    return sync(() => get6(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  isActive() {
    return !get6(this.shutdownFlag);
  }
  unsafeOffer(value) {
    if (get6(this.shutdownFlag)) {
      return false;
    }
    let noRemaining;
    if (this.queue.length() === 0) {
      const taker = pipe(this.takers, poll2(EmptyMutableQueue));
      if (taker !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, value);
        noRemaining = true;
      } else {
        noRemaining = false;
      }
    } else {
      noRemaining = false;
    }
    if (noRemaining) {
      return true;
    }
    const succeeded = this.queue.offer(value);
    unsafeCompleteTakers(this.strategy, this.queue, this.takers);
    return succeeded;
  }
  offer(value) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      let noRemaining;
      if (this.queue.length() === 0) {
        const taker = pipe(this.takers, poll2(EmptyMutableQueue));
        if (taker !== EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, value);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return succeed(true);
      }
      const succeeded = this.queue.offer(value);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded ? succeed(true) : this.strategy.handleSurplus([value], this.queue, this.takers, this.shutdownFlag);
    });
  }
  offerAll(iterable) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const values3 = fromIterable(iterable);
      const pTakers = this.queue.length() === 0 ? fromIterable(unsafePollN(this.takers, values3.length)) : empty;
      const [forTakers, remaining] = pipe(values3, splitAt(pTakers.length));
      for (let i = 0;i < pTakers.length; i++) {
        const taker = pTakers[i];
        const item = forTakers[i];
        unsafeCompleteDeferred(taker, item);
      }
      if (remaining.length === 0) {
        return succeed(true);
      }
      const surplus = this.queue.offerAll(remaining);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return isEmpty(surplus) ? succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
    });
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const item = this.queue.poll(EmptyMutableQueue);
      if (item !== EmptyMutableQueue) {
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return succeed(item);
      } else {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.takers, offer(deferred));
          unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => {
          return sync(() => unsafeRemove(this.takers, deferred));
        }));
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      return get6(this.shutdownFlag) ? interrupt2 : sync(() => {
        const values3 = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return fromIterable2(values3);
      });
    });
  }
  takeUpTo(max5) {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => {
      const values3 = this.queue.pollUpTo(max5);
      this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
      return fromIterable2(values3);
    }));
  }
  takeBetween(min3, max5) {
    return suspend(() => takeRemainderLoop(this, min3, max5, empty4()));
  }
}
var takeRemainderLoop = (self2, min3, max5, acc) => {
  if (max5 < min3) {
    return succeed(acc);
  }
  return pipe(takeUpTo(self2, max5), flatMap8((bs) => {
    const remaining = min3 - bs.length;
    if (remaining === 1) {
      return pipe(take2(self2), map10((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(take2(self2), flatMap8((b) => takeRemainderLoop(self2, remaining - 1, max5 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
};
var isQueue = (u) => isEnqueue(u) && isDequeue(u);
var isEnqueue = (u) => hasProperty(u, EnqueueTypeId);
var isDequeue = (u) => hasProperty(u, DequeueTypeId);
var bounded2 = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap8((queue) => make40(backingQueueFromMutableQueue(queue), backPressureStrategy())));
var dropping = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap8((queue) => make40(backingQueueFromMutableQueue(queue), droppingStrategy())));
var sliding = (requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap8((queue) => make40(backingQueueFromMutableQueue(queue), slidingStrategy())));
var unbounded2 = () => pipe(sync(() => unbounded()), flatMap8((queue) => make40(backingQueueFromMutableQueue(queue), droppingStrategy())));
var unsafeMake10 = (queue, takers, shutdownHook, shutdownFlag, strategy) => {
  return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
};
var make40 = (queue, strategy) => pipe(deferredMake(), map10((deferred) => unsafeMake10(queue, unbounded(), deferred, make11(false), strategy)));

class BackingQueueFromMutableQueue {
  mutable;
  [BackingQueueTypeId] = backingQueueVariance;
  constructor(mutable) {
    this.mutable = mutable;
  }
  poll(def) {
    return poll2(this.mutable, def);
  }
  pollUpTo(limit) {
    return pollUpTo(this.mutable, limit);
  }
  offerAll(elements) {
    return offerAll(this.mutable, elements);
  }
  offer(element) {
    return offer(this.mutable, element);
  }
  capacity() {
    return capacity(this.mutable);
  }
  length() {
    return length2(this.mutable);
  }
}
var backingQueueFromMutableQueue = (mutable) => new BackingQueueFromMutableQueue(mutable);
var capacity2 = (self2) => self2.capacity();
var size8 = (self2) => self2.size;
var isFull = (self2) => self2.isFull;
var isEmpty10 = (self2) => self2.isEmpty;
var isShutdown = (self2) => self2.isShutdown;
var awaitShutdown = (self2) => self2.awaitShutdown;
var shutdown = (self2) => self2.shutdown;
var offer2 = /* @__PURE__ */ dual(2, (self2, value) => self2.offer(value));
var unsafeOffer = /* @__PURE__ */ dual(2, (self2, value) => self2.unsafeOffer(value));
var offerAll2 = /* @__PURE__ */ dual(2, (self2, iterable) => self2.offerAll(iterable));
var poll5 = (self2) => map10(self2.takeUpTo(1), head2);
var take2 = (self2) => self2.take;
var takeAll = (self2) => self2.takeAll;
var takeUpTo = /* @__PURE__ */ dual(2, (self2, max5) => self2.takeUpTo(max5));
var takeBetween = /* @__PURE__ */ dual(3, (self2, min3, max5) => self2.takeBetween(min3, max5));
var takeN = /* @__PURE__ */ dual(2, (self2, n) => self2.takeBetween(n, n));
var backPressureStrategy = () => new BackPressureStrategy;
var droppingStrategy = () => new DroppingStrategy;
var slidingStrategy = () => new SlidingStrategy;

class BackPressureStrategy {
  [QueueStrategyTypeId] = queueStrategyVariance;
  putters = /* @__PURE__ */ unbounded();
  surplusSize() {
    return length2(this.putters);
  }
  onCompleteTakersWithEmptyQueue(takers) {
    while (!isEmpty7(this.putters) && !isEmpty7(takers)) {
      const taker = poll2(takers, undefined);
      const putter = poll2(this.putters, undefined);
      if (putter[2]) {
        unsafeCompleteDeferred(putter[1], true);
      }
      unsafeCompleteDeferred(taker, putter[0]);
    }
  }
  get shutdown() {
    return pipe(fiberId, flatMap8((fiberId3) => pipe(sync(() => unsafePollAll(this.putters)), flatMap8((putters) => forEachConcurrentDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred, fiberId3), asVoid) : void_, false, false)))));
  }
  handleSurplus(iterable, queue, takers, isShutdown2) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(iterable, deferred);
        this.unsafeOnQueueEmptySpace(queue, takers);
        unsafeCompleteTakers(this, queue, takers);
        return get6(isShutdown2) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnQueueEmptySpace(queue, takers) {
    let keepPolling = true;
    while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {
      const putter = pipe(this.putters, poll2(EmptyMutableQueue));
      if (putter === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const offered = queue.offer(putter[0]);
        if (offered && putter[2]) {
          unsafeCompleteDeferred(putter[1], true);
        } else if (!offered) {
          unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), prepend2(putter)));
        }
        unsafeCompleteTakers(this, queue, takers);
      }
    }
  }
  unsafeOffer(iterable, deferred) {
    const stuff = fromIterable(iterable);
    for (let i = 0;i < stuff.length; i++) {
      const value = stuff[i];
      if (i === stuff.length - 1) {
        pipe(this.putters, offer([value, deferred, true]));
      } else {
        pipe(this.putters, offer([value, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), filter2(([, _]) => _ !== deferred)));
  }
}

class DroppingStrategy {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_;
  }
  onCompleteTakersWithEmptyQueue() {}
  handleSurplus(_iterable, _queue, _takers, _isShutdown) {
    return succeed(false);
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {}
}

class SlidingStrategy {
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_;
  }
  onCompleteTakersWithEmptyQueue() {}
  handleSurplus(iterable, queue, takers, _isShutdown) {
    return sync(() => {
      this.unsafeOffer(queue, iterable);
      unsafeCompleteTakers(this, queue, takers);
      return true;
    });
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {}
  unsafeOffer(queue, iterable) {
    const iterator = iterable[Symbol.iterator]();
    let next;
    let offering = true;
    while (!(next = iterator.next()).done && offering) {
      if (queue.capacity() === 0) {
        return;
      }
      queue.poll(EmptyMutableQueue);
      offering = queue.offer(next.value);
    }
  }
}
var unsafeCompleteDeferred = (deferred, a) => {
  return deferredUnsafeDone(deferred, succeed(a));
};
var unsafeOfferAll = (queue, as4) => {
  return pipe(queue, offerAll(as4));
};
var unsafePollAll = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollN = (queue, max5) => {
  return pipe(queue, pollUpTo(max5));
};
var unsafeRemove = (queue, a) => {
  unsafeOfferAll(queue, pipe(unsafePollAll(queue), filter2((b) => a !== b)));
};
var unsafeCompleteTakers = (strategy, queue, takers) => {
  let keepPolling = true;
  while (keepPolling && queue.length() !== 0) {
    const taker = pipe(takers, poll2(EmptyMutableQueue));
    if (taker !== EmptyMutableQueue) {
      const element = queue.poll(EmptyMutableQueue);
      if (element !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, element);
        strategy.unsafeOnQueueEmptySpace(queue, takers);
      } else {
        unsafeOfferAll(takers, pipe(unsafePollAll(takers), prepend2(taker)));
      }
      keepPolling = true;
    } else {
      keepPolling = false;
    }
  }
  if (keepPolling && queue.length() === 0 && !isEmpty7(takers)) {
    strategy.onCompleteTakersWithEmptyQueue(takers);
  }
};

// node_modules/effect/dist/esm/internal/pubsub.js
var AbsentValue = /* @__PURE__ */ Symbol.for("effect/PubSub/AbsentValue");
var addSubscribers = (subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    subscribers.set(subscription, new Set);
  }
  const set7 = subscribers.get(subscription);
  set7.add(pollers);
};
var removeSubscribers = (subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    return;
  }
  const set7 = subscribers.get(subscription);
  set7.delete(pollers);
  if (set7.size === 0) {
    subscribers.delete(subscription);
  }
};
var bounded3 = (capacity3) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity3);
  return makePubSub(pubsub, new BackPressureStrategy2);
});
var dropping2 = (capacity3) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity3);
  return makePubSub(pubsub, new DroppingStrategy2);
});
var sliding2 = (capacity3) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity3);
  return makePubSub(pubsub, new SlidingStrategy2);
});
var unbounded3 = (options) => suspend(() => {
  const pubsub = makeUnboundedPubSub(options);
  return makePubSub(pubsub, new DroppingStrategy2);
});
var shutdown2 = (self2) => self2.shutdown;
var subscribe = (self2) => self2.subscribe;
var makeBoundedPubSub = (capacity3) => {
  const options = typeof capacity3 === "number" ? {
    capacity: capacity3
  } : capacity3;
  ensureCapacity(options.capacity);
  const replayBuffer = options.replay && options.replay > 0 ? new ReplayBuffer(Math.ceil(options.replay)) : undefined;
  if (options.capacity === 1) {
    return new BoundedPubSubSingle(replayBuffer);
  } else if (nextPow2(options.capacity) === options.capacity) {
    return new BoundedPubSubPow2(options.capacity, replayBuffer);
  } else {
    return new BoundedPubSubArb(options.capacity, replayBuffer);
  }
};
var makeUnboundedPubSub = (options) => new UnboundedPubSub(options?.replay ? new ReplayBuffer(options.replay) : undefined);
var makeSubscription = (pubsub, subscribers, strategy) => map10(deferredMake(), (deferred) => unsafeMakeSubscription(pubsub, subscribers, pubsub.subscribe(), unbounded(), deferred, make11(false), strategy));
var unsafeMakeSubscription = (pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) => new SubscriptionImpl(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, pubsub.replayWindow());

class BoundedPubSubArb {
  capacity;
  replayBuffer;
  array;
  publisherIndex = 0;
  subscribers;
  subscriberCount = 0;
  subscribersIndex = 0;
  constructor(capacity3, replayBuffer) {
    this.capacity = capacity3;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity3
    });
    this.subscribers = Array.from({
      length: capacity3
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex % this.capacity;
      this.array[index] = value;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty4();
    }
    const chunk2 = fromIterable2(elements);
    const n = chunk2.length;
    const size9 = this.publisherIndex - this.subscribersIndex;
    const available = this.capacity - size9;
    const forPubSub = Math.min(n, available);
    if (forPubSub === 0) {
      return chunk2;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const a = unsafeGet4(chunk2, iteratorIndex++);
      const index = this.publisherIndex % this.capacity;
      this.array[index] = a;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(a);
      }
    }
    return drop2(chunk2, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex % this.capacity;
      this.array[index] = AbsentValue;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubArbSubscription(this, this.publisherIndex, false);
  }
}

class BoundedPubSubArbSubscription {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex % this.self.capacity;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty4();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size9 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size9);
    if (toPoll <= 0) {
      return empty4();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex % this.self.capacity;
      const a = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(a);
      this.subscriberIndex += 1;
    }
    return fromIterable2(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex % this.self.capacity;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
}

class BoundedPubSubPow2 {
  capacity;
  replayBuffer;
  array;
  mask;
  publisherIndex = 0;
  subscribers;
  subscriberCount = 0;
  subscribersIndex = 0;
  constructor(capacity3, replayBuffer) {
    this.capacity = capacity3;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity3
    });
    this.mask = capacity3 - 1;
    this.subscribers = Array.from({
      length: capacity3
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index = this.publisherIndex & this.mask;
      this.array[index] = value;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty4();
    }
    const chunk2 = fromIterable2(elements);
    const n = chunk2.length;
    const size9 = this.publisherIndex - this.subscribersIndex;
    const available = this.capacity - size9;
    const forPubSub = Math.min(n, available);
    if (forPubSub === 0) {
      return chunk2;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const elem = unsafeGet4(chunk2, iteratorIndex++);
      const index = this.publisherIndex & this.mask;
      this.array[index] = elem;
      this.subscribers[index] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(elem);
      }
    }
    return drop2(chunk2, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index = this.subscribersIndex & this.mask;
      this.array[index] = AbsentValue;
      this.subscribers[index] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubPow2Subscription(this, this.publisherIndex, false);
  }
}

class BoundedPubSubPow2Subscription {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty4();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size9 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size9);
    if (toPoll <= 0) {
      return empty4();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index];
      this.self.subscribers[index] -= 1;
      if (this.self.subscribers[index] === 0) {
        this.self.array[index] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(elem);
      this.subscriberIndex += 1;
    }
    return fromIterable2(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index = this.subscriberIndex & this.self.mask;
        this.self.subscribers[index] -= 1;
        if (this.self.subscribers[index] === 0) {
          this.self.array[index] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
}

class BoundedPubSubSingle {
  replayBuffer;
  publisherIndex = 0;
  subscriberCount = 0;
  subscribers = 0;
  value = AbsentValue;
  capacity = 1;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  isEmpty() {
    return this.subscribers === 0;
  }
  isFull() {
    return !this.isEmpty();
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  publish(value) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      this.value = value;
      this.subscribers = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty4();
    }
    const chunk2 = fromIterable2(elements);
    if (isEmpty(chunk2)) {
      return chunk2;
    }
    if (this.publish(unsafeHead(chunk2))) {
      return drop2(chunk2, 1);
    } else {
      return chunk2;
    }
  }
  slide() {
    if (this.isFull()) {
      this.subscribers = 0;
      this.value = AbsentValue;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubSingleSubscription(this, this.publisherIndex, false);
  }
}

class BoundedPubSubSingleSubscription {
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.subscribers === 0 || this.subscriberIndex === this.self.publisherIndex;
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  poll(default_) {
    if (this.isEmpty()) {
      return default_;
    }
    const elem = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return elem;
  }
  pollUpTo(n) {
    if (this.isEmpty() || n < 1) {
      return empty4();
    }
    const a = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return of2(a);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      if (this.subscriberIndex !== this.self.publisherIndex) {
        this.self.subscribers -= 1;
        if (this.self.subscribers === 0) {
          this.self.value = AbsentValue;
        }
      }
    }
  }
}

class UnboundedPubSub {
  replayBuffer;
  publisherHead = {
    value: AbsentValue,
    subscribers: 0,
    next: null
  };
  publisherTail = this.publisherHead;
  publisherIndex = 0;
  subscribersIndex = 0;
  capacity = Number.MAX_SAFE_INTEGER;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherHead === this.publisherTail;
  }
  isFull() {
    return false;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value) {
    const subscribers = this.publisherTail.subscribers;
    if (subscribers !== 0) {
      this.publisherTail.next = {
        value,
        subscribers,
        next: null
      };
      this.publisherTail = this.publisherTail.next;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.publisherTail.subscribers !== 0) {
      for (const a of elements) {
        this.publish(a);
      }
    } else if (this.replayBuffer) {
      this.replayBuffer.offerAll(elements);
    }
    return empty4();
  }
  slide() {
    if (this.publisherHead !== this.publisherTail) {
      this.publisherHead = this.publisherHead.next;
      this.publisherHead.value = AbsentValue;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.publisherTail.subscribers += 1;
    return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
  }
}

class UnboundedPubSubSubscription {
  self;
  subscriberHead;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberHead, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberHead = subscriberHead;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    if (this.unsubscribed) {
      return true;
    }
    let empty29 = true;
    let loop3 = true;
    while (loop3) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop3 = false;
      } else {
        if (this.subscriberHead.next.value !== AbsentValue) {
          empty29 = false;
          loop3 = false;
        } else {
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
    }
    return empty29;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    let loop3 = true;
    let polled = default_;
    while (loop3) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop3 = false;
      } else {
        const elem = this.subscriberHead.next.value;
        if (elem !== AbsentValue) {
          polled = elem;
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          loop3 = false;
        }
        this.subscriberHead = this.subscriberHead.next;
        this.subscriberIndex += 1;
      }
    }
    return polled;
  }
  pollUpTo(n) {
    const builder = [];
    const default_ = AbsentValue;
    let i = 0;
    while (i !== n) {
      const a = this.poll(default_);
      if (a === default_) {
        i = n;
      } else {
        builder.push(a);
        i += 1;
      }
    }
    return fromIterable2(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.publisherTail.subscribers -= 1;
      while (this.subscriberHead !== this.self.publisherTail) {
        if (this.subscriberHead.next.value !== AbsentValue) {
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
        }
        this.subscriberHead = this.subscriberHead.next;
      }
    }
  }
}

class SubscriptionImpl extends Class {
  pubsub;
  subscribers;
  subscription;
  pollers;
  shutdownHook;
  shutdownFlag;
  strategy;
  replayWindow;
  [DequeueTypeId] = dequeueVariance;
  constructor(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, replayWindow) {
    super();
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.subscription = subscription;
    this.pollers = pollers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
    this.replayWindow = replayWindow;
  }
  commit() {
    return this.take;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  capacity() {
    return this.pubsub.capacity;
  }
  isActive() {
    return !get6(this.shutdownFlag);
  }
  get size() {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() + this.replayWindow.remaining));
  }
  unsafeSize() {
    if (get6(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.subscription.size() + this.replayWindow.remaining);
  }
  get isFull() {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() === this.capacity()));
  }
  get isEmpty() {
    return map10(this.size, (size9) => size9 === 0);
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      set2(this.shutdownFlag, true);
      return pipe(forEachParUnbounded(unsafePollAllQueue(this.pollers), (d) => deferredInterruptWith(d, state.id()), false), zipRight(sync(() => {
        this.subscribers.delete(this.subscription);
        this.subscription.unsubscribe();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      })), whenEffect(deferredSucceed(this.shutdownHook, undefined)), asVoid);
    }));
  }
  get isShutdown() {
    return sync(() => get6(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get take() {
    return withFiberRuntime((state) => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.replayWindow.remaining > 0) {
        const message2 = this.replayWindow.take();
        return succeed(message2);
      }
      const message = isEmpty7(this.pollers) ? this.subscription.poll(EmptyMutableQueue) : EmptyMutableQueue;
      if (message === EmptyMutableQueue) {
        const deferred = deferredUnsafeMake(state.id());
        return pipe(suspend(() => {
          pipe(this.pollers, offer(deferred));
          pipe(this.subscribers, addSubscribers(this.subscription, this.pollers));
          this.strategy.unsafeCompletePollers(this.pubsub, this.subscribers, this.subscription, this.pollers);
          return get6(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => sync(() => unsafeRemove2(this.pollers, deferred))));
      } else {
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        return succeed(message);
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const as4 = isEmpty7(this.pollers) ? unsafePollAllSubscription(this.subscription) : empty4();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      if (this.replayWindow.remaining > 0) {
        return succeed(appendAll2(this.replayWindow.takeAll(), as4));
      }
      return succeed(as4);
    });
  }
  takeUpTo(max5) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      let replay = undefined;
      if (this.replayWindow.remaining >= max5) {
        const as5 = this.replayWindow.takeN(max5);
        return succeed(as5);
      } else if (this.replayWindow.remaining > 0) {
        replay = this.replayWindow.takeAll();
        max5 = max5 - replay.length;
      }
      const as4 = isEmpty7(this.pollers) ? unsafePollN2(this.subscription, max5) : empty4();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      return replay ? succeed(appendAll2(replay, as4)) : succeed(as4);
    });
  }
  takeBetween(min3, max5) {
    return suspend(() => takeRemainderLoop2(this, min3, max5, empty4()));
  }
}
var takeRemainderLoop2 = (self2, min3, max5, acc) => {
  if (max5 < min3) {
    return succeed(acc);
  }
  return pipe(self2.takeUpTo(max5), flatMap8((bs) => {
    const remaining = min3 - bs.length;
    if (remaining === 1) {
      return pipe(self2.take, map10((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(self2.take, flatMap8((b) => takeRemainderLoop2(self2, remaining - 1, max5 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
};

class PubSubImpl {
  pubsub;
  subscribers;
  scope;
  shutdownHook;
  shutdownFlag;
  strategy;
  [EnqueueTypeId] = enqueueVariance;
  [DequeueTypeId] = dequeueVariance;
  constructor(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) {
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.scope = scope5;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  capacity() {
    return this.pubsub.capacity;
  }
  get size() {
    return suspend(() => get6(this.shutdownFlag) ? interrupt2 : sync(() => this.pubsub.size()));
  }
  unsafeSize() {
    if (get6(this.shutdownFlag)) {
      return none2();
    }
    return some2(this.pubsub.size());
  }
  get isFull() {
    return map10(this.size, (size9) => size9 === this.capacity());
  }
  get isEmpty() {
    return map10(this.size, (size9) => size9 === 0);
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get isShutdown() {
    return sync(() => get6(this.shutdownFlag));
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state) => {
      pipe(this.shutdownFlag, set2(true));
      return pipe(this.scope.close(exitInterrupt(state.id())), zipRight(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, undefined)), asVoid);
    }));
  }
  publish(value) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.pubsub.publish(value)) {
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, of2(value), this.shutdownFlag);
    });
  }
  isActive() {
    return !get6(this.shutdownFlag);
  }
  unsafeOffer(value) {
    if (get6(this.shutdownFlag)) {
      return false;
    }
    if (this.pubsub.publish(value)) {
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      return true;
    }
    return false;
  }
  publishAll(elements) {
    return suspend(() => {
      if (get6(this.shutdownFlag)) {
        return interrupt2;
      }
      const surplus = unsafePublishAll(this.pubsub, elements);
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      if (isEmpty(surplus)) {
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, surplus, this.shutdownFlag);
    });
  }
  get subscribe() {
    const acquire = tap(all3([this.scope.fork(sequential2), makeSubscription(this.pubsub, this.subscribers, this.strategy)]), (tuple) => tuple[0].addFinalizer(() => tuple[1].shutdown));
    return map10(acquireRelease(acquire, (tuple, exit3) => tuple[0].close(exit3)), (tuple) => tuple[1]);
  }
  offer(value) {
    return this.publish(value);
  }
  offerAll(elements) {
    return this.publishAll(elements);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var makePubSub = (pubsub, strategy) => flatMap8(scopeMake(), (scope5) => map10(deferredMake(), (deferred) => unsafeMakePubSub(pubsub, new Map, scope5, deferred, make11(false), strategy)));
var unsafeMakePubSub = (pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) => new PubSubImpl(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy);
var ensureCapacity = (capacity3) => {
  if (capacity3 <= 0) {
    throw new InvalidPubSubCapacityException(`Cannot construct PubSub with capacity of ${capacity3}`);
  }
};
var unsafeCompleteDeferred2 = (deferred, a) => {
  deferredUnsafeDone(deferred, succeed(a));
};
var unsafeOfferAll2 = (queue, as4) => {
  return pipe(queue, offerAll(as4));
};
var unsafePollAllQueue = (queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
};
var unsafePollAllSubscription = (subscription) => {
  return subscription.pollUpTo(Number.POSITIVE_INFINITY);
};
var unsafePollN2 = (subscription, max5) => {
  return subscription.pollUpTo(max5);
};
var unsafePublishAll = (pubsub, as4) => {
  return pubsub.publishAll(as4);
};
var unsafeRemove2 = (queue, value) => {
  unsafeOfferAll2(queue, pipe(unsafePollAllQueue(queue), filter2((elem) => elem !== value)));
};

class BackPressureStrategy2 {
  publishers = /* @__PURE__ */ unbounded();
  get shutdown() {
    return flatMap8(fiberId, (fiberId3) => flatMap8(sync(() => unsafePollAllQueue(this.publishers)), (publishers) => forEachConcurrentDiscard(publishers, ([_, deferred, last3]) => last3 ? pipe(deferredInterruptWith(deferred, fiberId3), asVoid) : void_, false, false)));
  }
  handleSurplus(pubsub, subscribers, elements, isShutdown2) {
    return withFiberRuntime((state) => {
      const deferred = deferredUnsafeMake(state.id());
      return pipe(suspend(() => {
        this.unsafeOffer(elements, deferred);
        this.unsafeOnPubSubEmptySpace(pubsub, subscribers);
        this.unsafeCompleteSubscribers(pubsub, subscribers);
        return get6(isShutdown2) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnPubSubEmptySpace(pubsub, subscribers) {
    let keepPolling = true;
    while (keepPolling && !pubsub.isFull()) {
      const publisher = pipe(this.publishers, poll2(EmptyMutableQueue));
      if (publisher === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const published = pubsub.publish(publisher[0]);
        if (published && publisher[2]) {
          unsafeCompleteDeferred2(publisher[1], true);
        } else if (!published) {
          unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), prepend2(publisher)));
        }
        this.unsafeCompleteSubscribers(pubsub, subscribers);
      }
    }
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeOffer(elements, deferred) {
    const iterator = elements[Symbol.iterator]();
    let next = iterator.next();
    if (!next.done) {
      while (true) {
        const value = next.value;
        next = iterator.next();
        if (next.done) {
          pipe(this.publishers, offer([value, deferred, true]));
          break;
        }
        pipe(this.publishers, offer([value, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), filter2(([_, a]) => a !== deferred)));
  }
}

class DroppingStrategy2 {
  get shutdown() {
    return void_;
  }
  handleSurplus(_pubsub, _subscribers, _elements, _isShutdown) {
    return succeed(false);
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {}
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
}

class SlidingStrategy2 {
  get shutdown() {
    return void_;
  }
  handleSurplus(pubsub, subscribers, elements, _isShutdown) {
    return sync(() => {
      this.unsafeSlidingPublish(pubsub, elements);
      this.unsafeCompleteSubscribers(pubsub, subscribers);
      return true;
    });
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {}
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeSlidingPublish(pubsub, elements) {
    const it = elements[Symbol.iterator]();
    let next = it.next();
    if (!next.done && pubsub.capacity > 0) {
      let a = next.value;
      let loop3 = true;
      while (loop3) {
        pubsub.slide();
        const pub = pubsub.publish(a);
        if (pub && (next = it.next()) && !next.done) {
          a = next.value;
        } else if (pub) {
          loop3 = false;
        }
      }
    }
  }
}
var unsafeStrategyCompletePollers = (strategy, pubsub, subscribers, subscription, pollers) => {
  let keepPolling = true;
  while (keepPolling && !subscription.isEmpty()) {
    const poller = pipe(pollers, poll2(EmptyMutableQueue));
    if (poller === EmptyMutableQueue) {
      pipe(subscribers, removeSubscribers(subscription, pollers));
      if (isEmpty7(pollers)) {
        keepPolling = false;
      } else {
        pipe(subscribers, addSubscribers(subscription, pollers));
      }
    } else {
      const pollResult = subscription.poll(EmptyMutableQueue);
      if (pollResult === EmptyMutableQueue) {
        unsafeOfferAll2(pollers, pipe(unsafePollAllQueue(pollers), prepend2(poller)));
      } else {
        unsafeCompleteDeferred2(poller, pollResult);
        strategy.unsafeOnPubSubEmptySpace(pubsub, subscribers);
      }
    }
  }
};
var unsafeStrategyCompleteSubscribers = (strategy, pubsub, subscribers) => {
  for (const [subscription, pollersSet] of subscribers) {
    for (const pollers of pollersSet) {
      strategy.unsafeCompletePollers(pubsub, subscribers, subscription, pollers);
    }
  }
};

class ReplayBuffer {
  capacity;
  constructor(capacity3) {
    this.capacity = capacity3;
  }
  head = {
    value: AbsentValue,
    next: null
  };
  tail = this.head;
  size = 0;
  index = 0;
  slide() {
    this.index++;
  }
  offer(a) {
    this.tail.value = a;
    this.tail.next = {
      value: AbsentValue,
      next: null
    };
    this.tail = this.tail.next;
    if (this.size === this.capacity) {
      this.head = this.head.next;
    } else {
      this.size += 1;
    }
  }
  offerAll(as4) {
    for (const a of as4) {
      this.offer(a);
    }
  }
}

class ReplayWindowImpl {
  buffer;
  head;
  index;
  remaining;
  constructor(buffer) {
    this.buffer = buffer;
    this.index = buffer.index;
    this.remaining = buffer.size;
    this.head = buffer.head;
  }
  fastForward() {
    while (this.index < this.buffer.index) {
      this.head = this.head.next;
      this.index++;
    }
  }
  take() {
    if (this.remaining === 0) {
      return;
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    this.remaining--;
    const value = this.head.value;
    this.head = this.head.next;
    return value;
  }
  takeN(n) {
    if (this.remaining === 0) {
      return empty4();
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    const len = Math.min(n, this.remaining);
    const items = new Array(len);
    for (let i = 0;i < len; i++) {
      const value = this.head.value;
      this.head = this.head.next;
      items[i] = value;
    }
    this.remaining -= len;
    return unsafeFromArray(items);
  }
  takeAll() {
    return this.takeN(this.remaining);
  }
}
var emptyReplayWindow = {
  remaining: 0,
  take: () => {
    return;
  },
  takeN: () => empty4(),
  takeAll: () => empty4()
};

// node_modules/effect/dist/esm/PubSub.js
var bounded4 = bounded3;
var dropping3 = dropping2;
var sliding3 = sliding2;
var unbounded4 = unbounded3;
var shutdown3 = shutdown2;
var subscribe2 = subscribe;

// node_modules/effect/dist/esm/Queue.js
var exports_Queue = {};
__export(exports_Queue, {
  unsafeOffer: () => unsafeOffer2,
  unbounded: () => unbounded5,
  takeUpTo: () => takeUpTo2,
  takeN: () => takeN2,
  takeBetween: () => takeBetween2,
  takeAll: () => takeAll2,
  take: () => take3,
  slidingStrategy: () => slidingStrategy2,
  sliding: () => sliding4,
  size: () => size10,
  shutdown: () => shutdown4,
  poll: () => poll6,
  offerAll: () => offerAll3,
  offer: () => offer3,
  make: () => make41,
  isShutdown: () => isShutdown3,
  isQueue: () => isQueue2,
  isFull: () => isFull3,
  isEnqueue: () => isEnqueue2,
  isEmpty: () => isEmpty12,
  isDequeue: () => isDequeue2,
  droppingStrategy: () => droppingStrategy2,
  dropping: () => dropping4,
  capacity: () => capacity4,
  bounded: () => bounded5,
  backPressureStrategy: () => backPressureStrategy2,
  awaitShutdown: () => awaitShutdown3,
  QueueStrategyTypeId: () => QueueStrategyTypeId2,
  EnqueueTypeId: () => EnqueueTypeId2,
  DequeueTypeId: () => DequeueTypeId2,
  BackingQueueTypeId: () => BackingQueueTypeId2
});
var EnqueueTypeId2 = EnqueueTypeId;
var DequeueTypeId2 = DequeueTypeId;
var QueueStrategyTypeId2 = QueueStrategyTypeId;
var BackingQueueTypeId2 = BackingQueueTypeId;
var isQueue2 = isQueue;
var isDequeue2 = isDequeue;
var isEnqueue2 = isEnqueue;
var backPressureStrategy2 = backPressureStrategy;
var droppingStrategy2 = droppingStrategy;
var slidingStrategy2 = slidingStrategy;
var make41 = make40;
var bounded5 = bounded2;
var dropping4 = dropping;
var sliding4 = sliding;
var unbounded5 = unbounded2;
var capacity4 = capacity2;
var size10 = size8;
var isEmpty12 = isEmpty10;
var isFull3 = isFull;
var isShutdown3 = isShutdown;
var awaitShutdown3 = awaitShutdown;
var shutdown4 = shutdown;
var offer3 = offer2;
var unsafeOffer2 = unsafeOffer;
var offerAll3 = offerAll2;
var poll6 = poll5;
var take3 = take2;
var takeAll2 = takeAll;
var takeUpTo2 = takeUpTo;
var takeBetween2 = takeBetween;
var takeN2 = takeN;

// node_modules/effect/dist/esm/internal/opCodes/channelChildExecutorDecision.js
var OP_CONTINUE2 = "Continue";
var OP_CLOSE = "Close";
var OP_YIELD2 = "Yield";

// node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
var ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
var ChildExecutorDecisionTypeId = /* @__PURE__ */ Symbol.for(ChildExecutorDecisionSymbolKey);
var proto4 = {
  [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
};
var Continue = (_) => {
  const op = Object.create(proto4);
  op._tag = OP_CONTINUE2;
  return op;
};

// node_modules/effect/dist/esm/internal/opCodes/continuation.js
var OP_CONTINUATION_K = "ContinuationK";
var OP_CONTINUATION_FINALIZER = "ContinuationFinalizer";

// node_modules/effect/dist/esm/internal/channel/continuation.js
var ContinuationTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelContinuation");
var continuationVariance = {
  _Env: (_) => _,
  _InErr: (_) => _,
  _InElem: (_) => _,
  _InDone: (_) => _,
  _OutErr: (_) => _,
  _OutDone: (_) => _,
  _OutErr2: (_) => _,
  _OutElem: (_) => _,
  _OutDone2: (_) => _
};

class ContinuationKImpl {
  onSuccess;
  onHalt;
  _tag = OP_CONTINUATION_K;
  [ContinuationTypeId] = continuationVariance;
  constructor(onSuccess, onHalt) {
    this.onSuccess = onSuccess;
    this.onHalt = onHalt;
  }
  onExit(exit3) {
    return isFailure(exit3) ? this.onHalt(exit3.cause) : this.onSuccess(exit3.value);
  }
}

class ContinuationFinalizerImpl {
  finalizer;
  _tag = OP_CONTINUATION_FINALIZER;
  [ContinuationTypeId] = continuationVariance;
  constructor(finalizer) {
    this.finalizer = finalizer;
  }
}

// node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullStrategy.js
var OP_PULL_AFTER_NEXT = "PullAfterNext";
var OP_PULL_AFTER_ALL_ENQUEUED = "PullAfterAllEnqueued";

// node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
var UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
var UpstreamPullStrategyTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullStrategySymbolKey);
var upstreamPullStrategyVariance = {
  _A: (_) => _
};
var proto5 = {
  [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
};
var PullAfterNext = (emitSeparator) => {
  const op = Object.create(proto5);
  op._tag = OP_PULL_AFTER_NEXT;
  op.emitSeparator = emitSeparator;
  return op;
};

// node_modules/effect/dist/esm/internal/opCodes/channel.js
var OP_BRACKET_OUT = "BracketOut";
var OP_BRIDGE = "Bridge";
var OP_CONCAT_ALL = "ConcatAll";
var OP_EMIT = "Emit";
var OP_ENSURING = "Ensuring";
var OP_FAIL3 = "Fail";
var OP_FOLD2 = "Fold";
var OP_FROM_EFFECT2 = "FromEffect";
var OP_PIPE_TO = "PipeTo";
var OP_PROVIDE2 = "Provide";
var OP_READ = "Read";
var OP_SUCCEED = "Succeed";
var OP_SUCCEED_NOW = "SucceedNow";
var OP_SUSPEND2 = "Suspend";

// node_modules/effect/dist/esm/internal/core-stream.js
var ChannelSymbolKey = "effect/Channel";
var ChannelTypeId2 = /* @__PURE__ */ Symbol.for(ChannelSymbolKey);
var channelVariance2 = {
  _Env: (_) => _,
  _InErr: (_) => _,
  _InElem: (_) => _,
  _InDone: (_) => _,
  _OutErr: (_) => _,
  _OutElem: (_) => _,
  _OutDone: (_) => _
};
var proto6 = {
  [ChannelTypeId2]: channelVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isChannel = (u) => hasProperty(u, ChannelTypeId2) || isEffect2(u);
var acquireReleaseOut = /* @__PURE__ */ dual(2, (self2, release) => {
  const op = Object.create(proto6);
  op._tag = OP_BRACKET_OUT;
  op.acquire = () => self2;
  op.finalizer = release;
  return op;
});
var catchAllCause5 = /* @__PURE__ */ dual(2, (self2, f) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self2;
  op.k = new ContinuationKImpl(succeed10, f);
  return op;
});
var collectElements = (self2) => {
  return suspend5(() => {
    const builder = [];
    return flatMap13(pipeTo(self2, collectElementsReader(builder)), (value) => sync5(() => [fromIterable2(builder), value]));
  });
};
var collectElementsReader = (builder) => readWith({
  onInput: (outElem) => flatMap13(sync5(() => {
    builder.push(outElem);
  }), () => collectElementsReader(builder)),
  onFailure: fail11,
  onDone: succeedNow
});
var concatAllWith = (channels, f, g) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = f;
  op.combineAll = g;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => channels;
  op.k = identity;
  return op;
};
var concatMapWith = /* @__PURE__ */ dual(4, (self2, f, g, h) => {
  const op = Object.create(proto6);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = g;
  op.combineAll = h;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => self2;
  op.k = f;
  return op;
});
var embedInput = /* @__PURE__ */ dual(2, (self2, input) => {
  const op = Object.create(proto6);
  op._tag = OP_BRIDGE;
  op.input = input;
  op.channel = self2;
  return op;
});
var ensuringWith = /* @__PURE__ */ dual(2, (self2, finalizer) => {
  const op = Object.create(proto6);
  op._tag = OP_ENSURING;
  op.channel = self2;
  op.finalizer = finalizer;
  return op;
});
var fail11 = (error) => failCause10(fail5(error));
var failCause10 = (cause3) => failCauseSync5(() => cause3);
var failCauseSync5 = (evaluate2) => {
  const op = Object.create(proto6);
  op._tag = OP_FAIL3;
  op.error = evaluate2;
  return op;
};
var flatMap13 = /* @__PURE__ */ dual(2, (self2, f) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self2;
  op.k = new ContinuationKImpl(f, failCause10);
  return op;
});
var foldCauseChannel = /* @__PURE__ */ dual(2, (self2, options) => {
  const op = Object.create(proto6);
  op._tag = OP_FOLD2;
  op.channel = self2;
  op.k = new ContinuationKImpl(options.onSuccess, options.onFailure);
  return op;
});
var fromEffect4 = (effect2) => {
  const op = Object.create(proto6);
  op._tag = OP_FROM_EFFECT2;
  op.effect = () => effect2;
  return op;
};
var pipeTo = /* @__PURE__ */ dual(2, (self2, that) => {
  const op = Object.create(proto6);
  op._tag = OP_PIPE_TO;
  op.left = () => self2;
  op.right = () => that;
  return op;
});
var provideContext3 = /* @__PURE__ */ dual(2, (self2, env) => {
  const op = Object.create(proto6);
  op._tag = OP_PROVIDE2;
  op.context = () => env;
  op.inner = self2;
  return op;
});
var readWith = (options) => readWithCause({
  onInput: options.onInput,
  onFailure: (cause3) => match(failureOrCause2(cause3), {
    onLeft: options.onFailure,
    onRight: failCause10
  }),
  onDone: options.onDone
});
var readWithCause = (options) => {
  const op = Object.create(proto6);
  op._tag = OP_READ;
  op.more = options.onInput;
  op.done = new ContinuationKImpl(options.onDone, options.onFailure);
  return op;
};
var succeed10 = (value) => sync5(() => value);
var succeedNow = (result) => {
  const op = Object.create(proto6);
  op._tag = OP_SUCCEED_NOW;
  op.terminal = result;
  return op;
};
var suspend5 = (evaluate2) => {
  const op = Object.create(proto6);
  op._tag = OP_SUSPEND2;
  op.channel = evaluate2;
  return op;
};
var sync5 = (evaluate2) => {
  const op = Object.create(proto6);
  op._tag = OP_SUCCEED;
  op.evaluate = evaluate2;
  return op;
};
var void_5 = /* @__PURE__ */ succeedNow(undefined);
var write = (out) => {
  const op = Object.create(proto6);
  op._tag = OP_EMIT;
  op.out = out;
  return op;
};

// node_modules/effect/dist/esm/internal/opCodes/channelState.js
var OP_DONE3 = "Done";
var OP_EMIT2 = "Emit";
var OP_FROM_EFFECT3 = "FromEffect";
var OP_READ2 = "Read";

// node_modules/effect/dist/esm/internal/channel/channelState.js
var ChannelStateTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelState");
var channelStateVariance = {
  _E: (_) => _,
  _R: (_) => _
};
var proto7 = {
  [ChannelStateTypeId]: channelStateVariance
};
var Done2 = () => {
  const op = Object.create(proto7);
  op._tag = OP_DONE3;
  return op;
};
var Emit = () => {
  const op = Object.create(proto7);
  op._tag = OP_EMIT2;
  return op;
};
var fromEffect5 = (effect2) => {
  const op = Object.create(proto7);
  op._tag = OP_FROM_EFFECT3;
  op.effect = effect2;
  return op;
};
var Read = (upstream, onEffect, onEmit, onDone) => {
  const op = Object.create(proto7);
  op._tag = OP_READ2;
  op.upstream = upstream;
  op.onEffect = onEffect;
  op.onEmit = onEmit;
  op.onDone = onDone;
  return op;
};
var isFromEffect = (self2) => self2._tag === OP_FROM_EFFECT3;
var effect2 = (self2) => isFromEffect(self2) ? self2.effect : _void;
var effectOrUndefinedIgnored = (self2) => isFromEffect(self2) ? ignore2(self2.effect) : undefined;

// node_modules/effect/dist/esm/internal/channel/subexecutor.js
var OP_PULL_FROM_CHILD = "PullFromChild";
var OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
var OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
var OP_EMIT3 = "Emit";

class PullFromChild {
  childExecutor;
  parentSubexecutor;
  onEmit;
  _tag = OP_PULL_FROM_CHILD;
  constructor(childExecutor, parentSubexecutor, onEmit) {
    this.childExecutor = childExecutor;
    this.parentSubexecutor = parentSubexecutor;
    this.onEmit = onEmit;
  }
  close(exit3) {
    const fin1 = this.childExecutor.close(exit3);
    const fin2 = this.parentSubexecutor.close(exit3);
    if (fin1 !== undefined && fin2 !== undefined) {
      return zipWith5(exit2(fin1), exit2(fin2), (exit1, exit22) => pipe(exit1, zipRight2(exit22)));
    } else if (fin1 !== undefined) {
      return fin1;
    } else if (fin2 !== undefined) {
      return fin2;
    } else {
      return;
    }
  }
  enqueuePullFromChild(_child) {
    return this;
  }
}

class PullFromUpstream {
  upstreamExecutor;
  createChild;
  lastDone;
  activeChildExecutors;
  combineChildResults;
  combineWithChildResult;
  onPull;
  onEmit;
  _tag = OP_PULL_FROM_UPSTREAM;
  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
    this.upstreamExecutor = upstreamExecutor;
    this.createChild = createChild;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
    this.onEmit = onEmit;
  }
  close(exit3) {
    const fin1 = this.upstreamExecutor.close(exit3);
    const fins = [...this.activeChildExecutors.map((child) => child !== undefined ? child.childExecutor.close(exit3) : undefined), fin1];
    const result = fins.reduce((acc, next) => {
      if (acc !== undefined && next !== undefined) {
        return zipWith5(acc, exit2(next), (exit1, exit22) => zipRight2(exit1, exit22));
      } else if (acc !== undefined) {
        return acc;
      } else if (next !== undefined) {
        return exit2(next);
      } else {
        return;
      }
    }, undefined);
    return result === undefined ? result : result;
  }
  enqueuePullFromChild(child) {
    return new PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
  }
}

class DrainChildExecutors {
  upstreamExecutor;
  lastDone;
  activeChildExecutors;
  upstreamDone;
  combineChildResults;
  combineWithChildResult;
  onPull;
  _tag = OP_DRAIN_CHILD_EXECUTORS;
  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
    this.upstreamExecutor = upstreamExecutor;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.upstreamDone = upstreamDone;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
  }
  close(exit3) {
    const fin1 = this.upstreamExecutor.close(exit3);
    const fins = [...this.activeChildExecutors.map((child) => child !== undefined ? child.childExecutor.close(exit3) : undefined), fin1];
    const result = fins.reduce((acc, next) => {
      if (acc !== undefined && next !== undefined) {
        return zipWith5(acc, exit2(next), (exit1, exit22) => zipRight2(exit1, exit22));
      } else if (acc !== undefined) {
        return acc;
      } else if (next !== undefined) {
        return exit2(next);
      } else {
        return;
      }
    }, undefined);
    return result === undefined ? result : result;
  }
  enqueuePullFromChild(child) {
    return new DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
  }
}

class Emit2 {
  value;
  next;
  _tag = OP_EMIT3;
  constructor(value, next) {
    this.value = value;
    this.next = next;
  }
  close(exit3) {
    const result = this.next.close(exit3);
    return result === undefined ? result : result;
  }
  enqueuePullFromChild(_child) {
    return this;
  }
}

// node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullRequest.js
var OP_PULLED = "Pulled";
var OP_NO_UPSTREAM = "NoUpstream";

// node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
var UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
var UpstreamPullRequestTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullRequestSymbolKey);
var upstreamPullRequestVariance = {
  _A: (_) => _
};
var proto8 = {
  [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
};
var Pulled = (value) => {
  const op = Object.create(proto8);
  op._tag = OP_PULLED;
  op.value = value;
  return op;
};
var NoUpstream = (activeDownstreamCount) => {
  const op = Object.create(proto8);
  op._tag = OP_NO_UPSTREAM;
  op.activeDownstreamCount = activeDownstreamCount;
  return op;
};

// node_modules/effect/dist/esm/internal/channel/channelExecutor.js
class ChannelExecutor {
  _activeSubexecutor = undefined;
  _cancelled = undefined;
  _closeLastSubstream = undefined;
  _currentChannel;
  _done = undefined;
  _doneStack = [];
  _emitted = undefined;
  _executeCloseLastSubstream;
  _input = undefined;
  _inProgressFinalizer = undefined;
  _providedEnv;
  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
    this._currentChannel = initialChannel;
    this._executeCloseLastSubstream = executeCloseLastSubstream;
    this._providedEnv = providedEnv;
  }
  run() {
    let result = undefined;
    while (result === undefined) {
      if (this._cancelled !== undefined) {
        result = this.processCancellation();
      } else if (this._activeSubexecutor !== undefined) {
        result = this.runSubexecutor();
      } else {
        try {
          if (this._currentChannel === undefined) {
            result = Done2();
          } else {
            if (isEffect2(this._currentChannel)) {
              this._currentChannel = fromEffect4(this._currentChannel);
            }
            switch (this._currentChannel._tag) {
              case OP_BRACKET_OUT: {
                result = this.runBracketOut(this._currentChannel);
                break;
              }
              case OP_BRIDGE: {
                const bridgeInput = this._currentChannel.input;
                this._currentChannel = this._currentChannel.channel;
                if (this._input !== undefined) {
                  const inputExecutor = this._input;
                  this._input = undefined;
                  const drainer = () => flatMap11(bridgeInput.awaitRead(), () => suspend3(() => {
                    const state = inputExecutor.run();
                    switch (state._tag) {
                      case OP_DONE3: {
                        return match6(inputExecutor.getDone(), {
                          onFailure: (cause3) => bridgeInput.error(cause3),
                          onSuccess: (value) => bridgeInput.done(value)
                        });
                      }
                      case OP_EMIT2: {
                        return flatMap11(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                      }
                      case OP_FROM_EFFECT3: {
                        return matchCauseEffect3(state.effect, {
                          onFailure: (cause3) => bridgeInput.error(cause3),
                          onSuccess: () => drainer()
                        });
                      }
                      case OP_READ2: {
                        return readUpstream(state, () => drainer(), (cause3) => bridgeInput.error(cause3));
                      }
                    }
                  }));
                  result = fromEffect5(flatMap11(forkDaemon2(interruptible4(drainer())), (fiber) => sync3(() => this.addFinalizer((exit3) => flatMap11(interrupt6(fiber), () => suspend3(() => {
                    const effect3 = this.restorePipe(exit3, inputExecutor);
                    return effect3 !== undefined ? effect3 : _void;
                  }))))));
                }
                break;
              }
              case OP_CONCAT_ALL: {
                const executor = new ChannelExecutor(this._currentChannel.value(), this._providedEnv, (effect3) => sync3(() => {
                  const prevLastClose = this._closeLastSubstream === undefined ? _void : this._closeLastSubstream;
                  this._closeLastSubstream = pipe(prevLastClose, zipRight3(effect3));
                }));
                executor._input = this._input;
                const channel = this._currentChannel;
                this._activeSubexecutor = new PullFromUpstream(executor, (value) => channel.k(value), undefined, [], (x, y) => channel.combineInners(x, y), (x, y) => channel.combineAll(x, y), (request2) => channel.onPull(request2), (value) => channel.onEmit(value));
                this._closeLastSubstream = undefined;
                this._currentChannel = undefined;
                break;
              }
              case OP_EMIT: {
                this._emitted = this._currentChannel.out;
                this._currentChannel = this._activeSubexecutor !== undefined ? undefined : void_5;
                result = Emit();
                break;
              }
              case OP_ENSURING: {
                this.runEnsuring(this._currentChannel);
                break;
              }
              case OP_FAIL3: {
                result = this.doneHalt(this._currentChannel.error());
                break;
              }
              case OP_FOLD2: {
                this._doneStack.push(this._currentChannel.k);
                this._currentChannel = this._currentChannel.channel;
                break;
              }
              case OP_FROM_EFFECT2: {
                const effect3 = this._providedEnv === undefined ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide2(this._providedEnv));
                result = fromEffect5(matchCauseEffect3(effect3, {
                  onFailure: (cause3) => {
                    const state = this.doneHalt(cause3);
                    return state !== undefined && isFromEffect(state) ? state.effect : _void;
                  },
                  onSuccess: (value) => {
                    const state = this.doneSucceed(value);
                    return state !== undefined && isFromEffect(state) ? state.effect : _void;
                  }
                }));
                break;
              }
              case OP_PIPE_TO: {
                const previousInput = this._input;
                const leftExec = new ChannelExecutor(this._currentChannel.left(), this._providedEnv, (effect3) => this._executeCloseLastSubstream(effect3));
                leftExec._input = previousInput;
                this._input = leftExec;
                this.addFinalizer((exit3) => {
                  const effect3 = this.restorePipe(exit3, previousInput);
                  return effect3 !== undefined ? effect3 : _void;
                });
                this._currentChannel = this._currentChannel.right();
                break;
              }
              case OP_PROVIDE2: {
                const previousEnv = this._providedEnv;
                this._providedEnv = this._currentChannel.context();
                this._currentChannel = this._currentChannel.inner;
                this.addFinalizer(() => sync3(() => {
                  this._providedEnv = previousEnv;
                }));
                break;
              }
              case OP_READ: {
                const read = this._currentChannel;
                result = Read(this._input, identity, (emitted) => {
                  try {
                    this._currentChannel = read.more(emitted);
                  } catch (error) {
                    this._currentChannel = read.done.onExit(die3(error));
                  }
                  return;
                }, (exit3) => {
                  const onExit4 = (exit4) => {
                    return read.done.onExit(exit4);
                  };
                  this._currentChannel = onExit4(exit3);
                  return;
                });
                break;
              }
              case OP_SUCCEED: {
                result = this.doneSucceed(this._currentChannel.evaluate());
                break;
              }
              case OP_SUCCEED_NOW: {
                result = this.doneSucceed(this._currentChannel.terminal);
                break;
              }
              case OP_SUSPEND2: {
                this._currentChannel = this._currentChannel.channel();
                break;
              }
            }
          }
        } catch (error) {
          this._currentChannel = failCause10(die4(error));
        }
      }
    }
    return result;
  }
  getDone() {
    return this._done;
  }
  getEmit() {
    return this._emitted;
  }
  cancelWith(exit3) {
    this._cancelled = exit3;
  }
  clearInProgressFinalizer() {
    this._inProgressFinalizer = undefined;
  }
  storeInProgressFinalizer(finalizer) {
    this._inProgressFinalizer = finalizer;
  }
  popAllFinalizers(exit3) {
    const finalizers = [];
    let next = this._doneStack.pop();
    while (next) {
      if (next._tag === "ContinuationFinalizer") {
        finalizers.push(next.finalizer);
      }
      next = this._doneStack.pop();
    }
    const effect3 = finalizers.length === 0 ? _void : runFinalizers(finalizers, exit3);
    this.storeInProgressFinalizer(effect3);
    return effect3;
  }
  popNextFinalizers() {
    const builder = [];
    while (this._doneStack.length !== 0) {
      const cont = this._doneStack[this._doneStack.length - 1];
      if (cont._tag === OP_CONTINUATION_K) {
        return builder;
      }
      builder.push(cont);
      this._doneStack.pop();
    }
    return builder;
  }
  restorePipe(exit3, prev) {
    const currInput = this._input;
    this._input = prev;
    if (currInput !== undefined) {
      const effect3 = currInput.close(exit3);
      return effect3;
    }
    return _void;
  }
  close(exit3) {
    let runInProgressFinalizers = undefined;
    const finalizer = this._inProgressFinalizer;
    if (finalizer !== undefined) {
      runInProgressFinalizers = pipe(finalizer, ensuring2(sync3(() => this.clearInProgressFinalizer())));
    }
    let closeSelf = undefined;
    const selfFinalizers = this.popAllFinalizers(exit3);
    if (selfFinalizers !== undefined) {
      closeSelf = pipe(selfFinalizers, ensuring2(sync3(() => this.clearInProgressFinalizer())));
    }
    const closeSubexecutors = this._activeSubexecutor === undefined ? undefined : this._activeSubexecutor.close(exit3);
    if (closeSubexecutors === undefined && runInProgressFinalizers === undefined && closeSelf === undefined) {
      return;
    }
    return pipe(exit2(ifNotNull(closeSubexecutors)), zip5(exit2(ifNotNull(runInProgressFinalizers))), zip5(exit2(ifNotNull(closeSelf))), map16(([[exit1, exit22], exit32]) => pipe(exit1, zipRight2(exit22), zipRight2(exit32))), uninterruptible2, flatMap11((exit4) => suspend3(() => exit4)));
  }
  doneSucceed(value) {
    if (this._doneStack.length === 0) {
      this._done = succeed3(value);
      this._currentChannel = undefined;
      return Done2();
    }
    const head5 = this._doneStack[this._doneStack.length - 1];
    if (head5._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      this._currentChannel = head5.onSuccess(value);
      return;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = succeed3(value);
      this._currentChannel = undefined;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), succeed3(value));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect3 = pipe(finalizerEffect, ensuring2(sync3(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap11(() => sync3(() => this.doneSucceed(value))));
    return fromEffect5(effect3);
  }
  doneHalt(cause3) {
    if (this._doneStack.length === 0) {
      this._done = failCause3(cause3);
      this._currentChannel = undefined;
      return Done2();
    }
    const head5 = this._doneStack[this._doneStack.length - 1];
    if (head5._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      try {
        this._currentChannel = head5.onHalt(cause3);
      } catch (error) {
        this._currentChannel = failCause10(die4(error));
      }
      return;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = failCause3(cause3);
      this._currentChannel = undefined;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), failCause3(cause3));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect3 = pipe(finalizerEffect, ensuring2(sync3(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap11(() => sync3(() => this.doneHalt(cause3))));
    return fromEffect5(effect3);
  }
  processCancellation() {
    this._currentChannel = undefined;
    this._done = this._cancelled;
    this._cancelled = undefined;
    return Done2();
  }
  runBracketOut(bracketOut) {
    const effect3 = uninterruptible2(matchCauseEffect3(this.provide(bracketOut.acquire()), {
      onFailure: (cause3) => sync3(() => {
        this._currentChannel = failCause10(cause3);
      }),
      onSuccess: (out) => sync3(() => {
        this.addFinalizer((exit3) => this.provide(bracketOut.finalizer(out, exit3)));
        this._currentChannel = write(out);
      })
    }));
    return fromEffect5(effect3);
  }
  provide(effect3) {
    if (this._providedEnv === undefined) {
      return effect3;
    }
    return pipe(effect3, provide2(this._providedEnv));
  }
  runEnsuring(ensuring3) {
    this.addFinalizer(ensuring3.finalizer);
    this._currentChannel = ensuring3.channel;
  }
  addFinalizer(f) {
    this._doneStack.push(new ContinuationFinalizerImpl(f));
  }
  runSubexecutor() {
    const subexecutor = this._activeSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_CHILD: {
        return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
      }
      case OP_PULL_FROM_UPSTREAM: {
        return this.pullFromUpstream(subexecutor);
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        return this.drainChildExecutors(subexecutor);
      }
      case OP_EMIT3: {
        this._emitted = subexecutor.value;
        this._activeSubexecutor = subexecutor.next;
        return Emit();
      }
    }
  }
  replaceSubexecutor(nextSubExec) {
    this._currentChannel = undefined;
    this._activeSubexecutor = nextSubExec;
  }
  finishWithExit(exit3) {
    const state = match6(exit3, {
      onFailure: (cause3) => this.doneHalt(cause3),
      onSuccess: (value) => this.doneSucceed(value)
    });
    this._activeSubexecutor = undefined;
    return state === undefined ? _void : effect2(state);
  }
  finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
    this.addFinalizer(() => pipe(closeFuncs, forEach6((closeFunc) => pipe(sync3(() => closeFunc(subexecutorDone)), flatMap11((closeEffect) => closeEffect !== undefined ? closeEffect : _void)), {
      discard: true
    })));
    const state = pipe(subexecutorDone, match6({
      onFailure: (cause3) => this.doneHalt(cause3),
      onSuccess: (value) => this.doneSucceed(value)
    }));
    this._activeSubexecutor = undefined;
    return state;
  }
  applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
    switch (strategy._tag) {
      case OP_PULL_AFTER_NEXT: {
        const shouldPrepend = !upstreamFinished || queue.some((subexecutor) => subexecutor !== undefined);
        return [strategy.emitSeparator, shouldPrepend ? [undefined, ...queue] : queue];
      }
      case OP_PULL_AFTER_ALL_ENQUEUED: {
        const shouldEnqueue = !upstreamFinished || queue.some((subexecutor) => subexecutor !== undefined);
        return [strategy.emitSeparator, shouldEnqueue ? [...queue, undefined] : queue];
      }
    }
  }
  pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
    return Read(childExecutor, identity, (emitted) => {
      const childExecutorDecision = onEmitted(emitted);
      switch (childExecutorDecision._tag) {
        case OP_CONTINUE2: {
          break;
        }
        case OP_CLOSE: {
          this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
          break;
        }
        case OP_YIELD2: {
          const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      }
      this._activeSubexecutor = new Emit2(emitted, this._activeSubexecutor);
      return;
    }, match6({
      onFailure: (cause3) => {
        const state = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3);
        return state === undefined ? undefined : effectOrUndefinedIgnored(state);
      },
      onSuccess: (doneValue) => {
        this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
        return;
      }
    }));
  }
  finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
    const subexecutor = parentSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_UPSTREAM: {
        const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
        this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== undefined ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      default: {
        break;
      }
    }
  }
  handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3) {
    return this.finishSubexecutorWithCloseEffect(failCause3(cause3), (exit3) => parentSubexecutor.close(exit3), (exit3) => childExecutor.close(exit3));
  }
  pullFromUpstream(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      return this.performPullFromUpstream(subexecutor);
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
    if (activeChild === undefined) {
      return this.performPullFromUpstream(parentSubexecutor);
    }
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return;
  }
  performPullFromUpstream(subexecutor) {
    return Read(subexecutor.upstreamExecutor, (effect3) => {
      const closeLastSubstream = this._closeLastSubstream === undefined ? _void : this._closeLastSubstream;
      this._closeLastSubstream = undefined;
      return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight3(effect3));
    }, (emitted) => {
      if (this._closeLastSubstream !== undefined) {
        const closeLastSubstream = this._closeLastSubstream;
        this._closeLastSubstream = undefined;
        return pipe(this._executeCloseLastSubstream(closeLastSubstream), map16(() => {
          const childExecutor2 = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
          childExecutor2._input = this._input;
          const [emitSeparator2, updatedChildExecutors2] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
          this._activeSubexecutor = new PullFromChild(childExecutor2, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors2, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
          if (isSome2(emitSeparator2)) {
            this._activeSubexecutor = new Emit2(emitSeparator2.value, this._activeSubexecutor);
          }
          return;
        }));
      }
      const childExecutor = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
      childExecutor._input = this._input;
      const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
      this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
      if (isSome2(emitSeparator)) {
        this._activeSubexecutor = new Emit2(emitSeparator.value, this._activeSubexecutor);
      }
      return;
    }, (exit3) => {
      if (subexecutor.activeChildExecutors.some((subexecutor2) => subexecutor2 !== undefined)) {
        const drain = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [undefined, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        if (this._closeLastSubstream !== undefined) {
          const closeLastSubstream2 = this._closeLastSubstream;
          this._closeLastSubstream = undefined;
          return pipe(this._executeCloseLastSubstream(closeLastSubstream2), map16(() => this.replaceSubexecutor(drain)));
        }
        this.replaceSubexecutor(drain);
        return;
      }
      const closeLastSubstream = this._closeLastSubstream;
      const state = this.finishSubexecutorWithCloseEffect(pipe(exit3, map11((a) => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, (exit4) => subexecutor.upstreamExecutor.close(exit4));
      return state === undefined ? undefined : effectOrUndefinedIgnored(state);
    });
  }
  drainChildExecutors(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      const lastClose = this._closeLastSubstream;
      if (lastClose !== undefined) {
        this.addFinalizer(() => succeed8(lastClose));
      }
      return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, (exit3) => subexecutor.upstreamExecutor.close(exit3));
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const rest = subexecutor.activeChildExecutors.slice(1);
    if (activeChild === undefined) {
      const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n, curr) => curr !== undefined ? n + 1 : n, 0))));
      this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
      if (isSome2(emitSeparator)) {
        this._emitted = emitSeparator.value;
        return Emit();
      }
      return;
    }
    const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return;
  }
}
var ifNotNull = (effect3) => effect3 !== undefined ? effect3 : _void;
var runFinalizers = (finalizers, exit3) => {
  return pipe(forEach6(finalizers, (fin) => exit2(fin(exit3))), map16((exits) => pipe(all(exits), getOrElse(() => void_2))), flatMap11((exit4) => suspend3(() => exit4)));
};
var readUpstream = (r, onSuccess, onFailure) => {
  const readStack = [r];
  const read = () => {
    const current = readStack.pop();
    if (current === undefined || current.upstream === undefined) {
      return dieMessage2("Unexpected end of input for channel execution");
    }
    const state = current.upstream.run();
    switch (state._tag) {
      case OP_EMIT2: {
        const emitEffect = current.onEmit(current.upstream.getEmit());
        if (readStack.length === 0) {
          if (emitEffect === undefined) {
            return suspend3(onSuccess);
          }
          return pipe(emitEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (emitEffect === undefined) {
          return suspend3(() => read());
        }
        return pipe(emitEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read()
        }));
      }
      case OP_DONE3: {
        const doneEffect = current.onDone(current.upstream.getDone());
        if (readStack.length === 0) {
          if (doneEffect === undefined) {
            return suspend3(onSuccess);
          }
          return pipe(doneEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (doneEffect === undefined) {
          return suspend3(() => read());
        }
        return pipe(doneEffect, matchCauseEffect3({
          onFailure,
          onSuccess: () => read()
        }));
      }
      case OP_FROM_EFFECT3: {
        readStack.push(current);
        return pipe(current.onEffect(state.effect), catchAllCause3((cause3) => suspend3(() => {
          const doneEffect = current.onDone(failCause3(cause3));
          return doneEffect === undefined ? _void : doneEffect;
        })), matchCauseEffect3({
          onFailure,
          onSuccess: () => read()
        }));
      }
      case OP_READ2: {
        readStack.push(current);
        readStack.push(state);
        return suspend3(() => read());
      }
    }
  };
  return read();
};
var runIn = /* @__PURE__ */ dual(2, (self2, scope5) => {
  const run = (channelDeferred, scopeDeferred, scope6) => acquireUseRelease2(sync3(() => new ChannelExecutor(self2, undefined, identity)), (exec) => suspend3(() => runScopedInterpret(exec.run(), exec).pipe(intoDeferred2(channelDeferred), zipRight3(_await(channelDeferred)), zipLeft2(_await(scopeDeferred)))), (exec, exit3) => {
    const finalize = exec.close(exit3);
    if (finalize === undefined) {
      return _void;
    }
    return tapErrorCause3(finalize, (cause3) => addFinalizer2(scope6, failCause8(cause3)));
  });
  return uninterruptibleMask3((restore) => all4([fork2(scope5, sequential3), make18(), make18()]).pipe(flatMap11(([child, channelDeferred, scopeDeferred]) => restore(run(channelDeferred, scopeDeferred, child)).pipe(forkIn2(scope5), flatMap11((fiber) => scope5.addFinalizer((exit3) => {
    const interruptors3 = isFailure(exit3) ? interruptors2(exit3.cause) : undefined;
    return isDone(channelDeferred).pipe(flatMap11((isDone6) => isDone6 ? succeed2(scopeDeferred, undefined).pipe(zipRight3(_await3(fiber)), zipRight3(inheritAll2(fiber))) : succeed2(scopeDeferred, undefined).pipe(zipRight3(interruptors3 && size3(interruptors3) > 0 ? interruptAs(fiber, combineAll2(interruptors3)) : interrupt6(fiber)), zipRight3(inheritAll2(fiber)))));
  }).pipe(zipRight3(restore(_await(channelDeferred)))))))));
});
var runScopedInterpret = (channelState, exec) => {
  const op = channelState;
  switch (op._tag) {
    case OP_FROM_EFFECT3: {
      return pipe(op.effect, flatMap11(() => runScopedInterpret(exec.run(), exec)));
    }
    case OP_EMIT2: {
      return runScopedInterpret(exec.run(), exec);
    }
    case OP_DONE3: {
      return suspend3(() => exec.getDone());
    }
    case OP_READ2: {
      return readUpstream(op, () => runScopedInterpret(exec.run(), exec), failCause8);
    }
  }
};

// node_modules/effect/dist/esm/internal/opCodes/channelMergeDecision.js
var OP_DONE4 = "Done";
var OP_AWAIT = "Await";

// node_modules/effect/dist/esm/internal/channel/mergeDecision.js
var MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
var MergeDecisionTypeId = /* @__PURE__ */ Symbol.for(MergeDecisionSymbolKey);
var proto9 = {
  [MergeDecisionTypeId]: {
    _R: (_) => _,
    _E0: (_) => _,
    _Z0: (_) => _,
    _E: (_) => _,
    _Z: (_) => _
  }
};
var Done3 = (effect3) => {
  const op = Object.create(proto9);
  op._tag = OP_DONE4;
  op.effect = effect3;
  return op;
};
var Await = (f) => {
  const op = Object.create(proto9);
  op._tag = OP_AWAIT;
  op.f = f;
  return op;
};

// node_modules/effect/dist/esm/internal/opCodes/channelMergeState.js
var OP_BOTH_RUNNING = "BothRunning";
var OP_LEFT_DONE = "LeftDone";
var OP_RIGHT_DONE = "RightDone";

// node_modules/effect/dist/esm/internal/channel/mergeState.js
var MergeStateSymbolKey = "effect/ChannelMergeState";
var MergeStateTypeId = /* @__PURE__ */ Symbol.for(MergeStateSymbolKey);
var proto10 = {
  [MergeStateTypeId]: MergeStateTypeId
};
var BothRunning = (left3, right3) => {
  const op = Object.create(proto10);
  op._tag = OP_BOTH_RUNNING;
  op.left = left3;
  op.right = right3;
  return op;
};
var LeftDone = (f) => {
  const op = Object.create(proto10);
  op._tag = OP_LEFT_DONE;
  op.f = f;
  return op;
};
var RightDone = (f) => {
  const op = Object.create(proto10);
  op._tag = OP_RIGHT_DONE;
  op.f = f;
  return op;
};

// node_modules/effect/dist/esm/internal/opCodes/channelMergeStrategy.js
var OP_BACK_PRESSURE = "BackPressure";
var OP_BUFFER_SLIDING = "BufferSliding";

// node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
var MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
var MergeStrategyTypeId = /* @__PURE__ */ Symbol.for(MergeStrategySymbolKey);
var proto11 = {
  [MergeStrategyTypeId]: MergeStrategyTypeId
};
var BackPressure = (_) => {
  const op = Object.create(proto11);
  op._tag = OP_BACK_PRESSURE;
  return op;
};
var BufferSliding = (_) => {
  const op = Object.create(proto11);
  op._tag = OP_BUFFER_SLIDING;
  return op;
};
var match14 = /* @__PURE__ */ dual(2, (self2, {
  onBackPressure,
  onBufferSliding
}) => {
  switch (self2._tag) {
    case OP_BACK_PRESSURE: {
      return onBackPressure();
    }
    case OP_BUFFER_SLIDING: {
      return onBufferSliding();
    }
  }
});

// node_modules/effect/dist/esm/internal/channel/singleProducerAsyncInput.js
var OP_STATE_EMPTY = "Empty";
var OP_STATE_EMIT = "Emit";
var OP_STATE_ERROR = "Error";
var OP_STATE_DONE2 = "Done";
var stateEmpty = (notifyProducer) => ({
  _tag: OP_STATE_EMPTY,
  notifyProducer
});
var stateEmit = (notifyConsumers) => ({
  _tag: OP_STATE_EMIT,
  notifyConsumers
});
var stateError = (cause3) => ({
  _tag: OP_STATE_ERROR,
  cause: cause3
});
var stateDone = (done8) => ({
  _tag: OP_STATE_DONE2,
  done: done8
});

class SingleProducerAsyncInputImpl {
  ref;
  constructor(ref) {
    this.ref = ref;
  }
  awaitRead() {
    return flatten9(modify4(this.ref, (state) => state._tag === OP_STATE_EMPTY ? [_await(state.notifyProducer), state] : [_void, state]));
  }
  get close() {
    return fiberIdWith2((fiberId3) => this.error(interrupt5(fiberId3)));
  }
  done(value) {
    return flatten9(modify4(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach6(state.notifyConsumers, (deferred) => succeed2(deferred, left2(value)), {
            discard: true
          }), stateDone(value)];
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    }));
  }
  emit(element) {
    return flatMap11(make18(), (deferred) => flatten9(modify4(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          const notifyConsumer = state.notifyConsumers[0];
          const notifyConsumers = state.notifyConsumers.slice(1);
          if (notifyConsumer !== undefined) {
            return [succeed2(notifyConsumer, right2(element)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
          }
          throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues");
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    })));
  }
  error(cause3) {
    return flatten9(modify4(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [_await(state.notifyProducer), state];
        }
        case OP_STATE_EMIT: {
          return [forEach6(state.notifyConsumers, (deferred) => failCause2(deferred, cause3), {
            discard: true
          }), stateError(cause3)];
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state];
        }
      }
    }));
  }
  get take() {
    return this.takeWith((cause3) => failCause3(map12(cause3, left2)), (elem) => succeed3(elem), (done8) => fail4(right2(done8)));
  }
  takeWith(onError3, onElement, onDone) {
    return flatMap11(make18(), (deferred) => flatten9(modify4(this.ref, (state) => {
      switch (state._tag) {
        case OP_STATE_EMPTY: {
          return [zipRight3(succeed2(state.notifyProducer, undefined), matchCause3(_await(deferred), {
            onFailure: onError3,
            onSuccess: match({
              onLeft: onDone,
              onRight: onElement
            })
          })), stateEmit([deferred])];
        }
        case OP_STATE_EMIT: {
          return [matchCause3(_await(deferred), {
            onFailure: onError3,
            onSuccess: match({
              onLeft: onDone,
              onRight: onElement
            })
          }), stateEmit([...state.notifyConsumers, deferred])];
        }
        case OP_STATE_ERROR: {
          return [succeed8(onError3(state.cause)), state];
        }
        case OP_STATE_DONE2: {
          return [succeed8(onDone(state.done)), state];
        }
      }
    })));
  }
}
var make42 = () => pipe(make18(), flatMap11((deferred) => make28(stateEmpty(deferred))), map16((ref) => new SingleProducerAsyncInputImpl(ref)));

// node_modules/effect/dist/esm/internal/channel.js
var acquireUseRelease3 = (acquire, use, release) => flatMap13(fromEffect4(make28(() => _void)), (ref) => pipe(fromEffect4(uninterruptible2(tap3(acquire, (a) => set6(ref, (exit3) => release(a, exit3))))), flatMap13(use), ensuringWith((exit3) => flatMap11(get12(ref), (f) => f(exit3)))));
var as4 = /* @__PURE__ */ dual(2, (self2, value) => map18(self2, () => value));
var catchAll5 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause5(self2, (cause3) => match(failureOrCause2(cause3), {
  onLeft: f,
  onRight: failCause10
})));
var concatMap = /* @__PURE__ */ dual(2, (self2, f) => concatMapWith(self2, f, () => {
  return;
}, () => {
  return;
}));
var drain = (self2) => {
  const drainer = readWithCause({
    onInput: () => drainer,
    onFailure: failCause10,
    onDone: succeed10
  });
  return pipeTo(self2, drainer);
};
var ensuring3 = /* @__PURE__ */ dual(2, (self2, finalizer) => ensuringWith(self2, () => finalizer));
var flatten11 = (self2) => flatMap13(self2, identity);
var foldChannel = /* @__PURE__ */ dual(2, (self2, options) => foldCauseChannel(self2, {
  onFailure: (cause3) => {
    const either4 = failureOrCause2(cause3);
    switch (either4._tag) {
      case "Left": {
        return options.onFailure(either4.left);
      }
      case "Right": {
        return failCause10(either4.right);
      }
    }
  },
  onSuccess: options.onSuccess
}));
var fromInput = (input) => unwrap(input.takeWith(failCause10, (elem) => flatMap13(write(elem), () => fromInput(input)), succeed10));
var fromQueue = (queue) => suspend5(() => fromQueueInternal(queue));
var fromQueueInternal = (queue) => pipe(fromEffect4(take3(queue)), flatMap13(match({
  onLeft: match6({
    onFailure: failCause10,
    onSuccess: succeedNow
  }),
  onRight: (elem) => flatMap13(write(elem), () => fromQueueInternal(queue))
})));
var identityChannel = () => readWith({
  onInput: (input) => flatMap13(write(input), () => identityChannel()),
  onFailure: fail11,
  onDone: succeedNow
});
var interruptWhen = /* @__PURE__ */ dual(2, (self2, effect3) => mergeWith2(self2, {
  other: fromEffect4(effect3),
  onSelfDone: (selfDone) => Done3(suspend3(() => selfDone)),
  onOtherDone: (effectDone) => Done3(suspend3(() => effectDone))
}));
var interruptWhenDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => interruptWhen(self2, _await(deferred)));
var map18 = /* @__PURE__ */ dual(2, (self2, f) => flatMap13(self2, (a) => sync5(() => f(a))));
var mapError5 = /* @__PURE__ */ dual(2, (self2, f) => mapErrorCause3(self2, map12(f)));
var mapErrorCause3 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause5(self2, (cause3) => failCause10(f(cause3))));
var mapOut = /* @__PURE__ */ dual(2, (self2, f) => {
  const reader = readWith({
    onInput: (outElem) => flatMap13(write(f(outElem)), () => reader),
    onFailure: fail11,
    onDone: succeedNow
  });
  return pipeTo(self2, reader);
});
var mapOutEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  const reader = readWithCause({
    onInput: (outElem) => pipe(fromEffect4(f(outElem)), flatMap13(write), flatMap13(() => reader)),
    onFailure: failCause10,
    onDone: succeedNow
  });
  return pipeTo(self2, reader);
});
var mapOutEffectPar = /* @__PURE__ */ dual(3, (self2, f, n) => unwrapScopedWith((scope5) => gen2(function* () {
  const input = yield* make42();
  const queueReader = fromInput(input);
  const queue = yield* bounded5(n);
  yield* addFinalizer2(scope5, shutdown4(queue));
  const errorSignal = yield* make18();
  const withPermits = n === Number.POSITIVE_INFINITY ? (_) => identity : (yield* makeSemaphore2(n)).withPermits;
  const pull = yield* queueReader.pipe(pipeTo(self2), toPullIn(scope5));
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause3) => offer3(queue, failCause8(cause3)),
    onSuccess: match({
      onLeft: (outDone) => zipRight3(interruptible4(withPermits(n)(_void)), asVoid3(offer3(queue, succeed8(left2(outDone))))),
      onRight: (outElem) => gen2(function* () {
        const deferred = yield* make18();
        const latch = yield* make18();
        yield* offer3(queue, map16(_await(deferred), right2));
        yield* succeed2(latch, undefined).pipe(zipRight3(uninterruptibleMask3((restore) => exit2(restore(_await(errorSignal))).pipe(raceFirst2(exit2(restore(f(outElem)))), flatMap11(identity))).pipe(tapErrorCause3((cause3) => failCause2(errorSignal, cause3)), intoDeferred2(deferred))), withPermits(1), forkIn2(scope5));
        yield* _await(latch);
      })
    })
  }), forever3, interruptible4, forkIn2(scope5));
  const consumer = unwrap(matchCause3(flatten9(take3(queue)), {
    onFailure: failCause10,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap13(write(outElem), () => consumer)
    })
  }));
  return embedInput(consumer, input);
})));
var mergeAll7 = (options) => {
  return (channels) => mergeAllWith(options)(channels, constVoid);
};
var mergeAllWith = ({
  bufferSize = 16,
  concurrency,
  mergeStrategy = BackPressure()
}) => (channels, f) => unwrapScopedWith((scope5) => gen2(function* () {
  const concurrencyN = concurrency === "unbounded" ? Number.MAX_SAFE_INTEGER : concurrency;
  const input = yield* make42();
  const queueReader = fromInput(input);
  const queue = yield* bounded5(bufferSize);
  yield* addFinalizer2(scope5, shutdown4(queue));
  const cancelers = yield* unbounded5();
  yield* addFinalizer2(scope5, shutdown4(cancelers));
  const lastDone = yield* make28(none2());
  const errorSignal = yield* make18();
  const withPermits = (yield* makeSemaphore2(concurrencyN)).withPermits;
  const pull = yield* toPullIn(pipeTo(queueReader, channels), scope5);
  function evaluatePull(pull2) {
    return pull2.pipe(flatMap11(match({
      onLeft: (done8) => succeed8(some2(done8)),
      onRight: (outElem) => as3(offer3(queue, succeed8(right2(outElem))), none2())
    })), repeat({
      until: (_) => isSome2(_)
    }), flatMap11((outDone) => update3(lastDone, match2({
      onNone: () => some2(outDone.value),
      onSome: (lastDone2) => some2(f(lastDone2, outDone.value))
    }))), catchAllCause3((cause3) => isInterrupted2(cause3) ? failCause8(cause3) : offer3(queue, failCause8(cause3)).pipe(zipRight3(succeed2(errorSignal, undefined)), asVoid3)));
  }
  yield* pull.pipe(matchCauseEffect3({
    onFailure: (cause3) => offer3(queue, failCause8(cause3)).pipe(zipRight3(succeed8(false))),
    onSuccess: match({
      onLeft: (outDone) => raceWith2(interruptible4(_await(errorSignal)), interruptible4(withPermits(concurrencyN)(_void)), {
        onSelfDone: (_, permitAcquisition) => as3(interrupt6(permitAcquisition), false),
        onOtherDone: (_, failureAwait) => zipRight3(interrupt6(failureAwait), get12(lastDone).pipe(flatMap11(match2({
          onNone: () => offer3(queue, succeed8(left2(outDone))),
          onSome: (lastDone2) => offer3(queue, succeed8(left2(f(lastDone2, outDone))))
        })), as3(false)))
      }),
      onRight: (channel) => match14(mergeStrategy, {
        onBackPressure: () => gen2(function* () {
          const latch = yield* make18();
          const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel), scope6).pipe(flatMap11((pull2) => race2(exit2(evaluatePull(pull2)), exit2(interruptible4(_await(errorSignal))))), flatMap11(identity)));
          yield* succeed2(latch, undefined).pipe(zipRight3(raceEffects), withPermits(1), forkIn2(scope5));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        }),
        onBufferSliding: () => gen2(function* () {
          const canceler = yield* make18();
          const latch = yield* make18();
          const size11 = yield* size10(cancelers);
          yield* take3(cancelers).pipe(flatMap11((canceler2) => succeed2(canceler2, undefined)), when2(() => size11 >= concurrencyN));
          yield* offer3(cancelers, canceler);
          const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel), scope6).pipe(flatMap11((pull2) => exit2(evaluatePull(pull2)).pipe(race2(exit2(interruptible4(_await(errorSignal)))), race2(exit2(interruptible4(_await(canceler)))))), flatMap11(identity)));
          yield* succeed2(latch, undefined).pipe(zipRight3(raceEffects), withPermits(1), forkIn2(scope5));
          yield* _await(latch);
          const errored = yield* isDone(errorSignal);
          return !errored;
        })
      })
    })
  }), repeat({
    while: (_) => _
  }), forkIn2(scope5));
  const consumer = pipe(take3(queue), flatten9, matchCause3({
    onFailure: failCause10,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: (outElem) => flatMap13(write(outElem), () => consumer)
    })
  }), unwrap);
  return embedInput(consumer, input);
}));
var mergeMap = /* @__PURE__ */ dual(3, (self2, f, options) => mergeAll7(options)(mapOut(self2, f)));
var mergeWith2 = /* @__PURE__ */ dual(2, (self2, options) => {
  function merge9(scope5) {
    return gen2(function* () {
      const input = yield* make42();
      const queueReader = fromInput(input);
      const pullL = yield* toPullIn(pipeTo(queueReader, self2), scope5);
      const pullR = yield* toPullIn(pipeTo(queueReader, options.other), scope5);
      function handleSide(exit3, fiber, pull) {
        return (done8, both2, single2) => {
          function onDecision(decision) {
            const op = decision;
            if (op._tag === OP_DONE4) {
              return succeed8(fromEffect4(zipRight3(interrupt6(fiber), op.effect)));
            }
            return map16(_await3(fiber), match6({
              onFailure: (cause3) => fromEffect4(op.f(failCause3(cause3))),
              onSuccess: match({
                onLeft: (done9) => fromEffect4(op.f(succeed3(done9))),
                onRight: (elem) => zipRight4(write(elem), go(single2(op.f)))
              })
            }));
          }
          return match6(exit3, {
            onFailure: (cause3) => onDecision(done8(failCause3(cause3))),
            onSuccess: match({
              onLeft: (z) => onDecision(done8(succeed3(z))),
              onRight: (elem) => succeed8(flatMap13(write(elem), () => flatMap13(fromEffect4(forkIn2(interruptible4(pull), scope5)), (leftFiber) => go(both2(leftFiber, fiber)))))
            })
          });
        };
      }
      function go(state) {
        switch (state._tag) {
          case OP_BOTH_RUNNING: {
            const leftJoin = interruptible4(join3(state.left));
            const rightJoin = interruptible4(join3(state.right));
            return unwrap(raceWith2(leftJoin, rightJoin, {
              onSelfDone: (leftExit, rf) => zipRight3(interrupt6(rf), handleSide(leftExit, state.right, pullL)(options.onSelfDone, BothRunning, (f) => LeftDone(f))),
              onOtherDone: (rightExit, lf) => zipRight3(interrupt6(lf), handleSide(rightExit, state.left, pullR)(options.onOtherDone, (left3, right3) => BothRunning(right3, left3), (f) => RightDone(f)))
            }));
          }
          case OP_LEFT_DONE: {
            return unwrap(map16(exit2(pullR), match6({
              onFailure: (cause3) => fromEffect4(state.f(failCause3(cause3))),
              onSuccess: match({
                onLeft: (done8) => fromEffect4(state.f(succeed3(done8))),
                onRight: (elem) => flatMap13(write(elem), () => go(LeftDone(state.f)))
              })
            })));
          }
          case OP_RIGHT_DONE: {
            return unwrap(map16(exit2(pullL), match6({
              onFailure: (cause3) => fromEffect4(state.f(failCause3(cause3))),
              onSuccess: match({
                onLeft: (done8) => fromEffect4(state.f(succeed3(done8))),
                onRight: (elem) => flatMap13(write(elem), () => go(RightDone(state.f)))
              })
            })));
          }
        }
      }
      return fromEffect4(withFiberRuntime2((parent) => {
        const inherit = withFiberRuntime2((state) => {
          state.transferChildren(parent.scope());
          return _void;
        });
        const leftFiber = interruptible4(pullL).pipe(ensuring2(inherit), forkIn2(scope5));
        const rightFiber = interruptible4(pullR).pipe(ensuring2(inherit), forkIn2(scope5));
        return zipWith5(leftFiber, rightFiber, (left3, right3) => BothRunning(left3, right3));
      })).pipe(flatMap13(go), embedInput(input));
    });
  }
  return unwrapScopedWith(merge9);
});
var orDieWith3 = /* @__PURE__ */ dual(2, (self2, f) => catchAll5(self2, (e) => failCauseSync5(() => die4(f(e)))));
var orElse7 = /* @__PURE__ */ dual(2, (self2, that) => catchAll5(self2, that));
var pipeToOrFail = /* @__PURE__ */ dual(2, (self2, that) => suspend5(() => {
  let channelException = undefined;
  const reader = readWith({
    onInput: (outElem) => flatMap13(write(outElem), () => reader),
    onFailure: (outErr) => {
      channelException = ChannelException(outErr);
      return failCause10(die4(channelException));
    },
    onDone: succeedNow
  });
  const writer = readWithCause({
    onInput: (outElem) => pipe(write(outElem), flatMap13(() => writer)),
    onFailure: (cause3) => isDieType2(cause3) && isChannelException(cause3.defect) && equals(cause3.defect, channelException) ? fail11(cause3.defect.error) : failCause10(cause3),
    onDone: succeedNow
  });
  return pipeTo(pipeTo(pipeTo(self2, reader), that), writer);
}));
var repeated = (self2) => flatMap13(self2, () => repeated(self2));
var run = (self2) => scopedWith2((scope5) => runIn(self2, scope5));
var runDrain = (self2) => run(drain(self2));
var runScoped = (self2) => scopeWith2((scope5) => runIn(self2, scope5));
var scoped4 = (effect3) => unwrap(uninterruptibleMask3((restore) => map16(make38(), (scope5) => acquireReleaseOut(tapErrorCause3(restore(extend2(effect3, scope5)), (cause3) => close(scope5, failCause3(cause3))), (_, exit3) => close(scope5, exit3)))));
var scopedWith3 = (f) => unwrapScoped3(map16(scope3, (scope5) => flatMap13(fromEffect4(f(scope5)), write)));
var splitLines = () => suspend5(() => {
  let stringBuilder = "";
  let midCRLF = false;
  const splitLinesChunk = (chunk2) => {
    const chunkBuilder = [];
    map4(chunk2, (str) => {
      if (str.length !== 0) {
        let from = 0;
        let indexOfCR = str.indexOf("\r");
        let indexOfLF = str.indexOf(`
`);
        if (midCRLF) {
          if (indexOfLF === 0) {
            chunkBuilder.push(stringBuilder);
            stringBuilder = "";
            from = 1;
            indexOfLF = str.indexOf(`
`, from);
          } else {
            stringBuilder = stringBuilder + "\r";
          }
          midCRLF = false;
        }
        while (indexOfCR !== -1 || indexOfLF !== -1) {
          if (indexOfCR === -1 || indexOfLF !== -1 && indexOfLF < indexOfCR) {
            if (stringBuilder.length === 0) {
              chunkBuilder.push(str.substring(from, indexOfLF));
            } else {
              chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF));
              stringBuilder = "";
            }
            from = indexOfLF + 1;
            indexOfLF = str.indexOf(`
`, from);
          } else {
            if (str.length === indexOfCR + 1) {
              midCRLF = true;
              indexOfCR = -1;
            } else {
              if (indexOfLF === indexOfCR + 1) {
                if (stringBuilder.length === 0) {
                  chunkBuilder.push(str.substring(from, indexOfCR));
                } else {
                  stringBuilder = stringBuilder + str.substring(from, indexOfCR);
                  chunkBuilder.push(stringBuilder);
                  stringBuilder = "";
                }
                from = indexOfCR + 2;
                indexOfCR = str.indexOf("\r", from);
                indexOfLF = str.indexOf(`
`, from);
              } else {
                indexOfCR = str.indexOf("\r", indexOfCR + 1);
              }
            }
          }
        }
        if (midCRLF) {
          stringBuilder = stringBuilder + str.substring(from, str.length - 1);
        } else {
          stringBuilder = stringBuilder + str.substring(from, str.length);
        }
      }
    });
    return unsafeFromArray(chunkBuilder);
  };
  const loop3 = readWithCause({
    onInput: (input) => {
      const out = splitLinesChunk(input);
      return isEmpty(out) ? loop3 : flatMap13(write(out), () => loop3);
    },
    onFailure: (cause3) => stringBuilder.length === 0 ? failCause10(cause3) : flatMap13(write(of2(stringBuilder)), () => failCause10(cause3)),
    onDone: (done8) => stringBuilder.length === 0 ? succeed10(done8) : flatMap13(write(of2(stringBuilder)), () => succeed10(done8))
  });
  return loop3;
});
var toPubSub = (pubsub) => toQueue(pubsub);
var toPull = (self2) => flatMap11(scope3, (scope5) => toPullIn(self2, scope5));
var toPullIn = /* @__PURE__ */ dual(2, (self2, scope5) => zip5(sync3(() => new ChannelExecutor(self2, undefined, identity)), runtime3()).pipe(tap3(([executor, runtime4]) => addFinalizerExit(scope5, (exit3) => {
  const finalizer = executor.close(exit3);
  return finalizer !== undefined ? provide2(finalizer, runtime4) : _void;
})), uninterruptible2, map16(([executor]) => suspend3(() => interpretToPull(executor.run(), executor)))));
var interpretToPull = (channelState, exec) => {
  const state = channelState;
  switch (state._tag) {
    case OP_DONE3: {
      return match6(exec.getDone(), {
        onFailure: failCause8,
        onSuccess: (done8) => succeed8(left2(done8))
      });
    }
    case OP_EMIT2: {
      return succeed8(right2(exec.getEmit()));
    }
    case OP_FROM_EFFECT3: {
      return pipe(state.effect, flatMap11(() => interpretToPull(exec.run(), exec)));
    }
    case OP_READ2: {
      return readUpstream(state, () => interpretToPull(exec.run(), exec), (cause3) => failCause8(cause3));
    }
  }
};
var toQueue = (queue) => suspend5(() => toQueueInternal(queue));
var toQueueInternal = (queue) => {
  return readWithCause({
    onInput: (elem) => flatMap13(fromEffect4(offer3(queue, right2(elem))), () => toQueueInternal(queue)),
    onFailure: (cause3) => fromEffect4(offer3(queue, left2(failCause3(cause3)))),
    onDone: (done8) => fromEffect4(offer3(queue, left2(succeed3(done8))))
  });
};
var unwrap = (channel) => flatten11(fromEffect4(channel));
var unwrapScoped3 = (self2) => concatAllWith(scoped4(self2), (d, _) => d, (d, _) => d);
var unwrapScopedWith = (f) => concatAllWith(scopedWith3(f), (d, _) => d, (d, _) => d);
var withSpan5 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  const acquire = all4([makeSpan2(name, options), context3(), clock2, get13(currentTracerTimingEnabled2)]);
  if (dataFirst) {
    const self2 = arguments[0];
    return acquireUseRelease3(acquire, ([span4, context5]) => provideContext3(self2, add2(context5, spanTag, span4)), ([span4, , clock3, timingEnabled], exit3) => endSpan(span4, exit3, clock3, timingEnabled));
  }
  return (self2) => acquireUseRelease3(acquire, ([span4, context5]) => provideContext3(self2, add2(context5, spanTag, span4)), ([span4, , clock3, timingEnabled], exit3) => endSpan(span4, exit3, clock3, timingEnabled));
};
var writeAll = (...outs) => writeChunk(fromIterable2(outs));
var writeChunk = (outs) => writeChunkWriter(0, outs.length, outs);
var writeChunkWriter = (idx, len, chunk2) => {
  return idx === len ? void_5 : pipe(write(pipe(chunk2, unsafeGet4(idx))), flatMap13(() => writeChunkWriter(idx + 1, len, chunk2)));
};
var zip6 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options) => options?.concurrent ? mergeWith2(self2, {
  other: that,
  onSelfDone: (exit1) => Await((exit22) => suspend3(() => zip3(exit1, exit22))),
  onOtherDone: (exit22) => Await((exit1) => suspend3(() => zip3(exit1, exit22)))
}) : flatMap13(self2, (a) => map18(that, (b) => [a, b])));
var zipLeft3 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options) => options?.concurrent ? map18(zip6(self2, that, {
  concurrent: true
}), (tuple) => tuple[0]) : flatMap13(self2, (z) => as4(that, z)));
var zipRight4 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options) => options?.concurrent ? map18(zip6(self2, that, {
  concurrent: true
}), (tuple) => tuple[1]) : flatMap13(self2, () => that));
var ChannelExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Channel/ChannelException");
var ChannelException = (error) => ({
  _tag: "ChannelException",
  [ChannelExceptionTypeId]: ChannelExceptionTypeId,
  error
});
var isChannelException = (u) => hasProperty(u, ChannelExceptionTypeId);

// node_modules/effect/dist/esm/internal/sink.js
var SinkTypeId2 = /* @__PURE__ */ Symbol.for("effect/Sink");
var sinkVariance2 = {
  _A: (_) => _,
  _In: (_) => _,
  _L: (_) => _,
  _E: (_) => _,
  _R: (_) => _
};

class SinkImpl {
  channel;
  [SinkTypeId2] = sinkVariance2;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var isSink = (u) => hasProperty(u, SinkTypeId2);
var suspend6 = (evaluate2) => new SinkImpl(suspend5(() => toChannel(evaluate2())));
var collectAll = () => new SinkImpl(collectAllLoop(empty4()));
var collectAllLoop = (acc) => readWithCause({
  onInput: (chunk2) => collectAllLoop(pipe(acc, appendAll2(chunk2))),
  onFailure: failCause10,
  onDone: () => succeed10(acc)
});
var collectAllN = (n) => suspend6(() => fromChannel(collectAllNLoop(n, empty4())));
var collectAllNLoop = (n, acc) => readWithCause({
  onInput: (chunk2) => {
    const [collected, leftovers] = splitAt2(chunk2, n);
    if (collected.length < n) {
      return collectAllNLoop(n - collected.length, appendAll2(acc, collected));
    }
    if (isEmpty(leftovers)) {
      return succeed10(appendAll2(acc, collected));
    }
    return flatMap13(write(leftovers), () => succeed10(appendAll2(acc, collected)));
  },
  onFailure: failCause10,
  onDone: () => succeed10(acc)
});
var collectLeftover = (self2) => new SinkImpl(pipe(collectElements(toChannel(self2)), map18(([chunks, z]) => [z, flatten3(chunks)])));
var drain2 = /* @__PURE__ */ new SinkImpl(/* @__PURE__ */ drain(/* @__PURE__ */ identityChannel()));
var fail12 = (e) => new SinkImpl(fail11(e));
var fold = (s, contFn, f) => suspend6(() => new SinkImpl(foldReader(s, contFn, f)));
var foldReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => {
      const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f, 0, input.length);
      if (isNonEmpty2(leftovers)) {
        return pipe(write(leftovers), as4(nextS));
      }
      return foldReader(nextS, contFn, f);
    },
    onFailure: fail11,
    onDone: () => succeedNow(s)
  });
};
var foldChunkSplit = (s, chunk2, contFn, f, index, length3) => {
  if (index === length3) {
    return [s, empty4()];
  }
  const s1 = f(s, pipe(chunk2, unsafeGet4(index)));
  if (contFn(s1)) {
    return foldChunkSplit(s1, chunk2, contFn, f, index + 1, length3);
  }
  return [s1, pipe(chunk2, drop2(index + 1))];
};
var foldSink = /* @__PURE__ */ dual(2, (self2, options) => {
  const newChannel = pipe(toChannel(self2), collectElements, foldChannel({
    onFailure: (error) => toChannel(options.onFailure(error)),
    onSuccess: ([leftovers, z]) => suspend5(() => {
      const leftoversRef = {
        ref: pipe(leftovers, filter2(isNonEmpty2))
      };
      const refReader = pipe(sync5(() => {
        const ref = leftoversRef.ref;
        leftoversRef.ref = empty4();
        return ref;
      }), flatMap13((chunk2) => writeChunk(chunk2)));
      const passthrough4 = identityChannel();
      const continuationSink = pipe(refReader, zipRight4(passthrough4), pipeTo(toChannel(options.onSuccess(z))));
      return flatMap13(collectElements(continuationSink), ([newLeftovers, z1]) => pipe(succeed10(leftoversRef.ref), flatMap13(writeChunk), zipRight4(writeChunk(newLeftovers)), as4(z1)));
    })
  }));
  return new SinkImpl(newChannel);
});
var foldChunks = (s, contFn, f) => suspend6(() => new SinkImpl(foldChunksReader(s, contFn, f)));
var foldChunksReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => foldChunksReader(f(s, input), contFn, f),
    onFailure: fail11,
    onDone: () => succeedNow(s)
  });
};
var foldEffect = (s, contFn, f) => suspend6(() => new SinkImpl(foldEffectReader(s, contFn, f)));
var foldEffectReader = (s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: (input) => pipe(fromEffect4(foldChunkSplitEffect(s, input, contFn, f)), flatMap13(([nextS, leftovers]) => pipe(leftovers, match2({
      onNone: () => foldEffectReader(nextS, contFn, f),
      onSome: (leftover) => pipe(write(leftover), as4(nextS))
    })))),
    onFailure: fail11,
    onDone: () => succeedNow(s)
  });
};
var foldChunkSplitEffect = (s, chunk2, contFn, f) => foldChunkSplitEffectInternal(s, chunk2, 0, chunk2.length, contFn, f);
var foldChunkSplitEffectInternal = (s, chunk2, index, length3, contFn, f) => {
  if (index === length3) {
    return succeed8([s, none2()]);
  }
  return pipe(f(s, pipe(chunk2, unsafeGet4(index))), flatMap11((s1) => contFn(s1) ? foldChunkSplitEffectInternal(s1, chunk2, index + 1, length3, contFn, f) : succeed8([s1, some2(pipe(chunk2, drop2(index + 1)))])));
};
var foldLeftChunks = (s, f) => foldChunks(s, constTrue, f);
var flatMap14 = /* @__PURE__ */ dual(2, (self2, f) => foldSink(self2, {
  onFailure: fail12,
  onSuccess: f
}));
var forEach7 = (f) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect4(forEach6(input, (v) => f(v), {
      discard: true
    })), flatMap13(() => process2)),
    onFailure: failCause10,
    onDone: () => void_5
  });
  return new SinkImpl(process2);
};
var forEachChunk = (f) => {
  const process2 = readWithCause({
    onInput: (input) => pipe(fromEffect4(f(input)), flatMap13(() => process2)),
    onFailure: failCause10,
    onDone: () => void_5
  });
  return new SinkImpl(process2);
};
var forEachWhile = (f) => {
  const process2 = readWithCause({
    onInput: (input) => forEachWhileReader(f, input, 0, input.length, process2),
    onFailure: failCause10,
    onDone: () => void_5
  });
  return new SinkImpl(process2);
};
var forEachWhileReader = (f, input, index, length3, cont) => {
  if (index === length3) {
    return cont;
  }
  return pipe(fromEffect4(f(pipe(input, unsafeGet4(index)))), flatMap13((bool) => bool ? forEachWhileReader(f, input, index + 1, length3, cont) : write(pipe(input, drop2(index)))), catchAll5((error) => pipe(write(pipe(input, drop2(index))), zipRight4(fail11(error)))));
};
var fromChannel = (channel) => new SinkImpl(channel);
var fromEffect6 = (effect3) => new SinkImpl(fromEffect4(effect3));
var head5 = () => fold(none2(), isNone2, (option3, input) => match2(option3, {
  onNone: () => some2(input),
  onSome: () => option3
}));
var last3 = () => foldLeftChunks(none2(), (s, input) => orElse(last2(input), () => s));
var map19 = /* @__PURE__ */ dual(2, (self2, f) => {
  return new SinkImpl(pipe(toChannel(self2), map18(f)));
});
var raceWith3 = /* @__PURE__ */ dual(2, (self2, options) => {
  function race3(scope5) {
    return gen2(function* () {
      const pubsub = yield* bounded4(options?.capacity ?? 16);
      const subscription1 = yield* extend2(subscribe2(pubsub), scope5);
      const subscription2 = yield* extend2(subscribe2(pubsub), scope5);
      const reader = toPubSub(pubsub);
      const writer = fromQueue(subscription1).pipe(pipeTo(toChannel(self2)), zipLeft3(fromEffect4(shutdown4(subscription1))), mergeWith2({
        other: fromQueue(subscription2).pipe(pipeTo(toChannel(options.other)), zipLeft3(fromEffect4(shutdown4(subscription2)))),
        onSelfDone: options.onSelfDone,
        onOtherDone: options.onOtherDone
      }));
      const racedChannel = mergeWith2(reader, {
        other: writer,
        onSelfDone: () => Await(identity),
        onOtherDone: (exit3) => Done3(exit3)
      });
      return new SinkImpl(racedChannel);
    });
  }
  return unwrapScopedWith2(race3);
});
var sum2 = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk2) => acc + reduce2(chunk2, 0, (s, a) => s + a));
var toChannel = (self2) => isEffect2(self2) ? toChannel(fromEffect6(self2)) : self2.channel;
var unwrapScopedWith2 = (f) => new SinkImpl(unwrapScopedWith((scope5) => f(scope5).pipe(map16((sink) => toChannel(sink)))));
var zipRight5 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self2, that, options) => zipWith7(self2, that, (_, z2) => z2, options));
var zipWith7 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self2, that, f, options) => options?.concurrent ? raceWith3(self2, {
  other: that,
  onSelfDone: match6({
    onFailure: (cause3) => Done3(failCause8(cause3)),
    onSuccess: (leftZ) => Await(match6({
      onFailure: failCause8,
      onSuccess: (rightZ) => succeed8(f(leftZ, rightZ))
    }))
  }),
  onOtherDone: match6({
    onFailure: (cause3) => Done3(failCause8(cause3)),
    onSuccess: (rightZ) => Await(match6({
      onFailure: failCause8,
      onSuccess: (leftZ) => succeed8(f(leftZ, rightZ))
    }))
  })
}) : flatMap14(self2, (z) => map19(that, (z2) => f(z, z2))));
var count = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk2) => acc + chunk2.length);
var mkString = /* @__PURE__ */ suspend6(() => {
  const strings = [];
  return pipe(foldLeftChunks(undefined, (_, elems) => map4(elems, (elem) => {
    strings.push(String(elem));
  })), map19(() => strings.join("")));
});

// node_modules/effect/dist/esm/MergeDecision.js
var Done4 = Done3;
var Await2 = Await;

// node_modules/effect/dist/esm/internal/rcRef.js
var TypeId15 = /* @__PURE__ */ Symbol.for("effect/RcRef");
var stateEmpty2 = {
  _tag: "Empty"
};
var stateClosed = {
  _tag: "Closed"
};
var variance5 = {
  _A: identity,
  _E: identity
};

class RcRefImpl extends Class {
  acquire;
  context;
  scope;
  idleTimeToLive;
  [TypeId15] = variance5;
  [TypeId12] = TypeId12;
  state = stateEmpty2;
  semaphore = /* @__PURE__ */ unsafeMakeSemaphore(1);
  constructor(acquire, context5, scope5, idleTimeToLive) {
    super();
    this.acquire = acquire;
    this.context = context5;
    this.scope = scope5;
    this.idleTimeToLive = idleTimeToLive;
    this.get = get14(this);
  }
  get;
  commit() {
    return this.get;
  }
}
var make43 = (options) => withFiberRuntime((fiber) => {
  const context5 = fiber.getFiberRef(currentContext);
  const scope5 = get3(context5, scopeTag);
  const ref = new RcRefImpl(options.acquire, context5, scope5, options.idleTimeToLive ? decode(options.idleTimeToLive) : undefined);
  return as(scope5.addFinalizer(() => ref.semaphore.withPermits(1)(suspend(() => {
    const close2 = ref.state._tag === "Acquired" ? scopeClose(ref.state.scope, exitVoid) : void_;
    ref.state = stateClosed;
    return close2;
  }))), ref);
});
var get14 = (self_) => {
  const self2 = self_;
  const isInfinite = self2.idleTimeToLive && !isFinite(self2.idleTimeToLive);
  return uninterruptibleMask((restore) => suspend(() => {
    switch (self2.state._tag) {
      case "Closed": {
        return interrupt2;
      }
      case "Acquired": {
        self2.state.refCount++;
        return self2.state.fiber ? as(interruptFiber(self2.state.fiber), self2.state) : succeed(self2.state);
      }
      case "Empty": {
        return scopeMake().pipe(bindTo2("scope"), bind2("value", ({
          scope: scope5
        }) => restore(fiberRefLocally(self2.acquire, currentContext, add2(self2.context, scopeTag, scope5)))), map10(({
          scope: scope5,
          value
        }) => {
          const state = {
            _tag: "Acquired",
            value,
            scope: scope5,
            fiber: undefined,
            refCount: 1
          };
          self2.state = state;
          return state;
        }));
      }
    }
  })).pipe(self2.semaphore.withPermits(1), bindTo2("state"), bind2("scope", () => scopeTag), tap(({
    scope: scope5,
    state
  }) => scope5.addFinalizer(() => suspend(() => {
    state.refCount--;
    if (state.refCount > 0 || isInfinite) {
      return void_;
    }
    if (self2.idleTimeToLive === undefined) {
      self2.state = stateEmpty2;
      return scopeClose(state.scope, exitVoid);
    }
    return sleep3(self2.idleTimeToLive).pipe(interruptible2, zipRight(suspend(() => {
      if (self2.state._tag === "Acquired" && self2.state.refCount === 0) {
        self2.state = stateEmpty2;
        return scopeClose(state.scope, exitVoid);
      }
      return void_;
    })), ensuring(sync(() => {
      state.fiber = undefined;
    })), forkIn(self2.scope), tap((fiber) => {
      state.fiber = fiber;
    }), self2.semaphore.withPermits(1));
  }))), map10(({
    state
  }) => state.value));
};

// node_modules/effect/dist/esm/RcRef.js
var make44 = make43;
var get15 = get14;

// node_modules/effect/dist/esm/Runtime.js
var runFork3 = unsafeFork2;
var runPromiseExit2 = unsafeRunPromiseExit;
var defaultRuntime2 = defaultRuntime;

// node_modules/effect/dist/esm/Schedule.js
var driver2 = driver;
var forever4 = forever2;
var spaced2 = spaced;
var CurrentIterationMetadata2 = CurrentIterationMetadata;

// node_modules/effect/dist/esm/internal/opCodes/streamHaltStrategy.js
var OP_LEFT = "Left";
var OP_RIGHT = "Right";
var OP_BOTH = "Both";
var OP_EITHER = "Either";

// node_modules/effect/dist/esm/internal/stream/haltStrategy.js
var Left = {
  _tag: OP_LEFT
};
var Right = {
  _tag: OP_RIGHT
};
var Both = {
  _tag: OP_BOTH
};
var Either = {
  _tag: OP_EITHER
};
var fromInput2 = (input) => {
  switch (input) {
    case "left":
      return Left;
    case "right":
      return Right;
    case "both":
      return Both;
    case "either":
      return Either;
    default:
      return input;
  }
};

// node_modules/effect/dist/esm/StreamHaltStrategy.js
var Both2 = Both;

// node_modules/effect/dist/esm/internal/stm/versioned.js
class Versioned {
  value;
  constructor(value) {
    this.value = value;
  }
}

// node_modules/effect/dist/esm/internal/stm/entry.js
var make45 = (ref, isNew) => ({
  ref,
  isNew,
  isChanged: false,
  expected: ref.versioned,
  newValue: ref.versioned.value
});
var unsafeGet6 = (self2) => {
  return self2.newValue;
};
var unsafeSet = (self2, value) => {
  self2.isChanged = true;
  self2.newValue = value;
};
var commit = (self2) => {
  self2.ref.versioned = new Versioned(self2.newValue);
};
var isInvalid = (self2) => {
  return self2.ref.versioned !== self2.expected;
};
var isChanged = (self2) => {
  return self2.isChanged;
};

// node_modules/effect/dist/esm/internal/stm/journal.js
var JournalAnalysisInvalid = "Invalid";
var JournalAnalysisReadWrite = "ReadWrite";
var JournalAnalysisReadOnly = "ReadOnly";
var commitJournal = (journal) => {
  for (const entry of journal) {
    commit(entry[1]);
  }
};
var analyzeJournal = (journal) => {
  let val = JournalAnalysisReadOnly;
  for (const [, entry] of journal) {
    val = isInvalid(entry) ? JournalAnalysisInvalid : isChanged(entry) ? JournalAnalysisReadWrite : val;
    if (val === JournalAnalysisInvalid) {
      return val;
    }
  }
  return val;
};
var collectTodos = (journal) => {
  const allTodos = new Map;
  for (const [, entry] of journal) {
    for (const todo of entry.ref.todos) {
      allTodos.set(todo[0], todo[1]);
    }
    entry.ref.todos = new Map;
  }
  return allTodos;
};
var execTodos = (todos) => {
  const todosSorted = Array.from(todos.entries()).sort((x, y) => x[0] - y[0]);
  for (const [_, todo] of todosSorted) {
    todo();
  }
};
var addTodo = (txnId, journal, todoEffect) => {
  let added = false;
  for (const [, entry] of journal) {
    if (!entry.ref.todos.has(txnId)) {
      entry.ref.todos.set(txnId, todoEffect);
      added = true;
    }
  }
  return added;
};

// node_modules/effect/dist/esm/internal/stm/opCodes/stm.js
var OP_WITH_STM_RUNTIME = "WithSTMRuntime";
var OP_ON_FAILURE2 = "OnFailure";
var OP_ON_RETRY = "OnRetry";
var OP_ON_SUCCESS2 = "OnSuccess";
var OP_PROVIDE3 = "Provide";
var OP_SYNC2 = "Sync";
var OP_SUCCEED2 = "Succeed";
var OP_RETRY = "Retry";
var OP_FAIL4 = "Fail";
var OP_DIE2 = "Die";
var OP_INTERRUPT2 = "Interrupt";

// node_modules/effect/dist/esm/internal/stm/opCodes/tExit.js
var OP_FAIL5 = "Fail";
var OP_DIE3 = "Die";
var OP_INTERRUPT3 = "Interrupt";
var OP_SUCCEED3 = "Succeed";
var OP_RETRY2 = "Retry";

// node_modules/effect/dist/esm/internal/stm/opCodes/tryCommit.js
var OP_DONE5 = "Done";
var OP_SUSPEND3 = "Suspend";

// node_modules/effect/dist/esm/internal/stm/opCodes/stmState.js
var OP_DONE6 = "Done";
var OP_INTERRUPTED = "Interrupted";
var OP_RUNNING2 = "Running";

// node_modules/effect/dist/esm/internal/stm/stmState.js
var STMStateSymbolKey = "effect/STM/State";
var STMStateTypeId = /* @__PURE__ */ Symbol.for(STMStateSymbolKey);
var isSTMState = (u) => hasProperty(u, STMStateTypeId);
var isRunning2 = (self2) => {
  return self2._tag === OP_RUNNING2;
};
var isDone6 = (self2) => {
  return self2._tag === OP_DONE6;
};
var done8 = (exit3) => {
  return {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_DONE6,
    exit: exit3,
    [symbol]() {
      return pipe(hash(STMStateSymbolKey), combine(hash(OP_DONE6)), combine(hash(exit3)), cached(this));
    },
    [symbol2](that) {
      return isSTMState(that) && that._tag === OP_DONE6 && equals(exit3, that.exit);
    }
  };
};
var interruptedHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_INTERRUPTED)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("interrupted")));
var interrupted2 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_INTERRUPTED,
  [symbol]() {
    return interruptedHash;
  },
  [symbol2](that) {
    return isSTMState(that) && that._tag === OP_INTERRUPTED;
  }
};
var runningHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RUNNING2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("running")));
var running3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_RUNNING2,
  [symbol]() {
    return runningHash;
  },
  [symbol2](that) {
    return isSTMState(that) && that._tag === OP_RUNNING2;
  }
};
var fromTExit = (tExit) => {
  switch (tExit._tag) {
    case OP_FAIL5: {
      return done8(fail4(tExit.error));
    }
    case OP_DIE3: {
      return done8(die3(tExit.defect));
    }
    case OP_INTERRUPT3: {
      return done8(interrupt4(tExit.fiberId));
    }
    case OP_SUCCEED3: {
      return done8(succeed3(tExit.value));
    }
    case OP_RETRY2: {
      throw new Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
  }
};

// node_modules/effect/dist/esm/internal/stm/tExit.js
var TExitSymbolKey = "effect/TExit";
var TExitTypeId = /* @__PURE__ */ Symbol.for(TExitSymbolKey);
var variance6 = {
  _A: (_) => _,
  _E: (_) => _
};
var isExit2 = (u) => hasProperty(u, TExitTypeId);
var isSuccess4 = (self2) => {
  return self2._tag === OP_SUCCEED3;
};
var isRetry = (self2) => {
  return self2._tag === OP_RETRY2;
};
var fail13 = (error) => ({
  [TExitTypeId]: variance6,
  _tag: OP_FAIL5,
  error,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_FAIL5)), combine(hash(error)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_FAIL5 && equals(error, that.error);
  }
});
var die8 = (defect) => ({
  [TExitTypeId]: variance6,
  _tag: OP_DIE3,
  defect,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_DIE3)), combine(hash(defect)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_DIE3 && equals(defect, that.defect);
  }
});
var interrupt8 = (fiberId3) => ({
  [TExitTypeId]: variance6,
  _tag: OP_INTERRUPT3,
  fiberId: fiberId3,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_INTERRUPT3)), combine(hash(fiberId3)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_INTERRUPT3 && equals(fiberId3, that.fiberId);
  }
});
var succeed12 = (value) => ({
  [TExitTypeId]: variance6,
  _tag: OP_SUCCEED3,
  value,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_SUCCEED3)), combine(hash(value)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_SUCCEED3 && equals(value, that.value);
  }
});
var retryHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(TExitSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RETRY2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("retry")));
var retry4 = {
  [TExitTypeId]: variance6,
  _tag: OP_RETRY2,
  [symbol]() {
    return retryHash;
  },
  [symbol2](that) {
    return isExit2(that) && isRetry(that);
  }
};

// node_modules/effect/dist/esm/internal/stm/tryCommit.js
var done9 = (exit3) => {
  return {
    _tag: OP_DONE5,
    exit: exit3
  };
};
var suspend7 = (journal) => {
  return {
    _tag: OP_SUSPEND3,
    journal
  };
};

// node_modules/effect/dist/esm/internal/stm/txnId.js
var txnCounter = {
  ref: 0
};
var make46 = () => {
  const newId = txnCounter.ref + 1;
  txnCounter.ref = newId;
  return newId;
};

// node_modules/effect/dist/esm/internal/stm/core.js
var STMSymbolKey2 = "effect/STM";
var STMTypeId2 = /* @__PURE__ */ Symbol.for(STMSymbolKey2);
var stmVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _A: (_) => _
};

class STMPrimitive {
  effect_instruction_i0;
  _op = OP_COMMIT;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  [EffectTypeId3];
  [StreamTypeId];
  [SinkTypeId2];
  [ChannelTypeId2];
  get [STMTypeId2]() {
    return stmVariance;
  }
  constructor(effect_instruction_i0) {
    this.effect_instruction_i0 = effect_instruction_i0;
    this[EffectTypeId3] = effectVariance;
    this[StreamTypeId] = stmVariance;
    this[SinkTypeId2] = stmVariance;
    this[ChannelTypeId2] = stmVariance;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
  commit() {
    return unsafeAtomically(this, constVoid, constVoid);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var unsafeAtomically = (self2, onDone, onInterrupt3) => withFiberRuntime((state) => {
  const fiberId3 = state.id();
  const env = state.getFiberRef(currentContext2);
  const scheduler = state.getFiberRef(currentScheduler2);
  const priority = state.getFiberRef(currentSchedulingPriority2);
  const commitResult = tryCommitSync(fiberId3, self2, env, scheduler, priority);
  switch (commitResult._tag) {
    case OP_DONE5: {
      onDone(commitResult.exit);
      return commitResult.exit;
    }
    case OP_SUSPEND3: {
      const txnId = make46();
      const state2 = {
        value: running3
      };
      const effect3 = async((k) => tryCommitAsync(fiberId3, self2, txnId, state2, env, scheduler, priority, k));
      return uninterruptibleMask3((restore) => pipe(restore(effect3), catchAllCause3((cause3) => {
        let currentState = state2.value;
        if (isRunning2(currentState)) {
          state2.value = interrupted2;
        }
        currentState = state2.value;
        if (isDone6(currentState)) {
          onDone(currentState.exit);
          return currentState.exit;
        }
        onInterrupt3();
        return failCause8(cause3);
      })));
    }
  }
});
var tryCommit = (fiberId3, stm, state, env, scheduler, priority) => {
  const journal = new Map;
  const tExit = new STMDriver(stm, journal, fiberId3, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      state.value = fromTExit(tExit);
      return completeTodos(succeed3(tExit.value), journal, scheduler, priority);
    }
    case OP_FAIL5: {
      state.value = fromTExit(tExit);
      const cause3 = fail5(tExit.error);
      return completeTodos(failCause3(cause3), journal, scheduler, priority);
    }
    case OP_DIE3: {
      state.value = fromTExit(tExit);
      const cause3 = die4(tExit.defect);
      return completeTodos(failCause3(cause3), journal, scheduler, priority);
    }
    case OP_INTERRUPT3: {
      state.value = fromTExit(tExit);
      const cause3 = interrupt5(fiberId3);
      return completeTodos(failCause3(cause3), journal, scheduler, priority);
    }
    case OP_RETRY2: {
      return suspend7(journal);
    }
  }
};
var tryCommitSync = (fiberId3, stm, env, scheduler, priority) => {
  const journal = new Map;
  const tExit = new STMDriver(stm, journal, fiberId3, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite && isSuccess4(tExit)) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      return completeTodos(succeed3(tExit.value), journal, scheduler, priority);
    }
    case OP_FAIL5: {
      const cause3 = fail5(tExit.error);
      return completeTodos(failCause3(cause3), journal, scheduler, priority);
    }
    case OP_DIE3: {
      const cause3 = die4(tExit.defect);
      return completeTodos(failCause3(cause3), journal, scheduler, priority);
    }
    case OP_INTERRUPT3: {
      const cause3 = interrupt5(fiberId3);
      return completeTodos(failCause3(cause3), journal, scheduler, priority);
    }
    case OP_RETRY2: {
      return suspend7(journal);
    }
  }
};
var tryCommitAsync = (fiberId3, self2, txnId, state, context5, scheduler, priority, k) => {
  if (isRunning2(state.value)) {
    const result = tryCommit(fiberId3, self2, state, context5, scheduler, priority);
    switch (result._tag) {
      case OP_DONE5: {
        completeTryCommit(result.exit, k);
        break;
      }
      case OP_SUSPEND3: {
        addTodo(txnId, result.journal, () => tryCommitAsync(fiberId3, self2, txnId, state, context5, scheduler, priority, k));
        break;
      }
    }
  }
};
var completeTodos = (exit3, journal, scheduler, priority) => {
  const todos = collectTodos(journal);
  if (todos.size > 0) {
    scheduler.scheduleTask(() => execTodos(todos), priority);
  }
  return done9(exit3);
};
var completeTryCommit = (exit3, k) => {
  k(exit3);
};
class STMDriver {
  self;
  journal;
  fiberId;
  contStack = [];
  env;
  constructor(self2, journal, fiberId3, r0) {
    this.self = self2;
    this.journal = journal;
    this.fiberId = fiberId3;
    this.env = r0;
  }
  getEnv() {
    return this.env;
  }
  pushStack(cont) {
    this.contStack.push(cont);
  }
  popStack() {
    return this.contStack.pop();
  }
  nextSuccess() {
    let current = this.popStack();
    while (current !== undefined && current.effect_instruction_i0 !== OP_ON_SUCCESS2) {
      current = this.popStack();
    }
    return current;
  }
  nextFailure() {
    let current = this.popStack();
    while (current !== undefined && current.effect_instruction_i0 !== OP_ON_FAILURE2) {
      current = this.popStack();
    }
    return current;
  }
  nextRetry() {
    let current = this.popStack();
    while (current !== undefined && current.effect_instruction_i0 !== OP_ON_RETRY) {
      current = this.popStack();
    }
    return current;
  }
  run() {
    let curr = this.self;
    let exit3 = undefined;
    while (exit3 === undefined && curr !== undefined) {
      try {
        const current = curr;
        if (current) {
          switch (current._op) {
            case "Tag": {
              curr = effect3((_, __, env) => unsafeGet3(env, current));
              break;
            }
            case "Left": {
              curr = fail14(current.left);
              break;
            }
            case "None": {
              curr = fail14(new NoSuchElementException2);
              break;
            }
            case "Right": {
              curr = succeed13(current.right);
              break;
            }
            case "Some": {
              curr = succeed13(current.value);
              break;
            }
            case "Commit": {
              switch (current.effect_instruction_i0) {
                case OP_DIE2: {
                  exit3 = die8(internalCall(() => current.effect_instruction_i1()));
                  break;
                }
                case OP_FAIL4: {
                  const cont = this.nextFailure();
                  if (cont === undefined) {
                    exit3 = fail13(internalCall(() => current.effect_instruction_i1()));
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(internalCall(() => current.effect_instruction_i1())));
                  }
                  break;
                }
                case OP_RETRY: {
                  const cont = this.nextRetry();
                  if (cont === undefined) {
                    exit3 = retry4;
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2());
                  }
                  break;
                }
                case OP_INTERRUPT2: {
                  exit3 = interrupt8(this.fiberId);
                  break;
                }
                case OP_WITH_STM_RUNTIME: {
                  curr = internalCall(() => current.effect_instruction_i1(this));
                  break;
                }
                case OP_ON_SUCCESS2:
                case OP_ON_FAILURE2:
                case OP_ON_RETRY: {
                  this.pushStack(current);
                  curr = current.effect_instruction_i1;
                  break;
                }
                case OP_PROVIDE3: {
                  const env = this.env;
                  this.env = internalCall(() => current.effect_instruction_i2(env));
                  curr = pipe(current.effect_instruction_i1, ensuring5(sync7(() => this.env = env)));
                  break;
                }
                case OP_SUCCEED2: {
                  const value = current.effect_instruction_i1;
                  const cont = this.nextSuccess();
                  if (cont === undefined) {
                    exit3 = succeed12(value);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value));
                  }
                  break;
                }
                case OP_SYNC2: {
                  const value = internalCall(() => current.effect_instruction_i1());
                  const cont = this.nextSuccess();
                  if (cont === undefined) {
                    exit3 = succeed12(value);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value));
                  }
                  break;
                }
              }
              break;
            }
          }
        }
      } catch (e) {
        curr = die9(e);
      }
    }
    return exit3;
  }
}
var catchAll6 = /* @__PURE__ */ dual(2, (self2, f) => {
  const stm = new STMPrimitive(OP_ON_FAILURE2);
  stm.effect_instruction_i1 = self2;
  stm.effect_instruction_i2 = f;
  return stm;
});
var die9 = (defect) => dieSync5(() => defect);
var dieSync5 = (evaluate2) => {
  const stm = new STMPrimitive(OP_DIE2);
  stm.effect_instruction_i1 = evaluate2;
  return stm;
};
var effect3 = (f) => withSTMRuntime((_) => succeed13(f(_.journal, _.fiberId, _.getEnv())));
var ensuring5 = /* @__PURE__ */ dual(2, (self2, finalizer) => matchSTM(self2, {
  onFailure: (e) => zipRight7(finalizer, fail14(e)),
  onSuccess: (a) => zipRight7(finalizer, succeed13(a))
}));
var fail14 = (error) => failSync6(() => error);
var failSync6 = (evaluate2) => {
  const stm = new STMPrimitive(OP_FAIL4);
  stm.effect_instruction_i1 = evaluate2;
  return stm;
};
var flatMap15 = /* @__PURE__ */ dual(2, (self2, f) => {
  const stm = new STMPrimitive(OP_ON_SUCCESS2);
  stm.effect_instruction_i1 = self2;
  stm.effect_instruction_i2 = f;
  return stm;
});
var matchSTM = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => pipe(self2, map20(right2), catchAll6((e) => pipe(onFailure(e), map20(left2))), flatMap15((either5) => {
  switch (either5._tag) {
    case "Left": {
      return succeed13(either5.left);
    }
    case "Right": {
      return onSuccess(either5.right);
    }
  }
})));
var withSTMRuntime = (f) => {
  const stm = new STMPrimitive(OP_WITH_STM_RUNTIME);
  stm.effect_instruction_i1 = f;
  return stm;
};
var interruptAs2 = (fiberId3) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = fiberId3;
  return stm;
};
var map20 = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, flatMap15((a) => sync7(() => f(a)))));
var retry5 = /* @__PURE__ */ new STMPrimitive(OP_RETRY);
var succeed13 = (value) => {
  const stm = new STMPrimitive(OP_SUCCEED2);
  stm.effect_instruction_i1 = value;
  return stm;
};
var sync7 = (evaluate2) => {
  const stm = new STMPrimitive(OP_SYNC2);
  stm.effect_instruction_i1 = evaluate2;
  return stm;
};
var zipRight7 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, flatMap15(() => that)));
var zipWith9 = /* @__PURE__ */ dual(3, (self2, that, f) => pipe(self2, flatMap15((a) => pipe(that, map20((b) => f(a, b))))));

// node_modules/effect/dist/esm/internal/stm/opCodes/strategy.js
var OP_BACKPRESSURE_STRATEGY = "BackPressure";
var OP_DROPPING_STRATEGY = "Dropping";
var OP_SLIDING_STRATEGY = "Sliding";

// node_modules/effect/dist/esm/internal/stm/stm.js
var as6 = /* @__PURE__ */ dual(2, (self2, value) => pipe(self2, map20(() => value)));
var flatten12 = (self2) => flatMap15(self2, identity);
var forEach8 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (iterable, f, options) => {
  if (options?.discard) {
    return pipe(sync7(() => iterable[Symbol.iterator]()), flatMap15((iterator) => {
      const loop3 = suspend8(() => {
        const next = iterator.next();
        if (next.done) {
          return void_6;
        }
        return pipe(f(next.value), flatMap15(() => loop3));
      });
      return loop3;
    }));
  }
  return suspend8(() => fromIterable(iterable).reduce((acc, curr) => zipWith9(acc, f(curr), (array3, elem) => {
    array3.push(elem);
    return array3;
  }), succeed13([])));
});
var all5 = (input, options) => {
  if (Symbol.iterator in input) {
    return forEach8(input, identity, options);
  } else if (options?.discard) {
    return forEach8(Object.values(input), identity, options);
  }
  return map20(forEach8(Object.entries(input), ([_, e]) => map20(e, (a) => [_, a])), (values3) => {
    const res = {};
    for (const [k, v] of values3) {
      res[k] = v;
    }
    return res;
  });
};
var suspend8 = (evaluate2) => flatten12(sync7(evaluate2));
var tap5 = /* @__PURE__ */ dual(2, (self2, f) => flatMap15(self2, (a) => as6(f(a), a)));
var void_6 = /* @__PURE__ */ succeed13(undefined);

// node_modules/effect/dist/esm/internal/stm/tRef.js
var TRefSymbolKey = "effect/TRef";
var TRefTypeId = /* @__PURE__ */ Symbol.for(TRefSymbolKey);
var tRefVariance = {
  _A: (_) => _
};

class TRefImpl {
  [TRefTypeId] = tRefVariance;
  todos;
  versioned;
  constructor(value) {
    this.versioned = new Versioned(value);
    this.todos = new Map;
  }
  modify(f) {
    return effect3((journal) => {
      const entry = getOrMakeEntry(this, journal);
      const [retValue, newValue] = f(unsafeGet6(entry));
      unsafeSet(entry, newValue);
      return retValue;
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var make47 = (value) => effect3((journal) => {
  const ref = new TRefImpl(value);
  journal.set(ref, make45(ref, true));
  return ref;
});
var get16 = (self2) => self2.modify((a) => [a, a]);
var set7 = /* @__PURE__ */ dual(2, (self2, value) => self2.modify(() => [undefined, value]));
var getOrMakeEntry = (self2, journal) => {
  if (journal.has(self2)) {
    return journal.get(self2);
  }
  const entry = make45(self2, false);
  journal.set(self2, entry);
  return entry;
};
var unsafeGet7 = /* @__PURE__ */ dual(2, (self2, journal) => unsafeGet6(getOrMakeEntry(self2, journal)));
var unsafeSet2 = /* @__PURE__ */ dual(3, (self2, value, journal) => {
  const entry = getOrMakeEntry(self2, journal);
  unsafeSet(entry, value);
  return;
});

// node_modules/effect/dist/esm/internal/stm/tQueue.js
var TEnqueueSymbolKey = "effect/TQueue/TEnqueue";
var TEnqueueTypeId = /* @__PURE__ */ Symbol.for(TEnqueueSymbolKey);
var TDequeueSymbolKey = "effect/TQueue/TDequeue";
var TDequeueTypeId = /* @__PURE__ */ Symbol.for(TDequeueSymbolKey);
var tDequeueVariance = {
  _Out: (_) => _
};
var tEnqueueVariance = {
  _In: (_) => _
};

class TQueueImpl {
  ref;
  requestedCapacity;
  strategy;
  [TDequeueTypeId] = tDequeueVariance;
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(ref, requestedCapacity, strategy) {
    this.ref = ref;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
  }
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime4) => {
    const queue = unsafeGet7(this.ref, runtime4.journal);
    if (queue === undefined) {
      return interruptAs2(runtime4.fiberId);
    }
    return succeed13(queue.length);
  });
  isFull = /* @__PURE__ */ map20(this.size, (size11) => size11 === this.requestedCapacity);
  isEmpty = /* @__PURE__ */ map20(this.size, (size11) => size11 === 0);
  shutdown = /* @__PURE__ */ withSTMRuntime((runtime4) => {
    unsafeSet2(this.ref, undefined, runtime4.journal);
    return void_6;
  });
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const queue = unsafeGet7(this.ref, journal);
    return queue === undefined;
  });
  awaitShutdown = /* @__PURE__ */ flatMap15(this.isShutdown, (isShutdown4) => isShutdown4 ? void_6 : retry5);
  offer(value) {
    return withSTMRuntime((runtime4) => {
      const queue = pipe(this.ref, unsafeGet7(runtime4.journal));
      if (queue === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      if (queue.length < this.requestedCapacity) {
        queue.push(value);
        unsafeSet2(this.ref, queue, runtime4.journal);
        return succeed13(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry5;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed13(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (queue.length === 0) {
            return succeed13(true);
          }
          queue.shift();
          queue.push(value);
          unsafeSet2(this.ref, queue, runtime4.journal);
          return succeed13(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return withSTMRuntime((runtime4) => {
      const as7 = Array.from(iterable);
      const queue = unsafeGet7(this.ref, runtime4.journal);
      if (queue === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      if (queue.length + as7.length <= this.requestedCapacity) {
        unsafeSet2(this.ref, [...queue, ...as7], runtime4.journal);
        return succeed13(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry5;
        }
        case OP_DROPPING_STRATEGY: {
          const forQueue = as7.slice(0, this.requestedCapacity - queue.length);
          unsafeSet2(this.ref, [...queue, ...forQueue], runtime4.journal);
          return succeed13(false);
        }
        case OP_SLIDING_STRATEGY: {
          const forQueue = as7.slice(0, this.requestedCapacity - queue.length);
          const toDrop = queue.length + forQueue.length - this.requestedCapacity;
          const newQueue = queue.slice(toDrop);
          unsafeSet2(this.ref, [...newQueue, ...forQueue], runtime4.journal);
          return succeed13(true);
        }
      }
    });
  }
  peek = /* @__PURE__ */ withSTMRuntime((runtime4) => {
    const queue = unsafeGet7(this.ref, runtime4.journal);
    if (queue === undefined) {
      return interruptAs2(runtime4.fiberId);
    }
    if (queue.length === 0) {
      return retry5;
    }
    return succeed13(queue[0]);
  });
  peekOption = /* @__PURE__ */ withSTMRuntime((runtime4) => {
    const queue = unsafeGet7(this.ref, runtime4.journal);
    if (queue === undefined) {
      return interruptAs2(runtime4.fiberId);
    }
    return succeed13(fromNullable(queue[0]));
  });
  take = /* @__PURE__ */ withSTMRuntime((runtime4) => {
    const queue = unsafeGet7(this.ref, runtime4.journal);
    if (queue === undefined) {
      return interruptAs2(runtime4.fiberId);
    }
    if (queue.length === 0) {
      return retry5;
    }
    const dequeued = queue.shift();
    unsafeSet2(this.ref, queue, runtime4.journal);
    return succeed13(dequeued);
  });
  takeAll = /* @__PURE__ */ withSTMRuntime((runtime4) => {
    const queue = unsafeGet7(this.ref, runtime4.journal);
    if (queue === undefined) {
      return interruptAs2(runtime4.fiberId);
    }
    unsafeSet2(this.ref, [], runtime4.journal);
    return succeed13(queue);
  });
  takeUpTo(max5) {
    return withSTMRuntime((runtime4) => {
      const queue = unsafeGet7(this.ref, runtime4.journal);
      if (queue === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      const [toTake, remaining] = splitAt2(unsafeFromArray(queue), max5);
      unsafeSet2(this.ref, Array.from(remaining), runtime4.journal);
      return succeed13(Array.from(toTake));
    });
  }
}
var isShutdown4 = (self2) => self2.isShutdown;
var shutdown5 = (self2) => self2.shutdown;
var take4 = (self2) => self2.take;

// node_modules/effect/dist/esm/internal/stm/tPubSub.js
var TPubSubSymbolKey = "effect/TPubSub";
var TPubSubTypeId = /* @__PURE__ */ Symbol.for(TPubSubSymbolKey);
var AbsentValue2 = /* @__PURE__ */ Symbol.for("effect/TPubSub/AbsentValue");
var makeNode2 = (head6, subscribers, tail) => ({
  head: head6,
  subscribers,
  tail
});

class TPubSubImpl {
  pubsubSize;
  publisherHead;
  publisherTail;
  requestedCapacity;
  strategy;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = {
    _A: (_) => _
  };
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.publisherTail = publisherTail;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const currentPublisherTail = unsafeGet7(this.publisherTail, journal);
    return currentPublisherTail === undefined;
  });
  awaitShutdown = /* @__PURE__ */ flatMap15(this.isShutdown, (isShutdown5) => isShutdown5 ? void_6 : retry5);
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime4) => {
    const currentPublisherTail = unsafeGet7(this.publisherTail, runtime4.journal);
    if (currentPublisherTail === undefined) {
      return interruptAs2(runtime4.fiberId);
    }
    return succeed13(unsafeGet7(this.pubsubSize, runtime4.journal));
  });
  isEmpty = /* @__PURE__ */ map20(this.size, (size11) => size11 === 0);
  isFull = /* @__PURE__ */ map20(this.size, (size11) => size11 === this.capacity());
  offer(value) {
    return withSTMRuntime((runtime4) => {
      const currentPublisherTail = unsafeGet7(this.publisherTail, runtime4.journal);
      if (currentPublisherTail === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      const currentSubscriberCount = unsafeGet7(this.subscriberCount, runtime4.journal);
      if (currentSubscriberCount === 0) {
        return succeed13(true);
      }
      const currentPubSubSize = unsafeGet7(this.pubsubSize, runtime4.journal);
      if (currentPubSubSize < this.requestedCapacity) {
        const updatedPublisherTail = new TRefImpl(undefined);
        const updatedNode = makeNode2(value, currentSubscriberCount, updatedPublisherTail);
        unsafeSet2(currentPublisherTail, updatedNode, runtime4.journal);
        unsafeSet2(this.publisherTail, updatedPublisherTail, runtime4.journal);
        unsafeSet2(this.pubsubSize, currentPubSubSize + 1, runtime4.journal);
        return succeed13(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry5;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed13(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (this.requestedCapacity > 0) {
            let currentPublisherHead = unsafeGet7(this.publisherHead, runtime4.journal);
            let loop3 = true;
            while (loop3) {
              const node = unsafeGet7(currentPublisherHead, runtime4.journal);
              if (node === undefined) {
                return retry5;
              }
              const head6 = node.head;
              const tail = node.tail;
              if (head6 !== AbsentValue2) {
                const updatedNode2 = makeNode2(AbsentValue2, node.subscribers, node.tail);
                unsafeSet2(currentPublisherHead, updatedNode2, runtime4.journal);
                unsafeSet2(this.publisherHead, tail, runtime4.journal);
                loop3 = false;
              } else {
                currentPublisherHead = tail;
              }
            }
          }
          const updatedPublisherTail = new TRefImpl(undefined);
          const updatedNode = makeNode2(value, currentSubscriberCount, updatedPublisherTail);
          unsafeSet2(currentPublisherTail, updatedNode, runtime4.journal);
          unsafeSet2(this.publisherTail, updatedPublisherTail, runtime4.journal);
          return succeed13(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return map20(forEach8(iterable, (a) => this.offer(a)), every(identity));
  }
  shutdown = /* @__PURE__ */ effect3((journal) => {
    const currentPublisherTail = unsafeGet7(this.publisherTail, journal);
    if (currentPublisherTail !== undefined) {
      unsafeSet2(this.publisherTail, undefined, journal);
      const currentSubscribers = unsafeGet7(this.subscribers, journal);
      forEach3(currentSubscribers, (subscriber) => {
        unsafeSet2(subscriber, undefined, journal);
      });
      unsafeSet2(this.subscribers, empty7(), journal);
    }
  });
}

class TPubSubSubscriptionImpl {
  pubsubSize;
  publisherHead;
  requestedCapacity;
  subscriberHead;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = TPubSubTypeId;
  [TDequeueTypeId] = tDequeueVariance;
  constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.requestedCapacity = requestedCapacity;
    this.subscriberHead = subscriberHead;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const currentSubscriberHead = unsafeGet7(this.subscriberHead, journal);
    return currentSubscriberHead === undefined;
  });
  awaitShutdown = /* @__PURE__ */ flatMap15(this.isShutdown, (isShutdown5) => isShutdown5 ? void_6 : retry5);
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime4) => {
    let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime4.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime4.fiberId);
    }
    let loop3 = true;
    let size11 = 0;
    while (loop3) {
      const node = unsafeGet7(currentSubscriberHead, runtime4.journal);
      if (node === undefined) {
        loop3 = false;
      } else {
        const head6 = node.head;
        const tail = node.tail;
        if (head6 !== AbsentValue2) {
          size11 = size11 + 1;
          if (size11 >= Number.MAX_SAFE_INTEGER) {
            loop3 = false;
          }
        }
        currentSubscriberHead = tail;
      }
    }
    return succeed13(size11);
  });
  isEmpty = /* @__PURE__ */ map20(this.size, (size11) => size11 === 0);
  isFull = /* @__PURE__ */ map20(this.size, (size11) => size11 === this.capacity());
  peek = /* @__PURE__ */ withSTMRuntime((runtime4) => {
    let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime4.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime4.fiberId);
    }
    let value = AbsentValue2;
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet7(currentSubscriberHead, runtime4.journal);
      if (node === undefined) {
        return retry5;
      }
      const head6 = node.head;
      const tail = node.tail;
      if (head6 !== AbsentValue2) {
        value = head6;
        loop3 = false;
      } else {
        currentSubscriberHead = tail;
      }
    }
    return succeed13(value);
  });
  peekOption = /* @__PURE__ */ withSTMRuntime((runtime4) => {
    let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime4.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime4.fiberId);
    }
    let value = none2();
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet7(currentSubscriberHead, runtime4.journal);
      if (node === undefined) {
        value = none2();
        loop3 = false;
      } else {
        const head6 = node.head;
        const tail = node.tail;
        if (head6 !== AbsentValue2) {
          value = some2(head6);
          loop3 = false;
        } else {
          currentSubscriberHead = tail;
        }
      }
    }
    return succeed13(value);
  });
  shutdown = /* @__PURE__ */ effect3((journal) => {
    let currentSubscriberHead = unsafeGet7(this.subscriberHead, journal);
    if (currentSubscriberHead !== undefined) {
      unsafeSet2(this.subscriberHead, undefined, journal);
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet7(currentSubscriberHead, journal);
        if (node === undefined) {
          loop3 = false;
        } else {
          const head6 = node.head;
          const tail = node.tail;
          if (head6 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size11 = unsafeGet7(this.pubsubSize, journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
              unsafeSet2(this.publisherHead, tail, journal);
              unsafeSet2(this.pubsubSize, size11 - 1, journal);
            } else {
              const updatedNode = makeNode2(head6, subscribers - 1, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
            }
          }
          currentSubscriberHead = tail;
        }
      }
      const currentSubscriberCount = unsafeGet7(this.subscriberCount, journal);
      unsafeSet2(this.subscriberCount, currentSubscriberCount - 1, journal);
      unsafeSet2(this.subscribers, remove4(unsafeGet7(this.subscribers, journal), this.subscriberHead), journal);
    }
  });
  take = /* @__PURE__ */ withSTMRuntime((runtime4) => {
    let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime4.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime4.fiberId);
    }
    let value = AbsentValue2;
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet7(currentSubscriberHead, runtime4.journal);
      if (node === undefined) {
        return retry5;
      }
      const head6 = node.head;
      const tail = node.tail;
      if (head6 !== AbsentValue2) {
        const subscribers = node.subscribers;
        if (subscribers === 1) {
          const size11 = unsafeGet7(this.pubsubSize, runtime4.journal);
          const updatedNode = makeNode2(AbsentValue2, 0, tail);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime4.journal);
          unsafeSet2(this.publisherHead, tail, runtime4.journal);
          unsafeSet2(this.pubsubSize, size11 - 1, runtime4.journal);
        } else {
          const updatedNode = makeNode2(head6, subscribers - 1, tail);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime4.journal);
        }
        unsafeSet2(this.subscriberHead, tail, runtime4.journal);
        value = head6;
        loop3 = false;
      } else {
        currentSubscriberHead = tail;
      }
    }
    return succeed13(value);
  });
  takeAll = /* @__PURE__ */ this.takeUpTo(Number.POSITIVE_INFINITY);
  takeUpTo(max5) {
    return withSTMRuntime((runtime4) => {
      let currentSubscriberHead = unsafeGet7(this.subscriberHead, runtime4.journal);
      if (currentSubscriberHead === undefined) {
        return interruptAs2(runtime4.fiberId);
      }
      const builder = [];
      let n = 0;
      while (n !== max5) {
        const node = unsafeGet7(currentSubscriberHead, runtime4.journal);
        if (node === undefined) {
          n = max5;
        } else {
          const head6 = node.head;
          const tail = node.tail;
          if (head6 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size11 = unsafeGet7(this.pubsubSize, runtime4.journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime4.journal);
              unsafeSet2(this.publisherHead, tail, runtime4.journal);
              unsafeSet2(this.pubsubSize, size11 - 1, runtime4.journal);
            } else {
              const updatedNode = makeNode2(head6, subscribers - 1, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime4.journal);
            }
            builder.push(head6);
            n = n + 1;
          }
          currentSubscriberHead = tail;
        }
      }
      unsafeSet2(this.subscriberHead, currentSubscriberHead, runtime4.journal);
      return succeed13(builder);
    });
  }
}
var makeSubscription2 = (pubsubSize, publisherHead, publisherTail, requestedCapacity, subscriberCount, subscribers) => pipe(get16(publisherTail), flatMap15((currentPublisherTail) => pipe(all5([make47(currentPublisherTail), get16(subscriberCount), get16(subscribers)]), tap5(([_, currentSubscriberCount]) => pipe(subscriberCount, set7(currentSubscriberCount + 1))), tap5(([subscriberHead, _, currentSubscribers]) => pipe(subscribers, set7(pipe(currentSubscribers, add4(subscriberHead))))), map20(([subscriberHead]) => new TPubSubSubscriptionImpl(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers)))));
var subscribe3 = (self2) => makeSubscription2(self2.pubsubSize, self2.publisherHead, self2.publisherTail, self2.requestedCapacity, self2.subscriberCount, self2.subscribers);
var subscribeScoped = (self2) => acquireRelease2(subscribe3(self2), (dequeue) => shutdown5(dequeue));

// node_modules/effect/dist/esm/TPubSub.js
var subscribeScoped2 = subscribeScoped;

// node_modules/effect/dist/esm/TQueue.js
var isShutdown6 = isShutdown4;
var take5 = take4;

// node_modules/effect/dist/esm/internal/ringBuffer.js
class RingBuffer {
  capacity;
  array;
  size = 0;
  current = 0;
  constructor(capacity7) {
    this.capacity = capacity7;
    this.array = Array.from({
      length: capacity7
    }, constUndefined);
  }
  head() {
    return fromNullable(this.array[this.current]);
  }
  lastOrNull() {
    if (this.size === 0) {
      return;
    }
    const index = this.current === 0 ? this.array.length - 1 : this.current - 1;
    return this.array[index] ?? undefined;
  }
  put(value) {
    this.array[this.current] = value;
    this.increment();
  }
  dropLast() {
    if (this.size > 0) {
      this.decrement();
      this.array[this.current] = undefined;
    }
  }
  toChunk() {
    const begin = this.current - this.size;
    const newArray = begin < 0 ? [...this.array.slice(this.capacity + begin, this.capacity), ...this.array.slice(0, this.current)] : this.array.slice(begin, this.current);
    return fromIterable2(newArray);
  }
  increment() {
    if (this.size < this.capacity) {
      this.size += 1;
    }
    this.current = (this.current + 1) % this.capacity;
  }
  decrement() {
    this.size -= 1;
    if (this.current > 0) {
      this.current -= 1;
    } else {
      this.current = this.capacity - 1;
    }
  }
}

// node_modules/effect/dist/esm/internal/stream/debounceState.js
var OP_NOT_STARTED = "NotStarted";
var OP_PREVIOUS = "Previous";
var OP_CURRENT = "Current";
var notStarted = {
  _tag: OP_NOT_STARTED
};
var previous = (fiber) => ({
  _tag: OP_PREVIOUS,
  fiber
});
var current = (fiber) => ({
  _tag: OP_CURRENT,
  fiber
});

// node_modules/effect/dist/esm/internal/stream/emit.js
var make48 = (emit) => {
  const ops = {
    chunk(as7) {
      return this(succeed8(as7));
    },
    die(defect) {
      return this(die6(defect));
    },
    dieMessage(message) {
      return this(dieMessage2(message));
    },
    done(exit3) {
      return this(suspend3(() => mapBoth2(exit3, {
        onFailure: some2,
        onSuccess: of2
      })));
    },
    end() {
      return this(fail9(none2()));
    },
    fail(e) {
      return this(fail9(some2(e)));
    },
    fromEffect(effect4) {
      return this(mapBoth3(effect4, {
        onFailure: some2,
        onSuccess: of2
      }));
    },
    fromEffectChunk(effect4) {
      return this(pipe(effect4, mapError3(some2)));
    },
    halt(cause3) {
      return this(failCause8(pipe(cause3, map12(some2))));
    },
    single(value) {
      return this(succeed8(of2(value)));
    }
  };
  return Object.assign(emit, ops);
};
var makePush = (queue, scheduler) => {
  let finished = false;
  let buffer = [];
  let running4 = false;
  function array3(items) {
    if (finished)
      return false;
    if (items.length <= 50000) {
      buffer.push.apply(buffer, items);
    } else {
      for (let i = 0;i < items.length; i++) {
        buffer.push(items[0]);
      }
    }
    if (!running4) {
      running4 = true;
      scheduler.scheduleTask(flush, 0);
    }
    return true;
  }
  function flush() {
    running4 = false;
    if (buffer.length > 0) {
      queue.unsafeOffer(buffer);
      buffer = [];
    }
  }
  function done10(exit3) {
    if (finished)
      return;
    finished = true;
    if (exit3._tag === "Success") {
      buffer.push(exit3.value);
    }
    flush();
    queue.unsafeOffer(exit3._tag === "Success" ? void_2 : exit3);
  }
  return {
    single(value) {
      if (finished)
        return false;
      buffer.push(value);
      if (!running4) {
        running4 = true;
        scheduler.scheduleTask(flush, 0);
      }
      return true;
    },
    array: array3,
    chunk(chunk2) {
      return array3(toReadonlyArray(chunk2));
    },
    done: done10,
    end() {
      if (finished)
        return;
      finished = true;
      flush();
      queue.unsafeOffer(void_2);
    },
    halt(cause3) {
      return done10(failCause3(cause3));
    },
    fail(error) {
      return done10(fail4(error));
    },
    die(defect) {
      return done10(die3(defect));
    },
    dieMessage(message) {
      return done10(die3(new Error(message)));
    }
  };
};

// node_modules/effect/dist/esm/internal/stream/handoff.js
var HandoffTypeId = /* @__PURE__ */ Symbol.for("effect/Stream/Handoff");
var OP_HANDOFF_STATE_EMPTY = "Empty";
var OP_HANDOFF_STATE_FULL = "Full";
var handoffStateEmpty = (notifyConsumer) => ({
  _tag: OP_HANDOFF_STATE_EMPTY,
  notifyConsumer
});
var handoffStateFull = (value, notifyProducer) => ({
  _tag: OP_HANDOFF_STATE_FULL,
  value,
  notifyProducer
});
var handoffStateMatch = (onEmpty, onFull) => {
  return (self2) => {
    switch (self2._tag) {
      case OP_HANDOFF_STATE_EMPTY: {
        return onEmpty(self2.notifyConsumer);
      }
      case OP_HANDOFF_STATE_FULL: {
        return onFull(self2.value, self2.notifyProducer);
      }
    }
  };
};
var handoffVariance = {
  _A: (_) => _
};
var make49 = () => pipe(make18(), flatMap11((deferred) => make28(handoffStateEmpty(deferred))), map16((ref) => ({
  [HandoffTypeId]: handoffVariance,
  ref
})));
var offer5 = /* @__PURE__ */ dual(2, (self2, value) => {
  return flatMap11(make18(), (deferred) => flatten9(modify4(self2.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [zipRight3(succeed2(notifyConsumer, undefined), _await(deferred)), handoffStateFull(value, deferred)], (_, notifyProducer) => [flatMap11(_await(notifyProducer), () => pipe(self2, offer5(value))), state])))));
});
var take6 = (self2) => flatMap11(make18(), (deferred) => flatten9(modify4(self2.ref, (state) => pipe(state, handoffStateMatch((notifyConsumer) => [flatMap11(_await(notifyConsumer), () => take6(self2)), state], (value, notifyProducer) => [as3(succeed2(notifyProducer, undefined), value), handoffStateEmpty(deferred)])))));

// node_modules/effect/dist/esm/internal/stream/handoffSignal.js
var OP_EMIT4 = "Emit";
var OP_HALT = "Halt";
var OP_END = "End";
var emit = (elements) => ({
  _tag: OP_EMIT4,
  elements
});
var halt = (cause3) => ({
  _tag: OP_HALT,
  cause: cause3
});
var end3 = (reason) => ({
  _tag: OP_END,
  reason
});

// node_modules/effect/dist/esm/internal/take.js
var TakeSymbolKey = "effect/Take";
var TakeTypeId = /* @__PURE__ */ Symbol.for(TakeSymbolKey);
var takeVariance = {
  _A: (_) => _,
  _E: (_) => _
};

class TakeImpl {
  exit;
  [TakeTypeId] = takeVariance;
  constructor(exit3) {
    this.exit = exit3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var chunk2 = (chunk3) => new TakeImpl(succeed3(chunk3));
var done10 = (self2) => suspend3(() => self2.exit);
var end4 = /* @__PURE__ */ new TakeImpl(/* @__PURE__ */ fail4(/* @__PURE__ */ none2()));
var failCause11 = (cause3) => new TakeImpl(failCause3(pipe(cause3, map12(some2))));
var fromPull = (pull) => matchCause3(pull, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: () => end4,
    onSome: failCause11
  }),
  onSuccess: chunk2
});
var match17 = /* @__PURE__ */ dual(2, (self2, {
  onEnd,
  onFailure,
  onSuccess
}) => match6(self2.exit, {
  onFailure: (cause3) => match2(flipCauseOption2(cause3), {
    onNone: onEnd,
    onSome: onFailure
  }),
  onSuccess
}));
var of5 = (value) => new TakeImpl(succeed3(of2(value)));

// node_modules/effect/dist/esm/internal/stream/pull.js
var end5 = () => fail9(none2());
var failCause12 = (cause3) => mapError3(failCause8(cause3), some2);

// node_modules/effect/dist/esm/internal/stream/sinkEndReason.js
var OP_SCHEDULE_END = "ScheduleEnd";
var OP_UPSTREAM_END = "UpstreamEnd";
var ScheduleEnd = {
  _tag: OP_SCHEDULE_END
};
var UpstreamEnd = {
  _tag: OP_UPSTREAM_END
};

// node_modules/effect/dist/esm/internal/stream/zipAllState.js
var OP_DRAIN_LEFT = "DrainLeft";
var OP_DRAIN_RIGHT = "DrainRight";
var OP_PULL_BOTH = "PullBoth";
var OP_PULL_LEFT = "PullLeft";
var OP_PULL_RIGHT = "PullRight";
var DrainLeft = {
  _tag: OP_DRAIN_LEFT
};
var DrainRight = {
  _tag: OP_DRAIN_RIGHT
};
var PullBoth = {
  _tag: OP_PULL_BOTH
};
var PullLeft = (rightChunk) => ({
  _tag: OP_PULL_LEFT,
  rightChunk
});
var PullRight = (leftChunk) => ({
  _tag: OP_PULL_RIGHT,
  leftChunk
});

// node_modules/effect/dist/esm/internal/stream/zipChunksState.js
var OP_PULL_BOTH2 = "PullBoth";
var OP_PULL_LEFT2 = "PullLet";
var OP_PULL_RIGHT2 = "PullRight";
var PullBoth2 = {
  _tag: OP_PULL_BOTH2
};
var PullLeft2 = (rightChunk) => ({
  _tag: OP_PULL_LEFT2,
  rightChunk
});
var PullRight2 = (leftChunk) => ({
  _tag: OP_PULL_RIGHT2,
  leftChunk
});

// node_modules/effect/dist/esm/internal/stream.js
var StreamSymbolKey = "effect/Stream";
var StreamTypeId2 = /* @__PURE__ */ Symbol.for(StreamSymbolKey);
var streamVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _A: (_) => _
};

class StreamImpl {
  channel;
  [StreamTypeId2] = streamVariance;
  constructor(channel) {
    this.channel = channel;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var isStream = (u) => hasProperty(u, StreamTypeId2) || isEffect2(u);
var DefaultChunkSize = 4096;
var accumulate = (self2) => chunks(accumulateChunks(self2));
var accumulateChunks = (self2) => {
  const accumulator = (s) => readWith({
    onInput: (input) => {
      const next = appendAll2(s, input);
      return flatMap13(write(next), () => accumulator(next));
    },
    onFailure: fail11,
    onDone: () => void_5
  });
  return new StreamImpl(pipeTo(toChannel2(self2), accumulator(empty4())));
};
var acquireRelease3 = (acquire, release) => scoped5(acquireRelease2(acquire, release));
var aggregate = /* @__PURE__ */ dual(2, (self2, sink) => aggregateWithin(self2, sink, forever4));
var aggregateWithin = /* @__PURE__ */ dual(3, (self2, sink, schedule2) => filterMap6(aggregateWithinEither(self2, sink, schedule2), (_) => match(_, {
  onLeft: none2,
  onRight: some2
})));
var aggregateWithinEither = /* @__PURE__ */ dual(3, (self2, sink, schedule2) => {
  const layer = all4([make49(), make28(ScheduleEnd), make28(empty4()), driver2(schedule2), make28(false), make28(false)]);
  return fromEffect7(layer).pipe(flatMap16(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {
    const handoffProducer = readWithCause({
      onInput: (input) => flatMap13(fromEffect4(pipe(handoff, offer5(emit(input)), when2(() => isNonEmpty2(input)))), () => handoffProducer),
      onFailure: (cause3) => fromEffect4(offer5(handoff, halt(cause3))),
      onDone: () => fromEffect4(offer5(handoff, end3(UpstreamEnd)))
    });
    const handoffConsumer = pipe(getAndSet2(sinkLeftovers, empty4()), flatMap11((leftovers) => {
      if (isNonEmpty2(leftovers)) {
        return pipe(set6(consumed, true), zipRight3(succeed8(pipe(write(leftovers), flatMap13(() => handoffConsumer)))));
      }
      return pipe(take6(handoff), map16((signal) => {
        switch (signal._tag) {
          case OP_EMIT4: {
            return pipe(fromEffect4(set6(consumed, true)), zipRight4(write(signal.elements)), zipRight4(fromEffect4(get12(endAfterEmit))), flatMap13((bool) => bool ? void_5 : handoffConsumer));
          }
          case OP_HALT: {
            return failCause10(signal.cause);
          }
          case OP_END: {
            if (signal.reason._tag === OP_SCHEDULE_END) {
              return pipe(get12(consumed), map16((bool) => bool ? fromEffect4(pipe(set6(sinkEndReason, ScheduleEnd), zipRight3(set6(endAfterEmit, true)))) : pipe(fromEffect4(pipe(set6(sinkEndReason, ScheduleEnd), zipRight3(set6(endAfterEmit, true)))), flatMap13(() => handoffConsumer))), unwrap);
            }
            return pipe(set6(sinkEndReason, signal.reason), zipRight3(set6(endAfterEmit, true)), fromEffect4);
          }
        }
      }));
    }), unwrap);
    const timeout3 = (lastB) => scheduleDriver.next(lastB);
    const scheduledAggregator = (sinkFiber, scheduleFiber, scope5) => {
      const forkSink = pipe(set6(consumed, false), zipRight3(set6(endAfterEmit, false)), zipRight3(pipe(handoffConsumer, pipeToOrFail(toChannel(sink)), collectElements, run, forkIn2(scope5))));
      const handleSide = (leftovers, b, c) => pipe(set6(sinkLeftovers, flatten3(leftovers)), zipRight3(map16(get12(sinkEndReason), (reason) => {
        switch (reason._tag) {
          case OP_SCHEDULE_END: {
            return pipe(all4([get12(consumed), forkSink, pipe(timeout3(some2(b)), forkIn2(scope5))]), map16(([wasConsumed, sinkFiber2, scheduleFiber2]) => {
              const toWrite = pipe(c, match2({
                onNone: () => of2(right2(b)),
                onSome: (c2) => make6(right2(b), left2(c2))
              }));
              if (wasConsumed) {
                return pipe(write(toWrite), flatMap13(() => scheduledAggregator(sinkFiber2, scheduleFiber2, scope5)));
              }
              return scheduledAggregator(sinkFiber2, scheduleFiber2, scope5);
            }), unwrap);
          }
          case OP_UPSTREAM_END: {
            return pipe(get12(consumed), map16((wasConsumed) => wasConsumed ? write(of2(right2(b))) : void_5), unwrap);
          }
        }
      })), unwrap);
      return unwrap(raceWith2(join3(sinkFiber), join3(scheduleFiber), {
        onSelfDone: (sinkExit, _) => pipe(interrupt6(scheduleFiber), zipRight3(pipe(suspend3(() => sinkExit), map16(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
        onOtherDone: (scheduleExit, _) => matchCauseEffect3(suspend3(() => scheduleExit), {
          onFailure: (cause3) => match(failureOrCause2(cause3), {
            onLeft: () => pipe(handoff, offer5(end3(ScheduleEnd)), forkDaemon2, zipRight3(pipe(join3(sinkFiber), map16(([leftovers, b]) => handleSide(leftovers, b, none2()))))),
            onRight: (cause4) => pipe(handoff, offer5(halt(cause4)), forkDaemon2, zipRight3(pipe(join3(sinkFiber), map16(([leftovers, b]) => handleSide(leftovers, b, none2())))))
          }),
          onSuccess: (c) => pipe(handoff, offer5(end3(ScheduleEnd)), forkDaemon2, zipRight3(pipe(join3(sinkFiber), map16(([leftovers, b]) => handleSide(leftovers, b, some2(c))))))
        })
      }));
    };
    return unwrapScopedWith3((scope5) => pipeTo(toChannel2(self2), handoffProducer).pipe(run, forkIn2(scope5), zipRight3(pipeToOrFail(handoffConsumer, toChannel(sink)).pipe(collectElements, run, forkIn2(scope5), flatMap11((sinkFiber) => timeout3(none2()).pipe(forkIn2(scope5), map16((scheduleFiber) => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope5)))))))));
  }));
});
var as7 = /* @__PURE__ */ dual(2, (self2, value) => map21(self2, () => value));
var queueFromBufferOptions = (bufferSize) => {
  if (bufferSize === "unbounded") {
    return unbounded5();
  } else if (typeof bufferSize === "number" || bufferSize === undefined) {
    return bounded5(bufferSize ?? 16);
  }
  switch (bufferSize.strategy) {
    case "dropping":
      return dropping4(bufferSize.bufferSize ?? 16);
    case "sliding":
      return sliding4(bufferSize.bufferSize ?? 16);
    default:
      return bounded5(bufferSize.bufferSize ?? 16);
  }
};
var _async = (register, bufferSize) => acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)).pipe(flatMap11((output) => runtime3().pipe(flatMap11((runtime4) => sync3(() => {
  const runPromiseExit3 = runPromiseExit2(runtime4);
  const canceler = register(make48((resume2) => fromPull(resume2).pipe(flatMap11((take7) => offer3(output, take7)), asVoid3, runPromiseExit3).then((exit3) => {
    if (isFailure(exit3)) {
      if (!isInterrupted2(exit3.cause)) {
        throw squash(exit3.cause);
      }
    }
  })));
  return canceler;
})), map16((value) => {
  const loop3 = take3(output).pipe(flatMap11((take7) => done10(take7)), match12({
    onFailure: (maybeError) => fromEffect4(shutdown4(output)).pipe(zipRight4(match2(maybeError, {
      onNone: () => void_5,
      onSome: (error) => fail11(error)
    }))),
    onSuccess: (chunk3) => write(chunk3).pipe(flatMap13(() => loop3))
  }), unwrap);
  return fromChannel2(loop3).pipe(ensuring6(value ?? _void));
}))), unwrapScoped4);
var asyncEffect3 = (register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)), flatMap11((output) => pipe(runtime3(), flatMap11((runtime4) => pipe(register(make48((k) => pipe(fromPull(k), flatMap11((take7) => offer3(output, take7)), asVoid3, runPromiseExit2(runtime4)).then((exit3) => {
  if (isFailure(exit3)) {
    if (!isInterrupted2(exit3.cause)) {
      throw squash(exit3.cause);
    }
  }
}))), map16(() => {
  const loop3 = pipe(take3(output), flatMap11(done10), match12({
    onFailure: (maybeError) => pipe(fromEffect4(shutdown4(output)), zipRight4(match2(maybeError, {
      onNone: () => void_5,
      onSome: fail11
    }))),
    onSuccess: (chunk3) => pipe(write(chunk3), flatMap13(() => loop3))
  }), unwrap);
  return loop3;
}))))), unwrapScoped3, fromChannel2);
var queueFromBufferOptionsPush = (options) => {
  if (options?.bufferSize === "unbounded" || options?.bufferSize === undefined && options?.strategy === undefined) {
    return unbounded5();
  }
  switch (options?.strategy) {
    case "sliding":
      return sliding4(options.bufferSize ?? 16);
    default:
      return dropping4(options?.bufferSize ?? 16);
  }
};
var asyncPush = (register, options) => acquireRelease2(queueFromBufferOptionsPush(options), shutdown4).pipe(tap3((queue) => getWith(currentScheduler2, (scheduler) => register(makePush(queue, scheduler)))), map16((queue) => {
  const loop3 = flatMap13(take3(queue), (item) => isExit(item) ? isSuccess(item) ? void_5 : failCause10(item.cause) : zipRight4(write(unsafeFromArray(item)), loop3));
  return loop3;
}), unwrapScoped3, fromChannel2);
var asyncScoped = (register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown4(queue)), flatMap11((output) => pipe(runtime3(), flatMap11((runtime4) => pipe(register(make48((k) => pipe(fromPull(k), flatMap11((take7) => offer3(output, take7)), asVoid3, runPromiseExit2(runtime4)).then((exit3) => {
  if (isFailure(exit3)) {
    if (!isInterrupted2(exit3.cause)) {
      throw squash(exit3.cause);
    }
  }
}))), zipRight3(make28(false)), flatMap11((ref) => pipe(get12(ref), map16((isDone7) => isDone7 ? end5() : pipe(take3(output), flatMap11(done10), onError2(() => pipe(set6(ref, true), zipRight3(shutdown4(output)))))))))))), scoped5, flatMap16(repeatEffectChunkOption));
var branchAfter = /* @__PURE__ */ dual(3, (self2, n, f) => suspend9(() => {
  const buffering = (acc) => readWith({
    onInput: (input) => {
      const nextSize = acc.length + input.length;
      if (nextSize >= n) {
        const [b1, b2] = pipe(input, splitAt2(n - acc.length));
        return running4(pipe(acc, appendAll2(b1)), b2);
      }
      return buffering(pipe(acc, appendAll2(input)));
    },
    onFailure: fail11,
    onDone: () => running4(acc, empty4())
  });
  const running4 = (prefix, leftover) => pipeTo(zipRight4(write(leftover), identityChannel()), toChannel2(f(prefix)));
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(buffering(empty4()))));
}));
var broadcast = /* @__PURE__ */ dual(3, (self2, n, maximumLag) => pipe(self2, broadcastedQueues(n, maximumLag), map16((tuple) => tuple.map((queue) => flattenTake(fromQueue2(queue, {
  shutdown: true
}))))));
var broadcastDynamic = /* @__PURE__ */ dual(2, (self2, maximumLag) => map16(toPubSub2(self2, maximumLag), (pubsub) => flattenTake(fromPubSub(pubsub))));
var share = /* @__PURE__ */ dual(2, (self2, options) => map16(make44({
  acquire: broadcastDynamic(self2, options),
  idleTimeToLive: options.idleTimeToLive
}), (rcRef) => unwrapScoped4(get15(rcRef))));
var broadcastedQueues = /* @__PURE__ */ dual(3, (self2, n, maximumLag) => flatMap11(pubsubFromOptions(maximumLag), (pubsub) => pipe(all4(Array.from({
  length: n
}, () => subscribe2(pubsub))), tap3(() => forkScoped2(runIntoPubSubScoped(self2, pubsub))))));
var broadcastedQueuesDynamic = /* @__PURE__ */ dual(2, (self2, maximumLag) => map16(toPubSub2(self2, maximumLag), subscribe2));
var buffer = /* @__PURE__ */ dual(2, (self2, options) => {
  if (options.capacity === "unbounded") {
    return bufferUnbounded(self2);
  } else if (options.strategy === "dropping") {
    return bufferDropping(self2, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferSliding(self2, options.capacity);
  }
  const queue = toQueueOfElements(self2, options);
  return new StreamImpl(unwrapScoped3(map16(queue, (queue2) => {
    const process2 = pipe(fromEffect4(take3(queue2)), flatMap13(match6({
      onFailure: (cause3) => pipe(flipCauseOption2(cause3), match2({
        onNone: () => void_5,
        onSome: failCause10
      })),
      onSuccess: (value) => flatMap13(write(of2(value)), () => process2)
    })));
    return process2;
  })));
});
var bufferChunks = /* @__PURE__ */ dual(2, (self2, options) => {
  if (options.strategy === "dropping") {
    return bufferChunksDropping(self2, options.capacity);
  } else if (options.strategy === "sliding") {
    return bufferChunksSliding(self2, options.capacity);
  }
  const queue = toQueue2(self2, options);
  return new StreamImpl(unwrapScoped3(map16(queue, (queue2) => {
    const process2 = pipe(fromEffect4(take3(queue2)), flatMap13(match17({
      onEnd: () => void_5,
      onFailure: failCause10,
      onSuccess: (value) => pipe(write(value), flatMap13(() => process2))
    })));
    return process2;
  })));
});
var bufferChunksDropping = /* @__PURE__ */ dual(2, (self2, capacity7) => {
  const queue = acquireRelease2(dropping4(capacity7), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self2)));
});
var bufferChunksSliding = /* @__PURE__ */ dual(2, (self2, capacity7) => {
  const queue = acquireRelease2(sliding4(capacity7), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self2)));
});
var bufferDropping = /* @__PURE__ */ dual(2, (self2, capacity7) => {
  const queue = acquireRelease2(dropping4(capacity7), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(rechunk(1)(self2))));
});
var bufferSliding = /* @__PURE__ */ dual(2, (self2, capacity7) => {
  const queue = acquireRelease2(sliding4(capacity7), (queue2) => shutdown4(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(pipe(self2, rechunk(1)))));
});
var bufferUnbounded = (self2) => {
  const queue = toQueue2(self2, {
    strategy: "unbounded"
  });
  return new StreamImpl(unwrapScoped3(map16(queue, (queue2) => {
    const process2 = pipe(fromEffect4(take3(queue2)), flatMap13(match17({
      onEnd: () => void_5,
      onFailure: failCause10,
      onSuccess: (value) => flatMap13(write(value), () => process2)
    })));
    return process2;
  })));
};
var bufferSignal = (scoped5, bufferChannel) => {
  const producer = (queue, ref) => {
    const terminate = (take7) => pipe(get12(ref), tap3(_await), zipRight3(make18()), flatMap11((deferred) => pipe(offer3(queue, [take7, deferred]), zipRight3(set6(ref, deferred)), zipRight3(_await(deferred)))), asVoid3, fromEffect4);
    return readWithCause({
      onInput: (input) => pipe(make18(), flatMap11((deferred) => pipe(offer3(queue, [chunk2(input), deferred]), flatMap11((added) => pipe(set6(ref, deferred), when2(() => added))))), asVoid3, fromEffect4, flatMap13(() => producer(queue, ref))),
      onFailure: (error) => terminate(failCause11(error)),
      onDone: () => terminate(end4)
    });
  };
  const consumer = (queue) => {
    const process2 = pipe(fromEffect4(take3(queue)), flatMap13(([take7, deferred]) => zipRight4(fromEffect4(succeed2(deferred, undefined)), match17(take7, {
      onEnd: () => void_5,
      onFailure: failCause10,
      onSuccess: (value) => pipe(write(value), flatMap13(() => process2))
    }))));
    return process2;
  };
  return unwrapScoped3(pipe(scoped5, flatMap11((queue) => pipe(make18(), tap3((start3) => succeed2(start3, undefined)), flatMap11((start3) => pipe(make28(start3), flatMap11((ref) => pipe(bufferChannel, pipeTo(producer(queue, ref)), runScoped, forkScoped2)), as3(consumer(queue))))))));
};
var catchAll7 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause6(self2, (cause3) => match(failureOrCause2(cause3), {
  onLeft: f,
  onRight: failCause13
})));
var catchAllCause6 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), catchAllCause5((cause3) => toChannel2(f(cause3))))));
var catchSome3 = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, catchAll7((error) => pipe(pf(error), getOrElse(() => fail15(error))))));
var catchSomeCause3 = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, catchAllCause6((cause3) => pipe(pf(cause3), getOrElse(() => failCause13(cause3))))));
var catchTag3 = /* @__PURE__ */ dual(3, (self2, k, f) => catchAll7(self2, (e) => {
  if ("_tag" in e && e["_tag"] === k) {
    return f(e);
  }
  return fail15(e);
}));
var catchTags3 = /* @__PURE__ */ dual(2, (self2, cases) => catchAll7(self2, (e) => {
  const keys3 = Object.keys(cases);
  if ("_tag" in e && keys3.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return fail15(e);
}));
var changes = (self2) => pipe(self2, changesWith((x, y) => equals(y)(x)));
var changesWith = /* @__PURE__ */ dual(2, (self2, f) => {
  const writer = (last4) => readWithCause({
    onInput: (input) => {
      const [newLast, newChunk] = reduce2(input, [last4, empty4()], ([option3, outputs], output) => {
        if (isSome2(option3) && f(option3.value, output)) {
          return [some2(output), outputs];
        }
        return [some2(output), pipe(outputs, append2(output))];
      });
      return flatMap13(write(newChunk), () => writer(newLast));
    },
    onFailure: failCause10,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer(none2()))));
});
var changesWithEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  const writer = (last4) => readWithCause({
    onInput: (input) => pipe(input, reduce10([last4, empty4()], ([option3, outputs], output) => {
      if (isSome2(option3)) {
        return pipe(f(option3.value, output), map16((bool) => bool ? [some2(output), outputs] : [some2(output), pipe(outputs, append2(output))]));
      }
      return succeed8([some2(output), pipe(outputs, append2(output))]);
    }), fromEffect4, flatMap13(([newLast, newChunk]) => pipe(write(newChunk), flatMap13(() => writer(newLast))))),
    onFailure: failCause10,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer(none2()))));
});
var chunks = (self2) => pipe(self2, mapChunks(of2));
var chunksWith = /* @__PURE__ */ dual(2, (self2, f) => flattenChunks(f(chunks(self2))));
var unsome = (effect4) => catchAll3(asSome2(effect4), (o) => o._tag === "None" ? succeedNone2 : fail9(o.value));
var combine9 = /* @__PURE__ */ dual(4, (self2, that, s, f) => {
  function producer(handoff, latch) {
    return fromEffect4(take6(latch)).pipe(zipRight4(readWithCause({
      onInput: (input) => flatMap13(fromEffect4(offer5(handoff, succeed3(input))), () => producer(handoff, latch)),
      onFailure: (cause3) => fromEffect4(offer5(handoff, failCause3(pipe(cause3, map12(some2))))),
      onDone: () => flatMap13(fromEffect4(offer5(handoff, fail4(none2()))), () => producer(handoff, latch))
    })));
  }
  return new StreamImpl(unwrapScopedWith((scope5) => all4([make49(), make49(), make49(), make49()]).pipe(tap3(([left3, _, latchL]) => toChannel2(self2).pipe(concatMap(writeChunk), pipeTo(producer(left3, latchL)), runIn(scope5), forkIn2(scope5))), tap3(([, right3, _, rightL]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3, rightL)), runIn(scope5), forkIn2(scope5))), map16(([left3, right3, latchL, latchR]) => {
    const pullLeft = offer5(latchL, undefined).pipe(zipRight3(take6(left3).pipe(flatMap11(identity))));
    const pullRight = offer5(latchR, undefined).pipe(zipRight3(take6(right3).pipe(flatMap11(identity))));
    return toChannel2(unfoldEffect(s, (s2) => flatMap11(f(s2, pullLeft, pullRight), unsome)));
  }))));
});
var combineChunks = /* @__PURE__ */ dual(4, (self2, that, s, f) => {
  const producer = (handoff, latch) => zipRight4(fromEffect4(take6(latch)), readWithCause({
    onInput: (input) => flatMap13(fromEffect4(pipe(handoff, offer5(chunk2(input)))), () => producer(handoff, latch)),
    onFailure: (cause3) => fromEffect4(offer5(handoff, failCause11(cause3))),
    onDone: () => fromEffect4(offer5(handoff, end4))
  }));
  return new StreamImpl(unwrapScopedWith((scope5) => all4([make49(), make49(), make49(), make49()]).pipe(tap3(([left3, _, latchL]) => pipeTo(toChannel2(self2), producer(left3, latchL)).pipe(runIn(scope5), forkIn2(scope5))), tap3(([_, right3, __, latchR]) => pipeTo(toChannel2(that), producer(right3, latchR)).pipe(runIn(scope5), forkIn2(scope5))), map16(([left3, right3, latchL, latchR]) => {
    const pullLeft = offer5(latchL, undefined).pipe(zipRight3(take6(left3).pipe(flatMap11(done10))));
    const pullRight = offer5(latchR, undefined).pipe(zipRight3(take6(right3).pipe(flatMap11(done10))));
    return toChannel2(unfoldChunkEffect(s, (s2) => flatMap11(f(s2, pullLeft, pullRight), unsome)));
  }))));
});
var concat2 = /* @__PURE__ */ dual(2, (self2, that) => new StreamImpl(pipe(toChannel2(self2), zipRight4(toChannel2(that)))));
var concatAll2 = (streams) => suspend9(() => pipe(streams, reduce2(empty29, (x, y) => concat2(y)(x))));
var cross = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, a2) => [a, a2])));
var crossLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, _) => a)));
var crossRight = /* @__PURE__ */ dual(2, (left3, right3) => flatMap16(left3, () => right3));
var crossWith = /* @__PURE__ */ dual(3, (left3, right3, f) => pipe(left3, flatMap16((a) => pipe(right3, map21((b) => f(a, b))))));
var debounce = /* @__PURE__ */ dual(2, (self2, duration2) => unwrapScopedWith3((scope5) => gen2(function* () {
  const handoff = yield* make49();
  function enqueue(last4) {
    return sleep2(duration2).pipe(as3(last4), forkIn2(scope5), map16((fiber) => consumer(previous(fiber))));
  }
  const producer = readWithCause({
    onInput: (input) => match2(last2(input), {
      onNone: () => producer,
      onSome: (elem) => fromEffect4(offer5(handoff, emit(of2(elem)))).pipe(flatMap13(() => producer))
    }),
    onFailure: (cause3) => fromEffect4(offer5(handoff, halt(cause3))),
    onDone: () => fromEffect4(offer5(handoff, end3(UpstreamEnd)))
  });
  function consumer(state) {
    switch (state._tag) {
      case OP_NOT_STARTED: {
        return unwrap(take6(handoff).pipe(map16((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause10(signal.cause);
            }
            case OP_END: {
              return void_5;
            }
          }
        })));
      }
      case OP_PREVIOUS: {
        return unwrap(take6(handoff).pipe(forkIn2(scope5), flatMap11((handoffFiber) => raceWith2(join3(state.fiber), join3(handoffFiber), {
          onSelfDone: (leftExit, current2) => match6(leftExit, {
            onFailure: (cause3) => interrupt6(current2).pipe(as3(failCause10(cause3))),
            onSuccess: (chunk3) => interrupt6(current2).pipe(zipRight3(succeed8(write(chunk3).pipe(flatMap13(() => consumer(current(handoffFiber)))))))
          }),
          onOtherDone: (rightExit, previous2) => match6(rightExit, {
            onFailure: (cause3) => interrupt6(previous2).pipe(as3(failCause10(cause3))),
            onSuccess: (signal) => {
              switch (signal._tag) {
                case OP_EMIT4: {
                  return interrupt6(previous2).pipe(zipRight3(enqueue(signal.elements)));
                }
                case OP_HALT: {
                  return interrupt6(previous2).pipe(as3(failCause10(signal.cause)));
                }
                case OP_END: {
                  return join3(previous2).pipe(map16((chunk3) => write(chunk3).pipe(zipRight4(void_5))));
                }
              }
            }
          })
        }))));
      }
      case OP_CURRENT: {
        return unwrap(join3(state.fiber).pipe(map16((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause10(signal.cause);
            }
            case OP_END: {
              return void_5;
            }
          }
        })));
      }
    }
  }
  return scopedWith4((scope6) => pipeTo(toChannel2(self2), producer).pipe(runIn(scope6), forkIn2(scope6))).pipe(crossRight(new StreamImpl(consumer(notStarted))));
})));
var die10 = (defect) => fromEffect7(die6(defect));
var dieSync6 = (evaluate2) => fromEffect7(dieSync3(evaluate2));
var dieMessage4 = (message) => fromEffect7(dieMessage2(message));
var distributedWith = /* @__PURE__ */ dual(2, (self2, options) => pipe(make18(), flatMap11((deferred) => pipe(self2, distributedWithDynamic({
  maximumLag: options.maximumLag,
  decide: (a) => flatMap11(_await(deferred), (f) => f(a))
}), flatMap11((next) => pipe(all4(map4(range(0, options.size - 1), (id2) => map16(next, ([key, queue]) => [[key, id2], queue]))), map16(unsafeFromArray), flatMap11((entries2) => {
  const [mappings, queues] = reduceRight2(entries2, [new Map, empty4()], ([mappings2, queues2], [mapping, queue]) => [mappings2.set(mapping[0], mapping[1]), pipe(queues2, prepend2(queue))]);
  return pipe(succeed2(deferred, (a) => map16(options.decide(a), (f) => (key) => f(mappings.get(key)))), as3(Array.from(queues)));
})))))));
var distributedWithDynamicId = {
  ref: 0
};
var newDistributedWithDynamicId = () => {
  const current2 = distributedWithDynamicId.ref;
  distributedWithDynamicId.ref = current2 + 1;
  return current2;
};
var distributedWithDynamic = /* @__PURE__ */ dual(2, (self2, options) => distributedWithDynamicCallback(self2, options.maximumLag, options.decide, () => _void));
var distributedWithDynamicCallback = /* @__PURE__ */ dual(4, (self2, maximumLag, decide, done11) => pipe(acquireRelease2(make28(new Map), (ref, _) => pipe(get12(ref), flatMap11((queues) => pipe(queues.values(), forEach6(shutdown4))))), flatMap11((queuesRef) => gen2(function* () {
  const offer6 = (a) => pipe(decide(a), flatMap11((shouldProcess) => pipe(get12(queuesRef), flatMap11((queues) => pipe(queues.entries(), reduce10(empty4(), (acc, [id2, queue]) => {
    if (shouldProcess(id2)) {
      return pipe(offer3(queue, succeed3(a)), matchCauseEffect3({
        onFailure: (cause3) => isInterrupted2(cause3) ? succeed8(pipe(acc, prepend2(id2))) : failCause8(cause3),
        onSuccess: () => succeed8(acc)
      }));
    }
    return succeed8(acc);
  }), flatMap11((ids3) => {
    if (isNonEmpty2(ids3)) {
      return update3(queuesRef, (map21) => {
        for (const id2 of ids3) {
          map21.delete(id2);
        }
        return map21;
      });
    }
    return _void;
  }))))), asVoid3);
  const queuesLock = yield* makeSemaphore2(1);
  const newQueue = yield* make28(pipe(bounded5(maximumLag), flatMap11((queue) => {
    const id2 = newDistributedWithDynamicId();
    return pipe(update3(queuesRef, (map21) => map21.set(id2, queue)), as3([id2, queue]));
  })));
  const finalize = (endTake) => queuesLock.withPermits(1)(pipe(set6(newQueue, pipe(bounded5(1), tap3((queue) => offer3(queue, endTake)), flatMap11((queue) => {
    const id2 = newDistributedWithDynamicId();
    return pipe(update3(queuesRef, (map21) => map21.set(id2, queue)), as3(make3(id2, queue)));
  }))), zipRight3(pipe(get12(queuesRef), flatMap11((map21) => pipe(fromIterable2(map21.values()), forEach6((queue) => pipe(offer3(queue, endTake), catchSomeCause2((cause3) => isInterrupted2(cause3) ? some2(_void) : none2()))))))), zipRight3(done11(endTake)), asVoid3));
  yield* pipe(self2, runForEachScoped(offer6), matchCauseEffect3({
    onFailure: (cause3) => finalize(failCause3(pipe(cause3, map12(some2)))),
    onSuccess: () => finalize(fail4(none2()))
  }), forkScoped2);
  return queuesLock.withPermits(1)(flatten9(get12(newQueue)));
}))));
var drain3 = (self2) => new StreamImpl(drain(toChannel2(self2)));
var drainFork = /* @__PURE__ */ dual(2, (self2, that) => fromEffect7(make18()).pipe(flatMap16((backgroundDied) => scopedWith4((scope5) => toChannel2(that).pipe(drain, runIn(scope5), catchAllCause3((cause3) => failCause2(backgroundDied, cause3)), forkIn2(scope5))).pipe(crossRight(interruptWhenDeferred2(self2, backgroundDied))))));
var drop3 = /* @__PURE__ */ dual(2, (self2, n) => {
  const loop3 = (r) => readWith({
    onInput: (input) => {
      const dropped = pipe(input, drop2(r));
      const leftover = Math.max(0, r - input.length);
      const more = isEmpty(input) || leftover > 0;
      if (more) {
        return loop3(leftover);
      }
      return pipe(write(dropped), zipRight4(identityChannel()));
    },
    onFailure: fail11,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3(n))));
});
var dropRight = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return identityStream();
  }
  return suspend9(() => {
    const queue = new RingBuffer(n);
    const reader = readWith({
      onInput: (input) => {
        const outputs = pipe(input, filterMap2((elem) => {
          const head6 = queue.head();
          queue.put(elem);
          return head6;
        }));
        return pipe(write(outputs), flatMap13(() => reader));
      },
      onFailure: fail11,
      onDone: () => void_5
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(reader)));
  });
});
var dropUntil3 = /* @__PURE__ */ dual(2, (self2, predicate) => drop3(dropWhile4(self2, (a) => !predicate(a)), 1));
var dropUntilEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => pipe(dropUntil2(input, predicate), map16(unsafeFromArray), map16((leftover) => {
      const more = isEmpty(leftover);
      if (more) {
        return suspend5(() => loop3);
      }
      return pipe(write(leftover), zipRight4(identityChannel()));
    }), unwrap),
    onFailure: fail11,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
});
var dropWhile4 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => {
      const output = dropWhile(input, predicate);
      if (isEmpty(output)) {
        return suspend5(() => loop3);
      }
      return zipRight4(write(output), identityChannel());
    },
    onFailure: fail11,
    onDone: succeedNow
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self2), loop3));
});
var dropWhileEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => pipe(dropWhile3(input, predicate), map16(unsafeFromArray), map16((leftover) => {
      const more = isEmpty(leftover);
      if (more) {
        return suspend5(() => loop3);
      }
      return zipRight4(write(leftover), identityChannel());
    }), unwrap),
    onFailure: fail11,
    onDone: () => void_5
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self2), loop3));
});
var either5 = (self2) => pipe(self2, map21(right2), catchAll7((error) => make50(left2(error))));
var empty29 = /* @__PURE__ */ new StreamImpl(void_5);
var ensuring6 = /* @__PURE__ */ dual(2, (self2, finalizer) => new StreamImpl(pipe(toChannel2(self2), ensuring3(finalizer))));
var ensuringWith2 = /* @__PURE__ */ dual(2, (self2, finalizer) => new StreamImpl(ensuringWith(toChannel2(self2), finalizer)));
var context5 = () => fromEffect7(context3());
var contextWith3 = (f) => pipe(context5(), map21(f));
var contextWithEffect3 = (f) => pipe(context5(), mapEffectSequential(f));
var contextWithStream = (f) => pipe(context5(), flatMap16(f));
var execute = (effect4) => drain3(fromEffect7(effect4));
var fail15 = (error) => fromEffectOption(fail9(some2(error)));
var failSync7 = (evaluate2) => fromEffectOption(failSync3(() => some2(evaluate2())));
var failCause13 = (cause3) => fromEffect7(failCause8(cause3));
var failCauseSync6 = (evaluate2) => fromEffect7(failCauseSync3(evaluate2));
var filter8 = /* @__PURE__ */ dual(2, (self2, predicate) => mapChunks(self2, filter2(predicate)));
var filterEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  const loop3 = (iterator) => {
    const next = iterator.next();
    if (next.done) {
      return readWithCause({
        onInput: (input) => loop3(input[Symbol.iterator]()),
        onFailure: failCause10,
        onDone: succeed10
      });
    } else {
      return pipe(f(next.value), map16((bool) => bool ? pipe(write(of2(next.value)), flatMap13(() => loop3(iterator))) : loop3(iterator)), unwrap);
    }
  };
  return new StreamImpl(suspend5(() => pipe(toChannel2(self2), pipeTo(loop3(empty4()[Symbol.iterator]())))));
});
var filterMap6 = /* @__PURE__ */ dual(2, (self2, pf) => mapChunks(self2, filterMap2(pf)));
var filterMapEffect = /* @__PURE__ */ dual(2, (self2, pf) => suspend9(() => {
  const loop3 = (iterator) => {
    const next = iterator.next();
    if (next.done) {
      return readWithCause({
        onInput: (input) => loop3(input[Symbol.iterator]()),
        onFailure: failCause10,
        onDone: succeed10
      });
    } else {
      return pipe(pf(next.value), match2({
        onNone: () => sync3(() => loop3(iterator)),
        onSome: map16((a2) => flatMap13(write(of2(a2)), () => loop3(iterator)))
      }), unwrap);
    }
  };
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3(empty4()[Symbol.iterator]()))));
}));
var filterMapWhile3 = /* @__PURE__ */ dual(2, (self2, pf) => {
  const loop3 = readWith({
    onInput: (input) => {
      const mapped = filterMapWhile2(input, pf);
      if (mapped.length === input.length) {
        return pipe(write(mapped), flatMap13(() => loop3));
      }
      return write(mapped);
    },
    onFailure: fail11,
    onDone: succeed10
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
});
var filterMapWhileEffect = /* @__PURE__ */ dual(2, (self2, pf) => suspend9(() => {
  const loop3 = (iterator) => {
    const next = iterator.next();
    if (next.done) {
      return readWithCause({
        onInput: (input) => loop3(input[Symbol.iterator]()),
        onFailure: failCause10,
        onDone: succeed10
      });
    } else {
      return unwrap(match2(pf(next.value), {
        onNone: () => succeed8(void_5),
        onSome: map16((a2) => flatMap13(write(of2(a2)), () => loop3(iterator)))
      }));
    }
  };
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3(empty4()[Symbol.iterator]()))));
}));
var finalizer = (finalizer2) => acquireRelease3(_void, () => finalizer2);
var find2 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => match2(findFirst3(input, predicate), {
      onNone: () => loop3,
      onSome: (n) => write(of2(n))
    }),
    onFailure: fail11,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3)));
});
var findEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => pipe(findFirst6(input, predicate), map16(match2({
      onNone: () => loop3,
      onSome: (n) => write(of2(n))
    })), unwrap),
    onFailure: fail11,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3)));
});
var flatMap16 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, f, options) => {
  const bufferSize = options?.bufferSize ?? 16;
  if (options?.switch) {
    return matchConcurrency(options?.concurrency, () => flatMapParSwitchBuffer(self2, 1, bufferSize, f), (n) => flatMapParSwitchBuffer(self2, n, bufferSize, f));
  }
  return matchConcurrency(options?.concurrency, () => new StreamImpl(concatMap(toChannel2(self2), (as8) => pipe(as8, map4((a) => toChannel2(f(a))), reduce2(void_5, (left3, right3) => pipe(left3, zipRight4(right3)))))), (_) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), options))));
});
var matchConcurrency = (concurrency, sequential4, bounded8) => {
  switch (concurrency) {
    case undefined:
      return sequential4();
    case "unbounded":
      return bounded8(Number.MAX_SAFE_INTEGER);
    default:
      return concurrency > 1 ? bounded8(concurrency) : sequential4();
  }
};
var flatMapParSwitchBuffer = /* @__PURE__ */ dual(4, (self2, n, bufferSize, f) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), {
  concurrency: n,
  mergeStrategy: BufferSliding(),
  bufferSize
}))));
var flatten13 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => flatMap16(self2, identity, options));
var flattenChunks = (self2) => {
  const flatten14 = readWithCause({
    onInput: (chunks2) => flatMap13(writeChunk(chunks2), () => flatten14),
    onFailure: failCause10,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(flatten14)));
};
var flattenEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => options?.unordered ? flatMap16(self2, (a) => fromEffect7(a), {
  concurrency: options.concurrency
}) : matchConcurrency(options?.concurrency, () => mapEffectSequential(self2, identity), (n) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mapOutEffectPar(identity, n), mapOut(of2)))));
var flattenExitOption = (self2) => {
  const processChunk = (chunk3, cont) => {
    const [toEmit, rest] = pipe(chunk3, splitWhere((exit3) => !isSuccess(exit3)));
    const next = pipe(head2(rest), match2({
      onNone: () => cont,
      onSome: match6({
        onFailure: (cause3) => match2(flipCauseOption2(cause3), {
          onNone: () => void_5,
          onSome: failCause10
        }),
        onSuccess: () => void_5
      })
    }));
    return pipe(write(pipe(toEmit, filterMap2((exit3) => isSuccess(exit3) ? some2(exit3.value) : none2()))), flatMap13(() => next));
  };
  const process2 = readWithCause({
    onInput: (chunk3) => processChunk(chunk3, process2),
    onFailure: (cause3) => failCause10(cause3),
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(process2)));
};
var flattenIterables = (self2) => pipe(self2, map21(fromIterable2), flattenChunks);
var flattenTake = (self2) => flattenChunks(flattenExitOption(pipe(self2, map21((take7) => take7.exit))));
var forever5 = (self2) => new StreamImpl(repeated(toChannel2(self2)));
var fromAsyncIterable = (iterable, onError3) => pipe(acquireRelease2(sync3(() => iterable[Symbol.asyncIterator]()), (iterator) => iterator.return ? promise2(async () => iterator.return()) : _void), map16((iterator) => repeatEffectOption(pipe(tryPromise2({
  try: async () => iterator.next(),
  catch: (reason) => some2(onError3(reason))
}), flatMap11((result) => result.done ? fail9(none2()) : succeed8(result.value))))), unwrapScoped4);
var fromChannel2 = (channel) => new StreamImpl(channel);
var toChannel2 = (stream) => {
  if ("channel" in stream) {
    return stream.channel;
  } else if (isEffect2(stream)) {
    return toChannel2(fromEffect7(stream));
  } else {
    throw new TypeError(`Expected a Stream.`);
  }
};
var fromChunk = (chunk3) => new StreamImpl(isEmpty(chunk3) ? void_5 : write(chunk3));
var fromChunkPubSub = (pubsub, options) => {
  if (options?.scoped) {
    const effect4 = map16(subscribe2(pubsub), fromChunkQueue);
    return options.shutdown ? map16(effect4, ensuring6(shutdown3(pubsub))) : effect4;
  }
  const stream = flatMap16(scoped5(subscribe2(pubsub)), fromChunkQueue);
  return options?.shutdown ? ensuring6(stream, shutdown3(pubsub)) : stream;
};
var fromChunkQueue = (queue, options) => pipe(take3(queue), catchAllCause3((cause3) => pipe(isShutdown3(queue), flatMap11((isShutdown7) => isShutdown7 && isInterrupted2(cause3) ? end5() : failCause12(cause3)))), repeatEffectChunkOption, options?.shutdown ? ensuring6(shutdown4(queue)) : identity);
var fromChunks = (...chunks2) => pipe(fromIterable9(chunks2), flatMap16(fromChunk));
var fromEffect7 = (effect4) => pipe(effect4, mapError3(some2), fromEffectOption);
var fromEffectOption = (effect4) => new StreamImpl(unwrap(match12(effect4, {
  onFailure: match2({
    onNone: () => void_5,
    onSome: fail11
  }),
  onSuccess: (a) => write(of2(a))
})));
var fromPubSub = (pubsub, options) => {
  const maxChunkSize = options?.maxChunkSize ?? DefaultChunkSize;
  if (options?.scoped) {
    const effect4 = map16(subscribe2(pubsub), (queue) => fromQueue2(queue, {
      maxChunkSize,
      shutdown: true
    }));
    return options.shutdown ? map16(effect4, ensuring6(shutdown3(pubsub))) : effect4;
  }
  const stream = flatMap16(scoped5(subscribe2(pubsub)), (queue) => fromQueue2(queue, {
    maxChunkSize
  }));
  return options?.shutdown ? ensuring6(stream, shutdown3(pubsub)) : stream;
};
var fromTPubSub = (pubsub) => {
  return unwrapScoped4(map16(subscribeScoped2(pubsub), (queue) => fromTQueue(queue)));
};
var fromIterable9 = (iterable) => suspend9(() => isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]()));
var fromIterableEffect = (effect4) => pipe(effect4, map16(fromIterable9), unwrap2);
var fromIteratorSucceed = (iterator, maxChunkSize = DefaultChunkSize) => {
  return pipe(sync3(() => {
    let builder = [];
    const loop3 = (iterator2) => pipe(sync3(() => {
      let next = iterator2.next();
      if (maxChunkSize === 1) {
        if (next.done) {
          return void_5;
        }
        return pipe(write(of2(next.value)), flatMap13(() => loop3(iterator2)));
      }
      builder = [];
      let count3 = 0;
      while (next.done === false) {
        builder.push(next.value);
        count3 = count3 + 1;
        if (count3 >= maxChunkSize) {
          break;
        }
        next = iterator2.next();
      }
      if (count3 > 0) {
        return pipe(write(unsafeFromArray(builder)), flatMap13(() => loop3(iterator2)));
      }
      return void_5;
    }), unwrap);
    return new StreamImpl(loop3(iterator));
  }), unwrap2);
};
var fromPull2 = (effect4) => pipe(effect4, map16(repeatEffectChunkOption), unwrapScoped4);
var fromQueue2 = (queue, options) => pipe(takeBetween2(queue, 1, options?.maxChunkSize ?? DefaultChunkSize), catchAllCause3((cause3) => pipe(isShutdown3(queue), flatMap11((isShutdown7) => isShutdown7 && isInterrupted2(cause3) ? end5() : failCause12(cause3)))), repeatEffectChunkOption, options?.shutdown ? ensuring6(shutdown4(queue)) : identity);
var fromTQueue = (queue) => pipe(take5(queue), map16(of2), catchAllCause3((cause3) => pipe(isShutdown6(queue), flatMap11((isShutdown7) => isShutdown7 && isInterrupted2(cause3) ? end5() : failCause12(cause3)))), repeatEffectChunkOption);
var fromSchedule = (schedule2) => pipe(driver2(schedule2), map16((driver3) => repeatEffectOption(driver3.next(undefined))), unwrap2);
var fromReadableStream = (...args2) => {
  const evaluate2 = args2.length === 1 ? args2[0].evaluate : args2[0];
  const onError3 = args2.length === 1 ? args2[0].onError : args2[1];
  const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
  return unwrapScoped4(map16(acquireRelease2(sync3(() => evaluate2().getReader()), (reader) => releaseLockOnEnd ? sync3(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => repeatEffectOption(flatMap11(tryPromise2({
    try: () => reader.read(),
    catch: (reason) => some2(onError3(reason))
  }), ({
    done: done11,
    value
  }) => done11 ? fail9(none2()) : succeed8(value)))));
};
var fromReadableStreamByob = (...args2) => {
  const evaluate2 = args2.length === 1 ? args2[0].evaluate : args2[0];
  const onError3 = args2.length === 1 ? args2[0].onError : args2[1];
  const allocSize = (args2.length === 1 ? args2[0].bufferSize : args2[2]) ?? 4096;
  const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
  return unwrapScoped4(map16(acquireRelease2(sync3(() => evaluate2().getReader({
    mode: "byob"
  })), (reader) => releaseLockOnEnd ? sync3(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => catchAll7(forever5(readChunkStreamByobReader(reader, onError3, allocSize)), (error) => error === EOF ? empty29 : fail15(error))));
};
var EOF = /* @__PURE__ */ Symbol.for("effect/Stream/EOF");
var readChunkStreamByobReader = (reader, onError3, size13) => {
  const buffer2 = new ArrayBuffer(size13);
  return paginateEffect(0, (offset) => flatMap11(tryPromise2({
    try: () => reader.read(new Uint8Array(buffer2, offset, buffer2.byteLength - offset)),
    catch: (reason) => onError3(reason)
  }), ({
    done: done11,
    value
  }) => {
    if (done11) {
      return fail9(EOF);
    }
    const newOffset = offset + value.byteLength;
    return succeed8([value, newOffset >= buffer2.byteLength ? none2() : some2(newOffset)]);
  }));
};
var groupAdjacentBy = /* @__PURE__ */ dual(2, (self2, f) => {
  const groupAdjacentByChunk = (state, chunk3) => {
    if (isEmpty(chunk3)) {
      return [state, empty4()];
    }
    const builder = [];
    let from = 0;
    let until = 0;
    let key = undefined;
    let previousChunk = empty4();
    switch (state._tag) {
      case "Some": {
        const tuple = state.value;
        key = tuple[0];
        let loop3 = true;
        while (loop3 && until < chunk3.length) {
          const input = unsafeGet4(chunk3, until);
          const updatedKey = f(input);
          if (!equals(key, updatedKey)) {
            const previousChunk2 = tuple[1];
            const additionalChunk = unsafeFromArray(Array.from(chunk3).slice(from, until));
            const group = appendAll2(previousChunk2, additionalChunk);
            builder.push([key, group]);
            key = updatedKey;
            from = until;
            loop3 = false;
          }
          until = until + 1;
        }
        if (loop3) {
          previousChunk = tuple[1];
        }
        break;
      }
      case "None": {
        key = f(unsafeGet4(chunk3, until));
        until = until + 1;
        break;
      }
    }
    while (until < chunk3.length) {
      const input = unsafeGet4(chunk3, until);
      const updatedKey = f(input);
      if (!equals(key, updatedKey)) {
        builder.push([key, unsafeFromArray(Array.from(chunk3).slice(from, until))]);
        key = updatedKey;
        from = until;
      }
      until = until + 1;
    }
    const nonEmptyChunk = appendAll2(previousChunk, unsafeFromArray(Array.from(chunk3).slice(from, until)));
    const output = unsafeFromArray(builder);
    return [some2([key, nonEmptyChunk]), output];
  };
  const groupAdjacent = (state) => readWithCause({
    onInput: (input) => {
      const [updatedState, output] = groupAdjacentByChunk(state, input);
      return isEmpty(output) ? groupAdjacent(updatedState) : flatMap13(write(output), () => groupAdjacent(updatedState));
    },
    onFailure: (cause3) => match2(state, {
      onNone: () => failCause10(cause3),
      onSome: (output) => flatMap13(write(of2(output)), () => failCause10(cause3))
    }),
    onDone: (done11) => match2(state, {
      onNone: () => succeedNow(done11),
      onSome: (output) => flatMap13(write(of2(output)), () => succeedNow(done11))
    })
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self2), groupAdjacent(none2())));
});
var grouped = /* @__PURE__ */ dual(2, (self2, chunkSize) => pipe(self2, rechunk(chunkSize), chunks));
var groupedWithin = /* @__PURE__ */ dual(3, (self2, chunkSize, duration2) => aggregateWithin(self2, collectAllN(chunkSize), spaced2(duration2)));
var haltWhen = /* @__PURE__ */ dual(2, (self2, effect4) => {
  const writer = (fiber) => pipe(poll4(fiber), map16(match2({
    onNone: () => readWith({
      onInput: (input) => flatMap13(write(input), () => writer(fiber)),
      onFailure: fail11,
      onDone: () => void_5
    }),
    onSome: match6({
      onFailure: failCause10,
      onSuccess: () => void_5
    })
  })), unwrap);
  return new StreamImpl(unwrapScopedWith((scope5) => effect4.pipe(forkIn2(scope5), map16((fiber) => toChannel2(self2).pipe(pipeTo(writer(fiber)))))));
});
var haltAfter = /* @__PURE__ */ dual(2, (self2, duration2) => pipe(self2, haltWhen(sleep2(duration2))));
var haltWhenDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => {
  const writer = pipe(poll(deferred), map16(match2({
    onNone: () => readWith({
      onInput: (input) => pipe(write(input), flatMap13(() => writer)),
      onFailure: fail11,
      onDone: () => void_5
    }),
    onSome: (effect4) => unwrap(match12(effect4, {
      onFailure: fail11,
      onSuccess: () => void_5
    }))
  })), unwrap);
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer)));
});
var identityStream = () => new StreamImpl(identityChannel());
var interleave = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, interleaveWith(that, forever5(make50(true, false)))));
var interleaveWith = /* @__PURE__ */ dual(3, (self2, that, decider) => {
  const producer = (handoff) => readWithCause({
    onInput: (value) => flatMap13(fromEffect4(offer5(handoff, of5(value))), () => producer(handoff)),
    onFailure: (cause3) => fromEffect4(offer5(handoff, failCause11(cause3))),
    onDone: () => fromEffect4(offer5(handoff, end4))
  });
  return new StreamImpl(unwrapScopedWith((scope5) => pipe(make49(), zip5(make49()), tap3(([left3]) => toChannel2(self2).pipe(concatMap(writeChunk), pipeTo(producer(left3)), runIn(scope5), forkIn2(scope5))), tap3(([_, right3]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3)), runIn(scope5), forkIn2(scope5))), map16(([left3, right3]) => {
    const process2 = (leftDone, rightDone) => readWithCause({
      onInput: (bool) => {
        if (bool && !leftDone) {
          return pipe(fromEffect4(take6(left3)), flatMap13(match17({
            onEnd: () => rightDone ? void_5 : process2(true, rightDone),
            onFailure: failCause10,
            onSuccess: (chunk3) => pipe(write(chunk3), flatMap13(() => process2(leftDone, rightDone)))
          })));
        }
        if (!bool && !rightDone) {
          return pipe(fromEffect4(take6(right3)), flatMap13(match17({
            onEnd: () => leftDone ? void_5 : process2(leftDone, true),
            onFailure: failCause10,
            onSuccess: (chunk3) => pipe(write(chunk3), flatMap13(() => process2(leftDone, rightDone)))
          })));
        }
        return process2(leftDone, rightDone);
      },
      onFailure: failCause10,
      onDone: () => void_5
    });
    return pipe(toChannel2(decider), concatMap(writeChunk), pipeTo(process2(false, false)));
  }))));
});
var intersperse = /* @__PURE__ */ dual(2, (self2, element) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(suspend5(() => {
  const writer = (isFirst) => readWithCause({
    onInput: (chunk3) => {
      const builder = [];
      let flagResult = isFirst;
      for (const output of chunk3) {
        if (flagResult) {
          flagResult = false;
          builder.push(output);
        } else {
          builder.push(element);
          builder.push(output);
        }
      }
      return pipe(write(unsafeFromArray(builder)), flatMap13(() => writer(flagResult)));
    },
    onFailure: failCause10,
    onDone: () => void_5
  });
  return writer(true);
})))));
var intersperseAffixes = /* @__PURE__ */ dual(2, (self2, {
  end: end6,
  middle,
  start: start3
}) => pipe(make50(start3), concat2(pipe(self2, intersperse(middle))), concat2(make50(end6))));
var interruptAfter = /* @__PURE__ */ dual(2, (self2, duration2) => pipe(self2, interruptWhen2(sleep2(duration2))));
var interruptWhen2 = /* @__PURE__ */ dual(2, (self2, effect4) => new StreamImpl(pipe(toChannel2(self2), interruptWhen(effect4))));
var interruptWhenDeferred2 = /* @__PURE__ */ dual(2, (self2, deferred) => new StreamImpl(pipe(toChannel2(self2), interruptWhenDeferred(deferred))));
var iterate3 = (value, next) => unfold3(value, (a) => some2([a, next(a)]));
var make50 = (...as8) => fromIterable9(as8);
var map21 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapOut(map4(f)))));
var mapAccum5 = /* @__PURE__ */ dual(3, (self2, s, f) => {
  const accumulator = (s2) => readWith({
    onInput: (input) => {
      const [nextS, chunk3] = mapAccum2(input, s2, f);
      return flatMap13(write(chunk3), () => accumulator(nextS));
    },
    onFailure: fail11,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(accumulator(s))));
});
var mapAccumEffect = /* @__PURE__ */ dual(3, (self2, s, f) => suspend9(() => {
  const accumulator = (s2) => readWith({
    onInput: (input) => pipe(suspend3(() => {
      const outputs = [];
      const emit2 = (output) => sync3(() => {
        outputs.push(output);
      });
      return pipe(input, reduce10(s2, (s3, a) => pipe(f(s3, a), flatMap11(([s4, a2]) => pipe(emit2(a2), as3(s4))))), match12({
        onFailure: (error) => {
          if (outputs.length !== 0) {
            return zipRight4(write(unsafeFromArray(outputs)), fail11(error));
          }
          return fail11(error);
        },
        onSuccess: (s3) => flatMap13(write(unsafeFromArray(outputs)), () => accumulator(s3))
      }));
    }), unwrap),
    onFailure: fail11,
    onDone: () => void_5
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(accumulator(s))));
}));
var mapBoth5 = /* @__PURE__ */ dual(2, (self2, options) => pipe(self2, mapError6(options.onFailure), map21(options.onSuccess)));
var mapChunks = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapOut(f))));
var mapChunksEffect = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapOutEffect(f))));
var mapConcat = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapConcatChunk((a) => fromIterable2(f(a)))));
var mapConcatChunk = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapChunks(flatMap3(f))));
var mapConcatChunkEffect = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapEffectSequential(f), mapConcatChunk(identity)));
var mapConcatEffect = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapEffectSequential((a) => pipe(f(a), map16(fromIterable2))), mapConcatChunk(identity)));
var mapEffectSequential = /* @__PURE__ */ dual(2, (self2, f) => {
  const loop3 = (iterator) => {
    const next = iterator.next();
    if (next.done) {
      return readWithCause({
        onInput: (elem) => loop3(elem[Symbol.iterator]()),
        onFailure: failCause10,
        onDone: succeed10
      });
    } else {
      const value = next.value;
      return unwrap(map16(f(value), (a2) => flatMap13(write(of2(a2)), () => loop3(iterator))));
    }
  };
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(suspend5(() => loop3(empty4()[Symbol.iterator]())))));
});
var mapEffectPar = /* @__PURE__ */ dual(3, (self2, n, f) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mapOutEffectPar(f, n), mapOut(of2))));
var mapError6 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapError5(f))));
var mapErrorCause4 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapErrorCause3(f))));
var merge9 = /* @__PURE__ */ dual((args2) => isStream(args2[1]), (self2, that, options) => mergeWith3(self2, that, {
  onSelf: identity,
  onOther: identity,
  haltStrategy: options?.haltStrategy
}));
var mergeAll8 = /* @__PURE__ */ dual((args2) => (Symbol.iterator in args2[0]), (streams, options) => flatten13(fromIterable9(streams), options));
var mergeWithTag = /* @__PURE__ */ dual(2, (streams, options) => {
  const keys3 = Object.keys(streams);
  const values3 = keys3.map((key) => streams[key].pipe(map21((value) => ({
    _tag: key,
    value
  }))));
  return mergeAll8(values3, options);
});
var mergeEither = /* @__PURE__ */ dual(2, (self2, that) => mergeWith3(self2, that, {
  onSelf: left2,
  onOther: right2
}));
var mergeLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, merge9(drain3(right3))));
var mergeRight = /* @__PURE__ */ dual(2, (left3, right3) => pipe(drain3(left3), merge9(right3)));
var mergeWith3 = /* @__PURE__ */ dual(3, (self2, other, options) => {
  const strategy = options.haltStrategy ? fromInput2(options.haltStrategy) : Both2;
  const handler = (terminate) => (exit3) => terminate || !isSuccess(exit3) ? Done4(suspend3(() => exit3)) : Await2((exit4) => suspend3(() => exit4));
  return new StreamImpl(mergeWith2(toChannel2(map21(self2, options.onSelf)), {
    other: toChannel2(map21(other, options.onOther)),
    onSelfDone: handler(strategy._tag === "Either" || strategy._tag === "Left"),
    onOtherDone: handler(strategy._tag === "Either" || strategy._tag === "Right")
  }));
});
var mkString2 = (self2) => run3(self2, mkString);
var never4 = /* @__PURE__ */ fromEffect7(never3);
var onEnd = /* @__PURE__ */ dual(2, (self2, effect4) => concat2(self2, drain3(fromEffect7(effect4))));
var onError3 = /* @__PURE__ */ dual(2, (self2, cleanup) => pipe(self2, catchAllCause6((cause3) => fromEffect7(pipe(cleanup(cause3), zipRight3(failCause8(cause3)))))));
var onDone = /* @__PURE__ */ dual(2, (self2, cleanup) => new StreamImpl(pipe(toChannel2(self2), ensuringWith((exit3) => isSuccess(exit3) ? cleanup() : _void))));
var onStart = /* @__PURE__ */ dual(2, (self2, effect4) => unwrap2(as3(effect4, self2)));
var orDie5 = (self2) => pipe(self2, orDieWith4(identity));
var orDieWith4 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), orDieWith3(f))));
var orElse8 = /* @__PURE__ */ dual(2, (self2, that) => new StreamImpl(pipe(toChannel2(self2), orElse7(() => toChannel2(that())))));
var orElseEither3 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, map21(left2), orElse8(() => pipe(that(), map21(right2)))));
var orElseFail3 = /* @__PURE__ */ dual(2, (self2, error) => pipe(self2, orElse8(() => failSync7(error))));
var orElseIfEmpty = /* @__PURE__ */ dual(2, (self2, element) => pipe(self2, orElseIfEmptyChunk(() => of2(element()))));
var orElseIfEmptyChunk = /* @__PURE__ */ dual(2, (self2, chunk3) => pipe(self2, orElseIfEmptyStream(() => new StreamImpl(write(chunk3())))));
var orElseIfEmptyStream = /* @__PURE__ */ dual(2, (self2, stream) => {
  const writer = readWith({
    onInput: (input) => {
      if (isEmpty(input)) {
        return suspend5(() => writer);
      }
      return pipe(write(input), zipRight4(identityChannel()));
    },
    onFailure: fail11,
    onDone: () => suspend5(() => toChannel2(stream()))
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer)));
});
var orElseSucceed3 = /* @__PURE__ */ dual(2, (self2, value) => pipe(self2, orElse8(() => sync8(value))));
var paginate = (s, f) => paginateChunk(s, (s2) => {
  const page = f(s2);
  return [of2(page[0]), page[1]];
});
var paginateChunk = (s, f) => {
  const loop3 = (s2) => {
    const page = f(s2);
    return match2(page[1], {
      onNone: () => zipRight4(write(page[0]), void_5),
      onSome: (s3) => flatMap13(write(page[0]), () => loop3(s3))
    });
  };
  return new StreamImpl(suspend5(() => loop3(s)));
};
var paginateChunkEffect = (s, f) => {
  const loop3 = (s2) => unwrap(map16(f(s2), ([chunk3, option3]) => match2(option3, {
    onNone: () => zipRight4(write(chunk3), void_5),
    onSome: (s3) => flatMap13(write(chunk3), () => loop3(s3))
  })));
  return new StreamImpl(suspend5(() => loop3(s)));
};
var paginateEffect = (s, f) => paginateChunkEffect(s, (s2) => pipe(f(s2), map16(([a, s3]) => [of2(a), s3])));
var peel = /* @__PURE__ */ dual(2, (self2, sink) => {
  const OP_EMIT5 = "Emit";
  const OP_HALT2 = "Halt";
  const OP_END2 = "End";
  return pipe(make18(), flatMap11((deferred) => pipe(make49(), map16((handoff) => {
    const consumer = foldSink(collectLeftover(sink), {
      onFailure: (error) => zipRight5(fromEffect6(fail3(deferred, error)), fail12(error)),
      onSuccess: ([z, leftovers]) => {
        const loop3 = readWithCause({
          onInput: (elements) => flatMap13(fromEffect4(offer5(handoff, {
            _tag: OP_EMIT5,
            elements
          })), () => loop3),
          onFailure: (cause3) => zipRight4(fromEffect4(offer5(handoff, {
            _tag: OP_HALT2,
            cause: cause3
          })), failCause10(cause3)),
          onDone: (_) => zipRight4(fromEffect4(offer5(handoff, {
            _tag: OP_END2
          })), void_5)
        });
        return fromChannel(pipe(fromEffect4(succeed2(deferred, z)), zipRight4(fromEffect4(pipe(handoff, offer5({
          _tag: OP_EMIT5,
          elements: leftovers
        })))), zipRight4(loop3)));
      }
    });
    const producer = pipe(take6(handoff), map16((signal) => {
      switch (signal._tag) {
        case OP_EMIT5: {
          return pipe(write(signal.elements), flatMap13(() => producer));
        }
        case OP_HALT2: {
          return failCause10(signal.cause);
        }
        case OP_END2: {
          return void_5;
        }
      }
    }), unwrap);
    return pipe(self2, tapErrorCause5((cause3) => failCause2(deferred, cause3)), run3(consumer), forkScoped2, zipRight3(_await(deferred)), map16((z) => [z, new StreamImpl(producer)]));
  }))), flatten9);
});
var partition5 = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self2, predicate, options) => partitionEither(self2, (a) => succeed8(predicate(a) ? right2(a) : left2(a)), options));
var partitionEither = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self2, predicate, options) => pipe(mapEffectSequential(self2, predicate), distributedWith({
  size: 2,
  maximumLag: options?.bufferSize ?? 16,
  decide: match({
    onLeft: () => succeed8((n) => n === 0),
    onRight: () => succeed8((n) => n === 1)
  })
}), flatMap11(([queue1, queue2]) => succeed8([filterMap6(flattenExitOption(fromQueue2(queue1, {
  shutdown: true
})), (_) => match(_, {
  onLeft: some2,
  onRight: none2
})), filterMap6(flattenExitOption(fromQueue2(queue2, {
  shutdown: true
})), (_) => match(_, {
  onLeft: none2,
  onRight: some2
}))]))));
var pipeThrough = /* @__PURE__ */ dual(2, (self2, sink) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(toChannel(sink)))));
var pipeThroughChannel = /* @__PURE__ */ dual(2, (self2, channel) => new StreamImpl(pipeTo(toChannel2(self2), channel)));
var pipeThroughChannelOrFail = /* @__PURE__ */ dual(2, (self2, chan) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(chan))));
var prepend4 = /* @__PURE__ */ dual(2, (self2, values3) => new StreamImpl(zipRight4(write(values3), toChannel2(self2))));
var provideContext5 = /* @__PURE__ */ dual(2, (self2, context6) => new StreamImpl(pipe(toChannel2(self2), provideContext3(context6))));
var provideSomeContext2 = /* @__PURE__ */ dual(2, (self2, context6) => mapInputContext5(self2, merge3(context6)));
var provideLayer = /* @__PURE__ */ dual(2, (self2, layer) => new StreamImpl(unwrapScopedWith((scope5) => buildWithScope2(layer, scope5).pipe(map16((env) => pipe(toChannel2(self2), provideContext3(env)))))));
var provideService5 = /* @__PURE__ */ dual(3, (self2, tag, resource) => provideServiceEffect3(self2, tag, succeed8(resource)));
var provideServiceEffect3 = /* @__PURE__ */ dual(3, (self2, tag, effect4) => provideServiceStream(self2, tag, fromEffect7(effect4)));
var provideServiceStream = /* @__PURE__ */ dual(3, (self2, tag, stream) => contextWithStream((env) => flatMap16(stream, (service3) => pipe(self2, provideContext5(add2(env, tag, service3))))));
var mapInputContext5 = /* @__PURE__ */ dual(2, (self2, f) => contextWithStream((env) => pipe(self2, provideContext5(f(env)))));
var provideSomeLayer2 = /* @__PURE__ */ dual(2, (self2, layer) => pipe(self2, provideLayer(pipe(context4(), merge8(layer)))));
var range2 = (min3, max5, chunkSize = DefaultChunkSize) => suspend9(() => {
  if (min3 > max5) {
    return empty29;
  }
  const go = (min4, max6, chunkSize2) => {
    const remaining = max6 - min4 + 1;
    if (remaining > chunkSize2) {
      return pipe(write(range(min4, min4 + chunkSize2 - 1)), flatMap13(() => go(min4 + chunkSize2, max6, chunkSize2)));
    }
    return write(range(min4, min4 + remaining - 1));
  };
  return new StreamImpl(go(min3, max5, chunkSize));
});
var race3 = /* @__PURE__ */ dual(2, (left3, right3) => raceAll3(left3, right3));
var raceAll3 = (...streams) => make18().pipe(map16((halt2) => {
  let winner = null;
  return mergeAll8(streams.map((stream, index) => stream.pipe(takeWhile4(() => {
    if (winner === null) {
      winner = index;
      unsafeDone(halt2, void_2);
      return true;
    }
    return winner === index;
  }), interruptWhen2(_await(halt2).pipe(flatMap11(() => winner === index ? never3 : _void))))), {
    concurrency: streams.length
  });
}), unwrap2);
var rechunk = /* @__PURE__ */ dual(2, (self2, n) => suspend9(() => {
  const target = Math.max(n, 1);
  const process2 = rechunkProcess(new StreamRechunker(target), target);
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(process2)));
}));
var rechunkProcess = (rechunker, target) => readWithCause({
  onInput: (chunk3) => {
    if (chunk3.length === target && rechunker.isEmpty()) {
      return flatMap13(write(chunk3), () => rechunkProcess(rechunker, target));
    }
    if (chunk3.length > 0) {
      const chunks2 = [];
      let result = undefined;
      let index = 0;
      while (index < chunk3.length) {
        while (index < chunk3.length && result === undefined) {
          result = rechunker.write(pipe(chunk3, unsafeGet4(index)));
          index = index + 1;
        }
        if (result !== undefined) {
          chunks2.push(result);
          result = undefined;
        }
      }
      return flatMap13(writeAll(...chunks2), () => rechunkProcess(rechunker, target));
    }
    return suspend5(() => rechunkProcess(rechunker, target));
  },
  onFailure: (cause3) => zipRight4(rechunker.emitIfNotEmpty(), failCause10(cause3)),
  onDone: () => rechunker.emitIfNotEmpty()
});

class StreamRechunker {
  n;
  builder = [];
  pos = 0;
  constructor(n) {
    this.n = n;
  }
  isEmpty() {
    return this.pos === 0;
  }
  write(elem) {
    this.builder.push(elem);
    this.pos += 1;
    if (this.pos === this.n) {
      const result = unsafeFromArray(this.builder);
      this.builder = [];
      this.pos = 0;
      return result;
    }
    return;
  }
  emitIfNotEmpty() {
    if (this.pos !== 0) {
      return write(unsafeFromArray(this.builder));
    }
    return void_5;
  }
}
var refineOrDie = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, refineOrDieWith(pf, identity)));
var refineOrDieWith = /* @__PURE__ */ dual(3, (self2, pf, f) => new StreamImpl(catchAll5(toChannel2(self2), (error) => match2(pf(error), {
  onNone: () => failCause10(die4(f(error))),
  onSome: fail11
}))));
var repeat2 = /* @__PURE__ */ dual(2, (self2, schedule2) => filterMap6(repeatEither(self2, schedule2), (_) => match(_, {
  onLeft: none2,
  onRight: some2
})));
var repeatEffect = (effect4) => repeatEffectOption(pipe(effect4, mapError3(some2)));
var repeatEffectChunk = (effect4) => repeatEffectChunkOption(pipe(effect4, mapError3(some2)));
var repeatEffectChunkOption = (effect4) => unfoldChunkEffect(effect4, (effect5) => pipe(map16(effect5, (chunk3) => some2([chunk3, effect5])), catchAll3(match2({
  onNone: () => succeed8(none2()),
  onSome: fail9
}))));
var repeatEffectOption = (effect4) => repeatEffectChunkOption(pipe(effect4, map16(of2)));
var repeatEither = /* @__PURE__ */ dual(2, (self2, schedule2) => repeatWith(self2, schedule2, {
  onElement: (a) => right2(a),
  onSchedule: left2
}));
var repeatElements = /* @__PURE__ */ dual(2, (self2, schedule2) => filterMap6(repeatElementsWith(self2, schedule2, {
  onElement: (a) => some2(a),
  onSchedule: none2
}), identity));
var repeatElementsWith = /* @__PURE__ */ dual(3, (self2, schedule2, options) => {
  const driver3 = pipe(driver2(schedule2), map16((driver4) => {
    const feed = (input) => match2(head2(input), {
      onNone: () => loop3,
      onSome: (a) => zipRight4(write(of2(options.onElement(a))), step4(pipe(input, drop2(1)), a))
    });
    const step4 = (input, a) => {
      const advance = pipe(driver4.next(a), as3(pipe(write(of2(options.onElement(a))), flatMap13(() => step4(input, a)))));
      const reset = pipe(driver4.last, orDie3, flatMap11((b) => pipe(driver4.reset, map16(() => pipe(write(of2(options.onSchedule(b))), zipRight4(feed(input)))))));
      return pipe(advance, orElse5(() => reset), unwrap);
    };
    const loop3 = readWith({
      onInput: feed,
      onFailure: fail11,
      onDone: () => void_5
    });
    return loop3;
  }), unwrap);
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(driver3)));
});
var repeatValue = (value) => new StreamImpl(repeated(write(of2(value))));
var repeatWith = /* @__PURE__ */ dual(3, (self2, schedule2, options) => {
  return pipe(driver2(schedule2), map16((driver3) => {
    const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get12(driver3.iterationMeta));
    const process2 = pipe(self2, provideLastIterationInfo, map21(options.onElement), toChannel2);
    const loop3 = unwrap(match12(driver3.next(undefined), {
      onFailure: () => void_5,
      onSuccess: (output) => flatMap13(process2, () => zipRight4(write(of2(options.onSchedule(output))), loop3))
    }));
    return new StreamImpl(zipRight4(process2, loop3));
  }), unwrap2);
});
var repeatWithSchedule = (value, schedule2) => repeatEffectWithSchedule(succeed8(value), schedule2);
var repeatEffectWithSchedule = (effect4, schedule2) => flatMap16(fromEffect7(zip5(effect4, driver2(schedule2))), ([a, driver3]) => {
  const provideLastIterationInfo = provideServiceEffect2(CurrentIterationMetadata2, get12(driver3.iterationMeta));
  return concat2(succeed14(a), unfoldEffect(a, (s) => matchEffect2(driver3.next(s), {
    onFailure: succeed8,
    onSuccess: () => map16(provideLastIterationInfo(effect4), (nextA) => some2([nextA, nextA]))
  })));
});
var retry6 = /* @__PURE__ */ dual(2, (self2, policy) => driver2(policy).pipe(map16((driver3) => {
  const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get12(driver3.iterationMeta));
  const loop3 = toChannel2(provideLastIterationInfo(self2)).pipe(mapOutEffect((out) => as3(driver3.reset, out)), catchAll5((error) => driver3.next(error).pipe(match12({
    onFailure: () => fail11(error),
    onSuccess: () => loop3
  }), unwrap)));
  return loop3;
}), unwrap, fromChannel2));
var withExecutionPlan3 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, policy, options) => suspend9(() => {
  const preventFallbackOnPartialStream = options?.preventFallbackOnPartialStream ?? false;
  let i = 0;
  let lastError = none2();
  const loop3 = suspend9(() => {
    const step4 = policy.steps[i++];
    if (!step4) {
      return fail15(getOrThrow2(lastError));
    }
    let nextStream = isContext2(step4.provide) ? provideSomeContext2(self2, step4.provide) : provideSomeLayer2(self2, step4.provide);
    let receivedElements = false;
    if (isSome2(lastError)) {
      const error = lastError.value;
      let attempted = false;
      const wrapped = nextStream;
      nextStream = suspend9(() => {
        if (attempted)
          return wrapped;
        attempted = true;
        return fail15(error);
      });
      nextStream = scheduleDefectRefail2(retry6(nextStream, scheduleFromStep(step4, false)));
    } else {
      const schedule2 = scheduleFromStep(step4, true);
      nextStream = schedule2 ? scheduleDefectRefail2(retry6(nextStream, schedule2)) : nextStream;
    }
    return catchAll7(preventFallbackOnPartialStream ? mapChunks(nextStream, (chunk3) => {
      receivedElements = true;
      return chunk3;
    }) : nextStream, (error) => {
      if (preventFallbackOnPartialStream && receivedElements) {
        return fail15(error);
      }
      lastError = some2(error);
      return loop3;
    });
  });
  return loop3;
}));
var scheduleDefectRefail2 = (self2) => catchAllCause6(self2, (cause3) => failCause13(scheduleDefectRefailCause(cause3)));
var run3 = /* @__PURE__ */ dual(2, (self2, sink) => toChannel2(self2).pipe(pipeToOrFail(toChannel(sink)), runDrain));
var runCollect = (self2) => run3(self2, collectAll());
var runCount = (self2) => run3(self2, count);
var runDrain2 = (self2) => run3(self2, drain2);
var runFold = /* @__PURE__ */ dual(3, (self2, s, f) => runFoldWhile(self2, s, constTrue, f));
var runFoldEffect = /* @__PURE__ */ dual(3, (self2, s, f) => runFoldWhileEffect(self2, s, constTrue, f));
var runFoldScoped = /* @__PURE__ */ dual(3, (self2, s, f) => pipe(self2, runFoldWhileScoped(s, constTrue, f)));
var runFoldScopedEffect = /* @__PURE__ */ dual(3, (self2, s, f) => pipe(self2, runFoldWhileScopedEffect(s, constTrue, f)));
var runFoldWhile = /* @__PURE__ */ dual(4, (self2, s, cont, f) => run3(self2, fold(s, cont, f)));
var runFoldWhileEffect = /* @__PURE__ */ dual(4, (self2, s, cont, f) => run3(self2, foldEffect(s, cont, f)));
var runFoldWhileScoped = /* @__PURE__ */ dual(4, (self2, s, cont, f) => pipe(self2, runScoped2(fold(s, cont, f))));
var runFoldWhileScopedEffect = /* @__PURE__ */ dual(4, (self2, s, cont, f) => pipe(self2, runScoped2(foldEffect(s, cont, f))));
var runForEach = /* @__PURE__ */ dual(2, (self2, f) => run3(self2, forEach7(f)));
var runForEachChunk = /* @__PURE__ */ dual(2, (self2, f) => run3(self2, forEachChunk(f)));
var runForEachChunkScoped = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, runScoped2(forEachChunk(f))));
var runForEachScoped = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, runScoped2(forEach7(f))));
var runForEachWhile = /* @__PURE__ */ dual(2, (self2, f) => run3(self2, forEachWhile(f)));
var runForEachWhileScoped = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, runScoped2(forEachWhile(f))));
var runHead = (self2) => run3(self2, head5());
var runIntoPubSub = /* @__PURE__ */ dual(2, (self2, pubsub) => pipe(self2, runIntoQueue(pubsub)));
var runIntoPubSubScoped = /* @__PURE__ */ dual(2, (self2, pubsub) => pipe(self2, runIntoQueueScoped(pubsub)));
var runIntoQueue = /* @__PURE__ */ dual(2, (self2, queue) => pipe(self2, runIntoQueueScoped(queue), scoped2));
var runIntoQueueElementsScoped = /* @__PURE__ */ dual(2, (self2, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap13(fromEffect4(offerAll3(queue, map4(input, succeed3))), () => writer),
    onFailure: (cause3) => fromEffect4(offer3(queue, failCause3(map12(cause3, some2)))),
    onDone: () => fromEffect4(offer3(queue, fail4(none2())))
  });
  return pipe(pipeTo(toChannel2(self2), writer), drain, runScoped, asVoid3);
});
var runIntoQueueScoped = /* @__PURE__ */ dual(2, (self2, queue) => {
  const writer = readWithCause({
    onInput: (input) => flatMap13(write(chunk2(input)), () => writer),
    onFailure: (cause3) => write(failCause11(cause3)),
    onDone: () => write(end4)
  });
  return pipe(pipeTo(toChannel2(self2), writer), mapOutEffect((take7) => offer3(queue, take7)), drain, runScoped, asVoid3);
});
var runLast = (self2) => run3(self2, last3());
var runScoped2 = /* @__PURE__ */ dual(2, (self2, sink) => pipe(toChannel2(self2), pipeToOrFail(toChannel(sink)), drain, runScoped));
var runSum = (self2) => run3(self2, sum2);
var scan = /* @__PURE__ */ dual(3, (self2, s, f) => pipe(self2, scanEffect(s, (s2, a) => succeed8(f(s2, a)))));
var scanReduce = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, scanReduceEffect((a2, a) => succeed8(f(a2, a)))));
var scanReduceEffect = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapAccumEffect(none2(), (option3, a) => {
  switch (option3._tag) {
    case "None": {
      return succeed8([some2(a), a]);
    }
    case "Some": {
      return pipe(f(option3.value, a), map16((b) => [some2(b), b]));
    }
  }
})));
var schedule2 = /* @__PURE__ */ dual(2, (self2, schedule3) => filterMap6(scheduleWith(self2, schedule3, {
  onElement: some2,
  onSchedule: none2
}), identity));
var scheduleWith = /* @__PURE__ */ dual(3, (self2, schedule3, options) => {
  const loop3 = (driver3, iterator) => {
    const next = iterator.next();
    if (next.done) {
      return readWithCause({
        onInput: (chunk3) => loop3(driver3, chunk3[Symbol.iterator]()),
        onFailure: failCause10,
        onDone: succeedNow
      });
    }
    return unwrap(matchEffect2(driver3.next(next.value), {
      onFailure: () => pipe(driver3.last, orDie3, map16((b) => pipe(write(make6(options.onElement(next.value), options.onSchedule(b))), flatMap13(() => loop3(driver3, iterator)))), zipLeft2(driver3.reset)),
      onSuccess: () => succeed8(pipe(write(of2(options.onElement(next.value))), flatMap13(() => loop3(driver3, iterator))))
    }));
  };
  return new StreamImpl(pipe(fromEffect4(driver2(schedule3)), flatMap13((driver3) => pipe(toChannel2(self2), pipeTo(loop3(driver3, empty4()[Symbol.iterator]()))))));
});
var scanEffect = /* @__PURE__ */ dual(3, (self2, s, f) => new StreamImpl(pipe(write(of2(s)), flatMap13(() => toChannel2(pipe(self2, mapAccumEffect(s, (s2, a) => pipe(f(s2, a), map16((s3) => [s3, s3])))))))));
var scoped5 = (effect4) => new StreamImpl(ensuring3(scoped4(pipe(effect4, map16(of2))), _void));
var scopedWith4 = (f) => new StreamImpl(scopedWith3((scope5) => f(scope5).pipe(map16(of2))));
var some5 = (self2) => pipe(self2, mapError6(some2), someOrFail(() => none2()));
var someOrElse = /* @__PURE__ */ dual(2, (self2, fallback) => pipe(self2, map21(getOrElse(fallback))));
var someOrFail = /* @__PURE__ */ dual(2, (self2, error) => mapEffectSequential(self2, match2({
  onNone: () => failSync3(error),
  onSome: succeed8
})));
var sliding7 = /* @__PURE__ */ dual(2, (self2, chunkSize) => slidingSize(self2, chunkSize, 1));
var slidingSize = /* @__PURE__ */ dual(3, (self2, chunkSize, stepSize) => {
  if (chunkSize <= 0 || stepSize <= 0) {
    return die10(new IllegalArgumentException2("Invalid bounds - `chunkSize` and `stepSize` must be greater than zero"));
  }
  return new StreamImpl(suspend5(() => {
    const queue = new RingBuffer(chunkSize);
    const emitOnStreamEnd = (queueSize, channelEnd) => {
      if (queueSize < chunkSize) {
        const items = queue.toChunk();
        const result2 = isEmpty(items) ? empty4() : of2(items);
        return pipe(write(result2), flatMap13(() => channelEnd));
      }
      const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;
      if (lastEmitIndex === queueSize) {
        return channelEnd;
      }
      const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);
      const lastItems = pipe(queue.toChunk(), takeRight(leftovers));
      const result = isEmpty(lastItems) ? empty4() : of2(lastItems);
      return pipe(write(result), flatMap13(() => channelEnd));
    };
    const reader = (queueSize) => readWithCause({
      onInput: (input) => flatMap13(write(filterMap2(input, (element, index) => {
        queue.put(element);
        const currentIndex = queueSize + index + 1;
        if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {
          return none2();
        }
        return some2(queue.toChunk());
      })), () => reader(queueSize + input.length)),
      onFailure: (cause3) => emitOnStreamEnd(queueSize, failCause10(cause3)),
      onDone: () => emitOnStreamEnd(queueSize, void_5)
    });
    return pipe(toChannel2(self2), pipeTo(reader(0)));
  }));
});
var split = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const split2 = (leftovers, input) => {
    const [chunk3, remaining] = pipe(leftovers, appendAll2(input), splitWhere(predicate));
    if (isEmpty(chunk3) || isEmpty(remaining)) {
      return loop3(pipe(chunk3, appendAll2(pipe(remaining, drop2(1)))));
    }
    return pipe(write(of2(chunk3)), flatMap13(() => split2(empty4(), pipe(remaining, drop2(1)))));
  };
  const loop3 = (leftovers) => readWith({
    onInput: (input) => split2(leftovers, input),
    onFailure: fail11,
    onDone: () => {
      if (isEmpty(leftovers)) {
        return void_5;
      }
      if (isNone2(pipe(leftovers, findFirst3(predicate)))) {
        return zipRight4(write(of2(leftovers)), void_5);
      }
      return zipRight4(split2(empty4(), leftovers), void_5);
    }
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3(empty4()))));
});
var splitOnChunk = /* @__PURE__ */ dual(2, (self2, delimiter) => {
  const next = (leftover, delimiterIndex) => readWithCause({
    onInput: (inputChunk) => {
      let buffer2;
      const [carry, delimiterCursor] = pipe(inputChunk, reduce2([pipe(leftover, getOrElse(() => empty4())), delimiterIndex], ([carry2, delimiterCursor2], a) => {
        const concatenated = pipe(carry2, append2(a));
        if (delimiterCursor2 < delimiter.length && equals(a, pipe(delimiter, unsafeGet4(delimiterCursor2)))) {
          if (delimiterCursor2 + 1 === delimiter.length) {
            if (buffer2 === undefined) {
              buffer2 = [];
            }
            buffer2.push(pipe(concatenated, take(concatenated.length - delimiter.length)));
            return [empty4(), 0];
          }
          return [concatenated, delimiterCursor2 + 1];
        }
        return [concatenated, equals(a, pipe(delimiter, unsafeGet4(0))) ? 1 : 0];
      }));
      const output = buffer2 === undefined ? empty4() : unsafeFromArray(buffer2);
      return flatMap13(write(output), () => next(isNonEmpty2(carry) ? some2(carry) : none2(), delimiterCursor));
    },
    onFailure: (cause3) => match2(leftover, {
      onNone: () => failCause10(cause3),
      onSome: (chunk3) => zipRight4(write(of2(chunk3)), failCause10(cause3))
    }),
    onDone: (done11) => match2(leftover, {
      onNone: () => succeed10(done11),
      onSome: (chunk3) => zipRight4(write(of2(chunk3)), succeed10(done11))
    })
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(next(none2(), 0))));
});
var splitLines2 = (self2) => pipeThroughChannel(self2, splitLines());
var succeed14 = (value) => fromChunk(of2(value));
var sync8 = (evaluate2) => suspend9(() => fromChunk(of2(evaluate2())));
var suspend9 = (stream) => new StreamImpl(suspend5(() => toChannel2(stream())));
var take7 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (!Number.isInteger(n)) {
    return die10(new IllegalArgumentException2(`${n} must be an integer`));
  }
  const loop3 = (n2) => readWith({
    onInput: (input) => {
      const taken = pipe(input, take(Math.min(n2, Number.POSITIVE_INFINITY)));
      const leftover = Math.max(0, n2 - taken.length);
      const more = leftover > 0;
      if (more) {
        return pipe(write(taken), flatMap13(() => loop3(leftover)));
      }
      return write(taken);
    },
    onFailure: fail11,
    onDone: succeed10
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(0 < n ? loop3(n) : void_5)));
});
var takeRight2 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return empty29;
  }
  return new StreamImpl(pipe(succeed8(new RingBuffer(n)), map16((queue) => {
    const reader = readWith({
      onInput: (input) => {
        for (const element of input) {
          queue.put(element);
        }
        return reader;
      },
      onFailure: fail11,
      onDone: () => pipe(write(queue.toChunk()), zipRight4(void_5))
    });
    return pipe(toChannel2(self2), pipeTo(reader));
  }), unwrap));
});
var takeUntil3 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => {
      const taken = pipe(input, takeWhile((a) => !predicate(a)));
      const last4 = pipe(input, drop2(taken.length), take(1));
      if (isEmpty(last4)) {
        return pipe(write(taken), flatMap13(() => loop3));
      }
      return write(pipe(taken, appendAll2(last4)));
    },
    onFailure: fail11,
    onDone: succeed10
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
});
var takeUntilEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = (iterator) => {
    const next = iterator.next();
    if (next.done) {
      return readWithCause({
        onInput: (elem) => loop3(elem[Symbol.iterator]()),
        onFailure: failCause10,
        onDone: succeed10
      });
    }
    return pipe(predicate(next.value), map16((bool) => bool ? write(of2(next.value)) : pipe(write(of2(next.value)), flatMap13(() => loop3(iterator)))), unwrap);
  };
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3(empty4()[Symbol.iterator]()))));
});
var takeWhile4 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop3 = readWith({
    onInput: (input) => {
      const taken = pipe(input, takeWhile(predicate));
      const more = taken.length === input.length;
      if (more) {
        return pipe(write(taken), flatMap13(() => loop3));
      }
      return write(taken);
    },
    onFailure: fail11,
    onDone: succeed10
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop3)));
});
var tap6 = /* @__PURE__ */ dual(2, (self2, f) => mapEffectSequential(self2, (a) => as3(f(a), a)));
var tapBoth3 = /* @__PURE__ */ dual(2, (self2, options) => pipe(self2, tapError5(options.onFailure), tap6(options.onSuccess)));
var tapError5 = /* @__PURE__ */ dual(2, (self2, f) => catchAll7(self2, (error) => fromEffect7(zipRight3(f(error), fail9(error)))));
var tapErrorCause5 = /* @__PURE__ */ dual(2, (self2, f) => {
  const loop3 = readWithCause({
    onInput: (chunk3) => flatMap13(write(chunk3), () => loop3),
    onFailure: (cause3) => fromEffect4(zipRight3(f(cause3), failCause8(cause3))),
    onDone: succeedNow
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop3)));
});
var tapSink = /* @__PURE__ */ dual(2, (self2, sink) => pipe(fromEffect7(all4([bounded5(1), make18()])), flatMap16(([queue, deferred]) => {
  const right3 = flattenTake(fromQueue2(queue, {
    maxChunkSize: 1
  }));
  const loop3 = readWithCause({
    onInput: (chunk3) => pipe(fromEffect4(offer3(queue, chunk2(chunk3))), foldCauseChannel({
      onFailure: () => flatMap13(write(chunk3), () => identityChannel()),
      onSuccess: () => flatMap13(write(chunk3), () => loop3)
    })),
    onFailure: (cause3) => pipe(fromEffect4(offer3(queue, failCause11(cause3))), foldCauseChannel({
      onFailure: () => failCause10(cause3),
      onSuccess: () => failCause10(cause3)
    })),
    onDone: () => pipe(fromEffect4(offer3(queue, end4)), foldCauseChannel({
      onFailure: () => void_5,
      onSuccess: () => void_5
    }))
  });
  return pipe(new StreamImpl(pipe(pipeTo(toChannel2(self2), loop3), ensuring3(zipRight3(forkDaemon2(offer3(queue, end4)), _await(deferred))))), merge9(execute(pipe(run3(right3, sink), ensuring2(zipRight3(shutdown4(queue), succeed2(deferred, undefined)))))));
})));
var throttle = /* @__PURE__ */ dual(2, (self2, options) => throttleEffect(self2, {
  ...options,
  cost: (chunk3) => succeed8(options.cost(chunk3))
}));
var throttleEffect = /* @__PURE__ */ dual(2, (self2, options) => {
  if (options.strategy === "enforce") {
    return throttleEnforceEffect(self2, options.cost, options.units, options.duration, options.burst ?? 0);
  }
  return throttleShapeEffect(self2, options.cost, options.units, options.duration, options.burst ?? 0);
});
var throttleEnforceEffect = (self2, cost, units, duration2, burst) => {
  const loop3 = (tokens, timestampMillis) => readWithCause({
    onInput: (input) => pipe(cost(input), zip5(currentTimeMillis2), map16(([weight, currentTimeMillis3]) => {
      const elapsed2 = currentTimeMillis3 - timestampMillis;
      const cycles = elapsed2 / toMillis(duration2);
      const sum3 = tokens + cycles * units;
      const max5 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available = sum3 < 0 ? max5 : Math.min(sum3, max5);
      if (weight <= available) {
        return pipe(write(input), flatMap13(() => loop3(available - weight, currentTimeMillis3)));
      }
      return loop3(tokens, timestampMillis);
    }), unwrap),
    onFailure: failCause10,
    onDone: () => void_5
  });
  const throttled = pipe(currentTimeMillis2, map16((currentTimeMillis3) => loop3(units, currentTimeMillis3)), unwrap);
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(throttled)));
};
var throttleShapeEffect = (self2, costFn, units, duration2, burst) => {
  const loop3 = (tokens, timestampMillis) => readWithCause({
    onInput: (input) => pipe(costFn(input), zip5(currentTimeMillis2), map16(([weight, currentTimeMillis3]) => {
      const elapsed2 = currentTimeMillis3 - timestampMillis;
      const cycles = elapsed2 / toMillis(duration2);
      const sum3 = tokens + cycles * units;
      const max5 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available = sum3 < 0 ? max5 : Math.min(sum3, max5);
      const remaining = available - weight;
      const waitCycles = remaining >= 0 ? 0 : -remaining / units;
      const delay3 = millis(Math.max(0, waitCycles * toMillis(duration2)));
      if (greaterThan2(delay3, zero)) {
        return pipe(fromEffect4(sleep2(delay3)), zipRight4(write(input)), flatMap13(() => loop3(remaining, currentTimeMillis3)));
      }
      return flatMap13(write(input), () => loop3(remaining, currentTimeMillis3));
    }), unwrap),
    onFailure: failCause10,
    onDone: () => void_5
  });
  const throttled = pipe(currentTimeMillis2, map16((currentTimeMillis3) => loop3(units, currentTimeMillis3)), unwrap);
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(throttled)));
};
var tick = (interval) => repeatWithSchedule(undefined, spaced2(interval));
var timeout3 = /* @__PURE__ */ dual(2, (self2, duration2) => pipe(toPull2(self2), map16(timeoutFail2({
  onTimeout: () => none2(),
  duration: duration2
})), fromPull2));
var timeoutFail3 = /* @__PURE__ */ dual(3, (self2, error, duration2) => pipe(self2, timeoutTo3(duration2, failSync7(error))));
var timeoutFailCause3 = /* @__PURE__ */ dual(3, (self2, cause3, duration2) => pipe(toPull2(self2), map16(timeoutFailCause2({
  onTimeout: () => map12(cause3(), some2),
  duration: duration2
})), fromPull2));
var timeoutTo3 = /* @__PURE__ */ dual(3, (self2, duration2, that) => {
  const StreamTimeout = new RuntimeException2("Stream Timeout");
  return pipe(self2, timeoutFailCause3(() => die4(StreamTimeout), duration2), catchSomeCause3((cause3) => isDieType2(cause3) && isRuntimeException2(cause3.defect) && cause3.defect.message !== undefined && cause3.defect.message === "Stream Timeout" ? some2(that) : none2()));
});
var pubsubFromOptions = (options) => {
  if (typeof options === "number") {
    return bounded4(options);
  } else if (options.capacity === "unbounded") {
    return unbounded4({
      replay: options.replay
    });
  }
  switch (options.strategy) {
    case "dropping":
      return dropping3(options);
    case "sliding":
      return sliding3(options);
    default:
      return bounded4(options);
  }
};
var toPubSub2 = /* @__PURE__ */ dual(2, (self2, capacity7) => pipe(acquireRelease2(pubsubFromOptions(capacity7), (pubsub) => shutdown3(pubsub)), tap3((pubsub) => pipe(self2, runIntoPubSubScoped(pubsub), forkScoped2))));
var toPull2 = (self2) => map16(toPull(toChannel2(self2)), (pull) => pipe(pull, mapError3(some2), flatMap11(match({
  onLeft: () => fail9(none2()),
  onRight: succeed8
}))));
var toQueue2 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => tap3(acquireRelease2(options?.strategy === "unbounded" ? unbounded5() : options?.strategy === "dropping" ? dropping4(options.capacity ?? 2) : options?.strategy === "sliding" ? sliding4(options.capacity ?? 2) : bounded5(options?.capacity ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped2(runIntoQueueScoped(self2, queue))));
var toQueueOfElements = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => tap3(acquireRelease2(bounded5(options?.capacity ?? 2), (queue) => shutdown4(queue)), (queue) => forkScoped2(runIntoQueueElementsScoped(self2, queue))));
var toReadableStream = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => toReadableStreamRuntime(self2, defaultRuntime2, options));
var toReadableStreamEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options) => map16(runtime3(), (runtime4) => toReadableStreamRuntime(self2, runtime4, options)));
var toReadableStreamRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, runtime4, options) => {
  const runFork4 = runFork3(runtime4);
  let currentResolve = undefined;
  let fiber = undefined;
  const latch = unsafeMakeLatch2(false);
  return new ReadableStream({
    start(controller) {
      fiber = runFork4(runForEachChunk(self2, (chunk3) => {
        if (chunk3.length === 0)
          return _void;
        return latch.whenOpen(sync3(() => {
          latch.unsafeClose();
          for (const item of chunk3) {
            controller.enqueue(item);
          }
          currentResolve();
          currentResolve = undefined;
        }));
      }));
      fiber.addObserver((exit3) => {
        try {
          if (exit3._tag === "Failure") {
            controller.error(squash(exit3.cause));
          } else {
            controller.close();
          }
        } catch {}
      });
    },
    pull() {
      return new Promise((resolve) => {
        currentResolve = resolve;
        runSync(latch.open);
      });
    },
    cancel() {
      if (!fiber)
        return;
      return runPromise(asVoid3(interrupt6(fiber)));
    }
  }, options?.strategy);
});
var transduce = /* @__PURE__ */ dual(2, (self2, sink) => {
  const newChannel = suspend5(() => {
    const leftovers = {
      ref: empty4()
    };
    const upstreamDone = {
      ref: false
    };
    const buffer2 = suspend5(() => {
      const leftover = leftovers.ref;
      if (isEmpty(leftover)) {
        return readWith({
          onInput: (input) => pipe(write(input), flatMap13(() => buffer2)),
          onFailure: fail11,
          onDone: succeedNow
        });
      }
      leftovers.ref = empty4();
      return pipe(writeChunk(leftover), flatMap13(() => buffer2));
    });
    const concatAndGet = (chunk3) => {
      const leftover = leftovers.ref;
      const concatenated = appendAll2(leftover, filter2(chunk3, (chunk4) => chunk4.length !== 0));
      leftovers.ref = concatenated;
      return concatenated;
    };
    const upstreamMarker = readWith({
      onInput: (input) => flatMap13(write(input), () => upstreamMarker),
      onFailure: fail11,
      onDone: (done11) => zipRight4(sync5(() => {
        upstreamDone.ref = true;
      }), succeedNow(done11))
    });
    const transducer = pipe(sink, toChannel, collectElements, flatMap13(([leftover, z]) => pipe(succeed10([upstreamDone.ref, concatAndGet(leftover)]), flatMap13(([done11, newLeftovers]) => {
      const nextChannel = done11 && isEmpty(newLeftovers) ? void_5 : transducer;
      return pipe(write(of2(z)), flatMap13(() => nextChannel));
    }))));
    return pipe(toChannel2(self2), pipeTo(upstreamMarker), pipeTo(buffer2), pipeToOrFail(transducer));
  });
  return new StreamImpl(newChannel);
});
var toAsyncIterableRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, runtime4) => {
  const runFork4 = runFork3(runtime4);
  return {
    [Symbol.asyncIterator]() {
      let currentResolve = undefined;
      let currentReject = undefined;
      let fiber = undefined;
      const latch = unsafeMakeLatch2(false);
      let returned = false;
      return {
        next() {
          if (!fiber) {
            fiber = runFork4(runForEach(self2, (value) => latch.whenOpen(sync3(() => {
              latch.unsafeClose();
              currentResolve({
                done: false,
                value
              });
              currentResolve = currentReject = undefined;
            }))));
            fiber.addObserver((exit3) => {
              if (returned)
                return;
              fiber = runFork2(latch.whenOpen(sync3(() => {
                if (exit3._tag === "Failure") {
                  currentReject(squash(exit3.cause));
                } else {
                  currentResolve({
                    done: true,
                    value: undefined
                  });
                }
                currentResolve = currentReject = undefined;
              })));
            });
          }
          return new Promise((resolve, reject) => {
            currentResolve = resolve;
            currentReject = reject;
            latch.unsafeOpen();
          });
        },
        return() {
          returned = true;
          if (!fiber)
            return Promise.resolve({
              done: true,
              value: undefined
            });
          return runPromise(as3(interrupt6(fiber), {
            done: true,
            value: undefined
          }));
        }
      };
    }
  };
});
var toAsyncIterable = (self2) => toAsyncIterableRuntime(self2, defaultRuntime2);
var toAsyncIterableEffect = (self2) => map16(runtime3(), (runtime4) => toAsyncIterableRuntime(self2, runtime4));
var unfold3 = (s, f) => unfoldChunk(s, (s2) => pipe(f(s2), map2(([a, s3]) => [of2(a), s3])));
var unfoldChunk = (s, f) => {
  const loop3 = (s2) => match2(f(s2), {
    onNone: () => void_5,
    onSome: ([chunk3, s3]) => flatMap13(write(chunk3), () => loop3(s3))
  });
  return new StreamImpl(suspend5(() => loop3(s)));
};
var unfoldChunkEffect = (s, f) => suspend9(() => {
  const loop3 = (s2) => unwrap(map16(f(s2), match2({
    onNone: () => void_5,
    onSome: ([chunk3, s3]) => flatMap13(write(chunk3), () => loop3(s3))
  })));
  return new StreamImpl(loop3(s));
});
var unfoldEffect = (s, f) => unfoldChunkEffect(s, (s2) => pipe(f(s2), map16(map2(([a, s3]) => [of2(a), s3]))));
var void_7 = /* @__PURE__ */ succeed14(undefined);
var unwrap2 = (effect4) => flatten13(fromEffect7(effect4));
var unwrapScoped4 = (effect4) => flatten13(scoped5(effect4));
var unwrapScopedWith3 = (f) => flatten13(scopedWith4((scope5) => f(scope5)));
var updateService4 = /* @__PURE__ */ dual(3, (self2, tag, f) => pipe(self2, mapInputContext5((context6) => pipe(context6, add2(tag, f(pipe(context6, unsafeGet3(tag))))))));
var when3 = /* @__PURE__ */ dual(2, (self2, test) => pipe(self2, whenEffect3(sync3(test))));
var whenCase = (evaluate2, pf) => whenCaseEffect(pf)(sync3(evaluate2));
var whenCaseEffect = /* @__PURE__ */ dual(2, (self2, pf) => pipe(fromEffect7(self2), flatMap16((a) => pipe(pf(a), getOrElse(() => empty29)))));
var whenEffect3 = /* @__PURE__ */ dual(2, (self2, effect4) => pipe(fromEffect7(effect4), flatMap16((bool) => bool ? self2 : empty29)));
var withSpan6 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return new StreamImpl(withSpan5(toChannel2(self2), name, options));
  }
  return (self2) => new StreamImpl(withSpan5(toChannel2(self2), name, options));
};
var zip7 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, zipWith10(that, (a, a2) => [a, a2])));
var zipFlatten = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, zipWith10(that, (a, a2) => [...a, a2])));
var zipAll = /* @__PURE__ */ dual(2, (self2, options) => zipAllWith(self2, {
  other: options.other,
  onSelf: (a) => [a, options.defaultOther],
  onOther: (a2) => [options.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2]
}));
var zipAllLeft = /* @__PURE__ */ dual(3, (self2, other, defaultSelf) => zipAllWith(self2, {
  other,
  onSelf: identity,
  onOther: () => defaultSelf,
  onBoth: (a) => a
}));
var zipAllRight = /* @__PURE__ */ dual(3, (self2, other, defaultRight) => zipAllWith(self2, {
  other,
  onSelf: () => defaultRight,
  onOther: identity,
  onBoth: (_, a2) => a2
}));
var zipAllSortedByKey = /* @__PURE__ */ dual(2, (self2, options) => zipAllSortedByKeyWith(self2, {
  other: options.other,
  onSelf: (a) => [a, options.defaultOther],
  onOther: (a2) => [options.defaultSelf, a2],
  onBoth: (a, a2) => [a, a2],
  order: options.order
}));
var zipAllSortedByKeyLeft = /* @__PURE__ */ dual(2, (self2, options) => zipAllSortedByKeyWith(self2, {
  other: options.other,
  onSelf: identity,
  onOther: () => options.defaultSelf,
  onBoth: (a) => a,
  order: options.order
}));
var zipAllSortedByKeyRight = /* @__PURE__ */ dual(2, (self2, options) => zipAllSortedByKeyWith(self2, {
  other: options.other,
  onSelf: () => options.defaultOther,
  onOther: identity,
  onBoth: (_, a2) => a2,
  order: options.order
}));
var zipAllSortedByKeyWith = /* @__PURE__ */ dual(2, (self2, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_DRAIN_LEFT: {
        return pipe(pullLeft, match12({
          onFailure: fail4,
          onSuccess: (leftChunk) => succeed3([map4(leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])
        }));
      }
      case OP_DRAIN_RIGHT: {
        return pipe(pullRight, match12({
          onFailure: fail4,
          onSuccess: (rightChunk) => succeed3([map4(rightChunk, ([k, a2]) => [k, options.onOther(a2)]), DrainRight])
        }));
      }
      case OP_PULL_BOTH: {
        return pipe(unsome(pullLeft), zip5(unsome(pullRight), {
          concurrent: true
        }), matchEffect2({
          onFailure: (error) => succeed8(fail4(some2(error))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed8(succeed3(merge10(leftOption.value, rightOption.value)));
            }
            if (isSome2(leftOption) && isNone2(rightOption)) {
              if (isEmpty(leftOption.value)) {
                return pull(DrainLeft, pullLeft, pullRight);
              }
              return succeed8(succeed3([pipe(leftOption.value, map4(([k, a]) => [k, options.onSelf(a)])), DrainLeft]));
            }
            if (isNone2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(rightOption.value)) {
                return pull(DrainRight, pullLeft, pullRight);
              }
              return succeed8(succeed3([pipe(rightOption.value, map4(([k, a2]) => [k, options.onOther(a2)])), DrainRight]));
            }
            return succeed8(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect2(pullLeft, {
          onFailure: match2({
            onNone: () => succeed8(succeed3([pipe(state.rightChunk, map4(([k, a2]) => [k, options.onOther(a2)])), DrainRight])),
            onSome: (error) => succeed8(fail4(some2(error)))
          }),
          onSuccess: (leftChunk) => isEmpty(leftChunk) ? pull(PullLeft(state.rightChunk), pullLeft, pullRight) : succeed8(succeed3(merge10(leftChunk, state.rightChunk)))
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect2(pullRight, {
          onFailure: match2({
            onNone: () => succeed8(succeed3([map4(state.leftChunk, ([k, a]) => [k, options.onSelf(a)]), DrainLeft])),
            onSome: (error) => succeed8(fail4(some2(error)))
          }),
          onSuccess: (rightChunk) => isEmpty(rightChunk) ? pull(PullRight(state.leftChunk), pullLeft, pullRight) : succeed8(succeed3(merge10(state.leftChunk, rightChunk)))
        });
      }
    }
  };
  const merge10 = (leftChunk, rightChunk) => {
    const hasNext = (chunk3, index) => index < chunk3.length - 1;
    const builder = [];
    let state = undefined;
    let leftIndex = 0;
    let rightIndex = 0;
    let leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
    let rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
    let k1 = leftTuple[0];
    let a = leftTuple[1];
    let k2 = rightTuple[0];
    let a2 = rightTuple[1];
    let loop3 = true;
    while (loop3) {
      const compare = options.order(k1, k2);
      if (compare === 0) {
        builder.push([k1, options.onBoth(a, a2)]);
        if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {
          leftIndex = leftIndex + 1;
          rightIndex = rightIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
          rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else if (hasNext(leftChunk, leftIndex)) {
          state = PullRight(pipe(leftChunk, drop2(leftIndex + 1)));
          loop3 = false;
        } else if (hasNext(rightChunk, rightIndex)) {
          state = PullLeft(pipe(rightChunk, drop2(rightIndex + 1)));
          loop3 = false;
        } else {
          state = PullBoth;
          loop3 = false;
        }
      } else if (compare < 0) {
        builder.push([k1, options.onSelf(a)]);
        if (hasNext(leftChunk, leftIndex)) {
          leftIndex = leftIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
        } else {
          const rightBuilder = [];
          rightBuilder.push(rightTuple);
          while (hasNext(rightChunk, rightIndex)) {
            rightIndex = rightIndex + 1;
            rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
            rightBuilder.push(rightTuple);
          }
          state = PullLeft(unsafeFromArray(rightBuilder));
          loop3 = false;
        }
      } else {
        builder.push([k2, options.onOther(a2)]);
        if (hasNext(rightChunk, rightIndex)) {
          rightIndex = rightIndex + 1;
          rightTuple = pipe(rightChunk, unsafeGet4(rightIndex));
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else {
          const leftBuilder = [];
          leftBuilder.push(leftTuple);
          while (hasNext(leftChunk, leftIndex)) {
            leftIndex = leftIndex + 1;
            leftTuple = pipe(leftChunk, unsafeGet4(leftIndex));
            leftBuilder.push(leftTuple);
          }
          state = PullRight(unsafeFromArray(leftBuilder));
          loop3 = false;
        }
      }
    }
    return [unsafeFromArray(builder), state];
  };
  return combineChunks(self2, options.other, PullBoth, pull);
});
var zipAllWith = /* @__PURE__ */ dual(2, (self2, options) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_DRAIN_LEFT: {
        return matchEffect2(pullLeft, {
          onFailure: (error) => succeed8(fail4(error)),
          onSuccess: (leftChunk) => succeed8(succeed3([map4(leftChunk, options.onSelf), DrainLeft]))
        });
      }
      case OP_DRAIN_RIGHT: {
        return matchEffect2(pullRight, {
          onFailure: (error) => succeed8(fail4(error)),
          onSuccess: (rightChunk) => succeed8(succeed3([map4(rightChunk, options.onOther), DrainRight]))
        });
      }
      case OP_PULL_BOTH: {
        return pipe(unsome(pullLeft), zip5(unsome(pullRight), {
          concurrent: true
        }), matchEffect2({
          onFailure: (error) => succeed8(fail4(some2(error))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed8(succeed3(zip8(leftOption.value, rightOption.value, options.onBoth)));
            }
            if (isSome2(leftOption) && isNone2(rightOption)) {
              return succeed8(succeed3([map4(leftOption.value, options.onSelf), DrainLeft]));
            }
            if (isNone2(leftOption) && isSome2(rightOption)) {
              return succeed8(succeed3([map4(rightOption.value, options.onOther), DrainRight]));
            }
            return succeed8(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect2(pullLeft, {
          onFailure: match2({
            onNone: () => succeed8(succeed3([map4(state.rightChunk, options.onOther), DrainRight])),
            onSome: (error) => succeed8(fail4(some2(error)))
          }),
          onSuccess: (leftChunk) => {
            if (isEmpty(leftChunk)) {
              return pull(PullLeft(state.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.rightChunk)) {
              return pull(PullRight(leftChunk), pullLeft, pullRight);
            }
            return succeed8(succeed3(zip8(leftChunk, state.rightChunk, options.onBoth)));
          }
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect2(pullRight, {
          onFailure: match2({
            onNone: () => succeed8(succeed3([map4(state.leftChunk, options.onSelf), DrainLeft])),
            onSome: (error) => succeed8(fail4(some2(error)))
          }),
          onSuccess: (rightChunk) => {
            if (isEmpty(rightChunk)) {
              return pull(PullRight(state.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.leftChunk)) {
              return pull(PullLeft(rightChunk), pullLeft, pullRight);
            }
            return succeed8(succeed3(zip8(state.leftChunk, rightChunk, options.onBoth)));
          }
        });
      }
    }
  };
  const zip8 = (leftChunk, rightChunk, f) => {
    const [output, either6] = zipChunks(leftChunk, rightChunk, f);
    switch (either6._tag) {
      case "Left": {
        if (isEmpty(either6.left)) {
          return [output, PullBoth];
        }
        return [output, PullRight(either6.left)];
      }
      case "Right": {
        if (isEmpty(either6.right)) {
          return [output, PullBoth];
        }
        return [output, PullLeft(either6.right)];
      }
    }
  };
  return combineChunks(self2, options.other, PullBoth, pull);
});
var zipLatest = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipLatestWith(right3, (a, a2) => [a, a2])));
var zipLatestAll = (...streams) => {
  if (streams.length === 0) {
    return empty29;
  } else if (streams.length === 1) {
    return map21(streams[0], (x) => [x]);
  }
  const [head6, ...tail] = streams;
  return zipLatestWith(head6, zipLatestAll(...tail), (first, second) => [first, ...second]);
};
var zipLatestWith = /* @__PURE__ */ dual(3, (left3, right3, f) => {
  const pullNonEmpty = (pull) => pipe(pull, flatMap11((chunk3) => isEmpty(chunk3) ? pullNonEmpty(pull) : succeed8(chunk3)));
  return pipe(toPull2(left3), map16(pullNonEmpty), zip5(pipe(toPull2(right3), map16(pullNonEmpty))), flatMap11(([left4, right4]) => pipe(fromEffectOption(raceWith2(left4, right4, {
    onSelfDone: (leftDone, rightFiber) => pipe(suspend3(() => leftDone), zipWith5(join3(rightFiber), (l, r) => [l, r, true])),
    onOtherDone: (rightDone, leftFiber) => pipe(suspend3(() => rightDone), zipWith5(join3(leftFiber), (l, r) => [r, l, false]))
  })), flatMap16(([l, r, leftFirst]) => pipe(fromEffect7(make28([unsafeLast(l), unsafeLast(r)])), flatMap16((latest) => pipe(fromChunk(leftFirst ? pipe(r, map4((a2) => f(unsafeLast(l), a2))) : pipe(l, map4((a) => f(a, unsafeLast(r))))), concat2(pipe(repeatEffectOption(left4), mergeEither(repeatEffectOption(right4)), mapEffectSequential(match({
    onLeft: (leftChunk) => modify4(latest, ([_, rightLatest]) => [pipe(leftChunk, map4((a) => f(a, rightLatest))), [unsafeLast(leftChunk), rightLatest]]),
    onRight: (rightChunk) => modify4(latest, ([leftLatest, _]) => [pipe(rightChunk, map4((a2) => f(leftLatest, a2))), [leftLatest, unsafeLast(rightChunk)]])
  })), flatMap16(fromChunk))))))), toPull2)), fromPull2);
});
var zipLeft5 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
  if (left4.length > right4.length) {
    return [pipe(left4, take(right4.length)), left2(pipe(left4, take(right4.length)))];
  }
  return [left4, right2(pipe(right4, drop2(left4.length)))];
})));
var zipRight8 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
  if (left4.length > right4.length) {
    return [right4, left2(pipe(left4, take(right4.length)))];
  }
  return [pipe(right4, take(left4.length)), right2(pipe(right4, drop2(left4.length)))];
})));
var zipWith10 = /* @__PURE__ */ dual(3, (left3, right3, f) => pipe(left3, zipWithChunks(right3, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f))));
var zipWithChunks = /* @__PURE__ */ dual(3, (self2, that, f) => {
  const pull = (state, pullLeft, pullRight) => {
    switch (state._tag) {
      case OP_PULL_BOTH2: {
        return pipe(unsome(pullLeft), zip5(unsome(pullRight), {
          concurrent: true
        }), matchEffect2({
          onFailure: (error) => succeed8(fail4(some2(error))),
          onSuccess: ([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth2, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft2(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight2(leftOption.value), pullLeft, pullRight);
              }
              return succeed8(succeed3(zip8(leftOption.value, rightOption.value)));
            }
            return succeed8(fail4(none2()));
          }
        }));
      }
      case OP_PULL_LEFT2: {
        return matchEffect2(pullLeft, {
          onFailure: (error) => succeed8(fail4(error)),
          onSuccess: (leftChunk) => {
            if (isEmpty(leftChunk)) {
              return pull(PullLeft2(state.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.rightChunk)) {
              return pull(PullRight2(leftChunk), pullLeft, pullRight);
            }
            return succeed8(succeed3(zip8(leftChunk, state.rightChunk)));
          }
        });
      }
      case OP_PULL_RIGHT2: {
        return matchEffect2(pullRight, {
          onFailure: (error) => succeed8(fail4(error)),
          onSuccess: (rightChunk) => {
            if (isEmpty(rightChunk)) {
              return pull(PullRight2(state.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty(state.leftChunk)) {
              return pull(PullLeft2(rightChunk), pullLeft, pullRight);
            }
            return succeed8(succeed3(zip8(state.leftChunk, rightChunk)));
          }
        });
      }
    }
  };
  const zip8 = (leftChunk, rightChunk) => {
    const [output, either6] = f(leftChunk, rightChunk);
    switch (either6._tag) {
      case "Left": {
        if (isEmpty(either6.left)) {
          return [output, PullBoth2];
        }
        return [output, PullRight2(either6.left)];
      }
      case "Right": {
        if (isEmpty(either6.right)) {
          return [output, PullBoth2];
        }
        return [output, PullLeft2(either6.right)];
      }
    }
  };
  return pipe(self2, combineChunks(that, PullBoth2, pull));
});
var zipWithIndex = (self2) => pipe(self2, mapAccum5(0, (index, a) => [index + 1, [a, index]]));
var zipWithNext = (self2) => {
  const process2 = (last4) => readWithCause({
    onInput: (input) => {
      const [newLast, chunk3] = mapAccum2(input, last4, (prev, curr) => [some2(curr), pipe(prev, map2((a) => [a, curr]))]);
      const output = filterMap2(chunk3, (option3) => isSome2(option3) ? some2([option3.value[0], some2(option3.value[1])]) : none2());
      return flatMap13(write(output), () => process2(newLast));
    },
    onFailure: failCause10,
    onDone: () => match2(last4, {
      onNone: () => void_5,
      onSome: (value) => zipRight4(write(of2([value, none2()])), void_5)
    })
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(process2(none2()))));
};
var zipWithPrevious = (self2) => pipe(self2, mapAccum5(none2(), (prev, curr) => [some2(curr), [prev, curr]]));
var zipWithPreviousAndNext = (self2) => pipe(zipWithNext(zipWithPrevious(self2)), map21(([[prev, curr], next]) => [prev, curr, pipe(next, map2((tuple) => tuple[1]))]));
var zipChunks = (left3, right3, f) => {
  if (left3.length > right3.length) {
    return [pipe(left3, take(right3.length), zipWith2(right3, f)), left2(pipe(left3, drop2(right3.length)))];
  }
  return [pipe(left3, zipWith2(pipe(right3, take(left3.length)), f)), right2(pipe(right3, drop2(left3.length)))];
};
var Do3 = /* @__PURE__ */ succeed14({});
var bind4 = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self2, tag, f, options) => flatMap16(self2, (k) => map21(f(k), (a) => ({
  ...k,
  [tag]: a
})), options));
var bindTo4 = /* @__PURE__ */ bindTo(map21);
var let_4 = /* @__PURE__ */ let_(map21);
var decodeText = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, encoding = "utf-8") => suspend9(() => {
  const decoder = new TextDecoder(encoding);
  return map21(self2, (s) => decoder.decode(s));
}));
var encodeText = (self2) => suspend9(() => {
  const encoder = new TextEncoder;
  return map21(self2, (s) => encoder.encode(s));
});
var fromEventListener = (target, type, options) => asyncPush((emit2) => acquireRelease2(sync3(() => target.addEventListener(type, emit2.single, options)), () => sync3(() => target.removeEventListener(type, emit2.single, options))), {
  bufferSize: typeof options === "object" ? options.bufferSize : undefined
});
// node_modules/effect/dist/esm/internal/groupBy.js
var GroupBySymbolKey = "effect/GroupBy";
var GroupByTypeId = /* @__PURE__ */ Symbol.for(GroupBySymbolKey);
var groupByVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _K: (_) => _,
  _V: (_) => _
};
var isGroupBy = (u) => hasProperty(u, GroupByTypeId);
var evaluate2 = /* @__PURE__ */ dual((args2) => isGroupBy(args2[0]), (self2, f, options) => flatMap16(self2.grouped, ([key, queue]) => f(key, flattenTake(fromQueue2(queue, {
  shutdown: true
}))), {
  concurrency: "unbounded",
  bufferSize: options?.bufferSize ?? 16
}));
var make51 = (grouped2) => ({
  [GroupByTypeId]: groupByVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  grouped: grouped2
});
var groupBy = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, f, options) => make51(unwrapScoped4(gen2(function* () {
  const decider = yield* make18();
  const output = yield* acquireRelease2(bounded5(options?.bufferSize ?? 16), (queue) => shutdown4(queue));
  const ref = yield* make28(new Map);
  const add5 = yield* pipe(mapEffectSequential(self2, f), distributedWithDynamicCallback(options?.bufferSize ?? 16, ([key, value]) => flatMap11(_await(decider), (f2) => f2(key, value)), (exit3) => offer3(output, exit3)));
  yield* succeed2(decider, (key, _) => pipe(get12(ref), map16((map22) => fromNullable(map22.get(key))), flatMap11(match2({
    onNone: () => flatMap11(add5, ([index, queue]) => zipRight3(update3(ref, (map22) => map22.set(key, index)), pipe(offer3(output, succeed3([key, mapDequeue(queue, (exit3) => new TakeImpl(pipe(exit3, map11((tuple) => of2(tuple[1])))))])), as3((n) => n === index)))),
    onSome: (index) => succeed8((n) => n === index)
  }))));
  return flattenExitOption(fromQueue2(output, {
    shutdown: true
  }));
}))));
var mapEffectOptions = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self2, f, options) => {
  if (options?.key) {
    return evaluate2(groupByKey(self2, options.key, {
      bufferSize: options.bufferSize
    }), (_, s) => mapEffectSequential(s, f));
  }
  return matchConcurrency(options?.concurrency, () => mapEffectSequential(self2, f), (n) => options?.unordered ? flatMap16(self2, (a) => fromEffect7(f(a)), {
    concurrency: n
  }) : mapEffectPar(self2, n, f));
});
var bindEffect = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self2, tag, f, options) => mapEffectOptions(self2, (k) => map16(f(k), (a) => ({
  ...k,
  [tag]: a
})), options));
var mapDequeue = (dequeue, f) => new MapDequeue(dequeue, f);

class MapDequeue extends Class {
  dequeue;
  f;
  [DequeueTypeId2] = {
    _Out: (_) => _
  };
  constructor(dequeue, f) {
    super();
    this.dequeue = dequeue;
    this.f = f;
  }
  capacity() {
    return capacity4(this.dequeue);
  }
  get size() {
    return size10(this.dequeue);
  }
  unsafeSize() {
    return this.dequeue.unsafeSize();
  }
  get awaitShutdown() {
    return awaitShutdown3(this.dequeue);
  }
  isActive() {
    return this.dequeue.isActive();
  }
  get isShutdown() {
    return isShutdown3(this.dequeue);
  }
  get shutdown() {
    return shutdown4(this.dequeue);
  }
  get isFull() {
    return isFull3(this.dequeue);
  }
  get isEmpty() {
    return isEmpty12(this.dequeue);
  }
  get take() {
    return pipe(take3(this.dequeue), map16((a) => this.f(a)));
  }
  get takeAll() {
    return pipe(takeAll2(this.dequeue), map16(map4((a) => this.f(a))));
  }
  takeUpTo(max5) {
    return pipe(takeUpTo2(this.dequeue, max5), map16(map4((a) => this.f(a))));
  }
  takeBetween(min3, max5) {
    return pipe(takeBetween2(this.dequeue, min3, max5), map16(map4((a) => this.f(a))));
  }
  takeN(n) {
    return pipe(takeN2(this.dequeue, n), map16(map4((a) => this.f(a))));
  }
  poll() {
    return pipe(poll6(this.dequeue), map16(map2((a) => this.f(a))));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
}
var groupByKey = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self2, f, options) => {
  const loop3 = (map22, outerQueue) => readWithCause({
    onInput: (input) => flatMap13(fromEffect4(forEach6(groupByIterable(input, f), ([key, values3]) => {
      const innerQueue = map22.get(key);
      if (innerQueue === undefined) {
        return pipe(bounded5(options?.bufferSize ?? 16), flatMap11((innerQueue2) => pipe(sync3(() => {
          map22.set(key, innerQueue2);
        }), zipRight3(offer3(outerQueue, of5([key, innerQueue2]))), zipRight3(pipe(offer3(innerQueue2, chunk2(values3)), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2()))))));
      }
      return catchSomeCause2(offer3(innerQueue, chunk2(values3)), (cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2());
    }, {
      discard: true
    })), () => loop3(map22, outerQueue)),
    onFailure: (cause3) => fromEffect4(offer3(outerQueue, failCause11(cause3))),
    onDone: () => fromEffect4(pipe(forEach6(map22.entries(), ([_, innerQueue]) => pipe(offer3(innerQueue, end4), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some2(_void) : none2())), {
      discard: true
    }), zipRight3(offer3(outerQueue, end4))))
  });
  return make51(unwrapScopedWith3((scope5) => gen2(function* () {
    const map22 = new Map;
    const queue = yield* unbounded5();
    yield* addFinalizer2(scope5, shutdown4(queue));
    return yield* toChannel2(self2).pipe(pipeTo(loop3(map22, queue)), drain, runIn(scope5), forkIn2(scope5), as3(flattenTake(fromQueue2(queue, {
      shutdown: true
    }))));
  })));
});
var groupByIterable = /* @__PURE__ */ dual(2, (iterable, f) => {
  const builder = [];
  const iterator = iterable[Symbol.iterator]();
  const map22 = new Map;
  let next;
  while ((next = iterator.next()) && !next.done) {
    const value = next.value;
    const key = f(value);
    if (map22.has(key)) {
      const innerBuilder = map22.get(key);
      innerBuilder.push(value);
    } else {
      const innerBuilder = [value];
      builder.push([key, innerBuilder]);
      map22.set(key, innerBuilder);
    }
  }
  return unsafeFromArray(builder.map((tuple) => [tuple[0], unsafeFromArray(tuple[1])]));
});
// node_modules/effect/dist/esm/ParseResult.js
class Pointer {
  path;
  actual;
  issue;
  _tag = "Pointer";
  constructor(path, actual, issue) {
    this.path = path;
    this.actual = actual;
    this.issue = issue;
  }
}

class Unexpected {
  actual;
  message;
  _tag = "Unexpected";
  constructor(actual, message) {
    this.actual = actual;
    this.message = message;
  }
}

class Missing {
  ast;
  message;
  _tag = "Missing";
  actual = undefined;
  constructor(ast, message) {
    this.ast = ast;
    this.message = message;
  }
}

class Composite2 {
  ast;
  actual;
  issues;
  output;
  _tag = "Composite";
  constructor(ast, actual, issues, output) {
    this.ast = ast;
    this.actual = actual;
    this.issues = issues;
    this.output = output;
  }
}

class Refinement2 {
  ast;
  actual;
  kind;
  issue;
  _tag = "Refinement";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
}

class Transformation2 {
  ast;
  actual;
  kind;
  issue;
  _tag = "Transformation";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
}

class Type2 {
  ast;
  actual;
  message;
  _tag = "Type";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
}

class Forbidden {
  ast;
  actual;
  message;
  _tag = "Forbidden";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
}
var ParseErrorTypeId = /* @__PURE__ */ Symbol.for("effect/Schema/ParseErrorTypeId");
class ParseError extends (/* @__PURE__ */ TaggedError("ParseError")) {
  [ParseErrorTypeId] = ParseErrorTypeId;
  get message() {
    return this.toString();
  }
  toString() {
    return TreeFormatter.formatIssueSync(this.issue);
  }
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}
var parseError = (issue) => new ParseError({
  issue
});
var succeed15 = right2;
var fail16 = left2;
var isEither4 = isEither2;
var flatMap17 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither4(self2) ? match(self2, {
    onLeft: left2,
    onRight: f
  }) : flatMap11(self2, f);
});
var map22 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither4(self2) ? map(self2, f) : map16(self2, f);
});
var mapError7 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither4(self2) ? mapLeft(self2, f) : mapError3(self2, f);
});
var orElse9 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither4(self2) ? match(self2, {
    onLeft: f,
    onRight: right2
  }) : catchAll3(self2, f);
});
var mergeInternalOptions = (options, overrideOptions) => {
  if (overrideOptions === undefined || isNumber(overrideOptions)) {
    return options;
  }
  if (options === undefined) {
    return overrideOptions;
  }
  return {
    ...options,
    ...overrideOptions
  };
};
var getEither = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (u, overrideOptions) => parser(u, mergeInternalOptions(options, overrideOptions));
};
var getSync = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError);
};
var getEffect = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (input, overrideOptions) => parser(input, {
    ...mergeInternalOptions(options, overrideOptions),
    isEffectAllowed: true
  });
};
var decodeUnknownSync = (schema, options) => getSync(schema.ast, true, options);
var encodeUnknownSync = (schema, options) => getSync(schema.ast, false, options);
var encodeUnknown = (schema, options) => getEffect(schema.ast, false, options);
var validateSync = (schema, options) => getSync(typeAST(schema.ast), true, options);
var is = (schema, options) => {
  const parser = goMemo(typeAST(schema.ast), true);
  return (u, overrideOptions) => isRight2(parser(u, {
    exact: true,
    ...mergeInternalOptions(options, overrideOptions)
  }));
};
var encodeSync = encodeUnknownSync;
var decodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/decodeMemoMap"), () => new WeakMap);
var encodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/encodeMemoMap"), () => new WeakMap);
var goMemo = (ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
  const memo = memoMap.get(ast);
  if (memo) {
    return memo;
  }
  const raw = go(ast, isDecoding);
  const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
  const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i, options) => raw(i, mergeInternalOptions(options, parseOptionsAnnotation.value)) : raw;
  const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
  const parser = isDecoding && isSome2(decodingFallbackAnnotation) ? (i, options) => handleForbidden(orElse9(parserWithOptions(i, options), decodingFallbackAnnotation.value), ast, i, options) : parserWithOptions;
  memoMap.set(ast, parser);
  return parser;
};
var getConcurrency = (ast) => getOrUndefined(getConcurrencyAnnotation(ast));
var getBatching = (ast) => getOrUndefined(getBatchingAnnotation(ast));
var go = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement": {
      if (isDecoding) {
        const from = goMemo(ast.from, true);
        return (i, options) => {
          options = options ?? defaultParseOption;
          const allErrors = options?.errors === "all";
          const result = flatMap17(orElse9(from(i, options), (ef) => {
            const issue = new Refinement2(ast, i, "From", ef);
            if (allErrors && hasStableFilter(ast) && isComposite2(ef)) {
              return match2(ast.filter(i, options, ast), {
                onNone: () => left2(issue),
                onSome: (ep) => left2(new Composite2(ast, i, [issue, new Refinement2(ast, i, "Predicate", ep)]))
              });
            }
            return left2(issue);
          }), (a) => match2(ast.filter(a, options, ast), {
            onNone: () => right2(a),
            onSome: (ep) => left2(new Refinement2(ast, i, "Predicate", ep))
          }));
          return handleForbidden(result, ast, i, options);
        };
      } else {
        const from = goMemo(typeAST(ast), true);
        const to = goMemo(dropRightRefinement(ast.from), false);
        return (i, options) => handleForbidden(flatMap17(from(i, options), (a) => to(a, options)), ast, i, options);
      }
    }
    case "Transformation": {
      const transform2 = getFinalTransformation(ast.transformation, isDecoding);
      const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
      const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
      return (i, options) => handleForbidden(flatMap17(mapError7(from(i, options), (e) => new Transformation2(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap17(mapError7(transform2(a, options ?? defaultParseOption, ast, i), (e) => new Transformation2(ast, i, "Transformation", e)), (i2) => mapError7(to(i2, options), (e) => new Transformation2(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options);
    }
    case "Declaration": {
      const parse = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
      return (i, options) => handleForbidden(parse(i, options ?? defaultParseOption, ast), ast, i, options);
    }
    case "Literal":
      return fromRefinement(ast, (u) => u === ast.literal);
    case "UniqueSymbol":
      return fromRefinement(ast, (u) => u === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement(ast, isUndefined);
    case "NeverKeyword":
      return fromRefinement(ast, isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
    case "VoidKeyword":
      return right2;
    case "StringKeyword":
      return fromRefinement(ast, isString);
    case "NumberKeyword":
      return fromRefinement(ast, isNumber);
    case "BooleanKeyword":
      return fromRefinement(ast, isBoolean);
    case "BigIntKeyword":
      return fromRefinement(ast, isBigInt);
    case "SymbolKeyword":
      return fromRefinement(ast, isSymbol);
    case "ObjectKeyword":
      return fromRefinement(ast, isObject);
    case "Enums":
      return fromRefinement(ast, (u) => ast.enums.some(([_, value]) => value === u));
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp(ast);
      return fromRefinement(ast, (u) => isString(u) && regex.test(u));
    }
    case "TupleType": {
      const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
      const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
      let requiredTypes = ast.elements.filter((e) => !e.isOptional);
      if (ast.rest.length > 0) {
        requiredTypes = requiredTypes.concat(ast.rest.slice(1));
      }
      const requiredLen = requiredTypes.length;
      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options) => {
        if (!isArray(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const output = [];
        const len = input.length;
        for (let i2 = len;i2 <= requiredLen - 1; i2++) {
          const e = new Pointer(i2, input, new Missing(requiredTypes[i2 - len]));
          if (allErrors) {
            es.push([stepKey++, e]);
            continue;
          } else {
            return left2(new Composite2(ast, input, e, output));
          }
        }
        if (ast.rest.length === 0) {
          for (let i2 = ast.elements.length;i2 <= len - 1; i2++) {
            const e = new Pointer(i2, input, new Unexpected(input[i2], `is unexpected, expected: ${expectedIndexes}`));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite2(ast, input, e, output));
            }
          }
        }
        let i = 0;
        let queue = undefined;
        for (;i < elements.length; i++) {
          if (len < i + 1) {
            if (ast.elements[i].isOptional) {
              continue;
            }
          } else {
            const parser = elements[i];
            const te = parser(input[i], options);
            if (isEither4(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              }
              output.push([stepKey++, te.right]);
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap11(either3(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                }
                output2.push([nk, t.right]);
                return _void;
              }));
            }
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head6, ...tail] = rest;
          for (;i < len - tail.length; i++) {
            const te = head6(input[i], options);
            if (isEither4(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              } else {
                output.push([stepKey++, te.right]);
              }
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap11(either3(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                } else {
                  output2.push([nk, t.right]);
                  return _void;
                }
              }));
            }
          }
          for (let j = 0;j < tail.length; j++) {
            i += j;
            if (len < i + 1) {
              continue;
            } else {
              const te = tail[j](input[i], options);
              if (isEither4(te)) {
                if (isLeft2(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output)));
                  }
                }
                output.push([stepKey++, te.right]);
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap11(either3(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                    }
                  }
                  output2.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => isNonEmptyArray2(es2) ? left2(new Composite2(ast, input, sortByIndex(es2), sortByIndex(output2))) : right2(sortByIndex(output2));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es),
              output: copy(output)
            };
            return flatMap11(forEach6(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          output,
          es
        });
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return fromRefinement(ast, isNotNullable);
      }
      const propertySignatures = [];
      const expectedKeysMap = {};
      const expectedKeys = [];
      for (const ps of ast.propertySignatures) {
        propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
        expectedKeysMap[ps.name] = null;
        expectedKeys.push(ps.name);
      }
      const indexSignatures = ast.indexSignatures.map((is2) => [goMemo(is2.parameter, isDecoding), goMemo(is2.type, isDecoding), is2.parameter]);
      const expectedAST = Union.make(ast.indexSignatures.map((is2) => is2.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal(key))));
      const expected = goMemo(expectedAST, isDecoding);
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options) => {
        if (!isRecord(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const onExcessPropertyError = options?.onExcessProperty === "error";
        const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
        const output = {};
        let inputKeys;
        if (onExcessPropertyError || onExcessPropertyPreserve) {
          inputKeys = Reflect.ownKeys(input);
          for (const key of inputKeys) {
            const te = expected(key, options);
            if (isEither4(te) && isLeft2(te)) {
              if (onExcessPropertyError) {
                const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output));
                }
              } else {
                output[key] = input[key];
              }
            }
          }
        }
        let queue = undefined;
        const isExact = options?.exact === true;
        for (let i = 0;i < propertySignatures.length; i++) {
          const ps = propertySignatures[i][1];
          const name = ps.name;
          const hasKey = Object.prototype.hasOwnProperty.call(input, name);
          if (!hasKey) {
            if (ps.isOptional) {
              continue;
            } else if (isExact) {
              const e = new Pointer(name, input, new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
          }
          const parser = propertySignatures[i][0];
          const te = parser(input[name], options);
          if (isEither4(te)) {
            if (isLeft2(te)) {
              const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
            output[name] = te.right;
          } else {
            const nk = stepKey++;
            const index = name;
            if (!queue) {
              queue = [];
            }
            queue.push(({
              es: es2,
              output: output2
            }) => flatMap11(either3(te), (t) => {
              if (isLeft2(t)) {
                const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps));
                if (allErrors) {
                  es2.push([nk, e]);
                  return _void;
                } else {
                  return left2(new Composite2(ast, input, e, output2));
                }
              }
              output2[index] = t.right;
              return _void;
            }));
          }
        }
        for (let i = 0;i < indexSignatures.length; i++) {
          const indexSignature = indexSignatures[i];
          const parameter = indexSignature[0];
          const type = indexSignature[1];
          const keys3 = getKeysForIndexSignature(input, indexSignature[2]);
          for (const key of keys3) {
            const keu = parameter(key, options);
            if (isEither4(keu) && isRight2(keu)) {
              const vpr = type(input[key], options);
              if (isEither4(vpr)) {
                if (isLeft2(vpr)) {
                  const e = new Pointer(key, input, vpr.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, output));
                  }
                } else {
                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                    output[key] = vpr.right;
                  }
                }
              } else {
                const nk = stepKey++;
                const index = key;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap11(either3(vpr), (tv) => {
                  if (isLeft2(tv)) {
                    const e = new Pointer(index, input, tv.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, output2));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output2[key] = tv.right;
                    }
                    return _void;
                  }
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => {
          if (isNonEmptyArray2(es2)) {
            return left2(new Composite2(ast, input, sortByIndex(es2), output2));
          }
          if (options?.propertyOrder === "original") {
            const keys3 = inputKeys || Reflect.ownKeys(input);
            for (const name of expectedKeys) {
              if (keys3.indexOf(name) === -1) {
                keys3.push(name);
              }
            }
            const out = {};
            for (const key of keys3) {
              if (Object.prototype.hasOwnProperty.call(output2, key)) {
                out[key] = output2[key];
              }
            }
            return right2(out);
          }
          return right2(output2);
        };
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es),
              output: Object.assign({}, output)
            };
            return flatMap11(forEach6(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          es,
          output
        });
      };
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, isDecoding);
      const ownKeys = Reflect.ownKeys(searchTree.keys);
      const ownKeysLen = ownKeys.length;
      const astTypesLen = ast.types.length;
      const map23 = new Map;
      for (let i = 0;i < astTypesLen; i++) {
        map23.set(ast.types[i], goMemo(ast.types[i], isDecoding));
      }
      const concurrency = getConcurrency(ast) ?? 1;
      const batching = getBatching(ast);
      return (input, options) => {
        const es = [];
        let stepKey = 0;
        let candidates = [];
        if (ownKeysLen > 0) {
          if (isRecordOrArray(input)) {
            for (let i = 0;i < ownKeysLen; i++) {
              const name = ownKeys[i];
              const buckets = searchTree.keys[name].buckets;
              if (Object.prototype.hasOwnProperty.call(input, name)) {
                const literal = String(input[name]);
                if (Object.prototype.hasOwnProperty.call(buckets, literal)) {
                  candidates = candidates.concat(buckets[literal]);
                } else {
                  const {
                    candidates: candidates2,
                    literals
                  } = searchTree.keys[name];
                  const literalsUnion = Union.make(literals);
                  const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([new PropertySignature(name, literalsUnion, false, true)], []) : Union.make(candidates2);
                  es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Type2(literalsUnion, input[name])))]);
                }
              } else {
                const {
                  candidates: candidates2,
                  literals
                } = searchTree.keys[name];
                const fakePropertySignature = new PropertySignature(name, Union.make(literals), false, true);
                const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates2);
                es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
              }
            }
          } else {
            const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
            es.push([stepKey++, new Type2(errorAst, input)]);
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        let queue = undefined;
        for (let i = 0;i < candidates.length; i++) {
          const candidate = candidates[i];
          const pr = map23.get(candidate)(input, options);
          if (isEither4(pr) && (!queue || queue.length === 0)) {
            if (isRight2(pr)) {
              return pr;
            } else {
              es.push([stepKey++, pr.left]);
            }
          } else {
            const nk = stepKey++;
            if (!queue) {
              queue = [];
            }
            queue.push((state) => suspend3(() => {
              if ("finalResult" in state) {
                return _void;
              } else {
                return flatMap11(either3(pr), (t) => {
                  if (isRight2(t)) {
                    state.finalResult = t;
                  } else {
                    state.es.push([nk, t.left]);
                  }
                  return _void;
                });
              }
            }));
          }
        }
        const computeResult = (es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite2(ast, input, sortByIndex(es2))) : left2(new Type2(ast, input));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es)
            };
            return flatMap11(forEach6(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => {
              if ("finalResult" in state) {
                return state.finalResult;
              }
              return computeResult(state.es);
            });
          });
        }
        return computeResult(es);
      };
    }
    case "Suspend": {
      const get17 = memoizeThunk(() => goMemo(ast.f(), isDecoding));
      return (a, options) => get17()(a, options);
    }
  }
};
var fromRefinement = (ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type2(ast, u));
var getLiterals = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return getLiterals(annotation.value, isDecoding);
      }
      break;
    }
    case "TypeLiteral": {
      const out = [];
      for (let i = 0;i < ast.propertySignatures.length; i++) {
        const propertySignature = ast.propertySignatures[i];
        const type = isDecoding ? encodedAST(propertySignature.type) : typeAST(propertySignature.type);
        if (isLiteral(type) && !propertySignature.isOptional) {
          out.push([propertySignature.name, type]);
        }
      }
      return out;
    }
    case "TupleType": {
      const out = [];
      for (let i = 0;i < ast.elements.length; i++) {
        const element = ast.elements[i];
        const type = isDecoding ? encodedAST(element.type) : typeAST(element.type);
        if (isLiteral(type) && !element.isOptional) {
          out.push([i, type]);
        }
      }
      return out;
    }
    case "Refinement":
      return getLiterals(ast.from, isDecoding);
    case "Suspend":
      return getLiterals(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
};
var getSearchTree = (members, isDecoding) => {
  const keys3 = {};
  const otherwise = [];
  const candidates = [];
  for (let i = 0;i < members.length; i++) {
    const member = members[i];
    const tags = getLiterals(member, isDecoding);
    if (tags.length > 0) {
      candidates.push(member);
      for (let j = 0;j < tags.length; j++) {
        const [key, literal] = tags[j];
        const hash2 = String(literal.literal);
        keys3[key] = keys3[key] || {
          buckets: {},
          literals: [],
          candidates: []
        };
        const buckets = keys3[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash2)) {
          if (j < tags.length - 1) {
            continue;
          }
          buckets[hash2].push(member);
          keys3[key].literals.push(literal);
          keys3[key].candidates.push(member);
        } else {
          buckets[hash2] = [member];
          keys3[key].literals.push(literal);
          keys3[key].candidates.push(member);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys: keys3,
    otherwise,
    candidates
  };
};
var dropRightRefinement = (ast) => isRefinement(ast) ? dropRightRefinement(ast.from) : ast;
var handleForbidden = (effect4, ast, actual, options) => {
  if (options?.isEffectAllowed === true) {
    return effect4;
  }
  if (isEither4(effect4)) {
    return effect4;
  }
  const scheduler = new SyncScheduler;
  const fiber = runFork2(effect4, {
    scheduler
  });
  scheduler.flush();
  const exit3 = fiber.unsafePoll();
  if (exit3) {
    if (isSuccess(exit3)) {
      return right2(exit3.value);
    }
    const cause3 = exit3.cause;
    if (isFailType2(cause3)) {
      return left2(cause3.error);
    }
    return left2(new Forbidden(ast, actual, pretty2(cause3)));
  }
  return left2(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
};
var compare = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0;
function sortByIndex(es) {
  return es.sort(compare).map((t) => t[1]);
}
var getFinalTransformation = (transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return right2;
    case "TypeLiteralTransformation":
      return (input) => {
        let out = right2(input);
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation2 = isDecoding ? pst.decode : pst.encode;
          const f = (input2) => {
            const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some2(input2[from]) : none2());
            delete input2[from];
            if (isSome2(o)) {
              input2[to] = o.value;
            }
            return input2;
          };
          out = map22(out, f);
        }
        return out;
      };
  }
};
var makeTree = (value, forest = []) => ({
  value,
  forest
});
var TreeFormatter = {
  formatIssue: (issue) => map22(formatTree(issue), drawTree),
  formatIssueSync: (issue) => {
    const e = TreeFormatter.formatIssue(issue);
    return isEither4(e) ? getOrThrow(e) : runSync(e);
  },
  formatError: (error) => TreeFormatter.formatIssue(error.issue),
  formatErrorSync: (error) => TreeFormatter.formatIssueSync(error.issue)
};
var drawTree = (tree) => tree.value + draw(`
`, tree.forest);
var draw = (indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0;i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "" : "") + " " + tree.value;
    r += draw(indentation + (len > 1 && !isLast ? "  " : "   "), tree.forest);
  }
  return r;
};
var formatTransformationKind = (kind) => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
};
var formatRefinementKind = (kind) => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
};
var getAnnotated = (issue) => ("ast" in issue) ? some2(issue.ast) : none2();
var Either_void = /* @__PURE__ */ right2(undefined);
var getCurrentMessage = (issue) => getAnnotated(issue).pipe(flatMap(getMessageAnnotation), match2({
  onNone: () => Either_void,
  onSome: (messageAnnotation) => {
    const union9 = messageAnnotation(issue);
    if (isString(union9)) {
      return right2({
        message: union9,
        override: false
      });
    }
    if (isEffect2(union9)) {
      return map16(union9, (message) => ({
        message,
        override: false
      }));
    }
    if (isString(union9.message)) {
      return right2({
        message: union9.message,
        override: union9.override
      });
    }
    return map16(union9.message, (message) => ({
      message,
      override: union9.override
    }));
  }
}));
var createParseIssueGuard = (tag) => (issue) => issue._tag === tag;
var isComposite2 = /* @__PURE__ */ createParseIssueGuard("Composite");
var isRefinement2 = /* @__PURE__ */ createParseIssueGuard("Refinement");
var isTransformation2 = /* @__PURE__ */ createParseIssueGuard("Transformation");
var getMessage = (issue) => flatMap17(getCurrentMessage(issue), (currentMessage) => {
  if (currentMessage !== undefined) {
    const useInnerMessage = !currentMessage.override && (isComposite2(issue) || isRefinement2(issue) && issue.kind === "From" || isTransformation2(issue) && issue.kind !== "Transformation");
    return useInnerMessage ? isTransformation2(issue) || isRefinement2(issue) ? getMessage(issue.issue) : Either_void : right2(currentMessage.message);
  }
  return Either_void;
});
var getParseIssueTitleAnnotation2 = (issue) => getAnnotated(issue).pipe(flatMap(getParseIssueTitleAnnotation), flatMapNullable((annotation) => annotation(issue)), getOrUndefined);
function getRefinementExpected(ast) {
  return getDescriptionAnnotation(ast).pipe(orElse(() => getTitleAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), orElse(() => getIdentifierAnnotation(ast)), getOrElse(() => `{ ${ast.from} | filter }`));
}
function getDefaultTypeMessage(issue) {
  if (issue.message !== undefined) {
    return issue.message;
  }
  const expected = isRefinement(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast);
  return `Expected ${expected}, actual ${formatUnknown(issue.actual)}`;
}
var formatTypeMessage = (issue) => map22(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation2(issue) ?? getDefaultTypeMessage(issue));
var getParseIssueTitle = (issue) => getParseIssueTitleAnnotation2(issue) ?? String(issue.ast);
var formatForbiddenMessage = (issue) => issue.message ?? "is forbidden";
var formatUnexpectedMessage = (issue) => issue.message ?? "is unexpected";
var formatMissingMessage = (issue) => {
  const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
  if (isSome2(missingMessageAnnotation)) {
    const annotation = missingMessageAnnotation.value();
    return isString(annotation) ? right2(annotation) : annotation;
  }
  return right2(issue.message ?? "is missing");
};
var formatTree = (issue) => {
  switch (issue._tag) {
    case "Type":
      return map22(formatTypeMessage(issue), makeTree);
    case "Forbidden":
      return right2(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
    case "Unexpected":
      return right2(makeTree(formatUnexpectedMessage(issue)));
    case "Missing":
      return map22(formatMissingMessage(issue), makeTree);
    case "Transformation":
      return flatMap17(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2(makeTree(message));
        }
        return map22(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
      });
    case "Refinement":
      return flatMap17(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2(makeTree(message));
        }
        return map22(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
      });
    case "Pointer":
      return map22(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
    case "Composite":
      return flatMap17(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2(makeTree(message));
        }
        const parseIssueTitle = getParseIssueTitle(issue);
        return isNonEmpty(issue.issues) ? map22(forEach6(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map22(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
      });
  }
};
// node_modules/effect/dist/esm/Struct.js
var pick3 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys3) => {
  const out = {};
  for (const k of keys3) {
    if (k in s) {
      out[k] = s[k];
    }
  }
  return out;
});
var omit3 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys3) => {
  const out = {
    ...s
  };
  for (const k of keys3) {
    delete out[k];
  }
  return out;
});

// node_modules/effect/dist/esm/Schema.js
var TypeId16 = /* @__PURE__ */ Symbol.for("effect/Schema");
function make52(ast) {
  return class SchemaClass {
    [TypeId16] = variance7;
    static ast = ast;
    static annotations(annotations2) {
      return make52(mergeSchemaAnnotations(this.ast, annotations2));
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static toString() {
      return String(ast);
    }
    static Type;
    static Encoded;
    static Context;
    static [TypeId16] = variance7;
  };
}
var variance7 = {
  _A: (_) => _,
  _I: (_) => _,
  _R: (_) => _
};
var builtInAnnotations = {
  schemaId: SchemaIdAnnotationId,
  message: MessageAnnotationId,
  missingMessage: MissingMessageAnnotationId,
  identifier: IdentifierAnnotationId,
  title: TitleAnnotationId,
  description: DescriptionAnnotationId,
  examples: ExamplesAnnotationId,
  default: DefaultAnnotationId,
  documentation: DocumentationAnnotationId,
  jsonSchema: JSONSchemaAnnotationId,
  arbitrary: ArbitraryAnnotationId,
  pretty: PrettyAnnotationId,
  equivalence: EquivalenceAnnotationId,
  concurrency: ConcurrencyAnnotationId,
  batching: BatchingAnnotationId,
  parseIssueTitle: ParseIssueTitleAnnotationId,
  parseOptions: ParseOptionsAnnotationId,
  decodingFallback: DecodingFallbackAnnotationId
};
var toASTAnnotations = (annotations2) => {
  if (!annotations2) {
    return {};
  }
  const out = {
    ...annotations2
  };
  for (const key in builtInAnnotations) {
    if (key in annotations2) {
      const id2 = builtInAnnotations[key];
      out[id2] = annotations2[key];
      delete out[key];
    }
  }
  return out;
};
var mergeSchemaAnnotations = (ast, annotations2) => annotations(ast, toASTAnnotations(annotations2));
var encodedSchema = (schema) => make52(encodedAST(schema.ast));
var typeSchema = (schema) => make52(typeAST(schema.ast));
var isSchema = (u) => hasProperty(u, TypeId16) && isObject(u[TypeId16]);
function getDefaultLiteralAST(literals) {
  return isMembers(literals) ? Union.make(mapMembers(literals, (literal) => new Literal(literal))) : new Literal(literals[0]);
}
function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
  return class LiteralClass extends make52(ast) {
    static annotations(annotations2) {
      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static literals = [...literals];
  };
}
function Literal2(...literals) {
  return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
}
var declareConstructor = (typeParameters, options, annotations2) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options.decode(...typeParameters2.map(make52)), (...typeParameters2) => options.encode(...typeParameters2.map(make52)), toASTAnnotations(annotations2)));
var declarePrimitive = (is2, annotations2) => {
  const decodeUnknown2 = () => (input, _, ast) => is2(input) ? succeed15(input) : fail16(new Type2(ast, input));
  const encodeUnknown2 = decodeUnknown2;
  return makeDeclareClass([], new Declaration([], decodeUnknown2, encodeUnknown2, toASTAnnotations(annotations2)));
};
function makeDeclareClass(typeParameters, ast) {
  return class DeclareClass extends make52(ast) {
    static annotations(annotations2) {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static typeParameters = [...typeParameters];
  };
}
var declare = function() {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options = arguments[1];
    const annotations3 = arguments[2];
    return declareConstructor(typeParameters, options, annotations3);
  }
  const is2 = arguments[0];
  const annotations2 = arguments[1];
  return declarePrimitive(is2, annotations2);
};
class Undefined extends (/* @__PURE__ */ make52(undefinedKeyword)) {
}
class Never extends (/* @__PURE__ */ make52(neverKeyword)) {
}

class Unknown extends (/* @__PURE__ */ make52(unknownKeyword)) {
}
class String$ extends (/* @__PURE__ */ make52(stringKeyword)) {
}

class Number$ extends (/* @__PURE__ */ make52(numberKeyword)) {
}

class Boolean$ extends (/* @__PURE__ */ make52(booleanKeyword)) {
}
var getDefaultUnionAST = (members) => Union.make(members.map((m) => m.ast));
function makeUnionClass(members, ast = getDefaultUnionAST(members)) {
  return class UnionClass extends make52(ast) {
    static annotations(annotations2) {
      return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static members = [...members];
  };
}
function Union2(...members) {
  return isMembers(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never;
}
var UndefinedOr = (self2) => Union2(self2, Undefined);
var getDefaultTupleTypeAST = (elements, rest) => new TupleType(elements.map((el) => isSchema(el) ? new OptionalType(el.ast, false) : el.ast), rest.map((el) => isSchema(el) ? new Type(el.ast) : el.ast), true);
function makeTupleTypeClass(elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) {
  return class TupleTypeClass extends make52(ast) {
    static annotations(annotations2) {
      return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static elements = [...elements];
    static rest = [...rest];
  };
}
function makeArrayClass(value, ast) {
  return class ArrayClass extends makeTupleTypeClass([], [value], ast) {
    static annotations(annotations2) {
      return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static value = value;
  };
}
var Array$ = (value) => makeArrayClass(value);
var formatPropertySignatureToken = (isOptional) => isOptional ? '"?:"' : '":"';

class PropertySignatureDeclaration extends OptionalType {
  isReadonly;
  defaultValue;
  _tag = "PropertySignatureDeclaration";
  constructor(type, isOptional, isReadonly, annotations2, defaultValue) {
    super(type, isOptional, annotations2);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
  toString() {
    const token = formatPropertySignatureToken(this.isOptional);
    const type = String(this.type);
    return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`;
  }
}
class ToPropertySignature extends OptionalType {
  isReadonly;
  defaultValue;
  constructor(type, isOptional, isReadonly, annotations2, defaultValue) {
    super(type, isOptional, annotations2);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
}
var formatPropertyKey2 = (p) => {
  if (p === undefined) {
    return "never";
  }
  if (isString(p)) {
    return JSON.stringify(p);
  }
  return String(p);
};

class PropertySignatureTransformation2 {
  from;
  to;
  decode;
  encode;
  _tag = "PropertySignatureTransformation";
  constructor(from, to, decode2, encode) {
    this.from = from;
    this.to = to;
    this.decode = decode2;
    this.encode = encode;
  }
  toString() {
    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey2(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
  }
}
var mergeSignatureAnnotations = (ast, annotations2) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
        ...ast.annotations,
        ...annotations2
      }, ast.defaultValue);
    }
    case "PropertySignatureTransformation": {
      return new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
        ...ast.to.annotations,
        ...annotations2
      }, ast.to.defaultValue), ast.decode, ast.encode);
    }
  }
};
var PropertySignatureTypeId = /* @__PURE__ */ Symbol.for("effect/PropertySignature");
var isPropertySignature = (u) => hasProperty(u, PropertySignatureTypeId);

class PropertySignatureImpl {
  ast;
  [TypeId16];
  [PropertySignatureTypeId] = null;
  _TypeToken;
  _Key;
  _EncodedToken;
  _HasDefault;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  annotations(annotations2) {
    return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations2)));
  }
  toString() {
    return String(this.ast);
  }
}
var makePropertySignature = (ast) => new PropertySignatureImpl(ast);

class PropertySignatureWithFromImpl extends PropertySignatureImpl {
  from;
  constructor(ast, from) {
    super(ast);
    this.from = from;
  }
  annotations(annotations2) {
    return new PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations2)), this.from);
  }
}
var propertySignature = (self2) => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self2.ast, false, true, {}, undefined), self2);
var withConstructorDefault = /* @__PURE__ */ dual(2, (self2, defaultValue) => {
  const ast = self2.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
  }
});
var optional = (self2) => {
  const ast = self2.ast === undefinedKeyword || self2.ast === neverKeyword ? undefinedKeyword : UndefinedOr(self2).ast;
  return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, undefined), self2);
};
var preserveMissingMessageAnnotation = /* @__PURE__ */ pickAnnotations([MissingMessageAnnotationId]);
var getDefaultTypeLiteralAST = (fields, records) => {
  const ownKeys = Reflect.ownKeys(fields);
  const pss = [];
  if (ownKeys.length > 0) {
    const from = [];
    const to = [];
    const transformations = [];
    for (let i = 0;i < ownKeys.length; i++) {
      const key = ownKeys[i];
      const field = fields[key];
      if (isPropertySignature(field)) {
        const ast = field.ast;
        switch (ast._tag) {
          case "PropertySignatureDeclaration": {
            const type = ast.type;
            const isOptional = ast.isOptional;
            const toAnnotations = ast.annotations;
            from.push(new PropertySignature(key, type, isOptional, true, preserveMissingMessageAnnotation(ast)));
            to.push(new PropertySignature(key, typeAST(type), isOptional, true, toAnnotations));
            pss.push(new PropertySignature(key, type, isOptional, true, toAnnotations));
            break;
          }
          case "PropertySignatureTransformation": {
            const fromKey = ast.from.fromKey ?? key;
            from.push(new PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
            to.push(new PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
            transformations.push(new PropertySignatureTransformation(fromKey, key, ast.decode, ast.encode));
            break;
          }
        }
      } else {
        from.push(new PropertySignature(key, field.ast, false, true));
        to.push(new PropertySignature(key, typeAST(field.ast), false, true));
        pss.push(new PropertySignature(key, field.ast, false, true));
      }
    }
    if (isNonEmptyReadonlyArray(transformations)) {
      const issFrom = [];
      const issTo = [];
      for (const r of records) {
        const {
          indexSignatures,
          propertySignatures
        } = record(r.key.ast, r.value.ast);
        propertySignatures.forEach((ps) => {
          from.push(ps);
          to.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
        });
        indexSignatures.forEach((is2) => {
          issFrom.push(is2);
          issTo.push(new IndexSignature(is2.parameter, typeAST(is2.type), is2.isReadonly));
        });
      }
      return new Transformation(new TypeLiteral(from, issFrom, {
        [AutoTitleAnnotationId]: "Struct (Encoded side)"
      }), new TypeLiteral(to, issTo, {
        [AutoTitleAnnotationId]: "Struct (Type side)"
      }), new TypeLiteralTransformation(transformations));
    }
  }
  const iss = [];
  for (const r of records) {
    const {
      indexSignatures,
      propertySignatures
    } = record(r.key.ast, r.value.ast);
    propertySignatures.forEach((ps) => pss.push(ps));
    indexSignatures.forEach((is2) => iss.push(is2));
  }
  return new TypeLiteral(pss, iss);
};
var lazilyMergeDefaults = (fields, out) => {
  const ownKeys = Reflect.ownKeys(fields);
  for (const key of ownKeys) {
    const field = fields[key];
    if (out[key] === undefined && isPropertySignature(field)) {
      const ast = field.ast;
      const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
      if (defaultValue !== undefined) {
        out[key] = defaultValue();
      }
    }
  }
  return out;
};
function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
  return class TypeLiteralClass extends make52(ast) {
    static annotations(annotations2) {
      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static fields = {
      ...fields
    };
    static records = [...records];
    static make = (props, options) => {
      const propsWithDefaults = lazilyMergeDefaults(fields, {
        ...props
      });
      return getDisableValidationMakeOption(options) ? propsWithDefaults : validateSync(this)(propsWithDefaults);
    };
    static pick(...keys3) {
      return Struct(pick3(fields, ...keys3));
    }
    static omit(...keys3) {
      return Struct(omit3(fields, ...keys3));
    }
  };
}
function Struct(fields, ...records) {
  return makeTypeLiteralClass(fields, records);
}
function makeRecordClass(key, value, ast) {
  return class RecordClass extends makeTypeLiteralClass({}, [{
    key,
    value
  }], ast) {
    static annotations(annotations2) {
      return makeRecordClass(key, value, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static key = key;
    static value = value;
  };
}
var Record = (options) => makeRecordClass(options.key, options.value);
var intersectTypeLiterals = (x, y, path) => {
  if (isTypeLiteral(x) && isTypeLiteral(y)) {
    const propertySignatures = [...x.propertySignatures];
    for (const ps of y.propertySignatures) {
      const name = ps.name;
      const i = propertySignatures.findIndex((ps2) => ps2.name === name);
      if (i === -1) {
        propertySignatures.push(ps);
      } else {
        const {
          isOptional,
          type
        } = propertySignatures[i];
        propertySignatures[i] = new PropertySignature(name, extendAST(type, ps.type, path.concat(name)), isOptional, true);
      }
    }
    return new TypeLiteral(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
  }
  throw new Error(getSchemaExtendErrorMessage(x, y, path));
};
var preserveRefinementAnnotations = /* @__PURE__ */ omitAnnotations([IdentifierAnnotationId]);
var addRefinementToMembers = (refinement, asts) => asts.map((ast) => new Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement)));
var extendAST = (x, y, path) => Union.make(intersectUnionMembers([x], [y], path));
var getTypes = (ast) => isUnion(ast) ? ast.types : [ast];
var intersectUnionMembers = (xs, ys, path) => flatMap2(xs, (x) => flatMap2(ys, (y) => {
  switch (y._tag) {
    case "Literal": {
      if (isString(y.literal) && isStringKeyword(x) || isNumber(y.literal) && isNumberKeyword(x) || isBoolean(y.literal) && isBooleanKeyword(x)) {
        return [y];
      }
      break;
    }
    case "StringKeyword": {
      if (y === stringKeyword) {
        if (isStringKeyword(x) || isLiteral(x) && isString(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        }
      } else if (x === stringKeyword) {
        return [y];
      }
      break;
    }
    case "NumberKeyword": {
      if (y === numberKeyword) {
        if (isNumberKeyword(x) || isLiteral(x) && isNumber(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        }
      } else if (x === numberKeyword) {
        return [y];
      }
      break;
    }
    case "BooleanKeyword": {
      if (y === booleanKeyword) {
        if (isBooleanKeyword(x) || isLiteral(x) && isBoolean(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        }
      } else if (x === booleanKeyword) {
        return [y];
      }
      break;
    }
    case "Union":
      return intersectUnionMembers(getTypes(x), y.types, path);
    case "Suspend":
      return [new Suspend(() => extendAST(x, y.f(), path))];
    case "Refinement":
      return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path));
    case "TypeLiteral": {
      switch (x._tag) {
        case "Union":
          return intersectUnionMembers(x.types, [y], path);
        case "Suspend":
          return [new Suspend(() => extendAST(x.f(), y, path))];
        case "Refinement":
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        case "TypeLiteral":
          return [intersectTypeLiterals(x, y, path)];
        case "Transformation": {
          const transformation = x.transformation;
          const from = intersectTypeLiterals(x.from, y, path);
          const to = intersectTypeLiterals(x.to, typeAST(y), path);
          switch (transformation._tag) {
            case "TypeLiteralTransformation":
              return [new Transformation(from, to, new TypeLiteralTransformation(transformation.propertySignatureTransformations))];
            case "ComposeTransformation":
              return [new Transformation(from, to, composeTransformation)];
            case "FinalTransformation":
              return [new Transformation(from, to, new FinalTransformation((fromA, options, ast, fromI) => map22(transformation.decode(fromA, options, ast, fromI), (partial2) => ({
                ...fromA,
                ...partial2
              })), (toI, options, ast, toA) => map22(transformation.encode(toI, options, ast, toA), (partial2) => ({
                ...toI,
                ...partial2
              }))))];
          }
        }
      }
      break;
    }
    case "Transformation": {
      if (isTransformation(x)) {
        if (isTypeLiteralTransformation(y.transformation) && isTypeLiteralTransformation(x.transformation)) {
          return [new Transformation(intersectTypeLiterals(x.from, y.from, path), intersectTypeLiterals(x.to, y.to, path), new TypeLiteralTransformation(y.transformation.propertySignatureTransformations.concat(x.transformation.propertySignatureTransformations)))];
        }
      } else {
        return intersectUnionMembers([y], [x], path);
      }
      break;
    }
  }
  throw new Error(getSchemaExtendErrorMessage(x, y, path));
}));
var extend3 = /* @__PURE__ */ dual(2, (self2, that) => make52(extendAST(self2.ast, that.ast, [])));
var RefineSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Refine");
function makeRefineClass(from, filter10, ast) {
  return class RefineClass extends make52(ast) {
    static annotations(annotations2) {
      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static [RefineSchemaId] = from;
    static from = from;
    static filter = filter10;
    static make = (a, options) => {
      return getDisableValidationMakeOption(options) ? a : validateSync(this)(a);
    };
  };
}
var fromFilterPredicateReturnTypeItem = (item, ast, input) => {
  if (isBoolean(item)) {
    return item ? none2() : some2(new Type2(ast, input));
  }
  if (isString(item)) {
    return some2(new Type2(ast, input, item));
  }
  if (item !== undefined) {
    if ("_tag" in item) {
      return some2(item);
    }
    const issue = new Type2(ast, input, item.message);
    return some2(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
  }
  return none2();
};
var toFilterParseIssue = (out, ast, input) => {
  if (isSingle(out)) {
    return fromFilterPredicateReturnTypeItem(out, ast, input);
  }
  if (isNonEmptyReadonlyArray(out)) {
    const issues = filterMap(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
    if (isNonEmptyReadonlyArray(issues)) {
      return some2(issues.length === 1 ? issues[0] : new Composite2(ast, input, issues));
    }
  }
  return none2();
};
function filter10(predicate, annotations2) {
  return (self2) => {
    function filter11(input, options, ast2) {
      return toFilterParseIssue(predicate(input, options, ast2), ast2, input);
    }
    const ast = new Refinement(self2.ast, filter11, toASTAnnotations(annotations2));
    return makeRefineClass(self2, filter11, ast);
  };
}
function makeTransformationClass(from, to, ast) {
  return class TransformationClass extends make52(ast) {
    static annotations(annotations2) {
      return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static from = from;
    static to = to;
  };
}
var transformOrFail = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options) => makeTransformationClass(from, to, new Transformation(from.ast, to.ast, new FinalTransformation(options.decode, options.encode))));
var transform2 = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options) => transformOrFail(from, to, {
  strict: true,
  decode: (fromA, _options, _ast, toA) => succeed15(options.decode(fromA, toA)),
  encode: (toI, _options, _ast, toA) => succeed15(options.encode(toI, toA))
}));
var PatternSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Pattern");
var pattern = (regex, annotations2) => (self2) => {
  const source = regex.source;
  return self2.pipe(filter10((a) => {
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    schemaId: PatternSchemaId,
    [PatternSchemaId]: {
      regex
    },
    description: `a string matching the pattern ${source}`,
    jsonSchema: {
      pattern: source
    },
    ...annotations2
  }));
};
var UUIDSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/UUID");
var uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;

class UUID extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ pattern(uuidRegexp, {
  schemaId: UUIDSchemaId,
  identifier: "UUID",
  jsonSchema: {
    format: "uuid",
    pattern: uuidRegexp.source
  },
  description: "a Universally Unique Identifier",
  arbitrary: () => (fc) => fc.uuid()
}))) {
}
var GreaterThanSchemaId2 = GreaterThanSchemaId;
var greaterThan4 = (exclusiveMinimum, annotations2) => (self2) => self2.pipe(filter10((a) => a > exclusiveMinimum, {
  schemaId: GreaterThanSchemaId2,
  title: `greaterThan(${exclusiveMinimum})`,
  description: exclusiveMinimum === 0 ? "a positive number" : `a number greater than ${exclusiveMinimum}`,
  jsonSchema: {
    exclusiveMinimum
  },
  ...annotations2
}));
var IntSchemaId2 = IntSchemaId;
var int = (annotations2) => (self2) => self2.pipe(filter10((a) => Number.isSafeInteger(a), {
  schemaId: IntSchemaId2,
  title: "int",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations2
}));
var positive = (annotations2) => greaterThan4(0, {
  title: "positive",
  ...annotations2
});
var DateFromSelfSchemaId2 = DateFromSelfSchemaId;

class DateFromSelf extends (/* @__PURE__ */ declare(isDate, {
  identifier: "DateFromSelf",
  schemaId: DateFromSelfSchemaId2,
  [DateFromSelfSchemaId2]: {
    noInvalidDate: false
  },
  description: "a potentially invalid Date instance",
  pretty: () => (date) => `new Date(${JSON.stringify(date)})`,
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Date2
})) {
}
var isField = (u) => isSchema(u) || isPropertySignature(u);
var isFields = (fields) => Reflect.ownKeys(fields).every((key) => isField(fields[key]));
var getFields = (hasFields) => ("fields" in hasFields) ? hasFields.fields : getFields(hasFields[RefineSchemaId]);
var getSchemaFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr));
var getFieldsFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr);
var getClassTag = (tag) => withConstructorDefault(propertySignature(Literal2(tag)), () => tag);
var TaggedError2 = (identifier2) => (tag, fieldsOr, annotations2) => {
  class Base3 extends Error3 {
  }
  Base3.prototype.name = tag;
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag)
  };
  const taggedFields = extendFields(newFields, fields);
  const hasMessageField = "message" in taggedFields;

  class TaggedErrorClass extends makeClass({
    kind: "TaggedError",
    identifier: identifier2 ?? tag,
    schema: extend3(schema, Struct(newFields)),
    fields: taggedFields,
    Base: Base3,
    annotations: annotations2,
    disableToString: true
  }) {
    static _tag = tag;
  }
  if (!hasMessageField) {
    Object.defineProperty(TaggedErrorClass.prototype, "message", {
      get() {
        return `{ ${Reflect.ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} }`;
      },
      enumerable: false,
      configurable: true
    });
  }
  return TaggedErrorClass;
};
var extendFields = (a, b) => {
  const out = {
    ...a
  };
  for (const key of Reflect.ownKeys(b)) {
    if (key in a) {
      throw new Error(getASTDuplicatePropertySignatureErrorMessage(key));
    }
    out[key] = b[key];
  }
  return out;
};
function getDisableValidationMakeOption(options) {
  return isBoolean(options) ? options : options?.disableValidation ?? false;
}
var astCache = /* @__PURE__ */ globalValue("effect/Schema/astCache", () => new WeakMap);
var getClassAnnotations = (annotations2) => {
  if (annotations2 === undefined) {
    return [];
  } else if (Array.isArray(annotations2)) {
    return annotations2;
  } else {
    return [annotations2];
  }
};
var makeClass = ({
  Base: Base3,
  annotations: annotations2,
  disableToString,
  fields,
  identifier: identifier2,
  kind,
  schema
}) => {
  const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier2}`);
  const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations2);
  const typeSchema_ = typeSchema(schema);
  const declarationSurrogate = typeSchema_.annotations({
    identifier: identifier2,
    ...typeAnnotations
  });
  const typeSide = typeSchema_.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Type side)`,
    ...typeAnnotations
  });
  const constructorSchema = schema.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Constructor)`,
    ...typeAnnotations
  });
  const encodedSide = schema.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Encoded side)`,
    ...encodedAnnotations
  });
  const transformationSurrogate = schema.annotations({
    ...encodedAnnotations,
    ...typeAnnotations,
    ...transformationAnnotations
  });
  const fallbackInstanceOf = (u) => hasProperty(u, classSymbol) && is(typeSide)(u);
  const klass = class extends Base3 {
    constructor(props = {}, options = false) {
      props = {
        ...props
      };
      if (kind !== "Class") {
        delete props["_tag"];
      }
      props = lazilyMergeDefaults(fields, props);
      if (!getDisableValidationMakeOption(options)) {
        props = validateSync(constructorSchema)(props);
      }
      super(props, true);
    }
    static [TypeId16] = variance7;
    static get ast() {
      let out = astCache.get(this);
      if (out) {
        return out;
      }
      const declaration = declare([schema], {
        decode: () => (input, _, ast) => input instanceof this || fallbackInstanceOf(input) ? succeed15(input) : fail16(new Type2(ast, input)),
        encode: () => (input, options) => input instanceof this ? succeed15(input) : map22(encodeUnknown(typeSide)(input, options), (props) => new this(props, true))
      }, {
        identifier: identifier2,
        pretty: (pretty4) => (self2) => `${identifier2}(${pretty4(self2)})`,
        arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),
        equivalence: identity,
        [SurrogateAnnotationId]: declarationSurrogate.ast,
        ...typeAnnotations
      });
      out = transform2(encodedSide, declaration, {
        strict: true,
        decode: (i) => new this(i, true),
        encode: identity
      }).annotations({
        [SurrogateAnnotationId]: transformationSurrogate.ast,
        ...transformationAnnotations
      }).ast;
      astCache.set(this, out);
      return out;
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static annotations(annotations3) {
      return make52(this.ast).annotations(annotations3);
    }
    static toString() {
      return `(${String(encodedSide)} <-> ${identifier2})`;
    }
    static make(...args2) {
      return new this(...args2);
    }
    static fields = {
      ...fields
    };
    static identifier = identifier2;
    static extend(identifier3) {
      return (newFieldsOr, annotations3) => {
        const newFields = getFieldsFromFieldsOr(newFieldsOr);
        const newSchema = getSchemaFromFieldsOr(newFieldsOr);
        const extendedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: extend3(schema, newSchema),
          fields: extendedFields,
          Base: this,
          annotations: annotations3
        });
      };
    }
    static transformOrFail(identifier3) {
      return (newFieldsOr, options, annotations3) => {
        const transformedFields = extendFields(fields, newFieldsOr);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(schema, typeSchema(Struct(transformedFields)), options),
          fields: transformedFields,
          Base: this,
          annotations: annotations3
        });
      };
    }
    static transformOrFailFrom(identifier3) {
      return (newFields, options, annotations3) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(encodedSchema(schema), Struct(transformedFields), options),
          fields: transformedFields,
          Base: this,
          annotations: annotations3
        });
      };
    }
    get [classSymbol]() {
      return classSymbol;
    }
  };
  if (disableToString !== true) {
    Object.defineProperty(klass.prototype, "toString", {
      value() {
        return `${identifier2}({ ${Reflect.ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} })`;
      },
      configurable: true,
      writable: true
    });
  }
  return klass;
};
class Defect extends (/* @__PURE__ */ transform2(Unknown, Unknown, {
  strict: true,
  decode: (i) => {
    if (isObject(i) && "message" in i && typeof i.message === "string") {
      const err = new Error(i.message, {
        cause: i
      });
      if ("name" in i && typeof i.name === "string") {
        err.name = i.name;
      }
      err.stack = "stack" in i && typeof i.stack === "string" ? i.stack : "";
      return err;
    }
    return prettyErrorMessage(i);
  },
  encode: (a) => {
    if (a instanceof Error) {
      return {
        name: a.name,
        message: a.message
      };
    }
    return prettyErrorMessage(a);
  }
}).annotations({
  identifier: "Defect"
})) {
}
// node_modules/effect/dist/esm/Stream.js
var exports_Stream = {};
__export(exports_Stream, {
  zipWithPreviousAndNext: () => zipWithPreviousAndNext2,
  zipWithPrevious: () => zipWithPrevious2,
  zipWithNext: () => zipWithNext2,
  zipWithIndex: () => zipWithIndex2,
  zipWithChunks: () => zipWithChunks2,
  zipWith: () => zipWith11,
  zipRight: () => zipRight9,
  zipLeft: () => zipLeft6,
  zipLatestWith: () => zipLatestWith2,
  zipLatestAll: () => zipLatestAll2,
  zipLatest: () => zipLatest2,
  zipFlatten: () => zipFlatten2,
  zipAllWith: () => zipAllWith2,
  zipAllSortedByKeyWith: () => zipAllSortedByKeyWith2,
  zipAllSortedByKeyRight: () => zipAllSortedByKeyRight2,
  zipAllSortedByKeyLeft: () => zipAllSortedByKeyLeft2,
  zipAllSortedByKey: () => zipAllSortedByKey2,
  zipAllRight: () => zipAllRight2,
  zipAllLeft: () => zipAllLeft2,
  zipAll: () => zipAll2,
  zip: () => zip8,
  withSpan: () => withSpan7,
  withExecutionPlan: () => withExecutionPlan4,
  whenEffect: () => whenEffect4,
  whenCaseEffect: () => whenCaseEffect2,
  whenCase: () => whenCase2,
  when: () => when4,
  void: () => void_8,
  updateService: () => updateService5,
  unwrapScopedWith: () => unwrapScopedWith4,
  unwrapScoped: () => unwrapScoped5,
  unwrap: () => unwrap3,
  unfoldEffect: () => unfoldEffect2,
  unfoldChunkEffect: () => unfoldChunkEffect2,
  unfoldChunk: () => unfoldChunk2,
  unfold: () => unfold4,
  transduce: () => transduce2,
  toReadableStreamRuntime: () => toReadableStreamRuntime2,
  toReadableStreamEffect: () => toReadableStreamEffect2,
  toReadableStream: () => toReadableStream2,
  toQueueOfElements: () => toQueueOfElements2,
  toQueue: () => toQueue3,
  toPull: () => toPull3,
  toPubSub: () => toPubSub3,
  toChannel: () => toChannel3,
  toAsyncIterableRuntime: () => toAsyncIterableRuntime2,
  toAsyncIterableEffect: () => toAsyncIterableEffect2,
  toAsyncIterable: () => toAsyncIterable2,
  timeoutTo: () => timeoutTo4,
  timeoutFailCause: () => timeoutFailCause4,
  timeoutFail: () => timeoutFail4,
  timeout: () => timeout4,
  tick: () => tick2,
  throttleEffect: () => throttleEffect2,
  throttle: () => throttle2,
  tapSink: () => tapSink2,
  tapErrorCause: () => tapErrorCause6,
  tapError: () => tapError6,
  tapBoth: () => tapBoth4,
  tap: () => tap7,
  takeWhile: () => takeWhile5,
  takeUntilEffect: () => takeUntilEffect2,
  takeUntil: () => takeUntil4,
  takeRight: () => takeRight3,
  take: () => take8,
  sync: () => sync9,
  suspend: () => suspend10,
  succeed: () => succeed16,
  splitOnChunk: () => splitOnChunk2,
  splitLines: () => splitLines3,
  split: () => split2,
  someOrFail: () => someOrFail2,
  someOrElse: () => someOrElse2,
  some: () => some6,
  slidingSize: () => slidingSize2,
  sliding: () => sliding8,
  share: () => share2,
  scopedWith: () => scopedWith5,
  scoped: () => scoped6,
  scheduleWith: () => scheduleWith2,
  schedule: () => schedule3,
  scanReduceEffect: () => scanReduceEffect2,
  scanReduce: () => scanReduce2,
  scanEffect: () => scanEffect2,
  scan: () => scan2,
  runSum: () => runSum2,
  runScoped: () => runScoped3,
  runLast: () => runLast2,
  runIntoQueueScoped: () => runIntoQueueScoped2,
  runIntoQueueElementsScoped: () => runIntoQueueElementsScoped2,
  runIntoQueue: () => runIntoQueue2,
  runIntoPubSubScoped: () => runIntoPubSubScoped2,
  runIntoPubSub: () => runIntoPubSub2,
  runHead: () => runHead2,
  runForEachWhileScoped: () => runForEachWhileScoped2,
  runForEachWhile: () => runForEachWhile2,
  runForEachScoped: () => runForEachScoped2,
  runForEachChunkScoped: () => runForEachChunkScoped2,
  runForEachChunk: () => runForEachChunk2,
  runForEach: () => runForEach2,
  runFoldWhileScopedEffect: () => runFoldWhileScopedEffect2,
  runFoldWhileScoped: () => runFoldWhileScoped2,
  runFoldWhileEffect: () => runFoldWhileEffect2,
  runFoldWhile: () => runFoldWhile2,
  runFoldScopedEffect: () => runFoldScopedEffect2,
  runFoldScoped: () => runFoldScoped2,
  runFoldEffect: () => runFoldEffect2,
  runFold: () => runFold2,
  runDrain: () => runDrain3,
  runCount: () => runCount2,
  runCollect: () => runCollect2,
  run: () => run4,
  retry: () => retry7,
  repeatWith: () => repeatWith2,
  repeatValue: () => repeatValue2,
  repeatElementsWith: () => repeatElementsWith2,
  repeatElements: () => repeatElements2,
  repeatEither: () => repeatEither2,
  repeatEffectWithSchedule: () => repeatEffectWithSchedule2,
  repeatEffectOption: () => repeatEffectOption2,
  repeatEffectChunkOption: () => repeatEffectChunkOption2,
  repeatEffectChunk: () => repeatEffectChunk2,
  repeatEffect: () => repeatEffect2,
  repeat: () => repeat3,
  refineOrDieWith: () => refineOrDieWith2,
  refineOrDie: () => refineOrDie2,
  rechunk: () => rechunk2,
  range: () => range3,
  raceAll: () => raceAll4,
  race: () => race4,
  provideSomeLayer: () => provideSomeLayer3,
  provideSomeContext: () => provideSomeContext3,
  provideServiceStream: () => provideServiceStream2,
  provideServiceEffect: () => provideServiceEffect4,
  provideService: () => provideService6,
  provideLayer: () => provideLayer2,
  provideContext: () => provideContext6,
  prepend: () => prepend5,
  pipeThroughChannelOrFail: () => pipeThroughChannelOrFail2,
  pipeThroughChannel: () => pipeThroughChannel2,
  pipeThrough: () => pipeThrough2,
  peel: () => peel2,
  partitionEither: () => partitionEither2,
  partition: () => partition6,
  paginateEffect: () => paginateEffect2,
  paginateChunkEffect: () => paginateChunkEffect2,
  paginateChunk: () => paginateChunk2,
  paginate: () => paginate2,
  orElseSucceed: () => orElseSucceed4,
  orElseIfEmptyStream: () => orElseIfEmptyStream2,
  orElseIfEmptyChunk: () => orElseIfEmptyChunk2,
  orElseIfEmpty: () => orElseIfEmpty2,
  orElseFail: () => orElseFail4,
  orElseEither: () => orElseEither4,
  orElse: () => orElse10,
  orDieWith: () => orDieWith5,
  orDie: () => orDie6,
  onStart: () => onStart2,
  onError: () => onError4,
  onEnd: () => onEnd2,
  onDone: () => onDone2,
  never: () => never5,
  mkString: () => mkString3,
  mergeWithTag: () => mergeWithTag2,
  mergeWith: () => mergeWith4,
  mergeRight: () => mergeRight2,
  mergeLeft: () => mergeLeft2,
  mergeEither: () => mergeEither2,
  mergeAll: () => mergeAll9,
  merge: () => merge10,
  mapInputContext: () => mapInputContext6,
  mapErrorCause: () => mapErrorCause5,
  mapError: () => mapError8,
  mapEffect: () => mapEffect4,
  mapConcatEffect: () => mapConcatEffect2,
  mapConcatChunkEffect: () => mapConcatChunkEffect2,
  mapConcatChunk: () => mapConcatChunk2,
  mapConcat: () => mapConcat2,
  mapChunksEffect: () => mapChunksEffect2,
  mapChunks: () => mapChunks2,
  mapBoth: () => mapBoth8,
  mapAccumEffect: () => mapAccumEffect2,
  mapAccum: () => mapAccum6,
  map: () => map23,
  make: () => make53,
  let: () => let_5,
  iterate: () => iterate4,
  intersperseAffixes: () => intersperseAffixes2,
  intersperse: () => intersperse2,
  interruptWhenDeferred: () => interruptWhenDeferred3,
  interruptWhen: () => interruptWhen3,
  interruptAfter: () => interruptAfter2,
  interleaveWith: () => interleaveWith2,
  interleave: () => interleave2,
  identity: () => identity3,
  haltWhenDeferred: () => haltWhenDeferred2,
  haltWhen: () => haltWhen2,
  haltAfter: () => haltAfter2,
  groupedWithin: () => groupedWithin2,
  grouped: () => grouped2,
  groupByKey: () => groupByKey2,
  groupBy: () => groupBy2,
  groupAdjacentBy: () => groupAdjacentBy2,
  fromTQueue: () => fromTQueue2,
  fromTPubSub: () => fromTPubSub2,
  fromSchedule: () => fromSchedule2,
  fromReadableStreamByob: () => fromReadableStreamByob2,
  fromReadableStream: () => fromReadableStream2,
  fromQueue: () => fromQueue3,
  fromPull: () => fromPull3,
  fromPubSub: () => fromPubSub2,
  fromIteratorSucceed: () => fromIteratorSucceed2,
  fromIterableEffect: () => fromIterableEffect2,
  fromIterable: () => fromIterable10,
  fromEventListener: () => fromEventListener2,
  fromEffectOption: () => fromEffectOption2,
  fromEffect: () => fromEffect8,
  fromChunks: () => fromChunks2,
  fromChunkQueue: () => fromChunkQueue2,
  fromChunkPubSub: () => fromChunkPubSub2,
  fromChunk: () => fromChunk2,
  fromChannel: () => fromChannel3,
  fromAsyncIterable: () => fromAsyncIterable2,
  forever: () => forever6,
  flattenTake: () => flattenTake2,
  flattenIterables: () => flattenIterables2,
  flattenExitOption: () => flattenExitOption2,
  flattenEffect: () => flattenEffect2,
  flattenChunks: () => flattenChunks2,
  flatten: () => flatten14,
  flatMap: () => flatMap18,
  findEffect: () => findEffect2,
  find: () => find3,
  finalizer: () => finalizer2,
  filterMapWhileEffect: () => filterMapWhileEffect2,
  filterMapWhile: () => filterMapWhile4,
  filterMapEffect: () => filterMapEffect2,
  filterMap: () => filterMap7,
  filterEffect: () => filterEffect2,
  filter: () => filter11,
  failSync: () => failSync8,
  failCauseSync: () => failCauseSync7,
  failCause: () => failCause14,
  fail: () => fail17,
  execute: () => execute2,
  ensuringWith: () => ensuringWith3,
  ensuring: () => ensuring7,
  encodeText: () => encodeText2,
  empty: () => empty30,
  either: () => either6,
  dropWhileEffect: () => dropWhileEffect2,
  dropWhile: () => dropWhile5,
  dropUntilEffect: () => dropUntilEffect2,
  dropUntil: () => dropUntil4,
  dropRight: () => dropRight2,
  drop: () => drop4,
  drainFork: () => drainFork2,
  drain: () => drain4,
  distributedWithDynamic: () => distributedWithDynamic2,
  distributedWith: () => distributedWith2,
  dieSync: () => dieSync7,
  dieMessage: () => dieMessage5,
  die: () => die11,
  decodeText: () => decodeText2,
  debounce: () => debounce2,
  crossWith: () => crossWith2,
  crossRight: () => crossRight2,
  crossLeft: () => crossLeft2,
  cross: () => cross2,
  contextWithStream: () => contextWithStream2,
  contextWithEffect: () => contextWithEffect4,
  contextWith: () => contextWith4,
  context: () => context6,
  concatAll: () => concatAll3,
  concat: () => concat3,
  combineChunks: () => combineChunks2,
  combine: () => combine10,
  chunksWith: () => chunksWith2,
  chunks: () => chunks2,
  changesWithEffect: () => changesWithEffect2,
  changesWith: () => changesWith2,
  changes: () => changes2,
  catchTags: () => catchTags4,
  catchTag: () => catchTag4,
  catchSomeCause: () => catchSomeCause4,
  catchSome: () => catchSome4,
  catchAllCause: () => catchAllCause7,
  catchAll: () => catchAll8,
  bufferChunks: () => bufferChunks2,
  buffer: () => buffer2,
  broadcastedQueuesDynamic: () => broadcastedQueuesDynamic2,
  broadcastedQueues: () => broadcastedQueues2,
  broadcastDynamic: () => broadcastDynamic2,
  broadcast: () => broadcast2,
  branchAfter: () => branchAfter2,
  bindTo: () => bindTo5,
  bindEffect: () => bindEffect2,
  bind: () => bind5,
  asyncScoped: () => asyncScoped2,
  asyncPush: () => asyncPush2,
  asyncEffect: () => asyncEffect4,
  async: () => _async2,
  as: () => as8,
  aggregateWithinEither: () => aggregateWithinEither2,
  aggregateWithin: () => aggregateWithin2,
  aggregate: () => aggregate2,
  acquireRelease: () => acquireRelease4,
  accumulateChunks: () => accumulateChunks2,
  accumulate: () => accumulate2,
  StreamTypeId: () => StreamTypeId3,
  Do: () => Do4,
  DefaultChunkSize: () => DefaultChunkSize2
});
var StreamTypeId3 = StreamTypeId2;
var DefaultChunkSize2 = DefaultChunkSize;
var accumulate2 = accumulate;
var accumulateChunks2 = accumulateChunks;
var acquireRelease4 = acquireRelease3;
var aggregate2 = aggregate;
var aggregateWithin2 = aggregateWithin;
var aggregateWithinEither2 = aggregateWithinEither;
var as8 = as7;
var _async2 = _async;
var asyncEffect4 = asyncEffect3;
var asyncPush2 = asyncPush;
var asyncScoped2 = asyncScoped;
var branchAfter2 = branchAfter;
var broadcast2 = broadcast;
var share2 = share;
var broadcastDynamic2 = broadcastDynamic;
var broadcastedQueues2 = broadcastedQueues;
var broadcastedQueuesDynamic2 = broadcastedQueuesDynamic;
var buffer2 = buffer;
var bufferChunks2 = bufferChunks;
var catchAll8 = catchAll7;
var catchAllCause7 = catchAllCause6;
var catchSome4 = catchSome3;
var catchTag4 = catchTag3;
var catchTags4 = catchTags3;
var catchSomeCause4 = catchSomeCause3;
var changes2 = changes;
var changesWith2 = changesWith;
var changesWithEffect2 = changesWithEffect;
var chunks2 = chunks;
var chunksWith2 = chunksWith;
var combine10 = combine9;
var combineChunks2 = combineChunks;
var concat3 = concat2;
var concatAll3 = concatAll2;
var cross2 = cross;
var crossLeft2 = crossLeft;
var crossRight2 = crossRight;
var crossWith2 = crossWith;
var debounce2 = debounce;
var die11 = die10;
var dieSync7 = dieSync6;
var dieMessage5 = dieMessage4;
var distributedWith2 = distributedWith;
var distributedWithDynamic2 = distributedWithDynamic;
var drain4 = drain3;
var drainFork2 = drainFork;
var drop4 = drop3;
var dropRight2 = dropRight;
var dropUntil4 = dropUntil3;
var dropUntilEffect2 = dropUntilEffect;
var dropWhile5 = dropWhile4;
var dropWhileEffect2 = dropWhileEffect;
var either6 = either5;
var empty30 = empty29;
var ensuring7 = ensuring6;
var ensuringWith3 = ensuringWith2;
var context6 = context5;
var contextWith4 = contextWith3;
var contextWithEffect4 = contextWithEffect3;
var contextWithStream2 = contextWithStream;
var execute2 = execute;
var fail17 = fail15;
var failSync8 = failSync7;
var failCause14 = failCause13;
var failCauseSync7 = failCauseSync6;
var filter11 = filter8;
var filterEffect2 = filterEffect;
var filterMap7 = filterMap6;
var filterMapEffect2 = filterMapEffect;
var filterMapWhile4 = filterMapWhile3;
var filterMapWhileEffect2 = filterMapWhileEffect;
var finalizer2 = finalizer;
var find3 = find2;
var findEffect2 = findEffect;
var flatMap18 = flatMap16;
var flatten14 = flatten13;
var flattenChunks2 = flattenChunks;
var flattenEffect2 = flattenEffect;
var flattenExitOption2 = flattenExitOption;
var flattenIterables2 = flattenIterables;
var flattenTake2 = flattenTake;
var forever6 = forever5;
var fromAsyncIterable2 = fromAsyncIterable;
var fromChannel3 = fromChannel2;
var toChannel3 = toChannel2;
var fromChunk2 = fromChunk;
var fromChunkPubSub2 = fromChunkPubSub;
var fromChunkQueue2 = fromChunkQueue;
var fromChunks2 = fromChunks;
var fromEffect8 = fromEffect7;
var fromEffectOption2 = fromEffectOption;
var fromPubSub2 = fromPubSub;
var fromTPubSub2 = fromTPubSub;
var fromIterable10 = fromIterable9;
var fromIterableEffect2 = fromIterableEffect;
var fromIteratorSucceed2 = fromIteratorSucceed;
var fromPull3 = fromPull2;
var fromQueue3 = fromQueue2;
var fromTQueue2 = fromTQueue;
var fromReadableStream2 = fromReadableStream;
var fromReadableStreamByob2 = fromReadableStreamByob;
var fromSchedule2 = fromSchedule;
var groupAdjacentBy2 = groupAdjacentBy;
var groupBy2 = groupBy;
var groupByKey2 = groupByKey;
var grouped2 = grouped;
var groupedWithin2 = groupedWithin;
var haltAfter2 = haltAfter;
var haltWhen2 = haltWhen;
var haltWhenDeferred2 = haltWhenDeferred;
var identity3 = identityStream;
var interleave2 = interleave;
var interleaveWith2 = interleaveWith;
var intersperse2 = intersperse;
var intersperseAffixes2 = intersperseAffixes;
var interruptAfter2 = interruptAfter;
var interruptWhen3 = interruptWhen2;
var interruptWhenDeferred3 = interruptWhenDeferred2;
var iterate4 = iterate3;
var make53 = make50;
var map23 = map21;
var mapAccum6 = mapAccum5;
var mapAccumEffect2 = mapAccumEffect;
var mapBoth8 = mapBoth5;
var mapChunks2 = mapChunks;
var mapChunksEffect2 = mapChunksEffect;
var mapConcat2 = mapConcat;
var mapConcatChunk2 = mapConcatChunk;
var mapConcatChunkEffect2 = mapConcatChunkEffect;
var mapConcatEffect2 = mapConcatEffect;
var mapEffect4 = mapEffectOptions;
var mapError8 = mapError6;
var mapErrorCause5 = mapErrorCause4;
var merge10 = merge9;
var mergeAll9 = mergeAll8;
var mergeWithTag2 = mergeWithTag;
var mergeWith4 = mergeWith3;
var mergeEither2 = mergeEither;
var mergeLeft2 = mergeLeft;
var mergeRight2 = mergeRight;
var mkString3 = mkString2;
var never5 = never4;
var onEnd2 = onEnd;
var onError4 = onError3;
var onDone2 = onDone;
var onStart2 = onStart;
var orDie6 = orDie5;
var orDieWith5 = orDieWith4;
var orElse10 = orElse8;
var orElseEither4 = orElseEither3;
var orElseFail4 = orElseFail3;
var orElseIfEmpty2 = orElseIfEmpty;
var orElseIfEmptyChunk2 = orElseIfEmptyChunk;
var orElseIfEmptyStream2 = orElseIfEmptyStream;
var orElseSucceed4 = orElseSucceed3;
var paginate2 = paginate;
var paginateChunk2 = paginateChunk;
var paginateChunkEffect2 = paginateChunkEffect;
var paginateEffect2 = paginateEffect;
var partition6 = partition5;
var partitionEither2 = partitionEither;
var peel2 = peel;
var pipeThrough2 = pipeThrough;
var pipeThroughChannel2 = pipeThroughChannel;
var pipeThroughChannelOrFail2 = pipeThroughChannelOrFail;
var prepend5 = prepend4;
var provideContext6 = provideContext5;
var provideSomeContext3 = provideSomeContext2;
var provideLayer2 = provideLayer;
var provideService6 = provideService5;
var provideServiceEffect4 = provideServiceEffect3;
var provideServiceStream2 = provideServiceStream;
var mapInputContext6 = mapInputContext5;
var provideSomeLayer3 = provideSomeLayer2;
var race4 = race3;
var raceAll4 = raceAll3;
var range3 = range2;
var rechunk2 = rechunk;
var refineOrDie2 = refineOrDie;
var refineOrDieWith2 = refineOrDieWith;
var repeat3 = repeat2;
var repeatEffect2 = repeatEffect;
var repeatEffectChunk2 = repeatEffectChunk;
var repeatEffectChunkOption2 = repeatEffectChunkOption;
var repeatEffectOption2 = repeatEffectOption;
var repeatEffectWithSchedule2 = repeatEffectWithSchedule;
var repeatEither2 = repeatEither;
var repeatElements2 = repeatElements;
var repeatElementsWith2 = repeatElementsWith;
var repeatValue2 = repeatValue;
var repeatWith2 = repeatWith;
var retry7 = retry6;
var withExecutionPlan4 = withExecutionPlan3;
var run4 = run3;
var runCollect2 = runCollect;
var runCount2 = runCount;
var runDrain3 = runDrain2;
var runFold2 = runFold;
var runFoldEffect2 = runFoldEffect;
var runFoldScoped2 = runFoldScoped;
var runFoldScopedEffect2 = runFoldScopedEffect;
var runFoldWhile2 = runFoldWhile;
var runFoldWhileEffect2 = runFoldWhileEffect;
var runFoldWhileScoped2 = runFoldWhileScoped;
var runFoldWhileScopedEffect2 = runFoldWhileScopedEffect;
var runForEach2 = runForEach;
var runForEachChunk2 = runForEachChunk;
var runForEachChunkScoped2 = runForEachChunkScoped;
var runForEachScoped2 = runForEachScoped;
var runForEachWhile2 = runForEachWhile;
var runForEachWhileScoped2 = runForEachWhileScoped;
var runHead2 = runHead;
var runIntoPubSub2 = runIntoPubSub;
var runIntoPubSubScoped2 = runIntoPubSubScoped;
var runIntoQueue2 = runIntoQueue;
var runIntoQueueElementsScoped2 = runIntoQueueElementsScoped;
var runIntoQueueScoped2 = runIntoQueueScoped;
var runLast2 = runLast;
var runScoped3 = runScoped2;
var runSum2 = runSum;
var scan2 = scan;
var scanEffect2 = scanEffect;
var scanReduce2 = scanReduce;
var scanReduceEffect2 = scanReduceEffect;
var schedule3 = schedule2;
var scheduleWith2 = scheduleWith;
var scoped6 = scoped5;
var scopedWith5 = scopedWith4;
var sliding8 = sliding7;
var slidingSize2 = slidingSize;
var some6 = some5;
var someOrElse2 = someOrElse;
var someOrFail2 = someOrFail;
var split2 = split;
var splitOnChunk2 = splitOnChunk;
var splitLines3 = splitLines2;
var succeed16 = succeed14;
var sync9 = sync8;
var suspend10 = suspend9;
var take8 = take7;
var takeRight3 = takeRight2;
var takeUntil4 = takeUntil3;
var takeUntilEffect2 = takeUntilEffect;
var takeWhile5 = takeWhile4;
var tap7 = tap6;
var tapBoth4 = tapBoth3;
var tapError6 = tapError5;
var tapErrorCause6 = tapErrorCause5;
var tapSink2 = tapSink;
var throttle2 = throttle;
var throttleEffect2 = throttleEffect;
var tick2 = tick;
var timeout4 = timeout3;
var timeoutFail4 = timeoutFail3;
var timeoutFailCause4 = timeoutFailCause3;
var timeoutTo4 = timeoutTo3;
var toPubSub3 = toPubSub2;
var toPull3 = toPull2;
var toQueue3 = toQueue2;
var toQueueOfElements2 = toQueueOfElements;
var toReadableStream2 = toReadableStream;
var toReadableStreamEffect2 = toReadableStreamEffect;
var toReadableStreamRuntime2 = toReadableStreamRuntime;
var toAsyncIterableRuntime2 = toAsyncIterableRuntime;
var toAsyncIterableEffect2 = toAsyncIterableEffect;
var toAsyncIterable2 = toAsyncIterable;
var transduce2 = transduce;
var unfold4 = unfold3;
var unfoldChunk2 = unfoldChunk;
var unfoldChunkEffect2 = unfoldChunkEffect;
var unfoldEffect2 = unfoldEffect;
var void_8 = void_7;
var unwrap3 = unwrap2;
var unwrapScoped5 = unwrapScoped4;
var unwrapScopedWith4 = unwrapScopedWith3;
var updateService5 = updateService4;
var when4 = when3;
var whenCase2 = whenCase;
var whenCaseEffect2 = whenCaseEffect;
var whenEffect4 = whenEffect3;
var withSpan7 = withSpan6;
var zip8 = zip7;
var zipFlatten2 = zipFlatten;
var zipAll2 = zipAll;
var zipAllLeft2 = zipAllLeft;
var zipAllRight2 = zipAllRight;
var zipAllSortedByKey2 = zipAllSortedByKey;
var zipAllSortedByKeyLeft2 = zipAllSortedByKeyLeft;
var zipAllSortedByKeyRight2 = zipAllSortedByKeyRight;
var zipAllSortedByKeyWith2 = zipAllSortedByKeyWith;
var zipAllWith2 = zipAllWith;
var zipLatest2 = zipLatest;
var zipLatestAll2 = zipLatestAll;
var zipLatestWith2 = zipLatestWith;
var zipLeft6 = zipLeft5;
var zipRight9 = zipRight8;
var zipWith11 = zipWith10;
var zipWithChunks2 = zipWithChunks;
var zipWithNext2 = zipWithNext;
var zipWithPrevious2 = zipWithPrevious;
var zipWithPreviousAndNext2 = zipWithPreviousAndNext;
var zipWithIndex2 = zipWithIndex;
var Do4 = Do3;
var bind5 = bind4;
var bindEffect2 = bindEffect;
var bindTo5 = bindTo4;
var let_5 = let_4;
var decodeText2 = decodeText;
var encodeText2 = encodeText;
var fromEventListener2 = fromEventListener;
// src/desktop/protocol.ts
function generateCorrelationId() {
  return `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
}
var isSocketResponse = (msg) => {
  if (typeof msg !== "object" || msg === null)
    return false;
  const obj = msg;
  return typeof obj.type === "string" && obj.type.startsWith("response:");
};
var isHudEvent = (msg) => {
  if (typeof msg !== "object" || msg === null)
    return false;
  const obj = msg;
  if (typeof obj.type !== "string")
    return false;
  return !obj.type.startsWith("request:") && !obj.type.startsWith("response:");
};
var serializeSocketMessage = (msg) => JSON.stringify(msg);
var parseSocketMessage = (data) => {
  try {
    const parsed = JSON.parse(data);
    if (typeof parsed !== "object" || parsed === null)
      return null;
    if (typeof parsed.type !== "string")
      return null;
    return parsed;
  } catch {
    return null;
  }
};
var DESKTOP_HTTP_PORT = 8080;
var DESKTOP_WS_PATH = "/ws";
var DESKTOP_WS_URL = `ws://localhost:${DESKTOP_HTTP_PORT}${DESKTOP_WS_PATH}`;

// src/mainview/socket-client.ts
class SocketClient {
  ws = null;
  url;
  requestTimeout;
  autoReconnect;
  maxReconnectAttempts;
  verbose;
  pendingRequests = new Map;
  messageQueue = [];
  messageHandlers = [];
  connectHandlers = [];
  disconnectHandlers = [];
  reconnectAttempts = 0;
  reconnectTimer = null;
  isConnecting = false;
  constructor(options = {}) {
    this.url = options.url ?? `ws://localhost:${DESKTOP_HTTP_PORT}${DESKTOP_WS_PATH}`;
    this.requestTimeout = options.requestTimeout ?? 1e4;
    this.autoReconnect = options.autoReconnect ?? true;
    this.maxReconnectAttempts = options.maxReconnectAttempts ?? 10;
    this.verbose = options.verbose ?? false;
  }
  connect() {
    return new Promise((resolve, reject) => {
      if (this.ws?.readyState === WebSocket.OPEN) {
        resolve();
        return;
      }
      if (this.isConnecting) {
        const checkInterval = setInterval(() => {
          if (this.ws?.readyState === WebSocket.OPEN) {
            clearInterval(checkInterval);
            resolve();
          }
        }, 100);
        return;
      }
      this.isConnecting = true;
      this.log(`Connecting to ${this.url}`);
      if (window.bunLog) {
        window.bunLog(`[SocketClient] Connecting to ${this.url}`);
      }
      try {
        this.ws = new WebSocket(this.url);
        if (window.bunLog) {
          window.bunLog(`[SocketClient] WebSocket created, waiting for open...`);
        }
        this.ws.onopen = () => {
          this.isConnecting = false;
          this.reconnectAttempts = 0;
          this.log("Connected");
          if (window.bunLog) {
            window.bunLog(`[SocketClient] WebSocket OPEN!`);
          }
          while (this.messageQueue.length > 0) {
            const msg = this.messageQueue.shift();
            this.ws?.send(msg);
          }
          for (const handler of this.connectHandlers) {
            try {
              handler();
            } catch (e) {
              console.error("[SocketClient] Connect handler error:", e);
            }
          }
          resolve();
        };
        this.ws.onmessage = (event) => {
          this.handleMessage(event.data);
        };
        this.ws.onclose = () => {
          this.isConnecting = false;
          this.log("Disconnected");
          for (const handler of this.disconnectHandlers) {
            try {
              handler();
            } catch (e) {
              console.error("[SocketClient] Disconnect handler error:", e);
            }
          }
          if (this.autoReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {
            this.scheduleReconnect();
          }
        };
        this.ws.onerror = (error) => {
          this.isConnecting = false;
          this.log(`Connection error: ${error}`);
          if (window.bunLog) {
            window.bunLog(`[SocketClient] WebSocket ERROR:`, String(error));
          }
          reject(new Error("WebSocket connection failed"));
        };
      } catch (e) {
        this.isConnecting = false;
        reject(e);
      }
    });
  }
  disconnect() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    this.reconnectAttempts = this.maxReconnectAttempts;
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    for (const [_id, pending3] of this.pendingRequests) {
      clearTimeout(pending3.timeout);
      pending3.reject(new Error("Client disconnected"));
    }
    this.pendingRequests.clear();
  }
  isConnected() {
    return this.ws?.readyState === WebSocket.OPEN;
  }
  async request(type, params) {
    const correlationId = generateCorrelationId();
    const request2 = { type, correlationId, ...params };
    return new Promise((resolve, reject) => {
      const timeout5 = setTimeout(() => {
        this.pendingRequests.delete(correlationId);
        reject(new Error(`Request timeout: ${type}`));
      }, this.requestTimeout);
      this.pendingRequests.set(correlationId, {
        resolve,
        reject,
        timeout: timeout5
      });
      const msg = serializeSocketMessage(request2);
      if (this.ws?.readyState === WebSocket.OPEN) {
        this.ws.send(msg);
      } else {
        this.messageQueue.push(msg);
        if (!this.isConnecting && this.autoReconnect) {
          this.connect().catch(() => {});
        }
      }
    });
  }
  onMessage(handler) {
    this.messageHandlers.push(handler);
    return () => {
      const idx = this.messageHandlers.indexOf(handler);
      if (idx >= 0)
        this.messageHandlers.splice(idx, 1);
    };
  }
  onConnect(handler) {
    this.connectHandlers.push(handler);
    return () => {
      const idx = this.connectHandlers.indexOf(handler);
      if (idx >= 0)
        this.connectHandlers.splice(idx, 1);
    };
  }
  onDisconnect(handler) {
    this.disconnectHandlers.push(handler);
    return () => {
      const idx = this.disconnectHandlers.indexOf(handler);
      if (idx >= 0)
        this.disconnectHandlers.splice(idx, 1);
    };
  }
  async loadTBSuite(suitePath) {
    const response = await this.request("request:loadTBSuite", { suitePath });
    if (!response.success) {
      throw new Error(response.error ?? "Failed to load suite");
    }
    return response.data;
  }
  async startTBRun(options) {
    const response = await this.request("request:startTBRun", options);
    if (!response.success) {
      throw new Error(response.error ?? "Failed to start run");
    }
    return response.data;
  }
  async stopTBRun() {
    const response = await this.request("request:stopTBRun", {});
    if (!response.success) {
      throw new Error(response.error ?? "Failed to stop run");
    }
    return response.data;
  }
  async loadRecentTBRuns(count3) {
    const response = await this.request("request:loadRecentTBRuns", { count: count3 });
    if (!response.success) {
      throw new Error(response.error ?? "Failed to load runs");
    }
    return response.data;
  }
  async loadTBRunDetails(runId) {
    const response = await this.request("request:loadTBRunDetails", { runId });
    if (!response.success) {
      throw new Error(response.error ?? "Failed to load run details");
    }
    return response.data ?? null;
  }
  async loadReadyTasks(limit) {
    const response = await this.request("request:loadReadyTasks", { limit });
    if (!response.success) {
      throw new Error(response.error ?? "Failed to load ready tasks");
    }
    return response.data ?? [];
  }
  async assignTaskToMC(taskId, options) {
    const response = await this.request("request:assignTaskToMC", { taskId, options });
    if (!response.success) {
      throw new Error(response.error ?? "Failed to assign task");
    }
    return response.data ?? { assigned: false };
  }
  async loadUnifiedTrajectories(limit) {
    const response = await this.request("request:loadUnifiedTrajectories", { limit });
    if (!response.success) {
      throw new Error(response.error ?? "Failed to load trajectories");
    }
    return response.data ?? [];
  }
  handleMessage(data) {
    const parsed = parseSocketMessage(data);
    if (!parsed) {
      this.log(`Invalid message: ${data.slice(0, 100)}`);
      return;
    }
    if (isSocketResponse(parsed)) {
      const pending3 = this.pendingRequests.get(parsed.correlationId);
      if (pending3) {
        clearTimeout(pending3.timeout);
        this.pendingRequests.delete(parsed.correlationId);
        pending3.resolve(parsed);
      }
      return;
    }
    if (isHudEvent(parsed)) {
      for (const handler of this.messageHandlers) {
        try {
          handler(parsed);
        } catch (e) {
          console.error("[SocketClient] Message handler error:", e);
        }
      }
    }
  }
  scheduleReconnect() {
    if (this.reconnectTimer)
      return;
    const delay3 = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);
    this.log(`Reconnecting in ${delay3}ms (attempt ${this.reconnectAttempts + 1})`);
    this.reconnectTimer = setTimeout(() => {
      this.reconnectTimer = null;
      this.reconnectAttempts++;
      this.connect().catch(() => {});
    }, delay3);
  }
  log(msg) {
    if (this.verbose) {
      console.log(`[SocketClient] ${msg}`);
    }
  }
}
var defaultClient = null;
function getSocketClient(options) {
  if (!defaultClient) {
    defaultClient = new SocketClient(options);
  }
  return defaultClient;
}

// src/effuse/template/types.ts
var isTemplateResult = (value) => typeof value === "object" && value !== null && ("_tag" in value) && value._tag === "TemplateResult";

// src/effuse/template/escape.ts
var ESCAPE_MAP = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var escapeHtml = (str) => str.replace(/[&<>"']/g, (char) => ESCAPE_MAP[char] ?? char);

// src/effuse/template/html.ts
var renderValue = (value) => {
  if (value === null || value === undefined) {
    return "";
  }
  if (typeof value === "string") {
    return escapeHtml(value);
  }
  if (typeof value === "number" || typeof value === "boolean") {
    return String(value);
  }
  if (isTemplateResult(value)) {
    return value.toString();
  }
  if (Array.isArray(value)) {
    return value.map(renderValue).join("");
  }
  return escapeHtml(String(value));
};
function html(strings, ...values3) {
  return {
    _tag: "TemplateResult",
    strings,
    values: values3,
    toString() {
      let result = "";
      for (let i = 0;i < strings.length; i++) {
        result += strings[i];
        if (i < values3.length) {
          result += renderValue(values3[i]);
        }
      }
      return result;
    }
  };
}
function rawHtml(content) {
  return {
    _tag: "TemplateResult",
    strings: [content],
    values: [],
    toString() {
      return content;
    }
  };
}
function joinTemplates(templates, separator = "") {
  const joined = templates.map((t) => t.toString()).join(separator);
  return rawHtml(joined);
}
// src/effuse/state/cell.ts
var makeCell = (initial) => exports_Effect.gen(function* () {
  const ref = yield* exports_Ref.make(initial);
  const queue = yield* exports_Queue.unbounded();
  yield* exports_Effect.addFinalizer(() => exports_Queue.shutdown(queue));
  const cell = {
    get: exports_Ref.get(ref),
    set: (value) => exports_Effect.gen(function* () {
      yield* exports_Ref.set(ref, value);
      yield* exports_Queue.offer(queue, value);
    }),
    update: (f) => exports_Effect.gen(function* () {
      const newValue = yield* exports_Ref.updateAndGet(ref, f);
      yield* exports_Queue.offer(queue, newValue);
    }),
    changes: exports_Stream.fromQueue(queue)
  };
  return cell;
});
// src/effuse/services/dom.ts
class DomError extends Error {
  reason;
  _tag = "DomError";
  constructor(reason, message) {
    super(message);
    this.reason = reason;
    this.name = "DomError";
  }
}

class DomServiceTag extends exports_Context.Tag("effuse/DomService")() {
}
// src/effuse/services/state.ts
class StateServiceTag extends exports_Context.Tag("effuse/StateService")() {
}
// src/effuse/services/socket.ts
class SocketError extends Error {
  reason;
  _tag = "SocketError";
  constructor(reason, message) {
    super(message);
    this.reason = reason;
    this.name = "SocketError";
  }
}

class SocketServiceTag extends exports_Context.Tag("effuse/SocketService")() {
}
// src/effuse/services/dom-live.ts
var makeDomService = (root = document) => ({
  query: (selector) => exports_Effect.gen(function* () {
    const element = root.querySelector(selector);
    if (!element) {
      return yield* exports_Effect.fail(new DomError("element_not_found", `Element not found: ${selector}`));
    }
    return element;
  }),
  queryOption: (selector) => exports_Effect.succeed(root.querySelector(selector)),
  queryId: (id2) => exports_Effect.gen(function* () {
    const element = document.getElementById(id2);
    if (!element) {
      return yield* exports_Effect.fail(new DomError("element_not_found", `Element not found: #${id2}`));
    }
    return element;
  }),
  render: (element, content) => exports_Effect.gen(function* () {
    try {
      element.innerHTML = content.toString();
    } catch (error) {
      return yield* exports_Effect.fail(new DomError("render_failed", `Failed to render: ${error instanceof Error ? error.message : String(error)}`));
    }
  }),
  listen: (element, event, handler, options) => exports_Effect.sync(() => {
    const listener = handler;
    element.addEventListener(event, listener, options);
    return () => element.removeEventListener(event, listener, options);
  }),
  delegate: (container, selector, event, handler) => exports_Effect.sync(() => {
    const listener = (e) => {
      const target = e.target?.closest(selector);
      if (target && container.contains(target)) {
        handler(e, target);
      }
    };
    container.addEventListener(event, listener);
    return () => container.removeEventListener(event, listener);
  }),
  createFragment: (content) => exports_Effect.gen(function* () {
    try {
      const template = document.createElement("template");
      template.innerHTML = content.toString();
      return template.content;
    } catch (error) {
      return yield* exports_Effect.fail(new DomError("render_failed", `Failed to create fragment: ${error instanceof Error ? error.message : String(error)}`));
    }
  })
});
var DomServiceLive = exports_Layer.effect(DomServiceTag, exports_Effect.sync(() => makeDomService()));
// src/effuse/services/state-live.ts
var makeStateService = () => ({
  cell: makeCell
});
var StateServiceLive = exports_Layer.succeed(StateServiceTag, makeStateService());
// src/effuse/services/socket-live.ts
var wrapRequest = (fn2, errorReason = "request_failed") => exports_Effect.tryPromise({
  try: fn2,
  catch: (error) => new SocketError(errorReason, error instanceof Error ? error.message : String(error))
});
var makeSocketService = (client) => {
  let messageStream = null;
  return {
    connect: () => exports_Effect.tryPromise({
      try: () => client.connect(),
      catch: (error) => new SocketError("connection_failed", error instanceof Error ? error.message : String(error))
    }),
    disconnect: () => exports_Effect.sync(() => client.disconnect()),
    isConnected: () => exports_Effect.sync(() => client.isConnected()),
    getMessages: () => {
      if (!messageStream) {
        messageStream = exports_Stream.async((emit2) => {
          const unsubscribe = client.onMessage((message) => {
            emit2.single(message).catch(() => {});
          });
          return exports_Effect.sync(unsubscribe);
        });
      }
      return messageStream;
    },
    loadTBSuite: (suitePath) => wrapRequest(() => client.loadTBSuite(suitePath)),
    startTBRun: (options) => wrapRequest(() => client.startTBRun(options)),
    stopTBRun: () => wrapRequest(() => client.stopTBRun()),
    loadRecentTBRuns: (count3) => wrapRequest(() => client.loadRecentTBRuns(count3)),
    loadTBRunDetails: (runId) => wrapRequest(() => client.loadTBRunDetails(runId)),
    loadReadyTasks: (limit) => wrapRequest(() => client.loadReadyTasks(limit)),
    assignTaskToMC: (taskId, options) => wrapRequest(() => client.assignTaskToMC(taskId, options)),
    loadUnifiedTrajectories: (limit) => wrapRequest(() => client.loadUnifiedTrajectories(limit))
  };
};
var SocketServiceLive = (options) => exports_Layer.succeed(SocketServiceTag, makeSocketService(new SocketClient(options)));
var SocketServiceFromClient = (client) => exports_Layer.succeed(SocketServiceTag, makeSocketService(client));
var SocketServiceDefault = SocketServiceLive();
// src/effuse/widget/mount.ts
var mountWidget = (widget, container) => exports_Effect.gen(function* () {
  const dom = yield* DomServiceTag;
  const stateService = yield* StateServiceTag;
  const state = yield* stateService.cell(widget.initialState());
  const eventQueue = yield* exports_Effect.acquireRelease(exports_Queue.unbounded(), (queue) => exports_Queue.shutdown(queue));
  const emit2 = (event) => exports_Queue.offer(eventQueue, event).pipe(exports_Effect.catchAll(() => exports_Effect.void));
  const ctx = {
    state,
    emit: emit2,
    dom,
    container
  };
  const initialContent = yield* widget.render(ctx);
  yield* dom.render(container, initialContent).pipe(exports_Effect.catchAll((error) => {
    console.error(`[Effuse] Initial render error for "${widget.id}":`, error);
    return exports_Effect.void;
  }));
  if (widget.setupEvents) {
    yield* widget.setupEvents(ctx);
  }
  yield* pipe(state.changes, exports_Stream.tap(() => exports_Effect.gen(function* () {
    const content = yield* widget.render(ctx);
    yield* dom.render(container, content).pipe(exports_Effect.catchAll((error) => {
      console.error(`[Effuse] Re-render error for "${widget.id}":`, error);
      return exports_Effect.void;
    }));
  })), exports_Stream.runDrain, exports_Effect.forkScoped);
  if (widget.handleEvent) {
    yield* pipe(exports_Stream.fromQueue(eventQueue), exports_Stream.tap((event) => widget.handleEvent(event, ctx)), exports_Stream.runDrain, exports_Effect.forkScoped);
  }
  if (widget.subscriptions) {
    const subs = widget.subscriptions(ctx);
    for (const sub of subs) {
      yield* pipe(sub, exports_Stream.tap((effect4) => effect4), exports_Stream.runDrain, exports_Effect.forkScoped);
    }
  }
  const mounted = {
    unmount: exports_Effect.void,
    events: exports_Stream.fromQueue(eventQueue),
    emit: emit2
  };
  return mounted;
});
var mountWidgetById = (widget, containerId) => exports_Effect.gen(function* () {
  const dom = yield* DomServiceTag;
  const container = yield* dom.queryId(containerId);
  return yield* mountWidget(widget, container);
}).pipe(exports_Effect.catchAll((error) => {
  console.error(`[Effuse] Failed to mount widget "${widget.id}":`, error);
  return exports_Effect.succeed({
    unmount: exports_Effect.void,
    events: exports_Stream.empty,
    emit: () => exports_Effect.void
  });
}));
// src/effuse/layers/live.ts
var EffuseLive = exports_Layer.mergeAll(DomServiceLive, StateServiceLive, SocketServiceDefault);
var EffuseLiveNoSocket = exports_Layer.mergeAll(DomServiceLive, StateServiceLive);
// src/effuse/widgets/apm-widget.ts
var getAPMColorClass = (apm) => {
  if (apm >= 30)
    return "text-emerald-400";
  if (apm >= 15)
    return "text-zinc-200";
  if (apm >= 5)
    return "text-zinc-400";
  return "text-zinc-500";
};
var getAPMBgClass = (apm) => {
  if (apm >= 30)
    return "bg-emerald-950/20 border-emerald-800/40";
  if (apm >= 15)
    return "bg-zinc-900/60 border-zinc-700/50";
  if (apm >= 5)
    return "bg-zinc-900/40 border-zinc-700/40";
  return "bg-zinc-950/40 border-zinc-800/30";
};
var formatDuration = (minutes2) => {
  if (minutes2 < 60)
    return `${minutes2.toFixed(0)}m`;
  const hours2 = Math.floor(minutes2 / 60);
  const mins = Math.round(minutes2 % 60);
  return mins > 0 ? `${hours2}h ${mins}m` : `${hours2}h`;
};
var isAPMUpdate = (msg) => msg.type === "apm_update";
var isAPMSnapshot = (msg) => msg.type === "apm_snapshot";
var APMWidget = {
  id: "apm-widget",
  initialState: () => ({
    sessionAPM: 0,
    recentAPM: 0,
    totalActions: 0,
    durationMinutes: 0,
    apm1h: 0,
    apm6h: 0,
    apm1d: 0,
    apmLifetime: 0,
    claudeCodeAPM: 0,
    mechaCoderAPM: 0,
    efficiencyRatio: 0,
    expanded: false
  }),
  render: (ctx) => exports_Effect.gen(function* () {
    const state = yield* ctx.state.get;
    const colorClass = getAPMColorClass(state.sessionAPM);
    const bgClass = getAPMBgClass(state.sessionAPM);
    if (!state.expanded) {
      return html`
          <div
            class="fixed bottom-4 right-4 rounded-xl border ${bgClass} px-4 py-3 shadow-lg backdrop-blur-sm cursor-pointer transition-all hover:scale-105"
            data-action="toggleExpand"
          >
            <div class="flex items-center gap-3">
              <div class="text-2xl font-bold ${colorClass} font-mono">
                ${state.sessionAPM.toFixed(1)}
              </div>
              <div class="text-xs text-zinc-500 uppercase tracking-wide">APM</div>
            </div>
            ${state.totalActions > 0 ? html`
                  <div class="text-xs text-zinc-500 mt-1">
                    ${state.totalActions} actions in ${formatDuration(state.durationMinutes)}
                  </div>
                ` : ""}
          </div>
        `;
    }
    return html`
        <div
          class="fixed bottom-4 right-4 w-72 rounded-xl border ${bgClass} shadow-xl backdrop-blur-sm"
        >
          <!-- Header -->
          <div
            class="flex items-center justify-between px-4 py-3 border-b border-zinc-800/50 cursor-pointer"
            data-action="toggleExpand"
          >
            <div class="flex items-center gap-2">
              <div class="text-xl font-bold ${colorClass} font-mono">
                ${state.sessionAPM.toFixed(1)}
              </div>
              <div class="text-xs text-zinc-500 uppercase">APM</div>
            </div>
            <div class="text-zinc-500 text-sm">-</div>
          </div>

          <!-- Current Session -->
          <div class="px-4 py-3 border-b border-zinc-800/30">
            <div class="text-xs text-zinc-500 uppercase tracking-wide mb-2">Session</div>
            <div class="grid grid-cols-2 gap-2 text-sm">
              <div>
                <span class="text-zinc-500">Recent:</span>
                <span class="text-zinc-300 font-mono ml-1">${state.recentAPM.toFixed(1)}</span>
              </div>
              <div>
                <span class="text-zinc-500">Actions:</span>
                <span class="text-zinc-300 font-mono ml-1">${state.totalActions}</span>
              </div>
              <div class="col-span-2">
                <span class="text-zinc-500">Duration:</span>
                <span class="text-zinc-300 ml-1">${formatDuration(state.durationMinutes)}</span>
              </div>
            </div>
          </div>

          <!-- Historical -->
          ${state.apm1h > 0 || state.apmLifetime > 0 ? html`
                <div class="px-4 py-3 border-b border-zinc-800/30">
                  <div class="text-xs text-zinc-500 uppercase tracking-wide mb-2">Historical</div>
                  <div class="grid grid-cols-2 gap-2 text-sm">
                    <div>
                      <span class="text-zinc-500">1h:</span>
                      <span class="text-zinc-300 font-mono ml-1">${state.apm1h.toFixed(1)}</span>
                    </div>
                    <div>
                      <span class="text-zinc-500">6h:</span>
                      <span class="text-zinc-300 font-mono ml-1">${state.apm6h.toFixed(1)}</span>
                    </div>
                    <div>
                      <span class="text-zinc-500">1d:</span>
                      <span class="text-zinc-300 font-mono ml-1">${state.apm1d.toFixed(1)}</span>
                    </div>
                    <div>
                      <span class="text-zinc-500">All:</span>
                      <span class="text-zinc-300 font-mono ml-1">${state.apmLifetime.toFixed(1)}</span>
                    </div>
                  </div>
                </div>
              ` : ""}

          <!-- Comparison -->
          ${state.efficiencyRatio > 0 ? html`
                <div class="px-4 py-3">
                  <div class="text-xs text-zinc-500 uppercase tracking-wide mb-2">Comparison</div>
                  <div class="grid grid-cols-2 gap-2 text-sm">
                    <div>
                      <span class="text-zinc-500">Claude:</span>
                      <span class="text-zinc-300 font-mono ml-1">${state.claudeCodeAPM.toFixed(1)}</span>
                    </div>
                    <div>
                      <span class="text-zinc-500">MC:</span>
                      <span class="text-zinc-300 font-mono ml-1">${state.mechaCoderAPM.toFixed(1)}</span>
                    </div>
                  </div>
                  <div class="mt-2 text-sm">
                    <span class="text-emerald-400 font-medium">
                      ${state.efficiencyRatio.toFixed(1)}x
                    </span>
                    <span class="text-zinc-500 ml-1">efficiency boost</span>
                  </div>
                </div>
              ` : ""}
        </div>
      `;
  }),
  setupEvents: (ctx) => exports_Effect.gen(function* () {
    yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (_e, target) => {
      const action = target.dataset.action;
      if (action === "toggleExpand") {
        exports_Effect.runFork(ctx.emit({ type: "toggleExpand" }));
      }
    });
  }),
  handleEvent: (event, ctx) => exports_Effect.gen(function* () {
    switch (event.type) {
      case "toggleExpand":
        yield* ctx.state.update((s) => ({ ...s, expanded: !s.expanded }));
        break;
      case "refresh":
        break;
    }
  }),
  subscriptions: (ctx) => {
    const socket = exports_Effect.map(SocketServiceTag, (s) => s);
    return [
      pipe(exports_Stream.unwrap(exports_Effect.map(socket, (s) => s.getMessages())), exports_Stream.filter((msg) => isAPMUpdate(msg) || isAPMSnapshot(msg)), exports_Stream.map((msg) => exports_Effect.gen(function* () {
        if (isAPMUpdate(msg)) {
          yield* ctx.state.update((s) => ({
            ...s,
            sessionAPM: msg.sessionAPM,
            recentAPM: msg.recentAPM,
            totalActions: msg.totalActions,
            durationMinutes: msg.durationMinutes
          }));
        }
        if (isAPMSnapshot(msg)) {
          yield* ctx.state.update((s) => ({
            ...s,
            apm1h: msg.combined.apm1h,
            apm6h: msg.combined.apm6h,
            apm1d: msg.combined.apm1d,
            apmLifetime: msg.combined.apmLifetime,
            claudeCodeAPM: msg.comparison.claudeCodeAPM,
            mechaCoderAPM: msg.comparison.mechaCoderAPM,
            efficiencyRatio: msg.comparison.efficiencyRatio
          }));
        }
      })))
    ];
  }
};
var initialAPMState = APMWidget.initialState();
// src/effuse/widgets/trajectory-pane.ts
var formatTimestamp = (iso) => {
  try {
    return new Date(iso).toLocaleString(undefined, {
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  } catch {
    return iso;
  }
};
var shortId = (id2) => id2.slice(-8);
var getTypeClass = (type) => {
  return type === "tb-run" ? "bg-emerald-900/40 text-emerald-300 border-emerald-700/50" : "bg-violet-900/40 text-violet-300 border-violet-700/50";
};
var getTypeLabel = (type) => {
  return type === "tb-run" ? "TB" : "ATIF";
};
var TrajectoryPaneWidget = {
  id: "trajectory-pane",
  initialState: () => ({
    trajectories: [],
    selectedId: null,
    loading: false,
    error: null,
    collapsed: false
  }),
  render: (ctx) => exports_Effect.gen(function* () {
    const state = yield* ctx.state.get;
    const header = html`
        <div class="flex items-center justify-between px-3 py-2 border-b border-zinc-800/60">
          <button
            class="text-sm font-medium text-zinc-300 hover:text-zinc-100 transition-colors"
            data-action="toggleCollapse"
          >
            ${state.collapsed ? "+" : "-"} Trajectories
          </button>
          <div class="flex items-center gap-2">
            <span class="text-xs text-zinc-500">${state.trajectories.length}</span>
            <button
              class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
              data-action="load"
            >
              ${state.loading ? "Loading..." : "Refresh"}
            </button>
          </div>
        </div>
      `;
    if (state.collapsed) {
      return html`
          <div class="h-full flex flex-col bg-zinc-950/80 border-r border-zinc-800/60">
            ${header}
          </div>
        `;
    }
    if (state.loading && state.trajectories.length === 0) {
      return html`
          <div class="h-full flex flex-col bg-zinc-950/80 border-r border-zinc-800/60">
            ${header}
            <div class="flex-1 flex items-center justify-center">
              <div class="text-sm text-zinc-500">Loading trajectories...</div>
            </div>
          </div>
        `;
    }
    if (state.error && state.trajectories.length === 0) {
      return html`
          <div class="h-full flex flex-col bg-zinc-950/80 border-r border-zinc-800/60">
            ${header}
            <div class="flex-1 flex items-center justify-center p-4">
              <div class="text-sm text-red-400 text-center">${state.error}</div>
            </div>
          </div>
        `;
    }
    if (state.trajectories.length === 0) {
      return html`
          <div class="h-full flex flex-col bg-zinc-950/80 border-r border-zinc-800/60">
            ${header}
            <div class="flex-1 flex items-center justify-center p-4">
              <div class="text-sm text-zinc-500 text-center">
                No trajectories found.<br />
                <button class="text-zinc-400 hover:text-zinc-200 underline mt-2" data-action="load">
                  Load trajectories
                </button>
              </div>
            </div>
          </div>
        `;
    }
    const trajectoryCards = state.trajectories.map((traj) => {
      const isSelected = traj.id === state.selectedId;
      const typeClass = getTypeClass(traj.type);
      return html`
          <div
            class="px-3 py-2 border-b border-zinc-800/40 cursor-pointer transition-colors
                   ${isSelected ? "bg-zinc-800/60" : "hover:bg-zinc-900/40"}"
            data-action="select"
            data-trajectory-id="${traj.id}"
          >
            <div class="flex items-center justify-between mb-1">
              <code class="text-xs font-mono text-zinc-400">${shortId(traj.id)}</code>
              <span class="text-xs px-1.5 py-0.5 rounded border ${typeClass}">
                ${getTypeLabel(traj.type)}
              </span>
            </div>
            <div class="text-sm text-zinc-300 truncate" title="${traj.label}">
              ${traj.label}
            </div>
            <div class="text-xs text-zinc-500 mt-1">
              ${formatTimestamp(traj.timestamp)}
            </div>
          </div>
        `;
    });
    return html`
        <div class="h-full flex flex-col bg-zinc-950/80 border-r border-zinc-800/60">
          ${header}
          <div class="flex-1 overflow-y-auto">
            ${trajectoryCards}
          </div>
        </div>
      `;
  }),
  setupEvents: (ctx) => exports_Effect.gen(function* () {
    yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (_e, target) => {
      const action = target.dataset.action;
      const trajectoryId = target.dataset.trajectoryId;
      if (action === "load") {
        exports_Effect.runFork(ctx.emit({ type: "load" }));
      } else if (action === "select" && trajectoryId) {
        exports_Effect.runFork(ctx.emit({ type: "select", trajectoryId }));
      } else if (action === "toggleCollapse") {
        exports_Effect.runFork(ctx.emit({ type: "toggleCollapse" }));
      }
    });
  }),
  handleEvent: (event, ctx) => exports_Effect.gen(function* () {
    const socket = yield* SocketServiceTag;
    switch (event.type) {
      case "load":
        yield* ctx.state.update((s) => ({ ...s, loading: true, error: null }));
        const result = yield* socket.loadUnifiedTrajectories(50).pipe(exports_Effect.map((trajectories) => ({ trajectories, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ trajectories: [], error: e.message })));
        yield* ctx.state.update((s) => ({
          ...s,
          loading: false,
          trajectories: result.trajectories,
          error: result.error
        }));
        break;
      case "select":
        yield* ctx.state.update((s) => ({ ...s, selectedId: event.trajectoryId }));
        break;
      case "toggleCollapse":
        yield* ctx.state.update((s) => ({ ...s, collapsed: !s.collapsed }));
        break;
      case "clear":
        yield* ctx.state.update((s) => ({
          ...s,
          trajectories: [],
          selectedId: null,
          error: null
        }));
        break;
    }
  })
};
var initialTrajectoryPaneState = TrajectoryPaneWidget.initialState();
// src/effuse/widgets/container-panes.ts
var MAX_VISIBLE_PANES = 10;
var MAX_LINES_PER_PANE = 500;
var getStatusIcon = (pane) => {
  if (pane.status === "running")
    return "";
  if (pane.status === "completed" && pane.exitCode === 0)
    return "";
  return "";
};
var getStatusColorClass = (pane) => {
  if (pane.status === "running")
    return "text-zinc-300";
  if (pane.exitCode === 0)
    return "text-emerald-400";
  return "text-red-400";
};
var formatDuration2 = (ms) => {
  if (ms === undefined)
    return "";
  return `${(ms / 1000).toFixed(1)}s`;
};
var truncateCommand = (command, maxLen = 60) => {
  const full = command.join(" ");
  if (full.length <= maxLen)
    return full;
  return full.slice(0, maxLen) + "...";
};
var isContainerStart = (msg) => msg.type === "container_start";
var isContainerOutput = (msg) => msg.type === "container_output";
var isContainerComplete = (msg) => msg.type === "container_complete";
var isContainerError = (msg) => msg.type === "container_error";
var isContainerMessage = (msg) => isContainerStart(msg) || isContainerOutput(msg) || isContainerComplete(msg) || isContainerError(msg);
var ContainerPanesWidget = {
  id: "container-panes",
  initialState: () => ({
    panes: new Map,
    maxVisible: MAX_VISIBLE_PANES,
    maxLinesPerPane: MAX_LINES_PER_PANE,
    collapsed: false
  }),
  render: (ctx) => exports_Effect.gen(function* () {
    const state = yield* ctx.state.get;
    const panes = Array.from(state.panes.values()).sort((a, b) => b.startedAt.localeCompare(a.startedAt)).slice(0, state.maxVisible);
    const header = html`
        <div class="flex items-center justify-between px-3 py-2 border-b border-zinc-800/60">
          <button
            class="text-sm font-medium text-zinc-300 hover:text-zinc-100 transition-colors"
            data-action="toggleCollapse"
          >
            ${state.collapsed ? "+" : "-"} Containers
          </button>
          <div class="flex items-center gap-2">
            <span class="text-xs text-zinc-500">${panes.length} active</span>
            ${panes.length > 0 ? html`
                  <button
                    class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
                    data-action="clear"
                  >
                    Clear
                  </button>
                ` : ""}
          </div>
        </div>
      `;
    if (state.collapsed) {
      return html`
          <div class="flex flex-col bg-zinc-950/80 border border-zinc-800/60 rounded-lg">
            ${header}
          </div>
        `;
    }
    if (panes.length === 0) {
      return html`
          <div class="flex flex-col bg-zinc-950/80 border border-zinc-800/60 rounded-lg">
            ${header}
            <div class="flex items-center justify-center py-8">
              <div class="text-sm text-zinc-500">No container executions</div>
            </div>
          </div>
        `;
    }
    const paneCards = panes.map((pane) => {
      const statusIcon = getStatusIcon(pane);
      const statusColor = getStatusColorClass(pane);
      const duration2 = formatDuration2(pane.durationMs);
      const cmdDisplay = truncateCommand(pane.command);
      const badge = pane.sandboxed ? html`<span class="text-xs px-1.5 py-0.5 rounded bg-violet-900/40 text-violet-300 border border-violet-700/50">sandbox</span>` : html`<span class="text-xs px-1.5 py-0.5 rounded bg-amber-900/40 text-amber-300 border border-amber-700/50">host</span>`;
      const exitCodeBadge = pane.exitCode !== undefined ? html`
                <span
                  class="text-xs px-1.5 py-0.5 rounded font-mono ${pane.exitCode === 0 ? "bg-emerald-900/40 text-emerald-300" : "bg-red-900/40 text-red-300"}"
                >
                  ${pane.exitCode}
                </span>
              ` : "";
      const outputLines = pane.outputLines.slice(-100).map((line) => html`
            <div class="font-mono text-xs ${line.stream === "stderr" ? "text-red-400" : "text-zinc-300"}">
              ${line.text}
            </div>
          `);
      return html`
          <div
            class="border border-zinc-800/50 rounded-lg overflow-hidden ${pane.status === "running" ? "border-l-2 border-l-blue-500" : ""}"
            data-execution-id="${pane.executionId}"
          >
            <div class="flex items-center justify-between px-3 py-2 bg-zinc-900/60">
              <div class="flex items-center gap-2">
                <span class="${statusColor}">${statusIcon}</span>
                <span class="text-sm text-zinc-300">${pane.image}</span>
                ${badge}
              </div>
              <div class="flex items-center gap-2">
                ${duration2 ? html`<span class="text-xs text-zinc-500">${duration2}</span>` : ""}
                ${exitCodeBadge}
                <button
                  class="text-zinc-500 hover:text-zinc-300 transition-colors"
                  data-action="dismiss"
                  data-execution-id="${pane.executionId}"
                >
                  
                </button>
              </div>
            </div>
            <div class="px-3 py-1 border-b border-zinc-800/40 bg-zinc-900/40">
              <code class="text-xs text-zinc-400 font-mono" title="${pane.command.join(" ")}">
                ${cmdDisplay}
              </code>
            </div>
            <div class="px-3 py-2 max-h-40 overflow-y-auto bg-zinc-950/60">
              ${outputLines.length > 0 ? joinTemplates(outputLines) : html`<div class="text-xs text-zinc-600">No output yet</div>`}
            </div>
          </div>
        `;
    });
    return html`
        <div class="flex flex-col bg-zinc-950/80 border border-zinc-800/60 rounded-lg">
          ${header}
          <div class="p-3 grid gap-3">
            ${joinTemplates(paneCards)}
          </div>
        </div>
      `;
  }),
  setupEvents: (ctx) => exports_Effect.gen(function* () {
    yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (_e, target) => {
      const el = target;
      const action = el.dataset.action;
      const executionId = el.dataset.executionId;
      if (action === "clear") {
        exports_Effect.runFork(ctx.emit({ type: "clear" }));
      } else if (action === "toggleCollapse") {
        exports_Effect.runFork(ctx.emit({ type: "toggleCollapse" }));
      } else if (action === "dismiss" && executionId) {
        exports_Effect.runFork(ctx.emit({ type: "dismiss", executionId }));
      }
    });
  }),
  handleEvent: (event, ctx) => exports_Effect.gen(function* () {
    switch (event.type) {
      case "clear":
        yield* ctx.state.update((s) => ({
          ...s,
          panes: new Map
        }));
        break;
      case "toggleCollapse":
        yield* ctx.state.update((s) => ({ ...s, collapsed: !s.collapsed }));
        break;
      case "dismiss":
        yield* ctx.state.update((s) => {
          const newPanes = new Map(s.panes);
          newPanes.delete(event.executionId);
          return { ...s, panes: newPanes };
        });
        break;
    }
  }),
  subscriptions: (ctx) => {
    const socket = exports_Effect.map(SocketServiceTag, (s) => s);
    return [
      pipe(exports_Stream.unwrap(exports_Effect.map(socket, (s) => s.getMessages())), exports_Stream.filter((msg) => isContainerMessage(msg)), exports_Stream.map((msg) => exports_Effect.gen(function* () {
        if (isContainerStart(msg)) {
          yield* ctx.state.update((s) => {
            const newPanes = new Map(s.panes);
            newPanes.set(msg.executionId, {
              executionId: msg.executionId,
              image: msg.image,
              command: msg.command,
              context: msg.context,
              sandboxed: msg.sandboxed,
              workdir: msg.workdir,
              status: "running",
              outputLines: [],
              startedAt: msg.timestamp
            });
            return { ...s, panes: newPanes };
          });
        }
        if (isContainerOutput(msg)) {
          yield* ctx.state.update((s) => {
            const pane = s.panes.get(msg.executionId);
            if (!pane)
              return s;
            const newPanes = new Map(s.panes);
            const updatedLines = [
              ...pane.outputLines,
              { text: msg.text, stream: msg.stream, sequence: msg.sequence }
            ].slice(-s.maxLinesPerPane);
            newPanes.set(msg.executionId, {
              ...pane,
              outputLines: updatedLines
            });
            return { ...s, panes: newPanes };
          });
        }
        if (isContainerComplete(msg)) {
          yield* ctx.state.update((s) => {
            const pane = s.panes.get(msg.executionId);
            if (!pane)
              return s;
            const newPanes = new Map(s.panes);
            newPanes.set(msg.executionId, {
              ...pane,
              status: "completed",
              exitCode: msg.exitCode,
              durationMs: msg.durationMs
            });
            return { ...s, panes: newPanes };
          });
        }
        if (isContainerError(msg)) {
          yield* ctx.state.update((s) => {
            const pane = s.panes.get(msg.executionId);
            if (!pane)
              return s;
            const newPanes = new Map(s.panes);
            newPanes.set(msg.executionId, {
              ...pane,
              status: "error",
              outputLines: [
                ...pane.outputLines,
                { text: `Error: ${msg.error}`, stream: "stderr", sequence: Date.now() }
              ]
            });
            return { ...s, panes: newPanes };
          });
        }
      })))
    ];
  }
};
var initialContainerPanesState = ContainerPanesWidget.initialState();
// src/hud/protocol.ts
var HUD_WS_PORT = 8080;
var HUD_WS_URL = `ws://localhost:${HUD_WS_PORT}/ws`;
var isATIFStep = (msg) => msg.type === "atif_step";

// src/effuse/widgets/tb-output.ts
var MAX_OUTPUT_LINES = 500;
var getSourceColorClass = (source) => {
  switch (source) {
    case "agent":
      return "text-blue-300";
    case "verification":
      return "text-emerald-300";
    case "system":
      return "text-zinc-400";
    case "tool":
      return "text-amber-300";
  }
};
var getSourceLabel = (source) => {
  switch (source) {
    case "agent":
      return "AGT";
    case "verification":
      return "VRF";
    case "system":
      return "SYS";
    case "tool":
      return "TL";
  }
};
var formatToolCall = (toolCall) => {
  const args2 = toolCall.arguments;
  let argsStr = "";
  if (args2 && typeof args2 === "object") {
    const truncated = Object.entries(args2).slice(0, 3).map(([k, v]) => {
      const val = typeof v === "string" && v.length > 50 ? v.slice(0, 47) + "..." : v;
      return `${k}=${JSON.stringify(val)}`;
    }).join(", ");
    argsStr = truncated + (Object.keys(args2).length > 3 ? ", ..." : "");
  }
  return ` ${toolCall.function_name}(${argsStr})`;
};
var formatObservationResult = (result) => {
  const content = result.content;
  if (typeof content === "string") {
    const truncated = content.length > 100 ? content.slice(0, 97) + "..." : content;
    return ` ${truncated}`;
  }
  if (content && typeof content === "object") {
    const str = JSON.stringify(content);
    return ` ${str.length > 100 ? str.slice(0, 97) + "..." : str}`;
  }
  return ` (result)`;
};
var isTBTaskOutput = (msg) => msg.type === "tb_task_output";
var isTBRunStart = (msg) => msg.type === "tb_run_start";
var isTBRunComplete = (msg) => msg.type === "tb_run_complete";
var isTBMessage = (msg) => isTBTaskOutput(msg) || isTBRunStart(msg) || isTBRunComplete(msg) || isATIFStep(msg);
var TBOutputWidget = {
  id: "tb-output",
  initialState: () => ({
    outputLines: [],
    maxLines: MAX_OUTPUT_LINES,
    visible: false,
    runId: null,
    taskId: null,
    autoScroll: true,
    showLineNumbers: true,
    selectedLine: null,
    visibleSources: {
      agent: true,
      verification: true,
      system: true,
      tool: true
    }
  }),
  render: (ctx) => exports_Effect.gen(function* () {
    const state = yield* ctx.state.get;
    if (!state.visible) {
      return html`<div class="hidden"></div>`;
    }
    const header = html`
        <div class="flex items-center justify-between px-3 py-2 border-b border-zinc-800/60 bg-zinc-900/80">
          <div class="flex items-center gap-2">
            <span class="text-sm font-medium text-zinc-300">TB Output</span>
            ${state.runId ? html`<code class="text-xs text-zinc-500 font-mono">${state.runId.slice(-8)}</code>` : ""}
            ${state.taskId ? html`<span class="text-xs text-zinc-400"> ${state.taskId}</span>` : ""}
          </div>
          <div class="flex items-center gap-2">
            <button
              class="text-xs px-2 py-1 rounded border transition-colors ${state.autoScroll ? "bg-blue-900/40 text-blue-300 border-blue-700/50" : "text-zinc-400 border-zinc-700/50 hover:border-zinc-600/60"}"
              data-action="toggleAutoScroll"
              title="Auto-scroll"
            >
              
            </button>
            <div class="flex items-center gap-1">
              ${["agent", "verification", "system", "tool"].map((source) => {
      const active2 = state.visibleSources[source];
      const label = getSourceLabel(source);
      const base = "text-xs px-2 py-1 rounded border transition-colors";
      const activeClasses = "bg-zinc-800/80 text-zinc-100 border-zinc-600/60";
      const inactiveClasses = "text-zinc-400 border-zinc-700/50 hover:border-zinc-600/60";
      return html`
                  <button
                    class="${base} ${active2 ? activeClasses : inactiveClasses}"
                    data-action="toggleSource"
                    data-source="${source}"
                    title="Toggle ${source} output"
                  >
                    ${label}
                  </button>
                `;
    })}
            </div>
            <button
              class="text-xs px-2 py-1 rounded border transition-colors ${state.showLineNumbers ? "bg-zinc-800/80 text-zinc-100 border-zinc-600/60" : "text-zinc-400 border-zinc-700/50 hover:border-zinc-600/60"}"
              data-action="toggleLineNumbers"
              title="Toggle line numbers"
            >
              #
            </button>
            <button
              class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
              data-action="copy"
            >
              Copy
            </button>
            <button
              class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
              data-action="clear"
            >
              Clear
            </button>
            <button
              class="text-zinc-500 hover:text-zinc-300 transition-colors"
              data-action="close"
            >
              
            </button>
          </div>
        </div>
      `;
    const visibleLines = state.outputLines.filter((line) => state.visibleSources[line.source]);
    const lines = visibleLines.length > 0 ? joinTemplates(visibleLines.slice(-100).map((line, index, arr) => {
      const lineNumber = state.outputLines.length - arr.length + index + 1;
      const lineNumberStyles = state.selectedLine === lineNumber ? "bg-zinc-800/80 text-zinc-100 border-zinc-700/60" : "text-zinc-500 border-transparent";
      return html`
                  <div class="flex gap-2 font-mono text-xs leading-relaxed">
                    ${state.showLineNumbers ? html`
                          <button
                            class="w-10 text-right pr-2 rounded border ${lineNumberStyles}"
                            data-action="selectLine"
                            data-line="${lineNumber}"
                            title="Line ${lineNumber}"
                          >
                            ${lineNumber}
                          </button>
                        ` : ""}
                    <span class="w-8 flex-shrink-0 ${getSourceColorClass(line.source)}">
                      ${getSourceLabel(line.source)}
                    </span>
                    <span class="text-zinc-300 whitespace-pre-wrap break-all">${line.text}</span>
                  </div>
                `;
    })) : html`<div class="text-xs text-zinc-600 italic">No output yet</div>`;
    return html`
        <div class="fixed right-4 bottom-20 w-[600px] max-h-[400px] flex flex-col bg-zinc-950/95 border border-zinc-800/60 rounded-lg shadow-xl backdrop-blur-sm overflow-hidden">
          ${header}
          <div
            class="flex-1 p-3 overflow-y-auto space-y-1"
            id="tb-output-scroll"
            data-autoscroll="${state.autoScroll ? "true" : "false"}"
          >
            ${lines}
          </div>
          <div class="px-3 py-1 border-t border-zinc-800/40 bg-zinc-900/60 text-xs text-zinc-500">
            ${visibleLines.length} lines
          </div>
        </div>
      `;
  }),
  setupEvents: (ctx) => exports_Effect.gen(function* () {
    yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (_e, target) => {
      const action = target.dataset.action;
      if (action === "clear") {
        exports_Effect.runFork(ctx.emit({ type: "clear" }));
      } else if (action === "copy") {
        exports_Effect.runFork(ctx.emit({ type: "copy" }));
      } else if (action === "close") {
        exports_Effect.runFork(ctx.emit({ type: "close" }));
      } else if (action === "toggleAutoScroll") {
        exports_Effect.runFork(ctx.emit({ type: "toggleAutoScroll" }));
      } else if (action === "toggleLineNumbers") {
        exports_Effect.runFork(ctx.emit({ type: "toggleLineNumbers" }));
      } else if (action === "selectLine") {
        const lineValue = target.dataset.line;
        if (lineValue) {
          exports_Effect.runFork(ctx.emit({ type: "selectLine", lineNumber: Number(lineValue) }));
        }
      } else if (action === "toggleSource") {
        const source = target.dataset.source;
        if (source) {
          exports_Effect.runFork(ctx.emit({ type: "toggleSource", source }));
        }
      }
    });
  }),
  handleEvent: (event, ctx) => exports_Effect.gen(function* () {
    switch (event.type) {
      case "clear":
        yield* ctx.state.update((s) => ({
          ...s,
          outputLines: [],
          selectedLine: null
        }));
        break;
      case "copy": {
        const state = yield* ctx.state.get;
        const linesToCopy = state.outputLines.filter((line) => state.visibleSources[line.source]);
        const total = state.outputLines.length;
        const start3 = total - linesToCopy.length;
        const text = linesToCopy.map((l, index) => {
          const lineNumber = start3 + index + 1;
          const prefix = state.showLineNumbers ? `${lineNumber}: ` : "";
          return `${prefix}[${l.source}] ${l.text}`;
        }).join(`
`);
        if (typeof navigator !== "undefined" && navigator.clipboard) {
          try {
            yield* exports_Effect.promise(() => navigator.clipboard.writeText(text));
          } catch {}
        }
        break;
      }
      case "close":
        yield* ctx.state.update((s) => ({ ...s, visible: false }));
        break;
      case "open":
        yield* ctx.state.update((s) => ({ ...s, visible: true }));
        break;
      case "toggleAutoScroll":
        yield* ctx.state.update((s) => ({ ...s, autoScroll: !s.autoScroll }));
        break;
      case "toggleLineNumbers":
        yield* ctx.state.update((s) => ({
          ...s,
          showLineNumbers: !s.showLineNumbers,
          selectedLine: s.showLineNumbers ? null : s.selectedLine
        }));
        break;
      case "selectLine":
        yield* ctx.state.update((s) => ({
          ...s,
          selectedLine: s.selectedLine === event.lineNumber ? null : event.lineNumber
        }));
        break;
      case "toggleSource":
        yield* ctx.state.update((s) => ({
          ...s,
          visibleSources: {
            ...s.visibleSources,
            [event.source]: !s.visibleSources[event.source]
          },
          selectedLine: s.showLineNumbers ? s.selectedLine : null
        }));
        break;
    }
  }),
  subscriptions: (ctx) => {
    const socket = exports_Effect.map(SocketServiceTag, (s) => s);
    return [
      pipe(exports_Stream.unwrap(exports_Effect.map(socket, (s) => s.getMessages())), exports_Stream.filter((msg) => isTBMessage(msg)), exports_Stream.map((msg) => exports_Effect.gen(function* () {
        if (isTBRunStart(msg)) {
          yield* ctx.state.update((s) => ({
            ...s,
            runId: msg.runId,
            taskId: null,
            outputLines: [],
            visible: true,
            selectedLine: null,
            visibleSources: {
              agent: true,
              verification: true,
              system: true,
              tool: true
            }
          }));
        }
        if (isTBTaskOutput(msg)) {
          yield* ctx.state.update((s) => {
            if (s.runId && s.runId !== msg.runId)
              return s;
            const newLines = [
              ...s.outputLines,
              {
                text: msg.text,
                source: msg.source,
                timestamp: Date.now()
              }
            ].slice(-s.maxLines);
            return {
              ...s,
              taskId: msg.taskId,
              outputLines: newLines
            };
          });
        }
        if (isATIFStep(msg)) {
          yield* ctx.state.update((s) => {
            if (s.runId && s.runId !== msg.runId)
              return s;
            const newLines = [...s.outputLines];
            const timestamp = Date.now();
            if (msg.step.tool_calls && msg.step.tool_calls.length > 0) {
              for (const toolCall of msg.step.tool_calls) {
                newLines.push({
                  text: formatToolCall(toolCall),
                  source: "tool",
                  timestamp
                });
              }
            }
            if (msg.step.observation?.results && msg.step.observation.results.length > 0) {
              for (const result of msg.step.observation.results) {
                newLines.push({
                  text: formatObservationResult(result),
                  source: "tool",
                  timestamp
                });
              }
            }
            return {
              ...s,
              outputLines: newLines.slice(-s.maxLines)
            };
          });
        }
        if (isTBRunComplete(msg)) {
          yield* ctx.state.update((s) => {
            if (s.runId !== msg.runId)
              return s;
            return {
              ...s,
              runId: null
            };
          });
        }
      })))
    ];
  }
};
var initialTBOutputState = TBOutputWidget.initialState();
// src/effuse/widgets/mc-tasks.ts
var getPriorityLabel = (priority) => {
  return `P${priority}`;
};
var getPriorityClasses = (priority) => {
  switch (priority) {
    case 0:
      return "bg-red-900/40 text-red-300 border-red-700/50";
    case 1:
      return "bg-orange-900/40 text-orange-300 border-orange-700/50";
    case 2:
      return "bg-zinc-800/50 text-zinc-200 border-zinc-600/50";
    case 3:
      return "bg-zinc-800/30 text-zinc-300 border-zinc-700/40";
    case 4:
      return "bg-zinc-900/30 text-zinc-400 border-zinc-700/30";
    default:
      return "bg-zinc-800/40 text-zinc-300 border-zinc-600/40";
  }
};
var getTypeBadgeClass = (type) => {
  switch (type) {
    case "bug":
      return "text-red-400";
    case "feature":
      return "text-emerald-400";
    case "task":
      return "text-blue-400";
    case "epic":
      return "text-violet-400";
    case "chore":
      return "text-zinc-400";
    default:
      return "text-zinc-400";
  }
};
var MCTasksWidget = {
  id: "mc-tasks",
  initialState: () => ({
    tasks: [],
    loading: false,
    error: null,
    collapsed: false,
    maxDisplay: 20,
    assigningId: null
  }),
  render: (ctx) => exports_Effect.gen(function* () {
    const state = yield* ctx.state.get;
    const header = html`
        <div
          class="flex items-center justify-between px-4 py-3 border-b border-zinc-800/60 cursor-pointer"
          data-action="toggleCollapse"
        >
          <h2 class="text-zinc-100 font-bold font-mono text-lg">
            Ready Tasks (${state.tasks.length})
          </h2>
          <div class="flex items-center gap-3">
            <button
              class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
              data-action="load"
            >
              ${state.loading ? "Loading..." : "Refresh"}
            </button>
            <span class="text-zinc-500">${state.collapsed ? "" : ""}</span>
          </div>
        </div>
      `;
    if (state.loading && state.tasks.length === 0) {
      return html`
          <div class="rounded-2xl border border-zinc-800/60 bg-zinc-950/80 shadow-2xl backdrop-blur-xl">
            ${header}
            <div class="flex items-center justify-center py-8">
              <div class="text-zinc-400 font-mono text-sm">Loading ready tasks...</div>
            </div>
          </div>
        `;
    }
    if (state.error && state.tasks.length === 0) {
      return html`
          <div class="rounded-2xl border border-zinc-800/60 bg-zinc-950/80 shadow-2xl backdrop-blur-xl">
            ${header}
            <div class="flex items-center justify-center py-8">
              <div class="text-red-400 font-mono text-sm">${state.error}</div>
            </div>
          </div>
        `;
    }
    if (state.tasks.length === 0) {
      return html`
          <div class="rounded-2xl border border-zinc-800/60 bg-zinc-950/80 shadow-2xl backdrop-blur-xl">
            ${header}
            <div class="flex items-center justify-center py-8">
              <div class="text-zinc-500 font-mono text-sm">No ready tasks found</div>
            </div>
          </div>
        `;
    }
    if (state.collapsed) {
      return html`
          <div class="rounded-2xl border border-zinc-800/60 bg-zinc-950/80 shadow-2xl backdrop-blur-xl">
            ${header}
          </div>
        `;
    }
    const taskRows = state.tasks.slice(0, state.maxDisplay).map((task) => {
      const prioClasses = getPriorityClasses(task.priority);
      const prioLabel = getPriorityLabel(task.priority);
      const typeClass = getTypeBadgeClass(task.type);
      const labelsStr = task.labels.slice(0, 2).join(", ");
      const isAssigning = state.assigningId === task.id;
      return html`
          <tr class="border-b border-zinc-800/40 last:border-0 hover:bg-zinc-900/30">
            <td class="py-2 px-3">
              <span class="inline-flex items-center px-1.5 py-0.5 text-[10px] font-bold rounded border ${prioClasses}">
                ${prioLabel}
              </span>
            </td>
            <td class="py-2 px-3">
              <code class="text-zinc-500 font-mono text-[10px]">${task.id}</code>
            </td>
            <td class="py-2 px-3">
              <span class="font-medium font-mono text-zinc-100 text-sm" title="${task.title}">
                ${task.title.length > 50 ? task.title.slice(0, 50) + "..." : task.title}
              </span>
            </td>
            <td class="py-2 px-3">
              <span class="${typeClass} font-mono text-xs">${task.type}</span>
            </td>
            <td class="py-2 px-3">
              <span class="text-zinc-400 font-mono text-xs">${labelsStr}</span>
            </td>
            <td class="py-2 px-3">
              <button
                class="inline-flex items-center justify-center border px-3 py-1 text-[10px] font-mono font-semibold uppercase rounded transition-colors
                       ${isAssigning ? "border-zinc-600 text-zinc-500 bg-zinc-800/40 cursor-not-allowed" : "border-zinc-700 text-zinc-50 bg-zinc-900/80 hover:bg-zinc-900/95"}"
                data-action="assign"
                data-task-id="${task.id}"
                ${isAssigning ? "disabled" : ""}
              >
                ${isAssigning ? "Starting..." : "Assign"}
              </button>
            </td>
          </tr>
        `;
    });
    const moreIndicator = state.tasks.length > state.maxDisplay ? html`
              <div class="px-4 py-2 border-t border-zinc-800/60 text-center text-xs font-mono text-zinc-500">
                + ${state.tasks.length - state.maxDisplay} more tasks...
              </div>
            ` : "";
    return html`
        <div class="rounded-2xl border border-zinc-800/60 bg-zinc-950/80 shadow-2xl backdrop-blur-xl max-h-[70vh] overflow-hidden">
          ${header}
          <div class="overflow-x-auto max-h-[calc(70vh-60px)] overflow-y-auto">
            <table class="min-w-full table-auto text-xs font-mono text-zinc-200">
              <thead>
                <tr class="text-zinc-500 uppercase text-[9px] tracking-[0.4em] bg-zinc-900/40">
                  <th class="w-12 px-3 py-2 text-left">Pri</th>
                  <th class="w-24 px-3 py-2 text-left">ID</th>
                  <th class="px-3 py-2 text-left">Title</th>
                  <th class="w-20 px-3 py-2 text-left">Type</th>
                  <th class="w-32 px-3 py-2 text-left">Labels</th>
                  <th class="w-24 px-3 py-2 text-left">Action</th>
                </tr>
              </thead>
              <tbody>
                ${joinTemplates(taskRows)}
              </tbody>
            </table>
          </div>
          ${moreIndicator}
        </div>
      `;
  }),
  setupEvents: (ctx) => exports_Effect.gen(function* () {
    yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (e, target) => {
      const el = target;
      const action = el.dataset.action;
      const taskId = el.dataset.taskId;
      if (action === "load") {
        e.stopPropagation();
        exports_Effect.runFork(ctx.emit({ type: "load" }));
      } else if (action === "toggleCollapse") {
        exports_Effect.runFork(ctx.emit({ type: "toggleCollapse" }));
      } else if (action === "assign" && taskId) {
        e.stopPropagation();
        exports_Effect.runFork(ctx.emit({ type: "assign", taskId }));
      }
    });
  }),
  handleEvent: (event, ctx) => exports_Effect.gen(function* () {
    const socket = yield* SocketServiceTag;
    switch (event.type) {
      case "load":
        yield* ctx.state.update((s) => ({ ...s, loading: true, error: null }));
        const result = yield* socket.loadReadyTasks(50).pipe(exports_Effect.map((tasks) => ({ tasks, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ tasks: [], error: e.message })));
        yield* ctx.state.update((s) => ({
          ...s,
          loading: false,
          tasks: result.tasks,
          error: result.error
        }));
        break;
      case "toggleCollapse":
        yield* ctx.state.update((s) => ({ ...s, collapsed: !s.collapsed }));
        break;
      case "assign":
        yield* ctx.state.update((s) => ({ ...s, assigningId: event.taskId }));
        const assignResult = yield* socket.assignTaskToMC(event.taskId, { sandbox: true }).pipe(exports_Effect.map(() => ({ success: true, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ success: false, error: e.message })));
        if (assignResult.success) {
          yield* ctx.state.update((s) => ({
            ...s,
            assigningId: null,
            tasks: s.tasks.filter((t) => t.id !== event.taskId)
          }));
        } else {
          yield* ctx.state.update((s) => ({
            ...s,
            assigningId: null,
            error: assignResult.error
          }));
        }
        break;
    }
  })
};
var initialMCTasksState = MCTasksWidget.initialState();
// src/effuse/widgets/tb-controls.ts
var getDifficultyClass = (difficulty) => {
  switch (difficulty.toLowerCase()) {
    case "easy":
      return "bg-emerald-900/40 text-emerald-300 border-emerald-700/50";
    case "medium":
      return "bg-amber-900/40 text-amber-300 border-amber-700/50";
    case "hard":
      return "bg-red-900/40 text-red-300 border-red-700/50";
    default:
      return "bg-zinc-800/40 text-zinc-300 border-zinc-700/50";
  }
};
var getStatusColorClass2 = (statusType) => {
  switch (statusType) {
    case "running":
      return "text-blue-400";
    case "error":
      return "text-red-400";
    case "success":
      return "text-emerald-400";
    case "loading":
      return "text-zinc-400";
    default:
      return "text-zinc-500";
  }
};
var formatDuration3 = (ms) => {
  const totalSeconds = Math.floor(ms / 1000);
  const hours2 = Math.floor(totalSeconds / 3600);
  const minutes2 = Math.floor(totalSeconds % 3600 / 60);
  const seconds2 = totalSeconds % 60;
  return `${String(hours2).padStart(2, "0")}:${String(minutes2).padStart(2, "0")}:${String(seconds2).padStart(2, "0")}`;
};
var isTBRunStart2 = (msg) => msg.type === "tb_run_start";
var isTBRunComplete2 = (msg) => msg.type === "tb_run_complete";
var isTBTaskComplete = (msg) => msg.type === "tb_task_complete";
var isTBMessage2 = (msg) => isTBRunStart2(msg) || isTBRunComplete2(msg) || isTBTaskComplete(msg);
var TBControlsWidget = {
  id: "tb-controls",
  initialState: () => ({
    suitePath: "./tasks/terminal-bench-2.json",
    suite: null,
    selectedTaskIds: new Set,
    loading: false,
    status: "Ready",
    statusType: "idle",
    isRunning: false,
    runId: null,
    collapsed: false,
    totalTasks: 0,
    completedTasks: 0,
    passedTasks: 0,
    failedTasks: 0,
    startedAt: null,
    duration: null,
    difficultyFilter: null,
    searchFilter: ""
  }),
  render: (ctx) => exports_Effect.gen(function* () {
    const state = yield* ctx.state.get;
    const statusColor = getStatusColorClass2(state.statusType);
    const header = html`
        <div
          class="flex items-center justify-between px-4 py-3 border-b border-zinc-800/60 cursor-pointer"
          data-action="toggleCollapse"
        >
          <div class="flex items-center gap-3">
            <h2 class="text-zinc-100 font-bold font-mono text-lg">Terminal-Bench</h2>
            <span class="text-xs ${statusColor}">${state.status}</span>
          </div>
          <span class="text-zinc-500">${state.collapsed ? "" : ""}</span>
        </div>
      `;
    if (state.collapsed) {
      return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header}
          </div>
        `;
    }
    const pathInput = html`
        <div class="flex items-center gap-2 px-4 py-3 border-b border-zinc-800/40">
          <input
            type="text"
            class="flex-1 bg-zinc-900/60 border border-zinc-700/50 rounded px-3 py-2 text-sm font-mono text-zinc-200 placeholder-zinc-500 focus:border-zinc-600/60 focus:outline-none"
            placeholder="Path to suite..."
            value="${state.suitePath}"
            data-input="suitePath"
            ${state.isRunning ? "disabled" : ""}
          />
          <button
            class="px-3 py-2 text-xs font-mono uppercase rounded border transition-colors
                   ${state.isRunning ? "border-zinc-700 text-zinc-500 bg-zinc-800/40 cursor-not-allowed" : "border-zinc-700 text-zinc-200 bg-zinc-900/80 hover:bg-zinc-900/95"}"
            data-action="loadSuite"
            ${state.isRunning ? "disabled" : ""}
          >
            ${state.loading ? "Loading..." : "Load"}
          </button>
        </div>
      `;
    const controls = html`
        <div class="flex items-center gap-2 px-4 py-3 border-b border-zinc-800/40">
          <button
            class="px-4 py-2 text-xs font-mono uppercase rounded border transition-colors
                   ${state.isRunning || !state.suite ? "border-zinc-700 text-zinc-500 bg-zinc-800/40 cursor-not-allowed" : "border-emerald-700 text-emerald-300 bg-emerald-900/40 hover:bg-emerald-900/60"}"
            data-action="startRun"
            ${state.isRunning || !state.suite ? "disabled" : ""}
          >
            Start
          </button>
          <button
            class="px-4 py-2 text-xs font-mono uppercase rounded border transition-colors
                   ${state.isRunning || !state.suite ? "border-zinc-700 text-zinc-500 bg-zinc-800/40 cursor-not-allowed" : "border-violet-700 text-violet-300 bg-violet-900/40 hover:bg-violet-900/60"}"
            data-action="startRandomTask"
            ${state.isRunning || !state.suite ? "disabled" : ""}
          >
            Random
          </button>
          <button
            class="px-4 py-2 text-xs font-mono uppercase rounded border transition-colors
                   ${!state.isRunning ? "border-zinc-700 text-zinc-500 bg-zinc-800/40 cursor-not-allowed" : "border-red-700 text-red-300 bg-red-900/40 hover:bg-red-900/60"}"
            data-action="stopRun"
            ${!state.isRunning ? "disabled" : ""}
          >
            Stop
          </button>
          <span class="flex-1"></span>
          <span class="text-xs text-zinc-500 font-mono">
            ${state.selectedTaskIds.size}/${state.suite?.tasks.length ?? 0} selected
          </span>
        </div>
      `;
    const progressPercent = state.totalTasks > 0 ? Math.round(state.completedTasks / state.totalTasks * 100) : 0;
    const passPercent = state.totalTasks > 0 ? Math.round(state.passedTasks / state.totalTasks * 100) : 0;
    const failPercent = state.totalTasks > 0 ? Math.round(state.failedTasks / state.totalTasks * 100) : 0;
    const elapsedMs = state.startedAt ? state.duration ?? Date.now() - state.startedAt : state.duration ?? 0;
    const durationDisplay = elapsedMs > 0 ? formatDuration3(elapsedMs) : null;
    const progressBar = state.isRunning || state.completedTasks > 0 ? html`
        <div class="px-4 py-2 border-b border-zinc-800/40" data-testid="progress-bar">
          <div class="flex items-center justify-between mb-1">
            <div class="flex items-center gap-3">
              <span class="text-xs font-mono text-zinc-400">
                Progress: ${state.completedTasks}/${state.totalTasks} (${progressPercent}%)
              </span>
              ${durationDisplay ? html`<span class="text-xs font-mono text-zinc-500" data-testid="run-duration"> ${durationDisplay}</span>` : ""}
            </div>
            <span class="text-xs font-mono">
              <span class="text-emerald-400">${state.passedTasks}</span>
              <span class="text-zinc-500 mx-1">|</span>
              <span class="text-red-400">${state.failedTasks}</span>
            </span>
          </div>
          <div class="h-2 bg-zinc-800 rounded-full overflow-hidden">
            <div class="h-full flex">
              <div
                class="bg-emerald-500 transition-all duration-300"
                style="width: ${passPercent}%"
                data-testid="progress-passed"
              ></div>
              <div
                class="bg-red-500 transition-all duration-300"
                style="width: ${failPercent}%"
                data-testid="progress-failed"
              ></div>
            </div>
          </div>
        </div>
      ` : "";
    const taskList = state.suite ? html`
            <div class="border-b border-zinc-800/40">
              <div class="flex items-center justify-between px-4 py-2 bg-zinc-900/40">
                <span class="text-xs text-zinc-400 font-mono">
                  ${state.suite.name} v${state.suite.version}
                </span>
                <div class="flex items-center gap-2">
                  <button
                    class="text-xs text-zinc-400 hover:text-zinc-200 transition-colors"
                    data-action="selectAll"
                  >
                    All
                  </button>
                  <span class="text-zinc-600">|</span>
                  <button
                    class="text-xs text-zinc-400 hover:text-zinc-200 transition-colors"
                    data-action="selectNone"
                  >
                    None
                  </button>
                </div>
              </div>
              <div class="flex items-center gap-2 px-4 py-2 border-b border-zinc-800/40 bg-zinc-900/20">
                <input
                  type="text"
                  class="flex-1 bg-zinc-900/60 border border-zinc-700/50 rounded px-2 py-1 text-xs font-mono text-zinc-200 placeholder-zinc-500 focus:border-zinc-600/60 focus:outline-none"
                  placeholder="Search tasks..."
                  value="${state.searchFilter}"
                  data-input="searchFilter"
                />
                <select
                  class="bg-zinc-900/60 border border-zinc-700/50 rounded px-2 py-1 text-xs font-mono text-zinc-200 focus:border-zinc-600/60 focus:outline-none"
                  data-input="difficultyFilter"
                >
                  <option value="" ${!state.difficultyFilter ? "selected" : ""}>All Difficulties</option>
                  <option value="easy" ${state.difficultyFilter === "easy" ? "selected" : ""}>Easy</option>
                  <option value="medium" ${state.difficultyFilter === "medium" ? "selected" : ""}>Medium</option>
                  <option value="hard" ${state.difficultyFilter === "hard" ? "selected" : ""}>Hard</option>
                </select>
              </div>
              <div class="max-h-60 overflow-y-auto">
                ${joinTemplates(state.suite.tasks.filter((task) => {
      if (state.difficultyFilter && task.difficulty.toLowerCase() !== state.difficultyFilter.toLowerCase()) {
        return false;
      }
      if (state.searchFilter) {
        const search = state.searchFilter.toLowerCase();
        return task.name.toLowerCase().includes(search) || task.id.toLowerCase().includes(search);
      }
      return true;
    }).map((task) => {
      const isSelected = state.selectedTaskIds.has(task.id);
      const diffClass = getDifficultyClass(task.difficulty);
      return html`
                      <label
                        class="flex items-center gap-3 px-4 py-2 hover:bg-zinc-900/40 cursor-pointer transition-colors"
                      >
                        <input
                          type="checkbox"
                          class="form-checkbox rounded border-zinc-600 bg-zinc-800 text-blue-500 focus:ring-blue-500/20"
                          data-action="toggleTask"
                          data-task-id="${task.id}"
                          ${isSelected ? "checked" : ""}
                        />
                        <span class="flex-1 text-sm font-mono text-zinc-200 truncate" title="${task.name}">
                          ${task.name}
                        </span>
                        <span class="text-xs px-1.5 py-0.5 rounded border ${diffClass}">
                          ${task.difficulty}
                        </span>
                      </label>
                    `;
    }))}
              </div>
            </div>
          ` : "";
    return html`
        <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm overflow-hidden">
          ${header}
          ${pathInput}
          ${controls}
          ${progressBar}
          ${taskList}
        </div>
      `;
  }),
  setupEvents: (ctx) => exports_Effect.gen(function* () {
    yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (e, target) => {
      const el = target;
      const action = el.dataset.action;
      const taskId = el.dataset.taskId;
      if (action === "toggleCollapse") {
        exports_Effect.runFork(ctx.emit({ type: "toggleCollapse" }));
      } else if (action === "loadSuite") {
        e.stopPropagation();
        exports_Effect.runFork(ctx.emit({ type: "loadSuite" }));
      } else if (action === "startRun") {
        e.stopPropagation();
        exports_Effect.runFork(ctx.emit({ type: "startRun" }));
      } else if (action === "startRandomTask") {
        e.stopPropagation();
        exports_Effect.runFork(ctx.emit({ type: "startRandomTask" }));
      } else if (action === "stopRun") {
        e.stopPropagation();
        exports_Effect.runFork(ctx.emit({ type: "stopRun" }));
      } else if (action === "selectAll") {
        e.stopPropagation();
        exports_Effect.runFork(ctx.emit({ type: "selectAll" }));
      } else if (action === "selectNone") {
        e.stopPropagation();
        exports_Effect.runFork(ctx.emit({ type: "selectNone" }));
      } else if (action === "toggleTask" && taskId) {
        exports_Effect.runFork(ctx.emit({ type: "toggleTask", taskId }));
      }
    });
    yield* ctx.dom.delegate(ctx.container, "[data-input]", "input", (_e, target) => {
      const el = target;
      const inputType = el.dataset.input;
      if (inputType === "suitePath") {
        exports_Effect.runFork(ctx.emit({ type: "setSuitePath", path: el.value }));
      } else if (inputType === "searchFilter") {
        exports_Effect.runFork(ctx.emit({ type: "setSearchFilter", search: el.value }));
      } else if (inputType === "difficultyFilter") {
        exports_Effect.runFork(ctx.emit({ type: "setDifficultyFilter", difficulty: el.value || null }));
      }
    });
  }),
  handleEvent: (event, ctx) => exports_Effect.gen(function* () {
    const socket = yield* SocketServiceTag;
    switch (event.type) {
      case "setSuitePath":
        yield* ctx.state.update((s) => ({ ...s, suitePath: event.path }));
        break;
      case "loadSuite": {
        const state = yield* ctx.state.get;
        if (!state.suitePath.trim()) {
          yield* ctx.state.update((s) => ({ ...s, status: "No path", statusType: "error" }));
          return;
        }
        yield* ctx.state.update((s) => ({ ...s, loading: true, status: "Loading...", statusType: "loading" }));
        const result = yield* socket.loadTBSuite(state.suitePath).pipe(exports_Effect.map((suite) => ({ suite, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ suite: null, error: e.message })));
        if (result.error) {
          yield* ctx.state.update((s) => ({
            ...s,
            loading: false,
            suite: null,
            selectedTaskIds: new Set,
            status: "Load failed",
            statusType: "error"
          }));
        } else if (result.suite) {
          const allIds = new Set(result.suite.tasks.map((t) => t.id));
          yield* ctx.state.update((s) => ({
            ...s,
            loading: false,
            suite: result.suite,
            selectedTaskIds: allIds,
            status: "Ready",
            statusType: "idle"
          }));
        }
        break;
      }
      case "startRun": {
        const state = yield* ctx.state.get;
        if (!state.suite || state.selectedTaskIds.size === 0)
          return;
        yield* ctx.state.update((s) => ({
          ...s,
          isRunning: true,
          status: "Starting...",
          statusType: "running",
          totalTasks: s.selectedTaskIds.size,
          completedTasks: 0,
          passedTasks: 0,
          failedTasks: 0,
          startedAt: Date.now(),
          duration: null
        }));
        const result = yield* socket.startTBRun({
          suitePath: state.suitePath,
          taskIds: Array.from(state.selectedTaskIds),
          timeout: 300000,
          maxTurns: 10
        }).pipe(exports_Effect.map((res) => ({ runId: res.runId, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ runId: null, error: e.message })));
        if (result.error) {
          yield* ctx.state.update((s) => ({
            ...s,
            isRunning: false,
            status: "Start failed",
            statusType: "error"
          }));
        } else {
          yield* ctx.state.update((s) => ({
            ...s,
            runId: result.runId,
            status: "Running...",
            statusType: "running"
          }));
        }
        break;
      }
      case "startRandomTask": {
        const state = yield* ctx.state.get;
        if (!state.suite || state.suite.tasks.length === 0)
          return;
        const randomIndex = Math.floor(Math.random() * state.suite.tasks.length);
        const randomTask = state.suite.tasks[randomIndex];
        yield* ctx.state.update((s) => ({
          ...s,
          isRunning: true,
          status: `Random: ${randomTask.name}`,
          statusType: "running",
          totalTasks: 1,
          completedTasks: 0,
          passedTasks: 0,
          failedTasks: 0,
          startedAt: Date.now(),
          duration: null
        }));
        const result = yield* socket.startTBRun({
          suitePath: state.suitePath,
          taskIds: [randomTask.id],
          timeout: 300000,
          maxTurns: 10
        }).pipe(exports_Effect.map((res) => ({ runId: res.runId, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ runId: null, error: e.message })));
        if (result.error) {
          yield* ctx.state.update((s) => ({
            ...s,
            isRunning: false,
            status: "Start failed",
            statusType: "error"
          }));
        } else {
          yield* ctx.state.update((s) => ({
            ...s,
            runId: result.runId,
            status: "Running...",
            statusType: "running"
          }));
        }
        break;
      }
      case "stopRun": {
        yield* ctx.state.update((s) => ({ ...s, status: "Stopping...", statusType: "loading" }));
        const result = yield* socket.stopTBRun().pipe(exports_Effect.map((res) => ({ stopped: res.stopped, error: null })), exports_Effect.catchAll((e) => exports_Effect.succeed({ stopped: false, error: e.message })));
        yield* ctx.state.update((s) => ({
          ...s,
          isRunning: false,
          runId: null,
          status: result.stopped ? "Stopped" : "No active run",
          statusType: result.error ? "error" : "idle"
        }));
        break;
      }
      case "selectAll": {
        const state = yield* ctx.state.get;
        if (!state.suite)
          return;
        const allIds = new Set(state.suite.tasks.map((t) => t.id));
        yield* ctx.state.update((s) => ({ ...s, selectedTaskIds: allIds }));
        break;
      }
      case "selectNone":
        yield* ctx.state.update((s) => ({ ...s, selectedTaskIds: new Set }));
        break;
      case "toggleTask": {
        yield* ctx.state.update((s) => {
          const newSelected = new Set(s.selectedTaskIds);
          if (newSelected.has(event.taskId)) {
            newSelected.delete(event.taskId);
          } else {
            newSelected.add(event.taskId);
          }
          return { ...s, selectedTaskIds: newSelected };
        });
        break;
      }
      case "setDifficultyFilter":
        yield* ctx.state.update((s) => ({ ...s, difficultyFilter: event.difficulty }));
        break;
      case "setSearchFilter":
        yield* ctx.state.update((s) => ({ ...s, searchFilter: event.search }));
        break;
      case "toggleCollapse":
        yield* ctx.state.update((s) => ({ ...s, collapsed: !s.collapsed }));
        break;
    }
  }),
  subscriptions: (ctx) => {
    const socket = exports_Effect.map(SocketServiceTag, (s) => s);
    return [
      pipe(exports_Stream.unwrap(exports_Effect.map(socket, (s) => s.getMessages())), exports_Stream.filter((msg) => isTBMessage2(msg)), exports_Stream.map((msg) => exports_Effect.gen(function* () {
        if (isTBRunStart2(msg)) {
          yield* ctx.state.update((s) => ({
            ...s,
            isRunning: true,
            runId: msg.runId,
            status: "Running...",
            statusType: "running"
          }));
        }
        if (isTBTaskComplete(msg)) {
          yield* ctx.state.update((s) => {
            if (s.runId !== msg.runId)
              return s;
            const isPassed = msg.outcome === "passed";
            return {
              ...s,
              completedTasks: s.completedTasks + 1,
              passedTasks: s.passedTasks + (isPassed ? 1 : 0),
              failedTasks: s.failedTasks + (isPassed ? 0 : 1),
              status: `${s.completedTasks + 1}/${s.totalTasks} tasks`
            };
          });
        }
        if (isTBRunComplete2(msg)) {
          yield* ctx.state.update((s) => {
            if (s.runId !== msg.runId)
              return s;
            const passRate = s.totalTasks > 0 ? Math.round(s.passedTasks / s.totalTasks * 100) : 0;
            const duration2 = s.startedAt ? Date.now() - s.startedAt : 0;
            return {
              ...s,
              isRunning: false,
              runId: null,
              status: `Complete: ${passRate}% (${s.passedTasks}/${s.totalTasks})`,
              statusType: "success",
              duration: duration2,
              startedAt: null
            };
          });
        }
      })))
    ];
  }
};
var initialTBControlsState = TBControlsWidget.initialState();
// src/effuse/widgets/category-tree.ts
var getStatusIcon2 = (status2) => {
  switch (status2) {
    case "passed":
      return "";
    case "failed":
      return "";
    case "error":
      return "";
    case "timeout":
      return "";
    case "running":
      return "";
    default:
      return "";
  }
};
var getStatusColorClass3 = (status2) => {
  switch (status2) {
    case "passed":
      return "text-emerald-400";
    case "failed":
      return "text-red-400";
    case "error":
      return "text-orange-400";
    case "timeout":
      return "text-amber-400";
    case "running":
      return "text-blue-400";
    default:
      return "text-zinc-500";
  }
};
var getDifficultyClass2 = (difficulty) => {
  switch (difficulty.toLowerCase()) {
    case "easy":
      return "bg-emerald-900/40 text-emerald-300";
    case "medium":
      return "bg-amber-900/40 text-amber-300";
    case "hard":
      return "bg-red-900/40 text-red-300";
    default:
      return "bg-zinc-800/40 text-zinc-300";
  }
};
var groupTasksByCategory = (tasks) => {
  const categories = new Map;
  for (const task of tasks.values()) {
    const cat = task.category || "uncategorized";
    if (!categories.has(cat)) {
      categories.set(cat, { category: cat, tasks: [], passed: 0, failed: 0, pending: 0, total: 0 });
    }
    const catData = categories.get(cat);
    catData.tasks.push(task);
    catData.total++;
    if (task.status === "passed")
      catData.passed++;
    if (task.status === "failed" || task.status === "error" || task.status === "timeout") {
      catData.failed++;
    }
    if (task.status === "pending")
      catData.pending++;
  }
  return categories;
};
var isTBTaskStart = (msg) => msg.type === "tb_task_start";
var isTBTaskComplete2 = (msg) => msg.type === "tb_task_complete";
var isTBSuiteInfo = (msg) => msg.type === "tb_suite_info";
var isTBMessage3 = (msg) => isTBTaskStart(msg) || isTBTaskComplete2(msg) || isTBSuiteInfo(msg);
var CategoryTreeWidget = {
  id: "category-tree",
  initialState: () => ({
    tasks: new Map,
    collapsedCategories: new Set,
    visible: false,
    selectedTaskId: null
  }),
  render: (ctx) => exports_Effect.gen(function* () {
    const state = yield* ctx.state.get;
    if (!state.visible) {
      return html`<div class="hidden"></div>`;
    }
    const categories = groupTasksByCategory(state.tasks);
    const header = html`
        <div class="flex items-center justify-between px-3 py-2 border-b border-zinc-800/60 bg-zinc-900/80">
          <span class="text-sm font-medium text-zinc-300">Categories</span>
          <div class="flex items-center gap-2">
            <button
              class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
              data-action="expandAll"
            >
              Expand
            </button>
            <button
              class="text-xs text-zinc-400 hover:text-zinc-200 px-2 py-1 rounded border border-zinc-700/50 hover:border-zinc-600/60 transition-colors"
              data-action="collapseAll"
            >
              Collapse
            </button>
            <button
              class="text-zinc-500 hover:text-zinc-300 transition-colors"
              data-action="hide"
            >
              
            </button>
          </div>
        </div>
      `;
    if (categories.size === 0) {
      return html`
          <div class="fixed right-4 top-20 w-72 rounded-lg border border-zinc-800/60 bg-zinc-950/95 shadow-xl backdrop-blur-sm overflow-hidden">
            ${header}
            <div class="p-4 text-center">
              <span class="text-sm text-zinc-500">No tasks loaded</span>
            </div>
          </div>
        `;
    }
    const categoryList = Array.from(categories.entries()).sort(([a], [b]) => a.localeCompare(b)).map(([catName, catData]) => {
      const isCollapsed = state.collapsedCategories.has(catName);
      const statsHtml = catData.passed > 0 || catData.failed > 0 ? html`
                  <span class="text-xs text-emerald-400">${catData.passed}</span>
                  <span class="text-xs text-red-400">${catData.failed}</span>
                ` : "";
      const taskItems = catData.tasks.map((task) => {
        const icon = getStatusIcon2(task.status);
        const statusColor = getStatusColorClass3(task.status);
        const diffClass = getDifficultyClass2(task.difficulty);
        const isSelected = state.selectedTaskId === task.id;
        const isRunning3 = task.status === "running";
        return html`
              <div
                class="flex items-center gap-2 px-3 py-1.5 hover:bg-zinc-900/40 cursor-pointer transition-colors
                       ${isSelected ? "bg-zinc-800/60" : ""} ${isRunning3 ? "animate-pulse" : ""}"
                data-action="selectTask"
                data-task-id="${task.id}"
              >
                <span class="${statusColor}">${icon}</span>
                <span class="flex-1 text-xs text-zinc-300 truncate" title="${task.name}">
                  ${task.name}
                </span>
                ${task.difficulty ? html`<span class="text-[9px] px-1 py-0.5 rounded ${diffClass}">${task.difficulty.slice(0, 1).toUpperCase()}</span>` : ""}
              </div>
            `;
      });
      return html`
            <div class="border-b border-zinc-800/40 last:border-0">
              <div
                class="flex items-center gap-2 px-3 py-2 hover:bg-zinc-900/40 cursor-pointer transition-colors"
                data-action="toggleCategory"
                data-category="${catName}"
              >
                <span class="text-zinc-500 text-xs">${isCollapsed ? "" : ""}</span>
                <span class="flex-1 text-sm font-medium text-zinc-200">${catName}</span>
                <div class="flex items-center gap-2">
                  ${statsHtml}
                  <span class="text-xs text-zinc-500">${catData.total}</span>
                </div>
              </div>
              ${isCollapsed ? "" : html`<div class="pb-1">${joinTemplates(taskItems)}</div>`}
            </div>
          `;
    });
    return html`
        <div class="fixed right-4 top-20 w-72 max-h-[70vh] flex flex-col rounded-lg border border-zinc-800/60 bg-zinc-950/95 shadow-xl backdrop-blur-sm overflow-hidden">
          ${header}
          <div class="flex-1 overflow-y-auto">
            ${joinTemplates(categoryList)}
          </div>
        </div>
      `;
  }),
  setupEvents: (ctx) => exports_Effect.gen(function* () {
    yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (_e, target) => {
      const el = target;
      const action = el.dataset.action;
      const category = el.dataset.category;
      const taskId = el.dataset.taskId;
      if (action === "hide") {
        exports_Effect.runFork(ctx.emit({ type: "hide" }));
      } else if (action === "expandAll") {
        exports_Effect.runFork(ctx.emit({ type: "expandAll" }));
      } else if (action === "collapseAll") {
        exports_Effect.runFork(ctx.emit({ type: "collapseAll" }));
      } else if (action === "toggleCategory" && category) {
        exports_Effect.runFork(ctx.emit({ type: "toggleCategory", category }));
      } else if (action === "selectTask" && taskId) {
        exports_Effect.runFork(ctx.emit({ type: "selectTask", taskId }));
      }
    });
  }),
  handleEvent: (event, ctx) => exports_Effect.gen(function* () {
    switch (event.type) {
      case "show":
        yield* ctx.state.update((s) => ({ ...s, visible: true }));
        break;
      case "hide":
        yield* ctx.state.update((s) => ({ ...s, visible: false }));
        break;
      case "toggleCategory":
        yield* ctx.state.update((s) => {
          const newCollapsed = new Set(s.collapsedCategories);
          if (newCollapsed.has(event.category)) {
            newCollapsed.delete(event.category);
          } else {
            newCollapsed.add(event.category);
          }
          return { ...s, collapsedCategories: newCollapsed };
        });
        break;
      case "expandAll":
        yield* ctx.state.update((s) => ({ ...s, collapsedCategories: new Set }));
        break;
      case "collapseAll": {
        const state = yield* ctx.state.get;
        const categories = groupTasksByCategory(state.tasks);
        const allCategories = new Set(categories.keys());
        yield* ctx.state.update((s) => ({ ...s, collapsedCategories: allCategories }));
        break;
      }
      case "selectTask":
        yield* ctx.state.update((s) => ({ ...s, selectedTaskId: event.taskId }));
        break;
    }
  }),
  subscriptions: (ctx) => {
    const socket = exports_Effect.map(SocketServiceTag, (s) => s);
    return [
      pipe(exports_Stream.unwrap(exports_Effect.map(socket, (s) => s.getMessages())), exports_Stream.filter((msg) => isTBMessage3(msg)), exports_Stream.map((msg) => exports_Effect.gen(function* () {
        if (isTBSuiteInfo(msg)) {
          const newTasks = new Map;
          for (const task of msg.tasks) {
            newTasks.set(task.id, {
              id: task.id,
              name: task.name,
              difficulty: task.difficulty,
              category: task.category,
              status: "pending"
            });
          }
          yield* ctx.state.update((s) => ({
            ...s,
            tasks: newTasks,
            visible: true
          }));
        }
        if (isTBTaskStart(msg)) {
          yield* ctx.state.update((s) => {
            const task = s.tasks.get(msg.taskId);
            if (!task)
              return s;
            const newTasks = new Map(s.tasks);
            newTasks.set(msg.taskId, { ...task, status: "running" });
            return { ...s, tasks: newTasks };
          });
        }
        if (isTBTaskComplete2(msg)) {
          yield* ctx.state.update((s) => {
            const task = s.tasks.get(msg.taskId);
            if (!task)
              return s;
            const newTasks = new Map(s.tasks);
            const status2 = msg.outcome;
            newTasks.set(msg.taskId, { ...task, status: status2 });
            return { ...s, tasks: newTasks };
          });
        }
      })))
    ];
  }
};
var initialCategoryTreeState = CategoryTreeWidget.initialState();
// node_modules/@effect/platform/dist/esm/Error.js
var TypeId17 = /* @__PURE__ */ Symbol.for("@effect/platform/Error");
var Module = /* @__PURE__ */ Literal2("Clipboard", "Command", "FileSystem", "KeyValueStore", "Path", "Stream", "Terminal");

class BadArgument extends (/* @__PURE__ */ TaggedError2("@effect/platform/Error/BadArgument")("BadArgument", {
  module: Module,
  method: String$,
  description: /* @__PURE__ */ optional(String$),
  cause: /* @__PURE__ */ optional(Defect)
})) {
  [TypeId17] = TypeId17;
  get message() {
    return `${this.module}.${this.method}${this.description ? `: ${this.description}` : ""}`;
  }
}

// node_modules/@effect/platform/dist/esm/internal/fileSystem.js
var tag = /* @__PURE__ */ GenericTag("@effect/platform/FileSystem");
var bigint1024 = /* @__PURE__ */ BigInt(1024);
var bigintPiB = bigint1024 * bigint1024 * bigint1024 * bigint1024 * bigint1024;

// node_modules/@effect/platform/dist/esm/FileSystem.js
var FileSystem = tag;

// node_modules/@effect/platform/dist/esm/internal/path.js
var TypeId18 = /* @__PURE__ */ Symbol.for("@effect/platform/Path");
var Path = /* @__PURE__ */ GenericTag("@effect/platform/Path");
function normalizeStringPosix(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code;
  for (let i = 0;i <= path.length; ++i) {
    if (i < path.length) {
      code = path.charCodeAt(i);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += "/" + path.slice(lastSlash + 1, i);
        } else {
          res = path.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format(sep, pathObject) {
  const dir = pathObject.dir || pathObject.root;
  const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}
function fromFileUrl(url) {
  if (url.protocol !== "file:") {
    return fail9(new BadArgument({
      module: "Path",
      method: "fromFileUrl",
      description: "URL must be of scheme file"
    }));
  } else if (url.hostname !== "") {
    return fail9(new BadArgument({
      module: "Path",
      method: "fromFileUrl",
      description: "Invalid file URL host"
    }));
  }
  const pathname = url.pathname;
  for (let n = 0;n < pathname.length; n++) {
    if (pathname[n] === "%") {
      const third = pathname.codePointAt(n + 2) | 32;
      if (pathname[n + 1] === "2" && third === 102) {
        return fail9(new BadArgument({
          module: "Path",
          method: "fromFileUrl",
          description: "must not include encoded / characters"
        }));
      }
    }
  }
  return succeed8(decodeURIComponent(pathname));
}
var resolve = function resolve2() {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  let cwd = undefined;
  for (let i = arguments.length - 1;i >= -1 && !resolvedAbsolute; i--) {
    let path;
    if (i >= 0) {
      path = arguments[i];
    } else {
      const process2 = globalThis.process;
      if (cwd === undefined && "process" in globalThis && typeof process2 === "object" && process2 !== null && typeof process2.cwd === "function") {
        cwd = process2.cwd();
      }
      path = cwd;
    }
    if (path.length === 0) {
      continue;
    }
    resolvedPath = path + "/" + resolvedPath;
    resolvedAbsolute = path.charCodeAt(0) === 47;
  }
  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0) {
      return "/" + resolvedPath;
    } else {
      return "/";
    }
  } else if (resolvedPath.length > 0) {
    return resolvedPath;
  } else {
    return ".";
  }
};
var CHAR_FORWARD_SLASH = 47;
function toFileUrl(filepath) {
  const outURL = new URL("file://");
  let resolved = resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if (filePathLast === CHAR_FORWARD_SLASH && resolved[resolved.length - 1] !== "/") {
    resolved += "/";
  }
  outURL.pathname = encodePathChars(resolved);
  return succeed8(outURL);
}
var percentRegEx = /%/g;
var backslashRegEx = /\\/g;
var newlineRegEx = /\n/g;
var carriageReturnRegEx = /\r/g;
var tabRegEx = /\t/g;
function encodePathChars(filepath) {
  if (filepath.includes("%")) {
    filepath = filepath.replace(percentRegEx, "%25");
  }
  if (filepath.includes("\\")) {
    filepath = filepath.replace(backslashRegEx, "%5C");
  }
  if (filepath.includes(`
`)) {
    filepath = filepath.replace(newlineRegEx, "%0A");
  }
  if (filepath.includes("\r")) {
    filepath = filepath.replace(carriageReturnRegEx, "%0D");
  }
  if (filepath.includes("\t")) {
    filepath = filepath.replace(tabRegEx, "%09");
  }
  return filepath;
}
var posixImpl = /* @__PURE__ */ Path.of({
  [TypeId18]: TypeId18,
  resolve,
  normalize(path) {
    if (path.length === 0)
      return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeStringPosix(path, !isAbsolute);
    if (path.length === 0 && !isAbsolute)
      path = ".";
    if (path.length > 0 && trailingSeparator)
      path += "/";
    if (isAbsolute)
      return "/" + path;
    return path;
  },
  isAbsolute(path) {
    return path.length > 0 && path.charCodeAt(0) === 47;
  },
  join() {
    if (arguments.length === 0) {
      return ".";
    }
    let joined;
    for (let i = 0;i < arguments.length; ++i) {
      const arg = arguments[i];
      if (arg.length > 0) {
        if (joined === undefined) {
          joined = arg;
        } else {
          joined += "/" + arg;
        }
      }
    }
    if (joined === undefined) {
      return ".";
    }
    return posixImpl.normalize(joined);
  },
  relative(from, to) {
    if (from === to)
      return "";
    from = posixImpl.resolve(from);
    to = posixImpl.resolve(to);
    if (from === to)
      return "";
    let fromStart = 1;
    for (;fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47) {
        break;
      }
    }
    const fromEnd = from.length;
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    for (;toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47) {
        break;
      }
    }
    const toEnd = to.length;
    const toLen = toEnd - toStart;
    const length3 = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for (;i <= length3; ++i) {
      if (i === length3) {
        if (toLen > length3) {
          if (to.charCodeAt(toStart + i) === 47) {
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            return to.slice(toStart + i);
          }
        } else if (fromLen > length3) {
          if (from.charCodeAt(fromStart + i) === 47) {
            lastCommonSep = i;
          } else if (i === 0) {
            lastCommonSep = 0;
          }
        }
        break;
      }
      const fromCode = from.charCodeAt(fromStart + i);
      const toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode) {
        break;
      } else if (fromCode === 47) {
        lastCommonSep = i;
      }
    }
    let out = "";
    for (i = fromStart + lastCommonSep + 1;i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47) {
        if (out.length === 0) {
          out += "..";
        } else {
          out += "/..";
        }
      }
    }
    if (out.length > 0) {
      return out + to.slice(toStart + lastCommonSep);
    } else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47) {
        ++toStart;
      }
      return to.slice(toStart);
    }
  },
  dirname(path) {
    if (path.length === 0)
      return ".";
    let code = path.charCodeAt(0);
    const hasRoot = code === 47;
    let end6 = -1;
    let matchedSlash = true;
    for (let i = path.length - 1;i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          end6 = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end6 === -1)
      return hasRoot ? "/" : ".";
    if (hasRoot && end6 === 1)
      return "//";
    return path.slice(0, end6);
  },
  basename(path, ext) {
    let start3 = 0;
    let end6 = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path)
        return "";
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path.length - 1;i >= 0; --i) {
        const code = path.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            start3 = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end6 = i;
              }
            } else {
              extIdx = -1;
              end6 = firstNonSlashEnd;
            }
          }
        }
      }
      if (start3 === end6)
        end6 = firstNonSlashEnd;
      else if (end6 === -1)
        end6 = path.length;
      return path.slice(start3, end6);
    } else {
      for (i = path.length - 1;i >= 0; --i) {
        if (path.charCodeAt(i) === 47) {
          if (!matchedSlash) {
            start3 = i + 1;
            break;
          }
        } else if (end6 === -1) {
          matchedSlash = false;
          end6 = i + 1;
        }
      }
      if (end6 === -1)
        return "";
      return path.slice(start3, end6);
    }
  },
  extname(path) {
    let startDot = -1;
    let startPart = 0;
    let end6 = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i = path.length - 1;i >= 0; --i) {
      const code = path.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end6 === -1) {
        matchedSlash = false;
        end6 = i + 1;
      }
      if (code === 46) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end6 === -1 || preDotState === 0 || preDotState === 1 && startDot === end6 - 1 && startDot === startPart + 1) {
      return "";
    }
    return path.slice(startDot, end6);
  },
  format: function format4(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format("/", pathObject);
  },
  parse(path) {
    const ret = {
      root: "",
      dir: "",
      base: "",
      ext: "",
      name: ""
    };
    if (path.length === 0)
      return ret;
    let code = path.charCodeAt(0);
    const isAbsolute = code === 47;
    let start3;
    if (isAbsolute) {
      ret.root = "/";
      start3 = 1;
    } else {
      start3 = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end6 = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for (;i >= start3; --i) {
      code = path.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end6 === -1) {
        matchedSlash = false;
        end6 = i + 1;
      }
      if (code === 46) {
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end6 === -1 || preDotState === 0 || preDotState === 1 && startDot === end6 - 1 && startDot === startPart + 1) {
      if (end6 !== -1) {
        if (startPart === 0 && isAbsolute)
          ret.base = ret.name = path.slice(1, end6);
        else
          ret.base = ret.name = path.slice(startPart, end6);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end6);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end6);
      }
      ret.ext = path.slice(startDot, end6);
    }
    if (startPart > 0)
      ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute)
      ret.dir = "/";
    return ret;
  },
  sep: "/",
  fromFileUrl,
  toFileUrl,
  toNamespacedPath: identity
});

// node_modules/@effect/platform/dist/esm/Path.js
var Path2 = Path;

// src/huggingface/schema.ts
class HFDatasetError extends Error {
  reason;
  cause;
  _tag = "HFDatasetError";
  constructor(reason, message, cause3) {
    super(message);
    this.reason = reason;
    this.cause = cause3;
    this.name = "HFDatasetError";
  }
}
var OPENTHOUGHTS_SFT_CONFIG = {
  repo: "open-thoughts/OpenThoughts-Agent-v1-SFT",
  revision: "main",
  filePattern: ".parquet"
};

// node_modules/@huggingface/hub/dist/browser/index.mjs
init_chunk_QXAXOUZS();
async function createApiError(response, opts) {
  const error = new HubApiError(response.url, response.status, response.headers.get("X-Request-Id") ?? opts?.requestId);
  error.message = `Api error with status ${error.statusCode}${opts?.message ? `. ${opts.message}` : ""}`;
  const trailer = [`URL: ${error.url}`, error.requestId ? `Request ID: ${error.requestId}` : undefined].filter(Boolean).join(". ");
  if (response.headers.get("Content-Type")?.startsWith("application/json")) {
    const json = await response.json();
    error.message = json.error || json.message || error.message;
    if (json.error_description) {
      error.message = error.message ? error.message + `: ${json.error_description}` : json.error_description;
    }
    error.data = json;
  } else {
    error.data = { message: await response.text() };
  }
  error.message += `. ${trailer}`;
  throw error;
}
var HubApiError = class extends Error {
  statusCode;
  url;
  requestId;
  data;
  constructor(url, statusCode, requestId, message) {
    super(message);
    this.statusCode = statusCode;
    this.requestId = requestId;
    this.url = url;
  }
};
function checkAccessToken(accessToken) {
  if (!accessToken.startsWith("hf_")) {
    throw new TypeError("Your access token must start with 'hf_'");
  }
}
function checkCredentials(params) {
  if (params.accessToken) {
    checkAccessToken(params.accessToken);
    return params.accessToken;
  }
  if (params.credentials?.accessToken) {
    checkAccessToken(params.credentials.accessToken);
    return params.credentials.accessToken;
  }
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var isWebWorker = typeof self === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
var resolve3;
var waitPromise = new Promise((r) => {
  resolve3 = r;
});
function combineUint8Arrays(a, b) {
  const aLength = a.length;
  const combinedBytes = new Uint8Array(aLength + b.length);
  combinedBytes.set(a);
  combinedBytes.set(b, aLength);
  return combinedBytes;
}
function readU64(b, n) {
  let x = 0;
  x |= b[n++] << 0;
  x |= b[n++] << 8;
  x |= b[n++] << 16;
  x |= b[n++] << 24;
  x |= b[n++] << 32;
  x |= b[n++] << 40;
  x |= b[n++] << 48;
  x |= b[n++] << 56;
  return x;
}
function readU32(b, n) {
  let x = 0;
  x |= b[n++] << 0;
  x |= b[n++] << 8;
  x |= b[n++] << 16;
  x |= b[n++] << 24;
  return x;
}
var minMatch = 4;
var hashSize = 65536;
var mlBits = 4;
var mlMask = (1 << mlBits) - 1;
var runBits = 4;
var runMask = (1 << runBits) - 1;
var blockBuf = makeBuffer(5242880);
var hashTable = makeHashTable();
var magicNum = 407708164;
var fdContentChksum = 4;
var fdContentSize = 8;
var fdBlockChksum = 16;
var fdVersion = 64;
var fdVersionMask = 192;
var bsUncompressed = 2147483648;
var bsShift = 4;
var bsMask = 7;
var bsMap = {
  4: 65536,
  5: 262144,
  6: 1048576,
  7: 4194304
};
function makeHashTable() {
  try {
    return new Uint32Array(hashSize);
  } catch (error) {
    const hashTable2 = new Array(hashSize);
    for (let i = 0;i < hashSize; i++) {
      hashTable2[i] = 0;
    }
    return hashTable2;
  }
}
function makeBuffer(size13) {
  return new Uint8Array(size13);
}
function sliceArray(array4, start3, end6) {
  return array4.slice(start3, end6);
}
function decompressBound(src) {
  let sIndex = 0;
  if (readU32(src, sIndex) !== magicNum) {
    throw new Error("invalid magic number");
  }
  sIndex += 4;
  const descriptor3 = src[sIndex++];
  if ((descriptor3 & fdVersionMask) !== fdVersion) {
    throw new Error("incompatible descriptor version " + (descriptor3 & fdVersionMask));
  }
  const useBlockSum = (descriptor3 & fdBlockChksum) !== 0;
  const useContentSize = (descriptor3 & fdContentSize) !== 0;
  const bsIdx = src[sIndex++] >> bsShift & bsMask;
  if (bsMap[bsIdx] === undefined) {
    throw new Error("invalid block size " + bsIdx);
  }
  const maxBlockSize = bsMap[bsIdx];
  if (useContentSize) {
    return readU64(src, sIndex);
  }
  sIndex++;
  let maxSize = 0;
  while (true) {
    let blockSize = readU32(src, sIndex);
    sIndex += 4;
    if (blockSize & bsUncompressed) {
      blockSize &= ~bsUncompressed;
      maxSize += blockSize;
    } else if (blockSize > 0) {
      maxSize += maxBlockSize;
    }
    if (blockSize === 0) {
      return maxSize;
    }
    if (useBlockSum) {
      sIndex += 4;
    }
    sIndex += blockSize;
  }
}
function decompressBlock(src, dst, sIndex, sLength, dIndex) {
  let mLength, mOffset, sEnd, n, i;
  const hasCopyWithin = dst.copyWithin !== undefined && dst.fill !== undefined;
  sEnd = sIndex + sLength;
  while (sIndex < sEnd) {
    const token = src[sIndex++];
    let literalCount = token >> 4;
    if (literalCount > 0) {
      if (literalCount === 15) {
        while (true) {
          literalCount += src[sIndex];
          if (src[sIndex++] !== 255) {
            break;
          }
        }
      }
      for (n = sIndex + literalCount;sIndex < n; ) {
        dst[dIndex++] = src[sIndex++];
      }
    }
    if (sIndex >= sEnd) {
      break;
    }
    mLength = token & 15;
    mOffset = src[sIndex++] | src[sIndex++] << 8;
    if (mLength === 15) {
      while (true) {
        mLength += src[sIndex];
        if (src[sIndex++] !== 255) {
          break;
        }
      }
    }
    mLength += minMatch;
    if (hasCopyWithin && mOffset === 1) {
      dst.fill(dst[dIndex - 1] | 0, dIndex, dIndex + mLength);
      dIndex += mLength;
    } else if (hasCopyWithin && mOffset > mLength && mLength > 31) {
      dst.copyWithin(dIndex, dIndex - mOffset, dIndex - mOffset + mLength);
      dIndex += mLength;
    } else {
      for (i = dIndex - mOffset, n = i + mLength;i < n; ) {
        dst[dIndex++] = dst[i++] | 0;
      }
    }
  }
  return dIndex;
}
function decompressFrame(src, dst) {
  let useBlockSum, useContentSum, useContentSize, descriptor3;
  let sIndex = 0;
  let dIndex = 0;
  if (readU32(src, sIndex) !== magicNum) {
    throw new Error("invalid magic number");
  }
  sIndex += 4;
  descriptor3 = src[sIndex++];
  if ((descriptor3 & fdVersionMask) !== fdVersion) {
    throw new Error("incompatible descriptor version");
  }
  useBlockSum = (descriptor3 & fdBlockChksum) !== 0;
  useContentSum = (descriptor3 & fdContentChksum) !== 0;
  useContentSize = (descriptor3 & fdContentSize) !== 0;
  const bsIdx = src[sIndex++] >> bsShift & bsMask;
  if (bsMap[bsIdx] === undefined) {
    throw new Error("invalid block size");
  }
  if (useContentSize) {
    sIndex += 8;
  }
  sIndex++;
  while (true) {
    var compSize;
    compSize = readU32(src, sIndex);
    sIndex += 4;
    if (compSize === 0) {
      break;
    }
    if (useBlockSum) {
      sIndex += 4;
    }
    if ((compSize & bsUncompressed) !== 0) {
      compSize &= ~bsUncompressed;
      for (let j = 0;j < compSize; j++) {
        dst[dIndex++] = src[sIndex++];
      }
    } else {
      dIndex = decompressBlock(src, dst, sIndex, compSize, dIndex);
      sIndex += compSize;
    }
  }
  if (useContentSum) {
    sIndex += 4;
  }
  return dIndex;
}
function decompress(src, maxSize) {
  let dst, size13;
  if (maxSize === undefined) {
    maxSize = decompressBound(src);
  }
  dst = makeBuffer(maxSize);
  size13 = decompressFrame(src, dst);
  if (size13 !== maxSize) {
    dst = sliceArray(dst, 0, size13);
  }
  return dst;
}
var RangeList = class {
  ranges = [];
  add(start3, end6) {
    if (end6 <= start3) {
      throw new TypeError("End must be greater than start");
    }
    const overlappingRanges = [];
    for (let i = 0;i < this.ranges.length; i++) {
      const range22 = this.ranges[i];
      if (start3 < range22.end && end6 > range22.start) {
        overlappingRanges.push({ index: i, range: range22 });
      }
      if (range22.data !== null) {
        throw new Error("Overlapping range already has data");
      }
    }
    if (overlappingRanges.length === 0) {
      this.ranges.push({ start: start3, end: end6, refCount: 1, data: null });
      this.ranges.sort((a, b) => a.start - b.start);
      return;
    }
    const newRanges = [];
    let currentPos = start3;
    for (let i = 0;i < overlappingRanges.length; i++) {
      const { range: range22 } = overlappingRanges[i];
      if (currentPos < range22.start) {
        newRanges.push({
          start: currentPos,
          end: range22.start,
          refCount: 1,
          data: null
        });
      } else if (range22.start < currentPos) {
        newRanges.push({
          start: range22.start,
          end: currentPos,
          refCount: range22.refCount,
          data: null
        });
      }
      newRanges.push({
        start: Math.max(currentPos, range22.start),
        end: Math.min(end6, range22.end),
        refCount: range22.refCount + 1,
        data: null
      });
      if (range22.end > end6) {
        newRanges.push({
          start: end6,
          end: range22.end,
          refCount: range22.refCount,
          data: null
        });
      }
      currentPos = Math.max(currentPos, range22.end);
    }
    if (currentPos < end6) {
      newRanges.push({
        start: currentPos,
        end: end6,
        refCount: 1,
        data: null
      });
    }
    const firstIndex = overlappingRanges[0].index;
    const lastIndex = overlappingRanges[overlappingRanges.length - 1].index;
    this.ranges.splice(firstIndex, lastIndex - firstIndex + 1, ...newRanges);
    this.ranges.sort((a, b) => a.start - b.start);
  }
  remove(start3, end6) {
    if (end6 <= start3) {
      throw new TypeError("End must be greater than start");
    }
    const affectedRanges = [];
    for (let i = 0;i < this.ranges.length; i++) {
      const range22 = this.ranges[i];
      if (start3 < range22.end && end6 > range22.start) {
        affectedRanges.push({ index: i, range: range22 });
      }
    }
    if (affectedRanges.length === 0) {
      throw new Error("No ranges found to remove");
    }
    if (start3 !== affectedRanges[0].range.start || end6 !== affectedRanges[affectedRanges.length - 1].range.end) {
      throw new Error("Range boundaries must match existing boundaries");
    }
    for (let i = 0;i < affectedRanges.length; i++) {
      const { range: range22 } = affectedRanges[i];
      range22.refCount--;
    }
    this.ranges = this.ranges.filter((range22) => range22.refCount > 0);
  }
  getRanges(start3, end6) {
    if (end6 <= start3) {
      throw new TypeError("End must be greater than start");
    }
    return this.ranges.filter((range22) => start3 < range22.end && end6 > range22.start);
  }
  getAllRanges() {
    return [...this.ranges];
  }
};
var JWT_SAFETY_PERIOD = 60000;
var JWT_CACHE_SIZE = 1000;
var compressionSchemeLabels = {
  [0]: "None",
  [1]: "LZ4",
  [2]: "ByteGroupingLZ4"
};
var XET_CHUNK_HEADER_BYTES = 8;
var XetBlob = class extends Blob {
  fetch;
  accessToken;
  refreshUrl;
  reconstructionUrl;
  hash;
  start = 0;
  end = 0;
  internalLogging = false;
  reconstructionInfo;
  listener;
  constructor(params) {
    super([]);
    this.fetch = params.fetch ?? fetch.bind(globalThis);
    this.accessToken = checkCredentials(params);
    this.refreshUrl = params.refreshUrl;
    this.end = params.size;
    this.reconstructionUrl = params.reconstructionUrl;
    this.hash = params.hash;
    this.listener = params.listener;
    this.internalLogging = params.internalLogging ?? false;
    this.refreshUrl;
  }
  get size() {
    return this.end - this.start;
  }
  #clone() {
    const blob = new XetBlob({
      fetch: this.fetch,
      hash: this.hash,
      refreshUrl: this.refreshUrl,
      reconstructionUrl: this.reconstructionUrl,
      size: this.size
    });
    blob.accessToken = this.accessToken;
    blob.start = this.start;
    blob.end = this.end;
    blob.reconstructionInfo = this.reconstructionInfo;
    blob.listener = this.listener;
    blob.internalLogging = this.internalLogging;
    return blob;
  }
  slice(start3 = 0, end6 = this.size) {
    if (start3 < 0 || end6 < 0) {
      new TypeError("Unsupported negative start/end on XetBlob.slice");
    }
    const slice = this.#clone();
    slice.start = this.start + start3;
    slice.end = Math.min(this.start + end6, this.end);
    if (slice.start !== this.start || slice.end !== this.end) {
      slice.reconstructionInfo = undefined;
    }
    return slice;
  }
  #reconstructionInfoPromise;
  #loadReconstructionInfo() {
    if (this.#reconstructionInfoPromise) {
      return this.#reconstructionInfoPromise;
    }
    this.#reconstructionInfoPromise = (async () => {
      const connParams = await getAccessToken(this.accessToken, this.fetch, this.refreshUrl);
      const resp = await this.fetch(this.reconstructionUrl ?? `${connParams.casUrl}/v1/reconstructions/${this.hash}`, {
        headers: {
          Authorization: `Bearer ${connParams.accessToken}`,
          Range: `bytes=${this.start}-${this.end - 1}`
        }
      });
      if (!resp.ok) {
        throw await createApiError(resp);
      }
      this.reconstructionInfo = await resp.json();
      return this.reconstructionInfo;
    })().finally(() => this.#reconstructionInfoPromise = undefined);
    return this.#reconstructionInfoPromise;
  }
  async#fetch() {
    if (!this.reconstructionInfo) {
      await this.#loadReconstructionInfo();
    }
    const rangeLists = /* @__PURE__ */ new Map;
    if (!this.reconstructionInfo) {
      throw new Error("Failed to load reconstruction info");
    }
    for (const term of this.reconstructionInfo.terms) {
      let rangeList = rangeLists.get(term.hash);
      if (!rangeList) {
        rangeList = new RangeList;
        rangeLists.set(term.hash, rangeList);
      }
      rangeList.add(term.range.start, term.range.end);
    }
    const listener = this.listener;
    const log3 = this.internalLogging ? (...args2) => console.log(...args2) : () => {};
    async function* readData(reconstructionInfo, customFetch, maxBytes, reloadReconstructionInfo) {
      let totalBytesRead = 0;
      let readBytesToSkip = reconstructionInfo.offset_into_first_range;
      for (const term of reconstructionInfo.terms) {
        if (totalBytesRead >= maxBytes) {
          break;
        }
        const rangeList = rangeLists.get(term.hash);
        if (!rangeList) {
          throw new Error(`Failed to find range list for term ${term.hash}`);
        }
        {
          const termRanges = rangeList.getRanges(term.range.start, term.range.end);
          if (termRanges.every((range22) => range22.data)) {
            log3("all data available for term", term.hash, readBytesToSkip);
            rangeLoop:
              for (const range22 of termRanges) {
                for (let chunk22 of range22.data) {
                  if (readBytesToSkip) {
                    const skipped = Math.min(readBytesToSkip, chunk22.byteLength);
                    chunk22 = chunk22.slice(skipped);
                    readBytesToSkip -= skipped;
                    if (!chunk22.byteLength) {
                      continue;
                    }
                  }
                  if (chunk22.byteLength > maxBytes - totalBytesRead) {
                    chunk22 = chunk22.slice(0, maxBytes - totalBytesRead);
                  }
                  totalBytesRead += chunk22.byteLength;
                  yield range22.refCount > 1 ? chunk22.slice() : chunk22;
                  listener?.({ event: "progress", progress: { read: totalBytesRead, total: maxBytes } });
                  if (totalBytesRead >= maxBytes) {
                    break rangeLoop;
                  }
                }
              }
            rangeList.remove(term.range.start, term.range.end);
            continue;
          }
        }
        const fetchInfo = reconstructionInfo.fetch_info[term.hash].find((info) => info.range.start <= term.range.start && info.range.end >= term.range.end);
        if (!fetchInfo) {
          throw new Error(`Failed to find fetch info for term ${term.hash} and range ${term.range.start}-${term.range.end}`);
        }
        log3("term", term);
        log3("fetchinfo", fetchInfo);
        log3("readBytesToSkip", readBytesToSkip);
        let resp = await customFetch(fetchInfo.url, {
          headers: {
            Range: `bytes=${fetchInfo.url_range.start}-${fetchInfo.url_range.end}`
          }
        });
        if (resp.status === 403) {
          reconstructionInfo = await reloadReconstructionInfo();
          resp = await customFetch(fetchInfo.url, {
            headers: {
              Range: `bytes=${fetchInfo.url_range.start}-${fetchInfo.url_range.end}`
            }
          });
        }
        if (!resp.ok) {
          throw await createApiError(resp);
        }
        log3("expected content length", resp.headers.get("content-length"), "range", fetchInfo.url_range, resp.headers.get("content-range"));
        const reader = resp.body?.getReader();
        if (!reader) {
          throw new Error("Failed to get reader from response body");
        }
        let done11 = false;
        let chunkIndex = fetchInfo.range.start;
        const ranges = rangeList.getRanges(fetchInfo.range.start, fetchInfo.range.end);
        let leftoverBytes = undefined;
        let totalFetchBytes = 0;
        fetchData:
          while (!done11 && totalBytesRead < maxBytes) {
            const result = await reader.read();
            listener?.({ event: "read" });
            done11 = result.done;
            log3("read", result.value?.byteLength, "bytes", "total read", totalBytesRead, "toSkip", readBytesToSkip);
            if (!result.value) {
              log3("no data in result, cancelled", result);
              continue;
            }
            totalFetchBytes += result.value.byteLength;
            if (leftoverBytes) {
              result.value = combineUint8Arrays(leftoverBytes, result.value);
              leftoverBytes = undefined;
            }
            while (totalBytesRead < maxBytes && result.value?.byteLength) {
              if (result.value.byteLength < 8) {
                leftoverBytes = result.value;
                continue fetchData;
              }
              const header = new DataView(result.value.buffer, result.value.byteOffset, XET_CHUNK_HEADER_BYTES);
              const chunkHeader = {
                version: header.getUint8(0),
                compressed_length: header.getUint8(1) | header.getUint8(2) << 8 | header.getUint8(3) << 16,
                compression_scheme: header.getUint8(4),
                uncompressed_length: header.getUint8(5) | header.getUint8(6) << 8 | header.getUint8(7) << 16
              };
              log3("chunk header", chunkHeader, "to skip", readBytesToSkip);
              if (chunkHeader.version !== 0) {
                throw new Error(`Unsupported chunk version ${chunkHeader.version}`);
              }
              if (chunkHeader.compression_scheme !== 0 && chunkHeader.compression_scheme !== 1 && chunkHeader.compression_scheme !== 2) {
                throw new Error(`Unsupported compression scheme ${compressionSchemeLabels[chunkHeader.compression_scheme] ?? chunkHeader.compression_scheme}`);
              }
              if (result.value.byteLength < chunkHeader.compressed_length + XET_CHUNK_HEADER_BYTES) {
                leftoverBytes = result.value;
                continue fetchData;
              }
              result.value = result.value.slice(XET_CHUNK_HEADER_BYTES);
              let uncompressed = chunkHeader.compression_scheme === 1 ? decompress(result.value.slice(0, chunkHeader.compressed_length), chunkHeader.uncompressed_length) : chunkHeader.compression_scheme === 2 ? bg4_regroup_bytes(decompress(result.value.slice(0, chunkHeader.compressed_length), chunkHeader.uncompressed_length)) : result.value.slice(0, chunkHeader.compressed_length);
              const range22 = ranges.find((range32) => chunkIndex >= range32.start && chunkIndex < range32.end);
              const shouldYield = chunkIndex >= term.range.start && chunkIndex < term.range.end;
              const minRefCountToStore = shouldYield ? 2 : 1;
              let stored = false;
              if (range22 && range22.refCount >= minRefCountToStore) {
                range22.data ??= [];
                range22.data.push(uncompressed);
                stored = true;
              }
              if (shouldYield) {
                if (readBytesToSkip) {
                  const skipped = Math.min(readBytesToSkip, uncompressed.byteLength);
                  uncompressed = uncompressed.slice(readBytesToSkip);
                  readBytesToSkip -= skipped;
                }
                if (uncompressed.byteLength > maxBytes - totalBytesRead) {
                  uncompressed = uncompressed.slice(0, maxBytes - totalBytesRead);
                }
                if (uncompressed.byteLength) {
                  log3("yield", uncompressed.byteLength, "bytes", result.value.byteLength, "total read", totalBytesRead, stored);
                  totalBytesRead += uncompressed.byteLength;
                  yield stored ? uncompressed.slice() : uncompressed;
                  listener?.({ event: "progress", progress: { read: totalBytesRead, total: maxBytes } });
                }
              }
              chunkIndex++;
              result.value = result.value.slice(chunkHeader.compressed_length);
            }
          }
        if (done11 && totalBytesRead < maxBytes && totalFetchBytes < fetchInfo.url_range.end - fetchInfo.url_range.start + 1) {
          log3("done", done11, "total read", totalBytesRead, maxBytes, totalFetchBytes);
          log3("failed to fetch all data for term", term.hash);
          throw new Error(`Failed to fetch all data for term ${term.hash}, fetched ${totalFetchBytes} bytes out of ${fetchInfo.url_range.end - fetchInfo.url_range.start + 1}`);
        }
        log3("done", done11, "total read", totalBytesRead, maxBytes, totalFetchBytes);
        log3("cancel reader");
        await reader.cancel();
      }
    }
    const iterator = readData(this.reconstructionInfo, this.fetch, this.end - this.start, this.#loadReconstructionInfo.bind(this));
    return new ReadableStream({
      async pull(controller) {
        const result = await iterator.next();
        if (result.value) {
          controller.enqueue(result.value);
        }
        if (result.done) {
          controller.close();
        }
      },
      type: "bytes"
    }, {
      highWaterMark: 1000
    });
  }
  async arrayBuffer() {
    const result = await this.#fetch();
    return new Response(result).arrayBuffer();
  }
  async text() {
    const result = await this.#fetch();
    return new Response(result).text();
  }
  async response() {
    const result = await this.#fetch();
    return new Response(result);
  }
  stream() {
    const stream = new TransformStream;
    this.#fetch().then((response) => response.pipeThrough(stream)).catch((error) => stream.writable.abort(error.message));
    return stream.readable;
  }
};
var jwtPromises = /* @__PURE__ */ new Map;
var jwts = /* @__PURE__ */ new Map;
function cacheKey(params) {
  return JSON.stringify([params.refreshUrl, params.initialAccessToken]);
}
function bg4_regroup_bytes(bytes) {
  const split3 = Math.floor(bytes.byteLength / 4);
  const rem = bytes.byteLength % 4;
  const g1_pos = split3 + (rem >= 1 ? 1 : 0);
  const g2_pos = g1_pos + split3 + (rem >= 2 ? 1 : 0);
  const g3_pos = g2_pos + split3 + (rem == 3 ? 1 : 0);
  const ret = new Uint8Array(bytes.byteLength);
  for (let i = 0, j = 0;i < bytes.byteLength; i += 4, j++) {
    ret[i] = bytes[j];
  }
  for (let i = 1, j = g1_pos;i < bytes.byteLength; i += 4, j++) {
    ret[i] = bytes[j];
  }
  for (let i = 2, j = g2_pos;i < bytes.byteLength; i += 4, j++) {
    ret[i] = bytes[j];
  }
  for (let i = 3, j = g3_pos;i < bytes.byteLength; i += 4, j++) {
    ret[i] = bytes[j];
  }
  return ret;
}
async function getAccessToken(initialAccessToken, customFetch, refreshUrl) {
  const key = cacheKey({ refreshUrl, initialAccessToken });
  const jwt = jwts.get(key);
  if (jwt && jwt.expiresAt > new Date(Date.now() + JWT_SAFETY_PERIOD)) {
    return { accessToken: jwt.accessToken, casUrl: jwt.casUrl };
  }
  const existingPromise = jwtPromises.get(key);
  if (existingPromise) {
    return existingPromise;
  }
  const promise3 = (async () => {
    const resp = await customFetch(refreshUrl, {
      headers: {
        ...initialAccessToken ? {
          Authorization: `Bearer ${initialAccessToken}`
        } : {}
      }
    });
    if (!resp.ok) {
      throw new Error(`Failed to get JWT token: ${resp.status} ${await resp.text()}`);
    }
    const json = await resp.json();
    const jwt2 = {
      accessToken: json.accessToken,
      expiresAt: new Date(json.exp * 1000),
      casUrl: json.casUrl
    };
    jwtPromises.delete(key);
    for (const [key2, value] of jwts.entries()) {
      if (value.expiresAt < new Date(Date.now() + JWT_SAFETY_PERIOD)) {
        jwts.delete(key2);
      } else {
        break;
      }
    }
    if (jwts.size >= JWT_CACHE_SIZE) {
      const keyToDelete = jwts.keys().next().value;
      if (keyToDelete) {
        jwts.delete(keyToDelete);
      }
    }
    jwts.set(key, jwt2);
    return {
      accessToken: json.accessToken,
      casUrl: json.casUrl
    };
  })();
  jwtPromises.set(key, promise3);
  return promise3;
}
var HASH_LENGTH = 32;
var XORB_HASH_BOOKEND = "ff".repeat(HASH_LENGTH);
var TARGET_CHUNK_SIZE = 65536;
var MAX_CHUNK_SIZE = 2 * TARGET_CHUNK_SIZE;
var PROCESSING_PROGRESS_RATIO = 0.1;
var UPLOADING_PROGRESS_RATIO = 1 - PROCESSING_PROGRESS_RATIO;
var SHARD_MAGIC_TAG = new Uint8Array([
  72,
  70,
  82,
  101,
  112,
  111,
  77,
  101,
  116,
  97,
  68,
  97,
  116,
  97,
  0,
  85,
  105,
  103,
  69,
  106,
  123,
  129,
  87,
  131,
  165,
  189,
  217,
  92,
  205,
  209,
  74,
  169
]);

// src/huggingface/service.ts
class HFDatasetService extends exports_Context.Tag("HFDatasetService")() {
}

// node_modules/parquet-wasm/esm/parquet_wasm.js
var wasm;
var cachedUint8ArrayMemory0 = null;
function getUint8ArrayMemory0() {
  if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8ArrayMemory0;
}
var cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
cachedTextDecoder.decode();
var MAX_SAFARI_DECODE_BYTES = 2146435072;
var numBytesDecoded = 0;
function decodeText3(ptr, len) {
  numBytesDecoded += len;
  if (numBytesDecoded >= MAX_SAFARI_DECODE_BYTES) {
    cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
    cachedTextDecoder.decode();
    numBytesDecoded = len;
  }
  return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return decodeText3(ptr, len);
}
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = new TextEncoder;
if (!("encodeInto" in cachedTextEncoder)) {
  cachedTextEncoder.encodeInto = function(arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
      read: arg.length,
      written: buf.length
    };
  };
}
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === undefined) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8ArrayMemory0();
  let offset = 0;
  for (;offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
    const ret = cachedTextEncoder.encodeInto(arg, view);
    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
var cachedDataViewMemory0 = null;
function getDataViewMemory0() {
  if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer) {
    cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
  }
  return cachedDataViewMemory0;
}
function addToExternrefTable0(obj) {
  const idx = wasm.__externref_table_alloc();
  wasm.__wbindgen_export_4.set(idx, obj);
  return idx;
}
function isLikeNone(x) {
  return x === undefined || x === null;
}
function getArrayU8FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}
var CLOSURE_DTORS = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((state) => {
  wasm.__wbindgen_export_5.get(state.dtor)(state.a, state.b);
});
function takeFromExternrefTable0(idx) {
  const value = wasm.__wbindgen_export_4.get(idx);
  wasm.__externref_table_dealloc(idx);
  return value;
}
function getArrayJsValueFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  const mem = getDataViewMemory0();
  const result = [];
  for (let i = ptr;i < ptr + 4 * len; i += 4) {
    result.push(wasm.__wbindgen_export_4.get(mem.getUint32(i, true)));
  }
  wasm.__externref_drop_slice(ptr, len);
  return result;
}
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1, 1) >>> 0;
  getUint8ArrayMemory0().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function readParquet(parquet_file, options) {
  const ptr0 = passArray8ToWasm0(parquet_file, wasm.__wbindgen_malloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.readParquet(ptr0, len0, isLikeNone(options) ? 0 : addToExternrefTable0(options));
  if (ret[2]) {
    throw takeFromExternrefTable0(ret[1]);
  }
  return Table.__wrap(ret[0]);
}
function _assertClass(instance, klass) {
  if (!(instance instanceof klass)) {
    throw new Error(`expected instance of ${klass.name}`);
  }
}
var cachedUint32ArrayMemory0 = null;
function getUint32ArrayMemory0() {
  if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {
    cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);
  }
  return cachedUint32ArrayMemory0;
}
function getArrayU32FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);
}
var Compression = Object.freeze({
  UNCOMPRESSED: 0,
  "0": "UNCOMPRESSED",
  SNAPPY: 1,
  "1": "SNAPPY",
  GZIP: 2,
  "2": "GZIP",
  BROTLI: 3,
  "3": "BROTLI",
  LZ4: 4,
  "4": "LZ4",
  ZSTD: 5,
  "5": "ZSTD",
  LZ4_RAW: 6,
  "6": "LZ4_RAW",
  LZO: 7,
  "7": "LZO"
});
var EnabledStatistics = Object.freeze({
  None: 0,
  "0": "None",
  Chunk: 1,
  "1": "Chunk",
  Page: 2,
  "2": "Page"
});
var Encoding = Object.freeze({
  PLAIN: 0,
  "0": "PLAIN",
  PLAIN_DICTIONARY: 1,
  "1": "PLAIN_DICTIONARY",
  RLE: 2,
  "2": "RLE",
  BIT_PACKED: 3,
  "3": "BIT_PACKED",
  DELTA_BINARY_PACKED: 4,
  "4": "DELTA_BINARY_PACKED",
  DELTA_LENGTH_BYTE_ARRAY: 5,
  "5": "DELTA_LENGTH_BYTE_ARRAY",
  DELTA_BYTE_ARRAY: 6,
  "6": "DELTA_BYTE_ARRAY",
  RLE_DICTIONARY: 7,
  "7": "RLE_DICTIONARY",
  BYTE_STREAM_SPLIT: 8,
  "8": "BYTE_STREAM_SPLIT"
});
var WriterVersion = Object.freeze({
  V1: 0,
  "0": "V1",
  V2: 1,
  "1": "V2"
});
var __wbindgen_enum_ReadableStreamType = ["bytes"];
var ColumnChunkMetaDataFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_columnchunkmetadata_free(ptr >>> 0, 1));

class ColumnChunkMetaData {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ColumnChunkMetaData.prototype);
    obj.__wbg_ptr = ptr;
    ColumnChunkMetaDataFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ColumnChunkMetaDataFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_columnchunkmetadata_free(ptr, 0);
  }
  filePath() {
    const ret = wasm.columnchunkmetadata_filePath(this.__wbg_ptr);
    let v1;
    if (ret[0] !== 0) {
      v1 = getStringFromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    }
    return v1;
  }
  fileOffset() {
    const ret = wasm.columnchunkmetadata_fileOffset(this.__wbg_ptr);
    return ret;
  }
  columnPath() {
    const ret = wasm.columnchunkmetadata_columnPath(this.__wbg_ptr);
    var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
    return v1;
  }
  encodings() {
    const ret = wasm.columnchunkmetadata_encodings(this.__wbg_ptr);
    var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
    return v1;
  }
  numValues() {
    const ret = wasm.columnchunkmetadata_numValues(this.__wbg_ptr);
    return ret;
  }
  compression() {
    const ret = wasm.columnchunkmetadata_compression(this.__wbg_ptr);
    return ret;
  }
  compressedSize() {
    const ret = wasm.columnchunkmetadata_compressedSize(this.__wbg_ptr);
    return ret;
  }
  uncompressedSize() {
    const ret = wasm.columnchunkmetadata_uncompressedSize(this.__wbg_ptr);
    return ret;
  }
}
if (Symbol.dispose)
  ColumnChunkMetaData.prototype[Symbol.dispose] = ColumnChunkMetaData.prototype.free;
var FFIDataFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_ffidata_free(ptr >>> 0, 1));

class FFIData {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(FFIData.prototype);
    obj.__wbg_ptr = ptr;
    FFIDataFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    FFIDataFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_ffidata_free(ptr, 0);
  }
  arrayAddr() {
    const ret = wasm.ffidata_arrayAddr(this.__wbg_ptr);
    return ret >>> 0;
  }
  schemaAddr() {
    const ret = wasm.ffidata_schemaAddr(this.__wbg_ptr);
    return ret >>> 0;
  }
}
if (Symbol.dispose)
  FFIData.prototype[Symbol.dispose] = FFIData.prototype.free;
var FFISchemaFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_ffischema_free(ptr >>> 0, 1));

class FFISchema {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(FFISchema.prototype);
    obj.__wbg_ptr = ptr;
    FFISchemaFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    FFISchemaFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_ffischema_free(ptr, 0);
  }
  addr() {
    const ret = wasm.ffischema_addr(this.__wbg_ptr);
    return ret >>> 0;
  }
}
if (Symbol.dispose)
  FFISchema.prototype[Symbol.dispose] = FFISchema.prototype.free;
var FFIStreamFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_ffistream_free(ptr >>> 0, 1));

class FFIStream {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(FFIStream.prototype);
    obj.__wbg_ptr = ptr;
    FFIStreamFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    FFIStreamFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_ffistream_free(ptr, 0);
  }
  numArrays() {
    const ret = wasm.ffistream_numArrays(this.__wbg_ptr);
    return ret >>> 0;
  }
  schemaAddr() {
    const ret = wasm.ffistream_schemaAddr(this.__wbg_ptr);
    return ret >>> 0;
  }
  arrayAddr(chunk3) {
    const ret = wasm.ffistream_arrayAddr(this.__wbg_ptr, chunk3);
    return ret >>> 0;
  }
  arrayAddrs() {
    const ret = wasm.ffistream_arrayAddrs(this.__wbg_ptr);
    var v1 = getArrayU32FromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
    return v1;
  }
  drop() {
    const ptr = this.__destroy_into_raw();
    wasm.ffistream_drop(ptr);
  }
}
if (Symbol.dispose)
  FFIStream.prototype[Symbol.dispose] = FFIStream.prototype.free;
var FileMetaDataFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_filemetadata_free(ptr >>> 0, 1));

class FileMetaData {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(FileMetaData.prototype);
    obj.__wbg_ptr = ptr;
    FileMetaDataFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    FileMetaDataFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_filemetadata_free(ptr, 0);
  }
  version() {
    const ret = wasm.filemetadata_version(this.__wbg_ptr);
    return ret;
  }
  numRows() {
    const ret = wasm.filemetadata_numRows(this.__wbg_ptr);
    return ret;
  }
  createdBy() {
    const ret = wasm.filemetadata_createdBy(this.__wbg_ptr);
    let v1;
    if (ret[0] !== 0) {
      v1 = getStringFromWasm0(ret[0], ret[1]).slice();
      wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    }
    return v1;
  }
  keyValueMetadata() {
    const ret = wasm.filemetadata_keyValueMetadata(this.__wbg_ptr);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
  }
}
if (Symbol.dispose)
  FileMetaData.prototype[Symbol.dispose] = FileMetaData.prototype.free;
var IntoUnderlyingByteSourceFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_intounderlyingbytesource_free(ptr >>> 0, 1));

class IntoUnderlyingByteSource {
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    IntoUnderlyingByteSourceFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_intounderlyingbytesource_free(ptr, 0);
  }
  get type() {
    const ret = wasm.intounderlyingbytesource_type(this.__wbg_ptr);
    return __wbindgen_enum_ReadableStreamType[ret];
  }
  get autoAllocateChunkSize() {
    const ret = wasm.intounderlyingbytesource_autoAllocateChunkSize(this.__wbg_ptr);
    return ret >>> 0;
  }
  start(controller) {
    wasm.intounderlyingbytesource_start(this.__wbg_ptr, controller);
  }
  pull(controller) {
    const ret = wasm.intounderlyingbytesource_pull(this.__wbg_ptr, controller);
    return ret;
  }
  cancel() {
    const ptr = this.__destroy_into_raw();
    wasm.intounderlyingbytesource_cancel(ptr);
  }
}
if (Symbol.dispose)
  IntoUnderlyingByteSource.prototype[Symbol.dispose] = IntoUnderlyingByteSource.prototype.free;
var IntoUnderlyingSinkFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_intounderlyingsink_free(ptr >>> 0, 1));

class IntoUnderlyingSink {
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    IntoUnderlyingSinkFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_intounderlyingsink_free(ptr, 0);
  }
  write(chunk3) {
    const ret = wasm.intounderlyingsink_write(this.__wbg_ptr, chunk3);
    return ret;
  }
  close() {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.intounderlyingsink_close(ptr);
    return ret;
  }
  abort(reason) {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.intounderlyingsink_abort(ptr, reason);
    return ret;
  }
}
if (Symbol.dispose)
  IntoUnderlyingSink.prototype[Symbol.dispose] = IntoUnderlyingSink.prototype.free;
var IntoUnderlyingSourceFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_intounderlyingsource_free(ptr >>> 0, 1));

class IntoUnderlyingSource {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(IntoUnderlyingSource.prototype);
    obj.__wbg_ptr = ptr;
    IntoUnderlyingSourceFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    IntoUnderlyingSourceFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_intounderlyingsource_free(ptr, 0);
  }
  pull(controller) {
    const ret = wasm.intounderlyingsource_pull(this.__wbg_ptr, controller);
    return ret;
  }
  cancel() {
    const ptr = this.__destroy_into_raw();
    wasm.intounderlyingsource_cancel(ptr);
  }
}
if (Symbol.dispose)
  IntoUnderlyingSource.prototype[Symbol.dispose] = IntoUnderlyingSource.prototype.free;
var ParquetFileFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_parquetfile_free(ptr >>> 0, 1));

class ParquetFile {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ParquetFile.prototype);
    obj.__wbg_ptr = ptr;
    ParquetFileFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ParquetFileFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_parquetfile_free(ptr, 0);
  }
  static fromUrl(url) {
    const ptr0 = passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.parquetfile_fromUrl(ptr0, len0);
    return ret;
  }
  static fromFile(handle) {
    const ret = wasm.parquetfile_fromFile(handle);
    return ret;
  }
  metadata() {
    const ret = wasm.parquetfile_metadata(this.__wbg_ptr);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return ParquetMetaData.__wrap(ret[0]);
  }
  schema() {
    const ret = wasm.parquetfile_schema(this.__wbg_ptr);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return Schema.__wrap(ret[0]);
  }
  read(options) {
    const ret = wasm.parquetfile_read(this.__wbg_ptr, isLikeNone(options) ? 0 : addToExternrefTable0(options));
    return ret;
  }
  stream(options) {
    const ret = wasm.parquetfile_stream(this.__wbg_ptr, isLikeNone(options) ? 0 : addToExternrefTable0(options));
    return ret;
  }
}
if (Symbol.dispose)
  ParquetFile.prototype[Symbol.dispose] = ParquetFile.prototype.free;
var ParquetMetaDataFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_parquetmetadata_free(ptr >>> 0, 1));

class ParquetMetaData {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ParquetMetaData.prototype);
    obj.__wbg_ptr = ptr;
    ParquetMetaDataFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ParquetMetaDataFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_parquetmetadata_free(ptr, 0);
  }
  fileMetadata() {
    const ret = wasm.parquetmetadata_fileMetadata(this.__wbg_ptr);
    return FileMetaData.__wrap(ret);
  }
  numRowGroups() {
    const ret = wasm.parquetmetadata_numRowGroups(this.__wbg_ptr);
    return ret >>> 0;
  }
  rowGroup(i) {
    const ret = wasm.parquetmetadata_rowGroup(this.__wbg_ptr, i);
    return RowGroupMetaData.__wrap(ret);
  }
  rowGroups() {
    const ret = wasm.parquetmetadata_rowGroups(this.__wbg_ptr);
    var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
    return v1;
  }
}
if (Symbol.dispose)
  ParquetMetaData.prototype[Symbol.dispose] = ParquetMetaData.prototype.free;
var RecordBatchFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_recordbatch_free(ptr >>> 0, 1));

class RecordBatch {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(RecordBatch.prototype);
    obj.__wbg_ptr = ptr;
    RecordBatchFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  static __unwrap(jsValue) {
    if (!(jsValue instanceof RecordBatch)) {
      return 0;
    }
    return jsValue.__destroy_into_raw();
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    RecordBatchFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_recordbatch_free(ptr, 0);
  }
  get numRows() {
    const ret = wasm.recordbatch_numRows(this.__wbg_ptr);
    return ret >>> 0;
  }
  get numColumns() {
    const ret = wasm.recordbatch_numColumns(this.__wbg_ptr);
    return ret >>> 0;
  }
  get schema() {
    const ret = wasm.recordbatch_schema(this.__wbg_ptr);
    return Schema.__wrap(ret);
  }
  toFFI() {
    const ret = wasm.recordbatch_toFFI(this.__wbg_ptr);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return FFIData.__wrap(ret[0]);
  }
  intoFFI() {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.recordbatch_intoFFI(ptr);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return FFIData.__wrap(ret[0]);
  }
  intoIPCStream() {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.recordbatch_intoIPCStream(ptr);
    if (ret[3]) {
      throw takeFromExternrefTable0(ret[2]);
    }
    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    return v1;
  }
  withSchema(schema) {
    _assertClass(schema, Schema);
    var ptr0 = schema.__destroy_into_raw();
    const ret = wasm.recordbatch_withSchema(this.__wbg_ptr, ptr0);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return RecordBatch.__wrap(ret[0]);
  }
  slice(offset, length3) {
    const ret = wasm.recordbatch_slice(this.__wbg_ptr, offset, length3);
    return RecordBatch.__wrap(ret);
  }
  getArrayMemorySize() {
    const ret = wasm.recordbatch_getArrayMemorySize(this.__wbg_ptr);
    return ret >>> 0;
  }
}
if (Symbol.dispose)
  RecordBatch.prototype[Symbol.dispose] = RecordBatch.prototype.free;
var RowGroupMetaDataFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_rowgroupmetadata_free(ptr >>> 0, 1));

class RowGroupMetaData {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(RowGroupMetaData.prototype);
    obj.__wbg_ptr = ptr;
    RowGroupMetaDataFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    RowGroupMetaDataFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_rowgroupmetadata_free(ptr, 0);
  }
  numColumns() {
    const ret = wasm.rowgroupmetadata_numColumns(this.__wbg_ptr);
    return ret >>> 0;
  }
  column(i) {
    const ret = wasm.rowgroupmetadata_column(this.__wbg_ptr, i);
    return ColumnChunkMetaData.__wrap(ret);
  }
  columns() {
    const ret = wasm.rowgroupmetadata_columns(this.__wbg_ptr);
    var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
    return v1;
  }
  numRows() {
    const ret = wasm.rowgroupmetadata_numRows(this.__wbg_ptr);
    return ret;
  }
  totalByteSize() {
    const ret = wasm.rowgroupmetadata_totalByteSize(this.__wbg_ptr);
    return ret;
  }
  compressedSize() {
    const ret = wasm.rowgroupmetadata_compressedSize(this.__wbg_ptr);
    return ret;
  }
}
if (Symbol.dispose)
  RowGroupMetaData.prototype[Symbol.dispose] = RowGroupMetaData.prototype.free;
var SchemaFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_schema_free(ptr >>> 0, 1));

class Schema {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Schema.prototype);
    obj.__wbg_ptr = ptr;
    SchemaFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    SchemaFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_schema_free(ptr, 0);
  }
  toFFI() {
    const ret = wasm.schema_toFFI(this.__wbg_ptr);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return FFISchema.__wrap(ret[0]);
  }
  intoFFI() {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.schema_intoFFI(ptr);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return FFISchema.__wrap(ret[0]);
  }
  intoIPCStream() {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.schema_intoIPCStream(ptr);
    if (ret[3]) {
      throw takeFromExternrefTable0(ret[2]);
    }
    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    return v1;
  }
  withMetadata(metadata) {
    const ret = wasm.schema_withMetadata(this.__wbg_ptr, metadata);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return Schema.__wrap(ret[0]);
  }
  indexOf(name) {
    const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.schema_indexOf(this.__wbg_ptr, ptr0, len0);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return ret[0] >>> 0;
  }
  metadata() {
    const ret = wasm.schema_metadata(this.__wbg_ptr);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return takeFromExternrefTable0(ret[0]);
  }
}
if (Symbol.dispose)
  Schema.prototype[Symbol.dispose] = Schema.prototype.free;
var TableFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_table_free(ptr >>> 0, 1));

class Table {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Table.prototype);
    obj.__wbg_ptr = ptr;
    TableFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TableFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_table_free(ptr, 0);
  }
  get schema() {
    const ret = wasm.table_schema(this.__wbg_ptr);
    return Schema.__wrap(ret);
  }
  recordBatch(index) {
    const ret = wasm.table_recordBatch(this.__wbg_ptr, index);
    return ret === 0 ? undefined : RecordBatch.__wrap(ret);
  }
  recordBatches() {
    const ret = wasm.table_recordBatches(this.__wbg_ptr);
    var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
    return v1;
  }
  get numBatches() {
    const ret = wasm.table_numBatches(this.__wbg_ptr);
    return ret >>> 0;
  }
  toFFI() {
    const ret = wasm.table_toFFI(this.__wbg_ptr);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return FFIStream.__wrap(ret[0]);
  }
  intoFFI() {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.table_intoFFI(ptr);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return FFIStream.__wrap(ret[0]);
  }
  intoIPCStream() {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.table_intoIPCStream(ptr);
    if (ret[3]) {
      throw takeFromExternrefTable0(ret[2]);
    }
    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    return v1;
  }
  static fromIPCStream(buf) {
    const ptr0 = passArray8ToWasm0(buf, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.table_fromIPCStream(ptr0, len0);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return Table.__wrap(ret[0]);
  }
  getArrayMemorySize() {
    const ret = wasm.table_getArrayMemorySize(this.__wbg_ptr);
    return ret >>> 0;
  }
}
if (Symbol.dispose)
  Table.prototype[Symbol.dispose] = Table.prototype.free;
var WriterPropertiesFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_writerproperties_free(ptr >>> 0, 1));

class WriterProperties {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(WriterProperties.prototype);
    obj.__wbg_ptr = ptr;
    WriterPropertiesFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    WriterPropertiesFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_writerproperties_free(ptr, 0);
  }
}
if (Symbol.dispose)
  WriterProperties.prototype[Symbol.dispose] = WriterProperties.prototype.free;
var WriterPropertiesBuilderFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {}, unregister: () => {} } : new FinalizationRegistry((ptr) => wasm.__wbg_writerpropertiesbuilder_free(ptr >>> 0, 1));

class WriterPropertiesBuilder {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(WriterPropertiesBuilder.prototype);
    obj.__wbg_ptr = ptr;
    WriterPropertiesBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    WriterPropertiesBuilderFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_writerpropertiesbuilder_free(ptr, 0);
  }
  constructor() {
    const ret = wasm.writerpropertiesbuilder_new();
    this.__wbg_ptr = ret >>> 0;
    WriterPropertiesBuilderFinalization.register(this, this.__wbg_ptr, this);
    return this;
  }
  build() {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.writerpropertiesbuilder_build(ptr);
    return WriterProperties.__wrap(ret);
  }
  setWriterVersion(value) {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.writerpropertiesbuilder_setWriterVersion(ptr, value);
    return WriterPropertiesBuilder.__wrap(ret);
  }
  setDataPageSizeLimit(value) {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.writerpropertiesbuilder_setDataPageSizeLimit(ptr, value);
    return WriterPropertiesBuilder.__wrap(ret);
  }
  setDictionaryPageSizeLimit(value) {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.writerpropertiesbuilder_setDictionaryPageSizeLimit(ptr, value);
    return WriterPropertiesBuilder.__wrap(ret);
  }
  setWriteBatchSize(value) {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.writerpropertiesbuilder_setWriteBatchSize(ptr, value);
    return WriterPropertiesBuilder.__wrap(ret);
  }
  setMaxRowGroupSize(value) {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.writerpropertiesbuilder_setMaxRowGroupSize(ptr, value);
    return WriterPropertiesBuilder.__wrap(ret);
  }
  setCreatedBy(value) {
    const ptr = this.__destroy_into_raw();
    const ptr0 = passStringToWasm0(value, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.writerpropertiesbuilder_setCreatedBy(ptr, ptr0, len0);
    return WriterPropertiesBuilder.__wrap(ret);
  }
  setKeyValueMetadata(value) {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.writerpropertiesbuilder_setKeyValueMetadata(ptr, value);
    if (ret[2]) {
      throw takeFromExternrefTable0(ret[1]);
    }
    return WriterPropertiesBuilder.__wrap(ret[0]);
  }
  setEncoding(value) {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.writerpropertiesbuilder_setEncoding(ptr, value);
    return WriterPropertiesBuilder.__wrap(ret);
  }
  setCompression(value) {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.writerpropertiesbuilder_setCompression(ptr, value);
    return WriterPropertiesBuilder.__wrap(ret);
  }
  setDictionaryEnabled(value) {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.writerpropertiesbuilder_setDictionaryEnabled(ptr, value);
    return WriterPropertiesBuilder.__wrap(ret);
  }
  setStatisticsEnabled(value) {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.writerpropertiesbuilder_setStatisticsEnabled(ptr, value);
    return WriterPropertiesBuilder.__wrap(ret);
  }
  setColumnEncoding(col, value) {
    const ptr = this.__destroy_into_raw();
    const ptr0 = passStringToWasm0(col, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.writerpropertiesbuilder_setColumnEncoding(ptr, ptr0, len0, value);
    return WriterPropertiesBuilder.__wrap(ret);
  }
  setColumnCompression(col, value) {
    const ptr = this.__destroy_into_raw();
    const ptr0 = passStringToWasm0(col, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.writerpropertiesbuilder_setColumnCompression(ptr, ptr0, len0, value);
    return WriterPropertiesBuilder.__wrap(ret);
  }
  setColumnDictionaryEnabled(col, value) {
    const ptr = this.__destroy_into_raw();
    const ptr0 = passStringToWasm0(col, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.writerpropertiesbuilder_setColumnDictionaryEnabled(ptr, ptr0, len0, value);
    return WriterPropertiesBuilder.__wrap(ret);
  }
  setColumnStatisticsEnabled(col, value) {
    const ptr = this.__destroy_into_raw();
    const ptr0 = passStringToWasm0(col, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.writerpropertiesbuilder_setColumnStatisticsEnabled(ptr, ptr0, len0, value);
    return WriterPropertiesBuilder.__wrap(ret);
  }
}
if (Symbol.dispose)
  WriterPropertiesBuilder.prototype[Symbol.dispose] = WriterPropertiesBuilder.prototype.free;
var EXPECTED_RESPONSE_TYPES = new Set(["basic", "cors", "default"]);

// node_modules/tslib/tslib.es6.mjs
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve4) {
      resolve4(value);
    });
  }
  return new (P || (P = Promise))(function(resolve4, reject) {
    function fulfilled(value) {
      try {
        step4(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step4(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step4(result) {
      result.done ? resolve4(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step4((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = undefined;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume2(n, v);
        });
      };
      if (f)
        i[n] = f(i[n]);
    }
  }
  function resume2(n, v) {
    try {
      step4(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step4(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume2("next", value);
  }
  function reject(value) {
    resume2("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length)
      resume2(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve4, reject) {
        v = o[n](v), settle(resolve4, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve4, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve4({ value: v2, done: d });
    }, reject);
  }
}

// node_modules/apache-arrow/util/buffer.mjs
var exports_buffer = {};
__export(exports_buffer, {
  toUint8ClampedArrayIterator: () => toUint8ClampedArrayIterator,
  toUint8ClampedArrayAsyncIterator: () => toUint8ClampedArrayAsyncIterator,
  toUint8ClampedArray: () => toUint8ClampedArray,
  toUint8ArrayIterator: () => toUint8ArrayIterator,
  toUint8ArrayAsyncIterator: () => toUint8ArrayAsyncIterator,
  toUint8Array: () => toUint8Array,
  toUint32ArrayIterator: () => toUint32ArrayIterator,
  toUint32ArrayAsyncIterator: () => toUint32ArrayAsyncIterator,
  toUint32Array: () => toUint32Array,
  toUint16ArrayIterator: () => toUint16ArrayIterator,
  toUint16ArrayAsyncIterator: () => toUint16ArrayAsyncIterator,
  toUint16Array: () => toUint16Array,
  toInt8ArrayIterator: () => toInt8ArrayIterator,
  toInt8ArrayAsyncIterator: () => toInt8ArrayAsyncIterator,
  toInt8Array: () => toInt8Array,
  toInt32ArrayIterator: () => toInt32ArrayIterator,
  toInt32ArrayAsyncIterator: () => toInt32ArrayAsyncIterator,
  toInt32Array: () => toInt32Array,
  toInt16ArrayIterator: () => toInt16ArrayIterator,
  toInt16ArrayAsyncIterator: () => toInt16ArrayAsyncIterator,
  toInt16Array: () => toInt16Array,
  toFloat64ArrayIterator: () => toFloat64ArrayIterator,
  toFloat64ArrayAsyncIterator: () => toFloat64ArrayAsyncIterator,
  toFloat64Array: () => toFloat64Array,
  toFloat32ArrayIterator: () => toFloat32ArrayIterator,
  toFloat32ArrayAsyncIterator: () => toFloat32ArrayAsyncIterator,
  toFloat32Array: () => toFloat32Array,
  toBigUint64Array: () => toBigUint64Array,
  toBigInt64Array: () => toBigInt64Array,
  toArrayBufferViewIterator: () => toArrayBufferViewIterator,
  toArrayBufferViewAsyncIterator: () => toArrayBufferViewAsyncIterator,
  toArrayBufferView: () => toArrayBufferView,
  rebaseValueOffsets: () => rebaseValueOffsets,
  memcpy: () => memcpy,
  joinUint8Arrays: () => joinUint8Arrays,
  compareArrayLike: () => compareArrayLike
});

// node_modules/apache-arrow/util/utf8.mjs
var decoder = new TextDecoder("utf-8");
var decodeUtf8 = decoder.decode.bind(decoder);
var encoder = new TextEncoder;
var encodeUtf8 = (value) => encoder.encode(value);

// node_modules/apache-arrow/util/compat.mjs
var isNumber2 = (x) => typeof x === "number";
var isBoolean2 = (x) => typeof x === "boolean";
var isFunction3 = (x) => typeof x === "function";
var isObject2 = (x) => x != null && Object(x) === x;
var isPromise = (x) => {
  return isObject2(x) && isFunction3(x.then);
};
var isIterable2 = (x) => {
  return isObject2(x) && isFunction3(x[Symbol.iterator]);
};
var isAsyncIterable = (x) => {
  return isObject2(x) && isFunction3(x[Symbol.asyncIterator]);
};
var isArrowJSON = (x) => {
  return isObject2(x) && isObject2(x["schema"]);
};
var isIteratorResult = (x) => {
  return isObject2(x) && "done" in x && "value" in x;
};
var isFileHandle = (x) => {
  return isObject2(x) && isFunction3(x["stat"]) && isNumber2(x["fd"]);
};
var isFetchResponse = (x) => {
  return isObject2(x) && isReadableDOMStream(x["body"]);
};
var isReadableInterop = (x) => ("_getDOMStream" in x) && ("_getNodeStream" in x);
var isWritableDOMStream = (x) => {
  return isObject2(x) && isFunction3(x["abort"]) && isFunction3(x["getWriter"]) && !isReadableInterop(x);
};
var isReadableDOMStream = (x) => {
  return isObject2(x) && isFunction3(x["cancel"]) && isFunction3(x["getReader"]) && !isReadableInterop(x);
};
var isWritableNodeStream = (x) => {
  return isObject2(x) && isFunction3(x["end"]) && isFunction3(x["write"]) && isBoolean2(x["writable"]) && !isReadableInterop(x);
};
var isReadableNodeStream = (x) => {
  return isObject2(x) && isFunction3(x["read"]) && isFunction3(x["pipe"]) && isBoolean2(x["readable"]) && !isReadableInterop(x);
};
var isFlatbuffersByteBuffer = (x) => {
  return isObject2(x) && isFunction3(x["clear"]) && isFunction3(x["bytes"]) && isFunction3(x["position"]) && isFunction3(x["setPosition"]) && isFunction3(x["capacity"]) && isFunction3(x["getBufferIdentifier"]) && isFunction3(x["createLong"]);
};

// node_modules/apache-arrow/util/buffer.mjs
var SharedArrayBuf = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : ArrayBuffer;
function collapseContiguousByteRanges(chunks3) {
  const result = chunks3[0] ? [chunks3[0]] : [];
  let xOffset, yOffset, xLen, yLen;
  for (let x, y, i = 0, j = 0, n = chunks3.length;++i < n; ) {
    x = result[j];
    y = chunks3[i];
    if (!x || !y || x.buffer !== y.buffer || y.byteOffset < x.byteOffset) {
      y && (result[++j] = y);
      continue;
    }
    ({ byteOffset: xOffset, byteLength: xLen } = x);
    ({ byteOffset: yOffset, byteLength: yLen } = y);
    if (xOffset + xLen < yOffset || yOffset + yLen < xOffset) {
      y && (result[++j] = y);
      continue;
    }
    result[j] = new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen);
  }
  return result;
}
function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
  const targetByteLength = target.byteLength;
  const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
  const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
  dst.set(src, targetByteOffset);
  return target;
}
function joinUint8Arrays(chunks3, size13) {
  const result = collapseContiguousByteRanges(chunks3);
  const byteLength = result.reduce((x, b) => x + b.byteLength, 0);
  let source, sliced, buffer3;
  let offset = 0, index = -1;
  const length3 = Math.min(size13 || Number.POSITIVE_INFINITY, byteLength);
  for (const n = result.length;++index < n; ) {
    source = result[index];
    sliced = source.subarray(0, Math.min(source.length, length3 - offset));
    if (length3 <= offset + sliced.length) {
      if (sliced.length < source.length) {
        result[index] = source.subarray(sliced.length);
      } else if (sliced.length === source.length) {
        index++;
      }
      buffer3 ? memcpy(buffer3, sliced, offset) : buffer3 = sliced;
      break;
    }
    memcpy(buffer3 || (buffer3 = new Uint8Array(length3)), sliced, offset);
    offset += sliced.length;
  }
  return [buffer3 || new Uint8Array(0), result.slice(index), byteLength - (buffer3 ? buffer3.byteLength : 0)];
}
function toArrayBufferView(ArrayBufferViewCtor, input) {
  let value = isIteratorResult(input) ? input.value : input;
  if (value instanceof ArrayBufferViewCtor) {
    if (ArrayBufferViewCtor === Uint8Array) {
      return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);
    }
    return value;
  }
  if (!value) {
    return new ArrayBufferViewCtor(0);
  }
  if (typeof value === "string") {
    value = encodeUtf8(value);
  }
  if (value instanceof ArrayBuffer) {
    return new ArrayBufferViewCtor(value);
  }
  if (value instanceof SharedArrayBuf) {
    return new ArrayBufferViewCtor(value);
  }
  if (isFlatbuffersByteBuffer(value)) {
    return toArrayBufferView(ArrayBufferViewCtor, value.bytes());
  }
  return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0) : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);
}
var toInt8Array = (input) => toArrayBufferView(Int8Array, input);
var toInt16Array = (input) => toArrayBufferView(Int16Array, input);
var toInt32Array = (input) => toArrayBufferView(Int32Array, input);
var toBigInt64Array = (input) => toArrayBufferView(BigInt64Array, input);
var toUint8Array = (input) => toArrayBufferView(Uint8Array, input);
var toUint16Array = (input) => toArrayBufferView(Uint16Array, input);
var toUint32Array = (input) => toArrayBufferView(Uint32Array, input);
var toBigUint64Array = (input) => toArrayBufferView(BigUint64Array, input);
var toFloat32Array = (input) => toArrayBufferView(Float32Array, input);
var toFloat64Array = (input) => toArrayBufferView(Float64Array, input);
var toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);
var pump = (iterator) => {
  iterator.next();
  return iterator;
};
function* toArrayBufferViewIterator(ArrayCtor, source) {
  const wrap = function* (x) {
    yield x;
  };
  const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : !isIterable2(source) ? wrap(source) : source;
  yield* pump(function* (it) {
    let r = null;
    do {
      r = it.next(yield toArrayBufferView(ArrayCtor, r));
    } while (!r.done);
  }(buffers[Symbol.iterator]()));
  return new ArrayCtor;
}
var toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);
var toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);
var toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);
var toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);
var toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);
var toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);
var toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);
var toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);
var toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);
function toArrayBufferViewAsyncIterator(ArrayCtor, source) {
  return __asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {
    if (isPromise(source)) {
      return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield __await(source))))));
    }
    const wrap = function(x) {
      return __asyncGenerator(this, arguments, function* () {
        yield yield __await(yield __await(x));
      });
    };
    const emit2 = function(source2) {
      return __asyncGenerator(this, arguments, function* () {
        yield __await(yield* __asyncDelegator(__asyncValues(pump(function* (it) {
          let r = null;
          do {
            r = it.next(yield r === null || r === undefined ? undefined : r.value);
          } while (!r.done);
        }(source2[Symbol.iterator]())))));
      });
    };
    const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : isIterable2(source) ? emit2(source) : !isAsyncIterable(source) ? wrap(source) : source;
    yield __await(yield* __asyncDelegator(__asyncValues(pump(function(it) {
      return __asyncGenerator(this, arguments, function* () {
        let r = null;
        do {
          r = yield __await(it.next(yield yield __await(toArrayBufferView(ArrayCtor, r))));
        } while (!r.done);
      });
    }(buffers[Symbol.asyncIterator]())))));
    return yield __await(new ArrayCtor);
  });
}
var toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);
var toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);
var toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);
var toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);
var toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);
var toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);
var toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);
var toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);
var toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);
function rebaseValueOffsets(offset, length3, valueOffsets) {
  if (offset !== 0) {
    valueOffsets = valueOffsets.slice(0, length3);
    for (let i = -1, n = valueOffsets.length;++i < n; ) {
      valueOffsets[i] += offset;
    }
  }
  return valueOffsets.subarray(0, length3);
}
function compareArrayLike(a, b) {
  let i = 0;
  const n = a.length;
  if (n !== b.length) {
    return false;
  }
  if (n > 0) {
    do {
      if (a[i] !== b[i]) {
        return false;
      }
    } while (++i < n);
  }
  return true;
}

// node_modules/apache-arrow/io/adapters.mjs
var adapters_default = {
  fromIterable(source) {
    return pump2(fromIterable11(source));
  },
  fromAsyncIterable(source) {
    return pump2(fromAsyncIterable3(source));
  },
  fromDOMStream(source) {
    return pump2(fromDOMStream(source));
  },
  fromNodeStream(stream) {
    return pump2(fromNodeStream(stream));
  },
  toDOMStream(source, options) {
    throw new Error(`"toDOMStream" not available in this environment`);
  },
  toNodeStream(source, options) {
    throw new Error(`"toNodeStream" not available in this environment`);
  }
};
var pump2 = (iterator) => {
  iterator.next();
  return iterator;
};
function* fromIterable11(source) {
  let done11, threw = false;
  let buffers = [], buffer3;
  let cmd, size13, bufferLength = 0;
  function byteRange() {
    if (cmd === "peek") {
      return joinUint8Arrays(buffers, size13)[0];
    }
    [buffer3, buffers, bufferLength] = joinUint8Arrays(buffers, size13);
    return buffer3;
  }
  ({ cmd, size: size13 } = (yield (() => null)()) || { cmd: "read", size: 0 });
  const it = toUint8ArrayIterator(source)[Symbol.iterator]();
  try {
    do {
      ({ done: done11, value: buffer3 } = Number.isNaN(size13 - bufferLength) ? it.next() : it.next(size13 - bufferLength));
      if (!done11 && buffer3.byteLength > 0) {
        buffers.push(buffer3);
        bufferLength += buffer3.byteLength;
      }
      if (done11 || size13 <= bufferLength) {
        do {
          ({ cmd, size: size13 } = yield byteRange());
        } while (size13 < bufferLength);
      }
    } while (!done11);
  } catch (e) {
    threw = true;
    typeof it.throw === "function" && it.throw(e);
  } finally {
    threw === false && typeof it.return === "function" && it.return(null);
  }
  return null;
}
function fromAsyncIterable3(source) {
  return __asyncGenerator(this, arguments, function* fromAsyncIterable_1() {
    let done11, threw = false;
    let buffers = [], buffer3;
    let cmd, size13, bufferLength = 0;
    function byteRange() {
      if (cmd === "peek") {
        return joinUint8Arrays(buffers, size13)[0];
      }
      [buffer3, buffers, bufferLength] = joinUint8Arrays(buffers, size13);
      return buffer3;
    }
    ({ cmd, size: size13 } = (yield yield __await((() => null)())) || { cmd: "read", size: 0 });
    const it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();
    try {
      do {
        ({ done: done11, value: buffer3 } = Number.isNaN(size13 - bufferLength) ? yield __await(it.next()) : yield __await(it.next(size13 - bufferLength)));
        if (!done11 && buffer3.byteLength > 0) {
          buffers.push(buffer3);
          bufferLength += buffer3.byteLength;
        }
        if (done11 || size13 <= bufferLength) {
          do {
            ({ cmd, size: size13 } = yield yield __await(byteRange()));
          } while (size13 < bufferLength);
        }
      } while (!done11);
    } catch (e) {
      threw = true;
      typeof it.throw === "function" && (yield __await(it.throw(e)));
    } finally {
      threw === false && typeof it.return === "function" && (yield __await(it.return(new Uint8Array(0))));
    }
    return yield __await(null);
  });
}
function fromDOMStream(source) {
  return __asyncGenerator(this, arguments, function* fromDOMStream_1() {
    let done11 = false, threw = false;
    let buffers = [], buffer3;
    let cmd, size13, bufferLength = 0;
    function byteRange() {
      if (cmd === "peek") {
        return joinUint8Arrays(buffers, size13)[0];
      }
      [buffer3, buffers, bufferLength] = joinUint8Arrays(buffers, size13);
      return buffer3;
    }
    ({ cmd, size: size13 } = (yield yield __await((() => null)())) || { cmd: "read", size: 0 });
    const it = new AdaptiveByteReader(source);
    try {
      do {
        ({ done: done11, value: buffer3 } = Number.isNaN(size13 - bufferLength) ? yield __await(it["read"]()) : yield __await(it["read"](size13 - bufferLength)));
        if (!done11 && buffer3.byteLength > 0) {
          buffers.push(toUint8Array(buffer3));
          bufferLength += buffer3.byteLength;
        }
        if (done11 || size13 <= bufferLength) {
          do {
            ({ cmd, size: size13 } = yield yield __await(byteRange()));
          } while (size13 < bufferLength);
        }
      } while (!done11);
    } catch (e) {
      threw = true;
      yield __await(it["cancel"](e));
    } finally {
      threw === false ? yield __await(it["cancel"]()) : source["locked"] && it.releaseLock();
    }
    return yield __await(null);
  });
}

class AdaptiveByteReader {
  constructor(source) {
    this.source = source;
    this.reader = null;
    this.reader = this.source["getReader"]();
    this.reader["closed"].catch(() => {});
  }
  get closed() {
    return this.reader ? this.reader["closed"].catch(() => {}) : Promise.resolve();
  }
  releaseLock() {
    if (this.reader) {
      this.reader.releaseLock();
    }
    this.reader = null;
  }
  cancel(reason) {
    return __awaiter(this, undefined, undefined, function* () {
      const { reader, source } = this;
      reader && (yield reader["cancel"](reason).catch(() => {}));
      source && (source["locked"] && this.releaseLock());
    });
  }
  read(size13) {
    return __awaiter(this, undefined, undefined, function* () {
      if (size13 === 0) {
        return { done: this.reader == null, value: new Uint8Array(0) };
      }
      const result = yield this.reader.read();
      !result.done && (result.value = toUint8Array(result));
      return result;
    });
  }
}
var onEvent = (stream, event) => {
  const handler = (_) => resolve4([event, _]);
  let resolve4;
  return [event, handler, new Promise((r) => (resolve4 = r) && stream["once"](event, handler))];
};
function fromNodeStream(stream) {
  return __asyncGenerator(this, arguments, function* fromNodeStream_1() {
    const events = [];
    let event = "error";
    let done11 = false, err = null;
    let cmd, size13, bufferLength = 0;
    let buffers = [], buffer3;
    function byteRange() {
      if (cmd === "peek") {
        return joinUint8Arrays(buffers, size13)[0];
      }
      [buffer3, buffers, bufferLength] = joinUint8Arrays(buffers, size13);
      return buffer3;
    }
    ({ cmd, size: size13 } = (yield yield __await((() => null)())) || { cmd: "read", size: 0 });
    if (stream["isTTY"]) {
      yield yield __await(new Uint8Array(0));
      return yield __await(null);
    }
    try {
      events[0] = onEvent(stream, "end");
      events[1] = onEvent(stream, "error");
      do {
        events[2] = onEvent(stream, "readable");
        [event, err] = yield __await(Promise.race(events.map((x) => x[2])));
        if (event === "error") {
          break;
        }
        if (!(done11 = event === "end")) {
          if (!Number.isFinite(size13 - bufferLength)) {
            buffer3 = toUint8Array(stream["read"]());
          } else {
            buffer3 = toUint8Array(stream["read"](size13 - bufferLength));
            if (buffer3.byteLength < size13 - bufferLength) {
              buffer3 = toUint8Array(stream["read"]());
            }
          }
          if (buffer3.byteLength > 0) {
            buffers.push(buffer3);
            bufferLength += buffer3.byteLength;
          }
        }
        if (done11 || size13 <= bufferLength) {
          do {
            ({ cmd, size: size13 } = yield yield __await(byteRange()));
          } while (size13 < bufferLength);
        }
      } while (!done11);
    } finally {
      yield __await(cleanup(events, event === "error" ? err : null));
    }
    return yield __await(null);
    function cleanup(events2, err2) {
      buffer3 = buffers = null;
      return new Promise((resolve4, reject) => {
        for (const [evt, fn2] of events2) {
          stream["off"](evt, fn2);
        }
        try {
          const destroy = stream["destroy"];
          destroy && destroy.call(stream, err2);
          err2 = undefined;
        } catch (e) {
          err2 = e || err2;
        } finally {
          err2 != null ? reject(err2) : resolve4();
        }
      });
    }
  });
}

// node_modules/apache-arrow/fb/metadata-version.mjs
var MetadataVersion;
(function(MetadataVersion2) {
  MetadataVersion2[MetadataVersion2["V1"] = 0] = "V1";
  MetadataVersion2[MetadataVersion2["V2"] = 1] = "V2";
  MetadataVersion2[MetadataVersion2["V3"] = 2] = "V3";
  MetadataVersion2[MetadataVersion2["V4"] = 3] = "V4";
  MetadataVersion2[MetadataVersion2["V5"] = 4] = "V5";
})(MetadataVersion || (MetadataVersion = {}));
// node_modules/apache-arrow/fb/union-mode.mjs
var UnionMode;
(function(UnionMode2) {
  UnionMode2[UnionMode2["Sparse"] = 0] = "Sparse";
  UnionMode2[UnionMode2["Dense"] = 1] = "Dense";
})(UnionMode || (UnionMode = {}));
// node_modules/apache-arrow/fb/precision.mjs
var Precision;
(function(Precision2) {
  Precision2[Precision2["HALF"] = 0] = "HALF";
  Precision2[Precision2["SINGLE"] = 1] = "SINGLE";
  Precision2[Precision2["DOUBLE"] = 2] = "DOUBLE";
})(Precision || (Precision = {}));
// node_modules/apache-arrow/fb/date-unit.mjs
var DateUnit;
(function(DateUnit2) {
  DateUnit2[DateUnit2["DAY"] = 0] = "DAY";
  DateUnit2[DateUnit2["MILLISECOND"] = 1] = "MILLISECOND";
})(DateUnit || (DateUnit = {}));
// node_modules/apache-arrow/fb/time-unit.mjs
var TimeUnit;
(function(TimeUnit2) {
  TimeUnit2[TimeUnit2["SECOND"] = 0] = "SECOND";
  TimeUnit2[TimeUnit2["MILLISECOND"] = 1] = "MILLISECOND";
  TimeUnit2[TimeUnit2["MICROSECOND"] = 2] = "MICROSECOND";
  TimeUnit2[TimeUnit2["NANOSECOND"] = 3] = "NANOSECOND";
})(TimeUnit || (TimeUnit = {}));
// node_modules/apache-arrow/fb/interval-unit.mjs
var IntervalUnit;
(function(IntervalUnit2) {
  IntervalUnit2[IntervalUnit2["YEAR_MONTH"] = 0] = "YEAR_MONTH";
  IntervalUnit2[IntervalUnit2["DAY_TIME"] = 1] = "DAY_TIME";
  IntervalUnit2[IntervalUnit2["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
})(IntervalUnit || (IntervalUnit = {}));
// node_modules/flatbuffers/mjs/constants.js
var SIZEOF_SHORT = 2;
var SIZEOF_INT = 4;
var FILE_IDENTIFIER_LENGTH = 4;
var SIZE_PREFIX_LENGTH = 4;
// node_modules/flatbuffers/mjs/utils.js
var int32 = new Int32Array(2);
var float32 = new Float32Array(int32.buffer);
var float64 = new Float64Array(int32.buffer);
var isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
// node_modules/flatbuffers/mjs/encoding.js
var Encoding2;
(function(Encoding3) {
  Encoding3[Encoding3["UTF8_BYTES"] = 1] = "UTF8_BYTES";
  Encoding3[Encoding3["UTF16_STRING"] = 2] = "UTF16_STRING";
})(Encoding2 || (Encoding2 = {}));

// node_modules/flatbuffers/mjs/byte-buffer.js
class ByteBuffer {
  constructor(bytes_) {
    this.bytes_ = bytes_;
    this.position_ = 0;
    this.text_decoder_ = new TextDecoder;
  }
  static allocate(byte_size) {
    return new ByteBuffer(new Uint8Array(byte_size));
  }
  clear() {
    this.position_ = 0;
  }
  bytes() {
    return this.bytes_;
  }
  position() {
    return this.position_;
  }
  setPosition(position) {
    this.position_ = position;
  }
  capacity() {
    return this.bytes_.length;
  }
  readInt8(offset) {
    return this.readUint8(offset) << 24 >> 24;
  }
  readUint8(offset) {
    return this.bytes_[offset];
  }
  readInt16(offset) {
    return this.readUint16(offset) << 16 >> 16;
  }
  readUint16(offset) {
    return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
  }
  readInt32(offset) {
    return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
  }
  readUint32(offset) {
    return this.readInt32(offset) >>> 0;
  }
  readInt64(offset) {
    return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
  }
  readUint64(offset) {
    return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
  }
  readFloat32(offset) {
    int32[0] = this.readInt32(offset);
    return float32[0];
  }
  readFloat64(offset) {
    int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);
    int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
    return float64[0];
  }
  writeInt8(offset, value) {
    this.bytes_[offset] = value;
  }
  writeUint8(offset, value) {
    this.bytes_[offset] = value;
  }
  writeInt16(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
  }
  writeUint16(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
  }
  writeInt32(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
    this.bytes_[offset + 2] = value >> 16;
    this.bytes_[offset + 3] = value >> 24;
  }
  writeUint32(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
    this.bytes_[offset + 2] = value >> 16;
    this.bytes_[offset + 3] = value >> 24;
  }
  writeInt64(offset, value) {
    this.writeInt32(offset, Number(BigInt.asIntN(32, value)));
    this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));
  }
  writeUint64(offset, value) {
    this.writeUint32(offset, Number(BigInt.asUintN(32, value)));
    this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));
  }
  writeFloat32(offset, value) {
    float32[0] = value;
    this.writeInt32(offset, int32[0]);
  }
  writeFloat64(offset, value) {
    float64[0] = value;
    this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);
    this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);
  }
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    }
    let result = "";
    for (let i = 0;i < FILE_IDENTIFIER_LENGTH; i++) {
      result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));
    }
    return result;
  }
  __offset(bb_pos, vtable_offset) {
    const vtable = bb_pos - this.readInt32(bb_pos);
    return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
  }
  __union(t, offset) {
    t.bb_pos = offset + this.readInt32(offset);
    t.bb = this;
    return t;
  }
  __string(offset, opt_encoding) {
    offset += this.readInt32(offset);
    const length3 = this.readInt32(offset);
    offset += SIZEOF_INT;
    const utf8bytes = this.bytes_.subarray(offset, offset + length3);
    if (opt_encoding === Encoding2.UTF8_BYTES)
      return utf8bytes;
    else
      return this.text_decoder_.decode(utf8bytes);
  }
  __union_with_string(o, offset) {
    if (typeof o === "string") {
      return this.__string(offset);
    }
    return this.__union(o, offset);
  }
  __indirect(offset) {
    return offset + this.readInt32(offset);
  }
  __vector(offset) {
    return offset + this.readInt32(offset) + SIZEOF_INT;
  }
  __vector_len(offset) {
    return this.readInt32(offset + this.readInt32(offset));
  }
  __has_identifier(ident) {
    if (ident.length != FILE_IDENTIFIER_LENGTH) {
      throw new Error("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
    }
    for (let i = 0;i < FILE_IDENTIFIER_LENGTH; i++) {
      if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {
        return false;
      }
    }
    return true;
  }
  createScalarList(listAccessor, listLength) {
    const ret = [];
    for (let i = 0;i < listLength; ++i) {
      const val = listAccessor(i);
      if (val !== null) {
        ret.push(val);
      }
    }
    return ret;
  }
  createObjList(listAccessor, listLength) {
    const ret = [];
    for (let i = 0;i < listLength; ++i) {
      const val = listAccessor(i);
      if (val !== null) {
        ret.push(val.unpack());
      }
    }
    return ret;
  }
}

// node_modules/flatbuffers/mjs/builder.js
class Builder {
  constructor(opt_initial_size) {
    this.minalign = 1;
    this.vtable = null;
    this.vtable_in_use = 0;
    this.isNested = false;
    this.object_start = 0;
    this.vtables = [];
    this.vector_num_elems = 0;
    this.force_defaults = false;
    this.string_maps = null;
    this.text_encoder = new TextEncoder;
    let initial_size;
    if (!opt_initial_size) {
      initial_size = 1024;
    } else {
      initial_size = opt_initial_size;
    }
    this.bb = ByteBuffer.allocate(initial_size);
    this.space = initial_size;
  }
  clear() {
    this.bb.clear();
    this.space = this.bb.capacity();
    this.minalign = 1;
    this.vtable = null;
    this.vtable_in_use = 0;
    this.isNested = false;
    this.object_start = 0;
    this.vtables = [];
    this.vector_num_elems = 0;
    this.force_defaults = false;
    this.string_maps = null;
  }
  forceDefaults(forceDefaults) {
    this.force_defaults = forceDefaults;
  }
  dataBuffer() {
    return this.bb;
  }
  asUint8Array() {
    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
  }
  prep(size13, additional_bytes) {
    if (size13 > this.minalign) {
      this.minalign = size13;
    }
    const align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size13 - 1;
    while (this.space < align_size + size13 + additional_bytes) {
      const old_buf_size = this.bb.capacity();
      this.bb = Builder.growByteBuffer(this.bb);
      this.space += this.bb.capacity() - old_buf_size;
    }
    this.pad(align_size);
  }
  pad(byte_size) {
    for (let i = 0;i < byte_size; i++) {
      this.bb.writeInt8(--this.space, 0);
    }
  }
  writeInt8(value) {
    this.bb.writeInt8(this.space -= 1, value);
  }
  writeInt16(value) {
    this.bb.writeInt16(this.space -= 2, value);
  }
  writeInt32(value) {
    this.bb.writeInt32(this.space -= 4, value);
  }
  writeInt64(value) {
    this.bb.writeInt64(this.space -= 8, value);
  }
  writeFloat32(value) {
    this.bb.writeFloat32(this.space -= 4, value);
  }
  writeFloat64(value) {
    this.bb.writeFloat64(this.space -= 8, value);
  }
  addInt8(value) {
    this.prep(1, 0);
    this.writeInt8(value);
  }
  addInt16(value) {
    this.prep(2, 0);
    this.writeInt16(value);
  }
  addInt32(value) {
    this.prep(4, 0);
    this.writeInt32(value);
  }
  addInt64(value) {
    this.prep(8, 0);
    this.writeInt64(value);
  }
  addFloat32(value) {
    this.prep(4, 0);
    this.writeFloat32(value);
  }
  addFloat64(value) {
    this.prep(8, 0);
    this.writeFloat64(value);
  }
  addFieldInt8(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt8(value);
      this.slot(voffset);
    }
  }
  addFieldInt16(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt16(value);
      this.slot(voffset);
    }
  }
  addFieldInt32(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt32(value);
      this.slot(voffset);
    }
  }
  addFieldInt64(voffset, value, defaultValue) {
    if (this.force_defaults || value !== defaultValue) {
      this.addInt64(value);
      this.slot(voffset);
    }
  }
  addFieldFloat32(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addFloat32(value);
      this.slot(voffset);
    }
  }
  addFieldFloat64(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addFloat64(value);
      this.slot(voffset);
    }
  }
  addFieldOffset(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addOffset(value);
      this.slot(voffset);
    }
  }
  addFieldStruct(voffset, value, defaultValue) {
    if (value != defaultValue) {
      this.nested(value);
      this.slot(voffset);
    }
  }
  nested(obj) {
    if (obj != this.offset()) {
      throw new TypeError("FlatBuffers: struct must be serialized inline.");
    }
  }
  notNested() {
    if (this.isNested) {
      throw new TypeError("FlatBuffers: object serialization must not be nested.");
    }
  }
  slot(voffset) {
    if (this.vtable !== null)
      this.vtable[voffset] = this.offset();
  }
  offset() {
    return this.bb.capacity() - this.space;
  }
  static growByteBuffer(bb) {
    const old_buf_size = bb.capacity();
    if (old_buf_size & 3221225472) {
      throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
    }
    const new_buf_size = old_buf_size << 1;
    const nbb = ByteBuffer.allocate(new_buf_size);
    nbb.setPosition(new_buf_size - old_buf_size);
    nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
    return nbb;
  }
  addOffset(offset) {
    this.prep(SIZEOF_INT, 0);
    this.writeInt32(this.offset() - offset + SIZEOF_INT);
  }
  startObject(numfields) {
    this.notNested();
    if (this.vtable == null) {
      this.vtable = [];
    }
    this.vtable_in_use = numfields;
    for (let i = 0;i < numfields; i++) {
      this.vtable[i] = 0;
    }
    this.isNested = true;
    this.object_start = this.offset();
  }
  endObject() {
    if (this.vtable == null || !this.isNested) {
      throw new Error("FlatBuffers: endObject called without startObject");
    }
    this.addInt32(0);
    const vtableloc = this.offset();
    let i = this.vtable_in_use - 1;
    for (;i >= 0 && this.vtable[i] == 0; i--) {}
    const trimmed_size = i + 1;
    for (;i >= 0; i--) {
      this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
    }
    const standard_fields = 2;
    this.addInt16(vtableloc - this.object_start);
    const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;
    this.addInt16(len);
    let existing_vtable = 0;
    const vt1 = this.space;
    outer_loop:
      for (i = 0;i < this.vtables.length; i++) {
        const vt2 = this.bb.capacity() - this.vtables[i];
        if (len == this.bb.readInt16(vt2)) {
          for (let j = SIZEOF_SHORT;j < len; j += SIZEOF_SHORT) {
            if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
              continue outer_loop;
            }
          }
          existing_vtable = this.vtables[i];
          break;
        }
      }
    if (existing_vtable) {
      this.space = this.bb.capacity() - vtableloc;
      this.bb.writeInt32(this.space, existing_vtable - vtableloc);
    } else {
      this.vtables.push(this.offset());
      this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
    }
    this.isNested = false;
    return vtableloc;
  }
  finish(root_table, opt_file_identifier, opt_size_prefix) {
    const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;
    if (opt_file_identifier) {
      const file_identifier = opt_file_identifier;
      this.prep(this.minalign, SIZEOF_INT + FILE_IDENTIFIER_LENGTH + size_prefix);
      if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {
        throw new TypeError("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
      }
      for (let i = FILE_IDENTIFIER_LENGTH - 1;i >= 0; i--) {
        this.writeInt8(file_identifier.charCodeAt(i));
      }
    }
    this.prep(this.minalign, SIZEOF_INT + size_prefix);
    this.addOffset(root_table);
    if (size_prefix) {
      this.addInt32(this.bb.capacity() - this.space);
    }
    this.bb.setPosition(this.space);
  }
  finishSizePrefixed(root_table, opt_file_identifier) {
    this.finish(root_table, opt_file_identifier, true);
  }
  requiredField(table, field) {
    const table_start = this.bb.capacity() - table;
    const vtable_start = table_start - this.bb.readInt32(table_start);
    const ok = field < this.bb.readInt16(vtable_start) && this.bb.readInt16(vtable_start + field) != 0;
    if (!ok) {
      throw new TypeError("FlatBuffers: field " + field + " must be set");
    }
  }
  startVector(elem_size, num_elems, alignment) {
    this.notNested();
    this.vector_num_elems = num_elems;
    this.prep(SIZEOF_INT, elem_size * num_elems);
    this.prep(alignment, elem_size * num_elems);
  }
  endVector() {
    this.writeInt32(this.vector_num_elems);
    return this.offset();
  }
  createSharedString(s) {
    if (!s) {
      return 0;
    }
    if (!this.string_maps) {
      this.string_maps = new Map;
    }
    if (this.string_maps.has(s)) {
      return this.string_maps.get(s);
    }
    const offset = this.createString(s);
    this.string_maps.set(s, offset);
    return offset;
  }
  createString(s) {
    if (s === null || s === undefined) {
      return 0;
    }
    let utf8;
    if (s instanceof Uint8Array) {
      utf8 = s;
    } else {
      utf8 = this.text_encoder.encode(s);
    }
    this.addInt8(0);
    this.startVector(1, utf8.length, 1);
    this.bb.setPosition(this.space -= utf8.length);
    this.bb.bytes().set(utf8, this.space);
    return this.endVector();
  }
  createByteVector(v) {
    if (v === null || v === undefined) {
      return 0;
    }
    this.startVector(1, v.length, 1);
    this.bb.setPosition(this.space -= v.length);
    this.bb.bytes().set(v, this.space);
    return this.endVector();
  }
  createObjectOffset(obj) {
    if (obj === null) {
      return 0;
    }
    if (typeof obj === "string") {
      return this.createString(obj);
    } else {
      return obj.pack(this);
    }
  }
  createObjectOffsetList(list) {
    const ret = [];
    for (let i = 0;i < list.length; ++i) {
      const val = list[i];
      if (val !== null) {
        ret.push(this.createObjectOffset(val));
      } else {
        throw new TypeError("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
      }
    }
    return ret;
  }
  createStructOffsetList(list, startFunc) {
    startFunc(this, list.length);
    this.createObjectOffsetList(list.slice().reverse());
    return this.endVector();
  }
}
// node_modules/apache-arrow/fb/body-compression-method.mjs
var BodyCompressionMethod;
(function(BodyCompressionMethod2) {
  BodyCompressionMethod2[BodyCompressionMethod2["BUFFER"] = 0] = "BUFFER";
})(BodyCompressionMethod || (BodyCompressionMethod = {}));

// node_modules/apache-arrow/fb/compression-type.mjs
var CompressionType;
(function(CompressionType2) {
  CompressionType2[CompressionType2["LZ4_FRAME"] = 0] = "LZ4_FRAME";
  CompressionType2[CompressionType2["ZSTD"] = 1] = "ZSTD";
})(CompressionType || (CompressionType = {}));

// node_modules/apache-arrow/fb/body-compression.mjs
class BodyCompression {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsBodyCompression(bb, obj) {
    return (obj || new BodyCompression).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsBodyCompression(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new BodyCompression).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  codec() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : CompressionType.LZ4_FRAME;
  }
  method() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readInt8(this.bb_pos + offset) : BodyCompressionMethod.BUFFER;
  }
  static startBodyCompression(builder) {
    builder.startObject(2);
  }
  static addCodec(builder, codec) {
    builder.addFieldInt8(0, codec, CompressionType.LZ4_FRAME);
  }
  static addMethod(builder, method) {
    builder.addFieldInt8(1, method, BodyCompressionMethod.BUFFER);
  }
  static endBodyCompression(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createBodyCompression(builder, codec, method) {
    BodyCompression.startBodyCompression(builder);
    BodyCompression.addCodec(builder, codec);
    BodyCompression.addMethod(builder, method);
    return BodyCompression.endBodyCompression(builder);
  }
}

// node_modules/apache-arrow/fb/buffer.mjs
class Buffer {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  offset() {
    return this.bb.readInt64(this.bb_pos);
  }
  length() {
    return this.bb.readInt64(this.bb_pos + 8);
  }
  static sizeOf() {
    return 16;
  }
  static createBuffer(builder, offset, length3) {
    builder.prep(8, 16);
    builder.writeInt64(BigInt(length3 !== null && length3 !== undefined ? length3 : 0));
    builder.writeInt64(BigInt(offset !== null && offset !== undefined ? offset : 0));
    return builder.offset();
  }
}

// node_modules/apache-arrow/fb/field-node.mjs
class FieldNode {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  length() {
    return this.bb.readInt64(this.bb_pos);
  }
  nullCount() {
    return this.bb.readInt64(this.bb_pos + 8);
  }
  static sizeOf() {
    return 16;
  }
  static createFieldNode(builder, length3, null_count) {
    builder.prep(8, 16);
    builder.writeInt64(BigInt(null_count !== null && null_count !== undefined ? null_count : 0));
    builder.writeInt64(BigInt(length3 !== null && length3 !== undefined ? length3 : 0));
    return builder.offset();
  }
}

// node_modules/apache-arrow/fb/record-batch.mjs
class RecordBatch2 {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsRecordBatch(bb, obj) {
    return (obj || new RecordBatch2).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsRecordBatch(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new RecordBatch2).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  length() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
  }
  nodes(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? (obj || new FieldNode).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
  }
  nodesLength() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  buffers(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? (obj || new Buffer).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
  }
  buffersLength() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  compression(obj) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? (obj || new BodyCompression).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
  }
  static startRecordBatch(builder) {
    builder.startObject(4);
  }
  static addLength(builder, length3) {
    builder.addFieldInt64(0, length3, BigInt("0"));
  }
  static addNodes(builder, nodesOffset) {
    builder.addFieldOffset(1, nodesOffset, 0);
  }
  static startNodesVector(builder, numElems) {
    builder.startVector(16, numElems, 8);
  }
  static addBuffers(builder, buffersOffset) {
    builder.addFieldOffset(2, buffersOffset, 0);
  }
  static startBuffersVector(builder, numElems) {
    builder.startVector(16, numElems, 8);
  }
  static addCompression(builder, compressionOffset) {
    builder.addFieldOffset(3, compressionOffset, 0);
  }
  static endRecordBatch(builder) {
    const offset = builder.endObject();
    return offset;
  }
}

// node_modules/apache-arrow/fb/dictionary-batch.mjs
class DictionaryBatch {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsDictionaryBatch(bb, obj) {
    return (obj || new DictionaryBatch).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsDictionaryBatch(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new DictionaryBatch).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  id() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
  }
  data(obj) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? (obj || new RecordBatch2).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
  }
  isDelta() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
  }
  static startDictionaryBatch(builder) {
    builder.startObject(3);
  }
  static addId(builder, id2) {
    builder.addFieldInt64(0, id2, BigInt("0"));
  }
  static addData(builder, dataOffset) {
    builder.addFieldOffset(1, dataOffset, 0);
  }
  static addIsDelta(builder, isDelta) {
    builder.addFieldInt8(2, +isDelta, 0);
  }
  static endDictionaryBatch(builder) {
    const offset = builder.endObject();
    return offset;
  }
}

// node_modules/apache-arrow/fb/endianness.mjs
var Endianness;
(function(Endianness2) {
  Endianness2[Endianness2["Little"] = 0] = "Little";
  Endianness2[Endianness2["Big"] = 1] = "Big";
})(Endianness || (Endianness = {}));

// node_modules/apache-arrow/fb/dictionary-kind.mjs
var DictionaryKind;
(function(DictionaryKind2) {
  DictionaryKind2[DictionaryKind2["DenseArray"] = 0] = "DenseArray";
})(DictionaryKind || (DictionaryKind = {}));

// node_modules/apache-arrow/fb/int.mjs
class Int {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsInt(bb, obj) {
    return (obj || new Int).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsInt(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Int).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  bitWidth() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
  }
  isSigned() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
  }
  static startInt(builder) {
    builder.startObject(2);
  }
  static addBitWidth(builder, bitWidth) {
    builder.addFieldInt32(0, bitWidth, 0);
  }
  static addIsSigned(builder, isSigned) {
    builder.addFieldInt8(1, +isSigned, 0);
  }
  static endInt(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createInt(builder, bitWidth, isSigned) {
    Int.startInt(builder);
    Int.addBitWidth(builder, bitWidth);
    Int.addIsSigned(builder, isSigned);
    return Int.endInt(builder);
  }
}

// node_modules/apache-arrow/fb/dictionary-encoding.mjs
class DictionaryEncoding {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsDictionaryEncoding(bb, obj) {
    return (obj || new DictionaryEncoding).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsDictionaryEncoding(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new DictionaryEncoding).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  id() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
  }
  indexType(obj) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? (obj || new Int).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
  }
  isOrdered() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
  }
  dictionaryKind() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readInt16(this.bb_pos + offset) : DictionaryKind.DenseArray;
  }
  static startDictionaryEncoding(builder) {
    builder.startObject(4);
  }
  static addId(builder, id2) {
    builder.addFieldInt64(0, id2, BigInt("0"));
  }
  static addIndexType(builder, indexTypeOffset) {
    builder.addFieldOffset(1, indexTypeOffset, 0);
  }
  static addIsOrdered(builder, isOrdered) {
    builder.addFieldInt8(2, +isOrdered, 0);
  }
  static addDictionaryKind(builder, dictionaryKind) {
    builder.addFieldInt16(3, dictionaryKind, DictionaryKind.DenseArray);
  }
  static endDictionaryEncoding(builder) {
    const offset = builder.endObject();
    return offset;
  }
}

// node_modules/apache-arrow/fb/key-value.mjs
class KeyValue {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsKeyValue(bb, obj) {
    return (obj || new KeyValue).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsKeyValue(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new KeyValue).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  key(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  value(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  static startKeyValue(builder) {
    builder.startObject(2);
  }
  static addKey(builder, keyOffset) {
    builder.addFieldOffset(0, keyOffset, 0);
  }
  static addValue(builder, valueOffset) {
    builder.addFieldOffset(1, valueOffset, 0);
  }
  static endKeyValue(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createKeyValue(builder, keyOffset, valueOffset) {
    KeyValue.startKeyValue(builder);
    KeyValue.addKey(builder, keyOffset);
    KeyValue.addValue(builder, valueOffset);
    return KeyValue.endKeyValue(builder);
  }
}

// node_modules/apache-arrow/fb/binary.mjs
class Binary {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsBinary(bb, obj) {
    return (obj || new Binary).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsBinary(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Binary).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static startBinary(builder) {
    builder.startObject(0);
  }
  static endBinary(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createBinary(builder) {
    Binary.startBinary(builder);
    return Binary.endBinary(builder);
  }
}

// node_modules/apache-arrow/fb/bool.mjs
class Bool {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsBool(bb, obj) {
    return (obj || new Bool).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsBool(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Bool).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static startBool(builder) {
    builder.startObject(0);
  }
  static endBool(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createBool(builder) {
    Bool.startBool(builder);
    return Bool.endBool(builder);
  }
}

// node_modules/apache-arrow/fb/date.mjs
class Date3 {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsDate(bb, obj) {
    return (obj || new Date3).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsDate(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Date3).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  unit() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readInt16(this.bb_pos + offset) : DateUnit.MILLISECOND;
  }
  static startDate(builder) {
    builder.startObject(1);
  }
  static addUnit(builder, unit) {
    builder.addFieldInt16(0, unit, DateUnit.MILLISECOND);
  }
  static endDate(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createDate(builder, unit) {
    Date3.startDate(builder);
    Date3.addUnit(builder, unit);
    return Date3.endDate(builder);
  }
}

// node_modules/apache-arrow/fb/decimal.mjs
class Decimal {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsDecimal(bb, obj) {
    return (obj || new Decimal).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsDecimal(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Decimal).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  precision() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
  }
  scale() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
  }
  bitWidth() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readInt32(this.bb_pos + offset) : 128;
  }
  static startDecimal(builder) {
    builder.startObject(3);
  }
  static addPrecision(builder, precision) {
    builder.addFieldInt32(0, precision, 0);
  }
  static addScale(builder, scale) {
    builder.addFieldInt32(1, scale, 0);
  }
  static addBitWidth(builder, bitWidth) {
    builder.addFieldInt32(2, bitWidth, 128);
  }
  static endDecimal(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createDecimal(builder, precision, scale, bitWidth) {
    Decimal.startDecimal(builder);
    Decimal.addPrecision(builder, precision);
    Decimal.addScale(builder, scale);
    Decimal.addBitWidth(builder, bitWidth);
    return Decimal.endDecimal(builder);
  }
}

// node_modules/apache-arrow/fb/duration.mjs
class Duration {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsDuration(bb, obj) {
    return (obj || new Duration).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsDuration(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Duration).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  unit() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit.MILLISECOND;
  }
  static startDuration(builder) {
    builder.startObject(1);
  }
  static addUnit(builder, unit) {
    builder.addFieldInt16(0, unit, TimeUnit.MILLISECOND);
  }
  static endDuration(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createDuration(builder, unit) {
    Duration.startDuration(builder);
    Duration.addUnit(builder, unit);
    return Duration.endDuration(builder);
  }
}

// node_modules/apache-arrow/fb/fixed-size-binary.mjs
class FixedSizeBinary {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsFixedSizeBinary(bb, obj) {
    return (obj || new FixedSizeBinary).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsFixedSizeBinary(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new FixedSizeBinary).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  byteWidth() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
  }
  static startFixedSizeBinary(builder) {
    builder.startObject(1);
  }
  static addByteWidth(builder, byteWidth) {
    builder.addFieldInt32(0, byteWidth, 0);
  }
  static endFixedSizeBinary(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createFixedSizeBinary(builder, byteWidth) {
    FixedSizeBinary.startFixedSizeBinary(builder);
    FixedSizeBinary.addByteWidth(builder, byteWidth);
    return FixedSizeBinary.endFixedSizeBinary(builder);
  }
}

// node_modules/apache-arrow/fb/fixed-size-list.mjs
class FixedSizeList {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsFixedSizeList(bb, obj) {
    return (obj || new FixedSizeList).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsFixedSizeList(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new FixedSizeList).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  listSize() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
  }
  static startFixedSizeList(builder) {
    builder.startObject(1);
  }
  static addListSize(builder, listSize) {
    builder.addFieldInt32(0, listSize, 0);
  }
  static endFixedSizeList(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createFixedSizeList(builder, listSize) {
    FixedSizeList.startFixedSizeList(builder);
    FixedSizeList.addListSize(builder, listSize);
    return FixedSizeList.endFixedSizeList(builder);
  }
}

// node_modules/apache-arrow/fb/floating-point.mjs
class FloatingPoint {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsFloatingPoint(bb, obj) {
    return (obj || new FloatingPoint).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsFloatingPoint(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new FloatingPoint).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  precision() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readInt16(this.bb_pos + offset) : Precision.HALF;
  }
  static startFloatingPoint(builder) {
    builder.startObject(1);
  }
  static addPrecision(builder, precision) {
    builder.addFieldInt16(0, precision, Precision.HALF);
  }
  static endFloatingPoint(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createFloatingPoint(builder, precision) {
    FloatingPoint.startFloatingPoint(builder);
    FloatingPoint.addPrecision(builder, precision);
    return FloatingPoint.endFloatingPoint(builder);
  }
}

// node_modules/apache-arrow/fb/interval.mjs
class Interval {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsInterval(bb, obj) {
    return (obj || new Interval).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsInterval(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Interval).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  unit() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readInt16(this.bb_pos + offset) : IntervalUnit.YEAR_MONTH;
  }
  static startInterval(builder) {
    builder.startObject(1);
  }
  static addUnit(builder, unit) {
    builder.addFieldInt16(0, unit, IntervalUnit.YEAR_MONTH);
  }
  static endInterval(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createInterval(builder, unit) {
    Interval.startInterval(builder);
    Interval.addUnit(builder, unit);
    return Interval.endInterval(builder);
  }
}

// node_modules/apache-arrow/fb/large-binary.mjs
class LargeBinary {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsLargeBinary(bb, obj) {
    return (obj || new LargeBinary).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsLargeBinary(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new LargeBinary).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static startLargeBinary(builder) {
    builder.startObject(0);
  }
  static endLargeBinary(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createLargeBinary(builder) {
    LargeBinary.startLargeBinary(builder);
    return LargeBinary.endLargeBinary(builder);
  }
}

// node_modules/apache-arrow/fb/large-utf8.mjs
class LargeUtf8 {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsLargeUtf8(bb, obj) {
    return (obj || new LargeUtf8).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsLargeUtf8(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new LargeUtf8).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static startLargeUtf8(builder) {
    builder.startObject(0);
  }
  static endLargeUtf8(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createLargeUtf8(builder) {
    LargeUtf8.startLargeUtf8(builder);
    return LargeUtf8.endLargeUtf8(builder);
  }
}

// node_modules/apache-arrow/fb/list.mjs
class List {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsList(bb, obj) {
    return (obj || new List).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsList(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new List).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static startList(builder) {
    builder.startObject(0);
  }
  static endList(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createList(builder) {
    List.startList(builder);
    return List.endList(builder);
  }
}

// node_modules/apache-arrow/fb/map.mjs
class Map2 {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsMap(bb, obj) {
    return (obj || new Map2).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsMap(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Map2).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  keysSorted() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
  }
  static startMap(builder) {
    builder.startObject(1);
  }
  static addKeysSorted(builder, keysSorted) {
    builder.addFieldInt8(0, +keysSorted, 0);
  }
  static endMap(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createMap(builder, keysSorted) {
    Map2.startMap(builder);
    Map2.addKeysSorted(builder, keysSorted);
    return Map2.endMap(builder);
  }
}

// node_modules/apache-arrow/fb/null.mjs
class Null {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsNull(bb, obj) {
    return (obj || new Null).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsNull(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Null).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static startNull(builder) {
    builder.startObject(0);
  }
  static endNull(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createNull(builder) {
    Null.startNull(builder);
    return Null.endNull(builder);
  }
}

// node_modules/apache-arrow/fb/struct-.mjs
class Struct_ {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsStruct_(bb, obj) {
    return (obj || new Struct_).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsStruct_(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Struct_).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static startStruct_(builder) {
    builder.startObject(0);
  }
  static endStruct_(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createStruct_(builder) {
    Struct_.startStruct_(builder);
    return Struct_.endStruct_(builder);
  }
}

// node_modules/apache-arrow/fb/time.mjs
class Time {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsTime(bb, obj) {
    return (obj || new Time).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsTime(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Time).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  unit() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit.MILLISECOND;
  }
  bitWidth() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readInt32(this.bb_pos + offset) : 32;
  }
  static startTime(builder) {
    builder.startObject(2);
  }
  static addUnit(builder, unit) {
    builder.addFieldInt16(0, unit, TimeUnit.MILLISECOND);
  }
  static addBitWidth(builder, bitWidth) {
    builder.addFieldInt32(1, bitWidth, 32);
  }
  static endTime(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createTime(builder, unit, bitWidth) {
    Time.startTime(builder);
    Time.addUnit(builder, unit);
    Time.addBitWidth(builder, bitWidth);
    return Time.endTime(builder);
  }
}

// node_modules/apache-arrow/fb/timestamp.mjs
class Timestamp {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsTimestamp(bb, obj) {
    return (obj || new Timestamp).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsTimestamp(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Timestamp).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  unit() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit.SECOND;
  }
  timezone(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  static startTimestamp(builder) {
    builder.startObject(2);
  }
  static addUnit(builder, unit) {
    builder.addFieldInt16(0, unit, TimeUnit.SECOND);
  }
  static addTimezone(builder, timezoneOffset) {
    builder.addFieldOffset(1, timezoneOffset, 0);
  }
  static endTimestamp(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createTimestamp(builder, unit, timezoneOffset) {
    Timestamp.startTimestamp(builder);
    Timestamp.addUnit(builder, unit);
    Timestamp.addTimezone(builder, timezoneOffset);
    return Timestamp.endTimestamp(builder);
  }
}

// node_modules/apache-arrow/fb/union.mjs
class Union3 {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsUnion(bb, obj) {
    return (obj || new Union3).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsUnion(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Union3).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  mode() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readInt16(this.bb_pos + offset) : UnionMode.Sparse;
  }
  typeIds(index) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  typeIdsLength() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  typeIdsArray() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  static startUnion(builder) {
    builder.startObject(2);
  }
  static addMode(builder, mode) {
    builder.addFieldInt16(0, mode, UnionMode.Sparse);
  }
  static addTypeIds(builder, typeIdsOffset) {
    builder.addFieldOffset(1, typeIdsOffset, 0);
  }
  static createTypeIdsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1;i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startTypeIdsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endUnion(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createUnion(builder, mode, typeIdsOffset) {
    Union3.startUnion(builder);
    Union3.addMode(builder, mode);
    Union3.addTypeIds(builder, typeIdsOffset);
    return Union3.endUnion(builder);
  }
}

// node_modules/apache-arrow/fb/utf8.mjs
class Utf8 {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsUtf8(bb, obj) {
    return (obj || new Utf8).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsUtf8(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Utf8).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static startUtf8(builder) {
    builder.startObject(0);
  }
  static endUtf8(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createUtf8(builder) {
    Utf8.startUtf8(builder);
    return Utf8.endUtf8(builder);
  }
}

// node_modules/apache-arrow/fb/type.mjs
var Type3;
(function(Type4) {
  Type4[Type4["NONE"] = 0] = "NONE";
  Type4[Type4["Null"] = 1] = "Null";
  Type4[Type4["Int"] = 2] = "Int";
  Type4[Type4["FloatingPoint"] = 3] = "FloatingPoint";
  Type4[Type4["Binary"] = 4] = "Binary";
  Type4[Type4["Utf8"] = 5] = "Utf8";
  Type4[Type4["Bool"] = 6] = "Bool";
  Type4[Type4["Decimal"] = 7] = "Decimal";
  Type4[Type4["Date"] = 8] = "Date";
  Type4[Type4["Time"] = 9] = "Time";
  Type4[Type4["Timestamp"] = 10] = "Timestamp";
  Type4[Type4["Interval"] = 11] = "Interval";
  Type4[Type4["List"] = 12] = "List";
  Type4[Type4["Struct_"] = 13] = "Struct_";
  Type4[Type4["Union"] = 14] = "Union";
  Type4[Type4["FixedSizeBinary"] = 15] = "FixedSizeBinary";
  Type4[Type4["FixedSizeList"] = 16] = "FixedSizeList";
  Type4[Type4["Map"] = 17] = "Map";
  Type4[Type4["Duration"] = 18] = "Duration";
  Type4[Type4["LargeBinary"] = 19] = "LargeBinary";
  Type4[Type4["LargeUtf8"] = 20] = "LargeUtf8";
  Type4[Type4["LargeList"] = 21] = "LargeList";
  Type4[Type4["RunEndEncoded"] = 22] = "RunEndEncoded";
})(Type3 || (Type3 = {}));

// node_modules/apache-arrow/fb/field.mjs
class Field {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsField(bb, obj) {
    return (obj || new Field).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsField(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Field).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  name(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  nullable() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
  }
  typeType() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readUint8(this.bb_pos + offset) : Type3.NONE;
  }
  type(obj) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
  }
  dictionary(obj) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? (obj || new DictionaryEncoding).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
  }
  children(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? (obj || new Field).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
  }
  childrenLength() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  customMetadata(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? (obj || new KeyValue).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
  }
  customMetadataLength() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startField(builder) {
    builder.startObject(7);
  }
  static addName(builder, nameOffset) {
    builder.addFieldOffset(0, nameOffset, 0);
  }
  static addNullable(builder, nullable) {
    builder.addFieldInt8(1, +nullable, 0);
  }
  static addTypeType(builder, typeType) {
    builder.addFieldInt8(2, typeType, Type3.NONE);
  }
  static addType(builder, typeOffset) {
    builder.addFieldOffset(3, typeOffset, 0);
  }
  static addDictionary(builder, dictionaryOffset) {
    builder.addFieldOffset(4, dictionaryOffset, 0);
  }
  static addChildren(builder, childrenOffset) {
    builder.addFieldOffset(5, childrenOffset, 0);
  }
  static createChildrenVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1;i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startChildrenVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addCustomMetadata(builder, customMetadataOffset) {
    builder.addFieldOffset(6, customMetadataOffset, 0);
  }
  static createCustomMetadataVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1;i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startCustomMetadataVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endField(builder) {
    const offset = builder.endObject();
    return offset;
  }
}

// node_modules/apache-arrow/fb/schema.mjs
class Schema2 {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsSchema(bb, obj) {
    return (obj || new Schema2).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsSchema(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Schema2).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  endianness() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readInt16(this.bb_pos + offset) : Endianness.Little;
  }
  fields(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? (obj || new Field).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
  }
  fieldsLength() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  customMetadata(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? (obj || new KeyValue).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
  }
  customMetadataLength() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  features(index) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
  }
  featuresLength() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startSchema(builder) {
    builder.startObject(4);
  }
  static addEndianness(builder, endianness) {
    builder.addFieldInt16(0, endianness, Endianness.Little);
  }
  static addFields(builder, fieldsOffset) {
    builder.addFieldOffset(1, fieldsOffset, 0);
  }
  static createFieldsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1;i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startFieldsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addCustomMetadata(builder, customMetadataOffset) {
    builder.addFieldOffset(2, customMetadataOffset, 0);
  }
  static createCustomMetadataVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1;i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startCustomMetadataVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addFeatures(builder, featuresOffset) {
    builder.addFieldOffset(3, featuresOffset, 0);
  }
  static createFeaturesVector(builder, data) {
    builder.startVector(8, data.length, 8);
    for (let i = data.length - 1;i >= 0; i--) {
      builder.addInt64(data[i]);
    }
    return builder.endVector();
  }
  static startFeaturesVector(builder, numElems) {
    builder.startVector(8, numElems, 8);
  }
  static endSchema(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishSchemaBuffer(builder, offset) {
    builder.finish(offset);
  }
  static finishSizePrefixedSchemaBuffer(builder, offset) {
    builder.finish(offset, undefined, true);
  }
  static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {
    Schema2.startSchema(builder);
    Schema2.addEndianness(builder, endianness);
    Schema2.addFields(builder, fieldsOffset);
    Schema2.addCustomMetadata(builder, customMetadataOffset);
    Schema2.addFeatures(builder, featuresOffset);
    return Schema2.endSchema(builder);
  }
}

// node_modules/apache-arrow/fb/message-header.mjs
var MessageHeader;
(function(MessageHeader2) {
  MessageHeader2[MessageHeader2["NONE"] = 0] = "NONE";
  MessageHeader2[MessageHeader2["Schema"] = 1] = "Schema";
  MessageHeader2[MessageHeader2["DictionaryBatch"] = 2] = "DictionaryBatch";
  MessageHeader2[MessageHeader2["RecordBatch"] = 3] = "RecordBatch";
  MessageHeader2[MessageHeader2["Tensor"] = 4] = "Tensor";
  MessageHeader2[MessageHeader2["SparseTensor"] = 5] = "SparseTensor";
})(MessageHeader || (MessageHeader = {}));

// node_modules/apache-arrow/enum.mjs
var Type4;
(function(Type5) {
  Type5[Type5["NONE"] = 0] = "NONE";
  Type5[Type5["Null"] = 1] = "Null";
  Type5[Type5["Int"] = 2] = "Int";
  Type5[Type5["Float"] = 3] = "Float";
  Type5[Type5["Binary"] = 4] = "Binary";
  Type5[Type5["Utf8"] = 5] = "Utf8";
  Type5[Type5["Bool"] = 6] = "Bool";
  Type5[Type5["Decimal"] = 7] = "Decimal";
  Type5[Type5["Date"] = 8] = "Date";
  Type5[Type5["Time"] = 9] = "Time";
  Type5[Type5["Timestamp"] = 10] = "Timestamp";
  Type5[Type5["Interval"] = 11] = "Interval";
  Type5[Type5["List"] = 12] = "List";
  Type5[Type5["Struct"] = 13] = "Struct";
  Type5[Type5["Union"] = 14] = "Union";
  Type5[Type5["FixedSizeBinary"] = 15] = "FixedSizeBinary";
  Type5[Type5["FixedSizeList"] = 16] = "FixedSizeList";
  Type5[Type5["Map"] = 17] = "Map";
  Type5[Type5["Duration"] = 18] = "Duration";
  Type5[Type5["LargeBinary"] = 19] = "LargeBinary";
  Type5[Type5["LargeUtf8"] = 20] = "LargeUtf8";
  Type5[Type5["Dictionary"] = -1] = "Dictionary";
  Type5[Type5["Int8"] = -2] = "Int8";
  Type5[Type5["Int16"] = -3] = "Int16";
  Type5[Type5["Int32"] = -4] = "Int32";
  Type5[Type5["Int64"] = -5] = "Int64";
  Type5[Type5["Uint8"] = -6] = "Uint8";
  Type5[Type5["Uint16"] = -7] = "Uint16";
  Type5[Type5["Uint32"] = -8] = "Uint32";
  Type5[Type5["Uint64"] = -9] = "Uint64";
  Type5[Type5["Float16"] = -10] = "Float16";
  Type5[Type5["Float32"] = -11] = "Float32";
  Type5[Type5["Float64"] = -12] = "Float64";
  Type5[Type5["DateDay"] = -13] = "DateDay";
  Type5[Type5["DateMillisecond"] = -14] = "DateMillisecond";
  Type5[Type5["TimestampSecond"] = -15] = "TimestampSecond";
  Type5[Type5["TimestampMillisecond"] = -16] = "TimestampMillisecond";
  Type5[Type5["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
  Type5[Type5["TimestampNanosecond"] = -18] = "TimestampNanosecond";
  Type5[Type5["TimeSecond"] = -19] = "TimeSecond";
  Type5[Type5["TimeMillisecond"] = -20] = "TimeMillisecond";
  Type5[Type5["TimeMicrosecond"] = -21] = "TimeMicrosecond";
  Type5[Type5["TimeNanosecond"] = -22] = "TimeNanosecond";
  Type5[Type5["DenseUnion"] = -23] = "DenseUnion";
  Type5[Type5["SparseUnion"] = -24] = "SparseUnion";
  Type5[Type5["IntervalDayTime"] = -25] = "IntervalDayTime";
  Type5[Type5["IntervalYearMonth"] = -26] = "IntervalYearMonth";
  Type5[Type5["DurationSecond"] = -27] = "DurationSecond";
  Type5[Type5["DurationMillisecond"] = -28] = "DurationMillisecond";
  Type5[Type5["DurationMicrosecond"] = -29] = "DurationMicrosecond";
  Type5[Type5["DurationNanosecond"] = -30] = "DurationNanosecond";
  Type5[Type5["IntervalMonthDayNano"] = -31] = "IntervalMonthDayNano";
})(Type4 || (Type4 = {}));
var BufferType;
(function(BufferType2) {
  BufferType2[BufferType2["OFFSET"] = 0] = "OFFSET";
  BufferType2[BufferType2["DATA"] = 1] = "DATA";
  BufferType2[BufferType2["VALIDITY"] = 2] = "VALIDITY";
  BufferType2[BufferType2["TYPE"] = 3] = "TYPE";
})(BufferType || (BufferType = {}));

// node_modules/apache-arrow/util/vector.mjs
var exports_vector = {};
__export(exports_vector, {
  wrapIndex: () => wrapIndex,
  createElementComparator: () => createElementComparator,
  clampRange: () => clampRange
});

// node_modules/apache-arrow/util/pretty.mjs
var exports_pretty = {};
__export(exports_pretty, {
  valueToString: () => valueToString
});
var undf = undefined;
function valueToString(x) {
  if (x === null) {
    return "null";
  }
  if (x === undf) {
    return "undefined";
  }
  switch (typeof x) {
    case "number":
      return `${x}`;
    case "bigint":
      return `${x}`;
    case "string":
      return `"${x}"`;
  }
  if (typeof x[Symbol.toPrimitive] === "function") {
    return x[Symbol.toPrimitive]("string");
  }
  if (ArrayBuffer.isView(x)) {
    if (x instanceof BigInt64Array || x instanceof BigUint64Array) {
      return `[${[...x].map((x2) => valueToString(x2))}]`;
    }
    return `[${x}]`;
  }
  return ArrayBuffer.isView(x) ? `[${x}]` : JSON.stringify(x, (_, y) => typeof y === "bigint" ? `${y}` : y);
}

// node_modules/apache-arrow/util/bn.mjs
var exports_bn = {};
__export(exports_bn, {
  isArrowBigNumSymbol: () => isArrowBigNumSymbol,
  bigNumToString: () => bigNumToString,
  bigNumToNumber: () => bigNumToNumber,
  bigNumToBigInt: () => bigNumToBigInt,
  BN: () => BN
});

// node_modules/apache-arrow/util/bigint.mjs
function bigIntToNumber(number4) {
  if (typeof number4 === "bigint" && (number4 < Number.MIN_SAFE_INTEGER || number4 > Number.MAX_SAFE_INTEGER)) {
    throw new TypeError(`${number4} is not safe to convert to a number.`);
  }
  return Number(number4);
}
function divideBigInts(number4, divisor) {
  return bigIntToNumber(number4 / divisor) + bigIntToNumber(number4 % divisor) / bigIntToNumber(divisor);
}

// node_modules/apache-arrow/util/bn.mjs
var isArrowBigNumSymbol = Symbol.for("isArrowBigNum");
function BigNum(x, ...xs) {
  if (xs.length === 0) {
    return Object.setPrototypeOf(toArrayBufferView(this["TypedArray"], x), this.constructor.prototype);
  }
  return Object.setPrototypeOf(new this["TypedArray"](x, ...xs), this.constructor.prototype);
}
BigNum.prototype[isArrowBigNumSymbol] = true;
BigNum.prototype.toJSON = function() {
  return `"${bigNumToString(this)}"`;
};
BigNum.prototype.valueOf = function(scale) {
  return bigNumToNumber(this, scale);
};
BigNum.prototype.toString = function() {
  return bigNumToString(this);
};
BigNum.prototype[Symbol.toPrimitive] = function(hint = "default") {
  switch (hint) {
    case "number":
      return bigNumToNumber(this);
    case "string":
      return bigNumToString(this);
    case "default":
      return bigNumToBigInt(this);
  }
  return bigNumToString(this);
};
function SignedBigNum(...args2) {
  return BigNum.apply(this, args2);
}
function UnsignedBigNum(...args2) {
  return BigNum.apply(this, args2);
}
function DecimalBigNum(...args2) {
  return BigNum.apply(this, args2);
}
Object.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));
Object.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));
Object.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));
Object.assign(SignedBigNum.prototype, BigNum.prototype, { constructor: SignedBigNum, signed: true, TypedArray: Int32Array, BigIntArray: BigInt64Array });
Object.assign(UnsignedBigNum.prototype, BigNum.prototype, { constructor: UnsignedBigNum, signed: false, TypedArray: Uint32Array, BigIntArray: BigUint64Array });
Object.assign(DecimalBigNum.prototype, BigNum.prototype, { constructor: DecimalBigNum, signed: true, TypedArray: Uint32Array, BigIntArray: BigUint64Array });
var TWO_TO_THE_64 = BigInt(4294967296) * BigInt(4294967296);
var TWO_TO_THE_64_MINUS_1 = TWO_TO_THE_64 - BigInt(1);
function bigNumToNumber(bn, scale) {
  const { buffer: buffer3, byteOffset, byteLength, signed } = bn;
  const words = new BigUint64Array(buffer3, byteOffset, byteLength / 8);
  const negative = signed && words.at(-1) & BigInt(1) << BigInt(63);
  let number4 = BigInt(0);
  let i = 0;
  if (negative) {
    for (const word of words) {
      number4 |= (word ^ TWO_TO_THE_64_MINUS_1) * (BigInt(1) << BigInt(64 * i++));
    }
    number4 *= BigInt(-1);
    number4 -= BigInt(1);
  } else {
    for (const word of words) {
      number4 |= word * (BigInt(1) << BigInt(64 * i++));
    }
  }
  if (typeof scale === "number" && scale > 0) {
    const denominator = BigInt("1".padEnd(scale + 1, "0"));
    const quotient = number4 / denominator;
    const remainder = negative ? -(number4 % denominator) : number4 % denominator;
    const integerPart = bigIntToNumber(quotient);
    const fractionPart = `${remainder}`.padStart(scale, "0");
    const sign = negative && integerPart === 0 ? "-" : "";
    return +`${sign}${integerPart}.${fractionPart}`;
  }
  return bigIntToNumber(number4);
}
function bigNumToString(a) {
  if (a.byteLength === 8) {
    const bigIntArray = new a["BigIntArray"](a.buffer, a.byteOffset, 1);
    return `${bigIntArray[0]}`;
  }
  if (!a["signed"]) {
    return unsignedBigNumToString(a);
  }
  let array4 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
  const highOrderWord = new Int16Array([array4.at(-1)])[0];
  if (highOrderWord >= 0) {
    return unsignedBigNumToString(a);
  }
  array4 = array4.slice();
  let carry = 1;
  for (let i = 0;i < array4.length; i++) {
    const elem = array4[i];
    const updated = ~elem + carry;
    array4[i] = updated;
    carry &= elem === 0 ? 1 : 0;
  }
  const negated = unsignedBigNumToString(array4);
  return `-${negated}`;
}
function bigNumToBigInt(a) {
  if (a.byteLength === 8) {
    const bigIntArray = new a["BigIntArray"](a.buffer, a.byteOffset, 1);
    return bigIntArray[0];
  } else {
    return bigNumToString(a);
  }
}
function unsignedBigNumToString(a) {
  let digits = "";
  const base64 = new Uint32Array(2);
  let base32 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
  const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);
  let i = -1;
  const n = base32.length - 1;
  do {
    for (base64[0] = base32[i = 0];i < n; ) {
      base32[i++] = base64[1] = base64[0] / 10;
      base64[0] = (base64[0] - base64[1] * 10 << 16) + base32[i];
    }
    base32[i] = base64[1] = base64[0] / 10;
    base64[0] = base64[0] - base64[1] * 10;
    digits = `${base64[0]}${digits}`;
  } while (checks[0] || checks[1] || checks[2] || checks[3]);
  return digits !== null && digits !== undefined ? digits : `0`;
}

class BN {
  static new(num, isSigned) {
    switch (isSigned) {
      case true:
        return new SignedBigNum(num);
      case false:
        return new UnsignedBigNum(num);
    }
    switch (num.constructor) {
      case Int8Array:
      case Int16Array:
      case Int32Array:
      case BigInt64Array:
        return new SignedBigNum(num);
    }
    if (num.byteLength === 16) {
      return new DecimalBigNum(num);
    }
    return new UnsignedBigNum(num);
  }
  static signed(num) {
    return new SignedBigNum(num);
  }
  static unsigned(num) {
    return new UnsignedBigNum(num);
  }
  static decimal(num) {
    return new DecimalBigNum(num);
  }
  constructor(num, isSigned) {
    return BN.new(num, isSigned);
  }
}

// node_modules/apache-arrow/type.mjs
var _a;
var _b;
var _c;
var _d;
var _e;
var _f;
var _g;
var _h;
var _j;
var _k;
var _l;
var _m;
var _o;
var _p;
var _q;
var _r;
var _s;
var _t;
var _u;
var _v;
var _w;
var _x;

class DataType {
  static isNull(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.Null;
  }
  static isInt(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.Int;
  }
  static isFloat(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.Float;
  }
  static isBinary(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.Binary;
  }
  static isLargeBinary(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.LargeBinary;
  }
  static isUtf8(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.Utf8;
  }
  static isLargeUtf8(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.LargeUtf8;
  }
  static isBool(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.Bool;
  }
  static isDecimal(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.Decimal;
  }
  static isDate(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.Date;
  }
  static isTime(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.Time;
  }
  static isTimestamp(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.Timestamp;
  }
  static isInterval(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.Interval;
  }
  static isDuration(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.Duration;
  }
  static isList(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.List;
  }
  static isStruct(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.Struct;
  }
  static isUnion(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.Union;
  }
  static isFixedSizeBinary(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.FixedSizeBinary;
  }
  static isFixedSizeList(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.FixedSizeList;
  }
  static isMap(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.Map;
  }
  static isDictionary(x) {
    return (x === null || x === undefined ? undefined : x.typeId) === Type4.Dictionary;
  }
  static isDenseUnion(x) {
    return DataType.isUnion(x) && x.mode === UnionMode.Dense;
  }
  static isSparseUnion(x) {
    return DataType.isUnion(x) && x.mode === UnionMode.Sparse;
  }
  constructor(typeId) {
    this.typeId = typeId;
  }
}
_a = Symbol.toStringTag;
DataType[_a] = ((proto12) => {
  proto12.children = null;
  proto12.ArrayType = Array;
  proto12.OffsetArrayType = Int32Array;
  return proto12[Symbol.toStringTag] = "DataType";
})(DataType.prototype);

class Null2 extends DataType {
  constructor() {
    super(Type4.Null);
  }
  toString() {
    return `Null`;
  }
}
_b = Symbol.toStringTag;
Null2[_b] = ((proto12) => proto12[Symbol.toStringTag] = "Null")(Null2.prototype);

class Int_ extends DataType {
  constructor(isSigned, bitWidth) {
    super(Type4.Int);
    this.isSigned = isSigned;
    this.bitWidth = bitWidth;
  }
  get ArrayType() {
    switch (this.bitWidth) {
      case 8:
        return this.isSigned ? Int8Array : Uint8Array;
      case 16:
        return this.isSigned ? Int16Array : Uint16Array;
      case 32:
        return this.isSigned ? Int32Array : Uint32Array;
      case 64:
        return this.isSigned ? BigInt64Array : BigUint64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
  toString() {
    return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`;
  }
}
_c = Symbol.toStringTag;
Int_[_c] = ((proto12) => {
  proto12.isSigned = null;
  proto12.bitWidth = null;
  return proto12[Symbol.toStringTag] = "Int";
})(Int_.prototype);
class Int8 extends Int_ {
  constructor() {
    super(true, 8);
  }
  get ArrayType() {
    return Int8Array;
  }
}

class Int16 extends Int_ {
  constructor() {
    super(true, 16);
  }
  get ArrayType() {
    return Int16Array;
  }
}

class Int32 extends Int_ {
  constructor() {
    super(true, 32);
  }
  get ArrayType() {
    return Int32Array;
  }
}

class Int64 extends Int_ {
  constructor() {
    super(true, 64);
  }
  get ArrayType() {
    return BigInt64Array;
  }
}

class Uint8 extends Int_ {
  constructor() {
    super(false, 8);
  }
  get ArrayType() {
    return Uint8Array;
  }
}

class Uint16 extends Int_ {
  constructor() {
    super(false, 16);
  }
  get ArrayType() {
    return Uint16Array;
  }
}

class Uint32 extends Int_ {
  constructor() {
    super(false, 32);
  }
  get ArrayType() {
    return Uint32Array;
  }
}

class Uint64 extends Int_ {
  constructor() {
    super(false, 64);
  }
  get ArrayType() {
    return BigUint64Array;
  }
}
Object.defineProperty(Int8.prototype, "ArrayType", { value: Int8Array });
Object.defineProperty(Int16.prototype, "ArrayType", { value: Int16Array });
Object.defineProperty(Int32.prototype, "ArrayType", { value: Int32Array });
Object.defineProperty(Int64.prototype, "ArrayType", { value: BigInt64Array });
Object.defineProperty(Uint8.prototype, "ArrayType", { value: Uint8Array });
Object.defineProperty(Uint16.prototype, "ArrayType", { value: Uint16Array });
Object.defineProperty(Uint32.prototype, "ArrayType", { value: Uint32Array });
Object.defineProperty(Uint64.prototype, "ArrayType", { value: BigUint64Array });

class Float extends DataType {
  constructor(precision) {
    super(Type4.Float);
    this.precision = precision;
  }
  get ArrayType() {
    switch (this.precision) {
      case Precision.HALF:
        return Uint16Array;
      case Precision.SINGLE:
        return Float32Array;
      case Precision.DOUBLE:
        return Float64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
  toString() {
    return `Float${this.precision << 5 || 16}`;
  }
}
_d = Symbol.toStringTag;
Float[_d] = ((proto12) => {
  proto12.precision = null;
  return proto12[Symbol.toStringTag] = "Float";
})(Float.prototype);

class Float16 extends Float {
  constructor() {
    super(Precision.HALF);
  }
}

class Float32 extends Float {
  constructor() {
    super(Precision.SINGLE);
  }
}

class Float64 extends Float {
  constructor() {
    super(Precision.DOUBLE);
  }
}
Object.defineProperty(Float16.prototype, "ArrayType", { value: Uint16Array });
Object.defineProperty(Float32.prototype, "ArrayType", { value: Float32Array });
Object.defineProperty(Float64.prototype, "ArrayType", { value: Float64Array });

class Binary2 extends DataType {
  constructor() {
    super(Type4.Binary);
  }
  toString() {
    return `Binary`;
  }
}
_e = Symbol.toStringTag;
Binary2[_e] = ((proto12) => {
  proto12.ArrayType = Uint8Array;
  return proto12[Symbol.toStringTag] = "Binary";
})(Binary2.prototype);

class LargeBinary2 extends DataType {
  constructor() {
    super(Type4.LargeBinary);
  }
  toString() {
    return `LargeBinary`;
  }
}
_f = Symbol.toStringTag;
LargeBinary2[_f] = ((proto12) => {
  proto12.ArrayType = Uint8Array;
  proto12.OffsetArrayType = BigInt64Array;
  return proto12[Symbol.toStringTag] = "LargeBinary";
})(LargeBinary2.prototype);

class Utf82 extends DataType {
  constructor() {
    super(Type4.Utf8);
  }
  toString() {
    return `Utf8`;
  }
}
_g = Symbol.toStringTag;
Utf82[_g] = ((proto12) => {
  proto12.ArrayType = Uint8Array;
  return proto12[Symbol.toStringTag] = "Utf8";
})(Utf82.prototype);

class LargeUtf82 extends DataType {
  constructor() {
    super(Type4.LargeUtf8);
  }
  toString() {
    return `LargeUtf8`;
  }
}
_h = Symbol.toStringTag;
LargeUtf82[_h] = ((proto12) => {
  proto12.ArrayType = Uint8Array;
  proto12.OffsetArrayType = BigInt64Array;
  return proto12[Symbol.toStringTag] = "LargeUtf8";
})(LargeUtf82.prototype);

class Bool2 extends DataType {
  constructor() {
    super(Type4.Bool);
  }
  toString() {
    return `Bool`;
  }
}
_j = Symbol.toStringTag;
Bool2[_j] = ((proto12) => {
  proto12.ArrayType = Uint8Array;
  return proto12[Symbol.toStringTag] = "Bool";
})(Bool2.prototype);

class Decimal2 extends DataType {
  constructor(scale, precision, bitWidth = 128) {
    super(Type4.Decimal);
    this.scale = scale;
    this.precision = precision;
    this.bitWidth = bitWidth;
  }
  toString() {
    return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`;
  }
}
_k = Symbol.toStringTag;
Decimal2[_k] = ((proto12) => {
  proto12.scale = null;
  proto12.precision = null;
  proto12.ArrayType = Uint32Array;
  return proto12[Symbol.toStringTag] = "Decimal";
})(Decimal2.prototype);

class Date_ extends DataType {
  constructor(unit) {
    super(Type4.Date);
    this.unit = unit;
  }
  toString() {
    return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;
  }
  get ArrayType() {
    return this.unit === DateUnit.DAY ? Int32Array : BigInt64Array;
  }
}
_l = Symbol.toStringTag;
Date_[_l] = ((proto12) => {
  proto12.unit = null;
  return proto12[Symbol.toStringTag] = "Date";
})(Date_.prototype);
class Time_ extends DataType {
  constructor(unit, bitWidth) {
    super(Type4.Time);
    this.unit = unit;
    this.bitWidth = bitWidth;
  }
  toString() {
    return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;
  }
  get ArrayType() {
    switch (this.bitWidth) {
      case 32:
        return Int32Array;
      case 64:
        return BigInt64Array;
    }
    throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
  }
}
_m = Symbol.toStringTag;
Time_[_m] = ((proto12) => {
  proto12.unit = null;
  proto12.bitWidth = null;
  return proto12[Symbol.toStringTag] = "Time";
})(Time_.prototype);
class Timestamp_ extends DataType {
  constructor(unit, timezone) {
    super(Type4.Timestamp);
    this.unit = unit;
    this.timezone = timezone;
  }
  toString() {
    return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;
  }
}
_o = Symbol.toStringTag;
Timestamp_[_o] = ((proto12) => {
  proto12.unit = null;
  proto12.timezone = null;
  proto12.ArrayType = BigInt64Array;
  return proto12[Symbol.toStringTag] = "Timestamp";
})(Timestamp_.prototype);
class Interval_ extends DataType {
  constructor(unit) {
    super(Type4.Interval);
    this.unit = unit;
  }
  toString() {
    return `Interval<${IntervalUnit[this.unit]}>`;
  }
}
_p = Symbol.toStringTag;
Interval_[_p] = ((proto12) => {
  proto12.unit = null;
  proto12.ArrayType = Int32Array;
  return proto12[Symbol.toStringTag] = "Interval";
})(Interval_.prototype);
class Duration2 extends DataType {
  constructor(unit) {
    super(Type4.Duration);
    this.unit = unit;
  }
  toString() {
    return `Duration<${TimeUnit[this.unit]}>`;
  }
}
_q = Symbol.toStringTag;
Duration2[_q] = ((proto12) => {
  proto12.unit = null;
  proto12.ArrayType = BigInt64Array;
  return proto12[Symbol.toStringTag] = "Duration";
})(Duration2.prototype);
class List2 extends DataType {
  constructor(child) {
    super(Type4.List);
    this.children = [child];
  }
  toString() {
    return `List<${this.valueType}>`;
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get ArrayType() {
    return this.valueType.ArrayType;
  }
}
_r = Symbol.toStringTag;
List2[_r] = ((proto12) => {
  proto12.children = null;
  return proto12[Symbol.toStringTag] = "List";
})(List2.prototype);

class Struct2 extends DataType {
  constructor(children2) {
    super(Type4.Struct);
    this.children = children2;
  }
  toString() {
    return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
  }
}
_s = Symbol.toStringTag;
Struct2[_s] = ((proto12) => {
  proto12.children = null;
  return proto12[Symbol.toStringTag] = "Struct";
})(Struct2.prototype);

class Union_ extends DataType {
  constructor(mode, typeIds, children2) {
    super(Type4.Union);
    this.mode = mode;
    this.children = children2;
    this.typeIds = typeIds = Int32Array.from(typeIds);
    this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, Object.create(null));
  }
  toString() {
    return `${this[Symbol.toStringTag]}<${this.children.map((x) => `${x.type}`).join(` | `)}>`;
  }
}
_t = Symbol.toStringTag;
Union_[_t] = ((proto12) => {
  proto12.mode = null;
  proto12.typeIds = null;
  proto12.children = null;
  proto12.typeIdToChildIndex = null;
  proto12.ArrayType = Int8Array;
  return proto12[Symbol.toStringTag] = "Union";
})(Union_.prototype);
class FixedSizeBinary2 extends DataType {
  constructor(byteWidth) {
    super(Type4.FixedSizeBinary);
    this.byteWidth = byteWidth;
  }
  toString() {
    return `FixedSizeBinary[${this.byteWidth}]`;
  }
}
_u = Symbol.toStringTag;
FixedSizeBinary2[_u] = ((proto12) => {
  proto12.byteWidth = null;
  proto12.ArrayType = Uint8Array;
  return proto12[Symbol.toStringTag] = "FixedSizeBinary";
})(FixedSizeBinary2.prototype);

class FixedSizeList2 extends DataType {
  constructor(listSize, child) {
    super(Type4.FixedSizeList);
    this.listSize = listSize;
    this.children = [child];
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get ArrayType() {
    return this.valueType.ArrayType;
  }
  toString() {
    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
  }
}
_v = Symbol.toStringTag;
FixedSizeList2[_v] = ((proto12) => {
  proto12.children = null;
  proto12.listSize = null;
  return proto12[Symbol.toStringTag] = "FixedSizeList";
})(FixedSizeList2.prototype);

class Map_ extends DataType {
  constructor(entries2, keysSorted = false) {
    var _y, _z, _0;
    super(Type4.Map);
    this.children = [entries2];
    this.keysSorted = keysSorted;
    if (entries2) {
      entries2["name"] = "entries";
      if ((_y = entries2 === null || entries2 === undefined ? undefined : entries2.type) === null || _y === undefined ? undefined : _y.children) {
        const key = (_z = entries2 === null || entries2 === undefined ? undefined : entries2.type) === null || _z === undefined ? undefined : _z.children[0];
        if (key) {
          key["name"] = "key";
        }
        const val = (_0 = entries2 === null || entries2 === undefined ? undefined : entries2.type) === null || _0 === undefined ? undefined : _0.children[1];
        if (val) {
          val["name"] = "value";
        }
      }
    }
  }
  get keyType() {
    return this.children[0].type.children[0].type;
  }
  get valueType() {
    return this.children[0].type.children[1].type;
  }
  get childType() {
    return this.children[0].type;
  }
  toString() {
    return `Map<{${this.children[0].type.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
  }
}
_w = Symbol.toStringTag;
Map_[_w] = ((proto12) => {
  proto12.children = null;
  proto12.keysSorted = null;
  return proto12[Symbol.toStringTag] = "Map_";
})(Map_.prototype);
var getId = ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);

class Dictionary extends DataType {
  constructor(dictionary, indices, id2, isOrdered) {
    super(Type4.Dictionary);
    this.indices = indices;
    this.dictionary = dictionary;
    this.isOrdered = isOrdered || false;
    this.id = id2 == null ? getId() : bigIntToNumber(id2);
  }
  get children() {
    return this.dictionary.children;
  }
  get valueType() {
    return this.dictionary;
  }
  get ArrayType() {
    return this.dictionary.ArrayType;
  }
  toString() {
    return `Dictionary<${this.indices}, ${this.dictionary}>`;
  }
}
_x = Symbol.toStringTag;
Dictionary[_x] = ((proto12) => {
  proto12.id = null;
  proto12.indices = null;
  proto12.isOrdered = null;
  proto12.dictionary = null;
  return proto12[Symbol.toStringTag] = "Dictionary";
})(Dictionary.prototype);
function strideForType(type) {
  const t = type;
  switch (type.typeId) {
    case Type4.Decimal:
      return type.bitWidth / 32;
    case Type4.Interval: {
      if (t.unit === IntervalUnit.MONTH_DAY_NANO) {
        return 4;
      }
      return 1 + t.unit;
    }
    case Type4.FixedSizeList:
      return t.listSize;
    case Type4.FixedSizeBinary:
      return t.byteWidth;
    default:
      return 1;
  }
}

// node_modules/apache-arrow/visitor.mjs
class Visitor {
  visitMany(nodes, ...args2) {
    return nodes.map((node, i) => this.visit(node, ...args2.map((x) => x[i])));
  }
  visit(...args2) {
    return this.getVisitFn(args2[0], false).apply(this, args2);
  }
  getVisitFn(node, throwIfNotFound = true) {
    return getVisitFn(this, node, throwIfNotFound);
  }
  getVisitFnByTypeId(typeId, throwIfNotFound = true) {
    return getVisitFnByTypeId(this, typeId, throwIfNotFound);
  }
  visitNull(_node, ..._args) {
    return null;
  }
  visitBool(_node, ..._args) {
    return null;
  }
  visitInt(_node, ..._args) {
    return null;
  }
  visitFloat(_node, ..._args) {
    return null;
  }
  visitUtf8(_node, ..._args) {
    return null;
  }
  visitLargeUtf8(_node, ..._args) {
    return null;
  }
  visitBinary(_node, ..._args) {
    return null;
  }
  visitLargeBinary(_node, ..._args) {
    return null;
  }
  visitFixedSizeBinary(_node, ..._args) {
    return null;
  }
  visitDate(_node, ..._args) {
    return null;
  }
  visitTimestamp(_node, ..._args) {
    return null;
  }
  visitTime(_node, ..._args) {
    return null;
  }
  visitDecimal(_node, ..._args) {
    return null;
  }
  visitList(_node, ..._args) {
    return null;
  }
  visitStruct(_node, ..._args) {
    return null;
  }
  visitUnion(_node, ..._args) {
    return null;
  }
  visitDictionary(_node, ..._args) {
    return null;
  }
  visitInterval(_node, ..._args) {
    return null;
  }
  visitDuration(_node, ..._args) {
    return null;
  }
  visitFixedSizeList(_node, ..._args) {
    return null;
  }
  visitMap(_node, ..._args) {
    return null;
  }
}
function getVisitFn(visitor, node, throwIfNotFound = true) {
  if (typeof node === "number") {
    return getVisitFnByTypeId(visitor, node, throwIfNotFound);
  }
  if (typeof node === "string" && node in Type4) {
    return getVisitFnByTypeId(visitor, Type4[node], throwIfNotFound);
  }
  if (node && node instanceof DataType) {
    return getVisitFnByTypeId(visitor, inferDType(node), throwIfNotFound);
  }
  if ((node === null || node === undefined ? undefined : node.type) && node.type instanceof DataType) {
    return getVisitFnByTypeId(visitor, inferDType(node.type), throwIfNotFound);
  }
  return getVisitFnByTypeId(visitor, Type4.NONE, throwIfNotFound);
}
function getVisitFnByTypeId(visitor, dtype, throwIfNotFound = true) {
  let fn2 = null;
  switch (dtype) {
    case Type4.Null:
      fn2 = visitor.visitNull;
      break;
    case Type4.Bool:
      fn2 = visitor.visitBool;
      break;
    case Type4.Int:
      fn2 = visitor.visitInt;
      break;
    case Type4.Int8:
      fn2 = visitor.visitInt8 || visitor.visitInt;
      break;
    case Type4.Int16:
      fn2 = visitor.visitInt16 || visitor.visitInt;
      break;
    case Type4.Int32:
      fn2 = visitor.visitInt32 || visitor.visitInt;
      break;
    case Type4.Int64:
      fn2 = visitor.visitInt64 || visitor.visitInt;
      break;
    case Type4.Uint8:
      fn2 = visitor.visitUint8 || visitor.visitInt;
      break;
    case Type4.Uint16:
      fn2 = visitor.visitUint16 || visitor.visitInt;
      break;
    case Type4.Uint32:
      fn2 = visitor.visitUint32 || visitor.visitInt;
      break;
    case Type4.Uint64:
      fn2 = visitor.visitUint64 || visitor.visitInt;
      break;
    case Type4.Float:
      fn2 = visitor.visitFloat;
      break;
    case Type4.Float16:
      fn2 = visitor.visitFloat16 || visitor.visitFloat;
      break;
    case Type4.Float32:
      fn2 = visitor.visitFloat32 || visitor.visitFloat;
      break;
    case Type4.Float64:
      fn2 = visitor.visitFloat64 || visitor.visitFloat;
      break;
    case Type4.Utf8:
      fn2 = visitor.visitUtf8;
      break;
    case Type4.LargeUtf8:
      fn2 = visitor.visitLargeUtf8;
      break;
    case Type4.Binary:
      fn2 = visitor.visitBinary;
      break;
    case Type4.LargeBinary:
      fn2 = visitor.visitLargeBinary;
      break;
    case Type4.FixedSizeBinary:
      fn2 = visitor.visitFixedSizeBinary;
      break;
    case Type4.Date:
      fn2 = visitor.visitDate;
      break;
    case Type4.DateDay:
      fn2 = visitor.visitDateDay || visitor.visitDate;
      break;
    case Type4.DateMillisecond:
      fn2 = visitor.visitDateMillisecond || visitor.visitDate;
      break;
    case Type4.Timestamp:
      fn2 = visitor.visitTimestamp;
      break;
    case Type4.TimestampSecond:
      fn2 = visitor.visitTimestampSecond || visitor.visitTimestamp;
      break;
    case Type4.TimestampMillisecond:
      fn2 = visitor.visitTimestampMillisecond || visitor.visitTimestamp;
      break;
    case Type4.TimestampMicrosecond:
      fn2 = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;
      break;
    case Type4.TimestampNanosecond:
      fn2 = visitor.visitTimestampNanosecond || visitor.visitTimestamp;
      break;
    case Type4.Time:
      fn2 = visitor.visitTime;
      break;
    case Type4.TimeSecond:
      fn2 = visitor.visitTimeSecond || visitor.visitTime;
      break;
    case Type4.TimeMillisecond:
      fn2 = visitor.visitTimeMillisecond || visitor.visitTime;
      break;
    case Type4.TimeMicrosecond:
      fn2 = visitor.visitTimeMicrosecond || visitor.visitTime;
      break;
    case Type4.TimeNanosecond:
      fn2 = visitor.visitTimeNanosecond || visitor.visitTime;
      break;
    case Type4.Decimal:
      fn2 = visitor.visitDecimal;
      break;
    case Type4.List:
      fn2 = visitor.visitList;
      break;
    case Type4.Struct:
      fn2 = visitor.visitStruct;
      break;
    case Type4.Union:
      fn2 = visitor.visitUnion;
      break;
    case Type4.DenseUnion:
      fn2 = visitor.visitDenseUnion || visitor.visitUnion;
      break;
    case Type4.SparseUnion:
      fn2 = visitor.visitSparseUnion || visitor.visitUnion;
      break;
    case Type4.Dictionary:
      fn2 = visitor.visitDictionary;
      break;
    case Type4.Interval:
      fn2 = visitor.visitInterval;
      break;
    case Type4.IntervalDayTime:
      fn2 = visitor.visitIntervalDayTime || visitor.visitInterval;
      break;
    case Type4.IntervalYearMonth:
      fn2 = visitor.visitIntervalYearMonth || visitor.visitInterval;
      break;
    case Type4.IntervalMonthDayNano:
      fn2 = visitor.visitIntervalMonthDayNano || visitor.visitInterval;
      break;
    case Type4.Duration:
      fn2 = visitor.visitDuration;
      break;
    case Type4.DurationSecond:
      fn2 = visitor.visitDurationSecond || visitor.visitDuration;
      break;
    case Type4.DurationMillisecond:
      fn2 = visitor.visitDurationMillisecond || visitor.visitDuration;
      break;
    case Type4.DurationMicrosecond:
      fn2 = visitor.visitDurationMicrosecond || visitor.visitDuration;
      break;
    case Type4.DurationNanosecond:
      fn2 = visitor.visitDurationNanosecond || visitor.visitDuration;
      break;
    case Type4.FixedSizeList:
      fn2 = visitor.visitFixedSizeList;
      break;
    case Type4.Map:
      fn2 = visitor.visitMap;
      break;
  }
  if (typeof fn2 === "function")
    return fn2;
  if (!throwIfNotFound)
    return () => null;
  throw new Error(`Unrecognized type '${Type4[dtype]}'`);
}
function inferDType(type) {
  switch (type.typeId) {
    case Type4.Null:
      return Type4.Null;
    case Type4.Int: {
      const { bitWidth, isSigned } = type;
      switch (bitWidth) {
        case 8:
          return isSigned ? Type4.Int8 : Type4.Uint8;
        case 16:
          return isSigned ? Type4.Int16 : Type4.Uint16;
        case 32:
          return isSigned ? Type4.Int32 : Type4.Uint32;
        case 64:
          return isSigned ? Type4.Int64 : Type4.Uint64;
      }
      return Type4.Int;
    }
    case Type4.Float:
      switch (type.precision) {
        case Precision.HALF:
          return Type4.Float16;
        case Precision.SINGLE:
          return Type4.Float32;
        case Precision.DOUBLE:
          return Type4.Float64;
      }
      return Type4.Float;
    case Type4.Binary:
      return Type4.Binary;
    case Type4.LargeBinary:
      return Type4.LargeBinary;
    case Type4.Utf8:
      return Type4.Utf8;
    case Type4.LargeUtf8:
      return Type4.LargeUtf8;
    case Type4.Bool:
      return Type4.Bool;
    case Type4.Decimal:
      return Type4.Decimal;
    case Type4.Time:
      switch (type.unit) {
        case TimeUnit.SECOND:
          return Type4.TimeSecond;
        case TimeUnit.MILLISECOND:
          return Type4.TimeMillisecond;
        case TimeUnit.MICROSECOND:
          return Type4.TimeMicrosecond;
        case TimeUnit.NANOSECOND:
          return Type4.TimeNanosecond;
      }
      return Type4.Time;
    case Type4.Timestamp:
      switch (type.unit) {
        case TimeUnit.SECOND:
          return Type4.TimestampSecond;
        case TimeUnit.MILLISECOND:
          return Type4.TimestampMillisecond;
        case TimeUnit.MICROSECOND:
          return Type4.TimestampMicrosecond;
        case TimeUnit.NANOSECOND:
          return Type4.TimestampNanosecond;
      }
      return Type4.Timestamp;
    case Type4.Date:
      switch (type.unit) {
        case DateUnit.DAY:
          return Type4.DateDay;
        case DateUnit.MILLISECOND:
          return Type4.DateMillisecond;
      }
      return Type4.Date;
    case Type4.Interval:
      switch (type.unit) {
        case IntervalUnit.DAY_TIME:
          return Type4.IntervalDayTime;
        case IntervalUnit.YEAR_MONTH:
          return Type4.IntervalYearMonth;
        case IntervalUnit.MONTH_DAY_NANO:
          return Type4.IntervalMonthDayNano;
      }
      return Type4.Interval;
    case Type4.Duration:
      switch (type.unit) {
        case TimeUnit.SECOND:
          return Type4.DurationSecond;
        case TimeUnit.MILLISECOND:
          return Type4.DurationMillisecond;
        case TimeUnit.MICROSECOND:
          return Type4.DurationMicrosecond;
        case TimeUnit.NANOSECOND:
          return Type4.DurationNanosecond;
      }
      return Type4.Duration;
    case Type4.Map:
      return Type4.Map;
    case Type4.List:
      return Type4.List;
    case Type4.Struct:
      return Type4.Struct;
    case Type4.Union:
      switch (type.mode) {
        case UnionMode.Dense:
          return Type4.DenseUnion;
        case UnionMode.Sparse:
          return Type4.SparseUnion;
      }
      return Type4.Union;
    case Type4.FixedSizeBinary:
      return Type4.FixedSizeBinary;
    case Type4.FixedSizeList:
      return Type4.FixedSizeList;
    case Type4.Dictionary:
      return Type4.Dictionary;
  }
  throw new Error(`Unrecognized type '${Type4[type.typeId]}'`);
}
Visitor.prototype.visitInt8 = null;
Visitor.prototype.visitInt16 = null;
Visitor.prototype.visitInt32 = null;
Visitor.prototype.visitInt64 = null;
Visitor.prototype.visitUint8 = null;
Visitor.prototype.visitUint16 = null;
Visitor.prototype.visitUint32 = null;
Visitor.prototype.visitUint64 = null;
Visitor.prototype.visitFloat16 = null;
Visitor.prototype.visitFloat32 = null;
Visitor.prototype.visitFloat64 = null;
Visitor.prototype.visitDateDay = null;
Visitor.prototype.visitDateMillisecond = null;
Visitor.prototype.visitTimestampSecond = null;
Visitor.prototype.visitTimestampMillisecond = null;
Visitor.prototype.visitTimestampMicrosecond = null;
Visitor.prototype.visitTimestampNanosecond = null;
Visitor.prototype.visitTimeSecond = null;
Visitor.prototype.visitTimeMillisecond = null;
Visitor.prototype.visitTimeMicrosecond = null;
Visitor.prototype.visitTimeNanosecond = null;
Visitor.prototype.visitDenseUnion = null;
Visitor.prototype.visitSparseUnion = null;
Visitor.prototype.visitIntervalDayTime = null;
Visitor.prototype.visitIntervalYearMonth = null;
Visitor.prototype.visitIntervalMonthDayNano = null;
Visitor.prototype.visitDuration = null;
Visitor.prototype.visitDurationSecond = null;
Visitor.prototype.visitDurationMillisecond = null;
Visitor.prototype.visitDurationMicrosecond = null;
Visitor.prototype.visitDurationNanosecond = null;

// node_modules/apache-arrow/util/math.mjs
var exports_math = {};
__export(exports_math, {
  uint16ToFloat64: () => uint16ToFloat64,
  float64ToUint16: () => float64ToUint16
});
var f64 = new Float64Array(1);
var u32 = new Uint32Array(f64.buffer);
function uint16ToFloat64(h) {
  const expo = (h & 31744) >> 10;
  const sigf = (h & 1023) / 1024;
  const sign = Math.pow(-1, (h & 32768) >> 15);
  switch (expo) {
    case 31:
      return sign * (sigf ? Number.NaN : 1 / 0);
    case 0:
      return sign * (sigf ? 0.00006103515625 * sigf : 0);
  }
  return sign * Math.pow(2, expo - 15) * (1 + sigf);
}
function float64ToUint16(d) {
  if (d !== d) {
    return 32256;
  }
  f64[0] = d;
  const sign = (u32[1] & 2147483648) >> 16 & 65535;
  let expo = u32[1] & 2146435072, sigf = 0;
  if (expo >= 1089470464) {
    if (u32[0] > 0) {
      expo = 31744;
    } else {
      expo = (expo & 2080374784) >> 16;
      sigf = (u32[1] & 1048575) >> 10;
    }
  } else if (expo <= 1056964608) {
    sigf = 1048576 + (u32[1] & 1048575);
    sigf = 1048576 + (sigf << (expo >> 20) - 998) >> 21;
    expo = 0;
  } else {
    expo = expo - 1056964608 >> 10;
    sigf = (u32[1] & 1048575) + 512 >> 10;
  }
  return sign | expo | sigf & 65535;
}

// node_modules/apache-arrow/visitor/set.mjs
class SetVisitor extends Visitor {
}
function wrapSet(fn2) {
  return (data, _1, _2) => {
    if (data.setValid(_1, _2 != null)) {
      return fn2(data, _1, _2);
    }
  };
}
var setEpochMsToDays = (data, index, epochMs) => {
  data[index] = Math.floor(epochMs / 86400000);
};
var setVariableWidthBytes = (values3, valueOffsets, index, value) => {
  if (index + 1 < valueOffsets.length) {
    const x = bigIntToNumber(valueOffsets[index]);
    const y = bigIntToNumber(valueOffsets[index + 1]);
    values3.set(value.subarray(0, y - x), x);
  }
};
var setBool = ({ offset, values: values3 }, index, val) => {
  const idx = offset + index;
  val ? values3[idx >> 3] |= 1 << idx % 8 : values3[idx >> 3] &= ~(1 << idx % 8);
};
var setInt = ({ values: values3 }, index, value) => {
  values3[index] = value;
};
var setFloat = ({ values: values3 }, index, value) => {
  values3[index] = value;
};
var setFloat16 = ({ values: values3 }, index, value) => {
  values3[index] = float64ToUint16(value);
};
var setAnyFloat = (data, index, value) => {
  switch (data.type.precision) {
    case Precision.HALF:
      return setFloat16(data, index, value);
    case Precision.SINGLE:
    case Precision.DOUBLE:
      return setFloat(data, index, value);
  }
};
var setDateDay = ({ values: values3 }, index, value) => {
  setEpochMsToDays(values3, index, value.valueOf());
};
var setDateMillisecond = ({ values: values3 }, index, value) => {
  values3[index] = BigInt(value);
};
var setFixedSizeBinary = ({ stride, values: values3 }, index, value) => {
  values3.set(value.subarray(0, stride), stride * index);
};
var setBinary = ({ values: values3, valueOffsets }, index, value) => setVariableWidthBytes(values3, valueOffsets, index, value);
var setUtf8 = ({ values: values3, valueOffsets }, index, value) => setVariableWidthBytes(values3, valueOffsets, index, encodeUtf8(value));
var setDate = (data, index, value) => {
  data.type.unit === DateUnit.DAY ? setDateDay(data, index, value) : setDateMillisecond(data, index, value);
};
var setTimestampSecond = ({ values: values3 }, index, value) => {
  values3[index] = BigInt(value / 1000);
};
var setTimestampMillisecond = ({ values: values3 }, index, value) => {
  values3[index] = BigInt(value);
};
var setTimestampMicrosecond = ({ values: values3 }, index, value) => {
  values3[index] = BigInt(value * 1000);
};
var setTimestampNanosecond = ({ values: values3 }, index, value) => {
  values3[index] = BigInt(value * 1e6);
};
var setTimestamp = (data, index, value) => {
  switch (data.type.unit) {
    case TimeUnit.SECOND:
      return setTimestampSecond(data, index, value);
    case TimeUnit.MILLISECOND:
      return setTimestampMillisecond(data, index, value);
    case TimeUnit.MICROSECOND:
      return setTimestampMicrosecond(data, index, value);
    case TimeUnit.NANOSECOND:
      return setTimestampNanosecond(data, index, value);
  }
};
var setTimeSecond = ({ values: values3 }, index, value) => {
  values3[index] = value;
};
var setTimeMillisecond = ({ values: values3 }, index, value) => {
  values3[index] = value;
};
var setTimeMicrosecond = ({ values: values3 }, index, value) => {
  values3[index] = value;
};
var setTimeNanosecond = ({ values: values3 }, index, value) => {
  values3[index] = value;
};
var setTime = (data, index, value) => {
  switch (data.type.unit) {
    case TimeUnit.SECOND:
      return setTimeSecond(data, index, value);
    case TimeUnit.MILLISECOND:
      return setTimeMillisecond(data, index, value);
    case TimeUnit.MICROSECOND:
      return setTimeMicrosecond(data, index, value);
    case TimeUnit.NANOSECOND:
      return setTimeNanosecond(data, index, value);
  }
};
var setDecimal = ({ values: values3, stride }, index, value) => {
  values3.set(value.subarray(0, stride), stride * index);
};
var setList = (data, index, value) => {
  const values3 = data.children[0];
  const valueOffsets = data.valueOffsets;
  const set8 = instance.getVisitFn(values3);
  if (Array.isArray(value)) {
    for (let idx = -1, itr = valueOffsets[index], end6 = valueOffsets[index + 1];itr < end6; ) {
      set8(values3, itr++, value[++idx]);
    }
  } else {
    for (let idx = -1, itr = valueOffsets[index], end6 = valueOffsets[index + 1];itr < end6; ) {
      set8(values3, itr++, value.get(++idx));
    }
  }
};
var setMap = (data, index, value) => {
  const values3 = data.children[0];
  const { valueOffsets } = data;
  const set8 = instance.getVisitFn(values3);
  let { [index]: idx, [index + 1]: end6 } = valueOffsets;
  const entries2 = value instanceof Map ? value.entries() : Object.entries(value);
  for (const val of entries2) {
    set8(values3, idx, val);
    if (++idx >= end6)
      break;
  }
};
var _setStructArrayValue = (o, v) => (set8, c, _, i) => c && set8(c, o, v[i]);
var _setStructVectorValue = (o, v) => (set8, c, _, i) => c && set8(c, o, v.get(i));
var _setStructMapValue = (o, v) => (set8, c, f, _) => c && set8(c, o, v.get(f.name));
var _setStructObjectValue = (o, v) => (set8, c, f, _) => c && set8(c, o, v[f.name]);
var setStruct = (data, index, value) => {
  const childSetters = data.type.children.map((f) => instance.getVisitFn(f.type));
  const set8 = value instanceof Map ? _setStructMapValue(index, value) : value instanceof Vector ? _setStructVectorValue(index, value) : Array.isArray(value) ? _setStructArrayValue(index, value) : _setStructObjectValue(index, value);
  data.type.children.forEach((f, i) => set8(childSetters[i], data.children[i], f, i));
};
var setUnion = (data, index, value) => {
  data.type.mode === UnionMode.Dense ? setDenseUnion(data, index, value) : setSparseUnion(data, index, value);
};
var setDenseUnion = (data, index, value) => {
  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
  const child = data.children[childIndex];
  instance.visit(child, data.valueOffsets[index], value);
};
var setSparseUnion = (data, index, value) => {
  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
  const child = data.children[childIndex];
  instance.visit(child, index, value);
};
var setDictionary = (data, index, value) => {
  var _a2;
  (_a2 = data.dictionary) === null || _a2 === undefined || _a2.set(data.values[index], value);
};
var setIntervalValue = (data, index, value) => {
  switch (data.type.unit) {
    case IntervalUnit.YEAR_MONTH:
      return setIntervalYearMonth(data, index, value);
    case IntervalUnit.DAY_TIME:
      return setIntervalDayTime(data, index, value);
    case IntervalUnit.MONTH_DAY_NANO:
      return setIntervalMonthDayNano(data, index, value);
  }
};
var setIntervalDayTime = ({ values: values3 }, index, value) => {
  values3.set(value.subarray(0, 2), 2 * index);
};
var setIntervalYearMonth = ({ values: values3 }, index, value) => {
  values3[index] = value[0] * 12 + value[1] % 12;
};
var setIntervalMonthDayNano = ({ values: values3, stride }, index, value) => {
  values3.set(value.subarray(0, stride), stride * index);
};
var setDurationSecond = ({ values: values3 }, index, value) => {
  values3[index] = value;
};
var setDurationMillisecond = ({ values: values3 }, index, value) => {
  values3[index] = value;
};
var setDurationMicrosecond = ({ values: values3 }, index, value) => {
  values3[index] = value;
};
var setDurationNanosecond = ({ values: values3 }, index, value) => {
  values3[index] = value;
};
var setDuration = (data, index, value) => {
  switch (data.type.unit) {
    case TimeUnit.SECOND:
      return setDurationSecond(data, index, value);
    case TimeUnit.MILLISECOND:
      return setDurationMillisecond(data, index, value);
    case TimeUnit.MICROSECOND:
      return setDurationMicrosecond(data, index, value);
    case TimeUnit.NANOSECOND:
      return setDurationNanosecond(data, index, value);
  }
};
var setFixedSizeList = (data, index, value) => {
  const { stride } = data;
  const child = data.children[0];
  const set8 = instance.getVisitFn(child);
  if (Array.isArray(value)) {
    for (let idx = -1, offset = index * stride;++idx < stride; ) {
      set8(child, offset + idx, value[idx]);
    }
  } else {
    for (let idx = -1, offset = index * stride;++idx < stride; ) {
      set8(child, offset + idx, value.get(idx));
    }
  }
};
SetVisitor.prototype.visitBool = wrapSet(setBool);
SetVisitor.prototype.visitInt = wrapSet(setInt);
SetVisitor.prototype.visitInt8 = wrapSet(setInt);
SetVisitor.prototype.visitInt16 = wrapSet(setInt);
SetVisitor.prototype.visitInt32 = wrapSet(setInt);
SetVisitor.prototype.visitInt64 = wrapSet(setInt);
SetVisitor.prototype.visitUint8 = wrapSet(setInt);
SetVisitor.prototype.visitUint16 = wrapSet(setInt);
SetVisitor.prototype.visitUint32 = wrapSet(setInt);
SetVisitor.prototype.visitUint64 = wrapSet(setInt);
SetVisitor.prototype.visitFloat = wrapSet(setAnyFloat);
SetVisitor.prototype.visitFloat16 = wrapSet(setFloat16);
SetVisitor.prototype.visitFloat32 = wrapSet(setFloat);
SetVisitor.prototype.visitFloat64 = wrapSet(setFloat);
SetVisitor.prototype.visitUtf8 = wrapSet(setUtf8);
SetVisitor.prototype.visitLargeUtf8 = wrapSet(setUtf8);
SetVisitor.prototype.visitBinary = wrapSet(setBinary);
SetVisitor.prototype.visitLargeBinary = wrapSet(setBinary);
SetVisitor.prototype.visitFixedSizeBinary = wrapSet(setFixedSizeBinary);
SetVisitor.prototype.visitDate = wrapSet(setDate);
SetVisitor.prototype.visitDateDay = wrapSet(setDateDay);
SetVisitor.prototype.visitDateMillisecond = wrapSet(setDateMillisecond);
SetVisitor.prototype.visitTimestamp = wrapSet(setTimestamp);
SetVisitor.prototype.visitTimestampSecond = wrapSet(setTimestampSecond);
SetVisitor.prototype.visitTimestampMillisecond = wrapSet(setTimestampMillisecond);
SetVisitor.prototype.visitTimestampMicrosecond = wrapSet(setTimestampMicrosecond);
SetVisitor.prototype.visitTimestampNanosecond = wrapSet(setTimestampNanosecond);
SetVisitor.prototype.visitTime = wrapSet(setTime);
SetVisitor.prototype.visitTimeSecond = wrapSet(setTimeSecond);
SetVisitor.prototype.visitTimeMillisecond = wrapSet(setTimeMillisecond);
SetVisitor.prototype.visitTimeMicrosecond = wrapSet(setTimeMicrosecond);
SetVisitor.prototype.visitTimeNanosecond = wrapSet(setTimeNanosecond);
SetVisitor.prototype.visitDecimal = wrapSet(setDecimal);
SetVisitor.prototype.visitList = wrapSet(setList);
SetVisitor.prototype.visitStruct = wrapSet(setStruct);
SetVisitor.prototype.visitUnion = wrapSet(setUnion);
SetVisitor.prototype.visitDenseUnion = wrapSet(setDenseUnion);
SetVisitor.prototype.visitSparseUnion = wrapSet(setSparseUnion);
SetVisitor.prototype.visitDictionary = wrapSet(setDictionary);
SetVisitor.prototype.visitInterval = wrapSet(setIntervalValue);
SetVisitor.prototype.visitIntervalDayTime = wrapSet(setIntervalDayTime);
SetVisitor.prototype.visitIntervalYearMonth = wrapSet(setIntervalYearMonth);
SetVisitor.prototype.visitIntervalMonthDayNano = wrapSet(setIntervalMonthDayNano);
SetVisitor.prototype.visitDuration = wrapSet(setDuration);
SetVisitor.prototype.visitDurationSecond = wrapSet(setDurationSecond);
SetVisitor.prototype.visitDurationMillisecond = wrapSet(setDurationMillisecond);
SetVisitor.prototype.visitDurationMicrosecond = wrapSet(setDurationMicrosecond);
SetVisitor.prototype.visitDurationNanosecond = wrapSet(setDurationNanosecond);
SetVisitor.prototype.visitFixedSizeList = wrapSet(setFixedSizeList);
SetVisitor.prototype.visitMap = wrapSet(setMap);
var instance = new SetVisitor;

// node_modules/apache-arrow/row/struct.mjs
var kParent = Symbol.for("parent");
var kRowIndex = Symbol.for("rowIndex");

class StructRow {
  constructor(parent, rowIndex) {
    this[kParent] = parent;
    this[kRowIndex] = rowIndex;
    return new Proxy(this, structRowProxyHandler);
  }
  toArray() {
    return Object.values(this.toJSON());
  }
  toJSON() {
    const i = this[kRowIndex];
    const parent = this[kParent];
    const keys3 = parent.type.children;
    const json = {};
    for (let j = -1, n = keys3.length;++j < n; ) {
      json[keys3[j].name] = instance2.visit(parent.children[j], i);
    }
    return json;
  }
  toString() {
    return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(", ")}}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
  [Symbol.iterator]() {
    return new StructRowIterator(this[kParent], this[kRowIndex]);
  }
}

class StructRowIterator {
  constructor(data, rowIndex) {
    this.childIndex = 0;
    this.children = data.children;
    this.rowIndex = rowIndex;
    this.childFields = data.type.children;
    this.numChildren = this.childFields.length;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const i = this.childIndex;
    if (i < this.numChildren) {
      this.childIndex = i + 1;
      return {
        done: false,
        value: [
          this.childFields[i].name,
          instance2.visit(this.children[i], this.rowIndex)
        ]
      };
    }
    return { done: true, value: null };
  }
}
Object.defineProperties(StructRow.prototype, {
  [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
  [kParent]: { writable: true, enumerable: false, configurable: false, value: null },
  [kRowIndex]: { writable: true, enumerable: false, configurable: false, value: -1 }
});

class StructRowProxyHandler {
  isExtensible() {
    return false;
  }
  deleteProperty() {
    return false;
  }
  preventExtensions() {
    return true;
  }
  ownKeys(row) {
    return row[kParent].type.children.map((f) => f.name);
  }
  has(row, key) {
    return row[kParent].type.children.some((f) => f.name === key);
  }
  getOwnPropertyDescriptor(row, key) {
    if (row[kParent].type.children.some((f) => f.name === key)) {
      return { writable: true, enumerable: true, configurable: true };
    }
    return;
  }
  get(row, key) {
    if (Reflect.has(row, key)) {
      return row[key];
    }
    const idx = row[kParent].type.children.findIndex((f) => f.name === key);
    if (idx !== -1) {
      const val = instance2.visit(row[kParent].children[idx], row[kRowIndex]);
      Reflect.set(row, key, val);
      return val;
    }
  }
  set(row, key, val) {
    const idx = row[kParent].type.children.findIndex((f) => f.name === key);
    if (idx !== -1) {
      instance.visit(row[kParent].children[idx], row[kRowIndex], val);
      return Reflect.set(row, key, val);
    } else if (Reflect.has(row, key) || typeof key === "symbol") {
      return Reflect.set(row, key, val);
    }
    return false;
  }
}
var structRowProxyHandler = new StructRowProxyHandler;

// node_modules/apache-arrow/visitor/get.mjs
class GetVisitor extends Visitor {
}
function wrapGet(fn2) {
  return (data, _1) => data.getValid(_1) ? fn2(data, _1) : null;
}
var epochDaysToMs = (data, index) => 86400000 * data[index];
var getNull = (_data, _index) => null;
var getVariableWidthBytes = (values3, valueOffsets, index) => {
  if (index + 1 >= valueOffsets.length) {
    return null;
  }
  const x = bigIntToNumber(valueOffsets[index]);
  const y = bigIntToNumber(valueOffsets[index + 1]);
  return values3.subarray(x, y);
};
var getBool = ({ offset, values: values3 }, index) => {
  const idx = offset + index;
  const byte = values3[idx >> 3];
  return (byte & 1 << idx % 8) !== 0;
};
var getDateDay = ({ values: values3 }, index) => epochDaysToMs(values3, index);
var getDateMillisecond = ({ values: values3 }, index) => bigIntToNumber(values3[index]);
var getNumeric = ({ stride, values: values3 }, index) => values3[stride * index];
var getFloat16 = ({ stride, values: values3 }, index) => uint16ToFloat64(values3[stride * index]);
var getBigInts = ({ values: values3 }, index) => values3[index];
var getFixedSizeBinary = ({ stride, values: values3 }, index) => values3.subarray(stride * index, stride * (index + 1));
var getBinary = ({ values: values3, valueOffsets }, index) => getVariableWidthBytes(values3, valueOffsets, index);
var getUtf8 = ({ values: values3, valueOffsets }, index) => {
  const bytes = getVariableWidthBytes(values3, valueOffsets, index);
  return bytes !== null ? decodeUtf8(bytes) : null;
};
var getInt = ({ values: values3 }, index) => values3[index];
var getFloat = ({ type, values: values3 }, index) => type.precision !== Precision.HALF ? values3[index] : uint16ToFloat64(values3[index]);
var getDate = (data, index) => data.type.unit === DateUnit.DAY ? getDateDay(data, index) : getDateMillisecond(data, index);
var getTimestampSecond = ({ values: values3 }, index) => 1000 * bigIntToNumber(values3[index]);
var getTimestampMillisecond = ({ values: values3 }, index) => bigIntToNumber(values3[index]);
var getTimestampMicrosecond = ({ values: values3 }, index) => divideBigInts(values3[index], BigInt(1000));
var getTimestampNanosecond = ({ values: values3 }, index) => divideBigInts(values3[index], BigInt(1e6));
var getTimestamp = (data, index) => {
  switch (data.type.unit) {
    case TimeUnit.SECOND:
      return getTimestampSecond(data, index);
    case TimeUnit.MILLISECOND:
      return getTimestampMillisecond(data, index);
    case TimeUnit.MICROSECOND:
      return getTimestampMicrosecond(data, index);
    case TimeUnit.NANOSECOND:
      return getTimestampNanosecond(data, index);
  }
};
var getTimeSecond = ({ values: values3 }, index) => values3[index];
var getTimeMillisecond = ({ values: values3 }, index) => values3[index];
var getTimeMicrosecond = ({ values: values3 }, index) => values3[index];
var getTimeNanosecond = ({ values: values3 }, index) => values3[index];
var getTime = (data, index) => {
  switch (data.type.unit) {
    case TimeUnit.SECOND:
      return getTimeSecond(data, index);
    case TimeUnit.MILLISECOND:
      return getTimeMillisecond(data, index);
    case TimeUnit.MICROSECOND:
      return getTimeMicrosecond(data, index);
    case TimeUnit.NANOSECOND:
      return getTimeNanosecond(data, index);
  }
};
var getDecimal = ({ values: values3, stride }, index) => BN.decimal(values3.subarray(stride * index, stride * (index + 1)));
var getList = (data, index) => {
  const { valueOffsets, stride, children: children2 } = data;
  const { [index * stride]: begin, [index * stride + 1]: end6 } = valueOffsets;
  const child = children2[0];
  const slice = child.slice(begin, end6 - begin);
  return new Vector([slice]);
};
var getMap = (data, index) => {
  const { valueOffsets, children: children2 } = data;
  const { [index]: begin, [index + 1]: end6 } = valueOffsets;
  const child = children2[0];
  return new MapRow(child.slice(begin, end6 - begin));
};
var getStruct = (data, index) => {
  return new StructRow(data, index);
};
var getUnion = (data, index) => {
  return data.type.mode === UnionMode.Dense ? getDenseUnion(data, index) : getSparseUnion(data, index);
};
var getDenseUnion = (data, index) => {
  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
  const child = data.children[childIndex];
  return instance2.visit(child, data.valueOffsets[index]);
};
var getSparseUnion = (data, index) => {
  const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
  const child = data.children[childIndex];
  return instance2.visit(child, index);
};
var getDictionary = (data, index) => {
  var _a2;
  return (_a2 = data.dictionary) === null || _a2 === undefined ? undefined : _a2.get(data.values[index]);
};
var getInterval = (data, index) => data.type.unit === IntervalUnit.MONTH_DAY_NANO ? getIntervalMonthDayNano(data, index) : data.type.unit === IntervalUnit.DAY_TIME ? getIntervalDayTime(data, index) : getIntervalYearMonth(data, index);
var getIntervalDayTime = ({ values: values3 }, index) => values3.subarray(2 * index, 2 * (index + 1));
var getIntervalYearMonth = ({ values: values3 }, index) => {
  const interval = values3[index];
  const int32s = new Int32Array(2);
  int32s[0] = Math.trunc(interval / 12);
  int32s[1] = Math.trunc(interval % 12);
  return int32s;
};
var getIntervalMonthDayNano = ({ values: values3 }, index) => values3.subarray(4 * index, 4 * (index + 1));
var getDurationSecond = ({ values: values3 }, index) => values3[index];
var getDurationMillisecond = ({ values: values3 }, index) => values3[index];
var getDurationMicrosecond = ({ values: values3 }, index) => values3[index];
var getDurationNanosecond = ({ values: values3 }, index) => values3[index];
var getDuration = (data, index) => {
  switch (data.type.unit) {
    case TimeUnit.SECOND:
      return getDurationSecond(data, index);
    case TimeUnit.MILLISECOND:
      return getDurationMillisecond(data, index);
    case TimeUnit.MICROSECOND:
      return getDurationMicrosecond(data, index);
    case TimeUnit.NANOSECOND:
      return getDurationNanosecond(data, index);
  }
};
var getFixedSizeList = (data, index) => {
  const { stride, children: children2 } = data;
  const child = children2[0];
  const slice = child.slice(index * stride, stride);
  return new Vector([slice]);
};
GetVisitor.prototype.visitNull = wrapGet(getNull);
GetVisitor.prototype.visitBool = wrapGet(getBool);
GetVisitor.prototype.visitInt = wrapGet(getInt);
GetVisitor.prototype.visitInt8 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt16 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt32 = wrapGet(getNumeric);
GetVisitor.prototype.visitInt64 = wrapGet(getBigInts);
GetVisitor.prototype.visitUint8 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint16 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint32 = wrapGet(getNumeric);
GetVisitor.prototype.visitUint64 = wrapGet(getBigInts);
GetVisitor.prototype.visitFloat = wrapGet(getFloat);
GetVisitor.prototype.visitFloat16 = wrapGet(getFloat16);
GetVisitor.prototype.visitFloat32 = wrapGet(getNumeric);
GetVisitor.prototype.visitFloat64 = wrapGet(getNumeric);
GetVisitor.prototype.visitUtf8 = wrapGet(getUtf8);
GetVisitor.prototype.visitLargeUtf8 = wrapGet(getUtf8);
GetVisitor.prototype.visitBinary = wrapGet(getBinary);
GetVisitor.prototype.visitLargeBinary = wrapGet(getBinary);
GetVisitor.prototype.visitFixedSizeBinary = wrapGet(getFixedSizeBinary);
GetVisitor.prototype.visitDate = wrapGet(getDate);
GetVisitor.prototype.visitDateDay = wrapGet(getDateDay);
GetVisitor.prototype.visitDateMillisecond = wrapGet(getDateMillisecond);
GetVisitor.prototype.visitTimestamp = wrapGet(getTimestamp);
GetVisitor.prototype.visitTimestampSecond = wrapGet(getTimestampSecond);
GetVisitor.prototype.visitTimestampMillisecond = wrapGet(getTimestampMillisecond);
GetVisitor.prototype.visitTimestampMicrosecond = wrapGet(getTimestampMicrosecond);
GetVisitor.prototype.visitTimestampNanosecond = wrapGet(getTimestampNanosecond);
GetVisitor.prototype.visitTime = wrapGet(getTime);
GetVisitor.prototype.visitTimeSecond = wrapGet(getTimeSecond);
GetVisitor.prototype.visitTimeMillisecond = wrapGet(getTimeMillisecond);
GetVisitor.prototype.visitTimeMicrosecond = wrapGet(getTimeMicrosecond);
GetVisitor.prototype.visitTimeNanosecond = wrapGet(getTimeNanosecond);
GetVisitor.prototype.visitDecimal = wrapGet(getDecimal);
GetVisitor.prototype.visitList = wrapGet(getList);
GetVisitor.prototype.visitStruct = wrapGet(getStruct);
GetVisitor.prototype.visitUnion = wrapGet(getUnion);
GetVisitor.prototype.visitDenseUnion = wrapGet(getDenseUnion);
GetVisitor.prototype.visitSparseUnion = wrapGet(getSparseUnion);
GetVisitor.prototype.visitDictionary = wrapGet(getDictionary);
GetVisitor.prototype.visitInterval = wrapGet(getInterval);
GetVisitor.prototype.visitIntervalDayTime = wrapGet(getIntervalDayTime);
GetVisitor.prototype.visitIntervalYearMonth = wrapGet(getIntervalYearMonth);
GetVisitor.prototype.visitIntervalMonthDayNano = wrapGet(getIntervalMonthDayNano);
GetVisitor.prototype.visitDuration = wrapGet(getDuration);
GetVisitor.prototype.visitDurationSecond = wrapGet(getDurationSecond);
GetVisitor.prototype.visitDurationMillisecond = wrapGet(getDurationMillisecond);
GetVisitor.prototype.visitDurationMicrosecond = wrapGet(getDurationMicrosecond);
GetVisitor.prototype.visitDurationNanosecond = wrapGet(getDurationNanosecond);
GetVisitor.prototype.visitFixedSizeList = wrapGet(getFixedSizeList);
GetVisitor.prototype.visitMap = wrapGet(getMap);
var instance2 = new GetVisitor;

// node_modules/apache-arrow/row/map.mjs
var kKeys = Symbol.for("keys");
var kVals = Symbol.for("vals");
var kKeysAsStrings = Symbol.for("kKeysAsStrings");
var _kKeysAsStrings = Symbol.for("_kKeysAsStrings");

class MapRow {
  constructor(slice) {
    this[kKeys] = new Vector([slice.children[0]]).memoize();
    this[kVals] = slice.children[1];
    return new Proxy(this, new MapRowProxyHandler);
  }
  get [kKeysAsStrings]() {
    return this[_kKeysAsStrings] || (this[_kKeysAsStrings] = Array.from(this[kKeys].toArray(), String));
  }
  [Symbol.iterator]() {
    return new MapRowIterator(this[kKeys], this[kVals]);
  }
  get size() {
    return this[kKeys].length;
  }
  toArray() {
    return Object.values(this.toJSON());
  }
  toJSON() {
    const keys3 = this[kKeys];
    const vals = this[kVals];
    const json = {};
    for (let i = -1, n = keys3.length;++i < n; ) {
      json[keys3.get(i)] = instance2.visit(vals, i);
    }
    return json;
  }
  toString() {
    return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(", ")}}`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toString();
  }
}

class MapRowIterator {
  constructor(keys3, vals) {
    this.keys = keys3;
    this.vals = vals;
    this.keyIndex = 0;
    this.numKeys = keys3.length;
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    const i = this.keyIndex;
    if (i === this.numKeys) {
      return { done: true, value: null };
    }
    this.keyIndex++;
    return {
      done: false,
      value: [
        this.keys.get(i),
        instance2.visit(this.vals, i)
      ]
    };
  }
}

class MapRowProxyHandler {
  isExtensible() {
    return false;
  }
  deleteProperty() {
    return false;
  }
  preventExtensions() {
    return true;
  }
  ownKeys(row) {
    return row[kKeysAsStrings];
  }
  has(row, key) {
    return row[kKeysAsStrings].includes(key);
  }
  getOwnPropertyDescriptor(row, key) {
    const idx = row[kKeysAsStrings].indexOf(key);
    if (idx !== -1) {
      return { writable: true, enumerable: true, configurable: true };
    }
    return;
  }
  get(row, key) {
    if (Reflect.has(row, key)) {
      return row[key];
    }
    const idx = row[kKeysAsStrings].indexOf(key);
    if (idx !== -1) {
      const val = instance2.visit(Reflect.get(row, kVals), idx);
      Reflect.set(row, key, val);
      return val;
    }
  }
  set(row, key, val) {
    const idx = row[kKeysAsStrings].indexOf(key);
    if (idx !== -1) {
      instance.visit(Reflect.get(row, kVals), idx, val);
      return Reflect.set(row, key, val);
    } else if (Reflect.has(row, key)) {
      return Reflect.set(row, key, val);
    }
    return false;
  }
}
Object.defineProperties(MapRow.prototype, {
  [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
  [kKeys]: { writable: true, enumerable: false, configurable: false, value: null },
  [kVals]: { writable: true, enumerable: false, configurable: false, value: null },
  [_kKeysAsStrings]: { writable: true, enumerable: false, configurable: false, value: null }
});

// node_modules/apache-arrow/util/vector.mjs
var tmp;
function clampRange(source, begin, end6, then) {
  const { length: len = 0 } = source;
  let lhs = typeof begin !== "number" ? 0 : begin;
  let rhs = typeof end6 !== "number" ? len : end6;
  lhs < 0 && (lhs = (lhs % len + len) % len);
  rhs < 0 && (rhs = (rhs % len + len) % len);
  rhs < lhs && (tmp = lhs, lhs = rhs, rhs = tmp);
  rhs > len && (rhs = len);
  return then ? then(source, lhs, rhs) : [lhs, rhs];
}
var wrapIndex = (index, len) => index < 0 ? len + index : index;
var isNaNFast = (value) => value !== value;
function createElementComparator(search) {
  const typeofSearch = typeof search;
  if (typeofSearch !== "object" || search === null) {
    if (isNaNFast(search)) {
      return isNaNFast;
    }
    return (value) => value === search;
  }
  if (search instanceof Date) {
    const valueOfSearch = search.valueOf();
    return (value) => value instanceof Date ? value.valueOf() === valueOfSearch : false;
  }
  if (ArrayBuffer.isView(search)) {
    return (value) => value ? compareArrayLike(search, value) : false;
  }
  if (search instanceof Map) {
    return createMapComparator(search);
  }
  if (Array.isArray(search)) {
    return createArrayLikeComparator(search);
  }
  if (search instanceof Vector) {
    return createVectorComparator(search);
  }
  return createObjectComparator(search, true);
}
function createArrayLikeComparator(lhs) {
  const comparators = [];
  for (let i = -1, n = lhs.length;++i < n; ) {
    comparators[i] = createElementComparator(lhs[i]);
  }
  return createSubElementsComparator(comparators);
}
function createMapComparator(lhs) {
  let i = -1;
  const comparators = [];
  for (const v of lhs.values())
    comparators[++i] = createElementComparator(v);
  return createSubElementsComparator(comparators);
}
function createVectorComparator(lhs) {
  const comparators = [];
  for (let i = -1, n = lhs.length;++i < n; ) {
    comparators[i] = createElementComparator(lhs.get(i));
  }
  return createSubElementsComparator(comparators);
}
function createObjectComparator(lhs, allowEmpty = false) {
  const keys3 = Object.keys(lhs);
  if (!allowEmpty && keys3.length === 0) {
    return () => false;
  }
  const comparators = [];
  for (let i = -1, n = keys3.length;++i < n; ) {
    comparators[i] = createElementComparator(lhs[keys3[i]]);
  }
  return createSubElementsComparator(comparators, keys3);
}
function createSubElementsComparator(comparators, keys3) {
  return (rhs) => {
    if (!rhs || typeof rhs !== "object") {
      return false;
    }
    switch (rhs.constructor) {
      case Array:
        return compareArray(comparators, rhs);
      case Map:
        return compareObject(comparators, rhs, rhs.keys());
      case MapRow:
      case StructRow:
      case Object:
      case undefined:
        return compareObject(comparators, rhs, keys3 || Object.keys(rhs));
    }
    return rhs instanceof Vector ? compareVector(comparators, rhs) : false;
  };
}
function compareArray(comparators, arr) {
  const n = comparators.length;
  if (arr.length !== n) {
    return false;
  }
  for (let i = -1;++i < n; ) {
    if (!comparators[i](arr[i])) {
      return false;
    }
  }
  return true;
}
function compareVector(comparators, vec) {
  const n = comparators.length;
  if (vec.length !== n) {
    return false;
  }
  for (let i = -1;++i < n; ) {
    if (!comparators[i](vec.get(i))) {
      return false;
    }
  }
  return true;
}
function compareObject(comparators, obj, keys3) {
  const lKeyItr = keys3[Symbol.iterator]();
  const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();
  const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();
  let i = 0;
  const n = comparators.length;
  let rVal = rValItr.next();
  let lKey = lKeyItr.next();
  let rKey = rKeyItr.next();
  for (;i < n && !lKey.done && !rKey.done && !rVal.done; ++i, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {
    if (lKey.value !== rKey.value || !comparators[i](rVal.value)) {
      break;
    }
  }
  if (i === n && lKey.done && rKey.done && rVal.done) {
    return true;
  }
  lKeyItr.return && lKeyItr.return();
  rKeyItr.return && rKeyItr.return();
  rValItr.return && rValItr.return();
  return false;
}

// node_modules/apache-arrow/util/bit.mjs
var exports_bit = {};
__export(exports_bit, {
  truncateBitmap: () => truncateBitmap,
  setBool: () => setBool2,
  popcnt_uint32: () => popcnt_uint32,
  popcnt_bit_range: () => popcnt_bit_range,
  popcnt_array: () => popcnt_array,
  packBools: () => packBools,
  getBool: () => getBool2,
  getBit: () => getBit,
  BitIterator: () => BitIterator
});
function getBool2(_data, _index, byte, bit) {
  return (byte & 1 << bit) !== 0;
}
function getBit(_data, _index, byte, bit) {
  return (byte & 1 << bit) >> bit;
}
function setBool2(bytes, index, value) {
  return value ? !!(bytes[index >> 3] |= 1 << index % 8) || true : !(bytes[index >> 3] &= ~(1 << index % 8)) && false;
}
function truncateBitmap(offset, length3, bitmap) {
  const alignedSize = bitmap.byteLength + 7 & ~7;
  if (offset > 0 || bitmap.byteLength < alignedSize) {
    const bytes = new Uint8Array(alignedSize);
    bytes.set(offset % 8 === 0 ? bitmap.subarray(offset >> 3) : packBools(new BitIterator(bitmap, offset, length3, null, getBool2)).subarray(0, alignedSize));
    return bytes;
  }
  return bitmap;
}
function packBools(values3) {
  const xs = [];
  let i = 0, bit = 0, byte = 0;
  for (const value of values3) {
    value && (byte |= 1 << bit);
    if (++bit === 8) {
      xs[i++] = byte;
      byte = bit = 0;
    }
  }
  if (i === 0 || bit > 0) {
    xs[i++] = byte;
  }
  const b = new Uint8Array(xs.length + 7 & ~7);
  b.set(xs);
  return b;
}

class BitIterator {
  constructor(bytes, begin, length3, context7, get17) {
    this.bytes = bytes;
    this.length = length3;
    this.context = context7;
    this.get = get17;
    this.bit = begin % 8;
    this.byteIndex = begin >> 3;
    this.byte = bytes[this.byteIndex++];
    this.index = 0;
  }
  next() {
    if (this.index < this.length) {
      if (this.bit === 8) {
        this.bit = 0;
        this.byte = this.bytes[this.byteIndex++];
      }
      return {
        value: this.get(this.context, this.index++, this.byte, this.bit++)
      };
    }
    return { done: true, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
}
function popcnt_bit_range(data, lhs, rhs) {
  if (rhs - lhs <= 0) {
    return 0;
  }
  if (rhs - lhs < 8) {
    let sum3 = 0;
    for (const bit of new BitIterator(data, lhs, rhs - lhs, data, getBit)) {
      sum3 += bit;
    }
    return sum3;
  }
  const rhsInside = rhs >> 3 << 3;
  const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);
  return popcnt_bit_range(data, lhs, lhsInside) + popcnt_bit_range(data, rhsInside, rhs) + popcnt_array(data, lhsInside >> 3, rhsInside - lhsInside >> 3);
}
function popcnt_array(arr, byteOffset, byteLength) {
  let cnt = 0, pos = Math.trunc(byteOffset);
  const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  const len = byteLength === undefined ? arr.byteLength : pos + byteLength;
  while (len - pos >= 4) {
    cnt += popcnt_uint32(view.getUint32(pos));
    pos += 4;
  }
  while (len - pos >= 2) {
    cnt += popcnt_uint32(view.getUint16(pos));
    pos += 2;
  }
  while (len - pos >= 1) {
    cnt += popcnt_uint32(view.getUint8(pos));
    pos += 1;
  }
  return cnt;
}
function popcnt_uint32(uint32) {
  let i = Math.trunc(uint32);
  i = i - (i >>> 1 & 1431655765);
  i = (i & 858993459) + (i >>> 2 & 858993459);
  return (i + (i >>> 4) & 252645135) * 16843009 >>> 24;
}

// node_modules/apache-arrow/data.mjs
var kUnknownNullCount = -1;

class Data {
  get typeId() {
    return this.type.typeId;
  }
  get ArrayType() {
    return this.type.ArrayType;
  }
  get buffers() {
    return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
  }
  get nullable() {
    if (this._nullCount !== 0) {
      const { type } = this;
      if (DataType.isSparseUnion(type)) {
        return this.children.some((child) => child.nullable);
      } else if (DataType.isDenseUnion(type)) {
        return this.children.some((child) => child.nullable);
      }
      return this.nullBitmap && this.nullBitmap.byteLength > 0;
    }
    return true;
  }
  get byteLength() {
    let byteLength = 0;
    const { valueOffsets, values: values3, nullBitmap, typeIds } = this;
    valueOffsets && (byteLength += valueOffsets.byteLength);
    values3 && (byteLength += values3.byteLength);
    nullBitmap && (byteLength += nullBitmap.byteLength);
    typeIds && (byteLength += typeIds.byteLength);
    return this.children.reduce((byteLength2, child) => byteLength2 + child.byteLength, byteLength);
  }
  get nullCount() {
    if (DataType.isUnion(this.type)) {
      return this.children.reduce((nullCount2, child) => nullCount2 + child.nullCount, 0);
    }
    let nullCount = this._nullCount;
    let nullBitmap;
    if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {
      this._nullCount = nullCount = nullBitmap.length === 0 ? 0 : this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);
    }
    return nullCount;
  }
  constructor(type, offset, length3, nullCount, buffers, children2 = [], dictionary) {
    this.type = type;
    this.children = children2;
    this.dictionary = dictionary;
    this.offset = Math.floor(Math.max(offset || 0, 0));
    this.length = Math.floor(Math.max(length3 || 0, 0));
    this._nullCount = Math.floor(Math.max(nullCount || 0, -1));
    let buffer3;
    if (buffers instanceof Data) {
      this.stride = buffers.stride;
      this.values = buffers.values;
      this.typeIds = buffers.typeIds;
      this.nullBitmap = buffers.nullBitmap;
      this.valueOffsets = buffers.valueOffsets;
    } else {
      this.stride = strideForType(type);
      if (buffers) {
        (buffer3 = buffers[0]) && (this.valueOffsets = buffer3);
        (buffer3 = buffers[1]) && (this.values = buffer3);
        (buffer3 = buffers[2]) && (this.nullBitmap = buffer3);
        (buffer3 = buffers[3]) && (this.typeIds = buffer3);
      }
    }
  }
  getValid(index) {
    const { type } = this;
    if (DataType.isUnion(type)) {
      const union9 = type;
      const child = this.children[union9.typeIdToChildIndex[this.typeIds[index]]];
      const indexInChild = union9.mode === UnionMode.Dense ? this.valueOffsets[index] : index;
      return child.getValid(indexInChild);
    }
    if (this.nullable && this.nullCount > 0) {
      const pos = this.offset + index;
      const val = this.nullBitmap[pos >> 3];
      return (val & 1 << pos % 8) !== 0;
    }
    return true;
  }
  setValid(index, value) {
    let prev;
    const { type } = this;
    if (DataType.isUnion(type)) {
      const union9 = type;
      const child = this.children[union9.typeIdToChildIndex[this.typeIds[index]]];
      const indexInChild = union9.mode === UnionMode.Dense ? this.valueOffsets[index] : index;
      prev = child.getValid(indexInChild);
      child.setValid(indexInChild, value);
    } else {
      let { nullBitmap } = this;
      const { offset, length: length3 } = this;
      const idx = offset + index;
      const mask = 1 << idx % 8;
      const byteOffset = idx >> 3;
      if (!nullBitmap || nullBitmap.byteLength <= byteOffset) {
        nullBitmap = new Uint8Array((offset + length3 + 63 & ~63) >> 3).fill(255);
        if (this.nullCount > 0) {
          nullBitmap.set(truncateBitmap(offset, length3, this.nullBitmap), 0);
          Object.assign(this, { nullBitmap });
        } else {
          Object.assign(this, { nullBitmap, _nullCount: 0 });
        }
      }
      const byte = nullBitmap[byteOffset];
      prev = (byte & mask) !== 0;
      nullBitmap[byteOffset] = value ? byte | mask : byte & ~mask;
    }
    if (prev !== !!value) {
      this._nullCount = this.nullCount + (value ? -1 : 1);
    }
    return value;
  }
  clone(type = this.type, offset = this.offset, length3 = this.length, nullCount = this._nullCount, buffers = this, children2 = this.children) {
    return new Data(type, offset, length3, nullCount, buffers, children2, this.dictionary);
  }
  slice(offset, length3) {
    const { stride, typeId, children: children2 } = this;
    const nullCount = +(this._nullCount === 0) - 1;
    const childStride = typeId === 16 ? stride : 1;
    const buffers = this._sliceBuffers(offset, length3, stride, typeId);
    return this.clone(this.type, this.offset + offset, length3, nullCount, buffers, children2.length === 0 || this.valueOffsets ? children2 : this._sliceChildren(children2, childStride * offset, childStride * length3));
  }
  _changeLengthAndBackfillNullBitmap(newLength) {
    if (this.typeId === Type4.Null) {
      return this.clone(this.type, 0, newLength, 0);
    }
    const { length: length3, nullCount } = this;
    const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length3 >> 3);
    bitmap[length3 >> 3] = (1 << length3 - (length3 & ~7)) - 1;
    if (nullCount > 0) {
      bitmap.set(truncateBitmap(this.offset, length3, this.nullBitmap), 0);
    }
    const buffers = this.buffers;
    buffers[BufferType.VALIDITY] = bitmap;
    return this.clone(this.type, 0, newLength, nullCount + (newLength - length3), buffers);
  }
  _sliceBuffers(offset, length3, stride, typeId) {
    let arr;
    const { buffers } = this;
    (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset, offset + length3));
    (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset, offset + length3 + 1)) || (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length3)));
    return buffers;
  }
  _sliceChildren(children2, offset, length3) {
    return children2.map((child) => child.slice(offset, length3));
  }
}
Data.prototype.children = Object.freeze([]);

class MakeDataVisitor extends Visitor {
  visit(props) {
    return this.getVisitFn(props["type"]).call(this, props);
  }
  visitNull(props) {
    const { ["type"]: type, ["offset"]: offset = 0, ["length"]: length3 = 0 } = props;
    return new Data(type, offset, length3, length3);
  }
  visitBool(props) {
    const { ["type"]: type, ["offset"]: offset = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length3 = data.length >> 3, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
  }
  visitInt(props) {
    const { ["type"]: type, ["offset"]: offset = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length3 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
  }
  visitFloat(props) {
    const { ["type"]: type, ["offset"]: offset = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length3 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
  }
  visitUtf8(props) {
    const { ["type"]: type, ["offset"]: offset = 0 } = props;
    const data = toUint8Array(props["data"]);
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const valueOffsets = toInt32Array(props["valueOffsets"]);
    const { ["length"]: length3 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [valueOffsets, data, nullBitmap]);
  }
  visitLargeUtf8(props) {
    const { ["type"]: type, ["offset"]: offset = 0 } = props;
    const data = toUint8Array(props["data"]);
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const valueOffsets = toBigInt64Array(props["valueOffsets"]);
    const { ["length"]: length3 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [valueOffsets, data, nullBitmap]);
  }
  visitBinary(props) {
    const { ["type"]: type, ["offset"]: offset = 0 } = props;
    const data = toUint8Array(props["data"]);
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const valueOffsets = toInt32Array(props["valueOffsets"]);
    const { ["length"]: length3 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [valueOffsets, data, nullBitmap]);
  }
  visitLargeBinary(props) {
    const { ["type"]: type, ["offset"]: offset = 0 } = props;
    const data = toUint8Array(props["data"]);
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const valueOffsets = toBigInt64Array(props["valueOffsets"]);
    const { ["length"]: length3 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [valueOffsets, data, nullBitmap]);
  }
  visitFixedSizeBinary(props) {
    const { ["type"]: type, ["offset"]: offset = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length3 = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
  }
  visitDate(props) {
    const { ["type"]: type, ["offset"]: offset = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length3 = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
  }
  visitTimestamp(props) {
    const { ["type"]: type, ["offset"]: offset = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length3 = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
  }
  visitTime(props) {
    const { ["type"]: type, ["offset"]: offset = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length3 = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
  }
  visitDecimal(props) {
    const { ["type"]: type, ["offset"]: offset = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length3 = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
  }
  visitList(props) {
    const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const valueOffsets = toInt32Array(props["valueOffsets"]);
    const { ["length"]: length3 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [valueOffsets, undefined, nullBitmap], [child]);
  }
  visitStruct(props) {
    const { ["type"]: type, ["offset"]: offset = 0, ["children"]: children2 = [] } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const { length: length3 = children2.reduce((len, { length: length4 }) => Math.max(len, length4), 0), nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [undefined, undefined, nullBitmap], children2);
  }
  visitUnion(props) {
    const { ["type"]: type, ["offset"]: offset = 0, ["children"]: children2 = [] } = props;
    const typeIds = toArrayBufferView(type.ArrayType, props["typeIds"]);
    const { ["length"]: length3 = typeIds.length, ["nullCount"]: nullCount = -1 } = props;
    if (DataType.isSparseUnion(type)) {
      return new Data(type, offset, length3, nullCount, [undefined, undefined, undefined, typeIds], children2);
    }
    const valueOffsets = toInt32Array(props["valueOffsets"]);
    return new Data(type, offset, length3, nullCount, [valueOffsets, undefined, undefined, typeIds], children2);
  }
  visitDictionary(props) {
    const { ["type"]: type, ["offset"]: offset = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type.indices.ArrayType, props["data"]);
    const { ["dictionary"]: dictionary = new Vector([new MakeDataVisitor().visit({ type: type.dictionary })]) } = props;
    const { ["length"]: length3 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap], [], dictionary);
  }
  visitInterval(props) {
    const { ["type"]: type, ["offset"]: offset = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length3 = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
  }
  visitDuration(props) {
    const { ["type"]: type, ["offset"]: offset = 0 } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const data = toArrayBufferView(type.ArrayType, props["data"]);
    const { ["length"]: length3 = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [undefined, data, nullBitmap]);
  }
  visitFixedSizeList(props) {
    const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child = new MakeDataVisitor().visit({ type: type.valueType }) } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const { ["length"]: length3 = child.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [undefined, undefined, nullBitmap], [child]);
  }
  visitMap(props) {
    const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child = new MakeDataVisitor().visit({ type: type.childType }) } = props;
    const nullBitmap = toUint8Array(props["nullBitmap"]);
    const valueOffsets = toInt32Array(props["valueOffsets"]);
    const { ["length"]: length3 = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
    return new Data(type, offset, length3, nullCount, [valueOffsets, undefined, nullBitmap], [child]);
  }
}
var makeDataVisitor = new MakeDataVisitor;
function makeData(props) {
  return makeDataVisitor.visit(props);
}

// node_modules/apache-arrow/util/chunk.mjs
class ChunkedIterator {
  constructor(numChunks = 0, getChunkIterator) {
    this.numChunks = numChunks;
    this.getChunkIterator = getChunkIterator;
    this.chunkIndex = 0;
    this.chunkIterator = this.getChunkIterator(0);
  }
  next() {
    while (this.chunkIndex < this.numChunks) {
      const next = this.chunkIterator.next();
      if (!next.done) {
        return next;
      }
      if (++this.chunkIndex < this.numChunks) {
        this.chunkIterator = this.getChunkIterator(this.chunkIndex);
      }
    }
    return { done: true, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
}
function computeChunkNullable(chunks3) {
  return chunks3.some((chunk3) => chunk3.nullable);
}
function computeChunkNullCounts(chunks3) {
  return chunks3.reduce((nullCount, chunk3) => nullCount + chunk3.nullCount, 0);
}
function computeChunkOffsets(chunks3) {
  return chunks3.reduce((offsets, chunk3, index) => {
    offsets[index + 1] = offsets[index] + chunk3.length;
    return offsets;
  }, new Uint32Array(chunks3.length + 1));
}
function sliceChunks(chunks3, offsets, begin, end6) {
  const slices = [];
  for (let i = -1, n = chunks3.length;++i < n; ) {
    const chunk3 = chunks3[i];
    const offset = offsets[i];
    const { length: length3 } = chunk3;
    if (offset >= end6) {
      break;
    }
    if (begin >= offset + length3) {
      continue;
    }
    if (offset >= begin && offset + length3 <= end6) {
      slices.push(chunk3);
      continue;
    }
    const from = Math.max(0, begin - offset);
    const to = Math.min(end6 - offset, length3);
    slices.push(chunk3.slice(from, to - from));
  }
  if (slices.length === 0) {
    slices.push(chunks3[0].slice(0, 0));
  }
  return slices;
}
function binarySearch(chunks3, offsets, idx, fn2) {
  let lhs = 0, mid = 0, rhs = offsets.length - 1;
  do {
    if (lhs >= rhs - 1) {
      return idx < offsets[rhs] ? fn2(chunks3, lhs, idx - offsets[lhs]) : null;
    }
    mid = lhs + Math.trunc((rhs - lhs) * 0.5);
    idx < offsets[mid] ? rhs = mid : lhs = mid;
  } while (lhs < rhs);
}
function isChunkedValid(data, index) {
  return data.getValid(index);
}
function wrapChunkedCall1(fn2) {
  function chunkedFn(chunks3, i, j) {
    return fn2(chunks3[i], j);
  }
  return function(index) {
    const data = this.data;
    return binarySearch(data, this._offsets, index, chunkedFn);
  };
}
function wrapChunkedCall2(fn2) {
  let _2;
  function chunkedFn(chunks3, i, j) {
    return fn2(chunks3[i], j, _2);
  }
  return function(index, value) {
    const data = this.data;
    _2 = value;
    const result = binarySearch(data, this._offsets, index, chunkedFn);
    _2 = undefined;
    return result;
  };
}
function wrapChunkedIndexOf(indexOf) {
  let _1;
  function chunkedIndexOf(data, chunkIndex, fromIndex) {
    let begin = fromIndex, index = 0, total = 0;
    for (let i = chunkIndex - 1, n = data.length;++i < n; ) {
      const chunk3 = data[i];
      if (~(index = indexOf(chunk3, _1, begin))) {
        return total + index;
      }
      begin = 0;
      total += chunk3.length;
    }
    return -1;
  }
  return function(element, offset) {
    _1 = element;
    const data = this.data;
    const result = typeof offset !== "number" ? chunkedIndexOf(data, 0, 0) : binarySearch(data, this._offsets, offset, chunkedIndexOf);
    _1 = undefined;
    return result;
  };
}

// node_modules/apache-arrow/visitor/indexof.mjs
class IndexOfVisitor extends Visitor {
}
function nullIndexOf(data, searchElement) {
  return searchElement === null && data.length > 0 ? 0 : -1;
}
function indexOfNull(data, fromIndex) {
  const { nullBitmap } = data;
  if (!nullBitmap || data.nullCount <= 0) {
    return -1;
  }
  let i = 0;
  for (const isValid2 of new BitIterator(nullBitmap, data.offset + (fromIndex || 0), data.length, nullBitmap, getBool2)) {
    if (!isValid2) {
      return i;
    }
    ++i;
  }
  return -1;
}
function indexOfValue(data, searchElement, fromIndex) {
  if (searchElement === undefined) {
    return -1;
  }
  if (searchElement === null) {
    switch (data.typeId) {
      case Type4.Union:
        break;
      case Type4.Dictionary:
        break;
      default:
        return indexOfNull(data, fromIndex);
    }
  }
  const get17 = instance2.getVisitFn(data);
  const compare2 = createElementComparator(searchElement);
  for (let i = (fromIndex || 0) - 1, n = data.length;++i < n; ) {
    if (compare2(get17(data, i))) {
      return i;
    }
  }
  return -1;
}
function indexOfUnion(data, searchElement, fromIndex) {
  const get17 = instance2.getVisitFn(data);
  const compare2 = createElementComparator(searchElement);
  for (let i = (fromIndex || 0) - 1, n = data.length;++i < n; ) {
    if (compare2(get17(data, i))) {
      return i;
    }
  }
  return -1;
}
IndexOfVisitor.prototype.visitNull = nullIndexOf;
IndexOfVisitor.prototype.visitBool = indexOfValue;
IndexOfVisitor.prototype.visitInt = indexOfValue;
IndexOfVisitor.prototype.visitInt8 = indexOfValue;
IndexOfVisitor.prototype.visitInt16 = indexOfValue;
IndexOfVisitor.prototype.visitInt32 = indexOfValue;
IndexOfVisitor.prototype.visitInt64 = indexOfValue;
IndexOfVisitor.prototype.visitUint8 = indexOfValue;
IndexOfVisitor.prototype.visitUint16 = indexOfValue;
IndexOfVisitor.prototype.visitUint32 = indexOfValue;
IndexOfVisitor.prototype.visitUint64 = indexOfValue;
IndexOfVisitor.prototype.visitFloat = indexOfValue;
IndexOfVisitor.prototype.visitFloat16 = indexOfValue;
IndexOfVisitor.prototype.visitFloat32 = indexOfValue;
IndexOfVisitor.prototype.visitFloat64 = indexOfValue;
IndexOfVisitor.prototype.visitUtf8 = indexOfValue;
IndexOfVisitor.prototype.visitLargeUtf8 = indexOfValue;
IndexOfVisitor.prototype.visitBinary = indexOfValue;
IndexOfVisitor.prototype.visitLargeBinary = indexOfValue;
IndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;
IndexOfVisitor.prototype.visitDate = indexOfValue;
IndexOfVisitor.prototype.visitDateDay = indexOfValue;
IndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestamp = indexOfValue;
IndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitTime = indexOfValue;
IndexOfVisitor.prototype.visitTimeSecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitDecimal = indexOfValue;
IndexOfVisitor.prototype.visitList = indexOfValue;
IndexOfVisitor.prototype.visitStruct = indexOfValue;
IndexOfVisitor.prototype.visitUnion = indexOfValue;
IndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;
IndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;
IndexOfVisitor.prototype.visitDictionary = indexOfValue;
IndexOfVisitor.prototype.visitInterval = indexOfValue;
IndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;
IndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;
IndexOfVisitor.prototype.visitIntervalMonthDayNano = indexOfValue;
IndexOfVisitor.prototype.visitDuration = indexOfValue;
IndexOfVisitor.prototype.visitDurationSecond = indexOfValue;
IndexOfVisitor.prototype.visitDurationMillisecond = indexOfValue;
IndexOfVisitor.prototype.visitDurationMicrosecond = indexOfValue;
IndexOfVisitor.prototype.visitDurationNanosecond = indexOfValue;
IndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;
IndexOfVisitor.prototype.visitMap = indexOfValue;
var instance3 = new IndexOfVisitor;

// node_modules/apache-arrow/visitor/iterator.mjs
class IteratorVisitor extends Visitor {
}
function vectorIterator(vector) {
  const { type } = vector;
  if (vector.nullCount === 0 && vector.stride === 1 && (DataType.isInt(type) && type.bitWidth !== 64 || DataType.isTime(type) && type.bitWidth !== 64 || DataType.isFloat(type) && type.precision !== Precision.HALF)) {
    return new ChunkedIterator(vector.data.length, (chunkIndex) => {
      const data = vector.data[chunkIndex];
      return data.values.subarray(0, data.length)[Symbol.iterator]();
    });
  }
  let offset = 0;
  return new ChunkedIterator(vector.data.length, (chunkIndex) => {
    const data = vector.data[chunkIndex];
    const length3 = data.length;
    const inner = vector.slice(offset, offset + length3);
    offset += length3;
    return new VectorIterator(inner);
  });
}

class VectorIterator {
  constructor(vector) {
    this.vector = vector;
    this.index = 0;
  }
  next() {
    if (this.index < this.vector.length) {
      return {
        value: this.vector.get(this.index++)
      };
    }
    return { done: true, value: null };
  }
  [Symbol.iterator]() {
    return this;
  }
}
IteratorVisitor.prototype.visitNull = vectorIterator;
IteratorVisitor.prototype.visitBool = vectorIterator;
IteratorVisitor.prototype.visitInt = vectorIterator;
IteratorVisitor.prototype.visitInt8 = vectorIterator;
IteratorVisitor.prototype.visitInt16 = vectorIterator;
IteratorVisitor.prototype.visitInt32 = vectorIterator;
IteratorVisitor.prototype.visitInt64 = vectorIterator;
IteratorVisitor.prototype.visitUint8 = vectorIterator;
IteratorVisitor.prototype.visitUint16 = vectorIterator;
IteratorVisitor.prototype.visitUint32 = vectorIterator;
IteratorVisitor.prototype.visitUint64 = vectorIterator;
IteratorVisitor.prototype.visitFloat = vectorIterator;
IteratorVisitor.prototype.visitFloat16 = vectorIterator;
IteratorVisitor.prototype.visitFloat32 = vectorIterator;
IteratorVisitor.prototype.visitFloat64 = vectorIterator;
IteratorVisitor.prototype.visitUtf8 = vectorIterator;
IteratorVisitor.prototype.visitLargeUtf8 = vectorIterator;
IteratorVisitor.prototype.visitBinary = vectorIterator;
IteratorVisitor.prototype.visitLargeBinary = vectorIterator;
IteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;
IteratorVisitor.prototype.visitDate = vectorIterator;
IteratorVisitor.prototype.visitDateDay = vectorIterator;
IteratorVisitor.prototype.visitDateMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimestamp = vectorIterator;
IteratorVisitor.prototype.visitTimestampSecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;
IteratorVisitor.prototype.visitTime = vectorIterator;
IteratorVisitor.prototype.visitTimeSecond = vectorIterator;
IteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;
IteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;
IteratorVisitor.prototype.visitDecimal = vectorIterator;
IteratorVisitor.prototype.visitList = vectorIterator;
IteratorVisitor.prototype.visitStruct = vectorIterator;
IteratorVisitor.prototype.visitUnion = vectorIterator;
IteratorVisitor.prototype.visitDenseUnion = vectorIterator;
IteratorVisitor.prototype.visitSparseUnion = vectorIterator;
IteratorVisitor.prototype.visitDictionary = vectorIterator;
IteratorVisitor.prototype.visitInterval = vectorIterator;
IteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;
IteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;
IteratorVisitor.prototype.visitIntervalMonthDayNano = vectorIterator;
IteratorVisitor.prototype.visitDuration = vectorIterator;
IteratorVisitor.prototype.visitDurationSecond = vectorIterator;
IteratorVisitor.prototype.visitDurationMillisecond = vectorIterator;
IteratorVisitor.prototype.visitDurationMicrosecond = vectorIterator;
IteratorVisitor.prototype.visitDurationNanosecond = vectorIterator;
IteratorVisitor.prototype.visitFixedSizeList = vectorIterator;
IteratorVisitor.prototype.visitMap = vectorIterator;
var instance4 = new IteratorVisitor;

// node_modules/apache-arrow/vector.mjs
var _a2;
var visitorsByTypeId = {};
var vectorPrototypesByTypeId = {};

class Vector {
  constructor(input) {
    var _b2, _c2, _d2;
    const data = input[0] instanceof Vector ? input.flatMap((x) => x.data) : input;
    if (data.length === 0 || data.some((x) => !(x instanceof Data))) {
      throw new TypeError("Vector constructor expects an Array of Data instances.");
    }
    const type = (_b2 = data[0]) === null || _b2 === undefined ? undefined : _b2.type;
    switch (data.length) {
      case 0:
        this._offsets = [0];
        break;
      case 1: {
        const { get: get17, set: set8, indexOf } = visitorsByTypeId[type.typeId];
        const unchunkedData = data[0];
        this.isValid = (index) => isChunkedValid(unchunkedData, index);
        this.get = (index) => get17(unchunkedData, index);
        this.set = (index, value) => set8(unchunkedData, index, value);
        this.indexOf = (index) => indexOf(unchunkedData, index);
        this._offsets = [0, unchunkedData.length];
        break;
      }
      default:
        Object.setPrototypeOf(this, vectorPrototypesByTypeId[type.typeId]);
        this._offsets = computeChunkOffsets(data);
        break;
    }
    this.data = data;
    this.type = type;
    this.stride = strideForType(type);
    this.numChildren = (_d2 = (_c2 = type.children) === null || _c2 === undefined ? undefined : _c2.length) !== null && _d2 !== undefined ? _d2 : 0;
    this.length = this._offsets.at(-1);
  }
  get byteLength() {
    return this.data.reduce((byteLength, data) => byteLength + data.byteLength, 0);
  }
  get nullable() {
    return computeChunkNullable(this.data);
  }
  get nullCount() {
    return computeChunkNullCounts(this.data);
  }
  get ArrayType() {
    return this.type.ArrayType;
  }
  get [Symbol.toStringTag]() {
    return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
  }
  get VectorName() {
    return `${Type4[this.type.typeId]}Vector`;
  }
  isValid(index) {
    return false;
  }
  get(index) {
    return null;
  }
  at(index) {
    return this.get(wrapIndex(index, this.length));
  }
  set(index, value) {
    return;
  }
  indexOf(element, offset) {
    return -1;
  }
  includes(element, offset) {
    return this.indexOf(element, offset) > -1;
  }
  [Symbol.iterator]() {
    return instance4.visit(this);
  }
  concat(...others) {
    return new Vector(this.data.concat(others.flatMap((x) => x.data).flat(Number.POSITIVE_INFINITY)));
  }
  slice(begin, end6) {
    return new Vector(clampRange(this, begin, end6, ({ data, _offsets }, begin2, end7) => sliceChunks(data, _offsets, begin2, end7)));
  }
  toJSON() {
    return [...this];
  }
  toArray() {
    const { type, data, length: length3, stride, ArrayType } = this;
    switch (type.typeId) {
      case Type4.Int:
      case Type4.Float:
      case Type4.Decimal:
      case Type4.Time:
      case Type4.Timestamp:
        switch (data.length) {
          case 0:
            return new ArrayType;
          case 1:
            return data[0].values.subarray(0, length3 * stride);
          default:
            return data.reduce((memo, { values: values3, length: chunk_length }) => {
              memo.array.set(values3.subarray(0, chunk_length * stride), memo.offset);
              memo.offset += chunk_length * stride;
              return memo;
            }, { array: new ArrayType(length3 * stride), offset: 0 }).array;
        }
    }
    return [...this];
  }
  toString() {
    return `[${[...this].join(",")}]`;
  }
  getChild(name) {
    var _b2;
    return this.getChildAt((_b2 = this.type.children) === null || _b2 === undefined ? undefined : _b2.findIndex((f) => f.name === name));
  }
  getChildAt(index) {
    if (index > -1 && index < this.numChildren) {
      return new Vector(this.data.map(({ children: children2 }) => children2[index]));
    }
    return null;
  }
  get isMemoized() {
    if (DataType.isDictionary(this.type)) {
      return this.data[0].dictionary.isMemoized;
    }
    return false;
  }
  memoize() {
    if (DataType.isDictionary(this.type)) {
      const dictionary = new MemoizedVector(this.data[0].dictionary);
      const newData = this.data.map((data) => {
        const cloned = data.clone();
        cloned.dictionary = dictionary;
        return cloned;
      });
      return new Vector(newData);
    }
    return new MemoizedVector(this);
  }
  unmemoize() {
    if (DataType.isDictionary(this.type) && this.isMemoized) {
      const dictionary = this.data[0].dictionary.unmemoize();
      const newData = this.data.map((data) => {
        const newData2 = data.clone();
        newData2.dictionary = dictionary;
        return newData2;
      });
      return new Vector(newData);
    }
    return this;
  }
}
_a2 = Symbol.toStringTag;
Vector[_a2] = ((proto12) => {
  proto12.type = DataType.prototype;
  proto12.data = [];
  proto12.length = 0;
  proto12.stride = 1;
  proto12.numChildren = 0;
  proto12._offsets = new Uint32Array([0]);
  proto12[Symbol.isConcatSpreadable] = true;
  const typeIds = Object.keys(Type4).map((T) => Type4[T]).filter((T) => typeof T === "number" && T !== Type4.NONE);
  for (const typeId of typeIds) {
    const get17 = instance2.getVisitFnByTypeId(typeId);
    const set8 = instance.getVisitFnByTypeId(typeId);
    const indexOf = instance3.getVisitFnByTypeId(typeId);
    visitorsByTypeId[typeId] = { get: get17, set: set8, indexOf };
    vectorPrototypesByTypeId[typeId] = Object.create(proto12, {
      ["isValid"]: { value: wrapChunkedCall1(isChunkedValid) },
      ["get"]: { value: wrapChunkedCall1(instance2.getVisitFnByTypeId(typeId)) },
      ["set"]: { value: wrapChunkedCall2(instance.getVisitFnByTypeId(typeId)) },
      ["indexOf"]: { value: wrapChunkedIndexOf(instance3.getVisitFnByTypeId(typeId)) }
    });
  }
  return "Vector";
})(Vector.prototype);

class MemoizedVector extends Vector {
  constructor(vector) {
    super(vector.data);
    const get17 = this.get;
    const set8 = this.set;
    const slice = this.slice;
    const cache = new Array(this.length);
    Object.defineProperty(this, "get", {
      value(index) {
        const cachedValue = cache[index];
        if (cachedValue !== undefined) {
          return cachedValue;
        }
        const value = get17.call(this, index);
        cache[index] = value;
        return value;
      }
    });
    Object.defineProperty(this, "set", {
      value(index, value) {
        set8.call(this, index, value);
        cache[index] = value;
      }
    });
    Object.defineProperty(this, "slice", {
      value: (begin, end6) => new MemoizedVector(slice.call(this, begin, end6))
    });
    Object.defineProperty(this, "isMemoized", { value: true });
    Object.defineProperty(this, "unmemoize", {
      value: () => new Vector(this.data)
    });
    Object.defineProperty(this, "memoize", {
      value: () => this
    });
  }
}

// node_modules/apache-arrow/builder/valid.mjs
function createIsValidFunction(nullValues) {
  if (!nullValues || nullValues.length <= 0) {
    return function isValid(value) {
      return true;
    };
  }
  let fnBody = "";
  const noNaNs = nullValues.filter((x) => x === x);
  if (noNaNs.length > 0) {
    fnBody = `
    switch (x) {${noNaNs.map((x) => `
        case ${valueToCase(x)}:`).join("")}
            return false;
    }`;
  }
  if (nullValues.length !== noNaNs.length) {
    fnBody = `if (x !== x) return false;
${fnBody}`;
  }
  return new Function(`x`, `${fnBody}
return true;`);
}
function valueToCase(x) {
  if (typeof x !== "bigint") {
    return valueToString(x);
  }
  return `${valueToString(x)}n`;
}

// node_modules/apache-arrow/builder/buffer.mjs
function roundLengthUpToNearest64Bytes(len, BPE) {
  const bytesMinus1 = Math.ceil(len) * BPE - 1;
  return (bytesMinus1 - bytesMinus1 % 64 + 64 || 64) / BPE;
}
function resizeArray(arr, len = 0) {
  return arr.length >= len ? arr.subarray(0, len) : memcpy(new arr.constructor(len), arr, 0);
}

class BufferBuilder {
  constructor(bufferType, initialSize = 0, stride = 1) {
    this.length = Math.ceil(initialSize / stride);
    this.buffer = new bufferType(this.length);
    this.stride = stride;
    this.BYTES_PER_ELEMENT = bufferType.BYTES_PER_ELEMENT;
    this.ArrayType = bufferType;
  }
  get byteLength() {
    return Math.ceil(this.length * this.stride) * this.BYTES_PER_ELEMENT;
  }
  get reservedLength() {
    return this.buffer.length / this.stride;
  }
  get reservedByteLength() {
    return this.buffer.byteLength;
  }
  set(index, value) {
    return this;
  }
  append(value) {
    return this.set(this.length, value);
  }
  reserve(extra) {
    if (extra > 0) {
      this.length += extra;
      const stride = this.stride;
      const length3 = this.length * stride;
      const reserved = this.buffer.length;
      if (length3 >= reserved) {
        this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes(length3 * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes(length3 * 2, this.BYTES_PER_ELEMENT));
      }
    }
    return this;
  }
  flush(length3 = this.length) {
    length3 = roundLengthUpToNearest64Bytes(length3 * this.stride, this.BYTES_PER_ELEMENT);
    const array4 = resizeArray(this.buffer, length3);
    this.clear();
    return array4;
  }
  clear() {
    this.length = 0;
    this.buffer = new this.ArrayType;
    return this;
  }
  _resize(newLength) {
    return this.buffer = resizeArray(this.buffer, newLength);
  }
}

class DataBufferBuilder extends BufferBuilder {
  last() {
    return this.get(this.length - 1);
  }
  get(index) {
    return this.buffer[index];
  }
  set(index, value) {
    this.reserve(index - this.length + 1);
    this.buffer[index * this.stride] = value;
    return this;
  }
}

class BitmapBufferBuilder extends DataBufferBuilder {
  constructor() {
    super(Uint8Array, 0, 1 / 8);
    this.numValid = 0;
  }
  get numInvalid() {
    return this.length - this.numValid;
  }
  get(idx) {
    return this.buffer[idx >> 3] >> idx % 8 & 1;
  }
  set(idx, val) {
    const { buffer: buffer3 } = this.reserve(idx - this.length + 1);
    const byte = idx >> 3, bit = idx % 8, cur = buffer3[byte] >> bit & 1;
    val ? cur === 0 && (buffer3[byte] |= 1 << bit, ++this.numValid) : cur === 1 && (buffer3[byte] &= ~(1 << bit), --this.numValid);
    return this;
  }
  clear() {
    this.numValid = 0;
    return super.clear();
  }
}

class OffsetsBufferBuilder extends DataBufferBuilder {
  constructor(type) {
    super(type.OffsetArrayType, 1, 1);
  }
  append(value) {
    return this.set(this.length - 1, value);
  }
  set(index, value) {
    const offset = this.length - 1;
    const buffer3 = this.reserve(index - offset + 1).buffer;
    if (offset < index++ && offset >= 0) {
      buffer3.fill(buffer3[offset], offset, index);
    }
    buffer3[index] = buffer3[index - 1] + value;
    return this;
  }
  flush(length3 = this.length - 1) {
    if (length3 > this.length) {
      this.set(length3 - 1, this.BYTES_PER_ELEMENT > 4 ? BigInt(0) : 0);
    }
    return super.flush(length3 + 1);
  }
}

// node_modules/apache-arrow/builder.mjs
class Builder2 {
  static throughNode(options) {
    throw new Error(`"throughNode" not available in this environment`);
  }
  static throughDOM(options) {
    throw new Error(`"throughDOM" not available in this environment`);
  }
  constructor({ type, nullValues: nulls }) {
    this.length = 0;
    this.finished = false;
    this.type = type;
    this.children = [];
    this.nullValues = nulls;
    this.stride = strideForType(type);
    this._nulls = new BitmapBufferBuilder;
    if (nulls && nulls.length > 0) {
      this._isValid = createIsValidFunction(nulls);
    }
  }
  toVector() {
    return new Vector([this.flush()]);
  }
  get ArrayType() {
    return this.type.ArrayType;
  }
  get nullCount() {
    return this._nulls.numInvalid;
  }
  get numChildren() {
    return this.children.length;
  }
  get byteLength() {
    let size13 = 0;
    const { _offsets, _values, _nulls, _typeIds, children: children2 } = this;
    _offsets && (size13 += _offsets.byteLength);
    _values && (size13 += _values.byteLength);
    _nulls && (size13 += _nulls.byteLength);
    _typeIds && (size13 += _typeIds.byteLength);
    return children2.reduce((size14, child) => size14 + child.byteLength, size13);
  }
  get reservedLength() {
    return this._nulls.reservedLength;
  }
  get reservedByteLength() {
    let size13 = 0;
    this._offsets && (size13 += this._offsets.reservedByteLength);
    this._values && (size13 += this._values.reservedByteLength);
    this._nulls && (size13 += this._nulls.reservedByteLength);
    this._typeIds && (size13 += this._typeIds.reservedByteLength);
    return this.children.reduce((size14, child) => size14 + child.reservedByteLength, size13);
  }
  get valueOffsets() {
    return this._offsets ? this._offsets.buffer : null;
  }
  get values() {
    return this._values ? this._values.buffer : null;
  }
  get nullBitmap() {
    return this._nulls ? this._nulls.buffer : null;
  }
  get typeIds() {
    return this._typeIds ? this._typeIds.buffer : null;
  }
  append(value) {
    return this.set(this.length, value);
  }
  isValid(value) {
    return this._isValid(value);
  }
  set(index, value) {
    if (this.setValid(index, this.isValid(value))) {
      this.setValue(index, value);
    }
    return this;
  }
  setValue(index, value) {
    this._setValue(this, index, value);
  }
  setValid(index, valid) {
    this.length = this._nulls.set(index, +valid).length;
    return valid;
  }
  addChild(child, name = `${this.numChildren}`) {
    throw new Error(`Cannot append children to non-nested type "${this.type}"`);
  }
  getChildAt(index) {
    return this.children[index] || null;
  }
  flush() {
    let data;
    let typeIds;
    let nullBitmap;
    let valueOffsets;
    const { type, length: length3, nullCount, _typeIds, _offsets, _values, _nulls } = this;
    if (typeIds = _typeIds === null || _typeIds === undefined ? undefined : _typeIds.flush(length3)) {
      valueOffsets = _offsets === null || _offsets === undefined ? undefined : _offsets.flush(length3);
    } else if (valueOffsets = _offsets === null || _offsets === undefined ? undefined : _offsets.flush(length3)) {
      data = _values === null || _values === undefined ? undefined : _values.flush(_offsets.last());
    } else {
      data = _values === null || _values === undefined ? undefined : _values.flush(length3);
    }
    if (nullCount > 0) {
      nullBitmap = _nulls === null || _nulls === undefined ? undefined : _nulls.flush(length3);
    }
    const children2 = this.children.map((child) => child.flush());
    this.clear();
    return makeData({
      type,
      length: length3,
      nullCount,
      children: children2,
      child: children2[0],
      data,
      typeIds,
      nullBitmap,
      valueOffsets
    });
  }
  finish() {
    this.finished = true;
    for (const child of this.children)
      child.finish();
    return this;
  }
  clear() {
    var _a3, _b2, _c2, _d2;
    this.length = 0;
    (_a3 = this._nulls) === null || _a3 === undefined || _a3.clear();
    (_b2 = this._values) === null || _b2 === undefined || _b2.clear();
    (_c2 = this._offsets) === null || _c2 === undefined || _c2.clear();
    (_d2 = this._typeIds) === null || _d2 === undefined || _d2.clear();
    for (const child of this.children)
      child.clear();
    return this;
  }
}
Builder2.prototype.length = 1;
Builder2.prototype.stride = 1;
Builder2.prototype.children = null;
Builder2.prototype.finished = false;
Builder2.prototype.nullValues = null;
Builder2.prototype._isValid = () => true;

class FixedWidthBuilder extends Builder2 {
  constructor(opts) {
    super(opts);
    this._values = new DataBufferBuilder(this.ArrayType, 0, this.stride);
  }
  setValue(index, value) {
    const values3 = this._values;
    values3.reserve(index - values3.length + 1);
    return super.setValue(index, value);
  }
}

class VariableWidthBuilder extends Builder2 {
  constructor(opts) {
    super(opts);
    this._pendingLength = 0;
    this._offsets = new OffsetsBufferBuilder(opts.type);
  }
  setValue(index, value) {
    const pending3 = this._pending || (this._pending = new Map);
    const current2 = pending3.get(index);
    current2 && (this._pendingLength -= current2.length);
    this._pendingLength += value instanceof MapRow ? value[kKeys].length : value.length;
    pending3.set(index, value);
  }
  setValid(index, isValid2) {
    if (!super.setValid(index, isValid2)) {
      (this._pending || (this._pending = new Map)).set(index, undefined);
      return false;
    }
    return true;
  }
  clear() {
    this._pendingLength = 0;
    this._pending = undefined;
    return super.clear();
  }
  flush() {
    this._flush();
    return super.flush();
  }
  finish() {
    this._flush();
    return super.finish();
  }
  _flush() {
    const pending3 = this._pending;
    const pendingLength = this._pendingLength;
    this._pendingLength = 0;
    this._pending = undefined;
    if (pending3 && pending3.size > 0) {
      this._flushPending(pending3, pendingLength);
    }
    return this;
  }
}

// node_modules/apache-arrow/fb/block.mjs
class Block {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  offset() {
    return this.bb.readInt64(this.bb_pos);
  }
  metaDataLength() {
    return this.bb.readInt32(this.bb_pos + 8);
  }
  bodyLength() {
    return this.bb.readInt64(this.bb_pos + 16);
  }
  static sizeOf() {
    return 24;
  }
  static createBlock(builder, offset, metaDataLength, bodyLength) {
    builder.prep(8, 24);
    builder.writeInt64(BigInt(bodyLength !== null && bodyLength !== undefined ? bodyLength : 0));
    builder.pad(4);
    builder.writeInt32(metaDataLength);
    builder.writeInt64(BigInt(offset !== null && offset !== undefined ? offset : 0));
    return builder.offset();
  }
}

// node_modules/apache-arrow/fb/footer.mjs
class Footer {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsFooter(bb, obj) {
    return (obj || new Footer).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsFooter(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Footer).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  version() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readInt16(this.bb_pos + offset) : MetadataVersion.V1;
  }
  schema(obj) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? (obj || new Schema2).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
  }
  dictionaries(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? (obj || new Block).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
  }
  dictionariesLength() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  recordBatches(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? (obj || new Block).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
  }
  recordBatchesLength() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  customMetadata(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? (obj || new KeyValue).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
  }
  customMetadataLength() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startFooter(builder) {
    builder.startObject(5);
  }
  static addVersion(builder, version) {
    builder.addFieldInt16(0, version, MetadataVersion.V1);
  }
  static addSchema(builder, schemaOffset) {
    builder.addFieldOffset(1, schemaOffset, 0);
  }
  static addDictionaries(builder, dictionariesOffset) {
    builder.addFieldOffset(2, dictionariesOffset, 0);
  }
  static startDictionariesVector(builder, numElems) {
    builder.startVector(24, numElems, 8);
  }
  static addRecordBatches(builder, recordBatchesOffset) {
    builder.addFieldOffset(3, recordBatchesOffset, 0);
  }
  static startRecordBatchesVector(builder, numElems) {
    builder.startVector(24, numElems, 8);
  }
  static addCustomMetadata(builder, customMetadataOffset) {
    builder.addFieldOffset(4, customMetadataOffset, 0);
  }
  static createCustomMetadataVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1;i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startCustomMetadataVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endFooter(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishFooterBuffer(builder, offset) {
    builder.finish(offset);
  }
  static finishSizePrefixedFooterBuffer(builder, offset) {
    builder.finish(offset, undefined, true);
  }
}

// node_modules/apache-arrow/schema.mjs
class Schema3 {
  constructor(fields = [], metadata, dictionaries, metadataVersion = MetadataVersion.V5) {
    this.fields = fields || [];
    this.metadata = metadata || new Map;
    if (!dictionaries) {
      dictionaries = generateDictionaryMap(this.fields);
    }
    this.dictionaries = dictionaries;
    this.metadataVersion = metadataVersion;
  }
  get [Symbol.toStringTag]() {
    return "Schema";
  }
  get names() {
    return this.fields.map((f) => f.name);
  }
  toString() {
    return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(", ")} }>`;
  }
  select(fieldNames) {
    const names = new Set(fieldNames);
    const fields = this.fields.filter((f) => names.has(f.name));
    return new Schema3(fields, this.metadata);
  }
  selectAt(fieldIndices) {
    const fields = fieldIndices.map((i) => this.fields[i]).filter(Boolean);
    return new Schema3(fields, this.metadata);
  }
  assign(...args2) {
    const other = args2[0] instanceof Schema3 ? args2[0] : Array.isArray(args2[0]) ? new Schema3(args2[0]) : new Schema3(args2);
    const curFields = [...this.fields];
    const metadata = mergeMaps(mergeMaps(new Map, this.metadata), other.metadata);
    const newFields = other.fields.filter((f2) => {
      const i = curFields.findIndex((f) => f.name === f2.name);
      return ~i ? (curFields[i] = f2.clone({
        metadata: mergeMaps(mergeMaps(new Map, curFields[i].metadata), f2.metadata)
      })) && false : true;
    });
    const newDictionaries = generateDictionaryMap(newFields, new Map);
    return new Schema3([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));
  }
}
Schema3.prototype.fields = null;
Schema3.prototype.metadata = null;
Schema3.prototype.dictionaries = null;

class Field2 {
  static new(...args2) {
    let [name, type, nullable, metadata] = args2;
    if (args2[0] && typeof args2[0] === "object") {
      ({ name } = args2[0]);
      type === undefined && (type = args2[0].type);
      nullable === undefined && (nullable = args2[0].nullable);
      metadata === undefined && (metadata = args2[0].metadata);
    }
    return new Field2(`${name}`, type, nullable, metadata);
  }
  constructor(name, type, nullable = false, metadata) {
    this.name = name;
    this.type = type;
    this.nullable = nullable;
    this.metadata = metadata || new Map;
  }
  get typeId() {
    return this.type.typeId;
  }
  get [Symbol.toStringTag]() {
    return "Field";
  }
  toString() {
    return `${this.name}: ${this.type}`;
  }
  clone(...args2) {
    let [name, type, nullable, metadata] = args2;
    !args2[0] || typeof args2[0] !== "object" ? [name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args2 : { name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata } = args2[0];
    return Field2.new(name, type, nullable, metadata);
  }
}
Field2.prototype.type = null;
Field2.prototype.name = null;
Field2.prototype.nullable = null;
Field2.prototype.metadata = null;
function mergeMaps(m1, m2) {
  return new Map([...m1 || new Map, ...m2 || new Map]);
}
function generateDictionaryMap(fields, dictionaries = new Map) {
  for (let i = -1, n = fields.length;++i < n; ) {
    const field = fields[i];
    const type = field.type;
    if (DataType.isDictionary(type)) {
      if (!dictionaries.has(type.id)) {
        dictionaries.set(type.id, type.dictionary);
      } else if (dictionaries.get(type.id) !== type.dictionary) {
        throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
      }
    }
    if (type.children && type.children.length > 0) {
      generateDictionaryMap(type.children, dictionaries);
    }
  }
  return dictionaries;
}

// node_modules/apache-arrow/ipc/metadata/file.mjs
var Builder3 = Builder;
var ByteBuffer2 = ByteBuffer;

class Footer_ {
  static decode(buf) {
    buf = new ByteBuffer2(toUint8Array(buf));
    const footer = Footer.getRootAsFooter(buf);
    const schema = Schema3.decode(footer.schema(), new Map, footer.version());
    return new OffHeapFooter(schema, footer);
  }
  static encode(footer) {
    const b = new Builder3;
    const schemaOffset = Schema3.encode(b, footer.schema);
    Footer.startRecordBatchesVector(b, footer.numRecordBatches);
    for (const rb of [...footer.recordBatches()].slice().reverse()) {
      FileBlock.encode(b, rb);
    }
    const recordBatchesOffset = b.endVector();
    Footer.startDictionariesVector(b, footer.numDictionaries);
    for (const db of [...footer.dictionaryBatches()].slice().reverse()) {
      FileBlock.encode(b, db);
    }
    const dictionaryBatchesOffset = b.endVector();
    Footer.startFooter(b);
    Footer.addSchema(b, schemaOffset);
    Footer.addVersion(b, MetadataVersion.V5);
    Footer.addRecordBatches(b, recordBatchesOffset);
    Footer.addDictionaries(b, dictionaryBatchesOffset);
    Footer.finishFooterBuffer(b, Footer.endFooter(b));
    return b.asUint8Array();
  }
  get numRecordBatches() {
    return this._recordBatches.length;
  }
  get numDictionaries() {
    return this._dictionaryBatches.length;
  }
  constructor(schema, version = MetadataVersion.V5, recordBatches, dictionaryBatches) {
    this.schema = schema;
    this.version = version;
    recordBatches && (this._recordBatches = recordBatches);
    dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);
  }
  *recordBatches() {
    for (let block, i = -1, n = this.numRecordBatches;++i < n; ) {
      if (block = this.getRecordBatch(i)) {
        yield block;
      }
    }
  }
  *dictionaryBatches() {
    for (let block, i = -1, n = this.numDictionaries;++i < n; ) {
      if (block = this.getDictionaryBatch(i)) {
        yield block;
      }
    }
  }
  getRecordBatch(index) {
    return index >= 0 && index < this.numRecordBatches && this._recordBatches[index] || null;
  }
  getDictionaryBatch(index) {
    return index >= 0 && index < this.numDictionaries && this._dictionaryBatches[index] || null;
  }
}
class OffHeapFooter extends Footer_ {
  get numRecordBatches() {
    return this._footer.recordBatchesLength();
  }
  get numDictionaries() {
    return this._footer.dictionariesLength();
  }
  constructor(schema, _footer) {
    super(schema, _footer.version());
    this._footer = _footer;
  }
  getRecordBatch(index) {
    if (index >= 0 && index < this.numRecordBatches) {
      const fileBlock = this._footer.recordBatches(index);
      if (fileBlock) {
        return FileBlock.decode(fileBlock);
      }
    }
    return null;
  }
  getDictionaryBatch(index) {
    if (index >= 0 && index < this.numDictionaries) {
      const fileBlock = this._footer.dictionaries(index);
      if (fileBlock) {
        return FileBlock.decode(fileBlock);
      }
    }
    return null;
  }
}

class FileBlock {
  static decode(block) {
    return new FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());
  }
  static encode(b, fileBlock) {
    const { metaDataLength } = fileBlock;
    const offset = BigInt(fileBlock.offset);
    const bodyLength = BigInt(fileBlock.bodyLength);
    return Block.createBlock(b, offset, metaDataLength, bodyLength);
  }
  constructor(metaDataLength, bodyLength, offset) {
    this.metaDataLength = metaDataLength;
    this.offset = bigIntToNumber(offset);
    this.bodyLength = bigIntToNumber(bodyLength);
  }
}

// node_modules/apache-arrow/fb/message.mjs
class Message {
  constructor() {
    this.bb = null;
    this.bb_pos = 0;
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsMessage(bb, obj) {
    return (obj || new Message).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsMessage(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Message).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  version() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readInt16(this.bb_pos + offset) : MetadataVersion.V1;
  }
  headerType() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readUint8(this.bb_pos + offset) : MessageHeader.NONE;
  }
  header(obj) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
  }
  bodyLength() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
  }
  customMetadata(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? (obj || new KeyValue).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
  }
  customMetadataLength() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startMessage(builder) {
    builder.startObject(5);
  }
  static addVersion(builder, version) {
    builder.addFieldInt16(0, version, MetadataVersion.V1);
  }
  static addHeaderType(builder, headerType) {
    builder.addFieldInt8(1, headerType, MessageHeader.NONE);
  }
  static addHeader(builder, headerOffset) {
    builder.addFieldOffset(2, headerOffset, 0);
  }
  static addBodyLength(builder, bodyLength) {
    builder.addFieldInt64(3, bodyLength, BigInt("0"));
  }
  static addCustomMetadata(builder, customMetadataOffset) {
    builder.addFieldOffset(4, customMetadataOffset, 0);
  }
  static createCustomMetadataVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1;i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startCustomMetadataVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endMessage(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishMessageBuffer(builder, offset) {
    builder.finish(offset);
  }
  static finishSizePrefixedMessageBuffer(builder, offset) {
    builder.finish(offset, undefined, true);
  }
  static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {
    Message.startMessage(builder);
    Message.addVersion(builder, version);
    Message.addHeaderType(builder, headerType);
    Message.addHeader(builder, headerOffset);
    Message.addBodyLength(builder, bodyLength);
    Message.addCustomMetadata(builder, customMetadataOffset);
    return Message.endMessage(builder);
  }
}

// node_modules/apache-arrow/visitor/typeassembler.mjs
class TypeAssembler extends Visitor {
  visit(node, builder) {
    return node == null || builder == null ? undefined : super.visit(node, builder);
  }
  visitNull(_node, b) {
    Null.startNull(b);
    return Null.endNull(b);
  }
  visitInt(node, b) {
    Int.startInt(b);
    Int.addBitWidth(b, node.bitWidth);
    Int.addIsSigned(b, node.isSigned);
    return Int.endInt(b);
  }
  visitFloat(node, b) {
    FloatingPoint.startFloatingPoint(b);
    FloatingPoint.addPrecision(b, node.precision);
    return FloatingPoint.endFloatingPoint(b);
  }
  visitBinary(_node, b) {
    Binary.startBinary(b);
    return Binary.endBinary(b);
  }
  visitLargeBinary(_node, b) {
    LargeBinary.startLargeBinary(b);
    return LargeBinary.endLargeBinary(b);
  }
  visitBool(_node, b) {
    Bool.startBool(b);
    return Bool.endBool(b);
  }
  visitUtf8(_node, b) {
    Utf8.startUtf8(b);
    return Utf8.endUtf8(b);
  }
  visitLargeUtf8(_node, b) {
    LargeUtf8.startLargeUtf8(b);
    return LargeUtf8.endLargeUtf8(b);
  }
  visitDecimal(node, b) {
    Decimal.startDecimal(b);
    Decimal.addScale(b, node.scale);
    Decimal.addPrecision(b, node.precision);
    Decimal.addBitWidth(b, node.bitWidth);
    return Decimal.endDecimal(b);
  }
  visitDate(node, b) {
    Date3.startDate(b);
    Date3.addUnit(b, node.unit);
    return Date3.endDate(b);
  }
  visitTime(node, b) {
    Time.startTime(b);
    Time.addUnit(b, node.unit);
    Time.addBitWidth(b, node.bitWidth);
    return Time.endTime(b);
  }
  visitTimestamp(node, b) {
    const timezone = node.timezone && b.createString(node.timezone) || undefined;
    Timestamp.startTimestamp(b);
    Timestamp.addUnit(b, node.unit);
    if (timezone !== undefined) {
      Timestamp.addTimezone(b, timezone);
    }
    return Timestamp.endTimestamp(b);
  }
  visitInterval(node, b) {
    Interval.startInterval(b);
    Interval.addUnit(b, node.unit);
    return Interval.endInterval(b);
  }
  visitDuration(node, b) {
    Duration.startDuration(b);
    Duration.addUnit(b, node.unit);
    return Duration.endDuration(b);
  }
  visitList(_node, b) {
    List.startList(b);
    return List.endList(b);
  }
  visitStruct(_node, b) {
    Struct_.startStruct_(b);
    return Struct_.endStruct_(b);
  }
  visitUnion(node, b) {
    Union3.startTypeIdsVector(b, node.typeIds.length);
    const typeIds = Union3.createTypeIdsVector(b, node.typeIds);
    Union3.startUnion(b);
    Union3.addMode(b, node.mode);
    Union3.addTypeIds(b, typeIds);
    return Union3.endUnion(b);
  }
  visitDictionary(node, b) {
    const indexType = this.visit(node.indices, b);
    DictionaryEncoding.startDictionaryEncoding(b);
    DictionaryEncoding.addId(b, BigInt(node.id));
    DictionaryEncoding.addIsOrdered(b, node.isOrdered);
    if (indexType !== undefined) {
      DictionaryEncoding.addIndexType(b, indexType);
    }
    return DictionaryEncoding.endDictionaryEncoding(b);
  }
  visitFixedSizeBinary(node, b) {
    FixedSizeBinary.startFixedSizeBinary(b);
    FixedSizeBinary.addByteWidth(b, node.byteWidth);
    return FixedSizeBinary.endFixedSizeBinary(b);
  }
  visitFixedSizeList(node, b) {
    FixedSizeList.startFixedSizeList(b);
    FixedSizeList.addListSize(b, node.listSize);
    return FixedSizeList.endFixedSizeList(b);
  }
  visitMap(node, b) {
    Map2.startMap(b);
    Map2.addKeysSorted(b, node.keysSorted);
    return Map2.endMap(b);
  }
}
var instance5 = new TypeAssembler;

// node_modules/apache-arrow/ipc/metadata/json.mjs
function schemaFromJSON(_schema, dictionaries = new Map) {
  return new Schema3(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema["metadata"]), dictionaries);
}
function recordBatchFromJSON(b) {
  return new RecordBatch3(b["count"], fieldNodesFromJSON(b["columns"]), buffersFromJSON(b["columns"]), null);
}
function dictionaryBatchFromJSON(b) {
  return new DictionaryBatch2(recordBatchFromJSON(b["data"]), b["id"], b["isDelta"]);
}
function schemaFieldsFromJSON(_schema, dictionaries) {
  return (_schema["fields"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));
}
function fieldChildrenFromJSON(_field, dictionaries) {
  return (_field["children"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));
}
function fieldNodesFromJSON(xs) {
  return (xs || []).reduce((fieldNodes, column) => [
    ...fieldNodes,
    new FieldNode2(column["count"], nullCountFromJSON(column["VALIDITY"])),
    ...fieldNodesFromJSON(column["children"])
  ], []);
}
function buffersFromJSON(xs, buffers = []) {
  for (let i = -1, n = (xs || []).length;++i < n; ) {
    const column = xs[i];
    column["VALIDITY"] && buffers.push(new BufferRegion(buffers.length, column["VALIDITY"].length));
    column["TYPE_ID"] && buffers.push(new BufferRegion(buffers.length, column["TYPE_ID"].length));
    column["OFFSET"] && buffers.push(new BufferRegion(buffers.length, column["OFFSET"].length));
    column["DATA"] && buffers.push(new BufferRegion(buffers.length, column["DATA"].length));
    buffers = buffersFromJSON(column["children"], buffers);
  }
  return buffers;
}
function nullCountFromJSON(validity) {
  return (validity || []).reduce((sum3, val) => sum3 + +(val === 0), 0);
}
function fieldFromJSON(_field, dictionaries) {
  let id2;
  let keys3;
  let field;
  let dictMeta;
  let type;
  let dictType;
  if (!dictionaries || !(dictMeta = _field["dictionary"])) {
    type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));
    field = new Field2(_field["name"], type, _field["nullable"], customMetadataFromJSON(_field["metadata"]));
  } else if (!dictionaries.has(id2 = dictMeta["id"])) {
    keys3 = (keys3 = dictMeta["indexType"]) ? indexTypeFromJSON(keys3) : new Int32;
    dictionaries.set(id2, type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));
    dictType = new Dictionary(type, keys3, id2, dictMeta["isOrdered"]);
    field = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["metadata"]));
  } else {
    keys3 = (keys3 = dictMeta["indexType"]) ? indexTypeFromJSON(keys3) : new Int32;
    dictType = new Dictionary(dictionaries.get(id2), keys3, id2, dictMeta["isOrdered"]);
    field = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["metadata"]));
  }
  return field || null;
}
function customMetadataFromJSON(metadata = []) {
  return new Map(metadata.map(({ key, value }) => [key, value]));
}
function indexTypeFromJSON(_type) {
  return new Int_(_type["isSigned"], _type["bitWidth"]);
}
function typeFromJSON(f, children2) {
  const typeId = f["type"]["name"];
  switch (typeId) {
    case "NONE":
      return new Null2;
    case "null":
      return new Null2;
    case "binary":
      return new Binary2;
    case "largebinary":
      return new LargeBinary2;
    case "utf8":
      return new Utf82;
    case "largeutf8":
      return new LargeUtf82;
    case "bool":
      return new Bool2;
    case "list":
      return new List2((children2 || [])[0]);
    case "struct":
      return new Struct2(children2 || []);
    case "struct_":
      return new Struct2(children2 || []);
  }
  switch (typeId) {
    case "int": {
      const t = f["type"];
      return new Int_(t["isSigned"], t["bitWidth"]);
    }
    case "floatingpoint": {
      const t = f["type"];
      return new Float(Precision[t["precision"]]);
    }
    case "decimal": {
      const t = f["type"];
      return new Decimal2(t["scale"], t["precision"], t["bitWidth"]);
    }
    case "date": {
      const t = f["type"];
      return new Date_(DateUnit[t["unit"]]);
    }
    case "time": {
      const t = f["type"];
      return new Time_(TimeUnit[t["unit"]], t["bitWidth"]);
    }
    case "timestamp": {
      const t = f["type"];
      return new Timestamp_(TimeUnit[t["unit"]], t["timezone"]);
    }
    case "interval": {
      const t = f["type"];
      return new Interval_(IntervalUnit[t["unit"]]);
    }
    case "duration": {
      const t = f["type"];
      return new Duration2(TimeUnit[t["unit"]]);
    }
    case "union": {
      const t = f["type"];
      const [m, ...ms] = (t["mode"] + "").toLowerCase();
      const mode = m.toUpperCase() + ms.join("");
      return new Union_(UnionMode[mode], t["typeIds"] || [], children2 || []);
    }
    case "fixedsizebinary": {
      const t = f["type"];
      return new FixedSizeBinary2(t["byteWidth"]);
    }
    case "fixedsizelist": {
      const t = f["type"];
      return new FixedSizeList2(t["listSize"], (children2 || [])[0]);
    }
    case "map": {
      const t = f["type"];
      return new Map_((children2 || [])[0], t["keysSorted"]);
    }
  }
  throw new Error(`Unrecognized type: "${typeId}"`);
}

// node_modules/apache-arrow/ipc/metadata/message.mjs
var Builder4 = Builder;
var ByteBuffer3 = ByteBuffer;

class Message2 {
  static fromJSON(msg, headerType) {
    const message = new Message2(0, MetadataVersion.V5, headerType);
    message._createHeader = messageHeaderFromJSON(msg, headerType);
    return message;
  }
  static decode(buf) {
    buf = new ByteBuffer3(toUint8Array(buf));
    const _message = Message.getRootAsMessage(buf);
    const bodyLength = _message.bodyLength();
    const version = _message.version();
    const headerType = _message.headerType();
    const message = new Message2(bodyLength, version, headerType);
    message._createHeader = decodeMessageHeader(_message, headerType);
    return message;
  }
  static encode(message) {
    const b = new Builder4;
    let headerOffset = -1;
    if (message.isSchema()) {
      headerOffset = Schema3.encode(b, message.header());
    } else if (message.isRecordBatch()) {
      headerOffset = RecordBatch3.encode(b, message.header());
    } else if (message.isDictionaryBatch()) {
      headerOffset = DictionaryBatch2.encode(b, message.header());
    }
    Message.startMessage(b);
    Message.addVersion(b, MetadataVersion.V5);
    Message.addHeader(b, headerOffset);
    Message.addHeaderType(b, message.headerType);
    Message.addBodyLength(b, BigInt(message.bodyLength));
    Message.finishMessageBuffer(b, Message.endMessage(b));
    return b.asUint8Array();
  }
  static from(header, bodyLength = 0) {
    if (header instanceof Schema3) {
      return new Message2(0, MetadataVersion.V5, MessageHeader.Schema, header);
    }
    if (header instanceof RecordBatch3) {
      return new Message2(bodyLength, MetadataVersion.V5, MessageHeader.RecordBatch, header);
    }
    if (header instanceof DictionaryBatch2) {
      return new Message2(bodyLength, MetadataVersion.V5, MessageHeader.DictionaryBatch, header);
    }
    throw new Error(`Unrecognized Message header: ${header}`);
  }
  get type() {
    return this.headerType;
  }
  get version() {
    return this._version;
  }
  get headerType() {
    return this._headerType;
  }
  get compression() {
    return this._compression;
  }
  get bodyLength() {
    return this._bodyLength;
  }
  header() {
    return this._createHeader();
  }
  isSchema() {
    return this.headerType === MessageHeader.Schema;
  }
  isRecordBatch() {
    return this.headerType === MessageHeader.RecordBatch;
  }
  isDictionaryBatch() {
    return this.headerType === MessageHeader.DictionaryBatch;
  }
  constructor(bodyLength, version, headerType, header) {
    this._version = version;
    this._headerType = headerType;
    this.body = new Uint8Array(0);
    this._compression = header === null || header === undefined ? undefined : header.compression;
    header && (this._createHeader = () => header);
    this._bodyLength = bigIntToNumber(bodyLength);
  }
}

class RecordBatch3 {
  get nodes() {
    return this._nodes;
  }
  get length() {
    return this._length;
  }
  get buffers() {
    return this._buffers;
  }
  get compression() {
    return this._compression;
  }
  constructor(length3, nodes, buffers, compression) {
    this._nodes = nodes;
    this._buffers = buffers;
    this._length = bigIntToNumber(length3);
    this._compression = compression;
  }
}

class DictionaryBatch2 {
  get id() {
    return this._id;
  }
  get data() {
    return this._data;
  }
  get isDelta() {
    return this._isDelta;
  }
  get length() {
    return this.data.length;
  }
  get nodes() {
    return this.data.nodes;
  }
  get buffers() {
    return this.data.buffers;
  }
  constructor(data, id2, isDelta = false) {
    this._data = data;
    this._isDelta = isDelta;
    this._id = bigIntToNumber(id2);
  }
}

class BufferRegion {
  constructor(offset, length3) {
    this.offset = bigIntToNumber(offset);
    this.length = bigIntToNumber(length3);
  }
}

class FieldNode2 {
  constructor(length3, nullCount) {
    this.length = bigIntToNumber(length3);
    this.nullCount = bigIntToNumber(nullCount);
  }
}

class BodyCompression2 {
  constructor(type, method = BodyCompressionMethod.BUFFER) {
    this.type = type;
    this.method = method;
  }
}
function messageHeaderFromJSON(message, type) {
  return () => {
    switch (type) {
      case MessageHeader.Schema:
        return Schema3.fromJSON(message);
      case MessageHeader.RecordBatch:
        return RecordBatch3.fromJSON(message);
      case MessageHeader.DictionaryBatch:
        return DictionaryBatch2.fromJSON(message);
    }
    throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type]}, type: ${type} }`);
  };
}
function decodeMessageHeader(message, type) {
  return () => {
    switch (type) {
      case MessageHeader.Schema:
        return Schema3.decode(message.header(new Schema2), new Map, message.version());
      case MessageHeader.RecordBatch:
        return RecordBatch3.decode(message.header(new RecordBatch2), message.version());
      case MessageHeader.DictionaryBatch:
        return DictionaryBatch2.decode(message.header(new DictionaryBatch), message.version());
    }
    throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type]}, type: ${type} }`);
  };
}
Field2["encode"] = encodeField;
Field2["decode"] = decodeField;
Field2["fromJSON"] = fieldFromJSON;
Schema3["encode"] = encodeSchema;
Schema3["decode"] = decodeSchema;
Schema3["fromJSON"] = schemaFromJSON;
RecordBatch3["encode"] = encodeRecordBatch;
RecordBatch3["decode"] = decodeRecordBatch;
RecordBatch3["fromJSON"] = recordBatchFromJSON;
DictionaryBatch2["encode"] = encodeDictionaryBatch;
DictionaryBatch2["decode"] = decodeDictionaryBatch;
DictionaryBatch2["fromJSON"] = dictionaryBatchFromJSON;
FieldNode2["encode"] = encodeFieldNode;
FieldNode2["decode"] = decodeFieldNode;
BufferRegion["encode"] = encodeBufferRegion;
BufferRegion["decode"] = decodeBufferRegion;
BodyCompression2["encode"] = encodeBodyCompression;
BodyCompression2["decode"] = decodeBodyCompression;
function decodeSchema(_schema, dictionaries = new Map, version = MetadataVersion.V5) {
  const fields = decodeSchemaFields(_schema, dictionaries);
  return new Schema3(fields, decodeCustomMetadata(_schema), dictionaries, version);
}
function decodeRecordBatch(batch, version = MetadataVersion.V5) {
  const recordBatch = new RecordBatch3(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version), decodeBodyCompression(batch.compression()));
  return recordBatch;
}
function decodeDictionaryBatch(batch, version = MetadataVersion.V5) {
  return new DictionaryBatch2(RecordBatch3.decode(batch.data(), version), batch.id(), batch.isDelta());
}
function decodeBufferRegion(b) {
  return new BufferRegion(b.offset(), b.length());
}
function decodeFieldNode(f) {
  return new FieldNode2(f.length(), f.nullCount());
}
function decodeFieldNodes(batch) {
  const nodes = [];
  for (let f, i = -1, j = -1, n = batch.nodesLength();++i < n; ) {
    if (f = batch.nodes(i)) {
      nodes[++j] = FieldNode2.decode(f);
    }
  }
  return nodes;
}
function decodeBuffers(batch, version) {
  const bufferRegions = [];
  for (let b, i = -1, j = -1, n = batch.buffersLength();++i < n; ) {
    if (b = batch.buffers(i)) {
      if (version < MetadataVersion.V4) {
        b.bb_pos += 8 * (i + 1);
      }
      bufferRegions[++j] = BufferRegion.decode(b);
    }
  }
  return bufferRegions;
}
function decodeSchemaFields(schema, dictionaries) {
  const fields = [];
  for (let f, i = -1, j = -1, n = schema.fieldsLength();++i < n; ) {
    if (f = schema.fields(i)) {
      fields[++j] = Field2.decode(f, dictionaries);
    }
  }
  return fields;
}
function decodeFieldChildren(field, dictionaries) {
  const children2 = [];
  for (let f, i = -1, j = -1, n = field.childrenLength();++i < n; ) {
    if (f = field.children(i)) {
      children2[++j] = Field2.decode(f, dictionaries);
    }
  }
  return children2;
}
function decodeField(f, dictionaries) {
  let id2;
  let field;
  let type;
  let keys3;
  let dictType;
  let dictMeta;
  if (!dictionaries || !(dictMeta = f.dictionary())) {
    type = decodeFieldType(f, decodeFieldChildren(f, dictionaries));
    field = new Field2(f.name(), type, f.nullable(), decodeCustomMetadata(f));
  } else if (!dictionaries.has(id2 = bigIntToNumber(dictMeta.id()))) {
    keys3 = (keys3 = dictMeta.indexType()) ? decodeIndexType(keys3) : new Int32;
    dictionaries.set(id2, type = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));
    dictType = new Dictionary(type, keys3, id2, dictMeta.isOrdered());
    field = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
  } else {
    keys3 = (keys3 = dictMeta.indexType()) ? decodeIndexType(keys3) : new Int32;
    dictType = new Dictionary(dictionaries.get(id2), keys3, id2, dictMeta.isOrdered());
    field = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
  }
  return field || null;
}
function decodeCustomMetadata(parent) {
  const data = new Map;
  if (parent) {
    for (let entry, key, i = -1, n = Math.trunc(parent.customMetadataLength());++i < n; ) {
      if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {
        data.set(key, entry.value());
      }
    }
  }
  return data;
}
function decodeIndexType(_type) {
  return new Int_(_type.isSigned(), _type.bitWidth());
}
function decodeFieldType(f, children2) {
  const typeId = f.typeType();
  switch (typeId) {
    case Type3["NONE"]:
      return new Null2;
    case Type3["Null"]:
      return new Null2;
    case Type3["Binary"]:
      return new Binary2;
    case Type3["LargeBinary"]:
      return new LargeBinary2;
    case Type3["Utf8"]:
      return new Utf82;
    case Type3["LargeUtf8"]:
      return new LargeUtf82;
    case Type3["Bool"]:
      return new Bool2;
    case Type3["List"]:
      return new List2((children2 || [])[0]);
    case Type3["Struct_"]:
      return new Struct2(children2 || []);
  }
  switch (typeId) {
    case Type3["Int"]: {
      const t = f.type(new Int);
      return new Int_(t.isSigned(), t.bitWidth());
    }
    case Type3["FloatingPoint"]: {
      const t = f.type(new FloatingPoint);
      return new Float(t.precision());
    }
    case Type3["Decimal"]: {
      const t = f.type(new Decimal);
      return new Decimal2(t.scale(), t.precision(), t.bitWidth());
    }
    case Type3["Date"]: {
      const t = f.type(new Date3);
      return new Date_(t.unit());
    }
    case Type3["Time"]: {
      const t = f.type(new Time);
      return new Time_(t.unit(), t.bitWidth());
    }
    case Type3["Timestamp"]: {
      const t = f.type(new Timestamp);
      return new Timestamp_(t.unit(), t.timezone());
    }
    case Type3["Interval"]: {
      const t = f.type(new Interval);
      return new Interval_(t.unit());
    }
    case Type3["Duration"]: {
      const t = f.type(new Duration);
      return new Duration2(t.unit());
    }
    case Type3["Union"]: {
      const t = f.type(new Union3);
      return new Union_(t.mode(), t.typeIdsArray() || [], children2 || []);
    }
    case Type3["FixedSizeBinary"]: {
      const t = f.type(new FixedSizeBinary);
      return new FixedSizeBinary2(t.byteWidth());
    }
    case Type3["FixedSizeList"]: {
      const t = f.type(new FixedSizeList);
      return new FixedSizeList2(t.listSize(), (children2 || [])[0]);
    }
    case Type3["Map"]: {
      const t = f.type(new Map2);
      return new Map_((children2 || [])[0], t.keysSorted());
    }
  }
  throw new Error(`Unrecognized type: "${Type3[typeId]}" (${typeId})`);
}
function decodeBodyCompression(b) {
  return b ? new BodyCompression2(b.codec(), b.method()) : null;
}
function encodeSchema(b, schema) {
  const fieldOffsets = schema.fields.map((f) => Field2.encode(b, f));
  Schema2.startFieldsVector(b, fieldOffsets.length);
  const fieldsVectorOffset = Schema2.createFieldsVector(b, fieldOffsets);
  const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 : Schema2.createCustomMetadataVector(b, [...schema.metadata].map(([k, v]) => {
    const key = b.createString(`${k}`);
    const val = b.createString(`${v}`);
    KeyValue.startKeyValue(b);
    KeyValue.addKey(b, key);
    KeyValue.addValue(b, val);
    return KeyValue.endKeyValue(b);
  }));
  Schema2.startSchema(b);
  Schema2.addFields(b, fieldsVectorOffset);
  Schema2.addEndianness(b, platformIsLittleEndian ? Endianness.Little : Endianness.Big);
  if (metadataOffset !== -1) {
    Schema2.addCustomMetadata(b, metadataOffset);
  }
  return Schema2.endSchema(b);
}
function encodeField(b, field) {
  let nameOffset = -1;
  let typeOffset = -1;
  let dictionaryOffset = -1;
  const type = field.type;
  let typeId = field.typeId;
  if (!DataType.isDictionary(type)) {
    typeOffset = instance5.visit(type, b);
  } else {
    typeId = type.dictionary.typeId;
    dictionaryOffset = instance5.visit(type, b);
    typeOffset = instance5.visit(type.dictionary, b);
  }
  const childOffsets = (type.children || []).map((f) => Field2.encode(b, f));
  const childrenVectorOffset = Field.createChildrenVector(b, childOffsets);
  const metadataOffset = !(field.metadata && field.metadata.size > 0) ? -1 : Field.createCustomMetadataVector(b, [...field.metadata].map(([k, v]) => {
    const key = b.createString(`${k}`);
    const val = b.createString(`${v}`);
    KeyValue.startKeyValue(b);
    KeyValue.addKey(b, key);
    KeyValue.addValue(b, val);
    return KeyValue.endKeyValue(b);
  }));
  if (field.name) {
    nameOffset = b.createString(field.name);
  }
  Field.startField(b);
  Field.addType(b, typeOffset);
  Field.addTypeType(b, typeId);
  Field.addChildren(b, childrenVectorOffset);
  Field.addNullable(b, !!field.nullable);
  if (nameOffset !== -1) {
    Field.addName(b, nameOffset);
  }
  if (dictionaryOffset !== -1) {
    Field.addDictionary(b, dictionaryOffset);
  }
  if (metadataOffset !== -1) {
    Field.addCustomMetadata(b, metadataOffset);
  }
  return Field.endField(b);
}
function encodeRecordBatch(b, recordBatch) {
  const nodes = recordBatch.nodes || [];
  const buffers = recordBatch.buffers || [];
  RecordBatch2.startNodesVector(b, nodes.length);
  for (const n of nodes.slice().reverse())
    FieldNode2.encode(b, n);
  const nodesVectorOffset = b.endVector();
  RecordBatch2.startBuffersVector(b, buffers.length);
  for (const b_ of buffers.slice().reverse())
    BufferRegion.encode(b, b_);
  const buffersVectorOffset = b.endVector();
  let bodyCompressionOffset = null;
  if (recordBatch.compression !== null) {
    bodyCompressionOffset = encodeBodyCompression(b, recordBatch.compression);
  }
  RecordBatch2.startRecordBatch(b);
  RecordBatch2.addLength(b, BigInt(recordBatch.length));
  RecordBatch2.addNodes(b, nodesVectorOffset);
  RecordBatch2.addBuffers(b, buffersVectorOffset);
  if (recordBatch.compression !== null && bodyCompressionOffset) {
    RecordBatch2.addCompression(b, bodyCompressionOffset);
  }
  return RecordBatch2.endRecordBatch(b);
}
function encodeBodyCompression(b, node) {
  BodyCompression.startBodyCompression(b);
  BodyCompression.addCodec(b, node.type);
  BodyCompression.addMethod(b, node.method);
  return BodyCompression.endBodyCompression(b);
}
function encodeDictionaryBatch(b, dictionaryBatch) {
  const dataOffset = RecordBatch3.encode(b, dictionaryBatch.data);
  DictionaryBatch.startDictionaryBatch(b);
  DictionaryBatch.addId(b, BigInt(dictionaryBatch.id));
  DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);
  DictionaryBatch.addData(b, dataOffset);
  return DictionaryBatch.endDictionaryBatch(b);
}
function encodeFieldNode(b, node) {
  return FieldNode.createFieldNode(b, BigInt(node.length), BigInt(node.nullCount));
}
function encodeBufferRegion(b, node) {
  return Buffer.createBuffer(b, BigInt(node.offset), BigInt(node.length));
}
var platformIsLittleEndian = (() => {
  const buffer3 = new ArrayBuffer(2);
  new DataView(buffer3).setInt16(0, 256, true);
  return new Int16Array(buffer3)[0] === 256;
})();

// node_modules/apache-arrow/io/interfaces.mjs
var ITERATOR_DONE = Object.freeze({ done: true, value: undefined });

class ArrowJSON {
  constructor(_json) {
    this._json = _json;
  }
  get schema() {
    return this._json["schema"];
  }
  get batches() {
    return this._json["batches"] || [];
  }
  get dictionaries() {
    return this._json["dictionaries"] || [];
  }
}

class ReadableInterop {
  tee() {
    return this._getDOMStream().tee();
  }
  pipe(writable, options) {
    return this._getNodeStream().pipe(writable, options);
  }
  pipeTo(writable, options) {
    return this._getDOMStream().pipeTo(writable, options);
  }
  pipeThrough(duplex, options) {
    return this._getDOMStream().pipeThrough(duplex, options);
  }
  _getDOMStream() {
    return this._DOMStream || (this._DOMStream = this.toDOMStream());
  }
  _getNodeStream() {
    return this._nodeStream || (this._nodeStream = this.toNodeStream());
  }
}

class AsyncQueue extends ReadableInterop {
  constructor() {
    super();
    this._values = [];
    this.resolvers = [];
    this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
  }
  get closed() {
    return this._closedPromise;
  }
  cancel(reason) {
    return __awaiter(this, undefined, undefined, function* () {
      yield this.return(reason);
    });
  }
  write(value) {
    if (this._ensureOpen()) {
      this.resolvers.length <= 0 ? this._values.push(value) : this.resolvers.shift().resolve({ done: false, value });
    }
  }
  abort(value) {
    if (this._closedPromiseResolve) {
      this.resolvers.length <= 0 ? this._error = { error: value } : this.resolvers.shift().reject({ done: true, value });
    }
  }
  close() {
    if (this._closedPromiseResolve) {
      const { resolvers } = this;
      while (resolvers.length > 0) {
        resolvers.shift().resolve(ITERATOR_DONE);
      }
      this._closedPromiseResolve();
      this._closedPromiseResolve = undefined;
    }
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  toDOMStream(options) {
    return adapters_default.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, options);
  }
  toNodeStream(options) {
    return adapters_default.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, options);
  }
  throw(_) {
    return __awaiter(this, undefined, undefined, function* () {
      yield this.abort(_);
      return ITERATOR_DONE;
    });
  }
  return(_) {
    return __awaiter(this, undefined, undefined, function* () {
      yield this.close();
      return ITERATOR_DONE;
    });
  }
  read(size13) {
    return __awaiter(this, undefined, undefined, function* () {
      return (yield this.next(size13, "read")).value;
    });
  }
  peek(size13) {
    return __awaiter(this, undefined, undefined, function* () {
      return (yield this.next(size13, "peek")).value;
    });
  }
  next(..._args) {
    if (this._values.length > 0) {
      return Promise.resolve({ done: false, value: this._values.shift() });
    } else if (this._error) {
      return Promise.reject({ done: true, value: this._error.error });
    } else if (!this._closedPromiseResolve) {
      return Promise.resolve(ITERATOR_DONE);
    } else {
      return new Promise((resolve4, reject) => {
        this.resolvers.push({ resolve: resolve4, reject });
      });
    }
  }
  _ensureOpen() {
    if (this._closedPromiseResolve) {
      return true;
    }
    throw new Error(`AsyncQueue is closed`);
  }
}

// node_modules/apache-arrow/io/stream.mjs
class AsyncByteQueue extends AsyncQueue {
  write(value) {
    if ((value = toUint8Array(value)).byteLength > 0) {
      return super.write(value);
    }
  }
  toString(sync10 = false) {
    return sync10 ? decodeUtf8(this.toUint8Array(true)) : this.toUint8Array(false).then(decodeUtf8);
  }
  toUint8Array(sync10 = false) {
    return sync10 ? joinUint8Arrays(this._values)[0] : (() => __awaiter(this, undefined, undefined, function* () {
      var _a3, e_1, _b2, _c2;
      const buffers = [];
      let byteLength = 0;
      try {
        for (var _d2 = true, _e2 = __asyncValues(this), _f2;_f2 = yield _e2.next(), _a3 = _f2.done, !_a3; _d2 = true) {
          _c2 = _f2.value;
          _d2 = false;
          const chunk3 = _c2;
          buffers.push(chunk3);
          byteLength += chunk3.byteLength;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d2 && !_a3 && (_b2 = _e2.return))
            yield _b2.call(_e2);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return joinUint8Arrays(buffers, byteLength)[0];
    }))();
  }
}

class ByteStream {
  constructor(source) {
    if (source) {
      this.source = new ByteStreamSource(adapters_default.fromIterable(source));
    }
  }
  [Symbol.iterator]() {
    return this;
  }
  next(value) {
    return this.source.next(value);
  }
  throw(value) {
    return this.source.throw(value);
  }
  return(value) {
    return this.source.return(value);
  }
  peek(size13) {
    return this.source.peek(size13);
  }
  read(size13) {
    return this.source.read(size13);
  }
}

class AsyncByteStream {
  constructor(source) {
    if (source instanceof AsyncByteStream) {
      this.source = source.source;
    } else if (source instanceof AsyncByteQueue) {
      this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
    } else if (isReadableNodeStream(source)) {
      this.source = new AsyncByteStreamSource(adapters_default.fromNodeStream(source));
    } else if (isReadableDOMStream(source)) {
      this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source));
    } else if (isFetchResponse(source)) {
      this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source.body));
    } else if (isIterable2(source)) {
      this.source = new AsyncByteStreamSource(adapters_default.fromIterable(source));
    } else if (isPromise(source)) {
      this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
    } else if (isAsyncIterable(source)) {
      this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
    }
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  next(value) {
    return this.source.next(value);
  }
  throw(value) {
    return this.source.throw(value);
  }
  return(value) {
    return this.source.return(value);
  }
  get closed() {
    return this.source.closed;
  }
  cancel(reason) {
    return this.source.cancel(reason);
  }
  peek(size13) {
    return this.source.peek(size13);
  }
  read(size13) {
    return this.source.read(size13);
  }
}

class ByteStreamSource {
  constructor(source) {
    this.source = source;
  }
  cancel(reason) {
    this.return(reason);
  }
  peek(size13) {
    return this.next(size13, "peek").value;
  }
  read(size13) {
    return this.next(size13, "read").value;
  }
  next(size13, cmd = "read") {
    return this.source.next({ cmd, size: size13 });
  }
  throw(value) {
    return Object.create(this.source.throw && this.source.throw(value) || ITERATOR_DONE);
  }
  return(value) {
    return Object.create(this.source.return && this.source.return(value) || ITERATOR_DONE);
  }
}

class AsyncByteStreamSource {
  constructor(source) {
    this.source = source;
    this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
  }
  cancel(reason) {
    return __awaiter(this, undefined, undefined, function* () {
      yield this.return(reason);
    });
  }
  get closed() {
    return this._closedPromise;
  }
  read(size13) {
    return __awaiter(this, undefined, undefined, function* () {
      return (yield this.next(size13, "read")).value;
    });
  }
  peek(size13) {
    return __awaiter(this, undefined, undefined, function* () {
      return (yield this.next(size13, "peek")).value;
    });
  }
  next(size_1) {
    return __awaiter(this, arguments, undefined, function* (size13, cmd = "read") {
      return yield this.source.next({ cmd, size: size13 });
    });
  }
  throw(value) {
    return __awaiter(this, undefined, undefined, function* () {
      const result = this.source.throw && (yield this.source.throw(value)) || ITERATOR_DONE;
      this._closedPromiseResolve && this._closedPromiseResolve();
      this._closedPromiseResolve = undefined;
      return Object.create(result);
    });
  }
  return(value) {
    return __awaiter(this, undefined, undefined, function* () {
      const result = this.source.return && (yield this.source.return(value)) || ITERATOR_DONE;
      this._closedPromiseResolve && this._closedPromiseResolve();
      this._closedPromiseResolve = undefined;
      return Object.create(result);
    });
  }
}

// node_modules/apache-arrow/io/file.mjs
class RandomAccessFile extends ByteStream {
  constructor(buffer3, byteLength) {
    super();
    this.position = 0;
    this.buffer = toUint8Array(buffer3);
    this.size = byteLength === undefined ? this.buffer.byteLength : byteLength;
  }
  readInt32(position) {
    const { buffer: buffer3, byteOffset } = this.readAt(position, 4);
    return new DataView(buffer3, byteOffset).getInt32(0, true);
  }
  seek(position) {
    this.position = Math.min(position, this.size);
    return position < this.size;
  }
  read(nBytes) {
    const { buffer: buffer3, size: size13, position } = this;
    if (buffer3 && position < size13) {
      if (typeof nBytes !== "number") {
        nBytes = Number.POSITIVE_INFINITY;
      }
      this.position = Math.min(size13, position + Math.min(size13 - position, nBytes));
      return buffer3.subarray(position, this.position);
    }
    return null;
  }
  readAt(position, nBytes) {
    const buf = this.buffer;
    const end6 = Math.min(this.size, position + nBytes);
    return buf ? buf.subarray(position, end6) : new Uint8Array(nBytes);
  }
  close() {
    this.buffer && (this.buffer = null);
  }
  throw(value) {
    this.close();
    return { done: true, value };
  }
  return(value) {
    this.close();
    return { done: true, value };
  }
}

class AsyncRandomAccessFile extends AsyncByteStream {
  constructor(file, byteLength) {
    super();
    this.position = 0;
    this._handle = file;
    if (typeof byteLength === "number") {
      this.size = byteLength;
    } else {
      this._pending = (() => __awaiter(this, undefined, undefined, function* () {
        this.size = (yield file.stat()).size;
        delete this._pending;
      }))();
    }
  }
  readInt32(position) {
    return __awaiter(this, undefined, undefined, function* () {
      const { buffer: buffer3, byteOffset } = yield this.readAt(position, 4);
      return new DataView(buffer3, byteOffset).getInt32(0, true);
    });
  }
  seek(position) {
    return __awaiter(this, undefined, undefined, function* () {
      this._pending && (yield this._pending);
      this.position = Math.min(position, this.size);
      return position < this.size;
    });
  }
  read(nBytes) {
    return __awaiter(this, undefined, undefined, function* () {
      this._pending && (yield this._pending);
      const { _handle: file, size: size13, position } = this;
      if (file && position < size13) {
        if (typeof nBytes !== "number") {
          nBytes = Number.POSITIVE_INFINITY;
        }
        let pos = position, offset = 0, bytesRead = 0;
        const end6 = Math.min(size13, pos + Math.min(size13 - pos, nBytes));
        const buffer3 = new Uint8Array(Math.max(0, (this.position = end6) - pos));
        while ((pos += bytesRead) < end6 && (offset += bytesRead) < buffer3.byteLength) {
          ({ bytesRead } = yield file.read(buffer3, offset, buffer3.byteLength - offset, pos));
        }
        return buffer3;
      }
      return null;
    });
  }
  readAt(position, nBytes) {
    return __awaiter(this, undefined, undefined, function* () {
      this._pending && (yield this._pending);
      const { _handle: file, size: size13 } = this;
      if (file && position + nBytes < size13) {
        const end6 = Math.min(size13, position + nBytes);
        const buffer3 = new Uint8Array(end6 - position);
        return (yield file.read(buffer3, 0, nBytes, position)).buffer;
      }
      return new Uint8Array(nBytes);
    });
  }
  close() {
    return __awaiter(this, undefined, undefined, function* () {
      const f = this._handle;
      this._handle = null;
      f && (yield f.close());
    });
  }
  throw(value) {
    return __awaiter(this, undefined, undefined, function* () {
      yield this.close();
      return { done: true, value };
    });
  }
  return(value) {
    return __awaiter(this, undefined, undefined, function* () {
      yield this.close();
      return { done: true, value };
    });
  }
}

// node_modules/apache-arrow/util/int.mjs
var exports_int = {};
__export(exports_int, {
  Uint64: () => Uint642,
  Int64: () => Int642,
  Int128: () => Int128,
  BaseInt64: () => BaseInt64
});
var carryBit16 = 1 << 16;
function intAsHex(value) {
  if (value < 0) {
    value = 4294967295 + value + 1;
  }
  return `0x${value.toString(16)}`;
}
var kInt32DecimalDigits = 8;
var kPowersOfTen = [
  1,
  10,
  100,
  1000,
  1e4,
  1e5,
  1e6,
  1e7,
  1e8
];

class BaseInt64 {
  constructor(buffer3) {
    this.buffer = buffer3;
  }
  high() {
    return this.buffer[1];
  }
  low() {
    return this.buffer[0];
  }
  _times(other) {
    const L = new Uint32Array([
      this.buffer[1] >>> 16,
      this.buffer[1] & 65535,
      this.buffer[0] >>> 16,
      this.buffer[0] & 65535
    ]);
    const R = new Uint32Array([
      other.buffer[1] >>> 16,
      other.buffer[1] & 65535,
      other.buffer[0] >>> 16,
      other.buffer[0] & 65535
    ]);
    let product = L[3] * R[3];
    this.buffer[0] = product & 65535;
    let sum3 = product >>> 16;
    product = L[2] * R[3];
    sum3 += product;
    product = L[3] * R[2] >>> 0;
    sum3 += product;
    this.buffer[0] += sum3 << 16;
    this.buffer[1] = sum3 >>> 0 < product ? carryBit16 : 0;
    this.buffer[1] += sum3 >>> 16;
    this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];
    this.buffer[1] += L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0] << 16;
    return this;
  }
  _plus(other) {
    const sum3 = this.buffer[0] + other.buffer[0] >>> 0;
    this.buffer[1] += other.buffer[1];
    if (sum3 < this.buffer[0] >>> 0) {
      ++this.buffer[1];
    }
    this.buffer[0] = sum3;
  }
  lessThan(other) {
    return this.buffer[1] < other.buffer[1] || this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0];
  }
  equals(other) {
    return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];
  }
  greaterThan(other) {
    return other.lessThan(this);
  }
  hex() {
    return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
  }
}

class Uint642 extends BaseInt64 {
  times(other) {
    this._times(other);
    return this;
  }
  plus(other) {
    this._plus(other);
    return this;
  }
  static from(val, out_buffer = new Uint32Array(2)) {
    return Uint642.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
  }
  static fromNumber(num, out_buffer = new Uint32Array(2)) {
    return Uint642.fromString(num.toString(), out_buffer);
  }
  static fromString(str, out_buffer = new Uint32Array(2)) {
    const length3 = str.length;
    const out = new Uint642(out_buffer);
    for (let posn = 0;posn < length3; ) {
      const group = kInt32DecimalDigits < length3 - posn ? kInt32DecimalDigits : length3 - posn;
      const chunk3 = new Uint642(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));
      const multiple = new Uint642(new Uint32Array([kPowersOfTen[group], 0]));
      out.times(multiple);
      out.plus(chunk3);
      posn += group;
    }
    return out;
  }
  static convertArray(values3) {
    const data = new Uint32Array(values3.length * 2);
    for (let i = -1, n = values3.length;++i < n; ) {
      Uint642.from(values3[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
    }
    return data;
  }
  static multiply(left3, right3) {
    const rtrn = new Uint642(new Uint32Array(left3.buffer));
    return rtrn.times(right3);
  }
  static add(left3, right3) {
    const rtrn = new Uint642(new Uint32Array(left3.buffer));
    return rtrn.plus(right3);
  }
}

class Int642 extends BaseInt64 {
  negate() {
    this.buffer[0] = ~this.buffer[0] + 1;
    this.buffer[1] = ~this.buffer[1];
    if (this.buffer[0] == 0) {
      ++this.buffer[1];
    }
    return this;
  }
  times(other) {
    this._times(other);
    return this;
  }
  plus(other) {
    this._plus(other);
    return this;
  }
  lessThan(other) {
    const this_high = this.buffer[1] << 0;
    const other_high = other.buffer[1] << 0;
    return this_high < other_high || this_high === other_high && this.buffer[0] < other.buffer[0];
  }
  static from(val, out_buffer = new Uint32Array(2)) {
    return Int642.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
  }
  static fromNumber(num, out_buffer = new Uint32Array(2)) {
    return Int642.fromString(num.toString(), out_buffer);
  }
  static fromString(str, out_buffer = new Uint32Array(2)) {
    const negate3 = str.startsWith("-");
    const length3 = str.length;
    const out = new Int642(out_buffer);
    for (let posn = negate3 ? 1 : 0;posn < length3; ) {
      const group = kInt32DecimalDigits < length3 - posn ? kInt32DecimalDigits : length3 - posn;
      const chunk3 = new Int642(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));
      const multiple = new Int642(new Uint32Array([kPowersOfTen[group], 0]));
      out.times(multiple);
      out.plus(chunk3);
      posn += group;
    }
    return negate3 ? out.negate() : out;
  }
  static convertArray(values3) {
    const data = new Uint32Array(values3.length * 2);
    for (let i = -1, n = values3.length;++i < n; ) {
      Int642.from(values3[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
    }
    return data;
  }
  static multiply(left3, right3) {
    const rtrn = new Int642(new Uint32Array(left3.buffer));
    return rtrn.times(right3);
  }
  static add(left3, right3) {
    const rtrn = new Int642(new Uint32Array(left3.buffer));
    return rtrn.plus(right3);
  }
}

class Int128 {
  constructor(buffer3) {
    this.buffer = buffer3;
  }
  high() {
    return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
  }
  low() {
    return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
  }
  negate() {
    this.buffer[0] = ~this.buffer[0] + 1;
    this.buffer[1] = ~this.buffer[1];
    this.buffer[2] = ~this.buffer[2];
    this.buffer[3] = ~this.buffer[3];
    if (this.buffer[0] == 0) {
      ++this.buffer[1];
    }
    if (this.buffer[1] == 0) {
      ++this.buffer[2];
    }
    if (this.buffer[2] == 0) {
      ++this.buffer[3];
    }
    return this;
  }
  times(other) {
    const L0 = new Uint642(new Uint32Array([this.buffer[3], 0]));
    const L1 = new Uint642(new Uint32Array([this.buffer[2], 0]));
    const L2 = new Uint642(new Uint32Array([this.buffer[1], 0]));
    const L3 = new Uint642(new Uint32Array([this.buffer[0], 0]));
    const R0 = new Uint642(new Uint32Array([other.buffer[3], 0]));
    const R1 = new Uint642(new Uint32Array([other.buffer[2], 0]));
    const R2 = new Uint642(new Uint32Array([other.buffer[1], 0]));
    const R3 = new Uint642(new Uint32Array([other.buffer[0], 0]));
    let product = Uint642.multiply(L3, R3);
    this.buffer[0] = product.low();
    const sum3 = new Uint642(new Uint32Array([product.high(), 0]));
    product = Uint642.multiply(L2, R3);
    sum3.plus(product);
    product = Uint642.multiply(L3, R2);
    sum3.plus(product);
    this.buffer[1] = sum3.low();
    this.buffer[3] = sum3.lessThan(product) ? 1 : 0;
    this.buffer[2] = sum3.high();
    const high = new Uint642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
    high.plus(Uint642.multiply(L1, R3)).plus(Uint642.multiply(L2, R2)).plus(Uint642.multiply(L3, R1));
    this.buffer[3] += Uint642.multiply(L0, R3).plus(Uint642.multiply(L1, R2)).plus(Uint642.multiply(L2, R1)).plus(Uint642.multiply(L3, R0)).low();
    return this;
  }
  plus(other) {
    const sums = new Uint32Array(4);
    sums[3] = this.buffer[3] + other.buffer[3] >>> 0;
    sums[2] = this.buffer[2] + other.buffer[2] >>> 0;
    sums[1] = this.buffer[1] + other.buffer[1] >>> 0;
    sums[0] = this.buffer[0] + other.buffer[0] >>> 0;
    if (sums[0] < this.buffer[0] >>> 0) {
      ++sums[1];
    }
    if (sums[1] < this.buffer[1] >>> 0) {
      ++sums[2];
    }
    if (sums[2] < this.buffer[2] >>> 0) {
      ++sums[3];
    }
    this.buffer[3] = sums[3];
    this.buffer[2] = sums[2];
    this.buffer[1] = sums[1];
    this.buffer[0] = sums[0];
    return this;
  }
  hex() {
    return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
  }
  static multiply(left3, right3) {
    const rtrn = new Int128(new Uint32Array(left3.buffer));
    return rtrn.times(right3);
  }
  static add(left3, right3) {
    const rtrn = new Int128(new Uint32Array(left3.buffer));
    return rtrn.plus(right3);
  }
  static from(val, out_buffer = new Uint32Array(4)) {
    return Int128.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
  }
  static fromNumber(num, out_buffer = new Uint32Array(4)) {
    return Int128.fromString(num.toString(), out_buffer);
  }
  static fromString(str, out_buffer = new Uint32Array(4)) {
    const negate3 = str.startsWith("-");
    const length3 = str.length;
    const out = new Int128(out_buffer);
    for (let posn = negate3 ? 1 : 0;posn < length3; ) {
      const group = kInt32DecimalDigits < length3 - posn ? kInt32DecimalDigits : length3 - posn;
      const chunk3 = new Int128(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0, 0, 0]));
      const multiple = new Int128(new Uint32Array([kPowersOfTen[group], 0, 0, 0]));
      out.times(multiple);
      out.plus(chunk3);
      posn += group;
    }
    return negate3 ? out.negate() : out;
  }
  static convertArray(values3) {
    const data = new Uint32Array(values3.length * 4);
    for (let i = -1, n = values3.length;++i < n; ) {
      Int128.from(values3[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));
    }
    return data;
  }
}

// node_modules/apache-arrow/util/interval.mjs
var exports_interval2 = {};
__export(exports_interval2, {
  toIntervalMonthDayNanoObjects: () => toIntervalMonthDayNanoObjects,
  toIntervalMonthDayNanoInt32Array: () => toIntervalMonthDayNanoInt32Array,
  toIntervalDayTimeObjects: () => toIntervalDayTimeObjects,
  toIntervalDayTimeInt32Array: () => toIntervalDayTimeInt32Array
});
function toIntervalDayTimeInt32Array(objects) {
  var _a3, _b2;
  const length3 = objects.length;
  const array4 = new Int32Array(length3 * 2);
  for (let oi = 0, ai = 0;oi < length3; oi++) {
    const interval = objects[oi];
    array4[ai++] = (_a3 = interval["days"]) !== null && _a3 !== undefined ? _a3 : 0;
    array4[ai++] = (_b2 = interval["milliseconds"]) !== null && _b2 !== undefined ? _b2 : 0;
  }
  return array4;
}
function toIntervalMonthDayNanoInt32Array(objects) {
  var _a3, _b2;
  const length3 = objects.length;
  const data = new Int32Array(length3 * 4);
  for (let oi = 0, ai = 0;oi < length3; oi++) {
    const interval = objects[oi];
    data[ai++] = (_a3 = interval["months"]) !== null && _a3 !== undefined ? _a3 : 0;
    data[ai++] = (_b2 = interval["days"]) !== null && _b2 !== undefined ? _b2 : 0;
    const nanoseconds = interval["nanoseconds"];
    if (nanoseconds) {
      data[ai++] = Number(BigInt(nanoseconds) & BigInt(4294967295));
      data[ai++] = Number(BigInt(nanoseconds) >> BigInt(32));
    } else {
      ai += 2;
    }
  }
  return data;
}
function toIntervalDayTimeObjects(array4) {
  const length3 = array4.length;
  const objects = new Array(length3 / 2);
  for (let ai = 0, oi = 0;ai < length3; ai += 2) {
    objects[oi++] = {
      days: array4[ai],
      milliseconds: array4[ai + 1]
    };
  }
  return objects;
}
function toIntervalMonthDayNanoObjects(array4, stringifyNano) {
  const length3 = array4.length;
  const objects = new Array(length3 / 4);
  for (let ai = 0, oi = 0;ai < length3; ai += 4) {
    const nanoseconds = BigInt(array4[ai + 3]) << BigInt(32) | BigInt(array4[ai + 2] >>> 0);
    objects[oi++] = {
      months: array4[ai],
      days: array4[ai + 1],
      nanoseconds: stringifyNano ? `${nanoseconds}` : nanoseconds
    };
  }
  return objects;
}

// node_modules/apache-arrow/visitor/vectorloader.mjs
class VectorLoader extends Visitor {
  constructor(bytes, nodes, buffers, dictionaries, metadataVersion = MetadataVersion.V5) {
    super();
    this.nodesIndex = -1;
    this.buffersIndex = -1;
    this.bytes = bytes;
    this.nodes = nodes;
    this.buffers = buffers;
    this.dictionaries = dictionaries;
    this.metadataVersion = metadataVersion;
  }
  visit(node) {
    return super.visit(node instanceof Field2 ? node.type : node);
  }
  visitNull(type, { length: length3 } = this.nextFieldNode()) {
    return makeData({ type, length: length3 });
  }
  visitBool(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitInt(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitFloat(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitUtf8(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
  }
  visitLargeUtf8(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
  }
  visitBinary(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
  }
  visitLargeBinary(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
  }
  visitFixedSizeBinary(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitDate(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitTimestamp(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitTime(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitDecimal(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitList(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), child: this.visit(type.children[0]) });
  }
  visitStruct(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), children: this.visitMany(type.children) });
  }
  visitUnion(type, { length: length3, nullCount } = this.nextFieldNode()) {
    if (this.metadataVersion < MetadataVersion.V5) {
      this.readNullBitmap(type, nullCount);
    }
    return type.mode === UnionMode.Sparse ? this.visitSparseUnion(type, { length: length3, nullCount }) : this.visitDenseUnion(type, { length: length3, nullCount });
  }
  visitDenseUnion(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, typeIds: this.readTypeIds(type), valueOffsets: this.readOffsets(type), children: this.visitMany(type.children) });
  }
  visitSparseUnion(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, typeIds: this.readTypeIds(type), children: this.visitMany(type.children) });
  }
  visitDictionary(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type.indices), dictionary: this.readDictionary(type) });
  }
  visitInterval(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitDuration(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
  }
  visitFixedSizeList(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), child: this.visit(type.children[0]) });
  }
  visitMap(type, { length: length3, nullCount } = this.nextFieldNode()) {
    return makeData({ type, length: length3, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), child: this.visit(type.children[0]) });
  }
  nextFieldNode() {
    return this.nodes[++this.nodesIndex];
  }
  nextBufferRange() {
    return this.buffers[++this.buffersIndex];
  }
  readNullBitmap(type, nullCount, buffer3 = this.nextBufferRange()) {
    return nullCount > 0 && this.readData(type, buffer3) || new Uint8Array(0);
  }
  readOffsets(type, buffer3) {
    return this.readData(type, buffer3);
  }
  readTypeIds(type, buffer3) {
    return this.readData(type, buffer3);
  }
  readData(_type, { length: length3, offset } = this.nextBufferRange()) {
    return this.bytes.subarray(offset, offset + length3);
  }
  readDictionary(type) {
    return this.dictionaries.get(type.id);
  }
}

class JSONVectorLoader extends VectorLoader {
  constructor(sources, nodes, buffers, dictionaries, metadataVersion) {
    super(new Uint8Array(0), nodes, buffers, dictionaries, metadataVersion);
    this.sources = sources;
  }
  readNullBitmap(_type, nullCount, { offset } = this.nextBufferRange()) {
    return nullCount <= 0 ? new Uint8Array(0) : packBools(this.sources[offset]);
  }
  readOffsets(_type, { offset } = this.nextBufferRange()) {
    return toArrayBufferView(Uint8Array, toArrayBufferView(_type.OffsetArrayType, this.sources[offset]));
  }
  readTypeIds(type, { offset } = this.nextBufferRange()) {
    return toArrayBufferView(Uint8Array, toArrayBufferView(type.ArrayType, this.sources[offset]));
  }
  readData(type, { offset } = this.nextBufferRange()) {
    const { sources } = this;
    if (DataType.isTimestamp(type)) {
      return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset]));
    } else if ((DataType.isInt(type) || DataType.isTime(type)) && type.bitWidth === 64 || DataType.isDuration(type)) {
      return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset]));
    } else if (DataType.isDate(type) && type.unit === DateUnit.MILLISECOND) {
      return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset]));
    } else if (DataType.isDecimal(type)) {
      return toArrayBufferView(Uint8Array, Int128.convertArray(sources[offset]));
    } else if (DataType.isBinary(type) || DataType.isLargeBinary(type) || DataType.isFixedSizeBinary(type)) {
      return binaryDataFromJSON(sources[offset]);
    } else if (DataType.isBool(type)) {
      return packBools(sources[offset]);
    } else if (DataType.isUtf8(type) || DataType.isLargeUtf8(type)) {
      return encodeUtf8(sources[offset].join(""));
    } else if (DataType.isInterval(type)) {
      switch (type.unit) {
        case IntervalUnit.DAY_TIME:
          return toIntervalDayTimeInt32Array(sources[offset]);
        case IntervalUnit.MONTH_DAY_NANO:
          return toIntervalMonthDayNanoInt32Array(sources[offset]);
        default:
          break;
      }
    }
    return toArrayBufferView(Uint8Array, toArrayBufferView(type.ArrayType, sources[offset].map((x) => +x)));
  }
}
function binaryDataFromJSON(values3) {
  const joined = values3.join("");
  const data = new Uint8Array(joined.length / 2);
  for (let i = 0;i < joined.length; i += 2) {
    data[i >> 1] = Number.parseInt(joined.slice(i, i + 2), 16);
  }
  return data;
}

class CompressedVectorLoader extends VectorLoader {
  constructor(bodyChunks, nodes, buffers, dictionaries, metadataVersion) {
    super(new Uint8Array(0), nodes, buffers, dictionaries, metadataVersion);
    this.bodyChunks = bodyChunks;
  }
  readData(_type, _buffer = this.nextBufferRange()) {
    return this.bodyChunks[this.buffersIndex];
  }
}

// node_modules/apache-arrow/builder/binary.mjs
class BinaryBuilder extends VariableWidthBuilder {
  constructor(opts) {
    super(opts);
    this._values = new BufferBuilder(Uint8Array);
  }
  get byteLength() {
    let size13 = this._pendingLength + this.length * 4;
    this._offsets && (size13 += this._offsets.byteLength);
    this._values && (size13 += this._values.byteLength);
    this._nulls && (size13 += this._nulls.byteLength);
    return size13;
  }
  setValue(index, value) {
    return super.setValue(index, toUint8Array(value));
  }
  _flushPending(pending3, pendingLength) {
    const offsets = this._offsets;
    const data = this._values.reserve(pendingLength).buffer;
    let offset = 0;
    for (const [index, value] of pending3) {
      if (value === undefined) {
        offsets.set(index, 0);
      } else {
        const length3 = value.length;
        data.set(value, offset);
        offsets.set(index, length3);
        offset += length3;
      }
    }
  }
}

// node_modules/apache-arrow/builder/largebinary.mjs
class LargeBinaryBuilder extends VariableWidthBuilder {
  constructor(opts) {
    super(opts);
    this._values = new BufferBuilder(Uint8Array);
  }
  get byteLength() {
    let size13 = this._pendingLength + this.length * 4;
    this._offsets && (size13 += this._offsets.byteLength);
    this._values && (size13 += this._values.byteLength);
    this._nulls && (size13 += this._nulls.byteLength);
    return size13;
  }
  setValue(index, value) {
    return super.setValue(index, toUint8Array(value));
  }
  _flushPending(pending3, pendingLength) {
    const offsets = this._offsets;
    const data = this._values.reserve(pendingLength).buffer;
    let offset = 0;
    for (const [index, value] of pending3) {
      if (value === undefined) {
        offsets.set(index, BigInt(0));
      } else {
        const length3 = value.length;
        data.set(value, offset);
        offsets.set(index, BigInt(length3));
        offset += length3;
      }
    }
  }
}

// node_modules/apache-arrow/builder/bool.mjs
class BoolBuilder extends Builder2 {
  constructor(options) {
    super(options);
    this._values = new BitmapBufferBuilder;
  }
  setValue(index, value) {
    this._values.set(index, +value);
  }
}

// node_modules/apache-arrow/builder/date.mjs
class DateBuilder extends FixedWidthBuilder {
}
DateBuilder.prototype._setValue = setDate;

class DateDayBuilder extends DateBuilder {
}
DateDayBuilder.prototype._setValue = setDateDay;

class DateMillisecondBuilder extends DateBuilder {
}
DateMillisecondBuilder.prototype._setValue = setDateMillisecond;

// node_modules/apache-arrow/builder/decimal.mjs
class DecimalBuilder extends FixedWidthBuilder {
}
DecimalBuilder.prototype._setValue = setDecimal;

// node_modules/apache-arrow/builder/dictionary.mjs
class DictionaryBuilder extends Builder2 {
  constructor({ type, nullValues: nulls, dictionaryHashFunction: hashFn }) {
    super({ type: new Dictionary(type.dictionary, type.indices, type.id, type.isOrdered) });
    this._nulls = null;
    this._dictionaryOffset = 0;
    this._keysToIndices = Object.create(null);
    this.indices = makeBuilder2({ type: this.type.indices, nullValues: nulls });
    this.dictionary = makeBuilder2({ type: this.type.dictionary, nullValues: null });
    if (typeof hashFn === "function") {
      this.valueToKey = hashFn;
    }
  }
  get values() {
    return this.indices.values;
  }
  get nullCount() {
    return this.indices.nullCount;
  }
  get nullBitmap() {
    return this.indices.nullBitmap;
  }
  get byteLength() {
    return this.indices.byteLength + this.dictionary.byteLength;
  }
  get reservedLength() {
    return this.indices.reservedLength + this.dictionary.reservedLength;
  }
  get reservedByteLength() {
    return this.indices.reservedByteLength + this.dictionary.reservedByteLength;
  }
  isValid(value) {
    return this.indices.isValid(value);
  }
  setValid(index, valid) {
    const indices = this.indices;
    valid = indices.setValid(index, valid);
    this.length = indices.length;
    return valid;
  }
  setValue(index, value) {
    const keysToIndices = this._keysToIndices;
    const key = this.valueToKey(value);
    let idx = keysToIndices[key];
    if (idx === undefined) {
      keysToIndices[key] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;
    }
    return this.indices.setValue(index, idx);
  }
  flush() {
    const type = this.type;
    const prev = this._dictionary;
    const curr = this.dictionary.toVector();
    const data = this.indices.flush().clone(type);
    data.dictionary = prev ? prev.concat(curr) : curr;
    this.finished || (this._dictionaryOffset += curr.length);
    this._dictionary = data.dictionary;
    this.clear();
    return data;
  }
  finish() {
    this.indices.finish();
    this.dictionary.finish();
    this._dictionaryOffset = 0;
    this._keysToIndices = Object.create(null);
    return super.finish();
  }
  clear() {
    this.indices.clear();
    this.dictionary.clear();
    return super.clear();
  }
  valueToKey(val) {
    return typeof val === "string" ? val : `${val}`;
  }
}

// node_modules/apache-arrow/builder/fixedsizebinary.mjs
class FixedSizeBinaryBuilder extends FixedWidthBuilder {
}
FixedSizeBinaryBuilder.prototype._setValue = setFixedSizeBinary;

// node_modules/apache-arrow/builder/fixedsizelist.mjs
class FixedSizeListBuilder extends Builder2 {
  setValue(index, value) {
    const [child] = this.children;
    const start3 = index * this.stride;
    for (let i = -1, n = this.stride;++i < n; ) {
      child.set(start3 + i, value[i]);
    }
  }
  setValid(index, valid) {
    if (!super.setValid(index, valid)) {
      this.children[0].setValid((index + 1) * this.stride - 1, false);
    }
    return valid;
  }
  addChild(child, name = "0") {
    if (this.numChildren > 0) {
      throw new Error("FixedSizeListBuilder can only have one child.");
    }
    const childIndex = this.children.push(child);
    this.type = new FixedSizeList2(this.type.listSize, new Field2(name, child.type, true));
    return childIndex;
  }
}

// node_modules/apache-arrow/builder/float.mjs
class FloatBuilder extends FixedWidthBuilder {
  setValue(index, value) {
    this._values.set(index, value);
  }
}

class Float16Builder extends FloatBuilder {
  setValue(index, value) {
    super.setValue(index, float64ToUint16(value));
  }
}

class Float32Builder extends FloatBuilder {
}

class Float64Builder extends FloatBuilder {
}

// node_modules/apache-arrow/builder/interval.mjs
class IntervalBuilder extends FixedWidthBuilder {
}
IntervalBuilder.prototype._setValue = setIntervalValue;

class IntervalDayTimeBuilder extends IntervalBuilder {
}
IntervalDayTimeBuilder.prototype._setValue = setIntervalDayTime;

class IntervalYearMonthBuilder extends IntervalBuilder {
}
IntervalYearMonthBuilder.prototype._setValue = setIntervalYearMonth;

class IntervalMonthDayNanoBuilder extends IntervalBuilder {
}
IntervalMonthDayNanoBuilder.prototype._setValue = setIntervalMonthDayNano;

// node_modules/apache-arrow/builder/duration.mjs
class DurationBuilder extends FixedWidthBuilder {
}
DurationBuilder.prototype._setValue = setDuration;

class DurationSecondBuilder extends DurationBuilder {
}
DurationSecondBuilder.prototype._setValue = setDurationSecond;

class DurationMillisecondBuilder extends DurationBuilder {
}
DurationMillisecondBuilder.prototype._setValue = setDurationMillisecond;

class DurationMicrosecondBuilder extends DurationBuilder {
}
DurationMicrosecondBuilder.prototype._setValue = setDurationMicrosecond;

class DurationNanosecondBuilder extends DurationBuilder {
}
DurationNanosecondBuilder.prototype._setValue = setDurationNanosecond;

// node_modules/apache-arrow/builder/int.mjs
class IntBuilder extends FixedWidthBuilder {
  setValue(index, value) {
    this._values.set(index, value);
  }
}

class Int8Builder extends IntBuilder {
}

class Int16Builder extends IntBuilder {
}

class Int32Builder extends IntBuilder {
}

class Int64Builder extends IntBuilder {
}

class Uint8Builder extends IntBuilder {
}

class Uint16Builder extends IntBuilder {
}

class Uint32Builder extends IntBuilder {
}

class Uint64Builder extends IntBuilder {
}

// node_modules/apache-arrow/builder/list.mjs
class ListBuilder extends VariableWidthBuilder {
  constructor(opts) {
    super(opts);
    this._offsets = new OffsetsBufferBuilder(opts.type);
  }
  addChild(child, name = "0") {
    if (this.numChildren > 0) {
      throw new Error("ListBuilder can only have one child.");
    }
    this.children[this.numChildren] = child;
    this.type = new List2(new Field2(name, child.type, true));
    return this.numChildren - 1;
  }
  _flushPending(pending3) {
    const offsets = this._offsets;
    const [child] = this.children;
    for (const [index, value] of pending3) {
      if (typeof value === "undefined") {
        offsets.set(index, 0);
      } else {
        const v = value;
        const n = v.length;
        const start3 = offsets.set(index, n).buffer[index];
        for (let i = -1;++i < n; ) {
          child.set(start3 + i, v[i]);
        }
      }
    }
  }
}

// node_modules/apache-arrow/builder/map.mjs
class MapBuilder extends VariableWidthBuilder {
  set(index, value) {
    return super.set(index, value);
  }
  setValue(index, value) {
    const row = value instanceof Map ? value : new Map(Object.entries(value));
    const pending3 = this._pending || (this._pending = new Map);
    const current2 = pending3.get(index);
    current2 && (this._pendingLength -= current2.size);
    this._pendingLength += row.size;
    pending3.set(index, row);
  }
  addChild(child, name = `${this.numChildren}`) {
    if (this.numChildren > 0) {
      throw new Error("ListBuilder can only have one child.");
    }
    this.children[this.numChildren] = child;
    this.type = new Map_(new Field2(name, child.type, true), this.type.keysSorted);
    return this.numChildren - 1;
  }
  _flushPending(pending3) {
    const offsets = this._offsets;
    const [child] = this.children;
    for (const [index, value] of pending3) {
      if (value === undefined) {
        offsets.set(index, 0);
      } else {
        let { [index]: idx, [index + 1]: end6 } = offsets.set(index, value.size).buffer;
        for (const val of value.entries()) {
          child.set(idx, val);
          if (++idx >= end6)
            break;
        }
      }
    }
  }
}

// node_modules/apache-arrow/builder/null.mjs
class NullBuilder extends Builder2 {
  setValue(index, value) {}
  setValid(index, valid) {
    this.length = Math.max(index + 1, this.length);
    return valid;
  }
}

// node_modules/apache-arrow/builder/struct.mjs
class StructBuilder extends Builder2 {
  setValue(index, value) {
    const { children: children2, type } = this;
    switch (Array.isArray(value) || value.constructor) {
      case true:
        return type.children.forEach((_, i) => children2[i].set(index, value[i]));
      case Map:
        return type.children.forEach((f, i) => children2[i].set(index, value.get(f.name)));
      default:
        return type.children.forEach((f, i) => children2[i].set(index, value[f.name]));
    }
  }
  setValid(index, valid) {
    if (!super.setValid(index, valid)) {
      this.children.forEach((child) => child.setValid(index, valid));
    }
    return valid;
  }
  addChild(child, name = `${this.numChildren}`) {
    const childIndex = this.children.push(child);
    this.type = new Struct2([...this.type.children, new Field2(name, child.type, true)]);
    return childIndex;
  }
}

// node_modules/apache-arrow/builder/timestamp.mjs
class TimestampBuilder extends FixedWidthBuilder {
}
TimestampBuilder.prototype._setValue = setTimestamp;

class TimestampSecondBuilder extends TimestampBuilder {
}
TimestampSecondBuilder.prototype._setValue = setTimestampSecond;

class TimestampMillisecondBuilder extends TimestampBuilder {
}
TimestampMillisecondBuilder.prototype._setValue = setTimestampMillisecond;

class TimestampMicrosecondBuilder extends TimestampBuilder {
}
TimestampMicrosecondBuilder.prototype._setValue = setTimestampMicrosecond;

class TimestampNanosecondBuilder extends TimestampBuilder {
}
TimestampNanosecondBuilder.prototype._setValue = setTimestampNanosecond;

// node_modules/apache-arrow/builder/time.mjs
class TimeBuilder extends FixedWidthBuilder {
}
TimeBuilder.prototype._setValue = setTime;

class TimeSecondBuilder extends TimeBuilder {
}
TimeSecondBuilder.prototype._setValue = setTimeSecond;

class TimeMillisecondBuilder extends TimeBuilder {
}
TimeMillisecondBuilder.prototype._setValue = setTimeMillisecond;

class TimeMicrosecondBuilder extends TimeBuilder {
}
TimeMicrosecondBuilder.prototype._setValue = setTimeMicrosecond;

class TimeNanosecondBuilder extends TimeBuilder {
}
TimeNanosecondBuilder.prototype._setValue = setTimeNanosecond;

// node_modules/apache-arrow/builder/union.mjs
class UnionBuilder extends Builder2 {
  constructor(options) {
    super(options);
    this._typeIds = new DataBufferBuilder(Int8Array, 0, 1);
    if (typeof options["valueToChildTypeId"] === "function") {
      this._valueToChildTypeId = options["valueToChildTypeId"];
    }
  }
  get typeIdToChildIndex() {
    return this.type.typeIdToChildIndex;
  }
  append(value, childTypeId) {
    return this.set(this.length, value, childTypeId);
  }
  set(index, value, childTypeId) {
    if (childTypeId === undefined) {
      childTypeId = this._valueToChildTypeId(this, value, index);
    }
    this.setValue(index, value, childTypeId);
    return this;
  }
  setValue(index, value, childTypeId) {
    this._typeIds.set(index, childTypeId);
    const childIndex = this.type.typeIdToChildIndex[childTypeId];
    const child = this.children[childIndex];
    child === null || child === undefined || child.set(index, value);
    this.length = Math.max(index + 1, this.length);
  }
  addChild(child, name = `${this.children.length}`) {
    const childTypeId = this.children.push(child);
    const { type: { children: children2, mode, typeIds } } = this;
    const fields = [...children2, new Field2(name, child.type)];
    this.type = new Union_(mode, [...typeIds, childTypeId], fields);
    return childTypeId;
  }
  _valueToChildTypeId(builder, value, offset) {
    throw new Error(`Cannot map UnionBuilder value to child typeId. Pass the \`childTypeId\` as the second argument to unionBuilder.append(), or supply a \`valueToChildTypeId\` function as part of the UnionBuilder constructor options.`);
  }
}

class SparseUnionBuilder extends UnionBuilder {
}

class DenseUnionBuilder extends UnionBuilder {
  constructor(options) {
    super(options);
    this._offsets = new DataBufferBuilder(Int32Array);
  }
  setValue(index, value, childTypeId) {
    const id2 = this._typeIds.set(index, childTypeId).buffer[index];
    const child = this.getChildAt(this.type.typeIdToChildIndex[id2]);
    const denseIndex = this._offsets.set(index, child.length).buffer[index];
    child === null || child === undefined || child.set(denseIndex, value);
    this.length = Math.max(index + 1, this.length);
  }
}

// node_modules/apache-arrow/builder/utf8.mjs
class Utf8Builder extends VariableWidthBuilder {
  constructor(opts) {
    super(opts);
    this._values = new BufferBuilder(Uint8Array);
  }
  get byteLength() {
    let size13 = this._pendingLength + this.length * 4;
    this._offsets && (size13 += this._offsets.byteLength);
    this._values && (size13 += this._values.byteLength);
    this._nulls && (size13 += this._nulls.byteLength);
    return size13;
  }
  setValue(index, value) {
    return super.setValue(index, encodeUtf8(value));
  }
  _flushPending(pending3, pendingLength) {}
}
Utf8Builder.prototype._flushPending = BinaryBuilder.prototype._flushPending;

// node_modules/apache-arrow/builder/largeutf8.mjs
class LargeUtf8Builder extends VariableWidthBuilder {
  constructor(opts) {
    super(opts);
    this._values = new BufferBuilder(Uint8Array);
  }
  get byteLength() {
    let size13 = this._pendingLength + this.length * 4;
    this._offsets && (size13 += this._offsets.byteLength);
    this._values && (size13 += this._values.byteLength);
    this._nulls && (size13 += this._nulls.byteLength);
    return size13;
  }
  setValue(index, value) {
    return super.setValue(index, encodeUtf8(value));
  }
  _flushPending(pending3, pendingLength) {}
}
LargeUtf8Builder.prototype._flushPending = LargeBinaryBuilder.prototype._flushPending;

// node_modules/apache-arrow/visitor/builderctor.mjs
class GetBuilderCtor extends Visitor {
  visitNull() {
    return NullBuilder;
  }
  visitBool() {
    return BoolBuilder;
  }
  visitInt() {
    return IntBuilder;
  }
  visitInt8() {
    return Int8Builder;
  }
  visitInt16() {
    return Int16Builder;
  }
  visitInt32() {
    return Int32Builder;
  }
  visitInt64() {
    return Int64Builder;
  }
  visitUint8() {
    return Uint8Builder;
  }
  visitUint16() {
    return Uint16Builder;
  }
  visitUint32() {
    return Uint32Builder;
  }
  visitUint64() {
    return Uint64Builder;
  }
  visitFloat() {
    return FloatBuilder;
  }
  visitFloat16() {
    return Float16Builder;
  }
  visitFloat32() {
    return Float32Builder;
  }
  visitFloat64() {
    return Float64Builder;
  }
  visitUtf8() {
    return Utf8Builder;
  }
  visitLargeUtf8() {
    return LargeUtf8Builder;
  }
  visitBinary() {
    return BinaryBuilder;
  }
  visitLargeBinary() {
    return LargeBinaryBuilder;
  }
  visitFixedSizeBinary() {
    return FixedSizeBinaryBuilder;
  }
  visitDate() {
    return DateBuilder;
  }
  visitDateDay() {
    return DateDayBuilder;
  }
  visitDateMillisecond() {
    return DateMillisecondBuilder;
  }
  visitTimestamp() {
    return TimestampBuilder;
  }
  visitTimestampSecond() {
    return TimestampSecondBuilder;
  }
  visitTimestampMillisecond() {
    return TimestampMillisecondBuilder;
  }
  visitTimestampMicrosecond() {
    return TimestampMicrosecondBuilder;
  }
  visitTimestampNanosecond() {
    return TimestampNanosecondBuilder;
  }
  visitTime() {
    return TimeBuilder;
  }
  visitTimeSecond() {
    return TimeSecondBuilder;
  }
  visitTimeMillisecond() {
    return TimeMillisecondBuilder;
  }
  visitTimeMicrosecond() {
    return TimeMicrosecondBuilder;
  }
  visitTimeNanosecond() {
    return TimeNanosecondBuilder;
  }
  visitDecimal() {
    return DecimalBuilder;
  }
  visitList() {
    return ListBuilder;
  }
  visitStruct() {
    return StructBuilder;
  }
  visitUnion() {
    return UnionBuilder;
  }
  visitDenseUnion() {
    return DenseUnionBuilder;
  }
  visitSparseUnion() {
    return SparseUnionBuilder;
  }
  visitDictionary() {
    return DictionaryBuilder;
  }
  visitInterval() {
    return IntervalBuilder;
  }
  visitIntervalDayTime() {
    return IntervalDayTimeBuilder;
  }
  visitIntervalYearMonth() {
    return IntervalYearMonthBuilder;
  }
  visitIntervalMonthDayNano() {
    return IntervalMonthDayNanoBuilder;
  }
  visitDuration() {
    return DurationBuilder;
  }
  visitDurationSecond() {
    return DurationSecondBuilder;
  }
  visitDurationMillisecond() {
    return DurationMillisecondBuilder;
  }
  visitDurationMicrosecond() {
    return DurationMicrosecondBuilder;
  }
  visitDurationNanosecond() {
    return DurationNanosecondBuilder;
  }
  visitFixedSizeList() {
    return FixedSizeListBuilder;
  }
  visitMap() {
    return MapBuilder;
  }
}
var instance6 = new GetBuilderCtor;

// node_modules/apache-arrow/visitor/typecomparator.mjs
class TypeComparator extends Visitor {
  compareSchemas(schema, other) {
    return schema === other || other instanceof schema.constructor && this.compareManyFields(schema.fields, other.fields);
  }
  compareManyFields(fields, others) {
    return fields === others || Array.isArray(fields) && Array.isArray(others) && fields.length === others.length && fields.every((f, i) => this.compareFields(f, others[i]));
  }
  compareFields(field, other) {
    return field === other || other instanceof field.constructor && field.name === other.name && field.nullable === other.nullable && this.visit(field.type, other.type);
  }
}
function compareConstructor(type, other) {
  return other instanceof type.constructor;
}
function compareAny(type, other) {
  return type === other || compareConstructor(type, other);
}
function compareInt(type, other) {
  return type === other || compareConstructor(type, other) && type.bitWidth === other.bitWidth && type.isSigned === other.isSigned;
}
function compareFloat(type, other) {
  return type === other || compareConstructor(type, other) && type.precision === other.precision;
}
function compareFixedSizeBinary(type, other) {
  return type === other || compareConstructor(type, other) && type.byteWidth === other.byteWidth;
}
function compareDate(type, other) {
  return type === other || compareConstructor(type, other) && type.unit === other.unit;
}
function compareTimestamp(type, other) {
  return type === other || compareConstructor(type, other) && type.unit === other.unit && type.timezone === other.timezone;
}
function compareTime(type, other) {
  return type === other || compareConstructor(type, other) && type.unit === other.unit && type.bitWidth === other.bitWidth;
}
function compareList(type, other) {
  return type === other || compareConstructor(type, other) && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
}
function compareStruct(type, other) {
  return type === other || compareConstructor(type, other) && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
}
function compareUnion(type, other) {
  return type === other || compareConstructor(type, other) && type.mode === other.mode && type.typeIds.every((x, i) => x === other.typeIds[i]) && instance7.compareManyFields(type.children, other.children);
}
function compareDictionary(type, other) {
  return type === other || compareConstructor(type, other) && type.id === other.id && type.isOrdered === other.isOrdered && instance7.visit(type.indices, other.indices) && instance7.visit(type.dictionary, other.dictionary);
}
function compareInterval(type, other) {
  return type === other || compareConstructor(type, other) && type.unit === other.unit;
}
function compareDuration(type, other) {
  return type === other || compareConstructor(type, other) && type.unit === other.unit;
}
function compareFixedSizeList(type, other) {
  return type === other || compareConstructor(type, other) && type.listSize === other.listSize && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
}
function compareMap(type, other) {
  return type === other || compareConstructor(type, other) && type.keysSorted === other.keysSorted && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
}
TypeComparator.prototype.visitNull = compareAny;
TypeComparator.prototype.visitBool = compareAny;
TypeComparator.prototype.visitInt = compareInt;
TypeComparator.prototype.visitInt8 = compareInt;
TypeComparator.prototype.visitInt16 = compareInt;
TypeComparator.prototype.visitInt32 = compareInt;
TypeComparator.prototype.visitInt64 = compareInt;
TypeComparator.prototype.visitUint8 = compareInt;
TypeComparator.prototype.visitUint16 = compareInt;
TypeComparator.prototype.visitUint32 = compareInt;
TypeComparator.prototype.visitUint64 = compareInt;
TypeComparator.prototype.visitFloat = compareFloat;
TypeComparator.prototype.visitFloat16 = compareFloat;
TypeComparator.prototype.visitFloat32 = compareFloat;
TypeComparator.prototype.visitFloat64 = compareFloat;
TypeComparator.prototype.visitUtf8 = compareAny;
TypeComparator.prototype.visitLargeUtf8 = compareAny;
TypeComparator.prototype.visitBinary = compareAny;
TypeComparator.prototype.visitLargeBinary = compareAny;
TypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;
TypeComparator.prototype.visitDate = compareDate;
TypeComparator.prototype.visitDateDay = compareDate;
TypeComparator.prototype.visitDateMillisecond = compareDate;
TypeComparator.prototype.visitTimestamp = compareTimestamp;
TypeComparator.prototype.visitTimestampSecond = compareTimestamp;
TypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;
TypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;
TypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;
TypeComparator.prototype.visitTime = compareTime;
TypeComparator.prototype.visitTimeSecond = compareTime;
TypeComparator.prototype.visitTimeMillisecond = compareTime;
TypeComparator.prototype.visitTimeMicrosecond = compareTime;
TypeComparator.prototype.visitTimeNanosecond = compareTime;
TypeComparator.prototype.visitDecimal = compareAny;
TypeComparator.prototype.visitList = compareList;
TypeComparator.prototype.visitStruct = compareStruct;
TypeComparator.prototype.visitUnion = compareUnion;
TypeComparator.prototype.visitDenseUnion = compareUnion;
TypeComparator.prototype.visitSparseUnion = compareUnion;
TypeComparator.prototype.visitDictionary = compareDictionary;
TypeComparator.prototype.visitInterval = compareInterval;
TypeComparator.prototype.visitIntervalDayTime = compareInterval;
TypeComparator.prototype.visitIntervalYearMonth = compareInterval;
TypeComparator.prototype.visitIntervalMonthDayNano = compareInterval;
TypeComparator.prototype.visitDuration = compareDuration;
TypeComparator.prototype.visitDurationSecond = compareDuration;
TypeComparator.prototype.visitDurationMillisecond = compareDuration;
TypeComparator.prototype.visitDurationMicrosecond = compareDuration;
TypeComparator.prototype.visitDurationNanosecond = compareDuration;
TypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;
TypeComparator.prototype.visitMap = compareMap;
var instance7 = new TypeComparator;
function compareSchemas(schema, other) {
  return instance7.compareSchemas(schema, other);
}
function compareFields(field, other) {
  return instance7.compareFields(field, other);
}
function compareTypes(type, other) {
  return instance7.visit(type, other);
}

// node_modules/apache-arrow/factories.mjs
function makeBuilder2(options) {
  const type = options.type;
  const builder = new (instance6.getVisitFn(type)())(options);
  if (type.children && type.children.length > 0) {
    const children2 = options["children"] || [];
    const defaultOptions = { nullValues: options["nullValues"] };
    const getChildOptions = Array.isArray(children2) ? (_, i) => children2[i] || defaultOptions : ({ name }) => children2[name] || defaultOptions;
    for (const [index, field] of type.children.entries()) {
      const { type: type2 } = field;
      const opts = getChildOptions(field, index);
      builder.children.push(makeBuilder2(Object.assign(Object.assign({}, opts), { type: type2 })));
    }
  }
  return builder;
}

// node_modules/apache-arrow/util/recordbatch.mjs
function distributeVectorsIntoRecordBatches(schema, vecs) {
  return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v) => v.data.concat()));
}
function uniformlyDistributeChunksAcrossRecordBatches(schema, cols) {
  const fields = [...schema.fields];
  const batches = [];
  const memo = { numBatches: cols.reduce((n, c) => Math.max(n, c.length), 0) };
  let numBatches = 0, batchLength = 0;
  let i = -1;
  const numColumns = cols.length;
  let child, children2 = [];
  while (memo.numBatches-- > 0) {
    for (batchLength = Number.POSITIVE_INFINITY, i = -1;++i < numColumns; ) {
      children2[i] = child = cols[i].shift();
      batchLength = Math.min(batchLength, child ? child.length : batchLength);
    }
    if (Number.isFinite(batchLength)) {
      children2 = distributeChildren(fields, batchLength, children2, cols, memo);
      if (batchLength > 0) {
        batches[numBatches++] = makeData({
          type: new Struct2(fields),
          length: batchLength,
          nullCount: 0,
          children: children2.slice()
        });
      }
    }
  }
  return [
    schema = schema.assign(fields),
    batches.map((data) => new RecordBatch4(schema, data))
  ];
}
function distributeChildren(fields, batchLength, children2, columns, memo) {
  var _a3;
  const nullBitmapSize = (batchLength + 63 & ~63) >> 3;
  for (let i = -1, n = columns.length;++i < n; ) {
    const child = children2[i];
    const length3 = child === null || child === undefined ? undefined : child.length;
    if (length3 >= batchLength) {
      if (length3 === batchLength) {
        children2[i] = child;
      } else {
        children2[i] = child.slice(0, batchLength);
        memo.numBatches = Math.max(memo.numBatches, columns[i].unshift(child.slice(batchLength, length3 - batchLength)));
      }
    } else {
      const field = fields[i];
      fields[i] = field.clone({ nullable: true });
      children2[i] = (_a3 = child === null || child === undefined ? undefined : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a3 !== undefined ? _a3 : makeData({
        type: field.type,
        length: batchLength,
        nullCount: batchLength,
        nullBitmap: new Uint8Array(nullBitmapSize)
      });
    }
  }
  return children2;
}

// node_modules/apache-arrow/table.mjs
var _a3;

class Table2 {
  constructor(...args2) {
    var _b2, _c2;
    if (args2.length === 0) {
      this.batches = [];
      this.schema = new Schema3([]);
      this._offsets = [0];
      return this;
    }
    let schema;
    let offsets;
    if (args2[0] instanceof Schema3) {
      schema = args2.shift();
    }
    if (args2.at(-1) instanceof Uint32Array) {
      offsets = args2.pop();
    }
    const unwrap4 = (x) => {
      if (x) {
        if (x instanceof RecordBatch4) {
          return [x];
        } else if (x instanceof Table2) {
          return x.batches;
        } else if (x instanceof Data) {
          if (x.type instanceof Struct2) {
            return [new RecordBatch4(new Schema3(x.type.children), x)];
          }
        } else if (Array.isArray(x)) {
          return x.flatMap((v) => unwrap4(v));
        } else if (typeof x[Symbol.iterator] === "function") {
          return [...x].flatMap((v) => unwrap4(v));
        } else if (typeof x === "object") {
          const keys3 = Object.keys(x);
          const vecs = keys3.map((k) => new Vector([x[k]]));
          const batchSchema = schema !== null && schema !== undefined ? schema : new Schema3(keys3.map((k, i) => new Field2(String(k), vecs[i].type, vecs[i].nullable)));
          const [, batches2] = distributeVectorsIntoRecordBatches(batchSchema, vecs);
          return batches2.length === 0 ? [new RecordBatch4(x)] : batches2;
        }
      }
      return [];
    };
    const batches = args2.flatMap((v) => unwrap4(v));
    schema = (_c2 = schema !== null && schema !== undefined ? schema : (_b2 = batches[0]) === null || _b2 === undefined ? undefined : _b2.schema) !== null && _c2 !== undefined ? _c2 : new Schema3([]);
    if (!(schema instanceof Schema3)) {
      throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
    }
    for (const batch of batches) {
      if (!(batch instanceof RecordBatch4)) {
        throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
      }
      if (!compareSchemas(schema, batch.schema)) {
        throw new TypeError("Table and inner RecordBatch schemas must be equivalent.");
      }
    }
    this.schema = schema;
    this.batches = batches;
    this._offsets = offsets !== null && offsets !== undefined ? offsets : computeChunkOffsets(this.data);
  }
  get data() {
    return this.batches.map(({ data }) => data);
  }
  get numCols() {
    return this.schema.fields.length;
  }
  get numRows() {
    return this.data.reduce((numRows, data) => numRows + data.length, 0);
  }
  get nullCount() {
    if (this._nullCount === -1) {
      this._nullCount = computeChunkNullCounts(this.data);
    }
    return this._nullCount;
  }
  isValid(index) {
    return false;
  }
  get(index) {
    return null;
  }
  at(index) {
    return this.get(wrapIndex(index, this.numRows));
  }
  set(index, value) {
    return;
  }
  indexOf(element, offset) {
    return -1;
  }
  [Symbol.iterator]() {
    if (this.batches.length > 0) {
      return instance4.visit(new Vector(this.data));
    }
    return new Array(0)[Symbol.iterator]();
  }
  toArray() {
    return [...this];
  }
  toString() {
    return `[
  ${this.toArray().join(`,
  `)}
]`;
  }
  concat(...others) {
    const schema = this.schema;
    const data = this.data.concat(others.flatMap(({ data: data2 }) => data2));
    return new Table2(schema, data.map((data2) => new RecordBatch4(schema, data2)));
  }
  slice(begin, end6) {
    const schema = this.schema;
    [begin, end6] = clampRange({ length: this.numRows }, begin, end6);
    const data = sliceChunks(this.data, this._offsets, begin, end6);
    return new Table2(schema, data.map((chunk3) => new RecordBatch4(schema, chunk3)));
  }
  getChild(name) {
    return this.getChildAt(this.schema.fields.findIndex((f) => f.name === name));
  }
  getChildAt(index) {
    if (index > -1 && index < this.schema.fields.length) {
      const data = this.data.map((data2) => data2.children[index]);
      if (data.length === 0) {
        const { type } = this.schema.fields[index];
        const empty31 = makeData({ type, length: 0, nullCount: 0 });
        data.push(empty31._changeLengthAndBackfillNullBitmap(this.numRows));
      }
      return new Vector(data);
    }
    return null;
  }
  setChild(name, child) {
    var _b2;
    return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === undefined ? undefined : _b2.findIndex((f) => f.name === name), child);
  }
  setChildAt(index, child) {
    let schema = this.schema;
    let batches = [...this.batches];
    if (index > -1 && index < this.numCols) {
      if (!child) {
        child = new Vector([makeData({ type: new Null2, length: this.numRows })]);
      }
      const fields = schema.fields.slice();
      const field = fields[index].clone({ type: child.type });
      const children2 = this.schema.fields.map((_, i) => this.getChildAt(i));
      [fields[index], children2[index]] = [field, child];
      [schema, batches] = distributeVectorsIntoRecordBatches(schema, children2);
    }
    return new Table2(schema, batches);
  }
  select(columnNames) {
    const nameToIndex = this.schema.fields.reduce((m, f, i) => m.set(f.name, i), new Map);
    return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x) => x > -1));
  }
  selectAt(columnIndices) {
    const schema = this.schema.selectAt(columnIndices);
    const data = this.batches.map((batch) => batch.selectAt(columnIndices));
    return new Table2(schema, data);
  }
  assign(other) {
    const fields = this.schema.fields;
    const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {
      const [indices2, oldToNew2] = memo;
      const i = fields.findIndex((f) => f.name === f2.name);
      ~i ? oldToNew2[i] = newIdx : indices2.push(newIdx);
      return memo;
    }, [[], []]);
    const schema = this.schema.assign(other.schema);
    const columns = [
      ...fields.map((_, i) => [i, oldToNew[i]]).map(([i, j]) => j === undefined ? this.getChildAt(i) : other.getChildAt(j)),
      ...indices.map((i) => other.getChildAt(i))
    ].filter(Boolean);
    return new Table2(...distributeVectorsIntoRecordBatches(schema, columns));
  }
}
_a3 = Symbol.toStringTag;
Table2[_a3] = ((proto12) => {
  proto12.schema = null;
  proto12.batches = [];
  proto12._offsets = new Uint32Array([0]);
  proto12._nullCount = -1;
  proto12[Symbol.isConcatSpreadable] = true;
  proto12["isValid"] = wrapChunkedCall1(isChunkedValid);
  proto12["get"] = wrapChunkedCall1(instance2.getVisitFn(Type4.Struct));
  proto12["set"] = wrapChunkedCall2(instance.getVisitFn(Type4.Struct));
  proto12["indexOf"] = wrapChunkedIndexOf(instance3.getVisitFn(Type4.Struct));
  return "Table";
})(Table2.prototype);

// node_modules/apache-arrow/recordbatch.mjs
var _a4;

class RecordBatch4 {
  constructor(...args2) {
    switch (args2.length) {
      case 2: {
        [this.schema] = args2;
        if (!(this.schema instanceof Schema3)) {
          throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
        }
        [
          ,
          this.data = makeData({
            nullCount: 0,
            type: new Struct2(this.schema.fields),
            children: this.schema.fields.map((f) => makeData({ type: f.type, nullCount: 0 }))
          })
        ] = args2;
        if (!(this.data instanceof Data)) {
          throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
        }
        [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);
        break;
      }
      case 1: {
        const [obj] = args2;
        const { fields, children: children2, length: length3 } = Object.keys(obj).reduce((memo, name, i) => {
          memo.children[i] = obj[name];
          memo.length = Math.max(memo.length, obj[name].length);
          memo.fields[i] = Field2.new({ name, type: obj[name].type, nullable: true });
          return memo;
        }, {
          length: 0,
          fields: new Array,
          children: new Array
        });
        const schema = new Schema3(fields);
        const data = makeData({ type: new Struct2(fields), length: length3, children: children2, nullCount: 0 });
        [this.schema, this.data] = ensureSameLengthData(schema, data.children, length3);
        break;
      }
      default:
        throw new TypeError("RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.");
    }
  }
  get dictionaries() {
    return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));
  }
  get numCols() {
    return this.schema.fields.length;
  }
  get numRows() {
    return this.data.length;
  }
  get nullCount() {
    return this.data.nullCount;
  }
  isValid(index) {
    return this.data.getValid(index);
  }
  get(index) {
    return instance2.visit(this.data, index);
  }
  at(index) {
    return this.get(wrapIndex(index, this.numRows));
  }
  set(index, value) {
    return instance.visit(this.data, index, value);
  }
  indexOf(element, offset) {
    return instance3.visit(this.data, element, offset);
  }
  [Symbol.iterator]() {
    return instance4.visit(new Vector([this.data]));
  }
  toArray() {
    return [...this];
  }
  concat(...others) {
    return new Table2(this.schema, [this, ...others]);
  }
  slice(begin, end6) {
    const [slice] = new Vector([this.data]).slice(begin, end6).data;
    return new RecordBatch4(this.schema, slice);
  }
  getChild(name) {
    var _b2;
    return this.getChildAt((_b2 = this.schema.fields) === null || _b2 === undefined ? undefined : _b2.findIndex((f) => f.name === name));
  }
  getChildAt(index) {
    if (index > -1 && index < this.schema.fields.length) {
      return new Vector([this.data.children[index]]);
    }
    return null;
  }
  setChild(name, child) {
    var _b2;
    return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === undefined ? undefined : _b2.findIndex((f) => f.name === name), child);
  }
  setChildAt(index, child) {
    let schema = this.schema;
    let data = this.data;
    if (index > -1 && index < this.numCols) {
      if (!child) {
        child = new Vector([makeData({ type: new Null2, length: this.numRows })]);
      }
      const fields = schema.fields.slice();
      const children2 = data.children.slice();
      const field = fields[index].clone({ type: child.type });
      [fields[index], children2[index]] = [field, child.data[0]];
      schema = new Schema3(fields, new Map(this.schema.metadata));
      data = makeData({ type: new Struct2(fields), children: children2 });
    }
    return new RecordBatch4(schema, data);
  }
  select(columnNames) {
    const schema = this.schema.select(columnNames);
    const type = new Struct2(schema.fields);
    const children2 = [];
    for (const name of columnNames) {
      const index = this.schema.fields.findIndex((f) => f.name === name);
      if (~index) {
        children2[index] = this.data.children[index];
      }
    }
    return new RecordBatch4(schema, makeData({ type, length: this.numRows, children: children2 }));
  }
  selectAt(columnIndices) {
    const schema = this.schema.selectAt(columnIndices);
    const children2 = columnIndices.map((i) => this.data.children[i]).filter(Boolean);
    const subset = makeData({ type: new Struct2(schema.fields), length: this.numRows, children: children2 });
    return new RecordBatch4(schema, subset);
  }
}
_a4 = Symbol.toStringTag;
RecordBatch4[_a4] = ((proto12) => {
  proto12._nullCount = -1;
  proto12[Symbol.isConcatSpreadable] = true;
  return "RecordBatch";
})(RecordBatch4.prototype);
function ensureSameLengthData(schema, chunks3, maxLength = chunks3.reduce((max5, col) => Math.max(max5, col.length), 0)) {
  var _b2;
  const fields = [...schema.fields];
  const children2 = [...chunks3];
  const nullBitmapSize = (maxLength + 63 & ~63) >> 3;
  for (const [idx, field] of schema.fields.entries()) {
    const chunk3 = chunks3[idx];
    if (!chunk3 || chunk3.length !== maxLength) {
      fields[idx] = field.clone({ nullable: true });
      children2[idx] = (_b2 = chunk3 === null || chunk3 === undefined ? undefined : chunk3._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b2 !== undefined ? _b2 : makeData({
        type: field.type,
        length: maxLength,
        nullCount: maxLength,
        nullBitmap: new Uint8Array(nullBitmapSize)
      });
    }
  }
  return [
    schema.assign(fields),
    makeData({ type: new Struct2(fields), length: maxLength, children: children2 })
  ];
}
function collectDictionaries(fields, children2, dictionaries = new Map) {
  var _b2, _c2;
  if (((_b2 = fields === null || fields === undefined ? undefined : fields.length) !== null && _b2 !== undefined ? _b2 : 0) > 0 && (fields === null || fields === undefined ? undefined : fields.length) === (children2 === null || children2 === undefined ? undefined : children2.length)) {
    for (let i = -1, n = fields.length;++i < n; ) {
      const { type } = fields[i];
      const data = children2[i];
      for (const next of [data, ...((_c2 = data === null || data === undefined ? undefined : data.dictionary) === null || _c2 === undefined ? undefined : _c2.data) || []]) {
        collectDictionaries(type.children, next === null || next === undefined ? undefined : next.children, dictionaries);
      }
      if (DataType.isDictionary(type)) {
        const { id: id2 } = type;
        if (!dictionaries.has(id2)) {
          if (data === null || data === undefined ? undefined : data.dictionary) {
            dictionaries.set(id2, data.dictionary);
          }
        } else if (dictionaries.get(id2) !== data.dictionary) {
          throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
        }
      }
    }
  }
  return dictionaries;
}

class _InternalEmptyPlaceholderRecordBatch extends RecordBatch4 {
  constructor(schema) {
    const children2 = schema.fields.map((f) => makeData({ type: f.type }));
    const data = makeData({ type: new Struct2(schema.fields), nullCount: 0, children: children2 });
    super(schema, data);
  }
}

// node_modules/apache-arrow/ipc/message.mjs
var invalidMessageType = (type) => `Expected ${MessageHeader[type]} Message in stream, but was null or length 0.`;
var nullMessage = (type) => `Header pointer of flatbuffer-encoded ${MessageHeader[type]} Message is null or length 0.`;
var invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;
var invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;

class MessageReader {
  constructor(source) {
    this.source = source instanceof ByteStream ? source : new ByteStream(source);
  }
  [Symbol.iterator]() {
    return this;
  }
  next() {
    let r;
    if ((r = this.readMetadataLength()).done) {
      return ITERATOR_DONE;
    }
    if (r.value === -1 && (r = this.readMetadataLength()).done) {
      return ITERATOR_DONE;
    }
    if ((r = this.readMetadata(r.value)).done) {
      return ITERATOR_DONE;
    }
    return r;
  }
  throw(value) {
    return this.source.throw(value);
  }
  return(value) {
    return this.source.return(value);
  }
  readMessage(type) {
    let r;
    if ((r = this.next()).done) {
      return null;
    }
    if (type != null && r.value.headerType !== type) {
      throw new Error(invalidMessageType(type));
    }
    return r.value;
  }
  readMessageBody(bodyLength) {
    if (bodyLength <= 0) {
      return new Uint8Array(0);
    }
    const buf = toUint8Array(this.source.read(bodyLength));
    if (buf.byteLength < bodyLength) {
      throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
    }
    return buf.byteOffset % 8 === 0 && buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice();
  }
  readSchema(throwIfNull = false) {
    const type = MessageHeader.Schema;
    const message = this.readMessage(type);
    const schema = message === null || message === undefined ? undefined : message.header();
    if (throwIfNull && !schema) {
      throw new Error(nullMessage(type));
    }
    return schema;
  }
  readMetadataLength() {
    const buf = this.source.read(PADDING);
    const bb = buf && new ByteBuffer(buf);
    const len = (bb === null || bb === undefined ? undefined : bb.readInt32(0)) || 0;
    return { done: len === 0, value: len };
  }
  readMetadata(metadataLength) {
    const buf = this.source.read(metadataLength);
    if (!buf) {
      return ITERATOR_DONE;
    }
    if (buf.byteLength < metadataLength) {
      throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
    }
    return { done: false, value: Message2.decode(buf) };
  }
}

class AsyncMessageReader {
  constructor(source, byteLength) {
    this.source = source instanceof AsyncByteStream ? source : isFileHandle(source) ? new AsyncRandomAccessFile(source, byteLength) : new AsyncByteStream(source);
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  next() {
    return __awaiter(this, undefined, undefined, function* () {
      let r;
      if ((r = yield this.readMetadataLength()).done) {
        return ITERATOR_DONE;
      }
      if (r.value === -1 && (r = yield this.readMetadataLength()).done) {
        return ITERATOR_DONE;
      }
      if ((r = yield this.readMetadata(r.value)).done) {
        return ITERATOR_DONE;
      }
      return r;
    });
  }
  throw(value) {
    return __awaiter(this, undefined, undefined, function* () {
      return yield this.source.throw(value);
    });
  }
  return(value) {
    return __awaiter(this, undefined, undefined, function* () {
      return yield this.source.return(value);
    });
  }
  readMessage(type) {
    return __awaiter(this, undefined, undefined, function* () {
      let r;
      if ((r = yield this.next()).done) {
        return null;
      }
      if (type != null && r.value.headerType !== type) {
        throw new Error(invalidMessageType(type));
      }
      return r.value;
    });
  }
  readMessageBody(bodyLength) {
    return __awaiter(this, undefined, undefined, function* () {
      if (bodyLength <= 0) {
        return new Uint8Array(0);
      }
      const buf = toUint8Array(yield this.source.read(bodyLength));
      if (buf.byteLength < bodyLength) {
        throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
      }
      return buf.byteOffset % 8 === 0 && buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice();
    });
  }
  readSchema() {
    return __awaiter(this, arguments, undefined, function* (throwIfNull = false) {
      const type = MessageHeader.Schema;
      const message = yield this.readMessage(type);
      const schema = message === null || message === undefined ? undefined : message.header();
      if (throwIfNull && !schema) {
        throw new Error(nullMessage(type));
      }
      return schema;
    });
  }
  readMetadataLength() {
    return __awaiter(this, undefined, undefined, function* () {
      const buf = yield this.source.read(PADDING);
      const bb = buf && new ByteBuffer(buf);
      const len = (bb === null || bb === undefined ? undefined : bb.readInt32(0)) || 0;
      return { done: len === 0, value: len };
    });
  }
  readMetadata(metadataLength) {
    return __awaiter(this, undefined, undefined, function* () {
      const buf = yield this.source.read(metadataLength);
      if (!buf) {
        return ITERATOR_DONE;
      }
      if (buf.byteLength < metadataLength) {
        throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
      }
      return { done: false, value: Message2.decode(buf) };
    });
  }
}

class JSONMessageReader extends MessageReader {
  constructor(source) {
    super(new Uint8Array(0));
    this._schema = false;
    this._body = [];
    this._batchIndex = 0;
    this._dictionaryIndex = 0;
    this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);
  }
  next() {
    const { _json } = this;
    if (!this._schema) {
      this._schema = true;
      const message = Message2.fromJSON(_json.schema, MessageHeader.Schema);
      return { done: false, value: message };
    }
    if (this._dictionaryIndex < _json.dictionaries.length) {
      const batch = _json.dictionaries[this._dictionaryIndex++];
      this._body = batch["data"]["columns"];
      const message = Message2.fromJSON(batch, MessageHeader.DictionaryBatch);
      return { done: false, value: message };
    }
    if (this._batchIndex < _json.batches.length) {
      const batch = _json.batches[this._batchIndex++];
      this._body = batch["columns"];
      const message = Message2.fromJSON(batch, MessageHeader.RecordBatch);
      return { done: false, value: message };
    }
    this._body = [];
    return ITERATOR_DONE;
  }
  readMessageBody(_bodyLength) {
    return flattenDataSources(this._body);
    function flattenDataSources(xs) {
      return (xs || []).reduce((buffers, column) => [
        ...buffers,
        ...column["VALIDITY"] && [column["VALIDITY"]] || [],
        ...column["TYPE_ID"] && [column["TYPE_ID"]] || [],
        ...column["OFFSET"] && [column["OFFSET"]] || [],
        ...column["DATA"] && [column["DATA"]] || [],
        ...flattenDataSources(column["children"])
      ], []);
    }
  }
  readMessage(type) {
    let r;
    if ((r = this.next()).done) {
      return null;
    }
    if (type != null && r.value.headerType !== type) {
      throw new Error(invalidMessageType(type));
    }
    return r.value;
  }
  readSchema() {
    const type = MessageHeader.Schema;
    const message = this.readMessage(type);
    const schema = message === null || message === undefined ? undefined : message.header();
    if (!message || !schema) {
      throw new Error(nullMessage(type));
    }
    return schema;
  }
}
var PADDING = 4;
var MAGIC_STR = "ARROW1";
var MAGIC = new Uint8Array(MAGIC_STR.length);
for (let i = 0;i < MAGIC_STR.length; i += 1) {
  MAGIC[i] = MAGIC_STR.codePointAt(i);
}
function checkForMagicArrowString(buffer3, index = 0) {
  for (let i = -1, n = MAGIC.length;++i < n; ) {
    if (MAGIC[i] !== buffer3[index + i]) {
      return false;
    }
  }
  return true;
}
var magicLength = MAGIC.length;
var magicAndPadding = magicLength + PADDING;
var magicX2AndPadding = magicLength * 2 + PADDING;

// node_modules/apache-arrow/ipc/compression/validators.mjs
class Lz4FrameValidator {
  constructor() {
    this.LZ4_FRAME_MAGIC = new Uint8Array([4, 34, 77, 24]);
    this.MIN_HEADER_LENGTH = 7;
  }
  isValidCodecEncode(codec) {
    const testData = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);
    const compressed = codec.encode(testData);
    return this._isValidCompressed(compressed);
  }
  _isValidCompressed(buffer3) {
    return this._hasMinimumLength(buffer3) && this._hasValidMagicNumber(buffer3) && this._hasValidVersion(buffer3);
  }
  _hasMinimumLength(buffer3) {
    return buffer3.length >= this.MIN_HEADER_LENGTH;
  }
  _hasValidMagicNumber(buffer3) {
    return this.LZ4_FRAME_MAGIC.every((byte, i) => buffer3[i] === byte);
  }
  _hasValidVersion(buffer3) {
    const flg = buffer3[4];
    const versionBits = (flg & 192) >> 6;
    return versionBits === 1;
  }
}

class ZstdValidator {
  constructor() {
    this.ZSTD_MAGIC = new Uint8Array([40, 181, 47, 253]);
    this.MIN_HEADER_LENGTH = 6;
  }
  isValidCodecEncode(codec) {
    const testData = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);
    const compressed = codec.encode(testData);
    return this._isValidCompressed(compressed);
  }
  _isValidCompressed(buffer3) {
    return this._hasMinimumLength(buffer3) && this._hasValidMagicNumber(buffer3);
  }
  _hasMinimumLength(buffer3) {
    return buffer3.length >= this.MIN_HEADER_LENGTH;
  }
  _hasValidMagicNumber(buffer3) {
    return this.ZSTD_MAGIC.every((byte, i) => buffer3[i] === byte);
  }
}
var compressionValidators = {
  [CompressionType.LZ4_FRAME]: new Lz4FrameValidator,
  [CompressionType.ZSTD]: new ZstdValidator
};

// node_modules/apache-arrow/ipc/compression/registry.mjs
class _CompressionRegistry {
  constructor() {
    this.registry = {};
  }
  set(compression, codec) {
    if ((codec === null || codec === undefined ? undefined : codec.encode) && typeof codec.encode === "function" && !compressionValidators[compression].isValidCodecEncode(codec)) {
      throw new Error(`Encoder for ${CompressionType[compression]} is not valid.`);
    }
    this.registry[compression] = codec;
  }
  get(compression) {
    var _a5;
    return ((_a5 = this.registry) === null || _a5 === undefined ? undefined : _a5[compression]) || null;
  }
}
var compressionRegistry = new _CompressionRegistry;

// node_modules/apache-arrow/ipc/compression/constants.mjs
var LENGTH_NO_COMPRESSED_DATA = -1;
var COMPRESS_LENGTH_PREFIX = 8;

// node_modules/apache-arrow/ipc/reader.mjs
class RecordBatchReader extends ReadableInterop {
  constructor(impl) {
    super();
    this._impl = impl;
  }
  get closed() {
    return this._impl.closed;
  }
  get schema() {
    return this._impl.schema;
  }
  get autoDestroy() {
    return this._impl.autoDestroy;
  }
  get dictionaries() {
    return this._impl.dictionaries;
  }
  get numDictionaries() {
    return this._impl.numDictionaries;
  }
  get numRecordBatches() {
    return this._impl.numRecordBatches;
  }
  get footer() {
    return this._impl.isFile() ? this._impl.footer : null;
  }
  isSync() {
    return this._impl.isSync();
  }
  isAsync() {
    return this._impl.isAsync();
  }
  isFile() {
    return this._impl.isFile();
  }
  isStream() {
    return this._impl.isStream();
  }
  next() {
    return this._impl.next();
  }
  throw(value) {
    return this._impl.throw(value);
  }
  return(value) {
    return this._impl.return(value);
  }
  cancel() {
    return this._impl.cancel();
  }
  reset(schema) {
    this._impl.reset(schema);
    this._DOMStream = undefined;
    this._nodeStream = undefined;
    return this;
  }
  open(options) {
    const opening = this._impl.open(options);
    return isPromise(opening) ? opening.then(() => this) : this;
  }
  readRecordBatch(index) {
    return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
  toDOMStream() {
    return adapters_default.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });
  }
  toNodeStream() {
    return adapters_default.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: true });
  }
  static throughNode(options) {
    throw new Error(`"throughNode" not available in this environment`);
  }
  static throughDOM(writableStrategy, readableStrategy) {
    throw new Error(`"throughDOM" not available in this environment`);
  }
  static from(source) {
    if (source instanceof RecordBatchReader) {
      return source;
    } else if (isArrowJSON(source)) {
      return fromArrowJSON(source);
    } else if (isFileHandle(source)) {
      return fromFileHandle(source);
    } else if (isPromise(source)) {
      return (() => __awaiter(this, undefined, undefined, function* () {
        return yield RecordBatchReader.from(yield source);
      }))();
    } else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {
      return fromAsyncByteStream(new AsyncByteStream(source));
    }
    return fromByteStream(new ByteStream(source));
  }
  static readAll(source) {
    if (source instanceof RecordBatchReader) {
      return source.isSync() ? readAllSync(source) : readAllAsync(source);
    } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable2(source) || isIteratorResult(source)) {
      return readAllSync(source);
    }
    return readAllAsync(source);
  }
}

class RecordBatchStreamReader extends RecordBatchReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
  readAll() {
    return [...this];
  }
  [Symbol.iterator]() {
    return this._impl[Symbol.iterator]();
  }
  [Symbol.asyncIterator]() {
    return __asyncGenerator(this, arguments, function* _a() {
      yield __await(yield* __asyncDelegator(__asyncValues(this[Symbol.iterator]())));
    });
  }
}

class AsyncRecordBatchStreamReader extends RecordBatchReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
  readAll() {
    return __awaiter(this, undefined, undefined, function* () {
      var _a5, e_1, _b2, _c2;
      const batches = new Array;
      try {
        for (var _d2 = true, _e2 = __asyncValues(this), _f2;_f2 = yield _e2.next(), _a5 = _f2.done, !_a5; _d2 = true) {
          _c2 = _f2.value;
          _d2 = false;
          const batch = _c2;
          batches.push(batch);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d2 && !_a5 && (_b2 = _e2.return))
            yield _b2.call(_e2);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return batches;
    });
  }
  [Symbol.iterator]() {
    throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);
  }
  [Symbol.asyncIterator]() {
    return this._impl[Symbol.asyncIterator]();
  }
}

class RecordBatchFileReader extends RecordBatchStreamReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
}

class AsyncRecordBatchFileReader extends AsyncRecordBatchStreamReader {
  constructor(_impl) {
    super(_impl);
    this._impl = _impl;
  }
}

class RecordBatchReaderImpl {
  get numDictionaries() {
    return this._dictionaryIndex;
  }
  get numRecordBatches() {
    return this._recordBatchIndex;
  }
  constructor(dictionaries = new Map) {
    this.closed = false;
    this.autoDestroy = true;
    this._dictionaryIndex = 0;
    this._recordBatchIndex = 0;
    this.dictionaries = dictionaries;
  }
  isSync() {
    return false;
  }
  isAsync() {
    return false;
  }
  isFile() {
    return false;
  }
  isStream() {
    return false;
  }
  reset(schema) {
    this._dictionaryIndex = 0;
    this._recordBatchIndex = 0;
    this.schema = schema;
    this.dictionaries = new Map;
    return this;
  }
  _loadRecordBatch(header, body) {
    let children2;
    if (header.compression != null) {
      const codec = compressionRegistry.get(header.compression.type);
      if ((codec === null || codec === undefined ? undefined : codec.decode) && typeof codec.decode === "function") {
        const { decommpressedBody, buffers } = this._decompressBuffers(header, body, codec);
        children2 = this._loadCompressedVectors(header, decommpressedBody, this.schema.fields);
        header = new RecordBatch3(header.length, header.nodes, buffers, null);
      } else {
        throw new Error("Record batch is compressed but codec not found");
      }
    } else {
      children2 = this._loadVectors(header, body, this.schema.fields);
    }
    const data = makeData({ type: new Struct2(this.schema.fields), length: header.length, children: children2 });
    return new RecordBatch4(this.schema, data);
  }
  _loadDictionaryBatch(header, body) {
    const { id: id2, isDelta } = header;
    const { dictionaries, schema } = this;
    const dictionary = dictionaries.get(id2);
    const type = schema.dictionaries.get(id2);
    let data;
    if (header.data.compression != null) {
      const codec = compressionRegistry.get(header.data.compression.type);
      if ((codec === null || codec === undefined ? undefined : codec.decode) && typeof codec.decode === "function") {
        const { decommpressedBody, buffers } = this._decompressBuffers(header.data, body, codec);
        data = this._loadCompressedVectors(header.data, decommpressedBody, [type]);
        header = new DictionaryBatch2(new RecordBatch3(header.data.length, header.data.nodes, buffers, null), id2, isDelta);
      } else {
        throw new Error("Dictionary batch is compressed but codec not found");
      }
    } else {
      data = this._loadVectors(header.data, body, [type]);
    }
    return (dictionary && isDelta ? dictionary.concat(new Vector(data)) : new Vector(data)).memoize();
  }
  _loadVectors(header, body, types) {
    return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);
  }
  _loadCompressedVectors(header, body, types) {
    return new CompressedVectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);
  }
  _decompressBuffers(header, body, codec) {
    const decompressedBuffers = [];
    const newBufferRegions = [];
    let currentOffset = 0;
    for (const { offset, length: length3 } of header.buffers) {
      if (length3 === 0) {
        decompressedBuffers.push(new Uint8Array(0));
        newBufferRegions.push(new BufferRegion(currentOffset, 0));
        continue;
      }
      const byteBuf = new ByteBuffer(body.subarray(offset, offset + length3));
      const uncompressedLenth = bigIntToNumber(byteBuf.readInt64(0));
      const bytes = byteBuf.bytes().subarray(COMPRESS_LENGTH_PREFIX);
      const decompressed = uncompressedLenth === LENGTH_NO_COMPRESSED_DATA ? bytes : codec.decode(bytes);
      decompressedBuffers.push(decompressed);
      const padding = (currentOffset + 7 & ~7) - currentOffset;
      currentOffset += padding;
      newBufferRegions.push(new BufferRegion(currentOffset, decompressed.length));
      currentOffset += decompressed.length;
    }
    return {
      decommpressedBody: decompressedBuffers,
      buffers: newBufferRegions
    };
  }
}

class RecordBatchStreamReaderImpl extends RecordBatchReaderImpl {
  constructor(source, dictionaries) {
    super(dictionaries);
    this._reader = !isArrowJSON(source) ? new MessageReader(this._handle = source) : new JSONMessageReader(this._handle = source);
  }
  isSync() {
    return true;
  }
  isStream() {
    return true;
  }
  [Symbol.iterator]() {
    return this;
  }
  cancel() {
    if (!this.closed && (this.closed = true)) {
      this.reset()._reader.return();
      this._reader = null;
      this.dictionaries = null;
    }
  }
  open(options) {
    if (!this.closed) {
      this.autoDestroy = shouldAutoDestroy(this, options);
      if (!(this.schema || (this.schema = this._reader.readSchema()))) {
        this.cancel();
      }
    }
    return this;
  }
  throw(value) {
    if (!this.closed && this.autoDestroy && (this.closed = true)) {
      return this.reset()._reader.throw(value);
    }
    return ITERATOR_DONE;
  }
  return(value) {
    if (!this.closed && this.autoDestroy && (this.closed = true)) {
      return this.reset()._reader.return(value);
    }
    return ITERATOR_DONE;
  }
  next() {
    if (this.closed) {
      return ITERATOR_DONE;
    }
    let message;
    const { _reader: reader } = this;
    while (message = this._readNextMessageAndValidate()) {
      if (message.isSchema()) {
        this.reset(message.header());
      } else if (message.isRecordBatch()) {
        this._recordBatchIndex++;
        const header = message.header();
        const buffer3 = reader.readMessageBody(message.bodyLength);
        const recordBatch = this._loadRecordBatch(header, buffer3);
        return { done: false, value: recordBatch };
      } else if (message.isDictionaryBatch()) {
        this._dictionaryIndex++;
        const header = message.header();
        const buffer3 = reader.readMessageBody(message.bodyLength);
        const vector = this._loadDictionaryBatch(header, buffer3);
        this.dictionaries.set(header.id, vector);
      }
    }
    if (this.schema && this._recordBatchIndex === 0) {
      this._recordBatchIndex++;
      return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };
    }
    return this.return();
  }
  _readNextMessageAndValidate(type) {
    return this._reader.readMessage(type);
  }
}

class AsyncRecordBatchStreamReaderImpl extends RecordBatchReaderImpl {
  constructor(source, dictionaries) {
    super(dictionaries);
    this._reader = new AsyncMessageReader(this._handle = source);
  }
  isAsync() {
    return true;
  }
  isStream() {
    return true;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  cancel() {
    return __awaiter(this, undefined, undefined, function* () {
      if (!this.closed && (this.closed = true)) {
        yield this.reset()._reader.return();
        this._reader = null;
        this.dictionaries = null;
      }
    });
  }
  open(options) {
    return __awaiter(this, undefined, undefined, function* () {
      if (!this.closed) {
        this.autoDestroy = shouldAutoDestroy(this, options);
        if (!(this.schema || (this.schema = yield this._reader.readSchema()))) {
          yield this.cancel();
        }
      }
      return this;
    });
  }
  throw(value) {
    return __awaiter(this, undefined, undefined, function* () {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return yield this.reset()._reader.throw(value);
      }
      return ITERATOR_DONE;
    });
  }
  return(value) {
    return __awaiter(this, undefined, undefined, function* () {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return yield this.reset()._reader.return(value);
      }
      return ITERATOR_DONE;
    });
  }
  next() {
    return __awaiter(this, undefined, undefined, function* () {
      if (this.closed) {
        return ITERATOR_DONE;
      }
      let message;
      const { _reader: reader } = this;
      while (message = yield this._readNextMessageAndValidate()) {
        if (message.isSchema()) {
          yield this.reset(message.header());
        } else if (message.isRecordBatch()) {
          this._recordBatchIndex++;
          const header = message.header();
          const buffer3 = yield reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer3);
          return { done: false, value: recordBatch };
        } else if (message.isDictionaryBatch()) {
          this._dictionaryIndex++;
          const header = message.header();
          const buffer3 = yield reader.readMessageBody(message.bodyLength);
          const vector = this._loadDictionaryBatch(header, buffer3);
          this.dictionaries.set(header.id, vector);
        }
      }
      if (this.schema && this._recordBatchIndex === 0) {
        this._recordBatchIndex++;
        return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };
      }
      return yield this.return();
    });
  }
  _readNextMessageAndValidate(type) {
    return __awaiter(this, undefined, undefined, function* () {
      return yield this._reader.readMessage(type);
    });
  }
}

class RecordBatchFileReaderImpl extends RecordBatchStreamReaderImpl {
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  constructor(source, dictionaries) {
    super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);
  }
  isSync() {
    return true;
  }
  isFile() {
    return true;
  }
  open(options) {
    if (!this.closed && !this._footer) {
      this.schema = (this._footer = this._readFooter()).schema;
      for (const block of this._footer.dictionaryBatches()) {
        block && this._readDictionaryBatch(this._dictionaryIndex++);
      }
    }
    return super.open(options);
  }
  readRecordBatch(index) {
    var _a5;
    if (this.closed) {
      return null;
    }
    if (!this._footer) {
      this.open();
    }
    const block = (_a5 = this._footer) === null || _a5 === undefined ? undefined : _a5.getRecordBatch(index);
    if (block && this._handle.seek(block.offset)) {
      const message = this._reader.readMessage(MessageHeader.RecordBatch);
      if (message === null || message === undefined ? undefined : message.isRecordBatch()) {
        const header = message.header();
        const buffer3 = this._reader.readMessageBody(message.bodyLength);
        const recordBatch = this._loadRecordBatch(header, buffer3);
        return recordBatch;
      }
    }
    return null;
  }
  _readDictionaryBatch(index) {
    var _a5;
    const block = (_a5 = this._footer) === null || _a5 === undefined ? undefined : _a5.getDictionaryBatch(index);
    if (block && this._handle.seek(block.offset)) {
      const message = this._reader.readMessage(MessageHeader.DictionaryBatch);
      if (message === null || message === undefined ? undefined : message.isDictionaryBatch()) {
        const header = message.header();
        const buffer3 = this._reader.readMessageBody(message.bodyLength);
        const vector = this._loadDictionaryBatch(header, buffer3);
        this.dictionaries.set(header.id, vector);
      }
    }
  }
  _readFooter() {
    const { _handle } = this;
    const offset = _handle.size - magicAndPadding;
    const length3 = _handle.readInt32(offset);
    const buffer3 = _handle.readAt(offset - length3, length3);
    return Footer_.decode(buffer3);
  }
  _readNextMessageAndValidate(type) {
    var _a5;
    if (!this._footer) {
      this.open();
    }
    if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
      const block = (_a5 = this._footer) === null || _a5 === undefined ? undefined : _a5.getRecordBatch(this._recordBatchIndex);
      if (block && this._handle.seek(block.offset)) {
        return this._reader.readMessage(type);
      }
    }
    return null;
  }
}

class AsyncRecordBatchFileReaderImpl extends AsyncRecordBatchStreamReaderImpl {
  get footer() {
    return this._footer;
  }
  get numDictionaries() {
    return this._footer ? this._footer.numDictionaries : 0;
  }
  get numRecordBatches() {
    return this._footer ? this._footer.numRecordBatches : 0;
  }
  constructor(source, ...rest) {
    const byteLength = typeof rest[0] !== "number" ? rest.shift() : undefined;
    const dictionaries = rest[0] instanceof Map ? rest.shift() : undefined;
    super(source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength), dictionaries);
  }
  isFile() {
    return true;
  }
  isAsync() {
    return true;
  }
  open(options) {
    const _super = Object.create(null, {
      open: { get: () => super.open }
    });
    return __awaiter(this, undefined, undefined, function* () {
      if (!this.closed && !this._footer) {
        this.schema = (this._footer = yield this._readFooter()).schema;
        for (const block of this._footer.dictionaryBatches()) {
          block && (yield this._readDictionaryBatch(this._dictionaryIndex++));
        }
      }
      return yield _super.open.call(this, options);
    });
  }
  readRecordBatch(index) {
    return __awaiter(this, undefined, undefined, function* () {
      var _a5;
      if (this.closed) {
        return null;
      }
      if (!this._footer) {
        yield this.open();
      }
      const block = (_a5 = this._footer) === null || _a5 === undefined ? undefined : _a5.getRecordBatch(index);
      if (block && (yield this._handle.seek(block.offset))) {
        const message = yield this._reader.readMessage(MessageHeader.RecordBatch);
        if (message === null || message === undefined ? undefined : message.isRecordBatch()) {
          const header = message.header();
          const buffer3 = yield this._reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer3);
          return recordBatch;
        }
      }
      return null;
    });
  }
  _readDictionaryBatch(index) {
    return __awaiter(this, undefined, undefined, function* () {
      var _a5;
      const block = (_a5 = this._footer) === null || _a5 === undefined ? undefined : _a5.getDictionaryBatch(index);
      if (block && (yield this._handle.seek(block.offset))) {
        const message = yield this._reader.readMessage(MessageHeader.DictionaryBatch);
        if (message === null || message === undefined ? undefined : message.isDictionaryBatch()) {
          const header = message.header();
          const buffer3 = yield this._reader.readMessageBody(message.bodyLength);
          const vector = this._loadDictionaryBatch(header, buffer3);
          this.dictionaries.set(header.id, vector);
        }
      }
    });
  }
  _readFooter() {
    return __awaiter(this, undefined, undefined, function* () {
      const { _handle } = this;
      _handle._pending && (yield _handle._pending);
      const offset = _handle.size - magicAndPadding;
      const length3 = yield _handle.readInt32(offset);
      const buffer3 = yield _handle.readAt(offset - length3, length3);
      return Footer_.decode(buffer3);
    });
  }
  _readNextMessageAndValidate(type) {
    return __awaiter(this, undefined, undefined, function* () {
      if (!this._footer) {
        yield this.open();
      }
      if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
        const block = this._footer.getRecordBatch(this._recordBatchIndex);
        if (block && (yield this._handle.seek(block.offset))) {
          return yield this._reader.readMessage(type);
        }
      }
      return null;
    });
  }
}

class RecordBatchJSONReaderImpl extends RecordBatchStreamReaderImpl {
  constructor(source, dictionaries) {
    super(source, dictionaries);
  }
  _loadVectors(header, body, types) {
    return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries, this.schema.metadataVersion).visitMany(types);
  }
}
function shouldAutoDestroy(self2, options) {
  return options && typeof options["autoDestroy"] === "boolean" ? options["autoDestroy"] : self2["autoDestroy"];
}
function* readAllSync(source) {
  const reader = RecordBatchReader.from(source);
  try {
    if (!reader.open({ autoDestroy: false }).closed) {
      do {
        yield reader;
      } while (!reader.reset().open().closed);
    }
  } finally {
    reader.cancel();
  }
}
function readAllAsync(source) {
  return __asyncGenerator(this, arguments, function* readAllAsync_1() {
    const reader = yield __await(RecordBatchReader.from(source));
    try {
      if (!(yield __await(reader.open({ autoDestroy: false }))).closed) {
        do {
          yield yield __await(reader);
        } while (!(yield __await(reader.reset().open())).closed);
      }
    } finally {
      yield __await(reader.cancel());
    }
  });
}
function fromArrowJSON(source) {
  return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));
}
function fromByteStream(source) {
  const bytes = source.peek(magicLength + 7 & ~7);
  return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function* () {}()));
}
function fromAsyncByteStream(source) {
  return __awaiter(this, undefined, undefined, function* () {
    const bytes = yield source.peek(magicLength + 7 & ~7);
    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(yield source.read())) : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(function() {
      return __asyncGenerator(this, arguments, function* () {});
    }()));
  });
}
function fromFileHandle(source) {
  return __awaiter(this, undefined, undefined, function* () {
    const { size: size13 } = yield source.stat();
    const file = new AsyncRandomAccessFile(source, size13);
    if (size13 >= magicX2AndPadding && checkForMagicArrowString(yield file.readAt(0, magicLength + 7 & ~7))) {
      return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));
    }
    return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));
  });
}

// node_modules/apache-arrow/visitor/vectorassembler.mjs
class VectorAssembler extends Visitor {
  static assemble(...args2) {
    const unwrap4 = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap4(node) : node instanceof RecordBatch4 ? node.data.children : node.data);
    const assembler = new VectorAssembler;
    assembler.visitMany(unwrap4(args2));
    return assembler;
  }
  constructor() {
    super();
    this._byteLength = 0;
    this._nodes = [];
    this._buffers = [];
    this._bufferRegions = [];
  }
  visit(data) {
    if (data instanceof Vector) {
      this.visitMany(data.data);
      return this;
    }
    const { type } = data;
    if (!DataType.isDictionary(type)) {
      const { length: length3 } = data;
      if (length3 > 2147483647) {
        throw new RangeError("Cannot write arrays larger than 2^31 - 1 in length");
      }
      if (DataType.isUnion(type)) {
        this.nodes.push(new FieldNode2(length3, 0));
      } else {
        const { nullCount } = data;
        if (!DataType.isNull(type)) {
          addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) : truncateBitmap(data.offset, length3, data.nullBitmap));
        }
        this.nodes.push(new FieldNode2(length3, nullCount));
      }
    }
    return super.visit(data);
  }
  visitNull(_null) {
    return this;
  }
  visitDictionary(data) {
    return this.visit(data.clone(data.type.indices));
  }
  get nodes() {
    return this._nodes;
  }
  get buffers() {
    return this._buffers;
  }
  get byteLength() {
    return this._byteLength;
  }
  get bufferRegions() {
    return this._bufferRegions;
  }
}
function addBuffer(values3) {
  const byteLength = values3.byteLength + 7 & ~7;
  this.buffers.push(values3);
  this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));
  this._byteLength += byteLength;
  return this;
}
function assembleUnion(data) {
  var _a5;
  const { type, length: length3, typeIds, valueOffsets } = data;
  addBuffer.call(this, typeIds);
  if (type.mode === UnionMode.Sparse) {
    return assembleNestedVector.call(this, data);
  } else if (type.mode === UnionMode.Dense) {
    if (data.offset <= 0) {
      addBuffer.call(this, valueOffsets);
      return assembleNestedVector.call(this, data);
    } else {
      const shiftedOffsets = new Int32Array(length3);
      const childOffsets = Object.create(null);
      const childLengths = Object.create(null);
      for (let typeId, shift2, index = -1;++index < length3; ) {
        if ((typeId = typeIds[index]) === undefined) {
          continue;
        }
        if ((shift2 = childOffsets[typeId]) === undefined) {
          shift2 = childOffsets[typeId] = valueOffsets[index];
        }
        shiftedOffsets[index] = valueOffsets[index] - shift2;
        childLengths[typeId] = ((_a5 = childLengths[typeId]) !== null && _a5 !== undefined ? _a5 : 0) + 1;
      }
      addBuffer.call(this, shiftedOffsets);
      this.visitMany(data.children.map((child, childIndex) => {
        const typeId = type.typeIds[childIndex];
        const childOffset = childOffsets[typeId];
        const childLength = childLengths[typeId];
        return child.slice(childOffset, Math.min(length3, childLength));
      }));
    }
  }
  return this;
}
function assembleBoolVector(data) {
  let values3;
  if (data.nullCount >= data.length) {
    return addBuffer.call(this, new Uint8Array(0));
  } else if ((values3 = data.values) instanceof Uint8Array) {
    return addBuffer.call(this, truncateBitmap(data.offset, data.length, values3));
  }
  return addBuffer.call(this, packBools(data.values));
}
function assembleFlatVector(data) {
  return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));
}
function assembleFlatListVector(data) {
  const { length: length3, values: values3, valueOffsets } = data;
  const begin = bigIntToNumber(valueOffsets[0]);
  const end6 = bigIntToNumber(valueOffsets[length3]);
  const byteLength = Math.min(end6 - begin, values3.byteLength - begin);
  addBuffer.call(this, rebaseValueOffsets(-begin, length3 + 1, valueOffsets));
  addBuffer.call(this, values3.subarray(begin, begin + byteLength));
  return this;
}
function assembleListVector(data) {
  const { length: length3, valueOffsets } = data;
  if (valueOffsets) {
    const { [0]: begin, [length3]: end6 } = valueOffsets;
    addBuffer.call(this, rebaseValueOffsets(-begin, length3 + 1, valueOffsets));
    return this.visit(data.children[0].slice(begin, end6 - begin));
  }
  return this.visit(data.children[0]);
}
function assembleNestedVector(data) {
  return this.visitMany(data.type.children.map((_, i) => data.children[i]).filter(Boolean))[0];
}
VectorAssembler.prototype.visitBool = assembleBoolVector;
VectorAssembler.prototype.visitInt = assembleFlatVector;
VectorAssembler.prototype.visitFloat = assembleFlatVector;
VectorAssembler.prototype.visitUtf8 = assembleFlatListVector;
VectorAssembler.prototype.visitLargeUtf8 = assembleFlatListVector;
VectorAssembler.prototype.visitBinary = assembleFlatListVector;
VectorAssembler.prototype.visitLargeBinary = assembleFlatListVector;
VectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;
VectorAssembler.prototype.visitDate = assembleFlatVector;
VectorAssembler.prototype.visitTimestamp = assembleFlatVector;
VectorAssembler.prototype.visitTime = assembleFlatVector;
VectorAssembler.prototype.visitDecimal = assembleFlatVector;
VectorAssembler.prototype.visitList = assembleListVector;
VectorAssembler.prototype.visitStruct = assembleNestedVector;
VectorAssembler.prototype.visitUnion = assembleUnion;
VectorAssembler.prototype.visitInterval = assembleFlatVector;
VectorAssembler.prototype.visitDuration = assembleFlatVector;
VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
VectorAssembler.prototype.visitMap = assembleListVector;

// node_modules/apache-arrow/ipc/writer.mjs
class RecordBatchWriter extends ReadableInterop {
  static throughNode(options) {
    throw new Error(`"throughNode" not available in this environment`);
  }
  static throughDOM(writableStrategy, readableStrategy) {
    throw new Error(`"throughDOM" not available in this environment`);
  }
  constructor(options) {
    super();
    this._position = 0;
    this._started = false;
    this._compression = null;
    this._sink = new AsyncByteQueue;
    this._schema = null;
    this._dictionaryBlocks = [];
    this._recordBatchBlocks = [];
    this._seenDictionaries = new Map;
    this._dictionaryDeltaOffsets = new Map;
    isObject2(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false, compressionType: null });
    this._autoDestroy = typeof options.autoDestroy === "boolean" ? options.autoDestroy : true;
    this._writeLegacyIpcFormat = typeof options.writeLegacyIpcFormat === "boolean" ? options.writeLegacyIpcFormat : false;
    if (options.compressionType != null) {
      if (this._writeLegacyIpcFormat) {
        throw new Error("Legacy IPC format does not support columnar compression. Use modern IPC format (writeLegacyIpcFormat=false).");
      }
      if (Object.values(CompressionType).includes(options.compressionType)) {
        this._compression = new BodyCompression2(options.compressionType);
      } else {
        const validCompressionTypes = Object.values(CompressionType).filter((v) => typeof v === "string");
        throw new Error(`Unsupported compressionType: ${options.compressionType} Available types: ${validCompressionTypes.join(", ")}`);
      }
    } else {
      this._compression = null;
    }
  }
  toString(sync10 = false) {
    return this._sink.toString(sync10);
  }
  toUint8Array(sync10 = false) {
    return this._sink.toUint8Array(sync10);
  }
  writeAll(input) {
    if (isPromise(input)) {
      return input.then((x) => this.writeAll(x));
    } else if (isAsyncIterable(input)) {
      return writeAllAsync(this, input);
    }
    return writeAll2(this, input);
  }
  get closed() {
    return this._sink.closed;
  }
  [Symbol.asyncIterator]() {
    return this._sink[Symbol.asyncIterator]();
  }
  toDOMStream(options) {
    return this._sink.toDOMStream(options);
  }
  toNodeStream(options) {
    return this._sink.toNodeStream(options);
  }
  close() {
    return this.reset()._sink.close();
  }
  abort(reason) {
    return this.reset()._sink.abort(reason);
  }
  finish() {
    this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);
    return this;
  }
  reset(sink = this._sink, schema = null) {
    if (sink === this._sink || sink instanceof AsyncByteQueue) {
      this._sink = sink;
    } else {
      this._sink = new AsyncByteQueue;
      if (sink && isWritableDOMStream(sink)) {
        this.toDOMStream({ type: "bytes" }).pipeTo(sink);
      } else if (sink && isWritableNodeStream(sink)) {
        this.toNodeStream({ objectMode: false }).pipe(sink);
      }
    }
    if (this._started && this._schema) {
      this._writeFooter(this._schema);
    }
    this._started = false;
    this._dictionaryBlocks = [];
    this._recordBatchBlocks = [];
    this._seenDictionaries = new Map;
    this._dictionaryDeltaOffsets = new Map;
    if (!schema || !compareSchemas(schema, this._schema)) {
      if (schema == null) {
        this._position = 0;
        this._schema = null;
      } else {
        this._started = true;
        this._schema = schema;
        this._writeSchema(schema);
      }
    }
    return this;
  }
  write(payload) {
    let schema = null;
    if (!this._sink) {
      throw new Error(`RecordBatchWriter is closed`);
    } else if (payload == null) {
      return this.finish() && undefined;
    } else if (payload instanceof Table2 && !(schema = payload.schema)) {
      return this.finish() && undefined;
    } else if (payload instanceof RecordBatch4 && !(schema = payload.schema)) {
      return this.finish() && undefined;
    }
    if (schema && !compareSchemas(schema, this._schema)) {
      if (this._started && this._autoDestroy) {
        return this.close();
      }
      this.reset(this._sink, schema);
    }
    if (payload instanceof RecordBatch4) {
      if (!(payload instanceof _InternalEmptyPlaceholderRecordBatch)) {
        this._writeRecordBatch(payload);
      }
    } else if (payload instanceof Table2) {
      this.writeAll(payload.batches);
    } else if (isIterable2(payload)) {
      this.writeAll(payload);
    }
  }
  _writeMessage(message, alignment = 8) {
    const a = alignment - 1;
    const buffer3 = Message2.encode(message);
    const flatbufferSize = buffer3.byteLength;
    const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;
    const alignedSize = flatbufferSize + prefixSize + a & ~a;
    const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;
    if (message.headerType === MessageHeader.RecordBatch) {
      this._recordBatchBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));
    } else if (message.headerType === MessageHeader.DictionaryBatch) {
      this._dictionaryBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));
    }
    if (!this._writeLegacyIpcFormat) {
      this._write(Int32Array.of(-1));
    }
    this._write(Int32Array.of(alignedSize - prefixSize));
    if (flatbufferSize > 0) {
      this._write(buffer3);
    }
    return this._writePadding(nPaddingBytes);
  }
  _write(chunk3) {
    if (this._started) {
      const buffer3 = toUint8Array(chunk3);
      if (buffer3 && buffer3.byteLength > 0) {
        this._sink.write(buffer3);
        this._position += buffer3.byteLength;
      }
    }
    return this;
  }
  _writeSchema(schema) {
    return this._writeMessage(Message2.from(schema));
  }
  _writeFooter(schema) {
    return this._writeLegacyIpcFormat ? this._write(Int32Array.of(0)) : this._write(Int32Array.of(-1, 0));
  }
  _writeMagic() {
    return this._write(MAGIC);
  }
  _writePadding(nBytes) {
    return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;
  }
  _writeRecordBatch(batch) {
    const { byteLength, nodes, bufferRegions, buffers } = this._assembleRecordBatch(batch);
    const recordBatch = new RecordBatch3(batch.numRows, nodes, bufferRegions, this._compression);
    const message = Message2.from(recordBatch, byteLength);
    return this._writeDictionaries(batch)._writeMessage(message)._writeBodyBuffers(buffers);
  }
  _assembleRecordBatch(batch) {
    let { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(batch);
    if (this._compression != null) {
      ({ byteLength, bufferRegions, buffers } = this._compressBodyBuffers(buffers));
    }
    return { byteLength, nodes, bufferRegions, buffers };
  }
  _compressBodyBuffers(buffers) {
    const codec = compressionRegistry.get(this._compression.type);
    if (!(codec === null || codec === undefined ? undefined : codec.encode) || typeof codec.encode !== "function") {
      throw new Error(`Codec for compression type "${CompressionType[this._compression.type]}" has invalid encode method`);
    }
    let currentOffset = 0;
    const compressedBuffers = [];
    const bufferRegions = [];
    for (const buffer3 of buffers) {
      const byteBuf = toUint8Array(buffer3);
      if (byteBuf.length === 0) {
        compressedBuffers.push(new Uint8Array(0), new Uint8Array(0));
        bufferRegions.push(new BufferRegion(currentOffset, 0));
        continue;
      }
      const compressed = codec.encode(byteBuf);
      const isCompressionEffective = compressed.length < byteBuf.length;
      const finalBuffer = isCompressionEffective ? compressed : byteBuf;
      const byteLength = isCompressionEffective ? finalBuffer.length : LENGTH_NO_COMPRESSED_DATA;
      const lengthPrefix = new ByteBuffer(new Uint8Array(COMPRESS_LENGTH_PREFIX));
      lengthPrefix.writeInt64(0, BigInt(byteLength));
      compressedBuffers.push(lengthPrefix.bytes(), new Uint8Array(finalBuffer));
      const padding = (currentOffset + 7 & ~7) - currentOffset;
      currentOffset += padding;
      const fullBodyLength = COMPRESS_LENGTH_PREFIX + finalBuffer.length;
      bufferRegions.push(new BufferRegion(currentOffset, fullBodyLength));
      currentOffset += fullBodyLength;
    }
    const finalPadding = (currentOffset + 7 & ~7) - currentOffset;
    currentOffset += finalPadding;
    return { byteLength: currentOffset, bufferRegions, buffers: compressedBuffers };
  }
  _writeDictionaryBatch(dictionary, id2, isDelta = false) {
    const { byteLength, nodes, bufferRegions, buffers } = this._assembleRecordBatch(new Vector([dictionary]));
    const recordBatch = new RecordBatch3(dictionary.length, nodes, bufferRegions, this._compression);
    const dictionaryBatch = new DictionaryBatch2(recordBatch, id2, isDelta);
    const message = Message2.from(dictionaryBatch, byteLength);
    return this._writeMessage(message)._writeBodyBuffers(buffers);
  }
  _writeBodyBuffers(buffers) {
    const bufGroupSize = this._compression != null ? 2 : 1;
    const bufs = new Array(bufGroupSize);
    for (let i = 0;i < buffers.length; i += bufGroupSize) {
      let size13 = 0;
      for (let j = -1;++j < bufGroupSize; ) {
        bufs[j] = buffers[i + j];
        size13 += bufs[j].byteLength;
      }
      if (size13 === 0) {
        continue;
      }
      for (const buf of bufs)
        this._write(buf);
      const padding = (size13 + 7 & ~7) - size13;
      if (padding > 0) {
        this._writePadding(padding);
      }
    }
    return this;
  }
  _writeDictionaries(batch) {
    var _a5, _b2;
    for (const [id2, dictionary] of batch.dictionaries) {
      const chunks3 = (_a5 = dictionary === null || dictionary === undefined ? undefined : dictionary.data) !== null && _a5 !== undefined ? _a5 : [];
      const prevDictionary = this._seenDictionaries.get(id2);
      const offset = (_b2 = this._dictionaryDeltaOffsets.get(id2)) !== null && _b2 !== undefined ? _b2 : 0;
      if (!prevDictionary || prevDictionary.data[0] !== chunks3[0]) {
        for (const [index, chunk3] of chunks3.entries())
          this._writeDictionaryBatch(chunk3, id2, index > 0);
      } else if (offset < chunks3.length) {
        for (const chunk3 of chunks3.slice(offset))
          this._writeDictionaryBatch(chunk3, id2, true);
      }
      this._seenDictionaries.set(id2, dictionary);
      this._dictionaryDeltaOffsets.set(id2, chunks3.length);
    }
    return this;
  }
}

class RecordBatchStreamWriter extends RecordBatchWriter {
  static writeAll(input, options) {
    const writer = new RecordBatchStreamWriter(options);
    if (isPromise(input)) {
      return input.then((x) => writer.writeAll(x));
    } else if (isAsyncIterable(input)) {
      return writeAllAsync(writer, input);
    }
    return writeAll2(writer, input);
  }
}

class RecordBatchFileWriter extends RecordBatchWriter {
  static writeAll(input, options) {
    const writer = new RecordBatchFileWriter(options);
    if (isPromise(input)) {
      return input.then((x) => writer.writeAll(x));
    } else if (isAsyncIterable(input)) {
      return writeAllAsync(writer, input);
    }
    return writeAll2(writer, input);
  }
  constructor(options) {
    super(options);
    this._autoDestroy = true;
    this._writeLegacyIpcFormat = false;
  }
  _writeSchema(schema) {
    return this._writeMagic()._writePadding(2);
  }
  _writeDictionaryBatch(dictionary, id2, isDelta = false) {
    if (!isDelta && this._seenDictionaries.has(id2)) {
      throw new Error("The Arrow File format does not support replacement dictionaries. ");
    }
    return super._writeDictionaryBatch(dictionary, id2, isDelta);
  }
  _writeFooter(schema) {
    const buffer3 = Footer_.encode(new Footer_(schema, MetadataVersion.V5, this._recordBatchBlocks, this._dictionaryBlocks));
    return super._writeFooter(schema)._write(buffer3)._write(Int32Array.of(buffer3.byteLength))._writeMagic();
  }
}
function writeAll2(writer, input) {
  let chunks3 = input;
  if (input instanceof Table2) {
    chunks3 = input.batches;
    writer.reset(undefined, input.schema);
  }
  for (const batch of chunks3) {
    writer.write(batch);
  }
  return writer.finish();
}
function writeAllAsync(writer, batches) {
  return __awaiter(this, undefined, undefined, function* () {
    var _a5, batches_1, batches_1_1;
    var _b2, e_1, _c2, _d2;
    try {
      for (_a5 = true, batches_1 = __asyncValues(batches);batches_1_1 = yield batches_1.next(), _b2 = batches_1_1.done, !_b2; _a5 = true) {
        _d2 = batches_1_1.value;
        _a5 = false;
        const batch = _d2;
        writer.write(batch);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (!_a5 && !_b2 && (_c2 = batches_1.return))
          yield _c2.call(batches_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return writer.finish();
  });
}

// node_modules/apache-arrow/io/whatwg/iterable.mjs
function toDOMStream(source, options) {
  if (isAsyncIterable(source)) {
    return asyncIterableAsReadableDOMStream(source, options);
  }
  if (isIterable2(source)) {
    return iterableAsReadableDOMStream(source, options);
  }
  throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);
}
function iterableAsReadableDOMStream(source, options) {
  let it = null;
  const bm = (options === null || options === undefined ? undefined : options.type) === "bytes" || false;
  const hwm = (options === null || options === undefined ? undefined : options.highWaterMark) || Math.pow(2, 24);
  return new ReadableStream(Object.assign(Object.assign({}, options), {
    start(controller) {
      next(controller, it || (it = source[Symbol.iterator]()));
    },
    pull(controller) {
      it ? next(controller, it) : controller.close();
    },
    cancel() {
      (it === null || it === undefined ? undefined : it.return) && it.return();
      it = null;
    }
  }), Object.assign({ highWaterMark: bm ? hwm : undefined }, options));
  function next(controller, it2) {
    let buf;
    let r = null;
    let size13 = controller.desiredSize || null;
    while (!(r = it2.next(bm ? size13 : null)).done) {
      if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {
        size13 != null && bm && (size13 = size13 - buf.byteLength + 1);
        r.value = buf;
      }
      controller.enqueue(r.value);
      if (size13 != null && --size13 <= 0) {
        return;
      }
    }
    controller.close();
  }
}
function asyncIterableAsReadableDOMStream(source, options) {
  let it = null;
  const bm = (options === null || options === undefined ? undefined : options.type) === "bytes" || false;
  const hwm = (options === null || options === undefined ? undefined : options.highWaterMark) || Math.pow(2, 24);
  return new ReadableStream(Object.assign(Object.assign({}, options), {
    start(controller) {
      return __awaiter(this, undefined, undefined, function* () {
        yield next(controller, it || (it = source[Symbol.asyncIterator]()));
      });
    },
    pull(controller) {
      return __awaiter(this, undefined, undefined, function* () {
        it ? yield next(controller, it) : controller.close();
      });
    },
    cancel() {
      return __awaiter(this, undefined, undefined, function* () {
        (it === null || it === undefined ? undefined : it.return) && (yield it.return());
        it = null;
      });
    }
  }), Object.assign({ highWaterMark: bm ? hwm : undefined }, options));
  function next(controller, it2) {
    return __awaiter(this, undefined, undefined, function* () {
      let buf;
      let r = null;
      let size13 = controller.desiredSize || null;
      while (!(r = yield it2.next(bm ? size13 : null)).done) {
        if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {
          size13 != null && bm && (size13 = size13 - buf.byteLength + 1);
          r.value = buf;
        }
        controller.enqueue(r.value);
        if (size13 != null && --size13 <= 0) {
          return;
        }
      }
      controller.close();
    });
  }
}

// node_modules/apache-arrow/io/whatwg/builder.mjs
function builderThroughDOMStream(options) {
  return new BuilderTransform(options);
}

class BuilderTransform {
  constructor(options) {
    this._numChunks = 0;
    this._finished = false;
    this._bufferedSize = 0;
    const { ["readableStrategy"]: readableStrategy, ["writableStrategy"]: writableStrategy, ["queueingStrategy"]: queueingStrategy = "count" } = options, builderOptions = __rest(options, ["readableStrategy", "writableStrategy", "queueingStrategy"]);
    this._controller = null;
    this._builder = makeBuilder2(builderOptions);
    this._getSize = queueingStrategy !== "bytes" ? chunkLength : chunkByteLength;
    const { ["highWaterMark"]: readableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1000 } = Object.assign({}, readableStrategy);
    const { ["highWaterMark"]: writableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1000 } = Object.assign({}, writableStrategy);
    this["readable"] = new ReadableStream({
      ["cancel"]: () => {
        this._builder.clear();
      },
      ["pull"]: (c) => {
        this._maybeFlush(this._builder, this._controller = c);
      },
      ["start"]: (c) => {
        this._maybeFlush(this._builder, this._controller = c);
      }
    }, {
      highWaterMark: readableHighWaterMark,
      size: queueingStrategy !== "bytes" ? chunkLength : chunkByteLength
    });
    this["writable"] = new WritableStream({
      ["abort"]: () => {
        this._builder.clear();
      },
      ["write"]: () => {
        this._maybeFlush(this._builder, this._controller);
      },
      ["close"]: () => {
        this._maybeFlush(this._builder.finish(), this._controller);
      }
    }, {
      highWaterMark: writableHighWaterMark,
      size: (value) => this._writeValueAndReturnChunkSize(value)
    });
  }
  _writeValueAndReturnChunkSize(value) {
    const bufferedSize = this._bufferedSize;
    this._bufferedSize = this._getSize(this._builder.append(value));
    return this._bufferedSize - bufferedSize;
  }
  _maybeFlush(builder, controller) {
    if (controller == null) {
      return;
    }
    if (this._bufferedSize >= controller.desiredSize) {
      ++this._numChunks && this._enqueue(controller, builder.toVector());
    }
    if (builder.finished) {
      if (builder.length > 0 || this._numChunks === 0) {
        ++this._numChunks && this._enqueue(controller, builder.toVector());
      }
      if (!this._finished && (this._finished = true)) {
        this._enqueue(controller, null);
      }
    }
  }
  _enqueue(controller, chunk3) {
    this._bufferedSize = 0;
    this._controller = null;
    chunk3 == null ? controller.close() : controller.enqueue(chunk3);
  }
}
var chunkLength = (chunk3) => {
  var _a5;
  return (_a5 = chunk3 === null || chunk3 === undefined ? undefined : chunk3.length) !== null && _a5 !== undefined ? _a5 : 0;
};
var chunkByteLength = (chunk3) => {
  var _a5;
  return (_a5 = chunk3 === null || chunk3 === undefined ? undefined : chunk3.byteLength) !== null && _a5 !== undefined ? _a5 : 0;
};

// node_modules/apache-arrow/io/whatwg/reader.mjs
function recordBatchReaderThroughDOMStream(writableStrategy, readableStrategy) {
  const queue = new AsyncByteQueue;
  let reader = null;
  const readable = new ReadableStream({
    cancel() {
      return __awaiter(this, undefined, undefined, function* () {
        yield queue.close();
      });
    },
    start(controller) {
      return __awaiter(this, undefined, undefined, function* () {
        yield next(controller, reader || (reader = yield open()));
      });
    },
    pull(controller) {
      return __awaiter(this, undefined, undefined, function* () {
        reader ? yield next(controller, reader) : controller.close();
      });
    }
  });
  return { writable: new WritableStream(queue, Object.assign({ highWaterMark: Math.pow(2, 14) }, writableStrategy)), readable };
  function open() {
    return __awaiter(this, undefined, undefined, function* () {
      return yield (yield RecordBatchReader.from(queue)).open(readableStrategy);
    });
  }
  function next(controller, reader2) {
    return __awaiter(this, undefined, undefined, function* () {
      let size13 = controller.desiredSize;
      let r = null;
      while (!(r = yield reader2.next()).done) {
        controller.enqueue(r.value);
        if (size13 != null && --size13 <= 0) {
          return;
        }
      }
      controller.close();
    });
  }
}

// node_modules/apache-arrow/io/whatwg/writer.mjs
function recordBatchWriterThroughDOMStream(writableStrategy, readableStrategy) {
  const writer = new this(writableStrategy);
  const reader = new AsyncByteStream(writer);
  const readable = new ReadableStream({
    cancel() {
      return __awaiter(this, undefined, undefined, function* () {
        yield reader.cancel();
      });
    },
    pull(controller) {
      return __awaiter(this, undefined, undefined, function* () {
        yield next(controller);
      });
    },
    start(controller) {
      return __awaiter(this, undefined, undefined, function* () {
        yield next(controller);
      });
    }
  }, Object.assign({ highWaterMark: Math.pow(2, 14) }, readableStrategy));
  return { writable: new WritableStream(writer, writableStrategy), readable };
  function next(controller) {
    return __awaiter(this, undefined, undefined, function* () {
      let buf = null;
      let size13 = controller.desiredSize;
      while (buf = yield reader.read(size13 || null)) {
        controller.enqueue(buf);
        if (size13 != null && (size13 -= buf.byteLength) <= 0) {
          return;
        }
      }
      controller.close();
    });
  }
}

// node_modules/apache-arrow/ipc/serialization.mjs
function tableFromIPC(input) {
  const reader = RecordBatchReader.from(input);
  if (isPromise(reader)) {
    return reader.then((reader2) => tableFromIPC(reader2));
  }
  if (reader.isAsync()) {
    return reader.readAll().then((xs) => new Table2(xs));
  }
  return new Table2(reader.readAll());
}
// node_modules/apache-arrow/Arrow.mjs
var util = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, exports_bn), exports_int), exports_bit), exports_math), exports_buffer), exports_vector), exports_pretty), exports_interval2), {
  compareSchemas,
  compareFields,
  compareTypes
});
// node_modules/apache-arrow/Arrow.dom.mjs
adapters_default.toDOMStream = toDOMStream;
Builder2["throughDOM"] = builderThroughDOMStream;
RecordBatchReader["throughDOM"] = recordBatchReaderThroughDOMStream;
RecordBatchFileReader["throughDOM"] = recordBatchReaderThroughDOMStream;
RecordBatchStreamReader["throughDOM"] = recordBatchReaderThroughDOMStream;
RecordBatchWriter["throughDOM"] = recordBatchWriterThroughDOMStream;
RecordBatchFileWriter["throughDOM"] = recordBatchWriterThroughDOMStream;
RecordBatchStreamWriter["throughDOM"] = recordBatchWriterThroughDOMStream;

// src/huggingface/parquet.ts
var readParquetToArrow = (filePath) => exports_Effect.gen(function* () {
  const fs = yield* FileSystem;
  const exists4 = yield* fs.exists(filePath).pipe(exports_Effect.catchAll(() => exports_Effect.succeed(false)));
  if (!exists4) {
    return yield* exports_Effect.fail(new HFDatasetError("not_found", `Parquet file not found: ${filePath}`));
  }
  const fileContent = yield* fs.readFile(filePath).pipe(exports_Effect.mapError((e) => new HFDatasetError("parse_error", `Failed to read file: ${e.message}`)));
  const table = yield* exports_Effect.try({
    try: () => {
      const parquetTable = readParquet(new Uint8Array(fileContent));
      return tableFromIPC(parquetTable.intoIPCStream());
    },
    catch: (e) => {
      const error = e;
      return new HFDatasetError("parse_error", `Failed to parse parquet: ${error.message}`, e);
    }
  });
  return table;
});
var readParquetFile = (filePath, options = {}) => exports_Effect.gen(function* () {
  const table = yield* readParquetToArrow(filePath);
  const { limit, offset = 0 } = options;
  const endIndex = limit !== undefined ? offset + limit : table.numRows;
  const rows = [];
  for (let i = offset;i < Math.min(endIndex, table.numRows); i++) {
    const row = table.get(i);
    if (row) {
      rows.push(row.toJSON());
    }
  }
  return rows;
});
var getParquetRowCount = (filePath) => exports_Effect.gen(function* () {
  const table = yield* readParquetToArrow(filePath);
  return table.numRows;
});
async function* streamParquetRows(filePath) {
  const file = Bun.file(filePath);
  const buffer3 = new Uint8Array(await file.arrayBuffer());
  const parquetTable = readParquet(buffer3);
  const table = tableFromIPC(parquetTable.intoIPCStream());
  for (let i = 0;i < table.numRows; i++) {
    const row = table.get(i);
    if (row) {
      yield row.toJSON();
    }
  }
}

// src/atif/schema.ts
var ATIF_SCHEMA_VERSION = "ATIF-v1.4";
var StepSource = Literal2("user", "agent", "system");
var Agent = Struct({
  name: String$,
  version: String$,
  model_name: String$,
  extra: optional(Record({ key: String$, value: Unknown }))
});
var ToolCall = Struct({
  tool_call_id: String$,
  function_name: String$,
  arguments: Unknown
});
var SubagentTrajectoryRef = Struct({
  session_id: String$,
  trajectory_path: optional(String$),
  extra: optional(Record({ key: String$, value: Unknown }))
});
var ObservationResult = Struct({
  source_call_id: optional(String$),
  content: optional(Unknown),
  subagent_trajectory_ref: optional(Array$(SubagentTrajectoryRef))
});
var Observation = Struct({
  results: Array$(ObservationResult)
});
var Metrics = Struct({
  prompt_tokens: optional(Number$),
  completion_tokens: optional(Number$),
  cached_tokens: optional(Number$),
  cost_usd: optional(Number$),
  logprobs: optional(Array$(Number$)),
  completion_token_ids: optional(Array$(Number$)),
  prompt_token_ids: optional(Array$(Number$)),
  extra: optional(Record({ key: String$, value: Unknown }))
});
var FinalMetrics = Struct({
  total_prompt_tokens: Number$,
  total_completion_tokens: Number$,
  total_cached_tokens: optional(Number$),
  total_cost_usd: optional(Number$),
  total_steps: Number$,
  extra: optional(Record({ key: String$, value: Unknown }))
});
var StepStatus = Literal2("pending", "executing", "completed", "failed", "replayed");
var Step = Struct({
  step_id: Number$.pipe(int(), positive()),
  timestamp: String$,
  source: StepSource,
  message: Unknown,
  reasoning_content: optional(String$),
  model_name: optional(String$),
  tool_calls: optional(Array$(ToolCall)),
  observation: optional(Observation),
  metrics: optional(Metrics),
  status: optional(StepStatus),
  completed_at: optional(String$),
  error: optional(String$),
  extra: optional(Record({ key: String$, value: Unknown }))
});
var Checkpoint = Struct({
  checkpoint_id: String$,
  phase: String$,
  timestamp: String$,
  resumable: Boolean$,
  step_id: optional(Number$.pipe(int(), positive())),
  extra: optional(Record({ key: String$, value: Unknown }))
});
var RecoveryInfo = Struct({
  recovered_from_session: optional(String$),
  recovered_at_step: optional(Number$.pipe(int(), positive())),
  recovery_timestamp: optional(String$),
  notes: optional(String$),
  extra: optional(Record({ key: String$, value: Unknown }))
});
var Trajectory = Struct({
  schema_version: Literal2(ATIF_SCHEMA_VERSION),
  session_id: String$,
  agent: Agent,
  steps: Array$(Step),
  notes: optional(String$),
  final_metrics: optional(FinalMetrics),
  checkpoints: optional(Array$(Checkpoint)),
  recovery_info: optional(RecoveryInfo),
  extra: optional(Record({ key: String$, value: Unknown }))
});
var decodeTrajectory = decodeUnknownSync(Trajectory);
var encodeTrajectory = encodeSync(Trajectory);
var decodeStep = decodeUnknownSync(Step);
var encodeStep = encodeSync(Step);
var decodeAgent = decodeUnknownSync(Agent);
var encodeAgent = encodeSync(Agent);
var hasToolCalls = (step4) => (step4.tool_calls?.length ?? 0) > 0;
var hasObservation = (step4) => step4.observation !== undefined && step4.observation.results.length > 0;
var extractStepText = (step4) => {
  if (typeof step4.message === "string")
    return step4.message;
  if (typeof step4.message === "object" && step4.message !== null) {
    const msg = step4.message;
    if (typeof msg.content === "string")
      return msg.content;
    if (typeof msg.text === "string")
      return msg.text;
  }
  return "";
};

// src/huggingface/openthoughts.ts
class OpenThoughtsService extends exports_Context.Tag("OpenThoughtsService")() {
}
function sftRowToTrajectory(row, index) {
  const sessionId = row.run_id ? `openthoughts-${row.run_id}` : `openthoughts-${row.task}__${row.episode}__${index}`;
  const conversations = Array.isArray(row.conversations) ? row.conversations : Array.from(row.conversations);
  const steps = conversations.map((msg, idx) => ({
    step_id: idx + 1,
    timestamp: row.date || new Date().toISOString(),
    source: msg.role === "assistant" ? "agent" : "user",
    message: msg.content
  }));
  return {
    schema_version: ATIF_SCHEMA_VERSION,
    session_id: sessionId,
    agent: {
      name: row.agent || "unknown",
      version: "1.0",
      model_name: row.model || "unknown"
    },
    steps,
    extra: {
      source_dataset: "open-thoughts/OpenThoughts-Agent-v1-SFT",
      task: row.task,
      episode: row.episode,
      run_id: row.run_id,
      trial_name: row.trial_name,
      model_provider: row.model_provider,
      original_date: row.date
    }
  };
}
var makeOpenThoughtsService = () => exports_Effect.gen(function* () {
  const hfService = yield* HFDatasetService;
  const fs = yield* FileSystem;
  const pathService = yield* Path2;
  const repo = OPENTHOUGHTS_SFT_CONFIG.repo;
  const getParquetFilePath = () => exports_Effect.gen(function* () {
    const info = yield* hfService.getDownloadInfo(repo);
    if (!info)
      return null;
    const parquetFile = info.files.find((f) => f.endsWith(".parquet"));
    if (!parquetFile)
      return null;
    return pathService.join(info.localPath, parquetFile);
  });
  const service3 = {
    ensureDownloaded: () => exports_Effect.gen(function* () {
      const isDownloaded = yield* hfService.isDownloaded(repo);
      if (!isDownloaded) {
        console.log(`Downloading OpenThoughts SFT dataset...`);
        yield* hfService.download(OPENTHOUGHTS_SFT_CONFIG);
      }
      const path = yield* getParquetFilePath();
      if (!path) {
        return yield* exports_Effect.fail(new HFDatasetError("not_found", "Dataset downloaded but parquet file not found"));
      }
      return path;
    }),
    count: () => exports_Effect.gen(function* () {
      const parquetPath = yield* service3.ensureDownloaded();
      return yield* getParquetRowCount(parquetPath);
    }),
    getTrajectory: (index) => exports_Effect.gen(function* () {
      const parquetPath = yield* service3.ensureDownloaded();
      const rows = yield* readParquetFile(parquetPath, {
        offset: index,
        limit: 1
      });
      if (rows.length === 0)
        return null;
      return sftRowToTrajectory(rows[0], index);
    }),
    getTrajectoryByRunId: (runId) => exports_Effect.gen(function* () {
      const parquetPath = yield* service3.ensureDownloaded();
      const result = yield* exports_Effect.tryPromise({
        try: async () => {
          let index = 0;
          for await (const row of streamParquetRows(parquetPath)) {
            if (row.run_id === runId) {
              return sftRowToTrajectory(row, index);
            }
            index++;
          }
          return null;
        },
        catch: (e) => new HFDatasetError("parse_error", `Failed to search by run_id: ${e}`)
      });
      return result;
    }),
    getTrajectories: (offset = 0, limit = 100) => exports_Effect.gen(function* () {
      const parquetPath = yield* service3.ensureDownloaded();
      const rows = yield* readParquetFile(parquetPath, {
        offset,
        limit
      });
      return rows.map((row, idx) => sftRowToTrajectory(row, offset + idx));
    }),
    streamTrajectories: () => exports_Effect.gen(function* () {
      const parquetPath = yield* service3.ensureDownloaded();
      async function* generator() {
        let index = 0;
        for await (const row of streamParquetRows(parquetPath)) {
          yield sftRowToTrajectory(row, index);
          index++;
        }
      }
      return generator();
    }),
    getParquetPath: () => getParquetFilePath()
  };
  return service3;
});
var OpenThoughtsServiceLive = exports_Layer.effect(OpenThoughtsService, makeOpenThoughtsService());

// src/effuse/widgets/hf-trajectory-list.ts
var extractMetadata = (trajectory, index) => {
  const agent = trajectory.agent;
  const extra = trajectory.extra;
  return {
    sessionId: trajectory.session_id,
    agentName: agent?.name ?? "unknown",
    modelName: agent?.model_name ?? "unknown",
    task: extra?.task ?? "unknown",
    episode: extra?.episode ?? "unknown",
    date: extra?.date ?? trajectory.steps[0]?.timestamp ?? new Date().toISOString(),
    stepCount: trajectory.steps.length,
    index
  };
};
var filterTrajectories = (trajectories, query) => {
  if (!query.trim())
    return trajectories;
  const lowercaseQuery = query.toLowerCase();
  return trajectories.filter((t) => t.agentName.toLowerCase().includes(lowercaseQuery) || t.task.toLowerCase().includes(lowercaseQuery) || t.episode.toLowerCase().includes(lowercaseQuery) || t.sessionId.toLowerCase().includes(lowercaseQuery));
};
var formatDate2 = (iso) => {
  try {
    return new Date(iso).toLocaleDateString(undefined, {
      month: "short",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  } catch {
    return iso.slice(0, 10);
  }
};
var HFTrajectoryListWidget = {
  id: "hf-trajectory-list",
  initialState: () => {
    if (window.bunLog) {
      window.bunLog("[HFTrajectoryList] Creating initial state");
    }
    return {
      trajectories: [],
      filteredTrajectories: [],
      selectedSessionId: null,
      searchQuery: "",
      currentPage: 0,
      pageSize: 100,
      totalCount: 0,
      loading: true,
      error: null,
      collapsed: false
    };
  },
  render: (ctx) => exports_Effect.gen(function* () {
    const state = yield* ctx.state.get;
    if (window.bunLog) {
      window.bunLog(`[HFTrajectoryList] Rendering, loading=${state.loading}, totalCount=${state.totalCount}, trajectories=${state.trajectories.length}, error=${state.error}`);
    }
    const header = html`
        <div
          class="flex items-center justify-between px-4 py-3 border-b border-zinc-800/60 cursor-pointer bg-zinc-900/40"
          data-action="toggleCollapse"
        >
          <div class="flex items-center gap-2">
            <h3 class="text-sm font-bold font-mono text-zinc-100">HuggingFace Trajectories</h3>
            ${state.totalCount > 0 ? html`<span class="text-xs text-zinc-400">(${state.totalCount})</span>` : ""}
          </div>
          <span class="text-zinc-500">${state.collapsed ? "" : ""}</span>
        </div>
      `;
    if (state.collapsed) {
      return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header}
          </div>
        `;
    }
    const searchInput = html`
        <div class="px-4 pt-3 pb-2">
          <input
            type="text"
            placeholder="Search by agent, task, episode..."
            class="w-full px-3 py-2 bg-zinc-900 border border-zinc-800 rounded text-zinc-100 text-sm placeholder:text-zinc-500 focus:border-zinc-700 focus:outline-none"
            data-action="search"
            value="${state.searchQuery}"
          />
        </div>
      `;
    const startIndex = state.currentPage * state.pageSize + 1;
    const endIndex = Math.min((state.currentPage + 1) * state.pageSize, state.totalCount);
    const pageInfo = html`
        <div class="px-4 py-2 border-b border-zinc-800/40 text-xs text-zinc-400">
          Showing ${startIndex}-${endIndex} of ${state.totalCount}
        </div>
      `;
    if (state.loading) {
      return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header} ${searchInput} ${pageInfo}
            <div class="px-4 py-8 text-center text-sm text-zinc-500">Loading trajectories...</div>
          </div>
        `;
    }
    if (state.error) {
      return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header} ${searchInput} ${pageInfo}
            <div class="px-4 py-8">
              <div class="text-sm text-red-400 mb-2">Error loading trajectories</div>
              <div class="text-xs text-zinc-500">${state.error}</div>
              <button
                class="mt-3 px-3 py-1.5 rounded bg-zinc-800 hover:bg-zinc-700 text-zinc-200 text-xs transition-colors"
                data-action="refresh"
              >
                Retry
              </button>
            </div>
          </div>
        `;
    }
    if (state.filteredTrajectories.length === 0) {
      const message = state.searchQuery ? `No trajectories match "${state.searchQuery}"` : "No trajectories found";
      return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header} ${searchInput} ${pageInfo}
            <div class="px-4 py-8 text-center text-sm text-zinc-500">${message}</div>
          </div>
        `;
    }
    const trajectoryItems = joinTemplates(state.filteredTrajectories.map((traj) => {
      const isSelected = traj.sessionId === state.selectedSessionId;
      const baseClasses = "bg-zinc-900/40 border border-zinc-800/40 rounded-lg p-3 mb-2 cursor-pointer transition-colors";
      const selectedClasses = isSelected ? "bg-zinc-800/60 border-zinc-700/50" : "hover:bg-zinc-900/60";
      return html`
            <div
              class="${baseClasses} ${selectedClasses}"
              data-action="select"
              data-session-id="${traj.sessionId}"
              data-index="${traj.index}"
            >
              <div class="flex items-center justify-between mb-1">
                <span class="text-sm font-mono text-zinc-200">${traj.agentName}</span>
                <span class="text-xs text-zinc-500">${formatDate2(traj.date)}</span>
              </div>
              <div class="text-xs text-zinc-400 mb-0.5">task: ${traj.task}</div>
              <div class="flex items-center gap-2 text-xs text-zinc-500">
                <span>${traj.episode}</span>
                <span></span>
                <span>${traj.stepCount} steps</span>
              </div>
            </div>
          `;
    }));
    const hasPrev = state.currentPage > 0;
    const hasNext = (state.currentPage + 1) * state.pageSize < state.totalCount;
    const pagination = html`
        <div class="px-4 py-3 border-t border-zinc-800/40 flex items-center justify-between">
          <button
            class="px-3 py-1.5 rounded bg-zinc-800 text-zinc-200 text-xs transition-colors ${hasPrev ? "hover:bg-zinc-700" : "opacity-50 cursor-not-allowed"}"
            data-action="prevPage"
            ${hasPrev ? "" : "disabled"}
          >
             Prev
          </button>
          <span class="text-xs text-zinc-500">Page ${state.currentPage + 1}</span>
          <button
            class="px-3 py-1.5 rounded bg-zinc-800 text-zinc-200 text-xs transition-colors ${hasNext ? "hover:bg-zinc-700" : "opacity-50 cursor-not-allowed"}"
            data-action="nextPage"
            ${hasNext ? "" : "disabled"}
          >
            Next 
          </button>
        </div>
      `;
    return html`
        <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm overflow-hidden">
          ${header} ${searchInput} ${pageInfo}
          <div class="max-h-[calc(100vh-16rem)] overflow-y-auto px-4 py-2">${trajectoryItems}</div>
          ${pagination}
        </div>
      `;
  }),
  setupEvents: (ctx) => exports_Effect.gen(function* () {
    yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (e, target) => {
      const el = target;
      const action = el.dataset.action;
      if (action === "toggleCollapse") {
        exports_Effect.runFork(ctx.emit({ type: "toggleCollapse" }));
      } else if (action === "select") {
        const sessionId = el.dataset.sessionId;
        const index = el.dataset.index;
        if (sessionId && index) {
          exports_Effect.runFork(ctx.emit({ type: "select", sessionId, index: parseInt(index, 10) }));
        }
      } else if (action === "prevPage") {
        exports_Effect.runFork(ctx.emit({ type: "loadPage", page: -1 }));
      } else if (action === "nextPage") {
        exports_Effect.runFork(ctx.emit({ type: "loadPage", page: -2 }));
      } else if (action === "refresh") {
        exports_Effect.runFork(ctx.emit({ type: "refresh" }));
      }
    });
    yield* ctx.dom.delegate(ctx.container, "[data-action='search']", "input", (e) => {
      const input = e.target;
      exports_Effect.runFork(ctx.emit({ type: "search", query: input.value }));
    });
  }),
  handleEvent: (event, ctx) => exports_Effect.gen(function* () {
    const service3 = yield* OpenThoughtsService;
    switch (event.type) {
      case "loadPage": {
        const state = yield* ctx.state.get;
        let newPage = event.page;
        if (newPage === -1) {
          newPage = Math.max(0, state.currentPage - 1);
        } else if (newPage === -2) {
          newPage = state.currentPage + 1;
        }
        const maxPage = Math.ceil(state.totalCount / state.pageSize) - 1;
        if (newPage < 0 || newPage > maxPage)
          break;
        yield* ctx.state.update((s) => ({ ...s, loading: true, error: null }));
        try {
          const offset = newPage * state.pageSize;
          const trajectories = yield* service3.getTrajectories(offset, state.pageSize);
          const metadata = trajectories.map((t, i) => extractMetadata(t, offset + i));
          yield* ctx.state.update((s) => ({
            ...s,
            trajectories: metadata,
            filteredTrajectories: filterTrajectories(metadata, s.searchQuery),
            currentPage: newPage,
            loading: false
          }));
        } catch (error) {
          yield* ctx.state.update((s) => ({
            ...s,
            loading: false,
            error: error instanceof Error ? error.message : String(error)
          }));
        }
        break;
      }
      case "search": {
        yield* ctx.state.update((s) => ({
          ...s,
          searchQuery: event.query,
          filteredTrajectories: filterTrajectories(s.trajectories, event.query)
        }));
        break;
      }
      case "select": {
        yield* ctx.state.update((s) => ({
          ...s,
          selectedSessionId: event.sessionId
        }));
        break;
      }
      case "toggleCollapse": {
        yield* ctx.state.update((s) => ({ ...s, collapsed: !s.collapsed }));
        break;
      }
      case "refresh": {
        yield* ctx.emit({ type: "loadPage", page: 0 });
        break;
      }
    }
  }),
  subscriptions: (ctx) => {
    const initialLoad = exports_Effect.gen(function* () {
      if (window.bunLog) {
        window.bunLog("[HFTrajectoryList] Starting initial load...");
      }
      const service3 = yield* OpenThoughtsService;
      try {
        if (window.bunLog) {
          window.bunLog("[HFTrajectoryList] Getting trajectory count...");
        }
        const totalCount = yield* service3.count();
        if (window.bunLog) {
          window.bunLog(`[HFTrajectoryList] Total count: ${totalCount}`);
        }
        if (window.bunLog) {
          window.bunLog("[HFTrajectoryList] Loading first page...");
        }
        const trajectories = yield* service3.getTrajectories(0, 100);
        if (window.bunLog) {
          window.bunLog(`[HFTrajectoryList] Loaded trajectories: ${trajectories.length}`);
        }
        const metadata = trajectories.map((t, i) => extractMetadata(t, i));
        yield* ctx.state.update((s) => ({
          ...s,
          trajectories: metadata,
          filteredTrajectories: metadata,
          totalCount,
          loading: false
        }));
        if (window.bunLog) {
          window.bunLog("[HFTrajectoryList] Initial load complete");
        }
      } catch (error) {
        if (window.bunLog) {
          window.bunLog(`[HFTrajectoryList] Initial load failed: ${error}`);
        }
        yield* ctx.state.update((s) => ({
          ...s,
          loading: false,
          error: error instanceof Error ? error.message : String(error)
        }));
      }
    });
    return [exports_Effect.asVoid(initialLoad)];
  }
};
var initialHFTrajectoryListState = HFTrajectoryListWidget.initialState();
// src/effuse/widgets/hf-trajectory-detail.ts
var formatTimestamp2 = (iso) => {
  try {
    return new Date(iso).toLocaleTimeString(undefined, {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  } catch {
    return iso.slice(0, 19).replace("T", " ");
  }
};
var formatDate3 = (iso) => {
  try {
    return new Date(iso).toLocaleDateString(undefined, {
      month: "short",
      day: "numeric",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  } catch {
    return iso.slice(0, 16).replace("T", " ");
  }
};
var getSourceClass = (source) => {
  switch (source) {
    case "user":
      return "bg-blue-900/40 text-blue-300 border-blue-700/50";
    case "agent":
      return "bg-emerald-900/40 text-emerald-300 border-emerald-700/50";
    case "system":
      return "bg-zinc-800/40 text-zinc-300 border-zinc-700/50";
    default:
      return "bg-zinc-800/40 text-zinc-300 border-zinc-700/50";
  }
};
var formatJSON = (obj) => {
  try {
    if (typeof obj === "string")
      return obj;
    return JSON.stringify(obj, null, 2);
  } catch {
    return String(obj);
  }
};
var getMessageText = (step4) => {
  const text = extractStepText(step4);
  if (text.length > 500) {
    return text.slice(0, 500) + "... (truncated)";
  }
  return text;
};
var HFTrajectoryDetailWidget = {
  id: "hf-trajectory-detail",
  initialState: () => {
    if (window.bunLog) {
      window.bunLog("[HFTrajectoryDetail] Creating initial state");
    }
    return {
      trajectory: null,
      sessionId: null,
      loading: false,
      error: null,
      collapsed: false,
      expandedStepId: null,
      viewMode: "formatted"
    };
  },
  render: (ctx) => exports_Effect.gen(function* () {
    const state = yield* ctx.state.get;
    const header = html`
        <div
          class="flex items-center justify-between px-4 py-3 border-b border-zinc-800/60 cursor-pointer bg-zinc-900/40"
          data-action="toggleCollapse"
        >
          <h3 class="text-sm font-bold font-mono text-zinc-100">HF Trajectory Details</h3>
          <span class="text-zinc-500">${state.collapsed ? "" : ""}</span>
        </div>
      `;
    if (state.collapsed) {
      return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header}
          </div>
        `;
    }
    if (state.loading) {
      return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header}
            <div class="px-4 py-8 text-center text-sm text-zinc-500">Loading trajectory...</div>
          </div>
        `;
    }
    if (state.error) {
      return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header}
            <div class="px-4 py-8">
              <div class="text-sm text-red-400 mb-2">Error loading trajectory</div>
              <div class="text-xs text-zinc-500">${state.error}</div>
            </div>
          </div>
        `;
    }
    if (!state.trajectory) {
      return html`
          <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm">
            ${header}
            <div class="px-4 py-8 text-center text-sm text-zinc-500">
              No trajectory selected. Click a trajectory in the sidebar to view details.
            </div>
          </div>
        `;
    }
    const traj = state.trajectory;
    const agent = traj.agent;
    const extra = traj.extra;
    const task = extra?.task ?? "unknown";
    const episode = extra?.episode ?? "unknown";
    const date = extra?.date ?? traj.steps[0]?.timestamp ?? "unknown";
    const metadata = html`
        <div class="px-4 py-3 bg-zinc-900/20 border-b border-zinc-800/40 space-y-1.5">
          <div class="flex items-center gap-2 text-xs">
            <span class="text-zinc-500">Session:</span>
            <span class="text-zinc-300 font-mono">${traj.session_id}</span>
          </div>
          <div class="flex items-center gap-2 text-xs">
            <span class="text-zinc-500">Agent:</span>
            <span class="text-zinc-300">${agent?.name ?? "unknown"}</span>
            ${agent?.model_name ? html`<span class="text-zinc-500">(${agent.model_name})</span>` : ""}
          </div>
          <div class="flex items-center gap-2 text-xs">
            <span class="text-zinc-500">Task:</span>
            <span class="text-zinc-300">${task}</span>
            <span class="text-zinc-500"></span>
            <span class="text-zinc-500">Episode:</span>
            <span class="text-zinc-300">${episode}</span>
          </div>
          <div class="flex items-center gap-2 text-xs">
            <span class="text-zinc-500">Steps:</span>
            <span class="text-zinc-300">${traj.steps.length}</span>
            <span class="text-zinc-500"></span>
            <span class="text-zinc-500">Date:</span>
            <span class="text-zinc-300">${formatDate3(date)}</span>
          </div>
        </div>
      `;
    const stepsList = html`
        <div class="max-h-[calc(100vh-20rem)] overflow-y-auto">
          ${joinTemplates(traj.steps.map((step4) => {
      const isExpanded = state.expandedStepId === step4.step_id;
      const source = step4.source ?? "system";
      const sourceClass = getSourceClass(source);
      const toolCallCount = hasToolCalls(step4) ? step4.tool_calls.length : 0;
      const hasObs = hasObservation(step4);
      const stepHeader = html`
                <div
                  class="flex items-center justify-between px-4 py-2 hover:bg-zinc-900/40 cursor-pointer transition-colors border-b border-zinc-800/40"
                  data-action="toggleStep"
                  data-step-id="${step4.step_id}"
                >
                  <div class="flex items-center gap-3 flex-1">
                    <span class="text-xs font-mono text-zinc-500">#${step4.step_id}</span>
                    <span class="text-xs px-1.5 py-0.5 rounded border ${sourceClass} uppercase font-mono">
                      ${source}
                    </span>
                    <span class="text-xs text-zinc-400 font-mono">${formatTimestamp2(step4.timestamp)}</span>
                    ${toolCallCount > 0 ? html`<span class="text-xs text-violet-400"> ${toolCallCount} tool${toolCallCount > 1 ? "s" : ""}</span>` : ""}
                    ${hasObs ? html`<span class="text-xs text-emerald-400"> obs</span>` : ""}
                  </div>
                  <span class="text-zinc-500">${isExpanded ? "" : ""}</span>
                </div>
              `;
      if (!isExpanded) {
        return stepHeader;
      }
      const expandedContent = html`
                <div class="px-4 py-3 bg-zinc-900/20 space-y-3">
                  ${step4.message ? html`
                        <div>
                          <div class="text-xs font-mono text-zinc-400 mb-1">Message:</div>
                          <pre
                            class="text-xs font-mono text-zinc-200 bg-zinc-950/60 p-2 rounded border border-zinc-800/40 overflow-x-auto whitespace-pre-wrap"
                          >${getMessageText(step4)}</pre>
                        </div>
                      ` : ""}
                  ${step4.reasoning_content ? html`
                        <div>
                          <div class="text-xs font-mono text-zinc-400 mb-1">Reasoning:</div>
                          <pre
                            class="text-xs font-mono text-zinc-300 bg-zinc-950/60 p-2 rounded border border-zinc-800/40 overflow-x-auto whitespace-pre-wrap"
                          >${step4.reasoning_content}</pre>
                        </div>
                      ` : ""}
                  ${hasToolCalls(step4) ? html`
                        <div>
                          <div class="text-xs font-mono text-zinc-400 mb-1">Tool Calls:</div>
                          ${joinTemplates(step4.tool_calls.map((tc) => html`
                                <div class="bg-zinc-950/60 p-2 rounded border border-zinc-800/40 mb-2">
                                  <div class="text-xs font-mono text-violet-300 mb-1">${tc.function_name}</div>
                                  <pre
                                    class="text-xs font-mono text-zinc-400 overflow-x-auto whitespace-pre-wrap"
                                  >${formatJSON(tc.arguments)}</pre>
                                </div>
                              `))}
                        </div>
                      ` : ""}
                  ${hasObservation(step4) ? html`
                        <div>
                          <div class="text-xs font-mono text-zinc-400 mb-1">Observation:</div>
                          ${joinTemplates(step4.observation.results.map((result) => {
        const content = result.content;
        const contentStr = typeof content === "string" ? content.length > 500 ? content.slice(0, 500) + "... (truncated)" : content : formatJSON(content);
        return html`
                                <pre
                                  class="text-xs font-mono text-emerald-300 bg-zinc-950/60 p-2 rounded border border-zinc-800/40 overflow-x-auto mb-2 whitespace-pre-wrap"
                                >${contentStr}</pre>
                              `;
      }))}
                        </div>
                      ` : ""}
                  ${step4.metrics ? html`
                        <div>
                          <div class="text-xs font-mono text-zinc-400 mb-1">Metrics:</div>
                          <div class="text-xs text-zinc-300 space-x-3">
                            ${step4.metrics.prompt_tokens ? html`<span>${step4.metrics.prompt_tokens} prompt tokens</span>` : ""}
                            ${step4.metrics.completion_tokens ? html`<span> ${step4.metrics.completion_tokens} completion tokens</span>` : ""}
                            ${step4.metrics.cost_usd ? html`<span> $${step4.metrics.cost_usd.toFixed(4)}</span>` : ""}
                          </div>
                        </div>
                      ` : ""}
                  ${step4.error ? html`
                        <div>
                          <div class="text-xs font-mono text-red-400 mb-1">Error:</div>
                          <pre
                            class="text-xs font-mono text-red-300 bg-red-950/20 p-2 rounded border border-red-800/40 overflow-x-auto whitespace-pre-wrap"
                          >${step4.error}</pre>
                        </div>
                      ` : ""}
                </div>
              `;
      return html`
                <div class="border-b border-zinc-800/40">
                  ${stepHeader}
                  ${expandedContent}
                </div>
              `;
    }))}
        </div>
      `;
    return html`
        <div class="rounded-xl border border-zinc-800/60 bg-zinc-950/80 shadow-xl backdrop-blur-sm overflow-hidden">
          ${header} ${metadata} ${stepsList}
        </div>
      `;
  }),
  setupEvents: (ctx) => exports_Effect.gen(function* () {
    yield* ctx.dom.delegate(ctx.container, "[data-action]", "click", (e, target) => {
      const el = target;
      const action = el.dataset.action;
      const stepId = el.dataset.stepId;
      if (action === "toggleCollapse") {
        exports_Effect.runFork(ctx.emit({ type: "toggleCollapse" }));
      } else if (action === "toggleStep" && stepId) {
        exports_Effect.runFork(ctx.emit({ type: "toggleStep", stepId: parseInt(stepId, 10) }));
      }
    });
  }),
  handleEvent: (event, ctx) => exports_Effect.gen(function* () {
    switch (event.type) {
      case "load": {
        yield* ctx.state.update((s) => ({
          ...s,
          trajectory: event.trajectory,
          sessionId: event.sessionId,
          loading: false,
          error: null,
          expandedStepId: null
        }));
        break;
      }
      case "toggleCollapse":
        yield* ctx.state.update((s) => ({ ...s, collapsed: !s.collapsed }));
        break;
      case "toggleStep": {
        yield* ctx.state.update((s) => ({
          ...s,
          expandedStepId: s.expandedStepId === event.stepId ? null : event.stepId
        }));
        break;
      }
      case "clear":
        yield* ctx.state.update(() => HFTrajectoryDetailWidget.initialState());
        break;
      case "toggleViewMode": {
        yield* ctx.state.update((s) => ({
          ...s,
          viewMode: s.viewMode === "formatted" ? "json" : "formatted"
        }));
        break;
      }
    }
  }),
  subscriptions: () => []
};
var initialHFTrajectoryDetailState = HFTrajectoryDetailWidget.initialState();
// src/mainview/effuse-main.ts
console.log("[Effuse] Loading mainview...");
var showError = (msg) => {
  document.body.innerHTML = `<div style="padding:20px;color:red;font-family:monospace;background:#1a1a1a;">
    <h2>Effuse Error</h2>
    <pre>${msg}</pre>
  </div>`;
};
window.onerror = (msg, src, line, col, error) => {
  console.error("[Effuse] Global error:", msg, src, line, col, error);
  showError(`${msg}

Source: ${src}:${line}:${col}

${error?.stack || ""}`);
  return false;
};
window.onunhandledrejection = (event) => {
  if (event.reason && event.reason.constructor?.name === "Error" && Object.keys(event.reason).length === 0) {
    event.preventDefault();
    return;
  }
  console.error("[Effuse] Unhandled rejection:", event.reason);
  showError(`Unhandled Promise rejection:

${event.reason?.stack || event.reason}`);
};
var createEffuseLayer = () => {
  const socketClient = getSocketClient();
  return exports_Layer.mergeAll(DomServiceLive, StateServiceLive, SocketServiceFromClient(socketClient), OpenThoughtsServiceLive);
};
var mountAllWidgets = exports_Effect.gen(function* () {
  console.log("[Effuse] Mounting HF Trajectory Browser widgets...");
  const socket = yield* SocketServiceTag;
  yield* socket.connect().pipe(exports_Effect.tap(() => console.log("[Effuse] Socket connected")), exports_Effect.catchAll((e) => {
    console.warn("[Effuse] Socket connection failed:", e);
    return exports_Effect.void;
  }));
  const openThoughtsService = yield* OpenThoughtsService;
  const listWidget = yield* mountWidgetById(HFTrajectoryListWidget, "hf-trajectory-list-widget").pipe(exports_Effect.tap(() => console.log("[Effuse] HF Trajectory List widget mounted")), exports_Effect.catchAll((e) => {
    console.error("[Effuse] Failed to mount HF Trajectory List widget:", e);
    return exports_Effect.die(e);
  }));
  const detailWidget = yield* mountWidgetById(HFTrajectoryDetailWidget, "hf-trajectory-detail-widget").pipe(exports_Effect.tap(() => console.log("[Effuse] HF Trajectory Detail widget mounted")), exports_Effect.catchAll((e) => {
    console.error("[Effuse] Failed to mount HF Trajectory Detail widget:", e);
    return exports_Effect.die(e);
  }));
  yield* exports_Stream.runForEach(listWidget.events, (event) => exports_Effect.gen(function* () {
    if (event.type === "select") {
      console.log("[Effuse] Loading trajectory:", event.sessionId, "at index:", event.index);
      yield* detailWidget.emit({ type: "clear" });
      try {
        const trajectory = yield* openThoughtsService.getTrajectory(event.index);
        yield* detailWidget.emit({
          type: "load",
          sessionId: event.sessionId,
          trajectory
        });
        console.log("[Effuse] Trajectory loaded successfully");
      } catch (error) {
        console.error("[Effuse] Failed to load trajectory:", error);
      }
    }
  })).pipe(exports_Effect.forkScoped);
  console.log("[Effuse] HF Trajectory Browser ready");
});
var initEffuse = () => {
  console.log("[Effuse] Creating layer...");
  let layer2;
  try {
    layer2 = createEffuseLayer();
    console.log("[Effuse] Layer created");
  } catch (e) {
    console.error("[Effuse] Failed to create layer:", e);
    return;
  }
  const program = exports_Effect.gen(function* () {
    yield* mountAllWidgets;
    console.log("[Effuse] Widgets mounted, keeping scope alive...");
    yield* exports_Effect.never;
  });
  console.log("[Effuse] Starting Effect runtime...");
  exports_Effect.runFork(program.pipe(exports_Effect.provide(layer2), exports_Effect.scoped, exports_Effect.catchAllDefect((defect) => {
    console.error("[Effuse] Defect:", defect);
    return exports_Effect.void;
  })));
  console.log("[Effuse] Mainview initialized");
};
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", () => {
    try {
      initEffuse();
    } catch (e) {
      console.error("[Effuse] Init error:", e);
    }
  });
} else {
  try {
    initEffuse();
  } catch (e) {
    console.error("[Effuse] Init error:", e);
  }
}
export {
  initEffuse
};
